<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>服务应用突然宕机了？别怕，Dubbo 帮你自动搞定服务隔离！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13575494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13575494.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1419561/202008/1419561-20200828083829099-90058590.jpg&quot; alt=&quot;听说猫猫可以增加点击量&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;某日中午，午睡正香的时候，接到系统的报警电话，提示生产某物理机异常宕机了，目前该物理机已恢复，需要重启上面部署的应用。&lt;/p&gt;
&lt;p&gt;这时瞬间没有了睡意，登上堡垒机，快速重启了应用，系统恢复正常。本想着继续午睡，但是已经没有了睡意。&lt;/p&gt;
&lt;p&gt;旁边的小师弟（&lt;em&gt;我们叫他小灰吧&lt;/em&gt;）刚才在我们边上，目睹这一切，然后向我请教个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;黑哥，刚才应用突然宕机，会不会对交易有影响啊？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;影响确实会有，不过也不大，就当时应用正在运行那些那些交易会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不对啊，我们现在系统架构是下面这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082735654-1037959224.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这次宕机的是业务逻辑层，那按照目前使用 Dubbo 轮询的负载均衡方式，不是还会有交易分发到宕机那台应用上，这些交易请求显然会异常。&lt;/p&gt;
&lt;p&gt;运气差点，不是会有一半交易请求都会有问题吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没错，我们的系统架构图确实如说的一样。&lt;/p&gt;
&lt;p&gt;不过你说的这个问题，它是不存在的。&lt;/p&gt;
&lt;p&gt;这是因为 Dubbo 内部会自动帮我们的摘除宕机的应用节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;啥？Dubbo 内部还有这功能啊？黑哥你给我讲讲原理呗！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以啊，不过讲这个原理之前，我们首先需要了解 Dubbo 服务注册发现流程。&lt;/p&gt;
&lt;p&gt;我看你最近一直在看『深入理解 Apache Dubbo 与实战』，这本书确实不错，里面框架原理，代码细节都讲的很透彻。&lt;/p&gt;
&lt;p&gt;你应该已经了解了 Dubbo 服务注册发现流程，那你先跟我简单讲讲原理吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰拿起纸笔，在上面画了个图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082735872-1244661697.jpg&quot; alt=&quot;Dubbo 服务注册发现流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恩，我当前了解的还不是很深，那我先聊聊目前我知道的。&lt;/p&gt;
&lt;p&gt;我们目前使用 &lt;strong&gt;ZooKeeper&lt;/strong&gt; 当做服务注册中心，&lt;strong&gt;ZooKeeper&lt;/strong&gt; 可以简单理解成是一个 &lt;strong&gt;KV&lt;/strong&gt;系统，内部是一个树形的数据结构。&lt;/p&gt;
&lt;p&gt;Dubbo 默认将会在 &lt;strong&gt;ZooKeeper&lt;/strong&gt; 中创建一个四层的数据结构，从上到下分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Root&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Category&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 &lt;strong&gt;Root&lt;/strong&gt; 层是注册中心分组，默认命名为 dubbo。我们可以通过修改 &lt;code&gt;&amp;lt;dubbo:registry&amp;gt;&lt;/code&gt; 中的 group 属性修改默认值，这样修改之后不同分组的 dubbo 服务不会互相影响，也不会互相调用，可以用于环境隔离。&lt;/p&gt;
&lt;p&gt;接下来 &lt;strong&gt;Service&lt;/strong&gt; 就是服务类的全路径，包括包路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service&lt;/strong&gt; 层下面就是 &lt;strong&gt;Category&lt;/strong&gt; 层，这其中总共有四类目录（上面图形只画了两种），分别为:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;providers：包含服务提供者 URL 元数据信息&lt;/li&gt;
&lt;li&gt;consumers：包含消费者 URL 元数据信息&lt;/li&gt;
&lt;li&gt;routers：包含消费者路由策略的 URL 元数据信息&lt;/li&gt;
&lt;li&gt;configurators：包含动态配置元数据信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一层就是具体 Dubbo 服务 URL，类似如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;dubbo://2.0.1.13:12345/com.dubbo.example.DemoService?xx=xx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没错，这个内部结构你理还是蛮清晰的么！&lt;/p&gt;
&lt;p&gt;平常使用的情况下，我们重点关注 &lt;strong&gt;providers&lt;/strong&gt; 以及 &lt;strong&gt;consumers&lt;/strong&gt; 就好了。如果我们需要配置服务路由信息以及动态配置，那我们需要在 Dubbo-Admin 服务治理中心下发配置。这时 &lt;code&gt;routers&lt;/code&gt; 与 &lt;code&gt;configurators&lt;/code&gt; 就会增加相关配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿😝，咱接下来讲服务注册流程。&lt;/p&gt;
&lt;p&gt;当服务提供者启动之后，会向注册中心写入自己的元数据信息，其实就是在 providers 节点下创建一个 URL 节点（如果上级节点都不存在，将会逐层创建），存储值类似如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dubbo://10.10.11.22:20880/com.foo/BarService?key=value....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着启动服务消费者，消费者第一次连接上 ZooKeeper 时，将会拉取provider 节点下所有服务提供者的 URL 信息，然后与相应的服务提供者建立连接。&lt;/p&gt;
&lt;p&gt;同时服务消费者也会将自己信息注册到在 consumer 节点下，这个目的是为了服务治理中心（Dubbo-Admin）发现自己。&lt;/p&gt;
&lt;p&gt;同时消费者将会在 provider 节点上注册一个 watcher ，当有新的服务提供者启动成功，provider 节点发生变更，ZooKeeper 将会推送变更信息给 Dubbo 服务，然后 Dubbo 将会重新建立与服务提供者的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你说的整个 Dubbo 服务注册发现流程没有什么问题，这里消费者与服务提供者建立的连接的流程，我们之前踩过一个坑，你有空可以看看 &lt;a href=&quot;https://mp.weixin.qq.com/s/Y4fLEAZ8ZezV_EXzx0YzAg&quot;&gt;天啦噜！生产机器连接数飙升到上万，背后发生了什么？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，再考你一下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务节点变更时，ZooKeeper 推送 provider 下全量子节点数据给消费者吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;呀，难道不是吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不是的。ZooKeeper 的 watch 机制目前只能推送节点变更信息，比如节点内容数据变更，监听节点下子节点列表变更等，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082736192-374969055.jpg&quot; alt=&quot;图片来自网络&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进一步从 Zookeeper 客户端的源码上来看，watcher 回调通知内容最终转为 &lt;code&gt;WatchedEvent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082736466-183596895.jpg&quot; alt=&quot;image-20200823204259983&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类只有三个字段，所以是不会推送子节点列表数据过来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然不是通过推送获取子节点列表的信息，那如何拿到变动子节点列表？&lt;/p&gt;
&lt;p&gt;有了，在收到推送的时候，我们能获取到变动节点信息，然后我再拉取一下子节点的列表不就好了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没错，Dubbo 就是这么做的。&lt;/p&gt;
&lt;p&gt;这一点我们可以具体看下 Dubbo 的源码，位于 &lt;code&gt;CuratorZookeeperClient&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;画外音：下面的源码基于 Dubbo 2.6.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082736773-1542666628.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中标注的地方，Dubbo 通过拉取获取了字节点的全量数据，同时再次注册了一个 &lt;code&gt;watcher&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;不过这么多，有个缺陷的，当微服务节点数量有很多的时候，全量拉取将会占用过多的内网带宽，很容易造成网络风暴。&lt;/p&gt;
&lt;p&gt;上面我们讲到 Zookeeper 的这种方式，是一种典型的 &lt;strong&gt;Push&lt;/strong&gt; 模式，对应的还有一种的模式为 &lt;strong&gt;Pull&lt;/strong&gt; 模式，&lt;strong&gt;eureka&lt;/strong&gt; 就是这种模式的典型的代表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eureka&lt;/strong&gt; 客户端就是通过定期轮询拉取数据，获取最新的变更数据。不过拉取模式也存在很大的劣势，如果轮询频率低，那么服务变更信息无法及时获取，如果轮率太高这就会增加注册中心的压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务发现流程这下我们已经搞明白了。如果有新增服务节点，Dubbo 消费者通过通知，然后再拉取全量的子节点列表，这样 Dubbo消费者就会新增与新的服务提供者连接，后续再通过负载均衡使用新的连接。&lt;/p&gt;
&lt;p&gt;如果 Dubbo 服务提供者正常停止下线，那么他将会删除 ZooKeeper 上的自己注册的节点信息。删除之后 Dubbo 消费者第一时间收到了通知，通过拉取全量的子节点列表，然后通过比对，发现某个节点下线，然后删除之前简历的连接。这样后续，就不会再调用这个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;恩，正常应用上下线，Dubbo 消费者可以感知到，但是像服务提供者宕机的情况，消费者是怎么感知到的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一点，就与 Zookeeper 的自身特性有关了。&lt;/p&gt;
&lt;p&gt;Zookeeper 中我们可以创建四种节点类型的节点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;永久节点&lt;/li&gt;
&lt;li&gt;临时节点&lt;/li&gt;
&lt;li&gt;顺序节点
&lt;ul&gt;&lt;li&gt;永久节点&lt;/li&gt;
&lt;li&gt;临时节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;临时节点与永久节点唯一的区别在于，一旦 Zookeeper 客户端断开连接，Zookeeper 服务感知到之后就会自动删除临时节点。&lt;/p&gt;
&lt;p&gt;Dubbo 服务提供者就是在 Zookeeper 注册了临时节点，如果服务提供者宕机了，临时节点自动被删除，后面的流程就跟 Dubbo 应用正常下线一样了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;すごい！&lt;/strong&gt;原来如此，这个设计 666 啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小黑：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实应用宕机这种， Dubbo RPC 框架内部都可以自动帮我们处理，这种故障其实很好处理。但是如果碰到下面这这种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务提供者与服务消费者网络隔离&lt;/li&gt;
&lt;li&gt;服务提供陷入缓慢&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在服务消费者看来，服务提供者其实是「活着」，这是因为服务提供者与 Zookeeper 还是正常连接。&lt;/p&gt;
&lt;p&gt;但是实际情况下，服务消费者其实已经不能正常调用服务提供者了，那这种情况就比较棘手了。&lt;/p&gt;
&lt;p&gt;不过 Dubbo 内部也提供了解决办法。马上就上班了，也来不及讲了，我们后面再讨论！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小灰：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好的，黑哥！今天学到了！&lt;/p&gt;
&lt;p&gt;黑哥🐂🍺！爱你~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202008/1419561-20200828082737249-12206703.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;帮助链接&quot;&gt;帮助链接&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/&quot;&gt;https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 28 Aug 2020 00:28:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>某日中午，午睡正香的时候，接到系统的报警电话，提示生产某物理机异常宕机了，目前该物理机已恢复，需要重启上面部署的应用。 这时瞬间没有了睡意，登上堡垒机，快速重启了应用，系统恢复正常。本想着继续午睡，但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13575494.html</dc:identifier>
</item>
<item>
<title>死磕二叉树（二） - punnpkin</title>
<link>http://www.cnblogs.com/punnpkin/p/13575493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/punnpkin/p/13575493.html</guid>
<description>&lt;h4 id=&quot;102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&quot;&gt;102. 二叉树的层序遍历&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;二叉树层序遍历可以借助BFS的思想解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到这个题目之后，首先看到返回的类型是一个&lt;code&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&lt;/code&gt;，因此在构造返回结果的时候，结果也是按层进行添加的，也就是说，在处理的过程中需要保存当前访问的&lt;strong&gt;层&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 构造返回结果
List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();

// 动态添加值
List&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
res.add(list);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，为了达到层次遍历的效果，可以把二叉树的依次&lt;strong&gt;按层节点&lt;/strong&gt;压入到队列中，再依次弹出使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();

TreeNode node = queue.poll();
if(node.left != null) queue.add(node.left);
if(node.right != null) queue.add(node.right);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以说，队列一次性保存了&lt;strong&gt;二叉树某个层的全部节点&lt;/strong&gt;，一层一层的直到最底层：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Solution {
    // 迭代
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        if(root == null) return res;

        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();
        queue.add(root);

        while (!queue.isEmpty()){
            List&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
            int level_length = queue.size();
            for (int i = 0; i &amp;lt; level_length; i++) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(list);
        }

        return res;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;107-二叉树的层次遍历-ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/&quot;&gt;107. 二叉树的层次遍历 II&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和上一题的唯一区别就是：&lt;strong&gt;每层的结点在结果中存放的先后顺序不同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;稍微调整一下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;res.add(0, list);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;剑指-offer-32---iii-从上到下打印二叉树-iii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/&quot;&gt;剑指 Offer 32 - III. 从上到下打印二叉树 III&lt;/a&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请实现一个函数按照之字形顺序打印二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过奇偶层的分离，就可以实现之字形打印的。在层序遍历中，res按&lt;strong&gt;层&lt;/strong&gt;保存了遍历的结果，因此可以借助&lt;code&gt;res.size&lt;/code&gt;来区分奇偶层，也可以在循环外单独设置一个变量来指示当前的层数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Solution {
    // 迭代
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new LinkedList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        if(root == null) return res;

        Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;();
        queue.add(root);

        int level = 0;
        while (!queue.isEmpty()){
            List&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();
            int level_length = queue.size();
            for (int i = 0; i &amp;lt; level_length; i++) {
                TreeNode node = queue.poll();
                if (level % 2 == 0) list.add(node.val);
                else list.add(0, node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(list);
            level ++;
        }

        return res;
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 28 Aug 2020 00:28:00 +0000</pubDate>
<dc:creator>punnpkin</dc:creator>
<og:description>102. 二叉树的层序遍历 二叉树层序遍历可以借助BFS的思想解决： class Solution { public List&amp;amp;lt;List&amp;amp;lt;Integer&amp;amp;gt;&amp;a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/punnpkin/p/13575493.html</dc:identifier>
</item>
<item>
<title>一、SQLMAP入门 - 一夜荒唐梦</title>
<link>http://www.cnblogs.com/chen-kaige/p/13575490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-kaige/p/13575490.html</guid>
<description>[unable to retrieve full-text content]一、SQLMAP入门 1、判断是否存在注入 sqlmap.py -u 网址/id=1 id=1不可缺少。当注入点后面的参数大于两个时。需要加双引号， sqlmap.py -u &quot;网址/id=1&amp;uid=1&quot; 2、判断文本中的请求是否存在注入 从文本中加载http请求，SQLMAP可以从一个文本文件中</description>
<pubDate>Fri, 28 Aug 2020 00:25:00 +0000</pubDate>
<dc:creator>一夜荒唐梦</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fchen-kaige%2Fp%2F13575490.html</dc:identifier>
</item>
<item>
<title>Docker 镜像构建之 Dockerfile - 哈喽沃德先生</title>
<link>http://www.cnblogs.com/mrhelloworld/p/docker7.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrhelloworld/p/docker7.html</guid>
<description>&lt;p&gt;在 Docker 中构建镜像最常用的方式，就是使用 &lt;code&gt;Dockerfile&lt;/code&gt;。Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。官方文档：&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-常用指令&quot;&gt;Dockerfile 常用指令&lt;/h2&gt;

&lt;h3 id=&quot;from&quot;&gt;FROM&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　指明构建的新镜像是来自于哪个基础镜像，如果没有选择 tag，那么默认值为 latest。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;FROM centos:7
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　如果不以任何镜像为基础，那么写法为：FROM scratch。官方说明：scratch 镜像是一个空镜像，可以用于构建 busybox 等超小镜像，可以说是真正的从零开始构建属于自己的镜像。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;maintainerdeprecated&quot;&gt;&lt;s&gt;MAINTAINER&lt;/s&gt;(deprecated)&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;MAINTAINER &amp;lt;name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　指明镜像维护者及其联系方式（一般是邮箱地址）。官方说明已过时，推荐使用 LABEL。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;MAINTAINER mrhelloworld &amp;lt;mrhelloworld@126.com&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;label&quot;&gt;LABEL&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　功能是为镜像指定标签。也可以使用 LABEL 来指定镜像作者。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;LABEL maintainer=&quot;mrhelloworld.com&quot;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;run&quot;&gt;RUN&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;RUN &amp;lt;command&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　构建镜像时运行的 Shell 命令，比如构建的新镜像中我们想在 /usr/local 目录下创建一个 java 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;RUN mkdir -p /usr/local/java
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;add&quot;&gt;ADD&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;ADD &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　拷贝文件或目录到镜像中。src 可以是一个本地文件或者是一个本地压缩文件，压缩文件会自动解压。还可以是一个 url，如果把 src 写成一个 url，那么 ADD 就类似于 wget 命令，然后自动下载和解压。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;copy&quot;&gt;COPY&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;COPY &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　拷贝文件或目录到镜像中。用法同 ADD，只是不支持自动下载和解压。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;COPY jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;expose&quot;&gt;EXPOSE&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;/&amp;lt;protocol&amp;gt;...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　暴露容器运行时的监听端口给外部，可以指定端口是监听 TCP 还是 UDP，如果未指定协议，则默认为 TCP。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;EXPOSE 80 443 8080/tcp
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想使得容器与宿主机的端口有映射关系，必须在容器启动的时候加上 -P 参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;env&quot;&gt;ENV&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 添加单个，&lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt; 添加多个。&lt;/p&gt;
&lt;p&gt;　　设置容器内环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ENV JAVA_HOME /usr/local/java/jdk-11.0.6/
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;cmd&quot;&gt;CMD&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]&lt;/code&gt;，比如：&lt;code&gt;CMD [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;start&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD [&quot;param1&quot;,&quot;param2&quot;]&lt;/code&gt; ，比如：&lt;code&gt;CMD [ &quot;echo&quot;, &quot;$JAVA_HOME&quot; ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD command param1 param2&lt;/code&gt;，比如：&lt;code&gt;CMD echo $JAVA_HOME&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　启动容器时执行的 Shell 命令。在 Dockerfile 中只能有一条 CMD 指令。如果设置了多条 CMD，只有最后一条 CMD 会生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;CMD ehco $JAVA_HOME
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　如果创建容器的时候指定了命令，则 CMD 命令会被替代。假如镜像叫 &lt;code&gt;centos:7&lt;/code&gt;，创建容器时命令是：&lt;code&gt;docker run -it --name centos7 centos:7 echo &quot;helloworld&quot;&lt;/code&gt; 或者 &lt;code&gt;docker run -it --name centos7 centos:7 /bin/bash&lt;/code&gt;，就不会输出 &lt;code&gt;$JAVA_HOME&lt;/code&gt; 的环境变量信息了，因为 CMD 命令被 &lt;code&gt;echo &quot;helloworld&quot;&lt;/code&gt;、&lt;code&gt;/bin/bash&lt;/code&gt; 覆盖了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;entrypoint&quot;&gt;ENTRYPOINT&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;，比如：&lt;code&gt;ENTRYPOINT [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;start&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENTRYPOINT command param1 param2&lt;/code&gt;，比如：&lt;code&gt;ENTRYPOINT ehco $JAVA_HOME&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　启动容器时执行的 Shell 命令，同 CMD 类似，不会被 docker run 命令行指定的参数所覆盖。在 Dockerfile 中只能有一条 ENTRYPOINT 指令。如果设置了多条 ENTRYPOINT，只有最后一条 ENTRYPOINT 会生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ENTRYPOINT ehco $JAVA_HOME
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如果在 Dockerfile 中同时写了 ENTRYPOINT 和 CMD，并且 CMD 指令不是一个完整的可执行命令，那么 CMD 指定的内容将会作为 ENTRYPOINT 的参数；&lt;/li&gt;
&lt;li&gt;如果在 Dockerfile 中同时写了 ENTRYPOINT 和 CMD，并且 CMD 是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3 id=&quot;workdir&quot;&gt;WORKDIR&lt;/h3&gt;

&lt;p&gt;　　语法：&lt;code&gt;WORKDIR /path/to/workdir&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　为 RUN、CMD、ENTRYPOINT 以及 COPY 和 AND 设置工作目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;WORKDIR /usr/local
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;volume&quot;&gt;VOLUME&lt;/h3&gt;

&lt;p&gt;　　指定容器挂载点到宿主机自动生成的目录或其他容器。一般的使用场景为需要持久化存储数据时。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 容器的 /var/lib/mysql 目录会在运行时自动挂载为匿名卷，匿名卷在宿主机的 /var/lib/docker/volumes 目录下
VOLUME [&quot;/var/lib/mysql&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般不会在 Dockerfile 中用到，更常见的还是在 docker run 的时候通过 -v 指定数据卷。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h2&gt;

&lt;p&gt;　　Dockerfile 文件编写好以后，真正构建镜像时需要通过 &lt;code&gt;docker build&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;docker build&lt;/code&gt; 命令用于使用 &lt;code&gt;Dockerfile&lt;/code&gt; 创建镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 使用当前目录的 Dockerfile 创建镜像
docker build -t mycentos:7 .
# 通过 -f Dockerfile 文件的位置创建镜像
docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;：指定要使用的 Dockerfile 路径；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--tag, -t&lt;/code&gt;：镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;关于--理解&quot;&gt;关于 . 理解&lt;/h3&gt;

&lt;p&gt;　　我们在使用 &lt;code&gt;docker build&lt;/code&gt; 命令去构建镜像时，往往会看到命令最后会有一个 &lt;code&gt;.&lt;/code&gt; 号。它究竟是什么意思呢？&lt;/p&gt;
&lt;p&gt;　　很多人以为是用来指定 &lt;code&gt;Dockerfile&lt;/code&gt; 文件所在的位置的，但其实 &lt;code&gt;-f&lt;/code&gt; 参数才是用来指定 &lt;code&gt;Dockerfile&lt;/code&gt; 的路径的，那么 &lt;code&gt;.&lt;/code&gt; 号究竟是用来做什么的呢？&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;Docker&lt;/code&gt; 在运行时分为 &lt;code&gt;Docker 引擎（服务端守护进程）&lt;/code&gt; 和 &lt;code&gt;客户端工具&lt;/code&gt;，我们日常使用各种 &lt;code&gt;docker 命令&lt;/code&gt;，其实就是在使用 &lt;code&gt;客户端工具&lt;/code&gt; 与 &lt;code&gt;Docker 引擎&lt;/code&gt; 进行交互。&lt;/p&gt;
&lt;p&gt;　　当我们使用 &lt;code&gt;docker build&lt;/code&gt; 命令来构建镜像时，这个构建过程其实是在 &lt;code&gt;Docker 引擎&lt;/code&gt; 中完成的，而不是在本机环境。如果在 &lt;code&gt;Dockerfile&lt;/code&gt; 中使用了一些 &lt;code&gt;ADD&lt;/code&gt; 等指令来操作文件，如何让 &lt;code&gt;Docker 引擎&lt;/code&gt; 获取到这些文件呢？&lt;/p&gt;
&lt;p&gt;　　这里就有了一个 &lt;code&gt;镜像构建上下文&lt;/code&gt; 的概念，当构建的时候，由用户指定构建镜像时的上下文路径，而 &lt;code&gt;docker build&lt;/code&gt; 会将这个路径下所有的文件都打包上传给 &lt;code&gt;Docker 引擎&lt;/code&gt;，引擎内将这些内容展开后，就能获取到上下文中的文件了。&lt;/p&gt;

&lt;p&gt;　　举个栗子：我的宿主机 jdk 文件在 /root 目录下，Dockerfile 文件在 /usr/local/dockerfile 目录下，文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　那么构建镜像时的命令就该这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　再举个栗子：我的宿主机 jdk 文件和 Dockerfile 文件都在 /usr/local/dockerfile 目录下，文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　那么构建镜像时的命令则这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 .
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;dockerfile-实践&quot;&gt;Dockerfile 实践&lt;/h2&gt;

&lt;p&gt;　　接下来我们通过基础镜像 &lt;code&gt;centos:7&lt;/code&gt;，在该镜像中安装 jdk 和 tomcat 以后将其制作为一个新的镜像 &lt;code&gt;mycentos:7&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　创建目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p /usr/local/dockerfile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　编写 Dockerfile 文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vi Dockerfile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　Dockerfile 文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 指明构建的新镜像是来自于 centos:7 基础镜像
FROM centos:7
# 通过镜像标签声明了作者信息
LABEL maintainer=&quot;mrhelloworld.com&quot;
# 设置工作目录
WORKDIR /usr/local
# 新镜像构建成功以后创建指定目录
RUN mkdir -p /usr/local/java &amp;amp;&amp;amp; mkdir -p /usr/local/tomcat
# 拷贝文件到镜像中并解压
ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
ADD apache-tomcat-9.0.37.tar.gz /usr/local/tomcat
# 暴露容器运行时的 8080 监听端口给外部
EXPOSE 8080
# 设置容器内 JAVA_HOME 环境变量
ENV JAVA_HOME /usr/local/java/jdk-11.0.6/
ENV PATH $PATH:$JAVA_HOME/bin
# 启动容器时启动 tomcat 并查看 tomcat 日志信息
ENTRYPOINT /usr/local/tomcat/apache-tomcat-9.0.37/bin/startup.sh &amp;amp;&amp;amp; tail -f /usr/local/tomcat/apache-tomcat-9.0.37/logs/catalina.out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　构建镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root/

[root@localhost ~]# docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root/
Sending build context to Docker daemon  191.4MB
Error response from daemon: Dockerfile parse error line 1: unknown instruction: NTOS:7
[root@localhost ~]# vi /usr/local/dockerfile/Dockerfile 
[root@localhost ~]# vi /usr/local/dockerfile/Dockerfile 
[root@localhost ~]# docker build -f /usr/local/dockerfile/Dockerfile -t mycentos:7 /root/
Sending build context to Docker daemon  191.4MB
Step 1/10 : FROM centos:7
 ---&amp;gt; 7e6257c9f8d8
Step 2/10 : LABEL maintainer=&quot;mrhelloworld.com&quot;
 ---&amp;gt; Running in 4c561fed28a5
Removing intermediate container 4c561fed28a5
 ---&amp;gt; b536fc4e4290
Step 3/10 : WORKDIR /usr/local
 ---&amp;gt; Running in 50141816c10e
Removing intermediate container 50141816c10e
 ---&amp;gt; 030f9db632da
Step 4/10 : RUN mkdir -p /usr/local/java &amp;amp;&amp;amp; mkdir -p /usr/local/tomcat
 ---&amp;gt; Running in d1f8f4e008c8
Removing intermediate container d1f8f4e008c8
 ---&amp;gt; 68773de3525a
Step 5/10 : ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java
 ---&amp;gt; 92f410a9e1ba
Step 6/10 : ADD apache-tomcat-9.0.37.tar.gz /usr/local/tomcat
 ---&amp;gt; 8e0576fccd4e
Step 7/10 : EXPOSE 8080
 ---&amp;gt; Running in bb6c4ef8f4e1
Removing intermediate container bb6c4ef8f4e1
 ---&amp;gt; 01edd4710cc1
Step 8/10 : ENV JAVA_HOME /usr/local/java/jdk-11.0.6/
 ---&amp;gt; Running in 722c2d369a2f
Removing intermediate container 722c2d369a2f
 ---&amp;gt; ef5172fb1dd6
Step 9/10 : ENV PATH $PATH:$JAVA_HOME/bin
 ---&amp;gt; Running in eaa287937565
Removing intermediate container eaa287937565
 ---&amp;gt; 0347db73b904
Step 10/10 : ENTRYPOINT /usr/local/tomcat/apache-tomcat-9.0.37/bin/startup.sh &amp;amp;&amp;amp; tail -f /usr/local/tomcat/apache-tomcat-9.0.37/logs/catalina.out
 ---&amp;gt; Running in 8f93d36f4de2
Removing intermediate container 8f93d36f4de2
 ---&amp;gt; 1674e0191270
Successfully built 1674e0191270
Successfully tagged mycentos:7
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;镜像构建历史&quot;&gt;镜像构建历史&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker history 镜像名称:标签|ID
docker history mycentos:7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200817200725799.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用构建的镜像创建容器&quot;&gt;使用构建的镜像创建容器&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 创建容器
docker run -di --name mycentos7 -p 8080:8080 mycentos:7
# 进入容器
docker exec -it mycentos7 /bin/bash
# 测试 java 环境变量
[root@dcae87df010b /]# java -version
java version &quot;11.0.6&quot; 2020-01-14 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.6+8-LTS)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.6+8-LTS, mixed mode)
# 访问 http://192.168.10.10:8080/ 看到页面说明环境 OK!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812190553942.png&quot; alt=&quot;&quot; title=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;太棒了，Dockerfile 构建镜像的方式你也学会了，再接再厉学习一下 Docker 镜像的备份恢复迁移，go ~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/1/171cf87f564bc82e?w=433&amp;amp;h=133&amp;amp;f=gif&amp;amp;s=333013&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;知识共享「署名-非商业性使用-禁止演绎 4.0 国际」许可协议&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家可以通过 &lt;a href=&quot;https://mrhelloworld.com/categories&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;分类&lt;/code&gt;&lt;/a&gt; 查看更多关于 &lt;a href=&quot;https://mrhelloworld.com/categories/docker&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; 的文章。&lt;/p&gt;

&lt;p&gt;🤗 您的&lt;code&gt;点赞&lt;/code&gt;和&lt;code&gt;转发&lt;/code&gt;是对我最大的支持。&lt;/p&gt;
&lt;p&gt;📢 扫码关注 &lt;code&gt;哈喽沃德先生&lt;/code&gt;「文档 + 视频」每篇文章都配有专门视频讲解，学习更轻松噢 ~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/27/171b91f4ae03d737?w=500&amp;amp;h=500&amp;amp;f=gif&amp;amp;s=126591&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/713e7e596507416fb2388a84902a7d1d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Aug 2020 00:23:00 +0000</pubDate>
<dc:creator>哈喽沃德先生</dc:creator>
<og:description>在 Docker 中构建镜像最常用的方式，就是使用 Dockerfile。Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。官方文档：https://d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrhelloworld/p/docker7.html</dc:identifier>
</item>
<item>
<title>一文带你深扒ClassLoader内核，揭开它的神秘面纱！ - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/13575224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/13575224.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827234848003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;「MoreThanJava」&lt;/strong&gt; 宣扬的是 &lt;strong&gt;「学习，不止 CODE」&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果觉得 &lt;strong&gt;「不错」&lt;/strong&gt; 的朋友，欢迎 &lt;strong&gt;「关注 + 留言 + 分享」&lt;/strong&gt;，文末有完整的获取链接，您的支持是我前进的最大的动力！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ClassLoader 可以说是 Java 最为神秘的功能之一了，好像大家都知道怎么回事儿 &lt;em&gt;(双亲委派模型好像都都能说得出来...)&lt;/em&gt;，又都说不清楚具体是怎么一回事 &lt;em&gt;(为什么需要需要有什么实际用途就很模糊了...)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/1598311905-57783.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天，我们就来深度扒一扒，揭开它神秘的面纱！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/006qOO1Xly1ghftzela9eg308c05sald.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先，我们知道，Java 为了实现 &lt;strong&gt;「一次编译，到处运行」&lt;/strong&gt; 的目标，采用了一种特别的方案：先 &lt;strong&gt;编译&lt;/strong&gt; 为 &lt;strong&gt;与任何具体及其环境及操作系统环境无关的中间代码&lt;/strong&gt;（也就是 &lt;code&gt;.class&lt;/code&gt; 字节码文件），然后交由各个平台特定的 Java 解释器（也就是 JVM）来负责 &lt;strong&gt;解释&lt;/strong&gt; 运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/img/img/%E3%80%8CMoreThanJava%E3%80%8D%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%88%B0%E6%B1%87%E7%BC%96%E5%86%8D%E5%88%B0%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/7896890-81a0bce7dbea21a5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ClassLoader &lt;em&gt;(顾名思义就是类加载器)&lt;/em&gt; 就是那个把字节码交给 JVM 的搬运工 &lt;em&gt;（加载进内存）&lt;/em&gt;。它负责将 &lt;strong&gt;字节码形式&lt;/strong&gt; 的 Class 转换成 JVM 中 &lt;strong&gt;内存形式&lt;/strong&gt; 的 Class 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200826073719796.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字节码可以是来自于磁盘上的 &lt;code&gt;.class&lt;/code&gt; 文件，也可以是 &lt;code&gt;jar&lt;/code&gt; 包里的 &lt;code&gt;*.class&lt;/code&gt;，甚至是来自远程服务器提供的字节流。&lt;strong&gt;字节码的本质其实就是一个有特定复杂格式的字节数组 &lt;code&gt;byte[]&lt;/code&gt;。&lt;/strong&gt; &lt;em&gt;(从后面解析 ClassLoader 类中的方法时更能体会)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200825080559568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，类加载器不光可以把 Class 加载到 JVM 之中并解析成 JVM 统一要求的对象格式，还有一个重要的作用就是 &lt;strong&gt;审查每个类应该由谁加载&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且，这些 Java 类不会一次全部加载到内存，而是在应用程序需要时加载，这也是需要类加载器的地方。&lt;/p&gt;

&lt;p&gt;以下就是 ClassLoader 的主要方法了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827083357060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;defineClass()&lt;/code&gt; 用于将 &lt;code&gt;byte&lt;/code&gt; 字节流解析成 JVM 能够识别的 Class 对象。有了这个方法意味着我们不仅可以通过 &lt;code&gt;.class&lt;/code&gt; 文件实例化对象，还可以通过其他方式实例化对象，例如通过网络接收到一个类的字节码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（注意，如果直接调用这个方法生成类的 Class 对象，这个类的 Class 对象还没有 &lt;code&gt;resolve&lt;/code&gt;，JVM 会在这个对象真正实例化时才调用 &lt;code&gt;resolveClass()&lt;/code&gt; 进行链接）&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;findClass()&lt;/code&gt; 通常和 &lt;code&gt;defineClass()&lt;/code&gt; 一起使用，我们需要直接覆盖 ClassLoader 父类的 &lt;code&gt;findClass()&lt;/code&gt; 方法来实现类的加载规则，从而取得要加载类的字节码。&lt;em&gt;(以下是 ClassLoader 源码)&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
  throw new ClassNotFoundException(name);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不想重新定义加载类的规则，也没有复杂的处理逻辑，只想在运行时能够加载自己制定的一个类，那么你可以用 &lt;code&gt;this.getClass().getClassLoader().loadClass(&quot;class&quot;)&lt;/code&gt; 调用 ClassLoader 的 &lt;code&gt;loadClass()&lt;/code&gt; 方法来获取这个类的 Class 对象，这个 &lt;code&gt;loadClass()&lt;/code&gt; 还有重载方法，你同样可以决定再什么时候解析这个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;loadClass()&lt;/code&gt; 用于接受一个全类名，然后返回一个 Class 类型的对象。&lt;em&gt;（该方法源码蕴含了著名的双亲委派模型）&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;resolveClass()&lt;/code&gt; 用于对 Class 进行 &lt;strong&gt;链接&lt;/strong&gt;，也就是把单一的 Class 加入到有继承关系的类树中。如果你想在类被加载到 JVM 中时就被链接（Link），那么可以在调用 &lt;code&gt;defineClass()&lt;/code&gt; 之后紧接着调用一个 &lt;code&gt;resolveClass()&lt;/code&gt; 方法，当然你也可以选择让 JVM 来解决什么时候才链接这个类（通常是真正被实实例化的时候）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ClassLoader 是个抽象类，它还有很多子类，如果我们要实现自己的 ClassLoader，一般都会继承 &lt;strong&gt;URLClassLoader&lt;/strong&gt; 这个子类，因为这个类已经帮我们实现了大部分工作。&lt;/p&gt;
&lt;p&gt;例如，我们来看一下 &lt;code&gt;java.net.URLClassLoader.findClass()&lt;/code&gt; 方法的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 入参为 Class 的 binary name，如 java.lang.String
protected Class&amp;lt;?&amp;gt; findClass(final String name) throws ClassNotFoundException {
    // 以上代码省略
  
    // 通过 binary name 生成包路径，如 java.lang.String -&amp;gt; java/lang/String.class
    String path = name.replace('.', '/').concat(&quot;.class&quot;);
    // 根据包路径，找到该 Class 的文件资源
    Resource res = ucp.getResource(path, false);
    if (res != null) {
        try {
           // 调用 defineClass 生成 java.lang.Class 对象
            return defineClass(name, res);
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    } else {
        return null;
    }
  
    // 以下代码省略
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以下就是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827092015305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上，我们每一次在 IDEA 中点击运行时，IDE 都会默认替我们执行以下的命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;javac Xxxx.java&lt;/code&gt; ➡️ 找到源文件中的 &lt;code&gt;public class&lt;/code&gt;，再找 &lt;code&gt;public class&lt;/code&gt; 引用的其他类，Java 编译器会根据每一个类生成一个字节码文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java Xxxx&lt;/code&gt; ➡️ 找到文件中的唯一主类 &lt;code&gt;public class&lt;/code&gt;，并根据 &lt;code&gt;public static&lt;/code&gt; 关键字找到跟主类关联可执行的 &lt;code&gt;main&lt;/code&gt; 方法 &lt;em&gt;（这也是为什么 &lt;code&gt;main&lt;/code&gt; 方法需要被定义为 &lt;code&gt;public static void&lt;/code&gt; 的原因了——我们需要在类没有加载时访问）&lt;/em&gt;，开始执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在真正的运行 &lt;code&gt;main&lt;/code&gt; 方法之前，JVM 需要 &lt;strong&gt;加载、链接&lt;/strong&gt; 以及 &lt;strong&gt;初始化&lt;/strong&gt; 上述的 Xxxx 类。&lt;/p&gt;
&lt;h2 id=&quot;第一步：加载（loading）&quot;&gt;第一步：加载（Loading）&lt;/h2&gt;
&lt;p&gt;这一步是读取到类文件产生的二进制流（&lt;code&gt;findClass()&lt;/code&gt;），并转换为特定的数据结构（&lt;code&gt;defineClass()&lt;/code&gt;），初步校验 &lt;code&gt;cafe babe&lt;/code&gt; 魔法数 &lt;em&gt;（二进制中前四个字节为 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 用来标识该文件是 Java 文件，这是很多软件的做法，比如 &lt;code&gt;zip压缩文件&lt;/code&gt;）&lt;/em&gt;、常量池、文件长度、是否有父类等，然后在 Java &lt;strong&gt;堆&lt;/strong&gt; 中创建对应类的 &lt;code&gt;java.lang.Class&lt;/code&gt; 实例，类中存储的各部分信息也需要对应放入 &lt;strong&gt;运行时数据区&lt;/strong&gt; 中（例如静态变量、类信息等放入方法区）。&lt;/p&gt;
&lt;blockquote readability=&quot;6.1333333333333&quot;&gt;
&lt;p&gt;以下是一个 Class 文件具有的基本结构的简单图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827093649056.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果对 Class 文件更多细节感兴趣的可以进一步阅读：&lt;a href=&quot;https://juejin.im/post/6844904199617003528&quot;&gt;https://juejin.im/post/6844904199617003528&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们可能会有一个疑问，&lt;strong&gt;为什么 JVM 允许还没有进行验证、准备和解析的类信息放入方法区呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是加载阶段和链接阶段的部分动作（比如一部分字节码文件格式验证动作）是 &lt;strong&gt;交叉进行&lt;/strong&gt; 的，也就是说 &lt;strong&gt;加载阶段还没完成，链接阶段可能已经开始了&lt;/strong&gt;。但这些夹杂在加载阶段的动作（验证文件格式等）仍然属于链接操作。&lt;/p&gt;
&lt;h2 id=&quot;第二步：链接（linking）&quot;&gt;第二步：链接（Linking）&lt;/h2&gt;
&lt;p&gt;Link 阶段包括验证、准备、解析三个步骤。下面👇我们来详细说说。&lt;/p&gt;
&lt;h3 id=&quot;验证：确保被加载的类的正确性&quot;&gt;验证：确保被加载的类的正确性&lt;/h3&gt;
&lt;p&gt;验证是连接阶段的第一步，这一阶段的目的是 &lt;strong&gt;为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全&lt;/strong&gt;。验证阶段大致会完成 &lt;code&gt;4&lt;/code&gt; 个阶段的检验动作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件格式验证：&lt;/strong&gt; 验证字节流是否符合 Class 文件格式的规范；例如：是否以 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据验证：&lt;/strong&gt; 对字节码描述的信息进行语义分析（注意：对比 &lt;code&gt;javac&lt;/code&gt; 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 &lt;code&gt;java.lang.Object&lt;/code&gt; 之外。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码验证：&lt;/strong&gt; 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用验证：&lt;/strong&gt; 确保解析动作能正确执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;验证阶段是非常重要的，但不是必须的&lt;/strong&gt;，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 &lt;code&gt;-Xverifynone&lt;/code&gt; 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。&lt;/p&gt;
&lt;h3 id=&quot;准备：为类的静态变量分配内存，并将其初始化为默认值&quot;&gt;准备：为类的静态变量分配内存，并将其初始化为默认值&lt;/h3&gt;
&lt;p&gt;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在 &lt;strong&gt;方法区&lt;/strong&gt; 中分配。对于该阶段有以下几点需要注意：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1️⃣ 这时候进行内存分配的 &lt;strong&gt;仅包括类变量&lt;/strong&gt;（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2️⃣ 这里所设置的 &lt;strong&gt;初始值通常情况下是数据类型默认的零值&lt;/strong&gt;（如 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;0L&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;等），而不是被在 Java 代码中被显式地赋予的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;3️⃣ 如果类字段的字段属性表中存在 ConstantValue 属性，即 &lt;strong&gt;同时被 &lt;code&gt;final&lt;/code&gt; 和 &lt;code&gt;static&lt;/code&gt; 修饰&lt;/strong&gt;，那么在准备阶段变量 &lt;code&gt;value&lt;/code&gt; 就会被初始化为 ConstValue 属性所指定的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;➡️ 例如，假设这里有一个类变量 &lt;code&gt;public static int value = 666;&lt;/code&gt;，在准备阶段时初始值是 &lt;code&gt;0&lt;/code&gt; 而不是 &lt;code&gt;666&lt;/code&gt;，在 &lt;strong&gt;初始化阶段&lt;/strong&gt; 才会被真正赋值为 &lt;code&gt;666&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;➡️ 假设是一个静态类变量 &lt;code&gt;public static final int value = 666;&lt;/code&gt;，则再准备阶段 JVM 就已经赋值为 &lt;code&gt;666&lt;/code&gt; 了。&lt;/p&gt;
&lt;h3 id=&quot;解析：把类中的符号引用转换为直接引用（重要）&quot;&gt;解析：把类中的符号引用转换为直接引用（重要）&lt;/h3&gt;
&lt;p&gt;解析阶段是虚拟机将常量池内的 &lt;strong&gt;符号引用&lt;/strong&gt; 替换为 &lt;strong&gt;直接引用&lt;/strong&gt; 的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 &lt;code&gt;7&lt;/code&gt; 类符号引用进行。&lt;/p&gt;
&lt;p&gt;➡️ &lt;strong&gt;符号引用&lt;/strong&gt; 的作用是在编译的过程中，JVM 并不知道引用的具体地址，所以用符号引用进行代替，而在解析阶段将会将这个符号引用转换为真正的内存地址。&lt;/p&gt;
&lt;p&gt;➡️ &lt;strong&gt;直接引用&lt;/strong&gt; 可以理解为指向 &lt;strong&gt;类、变量、方法&lt;/strong&gt; 的指针，指向 &lt;strong&gt;实例&lt;/strong&gt; 的指针和一个 &lt;strong&gt;间接定位&lt;/strong&gt; 到对象的对象句柄。&lt;/p&gt;
&lt;p&gt;为了理解👆上面两种概念的区别，来看一个实际的例子吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Tester {

    public static void main(String[] args) {
        String str = &quot;关注【我没有三颗心脏】，关注更多精彩&quot;;
        System.out.println(str);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先在该类同级目录下运行 &lt;code&gt;javac Tester&lt;/code&gt; 编译成 &lt;code&gt;.class&lt;/code&gt; 文件然后再利用 &lt;code&gt;javap -verbose Tester&lt;/code&gt; 查看类的详细信息 &lt;em&gt;（为了节省篇幅只截取了 &lt;code&gt;main&lt;/code&gt; 方法反编译后的代码）&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 上面是类的详细信息省略...
{
        // .....
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: ldc           #7                  // String 关注【我没有三颗心脏】，关注更多精彩
         2: astore_1
         3: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
         6: aload_1
         7: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        10: return
      LineNumberTable:
        line 4: 0
        line 5: 3
        line 6: 10
}
SourceFile: &quot;Tester.java&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，上面👆定义的 &lt;code&gt;str&lt;/code&gt; 变量在编译阶段会被解析称为 &lt;strong&gt;符号引用&lt;/strong&gt;，符号引用的标志是 &lt;code&gt;astore_&amp;lt;n&amp;gt;&lt;/code&gt;，这里就是 &lt;code&gt;astore_1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;store_1&lt;/code&gt;的含义是将操作数栈顶的 &lt;code&gt;关注【我没有三颗心脏】，关注更多精彩&lt;/code&gt; 保存回索引为 &lt;code&gt;1&lt;/code&gt; 的局部变量表中，此时访问变量 &lt;code&gt;str&lt;/code&gt; 就会读取局部变量表索引值为 &lt;code&gt;1&lt;/code&gt; 中的数据。所以局部变量 &lt;code&gt;str&lt;/code&gt; 就是一个符号引用。&lt;/p&gt;
&lt;p&gt;再来看另外一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Tester {

    public static void main(String[] args) {
        System.out.println(&quot;关注【我没有三颗心脏】，关注更多精彩&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一段代码反编译之后得到如下的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 上面是类的详细信息省略...
{
  // ......
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #13                 // String 关注【我没有三颗心脏】，关注更多精彩
         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 4: 0
        line 5: 8
}
SourceFile: &quot;Tester.java&quot;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这里直接使用了 &lt;code&gt;ldc&lt;/code&gt; 指令将 &lt;code&gt;关注【我没有三颗心脏】，关注更多精彩&lt;/code&gt; 推送到了栈，紧接着就是调用指令 &lt;code&gt;invokevirtual&lt;/code&gt;，并没有将字符串存入局部变量表中，这里的字符串就是一个 &lt;strong&gt;直接引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;第三步：初始化（initialization）&quot;&gt;第三步：初始化（Initialization）&lt;/h2&gt;
&lt;p&gt;初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1️⃣ 声明类变量是指定初始值；&lt;/li&gt;
&lt;li&gt;2️⃣ 使用静态代码块为类变量指定初始值；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;JVM 初始化步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1️⃣ 假如这个类还没有被加载和连接，则程序先加载并连接该类&lt;/li&gt;
&lt;li&gt;2️⃣ 假如该类的直接父类还没有被初始化，则先初始化其直接父类&lt;/li&gt;
&lt;li&gt;3️⃣ 假如类中有初始化语句，则系统依次执行这些初始化语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;类初始化时机&lt;/strong&gt;：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建类的实例，也就是 &lt;code&gt;new&lt;/code&gt; 的方式&lt;/li&gt;
&lt;li&gt;访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
&lt;li&gt;调用类的静态方法&lt;/li&gt;
&lt;li&gt;反射（如 &lt;code&gt;Class.forName(&quot;com.wmyskxz.Tester&quot;)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化某个类的子类，则其父类也会被初始化&lt;/li&gt;
&lt;li&gt;Java 虚拟机启动时被标明为启动类的类，直接使用 &lt;code&gt;java.exe&lt;/code&gt; 命令来运行某个主类&lt;/li&gt;
&lt;li&gt;使用 JDK 7 新加入的动态语言支持时，如果一个 &lt;code&gt;java.lang.invoke.MethodHanlde&lt;/code&gt; 实例最后的解析结果为 &lt;code&gt;REF_getstatic&lt;/code&gt;、&lt;code&gt;REF_putstatic&lt;/code&gt;、&lt;code&gt;REF_invokeStatic&lt;/code&gt;、&lt;code&gt;REF_newInvokeSpecial&lt;/code&gt; 四种类型的方法句柄时，都需要先初始化该句柄对应的类&lt;/li&gt;
&lt;li&gt;接口中定义了 JDK 8 新加入的默认方法（&lt;code&gt;default&lt;/code&gt;修饰符），&lt;strong&gt;实现类在初始化之前需要先初始化其接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在上面👆已经了解了一个类是如何被加载进 JVM 的——依靠类加载器——在 Java 语言中自带有三个类加载器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Bootstrap ClassLoader&lt;/strong&gt; 最顶层的加载类，主要加载 &lt;strong&gt;核心类库&lt;/strong&gt;，&lt;code&gt;%JRE_HOME%\lib&lt;/code&gt; 下的&lt;code&gt;rt.jar&lt;/code&gt;、&lt;code&gt;resources.jar&lt;/code&gt;、&lt;code&gt;charsets.jar&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extention ClassLoader&lt;/strong&gt; 扩展的类加载器，加载目录 &lt;code&gt;%JRE_HOME%\lib\ext&lt;/code&gt; 目录下的 &lt;code&gt;jar&lt;/code&gt; 包和 &lt;code&gt;class&lt;/code&gt; 文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Appclass Loader 也称为 SystemAppClass&lt;/strong&gt; 加载当前应用的 &lt;code&gt;classpath&lt;/code&gt; 的所有类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以通过一个简单的例子来简单了解 Java 中这些自带的类加载器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PrintClassLoader {

    public static void main(String[] args) {
        printClassLoaders();
    }

    public static void printClassLoaders() {
        System.out.println(&quot;Classloader of this class:&quot;
            + PrintClassLoader.class.getClassLoader());
        System.out.println(&quot;Classloader of Logging:&quot;
            + com.sun.javafx.util.Logging.class.getClassLoader());
        System.out.println(&quot;Classloader of ArrayList:&quot;
            + java.util.ArrayList.class.getClassLoader());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上方程序打印输出如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Classloader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2
Classloader of Logging:sun.misc.Launcher$ExtClassLoader@60e53b93
Classloader of ArrayList:null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如我们所见，这里分别对应三种不同类型的类加载器：AppClassLoader、ExtClassLoader 和 BootstrapClassLoader（显示为 &lt;code&gt;null&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;一个很好的问题是：&lt;strong&gt;Java 类是由 &lt;code&gt;java.lang.ClassLoader&lt;/code&gt; 实例加载的，但类加载器本身也是类，那么谁来加载类加载器呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们假装不知道，先来跟着源码一步一步来看。&lt;/p&gt;
&lt;h2 id=&quot;先来看看-java-虚拟机入口代码&quot;&gt;先来看看 Java 虚拟机入口代码&lt;/h2&gt;
&lt;p&gt;在 JDK 源码 &lt;code&gt;sun.misc.Launcher&lt;/code&gt; 中，蕴含了 Java 虚拟机的入口方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Launcher {
    private static Launcher launcher = new Launcher();
    private static String bootClassPath =
        System.getProperty(&quot;sun.boot.class.path&quot;);

    public static Launcher getLauncher() {
        return launcher;
    }

    private ClassLoader loader;

    public Launcher() {
        // Create the extension class loader
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create extension class loader&quot;, e);
        }

        // Now create the class loader to use to launch the application
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create application class loader&quot;, e);
        }

        // 设置 AppClassLoader 为线程上下文类加载器，这个文章后面部分讲解
        Thread.currentThread().setContextClassLoader(loader);
    }
    /*
     * Returns the class loader used to launch the main application.
     */
    public ClassLoader getClassLoader() {
        return loader;
    }
    /*
     * The class loader used for loading installed extensions.
     */
    static class ExtClassLoader extends URLClassLoader {}
                /**
     * The class loader used for loading from java.class.path.
     * runs in a restricted security context.
     */
    static class AppClassLoader extends URLClassLoader {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码有精简，但是我们可以得到以下信息：&lt;/p&gt;
&lt;p&gt;1️⃣ Launcher 初始化了 ExtClassLoader 和 AppClassLoader。&lt;/p&gt;
&lt;p&gt;2️⃣ Launcher 没有看到 Bootstrap ClassLoader 的影子，但是有一个叫做 &lt;code&gt;bootClassPath&lt;/code&gt; 的变量，大胆一猜就是 Bootstrap ClassLoader 加载的 &lt;code&gt;jar&lt;/code&gt; 包的路径。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(ps: 可以自己尝试输出一下 &lt;code&gt;System.getProperty(&quot;sun.boot.class.path&quot;)&lt;/code&gt; 的内容，它正好对应了 JDK 目录 &lt;code&gt;lib&lt;/code&gt; 和 &lt;code&gt;classes&lt;/code&gt; 目录下的 &lt;code&gt;jar&lt;/code&gt; 包——也就是通常你配置环境变量时设置的 &lt;code&gt;%JAVA_HOME/lib&lt;/code&gt; 的目录了——同样的方式你也可以看看 Ext 和 App 的源码)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3️⃣ ExtClassLoader 和 AppClassLoader 都继承自 URLClassLoader，进一步查看 ClassLoader 的继承树，传说中的双亲委派模型也并没有出现。&lt;em&gt;（甚至看不到 Bootstrap ClassLoader 的影子，Ext 也没有直接继承自 App 类加载器）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827155234783.png&quot; alt=&quot;ClassLoader 继承树&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（⚠️注意，这里可以明确看到每一个 ClassLoader 都有一个 &lt;code&gt;parent&lt;/code&gt; 变量，用于标识自己的父类，下面👇详细说）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;4️⃣ 注意以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ClassLoader extcl;
        
extcl = ExtClassLoader.getExtClassLoader();

loader = AppClassLoader.getAppClassLoader(extcl);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别跟踪查看到这两个 ClassLoader 初始化时的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 一直追踪到最顶层的 ClassLoader 定义，构造器的第二个参数标识了类加载器的父类
private ClassLoader(Void unused, ClassLoader parent) {
  this.parent = parent;
  // 代码省略.....
}
// Ext 设置自己的父类为 null
public ExtClassLoader(File[] var1) throws IOException {
  super(getExtURLs(var1), (ClassLoader)null, Launcher.factory);
  SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this);
}
// 手动把 Ext 设置为 App 的 parent（这里的 var2 是传进来的 extc1）
AppClassLoader(URL[] var1, ClassLoader var2) {
  super(var1, var2, Launcher.factory);
  this.ucp.initLookupCache(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此，我们得到了这样一个类加载器的关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827164809547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类加载器的父类都来自哪里？&quot;&gt;类加载器的父类都来自哪里？&lt;/h2&gt;
&lt;p&gt;奇怪，为什么 ExtClassLoader 的 &lt;code&gt;parent&lt;/code&gt; 明明是 &lt;code&gt;null&lt;/code&gt;，我们却一般地认为 Bootstrap ClassLoader 才是 ExtClassLoader 的父加载器呢？&lt;/p&gt;
&lt;p&gt;答案的一部分就藏在 &lt;code&gt;java.lang.ClassLoader.loadClass()&lt;/code&gt; 方法里面：&lt;strong&gt;（这也就是著名的「双亲委派模型」现场了）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
  throws ClassNotFoundException
{
  synchronized (getClassLoadingLock(name)) {
    // 首先检查是否已经加载过了
    Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
    if (c == null) {
      long t0 = System.nanoTime();
      try {
        if (parent != null) {
                                        // 父加载器不为空则调用父加载器的 loadClass 方法
          c = parent.loadClass(name, false);
        } else {
          // 父加载器为空则调用 Bootstrap ClassLoader
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // ClassNotFoundException thrown if class not found
        // from the non-null parent class loader
      }

      if (c == null) {
        // If still not found, then invoke findClass in order
        // to find the class.
        long t1 = System.nanoTime();
        // 父加载器没有找到，则调用 findclass
        c = findClass(name);

        // this is the defining class loader; record the stats
        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
        sun.misc.PerfCounter.getFindClasses().increment();
      }
    }
    if (resolve) {
      // 调用 resolveClass()
      resolveClass(c);
    }
    return c;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码逻辑很好地解释了双亲委派的原理。&lt;/p&gt;
&lt;p&gt;1️⃣ 当前 ClassLoader 首先从 &lt;strong&gt;自己已经加载的类中查询是否此类已经加载&lt;/strong&gt;，如果已经加载则直接返回原来已经加载的类。(每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。)&lt;/p&gt;
&lt;p&gt;2️⃣ 当前 ClassLoader 的缓存中没有找到被加载的类的时候，&lt;strong&gt;委托父类加载器去加载&lt;/strong&gt;，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 Bootstrap ClassLoader。（当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827213241812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，答案的另一部分是因为最高一层的类加载器 Bootstrap 是通过 C/C++ 实现的，并不存在于 JVM 体系内 &lt;em&gt;（不是一个 Java 类，没办法直接表示为 ExtClassLoader 的父加载器）&lt;/em&gt;，所以输出为 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（我们可以很轻易跟踪到 &lt;code&gt;findBootstrapClass()&lt;/code&gt; 方法被 &lt;code&gt;native&lt;/code&gt; 修饰：&lt;code&gt;private native Class&amp;lt;?&amp;gt; findBootstrapClass(String name);&lt;/code&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;➡️ OK，我们理解了为什么 ExtClassLoader 的父加载器为什么是表示为 &lt;code&gt;null&lt;/code&gt; 的 Bootstrap 加载器，那我们 &lt;strong&gt;自己实现的 ClassLoader 父加载器应该是谁呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;观察一下 ClassLoader 的源码就知道了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected ClassLoader(ClassLoader parent) {
    this(checkCreateClassLoader(), parent);
}
protected ClassLoader() {
    this(checkCreateClassLoader(), getSystemClassLoader());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类加载器的 &lt;code&gt;parent&lt;/code&gt; 的赋值是在 ClassLoader 对象的构造方法中，它有两个情况：&lt;/p&gt;
&lt;p&gt;1️⃣ 由外部类创建 ClassLoader 时直接指定一个 ClassLoader 为 &lt;code&gt;parent&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;2️⃣ 由 &lt;code&gt;getSystemClassLoader()&lt;/code&gt; 方法生成，也就是在 &lt;code&gt;sun.misc.Laucher&lt;/code&gt; 通过 &lt;code&gt;getClassLoader()&lt;/code&gt; 获取，也就是 AppClassLoader。直白的说，一个 ClassLoader 创建时如果没有指定 &lt;code&gt;parent&lt;/code&gt;，那么它的 &lt;code&gt;parent&lt;/code&gt; 默认就是 AppClassLoader。（建议去看一下源码）&lt;/p&gt;
&lt;h2 id=&quot;为什么这样设计呢？&quot;&gt;为什么这样设计呢？&lt;/h2&gt;
&lt;p&gt;简单来说，主要是为了 &lt;strong&gt;安全性&lt;/strong&gt;，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也 &lt;strong&gt;避免了重复加载&lt;/strong&gt;，因为 JVM 中区分不同类，不仅仅是根据类名，&lt;strong&gt;相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类&lt;/strong&gt;，如果相互转型的话会抛 &lt;code&gt;java.lang.ClassCaseException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们要实现自己的类加载器，不管你是直接实现抽象类 ClassLoader，还是继承 URLClassLoader 类，或者其他子类，它的父加载器都是 AppClassLoader。&lt;/p&gt;
&lt;p&gt;因为不管调用哪个父类构造器，创建的对象都必须最终调用 &lt;code&gt;getSystemClassLoader()&lt;/code&gt; 作为父加载器 &lt;em&gt;（我们已经从上面👆的源码中看到了）&lt;/em&gt;。而该方法最终获取到的正是 AppClassLoader &lt;em&gt;（别称 SystemClassLoader）&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;这也就是我们熟知的最终的双亲委派模型了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/BlogImage01/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E6%89%92%E7%A5%9E%E7%A7%98ClassLoader%E5%86%85%E6%A0%B8/image-20200827215439538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么情况下需要自定义类加载器&quot;&gt;什么情况下需要自定义类加载器&lt;/h2&gt;
&lt;p&gt;在学习了类加载器的实现机制之后，我们知道了双亲委派模型并非强制模型，用户可以自定义类加载器，在什么情况下需要自定义类加载器呢？&lt;/p&gt;
&lt;p&gt;1️⃣ &lt;strong&gt;隔离加载类&lt;/strong&gt;。在某些框架内进行中间件与应用的模块隔离，把类加载器到不同的环境。比如，阿里内某容器框架通过自定义类加载器确保应用中依赖的 &lt;code&gt;jar&lt;/code&gt; 包不会影响到中间件运行时使用的 &lt;code&gt;jar&lt;/code&gt; 包。&lt;/p&gt;
&lt;p&gt;2️⃣ &lt;strong&gt;修改类加载方式&lt;/strong&gt;。类的加载模型并非强制，除了 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需的动态加载。&lt;/p&gt;
&lt;p&gt;3️⃣ &lt;strong&gt;扩展加载源&lt;/strong&gt;。比如从数据库、网络，甚至是电视机顶盒进行加载。（下面👇我们会编写一个从网络加载类的例子）&lt;/p&gt;
&lt;p&gt;4️⃣ &lt;strong&gt;防止源码泄露&lt;/strong&gt;。Java 代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。&lt;/p&gt;
&lt;h2 id=&quot;一个常规的例子&quot;&gt;一个常规的例子&lt;/h2&gt;
&lt;p&gt;实现一个自定义的类加载器比较简单：继承 ClassLoader，重写 &lt;code&gt;findClass()&lt;/code&gt; 方法，调用 &lt;code&gt;defineClass()&lt;/code&gt; 方法，就差不多行了。&lt;/p&gt;
&lt;h3 id=&quot;testerjava&quot;&gt;Tester.java&lt;/h3&gt;
&lt;p&gt;我们先来编写一个测试用的类文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Tester {

    public void say() {
        System.out.println(&quot;关注【我没有三颗心脏】，解锁更多精彩！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在同级目录下执行 &lt;code&gt;javac Tester.java&lt;/code&gt; 命令，并把编译后的 &lt;code&gt;Tester.class&lt;/code&gt; 放到指定的目录下（我这边为了方便就放在桌面上啦 &lt;code&gt;/Users/wmyskxz/Desktop&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;myclassloaderjava&quot;&gt;MyClassLoader.java&lt;/h3&gt;
&lt;p&gt;我们编写自定义 ClassLoader 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class MyClassLoader extends ClassLoader {

    private final String mLibPath;

    public MyClassLoader(String path) {
        // TODO Auto-generated constructor stub
        mLibPath = path;
    }

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        // TODO Auto-generated method stub

        String fileName = getFileName(name);

        File file = new File(mLibPath, fileName);

        try {
            FileInputStream is = new FileInputStream(file);

            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            int len = 0;
            try {
                while ((len = is.read()) != -1) {
                    bos.write(len);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            byte[] data = bos.toByteArray();
            is.close();
            bos.close();

            return defineClass(name, data, 0, data.length);

        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return super.findClass(name);
    }

    // 获取要加载的 class 文件名
    private String getFileName(String name) {
        // TODO Auto-generated method stub
        int index = name.lastIndexOf('.');
        if (index == -1) {
            return name + &quot;.class&quot;;
        } else {
            return name.substring(index + 1) + &quot;.class&quot;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在 &lt;code&gt;findClass()&lt;/code&gt; 方法中定义了查找 class 的方法，然后数据通过 &lt;code&gt;defineClass()&lt;/code&gt; 生成了 Class 对象。&lt;/p&gt;
&lt;h3 id=&quot;classloadertester-测试类&quot;&gt;ClassLoaderTester 测试类&lt;/h3&gt;
&lt;p&gt;我们需要删除刚才在项目目录创建的 &lt;code&gt;Tester.java&lt;/code&gt; 和编译后的 &lt;code&gt;Tester.class&lt;/code&gt; 文件来观察效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class ClassLoaderTester {

    public static void main(String[] args) {
        // 创建自定义的 ClassLoader 对象
        MyClassLoader myClassLoader = new MyClassLoader(&quot;/Users/wmyskxz/Desktop&quot;);
        try {
            // 加载class文件
            Class&amp;lt;?&amp;gt; c = myClassLoader.loadClass(&quot;Tester&quot;);

            if(c != null){
                try {
                    Object obj = c.newInstance();
                    Method method = c.getDeclaredMethod(&quot;say&quot;,null);
                    //通过反射调用Test类的say方法
                    method.invoke(obj, null);
                } catch (InstantiationException | IllegalAccessException
                    | NoSuchMethodException
                    | SecurityException |
                    IllegalArgumentException |
                    InvocationTargetException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行测试，正常输出：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;关注【我没有三颗心脏】，解锁更多精彩！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;加密解密类加载器&quot;&gt;加密解密类加载器&lt;/h2&gt;
&lt;p&gt;突破了 JDK 系统内置加载路径的限制之后，我们就可以编写自定义的 ClassLoader。你完全可以按照自己的意愿进行业务的定制，将 ClassLoader 玩出花样来。&lt;/p&gt;
&lt;p&gt;例如，一个加密解密的类加载器。（不涉及完整代码，我们可以来说一下思路和关键代码）&lt;/p&gt;
&lt;p&gt;首先，在编译之后的字节码文件中动一动手脚，例如，给文件每一个 &lt;code&gt;byte&lt;/code&gt; 异或一个数字 2：（这就算是模拟加密过程）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;File file = new File(path);
try {
  FileInputStream fis = new FileInputStream(file);
  FileOutputStream fos = new FileOutputStream(path+&quot;en&quot;);
  int b = 0;
  int b1 = 0;
  try {
    while((b = fis.read()) != -1){
      // 每一个 byte 异或一个数字 2
      fos.write(b ^ 2);
    }
    fos.close();
    fis.close();
  } catch (IOException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
  }
} catch (FileNotFoundException e) {
  // TODO Auto-generated catch block
  e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再在 &lt;code&gt;findClass()&lt;/code&gt; 中自己解密：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;File file = new File(mLibPath,fileName);

try {
  FileInputStream is = new FileInputStream(file);

  ByteArrayOutputStream bos = new ByteArrayOutputStream();
  int len = 0;
  byte b = 0;
  try {
    while ((len = is.read()) != -1) {
      // 将数据异或一个数字 2 进行解密
      b = (byte) (len ^ 2);
      bos.write(b);
    }
  } catch (IOException e) {
    e.printStackTrace();
  }

  byte[] data = bos.toByteArray();
  is.close();
  bos.close();

  return defineClass(name,data,0,data.length);

} catch (IOException e) {
  // TODO Auto-generated catch block
  e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;（代码几乎与上面👆一个例子等同，所以只说一下思路和完整代码）&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络类加载器&quot;&gt;网络类加载器&lt;/h2&gt;
&lt;p&gt;其实非常类似，也不做过多讲解，直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.io.ByteArrayOutputStream;  
import java.io.InputStream;  
import java.net.URL;  
  
public class NetworkClassLoader extends ClassLoader {  
  
    private String rootUrl;  
  
    public NetworkClassLoader(String rootUrl) {  
        // 指定URL  
        this.rootUrl = rootUrl;  
    }  
  
    // 获取类的字节码  
    @Override  
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {  
        byte[] classData = getClassData(name);  
        if (classData == null) {  
            throw new ClassNotFoundException();  
        } else {  
            return defineClass(name, classData, 0, classData.length);  
        }  
    }  
  
    private byte[] getClassData(String className) {  
        // 从网络上读取的类的字节  
        String path = classNameToPath(className);  
        try {  
            URL url = new URL(path);  
            InputStream ins = url.openStream();  
            ByteArrayOutputStream baos = new ByteArrayOutputStream();  
            int bufferSize = 4096;  
            byte[] buffer = new byte[bufferSize];  
            int bytesNumRead = 0;  
            // 读取类文件的字节  
            while ((bytesNumRead = ins.read(buffer)) != -1) {  
                baos.write(buffer, 0, bytesNumRead);  
            }  
            return baos.toByteArray();  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        return null;  
    }  
  
    private String classNameToPath(String className) {  
        // 得到类文件的URL  
        return rootUrl + &quot;/&quot;  
                + className.replace('.', '/') + &quot;.class&quot;;  
    }  
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;(代码来自：&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/72217806&quot;&gt;https://blog.csdn.net/justloveyou_/article/details/72217806&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;学习到这里，我们对 ClassLoader 已经不再陌生了，但是仍然有一些必要的知识点需要去掌握 &lt;em&gt;（限于篇幅和能力这里不扩展了）&lt;/em&gt;，希望您能认真阅读以下的材料：&lt;em&gt;（可能排版上面层次不齐，但内容都是有质量的，并用 ♨️ 标注了更加重点一些的内容）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1️⃣ ♨️&lt;strong&gt;能不能自己写一个类叫 &lt;code&gt;java.lang.System&lt;/code&gt; 或者 &lt;code&gt;java.lang.String&lt;/code&gt;？&lt;/strong&gt; - &lt;a href=&quot;https://blog.csdn.net/tang9140/article/details/42738433&quot;&gt;https://blog.csdn.net/tang9140/article/details/42738433&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2️⃣ 深入理解 Java 之 JVM 启动流程 - &lt;a href=&quot;https://cloud.tencent.com/developer/article/1038435&quot;&gt;https://cloud.tencent.com/developer/article/1038435&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3️⃣ ♨️&lt;strong&gt;真正理解线程上下文类加载器（多案例分析）&lt;/strong&gt; - &lt;a href=&quot;https://blog.csdn.net/yangcheng33/article/details/52631940&quot;&gt;https://blog.csdn.net/yangcheng33/article/details/52631940&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4️⃣ ♨️&lt;strong&gt;曹工杂谈：Java 类加载器还会死锁？这是什么情况？&lt;/strong&gt; - &lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/11378747.html#_label2&quot;&gt;https://www.cnblogs.com/grey-wolf/p/11378747.html#_label2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5️⃣ 谨防JDK8重复类定义造成的内存泄漏 - &lt;a href=&quot;https://segmentfault.com/a/1190000022837543&quot;&gt;https://segmentfault.com/a/1190000022837543&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7️⃣ ♨️&lt;strong&gt;Tomcat 类加载器的实现&lt;/strong&gt; - &lt;a href=&quot;https://juejin.im/post/6844903945496690695&quot;&gt;https://juejin.im/post/6844903945496690695&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8️⃣ ♨️&lt;strong&gt;Spring 中的类加载机制&lt;/strong&gt; - &lt;a href=&quot;https://www.shuzhiduo.com/A/gVdnwgAlzW/&quot;&gt;https://www.shuzhiduo.com/A/gVdnwgAlzW/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;《深入分析 Java Web 技术内幕》 | 许令波 著&lt;/li&gt;
&lt;li&gt;Java 类加载机制分析 - &lt;a href=&quot;https://www.jianshu.com/p/3615403c7c84&quot;&gt;https://www.jianshu.com/p/3615403c7c84&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Class 文件解析实战 - &lt;a href=&quot;https://juejin.im/post/6844904199617003528&quot;&gt;https://juejin.im/post/6844904199617003528&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图文兼备看懂类加载机制的各个阶段，就差你了！ - &lt;a href=&quot;https://juejin.im/post/6844904119258316814&quot;&gt;https://juejin.im/post/6844904119258316814&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java面试知识点解析（三）——JVM篇 - &lt;a href=&quot;https://www.wmyskxz.com/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/&quot;&gt;https://www.wmyskxz.com/2018/05/16/java-mian-shi-zhi-shi-dian-jie-xi-san-jvm-pian/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一看你就懂，超详细Java中的ClassLoader详解 - &lt;a href=&quot;https://blog.csdn.net/briblue/article/details/54973413&quot;&gt;https://blog.csdn.net/briblue/article/details/54973413&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;本文已收录至我的 Github 程序员成长系列 &lt;strong&gt;【More Than Java】，学习，不止 Code，欢迎 star：&lt;a href=&quot;https://github.com/wmyskxz/MoreThanJava&quot;&gt;https://github.com/wmyskxz/MoreThanJava&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;个人公众号&lt;/strong&gt; ：wmyskxz，&lt;strong&gt;个人独立域名博客&lt;/strong&gt;：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wmyskxz/img/img/common/qrcode.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非常感谢各位人才能 &lt;strong&gt;看到这里&lt;/strong&gt;，如果觉得本篇文章写得不错，觉得 &lt;strong&gt;「我没有三颗心脏」有点东西&lt;/strong&gt; 的话，&lt;strong&gt;求点赞，求关注，求分享，求留言！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
</description>
<pubDate>Fri, 28 Aug 2020 00:19:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>「MoreThanJava」 宣扬的是 「学习，不止 CODE」。 如果觉得 「不错」 的朋友，欢迎 「关注 + 留言 + 分享」，文末有完整的获取链接，您的支持是我前进的最大的动力！ 前言 Clas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wmyskxz/p/13575224.html</dc:identifier>
</item>
<item>
<title>快醒醒，C# 9 中又来了一堆关键词 init,record,with - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13575171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13575171.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;.NET5 终于在 2020-08-25 也就是大前天发布了第八个预览版，这么多的预览版搞得我都麻木了，接踵而来的就是更多的新特性加入到了 C# 9 中，既然还想呆在这条船上，得继续硬着头皮学习哈，这一篇跟大家聊聊新增的几个关键词。&lt;/p&gt;
&lt;h2 id=&quot;二：新增关键词&quot;&gt;二：新增关键词&lt;/h2&gt;
&lt;h3 id=&quot;1-init&quot;&gt;1. init&lt;/h3&gt;
&lt;p&gt;出来一个新语法糖，首先要做的就是去揭它的老底，这样可以方便推测它的应用场景，为了方便表述，我先上一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    public class Person
    {
        public string Name { get; init; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看有点懵逼，没关系，先用 ILSpy 看一下，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071500305-102270307.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图就已经很清晰的解释了，原来 &lt;code&gt;init&lt;/code&gt; 就是自动生成了一个对 私有只读字段 的封装，对于 readonly 相信大家已经轻车熟路了，它的初始化只有两种方式：声明时和构造函数中，但从 C# 9 开始就多了一个属性赋值方式，也就是说现在有三种赋值方式了，还原代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    public class Person
    {
        private readonly string name;

        public string Name
        {
            get =&amp;gt; name;

            init
            {
                name = value;
            }
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式要是换作以前肯定是报错的，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071500579-427523929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一点要注意的是编译器还做了一个特殊限制，准你在 &lt;code&gt;类初始化器&lt;/code&gt; 中使用，不准你单独拿出来赋值，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071500885-162995774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以总的来说, &lt;code&gt;init&lt;/code&gt; 的作用就是多了一种让你初始化 只读字段 的方式，仅此而已罢了。&lt;/p&gt;
&lt;h3 id=&quot;2-record&quot;&gt;2. record&lt;/h3&gt;
&lt;p&gt;为了方便演示，我先上一段代码，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    public record Person
    {
        public string Name { get; set; }

        public int Age { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来挺 🐂👃 的，现在除了 class，struct , enum, delegate，又来了一个 record，俺们的 C# 是越来越强大啦。&lt;/p&gt;
&lt;p&gt;还是老规矩，用ILspy看看底层生成了个啥，如下代码所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public class Person : IEquatable&amp;lt;Person&amp;gt;
{
        protected virtual Type EqualityContract =&amp;gt; typeof(Person);

        public string Name
        {
                get;
                set;
        }

        public int Age
        {
                get;
                set;
        }

        public virtual Person &amp;lt;&amp;gt;Clone()
        {
                return new Person(this);
        }

        public override int GetHashCode()
        {
                return (EqualityComparer&amp;lt;Type&amp;gt;.Default.GetHashCode(EqualityContract) * -1521134295 + EqualityComparer&amp;lt;string&amp;gt;.Default.GetHashCode(Name)) * -1521134295 + EqualityComparer&amp;lt;int&amp;gt;.Default.GetHashCode(Age);
        }

        public override bool Equals(object? obj)
        {
                return Equals(obj as Person);
        }

        public virtual bool Equals(Person? P_0)
        {
                return P_0 != null &amp;amp;&amp;amp; (object)EqualityContract == P_0!.EqualityContract &amp;amp;&amp;amp; EqualityComparer&amp;lt;string&amp;gt;.Default.Equals(Name, P_0!.Name) &amp;amp;&amp;amp; EqualityComparer&amp;lt;int&amp;gt;.Default.Equals(Age, P_0!.Age);
        }

        protected Person(Person P_0)
        {
                Name = P_0.Name;
                Age = P_0.Age;
        }

        public Person()
        {
        }

        bool IEquatable&amp;lt;Person&amp;gt;.Equals(Person other)
        {
                return Equals(other);
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 ILspy 生成出来的代码来看，可以发现两点信息：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;record 玩的也是 class，重写了 object 中的一些方法 GetHashCode, Equals 等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按类中的字段逐一比较判断类的相等性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到根据字段判断类的相等性，不知道大家可有似曾相识的感觉? ,反正让我想起了匿名类型，因为它生成的 C# 代码和 record 如出一辙，不信的话，我演示给你看呗。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;var person = new { Name = &quot;jack&quot;, Age = 20 };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071501065-117547690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来看一看是否真的是按照逐一字段比较，代码如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var person = new Person() { Name = &quot;jack&quot;, Age = 20 };
            var person2 = new Person() { Name = &quot;jack&quot;, Age = 20 };

            var b = person.Equals(person2);
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071501302-304257007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了这么多，我想你肯定有一些疑问：&lt;/p&gt;
&lt;h4 id=&quot;1-为啥要实现-iequatable--接口&quot;&gt;1) 为啥要实现 IEquatable 接口&lt;/h4&gt;
&lt;p&gt;这是因为在当 Person 是 泛型 T 的时候避免走了默认的 &lt;code&gt;public override bool Equals(object? obj)&lt;/code&gt;，这是一个双装箱操作，性能太低效，深入研究可看我的博文：&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/12996361.html&quot;&gt;https://www.cnblogs.com/huangxincheng/p/12996361.html&lt;/a&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;2-为啥有-equals-没有-&quot;&gt;2) 为啥有 equals 没有 ==&lt;/h4&gt;
&lt;p&gt;这个问题问得好，谁知道 C# 开发团队怎么想的，按照目前现状， 用 == 和 equals 比较两个对象，结果肯定是不一样的，我想你肯定能理解，毕竟一个是引用一个是按字段比较，这就比较坑爹了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071501538-310544047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-clone-方法有何作用&quot;&gt;3) &amp;lt;&amp;gt;Clone() 方法有何作用&lt;/h4&gt;
&lt;p&gt;从方法体来看，这个方法用于做 浅copy 用的，但方法名前面有一对 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，说明是防你直接调用的，那问题来了，怎么调用呢？ 这就涉及一个新的语法糖。&lt;/p&gt;
&lt;h3 id=&quot;3-with&quot;&gt;3. with&lt;/h3&gt;
&lt;p&gt;这个语法糖也挺🐂👃的，就是为了助你调用 record 的 &lt;code&gt;&amp;lt;&amp;gt;clone&lt;/code&gt; 方法，不信的话，上代码呗。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var person = new Person() { Name = &quot;jack&quot;, Age = 20 };

            var person2 = person with { };
        }       

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后看一下 IL 反编译的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202008/214741-20200828071502028-665400018.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过我也有一个疑问，为啥要防着我直接调用 &lt;code&gt;Clone&lt;/code&gt; 方法呢？ 新东西，也不知道应用场景，谁搞的清楚哈~~~ 😂😂😂&lt;/p&gt;
&lt;h2 id=&quot;四：-总结&quot;&gt;四： 总结&lt;/h2&gt;
&lt;p&gt;总的来说C#是越来越新颖了，也一直在践行 jquery 的口号： write less,do more。 有一点要提醒的是，语法糖多了，一定要知道其实它是个啥，不要常年混在编译器之上迷失了方向😄😄😄&lt;/p&gt;
&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Thu, 27 Aug 2020 23:15:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 .NET5 终于在 2020-08-25 也就是大前天发布了第八个预览版，这么多的预览版搞得我都麻木了，接踵而来的就是更多的新特性加入到了 C# 9 中，既然还想呆在这条船上，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13575171.html</dc:identifier>
</item>
<item>
<title>用Python的Pandas和Matplotlib绘制股票KDJ指标线 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/13575164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/13575164.html</guid>
<description>&lt;p&gt;  我最近出了一本书，《基于股票大数据分析的Python入门实战 视频教学版》，京东链接：&lt;a href=&quot;https://item.jd.com/69241653952.html&quot;&gt;https://item.jd.com/69241653952.html&lt;/a&gt;，在其中给出了MACD，KDJ等指标图的绘制方法。这里将根据KDJ的算法，计算并绘制KDJ指标线。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1  KDJ指标的计算过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    KDJ指标也叫随机指标，是由乔治·蓝恩博士（George Lane）最早提出的。该指标集中包含了强弱指标、动量概念和移动平均线的优点，可以用来衡量股价脱离正常价格范围的偏离程度。&lt;/p&gt;
&lt;p&gt;    KDJ指标的计算过程是，首先获取指定周期（一般是9天）内出现过的股票最高价、最低价和最后一个交易日的收盘价，随后通过它们三者间的比例关系来算出未成熟&lt;a title=&quot;未成熟随机值&quot; href=&quot;http://wiki.mbalib.com/wiki/%E6%9C%AA%E6%88%90%E7%86%9F%E9%9A%8F%E6%9C%BA%E5%80%BC&quot;&gt;随机值&lt;/a&gt;RSV，并在此基础上再用平滑移动平均线的方式来计算K、D和J值。计算完成后，把KDJ的值绘成曲线图，以此来预判股票走势，具体的算法如下所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第一步：&lt;/strong&gt;计算周期内（n日、n周等，n一般是9）的RSV值，RSV也叫未成熟随机指标值，是计算K值、D值和J值的基础。以n日周期计算单位为例，计算公式如下所示。&lt;/p&gt;
&lt;p&gt;    n日RSV =（Cn－Ln）/（Hn－Ln）× 100&lt;/p&gt;
&lt;p&gt;    其中，Cn是第n日（一般是最后一日）的收盘价，Ln是n日范围内的最低价，Hn是n日范围内的最高价，根据上述公式可知，RSV值的取值范围是1到100。如果要计算n周的 RSV值，则Cn还是最后一日的收盘价，但Ln和Hn则是n周内的最低价和最高价。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第二步：&lt;/strong&gt;根据RSV计算K和D值，方法如下。&lt;/p&gt;
&lt;p&gt;    当日K值 = 2/3 × 前一日K值 ＋ 1/3 × 当日的RSV值&lt;/p&gt;
&lt;p&gt;    当日D值 = 2/3 × 前一日D值 ＋ 1/3 × 当日K值&lt;/p&gt;
&lt;p&gt;    在计算过程中，如果没有前一日K 值或D值，则可以用数字50来代替。&lt;/p&gt;
&lt;p&gt;    在实际使用过程中，一般是以9日为周期来计算KD线，根据上述公式，首先是计算出最近9日的RSV值，即未成熟随机值，计算公式是9日RSV = （C－L9）÷（H9－L9）× 100。其中各项参数含义在步骤一中已经提到，其次再按本步骤所示计算当日的K和D值。&lt;/p&gt;
&lt;p&gt;    需要说明的是，上式中的平滑因子2/3和1/3是可以更改的，不过在股市交易实践中，这两个值已经被默认设置为2/3和1/3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第三步：&lt;/strong&gt;计算J值。J指标的计算公式为：J = 3×K - 2×D。从使用角度来看，J的实质是反映K值和D值的乖离程度，它的范围上可超过100，下可低于0。&lt;/p&gt;
&lt;p&gt;最早的KDJ指标只有K线和D线两条线，那个时候也被称为KD指标，随着分析技术的发展，KD指标逐渐演变成KDJ指标，引入J指标后，能提高KDJ指标预判行情的能力。&lt;/p&gt;
&lt;p&gt;    在按上述三个步骤计算出每天的K、D和J三个值之后，把它们连接起来，就可以看到KDJ指标线了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 绘制静态的KDJ指标线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    根据上节给出的KDJ算法，在下面的drawKDJ.py范例程序中将绘制股票“金石资源”（股票代码为603505）从2018年9月到2019年5月这段时间内的KDJ走势图。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
 !/usr/bin/&lt;span&gt;env python
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;    import matplotlib.pyplot &lt;span&gt;as&lt;/span&gt;&lt;span&gt; plt
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;    import pandas &lt;span&gt;as&lt;/span&gt;&lt;span&gt; pd
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;    # 计算KDJ
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;    def calKDJ(df):
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;        df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinLow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].rolling(&lt;span&gt;9&lt;/span&gt;, min_periods=&lt;span&gt;9&lt;/span&gt;&lt;span&gt;).min()
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;        # 填充NaN数据
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;        df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinLow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fillna(value = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].expanding().min(), inplace =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;        df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MaxHigh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;High&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].rolling(&lt;span&gt;9&lt;/span&gt;, min_periods=&lt;span&gt;9&lt;/span&gt;&lt;span&gt;).max()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MaxHigh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fillna(value = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;High&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].expanding().max(), inplace =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RSV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] - df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinLow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) / (df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MaxHigh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] - df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MinLow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) * &lt;span&gt;100&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;&lt;span&gt;        # 通过for循环依次计算每个交易日的KDJ值
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(df)):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:     # 第一天
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;50&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;50&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;            &lt;span&gt;if&lt;/span&gt; i&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=df.ix[i-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]*&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;*df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RSV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=df.ix[i-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]*&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;*df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;            df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;3&lt;/span&gt;*df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]-&lt;span&gt;2&lt;/span&gt;*df.ix[i,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; df
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    从第6行到第22行程序语句定义的calKDJ方法中，将根据输入参数df，计算指定时间范围内的KDJ值。&lt;/p&gt;
&lt;p&gt;    具体的计算步骤是，在第8行中通过df['Low'].rolling(9, min_periods=9).min()，把每一行（即每个交易日）的 'MinLow' 属性值设置为9天内收盘价（Low）的最小值。&lt;/p&gt;
&lt;p&gt;    如果只执行这句，第1到第8个交易日的MinLow属性值将会是NaN，所以要通过第9行的程序代码，把这些交易日的MinLow属性值设置为9天内收盘价（Low）的最小值。同理，通过第10行的程序代码，把每个交易日的 'MaxHigh' 属性值设置为9天内的最高价，同样通过第11行的fillna方法，填充前8天的 'MaxHigh' 属性值。随后在第12行中根据算法计算每个交易日的RSV值。&lt;/p&gt;
&lt;p&gt;    在算完RSV值后，通过第14行的for循环，依次遍历每个交易日，在遍历时根据KDJ的算法分别计算出每个交易日对应的KDJ值。&lt;/p&gt;
&lt;p&gt;    请注意，如果是第1个交易日，则在第16行和第17行的程序代码中把 K值和D值设置为默认的50，如果不是第1交易日，则通过第19行和第20行的算法计算K值和D值。计算完K和D的值以后，再通过第21行的程序代码计算出每个交易日的J值。&lt;/p&gt;
&lt;p&gt;    从上述代码中，可以看到关于DataFrame对象的三个操作技巧：&lt;/p&gt;
&lt;p&gt;    第一，如第9行所示，如果要把修改后的数据写回到DataFrame中，必须加上inplace = True的参数；&lt;/p&gt;
&lt;p&gt;    第二，在第12行中，df['Close']等变量值是以列为单位，也就是说，在DataFrame中，可以直接以列为单位进行操作；&lt;/p&gt;
&lt;p&gt;    第三，在第16行的代码df.ix[i,'K']=50，这里用到的是ix通过索引值和标签值来访问对象，而实现类似功能的loc和iloc方法只能通过索引值来访问。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 绘制KDJ线
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;    def drawKDJ():
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;        df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/stockData/ch8/6035052018-09-012019-05-31.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;        stockDataFrame =&lt;span&gt; calKDJ(df)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt;        print(stockDataFrame)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;        # 开始绘图
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;        plt.figure()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;        stockDataFrame[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].plot(color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;        stockDataFrame[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].plot(color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;        stockDataFrame[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].plot(color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;purple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;        plt.legend(loc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;best&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)         # 绘制图例
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;        # 设置x轴坐标的标签和旋转角度    major_index=stockDataFrame.index[stockDataFrame.index%&lt;span&gt;10&lt;/span&gt;==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;    major_xtics=stockDataFrame[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][stockDataFrame.index%&lt;span&gt;10&lt;/span&gt;==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;        plt.xticks(major_index,major_xtics)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;        plt.setp(plt.gca().get_xticklabels(), rotation=&lt;span&gt;30&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;        # 带网格线，且设置了网格样式
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;        plt.grid(linestyle=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;        plt.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;金石资源的KDJ图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;        plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&lt;span&gt;        plt.show()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;&lt;span&gt;    # 调用方法
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;    drawKDJ()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第24行的drawKDJ方法中实现了绘制KDJ的操作。其中的关键步骤是，通过第25行的程序代码从指定的csv文件中读取股票交易数据，随后在第30行到第32行的程序代码中，调用plot方法分别用三种不同的颜色绘制了KDJ线，因为在绘制时通过label参数设置了标签，所以可以执行第33行的程序代码来绘制图例。&lt;/p&gt;
&lt;p&gt;    在第34行到第37行的代码中设置了x轴的文字标签和旋转角度，这部分代码与之前绘制MACD指标线的代码很相似，为了不在x轴上过多地显示日期，于是用stockDataFrame.index%10 == 0的方式，只显示索引值是10的倍数的日期。&lt;/p&gt;
&lt;p&gt;    在第44行调用了drawKDJ方法将KDJ绘制出来。运行这个范例程序之后，即可看到如图所示的结果，其中KDJ三根曲线分别用蓝色、绿色和紫色绘制出来（因为本书采用黑白印刷而看不出彩色，请读者在自己的计算机上运行这个范例程序）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226172/202008/1226172-20200828070855063-787059887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    下图是从股票软件中得到的股票“金石资源”在同时间段内的KDJ走势图，两者的变化趋势基本一致。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/1226172/202008/1226172-20200828070923843-107658905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;本文可以转载，转载时请全文转载，别有删节，并用链接的形式给出原文链接。否则的话，可能会遇到出版社的维权。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226172/202008/1226172-20200828071133055-1830235744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;     文本相关链接:&lt;/p&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_1&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/13534075.html&quot;&gt;用Python的Pandas和Matplotlib绘制股票唐奇安通道，布林带通道和鳄鱼组线 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_2&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/13489328.html&quot;&gt;用Python爬取股票数据，绘制K线和均线并用机器学习预测股价（来自我出的书） &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_3&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/13180774.html&quot;&gt;用Python语言绘制股市OBV指标效果 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;span class=&quot;post-view-count&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_4&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/13181181.html&quot;&gt;程序员如何高效学Python，如何高效用Python挣钱 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_5&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/12921960.html&quot;&gt;用matplotlib和pandas绘制股票MACD指标图，并验证化交易策略 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_6&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/12892692.html&quot;&gt;向大家介绍我的新书：《基于股票大数据分析的Python入门实战》&lt;/a&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_7&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11717998.html&quot;&gt;通过机器学习的线性回归算法预测股票走势（用Python实现） &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;span class=&quot;post-view-count&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_8&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11660792.html&quot;&gt;在我的新书里，尝试着用股票案例讲述Python爬虫大数据可视化等知识 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_9&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11463091.html&quot;&gt;以股票RSI指标为例，学习Python发送邮件功能（含RSI指标确定卖点策略） &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_10&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11350683.html&quot;&gt;以预测股票涨跌案例入门基于SVM的机器学习 &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_11&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11162005.html&quot;&gt;用python的matplotlib和numpy库绘制股票K线均线和成交量的整合效果（含量化验证交易策略代码） &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;PostList&quot;&gt;
&lt;div class=&quot;postTitl2&quot;&gt;&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_12&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/11014215.html&quot;&gt;用python的matplotlib和numpy库绘制股票K线均线的整合效果（含从网络接口爬取数据和验证交易策略代码） &lt;/a&gt;&lt;span class=&quot;postDesc2&quot;&gt;&lt;span class=&quot;post-view-count&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 27 Aug 2020 23:12:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>我最近出了一本书，《基于股票大数据分析的Python入门实战 视频教学版》，京东链接：https://item.jd.com/69241653952.html，在其中给出了MACD，KDJ等指标图的绘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaArchitect/p/13575164.html</dc:identifier>
</item>
<item>
<title>.NET ORM 导航属性【到底】可以解决什么问题？ - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/13575053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/13575053.html</guid>
<description>&lt;h2 id=&quot;写在开头&quot;&gt;写在开头&lt;/h2&gt;
&lt;p&gt;从最早期入门时的单表操作，&lt;/p&gt;
&lt;p&gt;到后来接触了 left join、right join、inner join 查询，&lt;/p&gt;
&lt;p&gt;因为经费有限，需要不断在多表查询中折腾解决实际需求，不知道是否有过这样的经历？&lt;/p&gt;
&lt;p&gt;本文从实际开发需求讲解导航属性（ManyToOne、OneToMany、ManyToMany）的设计思路，和到底解决了什么问题。提示：以下示例代码使用了 FreeSql 语法，和一些伪代码。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;入戏准备&quot;&gt;入戏准备&lt;/h2&gt;
&lt;p&gt;FreeSql 是 .Net ORM，能支持 .NetFramework4.0+、.NetCore、Xamarin、XAUI、Blazor、以及还有说不出来的运行平台，因为代码绿色无依赖，支持新平台非常简单。目前单元测试数量：5000+，Nuget下载数量：180K+，源码几乎每天都有提交。值得高兴的是 FreeSql 加入了 ncc 开源社区：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，加入组织之后社区责任感更大，需要更努力做好品质，为开源社区出一份力。&lt;/p&gt;
&lt;p&gt;QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;为什么要重复造轮子？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202005/31407-20200525013907903-1470982538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;FreeSql 主要优势在于易用性上，基本是开箱即用，在不同数据库之间切换兼容性比较好。作者花了大量的时间精力在这个项目，肯请您花半小时了解下项目，谢谢。功能特性如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;支持 CodeFirst 对比结构变化迁移；&lt;/li&gt;
&lt;li&gt;支持 DbFirst 从数据库导入实体类；&lt;/li&gt;
&lt;li&gt;支持 丰富的表达式函数，自定义解析；&lt;/li&gt;
&lt;li&gt;支持 批量添加、批量更新、BulkCopy；&lt;/li&gt;
&lt;li&gt;支持 导航属性，贪婪加载、延时加载、级联保存；&lt;/li&gt;
&lt;li&gt;支持 读写分离、分表分库，租户设计；&lt;/li&gt;
&lt;li&gt;支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/达梦/神通/人大金仓/MsAccess；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FreeSql 使用非常简单，只需要定义一个 IFreeSql 对象即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static IFreeSql fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.MySql, connectionString)
    .UseAutoSyncStructure(true) //自动同步实体结构到数据库
    .Build(); //请务必定义成 Singleton 单例模式
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;manytoone-多对一&quot;&gt;ManyToOne 多对一&lt;/h2&gt;
&lt;p&gt;left join、right join、inner join 从表的外键看来，主要是针对一对一、多对一的查询，比如 Topic、Type 两个表，一个 Topic 只能属于一个 Type：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select
topic.*, type.name
from topic
inner join type on type.id = topic.typeid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询 topic 把 type.name 一起返回，一个 type 可以对应 N 个 topic，对于 topic 来讲是 N对1，所以我命名为 ManyToOne&lt;/p&gt;
&lt;p&gt;在 c# 中使用实体查询的时候，N对1 场景查询容易，但是接收对象不方便，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic, Type&amp;gt;()
  .LeftJoin((a,b) =&amp;gt; a.typeid == b.Id)
  .ToList((a,b) =&amp;gt; new { a, b })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样只能返回匿名类型，除非自己再去建一个 TopicDto，但是查询场景真的太多了，几乎无法穷举 TopicDto，随着需求的变化，后面这个 Dto 会很泛滥越来越多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828024634879-2077957164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是聪明的人类想到了导航属性，在 Topic 实体内增加 Type 属性接收返回的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;()
   .LeftJoin((a,b) =&amp;gt; a.Type.id == a.typeid)
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回数据后，可以使用 [0].Type.name 得到分类名称。&lt;/p&gt;
&lt;p&gt;经过一段时间的使用，发现 InnerJoin 的条件总是在重复编写，每次都要用大脑回忆这个条件（论头发怎么掉光的）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828024750137-1027850166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进化一次之后，我们把 join 的条件做成了配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Topic
{
    public int typeid { get; set; }
    [Navigate(nameof(typeid))]
    public Type Type { get; set; }
}
class Type
{
    public int id { get; set; }
    public string name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询的时候变成了这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;()
   .Include(a =&amp;gt; a.Type)
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回数据后，同样可以使用 [0].Type.name 得到分类名称。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;[Navigate(nameof(typeid))] 理解成，Topic.typeid 与 Type.id 关联，这里省略了 Type.id 的配置，因为 Type.id 是主键（已知条件无须配置），从而达到简化配置的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;.Include(a =&amp;gt; a.Type) 查询的时候会自动转化为：.LeftJoin(a =&amp;gt; a.Type.id == a.typeid)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;思考：ToList 默认返回 topic.* 和 type.* 不对，因为当 Topic 下面的导航属性有很多的时候，每次都返回所有导航属性？&lt;/p&gt;
&lt;p&gt;于是：ToList 的时候只会返回 Include 过的，或者使用过的 N对1 导航属性字段。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fsql.Select&amp;lt;Topic&amp;gt;().ToList(); 返回 topic.*&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fsql.Select&amp;lt;Topic&amp;gt;().Include(a =&amp;gt; a.Type).ToList(); 返回 topic.* 和 type.*&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;fsql.Select&amp;lt;Topic&amp;gt;().Where(a =&amp;gt; a.Type.name == &quot;c#&quot;).ToList(); 返回 topic.* 和 type.*，此时不需要显式使用 Include(a =&amp;gt; a.Type)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;fsql.Select().ToList(a =&amp;gt; new { Topic = a, TypeName = a.Type.name }); 返回 topic.* 和 type.name&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;有了这些机制，各种复杂的 N对1，就很好查询了，比如这样的查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Tag&amp;gt;().Where(a =&amp;gt; a.Parent.Parent.name == &quot;粤语&quot;).ToList();
//该代码产生三个 tag 表 left join 查询。

class Tag {
  public int id { get; set; }
  public string name { get; set; }
  
  public int? parentid { get; set; }
  public Tag Parent { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;是不是比自己使用 left join/inner join/right join 方便多了？&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;onetoone-一对一&quot;&gt;OneToOne 一对一&lt;/h2&gt;
&lt;p&gt;一对一 和 N对1 解决目的是一样的，都是为了简化多表 join 查询。&lt;/p&gt;
&lt;p&gt;比如 order, order_detail 两个表，一对一场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;order&amp;gt;().Include(a =&amp;gt; a.detail).ToList();

fsql.Select&amp;lt;order_detail&amp;gt;().Include(a =&amp;gt; a.order).ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询的数据一样的，只是返回的 c# 类型不一样。&lt;/p&gt;
&lt;p&gt;一对一，只是配置上有点不同，使用方式跟 N对1 一样。&lt;/p&gt;
&lt;p&gt;一对一，要求两边都存在目标实体属性，并且两边都是使用主键做 Navigate。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class order
{
    public int id { get; set; }
    [Navigate(nameof(id))]
    public order_detail detail { get; set; }
}
class order_detail
{
    public int orderid { get; set; }
    [Navigate(nameof(orderid))]
    public order order { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828032759646-1618203847.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;onetomany-一对多&quot;&gt;OneToMany 一对多&lt;/h2&gt;
&lt;p&gt;1对N，和 N对1 是反过来看&lt;/p&gt;
&lt;p&gt;topic 相对于 type 是 N对1&lt;/p&gt;
&lt;p&gt;type 相对于 topic 是 1对N&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828025810358-1865590922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们在 Type 实体类中可以定义 List&amp;lt;Topic&amp;gt; Topics { get; set; } 导航属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Type
{
    public int id { get; set; }
    public List&amp;lt;Topic&amp;gt; Topics { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1对N 导航属性的主要优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询 Type 的时候可以把 topic 一起查询出来，并且还是用 Type 作为返回类型。&lt;/li&gt;
&lt;li&gt;添加 Type 的时候，把 Topics 一起添加&lt;/li&gt;
&lt;li&gt;更新 Type 的时候，把 Topics 一起更新&lt;/li&gt;
&lt;li&gt;删除 Type 的时候，没动作（ ef 那边是用数据库外键功能删除子表记录的）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;onetomany-级联查询&quot;&gt;OneToMany 级联查询&lt;/h3&gt;
&lt;p&gt;把 Type.name 为 c# java php，以及它们的 topic 查询出来：&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Type&amp;gt;()
   .IncludeMany(a =&amp;gt; a.Topics)
   .Where(a =&amp;gt; new { &quot;c#&quot;, &quot;java&quot;, &quot;php&quot; }.Contains(a.name))
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
{
  name : &quot;c#&quot;,
  Topics: [ 文章列表 ]
}
...
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法是从 Type 方向查询的，非常符合使用方的数据格式要求。&lt;/p&gt;
&lt;p&gt;最终是分两次 SQL 查询数据回来的，大概是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from type where name in ('c#', 'java', 'php')
select * from topics where typeid in (上一条SQL返回的id)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：从 Topic 方向也可以查询出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;()
   .Where(a =&amp;gt; new { &quot;c#&quot;, &quot;java&quot;, &quot;php&quot; }.Contains(a.Type.name)
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一次 SQL 查询返回所有数据的，大概是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from topic
left join type on type.id = topic.typeid
where type.name in ('c#', 'java', 'php')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828030137134-994318919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释：方法一 IncludeMany 虽然是分开两次查询的，但是 IO 性能远高于 方法二。方法二查询简单数据还行，复杂一点很容易产生大量重复 IO 数据。并且方法二返回的数据结构 List&amp;lt;Topic&amp;gt;，一般不符合使用方要求。&lt;/p&gt;
&lt;p&gt;IncludeMany 第二次查询 topic 的时候，如何把记录分配到 c# java php 对应的 Type.Topics 中？&lt;/p&gt;
&lt;p&gt;所以这个时候，配置一下导航关系就行了。&lt;/p&gt;
&lt;p&gt;N对1，这样配置的（从自己身上找一个字段，与目标类型主键关联）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Topic
{
    public int typeid { get; set; }
    [Navigate(nameof(typeid))]
    public Type Type { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1对N，这样配置的（从目标类型上找字段，与自己的主键关联）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Type
{
    public int id { get; set; }
    [Navigate(nameof(topic.typeid))]
    public List&amp;lt;Topic&amp;gt; Topics { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举一反三：&lt;/p&gt;
&lt;p&gt;IncludeMany 级联查询，在实际开发中，还可以 IncludeMany(a =&amp;gt; a.Topics, then =&amp;gt; then.IncludeMany(b =&amp;gt; b.Comments))&lt;/p&gt;
&lt;p&gt;假设，还需要把 topic 对应的 comments 也查询出来。最多会产生三条SQL查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from type where name in ('c#', 'java', 'php')
select * from topic where typeid in (上一条SQL返回的id)
select * from comment where topicid in (上一条SQL返回的id)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;思考：这样级联查询其实是有缺点的，比如 c# 下面有1000篇文章，那不是都返回了？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;IncludeMany(a =&amp;gt; a.Topics.Take(10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就能解决每个分类只返回 10 条数据了，这个功能 ef/efcore 目前做不到，直到 efcore 5.0 才支持，这可能是很多人忌讳 ef 导航属性的原因之一吧。几个月前我测试了 efcore 5.0 sqlite 该功能是报错的，也许只支持 sqlserver。而 FreeSql 没有数据库种类限制，还是那句话：都是亲儿子！&lt;/p&gt;
&lt;p&gt;关于 IncludeMany 还有更多功能请到 github wiki 文档中了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828032759646-1618203847.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;onetomany-级联保存&quot;&gt;OneToMany 级联保存&lt;/h3&gt;
&lt;p&gt;实践中发现，N对1 不适合做级联保存。保存 Topic 的时候把 Type 信息也保存？我个人认为自下向上保存的功能太不可控了，FreeSql 目前不支持自下向上保存。&lt;/p&gt;
&lt;p&gt;FreeSql 支持的级联保存，是自上向下。例如保存 Type 的时候，也同时能保存他的 Topic。&lt;/p&gt;
&lt;p&gt;级联保存，建议用在不太重要的功能，或者测试数据添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var repo = fsql.GetRepository&amp;lt;Type&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Type
{
  name = &quot;c#&quot;,
  Topics = new List&amp;lt;Topic&amp;gt;(new[] {
    new Topic
    {
        ...
    }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先添加 Type，如果他是自增，拿到自增值，向下赋给 Topics 再插入 topic。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;manytomany-多对多&quot;&gt;ManyToMany 多对多&lt;/h2&gt;
&lt;p&gt;多对多是很常见的一种设计，如：Topic, Tag, TopicTag&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Topic
{
    public int id { get; set; }
    public string title { get; set; }

    [Navigate(ManyToMany = typeof(TopicTag))]
    public List&amp;lt;Tag&amp;gt; Tags { get; set; }
}
public Tag
{
    public int id { get; set; }
    public string name { get; set; }

    [Navigate(ManyToMany = typeof(TopicTag))]
    public List&amp;lt;Topic&amp;gt; Topics { get; set; }
}
public TopicTag
{
    public int topicid { get; set; }
    public int tagid { get; set; }

    [Navigate(nameof(topicid))]
    public Topic Topic { get; set; }
    [Navigate(nameof(tagid))]
    public Tag Tag { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看着觉得复杂？？看完后面查询多么简单的时候，真的什么都值了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;N对N 导航属性的主要优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询 Topic 的时候可以把 Tag 一起查询出来，并且还是用 Topic 作为返回类型。&lt;/li&gt;
&lt;li&gt;添加 Topic 的时候，把 Tags 一起添加&lt;/li&gt;
&lt;li&gt;更新 Topic 的时候，把 Tags 一起更新&lt;/li&gt;
&lt;li&gt;删除 Topic 的时候，没动作（ ef 那边是用数据库外键功能删除子表记录的）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;manytomany-级联查询&quot;&gt;ManyToMany 级联查询&lt;/h3&gt;
&lt;p&gt;把 Tag.name 为 c# java php，以及它们的 topic 查询出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Tag&amp;gt;()
   .IncludeMany(a =&amp;gt; a.Topics)
   .Where(a =&amp;gt; new { &quot;c#&quot;, &quot;java&quot;, &quot;php&quot; }.Contains(a.name))
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
{
  name : &quot;c#&quot;,
  Topics: [ 文章列表 ]
}
...
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终是分两次 SQL 查询数据回来的，大概是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from tag where name in ('c#', 'java', 'php')
select * from topic where id in (select topicid from topictag where tagid in(上一条SQL返回的id))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 Tag.name = &quot;c#&quot; 下面的 Topic 记录太多，只想返回 top 10：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;.IncludeMany(a =&amp;gt; a.Topics.Take(10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以反过来查，把 Topic.Type.name 为 c# java php 的 topic，以及它们的 Tag 查询出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;()
   .IncludeMany(a =&amp;gt; a.Tags)
   .Where(a =&amp;gt; new { &quot;c#&quot;, &quot;java&quot;, &quot;php&quot; }.Contains(a.Type.name))
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
{
  title : &quot;FreeSql 1.8.1 正式发布&quot;,
  Type: { name: &quot;c#&quot; }
  Tags: [ 标签列表 ]
}
...
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;N对N 级联查询，跟 1对N 一样，都是用 IncludeMany，N对N IncludeMany 也可以继续向下 then。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询 Tag.name = &quot;c#&quot; 的所有 topic：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;fsql.Select&amp;lt;Topic&amp;gt;()
   .Where(a =&amp;gt; a.Tags.AsSelect().Any(b =&amp;gt; b.name = &quot;c#&quot;))
   .ToList();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;产生的 SQL 大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from topic
where id in ( 
    select topicid from topictag 
    where tagid in ( select id from tag where name = 'c#' ) 
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;manytomany-级联保存&quot;&gt;ManyToMany 级联保存&lt;/h3&gt;
&lt;p&gt;级联保存，建议用在不太重要的功能，或者测试数据添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var repo = fsql.GetRepository&amp;lt;Topic&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Topic
{
  title = &quot;FreeSql 1.8.1 正式发布&quot;,
  Tags = new List&amp;lt;Tag&amp;gt;(new[] {
    new Tag { name = &quot;c#&quot; }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入 topic，再判断 Tag 是否存在（如果不存在则插入 tag）。&lt;/p&gt;
&lt;p&gt;得到 topic.id 和 tag.id 再插入 TopicTag。&lt;/p&gt;
&lt;p&gt;另外提供的方法 repo.SaveMany(topic实体, &quot;Tags&quot;) 完整保存 TopicTag 数据。比如当 topic实体.Tags 属性为 Empty 时，删除 topic实体 存在于 TopicTag 所有表数据。&lt;/p&gt;
&lt;p&gt;SaveMany机制：完整保存，对比 TopicTag 表已存在的数据，计算出添加、修改、删除执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828032759646-1618203847.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;父子关系&quot;&gt;父子关系&lt;/h2&gt;
&lt;p&gt;父子关系，其实是 ManyToOne、OneToMany 的综合体，自己指向自己，常用于树形结构表设计。&lt;/p&gt;
&lt;p&gt;父子关系，除了能使用 ManyToOne、OneToMany 的使用方法外，还提供了 CTE递归查询、内存递归组装数据 功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828030619929-1935730275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Area
{
  [Column(IsPrimary = true)]
  public string Code { get; set; }

  public string Name { get; set; }
  public string ParentCode { get; set; }

  [Navigate(nameof(ParentCode))]
  public Area Parent { get; set; }
  [Navigate(nameof(ParentCode))]
  public List&amp;lt;Area&amp;gt; Childs { get; set; }
}

var repo = fsql.GetRepository&amp;lt;Area&amp;gt;();
repo.DbContextOptions.EnableAddOrUpdateNavigateList = true;
repo.DbContextOptions.NoneParameter = true;
repo.Insert(new Area
{
  Code = &quot;100000&quot;,
  Name = &quot;中国&quot;,
  Childs = new List&amp;lt;Area&amp;gt;(new[] {
    new Area
    {
      Code = &quot;110000&quot;,
      Name = &quot;北京&quot;,
      Childs = new List&amp;lt;Area&amp;gt;(new[] {
        new Area{ Code=&quot;110100&quot;, Name = &quot;北京市&quot; },
        new Area{ Code=&quot;110101&quot;, Name = &quot;东城区&quot; },
      })
    }
  })
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;递归数据&quot;&gt;递归数据&lt;/h3&gt;
&lt;p&gt;配置好父子属性之后，就可以这样用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t1 = fsql.Select&amp;lt;Area&amp;gt;().ToTreeList();
Assert.Single(t1);
Assert.Equal(&quot;100000&quot;, t1[0].Code);
Assert.Single(t1[0].Childs);
Assert.Equal(&quot;110000&quot;, t1[0].Childs[0].Code);
Assert.Equal(2, t1[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t1[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t1[0].Childs[0].Childs[1].Code);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询数据本来是平面的，ToTreeList 方法将返回的平面数据在内存中加工为树型 List 返回。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;cte递归删除&quot;&gt;CTE递归删除&lt;/h3&gt;
&lt;p&gt;很常见的无限级分类表功能，删除树节点时，把子节点也处理一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToDelete()
  .ExecuteAffrows(); //删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果软删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .ToUpdate()
  .Set(a =&amp;gt; a.IsDeleted, true)
  .ExecuteAffrows(); //软删除 中国 下的所有记录
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;cte递归查询&quot;&gt;CTE递归查询&lt;/h3&gt;
&lt;p&gt;若不做数据冗余的无限级分类表设计，递归查询少不了，AsTreeCte 正是解决递归查询的封装，方法参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSelector&lt;/td&gt;
&lt;td&gt;路径内容选择，可以设置查询返回：中国 -&amp;gt; 北京 -&amp;gt; 东城区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) up&lt;/td&gt;
&lt;td&gt;false(默认)：由父级向子级的递归查询，true：由子级向父级的递归查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(可选) pathSeparator&lt;/td&gt;
&lt;td&gt;设置 pathSelector 的连接符，默认：-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;(可选) level&lt;/td&gt;
&lt;td&gt;设置递归层级&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过测试的数据库：MySql8.0、SqlServer、PostgreSQL、Oracle、Sqlite、达梦、人大金仓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;姿势一：AsTreeCte() + ToTreeList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t2 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte() //查询 中国 下的所有记录
  .OrderBy(a =&amp;gt; a.Code)
  .ToTreeList(); //非必须，也可以使用 ToList（见姿势二）
Assert.Single(t2);
Assert.Equal(&quot;100000&quot;, t2[0].Code);
Assert.Single(t2[0].Childs);
Assert.Equal(&quot;110000&quot;, t2[0].Childs[0].Code);
Assert.Equal(2, t2[0].Childs[0].Childs.Count);
Assert.Equal(&quot;110100&quot;, t2[0].Childs[0].Childs[0].Code);
Assert.Equal(&quot;110101&quot;, t2[0].Childs[0].Childs[1].Code);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势二：AsTreeCte() + ToList&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t3 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte()
  .OrderBy(a =&amp;gt; a.Code)
  .ToList();
Assert.Equal(4, t3.Count);
Assert.Equal(&quot;100000&quot;, t3[0].Code);
Assert.Equal(&quot;110000&quot;, t3[1].Code);
Assert.Equal(&quot;110100&quot;, t3[2].Code);
Assert.Equal(&quot;110101&quot;, t3[3].Code);
//执行的 SQL 与姿势一相同
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姿势三：AsTreeCte(pathSelector) + ToList&lt;/p&gt;
&lt;p&gt;设置 pathSelector 参数后，如何返回隐藏字段？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var t4 = fsql.Select&amp;lt;Area&amp;gt;()
  .Where(a =&amp;gt; a.Name == &quot;中国&quot;)
  .AsTreeCte(a =&amp;gt; a.Name + &quot;[&quot; + a.Code + &quot;]&quot;)
  .OrderBy(a =&amp;gt; a.Code)
  .ToList(a =&amp;gt; new { 
    item = a, 
    level = Convert.ToInt32(&quot;a.cte_level&quot;), 
    path = &quot;a.cte_path&quot; 
  });
Assert.Equal(4, t4.Count);
Assert.Equal(&quot;100000&quot;, t4[0].item.Code);
Assert.Equal(&quot;110000&quot;, t4[1].item.Code);
Assert.Equal(&quot;110100&quot;, t4[2].item.Code);
Assert.Equal(&quot;110101&quot;, t4[3].item.Code);
Assert.Equal(&quot;中国[100000]&quot;, t4[0].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000]&quot;, t4[1].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 北京市[110100]&quot;, t4[2].path);
Assert.Equal(&quot;中国[100000] -&amp;gt; 北京[110000] -&amp;gt; 东城区[110101]&quot;, t4[3].path);
// WITH &quot;as_tree_cte&quot;
// as
// (
// SELECT 0 as cte_level, a.&quot;Name&quot; || '[' || a.&quot;Code&quot; || ']' as cte_path, a.&quot;Code&quot;, a.&quot;Name&quot;, a.&quot;ParentCode&quot; 
// FROM &quot;Area&quot; a 
// WHERE (a.&quot;Name&quot; = '中国')

// union all

// SELECT wct1.cte_level + 1 as cte_level, wct1.cte_path || ' -&amp;gt; ' || wct2.&quot;Name&quot; || '[' || wct2.&quot;Code&quot; || ']' as cte_path, wct2.&quot;Code&quot;, wct2.&quot;Name&quot;, wct2.&quot;ParentCode&quot; 
// FROM &quot;as_tree_cte&quot; wct1 
// INNER JOIN &quot;Area&quot; wct2 ON wct2.&quot;ParentCode&quot; = wct1.&quot;Code&quot;
// )
// SELECT a.&quot;Code&quot; as1, a.&quot;Name&quot; as2, a.&quot;ParentCode&quot; as5, a.cte_level as6, a.cte_path as7 
// FROM &quot;as_tree_cte&quot; a 
// ORDER BY a.&quot;Code&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200828031037345-862260815.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;微软制造了优秀的语言 c#，利用语言特性可以做一些非常好用的功能，在 ORM 中使用导航属性非常适合。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ManyToOne(N对1) 提供了简单的多表 join 查询；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OneToMany(1对N) 提供了简单可控的级联查询、级联保存功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ManyToMany(多对多) 提供了简单的多对多过滤查询、级联查询、级联保存功能；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;父子关系 提供了常用的 CTE查询、删除、递归功能；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希望正在使用的、善良的您能动一动小手指，把文章转发一下，让更多人知道 .NET 有这样一个好用的 ORM 存在。谢谢了！！&lt;/p&gt;
&lt;p&gt;FreeSql 开源协议 MIT &lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;，可以商用，文档齐全。QQ群：4336577(已满)、8578575(在线)、52508226(在线)&lt;/p&gt;
&lt;p&gt;如果你有好的 ORM 实现想法，欢迎给作者留言讨论，谢谢观看！&lt;/p&gt;
</description>
<pubDate>Thu, 27 Aug 2020 19:53:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>写在开头 从最早期入门时的单表操作， 到后来接触了 left join、right join、inner join 查询， 因为经费有限，需要不断在多表查询中折腾解决实际需求，不知道是否有过这样的经历</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/13575053.html</dc:identifier>
</item>
<item>
<title>欢迎来到 C＃ 9.0（Welcome to C# 9.0）【纯手工翻译】 - 技术译民</title>
<link>http://www.cnblogs.com/ittranslator/p/13575059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ittranslator/p/13575059.html</guid>
<description>&lt;blockquote readability=&quot;5.2159090909091&quot;&gt;
&lt;p&gt;翻译自 Mads Torgersen 2020年5月20日的博文&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/&quot;&gt;《Welcome to C# 9.0》&lt;/a&gt;，Mads Torgersen 是微软 C# 语言的首席设计师，也是微软 .NET 团队的项目群经理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C# 9.0 正在成形，我想和大家分享一下我们对下一版本语言中添加的一些主要特性的想法。&lt;/p&gt;
&lt;p&gt;对于 C# 的每一个新版本，我们都在努力让常见的编码场景的实现变得更加清晰和简单，C# 9.0 也不例外。这次特别关注的是支持数据模型的简洁和不可变表示。&lt;/p&gt;
&lt;p&gt;就让我们一探究竟吧!&lt;/p&gt;
&lt;h2 id=&quot;一、仅初始化init-only属性&quot;&gt;一、仅初始化(init-only)属性&lt;/h2&gt;
&lt;p&gt;对象初始化器非常棒。它们为类型的客户端提供了一种非常灵活和可读的格式来创建对象，并且特别适合于嵌套对象的创建，让你可以一次性创建整个对象树。这里有一个简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;new Person
{
    FirstName = &quot;Scott&quot;,
    LastName = &quot;Hunter&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象初始化器还使类型作者不必编写大量的构造函数——他们所要做的就是编写一些属性！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前最大的限制是属性必须是&lt;strong&gt;可变的&lt;/strong&gt;（&lt;em&gt;译者注：即可写的&lt;/em&gt;），对象初始化器才能工作：它们首先调用对象的构造函数(本例中是默认的无参数构造函数)，然后赋值给属性 &lt;code&gt;setter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;仅初始化(init-only)属性解决了这个问题！它引入了一个 &lt;code&gt;init&lt;/code&gt; 访问器，它是 &lt;code&gt;set&lt;/code&gt; 访问器的变体，只能在对象初始化时调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个声明，上面的客户端代码仍然是合法的，但是随后对 &lt;code&gt;FirstName&lt;/code&gt; 和 &lt;code&gt;LastName&lt;/code&gt; 属性的任何赋值都是错误的。&lt;/p&gt;
&lt;h3 id=&quot;初始化init-访问器和只读readonly字段&quot;&gt;初始化(&lt;code&gt;init&lt;/code&gt;) 访问器和只读(&lt;code&gt;readonly&lt;/code&gt;)字段&lt;/h3&gt;
&lt;p&gt;因为 &lt;code&gt;init&lt;/code&gt; 访问器只能在初始化期间调用，所以允许它们更改封闭类的只读(&lt;code&gt;readonly&lt;/code&gt;)字段，就像在构造函数中一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    private readonly string firstName;
    private readonly string lastName;
    
    public string FirstName 
    { 
        get =&amp;gt; firstName; 
        init =&amp;gt; firstName = (value ?? throw new ArgumentNullException(nameof(FirstName)));
    }
    public string LastName 
    { 
        get =&amp;gt; lastName; 
        init =&amp;gt; lastName = (value ?? throw new ArgumentNullException(nameof(LastName)));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、记录（record）&quot;&gt;二、记录（record）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者注：&lt;br/&gt;原文中声明一个记录的 &lt;code&gt;data class **&lt;/code&gt; 联合关键字现在已经变成 &lt;code&gt;record&lt;/code&gt; 关键字了，所以翻译过程中做了修正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您想使单个属性不可变，那么仅初始化(init-only)属性是极好的。如果您想要整个对象是不可变的，行为像一个值，那么你应该考虑声明它为一个&lt;em&gt;记录(record)&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于记录(&lt;code&gt;record&lt;/code&gt;)，赋予了它一些类似值的行为，我们将在下面深入探讨。一般来说，记录更应该被看作是“值”——数据(&lt;code&gt;data&lt;/code&gt;)，而不是对象！它们并不具有可变的封装状态，相反，您需要通过创建表示新状态的新记录来表示其随时间的变化。它们不是由它们的身份(identity)确定的，而是由它们的内容确定的。&lt;/p&gt;
&lt;h3 id=&quot;with-表达式&quot;&gt;&lt;code&gt;with&lt;/code&gt; 表达式&lt;/h3&gt;
&lt;p&gt;当使用不可变数据(&lt;code&gt;data&lt;/code&gt;)时，一种常见的模式是从现有的值中创建新值来表示新状态。例如，如果我们的 &lt;code&gt;person&lt;/code&gt; 要更改他们的 &lt;code&gt;LastName&lt;/code&gt;，我们会将其表示为一个新对象，该对象是旧对象的副本，只是有不同的 &lt;code&gt;LastName&lt;/code&gt;。这种技巧通常被称之为&lt;em&gt;非破坏性突变(non-destructive mutation)&lt;/em&gt;。记录(&lt;code&gt;record&lt;/code&gt;)不是代表 &lt;code&gt;person&lt;/code&gt; &lt;em&gt;在一段时间内的&lt;/em&gt; 状态，而是代表 &lt;code&gt;person&lt;/code&gt; &lt;em&gt;在给定时间点的&lt;/em&gt; 状态。&lt;/p&gt;
&lt;p&gt;为了帮助实现这种编程风格，记录(&lt;code&gt;record&lt;/code&gt;)允许使用一种新的表达式 —— &lt;code&gt;with&lt;/code&gt; 表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var otherPerson = person with { LastName = &quot;Hanselman&quot; };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;with&lt;/code&gt; 表达式使用对象初始化器语法来声明新对象与旧对象的不同之处。您可以指定多个属性。&lt;/p&gt;
&lt;p&gt;记录(&lt;code&gt;record&lt;/code&gt;)隐式定义了一个受保护的(&lt;code&gt;protected&lt;/code&gt;)“复制构造函数”——一个接受现有记录对象并逐字段将其复制到新记录对象的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected Person(Person original) { /* copy all the fields */ } // generated
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;with&lt;/code&gt; 表达式会调用“复制构造函数”，然后在上面应用对象初始化器来相应地变更属性。&lt;/p&gt;
&lt;p&gt;如果您不喜欢生成的“复制构造函数”的默认行为，您可以定义自己的“复制构造函数”，它将被 &lt;code&gt;with&lt;/code&gt; 表达式捕获。&lt;/p&gt;
&lt;h3 id=&quot;基于值的相等（value-based-equality）&quot;&gt;基于值的相等（Value-based equality）&lt;/h3&gt;
&lt;p&gt;所有对象都从对象类(&lt;code&gt;object&lt;/code&gt;)继承一个虚的 &lt;code&gt;Equals(object)&lt;/code&gt; 方法。这被用作是当两个参数都是非空(&lt;code&gt;non-null&lt;/code&gt;)时，静态方法 &lt;code&gt;Object.Equals(object, object)&lt;/code&gt; 的基础。&lt;/p&gt;
&lt;p&gt;结构体重写了 &lt;code&gt;Equals(object)&lt;/code&gt; 方法，通过递归地在结构体的每一个字段上调用 &lt;code&gt;Equals&lt;/code&gt; 来比较结构体的每一个字段，从而实现了“基于值的相等”。&lt;strong&gt;记录(&lt;code&gt;record&lt;/code&gt;)是一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这意味着，根据它们的“值性(value-ness)”，两个记录(&lt;code&gt;record&lt;/code&gt;)对象可以彼此相等，而不是&lt;em&gt;同一个&lt;/em&gt;对象。例如，如果我们将被修改 &lt;code&gt;person&lt;/code&gt; 的 &lt;code&gt;LastName&lt;/code&gt; 改回去：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var originalPerson = otherPerson with { LastName = &quot;Hunter&quot; };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们将得到 &lt;code&gt;ReferenceEquals(person, originalPerson)&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;(它们不是同一个对象)，但是 &lt;code&gt;Equals(person, originalPerson)&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt;(它们有相同的值)。&lt;/p&gt;
&lt;p&gt;如果您不喜欢生成的 &lt;code&gt;Equals&lt;/code&gt; 重写的默认逐个字段比较的行为，您可以自己编写。您只需要注意理解“基于值的相等”是如何在记录(&lt;code&gt;record&lt;/code&gt;)中工作的，特别是在涉及继承时，我们后面会讲到。&lt;/p&gt;
&lt;p&gt;除了基于值的 &lt;code&gt;Equals&lt;/code&gt; 之外，还有一个基于值 &lt;code&gt;GetHashCode()&lt;/code&gt; 的重写。&lt;/p&gt;
&lt;h3 id=&quot;数据成员（data-members）&quot;&gt;数据成员（Data members）&lt;/h3&gt;
&lt;p&gt;绝大多数情况下，记录(&lt;code&gt;record&lt;/code&gt;)都是不可变的，仅初始化(init-only)公共属性可以通过 &lt;code&gt;with&lt;/code&gt; 表达式进行非破坏性修改。为了对这种常见情况进行优化，记录(&lt;code&gt;record&lt;/code&gt;)更改了 &lt;code&gt;string FirstName&lt;/code&gt; 这种形式的简单成员声明的默认含义，与其他类和结构体声明中的隐式私有字段不同，它被当作是一个公共的、仅初始化(init-only) 自动属性的简写！因此，声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person { string FirstName; string LastName; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与我们之前的声明意思完全一样，即等同于声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们认为这有助于形成漂亮而清晰的记录(&lt;code&gt;record&lt;/code&gt;)声明。如果您确实需要私有字段，只需显式添加 &lt;code&gt;private&lt;/code&gt; 修饰符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private string firstName;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;位置记录（positional-records）&quot;&gt;位置记录（Positional records）&lt;/h3&gt;
&lt;p&gt;有时，对记录(&lt;code&gt;record&lt;/code&gt;)采用位置更明确的方法是有用的，其中它的内容是通过构造函数参数提供的，并且可以通过位置解构来提取。&lt;/p&gt;
&lt;p&gt;完全可以在记录(&lt;code&gt;record&lt;/code&gt;)中指定自己的构造函数和解构函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person 
{ 
    string FirstName; 
    string LastName; 
    public Person(string firstName, string lastName) 
      =&amp;gt; (FirstName, LastName) = (firstName, lastName);
    public void Deconstruct(out string firstName, out string lastName) 
      =&amp;gt; (firstName, lastName) = (FirstName, LastName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是有一种更简短的语法来表达完全相同的意思（参数名称包装模式&lt;code&gt;modulo casing of parameter names&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person(string FirstName, string LastName);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它声明了公共的仅初始化(init-only)自动属性以及构造函数和解构函数，因此您就可以编写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var person = new Person(&quot;Scott&quot;, &quot;Hunter&quot;); // 用位置参数构造（positional construction）
var (f, l) = person;                        // 用位置参数解构（positional deconstruction）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不喜欢生成的自动属性，您可以定义自己的同名属性，生成的构造函数和解构函数将只使用您自定义的属性。&lt;/p&gt;
&lt;h3 id=&quot;记录与可变性（records-and-mutation）&quot;&gt;记录与可变性（Records and mutation）&lt;/h3&gt;
&lt;p&gt;记录(&lt;code&gt;record&lt;/code&gt;)的基于值的语义不能很好地适应可变状态。想象一下，将一个记录(&lt;code&gt;record&lt;/code&gt;)对象放入字典中。再次查找它依赖于 &lt;code&gt;Equals&lt;/code&gt; 和 &lt;code&gt;GetHashCode&lt;/code&gt;(有时)。但是如果记录改变了状态，它的 &lt;code&gt;Equals&lt;/code&gt; 值也会随之改变，我们可能再也找不到它了！在哈希表实现中，它甚至可能破坏数据结构，因为位置是基于它的哈希码得到的。&lt;/p&gt;
&lt;p&gt;记录(&lt;code&gt;record&lt;/code&gt;)内部的可变状态或许有一些有效的高级用法，特别是对于缓存。但是重写默认行为以忽略这种状态所涉及的手工工作很可能是相当大的。&lt;/p&gt;
&lt;h3 id=&quot;with-表达式和继承（with-expressions-and-inheritance）&quot;&gt;&lt;code&gt;with&lt;/code&gt; 表达式和继承（With-expressions and inheritance）&lt;/h3&gt;
&lt;p&gt;众所周知，基于值的相等和非破坏性突变与继承结合在一起时是极具挑战性的。让我们在运行示例中添加一个派生的记录(&lt;code&gt;record&lt;/code&gt;)类 &lt;code&gt;Student&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public record Person { string FirstName; string LastName; }
public record Student : Person { int ID; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，让我们从 &lt;code&gt;with&lt;/code&gt; 表达式示例开始，实际地创建一个 &lt;code&gt;Student&lt;/code&gt;，但将它存储在 &lt;code&gt;Person&lt;/code&gt; 变量中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;int newId = 1;
Func&amp;lt;int&amp;gt; GetNewId = () =&amp;gt; ++newId;
//上面两上是译者在测试时发现需要添加的代码。

Person person = new Student { FirstName = &quot;Scott&quot;, LastName = &quot;Hunter&quot;, ID = GetNewId() };
otherPerson = person with { LastName = &quot;Hanselman&quot; };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在最后一行带 &lt;code&gt;with&lt;/code&gt; 表达式的地方，编译器不知道 &lt;code&gt;person&lt;/code&gt; 实际上包含 &lt;code&gt;Student&lt;/code&gt;。然而，如果新的 &lt;code&gt;person&lt;/code&gt;(即 &lt;code&gt;otherPerson&lt;/code&gt;) 不是一个&lt;em&gt;真正的&lt;/em&gt; &lt;code&gt;Student&lt;/code&gt; 对象，并且具有从第一个 &lt;code&gt;person&lt;/code&gt; 复制过去的相同的 &lt;code&gt;ID&lt;/code&gt;，那么它就不是一个恰当的拷贝。&lt;/p&gt;
&lt;p&gt;C# 实现了这一点。记录(&lt;code&gt;record&lt;/code&gt;)有一个隐藏的虚方法（&lt;code&gt;virtual method&lt;/code&gt;），它被委托“克隆”&lt;em&gt;整个&lt;/em&gt;对象。每个派生记录类型都重写此方法以调用该类型的复制构造函数，并且派生记录的复制构造函数将链接到基记录的复制构造函数。&lt;code&gt;with&lt;/code&gt; 表达式只需调用隐藏的“克隆”方法并将对象初始化器应用于其返回结果。&lt;/p&gt;
&lt;h3 id=&quot;基于值的相等和继承（value-based-equality-and-inheritance）&quot;&gt;基于值的相等和继承（Value-based equality and inheritance）&lt;/h3&gt;
&lt;p&gt;与 &lt;code&gt;with&lt;/code&gt; 表达式支持类似，基于值的相等也必须是“虚的(&lt;code&gt;virtual&lt;/code&gt;)”，即 &lt;code&gt;Student&lt;/code&gt; 需要比较 &lt;code&gt;Student&lt;/code&gt; 的所有字段，即使比较时静态已知的类型是 &lt;code&gt;Person&lt;/code&gt; 之类的基类型。这很容易通过重写虚的(&lt;code&gt;virtual&lt;/code&gt;) &lt;code&gt;Equals&lt;/code&gt; 方法来实现。&lt;/p&gt;
&lt;p&gt;然而，关于相等还有一个额外的挑战：如果你比较两种不同的 &lt;code&gt;Person&lt;/code&gt; 会怎样?我们不能仅仅让其中一个来决定实施哪个相等：相等应该是对称的，所以不管两个对象哪个在前面，结果应该是相同的。换句话说，它们必须在&lt;em&gt;相等&lt;/em&gt;的实施上&lt;em&gt;达成一致&lt;/em&gt;！&lt;/p&gt;
&lt;p&gt;举例说明一下这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Person person1 = new Person { FirstName = &quot;Scott&quot;, LastName = &quot;Hunter&quot; };
Person person2 = new Student { FirstName = &quot;Scott&quot;, LastName = &quot;Hunter&quot;, ID = GetNewId() };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个对象相等吗？ &lt;code&gt;person1&lt;/code&gt; 可能会认为相等，因为 &lt;code&gt;person2&lt;/code&gt; 对于 &lt;code&gt;Person&lt;/code&gt; 的所有属性都是正确的，但是 &lt;code&gt;person2&lt;/code&gt; 不敢苟同！我们需要确保它们都同意它们是不同的对象。&lt;/p&gt;
&lt;p&gt;同样，C# 会自动为您处理这个问题。实现的方式是，记录有一个名为 &lt;code&gt;EqualityContract&lt;/code&gt; 的“虚的(&lt;code&gt;virtual&lt;/code&gt;)”受保护的属性。每个派生记录(&lt;code&gt;record&lt;/code&gt;)都会重写它，为了比较相等，这两个对象必须具有相同的 &lt;code&gt;EqualityContract&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;三、顶级程序（top-level-programs）&quot;&gt;三、顶级程序（Top-level programs）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者注：&lt;br/&gt;什么是 Top-level program ? 这是在顶级编写程序的一种更简单的方式：一个更简单的 &lt;code&gt;Program.cs&lt;/code&gt; 文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用 C# 编写一个简单的程序需要大量的样板代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
class Program
{
    static void Main()
    {
        Console.WriteLine(&quot;Hello World!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这不仅对语言初学者来说是难以承受的，而且还会使代码混乱，增加缩进级别。&lt;/p&gt;
&lt;p&gt;在 C# 9.0 中，您可以选择在顶级编写你的主程序(main program)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

Console.WriteLine(&quot;Hello World!&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;允许任何语句。此程序必须在文件中的 &lt;code&gt;using&lt;/code&gt; 语句之后，任何类型或命名空间声明之前执行，并且只能在一个文件中执行。就像目前只能有一个 &lt;code&gt;Main&lt;/code&gt; 方法一样。&lt;/p&gt;
&lt;p&gt;如果您想返回一个状态码，您可以做。如果您想等待(&lt;code&gt;await&lt;/code&gt;)，您可以做。如果您想访问命令行参数，&lt;code&gt;args&lt;/code&gt; 可以作为一个“魔法”参数使用。&lt;/p&gt;
&lt;p&gt;局部函数是语句的一种形式，也允许在顶级程序中使用。从顶级语句部分之外的任何地方调用它们都是错误的。&lt;/p&gt;
&lt;h2 id=&quot;四、改进的模式匹配（improved-pattern-matching）&quot;&gt;四、改进的模式匹配（Improved pattern matching）&lt;/h2&gt;
&lt;p&gt;C# 9.0 中添加了几种新的模式。让我们从&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching&quot;&gt;模式匹配教程&lt;/a&gt;的代码片段的上下文中来看看它们:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static decimal CalculateToll(object vehicle) =&amp;gt;
    vehicle switch
    {
       ...
       
        DeliveryTruck t when t.GrossWeightClass &amp;gt; 5000 =&amp;gt; 10.00m + 5.00m,
        DeliveryTruck t when t.GrossWeightClass &amp;lt; 3000 =&amp;gt; 10.00m - 2.00m,
        DeliveryTruck _ =&amp;gt; 10.00m,

        _ =&amp;gt; throw new ArgumentException(&quot;Not a known vehicle type&quot;, nameof(vehicle))
    };
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简单类型模式（simple-type-patterns）&quot;&gt;简单类型模式（Simple type patterns）&lt;/h3&gt;
&lt;p&gt;目前，类型模式需要在类型匹配时声明一个标识符——即使该标识符是一个丢弃的 &lt;code&gt;_&lt;/code&gt;，如上面的 &lt;code&gt;DeliveryTruck _&lt;/code&gt; 所示。但现在你只需写下类型就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DeliveryTruck =&amp;gt; 10.00m,
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关系模式（relational-patterns）&quot;&gt;关系模式（Relational patterns）&lt;/h3&gt;
&lt;p&gt;C# 9.0 引入了与关系运算符 &lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt; 等相对应的模式。因此，现在可以将上述模式的 &lt;code&gt;DeliveryTruck&lt;/code&gt; 部分编写为嵌套的 &lt;code&gt;switch&lt;/code&gt; 表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DeliveryTruck t when t.GrossWeightClass switch
{
    &amp;gt; 5000 =&amp;gt; 10.00m + 5.00m,
    &amp;lt; 3000 =&amp;gt; 10.00m - 2.00m,
    _ =&amp;gt; 10.00m,
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;&amp;gt; 5000&lt;/code&gt; 和 &lt;code&gt;&amp;lt; 3000&lt;/code&gt; 是关系模式。&lt;/p&gt;
&lt;h3 id=&quot;逻辑模式（logical-patterns）&quot;&gt;逻辑模式（Logical patterns）&lt;/h3&gt;
&lt;p&gt;最后，您可以将模式与逻辑运算符 &lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;not&lt;/code&gt; 组合起来，这些运算符用单词拼写，以避免与表达式中使用的运算符混淆。例如，上面嵌套的&lt;code&gt;switch&lt;/code&gt;的示例可以按如下升序排列：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;DeliveryTruck t when t.GrossWeightClass switch
{
    &amp;lt; 3000 =&amp;gt; 10.00m - 2.00m,
    &amp;gt;= 3000 and &amp;lt;= 5000 =&amp;gt; 10.00m,
    &amp;gt; 5000 =&amp;gt; 10.00m + 5.00m,
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此例中间的案例使用 &lt;code&gt;and&lt;/code&gt; 合并了两个关系模式，形成一个表示区间的模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;not&lt;/code&gt; 模式的一个常见用法是将其应用于 &lt;code&gt;null&lt;/code&gt; 常量模式，如 &lt;code&gt;not null&lt;/code&gt;。例如，我们可以根据未知实例是否为空来拆分它们的处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;not null =&amp;gt; throw new ArgumentException($&quot;Not a known vehicle type: {vehicle}&quot;, nameof(vehicle)),
null =&amp;gt; throw new ArgumentNullException(nameof(vehicle))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，&lt;code&gt;not&lt;/code&gt; 在 &lt;code&gt;if&lt;/code&gt; 条件中包含 &lt;code&gt;is&lt;/code&gt; 表达式时将会很方便，可以取代笨拙的双括号，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;if (!(e is Customer)) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;if (e is not Customer) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、改进的目标类型（improved-target-typing）&quot;&gt;五、改进的目标类型（Improved target typing）&lt;/h2&gt;
&lt;p&gt;“目标类型(&lt;code&gt;Target typing&lt;/code&gt;)”是一个术语，当一个表达式从使用它的地方的上下文中获得其类型时，我们使用这个术语。例如，&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;lambda&lt;/code&gt;表达式始终是目标类型的。&lt;/p&gt;
&lt;p&gt;在 C# 9.0 中，一些以前不是目标类型的表达式变得可以由其上下文推导。&lt;/p&gt;
&lt;h3 id=&quot;目标类型的-new-表达式（target-typed-new-expressions）&quot;&gt;目标类型的 &lt;code&gt;new&lt;/code&gt; 表达式（Target-typed new expressions）&lt;/h3&gt;
&lt;p&gt;C# 中的 &lt;code&gt;new&lt;/code&gt; 表达式总是要求指定类型（隐式类型的数组表达式除外）。现在，如果表达式被赋值为一个明确的类型，则可以省略该类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Point p = new (3, 5);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目标类型的--和-（target-typed--and-）&quot;&gt;目标类型的 &lt;strong&gt;&lt;code&gt;??&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;?:&lt;/code&gt;&lt;/strong&gt;（Target typed &lt;code&gt;??&lt;/code&gt; and &lt;code&gt;?:&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;有时有条件的 &lt;code&gt;??&lt;/code&gt; 和 &lt;code&gt;?:&lt;/code&gt; 表达式在分支之间没有明显的共享类型，这种情况目前是失败的。但是如果有一个两个分支都可以转换成的目标类型，在 C# 9.0 中将是允许的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Person person = student ?? customer; // Shared base type
int? result = b ? 0 : null; // nullable value type
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六、协变式返回值（covariant-returns）&quot;&gt;六、协变式返回值（Covariant returns）&lt;/h2&gt;
&lt;p&gt;有时候，这样的表达是有用的——派生类中的方法重写具有一个比基类型中的声明更具体（更明确）的返回类型。C# 9.0 允许：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;abstract class Animal
{
    public abstract Food GetFood();
    ...
}
class Tiger : Animal
{
    public override Meat GetFood() =&amp;gt; ...;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更多内容&quot;&gt;更多内容……&lt;/h2&gt;
&lt;p&gt;要查看 C# 9.0 即将发布的全部特性并追随它们的完成，最好的地方是 Roslyn(C#/VB 编译器) GitHub 仓库上的 &lt;a href=&quot;https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md&quot;&gt;Language Feature Status&lt;/a&gt;。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;5.0649350649351&quot;&gt;
&lt;p&gt;作者 ： Mads Torgersen&lt;br/&gt;译者 ： 技术译民&lt;br/&gt;出品 ： &lt;a href=&quot;https://ittranslator.cn/&quot;&gt;技术译站&lt;/a&gt;&lt;br/&gt;链接 ： &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/&quot;&gt;英文原文&lt;/a&gt;&lt;br/&gt;©纯手工翻译，欢迎转载，转载请标明出处&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 27 Aug 2020 17:53:00 +0000</pubDate>
<dc:creator>技术译民</dc:creator>
<og:description>翻译自 Mads Torgersen 2020年5月20日的博文《Welcome to C# 9.0》，Mads Torgersen 是微软 C# 语言的首席设计师，也是微软 .NET 团队的项目群经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ittranslator/p/13575059.html</dc:identifier>
</item>
<item>
<title>ent orm笔记2---schema使用(下) - syncd</title>
<link>http://www.cnblogs.com/zhaof/p/13575062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/13575062.html</guid>
<description>&lt;h2 id=&quot;indexes-索引&quot;&gt;Indexes 索引&lt;/h2&gt;
&lt;p&gt;在前两篇的文章中，其实对于索引也有一些使用， 这里来详细看一下关于索引的使用&lt;/p&gt;
&lt;p&gt;Indexes方法可以在一个或者多个字段上设置索引，以提高数据检索的速度或者定义数据的唯一性&lt;/p&gt;
&lt;p&gt;在下面这个例子中，对user表的&lt;code&gt;field1&lt;/code&gt; 和&lt;code&gt;field2&lt;/code&gt; 字段设置了联合索引;对&lt;code&gt;first_name&lt;/code&gt;和&lt;code&gt;last_name&lt;/code&gt;设置了联合唯一索引; 对&lt;code&gt;field3&lt;/code&gt; 设置了唯一索引。&lt;/p&gt;
&lt;p&gt;这里需要注意对于单独的字段设置唯一索引，在Fields中定义字段的时候通过Unique方法即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
        &quot;github.com/facebook/ent&quot;
        &quot;github.com/facebook/ent/schema/field&quot;
        &quot;github.com/facebook/ent/schema/index&quot;
)

// User holds the schema definition for the User entity.
type User struct {
        ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
        return []ent.Field{
                field.String(&quot;field1&quot;),
                field.String(&quot;field2&quot;),
                field.String(&quot;field3&quot;).Unique(),
                field.String(&quot;first_name&quot;),
                field.String(&quot;last_name&quot;),
        }
}

// Edges of the User.
func (User) Edges() []ent.Edge {
        return nil
}

func Indexes() []ent.Index {
        return []ent.Index{
                // non-unique index.
                index.Fields(&quot;field1&quot;, &quot;field2&quot;),
                // unique index
                index.Fields(&quot;first_name&quot;, &quot;last_name&quot;).Unique(),
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看一下生成的表的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `field1` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `field2` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `field3` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `first_name` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `last_name` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `field3` (`field3`),
  UNIQUE KEY `user_first_name_last_name` (`first_name`,`last_name`),
  KEY `user_field1_field2` (`field1`,`field2`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;index-on-edges&quot;&gt;Index On Edges&lt;/h3&gt;
&lt;p&gt;在建立表关系的时候也可以对相应的字段设置索引，主要实在特定关系下设置字段的唯一性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://entgo.io/assets/er_city_streets.png&quot; alt=&quot;er-city-streets&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，我们有一个有许多街道的城市，我们希望在每个城市下设置街道名称是唯一的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ent/schema/city.go&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
   &quot;github.com/facebook/ent&quot;
   &quot;github.com/facebook/ent/schema/edge&quot;
   &quot;github.com/facebook/ent/schema/field&quot;
)

// City holds the schema definition for the City entity.
type City struct {
   ent.Schema
}

// Fields of the City.
func (City) Fields() []ent.Field {
   return []ent.Field{
      field.String(&quot;name&quot;),
   }
}

// Edges of the City.
func (City) Edges() []ent.Edge {
   return []ent.Edge{
      edge.To(&quot;streets&quot;, Street.Type),
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ent/schema/street.go&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
   &quot;github.com/facebook/ent&quot;
   &quot;github.com/facebook/ent/schema/edge&quot;
   &quot;github.com/facebook/ent/schema/field&quot;
)

// Street holds the schema definition for the Street entity.
type Street struct {
   ent.Schema
}

// Fields of the Street.
func (Street) Fields() []ent.Field {
   return []ent.Field{
      field.String(&quot;name&quot;),
   }
}

// Edges of the Street.
func (Street) Edges() []ent.Edge {
   return []ent.Edge{
      edge.From(&quot;city&quot;, City.Type).
         Ref(&quot;streets&quot;).
         Unique(),
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上一篇文章中这种用法我们已经见过，我们看一下这样创建的表信息，主要是看streets这个表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `streets` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `city_streets` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `streets_cities_streets` (`city_streets`),
  CONSTRAINT `streets_cities_streets` FOREIGN KEY (`city_streets`) REFERENCES `cities` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;ent/schema/street.go&lt;/code&gt; 添加索引的信息后，再次查看streets表的信息，其实这里我们就是通过添加约束，使得一个城市中每个街道的名称是唯一的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (Street) Indexes() []ent.Index {
   return []ent.Index{
      index.Fields(&quot;name&quot;).
         Edges(&quot;city&quot;).
         Unique(),
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `streets` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_bin NOT NULL,
  `city_streets` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `street_name_city_streets` (`name`,`city_streets`),
  KEY `streets_cities_streets` (`city_streets`),
  CONSTRAINT `streets_cities_streets` FOREIGN KEY (`city_streets`) REFERENCES `cities` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;config&quot;&gt;Config&lt;/h2&gt;
&lt;p&gt;可以使用Table选项为类型提供自定义表名，如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
    &quot;github.com/facebook/ent&quot;
    &quot;github.com/facebook/ent/schema/field&quot;
)

type User struct {
    ent.Schema
}

func (User) Config() ent.Config {
    return ent.Config{
        Table: &quot;Users&quot;,
    }
}

func (User) Fields() []ent.Field {
    return []ent.Field{
        field.Int(&quot;age&quot;),
        field.String(&quot;name&quot;),
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mixin&quot;&gt;Mixin&lt;/h2&gt;
&lt;p&gt;Mixin允许您创建可重用的&lt;code&gt;ent.Schema&lt;/code&gt;代码。&lt;code&gt;ent.Mixin&lt;/code&gt; 接口如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;Mixin interface {
    // Fields returns a slice of fields to add to the schema.
    Fields() []Field
    // Edges returns a slice of edges to add to the schema.
    Edges() []Edge
    // Indexes returns a slice of indexes to add to the schema.
    Indexes() []Index
    // Hooks returns a slice of hooks to add to the schema.
    // Note that mixin hooks are executed before schema hooks.
    Hooks() []Hook
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mixin的一个常见用例是将一些常用的通用字段进行内置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
    &quot;time&quot;

    &quot;github.com/facebook/ent&quot;
    &quot;github.com/facebook/ent/schema/field&quot;
    &quot;github.com/facebook/ent/schema/mixin&quot;
)

// -------------------------------------------------
// Mixin definition

// TimeMixin implements the ent.Mixin for sharing
// time fields with package schemas.
type TimeMixin struct{
    // We embed the `mixin.Schema` to avoid
    // implementing the rest of the methods.
    mixin.Schema
}

func (TimeMixin) Fields() []ent.Field {
    return []ent.Field{
        field.Time(&quot;created_at&quot;).
            Immutable().
            Default(time.Now),
        field.Time(&quot;updated_at&quot;).
            Default(time.Now).
            UpdateDefault(time.Now),
    }
}

// DetailsMixin implements the ent.Mixin for sharing
// entity details fields with package schemas.
type DetailsMixin struct{
    // We embed the `mixin.Schema` to avoid
    // implementing the rest of the methods.
    mixin.Schema
}

func (DetailsMixin) Fields() []ent.Field {
    return []ent.Field{
        field.Int(&quot;age&quot;).
            Positive(),
        field.String(&quot;name&quot;).
            NotEmpty(),
    }
}

// -------------------------------------------------
// Schema definition

// User schema mixed-in the TimeMixin and DetailsMixin fields and therefore
// has 5 fields: `created_at`, `updated_at`, `age`, `name` and `nickname`.
type User struct {
    ent.Schema
}

func (User) Mixin() []ent.Mixin {
    return []ent.Mixin{
        TimeMixin{},
        DetailsMixin{},
    }
}

func (User) Fields() []ent.Field {
    return []ent.Field{
        field.String(&quot;nickname&quot;).
            Unique(),
    }
}

// Pet schema mixed-in the DetailsMixin fields and therefore
// has 3 fields: `age`, `name` and `weight`.
type Pet struct {
    ent.Schema
}

func (Pet) Mixin() []ent.Mixin {
    return []ent.Mixin{
        DetailsMixin{},
    }
}

func (Pet) Fields() []ent.Field {
    return []ent.Field{
        field.Float(&quot;weight&quot;),
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;builtin-mixin&quot;&gt;Builtin Mixin&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Mixin&lt;/code&gt;提供了一些内置的&lt;code&gt;Mixin&lt;/code&gt;，可用于将create_time和update_time字段添加到schema中。&lt;/p&gt;
&lt;p&gt;为了使用它们，将 &lt;code&gt;mixin.Time mixin&lt;/code&gt; 添加到schema，如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package schema

import (
    &quot;github.com/facebook/ent&quot;
    &quot;github.com/facebook/ent/schema/mixin&quot;
)

type Pet struct {
    ent.Schema
}

func (Pet) Mixin() []ent.Mixin {
    return []ent.Mixin{
        mixin.Time{},
        // Or, mixin.CreateTime only for create_time
        // and mixin.UpdateTime only for update_time.
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h2&gt;
</description>
<pubDate>Thu, 27 Aug 2020 17:50:00 +0000</pubDate>
<dc:creator>syncd</dc:creator>
<og:description>Indexes 索引 在前两篇的文章中，其实对于索引也有一些使用， 这里来详细看一下关于索引的使用 Indexes方法可以在一个或者多个字段上设置索引，以提高数据检索的速度或者定义数据的唯一性 在下面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaof/p/13575062.html</dc:identifier>
</item>
</channel>
</rss>