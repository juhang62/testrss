<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>性能篇（九）保持应用响应 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10799715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10799715.html</guid>
<description>&lt;p&gt;       在世界上，编写可以赢得每一个性能测试的代码是有可能的，但是仍然感觉在某些显著的时间段内缓慢、挂起或者冻住，或者花费太长的时间来处理输入事件。可能发生的应用响应上最糟糕的事情是“应用未响应”（ANR）对话框。&lt;/p&gt;
&lt;p&gt;       在Android中，系统通过显示一个说明您的应用已经停止响应的对话框来防止应用在一段时间内响应不足，就像图1中的对话框一样。在这个点上，您的应用已经相当一段时间没有响应了，所以系统给用户提供了一个选项来终止该应用。将响应设计到您的应用，来让系统从来不给用户显示ANR对话框是极其重要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201905/472002-20190501091315988-590267514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1&lt;/strong&gt;.展示给用户的ANR对话框&lt;/p&gt;
&lt;p&gt;       本文描述了Android系统如何决定是否应用是不响应的并且提供指导来确保您的应用保持响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是什么触发了ANR？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       一般来说，如果应用不能响应用户输入事件，系统会显示ANR。例如，如果应用在UI线程上的某些I/O操作（频繁地访问网络）上阻塞了，以至于系统无法处理进来的用户输入事件。或者可能应用在UI线程上花费了太多时间来构建一个复杂的内存结构或者在游戏中计算下一个移动。确保这些计算高效总是很重要的，但是即使是最高效的代码仍然会花费时间来运行。&lt;/p&gt;
&lt;p&gt;       在任何您的应用可能执行长时间操作的场景下，您都不应该在UI线程中执行这项工作，而应该创建一个工作线程来处理大部分的工作。这让UI线程（它驱动用户接口时间循环）保持运行并且防止系统断定您的代码已经冻住了。因为这样的线程通常是在class级别上完成的，所以您可以把响应看成是一个class问题。（将这和基本的代码性能进行比较，代码性能问题是一个方法级别的概念。）&lt;/p&gt;
&lt;p&gt;       在Android中，应用响应被Activity Manager和Window Manager 系统服务监视，当检测到有以下条件之一时，Android将会为特定的应用显示ANR对话框：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;5秒内对输入事件（比如键被按下或者屏幕触摸事件）没有响应。&lt;/li&gt;
&lt;li&gt;BroadcastReceiver在10秒内没有完成执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何避免ANR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Android应用通常全部在一个单一的线程中运行（默认为“UI线程”或者“主线程”）。这意味着您的应用在UI线程中正在执行的需要花费很长时间来完成的任何任务，都可能触发ANR对话框，因为您的应用没有给自己机会来处理输入事件或者意图广播。&lt;/p&gt;
&lt;p&gt;       因此，任何在UI线程中运行的方法应该尽可能做少量的工作。尤其是，Activity应该尽可能少地在如onCreate()和onResume()这样的关键生命周期方法中设置。潜在的诸如网络操作或者数据库操作这样的长时间运行的操作，或者诸如重新设置bitmap大小等这样昂贵的计算，应该在工作线程中来执行（或者在数据操作的情况下，通过异步请求）。&lt;/p&gt;
&lt;p&gt;      为更长时间的操作创建工作线程最有效的方式是使用AsyncTask类。简单地继承AsyncTask并且实现doInBackground()方法来执行工作。为了将进度改变发送给用户，您可以调用publishProgress()，它调用了onProgressUpdate()回调方法。从onProgressUpdate()方法（它在UI线程中运行）的实现，您可以通知用户。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DownloadFilesTask &lt;span&gt;extends&lt;/span&gt; AsyncTask&amp;lt;URL, Integer, Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do the long-running work in here&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Long doInBackground(URL... urls) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; urls.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; totalSize = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             totalSize +=&lt;span&gt; Downloader.downloadFile(urls[i]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             publishProgress((&lt;span&gt;int&lt;/span&gt;) ((i / (&lt;span&gt;float&lt;/span&gt;) count) * 100&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Escape early if cancel() is called&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (isCancelled()) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalSize;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is called each time you call publishProgress()&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onProgressUpdate(Integer... progress) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         setProgressPercent(progress[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is called when doInBackground() is finished&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPostExecute(Long result) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         showNotification(&quot;Downloaded &quot; + result + &quot; bytes&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要执行该工作线程，简单地创建一个实例并且调用excute()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DownloadFilesTask().execute(url1, url2, url3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       您可能希望创建您自己的Thread或者HandlerThread类，虽然这比AsyncTask更加复杂。如果您这样做，您应该通过调用Process.setThreadPriority()方法并且传入THREAD_PRIORITY_BACKGROUND值来给“后台”优先级设置线程优先级。如果您没有通过这个方法来将该线程设置为更低的优先级，那么该线程可能仍然会拉低您应用的速度，因为它默认情况下会以和UI线程相同的优先级来运行。&lt;/p&gt;
&lt;p&gt;       如果您实现Thread或者HandlerThread，请确保当正在等待工作线程完成时，UI线程不会阻塞——不要调用Thread.wait()或者Thread.sleep()。当等待工作线程完成时，主线程不应该阻塞，而应该为其它线程提供一个Handler，当工作线程完成时将其传回主线程。通过这种方式设计应用将允许应用的UI线程保持对输入事件的响应，并且这样避免了5秒的输入事件超时所引起的ANR对话框。&lt;/p&gt;
&lt;p&gt;       BroadcastReceiver执行时间的特别限制强调了广播接收器应该做什么：小的，离散的后台工作量，比如保存设置或者注册通知。所以，当其它方法在UI线程中被调用时，在广播接收器中应用应该避免潜在的长时间运行操作或者计算。但是，如果潜在的长时间运行的action需要处理来响应intent广播，您的应用不应该通过工作线程处理密集的任务，而应该通过启动IntentService。&lt;/p&gt;
&lt;p&gt;       当BroadcastReceiver对象执行太频繁时，另外一个常见的BroadcastReceiver对象问题会发生。频繁的后台执行会降低其它应用可用内存的数量。更多关于如何有效地让BroadcastReceiver对象有效/失效，请查阅【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/manifest-receivers.html&quot; target=&quot;_blank&quot;&gt;按要求操作广播接收器&lt;/a&gt;】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 提示：您可以使用StrictMode来协助找到潜在的长时间运行操作，比如您可能无意间在主线程中执行的网络或者数据库操作。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;加强响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       一般来说，100到200毫秒时阈值，超过这个阈值用户将察觉到应用缓慢。所以，在为了避免ANR你应该做的之外，这里有一些附加的提示，让您的应用看起来对用户是响应的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果您的应用正在后台处理工作来响应用户输入，显示它的进度（比如在UI中使用ProgressBar）。&lt;/li&gt;
&lt;li&gt;特别是对于游戏，在工作线程中计算移动。&lt;/li&gt;
&lt;li&gt;如果您的应用有一个耗时的初始化设置阶段，考虑尽快显示一个初始化屏幕或者展示主视图，表明正在加载并且异步地填充信息。在其中任意一种情况，您应该指明取得的进展，以免用户以为应用冻住了。&lt;/li&gt;
&lt;li&gt;使用性能功能如【&lt;a href=&quot;https://www.cnblogs.com/andy-songwei/p/10659564.html&quot; target=&quot;_blank&quot;&gt;Systrace&lt;/a&gt;】和【&lt;a href=&quot;https://developer.android.google.cn/studio/profile/traceview&quot; target=&quot;_blank&quot;&gt;TraceView&lt;/a&gt;】来确定应用响应的瓶颈。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 01 May 2019 05:54:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>在世界上，编写可以通过每一个性能测试的代码是有可能的，但是仍然感觉在某些时间段内显著缓慢、挂起或者冻住，或者花费太长的时间来处理输入事件。对于响应用户，最糟糕的事情是“应用未响应”（ANR）对话框。本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10799715.html</dc:identifier>
</item>
<item>
<title>WebGL学习之法线贴图 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10799596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10799596.html</guid>
<description>&lt;p&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-a2003e57ddd79184.png&quot; width=&quot;400&quot; alt=&quot;法线贴图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法的视角考虑的话，只有一件事决定物体的形状，那就是垂直于它的法线向量。砖块表面只有一个法向量，表面完全根据这个法向量被以一致的方式照亮。如果每个片元都用不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-91a0ac5e7a16904f.png&quot; alt=&quot;表面法线&quot;/&gt;&lt;/p&gt;&lt;p&gt;每个片元使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个片元使用各自的法线，替代一个面上所有片元使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。&lt;/p&gt;
&lt;p&gt;以上都是从 LearnOpenGL CN 相关的文章摘抄 &lt;strong&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/&quot;&gt;法线贴图&lt;/a&gt;&lt;/strong&gt;。没办法，WebGL相关比较深入的知识你只能去看openGL，好在原理基本相同，WebGL1就是基于openGL es 2.0，WebGL2就是基于openGL es 3.0。&lt;/p&gt;
&lt;h2 id=&quot;法线贴图&quot;&gt;法线贴图&lt;/h2&gt;
&lt;p&gt;法线贴图就是用纹理中的颜色向量r、g、b存储法线向量的x、y、z。不过它们有另外的称呼：t (切线)、b (副切线)、n (法线)，它们组成了一个切线空间，被称为TBN坐标系。由于颜色与方向的表示范围有区别，颜色范围是[0,1]，而作为表示位置方向的TBN坐标系则是[-1,1]，那么从法线贴图取出来的值要使用的话，得进行转换。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 将法线向量转换为范围[-1,1]
vec3 normal = normalize(normal * 2.0 - 1.0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;法线贴图偏蓝是因为所有法线的指向都偏向z轴（0, 0, 1）， 对应于rgb 中的 blue分量，也就是蓝色。法线向量从z轴方向向其他方向轻微偏移，于是颜色也就发生轻微变化，这样看起来便有了一种深度。例如，你可以看到顶部颜色倾向于偏绿，这是因为顶部的法线偏向于指向正y轴方向（0, 1, 0）对应于rgb总的 green分量，也就是绿色。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-31c207a874927a96.png&quot; width=&quot;400&quot; alt=&quot;法线贴图颜色&quot;/&gt;&lt;/p&gt;
&lt;p&gt;法线贴图的优点是可以用一个低精度模型表现出非常高的细节，看起来像高精度模型那样。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-2cb177969bbac3e9.png&quot; alt=&quot;高精度模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要500个三角形的简单网格加上法线贴图就能达到媲美4M个三角形的精细网格模型的效果，可以说法线贴图优势巨大，处理4M个三角形的复杂度简直不可想象。&lt;/p&gt;
&lt;p&gt;但法线贴图也不是万能的，它也有缺点。因为它只是改变了物体表面的光照计算方式，所以不适合用在凹凸起伏较大的物体上，这些物体会有遮挡的效果，法线贴图是无法实现的。&lt;/p&gt;
&lt;p&gt;而文章 &lt;strong&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/&quot;&gt;法线贴图&lt;/a&gt;&lt;/strong&gt; 里面有很详细的原理讲解和切线推导过程，最后求出如下的公式，我这里也不再叙述了。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-69ffbf23bd54803f.png&quot; alt=&quot;公式&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;着色器&quot;&gt;着色器&lt;/h2&gt;
&lt;p&gt;我这里使用了另外一种更加方便的算法，能达到同样的效果，原理就是使用导数(dFdx/dFdy)求出每个像素在插值化传值过来的点的变化率当成一个法线，请看函数 &lt;strong&gt;dHdxy_fwd&lt;/strong&gt;。然后再通过与当前平面的法向量进行叉积 (cross)，即可求得同时垂直于这两个方向的法向量，请看函数 &lt;strong&gt;perturbNormalArb&lt;/strong&gt;，而最终的这个法向量就是我们所要求的值，非常地高明。下面是glsl 内置的几个关键函数。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;dFdx(p) //在x方向的偏导数
dFdy(p) //在y方向的偏导数
cross(p0,p1) //向量p0,p1的叉乘&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们用到的求导函数 dFdx / dFdy，在WebGL1是需要开启扩展的，顶点着色器无需变动，主要变动的是片元着色器。具体的计算过程，请看如下片元着色器代码：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#extension GL_OES_standard_derivatives : enable// 注意要开启该扩展
//...
uniform sampler2D u_diffMap;
uniform sampler2D u_specMap;
uniform sampler2D u_normMap;
//...
vec2 dHdxy_fwd() {
    vec2 dSTdx = dFdx( v_texcoord );
    vec2 dSTdy = dFdy( v_texcoord );
    float Hll = bumpScale * texture2D( u_normMap, v_texcoord ).x;
    float dBx = bumpScale * texture2D( u_normMap, v_texcoord + dSTdx ).x - Hll;
    float dBy = bumpScale * texture2D( u_normMap, v_texcoord + dSTdy ).x - Hll;
    return vec2( dBx, dBy );
}
vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
    vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
    vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
    vec3 vN = surf_norm;
    vec3 R1 = cross( vSigmaY, vN );
    vec3 R2 = cross( vN, vSigmaX );
    float fDet = dot( vSigmaX, R1 );
    fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
    return normalize( abs( fDet ) * surf_norm - vGrad );
}

//...
// 从法线贴图计算出逐像素法线向量
vec3 normal = normal = perturbNormalArb( -v_position, normal, dHdxy_fwd());
//...
// 总的光照
gl_FragColor = vec4(ambient + diffuse + specular, diffuseColor.a);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;相关资料 &lt;strong&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;LearnOpenGL CN&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 05:10:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>实际效果请看demo： '纹理贴图' 为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10799596.html</dc:identifier>
</item>
<item>
<title>降维之主成分分析法（PCA） - Luv_GEM</title>
<link>http://www.cnblogs.com/Luv-GEM/p/10765574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Luv-GEM/p/10765574.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;一、主成分分析法的思想&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在研究某些问题时，需要处理带有很多变量的数据，比如研究房价的影响因素，需要考虑的变量有物价水平、土地价格、利率、就业率、城市化率等。变量和数据很多，但是可能存在噪音和冗余，因为这些变量中有些是相关的，那么就可以从相关的变量中选择一个，或者将几个变量综合为一个变量，作为代表。用少数变量来代表所有的变量，用来解释所要研究的问题，就能从化繁为简，抓住关键，这也就是降维的思想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主成分分析法（Principal Component Analysis，PCA）就是一种运用线性代数的知识来进行数据降维的方法，它将多个变量转换为少数几个不相关的综合变量来比较全面地反映整个数据集。这是因为数据集中的原始变量之间存在一定的相关关系，可用较少的综合变量来综合各原始变量之间的信息。这些综合变量称为主成分，各主成分之间彼此不相关，即所代表的的信息不重叠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么主成分分析法是如何降维的呢？我们从坐标变换的角度来获得一个感性的认识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先从最简单的情形开始，假定数据集中的原始变量只有两个，即数据是二维的，每个观测值都用标准的X-y坐标轴来表示。如果每一个维度都服从正态分布（这比较常见），那么这些数据就会形成椭圆形状的点阵。如下图所示，椭圆有一个长轴和一个短轴，二者是垂直的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430190026190-578103227.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;292&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在短轴上，观测点数据的变化比较小，如果把这些点垂直地投影到短轴上，那么有很多点的投影会重合，这相当于很多数据点的信息都没有被充分利用到；而在长轴上，观测点的数据变化比较大。因此，如果坐标轴和椭圆的长短轴平行，那么代表长轴的变量直接可以从数据集的原始变量中找到，它描述了数据的主要变化，而另一个原始变量就代表短轴的变量，描述的是数据的次要变化。在极端情况下，短轴退化成一个点，那么就只能用长轴的变量来解释数据点的所有变化，就可以把二维数据降至一维。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，坐标轴通常并不和椭圆的长短轴平行，就像上图所展示的那样。因此，需要构建新的坐标系，使得新坐标系的坐标轴与椭圆的长短轴重合或平行。这需要用到坐标变换，把观测点在原坐标轴的坐标转换到新坐标系下，&lt;strong&gt;同时也把原始变量转换为了长轴的变量和短轴的变量，这种转换是通过对原始变量进行线性组合的方式而完成的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如一个观测点在原X-y坐标系中的坐标为(4,5)，坐标基为（1,0）和（0,1），如果长轴为斜率是1的线，短轴为斜率是-1的线，新坐标系以长轴和短轴作为坐标轴，那么新坐标基可以取为（1/√2, 1/√2）和（-1/√2, 1/√2）。我们把两个坐标基按行放置，作为变换矩阵，乘以原坐标，也就是对原坐标进行线性组合，可以得到该点在新坐标系下的坐标。可以看到变换后长轴变量的值远大于短轴变量的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430193158183-1410124758.png&quot; alt=&quot;&quot; width=&quot;221&quot; height=&quot;58&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果长轴变量解释了数据集中的大部分变化，那么就可以用长轴变量来代表原来的两个变量，从而把二维数据降至一维。椭圆的长轴和短轴的长度相差越大，这种做法的效果也就越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们把二维变量推广到多维变量，具有多维变量的数据集其观测点的形状类似于一个高维椭球，同样的，把高维椭球的轴都找出来，再把代表数据大部分信息的k个最长的轴作为新变量（相互垂直），也就是k个主成分，那么主成分分析就完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择的主成分越少，越能体现降维二字的内涵，可是不可避免会舍弃越多的信息。因此以什么标准来决定我们应该选几个主成分呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、主成分的选择问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，我们应该有三个问题需要思考：一是进行坐标变换的矩阵是怎么得到的呢？二是用什么指标来衡量一个主成分所能解释的数据变化的大小？三是以什么标准来决定选多少个主成分呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先来解决第二和第三个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假定我们有m个观测值，每个观测值有n个特征（变量），那么将其按列排成n行m列的矩阵，并且每一行都减去&lt;strong&gt;该行的均值&lt;/strong&gt;，得到矩阵X（减去均值是为了下面方便求方差和协方差）。并按行把X整理成n个行向量的形式，即用X&lt;sub&gt;1&lt;/sub&gt;, X&lt;sub&gt;2&lt;/sub&gt;, ..., X&lt;sub&gt;n&lt;/sub&gt;来表示n个原始变量。&lt;/span&gt;&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430202419669-1353955241.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一部分的例子说明了通过一个n×n的转换矩阵对数据集中的原始变量进行线性组合，就可以得到n个新的变量。转换矩阵可以有很多个，也就是变换的坐标系有很多个，但是只有一个可以由原始变量得到主成分。我们先不管这个独特的矩阵是怎么得到的，假定我们已经得到了这个转换矩阵P，那么把转换后的n个主成分记为Y&lt;sub&gt;1&lt;/sub&gt;, Y&lt;sub&gt;2&lt;/sub&gt;, ..., Y&lt;sub&gt;n&lt;/sub&gt;，那么由Y=PX，就可以得到主成分矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430203423560-776516454.png&quot; alt=&quot;&quot; width=&quot;73&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这n个行向量都是主成分，彼此之间是线性无关的，按照对数据变化解释力的强度降序排列&lt;/strong&gt;（并非被挑出来的前k个行向量才叫做主成分）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如何衡量每一个主成分所能解释的数据变化的大小呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先看n=2时，主成分为Y&lt;sub&gt;1&lt;/sub&gt;和Y&lt;sub&gt;2&lt;/sub&gt;，原变量为X&lt;sub&gt;1&lt;/sub&gt;和X&lt;sub&gt;2&lt;/sub&gt;。从下图可见Y&lt;sub&gt;1&lt;/sub&gt;为长轴变量，数据沿着这条轴的分布比较分散，数据的变化比较大，因此可以用Y&lt;sub&gt;1&lt;/sub&gt;作为第一主成分来替代X&lt;sub&gt;1&lt;/sub&gt;和X&lt;sub&gt;2&lt;/sub&gt;。那用什么指标来量化数据的变化和分散程度呢？用方差！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430203710361-1829333974.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把向量X&lt;sub&gt;1&lt;/sub&gt;和X&lt;sub&gt;2&lt;/sub&gt;的元素记为x&lt;sub&gt;1t&lt;/sub&gt;、x&lt;sub&gt;2t&lt;/sub&gt;（t=1,2,...,m），把主成分Y&lt;sub&gt;1&lt;/sub&gt;和Y&lt;sub&gt;2&lt;/sub&gt;的元素记为y&lt;sub&gt;1t&lt;/sub&gt;、y&lt;sub&gt;2t&lt;/sub&gt;（t=1,2,...,m），那么整个数据集上的方差可以如下表示（数据早已经减去均值，所以行向量的均值为0）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501135140680-1751343510.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;72&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一主成分Y&lt;sub&gt;1&lt;/sub&gt;所能解释的数据的变化，可以用主成分的方差来衡量，也就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501135259379-811191395.png&quot; alt=&quot;&quot; width=&quot;74&quot; height=&quot;50&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以用主成分的方差占总体方差的比重来衡量，&lt;span&gt;这里假设为85%，这个比例越大，则反映的信息越多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们回到有n个原始变量和n个主成分的例子，那么选择合适的转换矩阵P来计算得到主成分矩阵Y时，要让单个主成分在数据集上的方差尽可能大。那么选择主成分的第一个一般标准是少数k个主成分（1≤k&amp;lt;n）的方差占数据集总体方差的比例超过85%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;于是我们初步解决了第二个问题和第三个问题，也就是如果已知转换矩阵P和主成分矩阵Y，那么就用一个主成分的方差占数据集总体方差的比例，来衡量该主成分能解释的数据集方差的大小，然后按这个比例从大到小进行排序，并进行累加，如果到第k个主成分时，累加的比例恰好等于或者超过85%，那么就选择这k个主成分作为新变量，对数据集进行降维。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来问题倒回至第一个问题，也就是求解第二个问题和第三个问题的前提：转换矩阵P怎么算出来？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、求解转换矩阵和主成分矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面我们说了主成分矩阵Y的一个特点是，单个主成分向量Y&lt;sub&gt;i&lt;/sub&gt;的方差占总体方差的比例尽可能大，而且按照方差占比的大小，对所有的主成分进行降序排列。另外还有一个特性是所有的主成分都是线性无关的，或者说是正交的，那么所有主成分中，任意两个主成分Y&lt;sub&gt;i&lt;/sub&gt;和Y&lt;sub&gt;j&lt;/sub&gt;的协方差都是0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个特点涉及到主成分的方差，第二个特点涉及到主成分之间的协方差，这自然而然让我们想到协方差矩阵的概念，因为主成分矩阵Y的协方差矩阵的对角元素，就是每个主成分的方差，而非对角元素就是协方差。&lt;strong&gt;由于协方差为0，那么主成分矩阵的协方差矩阵为一个对角矩阵，且对角元素是降序排列的！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;由于数据集已经减去了均值，那么同样，主成分矩阵中的行向量也是0均值的，于是某两个主成分的协方差为;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430224025412-724817607.png&quot; alt=&quot;&quot; width=&quot;237&quot; height=&quot;54&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进一步得到主成分矩阵Y的协方差矩阵为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430224334662-2132783698.png&quot; alt=&quot;&quot; width=&quot;425&quot; height=&quot;94&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那知道了主成分矩阵Y的协方差矩阵是对角矩阵，对于我们求出转换矩阵P和主成分矩阵有什么用呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的，我们把Y=PX这个等式代入协方差矩阵中进行变换，就把已知的数据X和需要求的P都放到了协方差矩阵中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501063526647-1245209857.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较神奇的是，主成分矩阵Y的协方差矩阵可以由数据集X的协方差矩阵&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430230014502-188263565.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;34&quot;/&gt;得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据集X的协方差矩阵显然是一个实对称矩阵，实对称矩阵有一系列好用的性质：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、n阶实对称矩阵A必然可以对角化，而且相似对角阵的对角元素都是矩阵的特征值；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、n阶实对称矩阵A的不同特征值对应的特征向量是正交的（必然线性无关）；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、n阶实对称矩阵A的某一特征值λ&lt;sub&gt;k&lt;/sub&gt;如果是k重特征根，那么必有k个线性无关的特征向量与之对应。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此数据集X的协方差矩阵&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430230014502-188263565.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;34&quot;/&gt;作为n阶实对称矩阵，一定可以找到n个单位正交特征向量将其相似对角化。设这n个单位特征向量为e&lt;sub&gt;1&lt;/sub&gt;, e&lt;sub&gt;2&lt;/sub&gt;, ..., e&lt;sub&gt;n&lt;/sub&gt;，并按列组成一个矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501061816617-836750948.png&quot; alt=&quot;&quot; width=&quot;135&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么数据集X的协方差矩阵可以对角化为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501062214469-1563997427.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相似对角阵上的元素λ&lt;sub&gt;1&lt;/sub&gt;、λ&lt;sub&gt;2&lt;/sub&gt;、... 、λ&lt;sub&gt;n&lt;/sub&gt;是协方差矩阵的特征值（可能存在多重特征值），E中对应位置的列向量是特征值对应的单位特征向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来是高能时刻。我们把这个对角阵Λ上的元素从大到小降序排列，相应的把单位特征向量矩阵E里的特征向量也进行排列。我们假设上面已经是排列好之后的形式了，那么由于主成分矩阵的协方差矩阵也是元素从大到小降序排列的对角矩阵，那么就可以得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501063412775-2132278394.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是&lt;strong&gt;取X的协方差矩阵的单位特征向量矩阵E，用它的转置E&lt;sup&gt;T&lt;/sup&gt;来作为转换矩阵P，而X的协方差矩阵的特征值λ就是各主成分的方差&lt;/strong&gt;！有了转换矩阵P，那么由PX我们自然就可以得到主成分矩阵Y。如果我们想把数据从n维降至k维，那么从P中挑出前k个行向量，去乘以数据集X就行，就可以得到前k个主成分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此第一个问题，也就是转换矩阵P和主成分矩阵的求解就可以完成了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、主成分的方差贡献率和累计方差贡献率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来拆细了看各主成分是怎么得到的。主成分可以由协方差矩阵的单位特征向量和原始变量进行线性组合得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501071601797-1968883979.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;P&lt;sub&gt;1&lt;/sub&gt;就是由，X的协方差矩阵最大特征根λ&lt;sub&gt;1&lt;/sub&gt;的单位特征向量e&lt;sub&gt;1&lt;/sub&gt;转置而成（列向量变为行向量），于是第一主成分就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501072159518-1841028547.png&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一主成分的方差是最大的。然后第二主成分满足：(1)和第一主成分正交，(2)在剩余的其他主成分中，方差最大，表达式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501072739935-69940713.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，第k个主成分的表达式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501072928384-1039823001.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道用主成分的方差来衡量其所能解释的数据集的方差，而主成分的方差就是X的协方差矩阵的特征值λ，所以第k个主成分的方差就是λ&lt;sub&gt;k&lt;/sub&gt;。我们来定义一个指标，叫做主成分Y&lt;sub&gt;k&lt;/sub&gt;的方差贡献率，它是第k个主成分的方差占总方差的比例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501130935425-1005867384.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;64&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么前k个主成分的方差累计贡献率为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501130959080-141981584.png&quot; alt=&quot;&quot; width=&quot;102&quot; height=&quot;62&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果前k个主成分的方差累计贡献率超过了85%，那么说明用前k个主成分去代替原来的n个变量后，不能解释的方差不足15%，没有损失太多信息，于是我们可以把n个变量减少为k个变量，达到降维的目的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、主成分分析法的流程总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们为了推导出主成分分析法的线性代数解法，铺垫了很多，但推导出的结果却是相当简洁漂亮。现在我们省略中间的过程，看主成分分析法的计算流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们拿到了一份数据集，有m个样本，每个样本由n个特征（变量）来描述，那么我们可以按照以下的步骤进行降维：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、将数据集中的每个样本作为列向量，按列排列构成一个n行m列的矩阵；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、将矩阵的每一个行向量（每个变量）都减去该行向量的均值，从而使得新行向量的均值为0，得到新的数据集矩阵X；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、求X的协方差矩阵&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201904/1630478-20190430230014502-188263565.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;34&quot;/&gt;，并求出协方差矩阵的特征值λ和单位特征向量e；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、按照特征值从大到小的顺序，将单位特征向量排列成矩阵，得到转换矩阵P，并按PX计算出主成分矩阵；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、用特征值计算方差贡献率和方差累计贡献率，取方差累计贡献率超过85%的前k个主成分，或者想降至特定的k维，直接取前k个主成分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、主成分分析法计算的案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更好地掌握主成分分析法的计算过程，我们来看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们想研究上海、北京房地产指数与其他价格指数之间的关系，设定了4个变量，如下表所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501074418329-1337357407.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;样本数据取自1997年1月～2000年6月的统计资料，时间跨度为42个月，因此样本容量为m=42，为了简单起见，数据就不展示了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一步：计算数据集的协方差矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将每个样本作为列向量构成一个矩阵，并对矩阵的每一个行向量进行0均值化，得到了4行42列的数据集矩阵X。我们直接由X得到其协方差矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501084326831-338663430.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二步：计算协方差矩阵的特征值和单位特征向量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用numpy来计算，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; numpy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; linalg 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 协方差矩阵&lt;/span&gt;
C = [[1,-0.339,0.444,0.525&lt;span&gt;],
     [&lt;/span&gt;-0.339,1,0.076,-0.374&lt;span&gt;],
     [&lt;/span&gt;0.444,0.076,1,0.853&lt;span&gt;],
     [&lt;/span&gt;0.525,-0.374,0.853,1&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算特征值和特征向量&lt;/span&gt;
value,vector =&lt;span&gt; linalg.eig(C)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;特征值为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,np.round(value,4),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;特征值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,np.round(value[i],4),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;对应的特征向量为:\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,np.round(vector[:,i].T,4),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求每一列的L2范数,如果都是1，则已经单位化了。   &lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;特征向量已经是单位特征向量了：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,linalg.norm(vector,ord=2,axis=0))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
特征值为： [2.3326 1.0899 0.5399 0.0376&lt;span&gt;] 

特征值 &lt;/span&gt;2.3326&lt;span&gt; 对应的特征向量为:
 [ &lt;/span&gt;0.4947 -0.2687  0.5464  0.6201&lt;span&gt;] 

特征值 &lt;/span&gt;1.0899&lt;span&gt; 对应的特征向量为:
 [&lt;/span&gt;-0.2019  0.8378  0.5004  0.0832&lt;span&gt;] 

特征值 &lt;/span&gt;0.5399&lt;span&gt; 对应的特征向量为:
 [&lt;/span&gt;-0.844  -0.3399  0.1652  0.3805&lt;span&gt;] 

特征值 &lt;/span&gt;0.0376&lt;span&gt; 对应的特征向量为:
 [ &lt;/span&gt;0.0458  0.3322 -0.651   0.681&lt;span&gt; ] 

特征向量已经是单位特征向量了： [&lt;/span&gt;1. 1. 1. 1.]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;得到特征值是λ&lt;sub&gt;1&lt;/sub&gt;=2.3326 ，λ&lt;sub&gt;2&lt;/sub&gt;=1.0899 ，λ&lt;sub&gt;3&lt;/sub&gt;=0.5399 ，λ&lt;sub&gt;4&lt;/sub&gt;=0.0376，已经是从大到小排列好的了。而且特征向量已经是单位特征向量了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501094207592-110356652.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;104&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三步：得到转换矩阵P和主成分矩阵Y&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们得到第一个主成分如下，也就是用最大特征值的特征向量对原始变量进行线性组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501094453403-1405126883.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;26&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他三个主成分同样可以得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四步：计算主成分的方差贡献率和累计方差贡献率，选择k个主成分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了协方差矩阵的特征值，计算就非常简单了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方差贡献率&lt;/span&gt;
contrib_rate = value/&lt;span&gt;sum(value)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;方差贡献率为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,np.round(contrib_rate,4&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 累计方差贡献率&lt;/span&gt;
cum_contrib_rate =&lt;span&gt; np.cumsum(contrib_rate)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n累计方差贡献率为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,np.round(cum_contrib_rate,4))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
方差贡献率为： [0.5831 0.2725 0.135  0.0094&lt;span&gt;]

累计方差贡献率为： [&lt;/span&gt;0.5831 0.8556 0.9906 1.    ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的结果整理如下。可以看到第一主成分Y&lt;sub&gt;1&lt;/sub&gt;和第二主成分Y&lt;sub&gt;2&lt;/sub&gt;的累积方差贡献率已经达到了85.56%，可以认为用来代替4个原始变量，也不会造成太多信息损失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501095156906-664951330.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、基于投影方差最大化的数学推导&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要不耐烦，数学还是很有意思的，哈哈。我们下面用其他的方法来推导转换矩阵和主成分的计算公式，可以把主成分的求解问题转换为一个约束条件下的求最大值的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设数据集X有m个样本，每个样本是一个n维的列向量，我们把X整理成n行m列的矩阵：X=(X&lt;sub&gt;1&lt;/sub&gt;, X&lt;sub&gt;2&lt;/sub&gt;,..., X&lt;sub&gt;n&lt;/sub&gt;)&lt;sup&gt;T&lt;/sup&gt;，且已经对行向量进行了0均值化。现在我们希望用主成分分析法将n维变量降至k维。首先进行坐标变换，经过坐标变换后的新坐标系为W=｛w&lt;sub&gt;1&lt;/sub&gt;, w&lt;sub&gt;2&lt;/sub&gt;, ...,  w&lt;sub&gt;n&lt;/sub&gt;｝，其中w&lt;sub&gt;i&lt;/sub&gt;是标准正交基，W&lt;sup&gt;T&lt;/sup&gt;W是单位向量。如果第一主成分Y&lt;sub&gt;1&lt;/sub&gt;的方向就是w&lt;sub&gt;1&lt;/sub&gt;这条坐标轴的方向，那么样本投影到w&lt;sub&gt;1&lt;/sub&gt;上之后会被广泛散布，使得样本之间的差别变得特别明显，也就是投影的方差最大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设数据集X在w&lt;sub&gt;1&lt;/sub&gt;上的投影为z&lt;sub&gt;1&lt;/sub&gt;=w&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;X，那么问题就成了希望在w&lt;sub&gt;1&lt;/sub&gt;的L2范数为1的约束条件下，寻找向量w&lt;sub&gt;1&lt;/sub&gt;，使得投影的方差最大化。记数据集X的协方差矩阵为Cov(X)=Σ，则投影方差最大化问题为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501111145886-1247038002.png&quot; alt=&quot;&quot; width=&quot;282&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写成拉格朗日问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501111230029-263081404.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;40&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对w&lt;sub&gt;1&lt;/sub&gt;求导并令其为0，得到如下表达式。Σ是数据集X的协方差矩阵，所以w&lt;sub&gt;1&lt;/sub&gt;可以看做是协方差矩阵的一个特征值λ的特征向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501111315558-162406833.png&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;32&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于以上的式子，等式左右两边都左乘一个w&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;，得到数据集X在w&lt;sub&gt;1&lt;/sub&gt;上投影的方差，也就是特征值λ。由于w&lt;sub&gt;1&lt;/sub&gt;是第一主成分Y&lt;sub&gt;1&lt;/sub&gt;所在的坐标轴，那么由方差最大得到λ是最大的特征值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501111726139-301159860.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;30&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一主成分怎么求出来呢？很简单，Y&lt;sub&gt;1&lt;/sub&gt;=w&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;X（这里的w&lt;sub&gt;1&lt;/sub&gt;是特指方差最大化的解）就是了。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求出了第一主成分，我们可以再求第二主成分。假设第二主成分Y&lt;sub&gt;2&lt;/sub&gt;在新坐标轴w&lt;sub&gt;2&lt;/sub&gt;的方向上，那么Y&lt;sub&gt;2&lt;/sub&gt;应该是剩余的主成分中，使数据集在w&lt;sub&gt;2&lt;/sub&gt;上投影的方差最大的那个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据集X在w&lt;sub&gt;2&lt;/sub&gt;上的投影为z&lt;sub&gt;2&lt;/sub&gt;=w&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;X，除了满足w&lt;sub&gt;2&lt;/sub&gt;的L2范数为1的条件外，还需要满足w&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;w&lt;sub&gt;1&lt;/sub&gt;=0，其中w&lt;sub&gt;1&lt;/sub&gt;是我们已经求出来的。于是投影方差最大化问题写成拉格朗日的格式为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501113228888-1773386427.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;39&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对w&lt;sub&gt;2&lt;/sub&gt;求导，经过一系列的推导，我们最终可以得到Σw&lt;sub&gt;2&lt;/sub&gt;=λw&lt;sub&gt;2。&lt;/sub&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1630478/201905/1630478-20190501115528151-1898271855.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么w&lt;sub&gt;2&lt;/sub&gt;可以看做是协方差矩阵Σ的特征向量，对应的特征值为第二大特征值λ&lt;sub&gt;2&lt;/sub&gt;，第二主成分Y&lt;sub&gt;2&lt;/sub&gt;=w&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;T&lt;/sup&gt;X。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似的，其他主成分所在的坐标轴的标准正交基w&lt;sub&gt;i&lt;/sub&gt;是依次递减的特征值所对应的单位特征向量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;看到最后的人，祝你五一劳动节快乐！！！身体健康，工作顺利！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、《PCA数学原理》：http://www.360doc.com/content/13/1124/02/9482_331688889.shtml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/6239403.html&quot;&gt;主成分分析（PCA）原理总结&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 05:04:00 +0000</pubDate>
<dc:creator>Luv_GEM</dc:creator>
<og:description>一、主成分分析法的思想 我们在研究某些问题时，需要处理带有很多变量的数据，比如研究房价的影响因素，需要考虑的变量有物价水平、土地价格、利率、就业率、城市化率等。变量和数据很多，但是可能存在噪音和冗余，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Luv-GEM/p/10765574.html</dc:identifier>
</item>
<item>
<title>大白话5分钟带你走进人工智能-第十九节逻辑回归之优化点(4) - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/10799450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/10799450.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                                                      第十九节逻辑回归之优化点(4)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一节中我们讲解了逻辑回归导函数求解的问题，一步步推导出交叉熵损失函数的梯度。很是不容易，这节中我们一起看下逻辑回归的优化有哪些点？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一点关于逻辑回归优化：和多元性回归是一模一样。要不要设置w0？&lt;/strong&gt;比如下图：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;而对于逻辑回归来说，同样如此。&lt;strong&gt;如果设置w0，意味着有更多的可能性去找到最优解的分界线，然后把已有的数据分开；如果不设置w0，意味着分界线必须得穿过原点&lt;/strong&gt;，不可能找到完美的把红绿两个类别分开。 我们&lt;strong&gt;设置截距w0的方式是手动的为数据集x增加一列全1&lt;/strong&gt;。因此第一点：&lt;strong&gt;逻辑回归的优化或者也可以把它泛化成多元线性回归的优化，就是设置截距w0&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二点关于逻辑回归优化：如果碰到线性不可分的问题，我们可以考虑进行升维。&lt;/strong&gt;怎么来看它到底是不是线性不可分呢？我们可以把数据集放到逻辑回归里面去，算个模型出来，如果那个模型的准确率差了八丈远，很有可能会产生线性不可分的问题，你调整数据就行了。没有必要说拿到数据，先看数据的分布，看它是不是线性不可分的。比如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果做分类，要找到分界线，横轴是x2，纵轴是x1，两个维度，我们能不能在二维里面找到一个线，对已有的数据进行很好的分割？答案是不能，为什么要强调线？因为逻辑回归，它就是θTx，只不过是对它进行一步缩放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以逻辑回归的本质还是线性的，&lt;strong&gt;如果用逻辑回归基于现在的数据点不动，我们就一定得找个直线&lt;/strong&gt;，对二维的数据点进行分割，但是这是线性不可分的情况。不可能找到直线对数据进行分割。所以直线不行，能不能找一个曲线，对已有数据进行分割？当然可以，但是用曲线的话就不叫逻辑回归，就叫其它的算法了。如果非要用逻辑回归，将data数据带到agorithm算法里面，开发结果是模型。如果算法保持不动，为了让模型拟合的更好，或者是分类更好，我们就要改数据。之前在多元线性回归改变数据叫升维，比如说年龄和收入它不是线性变化的，那么给x数据里面多加一个age的平方，再多加一个维度进来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个地方思路也是一样的，升维。经验告诉我们是相乘，就是再多加一个维度，计算机模拟之后这个加的维度是x1*x2。当然如果用多项式回归对原来数据集加上x1^2+x2^2+x1*x2也可以，&lt;strong&gt;所以当维度少的情况下，可以人为地去升维，添加新的维度；维度多的情况下，直接多项式回归。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用几何图示表示，把点投影到高维空间中去，也就是升维，比如下面这张图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;会发现当再多一个维度的话，原来的数据点就得把它映射到更高的维度里面去，这里面多了一个x1x2的轴，这样我们能不能给它分割？我们知道一维的情况下，如果找到分界，一个轴的分界就是一个点；二维的情况下是个平面，如果要找到分界，对于线性回归来说是条直线；如果是三维的话，如果把一个立体分成两部分，我们需要一个平面。变成三维之后生成一个维度，原来线性不可分的就变成线性可分的了，就是去找一个平面，把两个不好分的类别很好的分开。这就意味着我们可以再一次去应用线性的模型逻辑回归去找一个平面，相当于改变数据点，去升维来做分类了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三点关于逻辑回归优化：改变阈值&lt;/strong&gt;。之前灌输的概念是0到1的区间，我们拿0.5来作为分界，大于0.5的就是1这个类别；小于0.5的就是0这个类别。但是0.5这个阈值可以调可以变，根据需求来变。如果是0到1这个区间范围内，把0.5作为一个分类的阈值的话，你觉得对正例和负例进行分类是公平的。什么叫不公平？就是把阈值从0.5调到0.3，小于0.3的才是负例，大于0.3的才是正例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看个生活中的例子，假如模型是来判别某个病人它是否得了癌症，如果病人是癌症，模型给它判定成不是癌症，这件事情很明显是判错；还有一种情况如果病人它没有得癌症，模型判别是癌症，也是判错了。这件事情哪一个更不能接受，就要看需求，看医院算法工程师告诉你的需求是什么，假如医院告诉我的需求是如果病人是癌症，模型给它判定成不是癌症这种情况不可饶恕。你就要把这种错误发生的概率给它变小。什么情况判定为不是癌症？是和不是就是一个正例和一个负例。如果想要避免上面这种情况发生，我们可以把阈值从0.5调成0.3，换句话说就是模型判别的结果ŷ小于0.3，我们认为没有得癌症，如果大于0.3，就认为得了癌症，也就是尽可能的多判断些癌症病人出来，使如果病人是癌症，模型给它判定成不是癌症这种情况少发生点。因为ŷ大于0.3就说你得癌症了，其实很多人没有得癌症，所以错误率变大就是代价。虽然整体的错误率大了，但是规避一些不能接受的风险。这风险按需求来定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上阈值调整经常发生，比如你设计一个模型，公司让你用这个模型去炒股，如果是0.5的话就意味只要大于0.5，认为这支股票会涨；只要小于0.5，就告诉公司会跌很高了。实际上大于0.5的情况很多，0.51大于0.5，0.99大于0.5，0.49小于0.5，0.01小于0.5。所以那些股票的软件它通常都是把这个阈值大于0.8，它会告诉公司说这支股票会涨，小于0.2才会告诉公司这支股票会跌。根据调整阈值可以来规避一些不能接受的风险。因为51%会涨，49%会跌，这个风险还是很大的。比如说去银行里面买理财，它首先会让我到一个表，之后她说我是最保守型用户，意味着理财产品大于0.95的时候我才会去买，小于0.95的都不会去买。其实就是它通过填表，获取到了你这个人心中的一个阈值。所以阈值是可以来调的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;阈值是在什么时候来调的？就是θ已经算出来了，你要去使用这个模型，θ和x带到1/（1+e-θTx）公式里面来，然后会得到一个ŷ，是0到1之间的一个值，在使用ŷ的时候，你不再跟0.5进行判别了，而是跟0.3进行判别。特意强调一下，阈值0.5和0.3是在使用的时候才会去改，在训练的时候其实和阈值没关系&lt;/strong&gt;。因为训练时候，正例就是1.0的概率，负例就是0.0概率，所以它在训练的时候没有这样的阈值，只有在使用的时候才有阈值。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们总结下&lt;strong&gt;逻辑回归优化：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一点是设置w0，最好加上，多元性回归里面同样也可以加上w0，为了有更多的模型的可能性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二点是升维， 升维在多元性回归里面，是为了更好的拟合非线性的数据，在逻辑回归里进行升维是为了解决线性不可分的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三点是为了去规避一些风险，在使用模型的时候可以去调一下阈值，默认二分类阈值就是0.5，那我们可以把它调高或者调低，根据需求来定。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 03:38:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>第十九节逻辑回归之优化点(4) 上一节中我们讲解了逻辑回归导函数求解的问题，一步步推导出交叉熵损失函数的梯度。很是不容易，这节中我们一起看下逻辑回归的优化有哪些点？ 第一点关于逻辑回归优化：和多元性回</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/10799450.html</dc:identifier>
</item>
<item>
<title>用函数式编程，从0开发3D引擎和编辑器（一） - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/10799388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/10799388.html</guid>
<description>&lt;p&gt;大家好，欢迎你踏上3D编程之旅～&lt;/p&gt;
&lt;p&gt;本系列的素材来自我们的产品:&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/10508464.html&quot;&gt;Wonder-WebGL 3D引擎和编辑器&lt;/a&gt; 的整个开发过程，探讨了在从0开始构建3D引擎和编辑器的过程中，每一个重要的功能点、设计方案的思考、讨论、总结和延伸。&lt;/p&gt;
&lt;p&gt;本系列避免陷入细节的实现代码，使用伪代码代替。所以没有可直接运行的代码，取而代之的是经过抽象和提炼的伪代码/模式。&lt;/p&gt;

&lt;p&gt;我有三个小目标：&lt;br/&gt;1.完全创造&lt;br/&gt;完全从0开始，创造一个有深度、有难度、有挑战的产品。&lt;br/&gt;所以Wonder被创造出来了，并且会持续地发展。&lt;/p&gt;
&lt;p&gt;2.完全纪录&lt;br/&gt;完全纪录创造的过程，把我整个人生都沉淀下来。&lt;br/&gt;所以有了&lt;a href=&quot;https://www.douban.com/group/topic/78459659/&quot;&gt;打造3D引擎，第8000小时开始&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;3.完全分享&lt;br/&gt;完全分享所有的创造、纪录，把我走过的路分享给需要的人。&lt;br/&gt;所以有了&lt;a href=&quot;https://github.com/Wonder-Technology&quot;&gt;Wonder开源&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;本系列为了完成第2个和第3个目标，会把开发Wonder的思考沉淀下来，进行提炼和升华，分享给世界，也分享给我自己。&lt;/p&gt;
&lt;p&gt;希望对你有所帮助～&lt;/p&gt;


&lt;p&gt;1.完全从0开始，素材来自我们的产品&lt;a href=&quot;https://www.wonder-3d.com/&quot;&gt;Wonder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们会一边开发Wonder，一边在本系列写文章分享。&lt;br/&gt;因为Wonder在不断更新中，所以本系列也会不断更新。&lt;/p&gt;
&lt;p&gt;2.完全、彻底地使用函数式编程。&lt;/p&gt;
&lt;p&gt;现在3D领域使用函数式编程的资料很少，主流还是使用面向对象。&lt;br/&gt;我以前也是用面向对象，不过自从我开始接触函数式编程，就拥抱了它。&lt;br/&gt;面向对象很好，函数式编程也很好。使用哪一个，是每个人的自由。&lt;/p&gt;
&lt;p&gt;本系列希望能扩展大家的视野和思维，展示函数式编程的魅力。&lt;/p&gt;
&lt;p&gt;3.不仅探讨3D引擎，而且以编辑器作为主线。&lt;/p&gt;
&lt;p&gt;讨论编辑器的资料很少，讨论3D引擎+编辑器的更少。&lt;/p&gt;
&lt;p&gt;本系列完全基于我们的实战经验，以编辑器作为主线，3D引擎作为底层实现。&lt;/p&gt;
&lt;p&gt;两者的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/m8dpvu2h7kkzlgild8fb9qn5/%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%95%E6%93%8E%E5%85%B3%E7%B3%BB2.png&quot; alt=&quot;编辑器引擎关系2.png-6.7kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.重点放在设计和思考上，避免实现细节&lt;/p&gt;
&lt;p&gt;本系列希望展示来自于实战的思考和设计，在较高的层面进行探讨，所以会用伪代码作为实现的说明，避免细节的干扰。&lt;/p&gt;
&lt;p&gt;5.类型驱动设计。尽量用Type和伪代码替代UML来探讨设计。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/22959608&quot;&gt;Curry-Howard 同构&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类型即命题，程序即证明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类型既然对应逻辑命题，那能用它来表示设计吗？&lt;br/&gt;具体就是：&lt;br/&gt;1）能表达领域模型吗？&lt;/p&gt;
&lt;p&gt;2）能表达领域模型的交互关系吗？&lt;/p&gt;
&lt;p&gt;3）能替代单元测试？&lt;/p&gt;
&lt;p&gt;使用类型进行约束，然后在编译时检查和发现错误，从而不再需要单元测试。&lt;/p&gt;
&lt;p&gt;4）能驱动设计吗？&lt;/p&gt;
&lt;p&gt;这样就能快速验证设计方案：&lt;br/&gt;通过定义类型来描述需求和设计，不需要具体实现；&lt;br/&gt;验证通过后，再一一实现。&lt;/p&gt;
&lt;p&gt;本系列使用&lt;a href=&quot;https://reasonml.github.io/docs/en/what-and-why&quot;&gt;Reason语言&lt;/a&gt;，大部分满足1和2，部分满足3和4。&lt;/p&gt;
&lt;p&gt;这是因为Reason语言的类型没有&lt;a href=&quot;https://www.zhihu.com/question/55342708&quot;&gt;Idris&lt;/a&gt;强大，所以3和4不能完全满足。。。。。。&lt;/p&gt;
&lt;p&gt;或许以后可以使用Idris来重写。。。。。。&lt;/p&gt;
&lt;p&gt;不过总的来说，我对Reason语言还是非常满意的，详见我们在知乎上的总结-&lt;a href=&quot;https://www.zhihu.com/question/264265665/answer/293472713&quot;&gt;如何评价 reasonml ?&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参考资料&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/lsgx/blog/487432&quot;&gt;程序与证明&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/series/designing-with-types.html&quot;&gt;Designing with types&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.了解Wonder的技术内幕&lt;/p&gt;
&lt;p&gt;2.学习从0开发3D引擎和编辑器&lt;/p&gt;
&lt;p&gt;3.学习函数式编程及其在3D领域的应用&lt;/p&gt;
&lt;p&gt;4.学习3D编程的功能实现，如纹理、光照、模型等功能的实现&lt;/p&gt;
&lt;p&gt;5.学习设计和架构，如Data Oriented、多线程、管道job等设计&lt;/p&gt;

&lt;p&gt;Wonder目前开发到1.0版本，因此本系列对应Wonder 0.1 - 1.0版本的内容。&lt;br/&gt;(随着Wonder不断更新新版本，本系列也会对应更新）&lt;/p&gt;
&lt;p&gt;Wonder 1.0产品展示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.wonder-3d.com/&quot;&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/iqbc0nv5xrdsn7h1tc33yty1/editor_show.gif&quot; alt=&quot;editor_show.gif-1353.8kB&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本系列目录&quot;&gt;本系列目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;函数式编程准备&lt;/li&gt;
&lt;li&gt;初步需求分析与设计&lt;/li&gt;
&lt;li&gt;搭建基础框架&lt;/li&gt;
&lt;li&gt;操作GameObject&lt;/li&gt;
&lt;li&gt;操作Component&lt;/li&gt;
&lt;li&gt;Redo/Undo&lt;/li&gt;
&lt;li&gt;端对端测试&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;li&gt;多线程渲染&lt;/li&gt;
&lt;li&gt;运行/停止&lt;/li&gt;
&lt;li&gt;事件和CameraContronller组件&lt;/li&gt;
&lt;li&gt;IMGUI&lt;/li&gt;
&lt;li&gt;增加资产Asset&lt;/li&gt;
&lt;li&gt;导入/导出&lt;/li&gt;
&lt;li&gt;发布本地包&lt;/li&gt;
&lt;li&gt;快捷键&lt;/li&gt;
&lt;li&gt;Picking&lt;/li&gt;
&lt;li&gt;Transform Gizmo&lt;/li&gt;
&lt;li&gt;PWA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢你能读到这里，欢迎你提出各种建议或意见，为你服务是我的荣幸～感谢～&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chaogex/p/10508464.html&quot;&gt;Wonder-WebGL 3D引擎和编辑器&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/22959608&quot;&gt;Curry-Howard 同构&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://my.oschina.net/lsgx/blog/487432&quot;&gt;程序与证明&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/series/designing-with-types.html&quot;&gt;Designing with types&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://reasonml.github.io/docs/en/what-and-why&quot;&gt;Reason语言&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 03:12:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>本系列探讨了在从0开始构建3D引擎和编辑器的过程中，每一个重要的功能点、设计方案的思考、讨论、总结和延伸。本文是开篇序言。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaogex/p/10799388.html</dc:identifier>
</item>
<item>
<title>CMU-15445 LAB2:实现一个支持并发操作的B+树 - gatsby123</title>
<link>http://www.cnblogs.com/gatsby123/p/10799313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/10799313.html</guid>
<description>&lt;p&gt;经过几天鏖战终于完成了lab2，本lab实现一个支持并发操作的B+树。简直B格满满。&lt;/p&gt;

&lt;h2 id=&quot;为什么需要b树&quot;&gt;为什么需要B+树&lt;/h2&gt;
&lt;p&gt;B+树本质上是一个索引数据结构。比如我们要用某个给定的ID去检索某个student记录，如果没有索引的话，我们可能从第一条记录开始遍历每一个student记录，直到找到某个ID和我们给定的ID一致的记录。可想而知，这是非常耗时的。&lt;br/&gt;如果我们已经维护了一个以ID为KEY的索引结构，我们可以向索引查询这个ID对应的记录所在的位置，然后直接从这个位置读取这个记录。从索引查询某个ID对应的位置，这个操作需要高效，B+树能保证以O(log n)的时间复杂度完成。&lt;/p&gt;
&lt;h2 id=&quot;b树的性质&quot;&gt;B+树的性质&lt;/h2&gt;
&lt;p&gt;B+树由叶子节点和内部节点组成，和其它树结构差不多，但是对(KEY, VALUE)的个数和排列顺序有要求。&lt;/p&gt;
&lt;h3 id=&quot;叶子节点&quot;&gt;叶子节点：&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; *  ---------------------------------------------------------------------------
 * | HEADER | KEY(1) + RID(1) | KEY(2) + RID(2) | ... | KEY(n) + RID(n) 
 *  ---------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设叶子结点最多能容纳个n个(KEY, RID)对，那么该叶子节点任何时候都不能少于n/2向上取整个(KEY, RID)对。假设(KEY, RID)对个数为x，那么x必须满足：&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;ceil(n/2) &amp;lt;= x &amp;lt;= n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ceil表示向上取整，博客园不支持LaTeX o(╯□╰)o。&lt;br/&gt;KEY是search key，RID是该KEY对应的记录的位置。(KEY, RID)对按照KEY的増序进行排列。&lt;br/&gt;HEADER的结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; * ----------------------------------------------------------------------------------------
 * | PageType (4) | LSN (4) | CurrentSize (4) | MaxSize (4) | ParentPageId (4) | PageId(4) |
 * ---------------------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ParentPageId指向父节点。&lt;/p&gt;
&lt;h3 id=&quot;内部节点&quot;&gt;内部节点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; *  ----------------------------------------------------------------------------------------
 * | HEADER | INVALID_KEY+PAGE_ID(1) | KEY(2)+PAGE_ID(2) | ... | KEY(n)+PAGE_ID(n) |
 *  ----------------------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设内部节点最多容纳n个(KEY, PAGE_ID)对，和叶子节点一样，x必须满足：&lt;/p&gt;
&lt;pre class=&quot;math&quot;&gt;
&lt;code&gt;ceil(n/2) &amp;lt;= x &amp;lt;= n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;KEY表示search key，PAGE_ID指的是子节点的ID。&lt;br/&gt;(KEY, PAGE_ID)对按照KEY的増序进行排列。&lt;br/&gt;第一个KEY是无效的。&lt;br/&gt;假设PAGE_ID(i)对应的子树中的KEY用SUB_KEY表示，那么SUBKEY都满足：KEY(i) &amp;lt;= SUB_KEY &amp;lt; KEY(i+1)。&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_1_page_node.PNG&quot; alt=&quot;lab2_1_page_node.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查找操作&quot;&gt;查找操作&lt;/h2&gt;
&lt;p&gt;课本p489给出了find的伪代码。总结来说就是先找到KEY应该出现的叶子节点，然后在该叶子节点中，查找KEY对应的RID。&lt;br/&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_2_find.PNG&quot; alt=&quot;lab2_2_find.PNG&quot;/&gt;&lt;br/&gt;假如我们希望查找的KEY为38，第一步在根节点A查找38应该出现在哪个子节点中，根据之前的性质，38应该出现在以B为根的子树中，继续查找节点B，以此类推，最终38应该出现在H的叶子节点中。最后我们在H中查找38。&lt;br/&gt;所以对于内部节点，我们需要一个Lookup(const KeyType &amp;amp;key,const KeyComparator &amp;amp;comparator)方法，查找key应该出现在哪个子节点对应的子树中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INDEX_TEMPLATE_ARGUMENTS
ValueType
B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup(const KeyType &amp;amp;key,
                                       const KeyComparator &amp;amp;comparator) const {
    assert(GetSize() &amp;gt;= 2);
    // 先找到第一个array[index].first大于等于key的index（从index 1开始）
    int left = 1;
    int right = GetSize() - 1;
    int mid;
    int compareResult;
    int targetIndex;
    while (left &amp;lt;= right) {
        mid = left + (right - left) / 2;
        compareResult = comparator(array[mid].first, key);
        if (compareResult == 0) {
            left = mid;
            break;
        } else if (compareResult &amp;lt; 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    targetIndex = left;

    // key比array中所有key都要大
    if (targetIndex &amp;gt;= GetSize()) {
        return array[GetSize() - 1].second;
    }

    if (comparator(array[targetIndex].first, key) == 0) {
        return array[targetIndex].second;
    } else {
        return array[targetIndex - 1].second;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为KEY是已排序的，所以可以先二分查找第一个大于或等于KEY的下标targetIndex，如果targetIndex对应的KEY就是我们要找的KEY，那么targetIndex对应的value就是下一步要搜索的节点，否则targetIndex-1对应的value是下一步应该搜索的节点。&lt;/p&gt;
&lt;h2 id=&quot;插入操作&quot;&gt;插入操作&lt;/h2&gt;
&lt;p&gt;课本p494给出了完整的insert(key, value)操作的伪代码。&lt;br/&gt;思路就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先找到key应该出现的叶子节点，将(key, value)插入到该叶子节点中。&lt;/li&gt;
&lt;li&gt;如果插入后该叶子节点中键值对超出了最大值，则进行分裂。如果插入后没有超出最大限制，那么就完成任务了。&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_3_insert.png&quot; alt=&quot;lab2_3_insert.png&quot;/&gt;&lt;br/&gt;如上图准备插入(7, 'g')，但是插入前p1叶子结点已经满了，那么先插入，然后将插入后的节点，分裂出新的节点p3，将p1原来一半的元素挪到p3，然后将(6, p3)插入到父节点p2中，其中6是新创建的节点p3第一个key。&lt;br/&gt;同样的，如果我们在父节点p2中插入了(6, p3)导致了p2超过最大限制，p2也需要分裂，以此类推，这个过程可能产生新的根节点。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;删除操作&quot;&gt;删除操作&lt;/h2&gt;
&lt;p&gt;课本p498给出了完整的delete(key)操作的伪代码。&lt;br/&gt;思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先找到key应该出现的叶子节点，删除该叶子节点中key对应的键值对。&lt;/li&gt;
&lt;li&gt;删除后如果个数少于规定最少个数，那么有两个措施，如果当前节点个数和兄弟节点个数总和不超过允许的最大个数，那么进行并合。否则，从兄弟节点中借一个元素。&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_4_delete.png&quot; alt=&quot;lab2_4_delete.png&quot;/&gt;&lt;br/&gt;上图第一种情况：&lt;br/&gt;删除(7, 'g')后，p3只有一个元素，少于最少允许的个数（2），于是将(6, 'f')已到兄弟节点p1, 删除p3节点，并且删除父节点p2中的(6, p3)，如果p2也少于最少允许个数，递归进行。&lt;br/&gt;第二种请求：&lt;br/&gt;删除p3的(8, 'h')后，p3只有一个元素，于是从兄弟节点p1借一个元素(6, f)，然后将父节点(7, 'g')修改为(6, 'f')，这种情况不需要递归。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最粗暴的方式就是在find, insert, delete开始就加锁，执行完毕后解锁，这样逻辑上没有问题，但是并发效率很低，相当于串行执行。&lt;/p&gt;
&lt;h2 id=&quot;crabbing协议&quot;&gt;crabbing协议&lt;/h2&gt;
&lt;p&gt;该协议允许多个线程同时访问修改B+树。&lt;/p&gt;
&lt;h2 id=&quot;基本算法&quot;&gt;基本算法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;对于查询操作，从根节点开始，首先获取根节点的&lt;strong&gt;读锁&lt;/strong&gt;，然后在根节点中查找key应该出现的孩子节点，获取孩子节点的&lt;strong&gt;读锁&lt;/strong&gt;，然后释放根节点的&lt;strong&gt;读锁&lt;/strong&gt;，以此类推，直到找到目标叶子节点，此时该叶子节点获取了读锁。&lt;/li&gt;
&lt;li&gt;对于删除和插入操作，也是从根节点开始，先获取根节点的&lt;strong&gt;写锁&lt;/strong&gt;，一旦孩子节点也获取了&lt;strong&gt;写锁&lt;/strong&gt;，检查根节点是否安全，如果安全释放孩子节点所有祖先节点的&lt;strong&gt;写锁&lt;/strong&gt;，以此类推，直到找到目标叶子节点。节点安全定义如下：如果对于插入操作，如果再插入一个元素，不会产生分裂，或者对于删除操作，如果再删除一个元素，不会产生并合。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个查找过程的例子，查找key=38：&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_5_crabbing_protol_find.png&quot; alt=&quot;lab2_5_crabbing_protol_find.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个插入过程的例子，插入25：&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/cmu-15445/lab2/lab2_6-crabbing_protol_insert.png&quot; alt=&quot;lab2_6-crabbing_protol_insert.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;crab有螃蟹的意思，了解完crabbing协议加锁的过程，应该不难理解为什么叫crabbing协议了吧。&lt;/p&gt;
&lt;h2 id=&quot;需要注意的地方&quot;&gt;需要注意的地方&lt;/h2&gt;
&lt;p&gt;我们需要保护根节点id。&lt;br/&gt;考虑下面这种情况：&lt;br/&gt;两个线程同时执行插入操作，插入前B+树只有一个节点，线程一插入当前key后将分裂，生成一个新的根节点。另一个线程在线程一分裂前读取了旧的根节点，从而将key插入到了错误的叶子节点中。&lt;br/&gt;解决办法：&lt;br/&gt;在访问，修改root_page_id_的地方加锁，访问或者修改完毕root_page_id_后释放锁。root_page_id_指向的是该B+树的根节点，会保存在内存中，以便快速查找。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;前文提到我们需要保护root_page_id_这个变量，可以用一个mutex，访问或修改前加锁，访问或者修改后释放锁。一次加锁只能对应一次解锁，如果多调用了一次unlock()，同样起不到保护的作用。unlock()调用分别在各个函数中，很可能不小心就多调用了次，所以千万要小心。&lt;/li&gt;
&lt;li&gt;必须先释放Page上的锁，然后才能unpin该Page。为什么？我们知道unpin后，如果pin_count为0，那么这个Page将被送到LRUReplacer，当没有足够的Page时，将从LRUReplacer中取Page，将该Page的内容保存到磁盘后用于保存其它其它页的内容。考虑下面这个场景：在插入25的过程中，查找到目标叶子节点，这时该叶子节点肯定被加上了写锁，如果我们执行完插入后，先unpin了该Page，然后才释放该Page的锁。可能出现这种情况，在unpin完后，释放锁前，这个Page被送到了LRUReplacer，另一个线程请求访问页面1，但是所有的Page都被占用了，LRUReplacer选择这个淘汰带锁的这个Page来保存页面1，因为该Page的锁还没释放，所以另一个线程可以直接访问或者修改，这是回到原来的线程，再释放已经晚了。&lt;/li&gt;
&lt;li&gt;lab本身提供的测试case是完全不够的，就算全部通过了，也不能保证代码是正确的。我自己加入了很多测试，涵盖多个线程的，根节点分裂等case。原代码只有对BPlusTree的测试，所以我添加了对BPlusTreeInternalPage和BPlusTreeLeafPage单独的测试，这样在用BPlusTreeInternalPage和BPlusTreeLeafPage构建BPlusTree前能保证自己是正确的。&lt;/li&gt;
&lt;li&gt;在使用完一个Page后应该立刻unpin掉，不能忘记unpin，如果忘记unpin的话，那么这个Page将永远不能用于保存其它页，当所有Page都被占用后，系统将无法继续运行。这个问题一度困扰我很久，一定要非常仔细。&lt;/li&gt;
&lt;li&gt;本lab的一个难点是调试，多使用assert和log。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，贴个实现：&lt;a href=&quot;https://github.com/gatsbyd/cmu_15445_2018&quot; class=&quot;uri&quot;&gt;https://github.com/gatsbyd/cmu_15445_2018&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 May 2019 02:34:00 +0000</pubDate>
<dc:creator>gatsby123</dc:creator>
<og:description>概述 经过几天鏖战终于完成了lab2，本lab实现一个支持并发操作的B+树。简直B格满满。 B+树 为什么需要B+树 B+树本质上是一个索引数据结构。比如我们要用某个给定的ID去检索某个student</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/10799313.html</dc:identifier>
</item>
<item>
<title>Ajax跨域问题及解决方案 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</guid>
<description>&lt;ul&gt;&lt;li&gt;做两个简单的小项目复现Ajax跨域问题. 后端语言使用Java&lt;/li&gt;
&lt;li&gt;首先是一个简单的订单系统, 通过访问&lt;code&gt;/loadOrderList&lt;/code&gt;, 最终以json串形式返回订单集合. 该项目使用Tomcat发布在7070端口.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/loadOrderList&quot;)
@ResponseBody
public List&amp;lt;Order&amp;gt; loadOrderList(String uid){
    //模拟订单数据
    Order o1 = new Order();
    o1.setId(&quot;111&quot;);
    o1.setTotal(333.33);
    o1.setDate(&quot;2019-4-29&quot;);

    Order o2 = new Order();
    o2.setId(&quot;222&quot;);
    o2.setTotal(444.44);
    o2.setDate(&quot;2019-5-29&quot;);

    Order o3 = new Order();
    o3.setId(&quot;333&quot;);
    o3.setTotal(555.55);
    o3.setDate(&quot;2019-6-29&quot;);

    List&amp;lt;Order&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(o1);
    list.add(o2);
    list.add(o3);

    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在另一个项目中做一个向订单系统发送一个ajax请求, 获取订单集合. 该项目使用Tomcat插件发布在9090端口.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//index.jsp

&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        function sendAjax() {
            $.post(&quot;http://localhost:7070/order/loadOrderList&quot;, &quot;uid=1234&quot;, function (data) {
                alert(data);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;javascript:sendAjax()&quot;&amp;gt;sendAjax&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;sendAjax&lt;/code&gt;超链接向订单系统发送ajax请求.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430191117328.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;通过开发者工具发现虽然服务器以状态码200响应回来, 但是控制台却报错了.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430191353533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430193153869.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;这就是Ajax跨域出错的一种表现, 下面分析原因.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;Ajax跨域问题是由浏览器的同源策略造成的, 首先要理解&lt;code&gt;源&lt;/code&gt;这个概念.&lt;/li&gt;
&lt;li&gt;我们可以通过协议+域名+端口确定一个源. 在上面的示例中, 你可以把一个项目理解为一个源. Ajax请求可以对源内的资源发起访问, 但是不同源之间进行Ajax就会有问题.&lt;/li&gt;
&lt;li&gt;当向不同源的资源发起Ajax请求时, 浏览器会加上&lt;code&gt;Origin&lt;/code&gt;字段来标识源&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Accept: */*
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive
Content-Length: 8
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Host: localhost:7070
Origin: http://localhost:9090   协议+域名+端口&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;服务器会根据&lt;code&gt;Origin&lt;/code&gt;字段决定是否同意这次请求, 如果&lt;code&gt;Origin&lt;/code&gt;指定的源不在许可范围内, 服务器会返回一个不带有&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段的响应. 浏览器解析时发现缺少了这个字段, 就会报错. 这种错误不能通过状态码识别, 因为状态码很有可能就是200(见上面的案例).&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;下面介绍最常用Ajax跨域解决方案.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一.-在服务端添加响应头access-control-allow-origin&quot;&gt;一. 在服务端添加响应头&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;既然我们已经知道了Ajax跨域失败是因为响应中缺少了响应头&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, 那么就想办法加上去.&lt;/li&gt;
&lt;li&gt;以Java项目为例, 在后端我们使用&lt;code&gt;CORSFilter&lt;/code&gt;过滤器加上该响应头.&lt;/li&gt;
&lt;li&gt;(假设是Maven项目), 首先在&lt;code&gt;pom.xml&lt;/code&gt;中添加坐标&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.thetransactioncompany&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;cors-filter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后在&lt;code&gt;web.xml&lt;/code&gt;中对过滤器进行配置.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;CORS&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;com.thetransactioncompany.cors.CORSFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.allowOrigin&amp;lt;/param-name&amp;gt;&amp;lt;!--这个标签是关键, *代表所有源都能访问--&amp;gt;
            &amp;lt;param-value&amp;gt;*&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportedMethods&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;GET, POST, HEAD, PUT, DELETE&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportedHeaders&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.exposedHeaders&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;Set-Cookie&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;cors.supportsCredentials&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;

    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;CORS&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;配置后重启订单项目, 再次发起Ajax请求可以看到成功返回数据, 响应头中包含了&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, 值为发起Ajax请求的源.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430194918105.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190430195151524.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-使用jsonp解决&quot;&gt;二. 使用JSONP解决&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上面直接通过过滤器添加响应头的方法可以说是对症下药, 那么还有没有什么偏方呢?&lt;/li&gt;
&lt;li&gt;还真的有. 在jsp文件中经常通过通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引入一段js代码, 这段代码通常来源于网络, 也就是不同源. 那么我们不妨通过&lt;code&gt;&amp;lt;srcipt&amp;gt;&lt;/code&gt;标签完成Ajax请求, 这样便顺带解决了跨域问题.&lt;/li&gt;
&lt;li&gt;下面还是沿用上面的案例进行演示.&lt;/li&gt;
&lt;li&gt;我们对发送ajax的jsp进行修改&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        function doCallBack(data){
            var str = JSON.stringify(data);
            alert(str);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;http://localhost:7070/order/loadOrderList3?uid=111&amp;amp;callBack=doCallBack&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面的代码中, 我们首先定义了&lt;code&gt;doCallBack()&lt;/code&gt;函数, 它接收一个字符串参数, 并且会把接收到的字符串显示出来.&lt;/li&gt;
&lt;li&gt;然后在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签中编写&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签, 我们将通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签请求订单系统, 订单系统将会返回一段js代码, 这段js代码会调用&lt;code&gt;doCallBack()&lt;/code&gt;方法.&lt;/li&gt;
&lt;li&gt;为了能够拼接出&lt;code&gt;doCallBack(字符串参数...)&lt;/code&gt;js代码, 我们在订单系统中作如下操作.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/loadOrderList3&quot;)
@ResponseBody
public String loadOrderList3(String uid, String callBack){
    //模拟订单数据
    Order o1 = new Order();
    o1.setId(&quot;111&quot;);
    o1.setTotal(333.33);
    o1.setDate(&quot;2019-4-29&quot;);

    Order o2 = new Order();
    o2.setId(&quot;222&quot;);
    o2.setTotal(444.44);
    o2.setDate(&quot;2019-5-29&quot;);

    Order o3 = new Order();
    o3.setId(&quot;333&quot;);
    o3.setTotal(555.55);
    o3.setDate(&quot;2019-6-29&quot;);

    List&amp;lt;Order&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(o1);
    list.add(o2);
    list.add(o3);

    //拼接js代码
    String result = callBack + &quot;(&quot; + JSON.toJSONString(list) + &quot;)&quot;;
    return result;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;这个想法是不是很妙? 明白这个原理之后, 我们可以使用jQuery方便进行JSONP操作, 在上面的代码中我们人为指定了一个名为&lt;code&gt;doCallBack&lt;/code&gt;的函数, 而jQuery会随机用时间戳生成一个函数名, 原理和上面是一样的.&lt;/li&gt;
&lt;li&gt;所以完成一开时点击超链接发送Ajax请求只需要如下几步.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.11.3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        function sendAjax(){
            $.getJSON(&quot;http://localhost:7070/order/loadOrderList3?callBack=?&quot;,&quot;uid=111&quot;,
            function (data) {
                var str = JSON.stringify(data);
                alert(str);
            });
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;javascript:sendAjax()&quot;&amp;gt;sendAjax&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上面两种解决办法在思路上有着本质的不同. 方案一抓住&lt;code&gt;CORS&lt;/code&gt;跨域访问问题的本质, 在后端加上响应头解决跨域问题. 方案二&lt;code&gt;JSONP&lt;/code&gt;利用的是&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签能够跨域获取js代码的特性, 绕过跨域问题.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 30 Apr 2019 23:10:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 复现Ajax跨域问题 做两个简单的小项目复现Ajax跨域问题. 后端语言使用Java 首先是一个简单的订单系统, 通过访问 , 最终以json串形式返回订单集合. 该项目使用Tomcat发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10799042.html</dc:identifier>
</item>
<item>
<title>子网划分和无分类编址 - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10795238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10795238.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;网络标识相同的计算机必须属于同一个网络，一个B类的IP网络，在理论上是允许六万多台计算机连接的但在实际网络结构中这种一般是不存在的，这样就浪费了资源，套句时髦的话，为解决日益增长的网络设备IP需求与日益减少的网络IP的矛盾和日益增加的网络号与有限空间存储路由的矛盾，因此子网划分应运而生。&lt;/p&gt;
&lt;h3&gt;子网&lt;/h3&gt;
&lt;p&gt;在一个有许多物理网络的单位，可以将所属的物理网络划分为N个子网。至于划分几个，这要看单位自己内部需求了，除了本单位外，在外部网络看来，你还是只有一个网络，也就是说这个子网对网络来说是不可见的。而它的划分方法是从网络的主机号借用几位作为子网号，所以主机号也要相应减小同样的位数，在IP和网络分层提过，分类的IP是两级的地址（网络号，主机号），但如今对本单位来说，这个IP地址已经变成三级IP地址了（网络号，子网号，主机号）。现在，有个数据包从外部网络要发给本单位C号子网的某个主机，它会先根据数据报文中目的IP的网络号（划分子网，只是把IP的地址的主机号在划分）找到连接在单位网络上的路由器，然后这个路由器在收到数据包后，按目的网络号和子网号找到这个C号子网，在找到目标主机，然后把数据包交给目的主机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1333075/201904/1333075-20190430134951299-1265572425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但现在出现了一个问题，根据数据包里的目的IP地址并不包含子网划分的信息，就是这个路由器怎么会知道是C号子网，而不会是A,B号子网哪。如果有网络的基础知识的话，一定听过一个词，子网掩码。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;子网掩码&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现在因特网规定，所有的网络都必须使用子网掩码，路由器的路由表也必须有子网掩码这一栏。即使你不划分子网，那也必须有子网掩码（默认子网掩码）。子网掩码用二进制标识，也是一个32位的数字，对应IP地址网络标识部分的位（网络号 + 子网号）全部为1，对应IP地址主机标识的部分都为0，现在，一个IP地址就可以不受自己类别限制，而可以用这样的子网掩码，自由的定位自己的网络标识长度。子网掩码不能单独使用，必须结合IP地址，它屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是局域网还是远程网。141.14.72.24/18（CIDR斜线记法）  这个18 就告诉我们网络号有18位，即18个1&lt;/p&gt;
&lt;p&gt;11111111    11111111  01001000  00000000  IP：141.14.72.24&lt;/p&gt;
&lt;p&gt;11111111    11111111  11000000  00000000 掩码为 255.255.292.0&lt;/p&gt;
&lt;p&gt;11111111    11111111  01000000 00000000  网络地址：141.14.64.0&lt;/p&gt;
&lt;p&gt;注意：用相同的IP地址和不同的子网掩码可以得出相同的网络地址，但是不同的掩码的效果是不同的，因为它们子网号和主机号位数是不一样的，所以可划分的子网数和每个子网最大主机数也都是不一样的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;给某个网络分配3个C类地址，ISP（地址网络提供商）的路由表就会有三条路由条目，路由表的不断变大，寻址效率不断下降。而且虽然划分子网在一定程序上缓解了IP地址紧张的问题，但最终也将很快全部耗尽，为了解决这些问题和缓解IP地址紧张。于是出现一个折中的办法，那就是无类域间路由，简称CIDR。就以把这三个网段 198.168.1.0    198.168.2.0  198.168.3.0 汇聚成一条路由 198.168.0.0/16（路由聚合）,这样ISP的路由表就只记录了一条198.168.0.0/16这一条路由，减少了路由表的条目，但若是ISP连接了一个172.168.96.0的网段，这些网络路由就没办法汇聚。CIRD节省了存储空间加快了查询速度。所以，现在都是用CIDR表示，就是说网络位的个数可以任意指定，同时也兼容早期IP划分的方法。它消除了以前A，B，C，D类地址的和划分子网的概念，使IP地址又从三级（网络号，子网号，主机号）又变回两级编址，不同的是，现在的两级编址是无分类的两级，这样就可以更有效分配IP地址了。&lt;/p&gt;
&lt;p&gt;对应位数的子网掩码&lt;/p&gt;
&lt;p&gt;255.0.0.0 /8&lt;br/&gt;255.128.0.0 /9&lt;br/&gt;255.192.0.0 /10&lt;br/&gt;255.224.0.0 /11&lt;br/&gt;255.240.0.0 /12&lt;br/&gt;255.248.0.0 /13&lt;br/&gt;255.252.0.0 /14&lt;br/&gt;255.254.0.0 /15&lt;br/&gt;255.255.0.0 /16&lt;br/&gt;255.255.128.0 /17&lt;br/&gt;255.255.192.0 /18&lt;br/&gt;255.255.224.0 /19&lt;br/&gt;255.255.240.0 /20&lt;br/&gt;255.255.248.0 /21&lt;br/&gt;255.255.252.0 /22&lt;br/&gt;255.255.254.0 /23&lt;br/&gt;255.255.255.0 /24&lt;br/&gt;255.255.255.128 /25&lt;br/&gt;255.255.255.192 /26&lt;br/&gt;255.255.255.224 /27&lt;br/&gt;255.255.255.240 /28&lt;br/&gt;255.255.255.248 /29&lt;br/&gt;255.255.255.252 /30&lt;/p&gt;
&lt;p&gt;CIDR表示法给出任何的一个IP地址，就可以从这个IP地址中得知一个CIDR地址块，我们随意给出一个代码块  128.101.74.7/20&lt;/p&gt;
&lt;p&gt;10000000  01100101  01001010  00000111    IP地址&lt;/p&gt;
&lt;p&gt;11111111   11111111    11110000   00000000   子网掩码  255.255.240.0&lt;/p&gt;
&lt;p&gt;10000000 01100101   01000000  00000000   最小地址  128.101.64.0&lt;/p&gt;
&lt;p&gt;10000000 01100101   01001111  11111111      最大地址  128.101.79.255&lt;/p&gt;
&lt;p&gt;因此，这个CIDR地址块可以指派（79-64+1）*  256 - 2 = 4094个地址（去除广播地址和网络号），也就大大缓解了IP地址的压力。&lt;/p&gt;
&lt;h3&gt;子网划分&lt;/h3&gt;
&lt;p&gt;在进行子网划分前，要首先明确一个问题，要划分几个子网。&lt;/p&gt;
&lt;p&gt;随机对一个网络地址块156.36.23.154/18，进行划分，假设要划分4个子网。&lt;/p&gt;
&lt;p&gt;第一步：默认的子网掩码是 11111111  11111111 11000000   00000000&lt;/p&gt;
&lt;p&gt;现在要划分两个子网，2的平方刚好是4，说明子网的网络位是2位，14 - 2 = 12 就是子网的主机位&lt;/p&gt;
&lt;p&gt;第二步：现在的子网掩码变为  11111111   11111111  11110000  00000000&lt;/p&gt;
&lt;p&gt;换成子网掩码则为  255.255.240.0，可用地址有16382个&lt;/p&gt;
&lt;p&gt;第一个子网地址  156.36.0.0&lt;/p&gt;
&lt;p&gt;第二个子网地址  156.36.16.0&lt;/p&gt;
&lt;p&gt;第三个子网地址  156.36.32.0&lt;/p&gt;
&lt;p&gt;第四个子网地址   156.36.48.0&lt;/p&gt;
&lt;p&gt;======================================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如发现错误，请及时留言，lz及时修改，避免误导后来者。感谢！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Apr 2019 18:14:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概述 网络标识相同的计算机必须属于同一个网络，一个B类的IP网络，在理论上是允许六万多台计算机连接的但在实际网络结构中这种一般是不存在的，这样就浪费了资源，套句时髦的话，为解决日益增长的网络设备IP需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10795238.html</dc:identifier>
</item>
<item>
<title>Pytest UI自动化测试实战实例 - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;@Time : 2019/4/20 8:45
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;@Auth : linux超
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@File : BasePage.py
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;@IDE  : PyCharm
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;------------------------------------
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait as wd
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium.common.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; NoSuchWindowException, TimeoutException, \
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    NoAlertPresentException, NoSuchFrameException
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.clipboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ClipBoard
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.keyboard &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KeyBoard
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseConFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseConFile
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; util.parseExcelFile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ParseExcel
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BasePage(object):
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    结合显示等待封装一些selenium 内置方法
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     cf =&lt;span&gt; ParseConFile()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     excel =&lt;span&gt; ParseExcel()
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, driver, outTime=30&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         self.byDic =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.ID,
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.NAME,
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;class_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.CLASS_NAME,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.XPATH,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;link_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: By.LINK_TEXT
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         self.driver =&lt;span&gt; driver
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         self.outTime =&lt;span&gt; outTime
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElement(self, by, locator):
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        find alone element
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        :param locator: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        :return: element object
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:Starting find the element &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             element = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the element &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; findElements(self, by, locator):
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        find group elements
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        :return: elements object
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[Info:start find the elements &quot;{}&quot; by &quot;{}&quot;!]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator, by))
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             elements = wd(self.driver, self.outTime).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.find_element(by, locator))
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(t)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('[Info:Had found the elements &quot;{}&quot; by &quot;{}&quot;!]'.format(locator, by))&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; elements
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isElementExsit(self, by, locator):
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        assert element if exist
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        :param by: eg: id, name, xpath, css.....
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        :param locator: eg: id, name, xpath for str
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        :return: if element return True else return false
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException:
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; time out!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException:
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error: element &quot;{}&quot; not exsit!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isClick(self, by, locator):
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断是否可点击,返回元素对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 element =&lt;span&gt; wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                    until(EC.element_to_be_clickable((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isAlertAndSwitchToIt(self):
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        assert alert if exsit
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        :return: alert obj
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             re =&lt;span&gt; wd(self.driver, self.outTime).until(EC.alert_is_present())
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoAlertPresentException:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToFrame(self, by, locator):
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;判断frame是否存在，存在就跳到frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switching to iframe &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; by.lower() &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.byDic:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                wd(self.driver, self.outTime).\
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                    until(EC.frame_to_be_available_and_switch_to_it((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchFrameException as e:
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; error!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(by))
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; switchToDefaultFrame(self):
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回默认的frame&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:switch back to default iframe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            self.driver.switch_to.default_content()
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getAlertText(self):
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取alert的提示信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isAlertAndSwitchToIt():
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             alert =&lt;span&gt; self.isAlertAndSwitchToIt()
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; alert.text
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; getElementText(self, by, locator, name=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某一个元素的text信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; name:
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.get_attribute(name)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; element.text
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get &quot;{}&quot; text failed return None&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadUrl(self, url):
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;加载url&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info: string upload url &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(url))
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        self.driver.get(url)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSource(self):
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取页面源码&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.driver.page_source
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sendKeys(self, by, locator, value=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:input &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;            element.send_keys(value)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; clear(self, by, locator):
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:clearing value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             element =&lt;span&gt; self.findElement(by, locator)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            element.clear()
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError as e:
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; click(self, by, locator):
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;点击某个元素&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:click &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;         element =&lt;span&gt; self.isClick(by, locator)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; element:
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            element.click()
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the &quot;{}&quot; unclickable!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; sleep(self, num=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;强制等待&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:sleep &quot;{}&quot; minutes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(num))
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        time.sleep(num)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ctrlV(self, value):
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;ctrl + V 粘贴&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:pasting &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;        ClipBoard.setText(value)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         self.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         KeyBoard.twoKeys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctrl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; enterKey(self):
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;enter 回车键&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:keydown enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         KeyBoard.oneKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; waitElementtobelocated(self, by, locator):
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;显示等待某个元素出现，且可见&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;227&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:waiting &quot;{}&quot; to be located&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator))
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;            wd(self.driver, self.outTime).until(EC.visibility_of_element_located((self.byDic[by], locator)))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutException as t:
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: found &quot;{}&quot; timeout！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), t)
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NoSuchWindowException as e:
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no such &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(locator), e)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; e
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertValueInSource(self, value):
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某个关键字是否存在页面源码中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; in page source&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value))
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;         source =&lt;span&gt; self.getSource()
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; source, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;关键字&quot;{}&quot;不存在源码中!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(value)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; assertStringContainsValue(self, String, value):
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;断言某段字符串包含另一个字符串&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;info:assert &quot;{}&quot; contains &quot;{}&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value))
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; String, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;{}&quot;不包含&quot;{}&quot;!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(String, value)
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSheet(sheetName):
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;获取某个sheet页的对象&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;         sheet =&lt;span&gt; BasePage.excel.getSheetByName(sheetName)
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sheet
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; 
&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;     driver =&lt;span&gt; webdriver.Firefox()
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;     frame = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;loginDiv&quot;]/ifram&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;     wait =&lt;span&gt; BasePage(driver)
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;     driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://mail.126.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;     wait.switchToFrame(*&lt;span&gt;frame)
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;     username = wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;email&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;     username.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; wait.isElementExsit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;         wait.findElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@name=&quot;password&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaochao11520&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     wait.click(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//a[@id=&quot;dologin&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;</description>
<pubDate>Tue, 30 Apr 2019 15:42:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 明天就放假了，4天小长假，是不是很开心！也许很多人要回老家帮家里种地，干农活。其实能陪陪家里人，帮忙干点农活还是挺开心的，希望大家有个愉快的假期！废话不多说哈，今天再来说说pytest吧，经过几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-pytest-Actual.html</dc:identifier>
</item>
<item>
<title>MySQL 中的日期时间类型 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</guid>
<description>&lt;p&gt;日期时间类型中包含以下几种数据类型：&lt;/p&gt;
&lt;p&gt;各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP 类型是个例外，给它设置一个超出范围的值时，将保存上该类型允许的最大值。&lt;/p&gt;
&lt;p&gt;MySQL 按标准格式 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt; 输出日期时间，但设置或进行日期时间相关的比较时却支持灵活的多种格式，会自动解析。具体支持的输入格式可参见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Section 9.1.3, “Date and Time Literals”&lt;/a&gt;。其中 &lt;code&gt;fraction&lt;/code&gt; 部分为秒后面的小数部分，取值范围为 0~6 位。&lt;/p&gt;
&lt;p&gt;虽然 MySQL 支持多种格式进行日期时间的设置，但日期部分要求必须是 年-月-日 的形式才能正确解析。比如 &lt;code&gt;98-09-04&lt;/code&gt; 是按年月日顺序解析的，而不是英文里常用的月日年，或者日月年。&lt;/p&gt;
&lt;p&gt;年在只给了两位数的情况下，MySQL 尝试使用以下规则来补全：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给定的两位数为 70~99 时解析成 1970 ~ 1999。&lt;/li&gt;
&lt;li&gt;给定为 00 ~ 69 时解析成 2000 ~ 2069。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，为了避免不可预测的结果，使用时还是指定全一些。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在需要使用数字的语境下，MySQL 会将日期时间自动转成数字。同理，在需要日期时间的相关操作语境下，会尝试将数字解析成日期时间。&lt;/li&gt;
&lt;li&gt;通过设置 MySQL 相关参数，日期类型可保存原本非法的值，比如开启 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;ALLOW_INVALID_DATES&lt;/a&gt; 设置项时，可设置日期类型保存一个 &lt;code&gt;2009-11-31&lt;/code&gt; 值，但正常情况下我们知道 11 月哪来什么 31 号。此时 MySQL 仅仅只是不检查月分与日期的关联性，但月分的取值范围 1&lt;del&gt;12 及日期的取值范围 1&lt;/del&gt;31 还是要单独各自做校验的。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1292 (22007): Incorrect date value: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;created_on&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET SESSION sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;ALLOW_INVALID_DATES&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO todo (title,created_on) VALUES (&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;blah&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;2019-09-31&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected, 1 warning (0.01 sec)
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM todo&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; id &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; title &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; created_on    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; blah &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 2019-09-31 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+----+------+------------+
1 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;某些场景下你可能需要保存部分日期，比如用户只输入了年没输入月日。所以 MySQL 是支持将月日设置成 0，比如 &lt;code&gt;2019-00-00&lt;/code&gt;。但这种情况下就无法从日期相关的操作中获得到准确的结果，比如使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-sub&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_SUB()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_date-add&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;DATE_ADD()&lt;/code&gt;&lt;/a&gt; 函数时。禁用月日的零值可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_in_date&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NO_ZERO_IN_DATE&lt;/code&gt;&lt;/a&gt; 模式。&lt;/p&gt;
&lt;p&gt;除了月日可零，MySQL 还支持设置年月日都零的值 &lt;code&gt;0000-00-00&lt;/code&gt;，对于日期非必填的情况比较有用，因为此时它比单纯的 &lt;code&gt;NULL&lt;/code&gt; 更有语义。可通过开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_zero_date&quot; rel=&quot;nofollow&quot;&gt;NO_ZERO_DATE&lt;/a&gt; 模式来禁用这个全零的值。&lt;/p&gt;
&lt;p&gt;各日期时间零值格式如下，但实际时用时，直接简写成一个 0 效果是等效的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Data Type&lt;/th&gt;
&lt;th&gt;“Zero” Value&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;'0000-00-00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;'00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;'0000-00-00 00:00:00'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;0000&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;DATE，DATETIME，及 TIMESTAMP&lt;/h2&gt;
&lt;p&gt;三者具有相关性，都支持多种格式的自动解析，详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html&quot; rel=&quot;nofollow&quot;&gt;Date and Time Literals&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATE&lt;/code&gt; 日期格式不带时间 &lt;code&gt;TIME&lt;/code&gt; 部分，查询时输出格式为 &lt;code&gt;YYYY-MM-DD&lt;/code&gt;，取值范围为 &lt;code&gt;1000-01-01&lt;/code&gt; 到 &lt;code&gt;9999-12-31&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DATETIME&lt;/code&gt; 包含日期及时间，输出格式为 &lt;code&gt;YYYY-MM-DD hh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;1000-01-01 00:00:00&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 同 &lt;code&gt;DATETIME&lt;/code&gt;，但取值范围基于 UTC 时间，较 &lt;code&gt;DATETIME&lt;/code&gt; 要小，为 &lt;code&gt;1970-01-01 00:00:01&lt;/code&gt; UTC 到 &lt;code&gt;2038-01-19 03:14:07&lt;/code&gt; UTC。所以使用 TIMESTAMP 格式的时间，到 2038 年会溢出，这就是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Year_2038_problem&quot; rel=&quot;nofollow&quot;&gt;Year 2038 problem&lt;/a&gt;。关于该问题的讨论和解决可参见这个 &lt;a href=&quot;https://stackoverflow.com/a/2012620/1553656&quot; rel=&quot;nofollow&quot;&gt;StackOverflow 的回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;既然如此，为何要使用这个取值范围更小的呢。&lt;code&gt;TIMESTAMP&lt;/code&gt; 存储的值是带时区的。在存储时会根据当前时区转成 UTC（universal time zone） 存储，查询时也会根据时区从 UTC 转换到具体的时间。对于支持多语及国际化全球部署的应用来说，显得尤为方便。需要注意的是，这里操作基于的时区默认为服务器的时区，可通过改变 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;time_zone&lt;/code&gt;&lt;/a&gt; &lt;code&gt;SET GLOBAL time_zone=time_zone&lt;/code&gt; 来修改。时区的设置也可以是以连接为单位，这样来自不同时区的请求可得到不同的时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 都可包含至多 6 位的小数来表示时间中毫秒（microseconds）的部分。所以，带上毫秒时完整的格式是 &lt;code&gt;YYYY-MM-DD hh:mm:ss[.fraction]&lt;/code&gt;。前者取值范围为 &lt;code&gt;1970-01-01 00:00:01.000000&lt;/code&gt; 到 &lt;code&gt;2038-01-19 03:14:07.999999&lt;/code&gt;，后者为 &lt;code&gt;1000-01-01 00:00:00.000000&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59.999999&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在写入时，对于非法的日期时间值，将自动存成零值，即 '0000-00-00' 或 '0000-00-00 00:00:00'。&lt;/p&gt;
&lt;p&gt;关于日期时间需要注意的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为 MySQL 支持比较宽松的格式来设置日期时间，所以理论上你可以用你想用的值来做为数字之间的分界符，但使用时需要关注其解析的原理。比如给一个日期格式的列设置 &lt;code&gt;10:11:12&lt;/code&gt;，虽然这个值看起来像时间类型，但还是可以正确在被解析成目标列的格式，即日期。如果这这个日期列设置 &lt;code&gt;10:45:15&lt;/code&gt; 则会认为是非法值，因为 &lt;code&gt;45&lt;/code&gt; 不是一个合法的月份值，所以存储时变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;日期时间与毫秒的分界符必需是小数点。&lt;/li&gt;
&lt;li&gt;默认 MySQL 除了检查日月值是否有有效范围 1~ 31,1~12。还会将两者结合进来检查，比如 4 月没有 31。所以对于日期 &lt;code&gt;2004-04-31&lt;/code&gt; 算是非法的，会变成零值 &lt;code&gt;0000-00-00&lt;/code&gt;。如果不需要这样的约束检查，可开启 MySQL 的 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_allow_invalid_dates&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;ALLOW_INVALID_DATES&lt;/code&gt;&lt;/a&gt; 模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;日期时间的自动初始化及更新&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 还支持自动初始化（auto-initialized）和更新到当前时间（auto-updated）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建表定义列时，指定 &lt;code&gt;DEFAULT CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动初始化。&lt;/li&gt;
&lt;li&gt;指定 &lt;code&gt;ON UPDATE CURRENT_TIMESTAMP&lt;/code&gt; 来使相应的日期时间列自动更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者可同时作用于一个日期时间列，表示插入记录时自动初始化成当前时间，后续记录更新时自动更新到当前时间。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 指代当前时间，与其有相同效果的还有 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_current-timestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;CURRENT_TIMESTAMP()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtime&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIME()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP&lt;/code&gt;&lt;/a&gt; 以及 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_localtimestamp&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;LOCALTIMESTAMP()&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT&lt;/code&gt; 除了可指定成当前时间外，也可指定一个任意的固定值，比如 &lt;code&gt;DEFAULT 0&lt;/code&gt; 或 `DEFAULT '2000-01-01 00:00:00'。&lt;/p&gt;
&lt;p&gt;对于指定了自动初始化的列，插入时如果没指定该列的值，则会自动设置为当前的时间。&lt;/p&gt;
&lt;p&gt;对于指定为自动更新的列，一旦一条记录中有字段变更，该日期会自动更新成变更时的时间。如果不想它更新，可在插入其他值时手动设置一下该日期列为原有的值，让其保持不变。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; 和 &lt;code&gt;DATETIME&lt;/code&gt; 在列的定义时，如果指定了小数部分，那么在配合使用 &lt;code&gt;CURRENT_TIMESTAMP(fsp)&lt;/code&gt; 时，这个小数部分的精度需要保持一致。比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; ✅&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;)
);

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;--&lt;/span&gt; 🚨&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  ts &lt;span class=&quot;pl-k&quot;&gt;TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;6&lt;/span&gt;) DEFAULT &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt;)
);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TIME&lt;/h2&gt;
&lt;p&gt;时间 &lt;code&gt;TIME&lt;/code&gt; 格式即日期时间中时间的部分，输出格式为 &lt;code&gt;hh:mm:ss&lt;/code&gt; 或时间较大时为 &lt;code&gt;hhh:mm:ss&lt;/code&gt;，取值范围 &lt;code&gt;-838:59:59&lt;/code&gt; 到 &lt;code&gt;838:59:59&lt;/code&gt;。同样地，也是支持带至多 6 位小数表示毫秒。&lt;/p&gt;
&lt;p&gt;设置时也是支持将多种格式自动解析。对于带冒号的情况，比如 &lt;code&gt;11:12&lt;/code&gt; 解析成 &lt;code&gt;11:12:00&lt;/code&gt; 而不是 &lt;code&gt;00:11:12&lt;/code&gt;。不带冒号的情况，将最右边的两位数字解析成秒（按逝去的时间来解析），比如 &lt;code&gt;'1112'&lt;/code&gt; 和 &lt;code&gt;1112&lt;/code&gt; 不是 &lt;code&gt;11:12:00&lt;/code&gt; 而会解析成 &lt;code&gt;00:11:12&lt;/code&gt;。同理，&lt;code&gt;'12'&lt;/code&gt; 和 &lt;code&gt;12&lt;/code&gt; 会解析成 &lt;code&gt;00:00:12&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;YEAR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;YEAR&lt;/code&gt; 表示日期中年的部分，是一个 1 字节大小的类型，可通过 &lt;code&gt;YEAR&lt;/code&gt; 或 &lt;code&gt;YEAR(4)&lt;/code&gt; 来声明，其展示宽度（display width）为 4。查询时输出格式为 &lt;code&gt;YYYY&lt;/code&gt;，取值范围 1901 到 2155。 &lt;code&gt;0000&lt;/code&gt; 也是合法的值。&lt;/p&gt;
&lt;p&gt;支持使用以下格式进行设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 1901 ~ 2155 间的四位数字值。&lt;/li&gt;
&lt;li&gt;或将上面的数字以字符串形式给定。&lt;/li&gt;
&lt;li&gt;1 ~ 99 之间的数字，此时 1 ~ 69 解析成 2001 ~ 2069，70 ~ 99 解析成 1970 ~ 1999.&lt;/li&gt;
&lt;li&gt;其他可返回合法值的方法，比如 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_now&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NOW()&lt;/code&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Tue, 30 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>日期时间类型中包含以下几种数据类型： DATE TIME DATETIME TIMESTAMP YEAR 各类型都有具体的取值范围，超出或非法的其他值时，MySQL 会回退到 0。TIMESTAMP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_data_type_datetime.html</dc:identifier>
</item>
</channel>
</rss>