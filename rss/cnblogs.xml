<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mysql常见数据类型 - 自律即自由-</title>
<link>http://www.cnblogs.com/deyo/p/13297144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deyo/p/13297144.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#常见的数据类型
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;数值型：
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    整型
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    小数：
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        定点数
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;        浮点数
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;字符型：
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    较短的文本：char、varchar
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    较长的文本：text、blob（较长的二进制数据）
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;日期型：
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#一、整型
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;分类：
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;tinyint、smallint、mediumint、int/integer、bigint
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;1     2        3    4        8
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;特点：
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;③ 如果不设置长度，会有默认的长度
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.如何设置无符号和有符号
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; tab_int;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_int(
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     t1 &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;&lt;span&gt;) ZEROFILL,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     t2 &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;&lt;span&gt;) ZEROFILL 
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;span&gt; tab_int;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_int &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;-&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_int &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;-&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;,&lt;span&gt;-&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_int &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;2147483648&lt;/span&gt;,&lt;span&gt;4294967296&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_int &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tab_int;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;#二、小数
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;分类：
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;1.浮点型
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;float(M,D)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;double(M,D)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;2.定点型
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;dec(M，D)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;decimal(M,D)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;特点：
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;①
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;M：整数部位+小数部位
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;D：小数部位
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;如果超过范围，则插入临界值
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;②
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;M和D都可以省略
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;如果是decimal，则M默认为10，D默认为0
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;如果是float和double，则会根据插入的数值的精度来决定精度
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;#测试M和D
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_float;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_float(
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     f1 &lt;span&gt;FLOAT&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     f2 &lt;span&gt;DOUBLE&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     f3 &lt;span&gt;DECIMAL&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tab_float;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;span&gt; tab_float;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_float &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;123.4523&lt;/span&gt;,&lt;span&gt;123.4523&lt;/span&gt;,&lt;span&gt;123.4523&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_float &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;123.456&lt;/span&gt;,&lt;span&gt;123.456&lt;/span&gt;,&lt;span&gt;123.456&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_float &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;123.4&lt;/span&gt;,&lt;span&gt;123.4&lt;/span&gt;,&lt;span&gt;123.4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_float &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;1523.4&lt;/span&gt;,&lt;span&gt;1523.4&lt;/span&gt;,&lt;span&gt;1523.4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;#原则：
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;所选择的类型越简单越好，能保存数值的类型越小越好
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;#三、字符型
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;较短的文本：
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;char
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;varchar
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;其他：
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;binary和varbinary用于保存较短的二进制
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;enum用于保存枚举
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;set用于保存集合
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;较长的文本：
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;text
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;blob(较大的二进制)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;特点：
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;    写法        M的意思                    特点            空间的耗费    效率
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;char    char(M)        最大的字符数，可以省略，默认为1        固定长度的字符        比较耗费    高
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;varchar varchar(M)    最大的字符数，不可以省略        可变长度的字符        比较节省    低
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_char(
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     c1 ENUM(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_char &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_char &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_char &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_char &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_char &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tab_set;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_set(
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt;     s1 &lt;span&gt;SET&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_set &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_set &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A,B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_set &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a,c,d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt; &lt;span&gt;#四、日期型
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt; &lt;span&gt;分类：
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;date只保存日期
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;time 只保存时间
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;year只保存年
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;datetime保存日期+时间
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;timestamp保存日期+时间
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;特点：
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        字节        范围        时区等的影响
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;datetime                   8        1000——9999                      不受
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;timestamp    4                   1970-2038                        受
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt; 
&lt;span&gt;185&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_date(
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;     t1 &lt;span&gt;DATETIME&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;     t2 &lt;span&gt;TIMESTAMP&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tab_date &lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;(NOW(),NOW());
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; 
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tab_date;
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; 
&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt; SHOW VARIABLES &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;time_zone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; 
&lt;span&gt;200&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; time_zone&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+9:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 Jul 2020 00:45:00 +0000</pubDate>
<dc:creator>自律即自由-</dc:creator>
<og:description>1 #常见的数据类型 2 /* 3 数值型： 4 整型 5 小数： 6 定点数 7 浮点数 8 字符型： 9 较短的文本：char、varchar 10 较长的文本：text、blob（较长的二进制数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deyo/p/13297144.html</dc:identifier>
</item>
<item>
<title>Java8——方法引用 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13297141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13297141.html</guid>
<description>&lt;p&gt;方法引用就是通过类名或方法名引用已经存在的方法来简化lambda表达式。那么什么时候需要用方法引用呢？如果lamdba体中的内容已经有方法实现了，我们就可以使用方法引用。&lt;/p&gt;
&lt;h2 id=&quot;一、方法引用的三种语法格式&quot;&gt;一、方法引用的三种语法格式&lt;/h2&gt;
&lt;h3 id=&quot;1-对象实例方法名&quot;&gt;1. 对象::实例方法名&lt;/h3&gt;
&lt;p&gt;lamdba写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test1(){
    Consumer&amp;lt;String&amp;gt; con = x -&amp;gt; System.out.println(x);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法引用写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test2(){
    PrintStream out = System.out;
    Consumer&amp;lt;String&amp;gt; con = out::println;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;consumer接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {
    void accept(T t);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-类静态方法名&quot;&gt;2. 类::静态方法名&lt;/h3&gt;
&lt;p&gt;lamdba写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test3(){
    Comparator&amp;lt;Integer&amp;gt; com = (x, y) -&amp;gt; Integer.compare(x,y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法引用写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test4(){
    Comparator&amp;lt;Integer&amp;gt; com = Integer::compare;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Comparator接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Comparator&amp;lt;T&amp;gt; {
    int compare(T o1, T o2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Integer类部分内容:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class Integer extends Number implements Comparable&amp;lt;Integer&amp;gt; { 
        public static int compare(int x, int y) {
        return (x &amp;lt; y) ? -1 : ((x == y) ? 0 : 1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-类实例方法名&quot;&gt;3. 类::实例方法名&lt;/h3&gt;
&lt;p&gt;lamdba写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test5(){

    BiPredicate&amp;lt;String,String&amp;gt; bp = (x,y) -&amp;gt; x.equals(y);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法引用写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test6(){
    BiPredicate&amp;lt;String,String&amp;gt; bp = String::equals;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BiPredicate接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface BiPredicate&amp;lt;T, U&amp;gt; {
    boolean test(T t, U u);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：第一个参数是这个实例方法的调用者，第二个参数是这个实例方法的参数时，就可以使用这种语法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、构造器引用&quot;&gt;二、构造器引用&lt;/h2&gt;
&lt;h3 id=&quot;类new&quot;&gt;类::new&lt;/h3&gt;
&lt;p&gt;lamdba写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test7(){
    Supplier&amp;lt;Person&amp;gt; supplier = ()-&amp;gt;new Person();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造器引用写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test8(){
    Supplier&amp;lt;Person&amp;gt; supplier = Person::new;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Supplier接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {
    T get();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Person类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class Person implements Serializable {
    private static final long serialVersionUID = -7008474395345458049L;

    private String name;
    private int age;

    public Person() {
    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：person类中有两个构造器，要调用哪个构造器是函数式接口决定的，也就是Supplier接口中的get()方法是无参的，那么就调用的是person中的无参构造器。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、数组引用&quot;&gt;三、数组引用&lt;/h2&gt;
&lt;h3 id=&quot;typenew&quot;&gt;Type::new&lt;/h3&gt;
&lt;p&gt;lamdba写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test9(){
    Function&amp;lt;Integer,String[]&amp;gt; fun = x -&amp;gt; new String[x];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组引用写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void test10(){
    Function&amp;lt;Integer, String[]&amp;gt; fun = String[]::new;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Function接口部分内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;方法应用及构造器引用其实可以理解为lamdba的另一种表现形式&lt;/li&gt;
&lt;li&gt;方法引用被调用的方法的参数列表和返回值类型需要与函数式接口中抽象方法的参数列表和返回值类型要一致&lt;/li&gt;
&lt;li&gt;方法引用中使用类::实例方法的条件是第一个参数是这个实例方法的调用者，第二个参数是这个实例方法的参数&lt;/li&gt;
&lt;li&gt;构造器引用需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表一致&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 14 Jul 2020 00:44:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>方法引用就是通过类名或方法名引用已经存在的方法来简化lambda表达式。那么什么时候需要用方法引用呢？如果lamdba体中的内容已经有方法实现了，我们就可以使用方法引用。 一、方法引用的三种语法格式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13297141.html</dc:identifier>
</item>
<item>
<title>学习Java8系列-Lambda - 大魔王先生</title>
<link>http://www.cnblogs.com/wtzbk/p/13296427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtzbk/p/13296427.html</guid>
<description>&lt;h3 id=&quot;hlambda&quot;&gt;&lt;span&gt;Lambda演进&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;小王在公司正在开发一个学生管理系统，产品经理向他提出一个需求，要筛选出年龄大于15的学生,于是小王写出了以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; filterAgeStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt; = Lists.newArrayList();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Student student : students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (student.getAge() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;.add(student);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过了几天产品经理又提出了一个需求，要筛选出体重大于50KG的学生，于是小王新增了一个方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; filterWeightStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt; = Lists.newArrayList();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Student student : students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (student.getWeight() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;.add(student);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过了一段时间，产品提出了要筛选出体重大于50并且年龄要大于15的学生，小王突然感觉到这不是一个简单的需求，于是小王仔细思考了一下，突然想到将每种筛选的策略抽象成为一个接口，并且将这个接口当做一个参数传入方法中，这样每次就可以只新增策略，其他代码不需要更改了，这样就满足了软件设计的六大原则的开放闭合原则，于是乎诞生以下的设计和代码:&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202007/1005447-20200706213706046-342518777.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StudentPredicate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Student student)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AgeStudentPredicate&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;StudentPredicate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Student student)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; student.getAge() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt; ? &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt; : &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; List&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;filterStudent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;Student&amp;gt; students,&lt;br/&gt;StudentPredicate predicate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;List&amp;lt;Student&amp;gt; list = Lists.newArrayList();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Student student : students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (predicate.filter(student)) {&lt;br/&gt;list.add(student);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过一段时间的学习，小王接触到匿名类，于是小王代码进行更改，以后再也不需要写策略了:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;List&amp;lt;Student&amp;gt; list = filterStudent(students, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StudentPredicate() {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Student student)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; student.getAge() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学习到匿名类以后，小王感觉到Java的浩瀚，然后继续学习，后来接触到Lambda，于是对待做了以下改造:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt; = filterStudent(students, student -&amp;gt; student.getAge() &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hlambda-1&quot;&gt;&lt;span&gt;Lambda知识整理&lt;/span&gt;&lt;/h3&gt;
&lt;h5 id=&quot;hlambda-2&quot;&gt;&lt;span&gt;Lambda定义&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;从上面的演进过程，我们基本上可以得到Lambda表达式是一种匿名函数，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。Java中的Lambda表达式通常使用(argument) -&amp;gt; (body)语法书写，常用的Lamda表达式例子有:&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;4&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b) -&amp;gt; {  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b; }&lt;p&gt;() -&amp;gt; System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;(String s) -&amp;gt; { System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(s); }&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;h&quot;&gt;&lt;span&gt;函数式接口&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;函数式接口指的是是只包含一个抽象方法声明的接口。例如java.lang.Runnable就是一种函数式接口，在 Runnable接口中只声明了一个抽象方法方法void run();&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于注解@FunctionalInterface对于lamda表达式来说的话并不是必要的，@FunctionalInterface是Java8新加入的一种接口，用于指明该接口类型声明是根据Java语言规范定义的函数式接口。Java8还声明了一些Lambda表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用@FunctionalInterface解决编译层面的错误。&lt;/p&gt;
&lt;h5 id=&quot;h-1&quot;&gt;&lt;span&gt;常用函数式&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;Java8中在java.util.function中引入了很多的函数式接口，这里介绍一下3个常用的函数式接口，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Predicate&lt;br/&gt;Predicate接口定义一个名叫test的抽象方法，它接收泛型T对象，并返回一个boolean类型。经常使用到的地方是在流处理的过程中filter方法，满足条件的数据才会被过滤出来,例如我们上面的例子也可以改造成为Predicate函数式接口的形式。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;@FunctionalInterface&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Predicate&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;boolean test(T t);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; filterStudent(&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; students,&lt;br/&gt;Predicate&amp;lt;Student&amp;gt; predicate) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt; = Lists.newArrayList();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Student student : students) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (predicate.test(student)) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;.add(student);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;list&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Consumer&lt;br/&gt;Consumer定义一个名叫accept的抽象方法，他接受泛型T的对象，没有返回值。如果你需要访问泛型对象T，并其进行修改，就使用Consumer。经常使用的地方就是常用的forEach方法。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Consumer&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;forEachOrdered&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Consumer&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Function&lt;br/&gt;Function定义一个叫apply的方法，他接受一个泛型对象T，返回一个泛型对象R。如果你需要定义一个Lambda表达式，将输入的对象映射到输出，就使用Function，经常使用到的地方就是常用的map方法。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Function&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;R &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&amp;lt;R&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Stream&amp;lt;R&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Function&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T, ? extends R&amp;gt; mapper)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hlambda-3&quot;&gt;&lt;span&gt;Lambda原理窥探&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;小王经过上面一系列学习，开始思考Lambda的原理是什么，因为Java8中每一个Lambda表达式必须有一个函数式接口与之对应，小王就思考经过编译器编译以后到可能实现的方式有两种，一种生成实现接口的类，另外一种是内部类，于是决定看一下反编译的以后代码，以解除心中的疑惑；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;@FunctionalInterface&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Func&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; y&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LambdaTest&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;Func func = (x, y) -&amp;gt; x + y;&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(func.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过javap -p -v -c LambdaTest.class查看反编译后的代码，&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;hljs sql&quot; readability=&quot;18&quot;&gt;Classfile /Users/wangtongzhou/Documents/Java/learning/target/classes/com/springboot2/learning/javabasic/java8/LambdaTest.class&lt;br/&gt;Last modified 2020-7-11; size 1392 bytes&lt;br/&gt;MD5 &lt;span class=&quot;hljs-keyword&quot;&gt;checksum&lt;/span&gt; ec7d77a8b0b0a0cb5940f80a9b27b3d0&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Compiled&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;LambdaTest.java&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; com.springboot2.learning.javabasic.java8.LambdaTest&lt;br/&gt;minor &lt;span class=&quot;hljs-keyword&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;major &lt;span class=&quot;hljs-keyword&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;52&lt;/span&gt;&lt;br/&gt;flags: ACC_PUBLIC, ACC_SUPER&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Constant&lt;/span&gt; pool:&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; com.springboot2.learning.javabasic.java8.LambdaTest();&lt;br/&gt;descriptor: ()V&lt;br/&gt;flags: ACC_PUBLIC&lt;br/&gt;Code:&lt;br/&gt;stack=1, locals=1, args_size=1&lt;br/&gt;0: aload_0&lt;br/&gt;1: invokespecial &lt;br/&gt;4: return&lt;br/&gt;LineNumberTable:&lt;br/&gt;line 3: 0&lt;br/&gt;LocalVariableTable:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Start&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;Length&lt;/span&gt;  Slot  &lt;span class=&quot;hljs-keyword&quot;&gt;Name&lt;/span&gt;   Signature&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  this   Lcom/springboot2/learning/javabasic/java8/LambdaTest;&lt;p&gt;public static void main(java.lang.String[]);&lt;br/&gt;descriptor: ([Ljava/lang/String;)V&lt;br/&gt;flags: ACC_PUBLIC, ACC_STATIC&lt;br/&gt;Code:&lt;br/&gt;stack=4, locals=2, args_size=1&lt;br/&gt;0: invokedynamic &lt;br/&gt;5: astore_1&lt;br/&gt;6: getstatic     &lt;br/&gt;9: aload_1&lt;br/&gt;10: iconst_1&lt;br/&gt;11: iconst_2&lt;br/&gt;12: invokeinterface &lt;br/&gt;17: invokevirtual &lt;br/&gt;20: return&lt;br/&gt;LineNumberTable:&lt;br/&gt;line 5: 0&lt;br/&gt;line 6: 6&lt;br/&gt;line 7: 20&lt;br/&gt;LocalVariableTable:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Start&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;Length&lt;/span&gt;  Slot  &lt;span class=&quot;hljs-keyword&quot;&gt;Name&lt;/span&gt;   Signature&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  args   [Ljava/lang/&lt;span class=&quot;hljs-keyword&quot;&gt;String&lt;/span&gt;;&lt;br/&gt;6      15     1  func   Lcom/springboot2/learning/javabasic/java8/Func;&lt;br/&gt;MethodParameters:&lt;br/&gt;Name                           Flags&lt;br/&gt;args&lt;/p&gt;&lt;p&gt;private static int lambda$main$0(int, int);&lt;br/&gt;descriptor: (II)I&lt;br/&gt;flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC&lt;br/&gt;Code:&lt;br/&gt;stack=2, locals=2, args_size=2&lt;br/&gt;0: iload_0&lt;br/&gt;1: iload_1&lt;br/&gt;2: iadd&lt;br/&gt;3: ireturn&lt;br/&gt;LineNumberTable:&lt;br/&gt;line 5: 0&lt;br/&gt;LocalVariableTable:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Start&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;Length&lt;/span&gt;  Slot  &lt;span class=&quot;hljs-keyword&quot;&gt;Name&lt;/span&gt;   Signature&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;     x   I&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;     y   I&lt;br/&gt;MethodParameters:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Name&lt;/span&gt;                           Flags&lt;br/&gt;x                              synthetic&lt;br/&gt;y                              synthetic&lt;br/&gt;}&lt;br/&gt;SourceFile: &lt;span class=&quot;hljs-string&quot;&gt;&quot;LambdaTest.java&quot;&lt;/span&gt;&lt;br/&gt;InnerClasses:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;br/&gt;BootstrapMethods:&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;br/&gt;Method arguments:&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译以后lambda表达式被编译成为一个lambda$main$0的函数，其实就是一段(x, y) -&amp;gt; x + y的方法，在看main方法主要分为以下8个步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;通过invokedynamic指令生成调用对象；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;存入本地缓存；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;加载java.lang.System.out静态方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将lambda表达式生成的对象加载入执行栈;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将int类型1加载入执行栈;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将int类型2加载入执行栈;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行lambda表达式生成的对象的add方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;输出执行结果；&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202007/1005447-20200711215034721-1710347919.png&quot; alt=&quot;重点部分&quot; title=&quot;重点部分&quot;/&gt;重点部分&lt;br/&gt;从mian方法中我们的重点就在于invokedynamic这个指令，重点要了解下是如何通过invokedynamic指令生成目标对象，invokedynamic指令通过找到BootstrapMethods中的方法，生成动态调用点，也是调用LambdaMetafactory的metafactory方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202007/1005447-20200711221711233-918513541.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; CallSite &lt;span class=&quot;hljs-title&quot;&gt;metafactory&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(MethodHandles.Lookup caller,&lt;br/&gt;String invokedName,&lt;br/&gt;MethodType invokedType,&lt;br/&gt;MethodType samMethodType,&lt;br/&gt;MethodHandle implMethod,&lt;br/&gt;MethodType instantiatedMethodType)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; LambdaConversionException &lt;/span&gt;{&lt;br/&gt;AbstractValidatingLambdaMetafactory mf;&lt;br/&gt;mf = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; InnerClassLambdaMetafactory(caller, invokedType,&lt;br/&gt;invokedName, samMethodType,&lt;br/&gt;implMethod, instantiatedMethodType,&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;, EMPTY_CLASS_ARRAY, &lt;br/&gt;EMPTY_MT_ARRAY);&lt;br/&gt;mf.validateMetafactoryArgs();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mf.buildCallSite();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码可以看出，metafactory方法通过InnerClassLambdaMetafactory类生成对象，并提供后续调用，在InnerClassLambdaMetafactory源码中可以看到，有提供开关是否dump生成的class文件。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202007/1005447-20200711223543984-1796714218.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1005447/202007/1005447-20200711223717362-2091742806.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;br/&gt;接下来我们通过设置启动参数-Djdk.internal.lambda.dumpProxyClasses查看中间对象，增加这个参数以后会生成LambdaTest$$Lambda$1类,
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LambdaTest&lt;/span&gt;$$&lt;span class=&quot;hljs-title&quot;&gt;Lambda&lt;/span&gt;$1 &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Func&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;() {&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Hidden&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; var1, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; var2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; LambdaTest.lambda$main$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;(var1, var2);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再看下上面这个类反编译以后的情况&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs objectivec&quot; readability=&quot;7&quot;&gt;Classfile /Users/wangtongzhou/Documents/Java/learning/com/springboot2/learning/javabasic/java8/LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;&lt;br/&gt;Last modified &lt;span class=&quot;hljs-number&quot;&gt;2020&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;-7&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;-11&lt;/span&gt;; size &lt;span class=&quot;hljs-number&quot;&gt;437&lt;/span&gt; bytes&lt;br/&gt;MD5 checksum &lt;span class=&quot;hljs-number&quot;&gt;729979930540708&lt;/span&gt;c60f4e71e63b69321&lt;br/&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; com.springboot2.learning.javabasic.java8.LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; implements com.springboot2.learning.javabasic.java8.Func&lt;br/&gt;minor version: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;major version: &lt;span class=&quot;hljs-number&quot;&gt;52&lt;/span&gt;&lt;br/&gt;flags: ACC_FINAL, ACC_SUPER, ACC_SYNTHETIC&lt;br/&gt;Constant pool:&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#1 = Utf8               com/springboot2/learning/javabasic/java8/LambdaTest$$Lambda$1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#2 = Class              #1             // com/springboot2/learning/javabasic/java8/LambdaTest$$Lambda$1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#3 = Utf8               java/lang/Object&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#4 = Class              #3             // java/lang/Object&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#5 = Utf8               com/springboot2/learning/javabasic/java8/Func&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#6 = Class              #5             // com/springboot2/learning/javabasic/java8/Func&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#7 = Utf8               &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#8 = Utf8               ()V&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#9 = NameAndType        #7:#8          // &lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;:()V&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#10 = Methodref          #4.#9          // java/lang/Object.&lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;:()V&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#11 = Utf8               add&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#12 = Utf8               (II)I&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#13 = Utf8               Ljava/lang/invoke/LambdaForm$Hidden;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#14 = Utf8               com/springboot2/learning/javabasic/java8/LambdaTest&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#15 = Class              #14            // com/springboot2/learning/javabasic/java8/LambdaTest&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#16 = Utf8               lambda$main$0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#17 = NameAndType        #16:#12        // lambda$main$0:(II)I&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#18 = Methodref          #15.#17        // com/springboot2/learning/javabasic/java8/LambdaTest.lambda$main$0:(II)I&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#19 = Utf8               Code&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#20 = Utf8               RuntimeVisibleAnnotations&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;private com.springboot2.learning.javabasic.java8.LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;();&lt;br/&gt;descriptor: ()V&lt;br/&gt;flags: ACC_PRIVATE&lt;br/&gt;Code:&lt;br/&gt;stack=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, locals=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, args_size=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: aload_0&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: invokespecial &lt;span class=&quot;hljs-meta&quot;&gt;#10                 // Method java/lang/Object.&lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;:()V&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;p&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; add(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;);&lt;br/&gt;descriptor: (II)I&lt;br/&gt;flags: ACC_PUBLIC&lt;br/&gt;Code:&lt;br/&gt;stack=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, locals=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, args_size=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: iload_1&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: iload_2&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;: invokestatic  &lt;span class=&quot;hljs-meta&quot;&gt;#18                 // Method com/springboot2/learning/javabasic/java8/LambdaTest.lambda$main$0:(II)I&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;: ireturn&lt;br/&gt;RuntimeVisibleAnnotations:&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-meta&quot;&gt;#13()&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此我们可以得出编译以后的代码为：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LambdaTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Func func= LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;();&lt;br/&gt;System.out.println(func.add(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; lambda$main$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; y) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LambdaTest&lt;/span&gt;$$&lt;span class=&quot;hljs-title&quot;&gt;Lambda&lt;/span&gt;$1 &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Func&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; LambdaTest$$Lambda$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;() {&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, inty)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; LambdaTest.lambda$main$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;(x,y);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结下，Lambda底层就是通过一个静态的内部类实现的；&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;欢迎大家点点关注，点点赞，感谢!&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201912/1005447-20191208220755887-1955863761.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;272&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Tue, 14 Jul 2020 00:38:00 +0000</pubDate>
<dc:creator>大魔王先生</dc:creator>
<og:description>Lambda演进 小王在公司正在开发一个学生管理系统，产品经理向他提出一个需求，要筛选出年龄大于15的学生,于是小王写出了以下代码: public&amp;#160;static&amp;#160;List&amp;lt;S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wtzbk/p/13296427.html</dc:identifier>
</item>
<item>
<title>JavaScript图形实例：平面镶嵌图案 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13297080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13297080.html</guid>
<description>&lt;p&gt;&lt;span&gt;      用形状、大小完全相同的一种或几种平面图形进行拼接，彼此之间不留空隙、不重叠地铺成一片，就叫做这几种图形的平面镶嵌。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1．用一种多边形实现的平面镶嵌图案&lt;/h3&gt;
&lt;p&gt;      我们可以采用正三角形、正方形或正六边形实现平面镶嵌。&lt;/p&gt;
&lt;p&gt;（1）用正方形平铺。&lt;/p&gt;
&lt;p&gt;用正方形进行平面镶嵌比较简单，编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正方形平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00'];&lt;/p&gt;
&lt;p&gt;   var L=50;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;10;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      y=k*L;&lt;/p&gt;
&lt;p&gt;      x0=0;&lt;/p&gt;
&lt;p&gt;      for (i=0;i&amp;lt;10;i++)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;          x=x0+i*L;&lt;/p&gt;
&lt;p&gt;          ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;          ctx.strokeRect(x,y,L,L);&lt;/p&gt;
&lt;p&gt;          ctx.fillStyle = color[(k+i)%2];&lt;/p&gt;
&lt;p&gt;          ctx.fillRect(x,y,L,L);&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图1所示的正方形平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080532719-36343636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1 正方形平面镶嵌图案（一）&lt;/p&gt;
&lt;p&gt;      将上述程序中的语句： x0=0; 改写为：&lt;/p&gt;
&lt;p&gt;      if (k%2==0) x0=0;&lt;/p&gt;
&lt;p&gt;      else x0=-L/2;&lt;/p&gt;
&lt;p&gt;      并将填充颜色改为单色填充，例如，ctx.fillStyle = &quot;green&quot;;，则绘制出如图2所示的正方形平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080557960-530950267.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  正方形平面镶嵌图案（二）&lt;/p&gt;
&lt;p&gt;（2）用正三角形平铺。&lt;/p&gt;
&lt;p&gt;用正三角形进行平面镶嵌，编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正三角形平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var sqrt3=Math.sqrt(3);&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00'];&lt;/p&gt;
&lt;p&gt;   var L=50;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;13;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      if (k%2==0)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=-L;&lt;/p&gt;
&lt;p&gt;      }        &lt;/p&gt;
&lt;p&gt;      else&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=-L/2;&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;      y=k*sqrt3*L/2;&lt;/p&gt;
&lt;p&gt;      for (i=0;i&amp;lt;15;i++)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;          x=x0+i*L;&lt;/p&gt;
&lt;p&gt;          ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;          ctx.beginPath();&lt;/p&gt;
&lt;p&gt;          ctx.moveTo(x,y);&lt;/p&gt;
&lt;p&gt;          ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;          ctx.lineTo(x+L,y);&lt;/p&gt;
&lt;p&gt;          ctx.closePath();&lt;/p&gt;
&lt;p&gt;          ctx.stroke();&lt;/p&gt;
&lt;p&gt;          ctx.fillStyle=color[0];&lt;/p&gt;
&lt;p&gt;          ctx.fill();&lt;/p&gt;
&lt;p&gt;          ctx.beginPath();&lt;/p&gt;
&lt;p&gt;          ctx.moveTo(x+L,y);&lt;/p&gt;
&lt;p&gt;          ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;          ctx.lineTo(x+3*L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;          ctx.closePath();&lt;/p&gt;
&lt;p&gt;          ctx.fillStyle = color[1];&lt;/p&gt;
&lt;p&gt;          ctx.stroke();&lt;/p&gt;
&lt;p&gt;          ctx.fill();&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图3所示的正三角形平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080626207-955038393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  正三角形平面镶嵌图案&lt;/p&gt;
&lt;p&gt;（3）用正六边形平铺。&lt;/p&gt;
&lt;p&gt;用正六边形进行平面镶嵌，编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正六边形平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var sqrt3=Math.sqrt(3);&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00','#FFFF00'];&lt;/p&gt;
&lt;p&gt;   function drawHexagon(x,y,L,c)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        ctx.beginPath();&lt;/p&gt;
&lt;p&gt;        ctx.moveTo(x-L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L,y);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y+sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L/2,y+sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L,y);&lt;/p&gt;
&lt;p&gt;        ctx.closePath();&lt;/p&gt;
&lt;p&gt;        ctx.fillStyle = c;&lt;/p&gt;
&lt;p&gt;        ctx.fill();&lt;/p&gt;
&lt;p&gt;        ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;        ctx.stroke();&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   var L=45;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;14;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      if (k%2==0)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=L;&lt;/p&gt;
&lt;p&gt;      }        &lt;/p&gt;
&lt;p&gt;      else&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=-L/2;&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;      y=k*sqrt3*L/2;&lt;/p&gt;
&lt;p&gt;      for (i=0;i&amp;lt;5;i++)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;          x=x0+i*3*L;&lt;/p&gt;
&lt;p&gt;          drawHexagon(x,y,L,color[k%3]);&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;       在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图4所示的正六边形平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080648383-517656085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  正六边形平面镶嵌图案&lt;/p&gt;
&lt;h3&gt;2．用几种多边形实现的平面镶嵌图案&lt;/h3&gt;
&lt;p&gt;      还可以用一种以上的多边形来实现的平面镶嵌。&lt;/p&gt;
&lt;p&gt;       （1）正三角形和正方形组合平面镶嵌。&lt;/p&gt;
&lt;p&gt;       可以使用正三角形与正方形，通过组合后重复排列的方式完成镶嵌。编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正三角形和正方形组合平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var sqrt3=Math.sqrt(3);&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00'];&lt;/p&gt;
&lt;p&gt;   var L=50;&lt;/p&gt;
&lt;p&gt;   var y=0;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;13;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      if (k%2==0)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=-L;&lt;/p&gt;
&lt;p&gt;         y=y+sqrt3*L/2;&lt;/p&gt;
&lt;p&gt;         for (i=0;i&amp;lt;12;i++)&lt;/p&gt;
&lt;p&gt;         {&lt;/p&gt;
&lt;p&gt;            x=x0+i*L;&lt;/p&gt;
&lt;p&gt;            ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;            ctx.beginPath();&lt;/p&gt;
&lt;p&gt;            ctx.moveTo(x,y);&lt;/p&gt;
&lt;p&gt;            ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;            ctx.lineTo(x+L,y);&lt;/p&gt;
&lt;p&gt;            ctx.closePath();&lt;/p&gt;
&lt;p&gt;            ctx.stroke();&lt;/p&gt;
&lt;p&gt;            ctx.fillStyle=color[0];&lt;/p&gt;
&lt;p&gt;            ctx.fill();&lt;/p&gt;
&lt;p&gt;            ctx.beginPath();&lt;/p&gt;
&lt;p&gt;            ctx.moveTo(x+L,y);&lt;/p&gt;
&lt;p&gt;            ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;            ctx.lineTo(x+3*L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;            ctx.closePath();&lt;/p&gt;
&lt;p&gt;            ctx.fillStyle = color[1];&lt;/p&gt;
&lt;p&gt;            ctx.stroke();&lt;/p&gt;
&lt;p&gt;            ctx.fill();&lt;/p&gt;
&lt;p&gt;         }&lt;/p&gt;
&lt;p&gt;       }&lt;/p&gt;
&lt;p&gt;       else&lt;/p&gt;
&lt;p&gt;       {&lt;/p&gt;
&lt;p&gt;         x0=0;&lt;/p&gt;
&lt;p&gt;         y=y+L;&lt;/p&gt;
&lt;p&gt;         for (i=0;i&amp;lt;6;i++)&lt;/p&gt;
&lt;p&gt;         {&lt;/p&gt;
&lt;p&gt;            x=x0+2*i*L;&lt;/p&gt;
&lt;p&gt;            ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;            ctx.strokeRect(x,y-L,L,L);&lt;/p&gt;
&lt;p&gt;            ctx.fillStyle=color[0];&lt;/p&gt;
&lt;p&gt;            ctx.fillRect(x,y-L,L,L);&lt;/p&gt;
&lt;p&gt;            ctx.strokeRect(x+L,y-L,L,L);&lt;/p&gt;
&lt;p&gt;            ctx.fillRect(x+L,y-L,L,L);&lt;/p&gt;
&lt;p&gt;         }&lt;/p&gt;
&lt;p&gt;       }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;       在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图5所示的正三角形和正方形组合平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080730193-547872586.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5  正三角形和正方形组合平面镶嵌图案&lt;/p&gt;
&lt;p&gt;       （2）正六边形与正三角形组合平面镶嵌。&lt;/p&gt;
&lt;p&gt;      可以使用正六边形与正三角形，通过组合后重复排列的方式完成镶嵌。编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正六边形与正三角形组合平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var sqrt3=Math.sqrt(3);&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00'];&lt;/p&gt;
&lt;p&gt;   function drawHexagon(x,y,L,c)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        ctx.beginPath();&lt;/p&gt;
&lt;p&gt;        ctx.moveTo(x-L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y-sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L,y);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y+sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L/2,y+sqrt3/2*L);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L,y);&lt;/p&gt;
&lt;p&gt;        ctx.closePath();&lt;/p&gt;
&lt;p&gt;        ctx.fillStyle = c;&lt;/p&gt;
&lt;p&gt;        ctx.fill();&lt;/p&gt;
&lt;p&gt;        ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;        ctx.stroke();&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle=&quot;#FFFF00&quot;;&lt;/p&gt;
&lt;p&gt;   ctx.fillRect(0,0,canvas.width,canvas.height);&lt;/p&gt;
&lt;p&gt;   var L=45;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;7;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      if (k%2==0)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=L;&lt;/p&gt;
&lt;p&gt;      }        &lt;/p&gt;
&lt;p&gt;      else&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=0;&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;      y=k*sqrt3*L;&lt;/p&gt;
&lt;p&gt;      for (i=0;i&amp;lt;7;i++)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;          x=x0+i*2*L;&lt;/p&gt;
&lt;p&gt;          drawHexagon(x,y,L,color[k%2]);&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图6所示的正六边形与正三角形组合平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080807569-1489807003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图6  正六边形与正三角形组合平面镶嵌图案&lt;/p&gt;
&lt;p&gt;      （3）正八边形组合正方形平面镶嵌。&lt;/p&gt;
&lt;p&gt;      可以使用正八边形与正方形，通过组合后重复排列的方式完成镶嵌。编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;正八边形组合正方形平面镶嵌图案&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;500&quot; height=&quot;500&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var sqrt2=Math.sqrt(2);&lt;/p&gt;
&lt;p&gt;   var color=['#00FFFF','#00FF00'];&lt;/p&gt;
&lt;p&gt;   function drawOctagon(x,y,L,c)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        ctx.beginPath();&lt;/p&gt;
&lt;p&gt;        ctx.moveTo(x-L/2-sqrt2*L/2,y-L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L/2-sqrt2*L/2,y+L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L/2,y+L/2+sqrt2*L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y+L/2+sqrt2*L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2+sqrt2*L/2,y+L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2+sqrt2*L/2,y-L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x+L/2,y-L/2-sqrt2*L/2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x-L/2,y-L/2-sqrt2*L/2);&lt;/p&gt;
&lt;p&gt;        ctx.closePath();&lt;/p&gt;
&lt;p&gt;        ctx.fillStyle = c;&lt;/p&gt;
&lt;p&gt;        ctx.fill();&lt;/p&gt;
&lt;p&gt;        ctx.strokeStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;        ctx.stroke();&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle=&quot;#FFFF00&quot;;&lt;/p&gt;
&lt;p&gt;   ctx.fillRect(0,0,canvas.width,canvas.height);&lt;/p&gt;
&lt;p&gt;   var L=30;&lt;/p&gt;
&lt;p&gt;   var y0=(sqrt2+1)*L/2;&lt;/p&gt;
&lt;p&gt;   for (k=0;k&amp;lt;11;k++)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;      if (k%2==0)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=(sqrt2+1)*L/2;&lt;/p&gt;
&lt;p&gt;      }        &lt;/p&gt;
&lt;p&gt;      else&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;         x0=-L/2;&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;      y=y0+(k-1)*(sqrt2+2)*L/2;&lt;/p&gt;
&lt;p&gt;      for (i=0;i&amp;lt;7;i++)&lt;/p&gt;
&lt;p&gt;      {&lt;/p&gt;
&lt;p&gt;          x=x0+i*(2+sqrt2)*L;&lt;/p&gt;
&lt;p&gt;          drawOctagon(x,y,L,color[k%2]);&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出如图7所示的正八边形组合正方形平面镶嵌图案。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200714080842545-628732306.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图7  正八边形组合正方形平面镶嵌图案&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 00:09:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>用形状、大小完全相同的一种或几种平面图形进行拼接，彼此之间不留空隙、不重叠地铺成一片，就叫做这几种图形的平面镶嵌。 1．用一种多边形实现的平面镶嵌图案 我们可以采用正三角形、正方形或正六边形实现平面镶</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13297080.html</dc:identifier>
</item>
<item>
<title>使用位运算、值交换等方式反转java字符串-共四种方法 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13297068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13297068.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200714080148192-533242564.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本文中，我们将向您展示几种在Java中将String类型的字符串字母倒序的几种方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char[]&lt;/code&gt;循环与值交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byte&lt;/code&gt;循环与值交换&lt;/li&gt;
&lt;li&gt;apache-commons-lang3&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是为了进行开发，请选择&lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;API。出于学习的目的，我们可以研究&lt;code&gt;char[]&lt;/code&gt;和&lt;code&gt;byte&lt;/code&gt;方法，其中涉及到值互换和移位运算技术，这些技术对于了解&lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;API黑匣子背后原理非常有帮助。&lt;/p&gt;
&lt;h2 id=&quot;1-stringbuilderstrreverse&quot;&gt;1. &lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在Java中，我们可以使用&lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;使字符串字母倒序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ReverseString1 {

    public static void main(String[] args) {

        String str = &quot;Reverse a String in Java&quot;;

        StringBuilder sb = new StringBuilder(str).reverse();

        System.out.println(sb.toString());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;avaJ ni gnirtS a esreveR
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2char&quot;&gt;2.&lt;code&gt;char[]&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;首先，我们将字符串转换为char数组，并逐个循环char数组，并使用temp变量交换值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReverseString2 {

    public static void main(String[] args) {

        String str = &quot;Hello World&quot;;
        System.out.println(reverse(str));         //  dlroW olleH

    }

    public static String reverse(String input) {

        if (input == null || input.length() &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Please provide an input!&quot;);

        char[] result = input.toCharArray();

        int startIndex = 0;
        int endIndex = result.length - 1;
        char temp;

        for (; endIndex &amp;gt; startIndex; startIndex++, endIndex--) {
            temp = result[startIndex];
            result[startIndex] = result[endIndex];
            result[endIndex] = temp;
        }

        return new String(result);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的算法需要5个循环（长度/ 2）来使字符串倒序“ Hello World”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;------------------------------------
H  e  l  l  o     W  o  r  l  d
------------------------------------
0  1  2  3  4  5  6  7  8  9  10
------------------------------------

Loop #1 - Swap index 0 &amp;lt;-&amp;gt; index 10
------------------------------------
{d}  e  l  l  o     W  o  r  l  {H}
------------------------------------
{0}  1  2  3  4  5  6  7  8  9  {10}
------------------------------------

Loop #2 - Swap index 1 &amp;lt;-&amp;gt; index 9
------------------------------------
d  {l}  l  l  o     W  o  r  {e}  H
------------------------------------
0  {1}  2  3  4  5  6  7  8  {9}  10
------------------------------------

Loop #3 - Swap index 2 &amp;lt;-&amp;gt; index 8
------------------------------------
d  l  {r}  l  o     W  o  {l}  e  H
------------------------------------
0  1  {2}  3  4  5  6  7  {8}  9  10
------------------------------------

Loop #4 - Swap index 3 &amp;lt;-&amp;gt; index 7
------------------------------------
d  l  r  {o}  o     W  {l}  l  e  H
------------------------------------
0  1  2  {3}  4  5  6  {7}  8  9  10
------------------------------------

Loop #5 - Swap index 4 &amp;lt;-&amp;gt; index 6
------------------------------------
d  l  r  o  {W}     {o}  l  l  e  H
------------------------------------
0  1  2  3  {4}  5  {6}  7  8  9  10
------------------------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-byte--stringbuilderstrreversestr&quot;&gt;3. &lt;code&gt;Byte[] – StringBuilder(str).reverse(str)&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;以下代码段类似于&lt;code&gt;StringBuilder(str).reverse()&lt;/code&gt;的内部实现（UTF16内容除外）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.nio.charset.StandardCharsets;

public class ReverseString3 {

    public static void main(String[] args) {

        String str = &quot;Hello World&quot;;
        System.out.println(reverse(str));

    }

    public static String reverse(String input) {

        if (input == null || input.length() &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Please provide an input!&quot;);

        byte[] val = input.getBytes(StandardCharsets.UTF_8);
        int length = val.length - 1;

        for (int start = (length - 1) &amp;gt;&amp;gt; 1; start &amp;gt;= 0; start--) {
            int end = length - start;
            byte temp = val[start];
            val[start] = val[end];
            val[end] = temp;

            // debugging
            //System.out.println(String.format(&quot;start=%s, end=%s&quot;, start, end));
        }

        return new String(val);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最令人困惑的部分是右移运算符&lt;code&gt;(length - 1) &amp;gt;&amp;gt; 1&lt;/code&gt;，这是什么意思？查看下面的8位示例，您可以找到规律吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(10&amp;gt;&amp;gt;1);  //  10 -&amp;gt; 5
0000 1010   = 10
0000 0101|0 = 10 &amp;gt;&amp;gt; 1 = 5

System.out.println(4&amp;gt;&amp;gt;1);   //  4 -&amp;gt; 2
0000 0100   = 4
0000 0010|0 = 4 &amp;gt;&amp;gt; 1 = 2

System.out.println(100&amp;gt;&amp;gt;1); //  100 -&amp;gt; 50
0110 0100   = 100
00110 010|0 = 100 &amp;gt;&amp;gt; 1 = 50

System.out.println(7&amp;gt;&amp;gt;1);   //  7 -&amp;gt; 3
0000 0111   = 7
0000 0011|1 = 7 &amp;gt;&amp;gt; 1 = 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于数字，每右移1位，金额将减少该值的一半并四舍五入。这&lt;code&gt;(length - 1) &amp;gt;&amp;gt; 1&lt;/code&gt;试图找出字符串的中间点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;number &amp;gt;&amp;gt; 1 = round_down(number/2) or Math.flooa(number/2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值交换从内部开始，然后扩展到外部。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (int start = (length - 1) &amp;gt;&amp;gt; 1; start &amp;gt;= 0; start--) {
    int end = length - start;
    byte temp = val[start];
    val[start] = val[end];
    val[end] = temp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的算法图示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;------------------------------------
H  e  l  l  o     W  o  r  l  d
------------------------------------
0  1  2  3  4  5  6  7  8  9  10
------------------------------------

Loop #1 - Swap index 4 &amp;lt;-&amp;gt; index 6
------------------------------------
H  e  l  l  {W}     {o}  o  r  l  d
------------------------------------
0  1  2  3  {4}  5  {6}  7  8  9  10
------------------------------------

Loop #2 - Swap index 3 &amp;lt;-&amp;gt; index 7
------------------------------------
H  e  l  {o}  W     o  {l}  r  l  d
------------------------------------
0  1  2  {3}  4  5  6  {7}  8  9  10
------------------------------------

Loop #3 - Swap index 2 &amp;lt;-&amp;gt; index 8
------------------------------------
H  e  {r}  o  W     o  l  {l}  l  d
------------------------------------
0  1  {2}  3  4  5  6  7  {8}  9  10
------------------------------------

Loop #4 - Swap index 1 &amp;lt;-&amp;gt; index 9
------------------------------------
H  {l}  r  o  W     o  l  l  {e}  d
------------------------------------
0  {1}  2  3  4  5  6  7  8  {9}  10
------------------------------------

Loop #5 - Swap index 0 &amp;lt;-&amp;gt; index 10
------------------------------------
{d}  l  r  o  W     o  l  l  e  {H}
------------------------------------
{0}  1  2  3  4  5  6  7  8  9  {10}
------------------------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-apache-commons-lang3&quot;&gt;4. Apache commons-lang3&lt;/h2&gt;
&lt;p&gt;对于&lt;a href=&quot;https://commons.apache.org/proper/commons-lang/&quot;&gt;Apache commons-lang3&lt;/a&gt;库，我们可以使用&lt;code&gt;StringUtils.reverse&lt;/code&gt;反转字符串和&lt;code&gt;StringUtils.reverseDelimited&lt;/code&gt;反转单词。&lt;/p&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.commons.lang3.StringUtils;

public class ReverseString3 {

    public static void main(String[] args) {

        System.out.println(StringUtils.reverse(&quot;Hello World Java&quot;));                // reverse string

        System.out.println(StringUtils.reverseDelimited(&quot;Hello World Java&quot;, ' '));  // reverse words

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;avaJ dlroW olleH

Java World Hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看其源代码，&lt;code&gt;Apache-commons-lang3&lt;/code&gt;其实是使用&lt;code&gt;new StringBuilder(str).reverse()&lt;/code&gt;来反转字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package org.apache.commons.lang3;

  public class StringUtils {

  public static String reverse(final String str) {
      if (str == null) {
          return null;
      }
      return new StringBuilder(str).reverse().toString();
  }

  //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 00:02:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>在本文中，我们将向您展示几种在Java中将String类型的字符串字母倒序的几种方法。 StringBuilder(str).reverse() char[]循环与值交换 byte循环与值交换 apa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13297068.html</dc:identifier>
</item>
<item>
<title>循环神经网络（RNN） - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13297037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13297037.html</guid>
<description>&lt;p&gt;在前面引言中对RNN诞生的意义说的不够浅显，这里举个例子来说。语义识别，文本分类是循环神经网络的重点应用领域，当然，并不是说其他的神经网络算法在这些领域就毫无作用，只是效果较差而已。加入有下面一句话：&lt;br/&gt;我是中国人，我会说 &lt;strong&gt;_&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这句话，我想无论是一般的升级网络模型还是循环神经网络模型，都一颗预测出，横线上的内容应该是“汉语”。&lt;/p&gt;
&lt;p&gt;继续，我们把这句话说完整：&lt;br/&gt;我是中国人，我会说汉语，但是我成年后移民到美国，所以我也会说&lt;strong&gt;&lt;strong&gt;_&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一般的神经网络模型中，会孤立地分析每一个词，因为句子中同时出现了中国和美国，所以预测得到的词是“汉语”和“英语”概率相仿，但是在循环神经网络中，模型具有一定的短期记忆功能，能够根据上下文进行语义的预测，所以在较的位置上的“美国”一词有着更大的影响，最终预测结果更有可能是“英语”。这就是为什么循环神经网络在序列相关应用中表现优异的原因。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jul 2020 23:38:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>循环神经网络（Recurrent Neural Network，RNN）是一种别具一格的网络模型，其循环元节点不仅可以接上来自上层的输入数据，也可以接收自身上一次迭代的输出，基于这种特殊的结构，循环神</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/13297037.html</dc:identifier>
</item>
<item>
<title>操作句柄Handle（7） - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13297034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13297034.html</guid>
<description>&lt;p&gt;可以将Handle理解成访问对象的一个“句柄”。垃圾回收时对象可能被移动（对象地址发生改变），通过Handle访问对象可以对使用者屏蔽垃圾回收细节。&lt;/p&gt;
&lt;p&gt;Handle涉及到的相关类的继承关系如下图所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703152254354-1959110231.png&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;244&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;HotSpot会通过Handle对Oop和某些Klass进行操作。下图左边显示了直接访问的情况，下图右边显示了间接访问的情况。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703152340532-1925790444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;可以看到，当对Oop直接引用时，如果Oop的地址发生变化，那么所有的引用都要更新，如图有3处引用，所以都需要更新；当通过Handle对Oop间接引用时，如果Oop的地址发生变化，那么只需要更新Handle中保存的对Oop的引用即可。&lt;/p&gt;
&lt;p&gt;每个Oop都有一个对应的Handle，这样通过对应的Handle可直接获取对应的Oop，不需要进行类型转换。为了读者方便阅读，这里再次给出了Oop继承体系，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703152404502-1484186142.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;可以看到Handle继承体系与Oop继承体系类似，实际上也有相应的对应关系，例如通过instanceHandle操作instanceOopDesc，通过objArrayHandle操作objArrayOopDesc。&lt;/p&gt;
&lt;p&gt;与Oop类似，Klass也需要通过Handle来间接引用。如下几个Klass有对应的Handle： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Klass -klassHandle
　　　　InstanceKlass - instanceKlassHandle
ConstantPool - constantPoolHandle
Method - methodHandle
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在假设有个Person类，还有这个类的一个Person对象，那么可以像下图这样理解Handle、Oop与Klass之间的关系： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703152433474-476558263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面具体看一下Handle的定义，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Base class for all handles. Provides overloading of frequently
// used operators for ease of use.

class Handle VALUE_OBJ_CLASS_SPEC {
 private:
  oop* _handle; // 可以看到是对oop的封装

 protected:
  oop obj() const {
          return _handle == NULL ? (oop)NULL : *_handle;
  }
  oop non_null_obj() const {
          assert(_handle != NULL, &quot;resolving NULL handle&quot;);
          return *_handle;
  }
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用obj()或non_null_obj()方法获取被封装的oop对象，不过并不会直接调用Handle对象的obj()或non_null_obj()对象，而是通过C++的运算符重载来获取。Handle类重载了()和-&amp;gt;运算符，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// General access
oop operator () () const {
   return obj();
}
oop operator -&amp;gt; () const { 
   return non_null_obj(); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这样使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
oop obj = ...;
Handle h1(obj); // allocate new handle

oop obj1 = h1(); // get handle value
h1-&amp;gt;print(); // invoking operation on oop　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于重载了运算符()，所以h1()会调用()运算符的重载方法，重载方法中调用obj()获取到被封装的oop对象。重载了运算符-&amp;gt;，所以h1-&amp;gt;print()同样会调用oop对象的print()方法。&lt;/p&gt;
&lt;p&gt;另外还需要知道，Handle分配在本地线程的HandleArea中，这样在进行垃圾回收时，只需要扫描每个线程的HandleArea即可找出句柄引用的活跃对象。每次创建句柄对象时，都会调用到Handle类的构造函数，其中一个构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
inline Handle::Handle(oop obj) {
  if (obj == NULL) {
    _handle = NULL;
  } else {
        HandleArea* ha = Thread::current()-&amp;gt;handle_area();
    _handle = ha-&amp;gt;allocate_handle(obj);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数obj就是要通过句柄操作的对象。通过调用当前线程的handle_area()函数获取HandleArea，然后调用allocate_handle()在HandleArea中分配存储obj的空间并将obj保存起来。&lt;/p&gt;
&lt;p&gt;每个线程都 会有一个_handle_area属性，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// Thread local handle area for allocation of handles within the VM
HandleArea* _handle_area;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在创建线程时初始化_handle_area属性，然后通过handle_area()函数获取这个属性的值。　&lt;/p&gt;
&lt;p&gt;allocate_handle()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
oop* real_allocate_handle(oop obj) {
    oop* handle = (oop*) Amalloc_4(oopSize);
    *handle = obj;
    return handle;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分配空间并完成obj的存储操作。　&lt;/p&gt;
&lt;p&gt;句柄的释放要通过HandleMark来完成，不过在介绍HandleMark之前需要介绍一下FHandleArea、Area及Chunk等类的实现，下一篇会详细分析。&lt;/p&gt;

&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;10、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13291427.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（6）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;　&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jul 2020 23:36:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>可以将Handle理解成访问对象的一个“句柄”。垃圾回收时对象可能被移动（对象地址发生改变），通过Handle访问对象可以对使用者屏蔽垃圾回收细节。 Handle涉及到的相关类的继承关系如下图所示。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13297034.html</dc:identifier>
</item>
<item>
<title>6 个珍藏已久 IDEA 小技巧，这一波全部分享给你！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13297025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13297025.html</guid>
<description>&lt;p&gt;每周趣图&lt;/p&gt;
&lt;p&gt;&lt;em&gt;产品经理设计体验/用户实际体验&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072033015-1073108542.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本周就不写技术分析文章了，分享几个珍藏已久的 IDEA 的「骚技巧」，助你快速完成代码。&lt;/p&gt;
&lt;p&gt;还等什么？赶紧上车吧......&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看，养成习惯。微信搜索「&lt;strong&gt;程序通事&lt;/strong&gt;」，关注就完事了~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前进后退&quot;&gt;前进/后退&lt;/h2&gt;
&lt;p&gt;我们使用浏览器的过程，可以点击后退查看之前的浏览记录。在 IDEA 也有同样的功能，当我们编辑代码时，点击查看了调用类实现逻辑，然后可以使用后退快捷键，快速回到刚才待编辑的代码处。&lt;/p&gt;
&lt;p&gt;有后退，当然也有前进啦~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前进/后退快捷键如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows:Ctrl + Alt + Left/Right（方向键）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac: ⌘ + ⌥ + ← / →(方向键)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072035593-1548501813.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查看历史记录&quot;&gt;查看历史记录&lt;/h2&gt;
&lt;p&gt;还是以浏览器为例，当我们已经点击很多网页，这时想查看之前看过一个网页，使用后退就会很费劲，需要一个个回退过去查找。这种情况下，直接从历史记录查看将会变得很高效。&lt;/p&gt;
&lt;p&gt;同样的，IDEA 也提供类似的功能查看历史文件,并且在弹出窗口内可以使用关键键快速查找。&lt;/p&gt;
&lt;p&gt;快捷键如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows：ctrl + E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac：⌘ +E&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072037859-216376885.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外 IDEA 中还有可以查看最近修改代码的位置，直接点击快速跳转。&lt;/p&gt;
&lt;p&gt;快捷键如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows：ctrl + shift + E&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac：⌘ + ⇧ +E&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072038615-358356755.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小技巧&quot;&gt;小技巧&lt;/h3&gt;
&lt;p&gt;讲到这里，建议大家设置一个选项，限制标签页（Edit Tabs）数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072039038-218666777.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;strong&gt;Tab Limit&lt;/strong&gt; 为 10，标签页只能打开 10 个，对于会按照打开顺序关闭。&lt;/p&gt;
&lt;p&gt;如果打开标签页很多，超过一屏之后， IDEA 就会把标签页收纳起来，我们需要点击按钮才能查看打开被隐藏的标签页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072039274-1726963046.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，被隐藏的标签页大概率是不会被查看了，这种情况下还不如使用上面查看历史文件的快捷键查找高效。&lt;/p&gt;
&lt;h2 id=&quot;自动补全代码&quot;&gt;自动补全代码&lt;/h2&gt;
&lt;p&gt;使用这个快捷键，可以自动补全代码末尾的分号，括号对等等，可以让我们少打很多字符。另外这个快捷键还会自动格式化完成的代码。&lt;/p&gt;
&lt;p&gt;快捷键：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows：ctrl + shift + Enter（回车键）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**Mac：⌘ + ⇧ +⏎ **&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;自动补全分号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072040223-1000078125.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动补全括号对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072042028-1867694019.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了以上功能，大家可以在其他地方试试，说不准有小惊喜哦！&lt;/p&gt;
&lt;h2 id=&quot;快速抽取变量&quot;&gt;快速抽取变量&lt;/h2&gt;
&lt;p&gt;有时候新建了一个对象，忘记了创建了变量，就很麻烦，需要移动光标到前面，然后声明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072042728-756907570.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，我们可以使用 IDEA 的重构功能-&lt;strong&gt;Introduce Variable&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;快捷键如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows：ctrl + alt + V&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**Mac：⌥ + ⌘ + V **&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072043281-1570387292.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了这种方式之外，最近还学到另外一种方式，使用 IDEA 后缀补全（&lt;strong&gt;Postfix Completion&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072044094-462454315.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;重命名&quot;&gt;重命名&lt;/h2&gt;
&lt;p&gt;有时候手误会把边变量名拼写错误，等到自己发现时，这个变量已经被引用了多次，这时再修改，需要把所有引用的地方都修改一遍，这就很麻烦。&lt;/p&gt;
&lt;p&gt;IDEA 重构功能-重命名（&lt;strong&gt;Rename&lt;/strong&gt;）,可以修改命名，并且一键替换虽有的引用的地方。&lt;/p&gt;
&lt;p&gt;另外函数名，类名修改都可以使用这个快捷键。&lt;/p&gt;
&lt;p&gt;快捷键如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows：shift + F6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**Mac： ⇧ + F6 **&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072044814-1179987695.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;generateserialversionuid&quot;&gt;GenerateSerialVersionUID&lt;/h2&gt;
&lt;p&gt;最后推荐一个插件-&lt;strong&gt;GenerateSerialVersionUID&lt;/strong&gt;，安装插件之后，可以使用 IDEA Generate 功能，自动生成 随机的&lt;strong&gt;serialVersionUID&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你们经常使用 Dubbo，这个插件可以省下很多事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202007/1419561-20200714072045566-1248878369.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后（一键四连呗）&quot;&gt;最后（一键四连呗）&lt;/h2&gt;
&lt;p&gt;知道你们还意犹未尽，可以看下小黑哥之前关于 IDEA 的文章，学习更多骚技巧：&lt;/p&gt;
&lt;ol readability=&quot;0.07235142118863&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/bookmark_and_favorites&quot;&gt;IDEA 小技巧之书签与收藏&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/06/02/1559465646386.html&quot;&gt;IDEA 日常小技巧&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/06/01/1559382236231.html&quot;&gt;解决 IDEA 无法找到 java.util.Date 的问题&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/05/30/1559152180029.html&quot;&gt;还不知道如何使用 IDEA 功能？教你三招掌握大部分功能&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/11/19/1574179066310.html&quot;&gt;分享 IDEA 调试源码的小技巧&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/idea_breakpoint_not_use&quot;&gt;IDEA Debug 无法进入断点的解决方法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/-why_choose_idea&quot;&gt;为什么将 Intellij IDEA 作为日常开发的首选&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://studyidea.cn/idea-2020&quot;&gt;崩盘，IDEA 2020 无法启动的解决办法|赠送 IDEA 2020 新功能&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，最后，你还知道其他骚技巧吗？欢迎留言区来波评论！&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Jul 2020 23:21:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>每周趣图 产品经理设计体验/用户实际体验 本周就不写技术分析文章了，分享几个珍藏已久的 IDEA 的「骚技巧」，助你快速完成代码。 还等什么？赶紧上车吧...... 先赞后看，养成习惯。微信搜索「程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13297025.html</dc:identifier>
</item>
<item>
<title>Java数据类型自动转换（++ ，+=） - 拉布</title>
<link>http://www.cnblogs.com/0nePlece/p/13296854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0nePlece/p/13296854.html</guid>
<description>&lt;h4 id=&quot;在算术表达式中的自动类型转换&quot;&gt;在算术表达式中的自动类型转换&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据从类型范围小的自动向数据范围大的转换&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整数向浮点数转换（包括long类型向float转换）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;例子：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1900950/202007/1900950-20200714010100464-661325353.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;char类型的范围内与整数之间转换依据ASCII表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;强制转换会丢失精度，尤其是超过数据范围和整数与浮点数的转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在赋值表达式中的自动类型转换&quot;&gt;在赋值表达式中的自动类型转换&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;先看两个例子&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1900950/202007/1900950-20200714010134632-144719544.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1900950/202007/1900950-20200714010147258-1711801181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;至此，若有纰漏，望各位不吝赐教&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Jul 2020 17:03:00 +0000</pubDate>
<dc:creator>拉布</dc:creator>
<og:description>Java数据类型自动转换（++ ，+=）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/0nePlece/p/13296854.html</dc:identifier>
</item>
<item>
<title>3dTiles 数据规范详解[4.2] i3dm瓦片二进制数据文件结构 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/13252897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/13252897.html</guid>
<description>&lt;p&gt;i3dm，即 &lt;code&gt;Instanced 3D Model&lt;/code&gt;，实例三维模型的意思。&lt;/p&gt;
&lt;p&gt;诸如树木、路灯、路边的垃圾桶、长椅等具有明显 &lt;strong&gt;重复&lt;/strong&gt; 特征的数据。这类数据用得较少（笑，现在都喜欢搞BIM、倾斜摄影、精模、白模等）&lt;/p&gt;
&lt;blockquote readability=&quot;3.0441176470588&quot;&gt;
&lt;p&gt;我的git地址：&lt;a href=&quot;https://github.com/onsummer&quot;&gt;github.com/onsummer&lt;/a&gt;&lt;br/&gt;转载请规范化转载。出处：@秋意正寒 &lt;a href=&quot;https://www.cnblogs.com/onsummer/p/13252897.html&quot;&gt;https://www.cnblogs.com/onsummer/p/13252897.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与 b3dm 一致，文件头多了个属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200714005624151-452521445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;i3dm的文件头有8个属性，前7个与b3dm是一样的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性的官方名称&lt;/th&gt;
&lt;th&gt;字节长&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;magic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;string（或char[4]）&lt;/td&gt;
&lt;td&gt;该瓦片文件的类型，在i3dm中是 &lt;code&gt;&quot;i3dm&quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;该瓦片的版本，目前限定是 1.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;byteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;该瓦片文件的文件大小，单位：byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;featureTableJSONByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;要素表的JSON文本（二进制形式）长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;featureTableBinaryByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;要素表的二进制数据长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;batchTableJSONByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;批量表的JSON文本（二进制形式）长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;batchTableBinaryByteLength&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;批量表的二进制数据长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;gltfFormat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;gltf在i3dm瓦片中存在的形式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中，前7个和b3dm意义一样，不做解释。&lt;/p&gt;
&lt;p&gt;第8个，&lt;code&gt;gltfFormat&lt;/code&gt; 只有两个值：0和1.&lt;/p&gt;
&lt;p&gt;0，则位于 i3dm 瓦片文件最后的 gltf 内容是一个 uri，指向gltf的数据内容（可能是Base64 DataURL，也可能是其他地方的地址，笔者没见过...）&lt;/p&gt;
&lt;p&gt;1，则位于 i3dm 瓦片文件最后的 gltf 内容是 二进制的 glb，大多数情况见的是这个。&lt;/p&gt;
&lt;p&gt;默认情况，gltf 是 y 轴朝上，3dTiles 是z轴朝上，需要坐标转换。&lt;/p&gt;

&lt;p&gt;在上篇，有介绍到要素表存在 &lt;strong&gt;全局属性&lt;/strong&gt; 和 &lt;strong&gt;要素属性&lt;/strong&gt;。在 i3dm 中，这对概念就能得到很好的解释。&lt;/p&gt;
&lt;h2 id=&quot;①-要素表的全局属性&quot;&gt;① 要素表的全局属性&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;INSTANCES_LENGTH&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;instance的个数&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RTC_CENTER&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;如果坐标是相对坐标，那么相对中心由此属性给出&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;QUANTIZED_VOLUME_OFFSET&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;量化空间范围体的偏移量&lt;/td&gt;
&lt;td&gt;否，与要素属性中的POSITION_QUANTIZED 共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;QUANTIZED_VOLUME_SCALE&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;量化空间范围体的缩放比例&lt;/td&gt;
&lt;td&gt;否，与要素属性中的POSITION_QUANTIZED 共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;EAST_NORTH_UP&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;如果这个属性值是true，而且每个实例的方向没有定义，那么每个实例将默认指向WGS84椭球的正东、正北方向。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第一第二个能与 b3dm 中的 &lt;code&gt;BATCH_LENGTH&lt;/code&gt; 和 &lt;code&gt;RTC_CENTER&lt;/code&gt; 类比来理解，就不解释了。&lt;/p&gt;
&lt;p&gt;最后一个属性指示当前 i3dm 瓦片的坐标轴朝向。&lt;/p&gt;
&lt;p&gt;下列要着重介绍这个所谓的 &lt;code&gt;QUANTIZED_VOLUME&lt;/code&gt;，即 &lt;strong&gt;量化空间范围体&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;量化空间范围体&quot;&gt;量化空间范围体&lt;/h3&gt;
&lt;p&gt;这个词“量化空间范围体”是我自己意译的。&lt;/p&gt;
&lt;p&gt;每个瓦片，都有它自己的空间范围，为了节约数据占用，可以使用相对坐标来记录每个 instance 的位置，也即记录全局属性中的 &lt;code&gt;RTC_CENTER&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;但是，即便用了相对坐标，instance 的坐标值仍然是 &lt;code&gt;FLOAT&lt;/code&gt; 类型，占 4字节。&lt;/p&gt;
&lt;p&gt;假设，存在一个矩形空间，它的左下角点的坐标是 &lt;code&gt;(x, y, z)&lt;/code&gt;，将矩形空间按 &lt;span class=&quot;math inline&quot;&gt;\(2^{16}\)&lt;/span&gt; 等分其 x、y、z 三个方向，定义矩形空间的三条边长对应瓦片本身的坐标空间的缩放比例为 &lt;code&gt;(ScaleX, ScaleY, ScaleZ)&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200714005648576-314489611.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，被细分出来的每一个 “小矩形”，都有它自己在这个矩形空间的量化坐标，因为 x、y、z 三个方向被分割成了 &lt;span class=&quot;math inline&quot;&gt;\(2^{16}\)&lt;/span&gt; 块，我们可以使用 &lt;code&gt;uint16&lt;/code&gt; 类型的数值来记录坐标，这样每个数字只占了 16bit，也即 2byte，比 &lt;code&gt;FLOAT&lt;/code&gt; 的4byte 小了一倍，对于顶点数据的压缩十分具有价值。&lt;/p&gt;
&lt;p&gt;那么，如何将 &lt;code&gt;(16464, 2172, 63312)&lt;/code&gt; 这个量化的坐标映射回瓦片原本的坐标呢？参考公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\vec{Position} = Scale * \displaystyle\frac{\vec{PositionQuantized}}{65535} + \vec{Offset}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即量化坐标 &lt;code&gt;PositionQuantized&lt;/code&gt; 各个坐标分量乘上缩放因子（ &lt;code&gt;Scale / 65535&lt;/code&gt; ），然后加偏移坐标即可。&lt;/p&gt;
&lt;p&gt;三个方向的缩放因子 &lt;code&gt;QUANTIZED_VOLUME_SCALE:float[3]&lt;/code&gt; 和 偏移量 &lt;code&gt;QUANTIZED_VOLUME_OFFSET:float[3]&lt;/code&gt; 作为全局属性写在要素表JSON中。&lt;/p&gt;
&lt;p&gt;如果这两个全局属性未定义，则 逐要素属性中的 &lt;code&gt;POSITION_QUANTIZED&lt;/code&gt; 这个量化坐标也不会存在，即使用原有的 float 类型坐标记法。&lt;/p&gt;
&lt;p&gt;需要注意的是，量化坐标和普通坐标只能二选一，如果都不存在，那么这个 i3dm 瓦片就不会被渲染。&lt;/p&gt;
&lt;p&gt;看到这，是否能理解“要素表的全局属性是对于整个瓦片文件而言”这句话了呢？&lt;/p&gt;
&lt;h2 id=&quot;②-要素表的逐要素属性&quot;&gt;② 要素表的(逐)要素属性&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名称&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;POSITION&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;模型实例的坐标&lt;/td&gt;
&lt;td&gt;是，与POSITION_QUANTIZED二选一&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;POSITION_QUANTIZED&lt;/td&gt;
&lt;td&gt;uint16[3]&lt;/td&gt;
&lt;td&gt;量化空间范围体内的模型实例坐标&lt;/td&gt;
&lt;td&gt;是，与POSITION二选一&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NORMAL_UP&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;模型上方向向量&lt;/td&gt;
&lt;td&gt;否，与NORMAL_RIGHT共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;NORMAL_RIGHT&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;模型右方向向量，必须与&lt;code&gt;up&lt;/code&gt;向量正交&lt;/td&gt;
&lt;td&gt;否，与NORMAL_UP共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;NORMAL_UP_OCT32P&lt;/td&gt;
&lt;td&gt;uint16[2]&lt;/td&gt;
&lt;td&gt;模型上方向向量，32位精度八进制编码&lt;/td&gt;
&lt;td&gt;否，与NORMAL_RIGHT_OCT32P共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;NORMAL_RIGHT_OCT32P&lt;/td&gt;
&lt;td&gt;uint16[2]&lt;/td&gt;
&lt;td&gt;模型右方向向量，必须与&lt;code&gt;up&lt;/code&gt;向量正交，32位精度8进制编码&lt;/td&gt;
&lt;td&gt;否，与NORMAL_UP_OCT32P共存亡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SCALE&lt;/td&gt;
&lt;td&gt;float32&lt;/td&gt;
&lt;td&gt;该 instance 对于 gltf 的缩放比例&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SCALE_NON_UNIFORM&lt;/td&gt;
&lt;td&gt;float32[3]&lt;/td&gt;
&lt;td&gt;该 instance 在三个方向上的缩放比例&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;BATCH_ID&lt;/td&gt;
&lt;td&gt;uin8/uint16(默认)/uint32&lt;/td&gt;
&lt;td&gt;用于在批量表里检索数据用的batchId&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当 i3dm 瓦片中逐个 instance 的&lt;code&gt;POSITION&lt;/code&gt; 被定义时，量化坐标 &lt;code&gt;POSITION_QUANTIZED&lt;/code&gt; 就不应存在，反之亦然。&lt;/p&gt;
&lt;p&gt;接下来四个方向向量属性（法线）&lt;code&gt;NORMAL_UP&lt;/code&gt;、&lt;code&gt;NORMAL_RIGHT&lt;/code&gt; 和 &lt;code&gt;NORMAL_UP_OCT32P&lt;/code&gt;、&lt;code&gt;NORMAL_RIGHT_OCT32P&lt;/code&gt; 也是一对反依赖的逐要素属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCALE&lt;/code&gt; 属性定义了当前要素（instance或实例）对使用的 gltf 模型的缩放比例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCALE_NON_UNIFORM&lt;/code&gt; 属性与 &lt;code&gt;SCALE&lt;/code&gt; 属性差不多，只不过是在三个方向上分别不同的缩放比例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BATCH_ID&lt;/code&gt;，是当前要素（instance或实例）的 id 号，将 要素 与 批量表中的属性 二者联系起来。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;个人觉得，应该叫 &lt;code&gt;INSTANCE_ID&lt;/code&gt; 更合适一些？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;默认方向&quot;&gt;默认方向&lt;/h3&gt;
&lt;p&gt;如果不给定要素属性中与方向有关的向量时，每个实例的朝向有一个默认值：在WGS84椭球上，上方向指向正北，右方向指向正东。&lt;/p&gt;
&lt;h2 id=&quot;③-要素表的json&quot;&gt;③ 要素表的JSON&lt;/h2&gt;
&lt;p&gt;上述所有属性全部会记录在要素表的 JSON 中，对于 全局属性，其值记录在 JSON 中，对于其要素属性，因为要素（即instance）很多的时候写在JSON中体积会变大，所以使用 JSON引用要素表二进制数据体 的形式。&lt;/p&gt;
&lt;p&gt;下列是一个要素表的JSON：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
    INSTANCES_LENGTH : 4, // 有4个实例
    POSITION : {
        byteOffset : 0 // POSITION的值从ftBinary的第0字节起开始计算
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读者不妨回顾上一篇，b3dm的要素表JSON，并未出现有对要素表体引用的属性，在这里出现了：&lt;code&gt;POSITION&lt;/code&gt;，它从要素表体的第 0 个字节开始记录数据。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;POSITION&lt;/code&gt; 这个逐要素（实例、instance）属性的定义，早已在上文提及，即三个 &lt;code&gt;FLOAT&lt;/code&gt; 类型数字为一组，一共 &lt;code&gt;INSTANCES_LENGTH&lt;/code&gt; 组的数据，记录在要素表体。这是 instance 坐标数据，写在 JSON 中虽然没问题，但是会造成空间浪费，以二进制形式记录会比较划算。&lt;/p&gt;
&lt;h2 id=&quot;④-要素表体&quot;&gt;④ 要素表体&lt;/h2&gt;
&lt;p&gt;要素表JSON中引用的二进制数据均顺次记录在此。&lt;/p&gt;

&lt;p&gt;批量表与 b3dm 的一致，均为 JSON 记录属性元数据，批量表体记录属性具体数据。此处不再举例。&lt;/p&gt;

&lt;p&gt;此部分参考官方文档。&lt;/p&gt;
&lt;h2 id=&quot;①-仅有-position-的-i3dm-瓦片&quot;&gt;① 仅有 &lt;code&gt;POSITION&lt;/code&gt; 的 i3dm 瓦片&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;var featureTableJSON = {
    INSTANCES_LENGTH : 4, // 有4个实例
    POSITION : {
        byteOffset : 0 // POSITION的值从ftBinary的第0字节起开始计算
    }
};

var featureTableBinary = new Buffer(new Float32Array([
    0.0, 0.0, 0.0,
    1.0, 0.0, 0.0,
    0.0, 0.0, 1.0,
    1.0, 0.0, 1.0
]).buffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 JavaScript 语言记录了 要素表JSON，以及要素表二进制数据（以ES6 TypedArray 形式）。&lt;/p&gt;
&lt;h2 id=&quot;②-使用量化位置与八进制方向向量&quot;&gt;② 使用量化位置与八进制方向向量&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;var featureTableJSON = {
    INSTANCES_LENGTH : 4, // 有4个实例
    QUANTIZED_VOLUME_OFFSET : [-250.0, 0.0, -250.0],
    QUANTIZED_VOLUME_SCALE : [500.0, 0.0, 500.0],
    POSITION_QUANTIZED : {
        byteOffset : 0
    },
    NORMAL_UP_OCT32P : {
        byteOffset : 24
    },
    NORMAL_RIGHT_OCT32P : {
        byteOffset : 40
    }
};

var positionQuantizedBinary = new Buffer(new Uint16Array([
    0, 0, 0,
    65535, 0, 0,
    0, 0, 65535,
    65535, 0, 65535
]).buffer);

var normalUpOct32PBinary = new Buffer(new Uint16Array([
    32768, 65535,
    32768, 65535,
    32768, 65535,
    32768, 65535
]).buffer);

var normalRightOct32PBinary = new Buffer(new Uint16Array([
    65535, 32768,
    65535, 32768,
    65535, 32768,
    65535, 32768
]).buffer);

var featureTableBinary = Buffer.concat([positionQuantizedBinary, normalUpOct32PBinary, normalRightOct32PBinary]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;规定了全局属性 &lt;code&gt;QUANTIZED_VOLUME_OFFSET&lt;/code&gt; 和 &lt;code&gt;QUANTIZED_VOLUME_SCALE&lt;/code&gt;，规定了量化坐标 &lt;code&gt;POSITION_QUANTIZED&lt;/code&gt;、八进制上方向和右方向向量&lt;code&gt;NORMAL_UP_OCT32P&lt;/code&gt;、&lt;code&gt;NORMAL_RIGHT_OCT32P&lt;/code&gt; 在要素表体中的起始偏移值。&lt;/p&gt;
&lt;p&gt;于是，使用三个 &lt;code&gt;TypedArray&lt;/code&gt; 构造的 &lt;code&gt;Buffer&lt;/code&gt; 对象，再拼接在一起，即要素表体 &lt;code&gt;featureTableBinary&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;与b3dm里写的一致，可以回看：&lt;a href=&quot;https://www.cnblogs.com/onsummer/p/13252896.html&quot;&gt;https://www.cnblogs.com/onsummer/p/13252896.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;同样，这部分内容与b3dm篇章内介绍的一致，会在后续文章内介绍。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jul 2020 16:58:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>i3dm，即 Instanced 3D Model，实例三维模型的意思。 诸如树木、路灯、路边的垃圾桶、长椅等具有明显 重复 特征的数据。这类数据用得较少（笑，现在都喜欢搞BIM、倾斜摄影、精模、白模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onsummer/p/13252897.html</dc:identifier>
</item>
</channel>
</rss>