<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET手撸2048小游戏 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20191030-2048-by-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20191030-2048-by-dotnet.html</guid>
<description>&lt;p&gt;&lt;code&gt;2048&lt;/code&gt;是一款益智小游戏，得益于其规则简单，又和&lt;code&gt;2&lt;/code&gt;的倍数有关，因此广为人知，特别是广受程序员的喜爱。&lt;/p&gt;
&lt;p&gt;本文将再次使用我自制的“准游戏引擎”&lt;code&gt;FlysEngine&lt;/code&gt;，从空白窗口开始，演示如何“手撸”&lt;code&gt;2048&lt;/code&gt;小游戏，并在编码过程中感受&lt;code&gt;C#&lt;/code&gt;的魅力和&lt;code&gt;.NET&lt;/code&gt;编程的快乐。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;说明：&lt;code&gt;FlysEngine&lt;/code&gt;是封装于&lt;code&gt;Direct2D&lt;/code&gt;，重复本文示例，只需在&lt;code&gt;.NET Core 3.0&lt;/code&gt;下安装&lt;code&gt;NuGet&lt;/code&gt;包&lt;code&gt;FlysEngine.Desktop&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;并不一定非要做一层封装才能用，只是&lt;code&gt;FlysEngine&lt;/code&gt;简化了创建设备、处理设备丢失、设备资源管理等“新手劝退”级操作，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先来看一下最终效果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004313140-1363822213.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在开始做游戏前，我先聊聊&lt;code&gt;CRUD&lt;/code&gt;程序员做小游戏时，我认为最重要的三大基本原则。很多时候我们有做个游戏的心，但发现做出来总不是那么回事。这时可以对照一下，看是不是违反了这三大原则中的某一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC&lt;/li&gt;
&lt;li&gt;应用程序驱动（而非事件驱动）&lt;/li&gt;
&lt;li&gt;动画&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;
&lt;p&gt;或者&lt;code&gt;MVP&lt;/code&gt;……关键是将逻辑与视图分离。它有两大特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;视图层完全没有状态;&lt;/li&gt;
&lt;li&gt;数据的变动不会直接影响呈现的画面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是所有的数据更新，都只应体现在内存中。游戏中的数据变化可能非常多，应该积攒起来，一次性更新到界面上。&lt;/p&gt;
&lt;p&gt;这是因为游戏实时渲染特有的性能所要求的，游戏常常有成百上千个动态元素在界面上飞舞，这些动作必须在一次垂直同步（如&lt;code&gt;16ms&lt;/code&gt;或更低）的时间内完成，否则用户就会察觉到卡顿。&lt;/p&gt;
&lt;p&gt;常见的反例有&lt;code&gt;knockout.js&lt;/code&gt;，它基于&lt;code&gt;MVVM&lt;/code&gt;，也就是数据改变会即时通知到视图(&lt;code&gt;DOM&lt;/code&gt;)，导致视图更新不受控制。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;MVC&lt;/code&gt;还有一个好处，就是假如代码需要移植平台时（如&lt;code&gt;C#&lt;/code&gt;移植到&lt;code&gt;html5&lt;/code&gt;），只需更新呈现层即可，模型层所有逻辑都能保留。&lt;/p&gt;
&lt;h2 id=&quot;应用程序驱动而非事件驱动&quot;&gt;应用程序驱动（而非事件驱动）&lt;/h2&gt;
&lt;p&gt;应用程序驱动的特点是界面上的动态元素，之所以“动”，是由应用程序触发——而非事件触发的。&lt;/p&gt;
&lt;p&gt;这一点其实与&lt;code&gt;MVC&lt;/code&gt;也是相辅相成。应用程序驱动确保了&lt;code&gt;MVC&lt;/code&gt;的性能，不会因为依赖变量重新求值次数过多而影响性能。&lt;/p&gt;
&lt;p&gt;另外，如果界面上有状态，就会导致逻辑变得非常复杂，比如变量之间的依赖求值、界面上某些参数的更新时机等。不如简单点搞！直接全部重新计算，全部重新渲染，绝对不会错！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;细心的读者可能发现最终效果&lt;code&gt;demo&lt;/code&gt;中的总分显示就有&lt;code&gt;bug&lt;/code&gt;，开始游戏时总分应该是&lt;code&gt;4&lt;/code&gt;，而非&lt;code&gt;72&lt;/code&gt;。这就是由于该部分没有使用应用程序驱动求值，导致逻辑复杂，导致粗心……最终导致出现了&lt;code&gt;bug&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;html5&lt;/code&gt;的&lt;code&gt;canvas&lt;/code&gt;中，实时渲染的“心脏”是&lt;code&gt;requestAnimationFrame()&lt;/code&gt;函数，在&lt;code&gt;FlysEngine&lt;/code&gt;中，“心脏”是&lt;code&gt;RenderLoop.Run()&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using var form = new RenderWindow { ClientSize = new System.Drawing.Size(400, 400) };
form.Draw += (RenderWindow sender, DeviceContext ctx) =&amp;gt;
{
    ctx.Clear(Color.CornflowerBlue);
};
RenderLoop.Run(form, () =&amp;gt; form.Render(1, PresentFlags.None)); // 心脏&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动画&quot;&gt;动画&lt;/h2&gt;
&lt;p&gt;动画是小游戏的灵魂，一个游戏做得够不够精致，有没有“质感”，除了&lt;code&gt;UI&lt;/code&gt;把关外，就靠我们程序员把动画做好了。&lt;/p&gt;
&lt;p&gt;动画的本质是变量从一个值按一定的速度变化到另一个值：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using var form = new RenderWindow { StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen };
float x = 0;
form.Draw += (w, ctx) =&amp;gt; 
{
    ctx.Clear(Color.CornflowerBlue);
    var brush = w.XResource.GetColor(Color.Red);
    ctx.FillRectangle(new RectangleF(x, 50, 50, 50), brush);
    ctx.DrawText($&quot;x = {x}&quot;, w.XResource.TextFormats[20], new RectangleF(0, 0, 100, 100), brush);
    x += 1.0f;
};
RenderLoop.Run(form, () =&amp;gt; form.Render(1, PresentFlags.None));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004321079-242862676.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，如果用应用程序驱动——而非事件驱动做动画，代码容易变得混乱不堪。尤其是多个动画、动画与动画之间做串联等等。&lt;/p&gt;
&lt;p&gt;这时代码需要精心设计，将代码写成像事件驱动那么容易，下文将演示如何在&lt;code&gt;2048&lt;/code&gt;小游戏中做出流畅的动画。&lt;/p&gt;

&lt;p&gt;回到2048小游戏，我们将在制作这个游戏，慢慢体会我所说的“小游戏三原则”。&lt;/p&gt;
&lt;h2 id=&quot;起始代码&quot;&gt;起始代码&lt;/h2&gt;
&lt;p&gt;这次我们创建一个新的类&lt;code&gt;GameWindow&lt;/code&gt;，继承于&lt;code&gt;RenderWindow&lt;/code&gt;（不像之前直接使用&lt;code&gt;RenderWindow&lt;/code&gt;类），这样有利于分离视图层：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;const int MatrixSize = 4;

void Main()
{
    using var g = new GameWindow() { ClientSize = new System.Drawing.Size(400, 400) };
    RenderLoop.Run(g, () =&amp;gt; g.Render(1, PresentFlags.None));
}

public class GameWindow : RenderWindow
{
    protected override void OnDraw(DeviceContext ctx)
    {
        ctx.Clear(new Color(0xffa0adbb));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OnDraw&lt;/code&gt;重载即为渲染的方法，提供了一个&lt;code&gt;ctx&lt;/code&gt;参数，对应&lt;code&gt;Direct2D&lt;/code&gt;中的&lt;code&gt;ID2D1DeviceContext&lt;/code&gt;类型，可以用来绘图。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;0xffa0adbb&lt;/code&gt;是棋盘背景颜色，它是用&lt;code&gt;ABGR&lt;/code&gt;的顺序表示的，运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004330409-2049974830.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;棋盘&quot;&gt;棋盘&lt;/h2&gt;
&lt;p&gt;首先我们需要“画”一个棋盘，它分为背景和棋格子组成。这部分内容是完全静态的，因此可以在呈现层直接完成。&lt;/p&gt;
&lt;p&gt;棋盘应该随着窗口大小变化而变化，因此各个变量都应该动态计算得出。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004341241-1232584573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，&lt;code&gt;2048&lt;/code&gt;游戏区域应该为正方形，因此总边长&lt;code&gt;fullEdge&lt;/code&gt;应该为窗口的高宽属性的较小者（以刚好放下一个正方形），代码表示如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;float fullEdge = Math.Min(ctx.Size.Width, ctx.Size.Height);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方块与方块之间的距离定义为总边长的&lt;code&gt;1/8&lt;/code&gt;再除以&lt;code&gt;MatrixSize&lt;/code&gt;（也就是4），此时单个方块的边长就可以计算出来了，为总边长&lt;code&gt;fullEdge&lt;/code&gt;减去5个&lt;code&gt;gap&lt;/code&gt;再除以&lt;code&gt;MatrixSize&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;float gap = fullEdge / (MatrixSize * 8);
float edge = (fullEdge - gap * (MatrixSize + 1)) / MatrixSize;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后即可按循环绘制&lt;code&gt;4&lt;/code&gt;行&lt;code&gt;4&lt;/code&gt;列方块位置，使用矩阵变换可以让代码更简单：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;foreach (var v in MatrixPositions)
{
    float centerX = gap + v.x * (edge + gap) + edge / 2.0f;
    float centerY = gap + v.y * (edge + gap) + edge / 2.0f;

    ctx.Transform =
        Matrix3x2.Translation(-edge / 2, -edge / 2) *
        Matrix3x2.Translation(centerX, centerY);

    ctx.FillRoundedRectangle(new RoundedRectangle
    {
        RadiusX = edge / 21,
        RadiusY = edge / 21,
        Rect = new RectangleF(0, 0, edge, edge),
    }, XResource.GetColor(new Color(0x59dae4ee)));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;foreach (var v in MatrixPositions)&lt;/code&gt;是以下代码的简写：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;for (var x = 0; x &amp;lt; MatrixSize; ++x)
{
    for (var y = 0; y &amp;lt; MatrixSize; ++y)
    {
        // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;2048&lt;/code&gt;将多次遍历&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;，因此定义了一个变量&lt;code&gt;MatrixPositions&lt;/code&gt;来简化这一过程：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static IEnumerable&amp;lt;int&amp;gt; inorder = Enumerable.Range(0, MatrixSize);
static IEnumerable&amp;lt;(int x, int y)&amp;gt; MatrixPositions =&amp;gt; 
    inorder.SelectMany(y =&amp;gt; inorder.Select(x =&amp;gt; (x, y)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004356245-168455058.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;加入数字方块&quot;&gt;加入数字方块&lt;/h2&gt;
&lt;p&gt;数据方块由于是活动的，为了代码清晰，需要加入额外两个类，&lt;code&gt;Cell&lt;/code&gt;和&lt;code&gt;Matrix&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;cell类&quot;&gt;Cell类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cell&lt;/code&gt;是单个方块，需要保存当前的数字&lt;code&gt;N&lt;/code&gt;，其次还要获取当前的颜色信息：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Cell
{
    public int N;

    public Cell(int n)
    {
        N = n;
    }

    public DisplayInfo DisplayInfo =&amp;gt; N switch
    {
        2 =&amp;gt; DisplayInfo.Create(),
        4 =&amp;gt; DisplayInfo.Create(0xede0c8ff),
        8 =&amp;gt; DisplayInfo.Create(0xf2b179ff, 0xf9f6f2ff),
        16 =&amp;gt; DisplayInfo.Create(0xf59563ff, 0xf9f6f2ff),
        32 =&amp;gt; DisplayInfo.Create(0xf67c5fff, 0xf9f6f2ff),
        64 =&amp;gt; DisplayInfo.Create(0xf65e3bff, 0xf9f6f2ff),
        128 =&amp;gt; DisplayInfo.Create(0xedcf72ff, 0xf9f6f2ff, 45),
        256 =&amp;gt; DisplayInfo.Create(0xedcc61ff, 0xf9f6f2ff, 45),
        512 =&amp;gt; DisplayInfo.Create(0xedc850ff, 0xf9f6f2ff, 45),
        1024 =&amp;gt; DisplayInfo.Create(0xedc53fff, 0xf9f6f2ff, 35),
        2048 =&amp;gt; DisplayInfo.Create(0x3c3a32ff, 0xf9f6f2ff, 35),
        _ =&amp;gt; DisplayInfo.Create(0x3c3a32ff, 0xf9f6f2ff, 30),
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;DisplayInfo&lt;/code&gt;类用来表达方块的文字颜色、背景颜色和字体大小：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;struct DisplayInfo
{
    public Color Background;
    public Color Foreground;
    public float FontSize;

    public static DisplayInfo Create(uint background = 0xeee4daff, uint color = 0x776e6fff, float fontSize = 55) =&amp;gt;
        new DisplayInfo { Background = new Color(background), Foreground = new Color(color), FontSize = fontSize };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章中的“魔法”数字&lt;code&gt;0xeee4daff&lt;/code&gt;等，和上文一样，是颜色的&lt;code&gt;ABGR&lt;/code&gt;顺序表示的。通过一个简单的&lt;code&gt;Create&lt;/code&gt;方法，即可实现默认颜色、默认字体的代码简化，无需写过多的&lt;code&gt;if/else&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我特意使用了&lt;code&gt;struct&lt;/code&gt;而非&lt;code&gt;class&lt;/code&gt;关键字，这样创建的是值类型而非引用类型，可以无需分配和回收堆内存。在应用或游戏中，内存分配和回收常常是最影响性能和吞吐性的指标之一。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N switch { ... }&lt;/code&gt;这样的代码，是&lt;code&gt;C# 8.0&lt;/code&gt;的&lt;code&gt;switch expression&lt;/code&gt;特性（下文将继续&lt;strong&gt;大量&lt;/strong&gt;使用），可以通过表达式——而非语句的方式表达一个逻辑，可以让代码大大简化。该特性现在在&lt;code&gt;.NET Core 3.0&lt;/code&gt;项目中默认已经打开，某些支持的早期版本，需要将项目中的&lt;code&gt;&amp;lt;LangVersion&amp;gt;&lt;/code&gt;属性设置为&lt;code&gt;8.0&lt;/code&gt;才可以使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据&lt;code&gt;2048&lt;/code&gt;的设计文档和参考其它项目，一个方块创建时有&lt;code&gt;90%&lt;/code&gt;机率是&lt;code&gt;2&lt;/code&gt;，&lt;code&gt;10%&lt;/code&gt;机率是&lt;code&gt;4&lt;/code&gt;，这可以通过&lt;code&gt;.NET&lt;/code&gt;中的&lt;code&gt;Random&lt;/code&gt;类实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static Random r = new Random();
public static Cell CreateRandom() =&amp;gt; new Cell(r.NextDouble() &amp;lt; 0.9 ? 2 : 4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时，只需调用&lt;code&gt;CreateRandom()&lt;/code&gt;即可。&lt;/p&gt;
&lt;h3 id=&quot;matrix类&quot;&gt;Matrix类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Matrix&lt;/code&gt;用于管理和控制多个&lt;code&gt;Cell&lt;/code&gt;类。它包含了一个二维数组&lt;code&gt;Cell[,]&lt;/code&gt;，用于保存&lt;code&gt;4x4&lt;/code&gt;的&lt;code&gt;Cell&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Matrix
{
    public Cell[,] CellTable;

    public IEnumerable&amp;lt;Cell&amp;gt; GetCells()
    {
        foreach (var c in CellTable)
            if (c != null) yield return c;
    }

    public int GetScore() =&amp;gt; GetCells().Sum(v =&amp;gt; v.N);

    public void ReInitialize()
    {
        CellTable = new Cell[MatrixSize, MatrixSize];

        (int x, int y)[] allPos = MatrixPositions.ShuffleCopy();
        for (var i = 0; i &amp;lt; 2; ++i) // 2: initial cell count
        {
            CellTable[allPos[i].y, allPos[i].x] = Cell.CreateRandom();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;ReInitialize&lt;/code&gt;方法对&lt;code&gt;Cell[,]&lt;/code&gt;二维数组进行了初始化，然后在随机位置创建了两个&lt;code&gt;Cell&lt;/code&gt;。值得一提的是&lt;code&gt;ShuffleCopy()&lt;/code&gt;函数，该函数可以对&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;进行乱序，然后复制为数组：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static class RandomUtil
{
    static Random r = new Random();
    public static T[] ShuffleCopy&amp;lt;T&amp;gt;(this IEnumerable&amp;lt;T&amp;gt; data)
    {
        var arr = data.ToArray();

        for (var i = arr.Length - 1; i &amp;gt; 0; --i)
        {
            int randomIndex = r.Next(i + 1);

            T temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }

        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数看似简单，能写准确可不容易。尤其注意&lt;code&gt;for&lt;/code&gt;循环的终止条件不是&lt;code&gt;i &amp;gt;= 0&lt;/code&gt;，而是&lt;code&gt;i &amp;gt; 0&lt;/code&gt;，这两者有区别，以后我有机会会深入聊聊这个函数。今天最简单的办法就是——直接使用它即可。&lt;/p&gt;
&lt;p&gt;最后回到&lt;code&gt;GameWindow&lt;/code&gt;类的&lt;code&gt;OnDraw&lt;/code&gt;方法，如法炮制，将&lt;code&gt;Matrix&lt;/code&gt;“画”出来即可：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// .. 继之前的OnDraw方法内容
foreach (var p in MatrixPositions)
{
    var c = Matrix.CellTable[p.y, p.x];
    if (c == null) continue;

    float centerX = gap + p.x * (edge + gap) + edge / 2.0f;
    float centerY = gap + p.y * (edge + gap) + edge / 2.0f;

    ctx.Transform =
        Matrix3x2.Translation(-edge / 2, -edge / 2) *
        Matrix3x2.Translation(centerX, centerY);
    ctx.FillRectangle(new RectangleF(0, 0, edge, edge), XResource.GetColor(c.DisplayInfo.Background));

    var textLayout = XResource.TextLayouts[c.N.ToString(), c.DisplayInfo.FontSize];
    ctx.Transform =
        Matrix3x2.Translation(-textLayout.Metrics.Width / 2, -textLayout.Metrics.Height / 2) *
        Matrix3x2.Translation(centerX, centerY);
    ctx.DrawTextLayout(Vector2.Zero, textLayout, XResource.GetColor(c.DisplayInfo.Foreground));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004421898-645356214.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想测试所有方块颜色，可将&lt;code&gt;ReInitialize()&lt;/code&gt;方法改为如下即可：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ReInitialize()
{
    CellTable = new Cell[MatrixSize, MatrixSize];

    CellTable[0, 0] = new Cell(2);
    CellTable[0, 1] = new Cell(4);
    CellTable[0, 2] = new Cell(8);
    CellTable[0, 3] = new Cell(16);
    CellTable[1, 0] = new Cell(32);
    CellTable[1, 1] = new Cell(64);
    CellTable[1, 2] = new Cell(128);
    CellTable[1, 3] = new Cell(256);
    CellTable[2, 0] = new Cell(512);
    CellTable[2, 1] = new Cell(1024);
    CellTable[2, 2] = new Cell(2048);
    CellTable[2, 3] = new Cell(4096);
    CellTable[3, 0] = new Cell(8192);
    CellTable[3, 1] = new Cell(16384);
    CellTable[3, 2] = new Cell(32768);
    CellTable[3, 3] = new Cell(65536);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004427693-2070081514.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，看起来……有那么点意思了。&lt;/p&gt;
&lt;h2 id=&quot;引入事件把方块移动起来&quot;&gt;引入事件，把方块移动起来&lt;/h2&gt;
&lt;p&gt;本篇也分两部分，事件，和方块移动逻辑。&lt;/p&gt;
&lt;h3 id=&quot;事件&quot;&gt;事件&lt;/h3&gt;
&lt;p&gt;首先是事件，要将方块移动起来，我们再次引入大名鼎鼎的&lt;code&gt;Rx&lt;/code&gt;（全称：&lt;code&gt;Reactive.NET&lt;/code&gt;，&lt;code&gt;NuGet&lt;/code&gt;包：&lt;code&gt;System.Reactive&lt;/code&gt;）。然后先引入一个基础枚举，用于表示上下左右：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;enum Direction
{
    Up, Down, Left, Right,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将键盘的上下左右事件，转换为该枚举的&lt;code&gt;IObservable&amp;lt;Direction&amp;gt;&lt;/code&gt;流（可以写在&lt;code&gt;GameWindow&lt;/code&gt;构造函数中），然后调用该“流”的&lt;code&gt;.Subscribe&lt;/code&gt;方法直接订阅该“流”：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var keyUp = Observable.FromEventPattern&amp;lt;KeyEventArgs&amp;gt;(this, nameof(this.KeyUp))
    .Select(x =&amp;gt; x.EventArgs.KeyCode);

keyUp.Select(x =&amp;gt; x switch
    {
        Keys.Left =&amp;gt; (Direction?)Direction.Left,
        Keys.Right =&amp;gt; Direction.Right,
        Keys.Down =&amp;gt; Direction.Down,
        Keys.Up =&amp;gt; Direction.Up,
        _ =&amp;gt; null
    })
    .Where(x =&amp;gt; x != null)
    .Select(x =&amp;gt; x.Value)
    .Subscribe(direction =&amp;gt;
    {
        Matrix.RequestDirection(direction);
        Text = $&quot;总分：{Matrix.GetScore()}&quot;;
    });

keyUp.Where(k =&amp;gt; k == Keys.Escape).Subscribe(k =&amp;gt;
{
    if (MessageBox.Show(&quot;要重新开始游戏吗？&quot;, &quot;确认&quot;, MessageBoxButtons.OKCancel) == System.Windows.Forms.DialogResult.OK)
    {
        Matrix.ReInitialize();
        // 这行代码没写就是文章最初说的bug，其根本原因（也许忘记了）就是因为这里不是用的MVC/应用程序驱动
        // Text = $&quot;总分：{Matrix.GetScore()}&quot;;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次用户松开上下左右四个键之一，就会调用&lt;code&gt;Matrix&lt;/code&gt;的&lt;code&gt;RequestDirection&lt;/code&gt;方法（马上说），松下&lt;code&gt;Escape&lt;/code&gt;键，则会提示用户是否重新开始玩，然后重新显示新的总分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我再次使用了&lt;code&gt;C# 8.0&lt;/code&gt;的&lt;code&gt;switch expression&lt;/code&gt;语法，它让我省去了&lt;code&gt;if/else&lt;/code&gt;或&lt;code&gt;switch case&lt;/code&gt;，代码精练了不少；&lt;/li&gt;
&lt;li&gt;不是非得要用&lt;code&gt;Rx&lt;/code&gt;，但&lt;code&gt;Rx&lt;/code&gt;相当于将事件转换为了数据，可以让代码精练许多，且极大地提高了可扩展性。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;移动逻辑&quot;&gt;移动逻辑&lt;/h3&gt;
&lt;p&gt;我们先在脑子里面想想，感受一下这款游戏的移动逻辑应该是怎样的。（你可以在草稿本上先画画图……）&lt;/p&gt;
&lt;p&gt;我将&lt;code&gt;2048&lt;/code&gt;游戏的逻辑概括如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将所有方块，向用户指定的方向遍历，找到最近的方块位置&lt;/li&gt;
&lt;li&gt;如果找到，且数字一样，则合并（删除对面，自己加倍）&lt;/li&gt;
&lt;li&gt;如果找到，但数字不一样，则移动到对面的前一格&lt;/li&gt;
&lt;li&gt;如果发生过移动，则生成一个新方块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果想清楚了这个逻辑，就能写出代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void RequestDirection(Direction direction)
{
    if (GameOver) return;

    var dv = Directions[(int)direction];
    var tx = dv.x == 1 ? inorder.Reverse() : inorder;
    var ty = dv.y == 1 ? inorder.Reverse() : inorder;

    bool moved = false;
    foreach (var i in tx.SelectMany(x =&amp;gt; ty.Select(y =&amp;gt; (x, y))))
    {
        Cell cell = CellTable[i.y, i.x];
        if (cell == null) continue;

        var next = NextCellInDirection(i, dv);

        if (WithinBounds(next.target) &amp;amp;&amp;amp; CellTable[next.target.y, next.target.x].N == cell.N)
        {   // 对面有方块，且可合并
            CellTable[i.y, i.x] = null;
            CellTable[next.target.y, next.target.x] = cell;
            cell.N *= 2;
            moved = true;
        }
        else if (next.prev != i) // 对面无方块，移动到prev
        {
            CellTable[i.y, i.x] = null;
            CellTable[next.prev.y, next.prev.x] = cell;
            moved = true;
        }
    }

    if (moved)
    {
        var nextPos = MatrixPositions
            .Where(v =&amp;gt; CellTable[v.y, v.x] == null)
            .ShuffleCopy()
            .First();
        CellTable[nextPos.y, nextPos.x] = Cell.CreateRandom();

        if (!IsMoveAvailable()) GameOver = true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;dv&lt;/code&gt;、&lt;code&gt;tx&lt;/code&gt;与&lt;code&gt;ty&lt;/code&gt;三个变量，巧妙地将&lt;code&gt;Direction&lt;/code&gt;枚举转换成了数据，避免了过多的&lt;code&gt;if/else&lt;/code&gt;，导致代码膨胀。然后通过一行简单的&lt;code&gt;LINQ&lt;/code&gt;，再次将两个&lt;code&gt;for&lt;/code&gt;循环联合在一起。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意示例还使用了&lt;code&gt;(x, y)&lt;/code&gt;这样的语法（下文将继续&lt;strong&gt;大量&lt;/strong&gt;使用），这叫&lt;code&gt;Value Tuple&lt;/code&gt;，或者&lt;code&gt;值元组&lt;/code&gt;。&lt;code&gt;Value Tuple&lt;/code&gt;是&lt;code&gt;C# 7.0&lt;/code&gt;的新功能，它和&lt;code&gt;C# 6.0&lt;/code&gt;新增的&lt;code&gt;Tuple&lt;/code&gt;的区别有两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Value Tuple&lt;/code&gt;可以通过&lt;code&gt;(x, y)&lt;/code&gt;这样的语法内联，而&lt;code&gt;Tuple&lt;/code&gt;要使用&lt;code&gt;Tuple.Create(x, y)&lt;/code&gt;来创建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Value Tuple&lt;/code&gt;故名思义，它是&lt;code&gt;值类型&lt;/code&gt;，可以无需内存分配和&lt;code&gt;GC&lt;/code&gt;开销（但稍稍增长了少许内存复制开销）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;我还定义了另外两个字段：&lt;code&gt;GameOver&lt;/code&gt;和&lt;code&gt;KeepGoing&lt;/code&gt;，用来表示是否游戏结束和游戏胜利时是否继续：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public bool GameOver,KeepGoing;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;NextCellInDirection&lt;/code&gt;用来计算方块对面的情况，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ((int x, int y) target, (int x, int y) prev) NextCellInDirection((int x, int y) cell, (int x, int y) dv)
{
    (int x, int y) prevCell;
    do
    {
        prevCell = cell;
        cell = (cell.x + dv.x, cell.y + dv.y);
    }
    while (WithinBounds(cell) &amp;amp;&amp;amp; CellTable[cell.y, cell.x] == null);

    return (cell, prevCell);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IsMoveAvailable&lt;/code&gt;函数用来判断游戏是否还能继续，如果不能继续将设置&lt;code&gt;GameOver = true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它的逻辑是如果方块数不满，则显示游戏可以继续，然后判断是否有任意相邻方块数字相同，有则表示游戏还能继续，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public bool IsMoveAvailable() =&amp;gt; GetCells().Count() switch
{
    MatrixSize * MatrixSize =&amp;gt; MatrixPositions
        .SelectMany(v =&amp;gt; Directions.Select(d =&amp;gt; new
        {
            Position = v,
            Next = (x: v.x + d.x, y: v.y + d.y)
        }))
        .Where(x =&amp;gt; WithinBounds(x.Position) &amp;amp;&amp;amp; WithinBounds(x.Next))
        .Any(v =&amp;gt; CellTable[v.Position.y, v.Position.x]?.N == CellTable[v.Next.y, v.Next.x]?.N), 
    _ =&amp;gt; true, 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意我再次使用了&lt;code&gt;switch expression&lt;/code&gt;、&lt;code&gt;Value Tuple&lt;/code&gt;和令人拍案叫绝的&lt;code&gt;LINQ&lt;/code&gt;，相当于只需&lt;strong&gt;一行&lt;/strong&gt;代码，就将这些复杂的逻辑搞定了。&lt;/p&gt;
&lt;p&gt;最后别忘了在&lt;code&gt;GameWindow&lt;/code&gt;的&lt;code&gt;OnUpdateLogic&lt;/code&gt;重载函数中加入一些弹窗提示，显示用于恭喜和失败的信息：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override void OnUpdateLogic(float dt)
{
    base.OnUpdateLogic(dt);

    if (Matrix.GameOver)
    {
        if (MessageBox.Show($&quot;总分：{Matrix.GetScore()}\r\n重新开始吗？&quot;, &quot;失败！&quot;, MessageBoxButtons.YesNo) == DialogResult.Yes)
        {
            Matrix.ReInitialize();
        }
        else
        {
            Matrix.GameOver = false;
        }
    }
    else if (!Matrix.KeepGoing &amp;amp;&amp;amp; Matrix.GetCells().Any(v =&amp;gt; v.N == 2048))
    {
        if (MessageBox.Show(&quot;您获得了2048！\r\n还想继续升级吗？&quot;, &quot;恭喜！&quot;, MessageBoxButtons.YesNo) == DialogResult.Yes)
        {
            Matrix.KeepGoing = true;
        }
        else
        {
            Matrix.ReInitialize();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，游戏运行效果显示如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004439571-1436600035.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中到了这一步，&lt;code&gt;2048&lt;/code&gt;已经可堪一玩了，但总感觉不是那么个味。还有什么可以做的呢？&lt;/p&gt;
&lt;h2 id=&quot;动画-1&quot;&gt;动画&lt;/h2&gt;
&lt;p&gt;上文说过，动画是灵魂级别的功能。和&lt;code&gt;CRUD&lt;/code&gt;程序员的日常——“功能”实现了就万事大吉不同，游戏&lt;strong&gt;必须&lt;/strong&gt;要有动画，没有动画简直就相当于游戏白做了。&lt;/p&gt;
&lt;p&gt;在远古&lt;code&gt;jQuery&lt;/code&gt;中，有一个&lt;code&gt;$(element).animate()&lt;/code&gt;方法，实现动画挺方便，我们可以模仿该方法的调用方式，自己实现一个：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static GameWindow Instance = null;

public static Task CreateAnimation(float initialVal, float finalVal, float durationMs, Action&amp;lt;float&amp;gt; setter)
{
    var tcs = new TaskCompletionSource&amp;lt;float&amp;gt;();
    Variable variable = Instance.XResource.CreateAnimation(initialVal, finalVal, durationMs / 1000);

    IDisposable subscription = null;
    subscription = Observable
        .FromEventPattern&amp;lt;RenderWindow, float&amp;gt;(Instance, nameof(Instance.UpdateLogic))
        .Select(x =&amp;gt; x.EventArgs)
        .Subscribe(x =&amp;gt;
        {
            setter((float)variable.Value);
            if (variable.FinalValue == variable.Value)
            {
                tcs.SetResult(finalVal);
                variable.Dispose();
                subscription.Dispose();
            }
        });

    return tcs.Task;
}

public GameWindow()
{
    Instance = this;
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，我实际是将一个动画转换成为了一个&lt;code&gt;Task&lt;/code&gt;，这样就可以实际复杂动画、依赖动画、连续动画的效果。&lt;/p&gt;
&lt;p&gt;使用该函数，可以轻易做出这样的效果，动画部分代码只需这样写（见&lt;code&gt;animation-demo.linq&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;float x = 50, y = 150, w = 50, h = 50;
float red = 0;
protected override async void OnLoad(EventArgs e)
{
    var stage1 = new[]
    {
        CreateAnimation(initialVal: x, finalVal: 340, durationMs: 1000, v =&amp;gt; x = v),
        CreateAnimation(initialVal: h, finalVal: 100, durationMs: 600, v =&amp;gt; h = v),
    };
    await Task.WhenAll(stage1);

    await CreateAnimation(initialVal: h, finalVal: 50, durationMs: 1000, v =&amp;gt; h = v);
    await CreateAnimation(initialVal: x, finalVal: 20, durationMs: 1000, v =&amp;gt; x = v);
    while (true)
    {
        await CreateAnimation(initialVal: red, finalVal: 1.0f, durationMs: 500, v =&amp;gt; red = v);
        await CreateAnimation(initialVal: red, finalVal: 0.0f, durationMs: 500, v =&amp;gt; red = v);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下，请注意最后的黑色-红色闪烁动画，其实是一个无限动画，各位可以想像下如果&lt;strong&gt;手撸&lt;/strong&gt;状态机，这些代码会多么麻烦，而&lt;code&gt;C#&lt;/code&gt;支持协程，这些代码只需一些&lt;code&gt;await&lt;/code&gt;和一个&lt;code&gt;while (true)&lt;/code&gt;语句即可完美完成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004448088-2016686405.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这个基础，开工做动画了，首先给&lt;code&gt;Cell&lt;/code&gt;类做一些修改：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Cell
{
    public int N;
    public float DisplayX, DisplayY, DisplaySize = 0;
    const float AnimationDurationMs = 120;

    public bool InAnimation =&amp;gt;
        (int)DisplayX != DisplayX ||
        (int)DisplayY != DisplayY ||
        (int)DisplaySize != DisplaySize;

    public Cell(int x, int y, int n)
    {
        DisplayX = x; DisplayY = y; N = n;
        _ = ShowSizeAnimation();
    }
    
    public async Task ShowSizeAnimation()
    {
        await GameWindow.CreateAnimation(DisplaySize, 1.2f, AnimationDurationMs, v =&amp;gt; DisplaySize = v);
        await GameWindow.CreateAnimation(DisplaySize, 1.0f, AnimationDurationMs, v =&amp;gt; DisplaySize = v);
    }

    public void MoveTo(int x, int y, int n = default)
    {
        _ = GameWindow.CreateAnimation(DisplayX, x, AnimationDurationMs, v =&amp;gt; DisplayX = v);
        _ = GameWindow.CreateAnimation(DisplayY, y, AnimationDurationMs, v =&amp;gt; DisplayY = v);

        if (n != default)
        {
            N = n;
            _ = ShowSizeAnimation();
        }
    }

    public DisplayInfo DisplayInfo =&amp;gt; N switch // ...

    static Random r = new Random();
    public static Cell CreateRandomAt(int x, int y) =&amp;gt; new Cell(x, y, r.NextDouble() &amp;lt; 0.9 ? 2 : 4);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入了&lt;code&gt;DisplayX&lt;/code&gt;，&lt;code&gt;DisplayY&lt;/code&gt;、&lt;code&gt;DisplaySize&lt;/code&gt;三个属性，用于管理其用于在界面上显示的值。还加入了一个&lt;code&gt;InAnimation&lt;/code&gt;变量，用于判断是否处理动画状态。&lt;/p&gt;
&lt;p&gt;另外，构造函数现在也要求传入&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的值，如果位置变化了，现在必须调用&lt;code&gt;MoveTo&lt;/code&gt;方法，它与&lt;code&gt;Cell&lt;/code&gt;建立关联了（之前并不会）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ShowSizeAnimation&lt;/code&gt;函数是演示该动画很好的示例，它先将方块放大至&lt;code&gt;1.2&lt;/code&gt;倍，然后缩小成原状。&lt;/p&gt;
&lt;p&gt;有了这个类之后，&lt;code&gt;Matrix&lt;/code&gt;和&lt;code&gt;GameWindow&lt;/code&gt;也要做一些相应的调整（详情见&lt;code&gt;2048.linq&lt;/code&gt;），最终做出来的效果如下（注意合并时的动画）：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004456001-243315335.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;撤销功能&quot;&gt;撤销功能&lt;/h2&gt;
&lt;p&gt;有一天突然找到了一个带撤销功能的&lt;code&gt;2048&lt;/code&gt;，那时我发现&lt;code&gt;2048&lt;/code&gt;带不带撤销，其实是两个游戏。撤销就像神器，给爱挑(&lt;code&gt;mian&lt;/code&gt;)战(&lt;code&gt;zi&lt;/code&gt;)的玩(&lt;code&gt;ruo&lt;/code&gt;)家(&lt;code&gt;ji&lt;/code&gt;)带来了轻松与快乐，给予了第二次机会，让玩家转危为安。&lt;/p&gt;
&lt;p&gt;所以不如先加入撤销功能。&lt;/p&gt;
&lt;p&gt;用户每次撤销的，都是最新状态，是一个经典的&lt;strong&gt;后入先出&lt;/strong&gt;的模式，也就是&lt;code&gt;栈&lt;/code&gt;，因此在&lt;code&gt;.NET&lt;/code&gt;中我们可以使用&lt;code&gt;Stack&amp;lt;T&amp;gt;&lt;/code&gt;，在&lt;code&gt;Matrix&lt;/code&gt;中可以这样定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Stack&amp;lt;int[]&amp;gt; CellHistory = new Stack&amp;lt;int[]&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要撤销，必将调用&lt;code&gt;Matrix&lt;/code&gt;的某个函数，这个函数定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void TryPopHistory()
{
    if (CellHistory.TryPop(out int[] history))
    {
        foreach (var pos in MatrixPositions)
        {
            CellTable[pos.y, pos.x] = history[pos.y * MatrixSize + pos.x] switch
            {
                default(int) =&amp;gt; null,
                _ =&amp;gt; new Cell(history[pos.y * MatrixSize + pos.x]),
            };
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意这里存在一个&lt;code&gt;一维数组&lt;/code&gt;与&lt;code&gt;二维数组&lt;/code&gt;的转换，通过控制下标求值，即可轻松将&lt;code&gt;一维数组&lt;/code&gt;转换为&lt;code&gt;二维数组&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后是创建撤销的时机，必须在准备移动前，记录当前历史：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int[] history = CellTable.Cast&amp;lt;Cell&amp;gt;().Select(v =&amp;gt; v?.N ?? default).ToArray();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意这其实也是&lt;code&gt;C#&lt;/code&gt;中将&lt;code&gt;二维数组&lt;/code&gt;转换为&lt;code&gt;一维数组&lt;/code&gt;的过程，数组继承于&lt;code&gt;IEnumerable&lt;/code&gt;，调用其&lt;code&gt;Cast&amp;lt;T&amp;gt;&lt;/code&gt;方法即可转换为&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;，然后即可愉快地使用&lt;code&gt;LINQ&lt;/code&gt;和&lt;code&gt;.ToArray()&lt;/code&gt;了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在确定移动之后，将历史&lt;code&gt;入栈&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;if (moved)
{
    CellHistory.Push(history);
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后当然还需要加入事件支持，用户按下&lt;code&gt;Back&lt;/code&gt;键即可撤销：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;keyUp.Where(k =&amp;gt; k == Keys.Back).Subscribe(k =&amp;gt; Matrix.TryPopHistory());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004503298-973668354.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意，这里又有一个&lt;code&gt;bug&lt;/code&gt;，撤销时总分又没变，聪明的读者可以试试如何解决。&lt;/p&gt;
&lt;p&gt;如果使用&lt;code&gt;MVC&lt;/code&gt;和应用程序驱动的实时渲染，则这种&lt;code&gt;bug&lt;/code&gt;则&lt;strong&gt;不可能&lt;/strong&gt;发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;手势操作&quot;&gt;手势操作&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;2048&lt;/code&gt;可以在平板或手机上玩，因此手势操作必不可少，虽然电脑上有键盘，但多一个功能总比少一个功能好。&lt;/p&gt;
&lt;p&gt;不知道&lt;code&gt;C#&lt;/code&gt;窗口上有没有做&lt;code&gt;手势识别&lt;/code&gt;这块的开源项目，但借助&lt;code&gt;RX&lt;/code&gt;，这&lt;strong&gt;手撸&lt;/strong&gt;一个也不难：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static IObservable&amp;lt;Direction&amp;gt; DetectMouseGesture(Form form)
{
    var mouseDown = Observable.FromEventPattern&amp;lt;MouseEventArgs&amp;gt;(form, nameof(form.MouseDown));
    var mouseUp = Observable.FromEventPattern&amp;lt;MouseEventArgs&amp;gt;(form, nameof(form.MouseUp));
    var mouseMove = Observable.FromEventPattern&amp;lt;MouseEventArgs&amp;gt;(form, nameof(form.MouseMove));
    const int throhold = 6;
    
    return mouseDown
        .SelectMany(x =&amp;gt; mouseMove
        .TakeUntil(mouseUp)
        .Select(x =&amp;gt; new { X = x.EventArgs.X, Y = x.EventArgs.Y })
        .ToList())
        .Select(d =&amp;gt;
        {
            int x = 0, y = 0;
            for (var i = 0; i &amp;lt; d.Count - 1; ++i)
            {
                if (d[i].X &amp;lt; d[i + 1].X) ++x;
                if (d[i].Y &amp;lt; d[i + 1].Y) ++y;
                if (d[i].X &amp;gt; d[i + 1].X) --x;
                if (d[i].Y &amp;gt; d[i + 1].Y) --y;
            }
            return (x, y);
        })
        .Select(v =&amp;gt; new { Max = Math.Max(Math.Abs(v.x), Math.Abs(v.y)), Value = v})
        .Where(x =&amp;gt; x.Max &amp;gt; throhold)
        .Select(v =&amp;gt;
        {
            if (v.Value.x == v.Max) return Direction.Right;
            if (v.Value.x == -v.Max) return Direction.Left;
            if (v.Value.y == v.Max) return Direction.Down;
            if (v.Value.y == -v.Max) return Direction.Up;
            throw new ArgumentOutOfRangeException(nameof(v));
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码非常精练，但其本质是&lt;code&gt;Rx&lt;/code&gt;对&lt;code&gt;MouseDown&lt;/code&gt;、&lt;code&gt;MouseUp&lt;/code&gt;和&lt;code&gt;MouseMove&lt;/code&gt;三个窗口事件“拍案叫绝”级别的应用，它做了如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MouseDown&lt;/code&gt;触发时开始记录，直到&lt;code&gt;MouseUp&lt;/code&gt;触发为止&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;MouseMove&lt;/code&gt;的点集合起来生成一个&lt;code&gt;List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录各个方向坐标递增的次数&lt;/li&gt;
&lt;li&gt;如果次数大于指定次数（&lt;code&gt;6&lt;/code&gt;），即认可为一次事件&lt;/li&gt;
&lt;li&gt;在各个方向中，取最大的值（以减少误差）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试代码及效果如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;void Main()
{
    using var form = new Form();
    DetectMouseGesture(form).Dump();

    Application.Run(form);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004512395-633490029.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了集成到&lt;code&gt;2048&lt;/code&gt;游戏时，&lt;code&gt;Rx&lt;/code&gt;的优势又体现出来了，如果之前使用事件操作，就会出现两个入口。但使用&lt;code&gt;Rx&lt;/code&gt;后触发入口仍然可以保持统一，在之前的基础上，只需添加一行代码即可解决：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;keyUp.Select(x =&amp;gt; x switch
    {
        Keys.Left =&amp;gt; (Direction?)Direction.Left,
        Keys.Right =&amp;gt; Direction.Right,
        Keys.Down =&amp;gt; Direction.Down,
        Keys.Up =&amp;gt; Direction.Up,
        _ =&amp;gt; null
    })
    .Where(x =&amp;gt; x != null &amp;amp;&amp;amp; !Matrix.IsInAnimation())
    .Select(x =&amp;gt; x.Value)
    .Merge(DetectMouseGesture(this)) // 只需加入这一行代码
    .Subscribe(direction =&amp;gt;
    {
        Matrix.RequestDirection(direction);
        Text = $&quot;总分：{Matrix.GetScore()}&quot;;
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简直难以置信，有传言说我某个同学，使用某知名游戏引擎，做小游戏集成手势控制，搞三天三夜都没做出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;重新来回顾一下最终效果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201911/233608-20191103004313140-1363822213.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有这些代码，都可以在我的&lt;code&gt;Github&lt;/code&gt;上下载，请下载&lt;code&gt;LINQPad 6&lt;/code&gt;运行。用&lt;code&gt;Visual Studio 2019&lt;/code&gt;/&lt;code&gt;VS Code&lt;/code&gt;也能编译运行，只需手动将代码拷贝至项目中，并安装&lt;code&gt;FlysEngine.Desktop&lt;/code&gt;和&lt;code&gt;System.Reactive&lt;/code&gt;两个&lt;code&gt;NuGet&lt;/code&gt;包即可。&lt;/p&gt;
&lt;p&gt;下载地址如下：&lt;a href=&quot;https://github.com/sdcb/blog-data/tree/master/2019/20191030-2048-by-dotnet&quot; class=&quot;uri&quot;&gt;https://github.com/sdcb/blog-data/tree/master/2019/20191030-2048-by-dotnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;2048.linq&lt;/code&gt;是最终版，可以完整地看到最终效果；&lt;/li&gt;
&lt;li&gt;最初版是&lt;code&gt;2048-r4-no-cell.linq&lt;/code&gt;，可以从该文件开始进行演练；&lt;/li&gt;
&lt;li&gt;演练的顺序是&lt;code&gt;r4, r3, r2, r1&lt;/code&gt;，最后最终版，因为写这篇文章是先把所有东西做出来，然后再慢慢删除做“阉割版”的示例；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;animation-demo.linq&lt;/code&gt;、&lt;code&gt;_mouse-geature.linq&lt;/code&gt;是周边示例，用于演示动画和鼠标手势；&lt;/li&gt;
&lt;li&gt;我还做了一个&lt;code&gt;2048-old.linq&lt;/code&gt;，采用的是&lt;code&gt;一维数组&lt;/code&gt;而非&lt;code&gt;二维&lt;/code&gt;储存&lt;code&gt;Cell[,]&lt;/code&gt;，有兴趣的可以看看，有少许区别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实除了&lt;code&gt;C#&lt;/code&gt;版，我多年前还做了一个&lt;code&gt;html5/canvas&lt;/code&gt;的&lt;code&gt;js&lt;/code&gt;版本，&lt;code&gt;Github&lt;/code&gt;地址如下：&lt;a href=&quot;https://github.com/sdcb/2048&quot; class=&quot;uri&quot;&gt;https://github.com/sdcb/2048&lt;/a&gt; 其逻辑层和渲染层都有异曲同工之妙，事实也是我从&lt;code&gt;js&lt;/code&gt;版本移动到&lt;code&gt;C#&lt;/code&gt;并没花多少心思。这恰恰说明的“小游戏第一原则”——&lt;code&gt;MVC&lt;/code&gt;的重要性。&lt;/p&gt;
&lt;p&gt;……但完成这篇文章我花了&lt;strong&gt;很多、很多&lt;/strong&gt;心思😂。喜欢的朋友 请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Nov 2019 23:44:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>本文将再次使用我自制的“准游戏引擎”FlysEngine，从空白窗口开始，演示如何“手撸”2048小游戏，并在编码过程中感受`C#`的魅力和`.NET`编程的快乐。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20191030-2048-by-dotnet.html</dc:identifier>
</item>
<item>
<title>laravel6.0控制器-资源控制器 - 浮梦云烟</title>
<link>http://www.cnblogs.com/dreamofprovence/p/11784855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreamofprovence/p/11784855.html</guid>
<description>&lt;p&gt;控制器：&lt;/p&gt;
&lt;p&gt;控制器用来处理业务的，不应该处理逻辑，如果是小项目可以把逻辑写到控制器里，大点的项目应该抽离出来业务处理层如下：&lt;/p&gt;
&lt;p&gt;services业务处理层：比如：获取值，验证值，异常捕获&lt;/p&gt;

&lt;p&gt;命名规则：&lt;/p&gt;
&lt;p&gt;控制器名：用大驼峰命名 如：HelloController；&lt;/p&gt;
&lt;p&gt;方法名：用小驼峰 如:helloWorld();&lt;/p&gt;
&lt;p&gt;成员变量：小驼峰 或者 _名称&lt;/p&gt;

&lt;p&gt;创建控制器（可以自定义目录）：&lt;/p&gt;
&lt;p&gt;php artisan make:controller UserController&lt;/p&gt;
&lt;p&gt;php artisan make:controller Admin/UserController&lt;/p&gt;


&lt;p&gt;控制器简单实用实例：&lt;/p&gt;
&lt;p&gt;控制器简单使用：&lt;/p&gt;
&lt;p&gt;迁移数据库&lt;/p&gt;
&lt;p&gt;1.创建数据库 laravel6 配置数据库连接&lt;/p&gt;
&lt;p&gt;.env&lt;/p&gt;
&lt;p&gt;DB_CONNECTION=mysql&lt;/p&gt;
&lt;p&gt;DB_HOST=127.0.0.1&lt;/p&gt;
&lt;p&gt;DB_PORT=3306&lt;/p&gt;
&lt;p&gt;DB_DATABASE=laravel6&lt;/p&gt;
&lt;p&gt;DB_USERNAME=root&lt;/p&gt;
&lt;p&gt;DB_PASSWORD=12345678&lt;/p&gt;
&lt;p&gt;2.检测默认连接&lt;/p&gt;
&lt;p&gt;\config\database.php&lt;/p&gt;
&lt;p&gt;   'default' =&amp;gt; env('DB_CONNECTION', 'mysql'),&lt;/p&gt;

&lt;p&gt;3.数据库迁移命令：&lt;/p&gt;
&lt;p&gt;php artisan migrate&lt;/p&gt;
&lt;p&gt;可能会出现42000  1071错误 ，因为创建表的字段名称过长，如下解决&lt;/p&gt;
&lt;p&gt;在 \Providers\AppServiceProvider.php 中&lt;/p&gt;

&lt;p&gt;控制器简单使用：&lt;/p&gt;
&lt;p&gt;迁移数据库&lt;/p&gt;
&lt;p&gt;1.创建数据库 laravel6 配置数据库连接&lt;/p&gt;
&lt;p&gt;.env&lt;/p&gt;
&lt;p&gt;DB_CONNECTION=mysql&lt;/p&gt;
&lt;p&gt;DB_HOST=127.0.0.1&lt;/p&gt;
&lt;p&gt;DB_PORT=3306&lt;/p&gt;
&lt;p&gt;DB_DATABASE=laravel6&lt;/p&gt;
&lt;p&gt;DB_USERNAME=root&lt;/p&gt;
&lt;p&gt;DB_PASSWORD=12345678&lt;/p&gt;
&lt;p&gt;2.检测默认连接&lt;/p&gt;
&lt;p&gt;\config\database.php&lt;/p&gt;
&lt;p&gt;   'default' =&amp;gt; env('DB_CONNECTION', 'mysql'),&lt;/p&gt;

&lt;p&gt;3.数据库迁移命令：&lt;/p&gt;
&lt;p&gt;php artisan migrate&lt;/p&gt;
&lt;p&gt;可能会出现42000  1071错误 ，因为创建表的字段名称过长，如下解决&lt;/p&gt;
&lt;p&gt;在 \Providers\AppServiceProvider.php 中&lt;/p&gt;

&lt;p&gt;模型工程写入&lt;/p&gt;
&lt;p&gt;php artisan tinker&lt;/p&gt;
&lt;p&gt;Psy Shell v0.9.9 (PHP 7.3.10 — cli) by Justin Hileman&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; factory(App\User::class,5)-&amp;gt;create();&lt;/p&gt;
&lt;p&gt;User模型 写入5条数据&lt;/p&gt;
&lt;p&gt;数据库中写入了5条数据&lt;/p&gt;

&lt;p&gt;view视图展示&lt;/p&gt;
&lt;p&gt;路由：Route::get(&quot;show/{id}&quot;,&quot;UserController@show&quot;);&lt;/p&gt;
&lt;p&gt;UserController控制器如下写：&lt;/p&gt;
&lt;p&gt;public function show($id)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    return view(&quot;user.profile&quot;,[&quot;user&quot; =&amp;gt; User::findOrNew($id)]);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;传递 id 查出一数据显示&lt;/p&gt;
&lt;p&gt;创建视图 \view\user\profile.blade.php&lt;/p&gt;
&lt;p&gt;{{$user}}&lt;/p&gt;





&lt;p&gt;模型工程写入&lt;/p&gt;
&lt;p&gt;php artisan tinker&lt;/p&gt;
&lt;p&gt;Psy Shell v0.9.9 (PHP 7.3.10 — cli) by Justin Hileman&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; factory(App\User::class,5)-&amp;gt;create();&lt;/p&gt;
&lt;p&gt;User模型 写入5条数据&lt;/p&gt;
&lt;p&gt;数据库中写入了5条数据&lt;/p&gt;

&lt;p&gt;view视图展示&lt;/p&gt;
&lt;p&gt;路由：Route::get(&quot;show/{id}&quot;,&quot;UserController@show&quot;);&lt;/p&gt;
&lt;p&gt;UserController控制器如下写：&lt;/p&gt;
&lt;p&gt;public function show($id)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    return view(&quot;user.profile&quot;,[&quot;user&quot; =&amp;gt; User::findOrNew($id)]);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;传递 id 查出一数据显示&lt;/p&gt;
&lt;p&gt;创建视图 \view\user\profile.blade.php&lt;/p&gt;
&lt;p&gt;{{$user}}&lt;/p&gt;


&lt;p&gt;控制器加载原理：&lt;/p&gt;
&lt;p&gt;在服务提供者中 RouteServiceProvider.php 中，可以自定义 命名空间&lt;/p&gt;
&lt;p&gt;功能 与 业务抽离 不同的控制器目录下&lt;/p&gt;

&lt;p&gt;控制器 &amp;amp; 命名空间：&lt;/p&gt;
&lt;p&gt;需要着重指出的是，在定义控制器路由时我们不需要指定完整的控制器命名空间。因为 `RouteServiceProvider` 会在一个包含命名空间的路由组中加载路由文件，我们只需要指令类名中 `App\Http\Controllers` 命名空间之后的部分就可以了。&lt;/p&gt;

&lt;p&gt;单个行为控制器：&lt;/p&gt;
&lt;p&gt;如果你想要定义一个只处理单个行为的控制器，你可以在控制器中放置一个 `__invoke` 方法：&lt;/p&gt;
&lt;p&gt;你可以通过 Artisan 命令工具里的 `make:controller` 命令中的 `--invokable` 选项来生成一个可调用的控制器：&lt;/p&gt;
&lt;p&gt;php artisan make:controller ShowProfile --invokable&lt;/p&gt;

&lt;p&gt;控制器中间件：&lt;/p&gt;
&lt;p&gt;请求流程：&lt;/p&gt;
&lt;p&gt;用户请求 -&amp;gt; 中间件 -&amp;gt; 控制器 -&amp;gt; 控制器方法&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;class UserController extends Controller&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    public function __construct()&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        $this-&amp;gt;middleware(&quot;auth&quot;);  //如果没有登录会重定向到 login 路由中&lt;/p&gt;
&lt;p&gt;        $this-&amp;gt;middleware(&quot;log&quot;)-&amp;gt;only(&quot;test&quot;); // 只执行当前中间件中 index 之外的方法 [可以是数组] 类似于白名单&lt;/p&gt;
&lt;p&gt;        $this-&amp;gt;middleware(&quot;subscribed&quot;)-&amp;gt;except(&quot;store&quot;); //执行当前中间件中 store 之外的方法 [可以是数组] 类似于黑名单&lt;/p&gt;
&lt;p&gt;//        dd($this);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    //&lt;/p&gt;
&lt;p&gt;    public function show($id)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        return view(&quot;user.profile&quot;,[&quot;user&quot; =&amp;gt; User::findOrNew($id)]);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    // pubf + tab 快捷键生成方法&lt;/p&gt;
&lt;p&gt;    public function index()&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        echo &quot;this is index()&quot;;&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    // 白名单方法test()&lt;/p&gt;
&lt;p&gt;    public function test()&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;

&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;错误： Route [login] not defined.&lt;/p&gt;
&lt;p&gt;原因： 没有登录的时候回执行 Middleware\Authenticate.php 重定向方法&lt;/p&gt;
&lt;p&gt;    protected function redirectTo($request)&lt;/p&gt;
&lt;p&gt;    {&lt;/p&gt;
&lt;p&gt;        if (! $request-&amp;gt;expectsJson()) {&lt;/p&gt;

&lt;p&gt;            return route('login');&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;错误：需要对象式的参数 log() expects parameter 1 to be float, object given&lt;/p&gt;
&lt;p&gt;$this-&amp;gt;middleware(&quot;log&quot;)这个中间件的错误提示&lt;/p&gt;

&lt;p&gt;可以通过闭包注册中间件&lt;/p&gt;
&lt;p&gt;同时，控制器还允许你使用一个闭包来注册中间件。这为不定义整个中间件类的情况下为单个控制器定义中间件提供了一种方便的方法：&lt;/p&gt;
&lt;p&gt;$this-&amp;gt;middleware(function ($request, $next) {&lt;/p&gt;
&lt;p&gt;    return $next($request);&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;Http请求处理:&lt;/p&gt;
&lt;p&gt;用户请求 -&amp;gt; Illuminate\Http\Request请求类 -&amp;gt;&lt;/p&gt;
&lt;p&gt;laravel 中 post请求 Cookie携带有 CRSF令牌，如果想要post get方式都可以请求需要注释掉 CRSF令牌校验在 kernel.php 如下：&lt;/p&gt;
&lt;p&gt;    //  \App\Http\Middleware\VerifyCsrfToken::class,&lt;/p&gt;
&lt;p&gt;public function store(Request $request, $name=null)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    $name = $request-&amp;gt;input('name'); // 既可以获取get 也可以请求post参数&lt;/p&gt;
&lt;p&gt;    $get = $request-&amp;gt;get('name');&lt;/p&gt;
&lt;p&gt;    $post = $request-&amp;gt;post('name');&lt;/p&gt;
&lt;p&gt;    $all = $request-&amp;gt;all('name');&lt;/p&gt;
&lt;p&gt;    dd($name,$get,$post,$all);&lt;/p&gt;
&lt;p&gt;    return $name;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;一个路由中可以，既有post参数，也有get地址栏的 where参数&lt;/p&gt;
&lt;p&gt;Route::any(&quot;stores/{id}/{where?}&quot;,&quot;UserController@stores&quot;);&lt;/p&gt;

&lt;p&gt;打印：&lt;/p&gt;
&lt;p&gt;&quot;333&quot;&lt;/p&gt;
&lt;p&gt;&quot;age&quot;&lt;/p&gt;
&lt;p&gt;array:2 [&lt;/p&gt;
&lt;p&gt;  &quot;u&quot; =&amp;gt; &quot;getUser&quot;&lt;/p&gt;
&lt;p&gt;  &quot;s&quot; =&amp;gt; &quot;shengri&quot;&lt;/p&gt;
&lt;p&gt;]&lt;/p&gt;

&lt;p&gt;旧数据：&lt;/p&gt;
&lt;p&gt;Laravel 允许你在两次请求之间保持数据。这个特性在有效性校验出错后重新填充表单时非常有用。&lt;/p&gt;
&lt;p&gt;比如：保存用户名！&lt;/p&gt;
&lt;p&gt;1.1 存储到session中&lt;/p&gt;
&lt;p&gt;    //读取 session数据&lt;/p&gt;
&lt;p&gt;    $name = $request-&amp;gt;old(&quot;name&quot;);  // post 方式请求的 存储到session&lt;/p&gt;
&lt;p&gt;    $m = $request-&amp;gt;old(&quot;m&quot;);        // where get 方式请求的 存储到session&lt;/p&gt;
&lt;p&gt;    var_dump($name,$m);&lt;/p&gt;
&lt;p&gt;    //dd($name,$m);&lt;/p&gt;
&lt;p&gt;    会把 请求参数写入session文件 \storage\framework\session\.......&lt;/p&gt;

&lt;p&gt;文件：上传与下载&lt;/p&gt;
&lt;p&gt;php artisan make:controller FileController&lt;/p&gt;
&lt;p&gt;当然你也可以使用 `hasFile` 方法判断请求中是否存在指定文件：&lt;/p&gt;
&lt;p&gt;if ($request-&amp;gt;hasFile('photo')) {}&lt;/p&gt;
&lt;p&gt;验证成功上传：除了检查上传的文件是否存在外，你也可以通过 `isValid` 方法验证上传的文件是否有效：&lt;/p&gt;
&lt;p&gt;if ($request-&amp;gt;file('photo')-&amp;gt;isValid()) {}&lt;/p&gt;
&lt;p&gt;文件路径 &amp;amp; 扩展名：`UploadedFile` 类还包含访问文件的全路径和扩展名的方法。 `extension` 方法会根据文件内容判断文件的扩展名。该扩展名可能会和客户端提供的扩展名不同：&lt;/p&gt;
&lt;p&gt;$path = $request-&amp;gt;photo-&amp;gt;path();  //临时路径&lt;/p&gt;
&lt;p&gt;$extension = $request-&amp;gt;photo-&amp;gt;extension();  //后缀名&lt;/p&gt;

&lt;p&gt;存储上传文件：&lt;/p&gt;
&lt;div readability=&quot;9.3214285714286&quot;&gt;要存储上传的文件，先配置好 [文件系统](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/filesystem&quot;&gt;https://learnku.com/docs/laravel/6.0/filesystem&lt;/a&gt;)。 你可以使用 `UploadedFile` 的 `store` 方法把上传文件移动到你的某个磁盘上，该文件可能是本地文件系统中的一个位置，甚至像 Amazon S3 这样的云存储位置。&lt;/div&gt;
&lt;p&gt;`store` 方法接受相对于文件系统配置的存储文件根目录的路径。这个路径不能包含文件名，因为系统会自动生成唯一的 ID 作为文件名。&lt;/p&gt;
&lt;p&gt;`store` 方法还接受可选的第二个参数，用于存储文件的磁盘名称。这个方法会返回相对于磁盘根目录的文件路径：&lt;/p&gt;
&lt;p&gt;$path = $request-&amp;gt;photo-&amp;gt;store('images');  // 上传的文件默认保存在 storage\app\images\xxxxxx&lt;/p&gt;
&lt;p&gt;$path = $request-&amp;gt;photo-&amp;gt;store('images', 's3');&lt;/p&gt;
&lt;p&gt;如果你不想自动生成文件名，那么可以使用 `storeAs` 方法，它接受路径、文件名和磁盘名作为其参数：&lt;/p&gt;
&lt;p&gt;$path = $request-&amp;gt;photo-&amp;gt;storeAs('images', 'filename.jpg');&lt;/p&gt;
&lt;p&gt;$path = $request-&amp;gt;photo-&amp;gt;storeAs('images', 'filename.jpg', 's3');&lt;/p&gt;

&lt;p&gt;响应：&lt;/p&gt;
&lt;p&gt;字符串，数组，视图，&lt;/p&gt;
&lt;p&gt;响应信息可以自定义，针对不同的响应结果，返回对应的响应状态&lt;/p&gt;
&lt;p&gt;string 类型响应 text/html; charset=UTF-8&lt;/p&gt;
&lt;p&gt;arr    响应类型 application/json&lt;/p&gt;
&lt;p&gt;3.4.2  Response 对象：&lt;/p&gt;
&lt;div readability=&quot;6.4372093023256&quot;&gt;通常，我们并不只是从路由动作简单返回字符串和数组，大多数情况下，都会返回一个完整的`Illuminate\Http\Response` 实例或 [视图](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/views&quot;&gt;https://learnku.com/docs/laravel/6.0/views&lt;/a&gt;)。&lt;/div&gt;

&lt;p&gt;返回完整的 `Response` 实例允许你自定义响应的 HTTP 状态码和响应头信息。 `Response` 实例 继承自 `Symfony\Component\HttpFoundation\Response` 类， 该类提供了各种构建 HTTP 响应的方法：&lt;/p&gt;

&lt;p&gt;Route::get('home', function () {&lt;/p&gt;
&lt;p&gt;    return response('Hello World', 200)&lt;/p&gt;
&lt;p&gt;                  -&amp;gt;header('Content-Type', 'text/plain');&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;添加响应头：&lt;/p&gt;
&lt;p&gt;大部分的响应方法都是可链式调用的，使得创建响应实例的过程更具可读性。例如，你可以在响应返回给用户前使用 `header` 方法为其添加一系列的头信息：&lt;/p&gt;
&lt;p&gt;return response($content)&lt;/p&gt;
&lt;p&gt;            -&amp;gt;header('Content-Type', $type)&lt;/p&gt;
&lt;p&gt;            -&amp;gt;header('X-Header-One', 'Header Value')&lt;/p&gt;
&lt;p&gt;            -&amp;gt;header('X-Header-Two', 'Header Value');&lt;/p&gt;
&lt;p&gt;或者，你可以使用 `withHeaders` 方法来指定要添加到响应的头信息数组：&lt;/p&gt;
&lt;p&gt;return response($content)&lt;/p&gt;
&lt;p&gt;            -&amp;gt;withHeaders([&lt;/p&gt;
&lt;p&gt;                'Content-Type' =&amp;gt; $type,&lt;/p&gt;
&lt;p&gt;                'X-Header-One' =&amp;gt; 'Header Value',&lt;/p&gt;
&lt;p&gt;                'X-Header-Two' =&amp;gt; 'Header Value',&lt;/p&gt;
&lt;p&gt;            ]);&lt;/p&gt;

&lt;p&gt;重定向：&lt;/p&gt;
&lt;p&gt;重定向响应是 `Illuminate\Http\RedirectResponse` 类的实例，并且包含用户需要重定向至另一个 URL 所需的头信息。Laravel 提供了几种方法用于生成 `RedirectResponse` 实例。其中最简单的方法是使用全局辅助函数 `redirect`：&lt;/p&gt;
&lt;p&gt;Route::get(&quot;home&quot;,function (){&lt;/p&gt;
&lt;p&gt;    return redirect(&quot;string&quot;); // 重定向到指定路由&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;Route::get(&quot;home&quot;,function (){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;Route::get(&quot;cdx&quot;,function (){&lt;/p&gt;
&lt;p&gt;    return redirect()-&amp;gt;away('arr');  // 重定向到指定路由&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;

&lt;div readability=&quot;9.6091954022989&quot;&gt;有时候你可能希望将用户重定向到之前的位置，比如提交的表单无效时。这时你可以使用全局辅助函数 `back` 来执行此操作。由于这个功能利用了 [会话控制](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/session&quot;&gt;https://learnku.com/docs/laravel/6.0/session&lt;/a&gt;)，请确保调用 `back` 函数的路由使用 `web` 中间件组或所有 Session 中间件：&lt;/div&gt;
&lt;p&gt;Route::post('user/profile', function () {&lt;/p&gt;
&lt;p&gt;    // 验证请求&lt;/p&gt;
&lt;p&gt;    return back()-&amp;gt;withInput();&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;重定向到命名路由：&lt;/p&gt;
&lt;p&gt;如果调用不带参数的辅助函数 `redirect` 时，会返回 `Illuminate\Routing\Redirector` 实例。这个实例允许你调用 `Redirector` 上的任何方法。例如为命名路由生成 `RedirectResponse`，可以使用 `route` 方法：&lt;/p&gt;
&lt;p&gt;return redirect()-&amp;gt;route('login');&lt;/p&gt;
&lt;p&gt;如果路由中有参数，可以将其作为第二个参数传递到 `route` 方法：&lt;/p&gt;
&lt;p&gt;return redirect()-&amp;gt;route('profile', ['id' =&amp;gt; 1]);&lt;/p&gt;

&lt;p&gt;重定向到控制器行为：&lt;/p&gt;
&lt;div readability=&quot;9.4695652173913&quot;&gt;还可以生成到 [controller action](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/controllers&quot;&gt;https://learnku.com/docs/laravel/6.0/controllers&lt;/a&gt;) 的重定向。要达到这个目的，只要把 控制器 和 action 的名称传递给 `action` 方法。记住，不需要传递控制器的全部命名空间，Laravel 的 `RouteServiceProvider` 会自动将其设置为基本控制器的命名空间：&lt;/div&gt;
&lt;p&gt;return redirect()-&amp;gt;action('HomeController@index');&lt;/p&gt;
&lt;p&gt;如果控制器路由需要参数，可以将其作为 `action` 方法的第二个参数：&lt;/p&gt;
&lt;p&gt;return redirect()-&amp;gt;action(&lt;/p&gt;
&lt;p&gt;    'UserController@profile', ['id' =&amp;gt; 1]&lt;/p&gt;
&lt;p&gt;);&lt;/p&gt;
&lt;p&gt;重定向到外部域名：&lt;/p&gt;
&lt;p&gt;有时候你需要重定向到应用外的域名。调用 `away` 方法可以达到此目的，它会创建一个不带有任何额外的 URL 编码、有效性校验和检查的 `RedirectResponse` 实例：&lt;/p&gt;

&lt;p&gt;其他的响应类型：&lt;/p&gt;
&lt;div readability=&quot;8.4563758389262&quot;&gt;`response` 助手可以用于生成其它类型的响应实例。当还带参数调用 `response` 助手时，返回 `Illuminate\Contracts\Routing\ResponseFactory` [contract](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/contracts&quot;&gt;https://learnku.com/docs/laravel/6.0/contracts&lt;/a&gt;) 的一个实现。这个契约提供了几个用于生成响应的方法：&lt;/div&gt;
&lt;p&gt;视图响应：&lt;/p&gt;
&lt;div readability=&quot;9.401384083045&quot;&gt;如果需要把 [视图](&lt;a href=&quot;https://learnku.com/docs/laravel/6.0/views&quot;&gt;https://learnku.com/docs/laravel/6.0/views&lt;/a&gt;) 作为响应内容返回的同时，控制响应状态和头信息，就需要调用 `view` 方法，如果不需要传递自定义的 HTTP 状态码和自定义头信息，还可以使用全局的 `view` 辅助函数。&lt;/div&gt;
&lt;p&gt;return response()&lt;/p&gt;
&lt;p&gt;            -&amp;gt;view('hello', $data, 200)&lt;/p&gt;
&lt;p&gt;            -&amp;gt;header('Content-Type', $type);&lt;/p&gt;
&lt;p&gt;JSON响应：&lt;/p&gt;
&lt;p&gt;`json` 自动将 `Content-Type` 头信息设置为 `application/json`，同时使用 PHP 的 `json_encode` 函数将给定的数组转换为 JSON ：&lt;/p&gt;
&lt;p&gt;return response()-&amp;gt;json([&lt;/p&gt;
&lt;p&gt;    'name' =&amp;gt; 'Abigail',&lt;/p&gt;
&lt;p&gt;    'state' =&amp;gt; 'CA'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;
&lt;p&gt;如果想要创建 JSONP 响应，可以结合 `withCallback` 方法使用 `json` 方法：&lt;/p&gt;
&lt;p&gt;return response()&lt;/p&gt;
&lt;p&gt;            -&amp;gt;json(['name' =&amp;gt; 'Abigail', 'state' =&amp;gt; 'CA'])&lt;/p&gt;
&lt;p&gt;            -&amp;gt;withCallback($request-&amp;gt;input('callback'));&lt;/p&gt;

&lt;p&gt;文件下载：&lt;/p&gt;
&lt;p&gt;1.设置http响应头&lt;/p&gt;
&lt;p&gt;2.下载文件的名称，大小&lt;/p&gt;
&lt;p&gt;return response()-&amp;gt;download($pathToFile);&lt;/p&gt;
&lt;p&gt;return response()-&amp;gt;download($pathToFile, $name, $headers);&lt;/p&gt;
&lt;p&gt;return response()-&amp;gt;download($pathToFile)-&amp;gt;deleteFileAfterSend();&lt;/p&gt;

&lt;p&gt;RESTful 风格：定义：&lt;/p&gt;
&lt;p&gt;REST 是 “呈现状态转移（REpresentational State Transfer）” 的缩写。或许可以这样来定义它：一种 API 的架构风格，在客户端和服务端之间通过呈现状态的转移来驱动应用状态的演进。&lt;/p&gt;

&lt;p&gt;约束：&lt;/p&gt;
&lt;p&gt;要让应用 RESTful 化，需要遵循以下约束。遵循了这些约束的分布式系统，就会拥有如下非功能属性：性能，伸缩性，易用性，扩展性，可见性，可移植性和可靠性。&lt;/p&gt;

&lt;p&gt;CS 模式：&lt;/p&gt;
&lt;p&gt;CS 模式通过分离客户端和服务器端的关注点，让客户端不再关注数据的存储问题，从而提高客户端代码的可移植性。另一方面，服务器端不再关注用户界面和用户状态，从而变得更简单，提高了伸缩性。服务器端跟客户端可以独立开发，只要它们都遵守契约。&lt;/p&gt;

&lt;p&gt;无状态：&lt;/p&gt;
&lt;p&gt;客户端上下文在多个请求之间是绝不会保存在服务器上的。每个请求必须包含必要的信息。无状态的服务器通过快速释放资源和简化实现提高了可伸缩性。可靠性使得从局部失败中恢复变得容易。很明显，监控系统不必通过考虑单个请求来判断请求的性质。 无状态服务器的一个缺点是降低了网络性能，因为所有需要的数据必须在每次请求中发送。&lt;/p&gt;

&lt;p&gt;可缓存：&lt;/p&gt;
&lt;p&gt;REST 应用程序是 web 系统，因此客户端和中间层可以缓存响应。响应必须被定义为可缓存或不可缓存的，以防客户端重复使用旧数据导致降低可靠性。如果缓存中的陈旧数据与已生成的请求的数据显著不同，则由服务器处理请求。缓存可以消除一些客户端和服务器之间的交互，这就提升了可伸缩性、效率和通过减少平均延迟达到的用户可感知的性能。&lt;/p&gt;

&lt;p&gt;统一的接口：&lt;/p&gt;
&lt;p&gt;使用统一的接口降低了系统复杂度和耦合度，让系统的不同部分可以独立演化。稍后会解释 URI，资源和超媒体是如何通过生成标准接口来提升用户交互可见性，降低系统复杂度，促进系统组件独立演化的。但是我们需要在效率方面做出妥协，毕竟消息是通过标准格式传输的，并不能满足所有应用对消息格式的要求。&lt;/p&gt;

&lt;p&gt;分层的系统：&lt;/p&gt;
&lt;p&gt;分层系统通过约束组件的行为来降低系统复杂度，组件不能越过它们的媒介层去访问其它层。通过组件的阻断来保持层间的独立性。遗留的组件可以被封装成新的层，不让旧的客户端访问。媒介层可以通过负载均衡来提升伸缩性。分层系统存在的主要不足，是它给数据处理增加了一些额外的开销，增加了延迟，对用户体验有所影响。&lt;/p&gt;

&lt;p&gt;按需编码：&lt;/p&gt;

&lt;p&gt;REST 允许客户端通过下载执行脚本来扩展它们的功能，简化了客户端，也提升了扩展性。但这同时也降低了可见性，所以这个约束不是必须遵循的。&lt;/p&gt;

&lt;p&gt;元素：&lt;/p&gt;
&lt;p&gt;REST 提供了以下几种元素来构建无状态，可伸缩的 web API。&lt;/p&gt;

&lt;p&gt;HTTP协议：&lt;/p&gt;
&lt;p&gt;资源&lt;/p&gt;
&lt;p&gt;URI&lt;/p&gt;
&lt;p&gt;超媒体&lt;/p&gt;
&lt;p&gt;HTTP - 文本传输协议&lt;/p&gt;

&lt;p&gt;REST 一般使用 HTTP 作为它的传输协议，因为 HTTP 提供了一些很好用的特性，如 HTTP 动词，状态码和头部信息&lt;/p&gt;

&lt;p&gt;HTTP 动词：&lt;/p&gt;
&lt;p&gt;HTTP 并没有定义很多动词来描述 web 服务中可能出现的行为，它只用了一个标准动词集合来处理各种相似情况，从而让 API 变得更直观。每个动词通过两种属性的组合来满足不同的场景需求。&lt;/p&gt;

&lt;p&gt;幂等性：操作可以被重复执行，就算在失败以后。&lt;/p&gt;
&lt;p&gt;安全性：对客户端来说操作不会产生副作用。&lt;/p&gt;

&lt;p&gt;GET:&lt;/p&gt;
&lt;p&gt;用来从服务器端读取状态。这个操作是安全的，所以它可以被执行很多次而不会对数据有任何影响，也就是说执行它一次跟执行十次是一样的效果。从幂等性方面来看，多次请求跟单个请求总能得到相同的结果。&lt;/p&gt;

&lt;p&gt;POST:&lt;/p&gt;
&lt;p&gt;一般用来在服务器端创建某种状态。这个操作不具备幂等性跟安全性，所以多次请求会在服务器端创建多个资源。因为 POST 是不幂等的， 所以不应该被用来做跟金钱有关系的操作，试想一次失败的请求如果被执行多次，那么很可能转账或者支付也被执行了多次。&lt;/p&gt;

&lt;p&gt;PUT:&lt;/p&gt;
&lt;p&gt;虽然它也可以被用来创建状态，但主要还是用来在服务器端更新状态的。它是幂等的，但不安全，因为它会改变服务端的状态。因为它的幂等性，PUT 可以被用来处理跟金钱有关系的操作。&lt;/p&gt;

&lt;p&gt;DELETE:&lt;/p&gt;
&lt;p&gt;用来在服务器端删除状态。它也是幂等非安全的，因为它会移除服务端的状态。它之所以是幂等的，是因为重复删除一个状态的结果是一样。&lt;/p&gt;

&lt;p&gt;响应状态码：&lt;/p&gt;
&lt;p&gt;HTTP 在请求资源的响应里提供了元数据信息，也就是状态码。它们是 web 平台之所以能用来构建分布式系统的重要因素。它们被分为以下几类：&lt;/p&gt;
&lt;p&gt;- 1xx —— 元数据&lt;/p&gt;
&lt;p&gt;- 2xx —— 正确的响应&lt;/p&gt;
&lt;p&gt;- 3xx —— 重定向&lt;/p&gt;
&lt;p&gt;- 4xx —— 客户端错误&lt;/p&gt;
&lt;p&gt;- 5xx —— 服务端错误&lt;/p&gt;

&lt;p&gt;头部信息：&lt;/p&gt;
&lt;p&gt;HTTP 在消息头部里为请求响应提供了额外信息。每个头部由大小写敏感的关键字和值组成，中间用冒号隔开。头部信息被分为以下几类：&lt;/p&gt;
&lt;p&gt;一般头部：在请求跟响应里都有，跟消息体里传输的数据没有关系。&lt;/p&gt;
&lt;p&gt;请求头部：更多的是关于被请求资源或者客户端的信息。&lt;/p&gt;
&lt;p&gt;响应头部：响应的额外信息。&lt;/p&gt;
&lt;p&gt;实体头部：消息体的额外信息，比如 content-length 或 MIMI-type。&lt;/p&gt;

&lt;p&gt;资源：&lt;/p&gt;
&lt;p&gt;资源可以是由系统暴露出来的任何具有唯一标识的东西。资源在应用领域跟客户端之间建立起了联系。一张图片，一个表格，或者它们的集合，都被看作资源。资源通过某种呈现方式被获取或被创建 (XML,JSON 等)。 我们与之打交道的是资源的呈现形式，并不是资源本身，这个跟值传递有点像。根据之前对 REST 的定义，资源代表了在网络上传输的文档。服务器端关心资源的状态，因为它们代表了领域的状态。而客户端只是获取或者发送资源的呈现状态，从而让应用的状态发生变化。客户单关心的是应用的状态，因为这些状态的变化跟应用所要达成的目标有关系。 资源的名字都应该是名词性质的，它们代表的是系统中领域的概念，并用 URI 标识。&lt;/p&gt;

&lt;p&gt;URIs  (Uniform Resource Identifiers)&lt;/p&gt;
&lt;p&gt;URIs 用来唯一标识资源。要访问或者操作一个资源，最起码要知道资源的地址。它们由协议 + 服务器地址 + 路径组成。&lt;/p&gt;
&lt;p&gt;客户端不应该与资源的 URI 有太多耦合，因为服务端可能随意改变它们的值。在这一点上，超媒体更具优势。它提供了一种解耦客户端跟 URI 的方式，并在应用协议中加入新的语义。&lt;/p&gt;

&lt;p&gt;资源控制器：&lt;/p&gt;
&lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;Laravel 的资源路由将典型的「CURD (增删改查)」路由分配给具有单行代码的控制器。例如，你希望创建一个控制器来处理保存 &quot;照片&quot; 应用的所有 HTTP 请求。使用 Artisan 命令 `make:controller` ，我们可以快速创建这样一个控制器：&lt;/p&gt;
&lt;p&gt;php artisan make:controller PhotoController --resource&lt;/p&gt;
&lt;p&gt;这个命令将会生成一个控制器 `app/Http/Controllers/PhotoController.php` 。其中包括每个可用资源操作的方法。&lt;/p&gt;

&lt;p&gt;接下来，你可以给控制器注册一个资源路由：&lt;/p&gt;
&lt;p&gt;Route::resource('photos', 'PhotoController');&lt;/p&gt;

&lt;p&gt;这个单一的路由声明创建了多个路由来处理资源上的各种行为。生成的控制器为每个行为保留了方法，包括了关于处理 HTTP 动词和 URLs 的声明注释。&lt;/p&gt;

&lt;p&gt;你可以通过将数组传参到 `resource` 方法中的方式来一次性的创建多个资源控制器：&lt;/p&gt;
&lt;p&gt;Route::resources([&lt;/p&gt;
&lt;p&gt;    'photos' =&amp;gt; 'PhotoController',&lt;/p&gt;
&lt;p&gt;    'posts' =&amp;gt; 'PostController'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;

&lt;p&gt;资源控制器操作处理：&lt;/p&gt;

&lt;p&gt;| HTTP 方法 | URI                    | 动作    | 路由名称       |&lt;/p&gt;
&lt;p&gt;| --------- | ---------------------- | ------- | -------------- |&lt;/p&gt;
&lt;p&gt;| GET       | `/photos`              | index   | photos.index   |&lt;/p&gt;
&lt;p&gt;| GET       | `/photos/create`       | create  | photos.create  |&lt;/p&gt;
&lt;p&gt;| POST      | `/photos`              | store   | photos.store   |&lt;/p&gt;
&lt;p&gt;| GET       | `/photos/{photo}`      | show    | photos.show    |&lt;/p&gt;
&lt;p&gt;| GET       | `/photos/{photo}/edit` | edit    | photos.edit    |&lt;/p&gt;
&lt;p&gt;| PUT/PATCH | `/photos/{photo}`      | update  | photos.update  |&lt;/p&gt;
&lt;p&gt;| DELETE    | `/photos/{photo}`      | destroy | photos.destroy |&lt;/p&gt;

&lt;p&gt;制定资源模型：&lt;/p&gt;
&lt;p&gt;如果你使用了路由模型绑定，并且想在资源控制器的方法中使用类型提示，你可以在生成控制器的时候使用 `--model`选项：&lt;/p&gt;
&lt;p&gt;php artisan make:controller PhotoController --resource --model=Photo&lt;/p&gt;


&lt;p&gt;部分资源路由：&lt;/p&gt;
&lt;p&gt;Route::resource('photos', 'PhotoController')-&amp;gt;only([&lt;/p&gt;
&lt;p&gt;    'index', 'show'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;
&lt;p&gt;Route::resource('photos', 'PhotoController')-&amp;gt;except([&lt;/p&gt;
&lt;p&gt;    'create', 'store', 'update', 'destroy'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;

&lt;p&gt;API 资源路由：&lt;/p&gt;
&lt;p&gt;当声明用于 APIs 的资源路由时，通常需要排除显示 HTML 模板的路由（如 `create` 和 `edit` ）。为了方便起见，你可以使用 apiResource 方法自动排除这两个路由：&lt;/p&gt;

&lt;p&gt;Route::apiResource('photos', 'PhotoController');&lt;/p&gt;

&lt;p&gt;你可以传递一个数组给 `apiResources` 方法来同时注册多个 API 资源控制器：&lt;/p&gt;
&lt;p&gt;Route::apiResources([&lt;/p&gt;
&lt;p&gt;    'photos' =&amp;gt; 'PhotoController',&lt;/p&gt;
&lt;p&gt;    'posts' =&amp;gt; 'PostController'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;

&lt;p&gt;要快速生成不包含 `create` 或 `edit` 方法的用于开发接口的资源控制器，请在执行 `make:controller` 命令时使用 `--api` 开关:&lt;/p&gt;
&lt;p&gt;php artisan make:controller API/PhotoController --api&lt;/p&gt;

&lt;p&gt;命名资源路由：&lt;/p&gt;
&lt;p&gt;默认情况下，所有的资源控制器行为都有一个路由名称。你可以传入 names 数组来覆盖这些名称：&lt;/p&gt;
&lt;p&gt;Route::resource('photos', 'PhotoController')-&amp;gt;names([&lt;/p&gt;
&lt;p&gt;    'create' =&amp;gt; 'photos.build'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;
&lt;p&gt;命名资源路由参数：&lt;/p&gt;

&lt;p&gt;默认情况下，`Route::resource` 会根据资源名称的「单数」形式创建资源路由的路由参数。你可以在选项数组中传入 `parameters` 参数来轻松地覆盖每个资源。`parameters` 数组应该是资源名称和参数名称的关联数组&lt;/p&gt;
&lt;p&gt;Route::resource('users', 'AdminUserController')-&amp;gt;parameters([&lt;/p&gt;
&lt;p&gt;    'users' =&amp;gt; 'admin_user'&lt;/p&gt;
&lt;p&gt;]);&lt;/p&gt;

&lt;p&gt;上例将会为资源的 `show` 路由生成如下的 URI ：&lt;/p&gt;
&lt;p&gt;/users/{admin_user}&lt;/p&gt;

&lt;p&gt;php artisan make:controller Api/ResController --resource&lt;/p&gt;
&lt;p&gt;php artisan route:list&lt;/p&gt;




</description>
<pubDate>Sat, 02 Nov 2019 15:56:00 +0000</pubDate>
<dc:creator>浮梦云烟</dc:creator>
<og:description>控制器： 控制器用来处理业务的，不应该处理逻辑，如果是小项目可以把逻辑写到控制器里，大点的项目应该抽离出来业务处理层如下： services业务处理层：比如：获取值，验证值，异常捕获 命名规则： 控制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dreamofprovence/p/11784855.html</dc:identifier>
</item>
<item>
<title>unity 之 自定义弹出框 - 无名之士</title>
<link>http://www.cnblogs.com/unknown6248/p/11784813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/unknown6248/p/11784813.html</guid>
<description>&lt;h5&gt;&lt;span&gt;一、弹出&lt;strong&gt;框的搭建：&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;布局如图：&lt;/span&gt;Message&lt;span&gt;为整个父物体，并且添加&lt;/span&gt;&lt;span&gt;UiMessage&lt;/span&gt;&lt;span&gt;代码。&lt;/span&gt;&lt;span&gt;panel&lt;/span&gt;&lt;span&gt;为遮罩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MessageBox&lt;span&gt;为整个提示框，&lt;/span&gt;&lt;span&gt;Panel&lt;/span&gt;&lt;span&gt;为标题，&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;为确定按钮，&lt;/span&gt;&lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;为取消按钮，&lt;/span&gt;&lt;span&gt;retry&lt;/span&gt;&lt;span&gt;为重试按钮，&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;为提示框的文字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意大小写，后面代码会根据名称进行获取对应组建。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1660904/201911/1660904-20191102222241621-1398058046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 效果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1660904/201911/1660904-20191102222253979-304030568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1660904/201911/1660904-20191102222259665-135313743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;二、&lt;strong&gt;MessageBox&lt;span&gt;代码：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 要说明的都在代码中注释了。&lt;span&gt;仿照Windows的提示框功能，如果功能不足可自行添加。例如关闭按钮、显示图标等。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; DialogResult
{
    Ok,
    OKCancel,
    RetryCancel,
    YesNo,
    YesNoCancel
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MessageBox
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; true表示模态框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; type;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三个委托，分别为三个按钮的点击运行事件&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Action clickOk;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Action clickRetry;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Action clickCancel;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DialogResult dialogResult;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; headText;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; text;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态。用于显示或隐藏弹出框&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; state;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;重试按钮点击事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClickRetry()
    {
        state &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        clickRetry&lt;/span&gt;?&lt;span&gt;.Invoke();
        clickRetry &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取消按钮点击事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClickCancel()
    {
        state &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        clickCancel&lt;/span&gt;?&lt;span&gt;.Invoke();
        clickCancel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 确定按钮点击事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClickOk()
    {
        state &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        clickOk&lt;/span&gt;?&lt;span&gt;.Invoke();
        clickOk &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;_text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;_head&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dialog&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;样式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;模式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show(&lt;span&gt;string&lt;/span&gt; _text,&lt;span&gt;string&lt;/span&gt; _head,DialogResult _dialog, &lt;span&gt;bool&lt;/span&gt; _type = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        text &lt;/span&gt;=&lt;span&gt; _text;
        headText &lt;/span&gt;=&lt;span&gt; _head;
        dialogResult &lt;/span&gt;=&lt;span&gt; _dialog;
        type &lt;/span&gt;=&lt;span&gt; _type;
        state &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show(&lt;span&gt;string&lt;/span&gt; _text,&lt;span&gt;string&lt;/span&gt; _head,&lt;span&gt;bool&lt;/span&gt; _type = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        text &lt;/span&gt;=&lt;span&gt; _text;
        headText &lt;/span&gt;=&lt;span&gt; _head;
        dialogResult &lt;/span&gt;=&lt;span&gt; DialogResult.Ok;
        type &lt;/span&gt;=&lt;span&gt; _type;
        state &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Show(&lt;span&gt;string&lt;/span&gt; _text, &lt;span&gt;bool&lt;/span&gt; _type = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        text &lt;/span&gt;=&lt;span&gt; _text;
        headText &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        dialogResult &lt;/span&gt;=&lt;span&gt; DialogResult.Ok;
        type &lt;/span&gt;=&lt;span&gt; _type;
        state &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;&lt;span&gt;三、&lt;strong&gt;UiMessage&lt;span&gt;代码：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 添加到Message物体上。用于控制弹出框的显示等功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.UI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UiMessage : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Button ok;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Button cancel;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Button retry;
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 遮罩
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GameObject panel;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text headText;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text text;
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; GameObject messageBox;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Awake()
    {
        messageBox &lt;/span&gt;= gameObject.transform.GetChild(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;).gameObject;
        ok &lt;/span&gt;= messageBox.transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
        cancel &lt;/span&gt;= messageBox.transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
        retry &lt;/span&gt;= messageBox.transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
        panel &lt;/span&gt;= gameObject.transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).gameObject;
        text &lt;/span&gt;= messageBox.transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;&lt;span&gt;();
        headText &lt;/span&gt;= messageBox.transform.GetChild(&lt;span&gt;0&lt;/span&gt;).Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将提示框居中显示&lt;/span&gt;
        messageBox.transform.position = &lt;span&gt;new&lt;/span&gt; Vector3(Screen.width / &lt;span&gt;2&lt;/span&gt; - messageBox.GetComponent&amp;lt;RectTransform&amp;gt;().rect.width / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                Screen.height &lt;/span&gt;/ &lt;span&gt;2&lt;/span&gt; + messageBox.GetComponent&amp;lt;RectTransform&amp;gt;().rect.height / &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        init();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEnable()
    {
        init();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init()
    {
        ok.onClick.AddListener(MessageBox.onClickOk);
        cancel.onClick.AddListener(MessageBox.onClickCancel);
        retry.onClick.AddListener(MessageBox.onClickRetry);
        text.text &lt;/span&gt;=&lt;span&gt; MessageBox.text;
        headText.text &lt;/span&gt;=&lt;span&gt; MessageBox.headText;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传递的参数，进行样式的显示&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (MessageBox.dialogResult)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DialogResult.Ok:
                ok.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                cancel.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                retry.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DialogResult.OKCancel:
                ok.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                cancel.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                retry.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DialogResult.RetryCancel:
                ok.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                cancel.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                retry.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DialogResult.YesNo:
                ok.transform.GetChild(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;().text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                cancel.transform.GetChild(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;().text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;否&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ok.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                cancel.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                retry.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DialogResult.YesNoCancel:
                ok.transform.GetChild(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;().text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                cancel.transform.GetChild(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;().text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;否&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ok.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                cancel.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                retry.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
    {
        panel.SetActive(MessageBox.type);
        gameObject.SetActive(MessageBox.state);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;&lt;span&gt;三、显示框的调用&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;此处调用可以自行设置一个按钮，在其点击事件中注册调用即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;笔者使用项目中的方式进行演示。具体不做说明。调用方式已给出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特别注意：由于UiMessage调用了MessageBox的方法，所以必须先初始化MessageBox的数据。使用什么就初始化什么。笔者使用了ok、cancel按钮（默认不初始化模式，即为模态框，不初始化DialogResult即为只显示ok按钮），所以注册了相应的点击事件（委托）。最后显示弹出框（整个包含遮罩和弹出框）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1660904/201911/1660904-20191102224052402-1644395004.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h5&gt;&lt;span&gt;三、运行结果&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1660904/201911/1660904-20191102224944834-1658785926.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h5&gt;&lt;span&gt;三、弹出框可拖拽移动&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;将DragManage添加到MessageBox物体上面。&lt;span&gt;（如果你想让ui物体可拖拽，对其添加DragManage即可实现）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;笔者就不做演示了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.EventSystems;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 只是用来处理拖拽
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DragManage : MonoBehaviour, IDragHandler, IBeginDragHandler, IEndDragHandler
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Vector3 offect;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnBeginDrag(PointerEventData eventData)
    {
        offect &lt;/span&gt;= Input.mousePosition -&lt;span&gt; transform.position;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnDrag(PointerEventData eventData)
    {
        transform.position &lt;/span&gt;= Input.mousePosition -&lt;span&gt; offect;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEndDrag(PointerEventData eventData)
    {
        transform.position &lt;/span&gt;= Input.mousePosition -&lt;span&gt; offect;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sat, 02 Nov 2019 15:43:00 +0000</pubDate>
<dc:creator>无名之士</dc:creator>
<og:description>一、弹出框的搭建： 布局如图：Message为整个父物体，并且添加UiMessage代码。panel为遮罩。 MessageBox为整个提示框，Panel为标题，ok为确定按钮，cancel为取消按钮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/unknown6248/p/11784813.html</dc:identifier>
</item>
<item>
<title>snaic和tornado的简单性能测试 - Mike_Zhang</title>
<link>http://www.cnblogs.com/MikeZhang/p/snaic_vs_tornado_20191102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MikeZhang/p/snaic_vs_tornado_20191102.html</guid>
<description>&lt;p&gt;操作系统 ： CentOS7.3.1611_x64&lt;/p&gt;
&lt;p&gt;Python 版本 : 3.6.8&lt;/p&gt;
&lt;p&gt;tornado版本：6.0.2&lt;/p&gt;
&lt;p&gt;snaic版本：19.9.0&lt;/p&gt;
&lt;p&gt;CPU ： Intel(R) Core(TM) i5-2320 CPU @ 3.00GHz 4核&lt;/p&gt;
&lt;p&gt;之前一直使用tornado作为http相关python程序的框架，最近查资料发现新出的snaic性能很高，这里在同样硬件条件下使用ab进行简单的压测。&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;p&gt;安装apache ab工具：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; httpd-tools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;压测命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ab -c &lt;span&gt;30&lt;/span&gt; -n &lt;span&gt;100000&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:9093/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;-c ：模拟并发数&lt;/p&gt;
&lt;p&gt;-n : 总请求数&lt;/p&gt;
&lt;h2&gt;对比测试&lt;/h2&gt;
&lt;p&gt;使用tornado实现的简单http服务器代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mike-zhang/pyExamples/blob/master/httpRelate/httpServer/tornadoTest1.py&quot;&gt;https://github.com/mike-zhang/pyExamples/blob/master/httpRelate/httpServer/tornadoTest1.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用snaic实现的简单http服务器代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mike-zhang/pyExamples/blob/master/httpRelate/httpServer/snaicTest1.py&quot;&gt;https://github.com/mike-zhang/pyExamples/blob/master/httpRelate/httpServer/snaicTest1.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tornado测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Server Software:        TornadoServer/&lt;span&gt;6.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Server Hostname:        &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Server Port:            &lt;/span&gt;&lt;span&gt;9093&lt;/span&gt;&lt;span&gt;

Document Path:          &lt;/span&gt;/&lt;span&gt;
Document Length:        &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt; bytes

Concurrency Level:      &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
Time taken &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tests:   &lt;span&gt;82.282&lt;/span&gt;&lt;span&gt; seconds
Complete requests:      &lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;
Failed requests:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Write errors:           &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Total transferred:      &lt;/span&gt;&lt;span&gt;20700000&lt;/span&gt;&lt;span&gt; bytes
HTML transferred:       &lt;/span&gt;&lt;span&gt;1200000&lt;/span&gt;&lt;span&gt; bytes
Requests per second:    &lt;/span&gt;&lt;span&gt;1215.33&lt;/span&gt; [#/&lt;span&gt;sec] (mean)
Time per request:       &lt;/span&gt;&lt;span&gt;24.685&lt;/span&gt;&lt;span&gt; [ms] (mean)
Time per request:       &lt;/span&gt;&lt;span&gt;0.823&lt;/span&gt;&lt;span&gt; [ms] (mean, across all concurrent requests)
Transfer rate:          &lt;/span&gt;&lt;span&gt;245.68&lt;/span&gt; [Kbytes/&lt;span&gt;sec] received

Connection Times (ms)
                          min  mean[&lt;/span&gt;+/-&lt;span&gt;sd] median   max
Connect:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;0.2&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;       &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
Processing:     &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;25&lt;/span&gt;  &lt;span&gt;10.3&lt;/span&gt;     &lt;span&gt;25&lt;/span&gt;      &lt;span&gt;74&lt;/span&gt;&lt;span&gt;
Waiting:        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt;  &lt;span&gt;10.3&lt;/span&gt;     &lt;span&gt;25&lt;/span&gt;      &lt;span&gt;74&lt;/span&gt;&lt;span&gt;
Total:          &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;25&lt;/span&gt;  &lt;span&gt;10.3&lt;/span&gt;     &lt;span&gt;25&lt;/span&gt;      &lt;span&gt;74&lt;/span&gt;&lt;span&gt;

Percentage of the requests served within a certain &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt; (ms)
  &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;%     &lt;span&gt;25&lt;/span&gt;
  &lt;span&gt;66&lt;/span&gt;%     &lt;span&gt;30&lt;/span&gt;
  &lt;span&gt;75&lt;/span&gt;%     &lt;span&gt;33&lt;/span&gt;
  &lt;span&gt;80&lt;/span&gt;%     &lt;span&gt;34&lt;/span&gt;
  &lt;span&gt;90&lt;/span&gt;%     &lt;span&gt;37&lt;/span&gt;
  &lt;span&gt;95&lt;/span&gt;%     &lt;span&gt;39&lt;/span&gt;
  &lt;span&gt;98&lt;/span&gt;%     &lt;span&gt;41&lt;/span&gt;
  &lt;span&gt;99&lt;/span&gt;%     &lt;span&gt;42&lt;/span&gt;
 &lt;span&gt;100&lt;/span&gt;%     &lt;span&gt;74&lt;/span&gt; (longest request)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;snaic测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Server Software:
Server Hostname:        &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Server Port:            &lt;/span&gt;&lt;span&gt;9093&lt;/span&gt;&lt;span&gt;

Document Path:          &lt;/span&gt;/&lt;span&gt;
Document Length:        &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt; bytes

Concurrency Level:      &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
Time taken &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tests:   &lt;span&gt;20.164&lt;/span&gt;&lt;span&gt; seconds
Complete requests:      &lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;
Failed requests:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Write errors:           &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
Total transferred:      &lt;/span&gt;&lt;span&gt;11100000&lt;/span&gt;&lt;span&gt; bytes
HTML transferred:       &lt;/span&gt;&lt;span&gt;1200000&lt;/span&gt;&lt;span&gt; bytes
Requests per second:    &lt;/span&gt;&lt;span&gt;4959.29&lt;/span&gt; [#/&lt;span&gt;sec] (mean)
Time per request:       &lt;/span&gt;&lt;span&gt;6.049&lt;/span&gt;&lt;span&gt; [ms] (mean)
Time per request:       &lt;/span&gt;&lt;span&gt;0.202&lt;/span&gt;&lt;span&gt; [ms] (mean, across all concurrent requests)
Transfer rate:          &lt;/span&gt;&lt;span&gt;537.58&lt;/span&gt; [Kbytes/&lt;span&gt;sec] received

Connection Times (ms)
                          min  mean[&lt;/span&gt;+/-&lt;span&gt;sd] median   max
Connect:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt;   &lt;span&gt;0.5&lt;/span&gt;      &lt;span&gt;2&lt;/span&gt;      &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
Processing:     &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt;   &lt;span&gt;1.5&lt;/span&gt;      &lt;span&gt;4&lt;/span&gt;      &lt;span&gt;38&lt;/span&gt;&lt;span&gt;
Waiting:        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt;   &lt;span&gt;1.4&lt;/span&gt;      &lt;span&gt;3&lt;/span&gt;      &lt;span&gt;37&lt;/span&gt;&lt;span&gt;
Total:          &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;6&lt;/span&gt;   &lt;span&gt;1.5&lt;/span&gt;      &lt;span&gt;6&lt;/span&gt;      &lt;span&gt;41&lt;/span&gt;&lt;span&gt;

Percentage of the requests served within a certain &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt; (ms)
  &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;%      &lt;span&gt;6&lt;/span&gt;
  &lt;span&gt;66&lt;/span&gt;%      &lt;span&gt;6&lt;/span&gt;
  &lt;span&gt;75&lt;/span&gt;%      &lt;span&gt;7&lt;/span&gt;
  &lt;span&gt;80&lt;/span&gt;%      &lt;span&gt;7&lt;/span&gt;
  &lt;span&gt;90&lt;/span&gt;%      &lt;span&gt;7&lt;/span&gt;
  &lt;span&gt;95&lt;/span&gt;%      &lt;span&gt;8&lt;/span&gt;
  &lt;span&gt;98&lt;/span&gt;%      &lt;span&gt;9&lt;/span&gt;
  &lt;span&gt;99&lt;/span&gt;%     &lt;span&gt;10&lt;/span&gt;
 &lt;span&gt;100&lt;/span&gt;%     &lt;span&gt;41&lt;/span&gt; (longest request)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从测试结果可以看到，开启两个进程情况下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tornado的cps是 1215.33 ，平均响应时间是 24.685 ms&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;snaic的cps是 4959.29 ，平均响应时间是 6.049 ms&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;修改并发数后的测试数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/300959/201911/300959-20191102232800395-1719540080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 测试结果对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/300959/201911/300959-20191102232903154-1068334143.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/300959/201911/300959-20191102233250536-849385589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从测试数据来看，snaic的cps比tornado高，平均响应时间方面，snaic也比tornado短。&lt;/p&gt;
&lt;p&gt;本文github地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mike-zhang/mikeBlogEssays/blob/master/2019/20191102_snaic%E5%92%8Ctornado%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.rst&quot; target=&quot;_blank&quot;&gt;https://github.com/mike-zhang/mikeBlogEssays/blob/master/2019&lt;span class=&quot;separator&quot;&gt;/20191102_snaic和tornado的简单性能测试.rst&lt;span class=&quot;final-path&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎补充&lt;/p&gt;
</description>
<pubDate>Sat, 02 Nov 2019 15:35:00 +0000</pubDate>
<dc:creator>Mike_Zhang</dc:creator>
<og:description>操作系统 ： CentOS7.3.1611_x64 Python 版本 : 3.6.8 tornado版本：6.0.2 snaic版本：19.9.0 CPU ： Intel(R) Core(TM) i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MikeZhang/p/snaic_vs_tornado_20191102.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExecutor源码中的适配器模式 - kingsleylam</title>
<link>http://www.cnblogs.com/kingsleylam/p/11784777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingsleylam/p/11784777.html</guid>
<description>&lt;h3 id=&quot;什么是适配器模式&quot;&gt;什么是适配器模式&lt;/h3&gt;
&lt;p&gt;网上已有很多的教程，不细讲了。可以参考：&lt;a href=&quot;https://www.cnblogs.com/kubidemanong/p/9609856.html&quot;&gt;五分钟了解设计模式(3)---适配器模式&lt;/a&gt;&lt;br/&gt;在适配器模式中，一定要识别清楚，Target Adaptee Adapter分别是哪些类或接口，这样才能知道是谁转成谁。&lt;br/&gt;Target: 最终给上下文调用的类&lt;br/&gt;Adaptee: 被适配的类，即需要转成Target&lt;br/&gt;Adapter: 将Target和Adaptee连接起来，起转换作用&lt;/p&gt;
&lt;h3 id=&quot;threadpoolexecutor中submit方法用到的适配器模式&quot;&gt;ThreadPoolExecutor中submit方法用到的适配器模式&lt;/h3&gt;
&lt;p&gt;ThreadPoolExecutor类提供了submit方法，共有3个重载。这三个方法最终调用到的是execute(Runnable r) 方法，返回一个Future类型的对象（具体为FutureTask类型），相比直接调用execute(Runnable r)方法，调用方可以获得任务执行的结果。三个submit方法， 都使用了适配器模式，才能将顺利调用execute(Runnable r)方法。&lt;br/&gt;  &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先看看public Future submit(Callable task)&lt;br/&gt;在这个方法中，Target是Runnable（因为execute方法的参数是Runnable类型），Adaptee是Callable。JDK使用了FutureTask类作为Adapter. FutureTask类的继承关系如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201911/452847-20191102233022073-615872829.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现了Runnable，可以传参给execute方法；实现了Future，可以返回给调用方。&lt;br/&gt;FutureTask作为Adapter，采用的是“类适配器方式”，持有一个Callable（即Adaptee）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201911/452847-20191102233057458-643659476.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;再看看public Future submit(Runnable task, T result)&lt;br/&gt;同样是包装成FutureTask类型，那么只要将Runnable转成FutureTask就可以了。上面说到FutureTask也是实现了Runnable，那为什么还要转换呢？因为FutureTask还实现了Future接口，功能上比Runnable更强大，同时要返回给调用方，提供运行结果。&lt;br/&gt;当前我们有一个Runnable和表示结果的参数，需要适配成FutureTask。前面我们已经知道，FutureTask起到Adapter的作用，它持有一个Callable成员变量。如果没有上面的分析，那么FutureTask可以改为持有Runnable，但现在它已经是持有Callable成员变量了，所以，还要再做一次适配，将Runnable适配成Callable.&lt;br/&gt;在这个例子中，Target是Callable，Adaptee是Runnable，Adapter是RunnableAdapter。&lt;br/&gt;RunnableAdapter使用“类适配器方式”&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201911/452847-20191102233104642-1380170878.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后一个public Future&amp;lt;?&amp;gt; submit(Runnable task)&lt;br/&gt;与上一个方法类似，只不过是运行结果为null.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;在ThreadPoolExecutor的三个submit方法中，都使用了适配器模式，都使用了其中的“类适配器方式”。&lt;br/&gt;submit方法都返回FutureTask，该类型可以得到运行结果。&lt;br/&gt;submit方法都调用了execute(Runnable r)方法执行任务，传入的具体类型为FutureTask。因此，Target是Runnable，Adapter是FutureTask，Adaptee则是不同的传入参数。&lt;br/&gt;FutureTask的实现方式是持有一个Callable类型的成员变量，因此，对于传入参数为Callable的情况，直接赋值，对于传入参数为Runnable的情况，需要再做一次适配，将Runnable适配成Callable. 在这个转换过程中，Target是Callable，Adaptee是Runnable，Adapter是Adapter是RunnableAdapter。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Nov 2019 15:33:00 +0000</pubDate>
<dc:creator>kingsleylam</dc:creator>
<og:description>什么是适配器模式 网上已有很多的教程，不细讲了。可以参考：[五分钟了解设计模式(3) 适配器模式]( https://www.cnblogs.com/kubidemanong/p/9609856.ht</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kingsleylam/p/11784777.html</dc:identifier>
</item>
<item>
<title>面试：让你设计一个第三方账号登陆你该如何实现？ - HG-93</title>
<link>http://www.cnblogs.com/cxydmx/p/11784713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxydmx/p/11784713.html</guid>
<description>&lt;p&gt;这里的多账户区别于系统级别的，我们讲的多账户系统是指，在我们互联网应用当中，我们的应用会使用多个第三方账号进行登录，必须现在常用的APP（网易云音乐）登录方式包含：网易、微信、QQ&lt;/p&gt;

&lt;p&gt;通过这一篇文章， 可以学到：多用户下面的技术方案细节，以及相应的表设计，流程设计。 不可以：与其他文章一样，我这里不会有具体代码实现细节，方案做的对，代码咋写都不会太烂。&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb3009405b73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;700&quot; data-height=&quot;1060&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb3009405b73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;/&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;创业初期&lt;/h2&gt;
&lt;p&gt;归结为创业初期是因为这个时候用户量比较少，甚至还没有接入上面所说的其他第三方的账户系统，只是自建的体系就可以满足，自建体系的话，目前常用的有&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;用户名密码注册登陆&lt;/h3&gt;
&lt;p&gt;这种方式在很多初期网站建设会使用，先注册，再进行登录，在老一点的cms中都能找到这个影子。&lt;/p&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb346d2dfe19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;1280&quot; data-height=&quot;660&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb346d2dfe19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;/&gt;&lt;p&gt;流程说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;前端将用户名、密码发送到服务器，服务器进行常规的判断，判断用户名、密码长度是否满足，用户名是否重复等条件，条件不通过直接返回对应错误码给到前端，这里密码字段，为了防止传输过程中被截胡，建议加密再上传，我们的传输密码默认都是会进行一个md5加密，然后记录到数据库再进行一层加密，就算是脱库也没事，密码不要明文存储。&lt;/li&gt;
&lt;li&gt;校验通过后，就将用户名密码写入数据库，并进行后面积分发放等操作，这里不展开。&lt;/li&gt;
&lt;li&gt;现在进行登录，前端将用户名，密码发送给到服务端，服务端首先会校验登录次数是否超过设置的阈值，如果超过只能继续等待被关小黑屋。&lt;/li&gt;
&lt;li&gt;如果未超过继续登录逻辑，判断用户名、密码是否正确，不正确密码则进行阈值的判断，如果超过则关小黑屋，记住小黑屋必须设置过期时间，要不然就会永久关上了，这个可以用redis的过期来做。&lt;/li&gt;
&lt;li&gt;登录成功后进行后续的一切后置逻辑，比如加积分。。。等操作。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;手机号注册登陆&lt;/h3&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb36d7bacb06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;660&quot; data-height=&quot;606&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/6/19/16b6fb36d7bacb06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;/&gt; 流程说明：
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先输入手机号，然后发送到服务端，服务端将手机号记录在我们数据库中，然后生成随机验证码，并将手机号和验证码绑定到一个redis里面，然后记录过期时间，这个过期时间一般是10分钟左右，这就是我们一般手机验证码的有效期。&lt;/li&gt;
&lt;li&gt;手机接收到手机短信后，那么就在界面填写验证码发送服务端，服务端收到验证码后就会在redis里面查询到这个手机号对应的验证码，失败就返回错误码。&lt;/li&gt;
&lt;li&gt;成功后就进行登录操作。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这里看起来没有明确的注册登录操作，其实在发送手机号码就可以认为是一个常规的注册，然后后面的验证码输入就是一个登陆操作，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问：&lt;/strong&gt; 那我要密码咋办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt; 在后续产品里面增加一个手机号码密码补录的功能即可，这也是现在很常规的手法，但是现在移动互联网大爆炸时代，密码已经显得不是那么重要了，反正我从来记不住密码，如果手机号码能操作的app，绝对不用密码来操作。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;数据库设计&lt;/h3&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;表结构&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;自增id&lt;/th&gt;
&lt;th&gt;用户名&lt;/th&gt;
&lt;th&gt;密码&lt;/th&gt;
&lt;th&gt;手机号&lt;/th&gt;
&lt;th&gt;错误次数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;user1&lt;/td&gt;
&lt;td&gt;7fef6171469e80d32c0559f88b377245&lt;/td&gt;
&lt;td&gt;13456789012&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;user2&lt;/td&gt;
&lt;td&gt;7fef6171469e80d32c0559f88b377245&lt;/td&gt;
&lt;td&gt;13456789013&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;说明&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里只是单纯说明需要用到的数据，没有扩展具体场景,这个表结构能够满足上面两个方案的设计。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;引入第三方账户方案&lt;/h2&gt;
&lt;p&gt;这里是以QQ-SDK的登录逻辑， 我们先来一波时序图&lt;/p&gt;
&lt;img class=&quot;lazyload inited loaded&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/6/20/16b7299a7015addb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;837&quot; data-height=&quot;735&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/6/20/16b7299a7015addb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;/&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;客户端自己调起登录的界面，进行输入用户名、密码，这里的是第三方的用户名，密码，登录成功后，会返回access_token openid expire_in,这过程会使用到oauth2.0，不过在sdk里面进行内置回调获取了，后面我们会说明我们自身实现的oauth2.0&lt;/li&gt;
&lt;li&gt;客户端拿到access_token、openid、login_type（qq、wechat...）请求应用服务器，应用服务器拿到这些数据后就会根据对应的login_type去对应的用户中心进行access_token和openid进行校验。校验不通过则返回对应错误码&lt;/li&gt;
&lt;li&gt;校验通过后就会判断本地是否有这个login_type和openid是否存在，不存在则进行获取远程的用户名、头像等基础信息来作为本地基础数据，并且返回code值&lt;/li&gt;
&lt;li&gt;如果已经存在，那就是进行登录操作，返回code值。&lt;/li&gt;
&lt;li&gt;客户端拿到code值后进行token值的换取，这个完全遵照oauth2.0的协议来走的，后续每次请求必须带上token，token值在服务端的时间比较久，因为我们想要做的是那种永不下线的操作，所以每次请求我们都将token过期时间进行累加。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;数据库设计&lt;/h3&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-11&quot;&gt;表结构&lt;/h4&gt;
&lt;p&gt;对于评论处 @讲不出再见1486617502000 的建议，我这里做一下数据库的整理 用户基础表（users）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;user_id&lt;/td&gt;
&lt;td&gt;用户id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;token&lt;/td&gt;
&lt;td&gt;用户登陆的token&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;expire_in&lt;/td&gt;
&lt;td&gt;token过期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;try_times&lt;/td&gt;
&lt;td&gt;登录失败次数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;用户验证关联表（user_auth_rel）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;自增id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;user_id&lt;/td&gt;
&lt;td&gt;用户id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;auth_id&lt;/td&gt;
&lt;td&gt;验证表id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;auth_type&lt;/td&gt;
&lt;td&gt;验证类型(local、third)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;本地用户表（user_local_auth）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;auth_id&lt;/td&gt;
&lt;td&gt;认证id，自增id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;user_name&lt;/td&gt;
&lt;td&gt;用户唯一标识&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;用户密码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mobile&lt;/td&gt;
&lt;td&gt;用户手机&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第三方用户表（user_third_auth）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;auth_id&lt;/td&gt;
&lt;td&gt;用户id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;openid&lt;/td&gt;
&lt;td&gt;第三方用户唯一标识&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;login_type&lt;/td&gt;
&lt;td&gt;第三方平台标识(qq、wechat...)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;access_token&lt;/td&gt;
&lt;td&gt;第三方获取的access_token,校验使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;users表只是单纯针对我们业务侧的登录，主要是做自身业务的oauth2.0业务，&lt;/li&gt;
&lt;li&gt;user_local_auth是做自己用户名、密码登录，手机号码登录信息记录，&lt;/li&gt;
&lt;li&gt;user_third_auth是我们第三方用户体系的数据记录，&lt;/li&gt;
&lt;li&gt;user_auth_rel是用来关联我们users表与user_local_auth、user_third_auth。&lt;/li&gt;
&lt;li&gt;整个设计理念就是将自建用户与第三方在存储上区分，这在架构演进上也是合乎情理的，开始用户体系大多自建，而后才是对外接入。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;ol&gt;&lt;li&gt;总的来讲，第三方用户的接入技术上来讲是比较简单的，这里设计多一个user_thirds是可以支持足够多的第三方接入，当然一般我们也就两三个登录就好，太多登录方不仅自身维护成本，界面摆盘也不好看不是。&lt;/li&gt;
&lt;li&gt;希望大家能够通过以上学习，能够对于我们多账户登录有一个比较好的认知，这里设计方案不包含分表分库、没有服务化，就是简单直接的设计，当然用户量和需要的不一样，在这个基础上还要加很多东西，谢谢大家阅读！！!&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 02 Nov 2019 15:13:00 +0000</pubDate>
<dc:creator>HG-93</dc:creator>
<og:description>名称解释 这里的多账户区别于系统级别的，我们讲的多账户系统是指，在我们互联网应用当中，我们的应用会使用多个第三方账号进行登录，必须现在常用的APP（网易云音乐）登录方式包含：网易、微信、QQ 内容 通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxydmx/p/11784713.html</dc:identifier>
</item>
<item>
<title>Sping MVC不使用任何注解处理（jQuery）Ajax请求（基于XML配置） - 我想和你拍照片</title>
<link>http://www.cnblogs.com/1314520wly/p/11783149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1314520wly/p/11783149.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. Spring&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;Spring框架是一个轻量级的解决方案，是一个潜在的一站式商店，用于构建企业就绪的应用程序。&lt;/span&gt;&lt;span&gt;Spring框架是一个Java平台，为开发Java应用程序提供全面的基础架构支持。Spring处理基础结构，因此您可以专注于应用程序。Spring使您能够从“普通的Java对象”（POJO）构建应用程序，并将企业服务非侵入性地应用于POJO。此功能适用于Java SE编程模型以及全部和部分Java EE&lt;/span&gt;&lt;span&gt;。但是，Spring是模块化的，允许您仅使用所需的那些部分，而不必引入其余部分。您可以将IoC容器与顶部的任何Web框架一起使用，但也可以仅使用 Hibernate集成代码或JDBC抽象层。Spring框架支持声明式事务管理，通过RMI或Web服务对逻辑的远程访问以及用于持久化数据的各种选项。它提供了功能全面的MVC框架，并使您能够将AOP透明地集成到软件中。&lt;/span&gt;&lt;span&gt;Spring被设计为非侵入式的，这意味着您的域逻辑代码通常不依赖于框架本身。在您的集成层（例如数据访问层）中，将存在对数据访问技术和Spring库的某些依赖关系。但是，将这些依赖项与其余代码库隔离起来应该很容易。Spring的两大核心特征：IoC（控制反转），AOP（面向切面编程）。IoC作用：把对象的控制权交给容器管理。AOP作用：面向切面编程（比如日志打印），底层使用动态代理实现。&lt;span&gt;Spring框架包含组织为约20个模块的功能。&lt;/span&gt;&lt;span&gt;这些模块分为核心容器，数据访问/集成，Web，AOP（面向方面​​的编程），检测，消息传递和测试。Spring的整个完整框 架来说，其设计原则则是&quot;对扩展开放，对修改闭合&quot;（OOP设计原则）。当然Spring还有很多强大的功能，这里先简单介绍一下，点到为止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. Spring MVC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;span&gt;Spring MVC是基于Servlet API构建的原始web框架，从一开始就已经包含在就包含在Spring框架中，与Spring框架无缝对接。全称应该为Spring Web MVC，其来源于模块spring-webmvc。但是，通常我们叫它Spring MVC（习惯）。Spring MVC框架是围绕一个 DispatcherServlet （核心控制器）来设计的，这个 Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区 与主题渲染等，甚至还能支持文件上传。&quot;对扩展开放&quot;是Spring Web MVC框架一个重要的设计原则。Spring Web MVC核心类库中的一些方法被定义为 final 方法。Sp'ring MVC的数据绑定非常灵活方便，视图解析也设计的非常灵活与方便，并且提供了好多功能强大的注解机制。当然，Spring MVC的强大之处不是一两句话可以搞定的，我们应该参考其文档，并且深入学习钻研，最好研究研究源码。这里话不多说，点到为止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. Spring MVC处理（jQuery）Ajax请求(前台不发送数据，后台返回普通字符串)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;开发环境：Eclipse+Tomcat+Spring MVC+Jackson+JSP+jQuery+Ajax&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;本篇博客比较长，原本是一个小的demo，写这么长不值，不，我认为值，因为我感觉自己写的还可以（哈哈！装一波），这些都是笔者一字一句写的，当然有参考一些东西（本人最讨厌复制粘贴），加上自己的理解，涉及到代码完全认真实践过，自己从头到尾写一遍，也是对自己知识的积累以及经验的提升，Spring MVC文档和Spring文档等，请大家认真看下去，看完这篇，你不仅掌握了Ajax，认识了Spring的好处，还会熟知Spring MVC的执行流程，还会接触到有趣的日志打印。当然也可以免费获取jar包（有源码链接），百度都有（基本都免费）。所以普通的一些jar包都是免费的，没有必要花一些代价去活得开发包。本质来说，框架只是个模板，我们遵从框架的规范来开发就行了，毕竟使用一些框架是我们的开发变得简单高效，笔者认为还是应该了解一下底层核心的原理比较好，这样便于在我们开发的时候遇到bug的时候可以迅速做出决策和解决。写博客，我是认真的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）搭建环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;span&gt; Eclipse中新建Java Web项目，并把项目部署到Tomcat容器中。下面是项目的结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102101332073-355464701.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102101353765-991502068.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目基本结构很简单，没啥可说的。这里说一下lib里面的jar包。既然我们想使用Spring MVC进行开发，必须导入其开发包。上面说了，Spring MVC其实是集成在Spring中的，所以也是导入Spring开发包。本次使用spring-framework-4.0.0.RELEASE开发包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring开发包：spring-aop面向切面编程所用到的包。spring-aspects提供对AspectJ（面向切面的一个框架）的支持，spring-beans包含访问配置文件，创建和管理Bean以及进行控制反转和依赖注入操作相关的所有类。spring-core是Spring的核心包（核心工具类）。&lt;/span&gt;&lt;span&gt;spring-expression是Spring的表达式语言，spring-jdbc它包含了spring 与 JDBC 数据访问时进行封装的所有类，提供使用springjdbc的最佳实现&lt;/span&gt;&lt;span&gt;（利用jdbc template）。spring-orm是Spring对DAO特性进行扩展，支持一些ORM（对象关系映射）框架（比如MyBatis和Hibernate等）。spring-test提供了对Junit等测试框架的简单封装，这让我们在对Spring的代码进行测试时更加方便和快捷。spring-tx包为JDBC、Hibernate、JDO、JPA等提供了一致的声明式的编程式事物管理。spring-web包含web应用研发时用到Spring框架时所需要的的核心类。spring-webmvc包含了Spring webmvc框架相关的所有类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;log4j日志信息包。不导这个包的话会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Jasckson三个包（前几篇博客说过好多遍）。这里导入Jackson包的原因说一下。1. Spring MVC内置的json与对象转换器依赖于Jackson类库。（底层通过对Jackson的一些方法进行封装实现）。2. 简单好用我感觉，效率也还可以。当然也可以实现自己的json与对象的转换器（题外话）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;com.springsource三个jar包，主要是为了提供Spring对Apache的一些服务的支持。Tomcat就是Apache的，不导这3个包的话会报错。当然，这里只是导入了spring的一部分常用的包，还有其他的（自己百度下spring开发包，在里面找找），本次开发也没把这些spring包全部用到，主要是为了着重介绍一下。好了，jar包说完了。下面进行开发。这里不使用任何注解的目的说一下，只是基于XML配置实现。其实我们使用注解会简单方便很多（后面会有更新的），此篇文章主要是为了便于大家熟悉Spring MVC的执行流程，并使用它最最原始的一些配置以及方法。方便大家了解更深层次的东西，以及深入了解Spring MVC&lt;/span&gt;&lt;span&gt;一些核心的东西。因为我们天天使用注解，但是估计我们都没了解过注解的机制以及原理，注解有什么用。以及注解代替了那些我们之前开发比较繁杂的操作以及方法。有时候我们研究一些东西，不能只停留在表面会使用就行了，我们深入到底层的话会有意想不到的收获及理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）编写jsp文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; import&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java.util.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;%&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt;&lt;span&gt; path &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getContextPath();
    &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; basePath &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getScheme() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; request.getServerName() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; request.getServerPort()
            &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; path &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;base &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&amp;lt;%=basePath%&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;I LOVE YOU&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;jquery-3.2.1.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mybutton1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;springmvc处理ajax请求&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;fun1()&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;（jquery）ajax请求（不发送数据）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spand &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很简单，定义了一个按钮。并调用js文件相关的函数进行处理，&amp;lt;span&amp;gt;标签是为了显示内容。页面引入自定义的js文件和jQeury的js文件（注意名称和路径）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）编写js文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用jquery提交ajax请求（不携带数据）&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fun1(){
    
    $.ajax({
        
        type:&lt;/span&gt;&quot;POST&quot;,                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送方式&lt;/span&gt;
        url:&quot;UserController1&quot;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求地址&lt;/span&gt;
        data:&quot;&quot;,                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据为空&lt;/span&gt;
        success:&lt;span&gt;function&lt;/span&gt;(data){             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功后的回调函数&lt;/span&gt;
&lt;span&gt;            
            $(&lt;/span&gt;&quot;#show1&quot;).html(data);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面展示内容&lt;/span&gt;
&lt;span&gt;            
        }            
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很简单，就写了一个fun1()函数。用来响应按钮。虽然说，讨论客户端不发送数据没多大意义，这里我们还是讨论一下吧。在学习java基础的时候，我们还经常讨论&quot;空&quot;呢。不是吗？这里主要是为了熟悉一下代码执行的流程，毕竟我们学习的过程是由浅入深的。闲话少叙。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）编写controller类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.controller;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.HttpRequestHandler;

public class UserController1 implements HttpRequestHandler{


    @Override
    public &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        response.setCharacterEncoding(&quot;UTF-8&quot;&lt;span&gt;);    
        String str &lt;/span&gt;= &quot;我是一个 springmvc&quot;&lt;span&gt;;        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            response.getWriter().print(str);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }    
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里定义了一个controller类，并且实现了HttpRequestHandler接口，并实现接口中的抽象方法。方法中定义了一个字符串，利用response获取打印流进行输出即可。Spring MVC中。一般在我们编写controller(也就是一个handler，用来处理客户端的请求)，要能被Sping MVC识别它是一个controller类，因为这里没有用到注解。所以我们有2种方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：&lt;strong&gt;编写controller类，实现org.springframework.web.servlet.mvc.Controller接口，然后交给核心控制器调用相对应的处理器适配器进行处理。&lt;/strong&gt;不过，实现了Controller，就必须实现其中的抽象方法public abstract ModelAndView handleRequest(HttpServletRequest request， HttpServletResponse response)。这个方法必须返回一个ModelAndView对象，而我们所作的是对字符串数据和json数据的处理。所以在这里我们并没有选择实现Controller接口。&lt;br/&gt;第二种：&lt;strong&gt;编写controller类，实现org.springframework.web.HttpRequestHandler接口，然后交给核心控制器调用相应的处理器适配器进行处理&lt;/strong&gt;，并实现其中的抽象方法。自己可以百度一下Spring MVC的执行流程，这里不多说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public abstract void handleRequest(HttpServletRequest request, HttpServletResponse response) 我们注意到，这个方法是没有返回值的，所以就方便了我们对字符串数据和json数据的处理。注意到有2个参数request和response(这是Servlet的东西)。Spring MVC支持的支持的参数类型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HttpServletRequest 对象，HttpServletResponse 对象，HttpSession 对象，Model/ModelMap 对象。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这里我们用到了其中的2个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）配置web.xml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;WebApp_ID&quot;&lt;/span&gt;&lt;span&gt; version&lt;/span&gt;&lt;span&gt;=&quot;3.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;display-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MySpringMVCAjax&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;display-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  
  
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置springmvc核心控制器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springmvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:springmvc.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
        
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springmvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对静态资源进行放行 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/static/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*.js&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*.css&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  
  
  
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置编码过滤器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringCharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
       
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;forceEncoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;         
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringCharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里我们配置了三个东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个，&lt;strong&gt;配置Spring核心控制器&lt;/strong&gt;。Sping MVC核心控制器（前端控制器或中央处理器）org.springframework.web.servlet.DispatcherServlet，DispatcherServlet 其实就是个 Servlet （它继承自 HttpServlet 基类），同样也需要在你 web应用的 web.xml 配置文件下声明。你需要在 web.xml 文件中把你希望 DispatcherServlet 处理的请求映射到对应的URL上去。这就是标准的Java EE Servlet配 置。DispatcherServlet就是一个Sping MVC处理请求的一个中央处理器，负责调度处理器映射器，处理器适配器以及视图解析器。配置初始化参数来加载Sping MVC的主配置文件springmvc.xml，这里我们把它放在src目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个，&lt;strong&gt;给静态资源放行&lt;/strong&gt;。这里注意一下。我们在核心控制器&amp;lt;url-pattern&amp;gt;标签下配置的是 / ，表示所有访问的url都交给核心控制器去处理，这样导致有可能加载不到静态资源文件（js,css,img）。解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：在springmvc.xml文件中配置&lt;/span&gt;&lt;span&gt;&amp;lt;mvc:default-servlet-handler /&amp;gt;&amp;lt;!-- 表示对所有静态资源进行放行 --&amp;gt;（比较高级的方法）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第二种：对静态资源进行放行，如我们web.xml所示。当然，也可以在spring.xml文件进行放行，语法为：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&amp;gt;
&amp;lt;resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&amp;gt;
&amp;lt;resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这里使用web.xml对静态资源进行放行，主要是因为这个方法简单易懂。后面我会对博客内容进行更新升级，再采取比较高级的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种：配置核心控制器时，把&amp;lt;url-pattern&amp;gt;标签设置为 *.do 或者 .action就好了。表示以.do结尾的或者以.action结尾的URL都由前端控制器DispatcherServlet来解析。这种方法也可以，但是到时访问路径的时候要加上这个后缀，看起来不太舒服（有一点强迫症的人应该懂）。当然笔者估计没有吧。笔者只是采取一些简单说不上高效的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个，就是&lt;strong&gt;配置spring提供编码过滤器&lt;/strong&gt;。web.xml配置的编码过滤器为了防止前端传入的中文数据出现乱码问题，使用Spring提供的编码过滤器来统一编码。配置为UTF-8。当然也可以使用GBK等其他编码。GBK编码方式的编码是以中国国情而创造的，在国际上的兼容性不好，这也是为什么大多数的网页是使用UTF-8编码而不是GBK。UTF-8好处：兼容ASCII，存储英文文件都是单字节，文件小。在eclipse中把项目的编码也设置为UTF-8，JSP页面中字符编码也设置为UTF-8。浏览器网页字符编码也设置为UTF-8。反正就是统统UTF-8的样子。做这么多主要是统一编码，解决中文乱码乱码问题。因为以前使用servlet和struts2的时候，经常出现中文乱码问题，让人摸不着什么头脑。所以。Spring提供的这个编码过滤器就比较方便好用了。所以说Spring是一个神奇的东西。我们研读一下Spring源码，看看Spring开发的文档，就可以汲取一些精华（精髓）。Spring提供的编码过滤器，org.springframework.web.filter.CharacterEncodingFilter类，注意把路径写正确。初始化参数（也就是编码）encoding为UTF-8。Spring里的字符过滤器CharacterEncodingFilter是针对请求的，forceEncoding=true是意思是指无论客户端请求是否包含了编码，都用过滤器里的编码来解析请求。forceEncoding默认为false。forceEncoding为true效果： request.setCharacterEncoding(&quot;UTF-8&quot;)；forceEncoding为false的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; request.setCharacterEncoding(&quot;UTF-8&quot;)； response.setCharacterEncoding(&quot;UTF-8&quot;)。 &amp;lt;url-pattern&amp;gt;标签配置的/*代表过滤所有请求，从而将编码设置为UTF-8。好了。web.xml到此结束。其实有时候我们只是开发一个简单的小例子demo，看起来很简单。但是我们要了解底层到底是怎么实现的。比如Java的底层，JVM(Java虚拟机)用c/c++编写，Java类库用Java语言编写。还有比如native本地方法，其底层本质也是c/c++编写的，Java只是调用了它的接口。这也就解释了为什么native方法效率一般比较高。那么问题来了，c语言用什么编写的 ? 这个可以自行谷歌或百度，这里不多说。当然，一个项目或者工作的执行流程我们也必须熟知。这次开发看起来很简单，但是我们把涉及到的知识内容都会为大家详细讲解，并且都是本人一字一句经过推敲实践进行编写的。当然，本人也是菜鸟一枚。知识有限。但是我们可以经过学习来获取更多的知识，提升自己的能力，从而达到人生的巅峰。不多说了（跑题了，哈哈！）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（6）配置springmvc.xml文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans   
      &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;  
      xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;  
      xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;  
      xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;  
      xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;  
      http://www.springframework.org/schema/beans 
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/mvc 
      http://www.springframework.org/schema/mvc/spring-mvc.xsd  
      http://www.springframework.org/schema/context 
      http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
    
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置user实体类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.pojo.User&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置handler&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;/UserController1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.controller.UserController1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;/UserController2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.controller.UserController2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;/UserController3&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.controller.UserController3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;  
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置处理器映射器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置处理器适配器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
         
     
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置json与对象的转换器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
     
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myconverter&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
              
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置视图解析器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
     
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;springmvc.xml是本次开发的主配置文件。通过观察得知，顶层标签&amp;lt;beans&amp;gt;包含了许多bean模块。Spring Bean其实就是是被实例的，组装的及被Spring 容器管理的Java对象。一个bean相当于一个实体类对象，通过IoC（控制反转，也叫依赖注入）我们可以把bean注入到容器当中，交给Spring容器管理（比如bean的实例化）。这样做的目的其实解耦合。因为软件设计的原则就是高内聚，低耦合。Spring默认的bean实例是单例的，我们可以用scope属性来设置bean的作用域。scope可以接受Singleton（单例模式，每次获取bean只有一个实例）、prototype（原型模式，每次获取bean都会产生新的实例）、request(每次HTTP request请求都会产生不同的Bean实例)、session(每次HTTP session请求都会产生不同的Bean实例)、global session (每个全局的HTTPSession对应一个Bean实例。仅在portlet Context的时候才有效。)5个值。我们常用单例模式，因为创建对象本身代价比较高，耗费资源，单例的本身也满足我们的需求了。当然我们也可以根据不同的需求设置不同的scope，这本无可厚非。还有，注意一下引入的xsd文件，Spring文件中的引用的xsd文件是用于校验xml文件的格式用的。Spring默认在启动时是要加载XSD文件来验证xml文件的。相当于是约束文件。这里我们引入了三个xsd文件，spring-beans-xsd包含对bean的解释。sprng-mvc.xsd包含了对&amp;lt;mvc&amp;gt;等标签的解释，spring-context.xsd包含对context的解释，这里我们其实只用到了spring-beans.xsd约束文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们具体看一下配置了什么东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 把User实体类注入到容器（下面会贴User类的代码，这里暂时还没用到）。相当于是通过&amp;lt;bean&amp;gt;标签来装配一个User类，我们就可以通过获取bean来达到获取User实体对象的目的。设置bean的id(一个bean的唯一标识)和class（类的全包路径 包.类）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 配置controller（也就是handler，处理客户端请求）。这里我们配置了好三个controller。我们看UserController1(对应上面的方法UserController1)的配置，配置了一个name和class。Spring MVC要识别请求的url，就是通过调用处理器映射器获取到这个name的名称，找到controller类，然后交给处理器设配器去处理controller。&lt;/span&gt;&lt;span&gt;相当于就是映射路径。注意名称前要加上/  不然无法识别。这里我们设置name=”/UserController1“和类名保持一致（为了方便），当然也可以起其他名字，别忘了/，前台提交的url和此处name的名称要保持一致。class为UserController1的全包类路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 配置处理器映射器BeanNameUrlHandlerMapping。不需要指定id，只配置全类路径即可，即class。这个处理器映射器，将bean的name作为url进行查找，需要在配置Handler时指定bean的 name（url）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    查看spring-webmvc包下面的DispatcherServlet.properties 资源文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
# Default implementation classes &lt;span&gt;for&lt;/span&gt; DispatcherServlet's strategy interfaces.
&lt;span&gt;# Used as fallback when no matching beans are found in the DispatcherServlet context.
# Not meant to be customized by application developers.

org.springframework.web.servlet.LocaleResolver&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver

org.springframework.web.servlet.ThemeResolver&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.theme.FixedThemeResolver

org.springframework.web.servlet.HandlerMapping&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
    org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

org.springframework.web.servlet.HandlerAdapter&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
    org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter

org.springframework.web.servlet.HandlerExceptionResolver&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\
    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

org.springframework.web.servlet.RequestToViewNameTranslator&lt;/span&gt;=&lt;span&gt;org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator

org.springframework.web.servlet.ViewResolver&lt;/span&gt;=org.springframework.web.servlet.view.InternalResourceViewResolver
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; org.springframework.web.servlet.FlashMapManager&lt;/span&gt;=org.springframework.web.servlet.support.SessionFlashMapManager
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;Spring MVC的处理器映射器，常用的有2个，一个是org.springframework.web.servlet.handler.&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt;BeanNameUrlHandlerMapping，继承了&lt;br/&gt;AbstractDetectingUrlHandlerMapping抽象类，它又向上继承了AbstractUrlHandlerMapping抽象类，它又向上继承了AbstractHandlerMapping，&lt;br/&gt;AbstractHandlerMapping抽象类实现了HandlerMapping接口。&lt;p&gt;另一个是org.springframework.web.servlet.handler.SimpleUrlHandlerMapping，继承了AbstractUrlHandlerMapping抽象类，&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;AbstractUrlHandlerMapping继承了AbstractHandlerMapping抽象类，AbstractHandlerMapping实现了org.springframework.web.servlet.HandlerMapping&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;接口。观察资源文件发现，&lt;/span&gt;&lt;span&gt;BeanNameUrlHandlerMapping是Spring MVC的默认处理器映射器，这里我们就使用这个。若要使用&lt;/span&gt;SimpleUrlHandlerMapping，
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;我们根据它的语法来就行了。可以这样配置：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bean id=&quot;UserController1&quot; class=&quot;com.controller.UserController1&quot; /&amp;gt;

&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 简单URL配置处理器映射器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mappings&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;/UserController1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UserController1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然这两种处理器映射器配置可以并存，核心控制器会正确的去判断 url 用哪个 Handler 去处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意这个上面资源文件的处理器映射器&lt;/span&gt;DefaultAnnotationHandlerMapping，&lt;span&gt;通过查看源码，它已经被废弃了。被抛弃的感觉不好受啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（估计DefaultAnnotationHandlerMapping的内心是崩溃的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 配置处理器适配器。不需要指定id，class为全类路径。&lt;/span&gt;&lt;span&gt;核心控制器调用处理器映射器找到了Controller类，那么谁来处理这个Controller呢。那么此时处理器适配器就闪亮登场了。什么是处理器适配器呢。且听下回分解，本章完。。。（皮一下）。通过观察以上资源文件。我们发现。Spring MVC的处理器适配器，常用的有2个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个是org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter，一个是&lt;/span&gt;&lt;span&gt;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这2个类都实现了HandlerAdapter接口。SimpleControllerHandlerAdapter处理的Handler必须实现Conreoller接口，一般返回一个ModelAndView对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HttpRequestHandlerAdapter处理的Handler必须实现HttpRequestHandler接口，一般用来处理字符串或者json数据。因为其抽象方法没有返回值。&lt;/span&gt;&lt;span&gt;AnnotationMethodHandlerAdapter已经废弃了，不多说。当然两种适配器可以共存，配置不同的映射器找到不同的controller。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring MVC默认的处理器适配器是&lt;/span&gt;&lt;span&gt;HttpRequestHandlerAdapter  。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 配置视图解析器。不需要指定id，class为全类路径。我们这里用的是InternalResourceViewResolver，配置它的class路径，注意有2个属性。prefix表示返回视图页面的前缀，suffix表示返回视图页面的后缀。比如一般我们要视图解析完成后返回一个页面index.jsp时，prefix相当于配置的是其根目录（在哪儿），suffix就是.jsp，这样在我们使用注解进行开发的时候，只需要返回一个字符串&quot;index&quot;就行了。上面那样配置，表示在 Handler 中只需要返回在 WebContent根目录下的jsp 文件名就ok了（为了简单方便，开发比较高效）。视图解析器作用&lt;/span&gt;&lt;span&gt;它负责将一个代表逻辑视图名的字符串 （String）映射到实际的视图类型 View 上。&lt;/span&gt;&lt;span&gt;通过以上资源文件发现。注意HandlerExceptionResolver处理器异常解析器。它负责将捕获的异常映射到不同的视 图上去，此外还支持更复杂的异常处理代码。Spring MVC的视图解析器这里介绍3种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种：&lt;/span&gt;&lt;span&gt;使用ViewResolver接口解析视图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;org.springframework.web.servlet.view.InternalResourceViewResolver类，通过连续向上继承，实现&lt;/span&gt;&lt;span&gt;org.springframework.web.servlet.ViewResolver接口。在实际应用中InternalResourceViewResolver也是使用的最广泛的一个视图解析器。本次开发就用的是这个视图解析器。这个比较常用。&lt;/span&gt;&lt;span&gt;InternalResourceViewResolver解析器可以解释为内部资源视图解析器。InternalResourceViewResolver会把返回的视图名称都解析为InternalResourceView对象，InternalResourceView会把Controller处理器方法返回的模型属性都存放到对应的request属性中，然后通过RequestDispatcher在服务器端把请求forword重定向到目标URL。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接口中的方法：通过传来的参数解析视图，并返回一个View对象。注意Handler类实现Conteoller接口方法时，就返回了一个ModelAndView对象。ModelAndView 是SpringMVC 框架的一个底层对象，包括 Model 和 View。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;public abstract interface ViewResolver&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public abstract View resolveViewName(String paramString, Locale paramLocale)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;throws Exception;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二种：使用RequestToViewNameTranslator接口解析视图。&lt;/span&gt;&lt;span&gt;DefaultRequestToViewNameTranslator为这个接口的实现子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个接口定义了一个抽象方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public abstract interface RequestToViewNameTranslator&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public abstract String getViewName(HttpServletRequest paramHttpServletRequest)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;throws Exception;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示根据request请求返回一个视图名称的字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三种：使用FlashMapManager接口解析视图。SessionFlashMapManager为这个接口的实现子类。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;FlashMap管理器。它能够存储并取回两次请求之间 的 FlashMap 对象。后者可用于在请求之间传递数据，通常 是在请求重定向的情境下使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个接口定义的方法：自己看看就好了，在这里不做过多介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;public abstract interface FlashMapManager&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public abstract FlashMap retrieveAndUpdate(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;public abstract void saveOutputFlashMap(FlashMap paramFlashMap, HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map肯定时用来保存数据的。RedirectView在页面跳转，数据的保存依赖于FlashMap和FlashMapManger，FlashMapManger在容器初始化时被填入，而FlashMap从Manger可以获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 配置json与对象的转换器。这里暂时用不到。下面会解释。先跳过。其实Spring MVC内置的json与对象的转换器底层还是用Jasckson类库实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（7）配置log4j.properties日志文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### set log levels ###
log4j.rootLogger &lt;/span&gt;=&lt;span&gt; INFO , console , D
 
### console ###  
log4j.appender.console &lt;/span&gt;=&lt;span&gt; org.apache.log4j.ConsoleAppender  
log4j.appender.console.Target &lt;/span&gt;=&lt;span&gt; System.out  
log4j.appender.console.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout  
log4j.appender.console.layout.ConversionPattern &lt;/span&gt;= %-d{yyyy-MM-dd HH\:mm\:ss} [%p]-[%c] %m%&lt;span&gt;n  
 
 
### log file ###  
log4j.appender.D &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File &lt;/span&gt;=../logs/IvaDubboWeb-&lt;span&gt;info.log
log4j.appender.D.Append &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
log4j.appender.D.Threshold &lt;/span&gt;=&lt;span&gt; INFO 
log4j.appender.D.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern &lt;/span&gt;= [%p] [%-d{yyyy-MM-dd HH:mm:ss}] %C.%M(%L) | %m%&lt;span&gt;n


### out zhiding log file ###
log4j.logger.haha &lt;/span&gt;=&lt;span&gt; INFO, haha
log4j.additivity.haha &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
log4j.appender.haha &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender
log4j.appender.haha.File &lt;/span&gt;=D:/logs/&lt;span&gt;mylog.log
log4j.appender.haha.Append &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
log4j.appender.haha.Threshold &lt;/span&gt;=&lt;span&gt; INFO
log4j.appender.haha.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout
log4j.appender.haha.layout.ConversionPattern &lt;/span&gt;= [%p] [%-d{yyyy-MM-dd HH:mm:ss}] %C.%M(%L) | %m%n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Log4j简单介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护线程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.  &lt;span&gt;配置根logger，日志输出级别为INFO级别。log4j的输出级别：TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL。比INFO级别高的也会打印输出，比INFO低的不会输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 配置console，在eclipse的控制台打印日志信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 配置输出到文件。一个是输出到一般性文件中，另一个是输出到我们指定的文件中。很简单。(笔者对log4j还琢磨了半天，主要是了解日志打印到底是什么玩意儿)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对上面log4j简单测试一下（注意要导入log4j开发包和单元测试JUinit包，并把log4j.properties文件放在src目录下）。打印到控制台：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.log4j;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Log4jTest {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BasicConfigurator.configure(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动快速地使用缺省Log4j环境。&lt;/span&gt;
&lt;span&gt;
        Logger logger &lt;/span&gt;= Logger.getLogger(Log4jTest.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;log4j&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;是&quot;&lt;span&gt;);
        logger.error(&lt;/span&gt;&quot;什么&quot;&lt;span&gt;);
        logger.debug(&lt;/span&gt;&quot;呢&quot;&lt;span&gt;);

    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行效果：debug级别比INFO低，无输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102170018925-1494925249.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印日志到指定文件：把方法放在一个类中就行了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BasicConfigurator.configure(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动快速地使用缺省Log4j环境。&lt;/span&gt;
&lt;span&gt;
        Logger logger &lt;/span&gt;= Logger.getLogger(&quot;haha&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;我&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;要&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;学&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;java&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;哈&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;哈&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102170540053-1193848042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（8）运行程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;启动Tomcat服务器，在浏览器地址栏上输入：localhost/MySpringAjax/  &lt;a href=&quot;http://localhost/MySpringMVCAjax/&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102171234299-434211055.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   完美运行，不做过多解释。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4. Spring MVC处理（jQuery）Ajax请求(前台发送key/value数据，后台返回json数据)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）编写jsp页面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;重复步骤我们一笔带过就好了。比如jar包都已经导好了，还有log4j.properties文件，springmvc.xml主配置文件，这些都是项目公用的。这里就不多说了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mybutton2&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;springmvc处理ajax请求&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;fun2()&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;发送数据格式为key/value的（jquery）ajax请求&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spand &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）编写js页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用jquery提交key/value数据（ajax请求）&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fun2(){
    
    $.ajax({
        
        type:&lt;/span&gt;&quot;POST&quot;&lt;span&gt;,
        url:&lt;/span&gt;&quot;UserController2&quot;&lt;span&gt;,
        data:&lt;/span&gt;&quot;username=wly&amp;amp;password=1314520&quot;,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key/value数据&lt;/span&gt;
        success:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
            
            $(&lt;/span&gt;&quot;#show2&quot;).html(data.username+&quot; &quot;+&lt;span&gt;data.password);
            
        }            
    });

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）编写User类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pojo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    
    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   &lt;span&gt;这里我们给User类增加了一个age属性，前台发送的还是username和password。（增加age属性主要是为了对User类进行重新的一些操作，就是方便我们演示不同的效果）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）配置web.xml文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;span&gt;上面已经配置好了，配置三个东西。1. Spring MVC核心控制器；2. 对静态资源进行放行；3. 配置Spring MVC提供的编码过滤器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）配置springmvc.xml文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;span&gt;上面已经配置好了，需要配置的bean有，User实体类，Controller类，处理器映射器，处理器适配器，视图解析器，json与对象的转换器（本次开发就调用Spring MVC内置的json与对象的转换器进行进行json数据与对象的转换）。配置json与对象转换器的id（唯一识别这个bean）和class（全包类路径）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置json与对象的转换器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
     
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myconverter&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;这里我们看一下配置的Spring MVC内置的json与对象的转换器，这里我们使用的是MappingJackson2HttpMessageConverter类。我们先介绍一下Spring MVC的2个常用的消息转换器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. &lt;strong&gt;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter消息转换器类&lt;/strong&gt;，这个类继承了AbstractHttpMessageConverter&amp;lt;T&amp;gt;抽象类，而这个抽象类实现了package org.springframework.http.converter.HttpMessageConverter&amp;lt;T&amp;gt;接口。我们看一下这个接口的抽象方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.http.converter;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpInputMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpOutputMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.MediaType;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; HttpMessageConverter&amp;lt;T&amp;gt;&lt;span&gt;
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canRead(Class&amp;lt;?&amp;gt;&lt;span&gt; paramClass, MediaType paramMediaType);
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; canWrite(Class&amp;lt;?&amp;gt;&lt;span&gt; paramClass, MediaType paramMediaType);
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; List&amp;lt;MediaType&amp;gt;&lt;span&gt; getSupportedMediaTypes();
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; T read(Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; paramClass, HttpInputMessage paramHttpInputMessage)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotReadableException;
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; write(T paramT, MediaType paramMediaType, HttpOutputMessage paramHttpOutputMessage)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotWritableException;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Location:           F:\eclipseWorkspace\myworkspace\MySpringMVCAjax\WebContent\WEB-INF\lib\spring-web-4.0.0.RELEASE.jar
 * Qualified Name:     org.springframework.http.converter.HttpMessageConverter
 * Java Class Version: 6 (50.0)
 * JD-Core Version:    0.7.0.1
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一般来说，我们在Spring MVC实现自定义的json与对象的转化器时，就应该实现HttpMessageConverter&amp;lt;T&amp;gt;这个接口。MediaType在网络协议的消息头里面叫做Content-Type，使用两部分的标识符来确定一个类型，我们用的时候其实就是为了表明我们传的东西是什么类型。MediaType类就是一个媒体类型，定义了好多静态常量，定义的就是数据的格式。相当于ContentType。静态常量值有application/json，text/html，image/png，application/xml等等。有好多呢。自己去看源码好了。canRead()方法表示检测能不能把java对象转化为json数据，canWrite表示检测能不能把json数据转化为java对象。read（）方法用来读，表示把json数据转化为java对象，write方法表示写，把java对象转换为json数据输出。MappingJackson2HttpMessageConverter是HttpMessageConverter&amp;lt;T&amp;gt;的实现子类，先来看一下AbstractHttpMessageConverter&amp;lt;T&amp;gt;抽象类定义的2个重要的抽象方法。实现HttpMessageConverter&amp;lt;T&amp;gt;接口中的read()和write（）抽象方法。&lt;/span&gt;&lt;span&gt;但是调用的还是本类定义的2个抽象方法。再交给起子类去实现这2个方法。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; T read(Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; clazz, HttpInputMessage inputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 158 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; readInternal(clazz, inputMessage);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; T t, MediaType contentType, HttpOutputMessage outputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotWritableException
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 170 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; HttpHeaders headers =&lt;span&gt; outputMessage.getHeaders();
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 171 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (headers.getContentType() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 172 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; ((contentType == &lt;span&gt;null&lt;/span&gt;) || (contentType.isWildcardType()) ||&lt;span&gt; (contentType.isWildcardSubtype())) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 173 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;         contentType =&lt;span&gt; getDefaultContentType(t);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 175 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (contentType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 176 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;         headers.setContentType(contentType);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 179 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (headers.getContentLength() == -1L&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 180 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       Long contentLength =&lt;span&gt; getContentLength(t, headers.getContentType());
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 181 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (contentLength != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 182 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;         headers.setContentLength(contentLength.longValue());
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 185 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((outputMessage &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; StreamingHttpOutputMessage)) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 186 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       StreamingHttpOutputMessage streamingOutputMessage =&lt;span&gt; (StreamingHttpOutputMessage)outputMessage;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;       
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 189 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       streamingOutputMessage.setBody(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamingHttpOutputMessage.Body()
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeTo(&lt;span&gt;final&lt;/span&gt; OutputStream outputStream) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 192 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;           AbstractHttpMessageConverter.&lt;span&gt;this&lt;/span&gt;.writeInternal(t, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpOutputMessage()
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;           {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; OutputStream getBody() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 195 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;               &lt;span&gt;return&lt;/span&gt;&lt;span&gt; outputStream;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;             
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpHeaders getHeaders()
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;             {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 200 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;               &lt;span&gt;return&lt;/span&gt; AbstractHttpMessageConverter.1.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.val$headers;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;           });
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       });
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 207 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       writeInternal(t, outputMessage);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 208 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       outputMessage.getBody().flush();
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 

&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; T readInternal(Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; paramClass, HttpInputMessage paramHttpInputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotReadableException;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeInternal(T paramT, HttpOutputMessage paramHttpOutputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotWritableException;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;接下来，MappingJackson2HttpMessageConverter就出现了，其实现了抽象类定义的方法readInternal()和writeInternal，通过观察发现。readInternal()方法其调用了ObjectMapper(Jackson核心操作类)的readValue()方法，表示将json字符串转化为java对象。read()方法其实是本类扩展的一个方法，作用和readInternal一样。writeInternal()方法其调用了ObjectMapper(Jackson核心操作类)的writeValue()方法，表示将java对象转化为json字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公共接口HttpInputMessage，扩展HttpMessage，表示HTTP输入消息，由表头 和可读主体组成。通常由服务器端的HTTP请求句柄或客户端的HTTP响应句柄实现。其实现子类ServletServerHttpRequest封装了请求头header和请求体body。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公共接口&lt;span class=&quot;typeNameLabel&quot;&gt;HttpOutputMessage ，扩展HttpMessage&lt;/span&gt;表示HTTP输出消息，由标头 和可写主体组成。通常由客户端的HTTP请求句柄或服务器端的HTTP响应句柄实现。其实现子类ServletServerHttpResponse相当于封装了响应头和响应体。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt; Object readInternal(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz, HttpInputMessage inputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotReadableException
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 168 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     JavaType javaType = getJavaType(clazz, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 169 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; readJavaType(javaType, inputMessage);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; Object read(Type type, Class&amp;lt;?&amp;gt;&lt;span&gt; contextClass, HttpInputMessage inputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotReadableException
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 176 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     JavaType javaType =&lt;span&gt; getJavaType(type, contextClass);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 177 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; readJavaType(javaType, inputMessage);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 182 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objectMapper.readValue(inputMessage.getBody(), javaType);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 185 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpMessageNotReadableException(&quot;Could not read JSON: &quot; +&lt;span&gt; ex.getMessage(), ex);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeInternal(Object object, HttpOutputMessage outputMessage)
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, HttpMessageNotWritableException
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 193 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     JsonEncoding encoding =&lt;span&gt; getJsonEncoding(outputMessage.getHeaders().getContentType());
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 198 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     JsonGenerator jsonGenerator = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objectMapper.getJsonFactory().createJsonGenerator(outputMessage.getBody(), encoding);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 202 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 203 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       jsonGenerator.useDefaultPrettyPrinter();
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 207 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.jsonPrefix != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 208 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;         jsonGenerator.writeRaw(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.jsonPrefix);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 210 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objectMapper.writeValue(jsonGenerator, object);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JsonProcessingException ex) {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 213 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HttpMessageNotWritableException(&quot;Could not write JSON: &quot; +&lt;span&gt; ex.getMessage(), ex);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;org.springframework.http.converter.StringHttpMessageConverter消息转换器类&lt;/strong&gt;，继承了AbstractHttpMessageConverter&amp;lt;String&amp;gt;抽象类，而这个抽象类实现了HttpMessageConverter&amp;lt;T&amp;gt;接口。主要用于以读写字符串。其实就是一个消息转换器。默认情况下，该转换器支持所有介质类型（&lt;code&gt;*/*&lt;/code&gt;），并用写&lt;code&gt;Content-Type&lt;/code&gt;的&lt;code&gt;text/plain&lt;/code&gt;。可以通过设置supportedMediaTypes该属性来覆盖。原理：通过输入和输出流的方式进行读和写操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计哲学：StringHttpMessageConverter的哲学便是：你想要什么类型的数据，我便发送给你该类型的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实很简单的道理，比如我希望接受的数据类型是Accept: application/json;charset=UTF-8，发送的数据类型Content-Type: application/json;charset=UTF-8 当然也要保持一致。&lt;/span&gt;&lt;span&gt;相当于以什么格式输入的字符串，就得以相应的格式进行转换。这里要深入了解的话请看具体源码。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;（6）配置编写Controller类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpOutputMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.MediaType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.HttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.ServletServerHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.HttpRequestHandler;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.pojo.User;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserController2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HttpRequestHandler{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(HttpServletRequest request, HttpServletResponse response)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        response.setCharacterEncoding(&quot;UTF-8&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载spring.xml文件初始化ApplicationContext&lt;/span&gt;
        ApplicationContext ac = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到User类的实例（对象），可以看出IoC（把对象交给容器管理）机制（工厂模式+Java反射机制）&lt;/span&gt;
        User user = (User) ac.getBean(&quot;user&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取username和password，进行手动封装&lt;/span&gt;
        String username=request.getParameter(&quot;username&quot;&lt;span&gt;);
        String password&lt;/span&gt;=request.getParameter(&quot;password&quot;&lt;span&gt;);    
        user.setUsername(username);
        user.setPassword(password);    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取消息转换器MappingJackson2HttpMessageConverter类对象，实现了HttpMessageConverter接口&lt;/span&gt;
        HttpMessageConverter converter= (HttpMessageConverter) ac.getBean(&quot;myconverter&quot;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取媒体类型，传入的是&quot;application/json;charset=UTF-8&quot;这里我们直接new&lt;/span&gt;
        MediaType mediaType=&lt;span&gt;new&lt;/span&gt; MediaType(MediaType.APPLICATION_JSON, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化响应信息类。ServletServerHttpResponse是HttpOutputMessage的实现子类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里直接new,要是配置到springmvc里面显得配置文件冗余。&lt;/span&gt;
        HttpOutputMessage out=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletServerHttpResponse(response);            
        converter.write(user, mediaType, out);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;首先要获取2个bean，一个是配置的转换器，一个是User类对象。通过加载spring.xml初始化Spring的一个应用上下文ApplicationContext对象，调用方法getBean(&quot;id&quot;)。我们可以获得bean对象，其实这是通过Java反射机制完成的。这个传入的id是我我们spring.xml中所配置的id，注意一定要对应，保持一致。关于获取Spring Bean还有其他方法，自己可以百度。得到user对象后，手动进行封装。代码都有注解，很容易理解。&lt;/span&gt;MediaType.APPLICATION_JSON是一个静态常量。MediaType类中定义的这个静态常量（还有好多，这里只列举一个）&lt;span&gt;public static final MediaType APPLICATION_JSON = valueOf(&quot;application/json&quot;)。HttpOutputMessage封装输出的信息。最后通过消息转换器的write（）方法把对象转化为json数据进行输出，响应客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ApplicationContext是一个中央接口，为应用程序提供配置。在应用程序运行时，它是只读的，但是如果实现支持，则可以重新加载。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ApplicationContext提供：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 用于访问应用程序组件的Bean工厂方法。继承自ListableBeanFactory。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.以通用方式加载文件资源的能力。从R&lt;code&gt;esourceLoader&lt;/code&gt;接口继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.将事件发布给注册的侦听器的能力。从ApplicationEventPublisher接口继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.解决消息的能力，支持国际化。从MessageSource接口继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.从父上下文继承。在后代上下文中的定义将始终优先。例如，这意味着整个Web应用程序都可以使用单个父上下文，而每个servlet都有其自己的子上下文，该子上下文独立于任何其他servlet的子上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存在问题：这里的User类对象其实最后还是通过Spring容器new的实例（反射），完全不用注解的话，怎么自动完成User类对key/value类型数据的封装呢，我们怎么得到user类呢。有一种思路（深入了解spring mvc的参数绑定机制，这就要又得研究研究源码了）。不知道大家还有什么好的办法。欢迎交流哈。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（7）运行程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102221015981-969024460.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;5. Spring MVC处理（jQuery）Ajax请求(前台发送json数据，后台返回json数据)&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（1）编写jsp页面&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mybutton3&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;springmvc处理ajax请求&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;fun3()&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;发送数据格式为json的(jquery)ajax请求&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spand &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（2）编写js文件&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用jquery提交json数据（ajax请求）&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fun3(){
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user={                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;符合json数据格式规范的javascript对象&lt;/span&gt;
            &quot;username&quot;:&quot;我是谁&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;password&quot;:&quot;1314520&quot;&lt;span&gt;    
    };    
$.ajax({
        
        type:&lt;/span&gt;&quot;POST&quot;&lt;span&gt;,
        url:&lt;/span&gt;&quot;UserController3&quot;&lt;span&gt;,
        contentType:&lt;/span&gt;&quot;application/json;charset=UTF-8&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据到服务器时所使用的内容类型&lt;/span&gt;
        data:JSON.stringify(user),    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将javascript对象转化为json字符串&lt;/span&gt;
        
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预期的服务器响应的数据类型。服务器返回json字符串。jquery会自动把json转化为js对象&lt;/span&gt;
        dataType:&quot;json&quot;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于调用JSON.parse（data）方法。此时我们省去即可。      &lt;/span&gt;
        success:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
            
            $(&lt;/span&gt;&quot;#show3&quot;).html(data.username+&quot; &quot;+data.password+&quot; &quot;+&lt;span&gt;data.age);
            
        }            
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打印信息时，我们加了一个age属性注意一下。这里username设置为中文，主要为了测试会不会出现乱码（看web.xml配置的编码过滤器生效没）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（3）编写User类&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt; &lt;span&gt; User实体类和上面一样。有3个属性，username,password,age。提供getters和setters方法，toString方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（4）配置web.xml&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;一样&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（5）配置springmvc.xml文件&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;同理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（6）编写Controller类&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpInputMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpOutputMessage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.MediaType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.HttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.HttpMessageNotWritableException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.StringHttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.ServletServerHttpRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.ServletServerHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.HttpRequestHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestBody;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.ResponseBody;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.databind.ObjectMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.pojo.User;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserController3 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HttpRequestHandler{


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(HttpServletRequest request, HttpServletResponse response)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        response.setCharacterEncoding(&quot;UTF-8&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;////&lt;/span&gt;&lt;span&gt;加载spring.xml文件初始化ApplicationContext&lt;/span&gt;
        ApplicationContext ac = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;////&lt;/span&gt;&lt;span&gt;获取消息转换器MappingJackson2HttpMessageConverter类对象，实现了HttpMessageConverter接口&lt;/span&gt;
        HttpMessageConverter converter=(HttpMessageConverter) ac.getBean(&quot;myconverter&quot;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;////&lt;/span&gt;&lt;span&gt;获取媒体类型，传入的是&quot;application/json;charset=UTF-8&quot;这里我们直接new对象&lt;/span&gt;
        MediaType mediaType=&lt;span&gt;new&lt;/span&gt; MediaType(MediaType.APPLICATION_JSON, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求信息类，封装输入信息&lt;/span&gt;
        HttpInputMessage in=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletServerHttpRequest(request);        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;响应信息类，封装输出信息&lt;/span&gt;
        HttpOutputMessage out=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletServerHttpResponse(response);                            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把前台传来传来json数据转化为User对象（read接受的参数：这里可以把json数据转化为User，得益于HttpInputMessage已经把请求的信息已经封装好了，包括请求头和请求体）&lt;/span&gt;
        User user= (User) converter.read(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, in);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置年龄&lt;/span&gt;
        user.setAge(666&lt;span&gt;);
        
        System.out.println(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把User对象转化为json数据输出&lt;/span&gt;
&lt;span&gt;        converter.write(user, mediaType, out);    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码都有注解。很简单。消息转换器对象的write()方法读客户端发送的json数据，把json数据转换为User类对象，为什么要转换？（方便我们代码进行操作和维护。比如我们登陆时，要查数据库看这个user存在不，设置其他属性什么的，比如age。所以是有一定需求的。java语言是面向对象程序设计语言，肯定操作java对象方便快捷）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;（7）跑一下程序&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1838259/201911/1838259-20191102223218109-567806677.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完美运行，没有出现乱码，好了，收工。打印出了username，password，age的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 理解Spring MVC的执行流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）用户发送请求到Spring MVC核心控制器（DispatcherServlet）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）前端控制器请求 HandlerMapping 查找 Controller，可以根据 xml 配置、注解进行查找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3） 处理器映射器 HandlerMapping 查找完成后向核心控制器返回 Controller。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）前端控制器调用处理器适配器去执行 Controller。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）处理器适配器执行 Controller。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Controller执行完成后给适配器返回 ModelAndView对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）处理器适配器向前端控制器返回 ModelAndView。ModelAndView 是SpringMVC 框架的一个底层对象，包括 Model 和 View。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）前端控制器请求试图解析器去进行视图解析根据逻辑视图名来解析真正的视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）视图解析器向前端控制器返回 view。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）核心控制器进行视图渲染。就是将模型数据（在 ModelAndView 对象中）填充到 request 域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11）核心控制器向用户响应结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）导包。不到log4j日志包会出现错误，Spring框架支持log4j日志输出。支持Apache服务的包也要导入（com.springresource）。Jackson包导全。Spring开发基本包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）加载不到静态资源，要对静态资源文件进行放行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Spring的IoC机制，可以把对象交给容器管理。IoC核心：通过配置文件或者是Annonation的方式，将实现类注入到调用者那里去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   IoC实现原理：工厂模式+java反射机制。IOC好处：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt; 第一：资源集中管理，实现资源的可配置和易管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   第二：降低了使用资源双方的依赖程度，也就是我们说的耦合度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   第三：通过配置文件，可以做到改变实现类，而不改变任何一个调用者的代码（IOC）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）本次开发我们使用到了Spring MVC内置的消息转换器MappingJackson2HttpMessageConverter（用于java对象与json数据的转换）。其内部实现原理还是使用到了Jackson开发包，这就是为什么要导入Jackson包的原因。当然，我们也可以直接使用Jackson类库进行java对象与json数据的转换（我的前几篇博客）。这里调用内置的消息转换器，方便大家理解。Spring MVC的执行流程，以及底层到底是怎么进行java对象与json数据的。当然也可以在Spring MVC自定义自己的消息转换器类，让其实现HttpMessageConverter&amp;lt;T&amp;gt;接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）本次开发的强大之处在于没有使用任何Spring的任何注解，基于纯XML配置，走原生模式。方便大家了解底层的实现原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）学习的时候可以多参考Spring和Spring MVC的开发文档。有不懂的类可以参考Spring API文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（7）通过本次开发，发现Spring MVC的优点：Spring MVC与Spring无缝对接，使用简单，易扩展，灵活性比较强，可适配，非侵入，清晰的角色划分，强大的配置方式，可定制的handler mapping和view resolver。当然我觉得Spring MVC最好的地方在于提供了非常灵活的参数绑定机制和强大的注解机制。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 02 Nov 2019 15:11:00 +0000</pubDate>
<dc:creator>我想和你拍照片</dc:creator>
<og:description>1. Spring Spring框架是一个轻量级的解决方案，是一个潜在的一站式商店，用于构建企业就绪的应用程序。Spring框架是一个Java平台，为开发Java应用程序提供全面的基础架构支持。Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/1314520wly/p/11783149.html</dc:identifier>
</item>
<item>
<title>docker-compose下的java应用启动顺序两部曲之一：问题分析 - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/11784526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/11784526.html</guid>
<description>&lt;p&gt;在docker-compose编排多个容器时，需要按实际情况控制各容器的启动顺序，本文是《docker-compose下的java应用启动顺序两部曲》的第一篇，文中会分析启动顺序的重要性，以及启动顺序有问题时会有什么样的影响，再给出临时解决的和官方推荐的两种解决方案，为下一篇的实战做好铺垫。&lt;/p&gt;
&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;p&gt;本次实战的环境如下：&lt;/p&gt;
&lt;ol readability=&quot;0.44111776447106&quot;&gt;&lt;li&gt;操作系统：CentOS Linux release 7.7.1908&lt;/li&gt;
&lt;li&gt;docker：1.13.1&lt;/li&gt;
&lt;li&gt;docker-compose：1.24.1&lt;/li&gt;
&lt;li readability=&quot;3.4326923076923&quot;&gt;
&lt;p&gt;spring cloud：Finchley.RELEASE&lt;/p&gt;
&lt;h3 id=&quot;分布式环境中的依赖关系&quot;&gt;分布式环境中的依赖关系&lt;/h3&gt;
&lt;p&gt;在分布式环境中，各服务之间可能存在依赖关系，例如SpringCloud环境中的应用在启动时都会先往注册中心Eurka发起请求，如下图（来自spring官方博客：&lt;a href=&quot;https://spring.io/blog/2015/07/14/microservices-with-spring&quot; class=&quot;uri&quot;&gt;https://spring.io/blog/2015/07/14/microservices-with-spring&lt;/a&gt; ）：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221835879-1778694802.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;从上图可知，如果Eureka的服务不可用，就会影响业务服务的功能；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;docker环境中的依赖关系&quot;&gt;Docker环境中的依赖关系&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上述服务如果用docker-compose编排在一起，也面依赖着问题：Eureka容器启动完毕并且能提供http服务以后，业务服务的容器才能在Eureka注册成功并取得服务列表，通常我们都使用&lt;span&gt;depends_on&lt;/span&gt;参数来设定依赖关系；&lt;/li&gt;
&lt;li&gt;以下是个docker-compose.yml文件，里面有两个容器：eureka和service，eureka是注册中心，service是业务服务，service启动后要去eureka注册，为了确保启动顺序，service配置了&lt;span&gt;depends_on&lt;/span&gt;参数：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: '3'
services:
  eureka:
    image: bolingcavalry/eureka:0.0.1-SNAPSHOT
    container_name: eureka
    restart: unless-stopped
  service:
    image: bolingcavalry/service:0.0.1-SNAPSHOT
    container_name: service
    restart: unless-stopped
    command: sh -c 'java -Xms1g -Xmx1g -cp /app/resources:/app/classes:/app/libs/* com.bolingcavalry.waitforitdemo.ServiceApplication'
    depends_on:
    - eureka&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;上述yml文件能解决依赖问题吗？service服务启动时能否成功在eureka注册？来试试吧，在Linux电脑上创建docker-compose.yml文件，内容如上所示；&lt;/li&gt;
&lt;li&gt;在docker-compose.yml所在目录执行&lt;span&gt;docker-compose up&lt;/span&gt;，docker服务会先去hub.docker.com下载镜像，然后依次创建容器，控制台会同时打印eureka和service的日志，如下图所示，service注册eureka失败了，请注意图中的文字分析：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221843765-528141972.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;为何会注册失败呢？继续看后面的日志，如下图，service注册失败后eureka才初始化完成，所以前面的service注册会失败：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221851480-965889285.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;至此可以确定：&lt;span&gt;depends_on&lt;/span&gt;参数可以确保eureka容器启动后再启动service容器，但我们真正想要的，是eureka容器启动后，并且eureka服务初始化完毕进入可用状态后，再启动service容器，显然&lt;span&gt;depends_on&lt;/span&gt;参数达不到我们的要求；&lt;/li&gt;
&lt;li&gt;docker官方文档也证实了这一点，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221853919-603146173.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;看来&lt;span&gt;depends_on&lt;/span&gt;参数解决不了我们的问题，需要去寻找其他方法；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外您可能会说：没关系，service会自动重新注册，但是在真实环境中，不是每个服务都有能力去自己解决依赖不可用的问题，例如spring-cloud-config服务如果起不来，依赖它的服务可能会立即停止；&lt;/p&gt;
&lt;h3 id=&quot;有一种临时方法此方法v3版语法不再支持&quot;&gt;有一种临时方法(此方法V3版语法不再支持)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果eureka容器配置了健康检查，那么service容器可以配置健康检查依赖来控制启动时机，具体的做法可以参考官方示例，如下所示，地址是：&lt;a href=&quot;https://docs.docker.com/compose/compose-file/compose-file-v2/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/compose/compose-file/compose-file-v2/&lt;/a&gt; ：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;version: &quot;2.4&quot;
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
  redis:
    image: redis
  db:
    image: redis
    healthcheck:
      test: &quot;exit 0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述编排内容可见：db容器有健康检查，可以确定db容器的服务是否可用，web容器的&lt;span&gt;depends_on&lt;/span&gt;参数内可以配置&lt;span&gt;condition&lt;/span&gt;，这样就做到了只有redis已经启动并且db的健康检查通过，才会启动web容器；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上述配置看起来似乎是个不错的方案，在我们这里，只要给eureka配置要健康检查，再让service容器的&lt;span&gt;depends_on&lt;/span&gt;参数内配置&lt;span&gt;condition: service_healthy&lt;/span&gt;就可以了；&lt;/li&gt;
&lt;li&gt;不幸的是：&lt;span&gt;在docker-compose的第三版语法中，取消了condition参数！&lt;/span&gt;文档地址是：&lt;a href=&quot;https://docs.docker.com/compose/compose-file/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/compose/compose-file/&lt;/a&gt; ，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221855407-1501492376.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;因此，condition参数看似好用，但是从V3版开始的docker-compose.yml已经不再支持该参数，不能作为标准的解决方案；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;官方推荐的方案&quot;&gt;官方推荐的方案&lt;/h3&gt;
&lt;p&gt;如下图红框所示，docker官方推荐使用&lt;span&gt;wait-for-it.sh&lt;/span&gt;脚本来解决问题，地址：&lt;a href=&quot;https://docs.docker.com/compose/startup-order/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/compose/startup-order/&lt;/a&gt; ：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/485422/201911/485422-20191102221857519-483696451.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;至此，本篇已经分析了docker-compose下容器启动顺序的问题，下一篇文章，我们用SpringCloud应用来做实战，将其做到在docker-compose下有序启动；&lt;/p&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;如果您对docker容器健康检查有兴趣，可以参考以下文章：&lt;/p&gt;
&lt;ol readability=&quot;-0.68115942028985&quot;&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/102641942&quot;&gt;《极速体验docker容器健康》&lt;/a&gt;；&lt;/li&gt;
&lt;li readability=&quot;-0.43877551020408&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/102649435&quot;&gt;《Java应用在docker环境配置容器健康检查》&lt;/a&gt;；&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 02 Nov 2019 14:19:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>在docker compose编排多个容器时，需要按实际情况控制各容器的启动顺序，本文是《docker compose下的java应用启动顺序两部曲》的第一篇，文中会分析启动顺序的重要性，以及启动顺序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/11784526.html</dc:identifier>
</item>
<item>
<title>公理设计-由奇怪海战引发的软件设计思考 - 程序员历小冰</title>
<link>http://www.cnblogs.com/remcarpediem/p/11784470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/remcarpediem/p/11784470.html</guid>
<description>&lt;p class=&quot;line&quot; data-line=&quot;0&quot;&gt;前几天看到了一个博客，推荐了《公理设计》一书，还有其相关的&lt;a href=&quot;http://blog.sciencenet.cn/home.php?mod=attachment&amp;amp;id=40989&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;以及&lt;a href=&quot;https://www.jianshu.com/[https://www.bilibili.com/video/av74189173/](https://www.bilibili.com/video/av74189173/)&quot; target=&quot;_blank&quot;&gt;视频&lt;/a&gt;。简单了解了一下，增深了一些对软件设计的理解，特此也推荐给大家。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;3&quot;&gt;公理设计理论将设计建立在科学公理、定理和推论的基础上，由麻省理工学院教授 Nam. P. Suh 领导的研究小组于 1978 年提出，适用于各种类别的设计活动。软件设计当然也属于一类工程设计过程，下面我们就来看一下两者的关联。&lt;/p&gt;
&lt;h3 class=&quot;line&quot; data-line=&quot;5&quot;&gt;奇怪的海战&lt;/h3&gt;
&lt;p class=&quot;line&quot; data-line=&quot;7&quot;&gt;首先从1862年11月13日的一场海战讲起。这场海战“标志着蒸汽动力铁甲舰新时代的到来。为了便于理解，我这里对舰船名称进行了修改，想了解的朋友可以百度 U.S.S. Monitor battles C.S.S. Virginia.&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;9&quot;&gt;南方叛军的大大号战舰，体型庞大，非常凶悍。已经击沉了两艘联邦军舰。北方政府军则只派出小小号，一艘非常小，火力也小多的军舰。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102215932768-1671304879.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;13&quot;&gt;大大号顾名思义，它船体特别的大，但是都是固定炮塔，两侧和首尾有很多门炮。而小小号虽然小，却有一个可以旋转的炮台。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;15&quot;&gt;我们可以理解为一条战舰需要有两个基础功能：调整航行方向和调整炮击方向。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;17&quot;&gt;对于大大号，这两个功能需求是耦合 couple 的，要改变炮击方向，就需要将船只转向。而对于小小号，这两个功能需求则是解耦合 decouple 的，航行方向与炮击方向无关，炮击方向可以独立调整。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;19&quot;&gt;于是小小号一直尽量守在大大号的射击死角攻击，而大大号虽然火力猛烈则必须不断通过改变航线来调整炮击方向，于是就不断绕圈。这两条船打了4个小时，大大号不得不撤退了，小小号获得了胜利。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;21&quot;&gt;由此可见功能之间的解耦十分重要，它增加了便捷性和灵活性。&lt;/p&gt;
&lt;h3 class=&quot;line&quot; data-line=&quot;23&quot;&gt;工科生最爱的映射矩阵&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102215946934-1599221623.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;27&quot;&gt;​书中由海战作为引子，介绍了设计过程中的四个域（Domain）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CNs：Customer Needs，客户域，就是客户描述的一大堆自然语言也说不清楚的事情，什么高端大气上档次之类的东西。&lt;/li&gt;
&lt;li&gt;FRs：Functional Requirements，功能域，从 CNs 域到 FRs 域的变换，就是把客户漫无边际的需求翻译成一些可定量的参数，比如战舰控制系统的 FR 是控制航行方向和控制开炮方向。&lt;/li&gt;
&lt;li&gt;DPs：Design Parameters，设计参数，或者叫物理域，实现 FRs 的物理参数，比如航向控制器和炮塔控制器。&lt;/li&gt;
&lt;li&gt;PVs：Process Variables，过程变量，或者叫过程域，是描述实现功能过程中涉及的过程变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;line&quot; data-line=&quot;35&quot;&gt;相邻域之间的映射，可以看成目标（做什么？）和手段（怎样做？）之间的对应关系。设计过程是相邻域中特征向量之间映射和转换过程。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;37&quot;&gt;例如，用户域元素映射到功能域的过程，实际上是将用户需求转变成产品功能要素的过程，即产品规划；功能域向物理域的映射过程是产品的设计过程；从物理域到过程域的映射则可看成“加工产品”的过程。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;39&quot;&gt;其中最为重要的是FRs（功能需求）到DPs（设计参数）的映射，这也是我们软件开发过程中最长接触的步骤，需求文档有了，如何进行代码设计并实现。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102220005167-521259059.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;43&quot;&gt;书中以矩阵向量的方式讲述了 FRs (功能需求) 和 DPs (设计参数) 的映射关系，也就是上图中由 A 变量组成的矩阵代表着 FPs 到 DPs 的映射。不同的矩阵代表着不同的映射关系，其实我们不需要关心矩阵各个位置的具体值如何计算，只需简化的了解如果 FP 和 DP 有关联，则矩阵相应位置上的值为1，否则为0。&lt;/p&gt;
&lt;p&gt;比如说小小号上的情况，有两个功能需要：FR1（调整航向）和FR2（调整开炮方向）；以及两个设计参数：DP1（船舵）和DP2（旋转炮塔）&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102220028934-1130714178.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;48&quot;&gt;其中转动船舵的时候，船会转向，所以A11这里是X，同时船身上的炮塔也跟着船一起转向，所以也影响开炮方向FR2，因此A21也是X。 而在旋转炮塔的时候，不影响船的航行方向，所以A12这里是0。&lt;/p&gt;
&lt;h3 class=&quot;line&quot; data-line=&quot;50&quot;&gt;好的设计？&lt;/h3&gt;
&lt;p class=&quot;line&quot; data-line=&quot;52&quot;&gt;所以，基于上边这个映射矩阵，好的设计应该有两个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先FRs（功能需求）的数量N，应当等于DPs (设计参数）的数量M。&lt;/li&gt;
&lt;li&gt;每一个FR（功能需求）与且只与一个DP（设计参数）相互关联。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;line&quot; data-line=&quot;56&quot;&gt;也就是说映射矩阵是一个对角矩阵，对角线上有值，其他位置都是0。《程序员修炼之道》中也提及了类似的思想，也就是正交性一节。那一节的提示是消除无关事务之间的影响，正好和这里映射矩阵是对角矩阵不谋而合。当映射举证是对角矩阵时，说明 FR 和 DP 一一对应，不会有交叉影响。当某一个 FR也就是需求发生变更时，只需要修改一个DP。&lt;/p&gt;
&lt;p&gt;当然对角矩阵属于比较理想的情况，书中也罗列了一些其他类型的映射矩阵。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102220042674-860793898.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;其中最差的情况是 FRs（功能需求）的数量N，小于 DPs(设计参数）的数量M。也就是大大号中的情景：它有两个功能需求，FR1 调整航向&lt;br/&gt;和FR2 调整开炮方向，但只有一个DP1 船舵。所以它的映射矩阵如下图所示。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102220054459-660576669.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;65&quot;&gt;书中还继续讲解了矩阵分解的知识，也就是对应了需求功能点细分到软件详细设计细分等部分的内容，有兴趣的小伙伴可以自己去看看。&lt;/p&gt;
&lt;h3 class=&quot;line&quot; data-line=&quot;67&quot;&gt;总结&lt;/h3&gt;
&lt;p class=&quot;line&quot; data-line=&quot;69&quot;&gt;所以书中最后给出两个公里：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;独立公理（功能独立性公理)&lt;/li&gt;
&lt;li&gt;信息公理（信息量最少公理）&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;line&quot; data-line=&quot;73&quot;&gt;这不正是软件设计中经常提及的松耦合和高内聚嘛。模块相互独立互不影响就是松耦合，最小化信息量就是不对外暴露过多信息，也就是高内聚或者信息隐藏。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;75&quot;&gt;&lt;a href=&quot;http://remcarpediem.net/article/f4b7b3d6/&quot; target=&quot;_blank&quot;&gt;我的博客，欢迎来玩&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816118/201911/1816118-20191102220110658-316787274.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 02 Nov 2019 14:03:00 +0000</pubDate>
<dc:creator>程序员历小冰</dc:creator>
<og:description>公理设计理论将设计建立在科学公理、定理和推论的基础上，由麻省理工学院教授 Nam. P. Suh 领导的研究小组于 1978 年提出，适用于各种类别的设计活动。软件设计当然也属于一类工程设计过程，下面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/remcarpediem/p/11784470.html</dc:identifier>
</item>
<item>
<title>spring源码学习（二） - 小小少年-</title>
<link>http://www.cnblogs.com/mpyn/p/11784232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpyn/p/11784232.html</guid>
<description>&lt;p&gt;本篇文章，来介绍finishBeanFactoryInitialization(beanFactory);这个方法主要是完成bean的实例化，&lt;/p&gt;
&lt;p&gt;invokeBeanFactoryPostProcessors(beanFactory);负责把所有的bean扫描到beanDefinitionMap中；&lt;/p&gt;

&lt;p&gt;下面来说是如何初始化的&lt;/p&gt;
&lt;p&gt;org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean&lt;/p&gt;
&lt;p&gt;我们直接从这个方法开始说起，前面的调用链简单，就不说了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doGetBean(&lt;span&gt;final&lt;/span&gt; String name, @Nullable &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; requiredType,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             @Nullable &lt;span&gt;final&lt;/span&gt; Object[] args, &lt;span&gt;boolean&lt;/span&gt; typeCheckOnly) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 通过name获取beanName,这里不使用name直接作为beanName有两个原因：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     *  1.name可能是以&amp;amp;开头的，表明调用者想获取FactoryBean本身，而非FactoryBean;在beanFactory中factoryBean的存储也是map格式
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *    &amp;lt;beanName,bean&amp;gt; 只是说，普通的beanName是没有&amp;amp;这个字符串的，所以，需要将name的首字母移除，这样才能从缓存中拿到factoryBean
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *  2.还是别名的问题，需要转换
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; String beanName =&lt;span&gt; transformedBeanName(name);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    Object bean;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 1.从单例池中获取当前bean
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 2.这里是循环依赖的重要方法之一
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eagerly check singleton cache for manually registered singletons.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     Object sharedInstance =&lt;span&gt; getSingleton(beanName);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sharedInstance != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; args == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSingletonCurrentlyInCreation(beanName)) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 logger.debug(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
&lt;span&gt;24&lt;/span&gt;                         &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 logger.debug(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         bean = getObjectForBeanInstance(sharedInstance, name, beanName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fail if we're already creating this bean instance:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We're assumably within a circular reference.&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;         * 这里判断bean是否在创建过程中，是第二次调用的时候 才会判断；如果是第一次执行到这里，set集合是空（这里判断的是原型bean）
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCurrentlyInCreationException(beanName);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到alreadyCreated集合当中，表示当前bean已经创建过一次了&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;typeCheckOnly) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            markBeanAsCreated(beanName);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; RootBeanDefinition mbd =&lt;span&gt; getMergedLocalBeanDefinition(beanName);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            checkMergedBeanDefinition(mbd, beanName, args);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Guarantee initialization of beans that the current bean depends on.&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             String[] dependsOn =&lt;span&gt; mbd.getDependsOn();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (dependsOn != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String dep : dependsOn) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isDependent(beanName, dep)) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                                 &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                    registerDependentBean(dep, beanName);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                        getBean(dep);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchBeanDefinitionException ex) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                                 &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create bean instance.如果当前bean是单实例的，就调用createBean&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mbd.isSingleton()) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 sharedInstance = getSingleton(beanName, () -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createBean(beanName, mbd, args);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Explicitly remove instance from singleton cache: It might have been put there
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eagerly by the creation process, to allow for circular reference resolution.
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Also remove any beans that received a temporary reference to the bean.&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;                        destroySingleton(beanName);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;                 bean =&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeansException ex) {
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            cleanupAfterBeanCreationFailure(beanName);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; 
&lt;span&gt;94&lt;/span&gt; 
&lt;span&gt;95&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) bean;
&lt;/span&gt;&lt;span&gt;96&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;粘贴出来的方法删减了一部分代码，我们只说单实例bean的初始化；&lt;/p&gt;
&lt;p&gt;在判断当前bean是单实例的时候，会调用createBean;在getSingleton这里，有一行代码，是把当前bean添加到一个set集合中(这个set集合表示当前bean正在创建过程中)，&lt;/p&gt;
&lt;p&gt;这个set是用来解决循环依赖问题的，在后面，会单独抽出一篇来介绍循环引用是如何解决的，在这里就先跳过；&lt;/p&gt;

&lt;p&gt;在createBean的方法中，会调用createBeanInstance(beanName, mbd, args); 这个方法主要是完成bean的初始化，在方法中会调用org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors；&lt;/p&gt;
&lt;p&gt;这个后置处理器的determineCandidateConstructors方法来推断使用哪个构造函数来初始化；&lt;/p&gt;
&lt;p&gt;这个方法里面，我目前也正在学习，后续会贴出对这个方法的学习笔记，这里先暂时跳过；(我们就认为createBeanInstance方法完成了bean的创建)，&lt;/p&gt;
&lt;p&gt;推断出使用哪个构造函数之后，会初始化bean，返回的是一个BeanWrapper对象。这里创建出来的仅仅是bean对象；需要经过后面的属性注入，以及初始化，才会变成我们所说的spring bean对象；&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Object doCreateBean(&lt;span&gt;final&lt;/span&gt; String beanName, &lt;span&gt;final&lt;/span&gt; RootBeanDefinition mbd, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; @Nullable Object[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeanCreationException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate the bean.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     BeanWrapper instanceWrapper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mbd.isSingleton()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         instanceWrapper = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.factoryBeanInstanceCache.remove(beanName);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (instanceWrapper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         *  创建bean实例，并将bean实例包裹在BeanWrapper实现类对象中返回，
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         *  createBeanInstance中包含三种创建bean的方式
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         *    1.通过工厂方法创建bean实例
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         *    2.通过构造方法自动注入的方式创建bean实例
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         *    3.通过无参构造方法创建bean实例
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         *  如果bean的配置中配置了lookup-method和replace-method  则会使用增强bean实例
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         * 在这个方法中完成了对bean的创建(仅仅是new出来，也就是说在这个方法里面推断要使用哪个构造函数来创建bean对象)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         * 然后完成bean的初始化
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         instanceWrapper =&lt;span&gt; createBeanInstance(beanName, mbd, args);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Object bean =&lt;span&gt; instanceWrapper.getWrappedInstance();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     Class&amp;lt;?&amp;gt; beanType =&lt;span&gt; instanceWrapper.getWrappedClass();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (beanType != NullBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         mbd.resolvedTargetType =&lt;span&gt; beanType;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Allow post-processors to modify the merged bean definition.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mbd.postProcessingLock) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mbd.postProcessed) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mpy 第三次调用后置处理器  缓存注解信息&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &quot;Post-processing of merged bean definition failed&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             mbd.postProcessed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eagerly cache singletons to be able to resolve circular references
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; even when triggered by lifecycle interfaces like BeanFactoryAware.&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            isSingletonCurrentlyInCreation(beanName));
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (earlySingletonExposure) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             logger.debug(&quot;Eagerly caching bean '&quot; + beanName +
&lt;span&gt;53&lt;/span&gt;                     &quot;' to allow for resolving potential circular references&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mpy 第四次调用后置处理器 获取一个提前暴露的对象  用来解决循环依赖&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         addSingletonFactory(beanName, () -&amp;gt;&lt;span&gt; getEarlyBeanReference(beanName, mbd, bean));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize the bean instance.&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     Object exposedObject =&lt;span&gt; bean;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在populateBean(beanName, mbd, instanceWrapper);方法中完成第五次第六次调用后置处理器&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        populateBean(beanName, mbd, instanceWrapper);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在initialzeBean中完成第七次第八次后置处理器调用&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         exposedObject =&lt;span&gt; initializeBean(beanName, exposedObject, mbd);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt; BeanCreationException &amp;amp;&amp;amp;&lt;span&gt; beanName.equals(((BeanCreationException) ex).getBeanName())) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (BeanCreationException) ex;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanCreationException(
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                     mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exposedObject;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这个方法中，调用第四次后置处理器这里，返回了一个object对象，这个方法是为了完成循环依赖的，放到后面一起讲，&lt;/p&gt;
&lt;p&gt;在populateBean中，会完成属性的注入，比如@AutoWired,@Value这个属性值注入&lt;/p&gt;
&lt;p&gt;initializeBean方法，主要是调用bean的初始化方法&lt;/p&gt;
&lt;p&gt;  bean的初始化有三种方式：&lt;/p&gt;
&lt;p&gt;   1.@Bean注解中指定 initMethod destroyMethod&lt;/p&gt;
&lt;p&gt;   2.@PostConstruct @PreDestroy&lt;/p&gt;
&lt;p&gt;   3.实现DisposableBean和InitializingBean接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424630/201911/1424630-20191102212257984-377569094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在方法执行完之后，会把创建好的bean对象存放到singletonObjects这个map中，这个map存放的是所有实例化好的对象；如果bean是原型的，在第二次getBean的时候，会从这个map中获取到bean对象&lt;/p&gt;

&lt;p&gt;从狭义上来讲，singletonObjects就是我们所说的spring容器&lt;/p&gt;

</description>
<pubDate>Sat, 02 Nov 2019 13:27:00 +0000</pubDate>
<dc:creator>小小少年-</dc:creator>
<og:description>本篇文章，来介绍finishBeanFactoryInitialization(beanFactory);这个方法主要是完成bean的实例化， invokeBeanFactoryPostProcess</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mpyn/p/11784232.html</dc:identifier>
</item>
</channel>
</rss>