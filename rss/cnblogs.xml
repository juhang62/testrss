<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何写项目方案的--从资料准备到书写技巧 - cooldream2009</title>
<link>http://www.cnblogs.com/coodream2009/p/10514330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coodream2009/p/10514330.html</guid>
<description>&lt;p&gt;        在工作中，除了技术工作之外，我们也经常需要写一些项目的方案，当然如果公司比较大，岗位分工比较细，可能不存在这个问题。如果公司规模不大，比如我们公司，人不多，就要把自己锻炼成全面手，写方案是一个不可或缺的工作内容。以下是我在公司里面写技术方案的一些体会，希望对大家有帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 积累参考资料&lt;/strong&gt;&lt;br/&gt;       一般我们写方案，比如项目申请方案，根据申请项目类型范围等要求，首先是要有一个大概的方向，选择一个什么样的项目，做项目的轮廓等等，可能我们手头有相关的资料可以参考，也可能没有，如果没有，就需要我们自己去查找一些资料，可以是别人写过的项目申请方案或者是一些相关的论文，也可能是网上的一些资料或者公司内部的一些资料。资料找到之后，提取对自己项目有用处的一些思想或内容，消化吸收之后，加到项目的方案中去，就完成了资料的使用，为了以后继续使用资料，还需要把资料进行分类，把不同类型的资料进行合理的分类，按照容易组织和查找到方式保存起来，一个是为了当前项目的编写，再一个也是为了以后写类似项目有一个数据基础，不用再做重复的查找工作。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201903/935893-20190312071743686-1144245511.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 积累的文档资料分类存储&lt;/p&gt;
&lt;p&gt;       这个阶段主要是一个知识资料积累的阶段，在这个过程中，还有一个需要注意的地方是，我们写项目要注意平时多关注一些行业的动态，行业的技术发展，这样碰到些项目的方案，就不会抓瞎，通过对技术前沿的了解，可以在写方案之前，就会对项目方案内容有一个方向的把握，查找资料的时候，就不会太盲目，这也要求我们平时多关注技术或者行业的发展信息，慢慢养成习惯，让学习永远在路上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 对项目方案的总体把握&lt;/strong&gt;&lt;br/&gt;       我们写项目方案，需要对方案有一个总体的了解。比如，项目的来源，项目方案的审阅流程等。比较常见的是某个行业的管理部门，需要做一件事，可能涉及到很多单位共同完成，每个单位会分一部分工作，同时也会分一部分资金。我们作为单位之一，就要向管理部门负责，这时候的方案主要是要把分配或者争取的事情阐述清楚，分析好实际的情况，提出存在的问题，最后给出解决办法，特别是要找出工作的痛点，把工作痛点讲明白了，解决的办法和途径说清楚了，基本就问题不大。&lt;/p&gt;
&lt;p&gt;       总体把握方案，主要是想一想看方案的人最关注的的问题，在方案里有没有体现。如果争取的是投资人的资金支持，就要知道投资人的目的是什么，如果是为了赚钱，就要在方案中体现项目的赚钱能力，可能是商业模式或者前景或者技术优势等等，如果单纯的投入钱就是做一些固定的事情，就要在方案中体现这个事情按照方案能够做成，方案内容主要阐述做法的合理性，完成任务的能力等等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201903/935893-20190312071754016-1843917870.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 全面考虑项目的问题&lt;/p&gt;
&lt;p&gt;       总体把握方案还有一个重要的方面是对项目内容和经费的匹配，根据经费情况，确定项目的范围，不能把项目的范围定的过大或过小，两种情况都会被评审的人质疑，范围过大，会被质疑能不能完成任务，范围过小，会被质疑经费被夸大，这两种情况都应该避免，这就需要我们制定大致合理的项目范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 注意项目的侧重点&lt;/strong&gt;&lt;br/&gt;       我们写方案的目的，是为了让项目方案通过审核。最主要的就是多考虑审核人关注什么，从而对方案进行分类，根据方案类型的不同，采取不同的策略。暂时想到两种类型的方案，我们针对这两种情况阐述应对方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1预算类方案&lt;/strong&gt;&lt;br/&gt;       这一类方案，主要是申请资金的支持，一般的写法也是先写概况，再写存在的问题，有哪些需求，针对需求应该采取什么样的措施，后面是技术路线，功能设计，方案设计，社会或经济效益，风险情况分析，实施的方法步骤，项目预算等等，这里面每部分内容都应该写，最重要的应该是项目预算。&lt;/p&gt;
&lt;p&gt;       项目预算有两方面需要认真编制，一方面是出资方对预算的要求，比如有哪些费用不能列支，有的不能有会议费，有的不能有出差费，有的不能有劳务费等等，严格按照要求来，如果没有按照要求编制，轻者这部分费用被砍掉，重者项目方案不能通过，所以一定要弄清楚预算要求，严格执行。另一方面就是预算要合理，也就是对于项目的每一项，要有一个合理的预算，比如一个商品管理系统，预算100万，就要说明这100万的合理性，有没有类似功能的系统，和这个预算差不多，是直接购置还是自己开发，要说明理由，如果自己开发，还要把工作量进行统计，估计每一部分预算，分得越细越好，分的细说明对项目了解的比较深入，当然也可能是自己有这个系统，只需要按照实际需要进行部分调整，所以会写的很细，这样投资方也会比较放心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201903/935893-20190312071807936-1098048345.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 一个预算表示例&lt;/p&gt;
&lt;p&gt;预算编制最重要，也并不是说其他的内容就不重要，其他的内容是对预算的支撑，首先是有方案中的事情要干，所以才要求预算经费，这是个因果关系，所以要做事情的实际情况，需求的分析，应对的措施也不能马虎，也要有所依据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2内容型方案&lt;/strong&gt;&lt;br/&gt;       预算通过之后，就会注重内容的编制，比如投标文件，一般都是已经有预算了，招标文件会写清楚要做的事情的要求以及预算价格，投标主要是把事情描述清楚，当然投标报价也很重要，招标是希望花最少的钱把事情办好，落脚点还是要把事情办好，也就是重点考察方案内容，在这里我们姑且称这类重视内容的方案为内容型方案，编制这类方案就要把内容本身列为重点。&lt;/p&gt;
&lt;p&gt;       该类方案的重点部分是在解决措施上，需求已经比较明确，就看如何来根据需求，提出解决方案，比如一个办公自动化系统，就是解决办公过程中效率低下的问题，如果我们通过调研，了解到甲方在办公中存在的具体问题，一一罗列出来，然后针对每个问题，都提出相应的措施，优化整个办公流程，将优化后的办公流程与原来的进行对比，能够显著提高办公效率，而且使用方便，用户体验好，这样甲方就会很容易认同你的方案。同样的道理，对于其他的类似问题，解决办法也是类似，只要找到需求的痛点，并很好的解决，就是一个好的方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4 用到的写作技巧&lt;/strong&gt;&lt;br/&gt;在实际写方案的过程中，还可以运用一些技巧，能够使方案更充实。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 软件开发步骤的写法&lt;/strong&gt;&lt;br/&gt;       按照软件的构建方法，我们写软件开发步骤，应该是调研、需求分析、总体设计、模块设计、详细设计、软件开发、软件测试、试运行、运行、维护等顺序，这也是具体开发软件系统的顺序，但这么写软件开发可能会有一个问题，一般我们前期都会对软件有一个大概的认识，比如总体架构，功能模块等环节能简单写写，详细设计及以后的环节我们就写不出内容了，因为我们还没有做这一部分工作，所以即使写出来，也是很宽泛的，没有实际的内容，只能写一些放之四海而皆准的话，或者叫做正确的废话。&lt;/p&gt;
&lt;p&gt;这个时候，我们换个思路，不按照开发的整体推进过程来写，我们可以分模块写，比如第一步先做1、2、3模块，中期做4、5、6模块，最后做7、8、9模块，由于我们对于系统的模块能够说一些内容，所以内容就会显得比较丰满，不至于言之无物。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 多画图多列表&lt;/strong&gt;&lt;br/&gt;       我们写方案的时候，很容易陷入到文字内容的雕琢上，但对于看方案的人来说，可能时间会很短，比如方案给评审专家，方案可能好几百页，专家们可能要在20-30分钟看完，然后花很短的时间给出是否通过的判断。如果全部都是文字，估计专家看一会就看不下去，或者就是看看题目，大概的扫一眼具体内容，这样很容易漏掉方案的关键信息。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201903/935893-20190312071825636-2112721935.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 图表示例&lt;/p&gt;
&lt;p&gt;       为了让方案更容易读懂，我们有必要对方案的内容进行提炼，用图说话，将主要的内容用图表现出来，看方案的人只要看图，很快就明白方案要表达的信息，画图的过程也是一个凝练内容的过程，也是一个思考的过程。如果是很多的数据，更应该用图表来表现，让人看上去一目了然，不用自己再费劲的去数据中查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5 注意细节&lt;/strong&gt;&lt;br/&gt;       最后要说的一个问题，就是在写方案的时候，要注意细节。我们的方案很少一蹴而就，直接提交，一般都要反复修改多次，这时候要特别注意一个地方的改动，相关联的地方是不是需要跟着改动。比如预算编制里面的金额，经过多次修改调整，单项预算加起来是不是还等于总预算，金额的单位是元还是万元，同一笔预算在不同的地方出现数字是不是一致等等，这些问题如果出现，被细心的评审人发现，就是大的问题，白字黑字，评审人不会为你的疏忽去担责任，这类问题，可以通过反复检查，多人交叉检查来规避。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201903/935893-20190312071834967-295450720.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 粗心大意将金额多写了个零&lt;/p&gt;
&lt;p&gt;       还有就是我们在写方案的过程中，可能会参考很多其他方案的资料，不要原版拷贝到自己的方案，要一句一句的读一读，如果大段摘抄，很容易把名称或者数据弄混，经常会出现给李四写的方案，却称呼张三的情况。类似的情况也都是通过细心检查来排除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 结语&lt;/strong&gt;&lt;br/&gt;       关于写方案的一些想法，从积累资料，到全局把握方案总体方向，从方案侧重点到写作的一些技巧，还有写方案应该注意的细节等，希望这些内容对大家有启发。当然，我们没有考虑其他的因素，仅仅是从准备方案本身来描述，实际的环境中，可能会复杂的多，可能不是方案能够解决的。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 23:22:00 +0000</pubDate>
<dc:creator>cooldream2009</dc:creator>
<og:description>在工作中，除了技术工作之外，我们也经常需要写一些项目的方案，当然如果公司比较大，岗位分工比较细，可能不存在这个问题。如果公司规模不大，比如我们公司，人不多，就要把自己锻炼成全面手，写方案是一个不可或缺</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coodream2009/p/10514330.html</dc:identifier>
</item>
<item>
<title>【机器学习之数学】01 导数、偏导数、方向导数、梯度 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10513371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10513371.html</guid>
<description>&lt;p&gt;最近学习《最优化导论》，遇到了“方向导数”这一概念，故对其及相关概念进行一遍梳理。并给出方向导数的推导过程。&lt;/p&gt;
&lt;h2 id=&quot;导数偏导数和方向导数&quot;&gt;导数、偏导数和方向导数&lt;/h2&gt;
&lt;p&gt;  在一元可导函数 &lt;span class=&quot;math inline&quot;&gt;\(y = f(x)\)&lt;/span&gt; 中，导数 &lt;span class=&quot;math inline&quot;&gt;\(f'(x_0)\)&lt;/span&gt; 即是曲线上 &lt;span class=&quot;math inline&quot;&gt;\(x = x_0\)&lt;/span&gt; 处的斜率。按照定义求导数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f'(x) = \lim_{\Delta x \to 0}\frac{f(x+ \Delta x) - f(x)}{\Delta x} \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以通过各种求导法则来计算导数。&lt;/p&gt;
&lt;p&gt;  对一个 &lt;span class=&quot;math inline&quot;&gt;\(R^m \to R\)&lt;/span&gt; 的多元可导函数，&lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x),\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt;，我们能够求的导数就多，如偏导数、方向导数，但归根到底，这些导数都可以认为是曲面上一点在某个方向的斜率。对于 &lt;span class=&quot;math inline&quot;&gt;\(m\le 2\)&lt;/span&gt; 的情况，我们还能够通过坐标系很直观地了解；当 &lt;span class=&quot;math inline&quot;&gt;\(m &amp;gt; 2\)&lt;/span&gt; 时，我们可以从向量空间的角度理解。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;偏导数&lt;/strong&gt;是指 &lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x)\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 中的某一维进行求导，如下式（2）所示，对第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 维求偏导数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\bm x)}{\partial x_i} &amp;amp;= \frac{\partial f(x_1, x_2, ...,x_i,..., x_m)}{\partial x_i} \\ &amp;amp;= \lim_{\Delta x_i \to 0}\frac{f(x_1, x_2, ...,x_i + \Delta x_i,..., x_m) - f(x_1, x_2, ...,x_i,..., x_m)}{\Delta x_i} \end{split} \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;方向导数&lt;/strong&gt;就更好理解了，&lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x)\)&lt;/span&gt; 对 &lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 构成的向量空间 &lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt; 中某一方向 &lt;span class=&quot;math inline&quot;&gt;\(\bm d' = [\Delta x_1, \Delta x_2, ..., \Delta x_m]^\top\)&lt;/span&gt; 求导数，即得到该方向上的方向导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial f(\bm x)}{\partial \bm d'}\)&lt;/span&gt;，如式（3）所示：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\bm x)}{\partial \bm d'} &amp;amp;= \frac{\partial f(x_1, x_2,..., x_m)}{\partial x_i} \\ &amp;amp;= \lim_{\rho \to 0}\frac{f(x_1 + \Delta x_1, x_2 +\Delta x_2, ..., x_m +\Delta x_m) - f(x_1, x_2, ...,x_i,..., x_m)}{\rho} \\ &amp;amp;\rho = \sqrt{\Delta x_1^2 + \Delta x_2^2 + \cdots +\Delta x_m^2} \end{split} \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;方向导数和偏导数是什么关系？&lt;/strong&gt;对于多元可导函数 &lt;span class=&quot;math inline&quot;&gt;\(y=f(\bm x),\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt;，在其上任一点 &lt;span class=&quot;math inline&quot;&gt;\(\bm x_i\)&lt;/span&gt;，我们都可以在向量空间 &lt;span class=&quot;math inline&quot;&gt;\(R^m\)&lt;/span&gt; 中的每一个方向都可以计算一个方向导数，也就是超平面上点 &lt;span class=&quot;math inline&quot;&gt;\(\bm x_i\)&lt;/span&gt; 在每一个方向切线的“斜率”。这里“每一个方向”自然包括各个偏导数的方向。即偏导数构成的集合 A 是方向导数构成集合 B 的子集。&lt;/p&gt;
&lt;h2 id=&quot;方向导数的推导过程&quot;&gt;方向导数的推导过程&lt;/h2&gt;
&lt;p&gt;  &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol x)\)&lt;/span&gt; 是一个 &lt;span class=&quot;math inline&quot;&gt;\(R^m \to R\)&lt;/span&gt; 的函数，如果我们要求 &lt;span class=&quot;math inline&quot;&gt;\(f(\boldsymbol x)\)&lt;/span&gt; 在任一点 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol x_0 = [x_1^{0}, x_2^{0}, ..., x_m^{0}]^\top\)&lt;/span&gt; 点方向为 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol d\)&lt;/span&gt; 的方向导数，那么按照定义，我们得到如下公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}\mid_{\boldsymbol x = \boldsymbol x_0} = \lim_{\alpha \to 0}\frac{f(\boldsymbol x_0 + \alpha \boldsymbol d) - f(\boldsymbol x_0)}{\alpha} \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;式（4）中，&lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol d\)&lt;/span&gt; 为单位向量。公式（4）其实是公式（3）的向量形式。（plus：公式（3）中 &lt;span class=&quot;math inline&quot;&gt;\(d'\)&lt;/span&gt; 不是单位向量，故加上 &lt;span class=&quot;math inline&quot;&gt;\('\)&lt;/span&gt; 来区分）&lt;/p&gt;
&lt;p&gt;  设 &lt;span class=&quot;math inline&quot;&gt;\(g(\alpha) = f(x_0+\alpha \boldsymbol d)\)&lt;/span&gt;，我们注意到，&lt;span class=&quot;math inline&quot;&gt;\(g(0) = f(x_0)\)&lt;/span&gt;，所以，式（4）又可以写为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}\mid_{\boldsymbol x = \boldsymbol x_0} &amp;amp; = \lim_{\alpha \to 0}\frac{g(\alpha) - g(0)}{\alpha} \\ &amp;amp;= \frac{d g(\alpha)}{d \alpha}\mid_{\alpha = 0} \\ &amp;amp;= \frac{d f(\boldsymbol x_0+\alpha \boldsymbol d)}{d \alpha}|_{\alpha = 0} \\ &amp;amp;= \nabla f(\boldsymbol x_0)^\top\boldsymbol d \\ &amp;amp;= &amp;lt;\nabla f(\boldsymbol x_0), \boldsymbol d&amp;gt; \\ &amp;amp;= \boldsymbol d^\top\nabla f(\boldsymbol x_0) \end{split} \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial f(\boldsymbol x)}{\partial \boldsymbol d}= \boldsymbol d^\top\nabla f(\boldsymbol x) \tag{6} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;方向导数和梯度&quot;&gt;方向导数和梯度&lt;/h2&gt;
&lt;p&gt;  首先明确，&lt;strong&gt;导数是一个值&lt;/strong&gt;，代表切线的斜率，而&lt;strong&gt;梯度是一个向量&lt;/strong&gt;。&lt;strong&gt;最大方向导数的方向就是梯度代表的方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;梯度&lt;/strong&gt;是 &lt;span class=&quot;math inline&quot;&gt;\(f(\bm x)\)&lt;/span&gt; 对各个自变量&lt;span class=&quot;math inline&quot;&gt;\(\bm x = [x_1, x_2, ..., x_m]^\top\)&lt;/span&gt; 每一维分别求偏导数得到的向量。&lt;/p&gt;
&lt;p&gt;  从式（5）和（6）中我们也可以知道，&lt;strong&gt;最大方向导数的方向就是梯度，最大的方向导数就是梯度的欧几里德范数&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/36301367&quot; target=&quot;_blank&quot;&gt;如何直观形象的理解方向导数与梯度以及它们之间的关系？-- 马同学&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40707407/article/details/80101501&quot; target=&quot;_blank&quot;&gt;方向导数与梯度——学习笔记 -- Reclusiveman&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/walilk/article/details/50978864&quot; target=&quot;_blank&quot;&gt;[机器学习] ML重要概念：梯度（Gradient）与梯度下降法（Gradient Descent）-- WangBo_NLPR&lt;/a&gt;&lt;br/&gt;Edwin K. P. Chong, Stanislaw H. Zak-An Introduction to Optimization-Wiley (2013)&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 15:46:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>本文从方向导数的角度理解偏导数和梯度，厘清这几者之间的关系，即“导数是一个值，代表切线的斜率，而梯度是一个向量。最大方向导数的方向就是梯度代表的方向，最大的方向导数就是梯度的欧几里德范数”。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10513371.html</dc:identifier>
</item>
<item>
<title>爬虫与反爬虫的较量-图片反爬 - 一杯闪光喵</title>
<link>http://www.cnblogs.com/lyxdw/p/10513967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyxdw/p/10513967.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在去年6月吧，刚转行做爬虫的时候，经常拿图片网还有小说网练手，无意中发现一个壁纸网站叫做娟娟壁纸网，有好多高清壁纸（这不是广告，哈哈）&lt;/p&gt;
&lt;p&gt;当时是写了全站爬取的代码。以为自己大工告成的时候，结果刚运行，就发现爬出来的图片不对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311220901019-1153800688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每张图片都是这样，我以为遇到了IP限制，于是使用代理，结果仍然是失败。&lt;/p&gt;
&lt;p&gt;难道是请求头做了限制？好，那我全部带上。结果依旧失败。&lt;/p&gt;
&lt;p&gt;当时也是忙于找工作,也没静下心来仔细想，今天回过头来继续盘它。&lt;/p&gt;
&lt;p&gt;虽然最后巧妙的用了get请求爬取成功,但是还是没搞明白原图反爬的原因。&lt;/p&gt;
&lt;p&gt;下面来看一看究竟是怎么回事。&lt;/p&gt;
&lt;h2&gt;分析网站&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311221704833-1171540162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 附上链接：http://www.jj20.com/bz/zrfg/ssrh/5565.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222027616-146266129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 图片url在网站html代码中，我爬取的也是这张图片。&lt;/p&gt;
&lt;p&gt;复制图片链接到浏览器访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222223619-1633576832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 正常，浏览器能加载，爬虫为什么就不能下载。刷新图片，结果图片没了，出现了和爬虫一样的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222422762-618232221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到网站，刷新，结果，图片没了，加载不出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311222540487-924273411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;假设是缓存导致的，清理一下浏览器的cookie和缓存。再次刷新，图片又出来了。&lt;/p&gt;
&lt;p&gt;爬虫直接请求链接会失败，具体的反爬策略，我们也不清楚。默认为图片只能在网站上加载，单独访问会失败。&lt;/p&gt;

&lt;p&gt;从网站分析图片，网站里可能有下载链接。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311225422821-760397861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成壁纸，根据分辨率来的，之前网站爬的应该都是原图，点进去看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311225632399-217067292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刷新，还是这张图，可以重复访问。&lt;/p&gt;
&lt;p&gt;http://cj.jj20.com/d/cj0.php?p=/up/allimg/611/031213123016/130312123016-0.jpg&amp;amp;w=1536&amp;amp;h=864&lt;/p&gt;
&lt;p&gt;这是一个get请求，提交了三个参数p(图片链接)，w(宽)，h(高),生成一张1536乘864的图片。&lt;/p&gt;
&lt;h2&gt;单张图片爬取&lt;/h2&gt;
&lt;p&gt;（写一个demo，测试了一下）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt;  requests
url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://cj.jj20.com/d/cj0.php?p=/up/allimg/611/031213123016/130312123016-0.jpg&amp;amp;w=1536&amp;amp;h=864&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
res &lt;/span&gt;= requests.get(url).content &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以二进制字节码保存&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    f.write(res)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201903/1364902-20190311230649914-1658491221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（单张图片爬取成功）宽和高都是可以自己改的，看自己桌面分辨率自己改。&lt;/p&gt;

&lt;p&gt;本文主要介绍爬取思路，全站爬取代码后续再补充。&lt;/p&gt;

&lt;p&gt;对于上面的网站原图反爬，我至今不是特别明白是什么原因，希望了解这方面的大牛，可以留言告知，我会尽快回复。&lt;/p&gt;

&lt;h3&gt;温馨提示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果您对本文有疑问，请在评论部分留言，我会在最短时间回复。&lt;/li&gt;
&lt;li&gt;如果本文帮助了您，也请评论关注，作为对我的一份鼓励。&lt;/li&gt;
&lt;li&gt;如果您感觉我写的有问题，也请批评指正，我会尽量修改。&lt;/li&gt;
&lt;li&gt;本文为原创，转载请注明出处。&lt;/li&gt;
&lt;li&gt;本文所有代码仅供学习参考，在爬取的同时考虑对方的服务器承受能力，适可而止。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>一杯闪光喵</dc:creator>
<og:description>前言 在去年6月吧，刚转行做爬虫的时候，经常拿图片网还有小说网练手，无意中发现一个壁纸网站叫做娟娟壁纸网，有好多高清壁纸（这不是广告，哈哈） 当时是写了全站爬取的代码。以为自己大工告成的时候，结果刚运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyxdw/p/10513967.html</dc:identifier>
</item>
<item>
<title>React 精要面试题讲解(一) 单向数据流 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10513571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10513571.html</guid>
<description>&lt;h2 id=&quot;react-单向数据流概念&quot;&gt;react 单向数据流概念&lt;/h2&gt;
&lt;h3 id=&quot;react框架是怎样的数据流向react单向数据流是怎样的概念&quot;&gt;'react框架是怎样的数据流向？'||'react单向数据流是怎样的概念 ?'&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  解答这个问题之前，我们首先得知道，js框架是个怎样的概念。
  框架：具备一定**编程思想**的(mvc/mvvm)js库,叫做框架;
  那么这道题的答案重点就在于编程思想这四个字上。

  众所周知，多数MVVM框架，如react、vue都是单向数据流的框架。
  单向数据流：即规范了数据的流向——由外层组件向内层组件进行传递;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190311232907585-718986797.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ok，我们经由上述概念得知了单向数据流其实是一种框架本身对数据流向的限制。
  那么为什么会做出这样的限制呢？   为什么不让我们为所欲为的想怎么传就怎么传呢？&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;react的编程思想和单向数据流的关系&quot;&gt;react的编程思想和单向数据流的关系&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  针对上述问题，我们结合编程思想来思考这个问题的答案。
  多数React框架的使用者可能在接触react这门框架前，就听说了有关react的诸如此类的评价——
   ”react，从入门到放弃。“
   ”相对vue，react入门难的一批。“
   ”react语法限制太严格。“
   ……
   ok，首先在这里说些题外话——我要批判这类评价。理由很简单：
   在react基于es6改版之前，只要深层次掌握了原生js的构造函数，react入门难度其实也算不上啥。
    1而在react16版本后，恕我直言，如果es6的class玩明白了，react上手使用真的零难度入门。
    2jsx花五分钟,如果之前接触过ejs/xtemplate/jade这些模版引擎，jsx相对它们还要简单;
    3而props、state、refs、context，children可以看作几个特殊的实例属性(我们甚至可以直接做个推测：父类React.Component定义了它们的管理方式);
    4那么封装组件就是写个子类啊没毛病啊;
    5好吧你说哪个框架没有生命周期钩子这玩意;
    6高阶组件对比一下类的修饰器(generetor,es6的提案，es7实现),我滴乖乖，一样的东西啊;
    
    综上所述问题，react简单的一批啊，我们只要在js的基础上，学下jsx语法，弄明白几个特殊实例属性怎么玩，一张图明白react的基本生命周期钩子，结合单向数据流的思想，为所欲为啊。
   
    ……
    跑远了，我们回来讲react编程思想和单向数据流之间的关系。
    敲黑板了看重点：
     
      react的编程思想是严谨且周密的，它约束了我们的花式操作，这是为了确保我们在使用react构建复杂项目的时候不会出现太多问题。
      而好处也是显而易见的——我们写react项目，一旦出现了问题，那么我们会很轻松的发现，根源几乎集中在props和state这俩实例属性上。 
      单向数据流是react规范的数据流向,它的作用是极大的降低了我们组件间通信的代码耦合，让组件间的通信更为清晰，debug直接往props中找(后面会介绍context)。
      也就是说，基于react严谨且周密的编程思想，制订了单向数据流这样的通信约束，使得我们react项目中的数据传递结构稳定且不易耦合，有事没事找props解决一切通信问题(多好啊，你看vue不也乐呵呵的在使用嘛，话说这里好想吐个槽：很明显了你们这些英语负八级的渣渣啊~找啥接口啊放弃react到vue，vue对比react最大优势明明是中文文档好啊有木有！毕竟是中国人做的啊！ps: 致敬尤大佬)。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单向数据流除了单向之外还有怎样的限制&quot;&gt;单向数据流除了单向之外还有怎样的限制？&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    其实react中的单向数据流，完整概念应该是： 数据的流向只能通过props由外层到内层 一层一层往里传递。
    只能通过props一层一层往里传递这样的限制啊……不可能的，考虑到项目复杂度，组件层级过高，这个我们真不能接受啊。
    react想了想，是啊不能太狠毒，限制过大万一没人用岂不是尴尬了？于是加上了context这个玩意，方便我们进行组件间的隔代通信。
  ![](https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190311233724579-784747102.png)
     但react也是要面子的，完事还告诉我们：这玩意轻易不要用啊，危险啊这家伙，慎重使用啊小伙子们！
   靠，君不见react-redux中的Provider组件，源码就是简单的用了context加上个插槽(children)就完事了啊…整个组件源码就八九行啊，我闭着眼都能封装给你看有木有啊喂！
   所以说只要是放在正式版本中的api，我们都可以大胆的去使用，当然，前提是最好得知道它的核心原理甚至源码的封装，避免太花哨的操作引起不必要的八阿哥。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;单向数据流的简单实现&quot;&gt;单向数据流的简单实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   实则单向数据流也是最符合js编程者编程习惯的规范。这个要从组件的本质说起。
   类组件的本质，是类，类的本质，是函数;   函数组件的本质也是函数。
   那么，组件的本质=&amp;gt;函数。
   是的，那么组件嵌套组件实例这种方式，像不像函数嵌套函数实例化对象？
  可不就是嘛！我们思考下面的原生js代码：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        function child(props){
            this.props = props
        }
       function parent(props){ 
               this.props = props              
               this.state = '这是父函数的一个状态'
               this.childNodes  = new child(this.state); 
        }
       console.log(new parent('这是一个属性'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（别那么懒，f12一下，复制代码到控制台里运行一下~）&lt;br/&gt;运行以上代码，你会发现——oh my god！&lt;br/&gt;我们干了什么？难道我们用原生js如此轻易的实现了react吗？&lt;br/&gt;原来单向数据流通过props的实现不就这么点事吗…(一脸懵b)&lt;br/&gt;于是赶紧对比react的组件代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       class Child extends React.Component{
            state = {
                  ...this.props
             }, 
            render(){
                return &amp;lt;div&amp;gt;我是Child组件&amp;lt;/div&amp;gt;
            }
        }
       class Parent extends React.Component{
            state = {
                data: '这是父组件的状态'
             }, 
            render(){
                return &amp;lt;Child data = {this.state.data}  /&amp;gt;
            }
        }
    console.log(&amp;lt;Parent data='这是一个属性'  /&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迫不及待的在react环境中运行了上述代码,发现：&lt;br/&gt;我靠！！！原来父子组件就这么回儿事啊…啥底层啊啥原理啊是个前端都能理解啊~~~&lt;br/&gt;我靠！！！这不单向难道还双向吗？？必然单向啊。。。双向那不是极度耦合加内存泄漏了吗(我中有你你中有我，内存永远不会释放。这个问题其实牵扯到一个究极面试题，如何实现双向信息传递的同时不会内存泄漏且松耦合)~&lt;br/&gt;…事实就这么简单粗暴啊…不信你看看Vue和Angular，他们也在点头啊…&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  就单向数据流的概念这个问题，在清晰的给出概念给面试官后，一定要结合react的严谨性去做个解释，后面讲讲单向数据流的传递方式props和context，这道题基本已经不需要再讲了。(你满分了，别讲了，再讲你讲讲源码吧)
  然而，一般来讲，在你讲完单向数据流的概念后，心机的面试官立马会问你下一个问题： 
  react既然规定了单向数据流， 那么如何在react中实现逆向通信？（子组件向父组件方向通信）
  这个问题，我们留到下一篇做个讲解。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 11 Mar 2019 15:20:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>react面试题之单向数据流</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10513571.html</dc:identifier>
</item>
<item>
<title>MySQL Binlog 解析工具 Maxwell 详解 - whirlys</title>
<link>http://www.cnblogs.com/whirly/p/10513868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whirly/p/10513868.html</guid>
<description>&lt;h3 id=&quot;maxwell-简介&quot;&gt;maxwell 简介&lt;/h3&gt;
&lt;p&gt;Maxwell是一个能实时读取MySQL二进制日志binlog，并生成 JSON 格式的消息，作为生产者发送给 Kafka，Kinesis、RabbitMQ、Redis、Google Cloud Pub/Sub、文件或其它平台的应用程序。它的常见应用场景有ETL、维护缓存、收集表级别的dml指标、增量到搜索引擎、数据分区迁移、切库binlog回滚方案等。官网(http://maxwells-daemon.io)、GitHub(https://github.com/zendesk/maxwell)&lt;/p&gt;
&lt;p&gt;Maxwell主要提供了下列功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持 &lt;code&gt;SELECT * FROM table&lt;/code&gt; 的方式进行全量数据初始化&lt;/li&gt;
&lt;li&gt;支持在主库发生failover后，自动恢复binlog位置(GTID)&lt;/li&gt;
&lt;li&gt;可以对数据进行分区，解决数据倾斜问题，发送到kafka的数据支持database、table、column等级别的数据分区&lt;/li&gt;
&lt;li&gt;工作方式是伪装为Slave，接收binlog events，然后根据schemas信息拼装，可以接受ddl、xid、row等各种event&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了Maxwell外，目前常用的MySQL Binlog解析工具主要有阿里的canal、mysql_streamer，三个工具对比如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190310_163023.png&quot; alt=&quot;canal、maxwell、mysql_streamer对比&quot;/&gt;&lt;/p&gt;
&lt;p&gt;canal 由Java开发，分为服务端和客户端，拥有众多的衍生应用，性能稳定，功能强大；canal 需要自己编写客户端来消费canal解析到的数据。&lt;/p&gt;
&lt;p&gt;maxwell相对于canal的优势是使用简单，它直接将数据变更输出为json字符串，不需要再编写客户端。&lt;/p&gt;
&lt;h4 id=&quot;快速开始&quot;&gt;快速开始&lt;/h4&gt;
&lt;p&gt;首先MySQL需要先启用binlog，关于什么是MySQL binlog，可以参考文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483875&amp;amp;idx=1&amp;amp;sn=2cdc232fa3036da52a826964996506a8&amp;amp;chksm=e9c2edeedeb564f891b34ef1e47418bbe6b8cb6dcb7f48b5fa73b15cf1d63172df1a173c75d0&amp;amp;scene=0&amp;amp;xtrack=1&amp;amp;key=e3977f8a79490c6345befb88d0bbf74cbdc6b508a52e61ea076c830a5b64c552def6c6ad848d4bcc7a1d21e53e30eb5c1ead33acdb97df779d0e6fa8a0fbe4bda32c04077ea0d3511bc9f9490ad0b46c&amp;amp;ascene=1&amp;amp;uin=MjI4MTc0ODEwOQ%3D%3D&amp;amp;devicetype=Windows+7&amp;amp;version=62060719&amp;amp;lang=zh_CN&amp;amp;pass_ticket=h8jyrQ71hQc872LxydZS%2F3aU1JXFbp4raQ1KvY908BcKBeSBtXFgBY9IS9ZaLEDi&quot;&gt;MySQL Binlog 介绍&lt;/a&gt;》&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ vi my.cnf

[mysqld]
server_id=1
log-bin=master
binlog_format=row&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建Maxwell用户，并赋予 maxwell 库的一些权限&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE USER 'maxwell'@'%' IDENTIFIED BY '123456';
GRANT ALL ON maxwell.* TO 'maxwell'@'%';
GRANT SELECT, REPLICATION CLIENT, REPLICATION SLAVE on *.* to 'maxwell'@'%'; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 maxwell 之前需要先启动 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.1.0/kafka_2.11-2.1.0.tgz
tar -xzf kafka_2.11-2.1.0.tgz
cd kafka_2.11-2.1.0
# 启动Zookeeper
bin/zookeeper-server-start.sh config/zookeeper.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单机启动 kafka 之前，需要修改一下配置文件，打开配置文件 &lt;code&gt;vi config/server.properties&lt;/code&gt;，在文件最后加入 &lt;code&gt;advertised.host.name&lt;/code&gt; 的配置，值为 kafka 所在机器的IP&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;advertised.host.name=10.100.97.246&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不然后面通过 docker 启动 maxwell 将会报异常（其中的 hadoop2 是我的主机名）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;17:45:21,446 DEBUG NetworkClient - [Producer clientId=producer-1] Error connecting to node hadoop2:9092 (id: 0 rack: null)
java.io.IOException: Can't resolve address: hadoop2:9092
        at org.apache.kafka.common.network.Selector.connect(Selector.java:217) ~[kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:793) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.NetworkClient.ready(NetworkClient.java:230) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.sendProducerData(Sender.java:263) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:238) [kafka-clients-1.0.0.jar:?]
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:176) [kafka-clients-1.0.0.jar:?]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_181]
Caused by: java.nio.channels.UnresolvedAddressException
        at sun.nio.ch.Net.checkAddress(Net.java:101) ~[?:1.8.0_181]
        at sun.nio.ch.SocketChannelImpl.connect(SocketChannelImpl.java:622) ~[?:1.8.0_181]
        at org.apache.kafka.common.network.Selector.connect(Selector.java:214) ~[kafka-clients-1.0.0.jar:?]
        ... 6 more&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着可以启动 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-server-start.sh config/server.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试 kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建一个 topic
bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test

# 列出所有 topic
bin/kafka-topics.sh --list --zookeeper localhost:2181

# 启动一个生产者，然后随意发送一些消息
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test
This is a message
This is another message

# 在另一个终端启动一下消费者，观察所消费的消息
bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
This is a message
This is another message&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 docker 快速安装并使用 Maxwell （当然之前需要自行安装 docker）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 拉取镜像 
docker pull zendesk/maxwell

# 启动maxwell，并将解析出的binlog输出到控制台
docker run -ti --rm zendesk/maxwell bin/maxwell --user='maxwell' --password='123456' --host='10.100.97.246' --producer=stdout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试Maxwell，首先创建一张简单的表，然后增改删数据&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `test` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 
insert into test values(1,22,&quot;小旋锋&quot;);
update test set name='whirly' where id=1;
delete from test where id=1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察docker控制台的输出，从输出的日志中可以看出Maxwell解析出的binlog的JSON字符串的格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;insert&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:832,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;小旋锋&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;update&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:833,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;whirly&quot;},&quot;old&quot;:{&quot;name&quot;:&quot;小旋锋&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;delete&quot;,&quot;ts&quot;:1552153502,&quot;xid&quot;:834,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:22,&quot;name&quot;:&quot;whirly&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出到 Kafka，关闭 docker，重新设置启动参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm zendesk/maxwell bin/maxwell --user='maxwell' \
    --password='123456' --host='10.100.97.246' --producer=kafka \
    --kafka.bootstrap.servers='10.100.97.246:9092' --kafka_topic=maxwell --log_level=debug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后启动一个消费者来消费 maxwell topic的消息，观察其输出；再一次执行增改删数据的SQL，仍然可以得到相同的输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出json字符串的格式&quot;&gt;输出JSON字符串的格式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;data 最新的数据，修改后的数据&lt;/li&gt;
&lt;li&gt;old 旧数据，修改前的数据&lt;/li&gt;
&lt;li&gt;type 操作类型，有insert, update, delete, database-create, database-alter, database-drop, table-create, table-alter, table-drop，bootstrap-insert，int(未知类型)&lt;/li&gt;
&lt;li&gt;xid 事务id&lt;/li&gt;
&lt;li&gt;commit 同一个xid代表同一个事务，事务的最后一条语句会有commit，可以利用这个重现事务&lt;/li&gt;
&lt;li&gt;server_id&lt;/li&gt;
&lt;li&gt;thread_id&lt;/li&gt;
&lt;li&gt;运行程序时添加参数--output_ddl，可以捕捉到ddl语句&lt;/li&gt;
&lt;li&gt;datetime列会输出为&quot;YYYY-MM-DD hh:mm:ss&quot;，如果遇到&quot;0000-00-00 00:00:00&quot;会原样输出&lt;/li&gt;
&lt;li&gt;maxwell支持多种编码，但仅输出utf8编码&lt;/li&gt;
&lt;li&gt;maxwell的TIMESTAMP总是作为UTC处理，如果要调整为自己的时区，需要在后端逻辑上进行处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与输出格式相关的配置如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_binlog_position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 binlog position&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_gtid_position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 gtid position&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_commit_info&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 commit and xid&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_xoffset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 virtual tx-row offset&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_nulls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含值为NULL的字段&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;output_server_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 server_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;output_thread_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 thread_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;output_schema_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 schema_id&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_row_query&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 INSERT/UPDATE/DELETE 语句. Mysql需要开启 &lt;code&gt;binlog_rows_query_log_events&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;output_ddl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否包含 DDL (table-alter, table-create, etc) events&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;output_null_zerodates&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否将 '0000-00-00' 转换为 null?&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;进阶使用&quot;&gt;进阶使用&lt;/h3&gt;
&lt;h4 id=&quot;基本的配置&quot;&gt;基本的配置&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;config&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;配置文件 &lt;code&gt;config.properties&lt;/code&gt; 的路径&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;log_level&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[debug | info | warn | error]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日志级别&lt;/td&gt;
&lt;td&gt;info&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;指定Maxwell实例作为守护进程到后台运行&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;env_config_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;匹配该前缀的环境变量将被视为配置值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以把Maxwell的启动参数写到一个配置文件 &lt;code&gt;config.properties&lt;/code&gt; 中，然后通过 config 选项指定，&lt;code&gt;bin/maxwell --config config.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user=maxwell
password=123456
host=10.100.97.246
producer=kafka
kafka.bootstrap.servers=10.100.97.246:9092
kafka_topic=maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mysql-配置选项&quot;&gt;mysql 配置选项&lt;/h4&gt;
&lt;p&gt;Maxwell 根据用途将 MySQL 划分为3种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;host&lt;/code&gt;：主机，建maxwell库表，存储捕获到的schema等信息
&lt;ul&gt;&lt;li&gt;主要有六张表，bootstrap用于数据初始化，schemas记录所有的binlog文件信息，databases记录了所有的数据库信息，tables记录了所有的表信息，columns记录了所有的字段信息，positions记录了读取binlog的位移信息，heartbeats记录了心跳信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replication_host&lt;/code&gt;：复制主机，Event监听，读取该主机binlog
&lt;ul&gt;&lt;li&gt;将&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;replication_host&lt;/code&gt;分开，可以避免 &lt;code&gt;replication_user&lt;/code&gt; 往生产库里写数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema_host&lt;/code&gt;：schema主机，捕获表结构schema的主机
&lt;ul&gt;&lt;li&gt;binlog里面没有字段信息，所以maxwell需要从数据库查出schema，存起来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema_host&lt;/code&gt;一般用不到，但在&lt;code&gt;binlog-proxy&lt;/code&gt;场景下就很实用。比如要将已经离线的binlog通过maxwell生成json流，于是自建一个mysql server里面没有结构，只用于发送binlog，此时表机构就可以制动从 schema_host 获取。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常，这三个主机都是同一个，&lt;code&gt;schema_host&lt;/code&gt; 只在有 &lt;code&gt;replication_host&lt;/code&gt; 的时候使用。&lt;/p&gt;
&lt;p&gt;与MySQL相关的有下列配置&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 地址&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 用户名&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql 密码&lt;/td&gt;
&lt;td&gt;(no password)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;mysql 端口 3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;jdbc_options&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;mysql jdbc connection options&lt;/td&gt;
&lt;td&gt;DEFAULT_JDBC_OPTS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for mysql cx&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_database&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;Maxwell用于维护的schema和position将使用的数据库&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;client_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;用于标识Maxwell实例的唯一字符串&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replica_server_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;LONG&lt;/td&gt;
&lt;td&gt;用于标识Maxwell实例的唯一数字&lt;/td&gt;
&lt;td&gt;6379 (see notes)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;master_recovery&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;enable experimental master recovery code&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;gtid_mode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否开启基于GTID的复制&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;recapture_schema&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;重新捕获最新的表结构(schema)，不可在 config.properties中配置&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;server to replicate from. See split server roles&lt;/td&gt;
&lt;td&gt;schema-store host&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;password on replication server&lt;/td&gt;
&lt;td&gt;(none)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;port on replication server&lt;/td&gt;
&lt;td&gt;3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;user on replication server&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication_ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for replication cx cx&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;server to capture schema from. See split server roles&lt;/td&gt;
&lt;td&gt;schema-store host&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;password on schema-capture server&lt;/td&gt;
&lt;td&gt;(none)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;port on schema-capture server&lt;/td&gt;
&lt;td&gt;3306&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;user on schema-capture server&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;schema_ssl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SSL_OPT&lt;/td&gt;
&lt;td&gt;SSL behavior for schema-capture server&lt;/td&gt;
&lt;td&gt;DISABLED&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;生产者的配置&quot;&gt;生产者的配置&lt;/h4&gt;
&lt;p&gt;仅介绍kafka，其他的生产者的配置详见官方文档。&lt;/p&gt;
&lt;p&gt;kafka是maxwell支持最完善的一个生产者，并且内置了多个版本的kafka客户端(0.8.2.2, 0.9.0.1, 0.10.0.1, 0.10.2.1 or 0.11.0.1, 1.0.0.)，默认 kafka_version=1.0.0（当前Maxwell版本1.20.0）&lt;/p&gt;
&lt;p&gt;Maxwell 会将消息投递到Kafka的Topic中，该Topic由 &lt;code&gt;kafka_topic&lt;/code&gt; 选项指定，默认值为 &lt;code&gt;maxwell&lt;/code&gt;，除了指定为静态的Topic，还可以指定为动态的，譬如 &lt;code&gt;namespace_%{database}_%{table}&lt;/code&gt;，&lt;code&gt;%{database}&lt;/code&gt; 和 &lt;code&gt;%{table}&lt;/code&gt; 将被具体的消息的 database 和 table 替换。&lt;/p&gt;
&lt;p&gt;Maxwell 读取配置时，如果配置项是以 &lt;code&gt;kafka.&lt;/code&gt; 开头，那么该配置将设置到 Kafka Producer 客户端的连接参数中去，譬如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kafka.acks = 1
kafka.compression.type = snappy
kafka.retries=5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是Maxwell通用生产者和Kafka生产者的配置参数&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;producer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PRODUCER_TYPE&lt;/td&gt;
&lt;td&gt;生产者类型&lt;/td&gt;
&lt;td&gt;stdout&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;custom_producer.factory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CLASS_NAME&lt;/td&gt;
&lt;td&gt;自定义消费者的工厂类&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;producer_ack_timeout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PRODUCER_ACK_TIMEOUT&lt;/td&gt;
&lt;td&gt;异步消费认为消息丢失的超时时间（毫秒ms）&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_by&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PARTITION_BY&lt;/td&gt;
&lt;td&gt;输入到kafka/kinesis的分区函数&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_columns&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;若按列分区，以逗号分隔的列名称&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;producer_partition_by_fallback&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;PARTITION_BY_FALLBACK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;producer_partition_by=column&lt;/code&gt;时需要，当列不存在是使用&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;ignore_producer_error&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;为false时，在kafka/kinesis发生错误时退出程序；为true时，仅记录日志 See also &lt;code&gt;dead_letter_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;kafka.bootstrap.servers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;kafka 集群列表，&lt;code&gt;HOST:PORT[,HOST:PORT]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;kafka topic&lt;/td&gt;
&lt;td&gt;maxwell&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;dead_letter_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;详见官方文档&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;KAFKA_VERSION&lt;/td&gt;
&lt;td&gt;指定maxwell的 kafka 生产者客户端版本，不可在config.properties中配置&lt;/td&gt;
&lt;td&gt;0.11.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_partition_hash&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[default | murmur3]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;选择kafka分区时使用的hash方法&lt;/td&gt;
&lt;td&gt;default&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;kafka_key_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[array | hash]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;how maxwell outputs kafka keys, either a hash or an array of hashes&lt;/td&gt;
&lt;td&gt;hash&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;ddl_kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;output_ddl&lt;/code&gt;为true时, 所有DDL的消息都将投递到该topic&lt;/td&gt;
&lt;td&gt;&lt;code&gt;kafka_topic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;过滤器配置&quot;&gt;过滤器配置&lt;/h4&gt;
&lt;p&gt;Maxwell 可以通过 &lt;code&gt;--filter&lt;/code&gt; 配置项来指定过滤规则，通过 &lt;code&gt;exclude&lt;/code&gt; 排除，通过 &lt;code&gt;include&lt;/code&gt; 包含，值可以为具体的数据库、数据表、数据列，甚至用 Javascript 来定义复杂的过滤规则；可以用正则表达式描述，有几个来自官网的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 仅匹配foodb数据库的tbl表和所有table_数字的表
--filter='exclude: foodb.*, include: foodb.tbl, include: foodb./table_\d+/'
# 排除所有库所有表，仅匹配db1数据库
--filter = 'exclude: *.*, include: db1.*'
# 排除含db.tbl.col列值为reject的所有更新
--filter = 'exclude: db.tbl.col = reject'
# 排除任何包含col_a列的更新
--filter = 'exclude: *.*.col_a = *'
# blacklist 黑名单，完全排除bad_db数据库，若要恢复，必须删除maxwell库
--filter = 'blacklist: bad_db.*' &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据初始化&quot;&gt;数据初始化&lt;/h4&gt;
&lt;p&gt;Maxwell 启动后将从maxwell库中获取上一次停止时position，从该断点处开始读取binlog。如果binlog已经清除了，那么怎样可以通过maxwell把整张表都复制出来呢？也就是数据初始化该怎么做？&lt;/p&gt;
&lt;p&gt;对整张表进行操作，人为地产生binlog？譬如找一个不影响业务的字段譬如update_time，然后加一秒，再减一秒？&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;update test set update_time = DATE_ADD(update_time,intever 1 second);
update test set update_time = DATE_ADD(update_time,intever -1 second);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样明显存在几个大问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不存在一个不重要的字段怎么办？每个字段都很重要，不能随便地修改！&lt;/li&gt;
&lt;li&gt;如果整张表很大，修改的过程耗时很长，影响了业务！&lt;/li&gt;
&lt;li&gt;将产生大量非业务的binlog！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对数据初始化的问题，Maxwell 提供了一个命令工具 &lt;code&gt;maxwell-bootstrap&lt;/code&gt; 帮助我们完成数据初始化，&lt;code&gt;maxwell-bootstrap&lt;/code&gt; 是基于 &lt;code&gt;SELECT * FROM table&lt;/code&gt; 的方式进行全量数据初始化，不会产生多余的binlog！&lt;/p&gt;
&lt;p&gt;这个工具有下面这些参数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;--log_level LOG_LEVEL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日志级别（DEBUG, INFO, WARN or ERROR）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--user USER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 用户名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--password PASSWORD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 密码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--host HOST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--port PORT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;mysql 端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;--database DATABASE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要bootstrap的表所在的数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;--table TABLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要引导的表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;--where WHERE_CLAUSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置过滤条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;--client_id CLIENT_ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定执行引导操作的Maxwell实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实验一番，下面将引导 &lt;code&gt;test&lt;/code&gt; 数据库中 &lt;code&gt;test&lt;/code&gt; 表，首先是准备几条测试用的数据&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;INSERT INTO `test` VALUES (1, 1, '1');
INSERT INTO `test` VALUES (2, 2, '2');
INSERT INTO `test` VALUES (3, 3, '3');
INSERT INTO `test` VALUES (4, 4, '4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 &lt;code&gt;reset master;&lt;/code&gt; 清空binlog，删除 maxwell 库中的表。接着使用快速开始中的命令，启动Kafka、Maxwell和Kafka消费者，然后启动 &lt;code&gt;maxwell-bootstrap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --rm zendesk/maxwell bin/maxwell-bootstrap --user maxwell  \
    --password 123456 --host 10.100.97.246  --database test --table test --client_id maxwell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;--bootstrapper=sync&lt;/code&gt; 时，在处理bootstrap时，会阻塞正常的binlog解析；&lt;code&gt;--bootstrapper=async&lt;/code&gt; 时，不会阻塞。&lt;/p&gt;
&lt;p&gt;也可以执行下面的SQL，在 &lt;code&gt;maxwell.bootstrap&lt;/code&gt; 表中插入记录，手动触发&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;insert into maxwell.bootstrap (database_name, table_name) values ('test', 'test');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以在 kafka 消费者端看见引导过来的数据了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;database&quot;:&quot;maxwell&quot;,&quot;table&quot;:&quot;bootstrap&quot;,&quot;type&quot;:&quot;insert&quot;,&quot;ts&quot;:1552199115,&quot;xid&quot;:36738,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:3,&quot;database_name&quot;:&quot;test&quot;,&quot;table_name&quot;:&quot;test&quot;,&quot;where_clause&quot;:null,&quot;is_complete&quot;:0,&quot;inserted_rows&quot;:0,&quot;total_rows&quot;:0,&quot;created_at&quot;:null,&quot;started_at&quot;:null,&quot;completed_at&quot;:null,&quot;binlog_file&quot;:null,&quot;binlog_position&quot;:0,&quot;client_id&quot;:&quot;maxwell&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-start&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:1,&quot;age&quot;:1,&quot;name&quot;:&quot;1&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:2,&quot;age&quot;:2,&quot;name&quot;:&quot;2&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:3,&quot;age&quot;:3,&quot;name&quot;:&quot;3&quot;}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-insert&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{&quot;id&quot;:4,&quot;age&quot;:4,&quot;name&quot;:&quot;4&quot;}}
{&quot;database&quot;:&quot;maxwell&quot;,&quot;table&quot;:&quot;bootstrap&quot;,&quot;type&quot;:&quot;update&quot;,&quot;ts&quot;:1552199115,&quot;xid&quot;:36756,&quot;commit&quot;:true,&quot;data&quot;:{&quot;id&quot;:3,&quot;database_name&quot;:&quot;test&quot;,&quot;table_name&quot;:&quot;test&quot;,&quot;where_clause&quot;:null,&quot;is_complete&quot;:1,&quot;inserted_rows&quot;:4,&quot;total_rows&quot;:0,&quot;created_at&quot;:null,&quot;started_at&quot;:&quot;2019-03-10 14:25:15&quot;,&quot;completed_at&quot;:&quot;2019-03-10 14:25:15&quot;,&quot;binlog_file&quot;:&quot;mysql-bin.000001&quot;,&quot;binlog_position&quot;:64446,&quot;client_id&quot;:&quot;maxwell&quot;},&quot;old&quot;:{&quot;is_complete&quot;:0,&quot;inserted_rows&quot;:1,&quot;completed_at&quot;:null}}
{&quot;database&quot;:&quot;test&quot;,&quot;table&quot;:&quot;test&quot;,&quot;type&quot;:&quot;bootstrap-complete&quot;,&quot;ts&quot;:1552199115,&quot;data&quot;:{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间的4条便是 &lt;code&gt;test.test&lt;/code&gt; 的binlog数据了，注意这里的 type 是 &lt;code&gt;bootstrap-insert&lt;/code&gt;，而不是 &lt;code&gt;insert&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后再一次查看binlog，&lt;code&gt;show binlog events;&lt;/code&gt;，会发现只有与 &lt;code&gt;maxwell&lt;/code&gt; 相关的binlog，并没有 &lt;code&gt;test.test&lt;/code&gt; 相关的binlog，所以 &lt;code&gt;maxwell-bootstrap&lt;/code&gt; 命令并不会产生多余的 binlog，当数据表的数量很大时，这个好处会更加明显&lt;/p&gt;
&lt;p&gt;Bootstrap 的过程是 &lt;code&gt;bootstrap-start -&amp;gt; bootstrap-insert -&amp;gt; bootstrap-complete&lt;/code&gt;，其中，start和complete的data字段为空，不携带数据。&lt;/p&gt;
&lt;p&gt;在进行bootstrap过程中，如果maxwell崩溃，重启时，bootstrap会完全重新开始，不管之前进行到多少，若不希望这样，可以到数据库中设置 &lt;code&gt;is_complete&lt;/code&gt; 字段值为1(表示完成)，或者删除该行&lt;/p&gt;
&lt;h4 id=&quot;maxwell监控&quot;&gt;Maxwell监控&lt;/h4&gt;
&lt;p&gt;Maxwell 提供了 &lt;code&gt;base logging mechanism, JMX, HTTP or by push to Datadog&lt;/code&gt; 这四种监控方式，与监控相关的配置项有下列这些：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;指标的前缀&lt;/td&gt;
&lt;td&gt;MaxwellMetrics&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[slf4j | jmx | http | datadog]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;发布指标的方式&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_jvm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;是否收集JVM信息&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_slf4j_interval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SECONDS&lt;/td&gt;
&lt;td&gt;将指标记录到日志的频率，&lt;code&gt;metrics_type&lt;/code&gt;须配置为slf4j&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;为http时，发布指标绑定的端口&lt;/td&gt;
&lt;td&gt;8080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;http_path_prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;http的路径前缀&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_bind_address&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;http发布指标绑定的地址&lt;/td&gt;
&lt;td&gt;all addresses&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_diagnostic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BOOLEAN&lt;/td&gt;
&lt;td&gt;http是否开启diagnostic后缀&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;http_diagnostic_timeout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;MILLISECONDS&lt;/td&gt;
&lt;td&gt;http diagnostic 响应超时时间&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[udp | http]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;metrics_type&lt;/code&gt;为datadog时发布指标的方式&lt;/td&gt;
&lt;td&gt;udp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;提供给 datadog 的标签，如 tag1:value1,tag2:value2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_interval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;推指标到datadog的频率，单位秒&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_apikey&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当 &lt;code&gt;metrics_datadog_type=http&lt;/code&gt; 时datadog用的api key&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_host&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;STRING&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;metrics_datadog_type=udp&lt;/code&gt;时推指标的目标地址&lt;/td&gt;
&lt;td&gt;localhost&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics_datadog_port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;当&lt;code&gt;metrics_datadog_type=udp&lt;/code&gt; 时推指标的端口&lt;/td&gt;
&lt;td&gt;8125&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体可以得到哪些监控指标呢？有如下，注意所有指标都预先配置了指标前缀 &lt;code&gt;metrics_prefix&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.succeeded&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;成功发送到kafka的消息数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.failed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;发送失败的消息数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;row.count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Counters&lt;/td&gt;
&lt;td&gt;已处理的binlog行数，注意并非所有binlog都发往kafka&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.succeeded.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;消息成功发送到Kafka的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;messages.failed.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;消息发送失败到kafka的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;row.meter&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Meters&lt;/td&gt;
&lt;td&gt;行(row)从binlog连接器到达maxwell的速率&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication.lag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gauges&lt;/td&gt;
&lt;td&gt;从数据库事务提交到Maxwell处理该事务之间所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;inflightmessages.count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gauges&lt;/td&gt;
&lt;td&gt;当前正在处理的消息数（等待来自目的地的确认，或在消息之前）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;message.publish.time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;向kafka发送record所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;message.publish.age&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;从数据库产生事件到发送到Kafka之间的时间（毫秒），精确度为+/-500ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;replication.queue.time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Timers&lt;/td&gt;
&lt;td&gt;将一个binlog事件送到处理队列所用的时间（毫秒）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上述有些指标为kafka特有的，并不支持所有的生产者。&lt;/p&gt;
&lt;p&gt;实验一番，通过 http 方式获取监控指标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -p 8080:8080 -it --rm zendesk/maxwell bin/maxwell --user='maxwell' \
    --password='123456' --host='10.100.97.246' --producer=kafka \
    --kafka.bootstrap.servers='10.100.97.246:9092' --kafka_topic=maxwell --log_level=debug \
    --metrics_type=http  --metrics_jvm=true --http_port=8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置大部分与前面的相同，不同的有 &lt;code&gt;-p 8080:8080&lt;/code&gt; docker端口映射，以及 &lt;code&gt;--metrics_type=http --metrics_jvm=true --http_port=8080&lt;/code&gt;，配置了通过http方式发布指标，启用收集JVM信息，端口为8080，之后可以通过 &lt;code&gt;http://10.100.97.246:8080/metrics&lt;/code&gt; 便可获取所有的指标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190310_234508.png&quot; alt=&quot;Maxwell监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http 方式有四种后缀，分别对应四种不同的格式&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/metrics&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有指标以JSON格式返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;/prometheus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有指标以Prometheus格式返回（Prometheus是一套开源的监控&amp;amp;报警&amp;amp;时间序列数据库的组合）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/healthcheck&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回Maxwell过去15分钟是否健康&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;/ping&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单的测试，返回 &lt;code&gt;pong&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果是通过 JMX 的方式收集Maxwell监控指标，可以 &lt;code&gt;JAVA_OPTS&lt;/code&gt; 环境变量配置JMX访问权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_OPTS=&quot;-Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.port=9010 \
-Dcom.sun.management.jmxremote.local.only=false \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-Djava.rmi.server.hostname=10.100.97.246&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;多个maxwell实例&quot;&gt;多个Maxwell实例&lt;/h4&gt;
&lt;p&gt;在不同的配置下，Maxwell可以在同一个主服务器上运行多个实例。如果希望让生产者以不同的配置运行，例如将来自不同组的表(table)的事件投递到不同的Topic中，这将非常有用。Maxwell的每个实例都必须配置一个唯一的client_id，以便区分的binlog位置。&lt;/p&gt;
&lt;h4 id=&quot;gtid-支持&quot;&gt;GTID 支持&lt;/h4&gt;
&lt;p&gt;Maxwell 从1.8.0版本开始支持基于GTID的复制(&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/replication-gtids.html&quot;&gt;GTID-based replication&lt;/a&gt;)，在GTID模式下，Maxwell将在主机更改后透明地选择新的复制位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是GTID Replication？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GTID (Global Transaction ID) 是对于一个已提交事务的编号，并且是一个全局唯一的编号。&lt;/p&gt;
&lt;p&gt;从 MySQL 5.6.5 开始新增了一种基于 GTID 的复制方式。通过 GTID 保证了每个在主库上提交的事务在集群中有一个唯一的ID。这种方式强化了数据库的主备一致性，故障恢复以及容错能力。&lt;/p&gt;
&lt;p&gt;在原来基于二进制日志的复制中，从库需要告知主库要从哪个偏移量进行增量同步，如果指定错误会造成数据的遗漏，从而造成数据的不一致。借助GTID，在发生主备切换的情况下，MySQL的其它从库可以自动在新主库上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制位置发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务，减少了数据发生不一致的风险。&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;h4 id=&quot;timestamp-column&quot;&gt;timestamp column&lt;/h4&gt;
&lt;p&gt;maxwell对时间类型（datetime, timestamp, date）都是&lt;strong&gt;当做字符串处理&lt;/strong&gt;的，这也是为了保证数据一致(比如&lt;code&gt;0000-00-00 00:00:00&lt;/code&gt;这样的时间在timestamp里是非法的，但mysql却认，解析成java或者python类型就是null/None)。&lt;/p&gt;
&lt;p&gt;如果MySQL表上的字段是 timestamp 类型，是有时区的概念，&lt;strong&gt;binlog解析出来的是标准UTC时间&lt;/strong&gt;，但用户看到的是本地时间。比如 &lt;code&gt;f_create_time timestamp&lt;/code&gt; 创建时间是北京时间 &lt;code&gt;2018-01-05 21:01:01&lt;/code&gt;，那么mysql实际存储的是 &lt;code&gt;2018-01-05 13:01:01&lt;/code&gt;，binlog里面也是这个时间字符串。如果不做消费者不做时区转换，会少8个小时。&lt;/p&gt;
&lt;p&gt;与其每个客户端都要考虑这个问题，我觉得更合理的做法是提供时区参数，然后maxwell自动处理时区问题，否则要么客户端先需要知道哪些列是timestamp类型，或者连接上原库缓存上这些类型。&lt;/p&gt;
&lt;h4 id=&quot;binary-column&quot;&gt;binary column&lt;/h4&gt;
&lt;p&gt;maxwell可以处理binary类型的列，如blob、varbinary，它的做法就是对二进制列使用 &lt;code&gt;base64_encode&lt;/code&gt;，当做字符串输出到json。消费者拿到这个列数据后，不能直接拼装，需要 &lt;code&gt;base64_decode&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;表结构不同步&quot;&gt;表结构不同步&lt;/h4&gt;
&lt;p&gt;如果是拿比较老的binlog，放到新的mysql server上去用maxwell拉去，有可能表结构已经发生了变化，比如binlog里面字段比 &lt;code&gt;schema_host&lt;/code&gt; 里面的字段多一个。目前这种情况没有发现异常，比如阿里RDS默认会为 无主键无唯一索引的表，增加一个&lt;code&gt;__##alibaba_rds_rowid##__&lt;/code&gt;，在 &lt;code&gt;show create table&lt;/code&gt; 和 &lt;code&gt;schema&lt;/code&gt; 里面都看不到这个隐藏主键，但binlog里面会有，同步到从库。&lt;/p&gt;
&lt;p&gt;另外我们有通过git去管理结构版本，如果真有这种场景，也可以应对。&lt;/p&gt;
&lt;h4 id=&quot;大事务binlog&quot;&gt;大事务binlog&lt;/h4&gt;
&lt;p&gt;当一个事物产生的binlog量非常大的时候，比如迁移日表数据，maxwell为了控制内存使用，会自动将处理不过来的binlog放到文件系统&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using kafka version: 0.11.0.1
21:16:07,109 WARN  MaxwellMetrics - Metrics will not be exposed: metricsReportingType not configured.
21:16:07,380 INFO  SchemaStoreSchema - Creating maxwell database
21:16:07,540 INFO  Maxwell - Maxwell v?? is booting (RabbitmqProducer), starting at Position[BinlogPosition[mysql-bin.006235:24980714],
lastHeartbeat=0]
21:16:07,649 INFO  AbstractSchemaStore - Maxwell is capturing initial schema
21:16:08,267 INFO  BinlogConnectorReplicator - Setting initial binlog pos to: mysql-bin.006235:24980714
21:16:08,324 INFO  BinaryLogClient - Connected to rm-xxxxxxxxxxx.mysql.rds.aliyuncs.com:3306 at mysql-bin.006235/24980714 (sid:637
9, cid:9182598)
21:16:08,325 INFO  BinlogConnectorLifecycleListener - Binlog connected.
03:15:36,104 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell7935334910787514257events
03:17:14,880 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell3143086481692829045events&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是遇到另外一个问题，overflow随后就出现异常 &lt;code&gt;EventDataDeserializationException: Failed to deserialize data of EventHeaderV4&lt;/code&gt;，当我另起一个maxwell指点之前的binlog postion开始解析，却有没有抛异常。事后的数据也表明并没有数据丢失。&lt;/p&gt;
&lt;p&gt;问题产生的原因还不明，&lt;code&gt;Caused by: java.net.SocketException: Connection reset&lt;/code&gt;，感觉像读取 binlog 流的时候还没读取到完整的event，异常关闭了连接。这个问题比较顽固，github上面类似问题都没有达到明确的解决。（这也从侧面告诉我们，大表数据迁移，也要批量进行，不要一个&lt;code&gt;insert into .. select&lt;/code&gt; 搞定）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;03:18:20,586 INFO  ListWithDiskBuffer - Overflowed in-memory buffer, spilling over into /tmp/maxwell5229190074667071141events
03:19:31,289 WARN  BinlogConnectorLifecycleListener - Communication failure.
com.github.shyiko.mysql.binlog.event.deserialization.EventDataDeserializationException: Failed to deserialize data of EventHeaderV4{time
stamp=1514920657000, eventType=WRITE_ROWS, serverId=2115082720, headerLength=19, dataLength=8155, nextPosition=520539918, flags=0}
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.deserializeEventData(EventDeserializer.java:216) ~[mys
ql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.nextEvent(EventDeserializer.java:184) ~[mysql-binlog-c
onnector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:890) [mysql-binlog-connector-java-0
.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:559) [mysql-binlog-connector-java-0.13.0.jar:0.13
.0]
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:793) [mysql-binlog-connector-java-0.13.0.jar:0.13.0
]
        at java.lang.Thread.run(Thread.java:745) [?:1.8.0_121]
Caused by: java.net.SocketException: Connection reset
        at java.net.SocketInputStream.read(SocketInputStream.java:210) ~[?:1.8.0_121]
        at java.net.SocketInputStream.read(SocketInputStream.java:141) ~[?:1.8.0_121]
        at com.github.shyiko.mysql.binlog.io.BufferedSocketInputStream.read(BufferedSocketInputStream.java:51) ~[mysql-binlog-connector-
java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.readWithinBlockBoundaries(ByteArrayInputStream.java:202) ~[mysql-binlo
g-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.read(ByteArrayInputStream.java:184) ~[mysql-binlog-connector-java-0.13
.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.io.ByteArrayInputStream.readInteger(ByteArrayInputStream.java:46) ~[mysql-binlog-connector-jav
a-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeLong(AbstractRowsEventDataD
eserializer.java:212) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeCell(AbstractRowsEventDataD
eserializer.java:150) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.deserializeRow(AbstractRowsEventDataDeserializer.java:132) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserializeRows(WriteRowsEventDataDeserializer.java:64) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserialize(WriteRowsEventDataDeserializer.java:56) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.WriteRowsEventDataDeserializer.deserialize(WriteRowsEventDataDeserializer.java:32) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        at com.github.shyiko.mysql.binlog.event.deserialization.EventDeserializer.deserializeEventData(EventDeserializer.java:210) ~[mysql-binlog-connector-java-0.13.0.jar:0.13.0]
        ... 5 more
03:19:31,514 INFO  BinlogConnectorLifecycleListener - Binlog disconnected.
03:19:31,590 WARN  BinlogConnectorReplicator - replicator stopped at position: mysql-bin.006236:520531744 -- restarting
03:19:31,595 INFO  BinaryLogClient - Connected to rm-xxxxxx.mysql.rds.aliyuncs.com:3306 at mysql-bin.006236/520531744 (sid:6379, cid:9220521)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tablemapcache&quot;&gt;tableMapCache&lt;/h4&gt;
&lt;p&gt;前面讲过，如果我只想获取某几个表的binlog变更，需要用 include_tables 来过滤，但如果mysql server上现在删了一个表t1，但我的binlog是从昨天开始读取，被删的那个表t1在maxwell启动的时候是拉取不到表结构的。然后昨天的binlog里面有 t1 的变更，因为找不到表结构给来组装成json，会抛异常。&lt;/p&gt;
&lt;p&gt;手动在 &lt;code&gt;maxwell.tables/columns&lt;/code&gt; 里面插入记录是可行的。但这个问题的根本是，maxwell在binlog过滤的时候，只在处理row_event的时候，而对 tableMapCache 要求binlog里面的所有表都要有。&lt;/p&gt;
&lt;p&gt;自己（seanlook）提交了一个commit，可以在做 tableMapCache 的时候也仅要求缓存 include_dbs/tables 这些表： https://github.com/seanlook/maxwell/commit/2618b70303078bf910a1981b69943cca75ee04fb&lt;/p&gt;
&lt;h4 id=&quot;提高消费性能&quot;&gt;提高消费性能&lt;/h4&gt;
&lt;p&gt;在用rabbitmq时，&lt;code&gt;routing_key&lt;/code&gt; 是 &lt;code&gt;%db%.%table%&lt;/code&gt;，但某些表产生的binlog增量非常大，就会导致各队列消息量很不平均，目前因为还没做到事务xid或者thread_id级别的并发回放，所以最小队列粒度也是表，尽量单独放一个队列，其它数据量小的合在一起。&lt;/p&gt;
&lt;h4 id=&quot;binlog&quot;&gt;binlog&lt;/h4&gt;
&lt;p&gt;Maxwell 在 maxwell 库中维护了 binlog 的位移等信息，由于一些原因譬如 &lt;code&gt;reset master;&lt;/code&gt;，导致 maxwell 库中的记录与实际的binlog对不上，这时将报异常，这是可以手动修正binlog位移或者直接清空/删除 maxwell 库重建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.github.shyiko.mysql.binlog.network.ServerException: Could not find first log file name in binary log index file
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:885)
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:564)
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:796)
        at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.github.shyiko.mysql.binlog.network.ServerException: A slave with the same server_uuid/server_id as this slave has connected to the master; the first event 'mysql-bin.000001' at 760357, the last event read from './mysql-bin.000001' at 1888540, the last byte read from './mysql-bin.000001' at 1888540.
        at com.github.shyiko.mysql.binlog.BinaryLogClient.listenForEventPackets(BinaryLogClient.java:885)
        at com.github.shyiko.mysql.binlog.BinaryLogClient.connect(BinaryLogClient.java:564)
        at com.github.shyiko.mysql.binlog.BinaryLogClient$7.run(BinaryLogClient.java:796)
        at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参考文档&quot;&gt;参考文档&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190116_014816.png&quot; alt=&quot;关注_小旋锋_微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 15:00:00 +0000</pubDate>
<dc:creator>whirlys</dc:creator>
<og:description>maxwell 简介 Maxwell是一个能实时读取MySQL二进制日志binlog，并生成 JSON 格式的消息，作为生产者发送给 Kafka，Kinesis、RabbitMQ、Redis、Goog</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whirly/p/10513868.html</dc:identifier>
</item>
<item>
<title>软件工程真的是一门什么用都没有的学科么？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10513847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10513847.html</guid>
<description>&lt;p&gt;软件工程真的是一门什么用都没有的学科么？&lt;/p&gt;
&lt;p&gt;-----读《构建之法》有感&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我很惭愧，构建之法这本书已经出版四五年了，我之前却未曾涉猎，还是在通过组织长沙.net技术社区之后，才因为因缘际遇有幸认识邹欣邹老师之后，才了解和阅读了这本书。这是一本非常不错的软件工程学著作，事实上应该值得IT企业中不同岗位的从业者都来读，而不仅仅只是软件工程师或软件设计师来读。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;回到10多年前，当时我有幸就读于位于湖南湘中小城娄底的人文科技学院，那是湖南众多二本院校中排名较后的普通学府，并且我就读的专业是数学系下的学科，信息与计算科学专业，这是一个数学和计算机的边缘学科。事实上呢，其实当时班上绝大多数人都是调剂生，我是为数不多的一志愿录取吧，因为对计算机感兴趣，高中数学成绩太差，想在进一步学习数学才选了这个专业，当然，实际上入学后我的数学成绩依然很差，这就是后话了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;由于这个专业的教授队伍本身就是数学教授为主，因此开设了许多数学加计算机的课程，那些数学课程令我头大，屡屡挂科，但是那些计算机学科的课程却令我痴迷，并最终让我选择了IT行业，并在这条道路上已经迈过来十个年头，甚至已经决定把他当做终生职业来奋斗。这些课程中，包括了软件工程，当时使用的教材来自于清华大学，那本在我这种阅读爱好者看来浅显易懂的软件工程基础书，在我的同学眼中却仿佛看天书。在书中，作者以比较容易理解的角度简单介绍了软件工程的前因后果和本质，让我觉得如获至宝，经常手不释卷，一直到大学毕业后三年，我都保留了这本书，并时常翻阅。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不知不觉从业十年，再回过头来看这门学科，我觉得我有了不同的体会。软件工程究竟是什么？应该说时至今日，许多资深从业者都不能理解，这也证明为什么有的院校的软件工程课，最终应学生的要求改成了学习JAVA视频教学的原因吧。作为一名十年经验的开发者，我不打算引用原文中的话来说明究竟什么是软件工程，而是说一下自己的理解，我认为软件工程实际上定义了IT公司的管理流程，设计理念，企业架构的方方面面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这个知识大爆炸的时代，计算机领域的书籍非常多，大部分都是偏重于介绍开发者技能提高的书籍，大概可以称为技能书，通过阅读这些技能书，开发者只需花较短的时间就能快速的掌握作者多年学习的收获，并快速的成长，进而实现自己收入的大幅度提高。软件工程所介绍的内容，在某些读者眼里，看起来就像天书昏昏欲睡，尤其是那些UML图和设计理念，在某些开发者眼里认为，就是浪费公司的人力财力和时间，于是有人说软件工程其实什么用都没有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;我觉得软件工程更像是心法，技术不好的时候，心法通则技术通，技术好了，更需要读心法，这样可以让你的念头通达，格局透彻。软件工程，或许并不像一门工程学，更像两种东西的融合，一个是软件管理学，一个是软件设计学，更像是从更高的维度来看待软件和软件公司的全生命周期，又从更微观的角度来介绍如何优雅的设计一个软件。这也大概是邹老师的杰作，《构建之法》的标题，取的是构建，而不是架构的原因吧。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;构建是什么？在最开始听到这个名词时，我以为是build，我甚至觉得构建一个软件，不就是开发集成环境中的一个按钮么？难道这本书谈的是编译原理？然而我错了，这本书实际上是build一套企业管理制度和文化，build一套切实可行的软件技术体系，正是讲述如何优雅的build一家能够持久生存的IT公司，用现在的主流说法，就是打造优秀IT企业的最佳实践方法吧。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;&lt;em&gt;当然，来到9102年的今天IT公司似乎已经成为一个令人不适的名词，在大家的眼中，仿佛言不离互联网公司，似乎一家公司自称是IT公司就自降身价一般。然而，互联网公司难道不是IT公司么？留给读者们评说吧。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;说到最佳实践，目前我也在一家互联网公司，也有幸接触了一些比较大的圈子，那就是中国的MVP们，他们是微软最有价值的技术专家，这些专家们都对技术充满了无限的追求、并积累了丰富的知识体系，从他们的交流沟通过程以及我自己平时的积累，我遇到了以下几种常&lt;span&gt;见，却不一定正确的最佳实践。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;1、设计优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;互联网公司常用的模式之一，就是设计和用户体验优先，在这种理念中，认为用户体验是第一生产力，技术是第二生产力。先把面子做好，再把产品做好。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;2，架构优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;这种理念认为，软件架构体系是决定软件生死命脉的关键因素。往往容易变成架构师优先，往往会招一位优秀的架构师，然后来组建他的核心班底，再变成一家技术优先的企业。真的是最佳实践么？谁吃过苦谁自己明白。&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;3，中台优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;阿里巴巴的实践告诉我们，要重中台，轻前台，一切以业务流转为目标。但是真的是每家企业的最佳实践么？&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;strong&gt;4，数据优先&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span&gt;这种理念认为，数据是第一生产力，一切业务都是数据。在前几年的DT时代，就是这么鼓吹数据优先，然后各种大数据平台层出不穷，但是，往往做成了多数据，数据大，却很少有必要做成大数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我认为，核心理念应该依然是，构建优先，即作为一家软件公司的核心任务，应该是构建符合企业实际的管理体系。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;必须承认，在中国有许多业务优先的公司，其实并不能理解IT公司与传统公司的区别，总是用自己片面的理解认为，公司什么都缺，缺的只是一个程序员或几个程序员，但是，真的是这样么？没有，哪怕有幸被你招到了一位能独挑大梁的优秀程序员，往往也会由于与企业文化和管理理念极度的不适应而离去。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;在互联网概念已经深入人心的今天，从某种意义上讲，或许对于企业，只要掌握了合适的时机加上一些机遇，也许总是能获得成功。但是，真的能存活超过十年的时间，并保持持续的增长么？在偌大的中国，近些年以来有许多优秀的企业凭借优秀的产品获得了短期的成功，却深刻反映出中国经济发展全靠吃人口红利的客观事实。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;尤其是那些看起来短期依靠员工的创新能力获得快速发展的中小型或者独角兽企业，越是容易因为创新能力枯竭而最终内卷化。每家公司都有机会火五分钟，但是有的公司大概只能火那么几分钟。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;任何IT公司，撇开软件管理之道谈纯粹的技术实现或产品输出，或许都不过是一瞬间的爆发，越是看起来成功的优秀的互联网公司越是必须基于软件工程学的理论出发，建立一套切实可行，持续迭代的管理体系才能获得长久的生命力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;但是，哪怕有了构建之法，又该如何打破中国IT企业平均寿命不过2.8年的客观事实呢？我想我还是好好搬砖吧。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201903/191302-20190311230208110-900599403.jpg&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;304&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　插播广告，长沙.NET 技术社区已经成立，各种技术活动正火热的开展中，欢迎各地高手前来指教，公众号：DotNET技术圈（MoreDotNetCore），也可以添加微信（xuehua0602），加入社区与大家共同探讨技术。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:55:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>软件工程真的是一门什么用都没有的学科么？ 读《构建之法》有感 楔子 我很惭愧，构建之法这本书已经出版四五年了，我之前却未曾涉猎，还是在通过组织长沙.net技术社区之后，才因为因缘际遇有幸认识邹欣邹老师</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10513847.html</dc:identifier>
</item>
<item>
<title>大湾区联动:广州深圳助力东莞.NET俱乐部首次线下活动 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</guid>
<description>&lt;p&gt;新年伊始，经过一个寒冬考验后的.NET社区热情不减，长沙、南京、合肥、东莞先后建立以微信为主要平台的线上.NET社区。并相继开始筹划和组织各地区的首次线下活动。&lt;br/&gt;东莞作为粤港澳大湾区的腹地，制造业基地，沉淀了大量的.NET传统领域的开发人员。这些默默无闻，致力于为制造业提供各种信息化解决方案的.NETer 需要去被挖掘，需要和广深两城的同行一起交流，需要和大湾区所有的同行一起努力才能打造出一个实力强大且受众广泛的“大湾区.NET俱乐部”。&lt;br/&gt;120报名额度三天内报满，活动当天即使下雨依旧有高达65%的到场率，天气不良下免费活动的到场率到达这个数字真的说明东莞.NET的小伙伴儿们非常关注此次活动。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225002333-265279109.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225012798-1924290768.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;Excel催化剂作者-李伟坚，公元前（网名）作为非专业人士，非常热情和积极的去组织和筹备这次东莞的线下活动。“广州.NET微软技术俱乐部”作为大湾区.NET线下活动先行者，在本次活动中积极的协助东莞方面筹备本次活动，并且在活动当天广州俱乐部的两位主席（叶伟民，陈作）以及秘书处的两位成员（戚亚柱，郑子铭）都赶到了现场，全程参与此次活动。深圳俱乐部的主席张队（张善友）也自驾从深圳赶赴东莞现场助威，并为活动带来了礼品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225040195-233892769.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，本次活动的三个话题均来自三城社区的领袖。&lt;/p&gt;&lt;p&gt;话题一：国外.NET俱乐部经验分享 · 叶伟民 · 广州.NET俱乐部主席&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225047029-1441661723.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;话题二：.NET Core,Docker &amp;amp; Kubernetes · 张善友 · 深圳.NET俱乐部主席&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225053568-677255965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;话题三：使用.NET技术对Office软件二次开发 · 东莞.NET社区发起者 · 李伟坚&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225103457-2088585476.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;除了各位讲师精心准备的课程之外，广州俱乐部也会同东莞俱乐部在本次活动中做了活动形式上的创新。为了区别线上社区和课程，提高线下活动中参会人员的参与感，本次活动最后特意设置了分小组讨论环节。&lt;br/&gt;每小组在小组主持人带领对一个或多个话题展开讨论，以此让所有参会者都有区别于线上活动的体验。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225120286-1739007624.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;.NET 社区在2018年末的燃气的星星之火，在互联网寒冬的大背景下依然在2019年春出现了燎原之势，相信不久的将来一定会横扫神州大地，让处在每一个地方的.NETer都能够找到“组织”，都能都社区组织各种活动中学到技术，了解信息，交到朋友。&lt;/p&gt;&lt;p&gt;欢迎广州的.NETer 加入“广州.NET微软技术俱乐部”QQ群：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201903/26286-20190311225128435-323427547.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;广州.NET微软技术俱乐部秘书处撰稿&lt;br/&gt;2019-03-11&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:42:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>大湾区联动:广州深圳助力东莞.NET俱乐部首次线下活动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/guang-zhou-dot-club-event-2019-03-10.html</dc:identifier>
</item>
<item>
<title>Typescript 3.x 中常见的几种函数重载方法与应用示例 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/10513731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/10513731.html</guid>
<description>&lt;p&gt;所谓的重载，其实就是使用相同的函数名，传入不同数量的参数或不同类型的参数，以此创建出多个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 最常见的，也就是根据定义傻瓜式地判断参数类型与数量&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name, ...others) {
    console.log(name, others)
}

showPerson('tate', {age: 25, test: 'test str'})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 其次就是使用常规的重载签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用重载签名进行重载，好处在于可以对传入的参数进行限制，只有当签名存在对应类型或数量的参数时，才不会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此处定义完重载签名之后，一定要有具体实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name: string): void;
function showPerson (age: number): void;
function showPerson (play: () =&amp;gt; void): void;

function showPerson (...args) {
    console.log(args)
    // 根据函数类型和数量作出不同的行为
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重载签名配合可选参数可以使重载变得更加灵活&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function showPerson (name:string, age?: number, play?: () =&amp;gt; void): void;

// 利用重载签名 对不同的缺省做相应的处理
function showPerson (name, age, play) {
    // dosomething
}

showPerson('tate', 25)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.利用特定重载签名做更加细致的重载处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;鄙人比较喜欢NBA，就拿NBA举例。比如说现在需要写一个函数，只有当名字是姚明的时候，他才可以打中锋， 是科比的时候才能打后卫，是詹姆斯的时候才能打前锋，并且因为国内球员比较瘦弱，所以只有当姚明是25岁以上的时候，才能被归为合格的中锋（只是举个例子，不要太当真），那这个时候就用到特定重载签名了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43.5&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot; readability=&quot;10&quot;&gt;
function playBasketball (name: 'YaoMing', age: number): void;
function playBasketball (name: 'Kobe', age?: number): void;
function playBasketball (name: 'James', age?: number): void;&lt;p&gt;function playBasketball (name: string, age: number) {
    if (name === 'YaoMing' &amp;amp;&amp;amp; age &amp;amp;&amp;amp; age &amp;gt;= 25) {
        console.log('good Center')
    } else if (name === 'Kobe') {
        console.log('good guard')
    } else if (name === 'Jams') {
        console.log('good forward')
    } else {
        console.log('ordinary baskerball player')
    }
}
&lt;br/&gt;playBasketball('YaoMing', 25);
playBasketball('Kobe');　
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.  使用接口搭配重载签名或非重载签名&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
interface BasketballPlayer {
    (name: 'YaoMing', age: number): void;
    (name: 'Kobe', age: number): void;
    (name: 'James', age: number): void;
}

let playBasketball: BasketballPlayer = function (name) {
    if (name === 'YaoMing') {
        // dosomething
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用接口配合函数的默认参数，可实现特定重载签名的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
interface BasketballPlayer {
    (name: 'YaoMing', age: number): void;
    (name: 'Kobe', age: number): void;
    (name: 'James', age: number): void;
}


let playBasketball: BasketballPlayer = function (name = 'Yaoming', age: number) {
    if (age &amp;gt;= 25) {
        console.log('good center')
    }
}

let playBasketball2: BasketballPlayer = function (name = 'Kobe') {
    console.log('good guard')
}

let playBasketball3: BasketballPlayer = function (name = 'James') {
    console.log('good forward');
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处其并非严格意义上的重载，但是却利用了重载的思想，并且灵活搭配了函数的默认参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TS在大型项目中带来的优势超乎我们的想象，其他各方面的分享将会持续进行，有兴趣的小伙伴可持续关注。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 11 Mar 2019 14:35:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<og:description>所谓的重载，其实就是使用相同的函数名，传入不同数量的参数或不同类型的参数，以此创建出多个方法。 1. 最常见的，也就是根据定义傻瓜式地判断参数类型与数量 2. 其次就是使用常规的重载签名 使用重载签名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pomelott/p/10513731.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——55. 明智而审慎地返回Optional - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10513664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10513664.html</guid>
<description>&lt;blockquote readability=&quot;5.0845771144279&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：&lt;a href=&quot;https://github.com/jbloch/effective-java-3e-source-code&quot; class=&quot;uri&quot;&gt;https://github.com/jbloch/effective-java-3e-source-code&lt;/a&gt;&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Java 8之前，编写在特定情况下无法返回任何值的方法时，可以采用两种方法。要么抛出异常，要么返回null(假设返回类型是对象是引用类型)。但这两种方法都不完美。应该为异常条件保留异常(条目 69)，并且抛出异常代价很高，因为在创建异常时捕获整个堆栈跟踪。返回null没有这些缺点，但是它有自己的缺陷。如果方法返回null，客户端必须包含特殊情况代码来处理null返回的可能性，除非程序员能够证明null返回是不可能的。如果客户端忽略检查null返回并将null返回值存储在某个数据结构中，那么会在将来的某个时间在与这个问题不相关的代码位置上，抛出&lt;code&gt;NullPointerException&lt;/code&gt;异常的可能性。&lt;/p&gt;
&lt;p&gt;在Java 8中，还有第三种方法来编写可能无法返回任何值的方法。&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;类表示一个不可变的容器，它可以包含一个非null的&lt;code&gt;T&lt;/code&gt;引用，也可以什么都不包含。不包含任何内容的Optional被称为空（empty）。非空的包含值称的Optional被称为存在（present）。Optional的本质上是一个不可变的集合，最多可以容纳一个元素。&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;没有实现&lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt;接口，但原则上是可以。&lt;/p&gt;
&lt;p&gt;在概念上返回T的方法，但在某些情况下可能无法这样做，可以声明为返回一个&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;。这允许该方法返回一个空结果，以表明不能返回有效的结果。返回Optional的方法比抛出异常的方法更灵活、更容易使用，而且比返回null的方法更不容易出错。&lt;/p&gt;
&lt;p&gt;在条目 30中，我们展示了根据集合中元素的自然顺序计算集合最大值的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Returns maximum value in collection - throws exception if empty
public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; E max(Collection&amp;lt;E&amp;gt; c) {
    if (c.isEmpty())
        throw new IllegalArgumentException(&quot;Empty collection&quot;);

    E result = null;
    for (E e : c)
        if (result == null || e.compareTo(result) &amp;gt; 0)
            result = Objects.requireNonNull(e);
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果给定集合为空，此方法将抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常。我们在条目30中提到，更好的替代方法是返回&lt;code&gt;Optional&amp;lt;E&amp;gt;&lt;/code&gt;。下面是修改后的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Returns maximum value in collection as an Optional&amp;lt;E&amp;gt;
public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt;
        Optional&amp;lt;E&amp;gt; max(Collection&amp;lt;E&amp;gt; c) {
    if (c.isEmpty())
        return Optional.empty();
 
    E result = null;
    for (E e : c)
        if (result == null || e.compareTo(result) &amp;gt; 0)
            result = Objects.requireNonNull(e);
    return Optional.of(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如你所见，返回Optional很简单。 你所要做的就是使用适当的静态工厂创建Optional。 在这个程序中，我们使用两个：&lt;code&gt;Optional.empty()&lt;/code&gt;返回一个空的Optional，&lt;code&gt;Optional.of(value)&lt;/code&gt;返回一个包含给定非null值的Optional。 将null传递给&lt;code&gt;Optional.of(value)&lt;/code&gt;是一个编程错误。 如果这样做，该方法通过抛出&lt;code&gt;NullPointerException&lt;/code&gt;异常作为回应。 &lt;code&gt;Optional.of(value)&lt;/code&gt;方法接受一个可能为null的值，如果传入null则返回一个空的Optional。&lt;strong&gt;永远不要通过返回Optional的方法返回一个空值&lt;/strong&gt;：它破坏Optional设计的初衷。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt;上的很多终止操作返回Optional。如果我们重写max方法来使用一个&lt;code&gt;Stream&lt;/code&gt;，那么&lt;code&gt;Stream&lt;/code&gt;的&lt;code&gt;max&lt;/code&gt;操作会为我们生成Optional的工作(尽管我们还是传递一个显式的&lt;code&gt;Comparator&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Returns max val in collection as Optional&amp;lt;E&amp;gt; - uses stream
public static &amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt;
        Optional&amp;lt;E&amp;gt; max(Collection&amp;lt;E&amp;gt; c) {
    return c.stream().max(Comparator.naturalOrder());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，如何选择返回Optional而不是返回null或抛出异常呢？&lt;code&gt;Optional&lt;/code&gt;在本质上类似于检查异常（checked exceptions）(条目 71)，因为它们迫使API的用户面对可能没有返回任何值的事实。抛出未检查的异常或返回null允许用户忽略这种可能性，从而带来潜在的可怕后果。但是，抛出一个检查异常需要在客户端中添加额外的样板代码。&lt;/p&gt;
&lt;p&gt;如果方法返回一个Optional，则客户端可以选择在方法无法返回值时要采取的操作。 可以指定默认值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using an optional to provide a chosen default value
String lastWordInLexicon = max(words).orElse(&quot;No words...&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者可以抛出任何适当的异常。注意，我们传递的是异常工厂，而不是实际的异常。这避免了创建异常的开销，除非它真的实际被抛出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using an optional to throw a chosen exception
Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你能证明Optional非空，你可以从Optional获取值，而不需要指定一个操作来执行。但是如果Optional是空的，你判断错了，代码会抛出一个&lt;code&gt;NoSuchElementException&lt;/code&gt;异常:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using optional when you know there’s a return value
Element lastNobleGas = max(Elements.NOBLE_GASES).get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时候，可能会遇到这样一种情况：获取默认值的代价很高，除非必要，否则希望避免这种代价。对于这些情况，Optional提供了一个方法，该方法接受&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;，并仅在必要时调用它。这个方法被称为&lt;code&gt;orElseGet&lt;/code&gt;，但是或许应该被称为&lt;code&gt;orElseCompute&lt;/code&gt;，因为它与以&lt;code&gt;compute&lt;/code&gt;开头的三个Map方法密切相关。有几个Optional的方法来处理更特殊的用例：&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;flatMap&lt;/code&gt;和&lt;code&gt;ifPresent&lt;/code&gt;。在Java 9中，又添加了两个这样的方法：&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;ifPresentOrElse&lt;/code&gt;。如果上面描述的基本方法与你的用例不太匹配，请查看这些更高级方法的文档，并查看它们是否能够完成任务。&lt;/p&gt;
&lt;p&gt;如果这些方法都不能满足你的需要，Optional提供&lt;code&gt;isPresent()&lt;/code&gt;方法，可以将其视为安全阀。如果Optional包含值，则返回true；如果为空，则返回false。你可以使用此方法对可选结果执行任何喜欢的处理，但请确保明智地使用它。&lt;code&gt;isPresent&lt;/code&gt;的许多用途都可以被上面提到的一种方法所替代。生成的代码通常更短、更清晰、更符合习惯。&lt;/p&gt;
&lt;p&gt;例如，请考虑此代码段，它打印一个进程的父进程ID，如果进程没有父进程，则打印N/A. 该代码段使用Java 9中引入的&lt;code&gt;ProcessHandle&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional&amp;lt;ProcessHandle&amp;gt; parentProcess = ph.parent();
System.out.println(&quot;Parent PID: &quot; + (parentProcess.isPresent() ?
    String.valueOf(parentProcess.get().pid()) : &quot;N/A&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码可以被如下代码所替代，使用了Optional的&lt;code&gt;map&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;Parent PID: &quot; +

  ph.parent().map(h -&amp;gt; String.valueOf(h.pid())).orElse(&quot;N/A&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用Stream进行编程时，通常会发现使用的是一个&lt;code&gt;Stream&amp;lt;Optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;，并且需要一个&lt;code&gt;Stream&amp;lt;T&amp;gt;&lt;/code&gt;，其中包含非Optional中的所有元素，以便继续进行。如果你正在使用Java 8，下面是弥补这个差距的代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;streamOfOptionals
    .filter(Optional::isPresent)
    .map(Optional::get)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Java 9中，Optional配备了一个&lt;code&gt;stream()&lt;/code&gt;方法。这个方法是一个适配器， 此方法是一个适配器，它将Optional变为包含一个元素的Stream，如果Optional为空，则不包含任何元素。此方法与Stream的&lt;code&gt;flatMap&lt;/code&gt;方法(条目45)相结合，这个方法可以简洁地替代上面的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;streamOfOptionals.
    .flatMap(Optional::stream)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并不是所有的返回类型都能从Optional的处理中获益。&lt;strong&gt;容器类型，包括集合、映射、Stream、数组和Optional，不应该封装在Optional中&lt;/strong&gt;。与其返回一个空的&lt;code&gt;Optional&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;，不还如返回一个空的&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;(条目 54)。返回空容器将消除客户端代码处理Optional的需要。&lt;code&gt;ProcessHandle&lt;/code&gt;类确实有&lt;code&gt;arguments&lt;/code&gt;方法，它返回&lt;code&gt;Optional&amp;lt;String[]&amp;gt;&lt;/code&gt;，但是这个方法应该被视为一种异常，不该被效仿。&lt;/p&gt;
&lt;p&gt;那么什么时候应该声明一个方法来返回&lt;code&gt;Optional &amp;lt;T&amp;gt;&lt;/code&gt;而不是&lt;code&gt;T&lt;/code&gt;呢？ 通常，&lt;strong&gt;如果可能无法返回结果，并且在没有返回结果，客户端还必须执行特殊处理的情况下，则应声明返回Optional 的方法&lt;/strong&gt;。也就是说，返回&lt;code&gt;Optional &amp;lt;T&amp;gt;&lt;/code&gt;并非没有成本。 Optional是必须分配和初始化的对象，从Optional中读取值需要额外的迂回。 这使得Optional不适合在某些性能关键的情况下使用。 特定方法是否属于此类别只能通过仔细测量来确定（条目 67）。&lt;/p&gt;
&lt;p&gt;与返回装箱的基本类型相比，返回包含已装箱基本类型的Optional的代价高得惊人，因为Optional有两个装箱级别，而不是零。因此，类库设计人员认为为基本类型int、long和double提供类似Option是合适的。这些Option是&lt;code&gt;OptionalInt&lt;/code&gt;、&lt;code&gt;OptionalLong&lt;/code&gt;和&lt;code&gt;OptionalDouble&lt;/code&gt;。它们包含&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;上的大多数方法，但不是所有方法。因此，除了“次要基本类型（minor primitive types）”Boolean，Byte，Character，Short和Float之外，&lt;strong&gt;永远不应该返回装箱的基本类型的Optional&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;到目前为止，我们已经讨论了返回Optional并在返回后处理它们的方法。我们还没有讨论其他可能的用法，这是因为大多数其他Optional的用法都是可疑的。例如，永远不要将Optional用作映射值。如果这样做，则有两种方法可以表示键（key）在映射中逻辑上的缺失：键要么不在映射中，要么存在的话映射到一个空的Optional。这反映了不必要的复杂性，很有可能导致混淆和错误。更通俗地说，在集合或数组中使用Optional的键、值或元素几乎都是不合适的。&lt;/p&gt;
&lt;p&gt;这里留下了一个悬而未决的大问题。在实例中存储Optional属性是否合适吗？通常这是一种“不好的味道”：它建议你可能应该有一个包含Optional属性的子类。但有时这可能是合理的。考虑条目2中的&lt;code&gt;NutritionFacts&lt;/code&gt;类的情况。&lt;code&gt;NutritionFacts&lt;/code&gt;实例包含许多不需要的属性。不可能为这些属性的每个可能组合都提供一个子类。此外，属性包含基本类型，这使得很难直接表示这种缺失。对于&lt;code&gt;NutritionFacts&lt;/code&gt;最好的API将为每个Optional属性从getter方法返回一个Optional，因此将这些Optional作为属性存储在对象中是很有意义的。&lt;/p&gt;
&lt;p&gt;总之，如果发现自己编写的方法不能总是返回值，并且认为该方法的用户在每次调用时考虑这种可能性很重要，那么或许应该返回一个Optional的方法。但是，应该意识到，返回Optional会带来实际的性能后果；对于性能关键的方法，最好返回null或抛出异常。最后，除了作为返回值之外，不应该在任何其他地方中使用Optional。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:24:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10513664.html</dc:identifier>
</item>
<item>
<title>Android Jetpack之AppCompat（一） - 萧文翰</title>
<link>http://www.cnblogs.com/wenhanxiao/p/10513498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenhanxiao/p/10513498.html</guid>
<description>&lt;p&gt;今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-354c8314b336df57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Jetpack一览&quot;/&gt;&lt;br/&gt;从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。&lt;br/&gt;Google官方网站：&lt;br/&gt;https://developer.android.com/jetpack&lt;br/&gt;按照Google官方的描述，AppCompat就是指v7 appcompat库。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。&lt;br/&gt;进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ActionBar：提供Actionbar用户界面模式的实现；&lt;/li&gt;
&lt;li&gt;AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类；&lt;/li&gt;
&lt;li&gt;AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类;&lt;/li&gt;
&lt;li&gt;ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想要使用这些类，我们需要添加v7支持库。&lt;br/&gt;到现在为止，支持库的最新版本是28，添加的库名称和版本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;com.android.support:appcompat-v7:28.0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。&lt;br/&gt;依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先解决疑问：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;一、添加ToolBar&lt;/strong&gt;&lt;br/&gt;想要添加一个ToolBar，总共3步走：&lt;br/&gt;1. 更改application主题样式，操作对象：styles.xml。&lt;br/&gt;对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:theme=&quot;@style/AppTheme&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2. 在Activity布局中添加ToolBar，操作对象：layout布局文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/activity_main_tb&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:elevation=&quot;4dp&quot;
    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。&lt;br/&gt;android:evevation指“仰角”，这部分知识请参考：&lt;br/&gt;https://developer.android.com/training/material/shadows-clipping&lt;br/&gt;这里就不再赘述了。&lt;br/&gt;如果你的项目已经迁移到Android X，你的布局文件代码片应该是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;androidx.appcompat.widget.Toolbar
    android:id=&quot;@+id/activity_main_tb&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:elevation=&quot;4dp&quot;
    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类&lt;br/&gt;这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Toolbar topTb;
topTb = findViewById(R.id.activity_main_tb);        
setSupportActionBar(topTb);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。&lt;br/&gt;到此，我们就完成了ToolBar的添加，还算简单吧？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、ToolBar外观的自定义&lt;/strong&gt;&lt;br/&gt;不出意外的话，我们运行的结果将会和下图类似：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-3526df1633d702a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;默认的配色方案&quot;/&gt;&lt;br/&gt;大绿底，大黑字，实在不怎么好看。&lt;br/&gt;那么，如果我们想要自定义配色方案，该如何做呢？参考下图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-542cfa07382ec381.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;配色方案指导&quot;/&gt;&lt;br/&gt;这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-cb317f8c05da9ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;自定义的配色方案&quot;/&gt;&lt;br/&gt;相关的代码片：&lt;br/&gt;color.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;color name=&quot;colorPrimary&quot;&amp;gt;#002FA7&amp;lt;/color&amp;gt;
    &amp;lt;color name=&quot;colorPrimaryDark&quot;&amp;gt;#001F67&amp;lt;/color&amp;gt;
    &amp;lt;color name=&quot;colorAccent&quot;&amp;gt;#003FB7&amp;lt;/color&amp;gt;
    &amp;lt;color name=&quot;textColorPrimary&quot;&amp;gt;#FFFFFF&amp;lt;/color&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;styles.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&amp;gt;
    &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/colorPrimary&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;colorPrimaryDark&quot;&amp;gt;@color/colorPrimaryDark&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;colorAccent&quot;&amp;gt;@color/colorAccent&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;android:textColorPrimary&quot;&amp;gt;@color/textColorPrimary&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、给ToolBar增加动作&lt;/strong&gt;&lt;br/&gt;首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。&lt;br/&gt;1. 编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件&lt;br/&gt;这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&amp;gt;

    &amp;lt;item
        android:id=&quot;@+id/menu_main_info&quot;
        android:title=&quot;@string/menu_main_activity_info&quot;
        app:showAsAction=&quot;never&quot; /&amp;gt;

    &amp;lt;item
        android:id=&quot;@+id/menu_main_search&quot;
        android:title=&quot;@string/menu_main_activity_search&quot;
        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;
        app:showAsAction=&quot;always&quot; /&amp;gt;
&amp;lt;/menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们可以看到有两个item，分别对应Info和搜索，我们使用&quot;app:showAsAction&quot;的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。&lt;/p&gt;
&lt;p&gt;2. 接下来是Java代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private SearchView tbSearchSv;

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main_activity_menu, menu);
    MenuItem searchItem = menu.findItem(R.id.menu_main_search);
    tbSearchSv = (SearchView) searchItem.getActionView();
    return super.onCreateOptionsMenu(menu);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的朋友会发现有这一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是做什么的呢？&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-d63b04cb72acb40f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;搜索栏效果&quot;/&gt;&lt;br/&gt;对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！&lt;br/&gt;典型的APP：网易云音乐、知乎上方的搜索都是这样的。&lt;/p&gt;
&lt;p&gt;3. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.menu_main_info:
            Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show();
            break;
    }
    return super.onOptionsItemSelected(item);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？&lt;br/&gt;其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
    @Override
    public boolean onQueryTextSubmit(String s) {
        
        return false;
    }

    @Override
    public boolean onQueryTextChange(String s) {
        
        return false;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。&lt;br/&gt;关于SearchView，还有一写额外的设置，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置提交按钮是否可见（默认不可见）
tbSearchSv.setSubmitButtonEnabled(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-cad240818edfd930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;提交按钮是否可见&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置左侧是否显示搜索图标（默认不可见）
tbSearchSv.setIconifiedByDefault(false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/940690-21038123431a98e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;左侧是否显示搜索图标&quot;/&gt;&lt;br/&gt;更多可使用的API请参考官方文档：&lt;br/&gt;https://developer.android.google.cn/reference/android/widget/SearchView&lt;/p&gt;
&lt;p&gt;不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。&lt;br/&gt;所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean onKeyUp(int keyCode, KeyEvent event) {
    switch (keyCode) {
        case KeyEvent.KEYCODE_BACK:
            if (!tbSearchSv.isIconified()) {
                tbSearchSv.setIconified(true);
                return true;
            }
            break;
    }
    return super.onKeyUp(keyCode, event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。&lt;/p&gt;
&lt;p&gt;四、返回上一层&lt;/p&gt;
&lt;p&gt;ToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。&lt;br/&gt;其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。&lt;/p&gt;
&lt;p&gt;1. 在ToolBar对象上启用返回钮&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getSupportActionBar().setDisplayHomeAsUpEnabled(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。&lt;/p&gt;
&lt;p&gt;2. 在AndroidManifest.xml中定义要跳转的Activity&lt;br/&gt;如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;activity
    android:name=&quot;.MainActivity&quot;
    android:parentActivityName=&quot;.SecondActivity&quot;&amp;gt;
    &amp;lt;!-- 兼容 Android4.0 及以下版本--&amp;gt;
    &amp;lt;meta-data
        android:name=&quot;android.support.PARENT_ACTIVITY&quot;
        android:value=&quot;.SecondActivity&quot; /&amp;gt;
&amp;lt;/activity&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/940690-1bfd36484573385f.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;返回键视频演示&quot;/&gt;&lt;br/&gt;到此，关于ToolBar常见用法的梳理告一段落。源码请自取：&lt;br/&gt;https://github.com/wh1990xiao2005/JetpackDemo&lt;/p&gt;
&lt;p&gt;我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。&lt;br/&gt;共勉！&lt;/p&gt;
</description>
<pubDate>Mon, 11 Mar 2019 14:05:00 +0000</pubDate>
<dc:creator>萧文翰</dc:creator>
<og:description>今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图： 从图中我们可以看到，整个Android Jetpac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenhanxiao/p/10513498.html</dc:identifier>
</item>
</channel>
</rss>