<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>fashion数据集训练 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/13976814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/13976814.html</guid>
<description>&lt;h3&gt;下载数据集&lt;/h3&gt;
&lt;p&gt;fashion数据集总共有7万张28*28像素点的灰度图片和标签，涵盖十个分类：T恤、裤子、套头衫、连衣裙、外套、凉鞋、衬衫、运动鞋、包、靴子。&lt;/p&gt;
&lt;p&gt;其中6万张用于训练，1万张用于测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181622/202011/1181622-20201115150059285-1400837738.jpg&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;482&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow &lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Conv2D, MaxPool2D, Flatten, Dense,Dropout

fashion &lt;/span&gt;=&lt;span&gt; keras.datasets.fashion_mnist
(x_train, y_train), (x_test, y_test) &lt;/span&gt;=&lt;span&gt; fashion.load_data()
x_train, x_test &lt;/span&gt;= x_train / 255.0, x_test / 255.0&lt;span&gt;

x_train &lt;/span&gt;= x_train.reshape(x_train.shape[0], 28, 28, 1&lt;span&gt;)
x_test &lt;/span&gt;= x_test.reshape(x_test.shape[0], 28, 28, 1)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;搭建网络结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
model =&lt;span&gt; keras.models.Sequential([
    Conv2D(&lt;/span&gt;64, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    MaxPool2D((&lt;/span&gt;2, 2&lt;span&gt;)),
    Conv2D(&lt;/span&gt;128, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    MaxPool2D((&lt;/span&gt;2, 2&lt;span&gt;)),
    Conv2D(&lt;/span&gt;128, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    Flatten(),
    Dropout(&lt;/span&gt;0.4&lt;span&gt;),
    Dense(&lt;/span&gt;128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,kernel_regularizer=&lt;span&gt;keras.regularizers.l2()),
    Dropout(&lt;/span&gt;0.4&lt;span&gt;),
    Dense(&lt;/span&gt;10, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;模型编译&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
model.compile(optimizer=keras.optimizers.Adam(lr=0.0001), loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False), metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;执行训练&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
history = model.fit(x_train, y_train, epochs=100, batch_size=32,verbose=1,validation_data=(x_test, y_test),validation_freq=1)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;模型评估&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
score = model.evaluate(x_test, y_test, verbose=0, batch_size=32&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试准确率:{}, 测试loss值: {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(score[1], score[0]))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;可视化acc/loss曲线&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示训练集和测试集的acc和loss曲线&lt;/span&gt;
plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
acc &lt;/span&gt;= history.history[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
val_acc &lt;/span&gt;= history.history[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;val_accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
loss &lt;/span&gt;= history.history[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
val_loss &lt;/span&gt;= history.history[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;val_loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

plt.subplot(&lt;/span&gt;1, 2, 1&lt;span&gt;)
plt.plot(acc, label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;训练Acc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.plot(val_acc, label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试Acc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Acc曲线&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend()

plt.subplot(&lt;/span&gt;1, 2, 2&lt;span&gt;)
plt.plot(loss, label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;训练Loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.plot(val_loss, label&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试Loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Loss曲线&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend()
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181622/202011/1181622-20201115150818409-1975871616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:57:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>下载数据集 fashion数据集总共有7万张28*28像素点的灰度图片和标签，涵盖十个分类：T恤、裤子、套头衫、连衣裙、外套、凉鞋、衬衫、运动鞋、包、靴子。 其中6万张用于训练，1万张用于测试。 im</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengyumeng/p/13976814.html</dc:identifier>
</item>
<item>
<title>使用 .NET 5 体验大数据和机器学习 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13983428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13983428.html</guid>
<description>&lt;blockquote readability=&quot;3.3928571428571&quot;&gt;
&lt;p&gt;翻译：精致码农-王亮&lt;br/&gt;原文：&lt;a href=&quot;http://dwz.win/XnM&quot;&gt;http://dwz.win/XnM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.NET 5 旨在提供统一的运行时和框架，使其在各平台都有统一的运行时行为和开发体验。微软发布了与 .NET 协作的大数据（.NET for Spark）和机器学习（ML.NET）工具，这些工具共同提供了富有成效的端到端体验。在本文中，我们将介绍 .NET for Spark、大数据、ML.NET 和机器学习的基础知识，我们将研究其 API 和功能，向你展示如何开始构建和消费你自己的 Spark 作业和 ML.NET 模型。&lt;/p&gt;
&lt;h2 id=&quot;什么是大数据&quot;&gt;什么是大数据&lt;/h2&gt;
&lt;p&gt;大数据是一个几乎不言自明的行业术语。该术语指的是大型数据集，通常涉及 TB 甚至 PB 级的信息，这些数据集被用作分析的输入，以揭示数据中的模式和趋势。大数据与传统工作负载之间的关键区别在于，大数据往往过于庞大、复杂或多变，传统数据库和应用程序无法处理。一种流行的数据分类方式被称为 &quot;3V&quot;（译注：即3个V，Volume 容量、Velocity 速度、Variety 多样性）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大数据解决方案是为适应高容量、处理复杂多样的数据结构而定制的，并通过批处理（静态）和流处理（动态）来管理速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多数大数据解决方案都提供了在数据仓库中存储数据的方式，数据仓库通常是一个为快速检索和为并行处理而优化的分布式集群。处理大数据往往涉及多个步骤，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230221.png&quot; alt=&quot;Figure 1: The big data process&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 开发人员如果需要基于大型数据集进行分析和洞察，可以使用基于流行的大数据解决方案 Apache Spark 的 .NET 实现：.NET for Spark。&lt;/p&gt;
&lt;h2 id=&quot;net-for-spark&quot;&gt;.NET for Spark&lt;/h2&gt;
&lt;p&gt;.NET for Spark 基于 Apache Spark，这是一个用于处理大数据的开源分析引擎。它被设计为在内存中处理大量数据，以提供比其他依赖持久化存储的解决方案更好的性能。它是一个分布式系统，并行处理工作负载。它为加载数据、查询数据、处理数据和输出数据提供支持。&lt;/p&gt;
&lt;p&gt;Apache Spark 支持 Java、Scala、Python、R 和 SQL。微软创建了 .NET for Spark 以增加对 .NET 的支持。该解决方案提供了免费、开放、跨平台的工具，用于使用 .NET 所支持的语言（如 C#和 F#）构建大数据应用程序，这样你就可以使用现有的 .NET 库，同时利用 SparkSQL 等 Spark 特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230222.png&quot; alt=&quot;Figure 2: Architecture for .NET for Spark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下代码展示了一个小而完整的 .NET for Spark 应用程序，它读取一个文本文件并按降序输出字数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Microsoft.Spark.Sql;

namespace MySparkApp
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a Spark session.
            SparkSession spark = SparkSession.Builder().AppName(&quot;word_count_sample&quot;).GetOrCreate();

            // Create initial DataFrame.
            DataFrame dataFrame = spark.Read().Text(&quot;input.txt&quot;);

            // Count words.
            DataFrame words = dataFrame.Select(Functions.Split(Functions.Col(&quot;value&quot;), &quot; &quot;).Alias(&quot;words&quot;))
                .Select(Functions.Explode(Functions .Col(&quot;words&quot;))
                .Alias(&quot;word&quot;))
                .GroupBy(&quot;word&quot;)
                .Count()
                .OrderBy(Functions.Col(&quot;count&quot;).Desc());

            // Show results.
            words.Show();

            // Stop Spark session.
            spark.Stop();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在开发机器上配置 .NET for Spark 需要安装几个依赖，包括 Java SDK 和 Apache Spark。你可以在这里(&lt;a href=&quot;https://aka.ms/go-spark-net&quot;&gt;https://aka.ms/go-spark-net&lt;/a&gt;)查看手把手的入门指南。&lt;/p&gt;
&lt;p&gt;Spark for .NET 可在多种环境中运行，并可部署到云中运行。可部署目标包括 Azure HDInsight、Azure Synapse、AWS EMR Spark 和 Databricks 等。如果数据作为项目可用的一部分，你可以将其与其他 &lt;code&gt;project&lt;/code&gt; 文件一起提交。&lt;/p&gt;
&lt;p&gt;大数据通常与机器学习一起使用，以获得关于数据的洞察。&lt;/p&gt;
&lt;h2 id=&quot;什么是机器学习&quot;&gt;什么是机器学习&lt;/h2&gt;
&lt;p&gt;首先，我们先来介绍一下人工智能和机器学习的基本知识。&lt;/p&gt;
&lt;p&gt;人工智能（AI）是指计算机模仿人类智慧和能力，如推理和寻找意义。典型的人工智能技术通常是从规则或逻辑系统开始的。作为一个简单的例子，想一想这样的场景：你想把某样东西分类为“面包”或“不是面包”。当你开始时，这似乎是一个简单的问题，例如“如果它有眼睛，它就不是面包”。然而，你很快就会开始意识到，有很多不同的特征可以将某物定性为面包与非面包，而且特征越多，一系列的 if 语句就会越长越复杂，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230223.png&quot; alt=&quot;Figure 3: Determining “bread or not bread?” with AI if statements&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中的例子可以看出，传统的、基于规则的人工智能技术往往难以扩展。这就是机器学习的作用。机器学习（ML）是人工智能的一个子集，它能在过去的数据中找到模式，并从经验中学习，以对新数据采取行动。ML 允许计算机在没有明确的逻辑规则编程的情况下进行预测。因此，当你有一个难以（或不可能）用基于规则的编程解决的问题时，你可以使用 ML。你可以把 ML 看作是 &quot;对不可编程的编程&quot;。&lt;/p&gt;
&lt;p&gt;为了用 ML 解决“面包”与“非面包”的问题，你提供面包的例子和非面包的例子（如下图所示），而不是实现一长串复杂的 if 语句。你将这些例子传递给一个算法，该算法在数据中找到模式，并返回一个模型，然后你可以用这个模型来预测尚未被模型“看到”的图像是“面包”还是“不是面包”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230224.png&quot; alt=&quot;Figure 4: Determining “bread or not bread?” with ML&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了 AI 与 ML 的另一种思考方式。AI 将规则和数据作为输入，预期输出基于这些规则的答案。而 ML 则是将数据和答案作为输入，输出可用于对新数据进行归纳的规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230225.png&quot; alt=&quot;Figure 5: Artificial intelligence compared to machine learning&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;AI 将规则和数据作为输入，并根据这些规则输出预期的答案。ML 将数据和答案作为输入，并输出可用于概括新数据的规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mlnet&quot;&gt;ML.NET&lt;/h2&gt;
&lt;p&gt;微软在 2019 年 5 月的 Build 上发布了 ML.NET，这是一个面向.NET 开发人员的开源、跨平台 ML 框架。在过去的九年里，微软的团队已经广泛使用该框架的内部版本来实现流行的 ML 驱动功能；一些例子包括 Dynamics 365 欺诈检测、PowerPoint 设计理念和 Microsoft Defender 防病毒威胁保护。&lt;/p&gt;
&lt;p&gt;ML.NET 允许你在.NET 生态系统中构建、训练和消费 ML 模型，而不需要 ML 或数据科学的背景。ML.NET 可以在任何.NET 运行的地方运行。Windows、Linux、macOS、on-prem、离线场景（如 WinForms 或 WPF 桌面应用）或任何云端（如 Azure）中。你可以将 ML.NET 用于各种场景，如表 1 所述。&lt;/p&gt;
&lt;p&gt;ML.NET 使用自动机器学习（或称 AutoML）来自动构建和训练 ML 模型的过程，以根据提供的场景和数据找到最佳模型。你可以通过 AutoML.NET API 或 ML.NET 工具来使用 ML.NET 的 AutoML，其中包括 Visual Studio 中的 Model Builder 和跨平台的 ML.NET CLI，如图 6 所示。除了训练最佳模型外，ML.NET 工具还生成在最终用户.NET 应用程序中消费模型所需的文件和 C#代码，该应用程序可以是任何.NET 应用程序（桌面、Web、控制台等）。所有 AutoML 方案都提供了本地训练选项，图像分类也允许你利用云的优势，使用 Model Builder 中的 Azure ML 进行训练。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230226.png&quot; alt=&quot;Figure 6: ML.NET tooling is built on top of the AutoML.NET API, which is on top of the ML.NET API.&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以在 Microsoft Docs 中了解更多关于 ML.NET 的信息，网址是：&lt;a href=&quot;https://aka.ms/mlnetdocs&quot;&gt;https://aka.ms/mlnetdocs&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;ml-和大数据结合&quot;&gt;ML 和大数据结合&lt;/h2&gt;
&lt;p&gt;大数据和 ML 可以很好地结合在一起。让我们构建一个同时使用 Spark for .NET 和 ML.NET 的管道，以展示大数据和 ML 如何一起工作。Markdown 是一种用于编写文档和创建静态网站的流行语言，它使用的语法不如 HTML 复杂，但提供的格式控制比纯文本更多。这是从 .NET 文档库中的摘取一段 markdown 文件内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;---
title: Welcome to .NET
description: Getting started with the .NET
family of technologies.
ms.date: 12/03/2019
ms.custom: &quot;updateeachrelease&quot;
---

# Welcome to .NET

See [Get started with .NET Core](core/get-started.md) to learn how to create .NET Core apps.

Build many types of apps with .NET, such as cloud ,IoT, and games using free cross-platform tools...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;破折号之间的部分称为&lt;strong&gt;前页&lt;/strong&gt;（front matter），是使用 YAML 描述的有关文档的元数据。以井号（＃）开头的部分是标题。两个哈希（##）表示二级标题。“ .NET Core 入门”是一个超链接。&lt;/p&gt;
&lt;p&gt;我们的目标是处理大量文档，添加诸如字数和估计的阅读时间之类的元数据，并将相似的文章自动分组在一起。&lt;/p&gt;
&lt;p&gt;这是我们将构建的管道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为每个文档建立字数统计；&lt;/li&gt;
&lt;li&gt;估计每个文档的阅读时间；&lt;/li&gt;
&lt;li&gt;根据“ TF-IDF”或“术语频率/反向文档频率”为每个文档创建前 20 个单词的列表（这将在后面说明）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一步是拉取文档存储库和需引用的应用程序。你可以使用任何包含 Markdown 文件的存储库及文件夹结构。本文使用的示例来自 .NET 文档存储库，可从 &lt;a href=&quot;https://aka.ms/dot-net-docs&quot;&gt;https://aka.ms/dot-net-docs&lt;/a&gt; 克隆。&lt;/p&gt;
&lt;p&gt;为.NET 和 Spark 准备本地环境之后，可以从&lt;a href=&quot;https://aka.ms/spark-ml-example&quot;&gt;https://aka.ms/spark-ml-example&lt;/a&gt;拉取项目。&lt;/p&gt;
&lt;p&gt;解决方案文件夹包含一个批处理命令（在仓库中有提供），你可以使用该命令来运行所有步骤。&lt;/p&gt;
&lt;h3 id=&quot;处理-markdown&quot;&gt;处理 Markdown&lt;/h3&gt;
&lt;p&gt;DocRepoParser 项目以递归方式遍历存储库中的子文件夹，以收集各文档有关的元数据。Common 项目包含几个帮助程序类。例如，&lt;code&gt;FilesHelper&lt;/code&gt; 用于所有文件 I/O。它跟踪存储文件和文件名的位置，并提供诸如为其他项目读取文件的服务。构造函数需要一个标签（一个唯一标识工作流的数字）和包含文档的 repo 或顶级文件夹的路径。默认情况下，它在用户的本地应用程序数据文件夹下创建一个文件夹。如有必要，可以将其覆盖。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MarkdownParser&lt;/code&gt;利用 &lt;code&gt;Microsoft.Toolkit.Parsers&lt;/code&gt;解析 Markdown 的库。该库有两个任务：首先，它必须提取标题和子标题；其次，它必须提取单词。Markdown 文件以 &quot;块 &quot;的形式暴露出来，代表标题、链接和其他 Markdown 特征。块又包含承载文本的“Inlines”。例如，这段代码通过迭代行和单元格来解析一个 TableBlock，以找到 Inlines。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;case TableBlock table:
    table.Rows.SelectMany(r =&amp;gt; r.Cells)
        .SelectMany(c =&amp;gt; c.Inlines)
        .ForEach(i =&amp;gt; candidate = RecurseInline(i, candidate, words, titles));
        break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此代码提取超链接的文本部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;case HyperlinkInline hyper:
    if (!string.IsNullOrWhiteSpace(hyper.Text))
    {
        words.Append(hyper.Text.ExtractWords());
    }
    break;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是一个 CSV 文件，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230227.png&quot; alt=&quot;图7：生成的CSV文件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步只是准备要处理的数据。下一步使用 Spark for .NET 作业确定每个文档的字数，阅读时间和前 20 个术语。&lt;/p&gt;
&lt;h3 id=&quot;构建-spark-job&quot;&gt;构建 Spark Job&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SparkWordsProcessor&lt;/code&gt;项目用来运行 Spark 作业。虽然该应用程序是一个控制台项目，但它需要 Spark 来运行。&lt;code&gt;runjob.cmd&lt;/code&gt;批处理命令将作业提交到正确配置的 Windows 计算机上运行。典型作业的模式是创建一个会话或“应用程序”，执行一些逻辑，然后停止会话。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var spark = SparkSession.Builder()
    .AppName(nameof(SparkWordsProcessor))
    .GetOrCreate();
RunJob();
spark.Stop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过将其路径传递给 Spark 会话，可以轻松读取上一步的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var docs = spark.Read().HasHeader().Csv(filesHelper.TempDataFile);
docs.CreateOrReplaceTempView(nameof(docs));
var totalDocs = docs.Count();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docs&lt;/code&gt;变量解析为一个&lt;code&gt;DataFrame&lt;/code&gt;。&lt;strong&gt;Data Frame 本质上是一个带有一组列和一个通用接口的表，用于与数据交互，而不管其底层来源是什么。&lt;/strong&gt;可以从其他 data frame 中引用一个 data frame。SparkSQL 也可以用来查询 data frame。你必须创建一个临时视图，该视图为 data frame 提供别名，以便从 SQL 中引用它。通过&lt;code&gt;CreateOrReplaceTempView&lt;/code&gt;方法，可以像这样从 data frame 中查询行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM docs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;totalDocs&lt;/code&gt;变量检索文档中所有行的计数。Spark 提供了一个名为&lt;code&gt;Split&lt;/code&gt;的将字符串分解为数组的函数。&lt;code&gt;Explode&lt;/code&gt;函数将每个数组项变成一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var words = docs.Select(fileCol,
    Functions.Split(nameof(FileDataParse.Words)
    .AsColumn(), &quot; &quot;)
    .Alias(wordList))
    .Select(fileCol, Functions.Explode(wordList.AsColumn())
    .Alias(word));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该查询为每个单词或术语生成一行。这个 data frame 是生成&lt;strong&gt;术语频率&lt;/strong&gt;（TF）或者说每个文档中每个词的计数的基础。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var termFrequency = words
    .GroupBy(fileCol, Functions.Lower(word.AsColumn()).Alias(word))
    .Count()
    .OrderBy(fileCol, count.AsColumn().Desc());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spark 有内置的模型，可以确定“术语频率/反向文档频率”。在这个例子中，你将手动确定术语频率来演示它是如何计算的。术语在每个文档中以特定的频率出现。一篇关于 wizard 的文档可能有很高的“wizard”一词计数。同一篇文档中，&quot;the &quot;和 &quot;is &quot;这两个词的出现次数可能也很高。对我们来说，很明显，“wizard”这个词更重要，也提供了更多的语境。另一方面，Spark 必须经过训练才能识别重要的术语。为了确定什么是真正重要的，我们将总结&lt;strong&gt;文档频率&lt;/strong&gt;（document frequency），或者说一个词在 repo 中所有文档中出现的次数。这就是“按不同出现次数分组”：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var documentFrequency = words
    .GroupBy(Functions.Lower(word.AsColumn())
    .Alias(word))
    .Agg(Functions.CountDistinct(fileCol)
    .Alias(docFrequency));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在是计算的时候了。一个特殊的方程式可以计算出所谓的&lt;strong&gt;反向文档频率&lt;/strong&gt;（inverse document frequency），即 IDF。将总文档的自然对数（加一）输入方程，然后除以该词的文档频率（加一）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;static double CalculateIdf(int docFrequency, int totalDocuments) =&amp;gt;
    Math.Log(totalDocuments + 1) / (docFrequency + 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在所有文档中出现的词比出现频率较低的词赋值低。例如，给定 1000 个文档，一个在每个文档中出现的词与一个只在少数文档中出现的词（约 1 个）相比，IDF 为 0.003。Spark 支持用户定义的函数，你可以这样注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;spark.Udf().Register&amp;lt;int, int, double&amp;gt;(nameof(CalculateIdf), CalculateIdf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，你可以使用该函数来计算 data frame 中所有单词的 IDF：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var idfPrep = documentFrequency.Select(word.AsColumn(),
    docFrequency.AsColumn())
        .WithColumn(total, Functions.Lit(totalDocs))
        .WithColumn(inverseDocFrequency,
            Functions.CallUDF(nameof(CalculateIdf), docFrequency.AsColumn(), total.AsColumn()
        )
    );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用文档频率 data frame，增加两列。第一列是文档的单词总数量，第二列是调用你的 UDF 来计算 IDF。还有一个步骤，就是确定“重要词”。重要词是指在所有文档中不经常出现，但在当前文档中经常出现的词，用 TF-IDF 表示，这只是 IDF 和 TF 的产物。考虑“is”的情况，IDF 为 0.002，在文档中的频率为 50，而“wizard”的 IDF 为 1，频率为 10。相比频率为 10 的“wizard”，“is”的 TF-IDF 计算结果为 0.1。这让 Spark 对重要性有了更好的概念，而不仅仅是原始字数。&lt;/p&gt;
&lt;p&gt;到目前为止，你已经使用代码来定义 data frame。让我们尝试一下 SparkSQL。为了计算 TF-IDF，你将文档频率 data frame 与反向文档频率 data frame 连接起来，并创建一个名为&lt;code&gt;termFreq_inverseDocFreq&lt;/code&gt;的新列。下面是 SparkSQL：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var idfJoin = spark.Sql($&quot;SELECT t.File, d.word, d.{docFrequency}, d.{inverseDocFrequency}, t.count, d.{inverseDocFrequency} * t.count as {termFreq_inverseDocFreq} from {nameof(documentFrequency)} d inner join {nameof(termFrequency)} t on t.word = d.word&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;探索代码，看看最后的步骤是如何实现的。这些步骤包括：&lt;/p&gt;
&lt;p&gt;到目前为止所描述的所有步骤都为 Spark 提供了一个模板或定义。像 LINQ 查询一样，实际的处理在结果被具体化之前不会发生（比如计算出总文档数时）。最后一步调用 Collect 来处理和返回结果，并将其写入另一个 CSV。然后，你可以使用新文件作为 ML 模型的输入，下图是该文件的一部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/20201115230228.png&quot; alt=&quot;图8：已准备好进行ML训练的已处理元数据。&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spark for .NET 使你能够查询和塑造数据。你在同一个数据源上建立了多个 data frame，然后添加它们以获得关于重要术语、字数和阅读时间的洞察。下一步是应用 ML 来自动生成类别。&lt;/p&gt;
&lt;h3 id=&quot;预测类别&quot;&gt;预测类别&lt;/h3&gt;
&lt;p&gt;最后一步是对文档进行分类。&lt;code&gt;DocMLCategorization&lt;/code&gt;项目包含了 ML.NET 的&lt;code&gt;Microsoft.ML&lt;/code&gt;包。虽然 Spark 使用的是 data frame，但 data view 在 ML.NET 中提供了类似的概念。&lt;/p&gt;
&lt;p&gt;这个例子为 ML.NET 使用了一个单独的项目，这样就可以将模型作为一个独立的步骤进行训练。对于许多场景，可以直接从你的.NET for Spark 项目中引用 ML.NET，并将 ML 作为同一工作的一部分来执行。&lt;/p&gt;
&lt;p&gt;首先，你必须对类进行标记，以便 ML.NET 知道源数据中的哪些列映射到类中的属性。在&lt;code&gt;FileData&lt;/code&gt; 类使用 &lt;code&gt;LoadColumn&lt;/code&gt; 注解，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[LoadColumn(0)]
public string File { get; set; }

[LoadColumn(1)]
public string Title { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，你可以为模型创建上下文，并从上一步中生成的文件中加载 data view：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var context = new MLContext(seed: 0);
var dataToTrain = context.Data
    .LoadFromTextFile&amp;lt;FileData&amp;gt;(path: filesHelper.ModelTrainingFile, hasHeader: true, allowQuoting: true, separatorChar: ',');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ML 算法对数字的处理效果最好，所以文档中的文本必须转换为数字向量。ML.NET 为此提供了&lt;code&gt;FeaturizeText&lt;/code&gt;方法。在一个步骤中，模型分别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检测语言&lt;/li&gt;
&lt;li&gt;将文本标记为单个单词或标记&lt;/li&gt;
&lt;li&gt;规范化文本，以便对单词的变体进行标准化和大小写相似化&lt;/li&gt;
&lt;li&gt;将这些术语转换为一致的数值或准备处理的“特征向量”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下代码将列转换为特征，然后创建一个结合了多个特征的“Features”列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var pipeline = context.Transforms.Text.FeaturizeText(
    nameof(FileData.Title).Featurized(),
    nameof(FileData.Title)).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Subtitle1).Featurized(),
    nameof(FileData.Subtitle1))).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Subtitle2).Featurized(),
    nameof(FileData.Subtitle2))).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Subtitle3).Featurized(),
    nameof(FileData.Subtitle3))).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Subtitle4).Featurized(),
    nameof(FileData.Subtitle4))).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Subtitle5).Featurized(),
    nameof(FileData.Subtitle5))).Append(context.Transforms.Text.FeaturizeText(nameof(FileData.Top20Words).Featurized(),
    nameof(FileData.Top20Words))).Append(context.Transforms.Concatenate(features, nameof(FileData.Title).Featurized(),
    nameof(FileData.Subtitle1).Featurized(),
    nameof(FileData.Subtitle2).Featurized(),
    nameof(FileData.Subtitle3).Featurized(),
    nameof(FileData.Subtitle4).Featurized(),
    nameof(FileData.Subtitle5).Featurized(),
    nameof(FileData.Top20Words).Featurized())
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，数据已经为训练模型做了适当的准备。训练是无监督的，这意味着它必须用一个例子来推断信息。你没有将样本类别输入到模型中，所以算法必须通过分析特征如何聚类来找出数据的相互关联。你将使用&lt;strong&gt;k-means 聚类&lt;/strong&gt;算法。该算法使用特征计算文档之间的“距离”，然后围绕分组后的文档“绘制”边界。该算法涉及随机化，因此两次运行结果会是不相同的。主要的挑战是确定训练的最佳聚类大小。不同的文档集最好有不同的最佳类别数，但算法需要你在训练前输入类别数。&lt;/p&gt;
&lt;p&gt;代码在 2 到 20 个簇之间迭代，以确定最佳大小。对于每次运行，它都会获取特征数据并应用算法或训练器。然后，它根据预测模型对现有数据进行转换。对结果进行评估，以确定每个簇中文档的平均距离，并选择平均距离最小的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var options = new KMeansTrainer.Options
{
    FeatureColumnName = features,
    NumberOfClusters = categories,
};

var clusterPipeline = pipeline.Append(context.Clustering.Trainers.KMeans(options));
var model = clusterPipeline.Fit(dataToTrain);
var predictions = model.Transform(dataToTrain);
var metrics = context.Clustering.Evaluate(predictions);
distances.Add(categories, metrics.AverageDistance);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过培训和评估后，你可以保存最佳模型，并使用它对数据集进行预测。将生成一个输出文件以及一个摘要，该摘要显示有关每个类别的一些元数据并在下面列出标题。标题只是几个功能之一，因此有时需要仔细研究细节才能使类别有意义。在本地测试中，教程之类的文档归于一组，API 文档归于另一组，而例外归于它们自己的组。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ML zip 文件可与 Prediction Engine 一起用于其他项目中的新数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;机器学习模型另存为单个 zip 文件。该文件可以包含在其他项目中，与 Prediction Engine 一起使用以对新数据进行预测。例如，你可以创建一个 WPF 应用程序，该应用程序允许用户浏览目录，然后加载并使用经过训练的模型对文档进行分类，而无需先对其进行训练。&lt;/p&gt;
&lt;h2 id=&quot;下一步是什么&quot;&gt;下一步是什么&lt;/h2&gt;
&lt;p&gt;Spark for .NET 计划与.NET 5 同时在 GA（译注：GA=General Availability，正式发布的版本）发布。请访问 &lt;a href=&quot;https://aka.ms/spark-net-roadmap&quot;&gt;https://aka.ms/spark-net-roadmap&lt;/a&gt; 阅读路线图和推出功能的计划。（译注：.NET 5 正式发布时间已过，Spark for .NET 已随 .NET 5 正式发布）&lt;/p&gt;
&lt;p&gt;本文着重于本地开发体验，为了充分利用大数据的力量，你可以将 Spark 作业提交到云中。有各种各样的云主机可以容纳 PB 级数据，并为你的工作负载提供数十个核的计算能力。Azure Synapse Analytics 是一项 Azure 服务，旨在承载大量数据，提供用于运行大数据作业的群集，并允许通过基于图表的仪表盘进行交互式探索。若要了解如何将 Spark for .NET 作业提交到 Azure Synapse，请阅读官方文档（&lt;a href=&quot;https://aka.ms/spark-net-synapse%EF%BC%89%E3%80%82&quot;&gt;https://aka.ms/spark-net-synapse）。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面这张表列举了 ML.NET 机器学习的常见任务和场景：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;任务&lt;/th&gt;
&lt;th&gt;示例场景&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;分类(基于文本) Classification&lt;/td&gt;
&lt;td&gt;将邮件信息分类为垃圾邮件或非垃圾邮件，或根据内容将调查评论分为不同的组别。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;回归 Regression&lt;/td&gt;
&lt;td&gt;根据二手车的品牌、型号、里程数来预测二手车的价格，或者根据广告预算来预测产品的销量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;预测 Forecasting&lt;/td&gt;
&lt;td&gt;根据过去的销售情况来预测未来产品的销售情况，或天气预报。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;异常检测 Anomaly detection&lt;/td&gt;
&lt;td&gt;检测产品在一段时间内的销售高峰或检测断电情况。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;排名 Ranking&lt;/td&gt;
&lt;td&gt;预测搜索引擎结果的最佳显示顺序，或为用户的新闻排序。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;聚类 Clustering&lt;/td&gt;
&lt;td&gt;对客户进行细分。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;推荐 Recommendation&lt;/td&gt;
&lt;td&gt;根据用户之前看的电影向用户推荐电影，或者推荐经常一起购买的产品。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;图像分类 Image classification&lt;/td&gt;
&lt;td&gt;对机器零件的图像进行分类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;对象检测 Object detection&lt;/td&gt;
&lt;td&gt;检测汽车图像上的车牌。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 16 Nov 2020 00:57:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>翻译：精致码农-王亮 原文：http://dwz.win/XnM .NET 5 旨在提供统一的运行时和框架，使其在各平台都有统一的运行时行为和开发体验。微软发布了与 .NET 协作的大数据（.NET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13983428.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core应用基本编程模式[4]：基于承载环境的编程 - Artech</title>
<link>http://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html</guid>
<description>&lt;p&gt;基于IHostBuilder/IHost的承载系统通过IHostEnvironment接口表示承载环境，我们利用它不仅可以得到当前部署环境的名称，还可以获知当前应用的名称和存放内容文件的根目录路径。对于一个Web应用来说，我们需要更多的承载环境信息，额外的信息定义在IWebHostEnvironment接口中。[本文节选自《ASP.NET Core 3框架揭秘》第11章, 更多关于ASP.NET Core的文章请点&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3.html&quot;&gt;这里&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、IWebHostEnvironment&lt;br/&gt;二、通过配置定制承载环境&lt;br/&gt;三、针对环境的编程&lt;br/&gt;     注册服务&lt;br/&gt;     注册中间件&lt;br/&gt;     配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如下面的代码片段所示，派生于IHostEnvironment接口的IWebHostEnvironment接口定义了两个属性：WebRootPath和WebRootFileProvider。WebRootPath属性表示用于存放Web资源文件根目录的路径，WebRootFileProvider属性则返回该路径对应的IFileProvider对象。如果我们希望外部可以采用HTTP请求的方式直接访问某个静态文件（如JavaScript、CSS和图片文件等），只需要将它存放于WebRootPath属性表示的目录之下即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebHostEnvironment : IHostEnvironment
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;     WebRootPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    IFileProvider WebRootFileProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面简单介绍与承载环境相关的6个属性（包含定义在IHostEnvironment接口中的4个属性）是如何设置的。IHostEnvironment 接口的ApplicationName代表当前应用的名称，它的默认值取决于注册的IStartup服务。IStartup服务旨在完成中间件的注册，不论是调用IWebHostBuilder接口的Configure方法，还是调用它的UseStartup/UseStartup&amp;lt;TStartup&amp;gt;方法，最终都是为了注册IStartup服务，所以这两个方法是不能被重复调用的。如果多次调用这两个方法，最后一次调用针对IStartup的服务注册会覆盖前面的注册。&lt;/p&gt;
&lt;p&gt;如果IStartup服务是通过调用IWebHostBuilder接口的Configure方法注册的，那么应用的名称由调用该方法提供的Action&amp;lt;IApplicationBuilder&amp;gt;对象来决定。具体来说，每个委托对象都会绑定到一个方法上，而方法是定义在某个类型中的，该类型所在程序集的名称会默认作为应用的名称。如果通过调用IWebHostBuilder接口的UseStartup/UseStartup&amp;lt;TStartup&amp;gt;方法来注册IStartup服务，那么注册的Startup类型所在的程序集名称就是应用名称。在默认情况下，针对应用名称的设置体现在如下所示的代码片段中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder Configure(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, Action&amp;lt;IApplicationBuilder&amp;gt;&lt;span&gt; configure)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; applicationName =&lt;span&gt; configure.GetMethodInfo().DeclaringType .GetTypeInfo().Assembly.GetName().Name;
    ...
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseStartup(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IWebHostBuilder hostBuilder,  Type startupType)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; applicationName =&lt;span&gt; startupType.GetTypeInfo().Assembly.GetName().Name;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EnvironmentName表示当前应用所处部署环境的名称，其中开发（Development）、预发（Staging）和产品（Production）是3种典型的部署环境。根据不同的目的可以将同一个应用部署到不同的环境中，在不同环境中部署的应用往往具有不同的设置。在默认情况下，环境的名称为Production。&lt;/p&gt;
&lt;p&gt;当我们编译发布一个ASP.NET Core项目时，项目的源代码文件会被编译成二进制并打包到相应的程序集中，而另外一些文件（如JavaScript、CSS和表示View的.cshtml文件等）会复制到目标目录中，我们将这些文件称为内容文件（Content File）。ASP.NET Core应用会将所有的内容文件存储在同一个目录下，这个目录的绝对路径通过IWebHostEnvironment接口的ContentRootPath属性来表示，而ContentRootFileProvider属性则返回针对这个目录的PhysicalFileProvider对象。部分内容文件可以直接作为Web资源（如JavaScript、CSS和图片等）供客户端以HTTP请求的方式获取，存放此种类型内容文件的绝对目录通过IWebHostEnvironment接口的WebRootPath属性来表示，而针对该目录的PhysicalFileProvider自然可以通过对应的WebRootFileProvider属性来获取。&lt;/p&gt;
&lt;p&gt;在默认情况下，由ContentRootPath属性表示的内容文件的根目录就是当前应用程序域的基础目录，也就是表示当前应用程序域的AppDomain对象的BaseDirectory属性返回的目录，静态类AppContext的BaseDirectory属性返回的也是这个目录。对于一个通过Visual Studio创建的 .NET Core项目来说，该目录就是编译后保存生成的程序集的目录（如“\bin\Debug\netcoreapp3.0”或者“\bin\Release\netcoreapp3.0”）。如果该目录下存在一个名为“wwwroot”的子目录，那么它将用来存放Web资源，WebRootPath属性将返回这个目录；如果这样的子目录不存在，那么WebRootPath属性会返回Null。针对这两个目录的默认设置体现在如下所示的代码片段中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {       
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builderUseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IWebHostEnvironment environment)
    {
        Debug.Assert(environment.ContentRootPath &lt;/span&gt;==&lt;span&gt; AppDomain.CurrentDomain.BaseDirectory);
        Debug.Assert(environment.ContentRootPath &lt;/span&gt;==&lt;span&gt; AppContext.BaseDirectory);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; wwwRoot = Path.Combine(AppContext.BaseDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wwwroot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Directory.Exists(wwwRoot))
        {
            Debug.Assert(environment.WebRootPath &lt;/span&gt;==&lt;span&gt; wwwRoot);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            Debug.Assert(environment.WebRootPath &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IWebHostEnvironment对象承载的4个与承载环境相关的属性（ApplicationName、EnvironmentName、ContentRootPath和WebRootPath）可以通过配置的方式进行定制，对应配置项的名称分别为applicationName、environment、contentRoot和webroot。如果记不住这些配置项的名称也没有关系，因为我们可以利用定义在静态类WebHostDefaults中如下所示的4个只读属性来得到它们的值。通过第11章的介绍可知，前三个配置项的名称同样以静态只读字段的形式定义在HostDefaults类型中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostDefaults
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnvironmentKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContentRootKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentRoot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ApplicationKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WebRootKey  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webroot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostDefaults
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnvironmentKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContentRootKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentRoot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ApplicationKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面演示如何通过配置的方式来设置当前的承载环境。在如下这段实例程序中，我们调用IWebHostBuilder接口的UseSetting方法针对上述4个配置项做了相应的设置。由于针对UseStartup&amp;lt;TStartup&amp;gt;方法的调用会设置应用的名称，所以通过调用UseSetting方法针对应用名称的设置需要放在后面才有意义。相对于当前目录（项目根目录）的两个子目录“contents”和“contents/web”是我们为ContentRootPath属性与WebRootPath属性设置的，由于系统会验证设置的目录是否存在，所以必须预先创建这两个目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureLogging(options &lt;/span&gt;=&amp;gt;&lt;span&gt; options.ClearProviders())
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Staging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contentRoot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contents&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webroot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contents/web&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApplicationName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        .Build()
        .Run();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IWebHostEnvironment environment)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApplicationName: {environment.ApplicationName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EnvironmentName: {environment.EnvironmentName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ContentRootPath: {environment.ContentRootPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebRootPath: {environment.WebRootPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) { }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在注册的Startup类型的构造函数中注入了IWebHostEnvironment服务，并直接将这4个属性输出到控制台上。我们在目录“C:\App”下运行这个程序后，设置的4个与承载相关的属性会以下图所示的形式呈现在控制台上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201116085520344-629937891.png&quot;&gt;&lt;img width=&quot;488&quot; height=&quot;244&quot; title=&quot;14&quot; alt=&quot;14&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201116085520827-1667939652.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于IWebHostEnvironment服务提供的应用名称会被视为一个程序集名称，针对它的设置会影响类型的加载，所以我们基本上不会设置应用的名称。至于其他3个属性，除了采用最原始的方式设置相应的配置项，我们还可以直接调用IWebHostBuilder接口中如下3个对应的扩展方法来设置。通过本系列之前文章介绍可知，IHostBuilder接口也有类似的扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingAbstractionsWebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseEnvironment(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; environment);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseContentRoot(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentRoot);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseWebRoot(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; webRoot);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseContentRoot(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentRoot);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder UseEnvironment(&lt;span&gt;this&lt;/span&gt; IHostBuilder hostBuilder,  &lt;span&gt;string&lt;/span&gt;&lt;span&gt; environment);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于同一个ASP.NET Core应用来说，我们添加的服务注册、提供的配置和注册的中间件可能会因部署环境的不同而有所差异。有了这个可以随意注入的IWebHostEnvironment服务，我们可以很方便地知道当前的部署环境并进行有针对性的差异化编程。&lt;/p&gt;
&lt;p&gt;IHostEnvironment接口提供了如下这个名为IsEnvironment的扩展方法，用于确定当前是否为指定的部署环境。除此之外，IHostEnvironment接口还提供额外3个扩展方法来进行针对3种典型部署环境（开发、预发和产品）的判断，这3种环境采用的名称分别为Development、Staging和Production，对应静态类型EnvironmentName的3个只读字段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostEnvironmentEnvExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsDevelopment(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsProduction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsStaging(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHostEnvironment hostEnvironment); 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsEnvironment(&lt;span&gt;this&lt;/span&gt; IHostEnvironment hostEnvironment, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; environmentName);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnvironmentName
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Development = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Staging     = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Staging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Production = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Production&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注册服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面先介绍针对环境的服务注册。ASP.NET Core应用提供了两种服务注册方式：第一种是调用IWebHostBuilder接口的ConfigureServices方法；第二种是调用UseStartup方法或者UseStartup&amp;lt;TStartup&amp;gt;方法注册一个Startup类型，并在其ConfigureServices方法中完成服务注册。对于第一种服务注册方式，用于注册服务的ConfigureServices方法具有一个参数类型为Action&amp;lt;WebHostBuilderContext, IServiceCollection&amp;gt;的重载，所以我们可以利用提供的WebHost&lt;br/&gt;BuilderContext对象以如下所示的方式针对具体的环境注册相应的服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .ConfigureServices((context,svcs)&lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.HostingEnvironment.IsDevelopment())
                {
                    svcs.AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foo&amp;gt;&lt;span&gt;();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    svcs.AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Bar&amp;gt;&lt;span&gt;();
                }
            }))
            .Build()
            .Run();
    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果利用Startup类型来添加服务注册，我们就可以按照如下所示的方式通过构造函数注入的方式得到所需的IWebHostEnvironment服务，并在ConfigureServices方法中根据它提供的环境信息来注册对应的服务。另外，Startup类型的ConfigureServices方法要么是无参的，要么具有一个类型为IServiceCollection的参数，所以我们无法直接在这个方法中注入IWebHost&lt;br/&gt;Environment服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IWebHostEnvironment _environment;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Startup(IWebHostEnvironment environment) =&amp;gt; _environment =&lt;span&gt; environment;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection svcs)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_environment.IsDevelopment())
        {
            svcs.AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foo&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            svcs.AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Bar&amp;gt;&lt;span&gt;();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了在注册Startup类型中的ConfigureServices方法完成针对承载环境的服务注册，我们还可以将针对某种环境的服务注册实现在对应的Configure{EnvironmentName}Services方法中。上面定义的Startup类型完全可以改写成如下形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureDevelopmentServices(IServiceCollection svcs)=&amp;gt; svcs.AddSingleton&amp;lt;IFoobar, Foo&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection svcs)=&amp;gt; svcs.AddSingleton&amp;lt;IFoobar, Bar&amp;gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注册中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与服务注册类似，中间件的注册同样具有两种方式：一种是直接调用IWebHostBuilder接口的Configure方法；另一种则是调用注册的Startup类型的同名方法。不管采用何种方式，中间件都是借助IApplicationBuilder对象来注册的。由于针对应用程序的IServiceProvider对象可以通过其ApplicationServices属性获得，所以我们可以利用它提供承载环境信息的IWebHostEnvironment服务，进而按照如下所示的方式实现针对环境的中间件注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .Configure(app&lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; environment = app.ApplicationServices.GetRequiredService&amp;lt;IWebHostEnvironment&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (environment.IsDevelopment())
                {
                    app.UseMiddleware&lt;/span&gt;&amp;lt;FooMiddleware&amp;gt;&lt;span&gt;();
                }
                app
                    .UseMiddleware&lt;/span&gt;&amp;lt;BarMiddleware&amp;gt;&lt;span&gt;()
                    .UseMiddleware&lt;/span&gt;&amp;lt;BazMiddleware&amp;gt;&lt;span&gt;();
            }))                       
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，用于注册中间件的IApplicationBuilder接口还有UseWhen的扩展方法。顾名思义，这个方法可以帮助我们根据指定的条件来注册对应的中间件。注册中间件的前提条件可以通过一个Func&amp;lt;HttpContext, bool&amp;gt;对象来表示，对于某个具体的请求来说，只有对应的HttpContext对象满足该对象设置的断言，指定的中间件注册操作才会生效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseWhenExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseWhen(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app,  Func&amp;lt;HttpContext, &lt;span&gt;bool&lt;/span&gt;&amp;gt; predicate, Action&amp;lt;IApplicationBuilder&amp;gt;&lt;span&gt; configuration);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果调用UseWhen方法来实现针对具体环境注册对应的中间件，我们就可以按照如下所示的方式利用HttpContext来提供针对当前请求的IServiceProvider对象，进而得到承载环境信息的IWebHostEnvironment服务，最终根据提供的环境信息进行有针对性的中间件注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .Configure(app&lt;/span&gt;=&amp;gt;&lt;span&gt; app
                .UseWhen(context&lt;/span&gt;=&amp;gt;context.RequestServices.GetRequiredService&amp;lt;IWebHostEnvironment&amp;gt;&lt;span&gt;().IsDevelopment(),
                    builder &lt;/span&gt;=&amp;gt; builder.UseMiddleware&amp;lt;FooMiddleware&amp;gt;&lt;span&gt;())
                .UseMiddleware&lt;/span&gt;&amp;lt;BarMiddleware&amp;gt;&lt;span&gt;()
                .UseMiddleware&lt;/span&gt;&amp;lt;BazMiddleware&amp;gt;&lt;span&gt;()))
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果应用注册了Startup类型，那么针对环境的中间件注册就更加简单，因为用来注册中间件的Configure方法自身是可以注入任意依赖服务的，所以我们可以在该方法中按照如下所示的方式直接注入IWebHostEnvironment服务来提供环境信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IWebHostEnvironment environment)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (environment.IsDevelopment())
        {
            app.UseMiddleware&lt;/span&gt;&amp;lt;FooMiddleware&amp;gt;&lt;span&gt;();
        }
        app
            .UseMiddleware&lt;/span&gt;&amp;lt;BarMiddleware&amp;gt;&lt;span&gt;()
            .UseMiddleware&lt;/span&gt;&amp;lt;BazMiddleware&amp;gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与服务注册类似，针对环境的中间件注册同样可以定义在对应的Configure{EnvironmentName}方法中，上面这个Startp类型完全可以改写成如下形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureDevelopment (IApplicationBuilder app)
    {
        app.UseMiddleware&lt;/span&gt;&amp;lt;FooMiddleware&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
    {
        app
            .UseMiddleware&lt;/span&gt;&amp;lt;BarMiddleware&amp;gt;&lt;span&gt;()
            .UseMiddleware&lt;/span&gt;&amp;lt;BazMiddleware&amp;gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面介绍了针对环境的服务和中间件注册，下面介绍如何根据当前的环境来提供有针对性的配置。通过前面的介绍可知，IWebHostBuilder接口提供了一个名为Configure&lt;br/&gt;AppConfiguration的方法，我们可以调用这个方法来注册相应的IConfigureSource对象。这个方法具有一个类型为Action&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt;的参数，所以可以通过提供的这个WebHostBuilderContext上下文得到提供环境信息的IWebHostEnvironment对象。&lt;/p&gt;
&lt;p&gt;如果采用配置文件，我们可以将配置内容分配到多个文件中。例如，我们可以将与环境无关的配置定义在Appsettings.json文件中，然后针对具体环境提供对应的配置文件Appsettings.&lt;br/&gt;{EnvironmentName}.json（如Appsettings.Development.json、Appsettings.Staging.json和Appsettings.&lt;br/&gt;Production.json）。最终我们可以按照如下所示的方式将针对这两类配置文件的IConfigureSource注册到提供的IConfigurationBuilder对象上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html&quot;&gt;ASP.NET Core编程模式[1]：管道式的请求处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html&quot;&gt;ASP.NET Core编程模式[2]：依赖注入的运用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html&quot;&gt;ASP.NET Core编程模式[3]：配置多种使用形式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html&quot;&gt;ASP.NET Core编程模式[4]：基于承载环境的编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-5.html&quot;&gt;ASP.NET Core编程模式[5]：如何放置你的初始化代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:56:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录一、IWebHostEnvironment 二、通过配置定制承载环境 三、针对环境的编程 注册服务 注册中间件 配置 一、IWebHostEnvironment 二、通过配置定制承载环境 三、针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html</dc:identifier>
</item>
<item>
<title>JAVA中常见的阻塞队列详解 - AnonyStar</title>
<link>http://www.cnblogs.com/i-code/p/13983419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i-code/p/13983419.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085210744-2073386236.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在之前的线程池的介绍中我们看到了很多阻塞队列，这篇文章我们主要来说说阻塞队列的事。&lt;/li&gt;
&lt;li&gt;阻塞队列也就是 &lt;code&gt;BlockingQueue&lt;/code&gt; ，这个类是一个接&lt;/li&gt;
&lt;li&gt;口，同时继承了 &lt;code&gt;Queue&lt;/code&gt; 接口，这两个接口都是在&lt;code&gt;JDK5&lt;/code&gt; 中加入的 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlockingQueue&lt;/code&gt; 阻塞队列是线程安全的，在我们业务中是会经常频繁使用到的，如典型的生产者消费的场景，生产者只需要向队列中添加，而消费者负责从队列中获取。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085212100-48677601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如上图展示，我们生产者线程不断的&lt;code&gt;put&lt;/code&gt; 元素到队列，而消费者从中&lt;code&gt;take&lt;/code&gt; 出元素处理，这样实现了任务与执行任务类之间的解耦，任务都被放入到了阻塞队列中，这样生产者和消费者之间就不会直接相互访问实现了隔离提高了安全性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;并发队列&quot;&gt;并发队列&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085212495-587651545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上面是 &lt;code&gt;Java&lt;/code&gt; 中队列&lt;code&gt;Queue&lt;/code&gt; 类的类图，我们可以看到它分为两大类，&lt;strong&gt;阻塞队列与非阻塞队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;阻塞队列的实现接口是 &lt;code&gt;BlockingQueue&lt;/code&gt; 而非阻塞队列的接口是 &lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt; , 本文主要介绍阻塞队列，非阻塞队列不再过多阐述&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlockingQueue&lt;/code&gt; 主要有下面六个实现类，分别是 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;、&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;、&lt;code&gt;SynchronousQueue&lt;/code&gt;、&lt;code&gt;DelayQueue&lt;/code&gt;、&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;、&lt;code&gt;LinkedTransferQueue&lt;/code&gt; 。这些阻塞队列有着各自的特点和适用场景，后面详细介绍。&lt;/li&gt;
&lt;li&gt;非阻塞队列的典型例子如 &lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt; , 它不会阻塞线程，而是利用了 &lt;code&gt;CAS&lt;/code&gt; 来保证线程的安全。&lt;/li&gt;
&lt;li&gt;其实还有一个队列和 &lt;code&gt;Queue&lt;/code&gt; 关系很紧密，那就是&lt;code&gt;Deque&lt;/code&gt;，这其实是 &lt;code&gt;double-ended-queue&lt;/code&gt; 的缩写，意思是双端队列。它的特点是从头部和尾部都能添加和删除元素，而我们常见的普通队列&lt;code&gt;Queue&lt;/code&gt; 则是只能一端进一端出，即&lt;code&gt;FIFO&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;阻塞队列特点&quot;&gt;阻塞队列特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;阻塞队列的特点就在于阻塞，它可以阻塞线程，让生产者消费者得以平衡，阻塞队列中有两个关键方法 &lt;code&gt;Put&lt;/code&gt; 和 &lt;code&gt;Take&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;take方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;take&lt;/code&gt; 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 &lt;code&gt;take&lt;/code&gt; 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。过程如图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085213625-1488568057.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;put方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;put&lt;/code&gt; 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中。过程如图所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085214330-1428051951.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;是否有界（容量有多大）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此外，阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。&lt;/li&gt;
&lt;li&gt;无界队列意味着里面可以容纳非常多的元素，例如 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 的上限是 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，约为 2 的 31 次方，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。&lt;/li&gt;
&lt;li&gt;但是有的阻塞队列是有界的，例如 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;阻塞队列常见方法&quot;&gt;阻塞队列常见方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先我们从常用的方法出发，根据各自的特点我们可以大致分为三个大类，如下表所示：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;抛出异常&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;如果队列已满，添加则抛出  &lt;code&gt;IllegalStateException&lt;/code&gt; 异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;删除队列头节点&lt;/td&gt;
&lt;td&gt;当队列为空后，删除则抛出  &lt;code&gt;NoSuchElementException&lt;/code&gt; 异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;element&lt;/td&gt;
&lt;td&gt;获取队列头元素&lt;/td&gt;
&lt;td&gt;当队列为空时，则抛出 &lt;code&gt;NoSuchElementException&lt;/code&gt; 异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;返回无异常&lt;/td&gt;
&lt;td&gt;offer&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;当队列已满，不会报异常，返回  &lt;code&gt;false&lt;/code&gt; ，如果成功返回 &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td/&gt;
&lt;td&gt;poll&lt;/td&gt;
&lt;td&gt;获取队列头节点，并且删除它&lt;/td&gt;
&lt;td&gt;当队列空时，返回  &lt;code&gt;Null&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;peek&lt;/td&gt;
&lt;td&gt;单纯获取头节点&lt;/td&gt;
&lt;td&gt;当队列为空时反馈 &lt;code&gt;NULL&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;阻塞&lt;/td&gt;
&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;如果队列已满则阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;take&lt;/td&gt;
&lt;td&gt;返回并删除头元素&lt;/td&gt;
&lt;td&gt;如果队列为空则阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;如上面所示主要的八个方法，相对都比较简单，下面我们通过实际代码演示的方式来认识&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;抛异常类型add、remove、element&quot;&gt;抛异常类型[add、remove、element]&lt;/h3&gt;
&lt;h4 id=&quot;add&quot;&gt;add&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;向队列中添加一个元素。如果队列是有界队列，当队列已满时再添加则抛出异常提示，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        BlockingQueue queue = new ArrayBlockingQueue(2);
        queue.add(1);
        queue.add(2);
        queue.add(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上述代码中我们创建了一个阻塞队列容量为2，当我们使用 &lt;code&gt;add&lt;/code&gt; 向其中添加元素，当添加到第三个时则会抛出异常如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085214949-814882568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;remove&quot;&gt;remove&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;remove&lt;/code&gt; 方法是从队列中删除队列的头节点，同时会返回该元素。当队列中为空时执行 &lt;code&gt;remove&lt;/code&gt; 方法时则会抛出异常，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void groupRemove() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        queue.add(&quot;i-code.online&quot;);
        System.out.println(queue.remove());
        System.out.println(queue.remove());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上述代码中，我们可以看到，我们想队列中添加了一个元素 &lt;code&gt;i-code.online&lt;/code&gt; , 之后通过 &lt;code&gt;remove&lt;/code&gt; 方法进行删除，当执行第二次&lt;code&gt;remove&lt;/code&gt; 时队列内已无元素，则抛出异常。如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085215221-175516982.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;element&quot;&gt;element&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;element&lt;/code&gt; 方法是获取队列的头元素，但是并不是删除该元素，这也是与 &lt;code&gt;remove&lt;/code&gt; 的区别，当队列中没有元素后我们再执行 &lt;code&gt;element&lt;/code&gt; 方法时则会抛出异常，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void groupElement() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        queue.add(&quot;i-code.online&quot;);
        System.out.println(queue.element());
        System.out.println(queue.element());
    }
    private static void groupElement2() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        System.out.println(queue.element());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面两个方法分别演示了在有元素和无元素的情况&lt;code&gt;element&lt;/code&gt; 的使用。在第一个方法中并不会报错，因为首元素一直存在的，第二个方法中因为空的，所以抛出异常，如下结果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085215795-1657815880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;无异常类型offer、poll、peek&quot;&gt;无异常类型[offer、poll、peek]&lt;/h3&gt;
&lt;h4 id=&quot;offer&quot;&gt;offer&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;offer&lt;/code&gt; 方法是向队列中添加元素, 同时反馈成功与失败，如果失败则返回 &lt;code&gt;false&lt;/code&gt; ，当队列已满时继续添加则会失败，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void groupOffer() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        System.out.println(queue.offer(&quot;i-code.online&quot;));
        System.out.println(queue.offer(&quot;云栖简码&quot;));
        System.out.println(queue.offer(&quot;AnonyStar&quot;));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如上述代码所示，我们向一个容量为2的队列中通过&lt;code&gt;offer&lt;/code&gt; 添加元素，当添加第三个时，则会反馈 &lt;code&gt;false&lt;/code&gt; ，如下结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
true
true
false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;poll&lt;/code&gt; 方法对应上面 &lt;code&gt;remove&lt;/code&gt; 方法，两者的区别就在于是否会在无元素情况下抛出异常，&lt;code&gt;poll&lt;/code&gt; 方法在无元素时不会抛出异常而是返回&lt;code&gt;null&lt;/code&gt; ，如下代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void groupPoll() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        System.out.println(queue.offer(&quot;云栖简码&quot;)); //添加元素
        System.out.println(queue.poll()); //取出头元素并且删除
        System.out.println(queue.poll());

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面代码中我们创建一个容量为2的队列，并添加一个元素，之后调用两次&lt;code&gt;poll&lt;/code&gt;方法来获取并删除头节点，发现第二次调用时为&lt;code&gt;null&lt;/code&gt; ，因为队列中已经为空了，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
true
云栖简码
null
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;peek&quot;&gt;peek&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;peek&lt;/code&gt; 方法与前面的 &lt;code&gt;element&lt;/code&gt; 方法是对应的 ，获取元素头节点但不删除，与其不同的在于&lt;code&gt;peek&lt;/code&gt; 方法在空队列下并不会抛出异常，而是返回 &lt;code&gt;null&lt;/code&gt;，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static void groupPeek() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        System.out.println(queue.offer(1));
        System.out.println(queue.peek());
        System.out.println(queue.peek());
    }
    private static void groupPeek2() {
        BlockingQueue queue = new ArrayBlockingQueue(2);
        System.out.println(queue.peek());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如上述代码所示，我么们分别展示了非空队列与空队列下&lt;code&gt;peek&lt;/code&gt; 的使用，结果如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202011/2024393-20201116085216114-1907720397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;阻塞类型put、take&quot;&gt;阻塞类型[put、take]&lt;/h3&gt;
&lt;h4 id=&quot;put&quot;&gt;put&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;put&lt;/code&gt; 方法是向队列中添加一个元素，这个方法是阻塞的，也就是说当队列已经满的情况下，再&lt;code&gt;put&lt;/code&gt;元素时则会阻塞，直到队列中有空位.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;take&quot;&gt;take&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;take&lt;/code&gt; 方法是从队列中获取头节点并且将其移除，这也是一个阻塞方法，当队列中已经没有元素时，&lt;code&gt;take&lt;/code&gt; 方法则会进入阻塞状态，直到队列中有新的元素进入。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;常见的阻塞队列&quot;&gt;常见的阻塞队列&lt;/h2&gt;
&lt;h3 id=&quot;arrayblockingqueue&quot;&gt;ArrayBlockingQueue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 是一个我们常用的典型的&lt;strong&gt;有界队列&lt;/strong&gt;，其内部的实现是基于数组来实现的，我们在创建时需要指定其长度，它的线程安全性由 &lt;code&gt;ReentrantLock&lt;/code&gt; 来实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ArrayBlockingQueue(int capacity) {...}
public ArrayBlockingQueue(int capacity, boolean fair) {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如上所示，&lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 提供的构造函数中，我们需要指定队列的长度，同时我们也可以设置队列是都是公平的，当我们设置了容量后就不能再修改了，符合数组的特性，此队列按照先进先出（&lt;code&gt;FIFO&lt;/code&gt;）的原则对元素进行排序。&lt;/li&gt;
&lt;li&gt;和 &lt;code&gt;ReentrantLock&lt;/code&gt; 一样，如果 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt; 被设置为非公平的，那么就存在插队的可能；如果设置为公平的，那么等待了最长时间的线程会被优先处理，其他线程不允许插队，不过这样的公平策略同时会带来一定的性能损耗，因为非公平的吞吐量通常会高于公平的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linkedblockingqueue&quot;&gt;LinkedBlockingQueue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;从它的名字我们可以知道，它是一个由链表实现的队列，这个队列的长度是 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; ，这个值是非常大的，几乎无法达到，对此我们可以认为这个队列基本属于一个无界队列（也又认为是有界队列）。此队列按照先进先出的顺序进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;synchronousqueue&quot;&gt;SynchronousQueue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronousQueue&lt;/code&gt; 是一个不存储任何元素的阻塞队列，每一个&lt;code&gt;put&lt;/code&gt;操作必须等待&lt;code&gt;take&lt;/code&gt;操作，否则不能添加元素。同时它也支持公平锁和非公平锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;synchronousQueue&lt;/code&gt; 的容量并不是1，而是0。因为它本身不会持有任何元素，它是直接传递的，&lt;code&gt;synchronousQueue&lt;/code&gt; 会把元素从生产者直接传递给消费者，在这个过程中能够是不需要存储的&lt;/li&gt;
&lt;li&gt;在我们之前介绍过的线程池 &lt;code&gt;CachedThreadPool&lt;/code&gt; 就是利用了该队列。&lt;code&gt;Executors.newCachedThreadPool()&lt;/code&gt;，因为这个线程池它的最大线程数是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，它是更具需求来创建线程，所有的线程都是临时线程，使用完后空闲60秒则被回收，&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;priorityblockingqueue&quot;&gt;PriorityBlockingQueue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PriorityBlockingQueue&lt;/code&gt; 是一个支持优先级排序的无界阻塞队列，可以通过自定义实现 &lt;code&gt;compareTo()&lt;/code&gt; 方法来指定元素的排序规则，或者通过构造器参数 &lt;code&gt;Comparator&lt;/code&gt; 来指定排序规则。&lt;strong&gt;但是需要注意插入队列的对象必须是可比较大小的，也就是 &lt;code&gt;Comparable&lt;/code&gt; 的，否则会抛出 &lt;code&gt;ClassCastException&lt;/code&gt; 异常。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;它的 &lt;code&gt;take&lt;/code&gt; 方法在队列为空的时候会阻塞，但是正因为它是无界队列，而且会自动扩容，所以它的队列永远不会满，所以它的 &lt;code&gt;put&lt;/code&gt; 方法永远不会阻塞，添加操作始终都会成功&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;delayqueue&quot;&gt;DelayQueue&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DelayQueue&lt;/code&gt; 是一个实现&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;的延迟获取的无界队列。具有“延迟”的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DelayQueue&lt;/code&gt; 应用场景：1. 缓存系统的设计：可以用&lt;code&gt;DelayQueue&lt;/code&gt;保存缓存元素的有效期，使用一个线程循环查询&lt;code&gt;DelayQueue&lt;/code&gt;，一旦能从&lt;code&gt;DelayQueue&lt;/code&gt;中获取元素时，表示缓存有效期到了。2. 定时任务调度。使用&lt;code&gt;DelayQueue&lt;/code&gt;保存当天将会执行的任务和执行时间，一旦从&lt;code&gt;DelayQueue&lt;/code&gt;中获取到任务就开始执行，从比如&lt;code&gt;TimerQueue&lt;/code&gt;就是使用&lt;code&gt;DelayQueue&lt;/code&gt;实现的。&lt;/li&gt;
&lt;li&gt;它是无界队列，放入的元素必须实现 &lt;code&gt;Delayed&lt;/code&gt; 接口，而 &lt;code&gt;Delayed&lt;/code&gt; 接口又继承了 &lt;code&gt;Comparable&lt;/code&gt; 接口，所以自然就拥有了比较和排序的能力，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Delayed extends Comparable&amp;lt;Delayed&amp;gt; {
    long getDelay(TimeUnit unit);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以看出 &lt;code&gt;Delayed&lt;/code&gt; 接口继承 &lt;code&gt;Comparable&lt;/code&gt;，里面有一个需要实现的方法，就是  &lt;code&gt;getDelay&lt;/code&gt;。这里的 &lt;code&gt;getDelay&lt;/code&gt; 方法返回的是“还剩下多长的延迟时间才会被执行”，如果返回 0 或者负数则代表任务已过期。&lt;/li&gt;
&lt;li&gt;元素会根据延迟时间的长短被放到队列的不同位置，越靠近队列头代表越早过期。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;6.0520833333333&quot;&gt;
&lt;p&gt;本文由AnonyStar 发布,可转载但需声明原文出处。&lt;br/&gt;欢迎关注微信公账号 ：云栖简码 获取更多优质文章&lt;br/&gt;更多文章关注笔者博客 ：&lt;a href=&quot;https://i-code.online/&quot;&gt;云栖简码 i-code.online&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:52:00 +0000</pubDate>
<dc:creator>AnonyStar</dc:creator>
<og:description>在之前的线程池的介绍中我们看到了很多阻塞队列，这篇文章我们主要来说说阻塞队列的事。 阻塞队列也就是 BlockingQueue ，这个类是一个接 口，同时继承了 Queue 接口，这两个接口都是在JD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i-code/p/13983419.html</dc:identifier>
</item>
<item>
<title>看了齐姐这篇文章，再也不怕面试问树了 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13983395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13983395.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;微信搜索🔍「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在写完了所有线性数据结构之后，今天开启非线性数据结构系列。&lt;/p&gt;
&lt;p&gt;我们今天先来看，什么是“树”。&lt;/p&gt;
&lt;p&gt;树是由顶点和边组成的且不存在环的数据结构。&lt;strong&gt;作为一个应用非常广的数据结构，不仅在工作中常用，在面试中也非常常考。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一是因为树的结构天然决定了它和递归联系紧密，很多树相关的算法题都非常适合用递归来解；&lt;/p&gt;
&lt;p&gt;二是因为它的难度介于链表和图之间，非常适合在 45 分钟的面试里进行考察，所以一场面试中遇到两三轮问树都是再正常不过的了。&lt;/p&gt;
&lt;p&gt;本文先来讲树的基础内容，分为以下小节，每个小节开头都会有思维导图和对应的 &lt;code&gt;Leetcode&lt;/code&gt; 算法题哟～&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;金融里的二叉树&lt;/li&gt;
&lt;li&gt;树的所有概念&lt;br/&gt;a. 树的&lt;strong&gt;三大特点&lt;/strong&gt;&lt;br/&gt;b. 树的&lt;strong&gt;五大品种&lt;/strong&gt;&lt;br/&gt;c. 高度和深度&lt;/li&gt;
&lt;li&gt;看树的角度&lt;br/&gt;a. 三种 &lt;code&gt;DFS&lt;/code&gt; 遍历方式&lt;br/&gt;b. 两种 &lt;code&gt;BFS&lt;/code&gt; 遍历方式&lt;br/&gt;c. 四种视图&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;鉴于树相关的内容太多，而且又是面试重点内容，之后会有文章再专门来讲&lt;strong&gt;树有关的解题思路&lt;/strong&gt;以及最常用的&lt;strong&gt;二叉搜索树&lt;/strong&gt;，大家敬请期待～&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;其实数据结构里的“树”和我们现实世界里的树挺像的，只不过倒过来了嘛，根朝上。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084113538-183480719.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这片森林里，最常用的还是「二叉树」。&lt;/p&gt;
&lt;p&gt;二叉树，是由很多个 &lt;code&gt;TreeNode&lt;/code&gt; 构成的这种树形的数据结构，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像链表中的 &lt;code&gt;ListNode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;二叉树并不一定非得是“二叉”的，而是说每个节点&lt;strong&gt;最多&lt;/strong&gt;有两个孩子，叫 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;，但也可以没有。&lt;/p&gt;
&lt;p&gt;当每个节点都只有一个孩子的时候，就退化成了链表。&lt;/p&gt;
&lt;p&gt;所以&lt;strong&gt;链表就是一棵特殊的树，而树是一个特殊的图。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;金融里的二叉树&quot;&gt;金融里的二叉树&lt;/h2&gt;
&lt;p&gt;大家知道我是金融背景的，所以我最开始了解二叉树是在金融工程课程中给衍生品定价，这里也简单梳理下，不感兴趣的小伙伴可以跳过这一段。&lt;/p&gt;
&lt;p&gt;在金融工程里，二叉树是用来在风险中性世界里给期权定价使用的模型。&lt;/p&gt;
&lt;p&gt;比如这是一个股价二叉树，其实就是我们把二叉树放倒了看嘛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084115245-1335507773.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有些小伙伴会发现，这里的节点好像少了很多，没错，因为我们让股价每次上涨和下跌的幅度保持不变，所以到第 n 层最多有 n 个节点，而不会像普通的二叉树一样按照等比序列增长。&lt;/p&gt;
&lt;p&gt;上图是两期的二叉树，那么最简单的一期的二叉树定价模型表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084116023-1299458064.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们假设当前股票的价格为 &lt;code&gt;S&lt;/code&gt;，那我们想知道未来某个时刻比如 &lt;code&gt;t 时刻&lt;/code&gt;的价格，股价有可能上涨也有可能下跌，还可能不变呢。&lt;/p&gt;
&lt;p&gt;在该模型里我们就抽象成两种可能性，一种是上涨，一种是下跌，所以可以用二叉树来表示。&lt;/p&gt;
&lt;p&gt;假设股票价格会有 &lt;code&gt;p&lt;/code&gt; 的概率上涨至 &lt;code&gt;uS&lt;/code&gt;,&lt;br/&gt;有 &lt;code&gt;1-p&lt;/code&gt; 的概率下跌至 &lt;code&gt;dS&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;p&lt;/code&gt; 并不是在真实世界里股票上涨的概率，而是一个在风险中性世界里的上涨概率，所以&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;股票现在的价格就是未来某时刻的无风险收益的折现&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;$$S = e^{-rt}[pS_u + (1-p) S_d] $$&lt;/p&gt;
&lt;p&gt;这就是最简单的二叉树定价模型。&lt;/p&gt;
&lt;p&gt;那我们言归正传。&lt;/p&gt;
&lt;h2 id=&quot;树的所有概念&quot;&gt;树的所有概念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084119942-65829459.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-三大特点&quot;&gt;1. 三大特点&lt;/h3&gt;
&lt;p&gt;树的三大特点是：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果把树看成一个无向图，那么它是一个&lt;strong&gt;连通图&lt;/strong&gt; &lt;code&gt;connected graph&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;树是一个&lt;strong&gt;无环图&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;树的节点个数和边的个数之间的关系是固定的。如果树上有 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;node&lt;/code&gt;，那么它有 &lt;code&gt;n-1&lt;/code&gt; 条边。因为除了根节点，其他的节点都会有一条边指向它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-树的品种&quot;&gt;2. 树的品种&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1 平衡二叉树&lt;/strong&gt; &lt;code&gt;Balanced Binary Tree&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：对于这棵树里的&lt;strong&gt;每个节点&lt;/strong&gt;，它的左子树和右子树的高度差不大于 1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里要注意，是对于&lt;strong&gt;每个节点&lt;/strong&gt;，而不只是对于根结点。&lt;/p&gt;
&lt;p&gt;比如左边这棵树就不是平衡二叉树，右边的才是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084121926-372059192.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么大名鼎鼎的 &lt;code&gt;AVL-Tree&lt;/code&gt; 就是平衡二叉树，准确说是自平衡二叉查找树。&lt;/p&gt;
&lt;p&gt;那什么是二叉查找树呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 二叉查找树&lt;/strong&gt; &lt;code&gt;Binary Search Tree&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：对于这棵树里的每个节点，
&lt;ul&gt;&lt;li&gt;它左子树里的每个节点的值都小于它的值；&lt;/li&gt;
&lt;li&gt;它右子树里的每个节点的值都大于它的值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084124089-645041065.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对二叉查找树，最重要的性质就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在做中序遍历时，这个序列是一个升序序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你在做二叉查找树的算法题没有思路时，可以想想这个性质，很多题目都会迎刃而解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 完全二叉树&lt;/strong&gt; &lt;code&gt;Complete Binary Tree&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：除了最后一层，其他层都是满的，那么最后一层的节点要靠左排列且中间不允许有气泡。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如左边不是完全二叉树，右边的是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084125676-2049971048.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如堆就是一个完全二叉树，还不了解堆的基本操作的，公众号内回复「堆」获取文章复习哟～&lt;/p&gt;
&lt;p&gt;那么完全二叉树的最大的好处就是因为它排列紧密没有气泡，所以可以用数组来存储，这样就大大节省了内存空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4 完美二叉树&lt;/strong&gt; &lt;code&gt;Perfect Binary Tree&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：所有层的所有节点都必须是满的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完美二叉树比完全二叉树的定义更加严格，包括最后一层，每一层的节点都要是满的，毕竟是追求完美的嘛。&lt;/p&gt;
&lt;p&gt;所以我们如果知道了层数，就知道了它有多少个节点，也就是一个等比数列求和。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084128537-18094558.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.5 完满二叉树&lt;/strong&gt; &lt;code&gt;Full Tree&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：对于这棵树的每个节点而言，要么有 0 个孩子，要么有 2 个孩子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/2.%20公众号/18.%20Tree/1.%20基础篇/图/3.2.5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家不要轻视这些概念哦，很多算法题都会直接考察，在本节的思维导图里也附带了 Leetcode 对应的题目，电面时很喜欢考哦～&lt;/p&gt;
&lt;h3 id=&quot;3-高度和深度&quot;&gt;3. 高度和深度&lt;/h3&gt;
&lt;p&gt;树的高度 &lt;code&gt;height&lt;/code&gt; 和深度 &lt;code&gt;depth&lt;/code&gt; 是两个非常重要的概念，比如 Leetcode 104 和 111 就是专门求树的高度的。&lt;/p&gt;
&lt;p&gt;而这两个概念是相反方向的，大体上呢，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;高度是从当前节点到叶子 🍃 节点的；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深度是从当前节点到根 🌲 节点的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084129667-1768251961.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度&lt;/strong&gt; &lt;code&gt;Height&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：从该节点，到以该节点为根节点的这棵树的最远的叶子结点的最长距离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;核心是，从该节点到最远叶子节点，有几条边。&lt;/p&gt;
&lt;p&gt;这个概念在分析时空复杂度时非常常用，比如在树上做一个递归复杂度是 O(height)。&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;p&gt;因为这个距离决定了在 &lt;code&gt;call stack&lt;/code&gt; 上有多少层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度&lt;/strong&gt; &lt;code&gt;Depth&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义：从这个节点到根节点的距离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个概念用的比较少，是和高度方向相反的概念。&lt;/p&gt;
&lt;h2 id=&quot;看树的角度&quot;&gt;看树的角度&lt;/h2&gt;
&lt;p&gt;俗话说，横看成岭侧成峰，这句话用在这里太合适不过了。&lt;/p&gt;
&lt;p&gt;对于树的几种遍历方式想必大家都不陌生，这就是我所说的「岭」；&lt;/p&gt;
&lt;p&gt;而还有一种面试常考题是问 &lt;code&gt;left/right/vertical/border view&lt;/code&gt;，也就是求树的左视图、右视图、俯视图、border view 这我没找到中文翻译。。这就是我所说的「峰」。&lt;/p&gt;
&lt;p&gt;先来总图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084132121-696114462.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;岭&quot;&gt;岭&lt;/h3&gt;
&lt;p&gt;最基本的三种遍历就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前序 &lt;code&gt;pre order&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中序 &lt;code&gt;in order&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后序 &lt;code&gt;post order&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实这三种遍历方式本质都是一样的，只是输出/打印节点的顺序不同罢了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084132837-2003159269.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来看伪代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void traverse(TreeNode node) {
  if (root == null) {
    return;
  }
  //preOrder
  print(root.value);

  traverse(root.left); //真正的遍历

  //inOrder
  print(root.value);

  traverse(root.right); //真正的遍历

  //postOrder
  print(root.value);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;真正的遍历就这两句话，无论是那种遍历顺序都是不变的，变的只是打印的顺序罢了。&lt;/p&gt;
&lt;p&gt;这三种遍历都是深度优先遍历 &lt;code&gt;DFS&lt;/code&gt;，而层序遍历是广度优先遍历 &lt;code&gt;BFS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DFS&lt;/code&gt; 和 &lt;code&gt;BFS&lt;/code&gt; 都是图的基本遍历方式，我之后也会专门写一篇。&lt;/p&gt;
&lt;p&gt;那我们来看层序遍历 &lt;code&gt;level order traversal&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084133539-1547872831.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出 &lt;code&gt;5 7 3 1 4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;参考 Leetcode 102 题。&lt;/p&gt;
&lt;p&gt;也就是每一层按照从左到右的顺序遍历。&lt;/p&gt;
&lt;p&gt;那么还有一种 &lt;code&gt;Zigzag&lt;/code&gt; 的遍历方式，就是&lt;strong&gt;一行从左到右，下一行从右到左&lt;/strong&gt;这样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084134224-1722079940.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出的就是 &lt;code&gt;5 3 7 1 4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;参考 Leetcode 103 题。&lt;/p&gt;
&lt;h3 id=&quot;峰&quot;&gt;峰&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;left/right/vertical/border view&lt;/code&gt;，也就是求树的左视图、右视图、俯视图，是非常爱考的一类题，它们是什么意思呢？&lt;/p&gt;
&lt;p&gt;比如对于这棵树，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084134640-2009748973.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左视图&lt;/strong&gt; &lt;code&gt;left view&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就是从左边看的每层的第一个节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[5, 7, 9]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;右视图&lt;/strong&gt; &lt;code&gt;right view&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就是从右边看的每层的第一个节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[5, 3, 8]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个应该比较简单，在层序遍历的时候保留我们需要的值就可以了。&lt;/p&gt;
&lt;p&gt;当然还有其他方法，比如前序遍历可以做左视图，但不是那么的直观，因为你还要判断这个元素是否是当前层的第一个。大家有想法的可以在群里交流哟。（提示：可以再加一个变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;俯视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个视图比前两个稍微难一点，在北美面试中是很爱考的。&lt;/p&gt;
&lt;p&gt;首先这个图中有一个变量叫 &lt;code&gt;column&lt;/code&gt;，根节点为 0，左孩子 - 1，右孩子 + 1。&lt;/p&gt;
&lt;p&gt;俯视图指的是，从上往下看这棵树，把 column 相同的这些节点放在一个 list 里，从上往下放，然后按照 column 从小到大的顺序排出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084135147-2130159084.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以对于这棵树，它的俯视图是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[7], [5, 9], [3], [8]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这题就作为本文的思考题啦，不是很难，大家可以在评论区或者群里交流～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Border View&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在讲完前三种视图之后，这个 &lt;code&gt;border view&lt;/code&gt; 想必大家都能猜出来意思了。&lt;/p&gt;
&lt;p&gt;就是求这棵树的“轮廓”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2000306/202011/2000306-20201116084136091-1640333007.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如还是这棵树，它的 &lt;code&gt;border view&lt;/code&gt; 就是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5, 7, 9, 8, 3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这题的大体思路不难，但是细节很多，而且很多条件可能就像我给的这样并没有定义清楚，所以你需要和面试官不断的 &lt;code&gt;clarify&lt;/code&gt; 很多细节。&lt;/p&gt;
&lt;p&gt;普通的思路可以用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左视图 + 叶子结点 + 反着的右视图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来做，表面上来看需要做三遍遍历，但是其实一遍遍历就够了，因为我刚才说过，DFS 遍历时，哪种遍历方式都是一样的，只是在不同时间打印不同节点罢了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了，以上就是本文的全部内容，如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多干货文章见我的 Github: &lt;a href=&quot;https://github.com/xiaoqi6666/NYCSDE&quot;&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:42:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>微信搜索&amp;amp;#128269;「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～ 在写完了所有线性数据结构之后，今天</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13983395.html</dc:identifier>
</item>
<item>
<title>「补课」进行时：设计模式(10)——小明起床记了解装饰模式 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13983396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13983396.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/java_design_pattern.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前文汇总&quot;&gt;1. 前文汇总&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/category/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/&quot;&gt;「补课」进行时：设计模式系列&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-小明起床记&quot;&gt;2. 小明起床记&lt;/h2&gt;
&lt;p&gt;小明每天早晨都是起床困难大户，大冬天的太冷了，温暖的被窝紧紧的拉住小明，阻止小明每天早晨的起床。&lt;/p&gt;
&lt;p&gt;闹钟响了一遍又一遍，如果再不起床就要迟到了，迟到了就要扣钱，扣了钱就要喝西北风了。&lt;/p&gt;
&lt;p&gt;每天早晨督促小明起床的根本不是闹钟，而是贫穷。&lt;/p&gt;
&lt;p&gt;起床第一件事儿是穿衣服，先传衣服，再传裤子，然后穿鞋子，最后穿上一件外套，出门上班。&lt;/p&gt;
&lt;p&gt;首先，定义一个抽象的小明，小明是个人，所以定义一个人：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Person {
    abstract void dress();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个人早晨起床都要穿衣服，这里定义一个穿衣服的方法。&lt;/p&gt;
&lt;p&gt;具体的小明上线：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Man extends Person {
    @Override
    void dress() {
        System.out.println(&quot;先穿衣服&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们要定义一个抽象的装饰器了，小明要穿的是衣服，我们将衣服抽象成一个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Clothes extends Person {
    private Person person;

    public Clothes(Person person) {
        this.person = person;
    }

    @Override
    void dress() {
        this.person.dress();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是具体的衣服：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Trousers extends Clothes {
    public Trousers(Person person) {
        super(person);
    }

    @Override
    void dress() {
        super.dress();
        this.dressTrousers();
    }

    private void dressTrousers() {
        System.out.println(&quot;穿上裤子啦！！！&quot;);
    }
}

public class Shoes extends Clothes {
    public Shoes(Person person) {
        super(person);
    }
    @Override
    void dress() {
        super.dress();
        this.dressShoes();
    }

    private void dressShoes() {
        System.out.println(&quot;穿上鞋子啦！！！&quot;);
    }
}

public class Coat extends Clothes {
    public Coat(Person person) {
        super(person);
    }

    @Override
    void dress() {
        super.dress();
        this.dressCoat();
    }

    private void dressCoat() {
        System.out.println(&quot;穿上外套啦！！！&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是一个测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test1 {
    public static void main(String[] args) {
        Person person = new Man();
        person.dress();

        System.out.println(&quot;--------------&quot;);
        System.out.println(&quot;增加裤子适配器&quot;);
        person = new Trousers(person);
        person.dress();

        System.out.println(&quot;--------------&quot;);
        System.out.println(&quot;增加鞋子适配器&quot;);
        person = new Shoes(person);
        person.dress();

        System.out.println(&quot;--------------&quot;);
        System.out.println(&quot;增加外套适配器&quot;);
        person = new Coat(person);
        person.dress();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;先穿衣服
--------------
增加裤子适配器
先穿衣服
穿上裤子啦！！！
--------------
增加鞋子适配器
先穿衣服
穿上裤子啦！！！
穿上鞋子啦！！！
--------------
增加外套适配器
先穿衣服
穿上裤子啦！！！
穿上鞋子啦！！！
穿上外套啦！！！
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这么写有点麻烦，我们可以稍微缩减一下测试类，使用装饰器嵌套，一次性直接把所有的衣服都穿好：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test2 {
    public static void main(String[] args) {
        Person person = new Coat(new Shoes(new Trousers(new Man())));
        person.dress();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-装饰器模式&quot;&gt;3. 装饰器模式&lt;/h2&gt;
&lt;h3 id=&quot;31-定义&quot;&gt;3.1 定义&lt;/h3&gt;
&lt;p&gt;装饰模式（Decorator Pattern）是一种比较常见的模式，其定义如下：&lt;/p&gt;
&lt;p&gt;Attachadditional responsibilities to an object dynamically keeping the sameinterface.Decorators provide a flexible alternative to subclassing forextending functionality.（动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/10/Decorator_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Component: 抽象构件，是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。&lt;/li&gt;
&lt;li&gt;ConcreteComponent: 具体构件，是最核心、最原始、最基本的接口或抽象类的实现。&lt;/li&gt;
&lt;li&gt;Decorator: 通用的装饰 ConcreteComponent 的装饰器，其内部必然有一个属性指向 Component 抽象组件；其实现一般是一个抽象类，主要是为了让其子类按照其构造形式传入一个 Component 抽象组件，这是强制的通用行为（当然，如果系统中装饰逻辑单一，并不需要实现许多装饰器，那么我们可以直接省略该类，而直接实现一个 具体装饰器（ConcreteDecorator） 即可）。&lt;/li&gt;
&lt;li&gt;ConcreteDecorator: Decorator 的具体实现类，理论上，每个 ConcreteDecorator 都扩展了 Component 对象的一种功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通用代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Component {
    abstract void operate();
}

public class ConcreteComponent extends Component {
    @Override
    void operate() {
        System.out.println(&quot;do Something&quot;);
    }
}

public abstract class Decorator extends Component {
    private Component component = null;
    // 通过构造函数传递被修饰者
    public Decorator(Component component) {
        this.component = component;
    }
    // 委托给被修饰者执行
    @Override
    void operate() {
        this.component.operate();
    }
}

public class ConcreteDecorator1 extends Decorator {
    // 定义被修饰者
    public ConcreteDecorator1(Component component) {
        super(component);
    }
    private void method1() {
        System.out.println(&quot;method1 修饰&quot;);
    }

    @Override
    void operate() {
        this.method1();
        super.operate();
    }
}

public class ConcreteDecorator2 extends Decorator {
    public ConcreteDecorator2(Component component) {
        super(component);
    }
    private void method2() {
        System.out.println(&quot;method2 修饰&quot;);
    }

    @Override
    void operate() {
        super.operate();
        this.method2();
    }
}

public class Test {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        // 第一次修饰
        component = new ConcreteDecorator1(component);
        // 第二次修饰
        component = new ConcreteDecorator2(component);
        // 修饰后运行
        component.operate();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-优点&quot;&gt;3.2 优点&lt;/h3&gt;
&lt;p&gt;装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说， Component 类无须知道 Decorator 类， Decorator 类是从外部来扩展 Component 类的功能，而 Decorator 也不用知道具体的构件。&lt;/p&gt;
&lt;h3 id=&quot;33-缺点&quot;&gt;3.3 缺点&lt;/h3&gt;
&lt;p&gt;对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？想想看，就像剥洋葱一样，至于剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。&lt;/p&gt;
&lt;h3 id=&quot;33-使用场景&quot;&gt;3.3 使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;需要扩展一个类的功能，或给一个类增加附加功能。&lt;/li&gt;
&lt;li&gt;需要动态地给一个对象增加功能，这些功能可以再动态地撤销。&lt;/li&gt;
&lt;li&gt;需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 16 Nov 2020 00:42:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 前文汇总 「补课」进行时：设计模式系列 2. 小明起床记 小明每天早晨都是起床困难大户，大冬天的太冷了，温暖的被窝紧紧的拉住小明，阻止小明每天早晨的起床。 闹钟响了一遍又一遍，如果再不起床就要迟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13983396.html</dc:identifier>
</item>
<item>
<title>将CSV的数据发送到kafka(java版) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13983379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13983379.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;为什么将csv的数据发到kafka&quot;&gt;为什么将CSV的数据发到kafka&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;flink做流式计算时，选用kafka消息作为数据源是常用手段，因此在学习和开发flink过程中，也会将数据集文件中的记录发送到kafka，来模拟不间断数据；&lt;/li&gt;
&lt;li&gt;整个流程如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201116083212318-1849502568.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;您可能会觉得这样做多此一举：flink直接读取CSV不就行了吗？这样做的原因如下：&lt;/li&gt;
&lt;li&gt;首先，这是学习和开发时的做法，数据集是CSV文件，而生产环境的实时数据却是kafka数据源；&lt;/li&gt;
&lt;li&gt;其次，Java应用中可以加入一些特殊逻辑，例如数据处理，汇总统计（用来和flink结果对比验证）；&lt;/li&gt;
&lt;li&gt;另外，如果两条记录实际的间隔时间如果是1分钟，那么Java应用在发送消息时也可以间隔一分钟再发送，这个逻辑在flink社区的demo中有具体的实现，此demo也是将数据集发送到kafka，再由flink消费kafka，地址是：&lt;a href=&quot;https://github.com/ververica/sql-training&quot;&gt;https://github.com/ververica/sql-training&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何将csv的数据发送到kafka&quot;&gt;如何将CSV的数据发送到kafka&lt;/h3&gt;
&lt;p&gt;前面的图可以看出，读取CSV再发送消息到kafka的操作是Java应用所为，因此今天的主要工作就是开发这个Java应用，并验证；&lt;/p&gt;
&lt;h3 id=&quot;版本信息&quot;&gt;版本信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JDK：1.8.0_181&lt;/li&gt;
&lt;li&gt;开发工具：IntelliJ IDEA 2019.2.1 (Ultimate Edition)&lt;/li&gt;
&lt;li&gt;开发环境：Win10&lt;/li&gt;
&lt;li&gt;Zookeeper：3.4.13&lt;/li&gt;
&lt;li&gt;Kafka：2.4.0（scala：2.12）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于数据集&quot;&gt;关于数据集&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本次实战用到的数据集是CSV文件，里面是一百零四万条淘宝用户行为数据，该数据来源是阿里云天池公开数据集，我对此数据做了少量调整；&lt;/li&gt;
&lt;li&gt;此CSV文件可以在CSDN下载，地址：&lt;a href=&quot;https://download.csdn.net/download/boling_cavalry/12381698&quot;&gt;https://download.csdn.net/download/boling_cavalry/12381698&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;也可以在我的Github下载，地址：&lt;a href=&quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/UserBehavior.7z&quot;&gt;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/UserBehavior.7z&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;该CSV文件的内容，一共有六列，每列的含义如下表：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;列名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;用户ID&lt;/td&gt;
&lt;td&gt;整数类型，序列化后的用户ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;商品ID&lt;/td&gt;
&lt;td&gt;整数类型，序列化后的商品ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;商品类目ID&lt;/td&gt;
&lt;td&gt;整数类型，序列化后的商品所属类目ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;行为类型&lt;/td&gt;
&lt;td&gt;字符串，枚举类型，包括('pv', 'buy', 'cart', 'fav')&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;时间戳&lt;/td&gt;
&lt;td&gt;行为发生的时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;时间字符串&lt;/td&gt;
&lt;td&gt;根据时间戳字段生成的时间字符串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;关于该数据集的详情，请参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106033059&quot;&gt;《准备数据集用于flink学习》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;java应用简介&quot;&gt;Java应用简介&lt;/h3&gt;
&lt;p&gt;编码前，先把具体内容列出来，然后再挨个实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从CSV读取记录的工具类：UserBehaviorCsvFileReader&lt;/li&gt;
&lt;li&gt;每条记录对应的Bean类：UserBehavior&lt;/li&gt;
&lt;li&gt;Java对象序列化成JSON的序列化类：JsonSerializer&lt;/li&gt;
&lt;li&gt;向kafka发送消息的工具类：KafkaProducer&lt;/li&gt;
&lt;li&gt;应用类，程序入口：SendMessageApplication&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述五个类即可完成Java应用的工作，接下来开始编码吧；&lt;/p&gt;
&lt;h3 id=&quot;直接下载源码&quot;&gt;直接下载源码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想写代码，您可以直接从GitHub下载这个工程的源码，地址和链接信息如下表所示：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章源码在flinksql这个文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201116083212748-1655313993.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建maven工程，pom.xml如下，比较重要的jackson和javacsv的依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;flinksql&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;flink.version&amp;gt;1.10.0&amp;lt;/flink.version&amp;gt;
        &amp;lt;kafka.version&amp;gt;2.2.0&amp;lt;/kafka.version&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;scala.binary.version&amp;gt;2.11&amp;lt;/scala.binary.version&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;${java.version}&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;${java.version}&amp;lt;/maven.compiler.target&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${kafka.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.10.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Logging dependencies --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;net.sourceforge.javacsv&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;javacsv&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- Java Compiler --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;${java.version}&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;${java.version}&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;

            &amp;lt;!-- Shade plugin to include all dependencies --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;!-- Run shade goal on package phase --&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                        &amp;lt;configuration&amp;gt;
                            &amp;lt;artifactSet&amp;gt;
                                &amp;lt;excludes&amp;gt;
                                &amp;lt;/excludes&amp;gt;
                            &amp;lt;/artifactSet&amp;gt;
                            &amp;lt;filters&amp;gt;
                                &amp;lt;filter&amp;gt;
                                    &amp;lt;!-- Do not copy the signatures in the META-INF folder.
                                    Otherwise, this might cause SecurityExceptions when using the JAR. --&amp;gt;
                                    &amp;lt;artifact&amp;gt;*:*&amp;lt;/artifact&amp;gt;
                                    &amp;lt;excludes&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;
                                        &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;
                                    &amp;lt;/excludes&amp;gt;
                                &amp;lt;/filter&amp;gt;
                            &amp;lt;/filters&amp;gt;
                        &amp;lt;/configuration&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;从CSV读取记录的工具类：&lt;span&gt;UserBehaviorCsvFileReader&lt;/span&gt;，后面在主程序中会用到java8的Steam API来处理集合，所以UserBehaviorCsvFileReader实现了Supplier接口：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserBehaviorCsvFileReader implements Supplier&amp;lt;UserBehavior&amp;gt; {

    private final String filePath;
    private CsvReader csvReader;

    public UserBehaviorCsvFileReader(String filePath) throws IOException {

        this.filePath = filePath;
        try {
            csvReader = new CsvReader(filePath);
            csvReader.readHeaders();
        } catch (IOException e) {
            throw new IOException(&quot;Error reading TaxiRecords from file: &quot; + filePath, e);
        }
    }

    @Override
    public UserBehavior get() {
        UserBehavior userBehavior = null;
        try{
            if(csvReader.readRecord()) {
                csvReader.getRawRecord();
                userBehavior = new UserBehavior(
                        Long.valueOf(csvReader.get(0)),
                        Long.valueOf(csvReader.get(1)),
                        Long.valueOf(csvReader.get(2)),
                        csvReader.get(3),
                        new Date(Long.valueOf(csvReader.get(4))*1000L));
            }
        } catch (IOException e) {
            throw new NoSuchElementException(&quot;IOException from &quot; + filePath);
        }

        if (null==userBehavior) {
            throw new NoSuchElementException(&quot;All records read from &quot; + filePath);
        }

        return userBehavior;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;每条记录对应的Bean类：&lt;span&gt;UserBehavior&lt;/span&gt;，和CSV记录格式保持一致即可，表示时间的&lt;span&gt;ts&lt;/span&gt;字段，使用了JsonFormat注解，在序列化的时候以此来控制格式：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserBehavior {

    @JsonFormat
    private long user_id;

    @JsonFormat
    private long item_id;

    @JsonFormat
    private long category_id;

    @JsonFormat
    private String behavior;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;)
    private Date ts;

    public UserBehavior() {
    }

    public UserBehavior(long user_id, long item_id, long category_id, String behavior, Date ts) {
        this.user_id = user_id;
        this.item_id = item_id;
        this.category_id = category_id;
        this.behavior = behavior;
        this.ts = ts;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;Java对象序列化成JSON的序列化类：JsonSerializer&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JsonSerializer&amp;lt;T&amp;gt; {

    private final ObjectMapper jsonMapper = new ObjectMapper();

    public String toJSONString(T r) {
        try {
            return jsonMapper.writeValueAsString(r);
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException(&quot;Could not serialize record: &quot; + r, e);
        }
    }

    public byte[] toJSONBytes(T r) {
        try {
            return jsonMapper.writeValueAsBytes(r);
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException(&quot;Could not serialize record: &quot; + r, e);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;向kafka发送消息的工具类：&lt;span&gt;KafkaProducer&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class KafkaProducer implements Consumer&amp;lt;UserBehavior&amp;gt; {

    private final String topic;
    private final org.apache.kafka.clients.producer.KafkaProducer&amp;lt;byte[], byte[]&amp;gt; producer;
    private final JsonSerializer&amp;lt;UserBehavior&amp;gt; serializer;

    public KafkaProducer(String kafkaTopic, String kafkaBrokers) {
        this.topic = kafkaTopic;
        this.producer = new org.apache.kafka.clients.producer.KafkaProducer&amp;lt;&amp;gt;(createKafkaProperties(kafkaBrokers));
        this.serializer = new JsonSerializer&amp;lt;&amp;gt;();
    }

    @Override
    public void accept(UserBehavior record) {
        // 将对象序列化成byte数组
        byte[] data = serializer.toJSONBytes(record);
        // 封装
        ProducerRecord&amp;lt;byte[], byte[]&amp;gt; kafkaRecord = new ProducerRecord&amp;lt;&amp;gt;(topic, data);
        // 发送
        producer.send(kafkaRecord);

        // 通过sleep控制消息的速度，请依据自身kafka配置以及flink服务器配置来调整
        try {
            Thread.sleep(500);
        }catch(InterruptedException e){
            e.printStackTrace();
        }
    }

    /**
     * kafka配置
     * @param brokers The brokers to connect to.
     * @return A Kafka producer configuration.
     */
    private static Properties createKafkaProperties(String brokers) {
        Properties kafkaProps = new Properties();
        kafkaProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, brokers);
        kafkaProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getCanonicalName());
        kafkaProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getCanonicalName());
        return kafkaProps;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;最后是应用类SendMessageApplication，CSV文件路径、kafka的topic和borker地址都在此设置，另外借助java8的Stream API，只需少量代码即可完成所有工作：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SendMessageApplication {

    public static void main(String[] args) throws Exception {
        // 文件地址
        String filePath = &quot;D:\\temp\\202005\\02\\UserBehavior.csv&quot;;
        // kafka topic
        String topic = &quot;user_behavior&quot;;
        // kafka borker地址
        String broker = &quot;192.168.50.43:9092&quot;;

        Stream.generate(new UserBehaviorCsvFileReader(filePath))
                .sequential()
                .forEachOrdered(new KafkaProducer(topic, broker));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请确保kafka已经就绪，并且名为&lt;span&gt;user_behavior&lt;/span&gt;的topic已经创建；&lt;/li&gt;
&lt;li&gt;请将CSV文件准备好；&lt;/li&gt;
&lt;li&gt;确认SendMessageApplication.java中的文件地址、kafka topic、kafka broker三个参数准确无误；&lt;/li&gt;
&lt;li&gt;运行SendMessageApplication.java；&lt;/li&gt;
&lt;li&gt;开启一个 控制台消息kafka消息，参考命令如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./kafka-console-consumer.sh \
--bootstrap-server 127.0.0.1:9092 \
--topic user_behavior \
--consumer-property group.id=old-consumer-test \
--consumer-property consumer.id=old-consumer-cl \
--from-beginning
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;正常情况下可以立即见到消息，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201116083214636-62642207.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，通过Java应用模拟用户行为消息流的操作就完成了，接下来的flink实战就用这个作为数据源；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:32:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13983379.html</dc:identifier>
</item>
<item>
<title>MySQL全面瓦解10：分组查询和聚合函数 - 翁智华</title>
<link>http://www.cnblogs.com/wzh2010/p/13971478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzh2010/p/13971478.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;相信我们经常会遇到这样的场景：想要了解双十一天猫购买化妆品的人员中平均消费额度是多少（这可能有利于对商品价格区间的定位）；或者不同年龄段的化妆品消费占比是多少（这可能有助于对商品备货量的预估）。&lt;/p&gt;
&lt;p&gt;这个时候就要用到分组查询，分组查询的目的是为了把数据分成多个逻辑组（购买化妆品的人员是一个组，不同年龄段购买化妆品的人员也是组），并对每个组进行聚合计算的过程:。&lt;/p&gt;
&lt;p&gt;分组查询的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; cname, group_fun,... &lt;span&gt;from&lt;/span&gt; tname [&lt;span&gt;where&lt;/span&gt;&lt;span&gt; condition]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; group by group_expression [having group_condition]; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;1、&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;group_fun&lt;/span&gt; 代表&lt;span class=&quot;fontstyle1&quot;&gt;聚合函数，是指对分组的数据进行聚合计算的函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;group_expression&lt;/span&gt; 代表&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;分组表达式，允许多个，多个之间使用逗号隔开。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;3、&lt;span&gt;group_condition &lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;分组之后，再对分组后的数据进行条件过滤的过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;4、分组语法中，&lt;span class=&quot;fontstyle0&quot;&gt;select&lt;span class=&quot;fontstyle1&quot;&gt;后面出现的字段 要么是group by后面的字段，要么是聚合函数的列，其他类型会报异常，我们下面的内容中会详细说明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;说分组之前，先来看看聚合函数，聚合函数是分组查询语法格式中重要的一部分。&lt;span class=&quot;fontstyle0&quot;&gt;我们经常需要汇总数据而不用把它们实际检索出来，所以&lt;span class=&quot;fontstyle1&quot;&gt;MySQL&lt;span class=&quot;fontstyle0&quot;&gt;提&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;供了专门的函数。使用这些函数，&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;可用于计算我们需要的数据，以便分&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;析和生成报表。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;聚合函数&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;聚合函数有以下几种。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AVG()&lt;/td&gt;
&lt;td&gt;返回指定字段的平均值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;COUNT()&lt;/td&gt;
&lt;td&gt;返回查询结果行数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MAX()&lt;/td&gt;
&lt;td&gt;返回指定字段的最大值　&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MIN()&lt;/td&gt;
&lt;td&gt;返回指定字段的最小值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SUM()&lt;/td&gt;
&lt;td&gt;返回指定字段的求和值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span class=&quot;fontstyle0&quot;&gt;AVG()&lt;span class=&quot;fontstyle1&quot;&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;AVG()&lt;span class=&quot;fontstyle1&quot;&gt;通过对表中行数计数并计算特定列值之和，求得该列的平均值。 &lt;span class=&quot;fontstyle0&quot;&gt;AVG()&lt;span class=&quot;fontstyle1&quot;&gt;可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;下面示例返回用户表中用户的平均年龄：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 3&lt;/span&gt; | id | name   | age  | address  | sex |
&lt;span&gt; 4&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; | brand  |   &lt;span&gt;21&lt;/span&gt; | fuzhou   |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; | helen  |   &lt;span&gt;20&lt;/span&gt; | quanzhou |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; | sol    |   &lt;span&gt;21&lt;/span&gt; | xiamen   |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | weng   |   &lt;span&gt;33&lt;/span&gt; | guizhou  |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;5&lt;/span&gt; | selina |   &lt;span&gt;25&lt;/span&gt; | NULL     |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; | anny   |   &lt;span&gt;23&lt;/span&gt; | shanghai |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; | annd   |   &lt;span&gt;24&lt;/span&gt; | shanghai |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; | sunny  | &lt;strong&gt;&lt;span&gt;NULL&lt;/span&gt; &lt;/strong&gt;| guizhou  |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; avg(age) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +----------+
&lt;span&gt;18&lt;/span&gt; | avg(age) |
&lt;span&gt;19&lt;/span&gt; +----------+
&lt;span&gt;20&lt;/span&gt; | &lt;span&gt;23.8571&lt;/span&gt;  |
&lt;span&gt;21&lt;/span&gt; +----------+
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;1、&lt;span class=&quot;fontstyle0&quot;&gt;AVG()&lt;span class=&quot;fontstyle1&quot;&gt;只能用来确定特定数值列的平均值 。&lt;br/&gt;2、&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;AVG()&lt;span class=&quot;fontstyle3&quot;&gt;函数忽略列值为&lt;span class=&quot;fontstyle0&quot;&gt;NULL&lt;span class=&quot;fontstyle3&quot;&gt;的行，所以上图中age值累加之后是除以7，而不是除以8。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span class=&quot;fontstyle0&quot;&gt;COUNT()&lt;span class=&quot;fontstyle1&quot;&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;COUNT()&lt;span class=&quot;fontstyle2&quot;&gt;函数进行计数。 可以用&lt;span class=&quot;fontstyle0&quot;&gt;COUNT()&lt;span class=&quot;fontstyle2&quot;&gt;确定表中符合条件的行的数目。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;count 有 count(*)、count(具体字段)、count(常量) 三种方式来体现 下面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt; 演示了count(*) 和 count(cname)的用法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 3&lt;/span&gt; | id | name   | age  | address  | sex |
&lt;span&gt; 4&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; | brand  |   &lt;span&gt;21&lt;/span&gt; | fuzhou   |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; | helen  |   &lt;span&gt;20&lt;/span&gt; | quanzhou |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; | sol    |   &lt;span&gt;21&lt;/span&gt; | xiamen   |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | weng   |   &lt;span&gt;33&lt;/span&gt; | guizhou  |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;5&lt;/span&gt; | selina |   &lt;span&gt;25&lt;/span&gt; | NULL     |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; | anny   |   &lt;span&gt;23&lt;/span&gt; | shanghai |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; | annd   |   &lt;span&gt;24&lt;/span&gt; | shanghai |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; | sunny  | NULL | guizhou  |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count(*)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; user2 &lt;span&gt;where&lt;/span&gt; sex=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +----------+
&lt;span&gt;18&lt;/span&gt; | count(*) |
&lt;span&gt;19&lt;/span&gt; +----------+
&lt;span&gt;20&lt;/span&gt; |        &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; +----------+
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count(age)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; user2 &lt;span&gt;where&lt;/span&gt; sex=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; +------------+
&lt;span&gt;26&lt;/span&gt; | count(age) |
&lt;span&gt;27&lt;/span&gt; +------------+
&lt;span&gt;28&lt;/span&gt; |        &lt;span&gt;  4&lt;/span&gt; |
&lt;span&gt;29&lt;/span&gt; +------------+
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;可以看到，都是取出女生的用户数量，count(*) 比 count(age) 多一个，那是因为age中包含null值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;所以：如果指定列名，则指定列的值为空的行被&lt;span class=&quot;fontstyle1&quot;&gt;COUNT()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;函数忽略，但如果&lt;span class=&quot;fontstyle1&quot;&gt;COUNT()&lt;span class=&quot;fontstyle0&quot;&gt;函数中用的是星号（ &lt;span class=&quot;fontstyle1&quot;&gt;*&lt;span class=&quot;fontstyle0&quot;&gt;），则不忽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;略。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;关于count 可以看我写的另一篇，详细分析了几种count的使用和性能比较： &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/wzh2010/p/13795093.html&quot; target=&quot;_blank&quot;&gt;SELECT COUNT 小结&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;fontstyle0&quot;&gt;MAX()和MIN()&lt;span class=&quot;fontstyle1&quot;&gt;函数&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;MAX()&lt;span class=&quot;fontstyle1&quot;&gt;返回指定列中的最大值，MIN()&lt;span class=&quot;fontstyle1&quot;&gt;返回指定列中的最小值&lt;/span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 3&lt;/span&gt; | id | name   | age  | address  | sex |
&lt;span&gt; 4&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; | brand  |   &lt;span&gt;21&lt;/span&gt; | fuzhou   |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; | helen  |   &lt;span&gt;20&lt;/span&gt; | quanzhou |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; | sol    |   &lt;span&gt;21&lt;/span&gt; | xiamen   |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | weng   |   &lt;span&gt;33&lt;/span&gt; | guizhou  |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;5&lt;/span&gt; | selina |   &lt;span&gt;25&lt;/span&gt; | NULL     |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; | anny   |   &lt;span&gt;23&lt;/span&gt; | shanghai |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; | annd   |   &lt;span&gt;24&lt;/span&gt; | shanghai |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; | sunny  | NULL | guizhou  |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; max(age),min(age) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +----------+----------+
&lt;span&gt;18&lt;/span&gt; | max(age) | min(age) |
&lt;span&gt;19&lt;/span&gt; +----------+----------+
&lt;span&gt;20&lt;/span&gt; |       &lt;span&gt;33&lt;/span&gt; |       &lt;span&gt;20&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; +----------+----------+
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt; 注意：同样的，MAX()、&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;MIN()&lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt;函数忽略列值为&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt;的行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;fontstyle0&quot;&gt;SUM函数&lt;span class=&quot;fontstyle1&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;SUM()&lt;span class=&quot;fontstyle1&quot;&gt;用来返回指定列值的和（总计） ，下面返回了所有年龄的总和，同样的，忽略了null的值&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 3&lt;/span&gt; | id | name   | age  | address  | sex |
&lt;span&gt; 4&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; | brand  |   &lt;span&gt;21&lt;/span&gt; | fuzhou   |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; | helen  |   &lt;span&gt;20&lt;/span&gt; | quanzhou |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; | sol    |   &lt;span&gt;21&lt;/span&gt; | xiamen   |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | weng   |   &lt;span&gt;33&lt;/span&gt; | guizhou  |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;5&lt;/span&gt; | selina |   &lt;span&gt;25&lt;/span&gt; | NULL     |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; | anny   |   &lt;span&gt;23&lt;/span&gt; | shanghai |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; | annd   |   &lt;span&gt;24&lt;/span&gt; | shanghai |   &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; | sunny  | NULL | guizhou  |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +----+--------+------+----------+-----+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; sum(age) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user2;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +----------+
&lt;span&gt;18&lt;/span&gt; | sum(age) |
&lt;span&gt;19&lt;/span&gt; +----------+
&lt;span&gt;20&lt;/span&gt; | &lt;span&gt;167&lt;/span&gt;      |
&lt;span&gt;21&lt;/span&gt; +----------+
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分组查询&lt;/h3&gt;
&lt;p&gt;数据准备，假设我们有一个订货单表如下（记载用户的订单金额和下单时间）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+-----+-------+--------+---------------------+------+
&lt;span&gt; 3&lt;/span&gt; | orderid | uid | uname | amount | time                | year |
&lt;span&gt; 4&lt;/span&gt; +---------+-----+-------+--------+---------------------+------+
&lt;span&gt; 5&lt;/span&gt; |      &lt;span&gt;20&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; | brand | &lt;span&gt;91.23&lt;/span&gt;  | &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt; | &lt;span&gt;2018&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |      &lt;span&gt;21&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; | brand | &lt;span&gt;87.54&lt;/span&gt;  | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt; &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;22&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; | brand | &lt;span&gt;166.88&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;04&lt;/span&gt;-&lt;span&gt;04&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;23&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; | helyn | &lt;span&gt;93.73&lt;/span&gt;  | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;24&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; | helyn | &lt;span&gt;102.32&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;33&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;25&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; | helyn | &lt;span&gt;106.06&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;24&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;26&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; | helyn | &lt;span&gt;73.42&lt;/span&gt;  | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;04&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |      &lt;span&gt;27&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; | sol   | &lt;span&gt;55.55&lt;/span&gt;  | &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt; | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; |      &lt;span&gt;28&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; | sol   | &lt;span&gt;69.96&lt;/span&gt;  | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt; | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;14&lt;/span&gt; |      &lt;span&gt;29&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; | weng  | &lt;span&gt;199.99&lt;/span&gt; | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;08&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;15&lt;/span&gt; +---------+-----+-------+--------+---------------------+------+
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;单字段分组&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;即对于某个字段进行分组，比如针对用户进行分组，输出他们的用户Id，订单数量和总额：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid),sum(amount) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order group by uid;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +-----+------------+-------------+
&lt;span&gt; 3&lt;/span&gt; | uid | count(uid) | sum(amount) |
&lt;span&gt; 4&lt;/span&gt; +-----+------------+-------------+
&lt;span&gt; 5&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |          &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;345.65&lt;/span&gt;      |
&lt;span&gt; 6&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |          &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;375.53&lt;/span&gt;      |
&lt;span&gt; 7&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |          &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;125.51&lt;/span&gt;      |
&lt;span&gt; 8&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; |          &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;199.99&lt;/span&gt;      |
&lt;span&gt; 9&lt;/span&gt; +-----+------------+-------------+
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;多字段分组&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;即对于多个字段进行分组，比如针对用户进行分组，再对他们不同年份的订单数据进行分组，输出订单数量和消费总额：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount,year &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order group by uid,year;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt; 3&lt;/span&gt; | uid | nums | totalamount | year |
&lt;span&gt; 4&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt; 5&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;91.23&lt;/span&gt;       | &lt;span&gt;2018&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;254.42&lt;/span&gt;      | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;302.11&lt;/span&gt;      | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;73.42&lt;/span&gt;       | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;55.55&lt;/span&gt;       | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;69.96&lt;/span&gt;       | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;199.99&lt;/span&gt;      | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;分组前的条件过滤：where&lt;/h4&gt;
&lt;p&gt;这个很简单，就是再分组（group by）之前通过where关键字进行条件过滤，取出我们需要的数据，假设我们只要列出2019年8月之后的数据，源数据只有6条合格的，有两条年份一样被分组的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount,year &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where&lt;/span&gt; time &amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-08-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; group by uid,year;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt; 3&lt;/span&gt; | uid | nums | totalamount | year |
&lt;span&gt; 4&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt; 5&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;199.79&lt;/span&gt;      | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;73.42&lt;/span&gt;       | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;55.55&lt;/span&gt;       | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;69.96&lt;/span&gt;       | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;199.99&lt;/span&gt;      | &lt;span&gt;2020&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;分组后的条件过滤：having&lt;/h4&gt;
&lt;p&gt;有时候我们需要再分组之后再对数据进行过滤，这时候就需要使用having关键字进行数据过滤，再上述条件下，我们需要取出消费次数超过一次的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount,year &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where&lt;/span&gt; time &amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-08-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; group by uid,year &lt;span&gt;having nums&amp;gt;1;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt;3&lt;/span&gt; | uid | nums | totalamount | year |
&lt;span&gt;4&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt;5&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;199.79&lt;/span&gt;      | &lt;span&gt;2019&lt;/span&gt; |
&lt;span&gt;6&lt;/span&gt; +-----+------+-------------+------+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这边需要注意区分where和having：&lt;/p&gt;
&lt;p&gt;where是在分组（聚合）前对记录进行筛选，而having是在分组结束后的结果里筛选，最后返回过滤后的结果。&lt;/p&gt;
&lt;p&gt;可以把having理解为两级查询，即含having的查询操作先获得不含having子句时的sql查询结果表，然后在这个结果表上使用having条件筛选出符合的记录，最后返回这些记录，因此，having后是可以跟聚合函数的，并且这个聚集函数不必与select后面的聚集函数相同。&lt;/p&gt;
&lt;h4&gt;分组后的排序处理&lt;/h4&gt;
&lt;p&gt;order条件接在group by后面，也就是统计出每个用户的消费总额和消费次数后，对用户的消费总额进行降序排序的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order group by uid;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +-----+------+-------------+
&lt;span&gt; 3&lt;/span&gt; | uid | nums | totalamount |
&lt;span&gt; 4&lt;/span&gt; +-----+------+-------------+
&lt;span&gt; 5&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |    &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;345.65&lt;/span&gt;      |
&lt;span&gt; 6&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;375.53&lt;/span&gt;      |
&lt;span&gt; 7&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;125.51&lt;/span&gt;      |
&lt;span&gt; 8&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;199.99&lt;/span&gt;      |
&lt;span&gt; 9&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order group by uid &lt;span&gt;order by totalamount desc;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;14&lt;/span&gt; | uid | nums | totalamount |
&lt;span&gt;15&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;16&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;375.53&lt;/span&gt;      |
&lt;span&gt;17&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |    &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;345.65&lt;/span&gt;      |
&lt;span&gt;18&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;199.99&lt;/span&gt;      |
&lt;span&gt;19&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; | &lt;span&gt;125.51&lt;/span&gt;      |
&lt;span&gt;20&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;分组后的limit 限制&lt;/h4&gt;
&lt;p&gt;limit限制关键字一般放在语句的最末尾，比如基于我们上面的搜索，我们再limit 1，只取出消费额最高的那条，其他跳过。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount &lt;span&gt;from&lt;/span&gt; t_order group by uid &lt;span&gt;order by totalamount desc limit 1;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;3&lt;/span&gt; | uid | nums | totalamount |
&lt;span&gt;4&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;5&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;375.53&lt;/span&gt;      |
&lt;span&gt;6&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;关键字的执行顺序&lt;/h4&gt;
&lt;p&gt;我们看到上面那我们用了 where、group by、having、order by、limit这些关键字，如果一起使用，他们是有先后顺序，顺序错了会导致异常，语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; cname &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tname
&lt;/span&gt;&lt;span&gt;2 where [原表查询条件]
3 group by [分组表达式]
4 having [分组过滤条件]
5 order by [排序条件]
6 limit [offset,] count;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; uid,count(uid) &lt;span&gt;as&lt;/span&gt; nums,sum(amount) &lt;span&gt;as&lt;/span&gt; totalamount &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where&lt;/span&gt; time &amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-08-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; group by uid having totalamount&amp;gt;&lt;span&gt;100&lt;/span&gt; order by totalamount desc limit &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;3&lt;/span&gt; | uid | nums | totalamount |
&lt;span&gt;4&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;5&lt;/span&gt; |   &lt;span&gt;2&lt;/span&gt; |    &lt;span&gt;3&lt;/span&gt; | &lt;span&gt;273.21&lt;/span&gt;      |
&lt;span&gt;6&lt;/span&gt; +-----+------+-------------+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1、分组语法中，&lt;span class=&quot;fontstyle0&quot;&gt;select&lt;span class=&quot;fontstyle1&quot;&gt;后面出现的字段 要么是group by后面的字段，要么是聚合函数的列，其他类型会报异常：可以自己试试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;2、分组关键字的执行顺序：where、group by、having、order by、limit，顺序不能调换，否则会报异常：可以自己试试。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:30:00 +0000</pubDate>
<dc:creator>翁智华</dc:creator>
<og:description>概述 相信我们经常会遇到这样的场景：想要了解双十一天猫购买化妆品的人员中平均消费额度是多少（这可能有利于对商品价格区间的定位）；或者不同年龄段的化妆品消费占比是多少（这可能有助于对商品备货量的预估）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzh2010/p/13971478.html</dc:identifier>
</item>
<item>
<title>Flutter 开发从 0 到 1（五）源码 - 吴小龙同學</title>
<link>http://www.cnblogs.com/WuXiaolong/p/13983333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WuXiaolong/p/13983333.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2efd3401de4b598384bbb65c0d1fbe87.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;flutter-开发从-0-到-1&quot;&gt;Flutter 开发从 0 到 1&lt;/h2&gt;
&lt;p&gt;明天开始又要上班了，你的假期任务完成如何啊？由于平时加班太多了，实在挤不出更多时间，从开始想用 Flutter 《&lt;a href=&quot;https://mp.weixin.qq.com/s/qau4u71ref6dVRyX4CQX4w&quot;&gt;Flutter 开发从 0 到 1（一）需求与准备&lt;/a&gt;》写一个完整的 APP 已经过去三个月了，但是我没有忘记，这个国庆时间我终于完成了。Flutter 确实强大，不止跨平台，还支持桌面应用，包括 Window、macOS、Linux，以及 Web 应用，真正一套代码，全平台支持，野心可见一斑。&lt;/p&gt;
&lt;p&gt;以上我尝试过了，打包成了 APK、macOS 桌面应用、Web 应用没问题，只能用两个字形容 Flutter：牛皮，今天先分享这个 APP 源码。&lt;/p&gt;
&lt;p&gt;大体功能如下：&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;公号「&lt;strong&gt;吴小龙同学&lt;/strong&gt;」回复关键字“AndBlog”获取源码下载链接。&lt;/p&gt;
&lt;p&gt;后续更新，这个链接都可以访问，来，我们一起继续探讨 Flutter。&lt;/p&gt;
&lt;h2 id=&quot;如何运行&quot;&gt;如何运行&lt;/h2&gt;
&lt;p&gt;拿到源码，可以以 Web Server (web) 或 Chrome (web)运行代码， 如果你是 MacBook Pro，你还可以以 iPhone 11 Pro Max (mobile)或 macOS (desktop)运行，运行到 Android 手机，开发的时候卡在了 Running Gradle task ‘assembleDebug’…或者‘assembleRelease’，这里记录下，这时候一般在下载 Gradle 并配置项目，所以可能出现的问题一般有两种：&lt;/p&gt;
&lt;p&gt;报错一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; Failed to apply plugin [id 'com.android.internal.version-check']
   &amp;gt; Minimum supported Gradle version is 6.1.1. Current version is 5.6.2. If using the gradle wrapper, try editing the distributionUrl in /Users/wuxiaolong/AndroidStudioProjects/flutter_andblog/android/gradle/wrapper/gradle-wrapper.properties to gradle-6.1.1-all.zip
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Gradle 目录 windows 一般在&lt;code&gt;C:\Users\用户名\.gradle\&lt;/code&gt; 下，macOS 一般在&lt;code&gt;/Users/用户名/.gradle&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;如果 Android Studio 开发，该路径可以在&quot;File | Settings | Build, Execution, Deployment | Build Tools | Gradle&quot;中修改。&lt;/p&gt;
&lt;p&gt;我使用的是 “gradle-6.1.1” ，可以在官网 &lt;a href=&quot;https://gradle.org/releases/&quot;&gt;https://gradle.org/releases/&lt;/a&gt; 页面下载对应的 “complete” 安装包，放在 &lt;code&gt;/Users/wuxiaolong/.gradle/wrapper/dists/gradle-6.1.1-all/cfmwm155h49vnt3hynmlrsdst&lt;/code&gt;目录下即可。&lt;/p&gt;
&lt;p&gt;报错二：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:desugarDebugFileDependencies'.
&amp;gt; Could not resolve all files for configuration ':app:debugRuntimeClasspath'.
   &amp;gt; Could not download arm64_v8a_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar (io.flutter:arm64_v8a_debug:1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7)
      &amp;gt; Could not get resource 'https://storage.googleapis.com/download.flutter.io/io/flutter/arm64_v8a_debug/1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7/arm64_v8a_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar'.
         &amp;gt; Could not HEAD 'https://storage.googleapis.com/download.flutter.io/io/flutter/arm64_v8a_debug/1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7/arm64_v8a_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar'.
            &amp;gt; Connect to storage.googleapis.com:443 [storage.googleapis.com/34.64.4.16, storage.googleapis.com/34.64.4.112, storage.googleapis.com/34.64.4.80] failed: connect timed out
   &amp;gt; Could not download x86_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar (io.flutter:x86_debug:1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7)
      &amp;gt; Could not get resource 'https://storage.googleapis.com/download.flutter.io/io/flutter/x86_debug/1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7/x86_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar'.
         &amp;gt; Could not HEAD 'https://storage.googleapis.com/download.flutter.io/io/flutter/x86_debug/1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7/x86_debug-1.0.0-ee76268252c22f5c11e82a7b87423ca3982e51a7.jar'.
            &amp;gt; Connect to storage.googleapis.com:443 [storage.googleapis.com/34.64.4.16, storage.googleapis.com/34.64.4.112, storage.googleapis.com/34.64.4.80] failed: connect timed out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决如下：&lt;/p&gt;
&lt;p&gt;打开项目中 build.gradle 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;buildscript {
    repositories {
        //google()
        //jcenter()
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public'}
        maven { url &quot;http://download.flutter.io&quot; }
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:4.0.1'
    }
}

allprojects {
    repositories {
        //google()
        //jcenter()
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public'}
        maven { url &quot;http://download.flutter.io&quot; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 16 Nov 2020 00:08:00 +0000</pubDate>
<dc:creator>吴小龙同學</dc:creator>
<og:description>Flutter 开发从 0 到 1 明天开始又要上班了，你的假期任务完成如何啊？由于平时加班太多了，实在挤不出更多时间，从开始想用 Flutter 《Flutter 开发从 0 到 1（一）需求与准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WuXiaolong/p/13983333.html</dc:identifier>
</item>
<item>
<title>Github Actions 中 Service Container 的使用 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/13983328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/13983328.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;之前写过一个 &lt;code&gt;StackExchange.Redis&lt;/code&gt; 的一个扩展，测试项目依赖 redis，所以之前测试一直只是在本地跑一下，最近通过 Github Action 中的 Service Container 来通过 CI 来跑测试，分享一下如何使用 service container 来跑测试，不仅仅是 Redis，数据库等依赖也可以使用这样的方式来测试&lt;/p&gt;
&lt;h2 id=&quot;redis-service-container-sample&quot;&gt;Redis Service Container Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;jobs:
  # Label of the runner job
  runner-job:
    # You must use a Linux environment when using service containers or container jobs
    runs-on: ubuntu-latest

    # Service containers to run with `runner-job`
    services:
      # Label used to access the service container
      redis:
        # Docker image
        image: redis:alpine
        # Set health checks to wait until redis has started
        options: &amp;gt;-
          --health-cmd &quot;redis-cli ping&quot;
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是一个 redis service container 配置示例的一部分，需要注意的是使用 service container 的时候必须要使用 Linux 环境，因为 service container 的本质就是 docker run 了一个 container，通过一定的规则配置来实现在跑 CI 的环境可以访问的这个 service&lt;/p&gt;
&lt;p&gt;上面的示例配置了一个 &lt;code&gt;redis&lt;/code&gt; 的 service container，并将容器服务的 6379 端口映射到 host 的 6379 端口，这样 host 上的服务就可以通过 &lt;code&gt;127.0.0.1:6379&lt;/code&gt;/&lt;code&gt;localhost:6379&lt;/code&gt; 访问到使用 docker 跑起来的 &lt;code&gt;redis&lt;/code&gt; 服务(redis service container)了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v2

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create
    # a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: localhost
      # The default Redis port
      REDIS_PORT: 6379
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;container-job-sample&quot;&gt;Container Job Sample&lt;/h2&gt;
&lt;p&gt;上面的这种形式是在 host 上跑的，也就是直接在跑 CI 的服务器上跑的，有些情况下环境的配置比较麻烦的情况下也可以直接在指定的 docker 镜像为基础的 docker container 里跑 CI，需要注意的是 docker container 里跑 CI 的时候和直接在 host 上跑 CI 网络上有区别， host 可能就是直接访问 &lt;code&gt;localhost&lt;/code&gt;，container 访问就是 service 名称，来看下面的 container 的一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;jobs:
  # Label of the container job
  container-job:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # Docker Hub image that `container-job` executes in
    container: node:10.18-jessie

    # Service containers to run with `container-job`
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis
        # Set health checks to wait until redis has started
        options: &amp;gt;-
          --health-cmd &quot;redis-cli ping&quot;
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到大部分是一样的，只是多了一个 &lt;code&gt;container&lt;/code&gt; 的配置，这样实际的 CI 就是在这个 container 里执行的，创建的执行 CI 的 container 和 service container 是在同一个 network 下，可以直接通过服务名称来访问&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;steps:
  # Downloads a copy of the code in your repository before running CI tests
  - name: Check out repository code
    uses: actions/checkout@v2

  # Performs a clean installation of all dependencies in the `package.json` file
  # For more information, see https://docs.npmjs.com/cli/ci.html
  - name: Install dependencies
    run: npm ci

  - name: Connect to Redis
    # Runs a script that creates a Redis client, populates
    # the client with data, and retrieves data
    run: node client.js
    # Environment variable used by the `client.js` script to create a new Redis client.
    env:
      # The hostname used to communicate with the Redis service container
      REDIS_HOST: redis
      # The default Redis port
      REDIS_PORT: 6379
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;提供一个我目前在用的一个 service container，和上面的示例基本是类似的，有需要的可以参考一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;name: dotnetcore

on: [push]

jobs:
  # Label of the container job
  redis-integration-test:
    # Containers must run in Linux based operating systems
    runs-on: ubuntu-latest
    # # Docker image that `job` executes in
    # container: mcr.microsoft.com/dotnet/sdk:5.0

    # Service containers to run with `container-job`
    # https://docs.github.com/en/free-pro-team@latest/actions/guides/creating-redis-service-containers
    services:
      # Label used to access the service container
      redis:
        # Docker Hub image
        image: redis:alpine
        # Set health checks to wait until redis has started
        options: &amp;gt;-
          --health-cmd &quot;redis-cli ping&quot;
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # Maps port 6379 on service container to the host
          - 6379:6379

    steps:
    - uses: actions/checkout@v1
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 5.0.x
    - name: dotnet info
      run: dotnet --info
    - name: build
      run: bash build.sh --target=test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CI 执行日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202011/489462-20201116080212609-575357264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从日志上我们可以看出来比普通的 CI 执行会多出两个步骤，一个是初始化 container，一个是清理 container&lt;/p&gt;
&lt;p&gt;完整的CI 日志可以在这里看到：&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Redis/runs/1400006789?check_suite_focus=true&quot;&gt;https://github.com/WeihanLi/WeihanLi.Redis/runs/1400006789?check_suite_focus=true&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;虽然我的场景是 redis，但是不仅仅是 redis，很多应用外的依赖比如说数据库，甚至MQ等都是可以通过 service container 来做一个完善的集成测试，没有尝试过的快去试试吧~~&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
</description>
<pubDate>Mon, 16 Nov 2020 00:04:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>利用 Github Actions 的 service container 进行集成测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/13983328.html</dc:identifier>
</item>
</channel>
</rss>