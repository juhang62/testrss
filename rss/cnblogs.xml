<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>90% 的 Java 程序员都说不上来的为何 Java 代码越执行越快（2）- TLAB预热 - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14375843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14375843.html</guid>
<description>&lt;p&gt;经常听到 Java 性能不如 C/C++ 的言论，也经常听说 Java 程序需要预热，&lt;strong&gt;那么其中主要原因是啥呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;面试的时候谈到 JVM，也有很多面试官喜欢问，&lt;strong&gt;为啥 Java 程序越执行越快呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;一般人都能回答上来，类加载，缓存预热等等，但是深入下去，&lt;strong&gt;最重要的却没有答上来&lt;/strong&gt;，今天本系列文章就来帮助大家理解这个问题的关键。本篇文章是 TLAB 预热。&lt;/p&gt;
&lt;p&gt;TLAB（Thread Local Allocation Buffer）线程本地分配缓存区，这是一个线程专用的内存分配区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E8%BF%87JFR%E4%B8%8E%E6%97%A5%E5%BF%97%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2JVM/TLAB/4.%20TLABAllocation.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然是一个内存分配区域，我们就先要搞清楚 Java 内存大概是如何分配的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E8%BF%87JFR%E4%B8%8E%E6%97%A5%E5%BF%97%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2JVM/TLAB/3.%20ObjectAllocation.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这里不考虑&lt;strong&gt;栈上分配&lt;/strong&gt;，这些会在 JIT 的章节详细分析，我们这里&lt;strong&gt;考虑的是无法栈上分配需要共享的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于 HotSpot JVM 实现，所有的 GC 算法的实现都是一种对于堆内存的管理，也就是都实现了一种堆的抽象，它们都实现了接口 CollectedHeap。当分配一个对象堆内存空间时，在 CollectedHeap 上首先都会检查是否启用了 TLAB，如果启用了，则会尝试 TLAB 分配；如果当前线程的 TLAB 大小足够，那么从线程当前的 TLAB 中分配；如果不够，但是当前 TLAB 剩余空间小于&lt;strong&gt;最大浪费空间限制（这是一个动态的值，我们后面会详细分析）&lt;/strong&gt;，则从堆上（一般是 Eden 区） 重新申请一个新的 TLAB 进行分配。否则，直接在 TLAB 外进行分配。TLAB 外的分配策略，不同的 GC 算法不同。例如G1：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是 Humongous 对象（对象在超过 Region 一半大小的时候），直接在 Humongous 区域分配（老年代的连续区域）。&lt;/li&gt;
&lt;li&gt;根据 Mutator 状况在当前分配下标的 Region 内分配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我们先只关心 TLAB 分配。&lt;br/&gt;对于单线程应用，每次分配内存，会记录上次分配对象内存地址末尾的指针，之后分配对象会从这个指针开始检索分配。这个机制叫做 &lt;strong&gt;bump-the-pointer&lt;/strong&gt; （撞针）。&lt;br/&gt;对于多线程应用来说，内存分配需要考虑线程安全。最直接的想法就是通过全局锁，但是这个性能会很差。为了优化这个性能，我们考虑可以每个线程分配一个线程本地私有的内存池，然后采用 &lt;strong&gt;bump-the-pointer&lt;/strong&gt; 机制进行内存分配。这个线程本地私有的内存池，就是 TLAB。只有 TLAB 满了，再去申请内存的时候，需要扩充 TLAB 或者使用新的 TLAB，这时候才需要锁。这样大大减少了锁使用。&lt;/p&gt;
&lt;h2 id=&quot;tlab-初始化&quot;&gt;TLAB 初始化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E8%BF%87JFR%E4%B8%8E%E6%97%A5%E5%BF%97%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2JVM/TLAB/8.%20TLAB%20Initialize.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tlab-分配&quot;&gt;TLAB 分配&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E8%BF%87JFR%E4%B8%8E%E6%97%A5%E5%BF%97%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2JVM/TLAB/9.%20TLAB%20Allocation.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;gc-时-tlab-回收与重计算期望大小&quot;&gt;GC 时 TLAB 回收与重计算期望大小&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E9%80%9A%E8%BF%87JFR%E4%B8%8E%E6%97%A5%E5%BF%97%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2JVM/TLAB/10.%20TLAB%20resize.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何-java-代码越执行越快---tlab预热&quot;&gt;为何 Java 代码越执行越快 - TLAB预热&lt;/h2&gt;
&lt;p&gt;根据之前的分析，每个线程的 TLAB 的大小，会根据线程分配的特性，不断变化并趋于稳定，大小主要是由分配比例 EMA 决定，但是这个采集是需要一定运行次数的。并且 EMA 的前 100 次采集默认是不够稳定的，所以 TLAB 大小也在程序一开始的时候变化频繁。当程序线程趋于稳定，运行一段时间后， 每个线程 TLAB 大小也会趋于稳定并且调整到最适合这个线程对象分配特性的大小。这样，就更接近最理想的只有 Eden 区满了才会 GC，所有 Eden 区的对象都是通过 TLAB 分配的高效分配情况。这就是 Java 代码越执行越快在 TLAB 方面的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 00:24:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>经常听到 Java 性能不如 C/C++ 的言论，也经常听说 Java 程序需要预热，那么其中主要原因是啥呢？ 面试的时候谈到 JVM，也有很多面试官喜欢问，为啥 Java 程序越执行越快呢？ 一般人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14375843.html</dc:identifier>
</item>
<item>
<title>校招有感：计算机专业毕业生如何找工作（Java方向） - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/14365503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/14365503.html</guid>
<description>&lt;p&gt;    这两年毕业生的就业形势，大家都看在眼里。由于我平时本职会到校园去做校招，兼职会做培训，所以也接触到了不少计算机应届毕业生。&lt;/p&gt;
&lt;p&gt;    我看到的计算机专业毕业生，各种情况的都有。虽然其中有学校的因素，但学校的因素也不足以造成这样大的差距。所以在本文里，就将结合找到各种工作的毕业生的情况，说下计算机专业的毕业生第一如何在大三大四时准好准备，第二如何在大四时找到心仪的工作。&lt;/p&gt;
&lt;h4&gt;1 哪些计算机毕业生能进大厂？或者至少能找到软件的活？&lt;/h4&gt;
&lt;p&gt;    我作为大厂面试官去做校招时，能收到一大堆简历，如何挑选有面试资格的人呢？&lt;/p&gt;
&lt;p&gt;    1 可能我去的都是一本，这里已经隐藏了“学校好”的条件。但对于学校一般的同学，绝非没机会，第一参加各种招聘会，第二多找猎头，第三直接到各招聘网站投简历。&lt;/p&gt;
&lt;p&gt;    2 简历上最好要有实际软件相关的项目，比如毕业实习，毕业设计，或者兼职去软件公司干活。其实我看下来真的有项目经验的人并不多，估计也就三成，所以这些人很占优势。&lt;/p&gt;
&lt;p&gt;    3 退而求其次，如果没有实际项目经验，那么好歹得写一些课程设计项目或学习项目。一般来说，大多数毕业生候选人简历上多少会有些。对于这些人，先比较学习项目的时长，再看简历上给出的技术。&lt;/p&gt;
&lt;p&gt;    4 至于很多简历上给出的篇幅很长的自我介绍，学校经历等，除了证书和获奖情况，基本掠过。&lt;/p&gt;
&lt;p&gt;    其实我知道，除非有实际项目经验，其它简历上只包含学习项目的同学，其实能力都差不多，但一般只能看，谁写的项目多，谁写的技术全面。也就是说，大多数毕业生得到面试机会，更需要的是语文能力，而不是技能。&lt;/p&gt;
&lt;p&gt;    然后是面试，（因为我是java方面）面试的机会一般会问如下的问题。&lt;/p&gt;
&lt;p&gt;    1 Spring Boot（或其它框架），你有没有做过基本的增删改查？其中大致流程是什么？&lt;/p&gt;
&lt;p&gt;    2 数据库方面，你会不会写SQL？可能会笔试让写。&lt;/p&gt;
&lt;p&gt;    3 Java方面，在集合，异常处理，多线程等方面，也不敢问深，因为一问深估计就招不到了，就挑些网上通用的问题问下。&lt;/p&gt;
&lt;p&gt;    4 随后就是大路的算法题和编程题，这些基本都是从网上找的。&lt;/p&gt;
&lt;p&gt;    也就是说，只要简历过筛选的候选人，真的运行过并吃透一个学习项目，要过面试应该问题不大。&lt;/p&gt;
&lt;h4&gt;2 哪些毕业生找不软件的活？&lt;/h4&gt;
&lt;p&gt;    话反过来说，哪些计算机专业的毕业生找不到软件的活？&lt;/p&gt;
&lt;p&gt;    第一，可能需要考虑一定的学校因素， 比如学校一般，同时又没有其它获奖等能弥补的因素。&lt;/p&gt;
&lt;p&gt;    第二，简历上看不出任何软件相关的项目，哪怕是学习项目也没有，只有干巴巴的用到的技术列表。&lt;/p&gt;
&lt;p&gt;    第三，即使有面试机会，框架，数据库和java核心方面一问三不知，可能只会说些智力题和基本的算法题。&lt;/p&gt;
&lt;p&gt;    这里大家要注意，哪怕毕业生学校再好，如果仅仅具备课本上的理论知识，比如只掌握数据结构，算法，操作系统等技能，没有项目技能，估计甚至找不到软件方面的活。&lt;/p&gt;
&lt;p&gt;    但相反，如果你学校一般，而你简历上心点，给出三个学习项目（当然最好是实际项目），同时面试前刷些题，背些答案和算法，你未必没机会。&lt;/p&gt;
&lt;h4&gt;3 如何积累（哪怕是纸面上的）项目经验&lt;/h4&gt;
&lt;p&gt;    再啰嗦下，面试前一定得准备项目经验。如下按优先级降序，给出建议的做法。&lt;/p&gt;
&lt;p&gt;    最好是你去找些软件公司的实习机会，比如毕业设计你上点心，或者你主动找有外快项目的老师一起做。当你真正做过项目，哪怕就3个月，别人都不用说，你自己就会知道面试该准备什么。&lt;/p&gt;
&lt;p&gt;    如果你实在没有机会去外面的软件公司实习，你好歹做好你的毕业设计或课程设计，虽然这些有可能是你老师拍脑袋想出来的选题，但好歹成系统，多少也会让你综合实践些技术。 &lt;/p&gt;
&lt;p&gt;    再不行，你买几本带案例的书，或者找至少3个Spring boot框架的项目，第一运行通，第二照书，找视频理解其中关键模块（比如控制器，业务层，jpa）的含义，然后再熟悉基本的sql语句，这样好歹你也算有项目经验。&lt;/p&gt;
&lt;p&gt;    如果你感觉实在没有时间了，同时感觉自己也没能力运行通项目，那么可能只能去找培训班了。培训班虽然学费贵，但好歹有人带。相比之下，如果个人动手能力确实不高，看一些视频还未必能调试通。所以上培训班可能真是没办法中的办法了。&lt;/p&gt;
&lt;p&gt;    总之，在找工作前，你至少能在简历上写上3个项目经验。&lt;/p&gt;
&lt;h4&gt;4 如何用简历争取到面试机会&lt;/h4&gt;
&lt;p&gt;    之前讲到了哪些简历有面试机会，这里具体给出写简历的方法。&lt;/p&gt;
&lt;p&gt;    第一，每个公司甚至每个职位所要求的技术不同，你得仔细阅读，给每份职位定制化简历，在不同的简历中根据要求的技术做些微调。&lt;/p&gt;
&lt;p&gt;    第二，按如下模版写项目。&lt;/p&gt;
&lt;p&gt;    时间：2020年7月到12月，项目名，xx应用系统 用到技术，Spring boot，mysql，jpa （再有当份jd上要求的技术）&lt;/p&gt;
&lt;p&gt;    我做的事情：1 用Spring boot全栈流程开发了xx模块 2 用sql语句编写了查询xx模块数据的业务 3 用前端css+div+jquery等，编写了xx页面&lt;/p&gt;
&lt;p&gt;    得到的收获：1 熟悉了Spring boot全栈开发流程，2 熟悉了mysql数据库基本操作 3 了解了java 多线程，异常处理和集合等技能点&lt;/p&gt;
&lt;p&gt;    照这你写3个，这样的简历，面试官一定能看出是学习项目，但如果你真的没商业项目也没办法，这样的话，你至少不会没面试机会。&lt;/p&gt;
&lt;p&gt;    第三，证书，获奖情况，甚至培训班经历，以及其它你的优势全写上，培训班经历对社会人员可能是不利因素，但对毕业生，这好歹能说明你有项目经验，受过系统软件开发培训。&lt;/p&gt;
&lt;p&gt;    第四，至于个人介绍，就写能加班肯吃苦，团队精神强学习能力强等能帮你找到工作的话，其它兴趣爱好之类无关的话别写。&lt;/p&gt;
&lt;h4&gt;5 准备优先级：说好项目&amp;gt;说好技能&amp;gt;手撕算法&lt;/h4&gt;
&lt;p&gt;    用简历得到面试机会后，你事先一定得准备。 如下给出我会问的问题。&lt;/p&gt;
&lt;p&gt;    1 你就以一个业务模块，比如增加订单，为例，说下Spring boot处理请求的流程。&lt;/p&gt;
&lt;p&gt;    2 你在Spring boot（或你做的项目）里，如何连数据库，比如jpa怎么连？mybatis怎么连？&lt;/p&gt;
&lt;p&gt;    3 你在项目里，如何编写控制器，或如何写数据库的配置，或者如何定义事务。&lt;/p&gt;
&lt;p&gt;    4 说下Spring ioc的理解（或从其它看到的网上关于Spring的面试题）&lt;/p&gt;
&lt;p&gt;    5 说下HashMap里的hashcode和equals方法，或其它能查到的java核心方面的面试题&lt;/p&gt;
&lt;p&gt;    6 找些算法题，比如用两个arraylist实现堆栈，或者分类问题。&lt;/p&gt;
&lt;p&gt;    这里大家能看到，面试问题按重要性划分，首先是项目里的问题，也就是说你得再三复习你做过的项目，了解Spring boot相关问题，随后是技能方面的问题，然后再是算法题编程题。&lt;/p&gt;
&lt;p&gt;    怎么准备？&lt;/p&gt;
&lt;p&gt;    1 多到网上搜，比如Spring boot面试题，java面试题，找到以后，你一定不能死记硬背，一定得在运行通的基础上理解看，比如ioc，又如hashcode，相关代码你要逐一调试通，这样你找到工作的可能性就一定很大。&lt;/p&gt;
&lt;p&gt;    2 还是这句话，多运行学习项目，凡运行通一个，你就写到简历上，通过这样全栈的运行，你会一点点熟悉框架里的细节。&lt;/p&gt;
&lt;p&gt;    3 然后再看些算法题编程题，这不用偏，重点看排序，和线性表哈希表相关即可，同时稍微准备些二叉树方面的冷门题目。&lt;/p&gt;
&lt;p&gt;    我见到很多候选人，项目和技能方面说到很差，但算法和编程题非常熟悉，这就属于本末倒置了。&lt;/p&gt;
&lt;h4&gt;6 这个时间点，大四毕业生应急的做法&lt;/h4&gt;
&lt;p&gt;    现在是2月，对大四毕业生而言，应该是4月找到工作，最晚6月，7月离校，所以现在还有3个月左右的时间，如果你当下属于什么都不懂，该如何应急呢？&lt;/p&gt;
&lt;p&gt;    1 赶紧买2本Java语法书，什么书都行，照着里面的代码敲一遍，注意别敲java界面（比如swing）方面的代码，这需要在2周内做好。&lt;/p&gt;
&lt;p&gt;    2 就安装个mysql数据库，然后买两本Spring boot书（最好是带视频教学的），照着其中的项目运行一通，这样你就至少接触过当下找工作所需要的技术了。这可能时间需要长些，估计得用1个月，这期间你可能会遇到很多问题，比如环境问题语法问题等，一般书上的代码至少能跑通，有问题再看视频。&lt;/p&gt;
&lt;p&gt;    3 上述两件事情，你得在4月前做好，这样你再用一个月，搜网上面试问题，再结合代码理解。&lt;/p&gt;
&lt;p&gt;    4 你在找面试题的同时，需要投简历面试，照本文给出的方法，你不会没面试机会。刚开始的时候，你可能真一问三不知，然后你搜集下实际的面试题，外带不断动手实践理解答案，一个月以后，你至少能和面试官对上话了。&lt;/p&gt;
&lt;p&gt;    5 进入到5月份，你再循环着做面试——搜索问题——找答案——不断提升，这样你好歹能在5月或6月找到工作，至于找到什么工作，就得看你之前敲代码和理解的程度了。&lt;/p&gt;
&lt;h4&gt;7 这个时间点，大三学生可以更从容&lt;/h4&gt;
&lt;p&gt;    相比之下，当下大三的同学，时间上就从容多了，除了可以做上文提到的运行项目+背题之外，还可以做如下的事情。&lt;/p&gt;
&lt;p&gt;    1 虽然当前环境下兼职活不好找，但不等于找不到，你可以用扫楼的方式去找软件实习活。&lt;/p&gt;
&lt;p&gt;    2 每个学校，计算机方向的老师，总有和外面公司有合作的，把活接到教研室里做，你打听下找老师做。由于给钱少，或者甚至不给钱，不少老师都愿意带本科生一起做。&lt;/p&gt;
&lt;p&gt;    3 更可以系统地看技术和运行项目。这里提到的技术，除了是课本上的理论知识外，更需要看Spring boot框架方面的技术。由于有充足的时间，所以更可以多照着视频做。就按两个月运行通一个项目的速度，到了大四，至少能跑通4个左右的项目。跑项目遇到问题怎么办？第一多视频讲解，第二就把错误点放网上搜，第三你还有充足的时间去问老师问技术大神。&lt;/p&gt;
&lt;p&gt;    4 更重要的是，你可以通过写技术博客，或者公众号等手段，不断写下你提升技术的心得。这样到找工作的时候，你博文本身也就是一个亮点，更别提你所积累的技术了。&lt;/p&gt;
&lt;h4&gt;8 总结：进大厂 or 送外卖，更取决于你&lt;/h4&gt;
&lt;p&gt;    计算机应届生，能否找到工作，或者能否找到好工作，根本在于实践过（或者运行通）多少个项目，而不是取决于专业课学得有多好。&lt;/p&gt;
&lt;p&gt;    从这角度上看，广大毕业生朋友当下应当找各种渠道，或者多接触商业项目，或者多在自己的电脑上跑通并理解学习项目，这才是面试的底气，而是单纯地背各种面试题。&lt;/p&gt;
&lt;p&gt;    我见过太多的毕业生，在大四上学期还是前景堪忧，但经过半学期的努力，就能找到心仪的工作，还不用去培训班。所以哪怕是从现在开始努力，为时也不算晚。最后祝各位毕业生都前程似锦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请大家关注我的公众号：一起进步，一起挣钱，在本公众号里，会有很多精彩文章。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/94ca48546154bf9739a4ede0b441d180.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/94ca48546154bf9739a4ede0b441d180.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/img_convert/94ca48546154bf9739a4ede0b441d180.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>这两年毕业生的就业形势，大家都看在眼里。由于我平时本职会到校园去做校招，兼职会做培训，所以也接触到了不少计算机应届毕业生。 我看到的计算机专业毕业生，各种情况的都有。虽然其中有学校的因素，但学校的因素</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaArchitect/p/14365503.html</dc:identifier>
</item>
<item>
<title>jackson学习之八：常用方法注解 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14375821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14375821.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文是《jackson学习》系列的第八篇，继续学习jackson强大的注解能力，本篇学习常用的方法注解，并通过实例来加深印象，下图是常用方法注解的简介：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071546462-1832973494.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071546953-756581339.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;jacksondemo&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;annotation&lt;/span&gt;子工程中，里面的&lt;span&gt;methodannotation&lt;/span&gt;这个package下，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071549188-64033952.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonvalue&quot;&gt;JsonValue&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在序列化时起作用，可以用来注解get方法或者成员变量；&lt;/li&gt;
&lt;li&gt;一个类中，JsonValue只允许出现一次；&lt;/li&gt;
&lt;li&gt;如果注解的是get方法，那么该方法的返回值就是整个实例的序列化结果；&lt;/li&gt;
&lt;li&gt;如果注解的是成员变量，那么该成员变量的值就是整个实例的序列化结果；&lt;/li&gt;
&lt;li&gt;下面是用来测试的Pojo类，JsonValue注解放在getField0方法上，此方法的返回值已经写死了&quot;abc&quot;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        private String field0;

        private String field1;

        @JsonValue
        public String getField0() { return &quot;abc&quot;; }

        public void setField0(String field0) { this.field0 = field0; }
        public String getField1() { return field1; }
        public void setField1(String field1) { this.field1 = field1; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;Test类的序列化结果如下，即getField0方法的返回值：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071550733-1134805600.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsoncreator&quot;&gt;JsonCreator&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在反序列化时，当出现有参构造方法时（可能是多个有参构造方法），需要通过JsonCreator注解指定反序列化时用哪个构造方法，并且在入参处还要通过JsonProperty指定字段关系：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        private String field0;
        private String field1;


        public Test(String field0) {
            this.field0 = field0;
        }

        // 通过JsonCreator指定反序列化的时候使用这个构造方法
        // 通过JsonProperty指定字段关系
        @JsonCreator
        public Test(@JsonProperty(&quot;field0&quot;) String field0,
                    @JsonProperty(&quot;field1&quot;) String field1) {
            this.field0 = field0;
            this.field1 = field1;
        }

        @Override
        public String toString() {
            return &quot;Test{&quot; +
                    &quot;field0='&quot; + field0 + '\'' +
                    &quot;, field1='&quot; + field1 + '\'' +
                    '}';
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;反序列化结果如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071551394-1645054736.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonsetter&quot;&gt;JsonSetter&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonSetter注解在set方法上，被用来在反序列化时指定set方法对应json的哪个属性；&lt;/li&gt;
&lt;li&gt;JsonSetter源码中，推荐使用JsonProperty来取代JsonSetter：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071552149-1001686684.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 测试代码和结果如下，可见反序列化时，是按照JsonSetter的value去json中查找属性的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071553200-1663270164.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsongetter&quot;&gt;JsonGetter&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonGetter只能作为方法注解；&lt;/li&gt;
&lt;li&gt;在序列化时，被JsonGetter注解的get方法，对应的json字段名是JsonGetter的value；&lt;/li&gt;
&lt;li&gt;JsonGetter源码中，推荐使用JsonProperty来取代JsonGetter：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071554538-1460134598.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 测试代码和结果如下，可见序列化时JsonGetter的value会被作为json字段名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071555200-1468462432.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonanygetter&quot;&gt;JsonAnyGetter&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonAnyGetter的作用有些特别：在序列化时，用Map对象的键值对转成json的字段和值；&lt;/li&gt;
&lt;li&gt;理解JsonAnyGetter最好的办法，是对比使用前后序列化结果的变化，先来看以下这段代码，是没有JsonAnyGetter注解的，Test有两个成员变量，其中map字段是HashMap类型的：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.annotation.methodannotation;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.util.HashMap;
import java.util.Map;

public class JsonAnySetterSerialization {

    static class Test {
        private String field0;
        private Map&amp;lt;String, Object&amp;gt; map;

        public String getField0() { return field0; }
        public void setField0(String field0) { this.field0 = field0; }
        public void setMap(Map&amp;lt;String, Object&amp;gt; map) { this.map = map; }
        public Map&amp;lt;String, Object&amp;gt; getMap() { return map; }
    }

    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        // 美化输出
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        // 新增一个HashMap，里面放入两个元素
        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;aaa&quot;, &quot;value_aaa&quot;);
        map.put(&quot;bbb&quot;, &quot;value_bbb&quot;);

        Test test = new Test();
        test.setField0(&quot;000&quot;);

        // map赋值给test.map
        test.setMap(map);

        System.out.println(mapper.writeValueAsString(test));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;上述代码的执行结果如下，其实很好理解，就是field0和map两个字段而已：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
  &quot;field0&quot; : &quot;000&quot;,
  &quot;map&quot; : {
    &quot;aaa&quot; : &quot;value_aaa&quot;,
    &quot;bbb&quot; : &quot;value_bbb&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;接下来，对上述代码做一处改动，如下图红框所示，给getMap方法增加JsonAnyGetter注解：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210205071555616-84394007.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 修改后的执行结果如下，原来的map字段没有了，map内部的所有键值对都成了json的字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
  &quot;field0&quot; : &quot;000&quot;,
  &quot;aaa&quot; : &quot;value_aaa&quot;,
  &quot;bbb&quot; : &quot;value_bbb&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;至此，可以品味出JsonAnyGetter的作用了：&lt;span&gt;序列化时，将Map中的键值对全部作为JSON的字段输出&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;jsonanysetter&quot;&gt;JsonAnySetter&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;弄懂了前面的JsonAnyGetter，对于JsonAnySetter的作用想必您也能大致猜到：反序列化时，对json中不认识的字段，统统调用JsonAnySetter注解修饰的方法去处理；&lt;/li&gt;
&lt;li&gt;测试的代码如下，Test类的setValue方法被JsonAnySetter注解，在反序列化时，json中的&lt;span&gt;aaa&lt;/span&gt;和&lt;span&gt;bbb&lt;/span&gt;字段，都会交给setValue方法处理，也就是放入map中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.annotation.methodannotation;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.HashMap;
import java.util.Map;

public class JsonAnySetterDeserialization {

    static class Test {

        private String field0;
        
        private Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

        @JsonAnySetter
        public void setValue(String key, Object value) {
            map.put(key, value);
        }

        @Override
        public String toString() {
            return &quot;Test{&quot; +
                    &quot;field0='&quot; + field0 + '\'' +
                    &quot;, map=&quot; + map +
                    '}';
        }
    }

    public static void main(String[] args) throws Exception {
        String jsonStr = &quot;{\n&quot; +
                &quot;  \&quot;field0\&quot; : \&quot;000\&quot;,\n&quot; +
                &quot;  \&quot;aaa\&quot; : \&quot;value_aaa\&quot;,\n&quot; +
                &quot;  \&quot;bbb\&quot; : \&quot;value_bbb\&quot;\n&quot; +
                &quot;}&quot;;

        System.out.println(new ObjectMapper().readValue(jsonStr, Test.class));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行结果如下，可见aaa、bbb都被放入了map中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Test{field0='null', map={aaa=value_aaa, field0=000, bbb=value_bbb}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;另外JsonAnySetter还可以作用在成员变量上，上面的代码中，去掉setValue方法，在成员变量map上增加&lt;span&gt;JsonAnySetter&lt;/span&gt;注解，修改后如下，执行结果也是一模一样的：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        private String field0;

        @JsonAnySetter
        private Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

        @Override
        public String toString() {
            return &quot;Test{&quot; +
                    &quot;field0='&quot; + field0 + '\'' +
                    &quot;, map=&quot; + map +
                    '}';
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;注意，JsonAnySetter作用在成员变量上时，&lt;span&gt;该成员变量必须是java.util.Map的实现类&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;至此，Jackson常用注解已全部实战完毕，希望这些丰富的注解能助您制定出各种灵活的序列化和反序列化策略；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 04 Feb 2021 23:16:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14375821.html</dc:identifier>
</item>
<item>
<title>数论内容简要整理 - Ivanovcraft</title>
<link>http://www.cnblogs.com/ivanovcraft/p/14375627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivanovcraft/p/14375627.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;部分内容引自清华大学秦岳《初等数论》，&lt;a href=&quot;https://www.luogu.com.cn/blog/dengyaotriangle/solution-p5656&quot; target=&quot;_blank&quot;&gt;dengyaotriangle的博客&lt;/a&gt;，&lt;a href=&quot;https://www.luogu.com.cn/blog/Loading---99/solution-p1495&quot; target=&quot;_blank&quot;&gt;_WZT_ 的博客&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.net/niiick/article/details/80229217&quot; target=&quot;_blank&quot;&gt;niiick的博客&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;算术基本定理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任何一个大于1的自然数$N$，如果$N$不为质数，那么$N$可以唯一分解成有限个质数的乘积&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$$N=P_1^{a_1}*P_2^{a_2}*P_3^{a_3}......P_n^{a_n}$$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里$P1&amp;lt;P2&amp;lt;P3......&amp;lt;Pn$均为质数，其中指数$a_i$是正整数。这样的分解称为$N$的标准分解式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;素数无限定理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正整数集中包含无限个素数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;证明：假设素数有限，设其为$p_1...p_n$，构造$s=1+\prod p_i$，若s是素数，矛盾；若s是合数，则$p_1...p_n$都不是s的约数，与算术基本定理矛盾&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Eratosthnes素数筛法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置一从2开始的数表，若该数没有被划掉，则其为一个素数，将其所有倍数划掉&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复杂度$O(nlogn)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化版埃氏筛关键部分代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_6285b676-ae54-41de-971a-6fc4da2e5a08&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_6285b676-ae54-41de-971a-6fc4da2e5a08&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6285b676-ae54-41de-971a-6fc4da2e5a08&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
p[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bool p[i]表示i是否为素数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; sq=&lt;span&gt;sqrt(n);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=sq;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;p[i])
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i*i;j&amp;lt;=n;j+=&lt;span&gt;i)
            p[j]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;欧拉线性筛法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维护每个数的最小素因子$mindiv$，从2开始，若其$mindiv$未知，则为素数，将其小于本身$mindiv$的素数倍的数设置成素数。每个数只会被其最小素因子筛一次。复杂度$O(n)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线性筛关键部分代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_78e27099-9176-4ba0-a377-e29d08d67db0&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_78e27099-9176-4ba0-a377-e29d08d67db0&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_78e27099-9176-4ba0-a377-e29d08d67db0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
p[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;p[i])
        pr[&lt;/span&gt;++cnt]=i;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pr为素数表&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;pr[j]*i&amp;lt;=n;j++&lt;span&gt;)
    {
        p[i&lt;/span&gt;*pr[j]]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以pr[j]作为最小质因子更新p[i*pr[j]]&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(i%pr[j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;i的mindiv比pr[j]更小，最小质因子不再是pr[j]
        ，若继续更新则会出现冗余操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;利用线性筛实现的高效分解质因数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于数$x$每次取其最小质因子，更新$x$为$x/mindiv$，当$x=1$时分解结束，时间复杂度$O(logn)$&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_d16c4991-cb05-432c-887d-a16ce6199d48&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_d16c4991-cb05-432c-887d-a16ce6199d48&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d16c4991-cb05-432c-887d-a16ce6199d48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
s[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;s[i])
        p[&lt;/span&gt;++cnt]=i,g[i]=&lt;span&gt;cnt;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;i*p[j]&amp;lt;=n;j++&lt;span&gt;)
    {
        s[i&lt;/span&gt;*p[j]]=&lt;span&gt;1&lt;/span&gt;,g[i*p[j]]=&lt;span&gt;j;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%p[j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;朴素分解质因数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$O(\sqrt n)$的分解质因数，对于单个数的分解质因数和积性函数单值求解具有重要作用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_34fb6d75-e8e8-4300-bf01-062d954add1f&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_34fb6d75-e8e8-4300-bf01-062d954add1f&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_34fb6d75-e8e8-4300-bf01-062d954add1f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i*i&amp;lt;=n;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的i一定是素数，不妨利用反证法证明
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若i为合数，设i有素因子j小于i，j在前面的过程中已被筛去，n%j!=0故n%i!=0，与条件矛盾，故i必为素数&lt;/span&gt;
        n/=i;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;更相减损术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$gcd(a,b)=gcd(a,a-b)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;欧几里得算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$gcd(a,b)=gcd(b,a\%b)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;裴蜀定理（贝祖定理）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若$a,b$是整数,且$(a,b)=d$，那么对于任意的整数$x,y$，$ax+by$都一定是$d$的倍数，特别地，一定存在整数$x,y$，使$ax+by=d$成立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推论：$a,b$互质的充要条件是存在整数$x,y$使$ax+by=1$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推论：设$a_1,a_2,a_3......a_n$为$n$个整数，$d$是它们的最大公约数，那么存在整数$x_1......x_n$使得$x_1*a_1+x_2*a_2+...x_n*a_n=d$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;扩展欧几里得算法（exgcd）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$exgcd$用于解决二元一次不定方程的解的相关问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于不定方程$ax+by=c$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由裴蜀定理可知$gcd(a,b)|(ax+by)$，故若$c$不是$gcd(a,b)$的倍数则无整数解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引理：$ax+by=gcd(a,b)$的特解求法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然存在$x1,y1$使得$ax+by=bx_1+(a\%b)y_1$成立&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由模运算的性质可知$a\%b=a-b*\left\lfloor\dfrac{a}{b}\right\rfloor$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可得$ax+by=bx_1+(a-b*\left\lfloor\dfrac{a}{b}\right\rfloor)y_1$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$=ay_1+b*(x_1-\left\lfloor\dfrac{a}{b}\right\rfloor y_1)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则有$x=y_1,y=x_1-\left\lfloor\dfrac{a}{b}\right\rfloor y_1$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由欧几里得算法得迭代过程的终止状态为$a=gcd(a,b),b=0$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时有$gcd(a,b)*x=gcd(a,b)$，取$x=1$即可，此时任取$y$均可保证该式成立，为避免溢出常取$y=0$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该过程的代码实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_ab42ce20-7645-4d73-b19c-4c3bba3ac102&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_ab42ce20-7645-4d73-b19c-4c3bba3ac102&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab42ce20-7645-4d73-b19c-4c3bba3ac102&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; exgcd(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt; &amp;amp;x,&lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;y)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;b)
    {
        x&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;,y=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    exgcd(b,a&lt;/span&gt;%&lt;span&gt;b,y,x);
    y&lt;/span&gt;-=x*(a/&lt;span&gt;b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;设$x_0,y_0$为$ax+by=gcd(a,b)$的一组特解，即有$ax_0+by_0=gcd(a,b)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则有&lt;strong&gt;原方程的一组特解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$$a\frac{x_0c}{gcd(a,b)}+b\frac{y_0c}{gcd(a,b)}=c$$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$$x_1=\frac{x_0c}{gcd(a,b)},y_1=\frac{y_0c}{gcd(a,b)}$$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;构造原方程的通解形式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;易得对于任意常数$d$，有$a(x_1+db)+b(y_1-da)=c$成立。为保证通解均为整数解，只需使$db,da$均为整数即可；而为保证得到通解，$d$须取满足上述条件的最小值，而易得该最小值为$\frac{1}{gcd(a,b)}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可得通解：$x=x_1+\frac{kb}{gcd(a,b)},y=y_1+\frac{ka}{gcd(a,b)}$其中$k$为任意整数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并有性质：随$k$增大，$x$增大，$y$减小&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则有最小正整数解$(x\%d_x+d_x)\%d_x$（$d_x$为上文所提$db$）（若上式结果为0则最小正整数解为$d_x$），此时$y$取到两数均为正整数时的最大值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;乘法逆元&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$ab≡ba≡1(mod\ p)$&lt;/span&gt;&lt;br/&gt;&lt;span&gt;则称$b$是$mod\ p$意义下$a$的乘法逆元(定义了剩余系中的除法)，记为$a^{-1}$，$a$的乘法逆元的意义是$a$在$mod\ p$剩余系下的倒数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;乘法逆元的扩展欧几里得求法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给定$a,p$计算$b$使得$a*b≡1(mod\ p)$，等价于解方程$ax+py=1$($x,y$为整数变量，扩展欧几里得即可)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;条件：$a,p$互质，即二元一次不定方程有解的条件，也即&lt;strong&gt;乘法逆元存在的充要条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c295c142-c92a-4d02-a16f-1bf1d785a799&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c295c142-c92a-4d02-a16f-1bf1d785a799&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c295c142-c92a-4d02-a16f-1bf1d785a799&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(exgcd(a,mod,x,y)==&lt;span&gt;1&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断逆元是否存在&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(x%mod+mod)%mod);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;xj=即为a的逆元&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;时间复杂度$O(logn)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;费马小定理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如$p$是质数，且$gcd(a,p)=1$，那么$a^{p-1}≡1(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引理：集合$S1=\{1,2,3…p-1\},S2=\{1a,2a,3a…(p-1)a\}$，$S1$在模$p$意义下等于$S2$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故$(p-1)!≡a^{p-1}*(p-1)! (mod\ p)$，$(p-1)!$与$p$互素存在乘法逆元，故$a^{p-1}≡1(mod\ p)$。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;乘法逆元的快速幂求法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若$p$是素数，由于$a^{p-1}≡1(mod\ p)$，故$a$的乘法逆元为$a^{p-2}$（就一个快速幂，所以这里就不再提供代码了）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;条件：$a,p$互质且$p$为质数；时间复杂度：$O(logn)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线性预处理乘法逆元&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在$O(n)$的时间内求出$1..n$的逆元，条件：$1...n$均与$p$互素（为简化表达常表达为$p$为质数）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然$1^{-1}≡1(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设$p=\left\lfloor\dfrac{p}{k}\right\rfloor*k+r(0&amp;lt;r&amp;lt;k&amp;lt;p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可得$\left\lfloor\dfrac{p}{k}\right\rfloor*k+r≡0(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两边同乘$k^{-1},r^{-1}$可得&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$\left\lfloor\dfrac{p}{k}\right\rfloor*r^{-1}+k^{-1}≡0(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可得$k^{-1}≡-\left\lfloor\dfrac{p}{k}\right\rfloor*(p\ mod\ k)^{-1}(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此可以实现递推求解逆元&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_97e62aa6-af55-431b-b208-9a6f8665bd7c&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_97e62aa6-af55-431b-b208-9a6f8665bd7c&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_97e62aa6-af55-431b-b208-9a6f8665bd7c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
a[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
{
    a[i]&lt;/span&gt;=-(p/i)*a[p%&lt;span&gt;i];
       a[i]&lt;/span&gt;=(a[i]%p+p)%&lt;span&gt;p;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;积性函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数论中的积性函数：对于正整数$n$的一个算术函数$f(n)$，若$f(1)=1$，且当$a,b$互质时$f(ab)=f(a)f(b)$，在数论上就称它为积性函数。若对于某积性函数$f(n)$，就算$a,b$不互质，也有$f(ab)=f(a)f(b)$，则称它为完全积性的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欧拉函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对正整数$n$，欧拉函数$\varphi(n)$是小于等于$n$的正整数中与$n$互质的数的数目，例如$\varphi(8)=4(1,3,5,7)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由欧拉函数的积性可得$φ(n)=\prodφ(p_i^{q_i})$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$φ(x=p^q)=p^{q-1}*(p-1)=x*(1-\frac{1}{p})$($p$为质数)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个结论是显然的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故$φ(x)=x*\prod\limits_{i=1}^n(1-\frac{1}{p_i})$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由$φ$的积性性质可由线性筛法$O(n)$计算$φ(1)...φ(n)$&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_43e56fe6-0d46-42e2-baef-e576a74eef15&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_43e56fe6-0d46-42e2-baef-e576a74eef15&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_43e56fe6-0d46-42e2-baef-e576a74eef15&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
p[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;,phi[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=maxn-&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;p[i])
        pr[&lt;/span&gt;++cnt]=i,phi[i]=i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=cnt&amp;amp;&amp;amp;pr[j]*i&amp;lt;=maxn-&lt;span&gt;10&lt;/span&gt;;j++&lt;span&gt;)
    {
        p[i&lt;/span&gt;*pr[j]]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%pr[j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            phi[i&lt;/span&gt;*pr[j]]=phi[i]*&lt;span&gt;pr[j];
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        phi[i&lt;/span&gt;*pr[j]]=phi[i]*&lt;span&gt;phi[pr[j]];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;欧拉定理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若$p,a$为正整数，且$p,a$互质，则：$a^{φ(p)}≡1(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推论：$(a^{φ(p)})^{-1}=a^{φ(p)}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推论：$a^b≡a^{b\%φ(p)}≡a^{b-k*φ(p)}(gcd(a,p)=1)$（等式两边同乘$(a^{φ(p)})^{-1}$）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;扩展欧拉定理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$b&amp;gt;=φ(p)$时，有$a^b≡a^{b\%p+p}(mod\ p)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（$b&amp;lt;φ(p)$时往往直接快速幂求解即可）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;中国剩余定理（CRT）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中国剩余定理可用于求解同余方程组&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$\begin{cases}x≡a_1(mod\ m_1)\\x≡a_2(mod\ m_2)\\.....\\x≡a_n(mod\ m_n)\end{cases}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中$m_1,m_2...m_n$为两两互质的整数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;求解过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们设$M=\prod\limits_{i=1}^nm_i\ ,\ M_i=\frac{M}{m_i}\ ,\ M_it_i≡1(mod\ m_i)\ (1&amp;lt;=i&amp;lt;=n)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则该方程组必有一解$x_0=\sum\limits_{i=1}^na_iM_it_i$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可得通解$x=x_0+k*M$（$k$为任意整数）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则有最小正整数解$x_{min}=(x\%M+M)\%M$，上式结果为0时$x_{min}=M$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;证明：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$\begin{cases}a_jM_jt_j≡0(mod\ m_i)(i\ne j)\\a_jM_jt_j≡a_j(mod\ m_i)(i=j)\end{cases}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故$\sum\limits_{i=1}^na_iM_it_i≡a_i(mod\ m_i)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;扩展中国剩余定理（EXCRT）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩展中国剩余定理可用于求解同余方程组&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$\begin{cases}x≡a_1(mod\ m_1)\\x≡a_2(mod\ m_2)\\.....\\x≡a_n(mod\ m_n)\end{cases}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和中国剩余定理的区别在于，扩展中国剩余定理不要求$m_i$两两互质（很强的性质）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑递推求解，假设已经求出前$k-1$个方程组成的同余方程组的一个解$x$，设$M=lcm(m_1,m_2...m_{k-1})$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则前$k-1$的方程的通解为$x+i*M$（$i$为任意整数）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么对于加入第$k$个方程后的方程组&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们就是要求一个正整数$t$，使得$x+t*M≡a_k(mod\ m_k)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即$t*M≡a_k-x(mod\ m_k)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这个式子我们已经可以通过扩展欧几里得求解$t$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若该同余式无解，则整个方程组无解，若有，则前$k$个同余式组成的方程组的一个解为$x_k=x+t*M$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;核心代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1b707ebe-c9e1-4671-a1a4-c99f398bbe92&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1b707ebe-c9e1-4671-a1a4-c99f398bbe92&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b707ebe-c9e1-4671-a1a4-c99f398bbe92&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld%lld%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;a,&amp;amp;&lt;span&gt;b);
m&lt;/span&gt;=a,ans=&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; t,tmp,i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;ans%=m,i++&lt;span&gt;)
{
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; g=exgcd(m,a,t,tmp),c=((b-ans)%a+a)%&lt;span&gt;a;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c%&lt;span&gt;g)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    t&lt;/span&gt;=mul(t,c/g,a/g),ans+=t*m,m=&lt;span&gt;lcm(m,a);
}
ans&lt;/span&gt;=(ans%m+m)%&lt;span&gt;m;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ans?ans:m);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;大步小步算法（BSGS）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;$BSGS$主要用于求解形如$a^x≡b(mod\ p)$的方程，其中$gcd(a,p)=1$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;考虑最小解$x_0$&lt;/strong&gt;，由欧拉定理的推论可得$a^x≡a^{x-k*φ(p)}$，则$x_0\in[0,φ(p)),k\in Z$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设$a^{x=ik-t}≡b(mod\ p)$，则必有$a^{ik}≡b*a^t(mod\ p)(0&amp;lt;t&amp;lt;=k,0&amp;lt;i&amp;lt;=\left\lceil\dfrac{φ(p)}{k}\right\rceil)$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;枚举$t$，将$b*a^t\%p$存入哈希表（这里也可以使用$map$，不过会多带一个$log$），枚举$i$，在哈希表中查找即可得到第一个循环节中的所有解。第一个查找到的解即为最小解，对于第一个循环节中的任一解$x$，显然$x+k*φ(p),k\in Z^*$为该方程的解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间复杂度$O(k+\dfrac{φ(p)}{k})$，由均值不等式可得$k=\sqrt{φ(p)}$时有最低时间复杂度$O(\sqrt{φ(p)})$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最小解求解代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_34ef99a4-8956-4063-a138-e7a1829e64ec&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_34ef99a4-8956-4063-a138-e7a1829e64ec&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_34ef99a4-8956-4063-a138-e7a1829e64ec&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
k=&lt;span&gt;ceil(sqrt(phi));
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tp=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tmp=n*b%p,i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=k;i++,(tp*=b)%=p,(tmp*=b)%=&lt;span&gt;p)
    mp[tmp]&lt;/span&gt;=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tmp=tp,i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=(phi+k-&lt;span&gt;1&lt;/span&gt;)/k;i++,(tmp*=tp)%=&lt;span&gt;p)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(mp[tmp])
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i*k-&lt;span&gt;mp[tmp]);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no solution\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;扩展BSGS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩展$BSGS$主要用于求解形如$a^x≡b(mod\ p)$的方程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于同余方程$a^x≡b(mod\ p)$，我们可以将其展开为$a*a^{x-1}+pk=b$的形式，可得$gcd(a,p)|b,x&amp;gt;0$为原方程有整数解的一个充分条件，这时讨论$x=0$等式是否成立，若成立则求得答案，否则若方程无解则同余方程无解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于有解的方程，两边同除$gcd(a,p)$可得$\frac{a}{gcd(a,p)}*a^{x-1}+\frac{p}{gcd(a,p)}*k=\frac{b}{gcd(a,p)}$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转化为同余式可得$\frac{a}{gcd(a,p)}a^{x-1}≡\frac{b}{gcd(a,p)}(mod\ \frac{p}{gcd(a,p)})$&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设$p'=\frac{p}{gcd(a,p)}$，若$gcd(a,p')=1$，按$BSGS$处理即可，否则重复执行上述过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然递归深度不超过$logp$，故可近似认为扩展$BSGS$与$BSGS$时间复杂度相同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_06441fda-10d0-4e25-9806-9a53ee7bdf1e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_06441fda-10d0-4e25-9806-9a53ee7bdf1e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06441fda-10d0-4e25-9806-9a53ee7bdf1e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;map&amp;gt;
&lt;span&gt;#define&lt;/span&gt; int long long
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c,a,p,b,k,ans,phi;
map&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;mp;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gcd(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; y?gcd(y,x%&lt;span&gt;y):x;
}
signed main()
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld%lld%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;p,&amp;amp;&lt;span&gt;b);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;a)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        a&lt;/span&gt;%=p,mp.clear(),ans=&lt;span&gt;0&lt;/span&gt;,c=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ps=p,bs=&lt;span&gt;b;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; f=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b&amp;gt;=&lt;span&gt;p)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No Solution\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;a)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; g=gcd(a,p);g!=&lt;span&gt;1&lt;/span&gt;;g=&lt;span&gt;gcd(a,p))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c==&lt;span&gt;b)
            {
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ans),f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b%&lt;span&gt;g)
            {
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No Solution\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            p&lt;/span&gt;/=g,(c*=a/g)%=p,b/=g,ans++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(f)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        phi&lt;/span&gt;=&lt;span&gt;p;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tmp=p,i=&lt;span&gt;2&lt;/span&gt;;i*i&amp;lt;=tmp;i++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tmp%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(tmp%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    tmp&lt;/span&gt;/=&lt;span&gt;i;
                phi&lt;/span&gt;=phi*(i-&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;i;
            }
        k&lt;/span&gt;=&lt;span&gt;ceil(sqrt(phi));
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tp=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tmp=b*a%p,i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=k;i++,(tp*=a)%=p,(tmp*=a)%=&lt;span&gt;p)
            mp[tmp]&lt;/span&gt;=&lt;span&gt;i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tmp=tp,i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=(phi+k-&lt;span&gt;1&lt;/span&gt;)/k;i++,(tmp*=tp)%=&lt;span&gt;p)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mp[tmp*c%&lt;span&gt;p])
            {
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i*k-mp[tmp*c%p]+ans),f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;f)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No Solution\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 04 Feb 2021 15:57:00 +0000</pubDate>
<dc:creator>Ivanovcraft</dc:creator>
<og:description>部分内容引自清华大学秦岳《初等数论》，dengyaotriangle的博客，_WZT_ 的博客，niiick的博客 算术基本定理任何一个大于1的自然数$N$，如果$N$不为质数，那么$N$可以唯一分解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ivanovcraft/p/14375627.html</dc:identifier>
</item>
<item>
<title>Python单元测试框架pytest常用测试报告类型 - 尘世风</title>
<link>http://www.cnblogs.com/feng0815/p/14337690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feng0815/p/14337690.html</guid>
<description>&lt;p&gt;先前博客有介绍pytest测试框架的安装及使用，现在来聊聊pytest可以生成哪些测试报告&lt;/p&gt;

&lt;p&gt;关于allure报告参见先前的一篇博文：&lt;a href=&quot;https://www.cnblogs.com/feng0815/p/13792188.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/feng0815/p/13792188.html&lt;/a&gt; ，这里不再赘述&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
&quot;&quot;&quot;
@author:chenshifeng
@file:test_report.py
@time:2021/01/27
&quot;&quot;&quot;
class TestReport:

    def test_one(self):
        x = &quot;shifeng&quot;
        assert &quot;feng&quot; in x

    def test_two(self):
        x = &quot;hello&quot;
        assert x == &quot;hi&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; pytest test_report.py  --resultlog=./resultlog.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定当前路径下生成resultlog.txt文件，打开文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;. reportdemo/test_report.py::TestReport::test_one
F reportdemo/test_report.py::TestReport::test_two
 self = &amp;lt;test_report.TestReport object at 0x7fd9c0a3eac0&amp;gt;
 
     def test_two(self):
         x = &quot;hello&quot;
 &amp;gt;       assert x == &quot;hi&quot;
 E       AssertionError: assert 'hello' == 'hi'
 E         - hi
 E         + hello
 
 test_report.py:16: AssertionError
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_report.py  --junitxml=./resultlog.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样指定在当前目录下生成resultlog.xml文件，打开文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;testsuites&amp;gt;
    &amp;lt;testsuite errors=&quot;0&quot; failures=&quot;1&quot; hostname=&quot;chenshifengdeMacBook-Pro.local&quot; name=&quot;pytest&quot; skipped=&quot;0&quot; tests=&quot;2&quot;
               time=&quot;0.072&quot; timestamp=&quot;2021-01-27T23:56:58.204464&quot;&amp;gt;
        &amp;lt;testcase classname=&quot;reportdemo.test_report.TestReport&quot; file=&quot;reportdemo/test_report.py&quot; line=&quot;9&quot;
                  name=&quot;test_one&quot; time=&quot;0.001&quot;&amp;gt;&amp;lt;/testcase&amp;gt;
        &amp;lt;testcase classname=&quot;reportdemo.test_report.TestReport&quot; file=&quot;reportdemo/test_report.py&quot; line=&quot;13&quot;
                  name=&quot;test_two&quot; time=&quot;0.002&quot;&amp;gt;
            &amp;lt;failure message=&quot;AssertionError: assert &amp;amp;apos;hello&amp;amp;apos; == &amp;amp;apos;hi&amp;amp;apos;
  - hi
  + hello&quot;&amp;gt;self = &amp;amp;lt;test_report.TestReport object at 0x7fa152b97790&amp;amp;gt;

                def test_two(self):
                x = &amp;amp;quot;hello&amp;amp;quot;
                &amp;amp;gt; assert x == &amp;amp;quot;hi&amp;amp;quot;
                E AssertionError: assert &amp;amp;apos;hello&amp;amp;apos; == &amp;amp;apos;hi&amp;amp;apos;
                E - hi
                E + hello

                test_report.py:16: AssertionError
            &amp;lt;/failure&amp;gt;
        &amp;lt;/testcase&amp;gt;
    &amp;lt;/testsuite&amp;gt;
&amp;lt;/testsuites&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建这样的XML文件有有什么用？ 主要是为了方便Jenkin或其它的持续集成工具读取。&lt;/p&gt;

&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_report.py  --pastebin=all
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210128000514430-653944129.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;复制打印结果最后生成的session-log测试报告链接到浏览器：&lt;a href=&quot;https://bpa.st/UW2IG&quot; target=&quot;_blank&quot;&gt;https://bpa.st/UW2IG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210128000736491-1200664547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;当然，你也可以只选择展示faile的测试用例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; pytest test_class.py  --pastebin=failed
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通过pip安装pytest-html&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; pip install pytest-html  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码文件的当前目录下执行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_report.py --html=./report.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210128003204917-978239891.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;指定在当前目录下生成report.html文件，打开测试文件：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210128003347662-658704397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Feb 2021 15:53:00 +0000</pubDate>
<dc:creator>尘世风</dc:creator>
<og:description>先前博客有介绍pytest测试框架的安装及使用，现在来聊聊pytest可以生成哪些测试报告 #1.allure测试报告 关于allure报告参见先前的一篇博文：https://www.cnblogs.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feng0815/p/14337690.html</dc:identifier>
</item>
<item>
<title>Jenkins Job迁移 - 纵苇星海</title>
<link>http://www.cnblogs.com/tobrainto/p/14375587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tobrainto/p/14375587.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233641319-1377124984.jpg&quot; class=&quot;desc_img&quot;/&gt;简单高效迁移jenkins job&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;121.05350614822&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233641319-1377124984.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前几天由于某些原因，新搞了一个jenkins实例，需要和老的机器具备相同的能力。&lt;/p&gt;
&lt;p&gt;也就是说需要将老的jenkins实例上的大概200多个job同步到新的jenkins实例上。&lt;/p&gt;
&lt;p&gt;下面是整个迁移的过程，如果你有更好的迁移方案，欢迎你在评论区或者后台交流分享，共同提高​。&lt;/p&gt;
&lt;h2 id=&quot;0-方案确定&quot;&gt;0. 方案确定&lt;/h2&gt;
&lt;p&gt;200多个job一方面是太多了，一个个重新建太费时，另一方面也担心建错。&lt;/p&gt;
&lt;p&gt;所以就就想看下有没有整体迁移的方案可以来实施，网上查了一下大概有两种方式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://plugins.jenkins.io/job-import-plugin/&quot; target=&quot;_blank&quot;&gt;插件:job-import-plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Administering+Jenkins#AdministeringJenkins-Moving/copying/renamingjobs&quot; target=&quot;_blank&quot;&gt;同步jobs目录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里采用的是第二种方案即同步jobs目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# tree jenkins -L 1
jenkins
省略n多
|-- jobs
|-- logs
|-- nodes
|-- plugins
省略n多
`-- workspace
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是同步老jenkins实例jenkins主目录下的jobs到新的jenkins实例的jenkins主目录下。&lt;/p&gt;
&lt;p&gt;不知道的jenkins主目录的可以到&lt;br/&gt;&lt;code&gt;系统管理-》系统设置-》主目录&lt;/code&gt;里查看,或者通过浏览器访问&lt;code&gt;http://ip:port/configure&lt;/code&gt;里查看。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233156594-1146041070.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233237606-490068043.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上就是先压缩老jenkins实例jenkins主目录下的&lt;code&gt;jobs&lt;/code&gt;目录，然后再复制压缩之后的文件到新jenkins实例的jenkins主目录下、解压，然后重启服务。&lt;/p&gt;
&lt;h2 id=&quot;1-压缩jobs目录&quot;&gt;1. 压缩jobs目录&lt;/h2&gt;
&lt;h3 id=&quot;11-初次压缩&quot;&gt;1.1 初次压缩&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;# tar -czvf jobs-bak.tar.gz jobs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是执行完这个命令之后迟迟没有结束，感觉不太对劲。第一反应是不是文件太多或者太大。所以赶紧取消了命令的执行，使用了下面的命令来看下目录的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;# du sh 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过了比较长的等待后结果回来了，发现整个目录近47G大，然后就想看下具体是哪些job的目录会比较大。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;# du -m --max-depth=1 | sort -nr
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次经过了比较长的等待后结果出来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;48472 .
35347 ./a
6968  ./b
971 ./c
省略n多目录
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-移除过多的历史构建记录之后再次压缩&quot;&gt;1.2 移除过多的历史构建记录之后再次压缩&lt;/h3&gt;
&lt;p&gt;然后就是清理这些多余的文件，为了清理这些过多的文件还差点整出了一个生产事故，具体参考我的上一篇博文&lt;a href=&quot;https://www.cnblogs.com/tobrainto/p/14280187.html&quot; target=&quot;_blank&quot;&gt;Jenkins开启丢弃旧的构建？你可要小心啊！&lt;/a&gt;&lt;br/&gt;在最终清理完这些文件之后再次压缩，这个时候压缩后得到的文件小多了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# tar -czvf jobs-bak.tar.gz jobs
# du -sh jobs-bak.tar.gz 
123M    jobs-bak.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-远程拷贝&quot;&gt;2. 远程拷贝&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# scp -f obs-bak.tar.gz root@JenkinsBip:/data/jenkins/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-登陆目标机器解压&quot;&gt;3. 登陆目标机器解压&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# tar -zxvf jobs-bak.tar.gz -C jobs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-加载jobs&quot;&gt;4. 加载jobs&lt;/h2&gt;
&lt;p&gt;解压之后拷贝的job并不会立即生效，需要通过jenkins的 &lt;code&gt;系统管理=》读取设置&lt;/code&gt;相关的功能来加载拷贝过来的job。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233259732-142757702.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外也可以通过重启服务来让这些job生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# systemctl restart  jenkins
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202102/2160689-20210204233320246-1060687699.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-经验教训&quot;&gt;5. 经验教训&lt;/h2&gt;
&lt;p&gt;总结一下本次得到的教训&lt;/p&gt;
&lt;p&gt;我们在进行job迁移之前需要先移除过多的历史构建记录，只保留少量的历史构建记录，来保证在源机器和目标机器之间传递的数据尽量小，以减少数据压缩传输耗时，提高迁移效率。&lt;/p&gt;
&lt;p&gt;另外就是确保job依赖的插件都要在新的机器上安装，否则迁移过来的job运行时会有问题。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2160689/202101/2160689-20210115003839182-1834075235.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 04 Feb 2021 15:38:00 +0000</pubDate>
<dc:creator>纵苇星海</dc:creator>
<og:description>前几天由于某些原因，新搞了一个jenkins实例，需要和老的机器具备相同的能力。 也就是说需要将老的jenkins实例上的大概200多个job同步到新的jenkins实例上。 下面是整个迁移的过程，如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tobrainto/p/14375587.html</dc:identifier>
</item>
<item>
<title>怎么一本正经地秀技 - codevald</title>
<link>http://www.cnblogs.com/codevald/p/14375582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codevald/p/14375582.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;修饰符怎么使用也是Java基础中比较重要的知识点，彻底理解了之后，后面学习更高深的东西才能得心应手。今天，以修饰符中比较常见的final为切入点，来谈谈final的使用的奇淫技巧以及一些相关的知识点。学废了记得三连哦。&lt;/p&gt;
&lt;h3 id=&quot;初始化块&quot;&gt;初始化块&lt;/h3&gt;
&lt;p&gt;在final的运用中，经常和初始化块和构造器结合起来一起使用。上篇文章已经介绍完什么是构造器，那么现在先来谈谈什么是初始化块。&lt;/p&gt;
&lt;p&gt;Java会使用构造器对对象进行初始化操作，在使用的构造器的时候需要完成初始化整个Java对象的状态的功能，然后再将整个完整的Java对象返回给程序使用。那么，在Java中，有一个与构造器功能类似的东西，就是初始化块，它能够对Java对象实现初始化操作。&lt;/p&gt;
&lt;p&gt;在Java中，一个类中可以有多个初始化块，相同类型的初始化块的执行顺序是有要求的，先定义的先执行（前面的先执行），后面定义的后执行。&lt;/p&gt;
&lt;p&gt;初始化块的语法其实很简单了，就是:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;

修饰符 {

  //初始化块中的可执行代码块
  ...
  ...
  ...
  
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那初始化块的分类也很简单，就分为&lt;strong&gt;静态初始化块&lt;/strong&gt;和&lt;strong&gt;非静态初始化块两种&lt;/strong&gt;,其中&lt;strong&gt;非静态初始化块&lt;/strong&gt;也叫做&lt;strong&gt;普通初始化块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非静态初始化块&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在生成每个对象的时候&lt;strong&gt;都会执行一次&lt;/strong&gt;，可以初始化&lt;strong&gt;类的实例变量&lt;/strong&gt;。非静态初始化块会在类的构造器之前执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;

`public class CodeVald {

        `  int a = 6;
        
    `//第一个初始化块

    {


      int a = 3;
      if (this.a &amp;gt; 4) {

        System.out.println(&quot;codevald的初始化块:  成员变量a的值大于4&quot;);

      }


      System.out.println(&quot;codevald的初始化块&quot;);


    }

    //第二个初始化块

    {

      System.out.println(&quot;codevald的第二个初始化块&quot;);


    }

    //定义一个无参数的构造器

    public CodeVald() {

      System.out.println(&quot;codevald的无参数构造器&quot;);

    }

    public static void main(String[] args) {

      new CodeVald();


    } 



  }

  
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码定义了两个普通初始化块和一个构造器，那么执行的顺序也很简单了，先定义的初始化块先执行，然后执行后定义的初始化块，接着执行构造器的内容&lt;/p&gt;
&lt;p&gt;来看下编译运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img1.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态初始化块&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;strong&gt;static&lt;/strong&gt;定义，当类装载到系统&lt;strong&gt;只会执行一次&lt;/strong&gt;。如果在静态初始化块中想初始化变量的话，就只能初始化类变量了，即是由&lt;strong&gt;static&lt;/strong&gt;修饰的数据成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来看一个静态初始化块、普通初始化块和构造器结合的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class JingTai_CodeBlock {

    public static void main(String[] args) {


      new C();
      new C();


    }

}


//定义第一个类A，这是父类

class A {


    static {


      System.out.println(&quot;A的静态初始化块&quot;);


    }

    {

      System.out.println(&quot;A的普通初始化块&quot;);

    }

    public A() {

      System.out.println(&quot;A的无参数构造器&quot;);

    }


}

//定义一个子类B

class B extends A {

    static {

      System.out.println(&quot;B的静态初始化块&quot;);


    }

    {

      System.out.println(&quot;B的普通初始化块&quot;);


    }

    public B() {

      System.out.println(&quot;B的无参数构造器&quot;);

    }

    public B(String message) {

      this();

      //通过this()调用无参数的构造器（即重载的构造器）
      System.out.println(&quot;B的带参数构造器，传入的信息为: &quot; + message);



    }

}

//定义一个子类C


class C extends B {


    static {

      System.out.println(&quot;C的静态初始化块&quot;);

    }

    {

      System.out.println(&quot;C的普通初始化块&quot;);


    }

    public C() {

      //通过super调用父类中带参数的构造器

      super(&quot;codevald&quot;);
      System.out.println(&quot;C的构造器&quot;);



    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码定义了A、B、C三个类，他们都提供了静态初始化块和普通初始化块，并且在类B中使用this()调用了重载构造器，在C中使用super()显式地调用了其父类指定的构造器，接着在main()函数调用了两次new C(),创建两个C对象。&lt;/p&gt;
&lt;p&gt;那么来猜下会输出什么结果&lt;/p&gt;
&lt;p&gt;先思考五分钟哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img2.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在来解释一下，这里定义了静态初始化块，那么会在类地初始化阶段执行静态初始化块，而不是创建对象的时候才执行，所以静态初始化块总是比普通初始化块先执行，接着是构造器&lt;/p&gt;
&lt;p&gt;但是系统在类初始化阶段执行静态初始化块的时候，不仅会执行本类的静态初始化块，还会一直上溯到java.lang.Object类（所有对象的父类），如果它包含静态初始化块，先执行java.lang.Object类的静态初始化块，然后执行其父类的静态初始化块...执行完最后才执行该类的静态初始化块，经过上述过程才能完成该类的初始化过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次&lt;/strong&gt;创建C对象的时候，会先运行静态初始化块的内容，但是会先上溯到顶级父类的静态初始化块，所以会先输出&lt;strong&gt;A的静态初始化块&lt;/strong&gt;，接着才是&lt;strong&gt;B的静态初始化块&lt;/strong&gt;，最后是&lt;strong&gt;C的静态初始化块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;执行完静态初始化块，一样先执行顶级父类的普通初始化块，即输出&lt;strong&gt;A的普通初始化块&lt;/strong&gt;，接着执行顶级父类的构造器代码，即输出&lt;strong&gt;A的无参数构造器&lt;/strong&gt;。然后输出父类的普通初始化块，接着是构造器，所以输出&lt;strong&gt;B的普通初始化块&lt;/strong&gt;,因为C的构造器调用的是带参数的父类构造器，所以B中会调用带参数的构造器B，所以会输出&lt;strong&gt;B的无参数构造器&lt;/strong&gt;，&lt;strong&gt;B的带参数构造器，传入的信息为: codevald&lt;/strong&gt;，接着执行C的普通初始化块的代码，即输出&lt;strong&gt;C的普通初始化块&lt;/strong&gt;，然后是构造器的代码，即&lt;strong&gt;C的构造器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次&lt;/strong&gt;创建实例C的时候，因为类C已经在虚拟机中存在，所以无需再初始化C类了，所以静态初始化块的代码不再执行，而是重复地执行静态后面的代码。&lt;/p&gt;
&lt;h3 id=&quot;final修饰符&quot;&gt;final修饰符&lt;/h3&gt;
&lt;p&gt;final可以用来修饰类、变量和方法，通过final修饰以后，被修饰的类、方法和变量就表示不可改变的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修饰成员变量&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;成员变量是随着类的初始化或者对象初始化而初始化的。当初始化的时候，就会为类的类属性分配内存，并设置一个默认值；当创建对象时，就会为对象的实例属性分配内存，并分配默认值。一般来说，都是在普通初始化块、静态初始化块、构造器中区指定初始值的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，final修饰的属性，在哪里声明初始值是有一定的规则的，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;修饰类属性时：可在静态静态初始化块中声明该属性的初始值&quot;&gt;修饰类属性时：可在静态静态初始化块中声明该属性的初始值&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&quot;修饰实例属性时：-可在普通初始化块中或者构造器中指定初始值&quot;&gt;修饰实例属性时： 可在普通初始化块中或者构造器中指定初始值&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;修饰局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在初始化局部变量的时候，局部变量必须由程序员显式地去初始化。但是使用final修饰地局部变脸既可以指定默认值，也可以不指定默认值。假如在定义修饰的局部变量时没有指定默认值，则可以在后面代码中对该变量赋予一个指定的初始值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，现在就&lt;strong&gt;final&lt;/strong&gt;和初始化块结合起来，来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class UseFinal {

        //定义成员变量时指定默认值
        
        final String author = &quot;codevald&quot;;
        final String str;
        final int a;
        final static double d;
        
        //初始化块，可对没有指定默认值的实例属性指定初始值
        
        {
        
                str = &quot;Hello&quot;;
                
                //由于定义author时已经制定了默认值，因此不能为author重新赋值，下列语句会导致编译错误
                
                //author = &quot;CodeVald&quot;
        
        
        }


        

        static {
        
                //在静态初始化块中为类属性指定初始值
        
                d = 2.1;
        
        
        }

        public UseFinal() {
        
                a = 21;
        
        }
        
        
        public void useFinal() {
        
                //普通方法不能为fina修饰的成员变量指定初始化值
                
                //d = 2.1;
        
        
        }



        public static void main(String[] args) {
        
                UseFinal useFinal = new UseFinal();
                System.out.println(useFinal.author);
                System.out.println(useFinal.str);
                System.out.println(useFinal.a);
                System.out.println(useFinal.d);
        
        
        
        }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果也很容易就出来了，但是，这里要注意一点的是，普通方法不能为final修饰的变量赋值，会出现编译错误的问题。&lt;/p&gt;
&lt;p&gt;来看下运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img3.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下，final成员变量（包括实例成员和类成员）必须由程序员显式地初始化，系统不会对final成员进行隐式初始化。如果想在初始化块、构造器中对final的成员变量进行初始化，那么一定要在初始化之前就访问该成员变量的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;final方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java中，经常用final修饰那些不希望被重写的方法。所以，如果我们不希望子类重写父类的某个方法，就可以使用final修饰该方法。我们有时候会希望获取一个Object对象，所用的getClass()方法就是一个final方法，因为它的设计者不希望该方法被重写，就用final将该方法密封起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;final修饰的方法只是不能重写，但是可以重载。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class Incorrect {

        public final void test() {
        
        
        
          }
        

}


class Sub extends Incorrect {
        
        //下面的写法将导致编译错误，不能重写final修饰的方法
        
        @Override 
        
        
        public void test() {
        
        
        
        
          }


}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译程序，执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img4.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java程序中，对于private修饰的方法来说，它只在当前类中可见，所以其子类无法访问该方法。所以，如果在子类中定义了一个与父类private方法有相同方法名、形参列表和返回值类型的方法，这不是方法重写，只是重新定义了一个新方法。不会出现编译错误的问题&lt;/p&gt;
&lt;p&gt;例如下面的代码在子类中重写父类的 private final方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class Invaild {

        private final void test() {
        
        
        
        }

}


class Sub extends Invaild {

        public void test() {}


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在匿名内部类中，很多时候也会用到final的地方，现在先来系统地谈谈内部类是啥东西。&lt;/p&gt;
&lt;h3 id=&quot;内部类&quot;&gt;内部类&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;内部类指的是在外部类的内部再定义一个类，内部类作为外部类的一个成员，是依附在外部类而存在的。内部类可以是静态的，非静态的，可以使用protected和private来修饰，而外部类只能使用public和默认的包访问权限。&lt;strong&gt;Java中的内部类主要有成员内部类、静态内部类、局部内部类和匿名内部类。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么内部类有什么使用的价值呢？&lt;/p&gt;
&lt;p&gt;Java是从JDK1.1开始引入了内部类，内部类的主要作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类&lt;/li&gt;
&lt;li&gt;内部类的成员可以直接访问外部类的私有数据，因为内部类被当成了外部类的成员，同一个类中的成员之间是可以互相访问的。但外部类不能访问内部类的实现细节，譬如属性。&lt;/li&gt;
&lt;li&gt;匿名内部类适用于那些创建仅使用一次的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;内部类是一个编译时的概念，一旦编译成功，外部类和内部类就成为完全不同的类，即生成两个类的编译文件，分别是outer.class和outer$inner.class(假如外部类是outer，内部类是inner)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员内部类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在大多数的情况下，内部类作为成员内部类来定义。成员内部类是一种与属性、方法、构造器和初始化块相似的类成员。局部内部类和匿名内部类都不是类成员。Java中的成员内部类分别是静态内部类和非静态内部类。&lt;strong&gt;使用static修饰的就是静态内部类，没有使用static修饰的成员内部类就是非静态内部类.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;非静态内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;

public class FeiJingTai {
        
        private String area;
        
        
        //重载构造器
        
        public FeiJingTai() {
        
        
        }
        
        public FeiJingTai(String area) {
        
                this.area = area;
        
        }
        
        //定义内部类
        
        private class FeiJingTaiInner {
        
                //内部类的属性
                
                private String name;
                private String wechat;
                
                public FeiJingTaiInner(String name,String wechat) {
                
                        this.name = name;
                        this.wechat = wechat;
                
                
                }
                
                //内部方法
                
                public void info() {
                
                
                        System.out.println(&quot;CodeVald的作者是 &quot; + name + &quot;,微信号是 &quot; + wechat);
                        System.out.println(&quot;所属地区是 &quot; + area);
                
                
                
                }

        
        }
        
                //外部类测试方法
        
                public void test() {
                
                
                        FeiJingTaiInner a = new FeiJingTaiInner(&quot;codevald&quot;,&quot;valdcode&quot;);
                        a.info();

                }


                public static void main(String[] args) {
                
                
                        FeiJingTai a = new FeiJingTai(&quot;广东广州&quot;);
                        a.test();

                
                }



}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，可以看到在非静态内部类中可以直接访问外部类的私有成员，所以其实就是在类FeiJingTaiInner的方法内直接访问外部类的私有属性。这是因为在类FeiJingTaiInner内部类对象中保存了一个它储存的外部类对象的引用[&lt;strong&gt;当调用非静态内部类的实例方法时，必须有一个非静态内部类实例，而非静态内部类实例必须寄居在外部类实例里&lt;/strong&gt;]&lt;/p&gt;
&lt;p&gt;编译程序，将会看到在文件路径下生成了两个类文件一个是&lt;strong&gt;FeiJingTai.class&lt;/strong&gt;，另一个是&lt;strong&gt;FeiJingTai$FeiJingTaiInner.class&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img6.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行后的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img7.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class MemberInner {// 定义类 MemberInner，这是一个外部类
    private String name = &quot;codevald&quot;;

    public void execute() {
        // 在外部类中创建成员内部类
        InnerClass innerClass = this.new InnerClass();
    }

    /** 成员内部类 */
    public class InnerClass {
        // 内部类可以创建与外部类同名的成员变量
        private String name = &quot;codevald&quot;;

        public void execute() {
            System.out.println(this.name);
            // 在内部类中使用外部类成员变量的方法
            System.out.println(MemberInner.this.name);
        }
    }

    public static void main(String[] args) {
        MemberInner.InnerClass innerClass = new MemberInner().new InnerClass();
        innerClass.execute();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，使用了两种方式创建内部类对象，一种是用外部引用的方式，另一种是调用方法创建，在execute()方法中,this代表的是创建在堆中的外部对象，而在内部类，使用this是分别引用内部类中的属性和外部类中的属性。&lt;/p&gt;
&lt;p&gt;看下编译运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img8.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态内部类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果不需要内部类对象与外部类对象之间有联系，则可以将内部类声明为static。在非静态内部类中，内部类对象通常会保存了一个指向外部类的引用，如果内部类是static时就不用了，&lt;strong&gt;非静态内部类通常也称为嵌套类&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;嵌套类要注意以下两点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要创建嵌套类的对象，不需要外部类的对象&lt;/li&gt;
&lt;li&gt;不能直接从嵌套类的对象中访问非静态的外部类对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从一段具体的代码来分析一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class JingTai {

        private String name_1 = &quot;codevald&quot;;
        private static String name_2 = &quot;codevald&quot;;
        
        static class JingTaiInner {
        
                private static String name;
                
                public static void main(String[] args) {
                
                        //可以输出外部类的静态类成员变量
                
                        System.out.println(name_2);
                        
                        //System.out.println(name_1);
                        //不可以直接输出外部类的非静态类成员变量
                        
                        //得生成对象，再用对象引用去访问
                        
                        JingTai a = new JingTai();
                        System.out.println(a.name_1);
                
                
                
                
                }

        
        }

        public static void main(String[] args) {
                
                JingTai.JingTaiInner a = new JingTai.JingTaiInner();
                

                
        }



}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img9.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码中，在内部类有输出语句，然后再外部类创建内部类，但是在内部类中，只能直接访问外部类的静态属性，要访问外部类的非静态属性得生成对象，再用对象的引用去访问。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;生成一个静态内部类不需要外部类成员，这是静态内部类和成员内部类的区别。静态内部类可以直接[Outer.Inner inner = new Outer.Inner();],而不需要通过外部类来完成。这样子实际上静态内部类就是一个独立的类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部内部类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在方法中定义的内部类就是局部内部类。与局部变量相似的是，局部内部类可以访问当前代码中的常量和外部类的所有成员。在Java中，和局部变量一样，不能将局部内部类定义为public、private、protected、和static类型，并且在定义方法时，只能在方法中声明final类型的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class LocalInner {

        public static void main(String[] args) {
        
        
                class InnerClass {
                
                        String name;
                
                }
        
                class InnerSub extends InnerClass {
                
                        String des;
                
                
                }
        
                //创建局部内部类的对象
                
                InnerSub is = new InnerSub();
                is.name = &quot;codevald&quot;;
                is.des = &quot;想起来了吗？看完就想起来了&quot;;
                System.out.println(&quot;author: &quot; + is.name + &quot;\n&quot; + &quot;subject: &quot; + is.des);

        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img10.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;匿名类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在实际的项目动手过程，经常会看到一个很奇怪的写法，直接在代码中随机用new新节一个对象，然后在new；里面直接简单粗暴的加入要执行的代码，这就是匿名类。好处就是代码简洁、紧凑，不会出现一大段繁杂的类定义代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java程序中，因为匿名类没有名字，所以它的创建方式初学的时候看起来会很懵逼，创建的格式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
new 类/接口名(参数列表) [实现接口()]{
     //匿名内部类的类体部分
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;{...}中可以定义变量的名称、方法，它跟普通的类一样。&lt;/p&gt;
&lt;p&gt;因为Java程序中的匿名类没有名称，所以不能在其他地方引用，也不能实例化，只能使用一次，而且里面不能有构造器。&lt;/p&gt;
&lt;p&gt;来看一段代码&lt;/p&gt;
&lt;p&gt;先定义一个抽象父类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public abstract class Author {
        
        private String name;
        
        public String getName() {
        
                return name;
        
        }


        public void setName(String name) {
        
                this.name = name;
        
        }

        public abstract int article();


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类进行测试，在类中,test()方法接收一个Author类型的参数，同时要先实现类才能new新的类实例，在方法中直接使用匿名内部类新建一个Author实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class NiMing {

        public void test(Author author) {
        
                System.out.println(&quot;这是&quot; + author.getName() + &quot;的第&quot; + author.article() + &quot;篇原创作品.&quot;);
        
        }
        
        
        public static void main(String[] args) {
        
                NiMing test = new NiMing();
                test.test(new Author() {
                
                        //使用匿名内部类来创建一个Author实例
                        
                        @Override 
                        
                        public int article() {
                                
                                return 2;
                        
                        }
                
                
                        @Override 
                        
                        public String getName() {
                                
                                return &quot;codevald&quot;;
                        
                        }

                
                });

        }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img11.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于讲完了，现在要进入主题了，匿名内部类中什么时候会用到final呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用final形参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java中，当我们需要给匿名内部类传递参数的时候，并且如果在内部类中使用该形参的时候，这个形参则必须由final修饰的。即该匿名内部类所在方法的形参必须加上final修饰符。&lt;/p&gt;
&lt;p&gt;编写一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class NiMing_Final {

        public static void main(String[] args) {
        
                NiMing_Final niming = new NiMing_Final();
                Inner inner = niming.getInner(&quot;codevald&quot;,true);
                System.out.println(&quot;这是&quot; + inner.getName() + &quot;的第&quot; + inner.article() + &quot;篇原创作品&quot;);
        
        

        }



        public Inner getInner(final String name,boolean isOriginal) {
        
                return new Inner() {
                
                        private String nameStr = name;
                        private int article;
                        
                        {
                        
                                //实例初始化
                                
                                if (isOriginal) {
                                
                                        article = 2;
                                
                                } else {
                                
                                        article = 0;
                                
                                }

                        
                        }
                
                
                        @Override 
                        
                        public String getName() {
                        
                                return nameStr;
                        
                        }
                        
                        @Override 
                        
                        public int article() {
                        
                                return article;
                        
                        }
                
                

                
                };
        

        }


}



interface Inner {

        String getName();
        int article();


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过实例初始化实现类似构造器的功能&lt;/p&gt;
&lt;p&gt;来看下运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img15.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;枚举类&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在枚举类中，使用final的频率是最频繁的。什么是枚举类？在大多数情况下，我们要实例化的类对象是有限的而且固定的，例如季节，这种实力数量有限而且固定的类，在Java中被称为枚举类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先来做个有意思的事情，自己模拟实现一个枚举类，在实现枚举类的时候，有以下几个步骤:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过private将构造器隐藏起来&lt;/li&gt;
&lt;li&gt;把此类需要用到的所有实例都用public static final修饰的形式保存起来&lt;/li&gt;
&lt;li&gt;提供一些静态方法允许其他程序根据特定参数获取与之匹配的实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么可以定义一个Season类，在里面分别为4个季节定义4个对象，这样类Season就定义为了一个枚举类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class Season {

        //将Season定义成不可变得，将其属性定义成final
        
        private final String name;
        private final String description;
        
        public static final Season SPRING = new Season(&quot;春天&quot;,&quot;绿肥红瘦&quot;);
        public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;骄阳似火&quot;);
        public static final Season FALL = new Season(&quot;秋天&quot;,&quot;天高云淡&quot;);
        public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;惟余莽莽&quot;);

        //构造器一定要定义为private属性
        
        private Season(String name,String description) {
        
                this.name = name;
                this.description = description;
        
        }
        
        //也可以通过getSeason()获取枚举常量
        
        public static final Season getSeason(int seasonValue) {
        
                switch(seasonValue) {
                
                        case 1:
                                
                                return SPRING;
                        
                        
                        
                        case 2:
                                
                                return SUMMER;
                        
                        
                        case 3:
                                
                                return FALL;

                        
                        case 4:
                        
                                return WINTER;

                                
                        
                        default:
                        
                                return null;

                }
        

        }


        public String getName() {
        
                return this.name;
        
        
        }


        public String getDescription() {
        
                return description;
                
        
        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类Season就成为了一个不可变的类，此类包含了4个static final常量的属性，也就代表了该类所能创建的对象。其他程序需要用到Season对象时，可以用Season.SPRING方式或者getSeason()静态方法获得。&lt;/p&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class TestSeason {

        public TestSeason(Season s) {
        
                System.out.println(s.getName() + &quot;，是一个&quot; + s.getDescription() + &quot;的季节&quot;);

        }


        public static void main(String[] args) {
        
        
        
                new TestSeason(Season.SPRING);
                new TestSeason(Season.SUMMER);
                new TestSeason(Season.FALL);
                new TestSeason(Season.WINTER);

        }
        
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img13.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自己模拟完枚举类后，会发现枚举类其实就是在类编译的时候，就生成了相对应的静态常量，并且构造器是对用户透明的，它会自己进行初始化，我们只需要关心我们需要获取什么样的枚举对象就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;枚举类型是从JDK1.5开始引入的，Java引入了一个新的关键字enum来定义枚举类。这个enum所定义的类实际上都是继承自类库中Enum(java.lang.Enum)的子类,它继承了Enum中许多有用的方法。&lt;/p&gt;
&lt;p&gt;来继续看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public enum Color {

        RED(255,0,0),BLUE(0,0,255),BLACK(0,0,0),YELLOW(255,255,0),GREEN(0,255,0);

        private Color(int redValue,int greenValue,int blueValue) {
        
                this.redValue = redValue;
                this.greenValue = greenValue;
                this.blueValue = blueValue;

        }
        
        
        @Override 
        
        public String toString() {
                
                //覆盖了父类Enum的toString()方法

                return super.toString() + &quot;(&quot; + redValue + &quot;,&quot; + greenValue + &quot;,&quot; + blueValue + &quot;)&quot;;

        }
        



        //自定义数据域

        private int redValue;
        private int greenValue;
        private int blueValue;

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的Color枚举类是一个不可继承的final类。枚举值（RED...）都是Color类型的静态常量，因为枚举类是class，所以在枚举类型中也可以有构造器、方法和数据域，但是枚举类的构造器是私有的，它会自己调用。&lt;/p&gt;
&lt;p&gt;而且在上面的枚举类中，重写了枚举类Enum的toString()方法，打印出更完整的信息。&lt;/p&gt;
&lt;p&gt;来看下会有什么输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/forward-codevald/official-accounts@main/img14.JPG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，调用了Enum的ordinal()方法，它会返回枚举值在枚举类中的顺序，这个顺序是根据枚举值在声明的顺序中定的，所以会输出&quot;0 1 2 3 4&quot;。&lt;/p&gt;
&lt;p&gt;然后调用了Enum的valueOf()方法，此方法是和toString()方法对应的，返回带指定名称的指定类型的枚举常量，所以会输出&quot;BLUE(0,0,255)&quot;。&lt;/p&gt;
&lt;p&gt;最后，可能大家会疑惑，为什么println输出会调用重写的toString()方法呢？&lt;/p&gt;
&lt;p&gt;别急，让我来一一分析一下。&lt;/p&gt;
&lt;p&gt;直接看Java相关类的源代码就可以分析出来了。&lt;/p&gt;
&lt;p&gt;先来看下System.out.println和System.out.print的源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void println(Object x){ 
  String s = String.valueOf(x); 
     synchronized (this) 
      { 
      print(s); 

      newLine();

      } 





   public void print(Object obj) { 
    write(String.valueOf(obj));
  } 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当要打印一个对象时，会自动调用String.valueOf()这个方法。&lt;/p&gt;
&lt;p&gt;那么我们再来看下valueof()这个方法的源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static String valueOf(Object obj) {
    return (obj == null) ? &quot;null&quot; : obj.toString();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思就是，当传入的对象为Null时，会返回一个null，当非null时，会返回这个obj的toString()方法，所以，非null时就会调用toString()方法，原因我们就知道了，这就是当我们调用 print 或者 println 打印一个对象时，它会打印出这个 对象的 toString()的最终根源。&lt;/p&gt;
&lt;p&gt;所以，我觉得平时没事可以多研究JDK的源代码，站在巨人的肩膀上，看下怎么写出更简洁优美的代码。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;今天的内容就到这里了，相信看到这里，你应该明白了final大概是怎么用的，什么时候需要用。“合抱之木,生于毫末。”只有站在设计者的角度，从根本上去理解为什么这么设计，吃透每个基本的知识点，并且深入研究源码，才能让内功更深厚，从而去解决一个又一个更高深的问题。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Feb 2021 15:34:00 +0000</pubDate>
<dc:creator>codevald</dc:creator>
<og:description>前言 修饰符怎么使用也是Java基础中比较重要的知识点，彻底理解了之后，后面学习更高深的东西才能得心应手。今天，以修饰符中比较常见的final为切入点，来谈谈final的使用的奇淫技巧以及一些相关的知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codevald/p/14375582.html</dc:identifier>
</item>
<item>
<title>设计模式（十）——组合模式（HashMap源码解析） - 十四lin</title>
<link>http://www.cnblogs.com/linzm14/p/14375555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzm14/p/14375555.html</guid>
<description>&lt;h2&gt;1 看一个学校院系展示需求&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，&lt;/span&gt; &lt;span&gt;一个学院有多个系。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232028800-556519925.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2 传统方案解决学校院系展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232051139-2055053907.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;Section0&quot; readability=&quot;11&quot;&gt;
&lt;h2&gt;3 传统方案解决学校院系展示存在的问题分析&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;实际上我们的要求是&lt;/span&gt; &lt;span&gt;：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，&lt;/span&gt; &lt;span&gt;因&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实&lt;span&gt;现管理操作。&lt;/span&gt; =&amp;gt; 组合模式&lt;/p&gt;
&lt;h2&gt;4 组合模式基本介绍&lt;/h2&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体&lt;strong&gt;-&lt;/strong&gt;部分”的层次关系。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 这种类型的设计模式属于结构型模式。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;4) 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象&lt;/p&gt;
&lt;h2&gt;5 组合模式原理类&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232213888-889897852.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对原理结构图的说明-即(组合模式的角色及职责)&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;1) &lt;strong&gt;Component&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;:这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理&lt;/p&gt;
&lt;p&gt;Component 子部件, Component  可以是抽象类或者接口&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) &lt;strong&gt;Leaf&lt;/strong&gt;&lt;strong&gt; :&lt;/strong&gt; 在组合中表示叶子节点，叶子节点没有子节点&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) &lt;strong&gt;Composite&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;:&lt;span&gt;非叶子节点，&lt;/span&gt;  用于存储子部件&lt;span&gt;，&lt;/span&gt;  在 Component 接口中实现 子部件的相关操作，比如增加(add), 删除。&lt;/p&gt;
&lt;h2&gt;6 &lt;span&gt;组合模式解决学校院系展示的&lt;/span&gt; &lt;span&gt;应用实例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;应用实例要求&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;1) &lt;span&gt;编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，&lt;/span&gt; &lt;span&gt;一个学院有多个系。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 思路分析和图解(类图)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232245508-1379967877.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;OrganizationComponmet 类&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrganizationComponmet {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String des;
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(OrganizationComponmet organizationComponmet) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(OrganizationComponmet organizationComponmet) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrganizationComponmet(String name, String des) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.des =&lt;span&gt; des;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDes() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; des;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDes(String des) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.des =&lt;span&gt; des;
    }
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print();
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
University 类
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; University &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; OrganizationComponmet{
    
    List&lt;/span&gt;&amp;lt;OrganizationComponmet&amp;gt; organizationComponmets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrganizationComponmet&amp;gt;&lt;span&gt;();

    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; University(String name, String des) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, des);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(OrganizationComponmet organizationComponmet) {
        organizationComponmets.add(organizationComponmet);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(OrganizationComponmet organizationComponmet) {
        organizationComponmets.remove(organizationComponmet);
    }
    
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDes() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getDes();
    }
    
    @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getName();
        }
    
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
    
        System.out.println(&lt;/span&gt;&quot;---------------------&quot; + getName() + &quot;--------------------&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (OrganizationComponmet organizationComponmet : organizationComponmets) {
            organizationComponmet.print();
        }
    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
College 类
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; College &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; OrganizationComponmet{

List&lt;/span&gt;&amp;lt;OrganizationComponmet&amp;gt; organizationComponmets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;OrganizationComponmet&amp;gt;&lt;span&gt;();

    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; College(String name, String des) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, des);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(OrganizationComponmet organizationComponmet) {
        organizationComponmets.add(organizationComponmet);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(OrganizationComponmet organizationComponmet) {
        organizationComponmets.remove(organizationComponmet);
    }
    
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDes() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getDes();
    }
    
    @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getName();
        }
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
    
        System.out.println(&lt;/span&gt;&quot;---------------------&quot; + getName() + &quot;--------------------&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (OrganizationComponmet organizationComponmet : organizationComponmets) {
            organizationComponmet.print();
        }
    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
Department 类
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Department &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; OrganizationComponmet{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Department(String name, String des) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name, des);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDes() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getDes();
    }
    
    @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getName();
        }
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        System.out.println(getName());
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Client类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        OrganizationComponmet university &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; University(&quot;波大&quot;, &quot;美国大学&quot;&lt;span&gt;);
        
        OrganizationComponmet college1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; College(&quot;计算机学院&quot;, &quot;计算机&quot;&lt;span&gt;);
        OrganizationComponmet college2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; College(&quot;中文学院&quot;, &quot;中文&quot;&lt;span&gt;);
        
        university.add(college1);
        university.add(college2);
        
        OrganizationComponmet department1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Department(&quot;软件工程专业&quot;, &quot;软件&quot;&lt;span&gt;);
        OrganizationComponmet department2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Department(&quot;大数据专业&quot;, &quot;大数据&quot;&lt;span&gt;);
        OrganizationComponmet department3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Department(&quot;汉语言专业&quot;, &quot;汉语言&quot;&lt;span&gt;);
        OrganizationComponmet department4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Department(&quot;中华文化专业&quot;, &quot;中华文化&quot;&lt;span&gt;);
        
        college1.add(department1);
        college1.add(department2);
        college2.add(department3);
        college2.add(department4);
        
        university.print();
        System.out.println(&lt;/span&gt;&quot;--------------------------------------------&quot;&lt;span&gt;);
        college1.print();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7 &lt;span&gt;组合模式在&lt;/span&gt; JDK 集合的源码分析&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) Java 的集合类-&lt;strong&gt;HashMap&lt;/strong&gt; 就使用了组合模式&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 代码分析&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232538631-500329085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210204232547114-1823326747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.composite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CompositeApply {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Map&lt;/span&gt;&amp;lt;Object, Object&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Object, Object&amp;gt;&lt;span&gt;();
        hashMap.put(&lt;/span&gt;0, &quot;zero&quot;&lt;span&gt;);
        System.out.println(hashMap);
        
        Map&lt;/span&gt;&amp;lt;Object, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Object, Object&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;1, &quot;one&quot;&lt;span&gt;);
        map.put(&lt;/span&gt;2, &quot;two&quot;&lt;span&gt;);
        map.put(&lt;/span&gt;3, &quot;three&quot;&lt;span&gt;);
        
        hashMap.putAll(map);
        System.out.println(hashMap);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8 组合模式的注意事项和细节&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;4) 需要遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.&lt;/p&gt;
&lt;p&gt;要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式&lt;/p&gt;

&lt;p&gt;仅供参考，有错误还请指出！&lt;/p&gt;
&lt;p&gt;有什么想法，评论区留言，互相指教指教。&lt;/p&gt;

</description>
<pubDate>Thu, 04 Feb 2021 15:27:00 +0000</pubDate>
<dc:creator>十四lin</dc:creator>
<og:description>1&amp;#160;看一个学校院系展示需求 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图： 2&amp;#160;传统方案解决学校院系展</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linzm14/p/14375555.html</dc:identifier>
</item>
<item>
<title>.NET使用DinkToPdf将HTML转成PDF - Iannnnnnnnnnnnn</title>
<link>http://www.cnblogs.com/Iannnnnnnnnnnnn/p/14375513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Iannnnnnnnnnnnn/p/14375513.html</guid>
<description>&lt;h2 id=&quot;0介绍&quot;&gt;0.介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;C# .NET Core wrapper for wkhtmltopdf library that uses Webkit engine to convert HTML pages to PDF.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近浏览文章的时候发现DinkToPdf框架，可以利用HTML转换成PDF，与我早期使用ITextSharp 框架构建PDF的方式不太一样。DinkToPdf直接将HTML转成PDF，HTML的构造直观且简单。这种方式可能可以成为不错的选择！&lt;br/&gt;下面为大家简单介绍DinkToPdf的使用方式。&lt;/p&gt;
&lt;h2 id=&quot;1-参考资料&quot;&gt;1. 参考资料&lt;/h2&gt;
&lt;blockquote readability=&quot;0.79545454545455&quot;&gt;
&lt;p&gt;Github &lt;a href=&quot;https://github.com/rdvojmoc/DinkToPdf&quot; target=&quot;_blank&quot;&gt;https://github.com/rdvojmoc/DinkToPdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2核心内容&quot;&gt;2.核心内容&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;构造htmltopdfdocument对象&quot;&gt;构造HtmlToPdfDocument对象&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;html文本形式&quot;&gt;Html文本形式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;string html = @&quot;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt; 
&amp;lt;meta charset='utf-8'&amp;gt; 
&amp;lt;title&amp;gt;W3Cschool&amp;lt;/title&amp;gt; 
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h4&amp;gt;Html文本&amp;lt;/h4&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&quot;;

var doc = new HtmlToPdfDocument()
{
    GlobalSettings = {
        ColorMode = ColorMode.Color,
        Orientation = Orientation.Landscape,
        PaperSize = PaperKind.A4,
    },
    Objects = {
        new ObjectSettings() {
            PagesCount = true,
            HtmlContent = htmlContent,
            WebSettings = { DefaultEncoding = &quot;utf-8&quot; },
            HeaderSettings = { FontSize = 9, Right = &quot;Page [page] of [toPage]&quot;, Line = true },
            FooterSettings = { FontSize = 9, Right = &quot;Page [page] of [toPage]&quot; }
        }
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;url方式&quot;&gt;URL方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;    
string url = &quot;&quot;https://www.baidu.com/&quot;;
var doc = new HtmlToPdfDocument()
{
    GlobalSettings = {
        PaperSize = PaperKind.A4Small
    },

    Objects = {
        new ObjectSettings()
        {
            Page = url,
        }
    }
};
            
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;htmltopdfdocument-转成-pdf&quot;&gt;HtmlToPdfDocument 转成 PDF&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var converter = new BasicConverter(new PdfTools());

byte[] pdf = converter.Convert(doc);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;if (!Directory.Exists(&quot;Files&quot;))
{
    Directory.CreateDirectory(&quot;Files&quot;);
}

using (FileStream stream = new FileStream(@&quot;Files\&quot; + DateTime.UtcNow.Ticks.ToString() + &quot;.pdf&quot;, FileMode.Create))
{
    stream.Write(pdf, 0, pdf.Length);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;框架依赖于wkhtmltopdf，在自己部署的时候如果提示缺少dll，记得去官方Git上下载（样例源码已经复制了64位的dll）&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rdvojmoc/DinkToPdf/tree/master/v0.12.4&quot; target=&quot;_blank&quot;&gt;https://github.com/rdvojmoc/DinkToPdf/tree/master/v0.12.4&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3效果图展示&quot;&gt;3.效果图展示&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;html文本形式-1&quot;&gt;Html文本形式&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;w3c表格截图&quot;&gt;w3c表格截图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/870711/202102/870711-20210204224048208-855643127.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;pdf生成结果图&quot;&gt;pdf生成结果图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/870711/202102/870711-20210204224153501-135886120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;百度网址生成pdf效果图&quot;&gt;百度网址生成pdf效果图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/870711/202102/870711-20210204224242208-628252641.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4样例源码地址&quot;&gt;4.样例源码地址&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Impartsoft/Bins/tree/main/DinkToPdfDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/Impartsoft/Bins/tree/main/DinkToPdfDemo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 04 Feb 2021 15:14:00 +0000</pubDate>
<dc:creator>Iannnnnnnnnnnnn</dc:creator>
<og:description>0.介绍 C# .NET Core wrapper for wkhtmltopdf library that uses Webkit engine to convert HTML pages to P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Iannnnnnnnnnnnn/p/14375513.html</dc:identifier>
</item>
<item>
<title>MySQL 中的自增主键 - 萌新J</title>
<link>http://www.cnblogs.com/mengxinJ/p/14352038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxinJ/p/14352038.html</guid>
<description>&lt;p&gt;&lt;span&gt;MySQL 的主键可以是自增的，那么如果在断电重启后新增的值还会延续断电前的自增值吗？自增值默认为1，那么可不可以改变呢？下面就说一下 MySQL 的自增值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;特点&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;保存策略&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、如果存储引擎是 MyISAM，那么这个自增值是存储在数据文件中的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果是 InnoDB 引擎，1）在 5.6 之前是存储在内存中，没有持久化，在重启后会去找最大的键值，举个例子，如果一个表当前数据行里最大 id是10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　  2）在 8.0 开始，自增值就保存在 redo log 中，重启后会从 redo log 中读取之前保存的自增值。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;自增值的确定&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、如果插入数据时 id 字段指定为0、null 或未指定，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段，并且&lt;/span&gt;&lt;span&gt;会以 &lt;span&gt;&lt;strong&gt;auto_increment_offset &lt;/strong&gt;&lt;/span&gt;作为初始值，&lt;span&gt;&lt;strong&gt;auto_increment_increment &lt;/strong&gt;&lt;/span&gt;为步长，找出第一个大于当前自增值的值作为新的自增值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果插入的数据的 id 字段指定了具体的值，就直接使用语句里的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一些场景下，使用的就不全是默认值。比如，双 M 的主备结构里要求双写的时候，我们就可能会设置成 auto_increment_increment=2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;自增值的修改&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设某次要输入的值是 X，当前的自增值是 Y。那么：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果 X&amp;lt;Y，那么这个表的自增值不变；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果 X≥Y，那么就把当前自增值修改为新的自增值。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;执行过程&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设有表 t ，id 是自增主键，在已有 (1,1,1)的情况下，插入一条 (null,1,1)，那么执行过程就如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、将传入的行的值改成 (2,1,1);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、将表的自增值改成 3；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、继续执行插入数据操作，由于已经存在 c=1 的记录，所以报 Duplicate key error，语句返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210204212039493-854717011.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;407&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;带来的问题&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于上面说得这种特性，在一些场景中会出现主键不连续的现象。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;场景1：添加数据时唯一索引重复&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210203225124029-1401174352.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;384&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 c 列索引重复后，原本要分配的主键值 2 就会被丢弃，而下次再次插入就从 2 开始计算，也就变成了 3。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;场景2：事务回滚&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;begin&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;rollback&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;插入的行是(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在第二条语句回滚后分配给其的主键 2 也会被丢弃。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;场景3：特殊批插入优化导致&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这里说得特殊的批插入指的是  insert … select、replace … select 和 load data 语句&lt;/strong&gt;&lt;/span&gt;。为什么说这些语句可能会导致？这就要说到自增锁了。首先自增锁是为了避免多线程冲突，因为在多线程下，如果同时有多个线程来获取自增值，那么就可能会导致同一个自增值被分配给多条记录，导致逐渐冲突。所以需要自增锁，而为什么前面说得这些批插入语句会导致主键不连续，在下面自增锁部分会说到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在说自增锁之前，先思考一个问题，为什么对于前两个场景，不把自增主键值设为可以回滚的？这样不就可以避免不连续了么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：因为设计成可回滚的会导致性能下降，看下面这个场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、事务 B 正确提交了，但事务 A 出现了唯一键冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而为了解决上面这个问题，就需要从下面两个方法中选一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一、每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法二：把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，综合来看，比如取消自增值回滚的功能。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;自增锁&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;自增锁是为了避免在多线程中多个线程获取到同一个主键值，导致主键冲突。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;加锁策略&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;5.0 版本&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;范围是语句，只有等到语句执行完后才会释放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1.22开始&lt;/strong&gt;&lt;span&gt;：引入了一个 innodb_autoinc_lock_mode 参数，根据参数值的不同执行不同的策略。默认是1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、参数等于0，表示采用之前的策略，即语句执行结束就会释放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、参数等于1，对于普通 insert 语句，自增锁在申请之后立马释放；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　对于 insert...select 这样的批量插入数据的语句，会等到语句执行完才会释放。加锁范围是 select 所涉及到的范围和间隙。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、参数等于3，所有的申请自增主键的动作都是申请后就释放锁。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;为什么默认情况下， insert...select 这样的批操作要使用语句级的锁？为什么参数默认不是2？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：因为对于 insert...select 这样的批量插入数据的语句，可能会导致主从不一致的情况发生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210204203413787-1416586902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 sessionB 执行完 &quot;create table t2 like t&quot; 后，sessionA 和 sessionB 同时操作 t2。如果没有锁，那么执行过程就可能会出现下面的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;session B 先插入了两个记录，(1,1,1)、(2,2,2)；然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这样看起来确实没有什么问题，但是如果是在集群中，主机这样执行，提示 binlog 是 statement 格式的，那么从机执行的顺序就有可能和主机不一致，最终导致主从不一致。所以需要在批量插入时加锁。而如果设置为2，那么如果 binlog 不是 row，就会导致主从数据不一致。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以，要想保证数据一致，也保证系统的并发性，可以有两种方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案一：将 binlog 格式设为 statement，innodb_autoinc_lock_mode 设为1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方案二：将 binlog 格式设为 row，innodb_autoinc_lock_mode 设为2。一般我们为了保证 MySQL 的高可用，都将 binlog 设为 row，所以一般选择第二种方案。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;批插入的优化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在批插入时，由于不知道一次性插入的语句有多少，如果记录多达几千万甚至上亿条，那么每次插入都需要分配一次自增值，这样效率会很慢，所以 MySQL 对批操作进行了优化：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、语句执行过程中，第一次申请自增 id，会分配 1 个；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，执行下面的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t2 &lt;span&gt;like&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t2(c,d) &lt;span&gt;select&lt;/span&gt; c,d &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t2 &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;insert…select，实际上往表 t2 中插入了 4 行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了 id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7 就被浪费掉了。之后，再执行 insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。这就是前面说到主键不连续的第三种情况。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;insert...select 前后操作同一个表会用到临时表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设有表结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `c` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `d` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`),
  &lt;/span&gt;&lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `c` (`c`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;InnoDB;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t2 &lt;span&gt;like&lt;/span&gt; t
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果执行的语句是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t2(c,d)  (&lt;span&gt;select&lt;/span&gt; c&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, d &lt;span&gt;from&lt;/span&gt; t force &lt;span&gt;index&lt;/span&gt;(c) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt; limit &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们查询慢日志，会发现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210204222547635-734711765.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;62&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描行数是1，也就是直接在 t 上通过索引找到那一条记录，然后插入 t2 表。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果将这条语句改成&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t(c,d)  (&lt;span&gt;select&lt;/span&gt; c&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, d &lt;span&gt;from&lt;/span&gt; t force &lt;span&gt;index&lt;/span&gt;(c) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt; limit &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么此时查看慢日志就会发现变成了 5，这是为什么？就算全查出来也只会是4条，这时我们查看扫描行数的变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210204222922666-1534344824.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;271&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现前后变化是4行，所以确定了是使用了临时表，那么就可以确定过程是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、创建临时表，表里有两个字段 c 和 d。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于为什么需要临时表，这是为了防止在读取时，读到了刚刚插入的值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为select 返回的记录数较少，所以可以使用内存临时表来优化， &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;temporary&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; temp_t(c &lt;span&gt;int&lt;/span&gt;,d &lt;span&gt;int&lt;/span&gt;) engine&lt;span&gt;=&lt;/span&gt;&lt;span&gt;memory;
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; temp_t  (&lt;span&gt;select&lt;/span&gt; c&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, d &lt;span&gt;from&lt;/span&gt; t force &lt;span&gt;index&lt;/span&gt;(c) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; c &lt;span&gt;desc&lt;/span&gt; limit &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; temp_t;
&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; temp_t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样扫描的总行数只有 select 的 1 加上临时表上的 1。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;最后&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于唯一索引的冲突，可以使用 insert into … on duplicate key update 来进行冲突后的更新处理，假设表 t 中有(1,1,1)、(2,2,2) 两条记录，那么执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202102/2012006-20210204224732040-820725177.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;163&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在插入时发现冲突就对冲突的记录进行修改操作。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Feb 2021 15:05:00 +0000</pubDate>
<dc:creator>萌新J</dc:creator>
<og:description>MySQL&amp;#160;的主键可以是自增的，那么如果在断电重启后新增的值还会延续断电前的自增值吗？自增值默认为1，那么可不可以改变呢？下面就说一下 MySQL&amp;#160;的自增值。 特点 保存策略 1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxinJ/p/14352038.html</dc:identifier>
</item>
</channel>
</rss>