<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>记一个有意思的面试题 → 线程交替输出问题 - 青石路</title>
<link>http://www.cnblogs.com/youzhibing/p/14399143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youzhibing/p/14399143.html</guid>
<description>&lt;h2&gt;开心一刻&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212195209395-156251746.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大年初一，一起嗨起来！！！&lt;/p&gt;
&lt;p&gt;　　强调一句很重要的心里话：&lt;span&gt;&lt;strong&gt;祝大家在 2021 年，健康好运，平安幸福！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;问题描述&lt;/h2&gt;
&lt;p&gt;　　用两个线程，一个输出数字，一个输出字母，交替输出 1A2B3C4D...26Z&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212204421654-2074734113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该如何实现？&lt;/p&gt;
&lt;h2&gt;解决方式&lt;/h2&gt;
&lt;p&gt;　　据说解决方式有上百种，但有些是脱了裤子放屁，有些是民间偏方，所以没必要全部都知道（其实楼主也不知道具体是哪一百多种）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212202417873-1931312895.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　掌握常用的那几个就好；为了方便，我们就以 &lt;span class=&quot;cnblogs_code&quot;&gt;1234567&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;ABCDEFG&lt;/span&gt; 为例进行演示&lt;/p&gt;
&lt;h3&gt;　　synchronized + wait + notify&lt;/h3&gt;
&lt;p&gt;　　如果我们对 &lt;span class=&quot;cnblogs_code&quot;&gt;JUC&lt;/span&gt; 不熟的话，那这种方式往往是我们最容易想到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212214406833-1912420845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式，相信大家都能写出来，但是这里留三个问题（面试点）&lt;/p&gt;
&lt;p&gt;　　1、线程代码中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;try&lt;/span&gt;&lt;/span&gt; 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;notify()&lt;/span&gt; 能否与 &lt;span class=&quot;cnblogs_code&quot;&gt;wait()&lt;/span&gt; 交换位置，为什么&lt;/p&gt;
&lt;p&gt;　　2、线程代码中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;for&lt;/span&gt;&lt;/span&gt; 下的 &lt;span class=&quot;cnblogs_code&quot;&gt;notify()&lt;/span&gt; 能否去掉，为什么&lt;/p&gt;
&lt;p&gt;　　3、上面的代码能否保证一定先输出数字，为什么，如何保证一定先输出数字&lt;/p&gt;
&lt;h3&gt;　　ReentrantLock + Condition + await + signal&lt;/h3&gt;
&lt;p&gt;　　很多场景下，用 &lt;span class=&quot;cnblogs_code&quot;&gt;ReentrantLock&lt;/span&gt; 可以替代 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;/span&gt; ，而在交叉输出这个场景中，同样可以替代&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212214500518-1716437283.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式，写出来应该也不难，同样留三个问题（面试点）&lt;/p&gt;
&lt;p&gt;　　1、线程代码中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;for&lt;/span&gt;&lt;/span&gt; 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;signal()&lt;/span&gt; 能否与 &lt;span class=&quot;cnblogs_code&quot;&gt;await()&lt;/span&gt; 交换位置，为什么&lt;/p&gt;
&lt;p&gt;　　2、线程代码中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;for&lt;/span&gt;&lt;/span&gt; 下的 &lt;span class=&quot;cnblogs_code&quot;&gt;signal()&lt;/span&gt; 能否去掉，为什么&lt;/p&gt;
&lt;p&gt;　　3、上面的代码能否保证一定先输出数字，为什么，如何保证一定先输出数字&lt;/p&gt;
&lt;h3&gt;　　LockSupport + park + unpark&lt;/h3&gt;
&lt;p&gt;　　估计很多人都没想到这种方式，直接上代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212221121740-1509885230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这是目前最优的解决方式&lt;/span&gt;，照样留四个问题（面试点）&lt;/p&gt;
&lt;p&gt;　　1、 &lt;span class=&quot;cnblogs_code&quot;&gt;t1.start()&lt;/span&gt; 能否与 &lt;span class=&quot;cnblogs_code&quot;&gt;t2.start()&lt;/span&gt; 交换位置，为什么&lt;/p&gt;
&lt;p&gt;　　2、线程 t1 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;LockSupport.unpark(t2)&lt;/span&gt; 在线程 t2 中的 &lt;span class=&quot;cnblogs_code&quot;&gt;LockSupport.park()&lt;/span&gt; 之前执行会怎么样，为什么&lt;/p&gt;
&lt;p&gt;　　3、上面的代码能否保证一定先输出数字，为什么&lt;/p&gt;
&lt;p&gt;　　4、 &lt;span class=&quot;cnblogs_code&quot;&gt;LockSupport&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;park&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;unpark&lt;/span&gt; 与  &lt;span class=&quot;cnblogs_code&quot;&gt;Object&lt;/span&gt; 的 &lt;span class=&quot;cnblogs_code&quot;&gt;wait&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;notify&lt;/span&gt; 有什么异同&lt;/p&gt;
&lt;h3&gt;　　CAS&lt;/h3&gt;
&lt;p&gt;　　这种方式可能也比较难想到，直接上代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212223601032-1591655450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式也许不太好理解，留四个问题（面试点）加深理解&lt;/p&gt;
&lt;p&gt;　　1、线程代码中， &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;while&lt;/span&gt;&lt;/span&gt; 条件为什么是 !=，而不是 ==&lt;/p&gt;
&lt;p&gt;　　2、上面的代码能否保证一定先输出数字，为什么&lt;/p&gt;
&lt;p&gt;　　3、CAS 的优缺点是什么，适用于什么场景&lt;/p&gt;
&lt;h3&gt;　　CAS + AtomicInteger&lt;/h3&gt;
&lt;p&gt;　　其实就是 CAS 的一个变种，直接上代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212224912007-56594203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　CAS + AtomicReference&lt;/h3&gt;
&lt;p&gt;　　也是 CAS 的一个变种，直接上代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212225013803-149556791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　TransferQueue&lt;/h3&gt;
&lt;p&gt;　　一般很难想象到这种方式，但却是很有趣的一种实现方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212230315410-44307806.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果不了解 &lt;span class=&quot;cnblogs_code&quot;&gt;TransferQueue&lt;/span&gt; ，那这种方式就想不到；同样留一个问题（面试点）&lt;/p&gt;
&lt;p&gt;　　1、上面的代码能否保证一定先输出数字，为什么&lt;/p&gt;
&lt;h3&gt;　　BlockingQueue&lt;/h3&gt;
&lt;p&gt;　　一般也比较难想到这种方式，有所了解就好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212231550451-2087607603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　PipedStream&lt;/h3&gt;
&lt;p&gt;　　效率很低，知道有这么回事就好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/747662/202102/747662-20210212231823396-832801264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　1、示例代码地址：&lt;a href=&quot;https://gitee.com/youzhibing/juc-demo&quot; target=&quot;_blank&quot;&gt;juc-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　2、需要掌握的实现方式&lt;/p&gt;
&lt;p&gt;　　　　synchronized、ReentrantLock、LockSupport、CAS、TransferQueue 这几种实现方式必须掌握&lt;/p&gt;
&lt;p&gt;　　　　其他的了解就好&lt;/p&gt;
&lt;p&gt;　　3、如何保证一定先输出数字&lt;/p&gt;
&lt;p&gt;　　　　上面介绍的那些方式中，有些是不能保证一定先输出数字的，而有些是能保证一定先输出数字的&lt;/p&gt;
&lt;p&gt;　　　　不能保证先输出数字的，可以用 &lt;span class=&quot;cnblogs_code&quot;&gt;CountDownLatch&lt;/span&gt; 来控制，是一种比较理想的做法&lt;/p&gt;
</description>
<pubDate>Sat, 13 Feb 2021 00:17:00 +0000</pubDate>
<dc:creator>青石路</dc:creator>
<og:description>开心一刻 大年初一，一起嗨起来！！！ 强调一句很重要的心里话：祝大家在 2021 年，健康好运，平安幸福！ 问题描述 用两个线程，一个输出数字，一个输出字母，交替输出 1A2B3C4D...26Z 该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youzhibing/p/14399143.html</dc:identifier>
</item>
<item>
<title>【原创】Linux虚拟化KVM-Qemu分析（九）之virtio设备 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/14399642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/14399642.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;KVM版本：5.9.1&lt;/li&gt;
&lt;li&gt;QEMU版本：5.0.0&lt;/li&gt;
&lt;li&gt;工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;li&gt;文章同步在博客园：&lt;code&gt;https://www.cnblogs.com/LoyenWang/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;新的一年， 大家牛起来！&lt;br/&gt;祝小姐姐们：&lt;br/&gt;落雁沉鱼 兰质蕙心 明眸皓齿 螓首蛾眉 天生丽质 天香国色 杏脸桃腮 煦色韶光 涎玉沫珠 宜嗔宜喜 远山芙蓉 艳色绝世 余霞成绮 阿娇金屋 逞娇呈美 国色天香 花颜月貌 绝色佳人 暗香盈袖 闭月羞花 倾国倾城 温婉娴淑 千娇百媚 仪态万千...&lt;/p&gt;
&lt;p&gt;祝男的：&lt;br/&gt;新年好。&lt;/p&gt;

&lt;p&gt;先来张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002146556-1295538181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图中罗列了四个关键模块：&lt;code&gt;Virtio Device&lt;/code&gt;、&lt;code&gt;Virtio Driver&lt;/code&gt;、&lt;code&gt;Virtqueue&lt;/code&gt;、&lt;code&gt;Notification（eventfd/irqfd）&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Virtio Driver&lt;/code&gt;：前端部分，处理用户请求，并将I/O请求转移到后端；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Virtio Device&lt;/code&gt;：后端部分，由Qemu来实现，接收前端的I/O请求，并通过物理设备进行I/O操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Virtqueue&lt;/code&gt;：中间层部分，用于数据的传输；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Notification&lt;/code&gt;：交互方式，用于异步事件的通知；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt;想在一篇文章中写完这四个模块，有点&lt;code&gt;too yong too simple&lt;/code&gt;，所以，看起来又是一个系列文章了。&lt;br/&gt;本文先从Qemu侧的virtio device入手，我会选择从一个实际的设备来阐述，没错，还是上篇文章中提到的网络设备。&lt;/p&gt;

&lt;p&gt;在Qemu的网卡虚拟化时，通常会创建一个虚拟网卡前端和虚拟网卡后端，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002157164-967550439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在虚拟机创建的时候指定参数：&lt;code&gt;-netdev tap, id = tap0， -device virtio-net-pci, netdev=tap0&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;创建一个&lt;code&gt;Tap&lt;/code&gt;网卡后端设备；&lt;/li&gt;
&lt;li&gt;创建一个&lt;code&gt;Virtio-Net&lt;/code&gt;网卡前端设备；&lt;/li&gt;
&lt;li&gt;网卡前端设备和后端设备进行交互，最终与Host的驱动完成数据的收发；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;全文围绕着&lt;code&gt;Tap&lt;/code&gt;设备的创建和&lt;code&gt;Virtio-Net&lt;/code&gt;设备的创建展开。&lt;/p&gt;
&lt;p&gt;入口流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002204631-1421245348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qemu的代码阅读起来还是比较费劲的，各种盘根错节，里边充斥着面向对象的思想，先给自己挖个坑，后续会专题研究的，&lt;code&gt;this is for you, you have my words.&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;图中与本文相关的有三个模块：1）模块初始化；2）网络设备初始化；3）设备初始化；
&lt;ol&gt;&lt;li&gt;Qemu中设备模拟通过&lt;code&gt;type_init&lt;/code&gt;先编译进系统，在&lt;code&gt;module_call_init&lt;/code&gt;时进行回调，比如图中的&lt;code&gt;xxx_register_types&lt;/code&gt;，在这些函数中都是根据&lt;code&gt;TypeInfo&lt;/code&gt;类型信息来创建具体的实现信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net_init_client&lt;/code&gt;用来创建网络设备，比如&lt;code&gt;Tap&lt;/code&gt;设备；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device_init_func&lt;/code&gt;根据Qemu命令的传入参数创建虚拟设备，比如&lt;code&gt;Virtio-Net&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下边进入细节，&lt;code&gt;the devil is in the details&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从上文中，我们知道，&lt;code&gt;Tap&lt;/code&gt;与&lt;code&gt;Virtio-Net&lt;/code&gt;属于前后端的关系，最终是通过结构体分别指向对方，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002217998-1655315613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;NetClientState&lt;/code&gt;是网卡模拟的核心结构，表示网络设备中的几个端点，两个端点通过&lt;code&gt;peer&lt;/code&gt;指向对方；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建Tap设备的主要工作就是创建一个&lt;code&gt;NetClientState&lt;/code&gt;结构，并添加到&lt;code&gt;net_clients&lt;/code&gt;链表中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002303803-1084163909.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数的调用细节如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002310283-874984329.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理流程只关注了核心的处理流程，整个过程有很多关于传入参数的处理，选择性忽略了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net_tap_init&lt;/code&gt;：与Host的&lt;code&gt;tun&lt;/code&gt;驱动进行交互，其实质就是打开该设备文件，并进行相应的配置等；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net_tap_fd_init&lt;/code&gt;：根据&lt;code&gt;net_tap_info&lt;/code&gt;结构，创建&lt;code&gt;NetClientState&lt;/code&gt;，并进行相关设置，这里边&lt;code&gt;net_tap_info&lt;/code&gt;结构体中的接收函数指针用于实际的数据传输处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tap_read_poll&lt;/code&gt;用于将fd添加到Qemu的AioContext中，用于异步响应，当有数据来临时，捕获事件并进行处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上就是Tap后端的创建过程，下文将针对前端创建了。&lt;/p&gt;

&lt;p&gt;这是一个复杂的流程。&lt;/p&gt;
&lt;h2 id=&quot;41-数据结构&quot;&gt;4.1 数据结构&lt;/h2&gt;
&lt;p&gt;Qemu中用C语言实现了面向对象的模型，用于对设备进行抽象，精妙！&lt;br/&gt;针对Virtio-Net设备，结构体及拓扑组织关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002318824-1058290140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DeviceState&lt;/code&gt;作为所有设备的父类，其中派生了&lt;code&gt;VirtIODevice&lt;/code&gt;和&lt;code&gt;PCIDevice&lt;/code&gt;，而本文研究的&lt;code&gt;Virtio-Net&lt;/code&gt;派生自&lt;code&gt;VirtIODevice&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Qemu中会虚拟一个PCI总线，同时创建&lt;code&gt;virtio-net-pci&lt;/code&gt;，&lt;code&gt;virtio-balloon-pci&lt;/code&gt;，&lt;code&gt;virtio-scsi-pci&lt;/code&gt;等PCI代理设备，这些代理设备挂载在PCI总线上，同时会创建Virtio总线，用于挂载最终的设备，比如&lt;code&gt;VirtIONet&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;PCI代理设备就是一个纽带；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;42-流程分析&quot;&gt;4.2 流程分析&lt;/h2&gt;
&lt;p&gt;与设备创建相关的三个函数，可以从&lt;code&gt;device_init_func&lt;/code&gt;入口跟踪得知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002328216-1328380691.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当Qemu命令通过&lt;code&gt;-device&lt;/code&gt;传入参数时，&lt;code&gt;device_init_func&lt;/code&gt;会根据参数去查找设备，并最终调用到该设备对应的类初始化函数、对象初始化函数、以及realize函数；&lt;/li&gt;
&lt;li&gt;所以，我们的分析就是这三个入口；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;421-class_init&quot;&gt;4.2.1 class_init&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002339829-618075364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在网卡虚拟化过程中，参数只需要指定PCI代理设备即可，也就是&lt;code&gt;-device virtio-net-pci, netdev=tap0&lt;/code&gt;，从而会调用到&lt;code&gt;virtio_net_pci_class_init&lt;/code&gt;函数；&lt;/li&gt;
&lt;li&gt;由于实现了类的继承关系，在子类初始化之前，需要先调用父类的实现，图中也表明了继承关系以及调用函数顺序；&lt;/li&gt;
&lt;li&gt;C语言实现继承，也就是将父对象放置在自己结构体的开始位置，图中的颜色能看出来；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;422-instance_init&quot;&gt;4.2.2 instance_init&lt;/h3&gt;
&lt;p&gt;类初始化结束后，开始对象的创建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002346674-1999852327.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对&lt;code&gt;Virtio-Net-PCI&lt;/code&gt;的实例化比较简单，作为代理，负责将它的后继对象初始化，也就是本文的前端设备&lt;code&gt;Virtio-Net&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;423-realize&quot;&gt;4.2.3 realize&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002356436-18682170.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;realize&lt;/code&gt;的调用，比较绕，简单来说，它的类继承关系中存在多个&lt;code&gt;realize&lt;/code&gt;的函数指针，最终会从父类开始执行，一直调用到子类，而这些函数指针的初始化在什么时候做的呢？没错，就是在class_init类初始化的时候，进行了赋值，细节不表，结论可靠；&lt;/li&gt;
&lt;li&gt;最终的调用关系就如图了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到目前为止，我们似乎都还没有看到&lt;code&gt;Virtio-Net&lt;/code&gt;设备的相关操作，不用着急，已经很接近真相了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002404478-1016637722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;virtio_net_pci_realize&lt;/code&gt;函数，会触发&lt;code&gt;virtio_device_realize&lt;/code&gt;的调用，该函数是一个通用的virtio设备实现函数，所有的virtio设备都会调用，而我们的前端设备&lt;code&gt;Virtio-Net&lt;/code&gt;也是virtio设备；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtio_net_device_realize&lt;/code&gt;就到了我们的主角了，它进行了virtio通用的设置（后续在数据通信中再分析），还创建了一个&lt;code&gt;NetClientState&lt;/code&gt;端点，与&lt;code&gt;Tap&lt;/code&gt;设备对应，分别指向了对方，惺惺相惜，各自安好；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtio_bus_device_plugged&lt;/code&gt;表示设备插入总线时的处理，完成的工作就是按照PCI总线规划，配置各类信息，以便与Guest OS中的virtio驱动交互，后续的文章再分析了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文基本捋清了虚拟网卡前端设备和后端设备的创建过程，完成的工作只是绑定了彼此，数据交互以及通知机制，留给后续吧。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;《 Virtual I/O Device (VIRTIO) Version 1.1》&lt;/code&gt;&lt;br/&gt;&lt;code&gt;https://www.redhat.com/en/blog/virtio-devices-and-drivers-overview-headjack-and-phone&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注个人公众号，不定期更新技术文章。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202102/1771657-20210213002442969-548664120.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Feb 2021 16:26:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 Read the fucking source code! --By 鲁迅 A picture is worth a thousand words. --By 高尔基 说明： KVM版本：5.9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/14399642.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 25 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14399544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14399544.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;150.88529801325&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot; target=&quot;_blank&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/14322190.html&quot; target=&quot;_blank&quot;&gt;《痞子衡嵌入式半月刊： 第 24 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;立春是上周三的事了，很抱歉推迟了近10天才给大家带来新一期半月刊，大家放心，半月刊有可能会迟，但绝不会缺席。&lt;/p&gt;
&lt;p&gt;今天是牛年大年初一，痞子衡就给大家拜个年吧，祝各位读者在牛年里工作顺利，事业有成，爱情甜蜜，家庭幸福，专业技术突飞猛进，成为行业大牛。&lt;/p&gt;
&lt;p&gt;本期共收录 2条资讯、2个项目、2个工具，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;1、瑞萨电子推出arm-cortex-mcu产品家族全新ra4m2-mcu产品群，扩展在低功耗工业与物联网应用中的覆盖范围&quot;&gt;&lt;span&gt;1、瑞萨电子推出Arm Cortex MCU产品家族全新RA4M2 MCU产品群，扩展在低功耗工业与物联网应用中的覆盖范围&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;0.62686567164179&quot;&gt;
&lt;p&gt;产品主页: &lt;a href=&quot;https://www2.renesas.cn/ra4m2?utm_campaign=mcu_ra4m2&amp;amp;utm_source=press_release&amp;amp;utm_medium=press_release&amp;amp;utm_content=ra4m2&quot; target=&quot;_blank&quot;&gt;https://www2.renesas.cn/ra4m2?utm_campaign=mcu_ra4m2&amp;amp;utm_source=press_release&amp;amp;utm_medium=press_release&amp;amp;utm_content=ra4m2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;近日， 瑞萨电子宣布推出12款全新RA4M2微控制器（MCU）产品，以扩展其RA4系列MCU阵容。新产品将超低功耗、高性能和增强的安全性充分结合，使其成为工业与物联网应用的理想解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/RA4M2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RA4M2 MCU产品群的关键特性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;- 提供运行模式下80μA/MHz的超低功耗，唤醒时间为30μs
- 采用100MHz主频Arm Cortex-M33内核，支持TrustZone技术
- 包含瑞萨安全加密引擎的完整安全解决方案
- 提供48-100引脚LQFP封装，以及48引脚QFN封装
- 集成512KB、384KB或256KB闪存，128K SRAM
- 电容式触摸感应单元
- 全速USB 2.0
- 高级模拟功能，支持一路ADC
- QuadSPI
- SDHI
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RA4M2 MCU采用基于Armv8-M架构的Arm® Cortex®-M33内核，集成Arm TrustZone®技术和瑞萨安全加密引擎。安全加密引擎包含多个对称和非对称加密加速器、高级密钥管理、安全的生命周期管理、抵抗功率分析攻击和篡改检测功能。这一组合使客户能够实现安全芯片功能，让物联网边缘设备等低功耗应用获得安全保障。&lt;/p&gt;
&lt;h3 id=&quot;2、瑞萨正式收购dialog，为车用芯片业务市场积极布局&quot;&gt;&lt;span&gt;2、瑞萨正式收购Dialog，为车用芯片业务市场积极布局&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;2月8日，据瑞萨电子最新公告宣布，瑞萨与电源管理提供商Dialog已就以每股67.50欧元全现金方式收购Dialog全部已发行股本和将要发行股本的条款达成协议，总股权价值约为49亿欧元（约合59亿美元）。收购完成后，Dialog将成为瑞萨电子的全资子公司，这为瑞萨在车用芯片市场的竞争注入新的活力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Dialog_Renesas.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.61643835616438&quot;&gt;
&lt;p&gt;芯片主页：&lt;a href=&quot;https://www.dialog-semiconductor.com/press-releases/renesas-and-dialog-semiconductor-join-forces-advance-global-leadership-embedded&quot; target=&quot;_blank&quot;&gt;https://www.dialog-semiconductor.com/press-releases/renesas-and-dialog-semiconductor-join-forces-advance-global-leadership-embedded&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管2021年汽车芯片市场供不应求，但并不妨碍半导体巨头收购动作频现。瑞萨电子在汽车微控制器领域拥有约30%的全球市场份额，车用芯片约占其营收的一半。Dialog以其低功耗和混合信号专业技术为核心，拥有非常广泛且丰富的产品系列，包括电池和电源管理、电源转换、CMIC、LED驱动器、ASIC、无线充电技术等，是高集成度和高能效混合信号IC的重要供应商，为物联网、消费电子产品以及汽车和工业终端市场的高增长细分市场中的众多客户提供服务。两家公司技术资产的互补性和产品组合的规模将使瑞萨电子能够构建更强大、更全面的解决方案，以服务于物联网和汽车市场等高增长细分市场。&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;1、key_board---用于单片机中的小巧多功能按键支持库&quot;&gt;&lt;span&gt;1、key_board - 用于单片机中的小巧多功能按键支持库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;key_board 是网友 wei513723 维护的用于单片机中的小巧多功能按键支持库。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3725490196078&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://gitee.com/wei513723/key_board&quot; target=&quot;_blank&quot;&gt;https://gitee.com/wei513723/key_board&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件采用了分层的思想，并且做到了与平台无关，用户只需要提供按键的基本信息和读写io电平的函数即可，非常方便移植，同时支持多个矩阵键盘及多个单io控制键盘，目前已实现按下触发、弹起触发、长按自动触发、长按弹起触发、多击触发、连续触发等功能，并且能够随意组合（支持状态的同一时间轴和非同一时间轴），后续还会添加更多的功能。&lt;/p&gt;
&lt;h3 id=&quot;2、watch-x---一款功能丰富的智能手表&quot;&gt;&lt;span&gt;2、WATCH-X - 一款功能丰富的智能手表&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;WATCH-X是一款基于LittleVGL的开源智能手表项目, 能够支持高质量流畅(60FPS+)的动画效果的显示，炫酷的界面加上易于扩展的系统框架，非常容易上手，下面是WATCH-X展示的部分功能UI界面。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5&quot;&gt;
&lt;p&gt;工具主页：&lt;a href=&quot;https://github.com/FASTSHIFT/WatchX&quot; target=&quot;_blank&quot;&gt;https://github.com/FASTSHIFT/WatchX&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Watch-X.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WATCH-X能够支持功能主要有9大类，分别是时间显示，温度显示，气压显示，海拔显示，秒表，亮度控制，时间控制，简易游戏系统，自动关机等。为支持这些功能需求，硬件系统如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;* 1.主控: STM32F411CEU6 (主频:100MHz RAM:128KB ROM:512KB)
* 2.屏幕: ST7789 IPS 1.14inch SPI接口 135x240分辨率 100Hz刷新率
* 3.输入设备: 按键x3
* 4.RTC:MCU内置RTC时钟
* 5.加速度计:MPU6050
* 6.气压计:BMP180
* 7.电源管理:TP4056 + TPS63070
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该手表项目还提供了详细的硬件原理图设计文件和PCB设计文件作为参考，轻松就能玩转起来！&lt;/p&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;1、sqlite---强大的适用于多平台的sql数据库引擎&quot;&gt;&lt;span&gt;1、SQLite - 强大的适用于多平台的SQL数据库引擎&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;SQLite是世界上部署最广泛的数据库，它是一种C语言库，它实现了一个小型，快速，自包含，高可靠性，功能齐全的SQL数据库引擎。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4893617021277&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://www.sqlite.org/index.html&quot; target=&quot;_blank&quot;&gt;https://www.sqlite.org/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/SQLite.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SQLite是嵌入式SQL数据库引擎。与大多数其他SQL数据库不同，SQLite没有单独的服务器进程。SQLite直接读取和写入普通磁盘文件。数据库文件格式是跨平台的，用户可以在32位和64位系统之间或在big-endian和 little-endian 体系结构之间自由复制数据库 。这些功能使SQLite成为应用程序文件格式的流行选择。&lt;/p&gt;
&lt;p&gt;SQLite是一个紧凑的库。启用所有功能后，库大小可以小于600KB，具体取决于目标平台和编译器优化设置。在内存使用和速度之间需要权衡。SQLite通常为您提供的内存越多，运行速度就越快。但是，即使在低内存环境下，性能通常也相当不错。根据使用方式，SQLite可以比直接文件系统I/O更快。&lt;/p&gt;
&lt;h3 id=&quot;2、sqlcipher---适用于本地数据存储的更加安全的sqlite&quot;&gt;&lt;span&gt;2、sqlcipher - 适用于本地数据存储的更加安全的SQLite&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;SQLCipher扩展了SQLite项目，以添加安全性增强功能，使其更适合于加密的本地数据存储，例如：动态加密，篡改检测，内存清理，强密钥派生等。SQLCipher基于SQLite，并且稳定地集成了稳定的上游发行功能。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3461538461538&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/sqlcipher/sqlcipher&quot; target=&quot;_blank&quot;&gt;https://github.com/sqlcipher/sqlcipher&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQLCipher具有如下的功能特点：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;- 高性能，许多操作的加密开销仅为5-15％
- 数据库文件的100%加密
- 良好的安全模式（CBC模式，HMAC，密钥派生）
- 零配置和应用级加密
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SQLCipher也与标准SQLite数据库兼容。如果未提供密钥，则SQLCipher的行为将与标准SQLite库类似。使用ATTACH和sqlcipher_export（）便捷函数，也可以从纯文本数据库（标准SQLite）转换为加密的SQLCipher数据库。&lt;/p&gt;
&lt;p&gt;感兴趣的嵌入式er可以去尝试在自己的设备上使用sqlcipher 及SQLite。&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot; target=&quot;_blank&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot; target=&quot;_blank&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot; target=&quot;_blank&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot; target=&quot;_blank&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 12 Feb 2021 15:11:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14399544.html</dc:identifier>
</item>
<item>
<title>Seq2Seq原理详解 - 早起的小虫子</title>
<link>http://www.cnblogs.com/liuxiaochong/p/14399416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxiaochong/p/14399416.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　seq2seq 是一个Encoder–Decoder 结构的网络，它的输入是一个序列，输出也是一个序列。Encoder 中将一个可变长度的信号序列变为固定长度的向量表达，Decoder 将这个固定长度的向量变成可变长度的目标的信号序列。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　很多自然语言处理任务，比如聊天机器人，机器翻译，自动文摘，智能问答等，传统的解决方案都是检索式(从候选集中选出答案)，这对素材的完善程度要求很高。seq2seq模型突破了传统的固定大小输入问题框架。采用序列到序列的模型，在NLP中是文本到文本的映射。其在各主流语言之间的相互翻译以及语音助手中人机短问快答的应用中有着非常好的表现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、编码解码模型&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;　　1、模型框架&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　在NLP任务中，其实输入的是文本序列，输出的很多时候也是文本序列，下图所示的是一个典型的机器翻译任务中，输入的文本序列(源语言表述)到输出的文本序列(目标语言表述)之间的变换。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019101722582171.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　2、编码解码器结构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　（1）编码器处理输入序列中的每个元素(在这里可能是1个词)，将捕获的信息编译成向量（称为上下文内容向量）。在处理整个输入序列之后，编码器将上下文发送到解码器，解码器逐项开始产生输出序列。如，机器翻译任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017230042619.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）上下文向量&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;输入的数据(文本序列)中的每个元素(词)通常会被编码成一个稠密的向量，这个过程叫做word embedding&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;经过循环神经网络（RNN），将最后一层的隐层输出作为上下文向量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;encoder和decoder都会借助于循环神经网络(RNN)这类特殊的神经网络完成，循环神经网络会接受每个位置(时间点)上的输入，同时经过处理进行信息融合，并可能会在某些位置(时间点)上输出。如下图所示。&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017230539925.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;动态地展示整个编码器和解码器，分拆的步骤过程：&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017230552106.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;更详细地展开，其实是这样的：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017231103862.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;三、加入attention注意力机制的Seq2Seq&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;　　1、为什么加入attention机制：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　提升效果，不会寄希望于把所有的内容都放到一个上下文向量(context vector)中，而是会采用一个叫做注意力模型的模型来动态处理和解码，动态的图如下所示。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017231444122.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　所谓的注意力机制，可以粗略地理解为是一种对于输入的信息，根据重要程度进行不同权重的加权处理(通常加权的权重来源于softmax后的结果)的机制，如下图所示，是一个在解码阶段，简单地对编码器中的hidden states进行不同权重的加权处理的过程。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　2、attention机制结构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017231657773.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　3、加入attention机制的Seq2Seq原理&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;带注意力的解码器RNN接收的嵌入(embedding)和一个初始的解码器隐藏状态(hidden state)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RNN处理输入，产生输出和新的隐藏状态向量（h4），输出被摒弃不用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;attention的步骤：使用编码器隐藏状态(hidden state)和h4向量来计算该时间步长的上下文向量（C4）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;把h4和C4拼接成一个向量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;把拼接后的向量连接全连接层和softmax完成解码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个时间点上重复这个操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232637302.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　也可以把这个动态解码的过程展示成下述图所示的过程。&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232738123.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、图解Attention Seq2Seq&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;输入：$x = (x_1,...,x_{T_x})$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出：$y = (y_1,...,y_{T_y})$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、$h_t = RNN_{enc}(x_t, h_{t-1})$，Encoder方面接受的每一个单词word embedding，和上一个时间点的hidden state。输出的是这个时间点的hidden state。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、$s_t = RNN_{dec}(\hat{y_{t-1}},s_{t-1})$，Decoder方面接受的是目标句子里单词的word embedding，和上一个时间点的hidden state。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、$c_i = \sum_{j=1}^{T_x} \alpha_{ij}h_j$，context vector是一个对于encoder输出的hidden states的一个加权平均。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、$\alpha_{ij} = \frac{exp(e_{ij})}{\sum_{k=1}^{T_x}exp(e_{ik})}$，每一个encoder的hidden states对应的权重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、$e_{ij} = score(s_i, h_j)$，通过decoder的hidden states加上encoder的hidden states来计算一个分数，用于计算权重(4)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、$\hat{s_t} = tanh(W_c[c_t;s_t])$，将context vector 和 decoder的hidden states 串起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、$p(y_t|y_{&amp;lt;t},x) = softmax(W_s\hat{s_t})$，计算最后的输出概率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017231905806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)$h_t = RNN_{enc}(x_t, h_{t-1})$，Encoder方面接受的是每一个单词word embedding，和上一个时间点的hidden state。输出的是这个时间点的hidden state。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017231905806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)$s_t = RNN_{dec}(\hat{y_{t-1}},s_{t-1})$，Decoder方面接受的是目标句子里单词的word embedding，和上一个时间点的hidden state。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232001369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3)、$c_i = \sum_{j=1}^{T_x} \alpha_{ij}h_j$，context vector是一个对于encoder输出的hidden states的一个加权平均。&lt;/p&gt;
&lt;p&gt;(4)、$\alpha_{ij} = \frac{exp(e_{ij})}{\sum_{k=1}^{T_x}exp(e_{ik})}$，每一个encoder的hidden states对应的权重。&lt;/p&gt;
&lt;p&gt;(5)、$e_{ij} = score(s_i, h_j)$，通过decoder的hidden states加上encoder的hidden states来计算一个分数，用于计算权重(4)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232024224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一个时间点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232024224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(6)$\hat{s_t} = tanh(W_c[c_t;s_t])$，将context vector 和 decoder的hidden states 串起来。&lt;/p&gt;
&lt;p&gt;(7)$p(y_t|y_{&amp;lt;t},x) = softmax(W_s\hat{s_t})$，计算最后的输出概率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232024224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;五、三种Attention得分计算方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在luong中提到了三种score的计算方法。这里图解前两种：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232222918.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;　　1、方法一&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　输入是encoder的所有hidden states H: 大小为(hid dim, sequence length)。decoder在一个时间点上的hidden state， s： 大小为（hid dim, 1）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（1）旋转H为（sequence length, hid dim) 与s做点乘得到一个 大小为(sequence length, 1)的分数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）对分数做softmax得到一个合为1的权重。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（3）将H与第二步得到的权重做点乘得到一个大小为(hid dim, 1)的context vector。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019101723232551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;　　2、方法二&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　输入是encoder的所有hidden states H: 大小为(hid dim1, sequence length)。decoder在一个时间点上的hidden state， s： 大小为（hid dim2, 1）。此处两个hidden state的纬度并不一样。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（1）旋转H为（sequence length, hid dim1) 与 Wa [大小为 hid dim1, hid dim 2)] 做点乘， 再和s做点乘得到一个 大小为(sequence length, 1)的分数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）对分数做softmax得到一个合为1的权重。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（3）将H与第二步得到的权重做点乘得到一个大小为(hid dim, 1)的context vector。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191017232337734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM4ODY3OQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Feb 2021 15:10:00 +0000</pubDate>
<dc:creator>早起的小虫子</dc:creator>
<og:description>一、Seq2Seq简介 seq2seq 是一个Encoder–Decoder 结构的网络，它的输入是一个序列，输出也是一个序列。Encoder 中将一个可变长度的信号序列变为固定长度的向量表达，Dec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuxiaochong/p/14399416.html</dc:identifier>
</item>
<item>
<title>大数据开发-从cogroup的实现来看join是宽依赖还是窄依赖 - Hoult丶吴邪</title>
<link>http://www.cnblogs.com/hulichao/p/14399398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hulichao/p/14399398.html</guid>
<description>&lt;p&gt;前面一篇文章提到大数据开发-Spark Join原理详解,本文从源码角度来看cogroup 的join实现&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-Scala&quot;&gt;import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}
object JoinDemo {
  def main(args: Array[String]): Unit = {
    val conf = new SparkConf().setAppName(this.getClass.getCanonicalName.init).setMaster(&quot;local[*]&quot;) 
    val sc = new SparkContext(conf)
    sc.setLogLevel(&quot;WARN&quot;)
    
    val random = scala.util.Random
    val col1 = Range(1, 50).map(idx =&amp;gt; (random.nextInt(10), s&quot;user$idx&quot;))
    val col2 = Array((0, &quot;BJ&quot;), (1, &quot;SH&quot;), (2, &quot;GZ&quot;), (3, &quot;SZ&quot;), (4, &quot;TJ&quot;), (5, &quot;CQ&quot;), (6, &quot;HZ&quot;), (7, &quot;NJ&quot;), (8, &quot;WH&quot;), (0, &quot;CD&quot;))
    val rdd1: RDD[(Int, String)] = sc.makeRDD(col1) 
    val rdd2: RDD[(Int, String)] = sc.makeRDD(col2)
    val rdd3: RDD[(Int, (String, String))] = rdd1.join(rdd2) 
    println(rdd3.dependencies)
    val rdd4: RDD[(Int, (String, String))] = rdd1.partitionBy(new HashPartitioner(3)).join(rdd2.partitionBy(new HashPartitioner(3)))
    println(rdd4.dependencies)
    sc.stop() 
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析上面一段代码，打印结果是什么，这种join是宽依赖还是窄依赖，为什么是这样&lt;/p&gt;

&lt;p&gt;关于stage划分和宽依赖窄依赖的关系，从2.1.3 如何区别宽依赖和窄依赖就知道stage与宽依赖对应，所以从rdd3和rdd4的stage的依赖图就可以区别宽依赖，可以看到join划分除了新的stage，所以rdd3的生成事宽依赖，另外&lt;code&gt;rdd1.partitionBy(new HashPartitioner(3)).join(rdd2.partitionBy(new HashPartitioner(3)))&lt;/code&gt; 是另外的依赖图，所以可以看到partitionBy以后再没有划分新的 stage，所以是窄依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://jeff.sp!%5Bfile%5D(http://jeff.spring4all.com/FhBTWpUB7pu_DyRGp4VZ9IMKx1MW)ring4all.com/Ft9l6DJcMGv4Z_pGWtxmnN9FSv6f&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://www.cnblogs.com/hulichao/p/14399398.html&quot; alt=&quot;Uploading file...&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前面知道结论，是从ui图里面看到的，现在看join源码是如何实现的（基于spark2.4.5）&lt;/p&gt;
&lt;p&gt;先进去入口方法，其中withScope的做法可以理解为装饰器，为了在sparkUI中能展示更多的信息。所以把所有创建的RDD的方法都包裹起来，同时用RDDOperationScope 记录 RDD 的操作历史和关联，就能达成目标。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Scala&quot;&gt;  /**
   * Return an RDD containing all pairs of elements with matching keys in `this` and `other`. Each
   * pair of elements will be returned as a (k, (v1, v2)) tuple, where (k, v1) is in `this` and
   * (k, v2) is in `other`. Performs a hash join across the cluster.
   */
  def join[W](other: RDD[(K, W)]): RDD[(K, (V, W))] = self.withScope {
    join(other, defaultPartitioner(self, other))
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来看&lt;code&gt;defaultPartitioner&lt;/code&gt; 的实现，其目的就是在默认值和分区器之间取一个较大的，返回分区器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Scala&quot;&gt;def defaultPartitioner(rdd: RDD[_], others: RDD[_]*): Partitioner = {
    val rdds = (Seq(rdd) ++ others)
    // 判断有没有设置分区器partitioner
    val hasPartitioner = rdds.filter(_.partitioner.exists(_.numPartitions &amp;gt; 0))
    
    //如果设置了partitioner，则取设置partitioner的最大分区数
    val hasMaxPartitioner: Option[RDD[_]] = if (hasPartitioner.nonEmpty) {
      Some(hasPartitioner.maxBy(_.partitions.length))
    } else {
      None
    }
 
    //判断是否设置了spark.default.parallelism，如果设置了则取spark.default.parallelism
    val defaultNumPartitions = if (rdd.context.conf.contains(&quot;spark.default.parallelism&quot;)) {
      rdd.context.defaultParallelism
    } else {
      rdds.map(_.partitions.length).max
    }
 
    // If the existing max partitioner is an eligible one, or its partitions number is larger
    // than the default number of partitions, use the existing partitioner.
    //主要判断传入rdd是否设置了默认的partitioner 以及设置的partitioner是否合法                
    //或者设置的partitioner分区数大于默认的分区数 
    //条件成立则取传入rdd最大的分区数，否则取默认的分区数
    if (hasMaxPartitioner.nonEmpty &amp;amp;&amp;amp; (isEligiblePartitioner(hasMaxPartitioner.get, rdds) ||
        defaultNumPartitions &amp;lt; hasMaxPartitioner.get.getNumPartitions)) {
      hasMaxPartitioner.get.partitioner.get
    } else {
      new HashPartitioner(defaultNumPartitions)
    }
  }

  private def isEligiblePartitioner(
     hasMaxPartitioner: RDD[_],
     rdds: Seq[RDD[_]]): Boolean = {
    val maxPartitions = rdds.map(_.partitions.length).max
    log10(maxPartitions) - log10(hasMaxPartitioner.getNumPartitions) &amp;lt; 1
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进入join的重载方法，里面有个&lt;code&gt;new CoGroupedRDD[K](Seq(self, other), partitioner)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Scala&quot;&gt;def join[W](other: RDD[(K, W)], partitioner: Partitioner): RDD[(K, (V, W))] = self.withScope {
    this.cogroup(other, partitioner).flatMapValues( pair =&amp;gt;
      for (v &amp;lt;- pair._1.iterator; w &amp;lt;- pair._2.iterator) yield (v, w)
    )
  }
def cogroup[W](other: RDD[(K, W)], partitioner: Partitioner)
    : RDD[(K, (Iterable[V], Iterable[W]))] = self.withScope {
  if (partitioner.isInstanceOf[HashPartitioner] &amp;amp;&amp;amp; keyClass.isArray) {
    throw new SparkException(&quot;HashPartitioner cannot partition array keys.&quot;)
  }
  //partitioner 通过对比得到的默认分区器，主要是分区器中的分区数
  val cg = new CoGroupedRDD[K](Seq(self, other), partitioner)
  cg.mapValues { case Array(vs, w1s) =&amp;gt;
    (vs.asInstanceOf[Iterable[V]], w1s.asInstanceOf[Iterable[W]])
  }
}


  /**
   * Return an RDD containing all pairs of elements with matching keys in `this` and `other`. Each
   * pair of elements will be returned as a (k, (v1, v2)) tuple, where (k, v1) is in `this` and
   * (k, v2) is in `other`. Performs a hash join across the cluster.
   */
  def join[W](other: RDD[(K, W)], numPartitions: Int): RDD[(K, (V, W))] = self.withScope {
    join(other, new HashPartitioner(numPartitions))
  } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后来看CoGroupedRDD，这是决定是宽依赖还是窄依赖的地方，可以看到如果左边rdd的分区和上面选择给定的分区器一致，则认为是窄依赖，否则是宽依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Scala&quot;&gt;  override def getDependencies: Seq[Dependency[_]] = {
    rdds.map { rdd: RDD[_] =&amp;gt;
      if (rdd.partitioner == Some(part)) {
        logDebug(&quot;Adding one-to-one dependency with &quot; + rdd)
        new OneToOneDependency(rdd)
      } else {
        logDebug(&quot;Adding shuffle dependency with &quot; + rdd)
        new ShuffleDependency[K, Any, CoGroupCombiner](
          rdd.asInstanceOf[RDD[_ &amp;lt;: Product2[K, _]]], part, serializer)
      }
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结，join时候可以指定分区数，如果join操作左右的rdd的&lt;strong&gt;分区方式和分区数一致&lt;/strong&gt;则不会产生shuffle，否则就会shuffle，而是宽依赖，分区方式和分区数的体现就是分区器。&lt;br/&gt;吴邪，小三爷，混迹于后台，大数据，人工智能领域的小菜鸟。&lt;br/&gt;更多请关注&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/669466/202102/669466-20210212214841280-1408744536.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Feb 2021 13:49:00 +0000</pubDate>
<dc:creator>Hoult丶吴邪</dc:creator>
<og:description>前面一篇文章提到大数据开发-Spark Join原理详解,本文从源码角度来看cogroup 的join实现 1.分析下面的代码 import org.apache.spark.rdd.RDD impo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hulichao/p/14399398.html</dc:identifier>
</item>
<item>
<title>Vue单页面应用中的Markdown渲染 - YouXam</title>
<link>http://www.cnblogs.com/youxam/p/vue-markdown-render.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxam/p/vue-markdown-render.html</guid>
<description>&lt;p&gt;之前渲染 Markdown 的时候, 笔者使用的是 &lt;a href=&quot;https://github.com/hinesboy/mavonEditor&quot; target=&quot;_blank&quot;&gt;mavonEditor&lt;/a&gt; 的预览模式, 使用起来比较爽, 只需要引入组件即可, 但是在最近的开发中, 遇到了困难.&lt;/p&gt;
&lt;p&gt;主要问题在于作为单页面应用, 站内链接必须是使用 &lt;code&gt;router-link&lt;/code&gt; 跳转, 如果使用 mavonEditor 默认渲染的 &lt;code&gt;a&lt;/code&gt; 标签, 就会重新加载页面, 用户体验较差.&lt;/p&gt;
&lt;h2 id=&quot;动态渲染&quot;&gt;动态渲染&lt;/h2&gt;
&lt;p&gt;想要实现在前端动态地根据用户内容渲染&lt;code&gt;router-link&lt;/code&gt; , 需要使用动态渲染, 根据 &lt;a href=&quot;https://cli.vuejs.org/config/#runtimecompiler&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;, 直接修改&lt;code&gt;vue.config.js&lt;/code&gt; 即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// vue.config.js
module.exports = {
  runtimeCompiler: true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;渲染-markdown&quot;&gt;渲染 Markdown&lt;/h2&gt;
&lt;p&gt;笔者使用的是 &lt;a href=&quot;https://github.com/markdown-it/markdown-it&quot; target=&quot;_blank&quot;&gt;markdown-it&lt;/a&gt;, 配置过程如下:&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;npm install markdown-it --save # 本体
npm install markdown-it-highlightjs --save # 代码高亮
npm install markdown-it-katex --save # latex 支持
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里还另外安装了两个语法插件, 如果有其他需要的话, 可以在 &lt;a href=&quot;https://www.npmjs.com/search?q=keywords:markdown-it-plugin&quot; target=&quot;_blank&quot;&gt;npm&lt;/a&gt; 上搜索&lt;/p&gt;
&lt;h3 id=&quot;静态文件导入&quot;&gt;静态文件导入&lt;/h3&gt;
&lt;h4 id=&quot;highlightjs&quot;&gt;highlight.js&lt;/h4&gt;
&lt;p&gt;通过 cdn 导入, 在 &lt;code&gt;index.html&lt;/code&gt; 中加入:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/default.min.css&quot;&amp;gt;
&amp;lt;script src=&quot;//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;github-markdown-css&quot;&gt;github-markdown-css&lt;/h4&gt;
&lt;p&gt;markdown 的样式&lt;/p&gt;
&lt;h5 id=&quot;安装-1&quot;&gt;安装&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;npm install github-markdown-css --save
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;导入&quot;&gt;导入&lt;/h5&gt;
&lt;p&gt;在 &lt;code&gt;main.js&lt;/code&gt; 文件中添加&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import 'github-markdown-css/github-markdown.css'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;katex&quot;&gt;katex&lt;/h4&gt;
&lt;p&gt;通过 cdn 导入, 在 &lt;code&gt;index.html&lt;/code&gt; 中加入:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;首先在 &lt;code&gt;components&lt;/code&gt; 目录下创建 &lt;code&gt;Markdown.vue&lt;/code&gt; 文件,&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;components :is=&quot;html&quot; class=&quot;markdown-body&quot;&amp;gt;&amp;lt;/components&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import MarkdownIt from 'markdown-it'
import hljs from 'markdown-it-highlightjs'
import latex from 'markdown-it-katex'
export default {
  name: 'Markdown',
  props: {
    content: String
  },
  data: () =&amp;gt; ({
    md: null
  }),
  computed: {
    // 使用 computed 才能在动态绑定时动态更新
    html: function () {
      let res = this.md.render(this.content)
      // 使用正则表达式将站内链接替换为 router-link 标签
      res = res.replace(/&amp;lt;a href=&quot;(?!http:\/\/|https:\/\/)(.*?)&quot;&amp;gt;(.*?)&amp;lt;\/a&amp;gt;/g, '&amp;lt;router-link to=&quot;$1&quot;&amp;gt;$2&amp;lt;/router-link&amp;gt;')
      // 使用正则表达式将站外链接在新窗口中打开
      res = res.replace(/&amp;lt;a href=&quot;(.*?)&quot;&amp;gt;(.*?)&amp;lt;\/a&amp;gt;/g, '&amp;lt;a href=&quot;$1&quot; target=&quot;_blank&quot;&amp;gt;$2&amp;lt;/a&amp;gt;')
      return {
        template: '&amp;lt;div&amp;gt;' + res + '&amp;lt;/div&amp;gt;'
      }
    }
  },
  created () {
    this.md = new MarkdownIt()
    this.md.use(hljs).use(latex)
  }
}
&amp;lt;/script&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在想使用的地方导入即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;Markdown :content=&quot;content&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import Markdown from '@/components/Markdown.vue'
export default {
  name: 'Home',
  components: {
    Markdown
  },
  data: () =&amp;gt; ({
    content: ''
  }),
  created () {
    this.content = '# 测试'
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://cli.vuejs.org/config/#runtimecompiler&quot; target=&quot;_blank&quot;&gt;https://cli.vuejs.org/config/#runtimecompiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/markdown-it/markdown-it&quot; target=&quot;_blank&quot;&gt;https://github.com/markdown-it/markdown-it&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sindresorhus/github-markdown-css&quot; target=&quot;_blank&quot;&gt;https://github.com/sindresorhus/github-markdown-css&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/markdown-it-highlightjs&quot; target=&quot;_blank&quot;&gt;https://www.npmjs.com/package/markdown-it-highlightjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/waylonflinn/markdown-it-katex&quot; target=&quot;_blank&quot;&gt;https://github.com/waylonflinn/markdown-it-katex&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 12 Feb 2021 13:16:00 +0000</pubDate>
<dc:creator>YouXam</dc:creator>
<og:description>之前渲染 Markdown 的时候, 笔者使用的是 mavonEditor 的预览模式, 使用起来比较爽, 只需要引入组件即可, 但是在最近的开发中, 遇到了困难. 主要问题在于作为单页面应用, 站内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youxam/p/vue-markdown-render.html</dc:identifier>
</item>
<item>
<title>超详细 DNS 协议解析 - 飞天小牛肉</title>
<link>http://www.cnblogs.com/cswiki/p/14388862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cswiki/p/14388862.html</guid>
<description>&lt;p&gt;为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;231.75883702588&quot;&gt;
&lt;blockquote readability=&quot;8.8461538461538&quot;&gt;
&lt;p&gt;🎓 尽人事，听天命。博主东南大学研究生在读，热爱健身和篮球，正在为两年后的秋招准备中，乐于分享技术相关的所见所得，关注公众号 @ &lt;strong&gt;飞天小牛肉&lt;/strong&gt;，第一时间获取文章更新，成长的路上我们一起进步&lt;/p&gt;
&lt;p&gt;🎁 本文已收录于 &lt;a href=&quot;https://gitee.com/veal98/CS-Wiki&quot; target=&quot;_blank&quot;&gt;CS-Wiki（Gitee 官方推荐项目，现已 0.9k star)&lt;/a&gt;，致力打造完善的后端知识体系，在技术的路上少走弯路，欢迎各位小伙伴前来交流学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120124147.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是-dns-协议&quot;&gt;1. 什么是 DNS 协议&lt;/h2&gt;
&lt;p&gt;在学习 DNS 协议之前，我们先区分一下域名和 IP 地址这个两个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;IP 地址&lt;/strong&gt;：一长串能够唯一地标记网络上的计算机的数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;域名&lt;/strong&gt;：又称网域，是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）比如 &lt;code&gt;www.baidu.com&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不知道有没有同学会混淆域名和&lt;strong&gt;网址&lt;/strong&gt;的概念，可以这样理解，网址里面含有域名。举个例子：&lt;code&gt;www.gitee.com/veal98&lt;/code&gt; 就是一个网址，而 &lt;code&gt;www.gitee.com&lt;/code&gt; 就是域名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;u&gt;由于 IP 地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点&lt;/u&gt;，人们设计出了域名，并&lt;strong&gt;通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射&lt;/strong&gt;，使人更方便地访问互联网，而不用去记住能够被机器直接读取的 IP 地址数串。将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;💡 DNS 协议可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。但&lt;strong&gt;大多数情况下 DNS 都使用 UDP 进行传输&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-域名详解&quot;&gt;2. 域名详解&lt;/h2&gt;
&lt;p&gt;❓ 那么域名由谁来规定和管理呢？不能是随便写吧？&lt;/p&gt;
&lt;p&gt;全世界域名的最高管理机构，是一个叫做 ICANN （Internet Corporation for Assigned Names and Numbers）的组织，总部在美国加州。&lt;strong&gt;ICANN 负责管理全世界域名系统的运作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210119205250.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;域名其实是具有一定的层次结构的，从上到下依次为：&lt;strong&gt;根域名&lt;/strong&gt;、&lt;strong&gt;顶级域名&lt;/strong&gt;（top level domain，TLD）、&lt;strong&gt;二级域名&lt;/strong&gt;、（三级域名）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210119205159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;①-顶级域名&quot;&gt;① 顶级域名&lt;/h3&gt;
&lt;p&gt;先来讲讲&lt;strong&gt;顶级域名&lt;/strong&gt;（TLD），即最高层级的域名。简单说，就是网址的最后一个部分。比如，网址&lt;code&gt;www.baidu.com&lt;/code&gt; 的顶级域名就是 &lt;code&gt;.com&lt;/code&gt;。ICANN 的一项主要工作，就是规定哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个，它们大致可以分成两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一类是&lt;strong&gt;通用顶级域名&lt;/strong&gt;（gTLD），比如&lt;code&gt;.com&lt;/code&gt;、&lt;code&gt;.net&lt;/code&gt;、&lt;code&gt;.edu&lt;/code&gt;、&lt;code&gt;.org&lt;/code&gt;、&lt;code&gt;.xxx&lt;/code&gt;等等，共有 700 多个。&lt;/li&gt;
&lt;li&gt;另一类是&lt;strong&gt;国家顶级域名&lt;/strong&gt;（ccTLD），代表不同的国家和地区，比如&lt;code&gt;.cn&lt;/code&gt;（中国）、&lt;code&gt;.io&lt;/code&gt;（英属印度洋领地）、&lt;code&gt;.cc&lt;/code&gt;（ 科科斯群岛）、&lt;code&gt;.tv&lt;/code&gt;（图瓦卢）等，共有 300 多个。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有1000多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。ICANN 的政策是，每个顶级域名都找一个&lt;strong&gt;托管商&lt;/strong&gt;，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，&lt;code&gt;.cn&lt;/code&gt; 国家顶级域名的托管商就是中国互联网络信息中心（CNNIC），它决定了 &lt;code&gt;.cn&lt;/code&gt; 域名的各种政策。&lt;/p&gt;
&lt;h3 id=&quot;②-二级域名&quot;&gt;② 二级域名&lt;/h3&gt;
&lt;p&gt;而&lt;strong&gt;二级域名&lt;/strong&gt;(Second Level Domain,SLD) 在通用顶级域名或国家顶级域名之下具有不同的意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用顶级域名下的二级域名：一般是指域名注册人选择使用的网上名称，如 &lt;code&gt;yahoo.com&lt;/code&gt;（商业组织通常使用自己的商标、商号或其他商业标志作为自己的网上名称，如 &lt;code&gt;baidu.com&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;国家顶级域名下的二级域名：一般是指类似于通用顶级域名的表示注册人类别和功能的标志。例如，在 &lt;code&gt;.com.cn&lt;/code&gt; 域名结构中，&lt;code&gt;.com&lt;/code&gt; 此时是置于国家顶级域名 &lt;code&gt;.cn&lt;/code&gt; 下的二级域名，表示中国的商业性组织，以此类推。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三级域名&lt;/strong&gt;是形如 &lt;code&gt;www.baidu.com&lt;/code&gt; 的域名，可以当做是二级域名的子域名，特征为域名包含两个 &lt;code&gt;.&lt;/code&gt;。对于域名所有者/使用者而言，三级域名都是二级域名的附属物而无需单独费用。&lt;strong&gt;三级域名甚至不能称为域名，一般称之为域名下的 “二级目录”&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;③-根域名&quot;&gt;③ 根域名&lt;/h3&gt;
&lt;p&gt;❓ 那么&lt;strong&gt;根域名&lt;/strong&gt;在哪里呢？在层次结构中根域名不是最顶级的吗？域名中怎么没有看见它？&lt;/p&gt;
&lt;p&gt;由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，&lt;code&gt;www.xxx.com&lt;/code&gt; 被写成 &lt;code&gt;www.xxx.com.&lt;/code&gt;，即最后还会多出一个点。这个点就是根域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120105950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理论上，&lt;strong&gt;所有域名的查询都必须先查询根域名&lt;/strong&gt;，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，&lt;strong&gt;ICANN 维护着一张列表（根域名列表），里面记载着顶级域名和对应的托管商&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210119214844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如，我要访问&lt;code&gt;abc.xyz&lt;/code&gt;，也必须先去询问根域名列表，它会告诉我 &lt;code&gt;.xyz&lt;/code&gt; 域名由 CentralNic 公司托管。根域名列表还记载，&lt;code&gt;.google&lt;/code&gt;由谷歌公司托管，&lt;code&gt;.apple&lt;/code&gt;由苹果公司托管等等。&lt;/p&gt;
&lt;p&gt;由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。&lt;/p&gt;
&lt;h2 id=&quot;3-域名服务器详解&quot;&gt;3. 域名服务器详解&lt;/h2&gt;
&lt;p&gt;域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作 &lt;strong&gt;区 (ZONE)&lt;/strong&gt;。域名的每层都设有一个域名服务器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根域名服务器&lt;/li&gt;
&lt;li&gt;顶级域名服务器&lt;/li&gt;
&lt;li&gt;权限域名服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面这幅图就很直观了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120111157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，即&lt;strong&gt;本地域名服务器&lt;/strong&gt;。下面我们分别讲解这四种服务器都是用来干什么的 👇&lt;/p&gt;
&lt;h3 id=&quot;①-根域名服务器&quot;&gt;① 根域名服务器&lt;/h3&gt;
&lt;p&gt;上面我们提到，ICANN 维护着一张根域名列表，里面记载着顶级域名和对应的托管商，其实根域名列表的正式名称是 &lt;strong&gt;DNS 根区&lt;/strong&gt;（DNS root zone），&lt;u&gt;保存 DNS 根区文件的服务器&lt;/u&gt;，就叫做 &lt;strong&gt;DNS 根域名服务器&lt;/strong&gt;（root name server）。根域名服务器&lt;strong&gt;保存所有的顶级域名服务器的地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从 &lt;code&gt;a.root-servers.net&lt;/code&gt; 一直到 &lt;code&gt;m.root-servers.net&lt;/code&gt;。其中 10 台设置在美国，另外各有一台设置于荷兰、瑞典和日本。&lt;/p&gt;
&lt;p&gt;前面我们说过，理论上&lt;strong&gt;所有域名的查询都必须先查询根域名&lt;/strong&gt;，所以一般来说所有的域名服务器都会注册一份根域名服务器的 IP 地址的缓存，用于在必要的时候向其发送请求。&lt;/p&gt;
&lt;h3 id=&quot;②-顶级域名服务器&quot;&gt;② 顶级域名服务器&lt;/h3&gt;
&lt;p&gt;按照根域名服务器管理顶级域名的逻辑，顶级域名服务器显然就是用来&lt;strong&gt;管理注册在该顶级域名下的所有二级域名&lt;/strong&gt;的，&lt;strong&gt;记录这些二级域名的 IP 地址&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;③-权限域名服务器&quot;&gt;③ 权限域名服务器&lt;/h3&gt;
&lt;p&gt;按照上面的逻辑，权限域名服务器应该是管理注册在二级域名下的所有三/四级域名的，但其实不是这样，如果一个二级域名或者一个三/四级域名对应一个域名服务器，则域名服务器数量会很多，我们需要使用&lt;strong&gt;划分区&lt;/strong&gt;的办法来解决这个问题。那么权限域名服务器就是负责管理一个“&lt;strong&gt;区&lt;/strong&gt;”的域名服务器。&lt;/p&gt;
&lt;p&gt;❓ 什么是区？怎样划分区呢？&lt;/p&gt;
&lt;p&gt;区和域其实是不同的，区可以有多种不同的划分方法。以百度为例，我们假设有 &lt;code&gt;fanyi.baidu.com&lt;/code&gt;、&lt;code&gt;ai.baidu.com&lt;/code&gt;、&lt;code&gt;tieba.baidu.com&lt;/code&gt; 这三个三级域名。我们可以这样分区，&lt;code&gt;fanyi.baidu.com&lt;/code&gt; 和 &lt;code&gt;tieba.baidu.com&lt;/code&gt; 放在 &lt;code&gt;baidu.com&lt;/code&gt; 权限域名服务器，&lt;code&gt;ai.baidu.com&lt;/code&gt; 放在 &lt;code&gt;ai.baidu.com&lt;/code&gt; 权限域名服务器中。并且 &lt;code&gt;baidu.com&lt;/code&gt; 权限域名服务器和 &lt;code&gt;ai.baidu.com&lt;/code&gt; 权限域名服务器是&lt;strong&gt;同等地位&lt;/strong&gt;的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。&lt;/p&gt;
&lt;p&gt;画个图直观理解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120114419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;④-本地域名服务器&quot;&gt;④ 本地域名服务器&lt;/h3&gt;
&lt;p&gt;除了上面三种 DNS 服务器，还有一种不在 DNS 层次结构之中，但是很重要的 DNS 服务器，就是&lt;strong&gt;本地域名服务器&lt;/strong&gt;（也被称为&lt;strong&gt;权威域名服务器&lt;/strong&gt;）。本地域名服务器是电脑解析时的&lt;strong&gt;默认&lt;/strong&gt;域名服务器，即电脑中设置的首选 DNS 服务器和备选 DNS 服务器。常见的有电信、联通、谷歌、阿里等的本地 DNS 服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120121349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个因特网服务提供者或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。&lt;strong&gt;当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器&lt;/strong&gt;。&lt;strong&gt;本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么具体本地域名服务器是如何向上级域名服务器转发查询请求的呢？&lt;/p&gt;
&lt;h2 id=&quot;4-dns-查询方式&quot;&gt;4. DNS 查询方式&lt;/h2&gt;
&lt;p&gt;具体 DNS 查询的方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;递归查询&lt;/li&gt;
&lt;li&gt;迭代查询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所谓迭代就是，如果请求的接收者不知道所请求的内容，那么&lt;strong&gt;接收者将扮演请求者&lt;/strong&gt;，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。&lt;/p&gt;
&lt;p&gt;👍 通俗点来说，在递归查询中，如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案；而迭代查询则是指，如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;strong&gt;域名服务器之间的查询使用迭代查询方式，以免根域名服务器的压力过大&lt;/strong&gt;。通过下面这两个图就能很好的理解了 👇&lt;/p&gt;
&lt;p&gt;1）递归查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210119232409.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）迭代查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210119232744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-域名缓存&quot;&gt;5. 域名缓存&lt;/h2&gt;
&lt;p&gt;上面讲解的是域名服务器之间的 DNS 查询请求过程，但实际上，每个时刻都有无数网民要上网，那每次都去访问本地域名服务器去获取 IP 地址显然是不实际的。解决方法就是&lt;strong&gt;使用缓存保存域名和 IP 地址的映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;浏览器缓存&lt;/strong&gt;：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;操作系统缓存&lt;/strong&gt;：操作系统的缓存其实是用户自己配置的 hosts 文件。比如 Windows10 下的 hosts 文件存放在 C:\Windows\System32\drivers\etc\hosts&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120115853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows 系统默认开启 DNS 缓存服务，服务名是 &lt;code&gt;DNSClient&lt;/code&gt;，可以缓存一些常用的域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120120035.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用命令 &lt;code&gt;ipconfig/displaydns&lt;/code&gt; 可以查看电脑中缓存的域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120120212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⭐ 在浏览器中进行访问的时候，会优先查询浏览器缓存，如果未命中则继续查询操作系统缓存，最后再查询本地域名服务器，然后本地域名服务器会递归的查找域名记录，最后返回结果。&lt;strong&gt;主机和本地域名服务器之间的查询方式是递归查询&lt;/strong&gt;，也就是说主机请求本地域名服务器，那么本地域名服务器作为请求的接收者一定要给主机想要的答案。&lt;/p&gt;
&lt;h2 id=&quot;6-完整域名解析过程&quot;&gt;6. 完整域名解析过程&lt;/h2&gt;
&lt;p&gt;OK，将我们上面所说的域名服务器之间的 DNS 查询请求过程和域名缓存结合起来，就是一个完整的 DNS 协议进行域名解析的过程。这里我们以正向解析为例（域名解析成 IP 地址）：&lt;/p&gt;
&lt;p&gt;1）首先搜索&lt;strong&gt;浏览器的 DNS 缓存&lt;/strong&gt;，缓存中维护一张域名与 IP 地址的对应表；&lt;/p&gt;
&lt;p&gt;2）若没有命中，则继续搜索&lt;strong&gt;操作系统的 DNS 缓存&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;3）若仍然没有命中，则操作系统将域名发送至&lt;strong&gt;本地域名服务器&lt;/strong&gt;，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是&lt;strong&gt;递归查询&lt;/strong&gt;）；&lt;/p&gt;
&lt;p&gt;4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行&lt;strong&gt;迭代查询&lt;/strong&gt;（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先本地域名服务器向&lt;strong&gt;根域名服务器&lt;/strong&gt;发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案&lt;/li&gt;
&lt;li&gt;本地域名服务器拿到这个&lt;strong&gt;顶级域名服务器&lt;/strong&gt;的地址后，就向其发起请求，获取&lt;strong&gt;权限域名服务器&lt;/strong&gt;的地址&lt;/li&gt;
&lt;li&gt;本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来&lt;/p&gt;
&lt;p&gt;5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来&lt;/p&gt;
&lt;p&gt;6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来&lt;/p&gt;
&lt;p&gt;配合下图直观理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/veal98/images/raw/master/img/20210120123619.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-关注公众号--飞天小牛肉，即时获取更新&quot;&gt;🎉 关注公众号 | 飞天小牛肉，即时获取更新&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;博主东南大学研究生在读，利用课余时间运营一个&lt;strong&gt;公众号『 飞天小牛肉 』&lt;/strong&gt;，2020/12/29 日第一次开通，专注分享计算机基础（数据结构 + 算法 + 计算机网络 + 数据库 + 操作系统 + Linux）、Java 基础和面试指南的相关原创技术好文。本公众号的目的就是&lt;strong&gt;让大家可以快速掌握重点知识，有的放矢&lt;/strong&gt;。希望大家多多支持哦，和小牛肉一起成长 😃&lt;/li&gt;
&lt;li&gt;并推荐个人维护的开源教程类项目： &lt;a href=&quot;https://gitee.com/veal98/CS-Wiki&quot; target=&quot;_blank&quot;&gt;CS-Wiki（Gitee 推荐项目，现已 0.9k star）&lt;/a&gt;, 致力打造完善的后端知识体系，在技术的路上少走弯路，欢迎各位小伙伴前来交流学习 ~ 😊&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Fri, 12 Feb 2021 12:51:00 +0000</pubDate>
<dc:creator>飞天小牛肉</dc:creator>
<og:description>为了保证网址的正常访问，域名解析协议（DNS）其实在背后做出了很多努力，本文将透彻讲解 DNS 协议的原理，了解我们每天都在接触的网址到底是怎么工作的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cswiki/p/14388862.html</dc:identifier>
</item>
<item>
<title>.NET中使用DebuggerDisplay轻松定制调试 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/14399282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/14399282.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;对于调试的方式有多种，不过在今天我们将看到的监视窗口对变量的监视，当然在这里我们是定制内部的变量值，或者说变量的显示与计算的内容。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：监视窗口在调试时可以一次显示多个变量。“快速监视”对话框一次显示一个变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-3f415a62-862d-4134-8889-41d261affbd3.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;debuggerdisplayattribute&quot;&gt;DebuggerDisplayAttribute&lt;/h2&gt;
&lt;p&gt;在下面示例中，我们在类上添加&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debuggerdisplayattribute?view=net-5.0&amp;amp;WT.mc_id=DT-MVP-5003855&quot; target=&quot;_blank&quot;&gt;DebuggerDisplay&lt;/a&gt;，添加字符串：(&quot;Name={Name},Age={Age}&quot;)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; class Program
    {
        static void Main(string[] args)
        {
            Student student = new Student()
            {
                Name = &quot;Mr.A&quot;,
                Age = 18
            };

            Console.WriteLine(&quot;Hello World!&quot;);
        }

        [DebuggerDisplay(&quot;Name={Name},Age={Age}&quot;)]
        class Student
        {
            public int Age { get; set; }

            public string Name { get; set; }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图，在调试模式下，我们可以将鼠标箭头放到变量上去，从而看到变量的值，也可以看到我们定义好的字符串内容格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-44159cbf-9599-4693-a4e0-ca2d707263c7.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进一步来看一下，我们定义一个属性，将属性的内容呈现出来，代码片段如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        [DebuggerDisplay(&quot;{DebuggerDisplay,nq}&quot;)]
        public struct Point
        {
            public int X { get; }
            public int Y { get; }

            public Point(int x, int y)
            {
                X = x;
                Y = y;
            }
            private string DebuggerDisplay =&amp;gt; $&quot;{X},{Y}&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于结果已经呈现出来了，我们可以看到我们在&lt;code&gt;DebuggerDisplay&lt;/code&gt;属性中定义的内容，同时我们看的是没有引号，是的，这一点很重要，对于&lt;code&gt;nq&lt;/code&gt;的话他主要删除引号，因为我们在这里采用的是字符串，所以可通过&lt;code&gt;nq&lt;/code&gt;进行引号的删除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-8c00086e-d4b1-4fa4-bb31-fea2c58bdaa0.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;debuggerbrowsableattribute&quot;&gt;DebuggerBrowsableAttribute&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;DebuggerBrowsableAttribute&lt;/code&gt;特性来说的话，他应用于属性字段，可控制它们的显示方式，通过枚举类型&lt;code&gt;DebuggerBrowsableState&lt;/code&gt;来控制字段属性的显示行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[DebuggerBrowsable(DebuggerBrowsableState.Never)]
public static string y = &quot;Test String&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DebuggerBrowsableState&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Never 可隐藏字段属性&lt;/li&gt;
&lt;li&gt;Collapsed 默认选项，显示成员信息&lt;/li&gt;
&lt;li&gt;RootHidden 不显示字段，如果是数组或者集合将以成对的对象形式显示&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;debuggertypeproxyattribute&quot;&gt;DebuggerTypeProxyAttribute&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DebuggerTypeProxyAttribute&lt;/code&gt;属性用于指定代理类型显示，它允许我们为类型定制视图，如果找到这个属性，则表达式评估其将显示代理类型替换为该属性所应用的类型，这其实对我们来公开原始类型以外的属性很有用。下面我们看一下代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [DebuggerTypeProxy(typeof(SampleDebugView))]
    public class Sample
    {
        public string Name { get; set; }

        private class SampleDebugView
        {
            private readonly Sample _sample;

            public SampleDebugView(Sample sample)
            {
                _sample = sample;
            }

            public string Name =&amp;gt; _sample.Name;
            public int NameLength =&amp;gt; _sample.Name.Length;

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public char[] NameCharacters =&amp;gt; _sample.Name.ToCharArray();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到下图，我们通过代理视图的方式将我们的信息都展开，这样更方便我们对信息的调试显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-e9c21de9-3e83-4ca9-8515-7f31b885a018.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.debuggerbrowsableattribute?WT.mc_id=DT-MVP-5003855&amp;amp;view=net-5.0&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.debuggerbrowsableattribute&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Feb 2021 12:48:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>前言 对于调试的方式有多种，不过在今天我们将看到的监视窗口对变量的监视，当然在这里我们是定制内部的变量值，或者说变量的显示与计算的内容。 注：监视窗口在调试时可以一次显示多个变量。“快速监视”对话框一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/14399282.html</dc:identifier>
</item>
<item>
<title>Python优化机制：常量折叠 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/14399239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/14399239.html</guid>
<description>&lt;p&gt;英文：&lt;a href=&quot;https://arpitbhayani.me/blogs/constant-folding-python&quot; target=&quot;_blank&quot;&gt;https://arpitbhayani.me/blogs/constant-folding-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：arprit&lt;/p&gt;
&lt;p&gt;译者：豌豆花下猫（“Python猫”公众号作者）&lt;/p&gt;
&lt;p&gt;声明：本翻译是出于交流学习的目的，基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 授权协议。为便于阅读，内容略有改动。&lt;/p&gt;
&lt;p&gt;每种编程语言为了表现出色，并且实现卓越的性能，都需要大量编译器级的优化。&lt;/p&gt;
&lt;p&gt;一种著名的优化技术是“&lt;code&gt;常量折叠&lt;/code&gt;”（Constant Folding）：在编译期间，编译器会设法识别出常量表达式，对其进行求值，然后用求值的结果来替换表达式，从而使得运行时更精简。&lt;/p&gt;
&lt;p&gt;在本文中，&lt;strong&gt;我们深入探讨了什么是常量折叠，了解了它在 Python 世界中的适用范围，最后解读了 Python 的源代码（即 &lt;a href=&quot;https://github.com/python/cpython/&quot; target=&quot;_blank&quot;&gt;CPython&lt;/a&gt;），并分析出 Python 是如何优雅地实现它。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;常量折叠&quot;&gt;常量折叠&lt;/h2&gt;
&lt;p&gt;所谓常量折叠，指的是&lt;strong&gt;在编译时&lt;/strong&gt;就查找并计算常量表达式，而不是&lt;strong&gt;在运行时&lt;/strong&gt;再对其进行计算，从而会使运行时更加精简和快速。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; day_sec = 24 * 60 * 60
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当编译器遇到一个常量表达式时，如上所述，它将对表达式求值，并作替换。&lt;/p&gt;
&lt;p&gt;通常而言，表达式会被“&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot; target=&quot;_blank&quot;&gt;抽象语法树&lt;/a&gt;”（ Abstract Syntax Tree，简写为 AST）中的计算值所替换，但是这完全取决于语言的实现。&lt;/p&gt;
&lt;p&gt;因此，上述表达式可以等效地被执行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; day_sec = 86400
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-中的常量折叠&quot;&gt;Python 中的常量折叠&lt;/h2&gt;
&lt;p&gt;在 Python 中，我们可以使用&lt;code&gt;反汇编模块&lt;/code&gt;（Disassembler）获取 CPython 字节码，从而更好地了解代码执行的过程。&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;dis&lt;/code&gt;模块反汇编上述常量表达式时，我们会得到以下字节码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import dis
&amp;gt;&amp;gt;&amp;gt; dis.dis(&quot;day_sec = 24 * 60 * 60&quot;)

        0 LOAD_CONST               0 (86400)
        2 STORE_NAME               0 (day_sec)
        4 LOAD_CONST               1 (None)
        6 RETURN_VALUE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从字节码中可以看出，它只有一个&lt;code&gt;LOAD_CONST&lt;/code&gt; ，以及一个已经计算好的值&lt;code&gt;86400&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这表明 CPython 解释器在解析和构建抽象语法树期间，会折叠常量表达式 24 * 60 * 60，并将其替换为计算值 86400。&lt;/p&gt;
&lt;h3 id=&quot;常量折叠的适应范围&quot;&gt;常量折叠的适应范围&lt;/h3&gt;
&lt;p&gt;Python 会尝试折叠每一个常量表达式，但在某些情况下，即使该表达式是常量，但是 Python 并不会对其进行折叠。&lt;/p&gt;
&lt;p&gt;例如，Python 不会折叠&lt;code&gt;x = 4 ** 64&lt;/code&gt;，但会折叠 &lt;code&gt;x = 2 ** 64&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1gngh3ig7j1j20me093t8y.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了算术表达式，Python 还会折叠涉及字符串和元组的表达式，其中，长度不超过 4096 的字符串常量表达式会被折叠。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = &quot;-&quot; * 4096   # folded
&amp;gt;&amp;gt;&amp;gt; a = &quot;-&quot; * 4097   # not folded
&amp;gt;&amp;gt;&amp;gt; a = &quot;--&quot; * 4096  # not folded
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常量折叠的内部细节&quot;&gt;常量折叠的内部细节&lt;/h2&gt;
&lt;p&gt;现在，我们将重点转移到内部的实现细节，即关注 CPython 在哪里以及如何实现常量折叠。&lt;/p&gt;
&lt;p&gt;所有的 AST 优化（包括常量折叠）都可以在 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Python/ast_opt.c&quot; target=&quot;_blank&quot;&gt;ast_opt.c&lt;/a&gt; 文件中找到。基本的开始函数是 astfold_expr，它会折叠 Python 源码中包含的所有表达式。&lt;/p&gt;
&lt;p&gt;这个函数以递归方式遍历 AST，并试着折叠每个常量表达式，如下面的代码片段所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1gngh7nspk0j20xc0hgdjo.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;astfold_expr 在折叠某个表达式之前，会尝试折叠其子表达式（操作对象），然后将折叠操作代理给特定的表达式折叠函数。&lt;/p&gt;
&lt;p&gt;特定操作的折叠函数对表达式求值，并返回计算后的常数，然后将其放入 AST 中。&lt;/p&gt;
&lt;p&gt;例如，每当 astfold_expr 遇到二值运算时，它便调用 fold_binop，递归地计算两个子操作对象（表达式） 。&lt;/p&gt;
&lt;p&gt;fold_binop 函数返回计算后的常量值，如下面的代码片段所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1gngh8xy503j20xc0hggp9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;fold_binop 函数通过检查当前运算符的种类，然后调用其相应的处理函数来折叠二值运算。例如，如果当前的操作是加法运算，为了计算最终值，它会对其左侧和右侧操作数调用 PyNumber_Add。&lt;/p&gt;
&lt;h3 id=&quot;怎样优雅？&quot;&gt;怎样优雅？&lt;/h3&gt;
&lt;p&gt;为了有效地折叠某些模式或类型的常量表达式，CPython 不会写特殊的逻辑，而是调用相同的通用代码。例如，在折叠时，它会调用通用的 PyNumber_Add 函数，跟执行常规的加法操作一样。&lt;/p&gt;
&lt;p&gt;因此，CPython 通过确保其通用代码/计算过程可以处理常量表达式的求值，从而消除了编写特殊函数来处理常量折叠的需要。&lt;/p&gt;
&lt;h2 id=&quot;参考材料&quot;&gt;参考材料&lt;/h2&gt;
</description>
<pubDate>Fri, 12 Feb 2021 12:22:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>英文：https://arpitbhayani.me/blogs/constant-folding-python 作者：arprit 译者：豌豆花下猫（“Python猫”公众号作者） 声明：本翻译是出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/14399239.html</dc:identifier>
</item>
<item>
<title>docker的企业级仓库-harbor - 林奋斗的成长之路</title>
<link>http://www.cnblogs.com/lin-strive/p/14398731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lin-strive/p/14398731.html</guid>
<description>&lt;p&gt;Harbor&lt;/p&gt;
&lt;p&gt;一、背景&lt;/p&gt;
&lt;p&gt;Docker中要使用镜像，我们一般都会从本地、Docker Hub公共仓库或者其它第三方的公共仓库中下载镜像，但是出于安全和一些内外网的原因考虑，企业级上不会轻易使用。普通的Docker Registry又不满足需求，所以一般可以利用Harbor搭建一个企业级的私有镜像仓库。&lt;/p&gt;
&lt;p&gt;二、简介&lt;/p&gt;
&lt;p&gt;Harbor是构建企业级私有docker镜像仓库的开源解决方案，它是Docker Registry的更高级封装，它除了提供友好的Web UI界面，角色和用户权限管理，用户操作审计等功能外，它还整合了K8s的插件(Add-ons)仓库，即Helm通过chart方式下载，管理，安装K8s插件，而chartmuseum可以提供存储chart数据的仓库（helm就相当于k8s的yum）。另外它还整合了两个开源的安全组件，一个是Notary，另一个是Clair，Notary类似于私有CA中心，而Clair则是容器安全扫描工具，它通过各大厂商提供的CVE漏洞库来获取最新漏洞信息，并扫描用户上传的容器是否存在已知的漏洞信息，这两个安全功能对于企业级私有仓库来说是非常具有意义的。&lt;/p&gt;
&lt;div readability=&quot;11.941888619855&quot;&gt;
&lt;p&gt;Harbor安装有3种方式：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小&lt;/li&gt;
&lt;li&gt;离线安装：安装包包含部署的相关镜像，因此安装包比较大&lt;/li&gt;
&lt;li&gt;OVA安装程序：当用户具有vCenter环境时，使用此安装程序，在部署OVA后启动Harbor&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;本文记录通过离线安装的方式部署&lt;/p&gt;
&lt;p&gt;前提条件：安装企业仓库不能有registry，否则冲突&lt;/p&gt;
&lt;div readability=&quot;6.9632990522283&quot;&gt;
&lt;p&gt;1、下载一个docker-compse工具&lt;/p&gt;
&lt;div readability=&quot;7.9577493398334&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
离线安装docker-&lt;span&gt;compse工具
[root@docker01 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
docker&lt;/span&gt;-compose.&lt;span&gt;1.25&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz  harbor-offline-installer-v2.&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;.tgz
[root@docker01 &lt;/span&gt;~]# &lt;span&gt;tar&lt;/span&gt;  zxpf docker-compose.&lt;span&gt;1.25&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz  -&lt;span&gt;C 
&lt;/span&gt;/usr/local/bin/&lt;span&gt;
[root@docker01 &lt;/span&gt;~]# cd /usr/local/bin/&lt;span&gt;
[root@docker01 bin]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
docker&lt;/span&gt;-compose-Linux-&lt;span&gt;x86_64
[root@docker01 bin]# &lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; docker-compose-Linux-x86_64  docker-&lt;span&gt;compose
[root@docker01 bin]# &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt;  +x /usr/local/bin/docker-&lt;span&gt;compose 
[root@docker01 bin]# docker&lt;/span&gt;-compose -&lt;span&gt;v
docker&lt;/span&gt;-compose version &lt;span&gt;1.25&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, build 0a186604
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下载依赖包&lt;/span&gt;
[root@docker bin]# &lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt;-utils device-mapper-persistentdata lvm2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、&lt;span&gt;harbor离线模式&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;直接在百度搜 harbor进官网 harbor的部署方式，有在线和离线两种方式，考虑到网速原因，这里我们采用离线下载方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.4592869188147&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.4.tgz&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;7.4518399604841&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@docker01 ~]# &lt;span&gt;tar&lt;/span&gt; -zxf harbor-offline-installer-v2.&lt;span&gt;0.2&lt;/span&gt;.tgz  -C /usr/local/&lt;span&gt;
[root@docker01 &lt;/span&gt;~]#  cd /usr/local/harbor/&lt;span&gt;
[root@docker harbor]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
common.&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;  harbor.v2.&lt;span&gt;0.2&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz  harbor.yml.tmpl  &lt;span&gt;install&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;  LICENSE  prepare
[root@docker01 harbor]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;&lt;span&gt;  harbor.yml.tmpl harbor.yml
[root@docker01 harbor]# vim harbor.yml&lt;br/&gt;修改hostname=IP&lt;br/&gt;注释掉https，我们就用http就可以了。如果要用https需要开启nginx sll为on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210212132359387-1650523718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;8.9355194268393&quot;&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 修改完配置文件后，在的当前目录执行./install.sh，Harbor服务就会根据当期目录下的docker-compose.yml开始下载依赖的镜像，检测并按照顺序依次启动,并且注意，harbor默认使用的是80端口，最好确认是否有冲突，或者也可以在docker-compose.yml中修改对应的端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@docker01 harbor]# systemctl daemon-&lt;span&gt;reload 
[root@docker01 harbor]# systemctl restart docker
[root@docker01 harbor]# .&lt;/span&gt;/&lt;span&gt;install&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210212132651676-351354644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
查看和监控&lt;/div&gt;
&lt;div readability=&quot;9.4214626391097&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@docker01 harbor]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE                             COMMAND                  CREATED              STATUS                            PORTS                       NAMES
af0d3f823c92        goharbor&lt;/span&gt;/registry-photon:v2.&lt;span&gt;0.2&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/harbor/entryp…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   About a minute ago   Up &lt;span&gt;2&lt;/span&gt; seconds (health: starting)   &lt;span&gt;5000&lt;/span&gt;/&lt;span&gt;tcp                    registry
ce229f6b7e37        goharbor&lt;/span&gt;/harbor-db:v2.&lt;span&gt;0.2&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/docker-entrypoint.…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   About a minute ago   Up &lt;span&gt;2&lt;/span&gt; seconds (health: starting)   &lt;span&gt;5432&lt;/span&gt;/tcp                    harbor-&lt;span&gt;db
a357025287c1        goharbor&lt;/span&gt;/harbor-log:v2.&lt;span&gt;0.2&lt;/span&gt;        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh -c /usr/loc…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   About a minute ago   Up &lt;span&gt;2&lt;/span&gt; seconds (health: starting)   &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;1514&lt;/span&gt;-&amp;gt;&lt;span&gt;10514&lt;/span&gt;/tcp   harbor-log harbor-log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;harbor使用&lt;/p&gt;
&lt;p&gt;//在执行此命令是一定要在模板目录下！&lt;/p&gt;
&lt;div readability=&quot;8.4134351743047&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@docker01 harbor]# &lt;span&gt;pwd&lt;/span&gt;
/usr/local/&lt;span&gt;harbor

[root@docker harbor]# docker&lt;/span&gt;-&lt;span&gt;compose  start
Starting log         ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting registry    ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting registryctl ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting postgresql  ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting portal      ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting redis       ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting core        ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting jobservice  ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Starting proxy       ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;

[root@docker01 harbor]# netstat  &lt;/span&gt;-anput | &lt;span&gt;grep&lt;/span&gt;  &lt;span&gt;80&lt;/span&gt;&lt;span&gt;        
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;51580&lt;/span&gt;         &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;1514&lt;/span&gt;          ESTABLISHED &lt;span&gt;6286&lt;/span&gt;/&lt;span&gt;dockerd        
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;1514&lt;/span&gt;          &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;51580&lt;/span&gt;         ESTABLISHED &lt;span&gt;6474&lt;/span&gt;/docker-&lt;span&gt;proxy   
tcp6       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; :::&lt;span&gt;80&lt;/span&gt;                   :::*                    LISTEN      &lt;span&gt;8355&lt;/span&gt;/docker-proxy   
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210212185848069-1958295064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210212185901368-455573505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;docker client的设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//因为docker不支持https的原因，我们也需要将docker的配置文件进 行更改。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@docker02 /]# vim /usr/lib/systemd/system/&lt;span&gt;docker.service
.....
ExecStart&lt;/span&gt;=/usr/bin/dockerd --insecure-registry &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;&lt;span&gt;
....
[root@docker02 &lt;/span&gt;/]# systemctl daemon-&lt;span&gt;reload
[root@docker02 &lt;/span&gt;/]# systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端登录与上传镜像&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@docker02 ~&lt;span&gt;]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos7             latest              7e6257c9f8d8        &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; months ago        203MB
[root@docker02 &lt;/span&gt;~]# docker tag centos7:latest   &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;/test/centos:&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新打个标签&lt;/span&gt;
[root@docker02 ~]# docker &lt;span&gt;login&lt;/span&gt;  -u admin  -p Harbor12345 &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;
WARNING! Using --password via the CLI is insecure. Use --password-&lt;span&gt;stdin.
WARNING&lt;/span&gt;! Your password will be stored unencrypted &lt;span&gt;in&lt;/span&gt; /root/.docker/&lt;span&gt;config.json.
Configure a credential helper to remove this warning. See
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;docs.docker.com/engine/reference/commandline/login/#credentials-store&lt;/span&gt;
&lt;span&gt;
Login Succeeded
[root@docker02 &lt;/span&gt;~]# docker push  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;/test/&lt;span&gt;centos
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传&lt;/span&gt;
The push refers to repository [&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;/test/&lt;span&gt;centos]
613be09ab3c0: Pushed
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;: digest: sha256:fe2347002c630d5d61bf2f28f21246ad1c21cc6fd343e70b4cf1e5102f8711a9 size: &lt;span&gt;529&lt;/span&gt;&lt;span&gt;
[root@docker &lt;/span&gt;~&lt;span&gt;]# docker images
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看harbor仓库所有镜像&lt;/span&gt;
&lt;span&gt;REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/httpd-iso   latest              740e9757f71d        &lt;span&gt;4&lt;/span&gt; hours ago         567MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2133896/202102/2133896-20210212190745671-1788257527.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令总结&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#推送之前先登录Harbor
docker &lt;/span&gt;&lt;span&gt;login&lt;/span&gt; docker &lt;span&gt;login&lt;/span&gt; registry.test.myop.com -u admin -&lt;span&gt;p Harbor12345
提示success登录成功

查看自己有哪些镜像;docker images
把需要上传到Harbor的镜像运行如下命令就可以了
#镜像打标签
docker tag 镜像名:标签 私服地址&lt;/span&gt;/仓库项目名/&lt;span&gt;镜像名:标签

#推送到私服
docker push  私服地址&lt;/span&gt;/仓库项目名/&lt;span&gt;镜像名：标签  

#从私服拉取镜像
docker pull 私服地址&lt;/span&gt;/仓库项目名/&lt;span&gt;镜像名：标签
也可以在web界面复制下载路径
#通过compose关闭harbor容器服务
docker&lt;/span&gt;-compose  down
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 12 Feb 2021 12:17:00 +0000</pubDate>
<dc:creator>林奋斗的成长之路</dc:creator>
<og:description>Harbor 一、背景 Docker中要使用镜像，我们一般都会从本地、Docker Hub公共仓库或者其它第三方的公共仓库中下载镜像，但是出于安全和一些内外网的原因考虑，企业级上不会轻易使用。普通的D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lin-strive/p/14398731.html</dc:identifier>
</item>
</channel>
</rss>