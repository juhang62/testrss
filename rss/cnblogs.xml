<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浅谈无线局域网WLAN - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12348147.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12348147.html</guid>
<description>&lt;h2 id=&quot;无线局域网wlan&quot;&gt;无线局域网WLAN&lt;/h2&gt;
&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;有线局域网的组成如下图所示，多台计算机通过双绞线连接到一个集线器（hub）或交换机（switch）上，组成一个有限局域网。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/1.png&quot; alt=&quot;image-20200208203457585&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无线局域网的组成如下图所示，多台计算机通过无线网卡与接入点 AP (Access Point)连接，组成一个无线局域网。无线AP可以给连接的计算机分配地址，连接同一个AP的计算机分配的地址都在同一网段。相比有线网络，无线网络的信号易受建筑物遮挡影响导致信号变弱，辐射范围变小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/2.png&quot; alt=&quot;image-20200208203248201&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二无线局域网的组成&quot;&gt;二、无线局域网的组成&lt;/h3&gt;
&lt;h4 id=&quot;简介&quot;&gt;2.1.简介&lt;/h4&gt;
&lt;p&gt;有固定基础设施的无线局域网:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/3.png&quot; alt=&quot;image-20200208212028515&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个基本服务集 BSS 包括&lt;strong&gt;一个基站&lt;/strong&gt;和&lt;strong&gt;若干个移动站&lt;/strong&gt;，即一个AP与连接它的计算机。所有的站在本 BSS 以内都可以直接通信，但在和本 BSS 以外的站通信时 ，都要通过本 BSS 的基站。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;基本服务集内的基站叫做&lt;strong&gt;接入点 AP&lt;/strong&gt; (Access Point)其作用和网桥相似。当网络管理员安装 AP 时，必须为该 AP 分配&lt;/p&gt;
&lt;p&gt;一个不超过 32 字节的&lt;strong&gt;服务集标识符 SSID&lt;/strong&gt; （即无线WLAN的名字）和一个&lt;strong&gt;信道&lt;/strong&gt;（即规定使用什么频率）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/4.png&quot; alt=&quot;image-20200208215119571&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过SSID来选择连接不同的无线AP，还可以设置连接密码，并且一般选择连接信号强的AP。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一个基本服务集可以是孤立的，也可通过接入点 AP连接到一个主干&lt;strong&gt;分配系统&lt;/strong&gt;（相当于交换机） DluS (Distribution System)，然后再接入到另一个基本服务集，构成&lt;strong&gt;扩展的服务集&lt;/strong&gt;ESS (Extended Service Set)。扩展服务集内设备的地址可以是同一网段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ESS 还可通过&lt;strong&gt;门户&lt;/strong&gt;(portal)为无线用户提供到非 802.11 无线局域网的接入。例如通过添加路由器把无线用户接入到有线连接的因特网，门户的作用就相当于一个网桥。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移动站 A 从某一个基本服务集&lt;strong&gt;漫游&lt;/strong&gt;到另一个基本服务集（到 A' 的位置），仍可保持与另一个移动站 B 进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/5.png&quot; alt=&quot;image-20200208212728023&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;与接入点-ap-建立关联association&quot;&gt;2.2.与接入点 AP 建立关联(association)&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;一个移动站（用户的通信设备）若要加入到一个基本服务集 BSS，就必须先选择一个接入点 AP（相当于基站），并与此接入点&lt;strong&gt;建立关联&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;建立关联就表示这个移动站加入了选定的 AP 所属的子网，并和这个 AP 之间创建了一个虚拟线路。&lt;/li&gt;
&lt;li&gt;只有关联的 AP 才向这个移动站发送数据帧，而这个移动站也只有通过关联的 AP 才能向其他站点发送数据帧。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;移动站与-ap-建立关联的方法&quot;&gt;2.3.移动站与 AP 建立关联的方法&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;被动扫描&lt;/strong&gt;：即移动站等待接收接入站周期性发出的&lt;strong&gt;信标帧&lt;/strong&gt;(beacon frame)。&lt;/p&gt;
&lt;p&gt;信标帧中包含有若干系统参数（如服务集标识符 SSID 以及支持的速率等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;主动扫描&lt;/strong&gt;：即移动站主动发出&lt;strong&gt;探测请求帧&lt;/strong&gt;(probe request frame)，然后等待从 AP 发回的&lt;strong&gt;探测响应帧&lt;/strong&gt;(probe response frame)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;热点hot-spot&quot;&gt;2.4.热点(hot spot)&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;现在许多地方，如办公室、机场、快餐店、旅馆、购物中心等都能够向公众提供有偿或无偿接入 Wi-Fi 的服务。这样的地点就叫做&lt;strong&gt;热点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;由许多热点和 AP 连接起来的区域叫做&lt;strong&gt;热区&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;手机打电话的过程&quot;&gt;2.5.手机打电话的过程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/6.png&quot; alt=&quot;image-20200209153122221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，移动和联通等通信运营商在全国各地建了很多个基站。当拥有移动设备手机的用户A出现在城市A时，他的手机会自动连接最近的，信号最强的基站A并进行注册；同样的，用户B在城市B出现，他的手机也会自动连接最近的基站B并进行注册；这样在联通或移动的数据库里面就会这样的记录：什么手机号现在在哪一个基站上注册了。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当用户A向用户B打电话的时候，用户A先与基站A建立通信，基站A通过查找数据库找到用户B注册的基站B，再通过光纤与城市B的基站B连接，最后通过基站B与用户B通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在全国范围内基站数量越多，没有信号的地方就越少，所以我们打电话总是能通，这就是打电话时如何实现通信的过程。&lt;/li&gt;
&lt;li&gt;当用户A移动到，基站A1附近，用户A就会在基站A1上注册，此时就会更改数据库中用户A与基站的绑定信息。也就是说，移动或联通的用户在移动位置的时候都要更新数据库。这样便能精准、实时地掌握用户所注册的基站，实现随时随地的通信。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这就是为什么跨省跨市移动的时候，就会收到&quot;xxx欢迎你&quot;的短信的原因。当我们移动时，我们的手机就会就近地在当地的基站上注册，并更新数据库。因此，联通移动等运行商就能掌握我们的位置信息了，于是给我们发送欢迎短信。所以说犯罪分子只要一使用手机通讯就知道他的大概位置了，这也是同样的道理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;用户通过手机与基站连接，基站通过查找数据库找到通信方所注册的基站，通过光纤与之连接，再通过该基站实现与通信方的通信。而非手机间直接通信，因为没有这么大的信号强度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/7.png&quot; alt=&quot;image-20200209154359325&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的，手机也是通过联通或移动的基站来访问Internet。手机通过3G或4G信号连接联通或移动的基站，基站通过光纤连接路由器，通过在路由器上设置网关便能连接Internet。这样只要有信号，手机能打电话，就能联系到基站，就能通过基站连接光纤接入Internet。这就是为什么我们感觉无论在哪里打开手机都能上网，其实就是通过基站连接Internet的。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;三组建无线局域网示例&quot;&gt;三、组建无线局域网示例&lt;/h3&gt;
&lt;h4 id=&quot;学校的无线网络举例&quot;&gt;3.1.学校的无线网络举例&lt;/h4&gt;
&lt;p&gt;下图为学校教师办公室组建无线局域网的案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/8.png&quot; alt=&quot;image-20200208214502966&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先在每间办公室安装一个AP；&lt;/li&gt;
&lt;li&gt;然后每间办公室的AP使用一根电缆连接到机房的交换机上；&lt;/li&gt;
&lt;li&gt;机房的交换机通过路由器连接Internet；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样每间办公室内的用户都可以就近连接无线AP，实现无线上网。&lt;/p&gt;
&lt;h4 id=&quot;家庭计算机上网过程&quot;&gt;3.2.家庭计算机上网过程&lt;/h4&gt;
&lt;p&gt;大多数网民都是采用电话线拨号上网的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;直接通过连接猫（调制解调器）上网。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/9.png&quot; alt=&quot;image-20200208221627619&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以前的电话线是直接接电话机，现在的电话线则接在分离器上。从分离器中拉出一根线接调制解调器（猫）的ADSL接口，猫上的LAN接口为局域网接口（网线接口）直接与计算机的网卡进行连接。随后，在计算机上创建ADSL的拨号连接，输入对应账号密码，拨通后计算机的ADSL拨号连接就获得一个公网的IP地址，即计算机可以访问Internet了。&lt;/p&gt;
&lt;p&gt;这种通过电话线连接猫的上网方式只允许连接一台计算机，不符合多台计算机上网的需求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过连接无线路由器上网。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/10.png&quot; alt=&quot;image-20200208221451636&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用无线路由器可以满足多台计算机上网的需求。无线路由器相当于一个专门建立ADSL拨号连接的设备。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如图，无线路由器的WLAN接口连接猫的LAN接口，给无线路由器配好拨号的账号密码后，只要给它供电它便会自动拨号上网，WLAN接口相当于一台电脑，获得了一个公网地址，可以访问Internet了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无线路由器上的LAN接口（以太网口）相当于四个接口的交换机，可以连接四台计算机的有线网卡，把它们的地址设为同一网段即可上网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;无线路由器上的天线是提供无线服务的，供手机和笔记本等设备连接，这些使用无线连接和使用LAN接口有线连接的设备地址都在同一网段。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当只有无线路由器A可以拨号上网时，可以在无线路由器B的LAN接口中引出一根线连接无线路由器A的LAN接口，这样无线路由器B就相当于一个交换机，只要把无线路由器B连接的设备地址和网关分别设置为无线路由器A所在网段和网关，便可实现网络共享。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;千万不要把无线路由器当成路由器，认为不同的LAN接口在不同网段。实际上无线路由器相当于三个设备的集合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/11.png&quot; alt=&quot;image-20200208230235800&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接猫建立ADSL拨号连接的路由器；&lt;/li&gt;
&lt;li&gt;连接有线用户的交换机；&lt;/li&gt;
&lt;li&gt;与设备的无线网卡连接的独立AP；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当路由器ADSL拨号通了之后，路由器获得一个公网IP地址。无线路由器中的三部分连接的所有设备都通过该公网地址上网，所以这些设备的IP地址都在一个网段上。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;四移动自组网络&quot;&gt;四、移动自组网络&lt;/h3&gt;
&lt;h4 id=&quot;简介-1&quot;&gt;4.1.简介&lt;/h4&gt;
&lt;p&gt;自组网络是没有固定基础设施（即没有 AP）的无线局域网。这种网络由一些处于平等状态的移动站之间相互通信组成的临时网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.1.%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91WLAN/12.png&quot; alt=&quot;image-20200209122906836&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;移动自组网络的应用前景&quot;&gt;4.2.移动自组网络的应用前景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在军事领域中，携带了移动站的战士可利用临时建立的移动自组网络进行通信；&lt;/li&gt;
&lt;li&gt;这种组网方式也能够应用到作战的地面车辆群和坦克群，以及海上的舰艇群、空中的机群；&lt;/li&gt;
&lt;li&gt;当出现自然灾害时，在抢险救灾时利用移动自组网络进行及时的通信往往很有效的；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Feb 2020 16:01:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>无线局域网WLAN 一、概述 有线局域网的组成如下图所示，多台计算机通过双绞线连接到一个集线器（hub）或交换机（switch）上，组成一个有限局域网。 无线局域网的组成如下图所示，多台计算机通过无线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12348147.html</dc:identifier>
</item>
<item>
<title>Java开发最佳实践(一) ——《Java开发手册》之&quot;编程规约&quot; - 行无际</title>
<link>http://www.cnblogs.com/itwild/p/12348087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itwild/p/12348087.html</guid>
<description>&lt;h2 id=&quot;java开发手册版本更新说明&quot;&gt;Java开发手册版本更新说明&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1.3.0&lt;/td&gt;
&lt;td&gt;终极版&lt;/td&gt;
&lt;td&gt;2017.09.25&lt;/td&gt;
&lt;td&gt;单元测试规约，IDE代码规约插件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.3.1&lt;/td&gt;
&lt;td&gt;纪念版&lt;/td&gt;
&lt;td&gt;2017.11.30&lt;/td&gt;
&lt;td&gt;修正部分描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1.4.0&lt;/td&gt;
&lt;td&gt;详尽版&lt;/td&gt;
&lt;td&gt;2018.05.20&lt;/td&gt;
&lt;td&gt;增加设计规约大类，共16条&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1.5.0&lt;/td&gt;
&lt;td&gt;华山版&lt;/td&gt;
&lt;td&gt;2019.06.19&lt;/td&gt;
&lt;td&gt;详细更新见下面&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;本笔记主要基于&lt;code&gt;华山版&lt;/code&gt;(1.5.0)的总结。华山版具体更新如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;鉴于本手册是社区开发者集体智慧的结晶，本版本移除阿里巴巴&lt;code&gt;Java开发手册&lt;/code&gt;的限定词&lt;code&gt;阿里巴巴&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新增21条新规约。比如，&lt;code&gt;switch&lt;/code&gt;的NPE问题、浮点数的比较、无泛型限制、锁的使用方式、判断表达式、日期格式等&lt;/li&gt;
&lt;li&gt;修改描述112处。比如，&lt;code&gt;IFNULL&lt;/code&gt;的判断、集合的&lt;code&gt;toArray&lt;/code&gt;、日志处理等&lt;/li&gt;
&lt;li&gt;完善若干处示例。比如，命名示例、卫语句示例、&lt;code&gt;enum&lt;/code&gt;示例、&lt;code&gt;finally&lt;/code&gt;的&lt;code&gt;return&lt;/code&gt;示例等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;PDF下载地址:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;https://pan.baidu.com/s/1K-GZ_CzRC0igIxMgLGVtZQ&lt;/code&gt; 密码:关注&lt;code&gt;行无际&lt;/code&gt;的微信公众号：&lt;code&gt;it_wild&lt;/code&gt;，回复&lt;code&gt;java开发手册&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itwild/1650404/o_200219053510itwild-wechat-gongzhonghao.png&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;专有名词解释&quot;&gt;专有名词解释&lt;/h2&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;&lt;code&gt;POJO&lt;/code&gt;（Plain Ordinary Java Object）: 在本手册中，POJO专指只有setter、getter、toString的简单类，包括DO、DTO、BO、VO等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GAV&lt;/code&gt;（GroupId、ArtifactctId、Version）: Maven坐标，是用来唯一标识jar包。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOP&lt;/code&gt;（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORM&lt;/code&gt;（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指ibatis, mybatis等框架。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NPE&lt;/code&gt;（java.lang.NullPointerException）: 空指针异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SOA&lt;/code&gt;（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IDE&lt;/code&gt;（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指 IntelliJ IDEA 和eclipse。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOM&lt;/code&gt;（Out Of Memory）: 源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一方库&lt;/code&gt;：本工程内部子项目模块依赖的库（jar包）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;二方库&lt;/code&gt;：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;三方库&lt;/code&gt;：公司之外的开源库（jar包）。&lt;/p&gt;
&lt;h2 id=&quot;一-编程规约&quot;&gt;一、 编程规约&lt;/h2&gt;
&lt;h3 id=&quot;一-命名风格&quot;&gt;(一) 命名风格&lt;/h3&gt;
&lt;strong&gt;&lt;em&gt;正例：&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;国际通用的名称，可视同英文；&lt;code&gt;alibaba&lt;/code&gt; / &lt;code&gt;youku&lt;/code&gt; / &lt;code&gt;hangzhou&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;类名使用&lt;code&gt;UpperCamelCase&lt;/code&gt;风格，但以下情形例外：&lt;code&gt;DO&lt;/code&gt; / &lt;code&gt;BO&lt;/code&gt; / &lt;code&gt;DTO&lt;/code&gt; / &lt;code&gt;VO&lt;/code&gt; / &lt;code&gt;AO&lt;/code&gt; / &lt;code&gt;PO&lt;/code&gt; / &lt;code&gt;UID&lt;/code&gt; 等。如：&lt;code&gt;UserDO&lt;/code&gt; / &lt;code&gt;XmlService&lt;/code&gt; / &lt;code&gt;TcpUdpDeal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法名、参数名、成员变量、局部变量都统一使用&lt;code&gt;lowerCamelCase&lt;/code&gt;风格，必须遵从驼峰形式；&lt;code&gt;localValue&lt;/code&gt; / &lt;code&gt;getHttpMessage&lt;/code&gt; / &lt;code&gt;inputUserId&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。&lt;code&gt;MAX_STOCK_COUNT&lt;/code&gt; / &lt;code&gt;CACHE_EXPIRED_TIME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;抽象类命名使用&lt;code&gt;Abstract&lt;/code&gt;或&lt;code&gt;Base&lt;/code&gt;开头；异常类命名使用&lt;code&gt;Exception&lt;/code&gt;结尾；测试类命名以它要测试的类的名称开始，以&lt;code&gt;Test&lt;/code&gt;结尾&lt;/li&gt;
&lt;li&gt;类型与中括号紧挨相连来表示数组，定义整形数组 &lt;code&gt;int[] arrayDemo;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;包名&lt;/code&gt;统一使用&lt;code&gt;小写&lt;/code&gt;，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用&lt;code&gt;单数&lt;/code&gt;形式，但是&lt;code&gt;类名&lt;/code&gt;如果有复数含义，&lt;code&gt;类名可以使用复数形式&lt;/code&gt;。包名&lt;code&gt;com.alibaba.ai.util&lt;/code&gt;，类名为&lt;code&gt;MessageUtils&lt;/code&gt;（此规则参考&lt;code&gt;spring&lt;/code&gt;的框架结构）&lt;/li&gt;
&lt;li&gt;为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。在JDK中，表达原子更新的类名为：&lt;code&gt;AtomicReferenceFieldUpdater&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。如：&lt;code&gt;startTime&lt;/code&gt; / &lt;code&gt;workQueue&lt;/code&gt; / &lt;code&gt;nameList&lt;/code&gt; / &lt;code&gt;TERMINATED_THREAD_COUNT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果模块、接口、类、方法使用了&lt;code&gt;设计模式&lt;/code&gt;，在命名时需体现出具体模式（将设计模式体现在名字中，有利于阅读者快速理解架构设计理念）。如： &lt;code&gt;class OrderFactory&lt;/code&gt; / &lt;code&gt;class LoginProxy&lt;/code&gt; / &lt;code&gt;class ResourceObserver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接口类中的方法和属性不要加任何修饰符号（&lt;code&gt;public&lt;/code&gt;也不要加），保持代码的简洁性,并加上有效的&lt;code&gt;Javadoc&lt;/code&gt;注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。接口方法签名&lt;code&gt;void commit();&lt;/code&gt;，接口基础常量&lt;code&gt;String COMPANY = &quot;alibaba&quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;Service&lt;/code&gt;和&lt;code&gt;DAO&lt;/code&gt;类，基于&lt;code&gt;SOA&lt;/code&gt;的理念，暴露出来的服务一定是接口，内部的实现类用&lt;code&gt;Impl&lt;/code&gt;的后缀与接口区别。如&lt;code&gt;CacheServiceImpl&lt;/code&gt;实现&lt;code&gt;CacheService&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;如果是&lt;code&gt;形容能力&lt;/code&gt;的&lt;code&gt;接口&lt;/code&gt;名称，取对应的形容词为接口名（通常是–&lt;code&gt;able&lt;/code&gt;的形容词）如 &lt;code&gt;AbstractTranslator&lt;/code&gt;实现&lt;code&gt;Translatable&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;枚举类名带上&lt;code&gt;Enum&lt;/code&gt;后缀，枚举成员名称需要&lt;code&gt;全大写&lt;/code&gt;，单词间用&lt;code&gt;下划线&lt;/code&gt;隔开。(说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。)枚举名字为&lt;code&gt;ProcessStatusEnum&lt;/code&gt;的成员名称：&lt;code&gt;SUCCESS&lt;/code&gt; / &lt;code&gt;UNKNOWN_REASON&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;各层命名规约:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;A) Service/DAO 层方法命名规约&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取单个对象的方法用&lt;code&gt;get&lt;/code&gt;做前缀。&lt;/li&gt;
&lt;li&gt;获取多个对象的方法用&lt;code&gt;list&lt;/code&gt;做前缀，复数形式结尾如：&lt;code&gt;listObjects&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;获取统计值的方法用&lt;code&gt;count&lt;/code&gt;做前缀。&lt;/li&gt;
&lt;li&gt;插入的方法用&lt;code&gt;save&lt;/code&gt;/&lt;code&gt;insert&lt;/code&gt;做前缀。&lt;/li&gt;
&lt;li&gt;删除的方法用&lt;code&gt;remove&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;做前缀。&lt;/li&gt;
&lt;li&gt;修改的方法用&lt;code&gt;update&lt;/code&gt;做前缀。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;B) 领域模型命名规约&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据对象：&lt;code&gt;xxxDO&lt;/code&gt;，xxx即为数据表名。&lt;/li&gt;
&lt;li&gt;数据传输对象：&lt;code&gt;xxxDTO&lt;/code&gt;，xxx为业务领域相关的名称。&lt;/li&gt;
&lt;li&gt;展示对象：&lt;code&gt;xxxVO&lt;/code&gt;，xxx一般为网页名称。&lt;/li&gt;
&lt;li&gt;POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;反例：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-常量定义&quot;&gt;(二) 常量定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不允许任何魔法值（即未经预先定义的常量）直接出现在代码中 &lt;del&gt;String key =&lt;code&gt;&quot;Id#taobao_&quot;&lt;/code&gt; + tradeId;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;long&lt;/code&gt;或者&lt;code&gt;Long&lt;/code&gt;赋值时，数值后使用大写的&lt;code&gt;L&lt;/code&gt;，不能是小写的&lt;code&gt;l&lt;/code&gt;，小写容易跟数字1混淆，造成误解。&lt;del&gt;Long a = 2l;&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。正例：缓存相关常量放在类&lt;code&gt;CacheConsts&lt;/code&gt;下；系统配置相关常量放在类&lt;code&gt;ConfigConsts&lt;/code&gt;下。&lt;/li&gt;
&lt;li&gt;如果变量值仅在一个固定范围内变化用&lt;code&gt;enum&lt;/code&gt;类型来定义。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三-代码格式&quot;&gt;(三) 代码格式&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);
BigDecimal recommend2 = BigDecimal.valueOf(0.1);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关于基本数据类型与包装数据类型的使用标准如下：&lt;code&gt;1）【强制】所有的POJO类属性必须使用包装数据类型。2）【强制】RPC方法的返回值和参数必须使用包装数据类型。3） 【推荐】所有的局部变量使用基本数据类型。&lt;/code&gt;【说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。&lt;code&gt;正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;定义 DO/DTO/VO等&lt;code&gt;POJO&lt;/code&gt;类时，不要设定任何属性&lt;code&gt;默认值&lt;/code&gt;。【反例：POJO 类的 createTime 默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。】&lt;/li&gt;
&lt;li&gt;序列化类新增属性时，请不要修改&lt;code&gt;serialVersionUID&lt;/code&gt;字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改&lt;code&gt;serialVersionUID&lt;/code&gt;值。(说明：注意serialVersionUID不一致会抛出序列化运行时异常。)&lt;/li&gt;
&lt;li&gt;构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在&lt;code&gt;init&lt;/code&gt;方法中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POJO&lt;/code&gt;类必须写&lt;code&gt;toString&lt;/code&gt;方法。使用IDE中的工具：source&amp;gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下&lt;code&gt;super.toString&lt;/code&gt;。【说明：在方法执行抛出异常时，可以直接调用 POJO 的 &lt;code&gt;toString()&lt;/code&gt;方法打印其属性值，便于排查问题】&lt;/li&gt;
&lt;li&gt;禁止在&lt;code&gt;POJO&lt;/code&gt;类中，同时存在对应属性xxx的&lt;code&gt;isXxx()&lt;/code&gt;和&lt;code&gt;getXxx()&lt;/code&gt;方法。【说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到】&lt;/li&gt;
&lt;li&gt;使用索引访问用String的&lt;code&gt;split&lt;/code&gt;方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;的风险&lt;/li&gt;
&lt;li&gt;当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于下一条&lt;/li&gt;
&lt;li&gt;类内方法定义的顺序依次是：公有方法或保护方法 &amp;gt; 私有方法 &amp;gt; getter/setter方法。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;getter/setter&lt;/code&gt;方法中，不要增加业务逻辑，增加排查问题的难度&lt;/li&gt;
&lt;li&gt;循环体内，字符串的连接方式，使用&lt;code&gt;StringBuilder&lt;/code&gt;的&lt;code&gt;append&lt;/code&gt;方法进行扩展&lt;/li&gt;
&lt;li&gt;&lt;code&gt;final&lt;/code&gt;可以声明类(不允许被继承的类，如&lt;code&gt;String&lt;/code&gt;类)、成员变量(不允许修改引用的域对象)、方法、以及本地变量(不允许运行过程中重新赋值的局部变量),避免上下文重复使用一个变量，使用final可以强制重新定义一个变量，方便更好地进行重构&lt;/li&gt;
&lt;li&gt;慎用&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;clone&lt;/code&gt;方法来拷贝对象，对象&lt;code&gt;clone&lt;/code&gt;方法默认是浅拷贝，若想实现深拷贝需覆写&lt;code&gt;clone&lt;/code&gt;方法实现域对象的深度遍历式拷贝。&lt;/li&gt;
&lt;li&gt;类成员与方法访问控制从严。&lt;code&gt;1）如果不允许外部直接通过new来创建对象，那么构造方法必须是private。2）工具类不允许有public或default构造方法。3）类非static 成员变量并且与子类共享，必须是protected。 4）类非static成员变量并且仅在本类使用，必须是private。5）类static成员变量如果仅在本类使用，必须是private。 6）若是static成员变量，考虑是否为final。7）类成员方法只供类内部调用，必须是 private。8）类成员方法只对继承类公开，那么限制为protected。&lt;/code&gt;【说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;浮点数&lt;/code&gt;之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals 来判断。【浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 反例
float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
if (a == b) { // 预期进入此代码快，执行其它业务逻辑
// 但事实上 a==b 的结果为 false
}
Float x = Float.valueOf(a);
Float y = Float.valueOf(b);
if (x.equals(y)) { // 预期进入此代码快，执行其它业务逻辑
// 但事实上 equals 的结果为 false
}

// 正例

// (1)指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的
float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
float diff = 1e-6f;

if (Math.abs(a - b) &amp;lt; diff) {
    System.out.println(&quot;true&quot;);
}

// (2)使用BigDecimal来定义值，再进行浮点数的运算操作
// BigDecimal构造的时候注意事项 见上文
BigDecimal a = new BigDecimal(&quot;1.0&quot;);
BigDecimal b = new BigDecimal(&quot;0.9&quot;);
BigDecimal c = new BigDecimal(&quot;0.8&quot;);

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

if (x.equals(y)) {
    System.out.println(&quot;true&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五-集合处理&quot;&gt;(五) 集合处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;关于&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;的处理，遵循如下规则:1）只要覆写&lt;code&gt;equals&lt;/code&gt;，就必须覆写&lt;code&gt;hashCode&lt;/code&gt;。2）因为&lt;code&gt;Set&lt;/code&gt;存储的是不重复的对象，依据&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;进行判断，所以&lt;code&gt;Set&lt;/code&gt;存储的对象必须覆写这两个方法。3）如果自定义对象作为&lt;code&gt;Map&lt;/code&gt;的键，那么必须覆写&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;。【说明：&lt;code&gt;String&lt;/code&gt;已覆写&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;方法，所以我们可以愉快地使用&lt;code&gt;String&lt;/code&gt;对象作为&lt;code&gt;key&lt;/code&gt;来使用】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt;的&lt;code&gt;subList&lt;/code&gt;结果不可强转成&lt;code&gt;ArrayList&lt;/code&gt;，否则会抛出&lt;code&gt;ClassCastException&lt;/code&gt;异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList【说明：&lt;code&gt;subList&lt;/code&gt;返回的是&lt;code&gt;ArrayList&lt;/code&gt;的内部类&lt;code&gt;SubList&lt;/code&gt;，并不是&lt;code&gt;ArrayList&lt;/code&gt;而是&lt;code&gt;ArrayList&lt;/code&gt;的一个视图，对于&lt;code&gt;SubList&lt;/code&gt;子列表的所有操作最终会反映到原列表上】&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Map&lt;/code&gt;的方法&lt;code&gt;keySet()/values()/entrySet()&lt;/code&gt;返回集合对象时，不可以对其进行添加元素操作，否则会抛出&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collections&lt;/code&gt;类返回的对象，如：&lt;code&gt;emptyList()/singletonList()&lt;/code&gt;等都是immutable list，不可对其进行添加或者删除元素的操作【反例：如果查询无结果，返回 &lt;code&gt;Collections.emptyList()&lt;/code&gt;空集合对象，调用方一旦进行了添加元素的操作，就会触发&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常。】&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;subList&lt;/code&gt;场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常&lt;/li&gt;
&lt;li&gt;使用集合转数组的方法，必须使用集合的&lt;code&gt;toArray(T[] array)&lt;/code&gt;，传入的是类型完全一致、长度为0的空数组【反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(2);
list.add(&quot;行无际&quot;);
list.add(&quot;itwild&quot;);
String[] array = list.toArray(new String[0]);
/*
说明：
使用toArray带参方法，数组空间大小的length：
1）等于0，动态创建与size相同的数组，性能最好
2）大于0但小于size，重新创建大小等于size的数组，增加GC负担
3）等于size，在高并发情况下，数组创建完成之后，size正在变大的情况下，负面影响与上相同
4）大于size，空间浪费，且在size处插入null值，存在NPE隐患
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在使用&lt;code&gt;Collection&lt;/code&gt;接口任何实现类的&lt;code&gt;addAll()&lt;/code&gt;方法时，都要对输入的集合参数进行NPE判断 【说明：在&lt;code&gt;ArrayList#addAll&lt;/code&gt;方法的第一行代码即&lt;code&gt;Object[] a = c.toArray();&lt;/code&gt;其中c为输入集合参数，如果为null，则直接抛出异常。】&lt;/li&gt;
&lt;li&gt;使用工具类&lt;code&gt;Arrays.asList()&lt;/code&gt;把数组转换成集合时，不能使用其修改集合相关的方法，它的&lt;code&gt;add/remove/clear&lt;/code&gt;方法会抛出&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常【说明：&lt;code&gt;asList&lt;/code&gt;的返回对象是一个&lt;code&gt;Arrays&lt;/code&gt;内部类，并没有实现集合的修改方法。&lt;code&gt;Arrays.asList&lt;/code&gt;体现的是适配器模式，只是转换接口，后台的数据仍是数组。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[] str = new String[] { &quot;it&quot;, &quot;wild&quot; };
List list = Arrays.asList(str);

// 第一种情况：list.add(&quot;itwild&quot;); 运行时异常
// 第二种情况：str[0] = &quot;changed1&quot;; 也会随之修改
// 反之亦然 list.set(0, &quot;changed2&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;泛型通配符&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;不能使用get方法，作为接口调用赋值时易出错。【说明：扩展说一下&lt;code&gt;PECS&lt;/code&gt;(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;。第二、经常往里插入的，适合用&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;】&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这个地方我觉得有必要简单解释一下(&lt;code&gt;行无际&lt;/code&gt;本人的个人理解哈，有不对的地方欢迎指出)，上面的说法可能有点官方或者难懂。其实我们一直也是这么干的，不过没注意而已。举个最简单的例子，用&lt;code&gt;泛型&lt;/code&gt;的时候，如果你&lt;code&gt;遍历&lt;/code&gt;(&lt;code&gt;read&lt;/code&gt;)一个List，你是不是希望List里面装的越具体越好啊，你希望里面装的是&lt;code&gt;Object&lt;/code&gt;吗，如果里面装的是&lt;code&gt;Object&lt;/code&gt;那么你想想你会有多痛苦，每个对象都用&lt;code&gt;instanceof&lt;/code&gt;判断一下再&lt;code&gt;类型强转&lt;/code&gt;，所以这个方法的参数List主要用于&lt;code&gt;遍历&lt;/code&gt;(&lt;code&gt;read&lt;/code&gt;)的时候，大多数情况你可能会要求里面的元素最大是&lt;code&gt;T&lt;/code&gt;类型，即用&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;限制一下。再看你往List里面&lt;code&gt;插入&lt;/code&gt;(&lt;code&gt;write&lt;/code&gt;)数据又会怎么样，为了灵活性和可扩展性，你马上可能就要说我当然希望List里面装的是&lt;code&gt;Object&lt;/code&gt;了，这样我什么类型的对象都能往List里面写啊，这样设计出来的接口的灵活性和可扩展性才强啊，如果里面装的类型太靠下(假定&lt;code&gt;继承层次从上往下&lt;/code&gt;，父类在上，子孙类在下)，那么位于上级的很多类型的数据你就无法写入了，这个时候用&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;来限制一下最小是&lt;code&gt;T&lt;/code&gt;类型。下面我们来看&lt;code&gt;Collections.copy()&lt;/code&gt;这个例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这里就要求dest的List里面的元素类型 不能在src的List元素类型 之下
// 如果dest的List元素类型位于src的List元素类型之下，就会出现写不进dest
public static &amp;lt;T&amp;gt; void copy(List&amp;lt;? super T&amp;gt; dest, List&amp;lt;? extends T&amp;gt; src) {
    //....省略具体的copy代码
}

// 下面再看我写的测试代码就更容易理解了
static class Animal {}

static class Dog extends Animal {}

static class BlackDog extends Dog {}

@Test
public void test() throws Exception {

    List&amp;lt;Dog&amp;gt; dogList = new ArrayList&amp;lt;&amp;gt;(2);
    dogList.add(new BlackDog());
    dogList.add(new BlackDog());

    List&amp;lt;Animal&amp;gt; animalList = new ArrayList&amp;lt;&amp;gt;(2);
    animalList.add(new Animal());
    animalList.add(new Animal());

    // 错误，无法编译通过
    Collections.copy(dogList, animalList);

    // 正确
    Collections.copy(animalList, dogList);
    
    // Collections.copy()的泛型参数就起作到了很好的限制作用
    // 编译期就能发现类型不对
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行&lt;code&gt;instanceof&lt;/code&gt;判断，避免抛出&lt;code&gt;ClassCastException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 反例
List&amp;lt;String&amp;gt; generics = null;

List notGenerics = new ArrayList(10);
notGenerics.add(new Object());
notGenerics.add(new Integer(1));

generics = notGenerics;

// 此处抛出 ClassCastException 异常
String string = generics.get(0);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不要在&lt;code&gt;foreach&lt;/code&gt;循环里进行元素的&lt;code&gt;remove/add&lt;/code&gt;操作。&lt;code&gt;remove&lt;/code&gt;元素请使用&lt;code&gt;Iterator&lt;/code&gt;方式，如果并发操作，需要对Iterator对象&lt;code&gt;加锁&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 
list.add(&quot;1&quot;); 
list.add(&quot;2&quot;); 

Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); 
while (iterator.hasNext()) { 
    String item = iterator.next(); 
    if (删除元素的条件) {
        iterator.remove(); 
    } 
}

// 反例
for (String item : list) { 
  if (&quot;1&quot;.equals(item)) { 
    list.remove(item); 
  } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在JDK7版本及以上，&lt;code&gt;Comparator&lt;/code&gt;实现类要满足如下三个条件，不然&lt;code&gt;Arrays.sort&lt;/code&gt;，&lt;code&gt;Collections.sort&lt;/code&gt;会抛&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常【说明：三个条件如下 1）x，y 的比较结果和 y，x 的比较结果相反。2）x&amp;gt;y，y&amp;gt;z，则x&amp;gt;z。 3） x=y，则x，z比较结果和y，z 比较结果相同。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 反例：下例中没有处理相等的情况
new Comparator&amp;lt;Student&amp;gt;() { 
  @Override 
  public int compare(Student o1, Student o2) { 
    return o1.getId() &amp;gt; o2.getId() ? 1 : -1; 
  } 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;集合泛型定义时，在JDK7及以上，使用diamond语法或全省略。【说明：菱形泛型，即 diamond，直接使用&amp;lt;&amp;gt;来指代前边已经指定的类型】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
// diamond 方式，即&amp;lt;&amp;gt;
HashMap&amp;lt;String, String&amp;gt; userCache = new HashMap&amp;lt;&amp;gt;(16);
// 全省略方式
ArrayList&amp;lt;User&amp;gt; users = new ArrayList(10);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;反例：&lt;code&gt;HashMap&lt;/code&gt;需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，&lt;code&gt;resize&lt;/code&gt;需要重建&lt;code&gt;hash&lt;/code&gt;表，严重影响性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;使用&lt;code&gt;entrySet&lt;/code&gt;遍历&lt;code&gt;Map&lt;/code&gt;类集合KV，而不是&lt;code&gt;keySet&lt;/code&gt;方式进行遍历。【说明：&lt;code&gt;keySet&lt;/code&gt;其实是遍历了2次，一次是转为&lt;code&gt;Iterator&lt;/code&gt;对象，另一次是从&lt;code&gt;hashMap&lt;/code&gt;中取出 &lt;code&gt;key&lt;/code&gt;所对应的&lt;code&gt;value&lt;/code&gt;。而&lt;code&gt;entrySet&lt;/code&gt;只是遍历了一次就把&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;都放到了entry中，效率更高。如果是JDK8，使用&lt;code&gt;Map.forEach&lt;/code&gt;方法。】&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;正例：&lt;code&gt;values()&lt;/code&gt;返回的是V值集合，是一个list集合对象；&lt;code&gt;keySet()&lt;/code&gt;返回的是K值集合，是一个Set集合对象；&lt;code&gt;entrySet()&lt;/code&gt;返回的是&lt;code&gt;K-V&lt;/code&gt;值组合集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高度注意&lt;code&gt;Map&lt;/code&gt;类集合&lt;code&gt;K/V&lt;/code&gt;能不能存储&lt;code&gt;null&lt;/code&gt;值的情况，如下表格：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Hashtable&lt;/td&gt;
&lt;td&gt;不允许为null&lt;/td&gt;
&lt;td&gt;不允许为null&lt;/td&gt;
&lt;td&gt;Dictionary&lt;/td&gt;
&lt;td&gt;线程安全&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ConcurrentHashMap&lt;/td&gt;
&lt;td&gt;不允许为null&lt;/td&gt;
&lt;td&gt;不允许为null&lt;/td&gt;
&lt;td&gt;AbstractMap&lt;/td&gt;
&lt;td&gt;锁分段技术（JDK8:CAS）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TreeMap&lt;/td&gt;
&lt;td&gt;不允许为null&lt;/td&gt;
&lt;td&gt;允许为null&lt;/td&gt;
&lt;td&gt;AbstractMap&lt;/td&gt;
&lt;td&gt;线程不安全&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;允许为null&lt;/td&gt;
&lt;td&gt;允许为null&lt;/td&gt;
&lt;td&gt;AbstractMap&lt;/td&gt;
&lt;td&gt;线程不安全&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;反例：由于&lt;code&gt;HashMap&lt;/code&gt;的干扰，很多人认为&lt;code&gt;ConcurrentHashMap&lt;/code&gt;是可以置入&lt;code&gt;null&lt;/code&gt;值，而事实上，存储&lt;code&gt;null&lt;/code&gt;值时会抛出&lt;code&gt;NPE&lt;/code&gt;异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;合理利用好集合的有序性(&lt;code&gt;sort&lt;/code&gt;)和稳定性(&lt;code&gt;order&lt;/code&gt;)，避免集合的无序性(&lt;code&gt;unsort&lt;/code&gt;)和不稳定性(&lt;code&gt;unorder&lt;/code&gt;)带来的负面影响。【说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：&lt;code&gt;ArrayList&lt;/code&gt;是 &lt;code&gt;order/unsort&lt;/code&gt;；&lt;code&gt;HashMap&lt;/code&gt;是&lt;code&gt;unorder/unsort&lt;/code&gt;；&lt;code&gt;TreeSet&lt;/code&gt;是&lt;code&gt;order/sort&lt;/code&gt;。】&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;Set&lt;/code&gt;元素唯一的特性，可以快速对一个集合进行去重操作，避免使用&lt;code&gt;List&lt;/code&gt;的&lt;code&gt;contains&lt;/code&gt;方法进行遍历、对比、去重操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;六-并发处理&quot;&gt;(六) 并发处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;获取单例对象需要保证线程安全，其中的方法也要保证线程安全【说明：资源驱动类、工具类、单例工厂类都需要注意】&lt;/li&gt;
&lt;li&gt;创建线程或线程池时请指定有意义的线程名称，方便出错时回溯&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例：自定义线程工厂，并且根据外部特征进行分组，比如机房信息
public class UserThreadFactory implements ThreadFactory {
    private final String namePrefix;
    private final AtomicInteger nextId = new AtomicInteger(1);
    // 定义线程组名称，在 jstack 问题排查时，非常有帮助
    UserThreadFactory(String whatFeaturOfGroup) {
        namePrefix = &quot;From UserThreadFactory's &quot; + whatFeaturOfGroup + &quot;-Worker-&quot;; 
    }
    
    @Override
    public Thread newThread(Runnable task) {
        String name = namePrefix + nextId.getAndIncrement();
        Thread thread = new Thread(null, task, name, 0, false);
        System.out.println(thread.getName());
        return thread; 
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1）&lt;code&gt;FixedThreadPool&lt;/code&gt;和&lt;code&gt;SingleThreadPool&lt;/code&gt;：&lt;br/&gt;允许的请求队列长度为&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，可能会堆积大量的请求，从而导致&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2）&lt;code&gt;CachedThreadPool&lt;/code&gt;：&lt;br/&gt;允许的创建线程数量为&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，可能会创建大量的线程，从而导致&lt;code&gt;OOM&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;是线程不安全的类，一般不要定义为&lt;code&gt;static&lt;/code&gt;变量，如果定义为&lt;code&gt;static&lt;/code&gt;，必须加锁。【说明：如果是JDK8的应用，可以使用&lt;code&gt;Instant&lt;/code&gt;代替&lt;code&gt;Date&lt;/code&gt;，&lt;code&gt;LocalDateTime&lt;/code&gt;代替&lt;code&gt;Calendar&lt;/code&gt;，&lt;code&gt;DateTimeFormatter&lt;/code&gt;代替&lt;code&gt;SimpleDateFormat&lt;/code&gt;，官方给出的解释：&lt;code&gt;simple beautiful strong immutable thread-safe&lt;/code&gt;。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例：注意线程安全。亦推荐如下处理
private static final ThreadLocal&amp;lt;DateFormat&amp;gt; df = new ThreadLocal&amp;lt;DateFormat&amp;gt;() { 
    @Override 
    protected DateFormat initialValue() { 
        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); 
    } 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;必须回收自定义的&lt;code&gt;ThreadLocal&lt;/code&gt;变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的&lt;code&gt;ThreadLocal&lt;/code&gt;变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量使用&lt;code&gt;try-finally&lt;/code&gt;块进行回收&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
objectThreadLocal.set(userInfo);
try {
    // ...
} finally {
    objectThreadLocal.remove();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明二：如果&lt;code&gt;lock&lt;/code&gt;方法在&lt;code&gt;try&lt;/code&gt;代码块之内，可能由于其它方法抛出异常，导致在 &lt;code&gt;finally&lt;/code&gt;代码块中，&lt;code&gt;unlock&lt;/code&gt;对未加锁的对象解锁，它会调用&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;tryRelease&lt;/code&gt;方法（取决于具体实现类），抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明三：在&lt;code&gt;Lock&lt;/code&gt;对象的&lt;code&gt;lock&lt;/code&gt;方法实现中可能抛出&lt;code&gt;unchecked&lt;/code&gt;异常，产生的后果与说明二相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
Lock lock = new XxxLock();
// ...
lock.lock();
try {
    doSomething();
    doOthers();
} finally {
    lock.unlock();
}

// 反例
Lock lock = new XxxLock();
// ...
try {
    // 如果此处抛出异常，则直接执行 finally 代码块
    doSomething();
    // 无论加锁是否成功，finally 代码块都会执行
    lock.lock();
    doOthers();
} finally {
    lock.unlock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
Lock lock = new XxxLock();
// ...
boolean isLocked = lock.tryLock();
if (isLocked) {
    try {
      doSomething();
      doOthers();
    } finally {
      lock.unlock();
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用&lt;code&gt;version&lt;/code&gt;作为更新依据【说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。】&lt;/li&gt;
&lt;li&gt;多线程并行处理定时任务时，&lt;code&gt;Timer&lt;/code&gt;运行多个&lt;code&gt;TimeTask&lt;/code&gt;时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用&lt;code&gt;ScheduledExecutorService&lt;/code&gt;则没有这个问题&lt;/li&gt;
&lt;li&gt;资金相关的金融敏感信息，使用悲观锁策略。【说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。】&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;CountDownLatch&lt;/code&gt;进行异步转同步操作，每个线程退出前必须调用&lt;code&gt;countDown&lt;/code&gt;方法，线程执行代码注意catch异常，确保&lt;code&gt;countDown&lt;/code&gt;方法被执行到，避免主线程无法执行至&lt;code&gt;await&lt;/code&gt;方法，直到超时才返回结果【说明：注意，子线程抛出异常堆栈，不能在主线程&lt;code&gt;try-catch&lt;/code&gt;到。】&lt;/li&gt;
&lt;li&gt;避免&lt;code&gt;Random&lt;/code&gt;实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一&lt;code&gt;seed&lt;/code&gt;导致的性能下降【说明：&lt;code&gt;Random&lt;/code&gt;实例包括&lt;code&gt;java.util.Random&lt;/code&gt;的实例或者&lt;code&gt;Math.random()&lt;/code&gt;的方式。正例：在JDK7之后，可以直接使用API&lt;code&gt;ThreadLocalRandom&lt;/code&gt;，而在JDK7之前，需要编码保证每个线程持有一个实例】&lt;/li&gt;
&lt;li&gt;在并发场景下，通过双重检查锁&lt;code&gt;（double-checked locking）&lt;/code&gt;实现延迟初始化的优化问题隐患(可参考 The &quot;Double-Checked Locking is Broken&quot; Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为&lt;code&gt;volatile&lt;/code&gt;型。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 注意 这里的代码并非出自官方的《java开发手册》
// 参考 https://blog.csdn.net/lovelion/article/details/7420886
public class LazySingleton { 
    // volatile除了保证内容可见性还有防止指令重排序
    // 对象的创建实际上是三条指令：
    // 1、分配内存地址 2、内存地址初始化 3、返回内存地址句柄
    // 其中2、3之间可能发生指令重排序
    // 重排序可能导致线程A创建对象先执行1、3两步，
    // 结果线程B进来判断句柄已经不为空，直接返回给上层方法
    // 此时对象还没有正确初始化内存，导致上层方法发生严重错误
    private volatile static LazySingleton instance = null; 
 
    private LazySingleton() { } 
    
    public static LazySingleton getInstance() { 
        // 第一重判断
        if (instance == null) {
            synchronized (LazySingleton.class) {
                // 第二重判断
                if (instance == null) {
                    // 创建单例实例
                    instance = new LazySingleton(); 
                }
            }
        }
        return instance; 
    }
}

// 既然这里提到 单例懒加载，还有这样写的
// 参考 https://blog.csdn.net/lovelion/article/details/7420888
class Singleton {
  private Singleton() { }
  
  private static class HolderClass {
  // 由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次
    final static Singleton instance = new Singleton();
  }

  public static Singleton getInstance() {
      return HolderClass.instance;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。【说明：如果是&lt;code&gt;count++&lt;/code&gt;操作，使用如下类实现：&lt;code&gt;AtomicInteger count = new AtomicInteger();&lt;/code&gt; &lt;code&gt;count.addAndGet(1);&lt;/code&gt;如果是JDK8，推荐使用&lt;code&gt;LongAdder&lt;/code&gt;对象，比&lt;code&gt;AtomicLong&lt;/code&gt;性能更好（减少乐观锁的重试次数）。】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;在容量不够进行&lt;code&gt;resize&lt;/code&gt;时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;对象使用&lt;code&gt;static&lt;/code&gt;修饰，&lt;code&gt;ThreadLocal&lt;/code&gt;无法解决共享对象的更新问题【说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量】&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;七-控制语句&quot;&gt;(七) 控制语句&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当&lt;code&gt;switch&lt;/code&gt;括号内的变量类型为&lt;code&gt;String&lt;/code&gt;并且此变量为外部参数时，必须先进行&lt;code&gt;null&lt;/code&gt;判断。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SwitchString {
    
    public static void main(String[] args) {
        // 这里会抛异常 java.lang.NullPointerException
        method(null);
    }
    
    public static void method(String param) {
        switch (param) {
            // 肯定不是进入这里
            case &quot;sth&quot;:
                System.out.println(&quot;it's sth&quot;);
                break;
            // 也不是进入这里
            case &quot;null&quot;:
                System.out.println(&quot;it's null&quot;);
                break;
            // 也不是进入这里
            default:
                System.out.println(&quot;default&quot;);
        } 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (condition) { 
    ...
    return obj; 
} 
// 接着写 else 的业务逻辑代码;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;超过3层的&lt;code&gt;if-else&lt;/code&gt;的逻辑判断代码可以使用&lt;code&gt;卫语句&lt;/code&gt;、&lt;code&gt;策略模式&lt;/code&gt;、&lt;code&gt;状态模式&lt;/code&gt;等来实现。其中卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 示例代码
public void findBoyfriend(Man man) {
  if (man.isUgly()) {
    System.out.println(&quot;本姑娘是外貌协会的资深会员&quot;);
    return;
  }
  if (man.isPoor()) {
    System.out.println(&quot;贫贱夫妻百事哀&quot;);
    return;
  }
  if (man.isBadTemper()) {
    System.out.println(&quot;银河有多远，你就给我滚多远&quot;);
    return;
  }
  System.out.println(&quot;可以先交往一段时间看看&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;除常用方法（如&lt;code&gt;getXxx/isXxx&lt;/code&gt;）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。【说明：很多&lt;code&gt;if&lt;/code&gt;语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 正例
// 伪代码如下
final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;amp;&amp;amp; (...) || (...);
if (existed) {
  ...
}

// 反例
// 哈哈，这好像是ReentrantLock里面有类似风格的代码
// 连Doug Lea的代码都拿来当做反面教材啊
// 早前就听别人说过“编程不识Doug Lea,写尽Java也枉然!!!”
public final void acquire(long arg) {
  if (!tryAcquire(arg) &amp;amp;&amp;amp;
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
      selfInterrupt();
  } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不要在其它表达式（尤其是条件表达式）中，插入赋值语句【说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。】&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 反例
public Lock getLock(boolean fair) {
  // 算术表达式中出现赋值操作，容易忽略 count 值已经被改变
  threshold = (count = Integer.MAX_VALUE) - 1;
  // 条件表达式中出现赋值操作，容易误认为是 sync==fair
  return (sync = fair) ? new FairSync() : new NonfairSync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八-注释规约&quot;&gt;(八) 注释规约&lt;/h3&gt;
&lt;h3 id=&quot;九-其它&quot;&gt;(九) 其它&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度【说明：不要在方法体内定义：&lt;code&gt;Pattern pattern = Pattern.compile(“规则”);&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;Math.random()&lt;/code&gt;这个方法返回是&lt;code&gt;double&lt;/code&gt;类型，注意取值的范围&lt;code&gt;0≤x&amp;lt;1&lt;/code&gt;（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用&lt;code&gt;Random&lt;/code&gt;对象的&lt;code&gt;nextInt&lt;/code&gt;或者&lt;code&gt;nextLong&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;获取当前毫秒数&lt;code&gt;System.currentTimeMillis();&lt;/code&gt;而不是&lt;code&gt;new Date().getTime();&lt;/code&gt;【说明：如果想获取更加精确的纳秒级时间值，使用&lt;code&gt;System.nanoTime()&lt;/code&gt;的方式。在JDK8中，针对统计时间等场景，推荐使用&lt;code&gt;Instant&lt;/code&gt;类。】&lt;/li&gt;
&lt;li&gt;日期格式化时，传入&lt;code&gt;pattern&lt;/code&gt;中表示年份统一使用&lt;code&gt;小写的y&lt;/code&gt;。【说明：日期格式化时，&lt;code&gt;yyyy&lt;/code&gt;表示当天所在的年，而大写的&lt;code&gt;YYYY&lt;/code&gt;代表是 week in which year（JDK7之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的&lt;code&gt;YYYY&lt;/code&gt;就是下一年。另外需要注意：&lt;strong&gt;表示月份是大写的M，表示分钟则是小写的m，24小时制的是大写的H，12小时制的则是小写的h&lt;/strong&gt; 。正例：&lt;code&gt;new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存&lt;/li&gt;
&lt;li&gt;及时清理不再使用的代码段或配置信息【说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(&lt;code&gt;///&lt;/code&gt;)来说明注释掉代码的理由】&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Feb 2020 15:45:00 +0000</pubDate>
<dc:creator>行无际</dc:creator>
<og:description>&amp;quot;Java开发手册版本更新说明&amp;quot; &amp;quot;专有名词解释&amp;quot; &amp;quot;一、 编程规约&amp;quot; &amp;quot;(一) 命名风格&amp;quot; &amp;quot;(二) 常量定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itwild/p/12348087.html</dc:identifier>
</item>
<item>
<title>设计模式的七大原则 - 苏维埃旧人</title>
<link>http://www.cnblogs.com/zh-ch/p/12348061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh-ch/p/12348061.html</guid>
<description>&lt;p&gt;&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;依赖倒转原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;合成复用原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计原则总得来说还是为了让代码尽量的：高内聚、低耦合。提高代码的扩展性，复用性。实际开发中需要平衡开发效率与代码设计的量，设计模式使用过多类和方法细分会越多，导致过于臃肿&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、开闭原则（Open Close Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;开闭原则的意思是：&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;抽象化是开闭原则的关键。想要达到这样的效果，我们需要使用接口和抽象类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、里氏代换原则（Liskov Substitution Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;所有引用基类（父类）的地方必须能透明地使用其子类的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;我的理解就是引用了父类的地方替换成子类不影响代码运行&lt;/p&gt;
&lt;p&gt;使用里氏代换原则需要注意：&lt;/p&gt;
&lt;p&gt;1）子类的多有方法必须在父类中声明，或者子类必须实现父类中声名的所有方法。&lt;/p&gt;
&lt;p&gt;2）尽量把父类设计成抽象类或接口，让子类继承父类或实现父接口。增加一个新功能时，通过增加一个新的子类来实现。&lt;/p&gt;
&lt;p&gt;3）java语言编译时会检查一个程序是否符合里氏代换原则，但只是一个语法意义上的检查，有局限性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、依赖倒转原则（Dependence Inversion Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;简单来说，依赖倒转原则就是指：代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。&lt;/p&gt;
&lt;p&gt;　　实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。&lt;/p&gt;
&lt;p&gt;Spring的DI 就是依赖倒转原则的一个具体实现&lt;/p&gt;
&lt;p&gt;策略模式也遵循依赖倒转原则&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;客户端不应该依赖那些它不需要的接口。&lt;/p&gt;
&lt;p&gt;　　一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;接口隔离原则针对的是接口类，与单一职责原则的区别就是单一原则针对的是实现类，两者区分的维度不一样&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、迪米特法则，又称最少知道原则（Demeter Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) 不要和“陌生人”说话。&lt;/p&gt;
&lt;p&gt;2) 只与你的直接朋友通信。&lt;/p&gt;
&lt;p&gt;3) 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;也是为了降低类之间的耦合，增加局部的内聚，增强扩展性。当一个模块功能独立时，对其进行修改扩展会更加的容易&lt;/p&gt;
&lt;p&gt;在迪米特法则中，对于一个对象，其朋友包括以下几类：&lt;/p&gt;
&lt;p&gt;1) 当前对象本身(this)；&lt;/p&gt;
&lt;p&gt;2) 以参数形式传入到当前对象方法中的对象；&lt;/p&gt;
&lt;p&gt;3) 当前对象的成员对象；&lt;/p&gt;
&lt;p&gt;4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；&lt;/p&gt;
&lt;p&gt;5) 当前对象所创建的对象。&lt;/p&gt;
&lt;p&gt;任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。&lt;/p&gt;
&lt;p&gt;　　迪米特法则可分为狭义法则和广义法则。在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。&lt;/p&gt;
&lt;p&gt;　　狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。&lt;/p&gt;
&lt;p&gt;　　广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;在于控制信息的过载：&lt;/p&gt;
&lt;p&gt;1)在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；&lt;/p&gt;
&lt;p&gt;2)在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；&lt;/p&gt;
&lt;p&gt;3)在类的设计上，只要有可能，一个类型应当设计成不变类；&lt;/p&gt;
&lt;p&gt;4)在对其他类的引用上，一个对象对其他对象的引用应当降到最低。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、合成复用原则（Composite Reuse Principle）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;继承属于高耦合，没有组合/聚合方式灵活。使用继承时需要充分遵循里氏替换原则.&lt;/p&gt;
&lt;p&gt;总之就是能用组合/聚合就不用继承&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、单一职责原则(Single Responsibility Principle, SRP)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;类的职责要单一，不能将太多的职责放在一个类中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;一个类职责越多，被复用的可能性越小，粒度越小越可能被复用。单一原则是针对实现类的设计模式&lt;/p&gt;


&lt;p&gt;参考：https://www.cnblogs.com/WindSun/p/10223080.html&lt;/p&gt;
</description>
<pubDate>Sat, 22 Feb 2020 15:37:00 +0000</pubDate>
<dc:creator>苏维埃旧人</dc:creator>
<og:description>开闭原则 里氏替换原则 依赖倒转原则 接口隔离原则 迪米特法则 合成复用原则 单一职责原则 设计原则总得来说还是为了让代码尽量的：高内聚、低耦合。提高代码的扩展性，复用性。实际开发中需要平衡开发效率与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zh-ch/p/12348061.html</dc:identifier>
</item>
<item>
<title>Java类的加载过程与ClassLoader的理解及测试 - &quot;H&quot;</title>
<link>http://www.cnblogs.com/csyh/p/12347525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csyh/p/12347525.html</guid>
<description>&lt;p&gt;先了解下在程序准备运行某个类，但是该类还没被加载到内存中，会经过以下三个步骤：&lt;/p&gt;
&lt;h4 id=&quot;类的加载load类的连接link类的初始化initialize&quot;&gt;类的加载(Load)→类的连接(Link)→类的初始化(Initialize)&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;：类经过javac.exe编译的.class字节码文件读入内存（将静态数据转换成堆中方法区的运行时数据结构），并为之创建一个java.lang.Class对象作为方法区中类数据的访问入口(引用的地址)，需要访问和使用类数据只能通过这个Class对象；此过程由类的加载器完成；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接&lt;/strong&gt;：将java类的二进制代码合并到JVM的运行状态中的过程；
&lt;ul&gt;&lt;li&gt;验证：确保加载的类符合JVM规范；&lt;/li&gt;
&lt;li&gt;准备：正式为类变量(static)分配内存并设置变量默认初始值（非任何显示赋值），这些内存都在方法区中分配；&lt;/li&gt;
&lt;li&gt;解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;：JVM负责对类进行初始化；
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;执行类构造器()方法的： 此方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的(类构造器是构造类信息的，并非new对象构造器)&lt;/li&gt;
&lt;li&gt;如其父类为进行初始化，则初始化操作从先从父类进行；&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步；&lt;/p&gt;
&lt;h4 id=&quot;类加载器classloader的作用&quot;&gt;类加载器ClassLoader的作用：&lt;/h4&gt;
&lt;p&gt;除了上面提到的作用，还有一个&lt;strong&gt;类缓存&lt;/strong&gt;机制：一旦某个类被加载到内存中，将位置加载(缓存)一段时间，相当于一个缓存了一个Class对象，无论此类创建多少个实例，都是从这唯一的结构中获取信息；GC也可以回收这些Class对象；&lt;br/&gt;JVM规范定义的类的加载器类型如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1778123/202002/1778123-20200222215828183-1948336983.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;加载器关系测试：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
    public void test1() {
        //1.获取一个系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);
        //2.获取系统类加载器的父类加载器，即扩展类加载器
        ClassLoader extensionClassLoader = systemClassLoader.getParent();
        System.out.println(extensionClassLoader);
        //3.获取扩展类加载器的父类加载器，即引导类加载器
        ClassLoader bootstapClassLoader = extensionClassLoader.getParent();
        //引导类加载器用于加载java核心库，无法直接获取，故输出null
        System.out.println(bootstapClassLoader);
        //4.测试当前类由哪个类加载器进行加载
        ClassLoader classLoader = null;
        try {
            classLoader = Class.forName(&quot;Reflection.ClassLoaderTest&quot;).getClassLoader();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(classLoader);//结果为系统类加载器
        //5.测试JDK提供的Object类由哪个类加载器完成
        ClassLoader objClassLoader = null;
        try {
            objClassLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(objClassLoader);//结果为null(说明是用的引导类加载器,我们无法获取）
        //6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取路径下的指定文件的输入流
        InputStream is = null;
        is = this.getClass().getClassLoader().getResourceAsStream(&quot;Reflection\\test.properties&quot;);
        System.out.println(is);
        //可用于读取配置文件，下面单独拿来测试
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;读取.properties配置文件：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void test2(){
        Properties properties = new Properties();//表示一个持久的属性集，可保存在流中或从流中加载
//        //1.获取输入流
//        //方式一：（此时的文件默认路径在Module下）
//        FileInputStream fis = null;
//        try {
//            fis = new FileInputStream(&quot;test.properties&quot;);
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }
        //方式二：使用ClassLoader方式（此时的文件默认路径在当前Module的src下）
        //获取当前类的Class实例对象-获取类加载器-获取指定指定路径下的文件输入流
        InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;test1.properties&quot;);

        //2.读取配置文件
        try {
            //从输入流中读取属性列表（键和元素对）
            properties.load(is);
        } catch (IOException e) {
            e.printStackTrace();
        }
        //匹配对应key的属性，获取key对应的元素值
        String user = properties.getProperty(&quot;user&quot;);
        String password = properties.getProperty(&quot;password&quot;);
        System.out.println(&quot;user = &quot; + user + &quot; , password = &quot; + password);
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Feb 2020 15:31:00 +0000</pubDate>
<dc:creator>&quot;H&quot;</dc:creator>
<og:description>先了解下在程序准备运行某个类，但是该类还没被加载到内存中，会经过以下三个步骤： 类的加载(Load)→类的连接(Link)→类的初始化(Initialize) 加载 ：类经过javac.exe编译的.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csyh/p/12347525.html</dc:identifier>
</item>
<item>
<title>ORB-SLAM2 论文&amp;代码学习 —— 概览 - MingruiYu</title>
<link>http://www.cnblogs.com/MingruiYu/p/12347171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingruiYu/p/12347171.html</guid>
<description>&lt;p&gt;转载请注明出处，谢谢&lt;br/&gt;原创作者：MingruiYU&lt;br/&gt;原创链接：&lt;a href=&quot;https://www.cnblogs.com/MingruiYu/p/12347171.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/MingruiYu/p/12347171.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ORB-SLAM2 简介&lt;/li&gt;
&lt;li&gt;ORB-SLAM2 实体对象之间的关系&lt;/li&gt;
&lt;li&gt;ORB-SLAM2 系统概览 （参考论文 + 代码）&lt;/li&gt;
&lt;li&gt;以思维导图形式绘制的 ORB-SLAM2 程序导图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近准备开始做本科毕业设计，准备对 SLAM 系统中的回环检测模块下手。因为新冠疫情不知道什么时候才能返校，这次放假回家就带了个 matebook 14 回来，搬砖全靠这小电脑，它苦我也苦（流泪）。&lt;/p&gt;
&lt;p&gt;作为开源 SLAM 系统中的经典之一 —— ORB-SLAM2，自然是要拿来好好研究一番。之前阅读了 ORB-SLAM 和 ORB-SLAM2 论文，之后配置安装了 ORB-SLAM2 跑了个 example 看看样子（我的博文 &lt;a href=&quot;https://www.cnblogs.com/MingruiYu/p/12286752.html&quot;&gt;ORB-SLAM2 初体验 —— 配置安装&lt;/a&gt;），这回准备开始磕代码。但越磕越发现，这玩意也太复杂了吧。为了实现较好的鲁棒性，ORB-SLAM2 中加入了很多很多小 trick 来从细节上提升系统的性能。这些细节在论文里往往就是一句话带过，但在代码里就是一大堆环环相扣绕来绕去的东西。虽然大家都说 ORB-SLAM2 的代码是结构清晰，注释完整，易于理解，但本渣渣还是看的把头发挠成了鸟窝状。&lt;/p&gt;
&lt;p&gt;所以，我决定通过写博文的方式，来更好地梳理 ORB-SLAM2 代码的框架和步骤，以加深自己的理解，也希望我的梳理能够对大家有所帮助。&lt;/p&gt;

&lt;p&gt;ORB-SLAM是15年Raul等人提出的一个单目SLAM系统，其在单目SLAM领域影响广泛。详情可见论文：[Monocular] Raúl Mur-Artal, J. M. M. Montiel and Juan D. Tardós. ORB-SLAM: A Versatile and Accurate Monocular SLAM System. IEEE Transactions on Robotics, vol. 31, no. 5, pp. 1147-1163, 2015. (2015 IEEE Transactions on Robotics Best Paper Award). &lt;a href=&quot;http://webdiis.unizar.es/~raulmur/MurMontielTardosTRO15.pdf&quot;&gt;PDF&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;在单目ORB-SLAM的基础上，17年Raul等人又提出了ORB-SLAM2，增加了对于双目相机和RGB相机的支持。详情可见论文：[Stereo and RGB-D] Raúl Mur-Artal and Juan D. Tardós. ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras. IEEE Transactions on Robotics, vol. 33, no. 5, pp. 1255-1262, 2017. &lt;a href=&quot;https://128.84.21.199/pdf/1610.06475.pdf&quot;&gt;PDF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ORB-SLAM2 的论文中，对于单目部分并没有做很大修改，也没有笔墨去重写单目实现的细节。而其虽然增加了双目和 RGB-D 相机的支持，但本质上还是在单目系统的基础上加的，并不是从根本上以双目或 RGB-D 输入为设计出发点。所以个人认为，学习 ORB-SLAM2 还是要以单目为主，不能绕开单目去看双目或 RGB-D 的实现。另外，因为 ORB-SLAM2 论文中并没有重写单目实现的细节，所以对于 ORB-SLAM2 的学习还是要从第一篇 ORB-SLAM 的论文入手。以下内容均以 ORB-SLAM 单目部分为基础。&lt;/p&gt;

&lt;h2 id=&quot;orb-slam2-中的实体对象&quot;&gt;ORB-SLAM2 中的实体对象&lt;/h2&gt;
&lt;p&gt;ORB-SLAM2 中的实体对象包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Frame&lt;/li&gt;
&lt;li&gt;KeyFrame&lt;/li&gt;
&lt;li&gt;MapPoint&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;li&gt;KeyFrame Database&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们之间的关系是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个送入系统的视频帧都会构造一个 Frame&lt;/li&gt;
&lt;li&gt;Frame 中比较重要的会设为 KeyFrame&lt;/li&gt;
&lt;li&gt;每个 Frame 会提取很多 ORB 特征点，每一个 ORB 特征点可能会对应一个 MapPoint&lt;/li&gt;
&lt;li&gt;同一个 MapPoint 会对应多个不同 Frame 中 ORB 特征&lt;/li&gt;
&lt;li&gt;KeyFrames 和 MapPoints 构成了 Map&lt;/li&gt;
&lt;li&gt;重要的 KeyFrame 会存入 KeyFrame Database，用于回环检测和重定位&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;博文中可能出现的简称&quot;&gt;博文中可能出现的简称&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;KF：表示 KeyFrame&lt;/li&gt;
&lt;li&gt;Current KF：表示当前 KeyFrame&lt;/li&gt;
&lt;li&gt;Covisible KF：表示在 Covisibility Graph 中与 Current KF 相连的 KFs&lt;/li&gt;
&lt;li&gt;Loop KF：表示回环 KeyFrame，即和 Current KF 相匹配的 KeyFrame Database 中的 KF&lt;/li&gt;
&lt;li&gt;Candidate KF：表示可能是 Current KF 的 Loop KF 的候选 KF&lt;/li&gt;
&lt;li&gt;Reference KF：表示距离当前帧最近的上一 KF&lt;/li&gt;
&lt;li&gt;KF Database：表示用来存储 KFs 的 Database，这些 KFs 会用于回环检测和重定位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我会从论文和代码（程序导图）两个角度出发，对 ORB-SLAM2 系统进行一个概览。&lt;/p&gt;
&lt;h2 id=&quot;以论文为参考&quot;&gt;以论文为参考&lt;/h2&gt;
&lt;p&gt;ORB-SLAM 论文中，有一张图非常经典且重要：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200222204039109-1788194422.png&quot; width=&quot;60%&quot;/&gt;&lt;/div&gt;
&lt;p&gt;ORB-SLAM 系统同时运行三个线程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tracking 线程：
&lt;ul&gt;&lt;li&gt;对于新读取的帧，提取 ORB 特征&lt;/li&gt;
&lt;li&gt;（系统初始化）&lt;/li&gt;
&lt;li&gt;相机位姿初值估计（根据上一帧 + motion-only BA，或进行重定位）&lt;/li&gt;
&lt;li&gt;局部地图跟踪
&lt;ul&gt;&lt;li&gt;对上一步得到的位姿初值进行进一步 BA 优化&lt;/li&gt;
&lt;li&gt;局部地图：指 Covisibility Graph 中附近的 KFs 及其 MapPoints 所组成的局部的地图&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;决定是否将该帧作为关键帧插入 LocalMapping 线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LocalMapping 线程：
&lt;ul&gt;&lt;li&gt;接收从 Tracking 线程插入的 KF，并进行预处理&lt;/li&gt;
&lt;li&gt;剔除质量较差的 MapPoints&lt;/li&gt;
&lt;li&gt;通过三角化生成新的 MapPoints
&lt;ul&gt;&lt;li&gt;Current KF 未与现有 MapPoints 匹配的 ORB 特征点 与其 Covisible KFs 的特征点进行匹配，并三角化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Local BA&lt;/li&gt;
&lt;li&gt;剔除冗余的局部关键帧&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;LoopClosing 线程
&lt;ul&gt;&lt;li&gt;接收 LoopClosing 送来的筛选处理后的 KF&lt;/li&gt;
&lt;li&gt;检测出一批 Candidate KFs&lt;/li&gt;
&lt;li&gt;计算 Sim3，确定最终的 Loop KF&lt;/li&gt;
&lt;li&gt;进行回环融合&lt;/li&gt;
&lt;li&gt;优化 Essential Graph&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 Covisibility Graph 指的是：其节点为所有 KF。一个 KF，如果它与另一个 KF 观测到的相同的 MapPoints 的数量大于15个，则这两个 KFs 之间有边相连。从而组成了 Covisibility Graph。同时，Covisibility Graph 中的每条边有权重，权重即为两个 KFs 共同观测到的 MapPoints 数目。&lt;/p&gt;
&lt;p&gt;其中 Essential Graph 指的是：系统会构造一个生成树。当一个新的 KF 插入时，将它与(与它观测到相同的 MapPoints 的数量最多的 KF)相连，从而得到一个生成树。Essential Graph = 该生成树 + Covisibility Graph 中权重大于100的边。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1921421/202002/1921421-20200222222705588-1009848870.png&quot; width=&quot;60%&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从上图可以看出，Covisibility Graph 中的边很多，生成树就是一条线，而 Essential Graph 介于两者之间。&lt;/p&gt;
&lt;h2 id=&quot;以代码程序导图为参考&quot;&gt;以代码（程序导图）为参考&lt;/h2&gt;
&lt;p&gt;上面论文里那张框架图概括的非常好，但是这张图还是太简略了，光看它也搞不懂每个步骤之间的逻辑关系是怎样。而它们之间复杂的逻辑关系用大段文字更是很难描述清楚。在通读代码的时候，我经常读着读着就忘了前面读了什么，忘了现在读的部分是嵌套在哪里循环里，是属于哪个子函数。于是我想了个办法 —— 用思维导图来梳理代码的结构和逻辑。试验过后，我觉得这个办法很好用。此处献上我梳理的非常非常大的 ORB-SLAM2 程序导图：&lt;/p&gt;
&lt;p&gt;（如果下方显示不出来，就点 &lt;a href=&quot;https://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/16314155/share/2020-2-22/1582376377/main.svg&quot;&gt;ORB-SLAM2 程序框图&lt;/a&gt; 链接查看吧）&lt;/p&gt;
&lt;p&gt;这个导图梳理的挺详细的了，希望它能对大家有帮助。（我用的 MindMaster 这款画思维导图的软件，Windows Linux ios Andriod 都支持，同时可以将导图存储在个人云上多设备共享，另外也支持生成并分享导图链接）&lt;/p&gt;

&lt;p&gt;我绘制的程序导图是以 mono_tum.cc 程序为入口，该程序是官方提供的 example，其对 TUM 数据集中的视频序列进行 SLAM。根据该程序，我们可以清晰地看出该怎么调用整个 ORB-SLAM2 系统。&lt;/p&gt;
&lt;p&gt;ORB-SLAM2 系统以 System.cc 为系统的入口，其负责创建各种对象，同时创建 Tracking，LocalMapping, LoopCLosing 三个线程并运行。其中，System::TrackMonocular()是启动 Tracking 线程的入口。Tracking 线程为主线程，而 LocalMapping 和 LoopClosing 线程是通过 new thread 创建的。&lt;br/&gt;  &lt;br/&gt; &lt;/p&gt;
&lt;p&gt;关于 Tracking，LocalMapping, LoopCLosing 三个线程的具体内容，我会在以后的博文中进行更为详细的介绍和梳理。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/MingruiYu/p/12286752.html&quot;&gt;ORB-SLAM2 初体验 —— 配置安装&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Feb 2020 15:15:00 +0000</pubDate>
<dc:creator>MingruiYu</dc:creator>
<og:description>本文旨在对 ORB-SLAM2 的论文和代码进行学习，从而在宏观上对 ORB-SLAM2 系统进行概览。在本文中，绘制了一个详尽的思维导图形式的 ORB-SLAM2 程序导图，对 ORB-SLAM2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingruiYu/p/12347171.html</dc:identifier>
</item>
<item>
<title>Ant Design Vue Pro 项目实战-项目初始化（一） - Armys</title>
<link>http://www.cnblogs.com/wzgj/p/12344846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzgj/p/12344846.html</guid>
<description>&lt;blockquote readability=&quot;7.9257195914578&quot;&gt;
&lt;p&gt;    时间真快，转眼又是新的一年。随着前后端技术的不断更新迭代，尤其是前端，在目前前后端分离开发模式这样的一个大环境下，交互性、兼容性等传统的开发模式已经显得有些吃力。之前一直用的是react，随着后面钩子的加入更让人爱不释手，但是整个团队需要更新技术，这里选择了更容易上手的Vue（这里的容易上手并没有歧义，指的是更容易适应），也相信Vue3.0发布后会更好，毕竟没有大公司的限制。选择Vue后很纠结，看了几个框架基本都缺少很多组件、需要自己造轮子。后面决定使用Ant Design Vue（Pro），引用Vue官网的一句话就是“Ant Design Pro 是一个企业级中后台前端/设计解决方案，我们秉承 &lt;a href=&quot;http://ant.design/&quot;&gt;Ant Design&lt;/a&gt; 的设计价值观，致力于在设计规范和基础组件的基础上，继续向上构建，提炼出典型模板/业务组件/配套设计资源，进一步提升企业级中后台产品设计研发过程中的『用户』和『设计者』的体验。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     相关地址：&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;代码(码云镜像)：&lt;a href=&quot;https://gitee.com/sendya/ant-design-pro-vue&quot;&gt;https://gitee.com/sendya/ant-design-pro-vue&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;代码(GitHub)&lt;strong&gt;：&lt;a href=&quot;https://github.com/sendya/ant-design-pro-vue&quot;&gt;https://github.com/sendya/ant-design-pro-vue&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     在线预览地址&lt;/strong&gt;：&lt;a href=&quot;https://preview.pro.loacg.com/user/login?redirect=%2Fdashboard%2Fworkplace&quot;&gt;https://preview.pro.loacg.com/user/login?redirect=%2Fdashboard%2Fworkplace&lt;/a&gt;      （账号/密码：admin/ant.design）&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     官网资料：&lt;a href=&quot;https://pro.loacg.com/docs/getting-started&quot;&gt;https://pro.loacg.com/docs/getting-started&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;     这里直接使用已经造好的前端UI框架这个大轮子，就不多介绍了，具体参考“Ant Design Pro”。&lt;/p&gt;
&lt;p&gt;     我们这里只简单的介绍，我们如何用已经搭建好的Ant Design Vue Pro，稍作改动，实现自己的前端部分。&lt;/p&gt;

&lt;p&gt;     这里只简单说一下前端，后端本次项目用的是.NET Core3.1，不多做介绍&lt;/p&gt;
&lt;p&gt;     前端开发工具：Visual Studio Code,安装&lt;strong&gt;nodejs&lt;/strong&gt;,&lt;strong&gt;yarn&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/common/471316/202002/471316-20200222220102218-964985269.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;325&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/strong&gt; 输入命令：yarn install&lt;br/&gt;    输入命令：yarn run serve&lt;br/&gt;    成功运行后即可打开登录页面&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/common/471316/202002/471316-20200222220322665-2016184720.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    输入账号密码即可进入主页&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;  1、更换显示名称和logo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;/public/favicon.png 替换logo   index.html更改标题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/471316/202002/471316-20200222223449899-1315215161.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/471316/202002/471316-20200222223847616-1347076001.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;strong&gt;  2、更换首页显示图标和名称&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/471316/202002/471316-20200222224126419-1094744480.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    替换后&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/471316/202002/471316-20200222224203136-765727803.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    初始化已经准备好，运行登陆，现在使用的是自带的模拟数据（mock），后续开始配置为本地服务器api....&lt;/p&gt;

</description>
<pubDate>Sat, 22 Feb 2020 14:45:00 +0000</pubDate>
<dc:creator>Armys</dc:creator>
<og:description>写在前面 时间真快，转眼又是新的一年。随着前后端技术的不断更新迭代，尤其是前端，在目前前后端分离开发模式这样的一个大环境下，交互性、兼容性等传统的开发模式已经显得有些吃力。之前一直用的是react，随</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzgj/p/12344846.html</dc:identifier>
</item>
<item>
<title>Time-Frequency Networks For Audio Super-Resolution - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/12345950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/12345950.html</guid>
<description>&lt;p&gt;论文题目：&lt;a href=&quot;http://isle.illinois.edu/sst/pubs/2018/lim18icassp.pdf&quot; target=&quot;_blank&quot;&gt;2018_用于音频超分辨率的时频网络&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客作者：凌逆战&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Time-Frequency Networks For Audio Super-Resolution&quot; href=&quot;https://www.cnblogs.com/LXP-Never/p/12345950.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/LXP-Never/p/12345950.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　音频超分辨率(即带宽扩展)是提高音频信号时域分辨率的一项具有挑战性的任务。最近的一些深度学习方法通过将任务建模为时域或频域的&lt;strong&gt;回归问题&lt;/strong&gt;，取得了令人满意的结果。在本文中，我们提出了一种新的模型体系结构——&lt;span&gt;&lt;strong&gt;时频网络(TFNet，Time-Frequency Network)&lt;/strong&gt;&lt;/span&gt;，这是一种在时域和频域同时进行监控的深度神经网络。我们提出了一种新的模型体系结构，允许两个域共同优化。结果表明，我们的方法在数量和质量上都优于目前最先进的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引术语&lt;/strong&gt;：带宽扩展，音频超分辨率，深度学习&lt;/p&gt;

&lt;p&gt;　　超分辨率(SR)是从低分辨率(LR)输入重建高分辨率(HR)数据的任务。这是一个具有挑战性的任务，因为它是ill-posed的性质，特别是当上采样因子很高的时候。通过处理SR问题，我们可以获得对数据先验的理解，并引导相关领域的改进，如压缩和生成建模。&lt;/p&gt;
&lt;p&gt;　　近年来，图像超分辨率算法在计算机视觉领域得到了广泛的关注，并将SR建模为一种深度神经网络回归任务，取得了显著的成功。在这项工作中，我们探索了音频数据的类似SR任务(即学习从LR到HR音频帧的映射)。为了可视化重建，在图1中我们展示了LR输入、HR重建和ground truth的频谱图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222170844734-1726687593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1：LR输入(频率4kHz以上缺失)，HR重构，HR ground truth。我们的方法成功地从LR音频信号中恢复了高频分量。&lt;/p&gt;
&lt;p&gt;　　Li[1]等人提出了一种深度神经网络来学习频谱幅值从LR到HR的映射，完全忽略缺失的高频分量的相位。在[2]中，Kuleshov等人提出了一种深度神经网络来直接在时域中学习LR到HR的映射。虽然这些模型显示了有希望的结果，但每个模型都只在时域或频域工作，并侧重于信号的不同方面。&lt;strong&gt;&lt;span&gt;目前也只有这两个人提供了代码。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了充分利用时域和频域信息，我们提出了时频网络(TFNet)，它是一种深度神经网络，可以选择何时将时域和频域信息用于音频SR。&lt;/p&gt;
&lt;p&gt;　　乍一看，在频域和时域建模似乎是一个冗余的表示；从Parseval定理可知，预测误差的L2差异，无论是在频域还是在时域都是完全相同的。然而，从LR到HR在时域或频域的回归解决了一个非常不同的问题。在时域上，它类似于图像的超分辨率任务，将音频块从LR映射到HR。另一方面，频域SR与语意图像修复任务类似[3,4]。给定频谱的低频分量，输出高频分量，如图2所示。因此，为了充分利用这两种方法的优点，我们建议在时域和频域内对音频SR进行联合建模。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222170131224-597375929.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2：图像SR的输入输出，语义图像修复，音频SR的时域和频域说明。时域中的音频SR类似于图像SR，其中LR输入中缺少“edges边”。另一方面，谱域音频SR可以看作是谱图的图像修复，即给定底层低频“图像”，对剩余图像进行预测。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;频带扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　语音社区将音频超分辨任务作为带宽扩展进行研究。提出了利用低频[5]估计高频分量的各种方法。如线性映射[6,7]、混合模型[8,9,10]、神经网络[11,12,1,2]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度神经网络的单图像超分辨率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　深度卷积神经网络(CNNs)是目前单图像超分辨率研究的最新进展。已经提出了许多体系结构[13,14,15]。这些模型都是完全卷积的，并带有早些时候的skip / redisual连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度神经网络的语义图像修复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　深度神经网络在语义图像修复任务中也表现出了较强的性能。利用CNNs，[3,4]证明了预测图像中掩蔽区域的可能性。与超级分辨率类似，这些模型也是完全卷积的。从这些模型中获得灵感，我们的深层网络架构也遵循类似的设计原则。&lt;/p&gt;

&lt;p&gt;　　我们将音频SR定义为回归任务，即预测HR音频帧，$y\in \mathbb{R}^L$，给定LR音频帧，$x\in \mathbb{R}^{L/R}$，其中$R$是下采样因子。&lt;/p&gt;
&lt;h2&gt;3.1 时频网络&lt;/h2&gt;
&lt;p&gt;　　我们提出时频网络(TFNet)，这是一个完全可微的网络，可以端到端的训练。如图3所示，设$\Theta $为模型中的所有参数，我们的模型由一个基于全卷积的编码器-解码器网络$H(x; \Theta )$构成。对于给定的LR输入x，H预测HR音频，重建$\hat{z}$和HR频谱幅度$\hat{m}$。利用我们提出的频谱融合层合成最终的输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222195925487-2130072639.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3：时频网络结构。TFNet同时利用时域和频域来完成音频信号的重构，它包含一个明确建模重构频谱幅值的分支，而其他的分支建模重构时域音频。最后将这两个分支的输出与我们的频谱融合层相结合，合成高分辨率的输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频谱融合层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　频谱融合层结合$\hat{z}$和$\hat{m}$输出最终的重建$\hat{y}$，如下图所示：&lt;/p&gt;
&lt;p&gt;$$\begin{aligned} M=&amp;amp; w \odot|\mathscr{F}(\hat{z})|+(1-w) \odot \hat{m} \\ \hat{y} &amp;amp;=\mathscr{F}^{-1}\left(M e^{j \angle \mathscr{F}(\hat{z})}\right) \end{aligned}$$&lt;/p&gt;
&lt;p&gt;其中$\mathscr{F}$表示傅里叶变换，$\odot$是元素的乘法运算，$w$是可训练参数。&lt;/p&gt;
&lt;p&gt;　　这一层是可微的，可以端到端的训练。关键的优点是，该层可强制网络对波形的频谱幅度进行建模，而模型的其余部分可以在时域内建模相位。&lt;/p&gt;
&lt;p&gt;　　我们对网络体系结构的设计是基于这样的观察：卷积层只能捕获局部关系，特别擅长捕获视觉特征。当我们利用短时傅里叶变换对赋值和相位进行可视化处理时，幅值明显的视觉结构，而相位没有，因此，我们只在谱域中对幅值进行建模。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频谱复制器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如前所述，卷积层通常捕获局部关系(即，输入-输出关系的范围受到感受野的限制)。这导致了一个问题，因为我们想要输出的高频分量依赖于输入的低频分量。例如，当向上采样4倍时，接受域至少需要为总频率bin的3/4，这将需要非常大的内核或许多层。为了解决接受域的问题，我们将可用的低频频谱复制到高频频谱中，高频频谱最初都是零，如图4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222200559259-1312771897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4：在4x SR任务上的频谱复制层图解。低频分量被复制四次以替换零&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;损失函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了训练我们的网络，我们利用$l_2$重建损失和权重衰减。总的目标函数是最小化下面关于$\Theta $的损失函数&lt;/p&gt;
&lt;p&gt;$$公式1：\mathcal{L}=\sum_{(x, y) \in \mathcal{D}}\|y-\hat{y}(x)\|_{2}+\lambda\|\Theta\|_{2}$$&lt;/p&gt;
&lt;p&gt;其中$D$是所有（LR，HR）对的训练集，$\lambda $是正则化器的加权超参数，在我们的所有实验中选择为0:0001。&lt;/p&gt;
&lt;h2&gt;3.2、实现细节&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;预处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于训练，我们进行了沉默过滤以丢弃能量阈值为0.05以下的序列脉冲，计算结果A。我们发现这提高了训练的收敛性，并稳定了梯度。对于测试和评估，我们不过滤沉默。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们的网络由两个具有相似架构的分支组成;时域分支和频域分支。为了公平的比较，我们的网络遵循了AudioUNet[2]的架构设计模式，包括编码器和解码器块。为了保持模型大小大致相同，每个分支中的过滤器数量减半。我们的网络以8192段音频作为输入。&lt;/p&gt;
&lt;p&gt;　　对于频域分支，我们对序列进行离散傅里叶变换(DFT)。由于所有的音频信号都是实数，所以我们抛弃了所有负相位的分量，得到了4097个傅立叶系数。最后，求这些系数的大小。&lt;/p&gt;
&lt;p&gt;　　如前所述，输入的高频分量为零，因此使用频谱复制器，我们用低频分量的副本替换零值。具体来说，对于4x上采样，我们在1025到2048、2049到3072和3073到4096重复第1个分量到第1024个分量。第0个分量(直流分量)直接通过网络，最后融合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;训练细节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们使用流行的Adam 优化器[16]来训练我们的网络。初始学习速率为$3e^{-5}$，采用多项式学习速率衰减调度，学习速率为0.5。我们所有的模特都经过了50万步的训练。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据集和准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在两个数据集上评估我们的方法:VCTK数据集[17]和Piano数据集[18]。&lt;/p&gt;
&lt;p&gt;　　VCTK数据集包含来自109个以英语为母语的人的语音数据。每个说话人会读出大约400个不同的句子，每个说话人的句子也不同，总共有44个小时的语音数据。&lt;/p&gt;
&lt;p&gt;　　根据之前的工作[2]，我们将数据分为88%的培训6%的验证和6%的测试，没有说话人重叠。&lt;/p&gt;
&lt;p&gt;　　对于数据集中的每个文件，我们通过以目标较低采样率的奈奎斯特速率执行带截止频率的低通滤波器，将音频重采样到较低的采样率。然后通过双三次插值将LR序列向上采样到原始速率。为了编制训练(LR, HR)对，我们从重采样信号及其对应的原始信号中提取了8192个重叠度为75%的样本长度子序列。　　&lt;/p&gt;
&lt;p&gt;　　对于采样速率为16kHz的VCTK数据集，它对应的子序列约为500ms，每个子序列的起始距离为125ms。剩下的50%的序列会被丢弃，因为得到的数据集太大，无法有效地训练。&lt;/p&gt;
&lt;p&gt;　　此外，为了了解模型的性能是否会受到数据多样性的影响，我们建立了一个新的数据集(VCTKs)，它只包含说话者VCTK的一个子集。这包括大约30分钟的演讲。音频数据以16kHz的采样率提供。&lt;/p&gt;
&lt;p&gt;　　钢琴数据集包含10小时的贝多芬奏鸣曲，采样率为16kHz。由于音乐的重复性，我们在文件级别上对Piano数据集进行了分割以进行公平的评估。&lt;/p&gt;
&lt;h2&gt;评估&lt;/h2&gt;
&lt;p&gt;为了进行评价，我们计算了信噪比(SNR)和对数谱距离(LSD)的相似性度量。&lt;/p&gt;
&lt;p&gt;　　在时域内，信噪比捕获了预测和fround-truth数据之间的加权差。另一方面，LSD在频域[19]捕获预测与fround-truth之间的差异。&lt;/p&gt;
&lt;p&gt;$$公式2：\mathrm{LSD}(y, \hat{y})=\frac{10}{L} \sum_{l=1}^{L}\left\|\log _{10} \mathscr{F}\left(y_{l}\right)-\log _{10} \mathscr{F}\left(\hat{y}_{l}\right)\right\|_{2}$$&lt;/p&gt;
&lt;p&gt;其中下标$l$表示音频短窗口段的索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据表1中[1,2]的结果，我们将我们的方法与三个不同的基线、一个简单的双三次插值和两个深度网络方法进行了比较。特别地，我们实验了不同的下采样率，从4x开始，在这里质量的下降变得清晰可见。对于VCTK，我们的方法在4倍上采样的情况下比基线方法的信噪比大约高出1.5dB。8倍上采样甚至比基线 6倍上采样结果高1.5dB SNR。在Piano数据集上，我们的方法性能与基线方法相当。需要注意的是，在[2]中的参数数量与我们的模型相同；这进一步证明了我们的model架构在表达上更加有效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222223224412-513847528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表1：对不同上采样率下的测试集进行定量比较。左/右结果为信噪比/LSD。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i1/1433301/202002/1433301-20200222223307309-1025799240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表2：消融研究，评估时域和谱域各分支的性能。左/右结果为信噪比/LSD。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　此外，为了确认我们的网络架构同时利用了时域和频域，我们进行了消融(ablation)研究。我们通过移除时域或频域分支来评估模型性能，如表2所示。对于谱支，我们假设重构时高频分量为零相位。&lt;/p&gt;

&lt;p&gt; 　　本文提出了一种时频网络(TFNet)，这是一种深度卷积神经网络，利用时域和频域来实现音频的超分辨。与现有方法相比，我们的新型频谱复制和融合层具有更好的性能。最后，TFNet已经证明了具有冗余表示有助于对音频信号进行建模。我们认为该方法的经验结果是有趣的和有前途的，这为进一步的理论和数值分析提供了依据。此外，我们希望将此观察推广到其他音频任务，例如音频生成，目前最先进的WaveNet[20]是一种时域方法。&lt;/p&gt;

&lt;p&gt;[1] Kehuang Li, Zhen Huang, Yong Xu, and Chin-Hui Lee,“Dnn-based speech bandwidth expansion and its application to adding high-frequency missing features for automatic speech recognition of narrowband speech,” in Proc. INTERSPEECH, 2015.&lt;br/&gt;[2] Volodymyr Kuleshov, S Zayd Enam, and Stefano Ermon,“Audio super-resolution using neural networks,”, 2017.&lt;br/&gt;[3] Deepak Pathak, Philipp Kr¨ahenb¨uhl, Jeff Donahue,Trevor Darrell, and Alexei Efros, “Context encoders:Feature learning by inpainting,” in Computer Vision and Pattern Recognition (CVPR), 2016.&lt;br/&gt;[4] Raymond A. Yeh, Chen Chen, Teck Yian Lim,Schwing Alexander G., Mark Hasegawa-Johnson, and Minh N. Do, “Semantic image inpainting with deep generative models,” in Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017, equal contribution.&lt;br/&gt;[5] Bernd Iser and Gerhard Schmidt, “Bandwidth extension of telephony speech,” Speech and Audio Processing in Adverse Environments, pp. 135–184, 2008.&lt;br/&gt;[6] Yoshihisa Nakatoh, Mineo Tsushima, and Takeshi Norimatsu,“Generation of broadband speech from narrowband speech using piecewise linear mapping,” in Fifth European Conference on Speech Communication and Technology, 1997.&lt;br/&gt;[7] Yoshihisa Nakatoh, Mineo Tsushima, and Takeshi Norimatsu,“Generation of broadband speech from narrowband speech based on linear mapping,” Electronics and Communications in Japan (Part II: Electronics), vol. 85,no. 8, pp. 44–53, 2002.&lt;br/&gt;[8] Geun-Bae Song and Pavel Martynovich, “A study of hmm-based bandwidth extension of speech signals,” Signal Processing, vol. 89, no. 10, pp. 2036–2044, 2009.&lt;br/&gt;[9] Hyunson Seo, Hong-Goo Kang, and Frank Soong, “A maximum a posterior-based reconstruction approach to speech bandwidth expansion in noise,” in Acoustics,Speech and Signal Processing (ICASSP), 2014 IEEE International Conference on. IEEE, 2014, pp. 6087–6091.&lt;br/&gt;[10] Saeed Vaseghi, Esfandiar Zavarehei, and Qin Yan, “Speech bandwidth extension: Extrapolations of spectral envelop and harmonicity quality of excitation,” in Acoustics, Speech and Signal Processing, 2006. ICASSP 2006 Proceedings. 2006 IEEE International Conference on. IEEE, 2006, vol. 3, pp. III–III.&lt;br/&gt;[11] Juho Kontio, Laura Laaksonen, and Paavo Alku, “Neural network-based artificial bandwidth expansion of speech,” IEEE transactions on audio, speech, and language processing, vol. 15, no. 3, pp. 873–881, 2007.&lt;br/&gt;[12] Bernd Iser and Gerhard Schmidt, “Neural networks versus codebooks in an application for bandwidth extension of speech signals,” in Eighth European Conference on Speech Communication and Technology, 2003.&lt;br/&gt;[13] Chao Dong, Chen Change Loy, Kaiming He, and Xiaoou Tang, “Image super-resolution using deep convolutional networks,” IEEE Trans. Pattern Anal. Mach.Intell., vol. 38, no. 2, pp. 295–307, Feb. 2016.&lt;br/&gt;[14] Jiwon Kim, Jung Kwon Lee, and Kyoung Mu Lee, “Accurate image super-resolution using very deep convolutional networks,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR Oral), June 2016.&lt;br/&gt;[15] Wei-Sheng Lai, Jia-Bin Huang, Narendra Ahuja, and Ming-Hsuan Yang, “Deep laplacian pyramid networks for fast and accurate super-resolution,” in IEEE Conference on Computer Vision and Pattern Recognition,2017.&lt;br/&gt;[16] Diederik Kingma and Jimmy Ba, “Adam: A method for stochastic optimization,” arXiv preprint arXiv:1412.6980, 2014.&lt;br/&gt;[17] Junichi Yamagishi, “English multi-speaker corpus for cstr voice cloning toolkit,” http://homepages.inf.ed.ac.uk/jyamagis/page3/page58/page58.html, 2012.&lt;br/&gt;[18] Soroush Mehri, Kundan Kumar, Ishaan Gulrajani,Rithesh Kumar, Shubham Jain, Jose Sotelo, Aaron Courville, and Yoshua Bengio, “Samplernn: An unconditional end-to-end neural audio generation model,”2016, cite arxiv:1612.07837.&lt;br/&gt;[19] Augustine Gray and John Markel, “Distance measures for speech processing,” IEEE Transactions on Acoustics,Speech, and Signal Processing, vol. 24, no. 5, pp.380–391, 1976.&lt;br/&gt;[20] Aron van den Oord, Sander Dieleman, Heiga Zen,Karen Simonyan, Oriol Vinyals, Alexander Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu,“Wavenet: A generative model for raw audio,” in Arxiv,2016.&lt;/p&gt;

</description>
<pubDate>Sat, 22 Feb 2020 14:42:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>论文题目：2018_用于音频超分辨率的时频网络 博客作者：凌逆战 博客地址：https://www.cnblogs.com/LXP-Never/p/12345950.html 摘要 音频超分辨率(即带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/12345950.html</dc:identifier>
</item>
<item>
<title>C++ 类的赋值运算符'='重载 - cainiaozjz</title>
<link>http://www.cnblogs.com/rookiezjz/p/12347628.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rookiezjz/p/12347628.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/winston/archive/2008/06/03/1212700.html&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么类需要重载赋值运算符&quot;&gt;什么类需要重载赋值运算符&lt;/h2&gt;
&lt;p&gt;先来看一个普通类的直接赋值。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class person{
    int age;
public:
    person(const int&amp;amp; a=10):age(a){}  //构造函数
    ~person();  //析构函数
    void showAdd();   //打印age的地址
};

person::~person(){cout&amp;lt;&amp;lt;&quot;析构\n&quot;;}

void person::showAdd() {cout &amp;lt;&amp;lt;hex&amp;lt;&amp;lt; &amp;amp;age&amp;lt;&amp;lt;endl;}

int main() {
    person a(11);
    person b;
    b = a;
    a.showAdd();
    b.showAdd();
    return 0;
}
/*
结果是：
0x7fffffffdc5c
0x7fffffffdc60
析构
析构
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222220233553-747275996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是这个程序的内存情况，一切都运行的很正常，不需要运算符重载。&lt;/p&gt;
&lt;p&gt;看下边这个例子，这个类的构造函数需要申请（new）堆内存：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class person{
    int* age;
public:
    person(const int&amp;amp; a=10);  //构造函数
    ~person();  //析构函数
    void showAdd();   //打印age的地址
    void show();  //打印age指向的值
    void set(const int&amp;amp; a){*age=a;}
};

person::person(const int&amp;amp; a) {age = new int(a);}

person::~person(){delete age; cout&amp;lt;&amp;lt;&quot;析构\n&quot;;}

void person::showAdd() {cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; age&amp;lt;&amp;lt;endl;}

void person::show() {cout&amp;lt;&amp;lt;*age&amp;lt;&amp;lt;endl;}

void f(person&amp;amp; a) {
    person b;
    b=a;
    a.show();
    b.show();
    a.showAdd();
    b.showAdd();
    //因为b是局部变量，所以进入main函数之前，b会自动调用析构函数
}

int main() {
    person a(11);
    f(a);
    cout&amp;lt;&amp;lt;&quot;进入main函数\n&quot;;
    a.set(9);  //因为b已经释放过age指针，set应该会出错
    a.show();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222220331020-1644788507.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是这个程序进入 f() 函数时的内存情况，两个age指针指向同一块内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222220535656-1262848184.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是这个程序退出 f() 函数进入main函数的情况，因为b是局部变量，所以f()函数结束的时候，b会调用析构函数，释放age指向的堆内存。这时候a.set()就会发生错误，因为内存已经释放，无权修改内存里的值。就算没有set()函数，main函数结束的时候还会产生doublefree的错误，同一块内存被释放两次，C++文档说明这是个未定义行为，所以不同编译器可能处理手段不一样，我的gcc 7.4.0 竟然没有报错。后来我又在网上的一些在线编译器实验一下，有的会报错，有的不会。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以结论就是：类的构造函数需要申请堆内存的时候，我们要进行赋值运算符的重载，下面讲如何重载。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何重载赋值运算符&quot;&gt;如何重载赋值运算符&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class person{
    int* age;
public:
    person(const int&amp;amp; a=10);  //构造函数
    ~person();  //析构函数
    void showAdd();   //打印age的地址
    void show();  //打印age指向的值
    void set(const int&amp;amp; a){*age=a;}  //设置age指向的值

    void operator=(person const&amp;amp; e);  //重载赋值运算符
};

void person::operator=(person const&amp;amp; e)
{
    if(age) delete age;  //如果原先age申请过堆内存，要先释放
    int data = *(e.age);
    age = new int(data);
}

person::person(const int&amp;amp; a) {age = new int(a);}

person::~person(){delete age; cout&amp;lt;&amp;lt;&quot;析构\n&quot;;}

void person::showAdd() {cout &amp;lt;&amp;lt; hex &amp;lt;&amp;lt; age&amp;lt;&amp;lt;endl;}

void person::show() {cout&amp;lt;&amp;lt;*age&amp;lt;&amp;lt;endl;}

void f(person&amp;amp; a) {
    person b;
    b = a;  //这时候b指向了一块新的空间
    a.show();
    b.show();
    a.showAdd();
    b.showAdd();
    //因为b是局部变量，所以进入main函数之前，b会自动调用析构函数
}

int main() {
    person a(11);
    f(a);
    cout&amp;lt;&amp;lt;&quot;进入main函数\n&quot;;
    a.set(9);  //因为b释放的指针和age指向不一样，set不会出错
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222220659818-204769225.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行正常，内存图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222220823281-1982449956.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意上边我用的operator=返回值是void, 这样不能进行连续赋值，比如：&lt;code&gt;person a = b = c;&lt;/code&gt; ,若想连续赋值，返回值要声明为 引用&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;person&amp;amp; person::operator=(person const&amp;amp; e)
{
    if(age) delete age; 
    int data = *(e.age);
    age = new int(data);
    return *this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于拷贝函数&quot;&gt;关于拷贝函数&lt;/h2&gt;
&lt;p&gt;再回看一下上边的代码，我的声明语句和赋值语句是分开的&lt;code&gt;person b; b=a;&lt;/code&gt;,如果声明时赋值&lt;code&gt;person b=a;&lt;/code&gt;，那么调用的函数就不是&lt;code&gt;operator=&lt;/code&gt;了，而是拷贝函数&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class person{
    int* age;
public:
    person(person const&amp;amp; e);  //这就是拷贝函数 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是： &lt;span&gt;上边说的operator返回值有两种情况：void和引用，其实还有第三种，既然能返回引用那就还能返回值：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;person person::operator=(person const&amp;amp; e)
{
    if(age) delete age; 
    int data = *(e.age);
    age = new int(data);
    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数返回值的时候会临时构造一个&lt;code&gt;person&lt;/code&gt;变量, 这个变量的&lt;code&gt;age&lt;/code&gt;的指向和调用&lt;code&gt;operator=&lt;/code&gt;的对象的&lt;code&gt;age&lt;/code&gt;指向一样，也就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1742389/202002/1742389-20200222221113690-1694951796.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;operator=&lt;/code&gt;调用完之后，临时变量会调用析构函数，从而导致和上边一样的错误，doublefree。所以&lt;code&gt;operator=&lt;/code&gt;的返回值最好是引用！&lt;/p&gt;
</description>
<pubDate>Sat, 22 Feb 2020 14:22:00 +0000</pubDate>
<dc:creator>cainiaozjz</dc:creator>
<og:description>&amp;quot;参考&amp;quot; 什么类需要重载赋值运算符 先来看一个普通类的直接赋值。 cpp include using namespace std; class person{ int age; p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rookiezjz/p/12347628.html</dc:identifier>
</item>
<item>
<title>通过 Serverless 加速 Blazor WebAssembly - Elder_James</title>
<link>http://www.cnblogs.com/ElderJames/p/run-blazor-webassembly-on-serverless.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ElderJames/p/run-blazor-webassembly-on-serverless.html</guid>
<description>&lt;p&gt;我正在开发 Ant Design 的 Blazor 版本，预览页面部署在 Github Pages 上，但是加载速度很不理想，往往需要 1 分钟多钟才完成。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/ElderJames/ant-design-blazor&quot; class=&quot;uri&quot;&gt;https://github.com/ElderJames/ant-design-blazor&lt;/a&gt; 求 Star。&lt;/p&gt;
&lt;p&gt;当寻求解决方案时，了解到了 Serverless 可以轻松地部署静态网站到腾讯云的对象存储服务上，经过尝试之后，体验非常好！访问速度就变成了 3 秒钟，心想 Blazor 与 Serverless 结合后，是一定能成功的。&lt;/p&gt;
&lt;h2 id=&quot;blazor-webassembly-简介&quot;&gt;Blazor WebAssembly 简介&lt;/h2&gt;
&lt;p&gt;Blazor 是 .NET 实现的前端框架，它使一套代码可分别支持服务端 WebSocket 双向绑定或者是运行在 WebAssembly上。Blazor WebAssembly 可以让开发者使用跟熟悉的 Razor 模版同样的开发模型，来开发基于 WebAssembly 的 SPA 应用。目前 Blazor WebAssembly 已经是在 WebAssembly 领域中发展得最完善的 Web 框架。&lt;/p&gt;
&lt;h2 id=&quot;serverless-简介&quot;&gt;Serverless 简介&lt;/h2&gt;
&lt;p&gt;Serverless 是开发者和企业用户共同推动的,它可以使开发者在构建和运行应用时无需管理服务器等基础设施，将构建应用的成本进一步降低，函数是部署和运行的基本单位。&lt;/p&gt;
&lt;p&gt;开发者无需关心底层资源即可部署完整可用的 Serverless 应用架构。&lt;/p&gt;

&lt;h2 id=&quot;前置准备&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;安装.NET Core SDK 3.1.2 以上版本 &lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装模版&quot;&gt;安装模版&lt;/h2&gt;
&lt;p&gt;Blazor WebAssembly 目前还在 preview 阶段，所以正式发布的.NET Core SDK 还没有内置模版，但是我们可以手动安装模版。&lt;/p&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new -i Microsoft.AspNetCore.Blazor.Templates::3.2.0-preview1.20073.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new blazorwasm -o BlazorServerless&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在 BlazorServerless 已经创建好了 Web WebAssembly 应用。我们进入目录，运行 &lt;code&gt;dotnet run&lt;/code&gt; ，访问 &lt;code&gt;https://localhost:5001&lt;/code&gt; 就能浏览了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd BlazorServerless
dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/blazor_serverless/blazor.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，加载时要加载 2.1MB 的文件，首次加载时对网速的压力还是很大的。如果部署在境外，例如 Github Pages，可能就需要等上好几分钟了。&lt;/p&gt;
&lt;p&gt;所幸，我们可以用 Serverless 把它部署到国内服务器上，解决了加载问题。&lt;/p&gt;
&lt;h2 id=&quot;发布项目&quot;&gt;发布项目&lt;/h2&gt;
&lt;p&gt;现在，我们需要发布这个项目，生成需要部署的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet publish -o publish&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，&lt;code&gt;publish\BlazorServerless\dist&lt;/code&gt; 目录里的文件就是我们需要部署的文件了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/blazor_serverless/publish.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;前置准备-1&quot;&gt;前置准备&lt;/h2&gt;
&lt;p&gt;首先确保系统包含以下环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi&quot;&gt;Node.js&lt;/a&gt; (Node.js 版本需不低于 8.6，建议使用最新版本)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装-serverless-cli&quot;&gt;安装 serverless cli&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;npm install -g serverless&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Windows 系统上，如果报错，错误提示是&lt;code&gt;因为在此系统上禁止运行脚本...&lt;/code&gt;，那么请执行命令开启 &lt;code&gt;.ps1&lt;/code&gt; 脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set-ExecutionPolicy RemoteSigned&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加配置文件&quot;&gt;添加配置文件&lt;/h2&gt;
&lt;p&gt;现在，需要在上面我们的发布目录 &lt;code&gt;publish\BlazorServerless&lt;/code&gt; （跟 &lt;code&gt;dist&lt;/code&gt; 目录同级）中，创建 &lt;code&gt;serverless.yml&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# serverless.yml

blazor-wasm:
  component: &quot;@serverless/tencent-website&quot;
  inputs:
    code:
      src: ./dist # Upload static files
      index: index.html
      error: index.html
    region: ap-guangzhou
    bucketName: blazor-bucket&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，如果我们部署的是依赖路由系统的 SPA 站点，&lt;code&gt;error&lt;/code&gt; 项也要指向 &lt;code&gt;index.html&lt;/code&gt;，这样在直接访问子路由时，还能回到index页面加载路由。否则会有 404 错误。&lt;/p&gt;
&lt;p&gt;配置完成后，文件目录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/BlazorServerless
  ├── publish/BlazorServerless
  |    ├── dist
  |    |   ├── _framework
  |    |   ├── css
  |    |   ├── sample-data
  |    |   └── index.html
  |    └── serverless.yml
  └── README.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/blazor_serverless/yml.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三部署并浏览&quot;&gt;三、部署并浏览&lt;/h2&gt;
&lt;p&gt;在上图所示，即 &lt;code&gt;serverless.yml&lt;/code&gt; 文件所在目录下，通过 &lt;code&gt;serverless&lt;/code&gt; 命令进行部署，添加 --debug 参数查看部署详情：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;serverless --debug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这个目录是第一次授权，或者没有创建环境变量文件设置授权信息，则会出现一个二维码，不管有没有注册过腾讯云，都能通过微信扫码授权开通，非常方便。&lt;/p&gt;
&lt;p&gt;以下是输入以上命令后的控制台的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS D:\code\net\blazor\BlazorServerless\publish\BlazorServerless&amp;gt; serverless --debug

  DEBUG ─ Resolving the template's static variables.
  DEBUG ─ Collecting components from the template.
  DEBUG ─ Downloading any NPM components found in the template.
  DEBUG ─ Analyzing the template's components dependencies.
  DEBUG ─ Creating the template's components graph.
  DEBUG ─ Syncing template state.
  DEBUG ─ Executing the template's components graph.

(此处会出现二维码)

Please scan QR code login from wechat. 
Wait login...
Login successful for TencentCloud. 
  DEBUG ─ Preparing website Tencent COS bucket blazor-bucket-1256169759.
  DEBUG ─ Bucket &quot;blazor-bucket-1256169759&quot; in the &quot;ap-guangzhou&quot; region already exist.
  DEBUG ─ Setting ACL for &quot;blazor-bucket-1256169759&quot; bucket in the &quot;ap-guangzhou&quot; region.
  DEBUG ─ Ensuring no CORS are set for &quot;blazor-bucket-1256169759&quot; bucket in the &quot;ap-guangzhou&quot; region.
  DEBUG ─ Ensuring no Tags are set for &quot;blazor-bucket-1256169759&quot; bucket in the &quot;ap-guangzhou&quot; region.
  DEBUG ─ Configuring bucket blazor-bucket-1256169759 for website hosting.
  DEBUG ─ Uploading website files from D:\code\net\blazor\BlazorServerless\publish\BlazorServerless\dist to bucket blazor-bucket-1256169759.
  DEBUG ─ Starting upload to bucket blazor-bucket-1256169759 in region ap-guangzhou
  DEBUG ─ Uploading directory D:\code\net\blazor\BlazorServerless\publish\BlazorServerless\dist to bucket blazor-bucket-1256169759
  DEBUG ─ Website deployed successfully to URL: http://blazor-bucket-1256169759.cos-website.ap-guangzhou.myqcloud.com.

  blazor-wasm: 
    url: http://blazor-bucket-1256169759.cos-website.ap-guangzhou.myqcloud.com
    env: 

  116s » blazor-wasm » done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，最后出现绿色的 Done 字样，就说明部署成功了！访问给出的url，就能看到部署在腾讯云对象存储服务中的站点了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/blazor_serverless/deploy.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问时加载速度非常快！&lt;/p&gt;
</description>
<pubDate>Sat, 22 Feb 2020 14:12:00 +0000</pubDate>
<dc:creator>Elder_James</dc:creator>
<og:description>Blazor ❤ Serverless 我正在开发 Ant Design 的 Blazor 版本，预览页面部署在 Github Pages 上，但是加载速度很不理想，往往需要 1 分钟多钟才完成。 项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ElderJames/p/run-blazor-webassembly-on-serverless.html</dc:identifier>
</item>
<item>
<title>SpringProfile轻松切换多环境配置文件 - 后青春期的Keats</title>
<link>http://www.cnblogs.com/keatsCoder/p/12347382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keatsCoder/p/12347382.html</guid>
<description>&lt;p&gt;在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring 为我们提供了一种多环境配置文件同时存在，而运行/打包时仅运行所选的配置文件的方式。具体的介绍如下：&lt;/p&gt;
&lt;h3 id=&quot;spring提供了两种属性&quot;&gt;Spring提供了两种属性：&lt;/h3&gt;
&lt;h4 id=&quot;spring.profiles.active&quot;&gt;spring.profiles.active&lt;/h4&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  profiles:
#    active: yaya
    active: keats&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定激活哪个文件，值是 application-{profileName}.yml 中的 profileName。&lt;strong&gt;用于区分不同的运行环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PS：如果 application.yml 和被激活的 yml 中同时配置了一个相同的键，被激活的yml中的值会覆盖 application.yml 中的值。&lt;/p&gt;
&lt;h4 id=&quot;spring.profiles.include&quot;&gt;spring.profiles.include&lt;/h4&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  profiles:
    include: yayaDB,yayaRedis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定包含(合并)多个yml的内容一起启动。这样有助于&lt;strong&gt;同环境下yml文件的分类管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS：像上面 include 值是多个的情况，除了使用 , 分隔的输入方式外，还可以使用 换行 - profileName 的方式，这是 yml 的一种语法。如果不清楚 yml 的语法，可以参考 &lt;a href=&quot;https://www.cnblogs.com/keatsCoder/p/11321756.html&quot;&gt;SpringBoot入门及YML文件详解&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  profiles:
    include:
      - yayaDB # 注意换行和空格
      - yayaRedis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是一个示例的DEMO项目，项目的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202002/1654189-20200222213614582-1509656106.png&quot; alt=&quot;1582377859097&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各文件内容如下：&lt;/p&gt;
&lt;p&gt;application.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  profiles:
    active: yaya
#    active: keats
server:
  port: 9001 # 如果被激活的 yml 中有相同的配置，会覆盖此值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application-keats.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;server:
  port: 9000
eureka:
  server:
    enable-self-preservation: false # 关闭自我保护
    eviction-interval-timer-in-ms: 4000 # 剔除服务间隔，单位/ms
  instance:
    hostname: localhost
  client:
    register-with-eureka: false # 是否将自己注册到注册中心
    fetch-registry: false # 是否从Eureka中获取注册信息
    service-url: # Eureka Client 的请求地址
      defaultZone: http://#{eureka.instance.hostname}:#{server.port}/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application-yaya.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  profiles:
    include: yayaDB,yayaRedis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application-yayaDB.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# 专门配置DB 的yml，实际项目中可以根据需求，配置文件多了需要分类就分类，少了用不着分类就一种环境一个YML# 这里因为Eureka服务用不到连接数据库，用端口号配置信息代替
server: 
  port: 9100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application-yayaRedis.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# 可以专门用来配置Redis的信息。这里因为用不到Redis。我就用除端口以外的其他配置信息填充了
eureka:
  server:
    enable-self-preservation: false # 关闭自我保护
    eviction-interval-timer-in-ms: 4000 # 剔除服务间隔，单位/ms
  instance:
    hostname: localhost
  client:
    register-with-eureka: false # 是否将自己注册到注册中心
    fetch-registry: false # 是否从Eureka中获取注册信息
    service-url: # Eureka Client 的请求地址
      defaultZone: http://#{eureka.instance.hostname}:#{server.port}/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照以上的 yml 配置之后，就可以通过注释与放开不同的 active，来实现环境的切换了。&lt;/p&gt;
&lt;p&gt;顺便教大家另外一个技能：&lt;/p&gt;
&lt;h3 id=&quot;idea将同一个项目多次启动&quot;&gt;Idea将同一个项目多次启动&lt;/h3&gt;
&lt;p&gt;选择对应的项目启动类，点击 Edit Configurations&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202002/1654189-20200222213614147-1017827321.png&quot; alt=&quot;1582378343139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;取消勾选： Single instance only&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/202002/1654189-20200222213613338-1643349068.png&quot; alt=&quot;1582378399992&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Feb 2020 13:38:00 +0000</pubDate>
<dc:creator>后青春期的Keats</dc:creator>
<og:description>﻿在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring 为我们提供了一种多环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keatsCoder/p/12347382.html</dc:identifier>
</item>
</channel>
</rss>