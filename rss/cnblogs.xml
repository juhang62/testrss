<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>shiro入门学习--使用MD5和salt进行加密|练气后期 - 赖柄沣</title>
<link>http://www.cnblogs.com/bingfengdev/p/13779955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingfengdev/p/13779955.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/bingfengdev/p/13775968.html&quot;&gt;《Shiro入门学习---使用自定义Realm完成认证|练气中期》&lt;/a&gt;当中，我们学会了使用自定义Realm实现shiro数据源的切换，我们可以切换成从关系数据库如MySQL中读取用户认证信息进行认证，亦可从非关系型数据库例如mongodb中读取用户认证信息进行认证。这是一个伟大的进度，这使得我们可以使用shiro来提升我们应用程序的安全度了，&lt;/p&gt;
&lt;p&gt;那么，请大家思考一个问题，我们的应用程序真的安全了吗？&lt;/p&gt;
&lt;p&gt;我把咱么上一篇文章当中的认证方法代码摘抄在下面给大家看看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**认证
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @date 2020-10-04 11:01:50
 * @param authenticationToken
 * @return org.apache.shiro.authz.AuthorizationInfo
 * @throws AuthenticationException
 * @version 1.0
 */
@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
    // 1. 从token中获取用户名
    String principal = (String) authenticationToken.getPrincipal();

    //2. 根据用户名查询数据库并封装成authenticationinfo对象返回(模拟)
    if (principal == &quot;xiangbei&quot;) {
        AuthenticationInfo authInfo = new SimpleAuthenticationInfo(&quot;xiangbei&quot;,&quot;123&quot;,this.getName());
        return authInfo;
    }

    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在16行当中，我们模拟从数据库当中查询出了用户的注册信息，包括账户和密码，并且这里的&lt;strong&gt;密码是明文的&lt;/strong&gt;。这意味着如果我们的用户密码被泄露了（这里用户原因导致的泄露除外），那么一些不友好的朋友将可以随意的进出我们的系统。这不但让我们的应用程序变得不安全，而且还会让我们面临法律风险。&lt;/p&gt;
&lt;p&gt;以下内容摘自《网络安全法》&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;第三十四条 网络运营者应当&lt;strong&gt;建立健全用户信息保护制 度，加强对用户个人信息、隐私和商业秘密的保护&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第三十五条 网络运营者收集、使用公民个人信息，应当 遵循合法、正当、必要的原则，明示收集、使用信息的目 的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的公民个人 信息，不得违反法律、行政法规的规定和双方的约定收 集、使用公民个人信息，&lt;strong&gt;并应当依照法律、行政法规的规 定或者与用户的约定，处理其保存的公民个人信息。&lt;/strong&gt; 网络运营者收集、使用公民个人信息，应当公开其收 集、使用规则。&lt;/p&gt;
&lt;p&gt;第三十六条 网络运营者对其收集的公民个人信息必须严 格保密，不得泄露、篡改、毁损，不得出售或者非法向他 人提供。 &lt;strong&gt;网络运营者应当采取技术措施和其他必要措施，确保 公民个人信息安全，防止其收集的公民个人信息泄露、毁 损、丢失。&lt;/strong&gt;在发生或者可能发生信息泄露、毁损、丢失的 情况时，应当立即采取补救措施，告知可能受到影响的用 户，并按照规定向有关主管部门报告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我们需要对用户信息进行加密保护。对于账户密码信息，我们应该采取不可逆的加密方式。也就是说，我们对密码进行加密存储后，哪怕其获取了我们的密文，他也不能得到我们的密码明文。这样就对我们的用户信息起到了一个很好的保护作用。&lt;/p&gt;
&lt;h2 id=&quot;md5加密算法和salt盐值加密&quot;&gt;MD5加密算法和salt盐值加密&lt;/h2&gt;
&lt;h3 id=&quot;md5加密算法&quot;&gt;MD5加密算法&lt;/h3&gt;
&lt;h4 id=&quot;什么是md5加密&quot;&gt;什么是MD5加密&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MD5信息摘要算法&lt;/strong&gt;（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E8%8A%82/1096318&quot;&gt;字节&lt;/a&gt;）的散列值（hash value），用于确保信息传输完整一致。&lt;/p&gt;
&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;不可逆，也就是说其本身上不能由密文推出明文，&lt;/p&gt;
&lt;p&gt;但是，如果明文比较简单常见，还是存在泄露风险，例如先生成好简单明文的密文，然后使用穷举法进行破解；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于同一个明文，无论加密多少次其密文都是一样的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生成的结果始终是一个16进制的32位字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;作用&quot;&gt;作用&lt;/h4&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;数字签名（校验和）&lt;/p&gt;
&lt;p&gt;例如对于一份文件，为了保证网络传输当中不发生改变，我提前对其用md5加密算法进行加密，得到一段密文。我将这份文件和密文分别发给你。你在收到文件后也对其使用md5加密一次，得到一个密文。这时，你就可以比较两个密文是否一致，如果一致，则文件没有被篡改，反之，文件已经被篡改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;垃圾邮件筛选&lt;/p&gt;
&lt;p&gt;原理和作用1一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;salt盐值加密策略&quot;&gt;salt盐值加密策略&lt;/h3&gt;
&lt;p&gt;在上面的介绍md5加密算法时我们讲到，虽然MD5算法本身不可逆，但是如果用户采用简单的字符串作为密码的话，仍然有被暴力破解的风险。因此，为了解决这个问题，我们需要在对密码加密之前使其变得复杂化。&lt;/p&gt;
&lt;p&gt;而加盐就是其中的一种方式。所谓的加盐就是在原密码的基础上，加上一段随机字符串。然后再加密。&lt;/p&gt;
&lt;p&gt;当然，如果盐值随着密码一起被泄露出去，也是存在着密码被破解的风险的，我们只能做到相对安全。&lt;/p&gt;
&lt;p&gt;为了增加破解难度，可以在加盐时采取一定的策略，例如哈希加盐、加密后多次哈希。&lt;/p&gt;
&lt;p&gt;当然，这要在安全跟性能直接做个平衡。&lt;/p&gt;
&lt;h2 id=&quot;shiro使用md5salt加密&quot;&gt;shiro使用MD5+salt加密&lt;/h2&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;在进行编码之前，我们需要理一下流程：&lt;/p&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;用户注册或系统分配账户时，服务层在接收到账号和凭证信息后，先对凭证信息采用md5+salt进行加密处理，然后将账号、加密后的密码还有盐值存入数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;用户登录请求接收后，先根据请求中的账号查询数据库：&lt;/p&gt;
&lt;p&gt;2.1 如果没有查到，直接返回“用户名或密码错误”的类似提示&lt;/p&gt;
&lt;p&gt;2.2 如果查到了账户信息，就执行步骤3；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将账号和加盐后凭证封装成AuthenticationInfo对象返回给shiro，shiro执行步骤4&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对请求中的凭证进行加盐处理并执行步骤5&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;对加盐后的凭证进行md5加密，并将密文跟数据库当中的存储的密文进行比对：&lt;/p&gt;
&lt;p&gt;5.1 如果匹配成功，则认证通过&lt;/p&gt;
&lt;p&gt;5.2 如果匹配失败，则返回“用户名或密码错误”的类似提示&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;h4 id=&quot;编写自定义realm并切换掉默认的凭证匹配器&quot;&gt;编写自定义Realm并切换掉默认的凭证匹配器&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**自定义Realm对象
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:00
 */
public class MySqlRealm extends AuthorizingRealm {

    public MySqlRealm() {
        //设置凭证匹配器，修改为hash凭证匹配器
        HashedCredentialsMatcher myCredentialsMatcher = new HashedCredentialsMatcher();
        //设置算法
        myCredentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);
        //散列次数
        myCredentialsMatcher.setHashIterations(1024);
        this.setCredentialsMatcher(myCredentialsMatcher);
    }

    /**授权
     * @author 赖柄沣 bingfengdev@aliyun.com
     * @date 2020-10-04 11:01:50
     * @param principalCollection
     * @return org.apache.shiro.authz.AuthorizationInfo
     * @throws AuthenticationException
     * @version 1.0
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {

        return null;
    }

    /**认证
     * @author 赖柄沣 bingfengdev@aliyun.com
     * @date 2020-10-04 11:01:50
     * @param authenticationToken
     * @return org.apache.shiro.authz.AuthorizationInfo
     * @throws AuthenticationException
     * @version 1.0
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 1. 从token中获取用户名
        String principal = (String) authenticationToken.getPrincipal();

        //2. 根据用户名查询数据库并封装成authenticationinfo对象返回(模拟)
        if (principal == &quot;xiangbei&quot;) {
            //四个参数分别是数据库中的账号、加密后的密码、盐值、realm名字
            AuthenticationInfo authInfo = new SimpleAuthenticationInfo(&quot;xiangbei&quot;,
                    &quot;ff595c47b51b4cf70fddce090f68879e&quot;,
                    ByteSource.Util.bytes(&quot;ee575f62-0dda-44f2-b75e-4efef795018f&quot;),
                    this.getName());
            return authInfo;
        }

        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;编写认证器&quot;&gt;编写认证器&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**认证管理器
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:11
 */
public class CurrentSystemAuthenticator {
    private DefaultSecurityManager securityManager;
    public CurrentSystemAuthenticator() {
        //创建安全管理器
        securityManager = new DefaultSecurityManager();

        //设置自定义realm
        this.securityManager.setRealm(new MySqlRealm());

        //将安全管理器设置到安全工具类中
        SecurityUtils.setSecurityManager(securityManager);

    }

    public void authenticate(String username,String password) {
        //获取当前登录主题
        Subject subject = SecurityUtils.getSubject();

        //生成toeken
        UsernamePasswordToken token = new UsernamePasswordToken(username, password);

        //进行认证
        try {
            subject.login(token);
        }catch (UnknownAccountException | IncorrectCredentialsException e) {
            System.out.println(&quot;用户名或密码不正确&quot;);
        }


        //打印认证状态
        if (subject.isAuthenticated()){
            System.out.println(token.getPrincipal()+&quot; 认证通过！&quot;);
        }else {
            System.out.println(token.getPrincipal()+&quot; 认证未通过！&quot;);
        }





    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;测试&lt;/h4&gt;
&lt;h5 id=&quot;生成加密后的密码&quot;&gt;生成加密后的密码&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 21:37
 */
public class Md5Test {

    @Test
    public void testMd5(){
        //三个参数分别对应密码明文、盐值、散列次数
        String salt = UUID.randomUUID().toString();
        Md5Hash md5Hash = new Md5Hash(&quot;123&quot;, salt,1024);
        System.out.println(&quot;密文：&quot;+md5Hash.toHex());
        System.out.println(&quot;盐值：&quot;+salt);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;密文：ff595c47b51b4cf70fddce090f68879e
盐值：ee575f62-0dda-44f2-b75e-4efef795018f
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;进行认证测试&quot;&gt;进行认证测试&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/10/4 11:20
 */
public class AuthcTest {
    private CurrentSystemAuthenticator authenticator;
    @Before
    public void init() {
        this.authenticator = new CurrentSystemAuthenticator();
    }

    @Test
    public void testAuthc(){
        this.authenticator.authenticate(&quot;xiangbei&quot;,&quot;123&quot;);
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xiangbei 认证通过！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;在这篇文章当中，我们主要是简单了解了shiro中的加密策略以及如何使用MD5+salt对密码进行加密。大家可以尝试着将MD5换成SHA-256加密算法再测一下。&lt;/p&gt;
&lt;p&gt;在下一篇文章当中，作者将介绍SpringBoot整合Shiro的相关内容，文章可能有点长，会考虑分两次写。请大家多多关注。&lt;/p&gt;
&lt;p&gt;欢迎大家点赞、转发、分享。转载注明出处时要带有原文链接。&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 16:12:00 +0000</pubDate>
<dc:creator>赖柄沣</dc:creator>
<og:description>写在前面 在上一篇文章《Shiro入门学习 使用自定义Realm完成认证|练气中期》当中，我们学会了使用自定义Realm实现shiro数据源的切换，我们可以切换成从关系数据库如MySQL中读取用户认证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingfengdev/p/13779955.html</dc:identifier>
</item>
<item>
<title>spring-boot-route（八）整合mybatis操作数据库 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13779876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13779876.html</guid>
<description>&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;h2 id=&quot;通过注解完成数据操作&quot;&gt;通过注解完成数据操作&lt;/h2&gt;
&lt;p&gt;第一步：引入mysql依赖和mybatis依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;LATEST&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：新建学生表及对应的实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;CREATE TABLE `student` (
   `student_id` int(30) NOT NULL AUTO_INCREMENT,
   `age` int(1) DEFAULT NULL COMMENT '年龄',
   `name` varchar(45) DEFAULT NULL COMMENT '姓名',
   `sex` int(1) DEFAULT NULL COMMENT '性别：1：男，2：女，0：未知',
   `create_time` datetime DEFAULT NULL COMMENT '创建时间',
   `status` int(1) DEFAULT NULL COMMENT '状态：1：正常，-1：删除',
   PRIMARY KEY (`student_id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=617354 DEFAULT CHARSET=utf8mb4 CHECKSUM=1 DELAY_KEY_WRITE=1 ROW_FORMAT=DYNAMIC COMMENT='学生表'
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student implements Serializable {

    private static final long serialVersionUID = 6712540741269055064L;

    private Integer studentId;
    private Integer age;
    private String name;
    private Integer sex;
    private Date createTime;
    private Integer status;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：配置数据库连接信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/simple_fast
    username: root
    password: root
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;增删改查&quot;&gt;增删改查&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Mapper
public interface StudentMapper {

    @Select(&quot;select * from student where student_id = #{studentId}&quot;)
    Student findById(@Param(&quot;studentId&quot;) Integer studentId);

    @Insert(&quot;insert into student(age,name) values(#{age},#{name})&quot;)
    int addStudent(@Param(&quot;name&quot;) String name,@Param(&quot;age&quot;) Integer age);

    @Update(&quot;update student set name = #{name} where student_id = #{studentId}&quot;)
    int updateStudent(@Param(&quot;studentId&quot;) Integer studentId,@Param(&quot;name&quot;) String name);

    @Delete(&quot;delete from student where student_id = #{studentId}&quot;)
    int deleteStudent(@Param(&quot;studentId&quot;) Integer studentId);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面演示的传参方式是通过单个参数传递的，&lt;strong&gt;如果想通过Map或实体类传参数，就不需要使用@Param来绑定参数了，将map中的key或者实体类中的属性与sql中的参数值对应上就可以了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;通过xml配置完成数据操作&quot;&gt;通过XML配置完成数据操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;@Mapper和@MapperScan&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@Mapper加在数据层接口上，将其注册到ioc容器上，@MapperScan加在启动类上，需要指定扫描的数据层接口包。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Mapper
public interface StudentMapper {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@MapperScan(&quot;com.javatrip.mybatis.mapper&quot;)
public class MybatisApplication {
    public static void main(String[] args) {
        SpringApplication.run(MybatisApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个注解的作用一样，在开发中为了方便，通常我们会使用@MapperScan。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定mapper.xml的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mybatis:
  mapper-locations: classpath:mybatis/*.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;开启数据实体映射驼峰命名&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mybatis:
  configuration:
    map-underscore-to-camel-case: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编写xml和与之对应的mapper接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.javatrip.mybatis.mapper.StudentXMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;findById&quot; resultType=&quot;com.javatrip.mybatis.entity.Student&quot;&amp;gt;
        select * from student where student_id = #{studentId}
    &amp;lt;/select&amp;gt;
    &amp;lt;insert id=&quot;addStudent&quot; parameterType=&quot;com.javatrip.mybatis.entity.Student&quot;&amp;gt;
        insert into student(name,age) values(#{name},#{age})
    &amp;lt;/insert&amp;gt;
    
    &amp;lt;update id=&quot;updateStudent&quot; parameterType=&quot;com.javatrip.mybatis.entity.Student&quot;&amp;gt;
        update student set name = #{name} where  student_id = #{studentId}
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;Integer&quot;&amp;gt;
        delete from student where student_id = #{studentId}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Mapper
public interface StudentXMapper {

    Student findById(@Param(&quot;studentId&quot;) Integer studentId);

    int addStudent(Student student);

    int updateStudent(@Param(&quot;studentId&quot;) Integer studentId,@Param(&quot;name&quot;) String name);

    int deleteStudent(@Param(&quot;studentId&quot;) Integer studentId);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编写测试类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest
class MybatisApplicationTests {

    @Autowired
    StudentMapper mapper;

    @Autowired
    StudentXMapper xMapper;

    @Test
    void testMapper() {

        Student student = mapper.findById(10);
        mapper.addStudent(&quot;Java旅途&quot;,19);
        mapper.deleteStudent(31);
        mapper.updateStudent(10,&quot;Java旅途&quot;);
    }

    @Test
    void contextLoads() {
        
        Student student = xMapper.findById(10);
        Student studentDo = new Student();
        studentDo.setAge(18);
        studentDo.setName(&quot;Java旅途呀&quot;);
        xMapper.addStudent(studentDo);
        xMapper.deleteStudent(32);
        xMapper.updateStudent(31,&quot;Java旅途&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有几个需要注意的点：mapper标签中namespace属性对应的是mapper接口；select标签的id对应mapper接口中的方法名字；select标签的resultType对应查询的实体类，使用全路径。&lt;/p&gt;
&lt;p&gt;此是spring-boot-route系列的第八篇文章，这个系列的文章都比较简单，主要目的就是为了帮助初次接触Spring Boot 的同学有一个系统的认识。本文已收录至我的&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;github&lt;/a&gt;，欢迎各位小伙伴&lt;code&gt;star&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;：&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;https://github.com/binzh303/spring-boot-route&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;点关注、不迷路&quot;&gt;点关注、不迷路&lt;/h2&gt;
&lt;p&gt;如果觉得文章不错，欢迎&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;，你们的支持是我创作的动力，感谢大家。&lt;/p&gt;
&lt;p&gt;如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。&lt;/p&gt;
&lt;p&gt;如果你还想更加深入的了解我，可以微信搜索「&lt;strong&gt;Java旅途&lt;/strong&gt;」进行关注。回复「&lt;strong&gt;1024&lt;/strong&gt;」即可获得学习视频及精美电子书。每天7:30准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 15:40:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13779876.html</dc:identifier>
</item>
<item>
<title>sqli-labs第3-4关 详解 - junlebao</title>
<link>http://www.cnblogs.com/junlebao/p/13779759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junlebao/p/13779759.html</guid>
<description>&lt;p&gt;通过第二关，来到第三关&lt;/p&gt;
&lt;p&gt;我们用了前两种方法，都报错，然后自己也不太会别的注入，然后莫名的小知识又增加了。这居然是一个带括号的字符型注入，&lt;/p&gt;
&lt;p&gt;这里我们需要闭合前面的括号。&lt;/p&gt;
&lt;p&gt;$sql=select * from users where id=(&quot;$id&quot;);&lt;/p&gt;
&lt;p&gt;但我们传入的id为5')然后我们的语句就变成了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2075370/202010/2075370-20201007225032758-1067863982.png&quot; alt=&quot;&quot; width=&quot;957&quot; height=&quot;294&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 而且页面显示正常，然后我们就去判断字段的列数，这个跟前三关应该是一样的 ，我们直接&lt;/p&gt;
&lt;p&gt;pyload: ?id=5')order by 4--+&lt;/p&gt;
&lt;p&gt;然后判断3的时候，没有报错，于是确定列数为3，具体为什么要确定列数，在第一个wp中有提到，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/junlebao/p/13758919.html&quot;&gt;https://www.cnblogs.com/junlebao/p/13758919.html&lt;/a&gt;点击这个就可以看到关于联合查询的知识点了&lt;/p&gt;
&lt;p&gt;我们用联合查询，所以我们要保证列数字段一致，如果不一致则会报错。&lt;/p&gt;
&lt;p&gt;下面我们贴出源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
&amp;lt;title&amp;gt;Less-4 Error Based- DoubleQuotes String&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body bgcolor=&quot;#000000&quot;&amp;gt;
&amp;lt;div style=&quot; margin-top:60px;color:#FFF; font-size:23px; text-align:center&quot;&amp;gt;Welcome   &amp;lt;font color=&quot;#FF0000&quot;&amp;gt; Dhakkan &amp;lt;/font&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;font size=&quot;3&quot; color=&quot;#FFFF00&quot;&amp;gt;


&amp;lt;?php
//including the Mysql connect parameters.
include(&quot;../sql-connections/sql-connect.php&quot;);
error_reporting(0);
// take the variables
if(isset($_GET['id']))
{
$id=$_GET['id'];
//logging the connection parameters to a file for analysis.
$fp=fopen('result.txt','a');
fwrite($fp,'ID:'.$id.&quot;\n&quot;);
fclose($fp);

// connectivity 

$id = '&quot;' . $id . '&quot;';
$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;
$result=mysql_query($sql);
$row = mysql_fetch_array($result);//函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false
&lt;/pre&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
    if($row)
        {
        echo &quot;&amp;lt;font size='5' color= '#99FF00'&amp;gt;&quot;;
        echo 'Your Login name:'. $row['username'];
        echo &quot;&amp;lt;br&amp;gt;&quot;;
        echo 'Your Password:' .$row['password'];
        echo &quot;&amp;lt;/font&amp;gt;&quot;;
        }
        else 
        {
        echo '&amp;lt;font color= &quot;#FFFF00&quot;&amp;gt;';
        print_r(mysql_error());
        echo &quot;&amp;lt;/font&amp;gt;&quot;;  
        }
}
        else { echo &quot;Please input the ID as parameter with numeric value&quot;;}

?&amp;gt;

&amp;lt;/font&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;/br&amp;gt;&amp;lt;center&amp;gt;
&amp;lt;img src=&quot;../images/Less-4.jpg&quot; /&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看源码里面的函数，我给了注释，这就是为什么我们要将id的值给-1，我们需要将前面的数据便为空集，然后我们后面的数据就会呈现出来。&lt;/p&gt;
&lt;p&gt;说完了这个，我们接着下一步操作：&lt;/p&gt;
&lt;p&gt;1. 爆库名　　?id=-1') union select 1,2,database()--+&lt;/p&gt;
&lt;p&gt;2. 爆表名　　?id=-1') union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+&lt;/p&gt;
&lt;p&gt;3. 爆字段　　?id=-1') union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'--+&lt;/p&gt;
&lt;p&gt;4. 爆数据　　?id=-1') union select 1,2,group_concat(0x5c,username,0x5c,password) from users--+&lt;/p&gt;
&lt;p&gt;然后就查到了我们想要的users表中的数据了。&lt;/p&gt;
&lt;p&gt; 之后我们又来到了第四关，发现第四关只是将单引号变成了双引号了，所以我们&lt;/p&gt;
&lt;p&gt;pyload：?id=5&quot;)--+&lt;/p&gt;
&lt;p&gt;然后发现页面正常显示，没有报错，于是我们用order by来判断列数，步骤和第三题一样。&lt;/p&gt;
&lt;p&gt;希望可以对读者有帮助，不对的希望大家多多指正，大家共同进步。&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 15:06:00 +0000</pubDate>
<dc:creator>junlebao</dc:creator>
<og:description>通过第二关，来到第三关 我们用了前两种方法，都报错，然后自己也不太会别的注入，然后莫名的小知识又增加了。这居然是一个带括号的字符型注入， 这里我们需要闭合前面的括号。 $sql=select * fr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/junlebao/p/13779759.html</dc:identifier>
</item>
<item>
<title>java 线程池、多线程并发实战(生产者消费者模型 1 vs 10) 附案例源码 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13756921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13756921.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 50728
 Source Host           : localhost:3306
 Source Schema         : middle

 Target Server Type    : MySQL
 Target Server Version : 50728
 File Encoding         : 65001

 Date: 07/10/2020 22:42:55
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt;&lt;span&gt; NAMES utf8mb4;
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Table structure for student&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `student`;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `student` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;主键&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `sex` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `address` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `department` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `add_time` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据进入中间表时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `data_status` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I:第三方系统入库；D:处理中；F:处理完成；E:发生错误或异常&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `deal_time` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;处理时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Records of student&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;
&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `student` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;英语系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:25&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:26&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `student` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;女&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:25&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:26&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `student` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;天津&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;计算机系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:25&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-10-07 22:19:26&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; FOREIGN_KEY_CHECKS &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;</description>
<pubDate>Wed, 07 Oct 2020 15:00:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 前二天写了一篇《Java 多线程并发编程》点我直达，放国庆，在家闲着没事，继续写剩下的东西，开干！ 线程池 为什么要使用线程池 例如web服务器、数据库服务器、文件服务器或邮件服务器之类的。请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13756921.html</dc:identifier>
</item>
<item>
<title>2020年的一些思考和总结 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/13779683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/13779683.html</guid>
<description>&lt;p&gt;首先这篇文章不等于”2020年总结”，因为2020年还没有完全结束，还有近两个多月的时间。通常来说，我的2020年总结会在2021年初以及2020年末写的，内容格式都是今年计划完成情况+来年计划制定等。&lt;/p&gt;
&lt;p&gt;国庆假期游山玩水了四五天，该玩的都玩了，没玩的，等有时间了再计划。&lt;/p&gt;
&lt;p&gt;每年在某个特定的时候，总感觉要写些什么东西。&lt;/p&gt;
&lt;p&gt;就像在2018年的时候，感触非常深，写下了这篇&lt;a href=&quot;https://www.cnblogs.com/youcong/p/9862712.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;作为程序员的思考与反省&lt;/a&gt;，&lt;br/&gt;再然后创业公司近两年的经历，写下了这么几篇关键性的文章(对于我挺关键的):&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/youcong/p/12153262.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;创业公司这两年&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/youcong/p/10933433.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;致所有的开发者们&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/youcong/p/10162609.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;如何成为一名全栈开发工程师&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/youcong/p/10016594.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;谈谈在创业公司的几点感触&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至于其它关于技术方面的，感兴趣的，可以在我这个博客地址上搜索:&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/youcong/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/youcong/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的文笔并不那么好，有的时候写起来有点题内不符合(标题和内容不一样，当然了，我也尝试过不断改进，还是有效果的)，但都是我的真情实感的流露和一些痛定思痛的经历。&lt;/p&gt;
&lt;p&gt;前文稍微啰嗦了一些，接下来进入正题:&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;一-我对技术的思考&quot;&gt;一、我对技术的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;记得在第一家公司的时候，我的技术栈是单薄的，就会前端(写一些简单的HTML、CSS、javascript等)，再加主攻Java后端(Spring+SpringMVC+MyBatis+JSP),再加数据库(MySQL)。&lt;br/&gt;基本上能干一些活，但这些活又不能太核心关键，太核心关键的写不了。&lt;br/&gt;那个时候我的思维比较狭隘，信奉”唯技术论”(技术高于业务，技术高于一切)，那个时候之所以如此，关键在于接触的太少，经历的太少。&lt;/p&gt;
&lt;p&gt;第一家公司是一家外包公司，专做CRM、ERP等之类的解决方案。在这家公司我做过运维、测试、项目实施等(其实间接也为我在第二家公司，也就是创业公司做准备)。那个时候，在我眼里还是技术始终是第一位(只想埋头弄技术写代码，其它都不管)。&lt;/p&gt;
&lt;p&gt;而后来到创业公司后，这个时候，全栈就是我的目标，因为创业公司资金有限，各方面都不是很完善，一个人常常身兼多职，就拿开发人员为例，我是做Java后端开发的，但在创业公司就要求我必须会写前端，再然后，项目第一个版本发布，为了确保领导试用时不出差错，这个时候我们编写好测试用例，然后按照业务流程一个个功能性测试和业务性测试，再然后发布到公网环境对外开放(实际是对老板那边的员工开放，让其体验使用)。&lt;/p&gt;
&lt;p&gt;在创业公司，我是开发、运维、测试、产品都做。但仍然有所偏重，技术仍然是第一位的，对于我来说，技术是产品的基石，没有技术，产品仅仅是蓝图(&lt;strong&gt;其实后来想想，并非如此,业务才是基础(包含商业模式等)-&amp;gt;产品蓝图或原型-&amp;gt;技术手段实现&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;在创业公司我做过物联网平台(智能酒店、智能门锁、共享洗浴间等)、电商二次开发(类似淘宝、京东)、教育产品(编程教育为主)等三个领域的项目，除了教育产品稍有起色之外，其它全部死掉了。那个时候对我的打击很大(不仅仅是我，整个团队的士气也很低下，大家对未来一切迷茫)，一年零九个月的时间，没有一个项目(除教育项目外)真正的实现盈利(&lt;strong&gt;盈利也意味着成功验证商业模式的可行性&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;最初的时候，哪怕我身兼多职，我给自己的定位仍然是一名埋头写代码的程序员，而非产品的创造者(从产品的创造者角度来看，一方面如何让产品更完善，另外一方面如何更好的提高用户粘性，这需要不断思考和实践)。于是我放弃了对产品的思考，那个时候我觉得这是高层的事情(领导的事情)，与我无关，拿一份工资，干一份活(更何况做这么多事情，还只拿一份工资)(大家可以思考这个问题，接下来下面的内容的可能会给出答案)。&lt;/p&gt;
&lt;p&gt;再回到这个主题来，&lt;strong&gt;“我对技术的思考核心两点”&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 业务是基础，产品是蓝图，而技术是将蓝图变成现实的手段；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 技术的本质在于解决问题(回顾人类历史，很多技术创新发明都是在某个领域解决了什么样的问题，或者是在多个领域解决类似的问题)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过三家关键性公司的磨练，更加坚定了上述两点(因为这两点，让一家创业公司(前教育saas公司)从弱小走向强大(年盈利几十万几百万到上千万，有上市的潜力),也让一家公司从有到无，从无到有，危机重重)。&lt;/p&gt;
&lt;p&gt;因为上述列出的核心两点(我对技术的思考):&lt;br/&gt;使我不再刻意的去追求新的技术，当然了，作为一名技术工程师而言，我会不断去学习新的技术，学习新的思想和理念。但在学习的过程中，我不再像过去那样，因为学习一个新技术，就觉得自己很牛逼，沾沾自喜，似乎超过了N多人，我会更关注新技术优点特性(适应的业务场景是什么)、缺点(没有技术是完美的，都有缺点(包含局限性)、设计理念和思想等。&lt;/p&gt;
&lt;p&gt;简单概括这几年的项目技术架构经历:&lt;br/&gt;单体应用(外包、创业)-&amp;gt;前后端分离实践(创业)-&amp;gt;变相微服务实践(创业）-&amp;gt;分布式微服务实践初级(教育saas)-&amp;gt;分布式微服务实践全权把控(当前所在公司)&lt;/p&gt;
&lt;p&gt;总的来说，走了很多弯路，填了很多坑。走弯路和填坑的原因，有很多。虽然都说，成长就是经历，有些坑是无法避免的。但其实有不少是我自己的独断专制造成的，这一点我至今仍要反思(虽然目前没有犯类似的错误，但我仍要反思，反思的目的，在于不能再走老路了，同时也是为了让新路更加通顺)。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;二-我对学习的思考&quot;&gt;二、我对学习的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;人从出生就开始不断学习，从走路到识字，再到独立生活和工作，再到生儿育女等。&lt;/p&gt;
&lt;p&gt;我在博客园写了800多篇的博客文章，最开始我没想写这个:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;觉得没时间(最大的理由是工作太累不想写，懒惰)；&lt;/li&gt;
&lt;li&gt;觉得没意义没价值(最大的理由是有很多现成的，人家写好了，我为什么还要写呢，不想重复造轮子)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一切源于我的导师，他当初给我说过这样的话(导师说过话很多，我也记不清，但核心的意思是这样的):&lt;br/&gt;&lt;strong&gt;写作的目的，不仅仅在培养形成解决问题的良性循环，同时更关键在于培养自己深度思考和善于总结的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的写作和我的学习历程很相近。我的博客写了800多篇文章，大多是技术学习和问题解决等内容，少部分是一些职业思考、读书新的/笔记等内容。&lt;/p&gt;
&lt;p&gt;我的写作间接反映出我是一个持之以恒且热爱技术、热爱学习的人，但同样也反映出我在学习过程中的很多不足。&lt;/p&gt;
&lt;p&gt;以下是写作中暴露的问题(这里就不谈写的语句通顺方面的问题):&lt;br/&gt;&lt;strong&gt;1. 欠缺较为深度的文章；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 刻意练习过于简单；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3. 读书笔记欠缺自己的思考；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4. 解决问题类问题欠缺较为详细的错误原因分析(为什么会报错，原因是什么等，缺乏对错误原因的深究)。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;1欠缺较为深度的文章&quot;&gt;1.欠缺较为深度的文章&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;深度的文章在于思考，思考的关键在于提问。&lt;br/&gt;爱因斯坦曾说过，提出问题比解决问题更重要。&lt;br/&gt;我觉得原因应该是因为提出问题能让思维更加发散，思维发散能让视野更加广阔(因为它可以让人从多个角度来看问题)。&lt;/p&gt;
&lt;p&gt;深度的文章在于深度思考(思考的关键在于多提问)。&lt;/p&gt;
&lt;p&gt;我的导师曾用《论语》中一句话，来概述我目前所存在的问题，&lt;strong&gt;“学而不思则罔，思而不学则殆”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这句话的解释如下:&lt;br/&gt;&lt;strong&gt;指的是一味读书而不思考，就会因为不能深刻理解书本的意义而不能合理有效利用书本的知识，甚至会陷入迷茫。而如果一味空想而不去进行实实在在地学习和钻研，则终究是沙上建塔，一无所得。告诫我们只有把学习和思考结合起来，才能学到切实有用的知识，否则就会收效甚微。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于学习提问，很多人不知道提出什么样的问题才是好的问题，我个人觉得刚刚开始不应该执着于这个，越是执着，越难以落地。刚刚开始，应该在于做。&lt;strong&gt;就像我当初写博客那样，如果我一昧的以高质量作为前提的话(而忽略自身实际情况)，恐怕很难坚持到现在，任何事情都是一个循序渐进的过程，不能揠苗助长。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在写的过程中，每天一点一滴的积累，有读者朋友会提出一些问题启发我思考，也有像我导师这样的，指出我写作欠缺深度。&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;2刻意练习过于简单&quot;&gt;2.刻意练习过于简单&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;《异类》的作者马尔科姆·格拉德威尔说过这样的话:&lt;br/&gt;&lt;strong&gt;“人们眼中的天才之所以卓越不凡，并非天资超人一等，而是付出了持续不断的努力。只要经过1万小时的锤炼，任何人都能从平凡变成超凡。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以写博客文章为例，当初我在写学习类的教程文章时，不乏有这样的意识，&lt;strong&gt;“只要我将例子正常运行并写出相应的步骤来，加上笔记记录，我就能充分地掌握这门技术框架。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但事实真的如此吗？&lt;/strong&gt;&lt;br/&gt;然而并不是这样。基于上述这种意识，我学习了Python和Node.js，我的学习步骤很简单，例子敲一遍，正常运行出来，然后记点笔记，遇到错误，记录错误。经过这样的步骤，然后我觉得我掌握了。&lt;br/&gt;当初没被打脸，是因为当时没人知道我会Node.js和Python，后来呢，因为要做一个在线测评(OJ),当时参考的OJ是一个青岛大学的开源项目，于是我开始接触，起初运行起来还是比较简单的，用Docker一键就能启动。但后来了，领导发话，要对其二次开发，二次开发意味着不仅仅要弄懂它的一些关键核心代码，同时也要加上我们自己写的功能，当时我就懵逼了，这个该怎么弄啊，于是只好翻看文档，原来这个青岛OJ用的技术框架，主要还是Python的Django。也正是因为研究过程中，我才发现我对Python仅仅还是个小白，并没有因为把教程敲了2~3遍就成了专家非常熟练和精通。&lt;/p&gt;
&lt;p&gt;由此我发现我缺乏一个东西将新学的技术串起来，人的记忆是有限的，今天学过的东西，可能明天还记得一半，过了几个礼拜不用，可能就全部忘光了。&lt;/p&gt;
&lt;p&gt;于是我想起了导师当年对我说的一句话(还是跟博客有关，但与写文章没有直接关系)，&lt;strong&gt;做一个博客系统&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;做一个博客系统，不仅仅能让你将知识串起来，更能让你在实践中不断熟练和提高(实践中需要大量动手，更能加深印象，遇到问题并解决问题，不仅使你深刻理解该语言的特性，同样也能提高解决问题的能力)。&lt;/p&gt;
&lt;p&gt;而后我更能深刻体会到这一点，就像当初没有接触过微服务框架那样，我通过博客系统来驱动学习，让我更能深刻的理解该框架技术，同样更能贴近实际应用场景，解决实际的问题。&lt;/p&gt;
&lt;p&gt;博客系统让我的刻意练习更加精确，博客系统其实说简单也简单，说难也难。简单在于你可以仅仅写个CRUD(增删改查),难的在于按照企业级产品应用来做(就像著名的WordPress那样，虽然它看起来仅仅是一个CMS，但它丰富的插件扩展，让其可以是电商，也可以是视频、论坛等，只有想不到没有做不到)。&lt;/p&gt;
&lt;p&gt;在做一个企业级应用产品的过程中，它是很令人痛苦的，因为你作为一个产品的创造者而言，你必须要想清楚它做出来之后是什么样的，同样你也必须关注跟你所做的类似的东西(但已经面向C端用户)有哪些可以参考借鉴的(就像现在有很多电商平台，难保他们不彼此借鉴彼此的优劣来改进产品)。&lt;/p&gt;
&lt;p&gt;我的博客系统断断续续做了好几年了，从单体到分布式微服务，能用的技术都用了，我不否认当初有段时期仅仅是为了技术而技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外说说我的博客系统断断续续做了好几年的原因&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模块单一，拆分为多模块；&lt;/li&gt;
&lt;li&gt;技术太过单一，实践新的技术；&lt;/li&gt;
&lt;li&gt;业务大而全，写不下去，没有把握好博客系统的本质，即CMS；&lt;/li&gt;
&lt;li&gt;代码质量太差，中间断层太多，牵一发动其余，改的太痛苦不如重构;&lt;/li&gt;
&lt;li&gt;找到几个参考对象，最后改成了一个四不像。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今年有段相对空闲的时间，于是进行了改造，以WordPress作为参考对象(不再追求大而全，把握核心本质)，&lt;/p&gt;
&lt;p&gt;访问地址:&lt;br/&gt;&lt;a href=&quot;http://www.youcongtech.com/blog-portal&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://www.youcongtech.com/blog-portal&lt;/a&gt;&lt;br/&gt;效果图如下:&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-ctn fancybox&quot; title=&quot;图一&quot; href=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/01.png&quot; rel=&quot;fancy-group&quot;&gt;&lt;img src=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/01.png&quot; alt=&quot;图一&quot; width=&quot;undefined&quot; height=&quot;undefined&quot; title=&quot;图一&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-ctn fancybox&quot; title=&quot;图二&quot; href=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/02.png&quot; rel=&quot;fancy-group&quot;&gt;&lt;img src=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/02.png&quot; alt=&quot;图二&quot; width=&quot;undefined&quot; height=&quot;undefined&quot; title=&quot;图二&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-ctn fancybox&quot; title=&quot;图三&quot; href=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/03.png&quot; rel=&quot;fancy-group&quot;&gt;&lt;img src=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/03.png&quot; alt=&quot;图三&quot; width=&quot;undefined&quot; height=&quot;undefined&quot; title=&quot;图三&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancy-ctn fancybox&quot; title=&quot;图四&quot; href=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/04.png&quot; rel=&quot;fancy-group&quot;&gt;&lt;img src=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/04.png&quot; alt=&quot;图四&quot; width=&quot;undefined&quot; height=&quot;undefined&quot; title=&quot;图四&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近因工作繁忙，目前还不能面向广大朋友们。目前该网站文章题材均是通过爬虫技术获取。&lt;/p&gt;
&lt;p&gt;因为这个博客系统，我在技术上的刻意练习不再是简单、单一。随着博客的面世，我需要考虑用户体验、数据隔离稳定性、大数据量、类似于WordPress的丰富插件和主题等，当然了，这并非一朝一夕的事情，需要一个循序渐进的过程，这个事情我会长期坚持下来的。&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;3读书笔记欠缺自己的思考&quot;&gt;3.读书笔记欠缺自己的思考&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;前面我说过，思考的关键在于提问。人在读一本书的时候，通常会带一些疑问，读专业书籍如此，读小说也是如此。即便刚读的时候没有疑问，但随着越来越多的时候，就有了疑问，这个疑问比分说是故事人物之间的关系、专业书籍中抛出问题等。&lt;/p&gt;
&lt;p&gt;有段时间我感觉我即便读了很多书，但所知甚少。就像我在博客里写了大量的读书笔记，就像如图所示:&lt;br/&gt;&lt;a class=&quot;fancy-ctn fancybox&quot; title=&quot;图五&quot; href=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/05.png&quot; rel=&quot;fancy-group&quot;&gt;&lt;img src=&quot;https://developers-youcong.github.io/2020/10/07/2020%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/05.png&quot; alt=&quot;图五&quot; width=&quot;undefined&quot; height=&quot;undefined&quot; title=&quot;图五&quot;/&gt;&lt;/a&gt;&lt;br/&gt;《算法图解》我读了近一个月的时间，做了一些笔记，但仍觉得还是不知道。&lt;br/&gt;最近总结了两点原因:&lt;br/&gt;&lt;strong&gt;- 没有真正的思考(记录书中关键话，然后一些术语名词通过搜索来记录，没有就关键话语展开疑问)；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;- 没有把理论同实践充分的结合起来(这需要实践，后来在LeetCode刷题实践才方觉有些收获，知行合一)。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;4解决问题类问题欠缺较为详细的错误原因分析为什么会报错原因是什么等缺乏对错误原因的深究&quot;&gt;4.解决问题类问题欠缺较为详细的错误原因分析(为什么会报错，原因是什么等，缺乏对错误原因的深究)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;800多篇博客，有半数是关于遇到问题怎么解决的。刚开始时，是照搬照抄，而后就是就错误信息展开(错误原因、解决步骤/方案、参考链接等)。但后来发现解决问题的效率有些提高(比方说，公司小伙伴们遇到一些技术问题时，我对那些问题有些印象，然后我就让小伙伴去我的博客上搜索即可，或者是有些技术小伙伴不会，但我之前应用过并记录在我的博客里，小伙伴一搜，然后也能快速应用)。&lt;br/&gt;&lt;strong&gt;但是呢？我发现有一点严重弊端。&lt;/strong&gt;&lt;br/&gt;那就是这些问题总会以一种形式到另一种形式转变，实际上问题的本质是一样的，以Java开发为例，用Spring全家桶总会遇到找不到Bean之类的错误，通常来说，一般是因为Service类，没有加@Service注解导致的。但是最近我所遇到的并不是这样的，哪怕@Service注解加上对应的业务类它还会报这样的错误，这个问题最初使我百思不得其解。&lt;br/&gt;最后找到了原因，发现就是一段代码的问题(由于这段代码是公司的核心代码，这里就不能公开了)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由此发现很多问题其实都是一样的，关键在于把握问题的本质，那么如何把握问题的本质呢？&lt;/strong&gt;&lt;br/&gt;最关键的就是明确问题是什么。就像刚才我举的例子，找不到bean，原因并不是没有加注解，而是一段代码导致的。&lt;strong&gt;很多开发人员(包括我)常常面对错误最容易犯的错误是没有真正的理解问题到底是什么，而仅仅的非常浅度的复制问题，然后百度或者google搜索之类的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么我们怎么避免这样的现象出现呢？&lt;/strong&gt;&lt;br/&gt;答案很简单，&lt;strong&gt;那就是耐心的把问题看全&lt;/strong&gt;，通常报错，IDE的控制台会显示那段代码那一行，看具体代码通常就明白了。最重要的是要把信息看全，看全后，通常就能把握错误的关键信息是什么，这样才能更好的解决问题(其实在看错误信息的时候，脑袋里也会不由自主的分析错误信息，思考可能是什么原因导致这样的错误信息)。另外这对于学习技术，参考他人的博客也有很大的启发意义，如今互联网上各种信息非常全(也意味着非常杂乱而不系统)，这就需要呢学会如何筛选信息，关键字搜索很重要，还有一点就是识别信息也很重要，比方说看一篇博客，你如果要按照他写的博客实践，最好还是从头到尾看一遍，然后再决定是否这样做，因为很多人写博客并不一定写的很全(中间可能有些代码没有展示出来，导致最后你按照这个例子来写，缺东西，从而导致进展不顺，只好放弃)。&lt;/p&gt;
&lt;p&gt;学习是人一生的事情，不管你从事哪行哪业，都要树立这样的观念，”终身学习观”。只有这样你才不至于被淘汰(社会淘汰、时代淘汰)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我曾因为，只要像程咬金那样只会”三板斧”就能打天下，后来随着经历的事情很多，看的世界越来越广，我才发现这远远不够。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;三-我对工作的思考&quot;&gt;三、我对工作的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我对工作的思考，不禁让我想起曾在公众号写了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODk0ODQ3Ng==&amp;amp;mid=2247485165&amp;amp;idx=1&amp;amp;sn=4c3f297583a42b946e7fc673a1c2ca17&amp;amp;chksm=f98055fecef7dce814c3b7c7636550cf26cdbad5dc3cf87c62d7e63616613b6add54630c76f8&amp;amp;token=1678293524&amp;amp;lang=zh_CN#rd&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;《工作的意义》&lt;/a&gt;，我在文章中这么说，工作的意义无非两点，一点是为了金钱(物质，也就是让生活更好，比较物质基础决定上层建筑)，二是为了成长。&lt;/p&gt;
&lt;p&gt;《工作的意义》这篇文章也间接反映和验证，我因为工作，生活也走向越来越好。&lt;/p&gt;
&lt;p&gt;但是呢？也让我逐渐形成了”安逸”。记得之前在创业公司的时候，其中某段时间(大概持续一到两个月)，那个时候开始迷上了游戏，如刺激战场、王者荣耀，可谓是天天打游戏，没有一天不打，同时呢，也变得不怎么爱学习了，也以为工作就意味着稳定。然而，就像我在《创业这两年》说的那样，突然一天领导对我们说，公司如果拿不到融资可能就要解散了。当我听到这则消息，心就突然慌了。因为我从来就没有经历类似得场景。&lt;/p&gt;
&lt;p&gt;虽然心慌了，但另外一个”我”提醒着我，保持冷静，近观态势。&lt;br/&gt;于是就有了这篇文章&lt;a href=&quot;https://www.cnblogs.com/youcong/p/12293309.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;互联网的寒冬该如何度过&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而后2019年10月以及2020年的经历再次告诉我，安逸是不存在的，工作的意义，不仅仅是诗和远方，也不仅仅是自身成长，更是提高自我市场价值的一种重要方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么我会给原来的那句话再加上了提高自我市场价值的一种重要方式呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先一件东西为什么会有价值，答案是因为有市场需求(关键就是供求关系，供过于求，贬值，供不应求升值)。&lt;/p&gt;
&lt;p&gt;人只有工作才能实现自我市场价值的增值，尽管你可能有非常大的本事，但如果没有公司这个大的平台，恐怕只能感叹”英雄无用武之地”。&lt;/p&gt;
&lt;p&gt;很多人都说要有职业规划，职业规划是为了谋求长远的发展。但这个职业规划仍然有一个大的前提，那就是工作，在特定的单位工作(可以是传统企业，也可以是互联网企业等)，还是离不开公司提供的平台。&lt;/p&gt;
&lt;p&gt;以程序员找工作为例，很多公司招聘上都说高并发、高性能、分布式微服务等，但是对于很多人来说，在一些较为传统的公司工作根本就没有这样的机会接触这些。就好像当初如果没在教育saas公司积累，很难主导公司的技术平台设计。再换言之没有创业公司的洗涤，面对从0到1或者二次开发，我可能很难上手甚至头疼，尽管很多人说开源有现成的，但试问对于一个企业来说开发产品中最重要的一环是稳定性和可靠性，开源项目虽多，但不少开源项目不稳定不可靠，对于一个新人来说，贸然使用开源项目和使用新的技术一样，无异于自杀。因为你所遇到的问题，在搜索引擎上搜索可能非常少甚至无。&lt;/p&gt;
&lt;p&gt;从这点来看，也是公司成就了我，提高了我的市场价值。&lt;/p&gt;
&lt;p&gt;但有一点非常重要，那就是公司不养闲人。&lt;/p&gt;
&lt;p&gt;如果你不去主动成长和提高自我价值的话，那么你随时可能会被裁员(对于公司而言，发展是硬道理，发展的关键在于人才)。&lt;/p&gt;
&lt;p&gt;从这点来看，毫无安逸可能。&lt;/p&gt;
&lt;p&gt;再比如很多人说国企安逸，早九晚五，福利好(虽然工资不高)。但大家别忘记了当年的”国企下岗潮”。&lt;/p&gt;
&lt;p&gt;我说了这么多，只想诠释一个重要观点(虽然过于武断，但还是要说)，&lt;strong&gt;“根本没有安全/稳定的工作，唯有提高自我价值才是王道”&lt;/strong&gt;(虽然这些话，对于前辈而言是废话，但这些来源于我自身的经历和深刻的体会)。&lt;/p&gt;
&lt;p&gt;那么如何提高自我价值呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要有终身学习观的意识，然后不断去学习和实践；&lt;/li&gt;
&lt;li&gt;工作中不要畏难，要敢于面对和战胜。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多人都说人脉很重要，这里我之所以不列举人脉是因为，&lt;strong&gt;社交的核心在于价值交换(虽然功利点，但却很对)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以我上家教育saas公司的CTO为例，他也是从一名初级研发工程师到高级研发工程师、架构师，到目前的位置，和他一起创业的是他的同事，两个人在当时公司的位置相等，只是负责的领域不一样，一个是营销，另一个是技术。两个人互补彼此优劣，然后带着团队的骨干一起创业，如今也算是财务自由，跟着他们的骨干也有股份。&lt;/p&gt;
&lt;p&gt;当然了，这样的例子还有很多。再列举一个在比如当初在北京的一个合租屋，合租的小伙伴们从事不同的工作，碰巧有个猎头，平时很少见，有天遇上聊了一会儿，然后突然说电脑遇到了一个问题，然后跟我说，这样的问题，我之前遇见过，然后飞快的将其解决，因为是猎头，从哪以后时不时推工作给我，甚至要我给他推荐人。&lt;/p&gt;
&lt;p&gt;2020年我觉得最重要的一点是我对工作态度和观念上的转变。&lt;/p&gt;
&lt;p&gt;过去我多少会有些逃避或者是畏难，如今的我不会了。虽然过程会让人痛苦，但过后会非常愉悦，我想这就是工作成就自我的一个体现。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;四-我对理财的思考&quot;&gt;四、我对理财的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在我看来，理财的含义，就是打理自己的财富。&lt;br/&gt;很多人都说学会理财很重要。&lt;/p&gt;
&lt;p&gt;那么如何打理自己的财富呢？&lt;br/&gt;很多人都说投资，如投资股票、基金、债劵等。我曾读过一些相关的书籍如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《富爸爸穷爸爸》这本书告诉我，增加资产，减少负债；&lt;/li&gt;
&lt;li&gt;《小狗钱钱》这本书告诉我，量入为出，不要超前消费；&lt;/li&gt;
&lt;li&gt;《富爸爸:为什么富人越来越富》这本书告诉我，要让自己往B、I象限发展和人生需要一个B计划；&lt;/li&gt;
&lt;li&gt;《新中产家庭理财第一课》这本书告诉我投资组合、风险管理、家庭资产配置、信用资产等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述四本书都属于已经读完的。我和导师的交流以及这些书让我产生一些思考，我对自己的理财有了更清晰的认识。总结了如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;量入为出，拒绝超前消费(固定支出或零花钱,记账);&lt;/li&gt;
&lt;li&gt;每月定存(特殊用途，如买房等,雷打不动);&lt;/li&gt;
&lt;li&gt;投资组合(基金、债劵持有,一般不动，每月定投);&lt;/li&gt;
&lt;li&gt;应急定存(银行卡或其它，随时能取);&lt;/li&gt;
&lt;li&gt;房租定存(通常会放入基金，偏中低风险)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一直以来有这么一样的观念，”没钱怎么理财”？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持有这种观念的人，我能够理解，过去我也曾有这样的观念。&lt;br/&gt;后来我转变了，因为我体会到没钱的无助和负债的压迫。&lt;br/&gt;于是当我工作后，我会强制自己储蓄。正是因为这种强制储蓄，成为我人生中的一个转折点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有部分人认为，一点小钱再怎么理，也不能一夜变个几百万出来？&lt;/strong&gt;&lt;br/&gt;前面我提到过，理财的含义就是打理财富。钱少的时候，节俭，钱多的时候，大手大脚的花，这也就解释了为什么一夜暴富或因某种机遇发横财的人，最后都穷困潦倒。&lt;/p&gt;
&lt;p&gt;实际上理财不单单是打理财富，它也体现出一个人的持家。&lt;/p&gt;
&lt;p&gt;简单的来说，一个人单身的时候，可以毫无顾忌，但两个人的时候就不一样，特别是当决定结婚的时候。这个时候你会发现，如果当初你不善于打理钱财，一方面婚前的房子、彩礼、结婚所需的资金等拿不出来需要啃老或外借(如果你一直是别人眼里的”月光族”，不一定能借到)，另外一方面，尽管婚前房子、彩礼、结婚所需的资金都解决搞定了，这时你还得考虑两个人一起的生活开销、孩子到来开销(出生、以后教育等)。&lt;/p&gt;
&lt;p&gt;所以从某个角度来看，越早学会理财显得更加重要。有一点明确的是，&lt;strong&gt;适合自己的理财方式才是最好的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比方说对于一个月收入5k的白领而言，总不可能拿3k去投资股票或者是存4k，只用1k吧。&lt;/p&gt;
&lt;p&gt;所以说，每个人的理财方式不同，最关键的在于适合。这个适合在于不影响生活质量和水平的前提下(吃、穿、住、行在合理的区间下)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理财也是便于了解自己的开支。&lt;/strong&gt;&lt;br/&gt;不论是通过支付宝或者微信，再或者我自己的记账本之类的。我能够更好的了解自己的开支，这也为了每月的资金分配做合理决策。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理财中所涉及的投资是如何分配的？&lt;/strong&gt;&lt;br/&gt;“割韭菜”这个词，对于投资股票或炒比特币的小伙伴们并不陌生。&lt;/p&gt;
&lt;p&gt;究竟什么样的人会被割韭菜？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;盲目听从他人推荐；&lt;/li&gt;
&lt;li&gt;什么都不懂，凭感觉；&lt;/li&gt;
&lt;li&gt;半知半解，充当专家。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对此有人这样说:炒股中也有”二八定律”，即20%懂的人赚钱，80%不懂的人亏钱。&lt;/p&gt;
&lt;p&gt;对于理财投资的分配，我不会将太多的钱进行投入，一方面，我很清楚我自己的风险承担能力，另外一方面，对于投资方面我并不擅长，因此高风险和高回报的，我很少考虑，一般倾向于中低风险或低风险的，这个占的比重高。如果要说100%的资金(月收入)，一般10%~15%是偏向于中低风险的基金或债劵，5%是中高风险的指数基金。其它80%就按照前面的总结进行分配。&lt;/p&gt;
&lt;p&gt;就像前面所说，人需要不断学习，理财相关的知识学习也是一个循序渐进的过程。&lt;/p&gt;
&lt;p&gt;我曾在吴军《见识》中看到这样一句话，&lt;strong&gt;任何好的投资都要建立在控制风险的基础之上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一句话，理财同工作一样，目的只有一个让生活更好。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;五-我对学习周报的思考&quot;&gt;五、我对学习周报的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;学习周报与工作周报是两码事。学习周报是我与我导师之间的交流工具。&lt;/p&gt;
&lt;p&gt;学习周报制定我每周的计划，如学习、锻炼身体等。&lt;/p&gt;
&lt;p&gt;学习周报从2018年末开始写。中间有过断续。&lt;/p&gt;
&lt;p&gt;刚刚开始写的时候，极其不适应，感觉自己很被限制。&lt;/p&gt;
&lt;p&gt;后来随着不断写，和每周执行。发现自身存在很多不足(这些不足是通过写学习周报发现的):&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.制定的计划，永远都完不成(忽略自身实际情况，盲目追求大而全);&lt;/li&gt;
&lt;li&gt;2.制定的计划，没有具体可衡量的指标(如该任务完成得情况标准是什么);&lt;/li&gt;
&lt;li&gt;3.自律性存在问题，不能在固定的时间专注于做一件事情;&lt;/li&gt;
&lt;li&gt;4.其它问题(前面提到过的，技术博客文章缺乏深度等)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过一年多的执行，总的来说于我自身而言还是有很大的提升的。&lt;/p&gt;
&lt;p&gt;一方面，在创业公司的时候，领导经常处于不在公司状态，有时去深圳出差，也有时去其它地方，由于写学习周报，即便在工作任务少的情况下，我仍能抵抗外界干扰(某同事看电子书、斗地主之类的)学习，虽然有些特立独行，但不学不行欠缺的东西太多，直到如今为止，我仍然觉得我还有很多要学。&lt;/p&gt;
&lt;p&gt;另一方面，养成计划的习惯，虽说有些时候，计划跟不上变化，但绝大多数时候还是能跟的上的，如果一直跟不上就说明计划制定的不合理。计划的习惯使我自律性提高，能在固定的时间段专注于做一件事情。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;六-我对健康的思考&quot;&gt;六、我对健康的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;健康是我一直所忽略的。因为有段困难时期不在乎也顾不上。后来到了教育saas，那段时期可谓是加班加疯了。经常加班，9点下班都算早班。但我仍然感激那段时期的经历，确实磨练了我。也让我深刻明白一个盈利的教育saas产品应该是怎样的。&lt;/p&gt;
&lt;p&gt;5月中旬体检，结果一半好，一半差。但无疑是给我一个警钟，这个警钟告诉我在透支下去，无疑于加快自杀的进程。于是我开始制定了我的养生计划，无奈于生活并不会因此而停滞不前，休息总有截至的日期，太长了就成了不务正业了。&lt;/p&gt;
&lt;p&gt;曾参加的一个读书会，里面有位书友这样诠释健康:&lt;br/&gt;&lt;strong&gt;身心和财务都要好，落实到具体的事情上，吃的好一点、睡得好一点，多运动一点、心情好一点，财务好一点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;健康是极易忽略的，因为只有当我生病时才会意识到它是多么的难能可贵。所幸因为年轻，抵抗力较为强，基本上的小病都能扛过去。&lt;/p&gt;
&lt;p&gt;但随着年纪不断增长，我需要重视一个问题就是身体机能一年比一年下降，曾经上班，经常性一两点才到住的地方，只需睡三到四个小时，照样能爬起来继续工作。&lt;/p&gt;
&lt;p&gt;但我不能不重视了，再不重视了，就真的可能验证”工作996，生病ICU了”。&lt;/p&gt;
&lt;p&gt;为此我给自己首条要求就是11点睡觉+每周至少锻炼3公里。&lt;/p&gt;
&lt;p&gt;虽然说从10点半开始不睡觉就算熬夜，但由于程序员这个工作性质，很难这个点睡，虽说11点睡觉，但通常也要11点半才能睡着。其实这么一说，每周3公里其实是最容易的，从9月份到现在，我一直坚持着。&lt;br/&gt;随着天气越来越冷，对于锻炼身体也是一个不小的挑战。因此我基本上都是下午去跑步。早上担心起不来，就算起来了，也比较晚了。&lt;br/&gt;按照上面的理解，我觉得吃的好，多运动、财务好一点，就目前而言达到这个标准并不难，吃的好，蔬菜、水果、肉这些都能满足，多运动一周3公里加上每天步行也算是运动了，财务方面，按照前面”我对理财的思考”这并不难，也算我从18年就开始制定的计划。最难的可能就是睡得好和心情要好点。&lt;/p&gt;
&lt;p&gt;都说晚读(晚上读书)能治疗失眠，从今天开始就开始实施吧。当年当当活动买了十几本书，至今尚未看完。其中《原则》这本书只看了一部分，从昨天开始看。这本书也让我启发蛮多的。&lt;/p&gt;
&lt;p&gt;其实仔细思考，吃得好、睡得好、财务好点、心情好点，可概括为一句话，即良好的生活习惯(合理的饮食结构、规律的作息习惯、适当的体育运动等)&lt;/p&gt;
&lt;p&gt;良好的生活习惯应该包含如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;健康规律的饮食(一日三餐、每天8杯水、多吃水果等，我是一餐不吃饿的慌，8杯水看情况，3杯水至少的，很多时候忙，就顾不上喝水，水果的话，从来未断过)；&lt;/li&gt;
&lt;li&gt;运动(步行或定期跑步，一般一周一跑或两跑，至于多少公里看身体状况，我个人就跑3公里)；&lt;/li&gt;
&lt;li&gt;多读书(多读书，不仅仅是学习，最主要丰富精神世界，记得当初我挺喜欢刷小视频的，觉得离不开小视频，最后把抖音卸了，如今微信虽有小视频，偶尔看看，无伤大雅，也没关系，也没有刷的欲望，游戏也如此，近来主要读刘慈欣《三体》，这本书我觉得挺不错的);&lt;/li&gt;
&lt;li&gt;干净整洁(每周定期清理，平时打扫打扫，保持整洁，事实证明，整洁利于心情愉悦，同样也利于良好的生活习惯养成，婚后可减少不少矛盾，同样不论男女，每天拾掇拾掇，干净整洁的去上班也很不错，我就挺反对有人说男程序员不修边幅之类的一说);&lt;/li&gt;
&lt;li&gt;不熬夜(这一点对我要求稍微高点，不过我会试着去做，就像前面说的晚读)；&lt;/li&gt;
&lt;li&gt;劳逸结合(工作闲暇，会去楼下走走，如果实在走不开，也会再工位上静坐看远处的风景，喝喝茶，适当的休息的确能倍增灵感，提高接下来的工作效率等)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然了良好的生活习惯还有很多，这里我列举最关键的几个。&lt;/p&gt;
&lt;p&gt;人的一生，每10年就是一个分水岭，马上就要25了，离我的分水岭还有5年。5年以后，也就是30，对于一个程序员而言，这是一个至关重要的标志。可能会中年危机，也可能走向不一样的路。&lt;br/&gt;但就目前而言，不在考虑的范围。因为我所能把握的仅仅是当下，珍惜当下，看得见的，摸得着的，才是最重要的。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;七-我对职业生涯的思考&quot;&gt;七、我对职业生涯的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;与职业生涯对应的是职业规划。&lt;br/&gt;近来摆在我面前有两个IT转型的例子，一个前端开发的女程序员，另外一个是后端开发的男程序员。前者成了产品经理(产品设计，无需写代码)，后者成了项目经理(把握项目进度，任务派发，可能要写点代码)。&lt;/p&gt;
&lt;p&gt;当初我在&lt;a href=&quot;https://www.cnblogs.com/youcong/p/9862712.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;作为程序员的思考与反省&lt;/a&gt;中的职业规划提到过如下内容:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初级开发工程师-&amp;gt;中级开发工程师-&amp;gt;高级开发工程师-&amp;gt;架构师/项目经理-&amp;gt;技术总监-&amp;gt;CTO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初级开发工程师-&amp;gt;中级开发工程师-&amp;gt;高级开发工程师-&amp;gt;产品经理-&amp;gt;产品总监&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初级开发工程师-&amp;gt;中级开发工程师-&amp;gt;高级开发工程师-&amp;gt;技术合伙人(参与创业)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于男程序员而言，基本上都达到5年以上的研发经验，然后转向的管理层(项目经理)。&lt;/p&gt;
&lt;p&gt;对于女程序员而言，具备3年以上的研发经验，加上一些机遇，成功转型了产品。&lt;/p&gt;
&lt;p&gt;仔细想来，我所认识的人，前教育SAAS公司CTO走的就是第一条路。前创业公司经理走的初级开发工程师-&amp;gt;中级开发工程师-&amp;gt;高级开发工程师-&amp;gt;产品经理-&amp;gt;高级产品经理/项目经理-自主创业当老板(这是我根据他以往三家公司的经历推出来的)。&lt;/p&gt;
&lt;p&gt;但很多人都卡在了这个高级开发工程师上，无法前进，有的是自身能力，也有的确实是喜欢写代码，写代码能力非常强，但不喜欢管理。我所遇到的人都有。&lt;/p&gt;
&lt;p&gt;转型目前不在我考虑范围，我所想的是如何成为这个高级开发工程师。经过这几年的时间，我愈发了解自己。&lt;/p&gt;
&lt;p&gt;当年某公司领导让我取代某个人成为组长，我犹豫了。找了一堆理由，说自己不太胜任，最后此事不了了之。那个时候确实是无法胜任，太嫩了。&lt;/p&gt;
&lt;p&gt;其实仔细想来我还是很感激互联网的，正是因为它，我从一个农村小伙跳到了大城市。而大城市给了一个相对平等的机会与众多人竞争，这场竞争中，我不会一直处于弱势。这场竞争其实也算是马拉松。跑在最前面的，不一定最终跨过终点，跑在后面的，总有机会超过前面的。&lt;br/&gt;这个过程一定是无比艰辛的。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;我对沟通的思考&quot;&gt;八、我对沟通的思考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;沟通这一环节在项目开发中至关重要，关系到项目的存亡，项目的存亡关系到公司的兴亡。&lt;br/&gt;&lt;strong&gt;我一直在思考如何更好的把握对方的问题给予对方能够理解的答案。&lt;/strong&gt;&lt;br/&gt;近来公司的程序媛小伙伴们请教我一些问题，其实问题我基本上都遇到过，但给她们的回答，她们又无法理解，等我坐在她们的电脑桌上给她们讲，她们一下就明白了。我在想，难道问题是出在我这，我没有说清楚，我觉得我已经说的很清楚了。但事实上因为沟通表达方式(语句叙述)，确实我的回答和她们说的不是一个问题。而有些时候，我的回答是那个问题，而答案对于她们而言又不太理解。一来一去，有的时候一个小时就过去了。所以针对此，我想出了一个办法，遇到问题，要么微信描述或者是我去她电脑旁看，这样的话比较高效。这仅仅是日常工作。&lt;/p&gt;
&lt;p&gt;在回到现实生活中，我的父母是做卖菜生意的，从小在他们身边看的事情很多，记得一次在市场卖菜的时候，见过旁边的摊贩和顾客因为商品的事情争吵，事情表面仅仅是商品价格折扣，实际上由于摊贩的表述不当，让顾客以为其看不起他，认为他是因为付不起钱，从而争吵。&lt;/p&gt;
&lt;p&gt;后来读了一本书《非暴力沟通》，该书有一句话让我印象很深刻&lt;strong&gt;，”暴力的根源在于人们忽视彼此的感受与需要，而将冲突归咎于对方–至少大部分暴力的根源都是如此，不论是语言、精神或身体的暴力，还是家族、部落以及国家暴力”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几年互联网研发工作，待的几家公司，多多少少看过一些争吵，其实原因正如《非暴力沟通》这句话。&lt;/p&gt;
&lt;p&gt;这篇文章就写到这吧，也算是我国庆假期的一个结尾小插曲。&lt;br/&gt;这篇文章总的来说应该是近来一些经历的总结，犹豫了很长时间，究竟要不要写，想了想，总要留些什么东西，于是动笔开始写(键盘和鼠标就是我的笔)。&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 14:47:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>首先这篇文章不等于”2020年总结”，因为2020年还没有完全结束，还有近两个多月的时间。通常来说，我的2020年总结会在2021年初以及2020年末写的，内容格式都是今年计划完成情况+来年计划制定等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youcong/p/13779683.html</dc:identifier>
</item>
<item>
<title>使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源（二） - mzlogin</title>
<link>http://www.cnblogs.com/mazhuang/p/13779379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhuang/p/13779379.html</guid>
<description>&lt;p&gt;之前写过一篇 &lt;a href=&quot;https://mazhuang.org/2020/05/01/cdn-for-github-pages/&quot;&gt;使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源&lt;/a&gt;，在那之后，又陆续想到并实施了几点利用 jsDelivr 进一步加速静态资源加载的措施，新起一篇作为记录和分享。&lt;/p&gt;
&lt;p&gt;继上一轮改造过后，比较拖页面加载速度的主要有三点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面首个请求响应时间；&lt;/li&gt;
&lt;li&gt;图片资源加载时间；&lt;/li&gt;
&lt;li&gt;站内搜索引用的 JSON 资源加载时间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第 1 点在页面仍然托管在 GitHub Pages 的前提下，似乎没有什么好办法能产生质的飞跃；本篇主要改善了第 2 点和第 3 点。&lt;/p&gt;
&lt;h2 id=&quot;0x01-图片资源加速&quot;&gt;0x01 图片资源加速&lt;/h2&gt;
&lt;p&gt;这里所说的图片主要是指文章里引用的图片。&lt;/p&gt;
&lt;p&gt;我一直将图片放在博客源码根目录的 images 文件夹下，引用图片的习惯写法是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;![after use cdn](/images/posts/github/cdn-after.png)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想将这个图片地址替换为 jsDelivr 的地址，需要做的就是将 &lt;code&gt;/images&lt;/code&gt; 替换为 &lt;code&gt;https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一处一处替换行不行？当然也行，但后面写新文章时要引用图片，还得手动写这一长串，不方便；万一 jsDeliver 出状况，也不好一键切换回来。有没有一劳永逸的方法？当然也有，我们从 Jekyll 的 layout 机制来想办法。&lt;/p&gt;
&lt;p&gt;Jekyll 的 layout 可以理解为页面模板，它是可以继承的，比如我的博客的所有页面模板有一个共同的祖先模板 _layouts/default.html，模板里可以使用 &lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;Liquid&lt;/a&gt; 语法对内容进行处理，我们可以利用这一点，来自动完成批量替换的工作。&lt;/p&gt;
&lt;p&gt;关键代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-liquid&quot;&gt;{% assign assets_base_url = site.url %}
{% if site.cdn.jsdelivr.enabled %}
{% assign assets_base_url = &quot;https://cdn.jsdelivr.net/gh/&quot; | append: site.repository | append: '@master' %}
{% endif %}
{% assign assets_images_url = 'src=&quot;' | append: assets_base_url | append: &quot;/images&quot; %}
{% include header.html %}
    {{ content | replace: 'src=&quot;/images', assets_images_url }}
{% include footer.html %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大意就是，如果打开了启用 jsDelivr 加速的开关，就将 &lt;code&gt;content&lt;/code&gt; 里的 &lt;code&gt;src=&quot;/images&quot;&lt;/code&gt; 替换为 &lt;code&gt;src=&quot;https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@master/images&quot;&lt;/code&gt;，否则替换为 &lt;code&gt;src=&quot;https://mazhuang.org/images&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以上便达成了我们的目的。&lt;/p&gt;
&lt;h2 id=&quot;0x02-站内搜索引用的-json-资源加速&quot;&gt;0x02 站内搜索引用的 JSON 资源加速&lt;/h2&gt;
&lt;p&gt;我是使用 &lt;a href=&quot;https://github.com/christian-fei/Simple-Jekyll-Search&quot;&gt;Simple-Jekyll-Search&lt;/a&gt; 这个 JavaScript 库来实现站内搜索的，它的搜索数据是来自一个动态生成的 JSON 文件。&lt;/p&gt;
&lt;p&gt;这个 JSON 文件编译前长这样：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mzlogin/mzlogin.github.io/blob/master/assets/search_data.json&quot;&gt;https://github.com/mzlogin/mzlogin.github.io/blob/master/assets/search_data.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jekyll 编译后长这样：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mazhuang.org/assets/search_data.json&quot;&gt;https://mazhuang.org/assets/search_data.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样的资源是没有办法直接通过替换网址来用 jsDelivr 加速的，因为 jsDelivr 上缓存的是编译前的文件，而我们需要的是编译后的。&lt;/p&gt;
&lt;p&gt;那我们就想办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将博客源码编译；&lt;/li&gt;
&lt;li&gt;将编译结果保存到另一个分支；&lt;/li&gt;
&lt;li&gt;通过 jsDelivr 引用新分支上的这个文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些步骤可以通过 GitHub 去年推出的新特性 &lt;a href=&quot;https://github.com/features/actions&quot;&gt;Actions&lt;/a&gt; 来完成，在我们每一次向博客源码仓库 push 代码时自动触发。&lt;/p&gt;
&lt;p&gt;关键步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;13&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在 GitHub 新建一个 Personal access Token：&lt;/p&gt;
&lt;p&gt;Settings --&amp;gt; Developer settings --&amp;gt; Personal access tokens --&amp;gt; Generate new token --&amp;gt; 填写 note，勾选 public_repo，生成之后复制 token 值备用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在博客源码仓库的 Settings --&amp;gt; Secrets --&amp;gt; New secret，Name 填 &lt;code&gt;ACCESS_TOKEN&lt;/code&gt;，Value 填第 1 步里复制的 token 值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;在博客源码根目录下新建文件 .github/workflows/ci.yml，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;name: Build and Deploy

on:
  push:
    branches: [ master ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2.3.1
        with: 
          persist-credentials: false

      - name: Set Ruby 2.7
        uses: actions/setup-ruby@v1
        with:
          ruby-version: 2.7

      - name: Install and Build
        run: |
          gem install bundler
          bundle install
          bundle exec jekyll build
        
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@3.6.2
        with:
          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
          BRANCH: built
          FOLDER: _site
          CLEAN: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大意就是在向 master 分支 push 代码时，自动执行 checkout、初始化 ruby 环境、安装 Jekyll 并编译博客源码的工作，最后将编译生成的 _site 目录里的内容推送到 built 分支。对 GitHub Actions 感兴趣的同学可以自行参考官方说明学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;修改引用 JSON 文件的地方，比如我的 _includes/sidebar-search.html 里的写法由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;json: '{{ site.url }}/assets/search_data.json',
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改为了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-liquid&quot;&gt;{% if site.cdn.jsdelivr.enabled and site.url contains 'mazhuang.org' %}
  json: 'https://cdn.jsdelivr.net/gh/mzlogin/mzlogin.github.io@built/assets/search_data.json',
{% else %}
  json: '{{ site.url }}/assets/search_data.json',
{% endif %}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将以上更改推送到源码仓库，等待处理完成即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;0x03-结语&quot;&gt;0x03 结语&lt;/h2&gt;
&lt;p&gt;经过以上改造，博客页面的加载速度又得到了小小的提升，所有相关源码可以在 &lt;a href=&quot;https://github.com/mzlogin/mzlogin.github.io&quot;&gt;https://github.com/mzlogin/mzlogin.github.io&lt;/a&gt; 找到，有相关心得或建议的朋友欢迎交流指正。&lt;/p&gt;
&lt;p&gt;相关文章：&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 13:25:00 +0000</pubDate>
<dc:creator>mzlogin</dc:creator>
<og:description>之前写过一篇 使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源，在那之后，又陆续想到并实施了几点利用 jsDelivr 进一步加速静态资源加载的措施，新起一篇作为记录和分享。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhuang/p/13779379.html</dc:identifier>
</item>
<item>
<title>学习git这一篇就够了！！！ - 匠人码农</title>
<link>http://www.cnblogs.com/worthycoder/p/13778998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/worthycoder/p/13778998.html</guid>
<description>&lt;h2 id=&quot;git工作流程&quot;&gt;git工作流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246213/202010/1246213-20201007213140392-141173790.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本地库操作&quot;&gt;本地库操作&lt;/h2&gt;
&lt;h3 id=&quot;初始化本地仓库&quot;&gt;初始化本地仓库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;初始化命令&lt;br/&gt;git init&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$ work % cd workspace
$ workspace % mkdir WebService //创建文件夹
$ workspace % git init //初始化
Initialized empty Git repository in /Users/jack/work/workspace/.git/
$ workspace %
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;初始化后的效果&lt;br/&gt;会在初始化后的目录中生成一个.git隐藏文件夹&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$ workspace % cd .git
$ .git % ls
HEAD            branches        config          description     hooks           info            objects         refs
$ .git % ls -l
total 24
-rw-r--r--   1 jack  staff   23 Sep 25 22:16 HEAD
drwxr-xr-x   2 jack  staff   64 Sep 25 22:16 branches
-rw-r--r--   1 jack  staff  137 Sep 25 22:16 config
-rw-r--r--   1 jack  staff   73 Sep 25 22:16 description
drwxr-xr-x  13 jack  staff  416 Sep 25 22:16 hooks
drwxr-xr-x   3 jack  staff   96 Sep 25 22:16 info
drwxr-xr-x   4 jack  staff  128 Sep 25 22:16 objects
drwxr-xr-x   4 jack  staff  128 Sep 25 22:16 refs
$ .git % 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：.git目录中的文件不要删除也不要修改，否则git不能正常工作。&lt;/p&gt;
&lt;h3 id=&quot;设置签名&quot;&gt;设置签名&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;形式&lt;br/&gt;用户名：XXX&lt;br/&gt;Email地址：XXX@gmail.com&lt;/li&gt;
&lt;li&gt;作用&lt;br/&gt;只是为了区分成员身份，不会给邮件地址发送邮件。而且邮件地址可以是不存在地址。&lt;/li&gt;
&lt;li&gt;注意&lt;br/&gt;这里的签名和远程仓库的邮件地址密码没有任何关系&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;命令&lt;br/&gt;1.项目级别/仓库级别&lt;br/&gt;仅在当前本地仓库有效&lt;br/&gt;git config user.name &lt;em&gt;&lt;strong&gt;用户名&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;git config user.email &lt;em&gt;&lt;strong&gt;邮箱地址&lt;/strong&gt;&lt;/em&gt;
&lt;pre&gt;
&lt;code&gt;$ WebService % git config user.name njzy    
$ WebService % git config user.email njzy@2020.com 
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
2.系统用户级别&lt;br/&gt;登录当前系统的用户范围&lt;br/&gt;git config --global user.name &lt;em&gt;&lt;strong&gt;用户名&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;git config --global user.email &lt;em&gt;&lt;strong&gt;邮箱地址&lt;/strong&gt;&lt;/em&gt;
&lt;pre&gt;
&lt;code&gt;$ WebService % git config --global user.name njzy_global 
$ WebService % git config --global user.email njzy_global@2020.com
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;签名保存位置&lt;br/&gt;1.项目级别&lt;br/&gt;当前项目下的.git文件夹下的config文件中。&lt;br/&gt;查看命令：cat .git/config
&lt;pre&gt;
&lt;code&gt;$ WebService % cat .git/config //查看当前项目的签名信息                            
[core]
  repositoryformatversion = 0
  filemode = true
  bare = false
  logallrefupdates = true
  ignorecase = true
  precomposeunicode = true
[user]
  name = njzy //被设置的项目用户名
  email = njzy@2020.com //被设置的项目邮件地址
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
2.系统用户级别&lt;br/&gt;当前用户文件夹下的.gitconfig文件中。&lt;br/&gt;查看命令：cat .gitconfig
&lt;pre&gt;
&lt;code&gt;$ ~ % cd ~ //切换到当前用户根目录
$ ~ % pwd  //查看当前位置
/Users/jack
$ ~ % cat .gitconfig //查看全局签名信息
[user]
  name = njzy_global //被设置的全局用户名
  email = njzy_global@2020.com //被设置的全局邮件地址
$ ~ % 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;项目级别和系统用户级别的签名的优先（就近原则）&lt;br/&gt;1.&amp;gt; 两个都设置情况下&lt;br/&gt;项目级别优先于系统用户级别&lt;br/&gt;2.&amp;gt; 只设定系统用户级别签名&lt;br/&gt;以系统用户级签名别为准&lt;br/&gt;3.&amp;gt; 只设定项目级别&lt;br/&gt;以项目级别为准&lt;br/&gt;4.&amp;gt; 两个都没有设定的话不允许。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看git状态&quot;&gt;查看git状态&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;作用&lt;br/&gt;确认git的暂存区，本地仓库的情况。&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git status&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;添加操作&quot;&gt;添加操作&lt;/h3&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li&gt;目的&lt;br/&gt;把内容从工作区添加到暂存区，也叫追踪。&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;命令&lt;br/&gt;1.添加单个文件&lt;br/&gt;git add 文件名&lt;br/&gt;2.添加多个文件&lt;br/&gt;1.&amp;gt; git add 文件名1 文件名2 文件名3 ....&lt;br/&gt;2.&amp;gt; git add -A&lt;br/&gt;3.&amp;gt; git add .&lt;br/&gt;详细参考git帮助文档
&lt;pre&gt;
&lt;code&gt;usage: git add [&amp;lt;options&amp;gt;] [--] &amp;lt;pathspec&amp;gt;...

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files //更新追踪的文件
    --renormalize         renormalize EOL of tracked files (implies -u)
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files //添加所有被追踪文件的更新，和没有被追踪的文件
    --ignore-removal      ignore paths removed in the working tree (same as --no-all) //忽略工作区被删除的文件
    --refresh             don't add, only refresh the index 
    --ignore-errors       just skip files which cannot be added because of errors //忽略由于文件的错误不能被追踪
    --ignore-missing      check if - even missing - files are ignored in dry run
    --chmod (+|-)x        override the executable bit of the listed files
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;使用例&lt;br/&gt;为了清除git各个阶段的状态，在进行添加操作之前先查看一下git的状态。&lt;br/&gt;(下面例子是从工作区文件的创建到追加暂存区的过程)&lt;br/&gt;1.查看工作区被初始化后的状态
&lt;pre&gt;
&lt;code&gt;$ WebService % git status
On branch master

No commits yet //本地仓库没有可提交的东西

nothing to commit (create/copy files and use &quot;git add&quot; to track) //暂存区没有可以提交的东西
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
2.创建文件testGIt.txt文件
&lt;pre&gt;
&lt;code&gt;$ WebService % vim testGit.txt
$ WebService % cat testGit.txt
//查看文件内容
hello !
this is my first git test file !
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
3.查看文件创建完后git状态
&lt;pre&gt;
&lt;code&gt;$ WebService % git status
On branch master

No commits yet //本地仓库没有乐意提交的东西。

Untracked files: //没有追加跟踪的文件
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) //使用git add &amp;lt;file&amp;gt; 命令可以追加文件到暂存区
        testGit.txt //刚才新创建的文件，此时文件名字体为红色

nothing added to commit but untracked files present (use &quot;git add&quot; to track) //使用git add命令
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
4.将文件添加到暂存区并查看状态
&lt;pre&gt;
&lt;code&gt;$ WebService % git add testGit.txt
$ WebService % git status
On branch master

No commits yet

Changes to be committed:
  (use &quot;git rm --cached &amp;lt;file&amp;gt;...&quot; to unstage) //已经把文件放到暂存区，如果想清除暂存区，可以使用git rm --cached 文件名来擦除暂存区 testGit.txt
        new file:   testGit.txt //此时文件为绿色

$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;提交操作&quot;&gt;提交操作&lt;/h3&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li&gt;目的&lt;br/&gt;将文件从暂存区提交到本地仓库&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;命令&lt;br/&gt;1.提交单个文件&lt;br/&gt;git commit -m &quot;提交时注释信息&quot; 文件名&lt;br/&gt;2.提交复数个文件&lt;br/&gt;git comit -a -m &quot;提交时注释信息&quot;&lt;br/&gt;更多详细可以参考git帮助文档
&lt;pre&gt;
&lt;code&gt;usage: git commit [&amp;lt;options&amp;gt;] [--] &amp;lt;pathspec&amp;gt;...

    -q, --quiet           suppress summary after successful commit
    -v, --verbose         show diff in commit message template

Commit message options
    -F, --file &amp;lt;file&amp;gt;     read message from file
    --author &amp;lt;author&amp;gt;     override author for commit
    --date &amp;lt;date&amp;gt;         override date for commit
    -m, --message &amp;lt;message&amp;gt;
                          commit message
    -c, --reedit-message &amp;lt;commit&amp;gt;
                          reuse and edit message from specified commit
    -C, --reuse-message &amp;lt;commit&amp;gt;
                          reuse message from specified commit
    --fixup &amp;lt;commit&amp;gt;      use autosquash formatted message to fixup specified commit
    --squash &amp;lt;commit&amp;gt;     use autosquash formatted message to squash specified commit
    --reset-author        the commit is authored by me now (used with -C/-c/--amend)
    -s, --signoff         add Signed-off-by:
    -t, --template &amp;lt;file&amp;gt;
                          use specified template file
    -e, --edit            force edit of commit
    --cleanup &amp;lt;mode&amp;gt;      how to strip spaces and #comments from message
    --status              include status in commit message template
    -S, --gpg-sign[=&amp;lt;key-id&amp;gt;]
                          GPG sign commit

Commit contents options
    -a, --all             commit all changed files
    -i, --include         add specified files to index for commit
    --interactive         interactively add files
    -p, --patch           interactively add changes
    -o, --only            commit only specified files
    -n, --no-verify       bypass pre-commit and commit-msg hooks
    --dry-run             show what would be committed
    --short               show status concisely
    --branch              show branch information
    --ahead-behind        compute full ahead/behind values
    --porcelain           machine-readable output
    --long                show status in long format (default)
    -z, --null            terminate entries with NUL
    --amend               amend previous commit
    --no-post-rewrite     bypass post-rewrite hook
    -u, --untracked-files[=&amp;lt;mode&amp;gt;]
                          show untracked files, optional modes: all, normal, no. (Default: all)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;使用例&lt;br/&gt;提交文件到本地仓库并查看git状态
&lt;pre&gt;
&lt;code&gt;$ WebService % git commit -m &quot;first commit:new file testGit.txt&quot; testGit.txt
[master (root-commit) c970a17] first commit:new file testGit.txt //first commit:new file testGit.txt 是提交时候的注释信息
 1 file changed, 2 insertions(+) //改变了一个文件，追加了两行信息。
 create mode 100644 testGit.txt
$ WebService % git status            
On branch master
nothing to commit, working tree clean //暂存区没有可以提交的东西
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;擦除暂存区操作&quot;&gt;擦除暂存区操作&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;目的&lt;br/&gt;擦除暂存区的内容&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;命令&lt;br/&gt;git rm --cached 文件名
&lt;pre&gt;
&lt;code&gt;$ WebService % git rm --cached testGit.txt
rm 'testGit.txt'
$ WebService % git status                 
On branch master

No commits yet

Untracked files:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
        testGit.txt //没有被追踪的文件

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查看历史版本信息&quot;&gt;查看历史版本信息&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;目的&lt;br/&gt;查看提交版本的历史信息&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;1.git log&lt;br/&gt;显示完整信息，包含提交的版本号，提交用户，提交日期，提交注释等信息。&lt;br/&gt;2.git log --pretty=oneline&lt;br/&gt;只包含提交后的完整版本号和提交时的注释信息&lt;br/&gt;3.git log --oneline&lt;br/&gt;包含提交后的简略版本号和提交时的注释信息&lt;/li&gt;
&lt;li&gt;注意&lt;br/&gt;只能查看已经被提交（commit）的文件的历史信息。&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;使用例1
&lt;pre&gt;
&lt;code&gt;$ WebService % git log
//第二次被提交的信息
commit 148942fd3c0ff3e01e09bf98d883f97a3b0a9c86 (HEAD -&amp;gt; master) //提交版本的hash值
Author: njzy &amp;lt;njzy@2020.com&amp;gt; //提交用户信息
Date:   Sat Sep 26 15:53:52 2020 +0900 //提交日期

    this is my second commit, modify testGit.txt //提交时注释
//第一次被提交的信息
commit c970a176de13abc4d436e4a08df329046ef193e7
Author: njzy &amp;lt;njzy@2020.com&amp;gt;
Date:   Sat Sep 26 12:30:20 2020 +0900

    first commit:new file testGit.txt
$ WebService % 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;使用例2
&lt;pre&gt;
&lt;code&gt;$ WebService % git log --pretty=oneline
148942fd3c0ff3e01e09bf98d883f97a3b0a9c86 (HEAD -&amp;gt; master) this is my second commit, modify testGit.txt
c970a176de13abc4d436e4a08df329046ef193e7 first commit:new file testGit.txt
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;使用例3
&lt;pre&gt;
&lt;code&gt;$ WebService % git log --oneline

148942f (HEAD -&amp;gt; master) this is my second commit, modify testGit.txt
c970a17 first commit:new file testGit.txt
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;历史版本的前进或者回退&quot;&gt;历史版本的前进或者回退&lt;/h3&gt;
&lt;h4 id=&quot;查看带head信息的日志&quot;&gt;查看带head信息的日志&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;目的&lt;br/&gt;查看带有指针和hash地址的日志信息，方便进行版本的前进或者后退。&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reflog&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ WebService % git reflog
148942f (HEAD -&amp;gt; master) HEAD@{0}: commit: this is my second commit, modify testGit.txt 
//148942f:简短的hash地址
//HEAD@{0}:指针0的位置
c970a17 HEAD@{1}: commit (initial): first commit:new file testGit.txt
//HEAD@{1} 指针1的位置
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;版本的前进或者和回退&quot;&gt;版本的前进或者和回退&lt;/h4&gt;
&lt;h5 id=&quot;基于hash地址的版本指定【推荐】&quot;&gt;基于hash地址的版本指定【推荐】&lt;/h5&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;目的&lt;br/&gt;对版本进行前进操作或者回退操作&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --hard 指定版本的hash地址&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;使用例&lt;br/&gt;从第五个版本跳转到第三个版本
&lt;pre&gt;
&lt;code&gt;$ WebService % git reflog //首先查看各种版本信息
d3c9608 (HEAD -&amp;gt; master) HEAD@{0}: commit: this is my fifth updata,updata testGit.txt
364024e HEAD@{1}: commit: this is my fourth commit,updata testGit.txt
9dba7c5 HEAD@{2}: commit: this is my third commit,updata testGit.txt
148942f HEAD@{3}: commit: this is my second commit, modify testGit.txt
c970a17 HEAD@{4}: commit (initial): first commit:new file testGit.txt
$ WebService % cat testGit.txt //查看当前版本的文件内容
hello !
this is my first git test file !

this is added 

this is my third updata!

this is my four updata!

this is my fifth updata!
$ WebService % git reset --hard 9dba7c5
//然后根据查看的版本地址信息，指定到要恢复到的版本。
HEAD is now at 9dba7c5 this is my third commit,updata testGit.txt
$ WebService % cat testGit.txt //然后查看回退后的当前版本文件内容         
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService % git reflog //然后我们再来看一下log信息
9dba7c5 (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to 9dba7c5
d3c9608 HEAD@{1}: commit: this is my fifth updata,updata testGit.txt
364024e HEAD@{2}: commit: this is my fourth commit,updata testGit.txt
9dba7c5 (HEAD -&amp;gt; master) HEAD@{3}: commit: this is my third commit,updata testGit.txt
148942f HEAD@{4}: commit: this is my second commit, modify testGit.txt
c970a17 HEAD@{5}: commit (initial): first commit:new file testGit.txt
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;使用符号（只能进行版本的后退不能前进）&quot;&gt;使用^符号（只能进行版本的后退不能前进）&lt;/h5&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;目的&lt;br/&gt;进行版本的回退&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --hard HEAD^&lt;br/&gt;(注意：一个^代表倒退一个版本)&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;使用例&lt;br/&gt;从第四个版本倒退到一个版本到第三个版本
&lt;pre&gt;
&lt;code&gt;$ WebService % git reset --hard HEAD^
HEAD is now at 9dba7c5 this is my third commit,updata testGit.txt
$ WebService % cat testGit.txt       
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
倒退两个版本
&lt;pre&gt;
&lt;code&gt;$ WebService % git reset --hard HEAD^^ 
HEAD is now at c970a17 first commit:new file testGit.txt
$ WebService % cat testGit.txt        
hello !
this is my first git test file !
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;使用符号&quot;&gt;使用~符号&lt;/h5&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;目的&lt;br/&gt;退回指定版本&lt;br/&gt;（只能倒退，但是可以指定指定退几步）&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --hard HEAD~要退的步数&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;使用例&lt;br/&gt;从当前版本第五版后退两步到第三个版本
&lt;pre&gt;
&lt;code&gt;$ WebService % git reset --hard HEAD~2 
HEAD is now at 9dba7c5 this is my third commit,updata testGit.txt
$ WebService % cat testGit.txt         
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;reset三个参数的对比&quot;&gt;reset三个参数的对比&lt;/h5&gt;
&lt;h6 id=&quot;--soft参数&quot;&gt;--soft参数&lt;/h6&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;示意图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246213/202010/1246213-20201007213701761-1545592731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;说明&lt;br/&gt;仅在本地仓库移动HEAD指针&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset -soft 指定版本号&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ WebService % cat testGit.txt //退回版本之前查看文件内容
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService % git reset --soft 148942f
//退回版本操作
$ WebService % cat testGit.txt //退回版本信息后查看文件内容        
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService % git status //查看状态
On branch master
Changes to be committed:
  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
        modified:   testGit.txt //查看完后显示为绿色字体，表示被更改了。为哈如此呢？
        //是由于原来本地仓库，暂存区，工作区的指针是相同的。而经过soft操作后，本地仓库的指针发生变化，导致暂存区的指针相对的产生了变化。所以显示是发生了变化。

$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;--mixd参数&quot;&gt;--mixd参数&lt;/h6&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;示意图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246213/202010/1246213-20201007213740624-544120967.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;说明&lt;br/&gt;在本地仓库移动HEAD指针，重置暂存区。&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --mixed 指定版本号&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ WebService % cat testGit.txt //跳转到其他版本之前文件内容
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService % git reset --mixed d3c9608
//指定到指定版本
Unstaged changes after reset:
M       testGit.txt
$ WebService % git reflog
//指定版本后的日志
d3c9608 (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to d3c9608
148942f HEAD@{1}: reset: moving to 148942f
9dba7c5 HEAD@{2}: reset: moving to HEAD~2
d3c9608 (HEAD -&amp;gt; master) HEAD@{3}: reset: moving to d3c9608
c970a17 HEAD@{4}: reset: moving to HEAD^^
9dba7c5 HEAD@{5}: reset: moving to HEAD^
364024e HEAD@{6}: reset: moving to 364024e
9dba7c5 HEAD@{7}: reset: moving to 9dba7c5
d3c9608 (HEAD -&amp;gt; master) HEAD@{8}: commit: this is my fifth updata,updata testGit.txt
364024e HEAD@{9}: commit: this is my fourth commit,updata testGit.txt
9dba7c5 HEAD@{10}: commit: this is my third commit,updata testGit.txt
148942f HEAD@{11}: commit: this is my second commit, modify testGit.txt
c970a17 HEAD@{12}: commit (initial): first commit:new file testGit.txt
$ WebService % cat testGit.txt  //查看切换版本后的文件内容        
hello !
this is my first git test file !

this is added 

this is my third updata!

$ WebService % git status
On branch master
Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
        modified:   testGit.txt //此时文件名是红色

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;--hard参数&quot;&gt;--hard参数&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;示意图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246213/202010/1246213-20201007213818785-1769164834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;说明&lt;br/&gt;在本地仓库移动HEAD指针&lt;br/&gt;重置暂存区&lt;br/&gt;重置工作区&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --hard 指定版本&lt;/li&gt;
&lt;li&gt;使用例&lt;br/&gt;参照上面各种版本前进或者后退的例子。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;删除文件并找回&quot;&gt;删除文件并找回&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;示意图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1246213/202010/1246213-20201007213925011-2058280576.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;前提&lt;br/&gt;提交到本地库后删除才能找回&lt;/li&gt;
&lt;li&gt;删除&lt;br/&gt;物理删除即可&lt;/li&gt;
&lt;li&gt;找回版本&lt;br/&gt;通过跳转到指定版本命令即可找回删除的内容。&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;使用例&lt;br/&gt;新建文件-&amp;gt;追加到暂存区-&amp;gt;提交到本地仓库-&amp;gt;删除文件-&amp;gt;添加到暂存区-&amp;gt;提交到本地仓库
&lt;pre&gt;
&lt;code&gt;$ WebService % vim test2.txt //1.创建一个新的测试文件
$ WebService % git add test2.txt //2.添加到暂存区
$ WebService % git commit -m &quot;add new test2.txt&quot; test2.txt //3.提交到本地仓库
[master 8a4e57d] add new test2.txt
 1 file changed, 3 insertions(+)
 create mode 100644 test2.txt
$ WebService % ls -l //查看当前文件夹文件
total 16
-rw-r--r--  1 jack  staff   27 Sep 27 07:11 test2.txt
-rw-r--r--  1 jack  staff  134 Sep 26 22:33 testGit.txt
$ WebService % git status //查看git状态
On branch master
nothing to commit, working tree clean
$ WebService %             
$ WebService % 
$ WebService % 
$ WebService % rm test2.txt //4.本地物理删除文件
$ WebService % ls -l //5.删除后确认
total 8
-rw-r--r--  1 jack  staff  134 Sep 26 22:33 testGit.txt
$ WebService % git status //6.查看删除后
On branch master
Changes not staged for commit:
  (use &quot;git add/rm &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
        deleted:    test2.txt //红色字体，表示这个操作没有被添加到暂存区

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
$ WebService % git add test2.txt //7.将删除后的状态添加到暂存区
$ WebService % git status //查看添加后的git状态
On branch master
Changes to be committed:
  (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage)
        deleted:    test2.txt //文字为绿色，表示暂存区已被更新。

$ WebService % git commit -m &quot;delete file test2.txt&quot; test2.txt //8.把暂存区内容提交到本地仓库
[master f8373c4] delete file test2.txt
 1 file changed, 3 deletions(-)
 delete mode 100644 test2.txt
$ WebService % git status //查看git状态
On branch master
nothing to commit, working tree clean
$ WebService % ls
testGit.txt
$ WebService % git reflog //9.查看日志信息
f8373c4 (HEAD -&amp;gt; master) HEAD@{0}: commit: delete file test2.txt //10/1文件被删除的历史记录
8a4e57d HEAD@{1}: commit: add new test2.txt
d3c9608 HEAD@{2}: reset: moving to d3c9608
d3c9608 HEAD@{3}: reset: moving to d3c9608
148942f HEAD@{4}: reset: moving to 148942f
9dba7c5 HEAD@{5}: reset: moving to HEAD~2
d3c9608 HEAD@{6}: reset: moving to d3c9608
c970a17 HEAD@{7}: reset: moving to HEAD^^
9dba7c5 HEAD@{8}: reset: moving to HEAD^
364024e HEAD@{9}: reset: moving to 364024e
9dba7c5 HEAD@{10}: reset: moving to 9dba7c5
d3c9608 HEAD@{11}: commit: this is my fifth updata,updata testGit.txt
364024e HEAD@{12}: commit: this is my fourth commit,updata testGit.txt
9dba7c5 HEAD@{13}: commit: this is my third commit,updata testGit.txt
148942f HEAD@{14}: commit: this is my second commit, modify testGit.txt
c970a17 HEAD@{15}: commit (initial): first commit:new file testGit.txt
$ WebService % git reset --hard 8a4e57d  //2.恢复到删除之前的版本
HEAD is now at 8a4e57d add new test2.txt
$ WebService % ls -l//3.查看本地文件是否恢复？
total 16
-rw-r--r--  1 jack  staff   27 Sep 27 07:25 test2.txt//文件又被恢复回来了
-rw-r--r--  1 jack  staff  134 Sep 26 22:33 testGit.txt
$ WebService % 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;恢复暂存区的文件&quot;&gt;恢复暂存区的文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;说明&lt;br/&gt;使暂存区文件恢复&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git reset --hard HEAD&lt;br/&gt;通过上面刷新让三个区保持一致即可&lt;/li&gt;
&lt;li&gt;条件&lt;br/&gt;要恢复的文件提交到了本地库&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;版本比较&quot;&gt;版本比较&lt;/h4&gt;
&lt;h5 id=&quot;比较工作区和暂存区&quot;&gt;比较工作区和暂存区&lt;/h5&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;命令&lt;br/&gt;git diff 文件名&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;使用例&lt;br/&gt;比较修改后的test2.txt的工作区和暂存区&lt;br/&gt;工作区，暂存区，本地仓库test2.txt内容一致
&lt;pre&gt;
&lt;code&gt;aaaaaaaa
bbbbbbbb
cccccccc
&lt;/code&gt;
&lt;/pre&gt;
修改后的工作区test2.txt
&lt;pre&gt;
&lt;code&gt;aaaaaaaa
bbbbbbbb
cccccccc@@@@@@
&lt;/code&gt;
&lt;/pre&gt;
比较后结果
&lt;pre&gt;
&lt;code&gt;$ WebService % git diff test2.txt
diff --git a/test2.txt b/test2.txt
index 092b923..0c08686 100644
--- a/test2.txt
+++ b/test2.txt
@@ -1,3 +1,3 @@
 aaaaaaaa
 bbbbbbbb
-cccccccc //-代表删除
+cccccccc@@@@@@ //+代表追加。git是以行尾单位来管理版本的，所以cccccccc表示为删除，cccccccc@@@@@@表示为追加。
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
提交到暂存区后再比较
&lt;pre&gt;
&lt;code&gt;$ WebService % git add test2.txt
$ WebService % git diff test2.txt
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;工作区和本地仓库版本比较&quot;&gt;工作区和本地仓库版本比较&lt;/h5&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;命令&lt;br/&gt;git diff 指定版本 [文件名]&lt;/li&gt;
&lt;li&gt;指定版本&lt;br/&gt;HEAD：当前本地仓库的版本&lt;br/&gt;HEAD^:本地仓库的上一个版本&lt;br/&gt;HEAD^^：本地仓库的上两个版本&lt;br/&gt;HEAD~n：本地仓库的上n个版本&lt;br/&gt;版本号的hash值&lt;/li&gt;
&lt;li&gt;注意&lt;br/&gt;文件名不写的话是所有当前文件夹的所有文件&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;使用例&lt;br/&gt;工作区和本地仓库的当前版本比较
&lt;pre&gt;
&lt;code&gt;$ WebService % git reset --hard HEAD 
//先把三个区同步一下，恢复到同一状态
HEAD is now at 8a4e57d add new test2.txt
$ WebService % git status           
On branch master
nothing to commit, working tree clean
$ WebService % cat test2.txt
aaaaaaaa
bbbbbbbb
cccccccc
$ WebService % vim test2.txt //对工作区修改
$ WebService % git diff HEAD test2.txt//修改后进行比较
diff --git a/test2.txt b/test2.txt
index 092b923..0c08686 100644
--- a/test2.txt
+++ b/test2.txt
@@ -1,3 +1,3 @@
 aaaaaaaa
 bbbbbbbb
-cccccccc
+cccccccc@@@@@@
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
和本地仓库的上一个版本进行比较
&lt;pre&gt;
&lt;code&gt;$ WebService % git diff HEAD^ test2.txt
diff --git a/test2.txt b/test2.txt
new file mode 100644
index 0000000..0c08686
--- /dev/null
+++ b/test2.txt
@@ -0,0 +1,3 @@
+aaaaaaaa
+bbbbbbbb
+cccccccc@@@@@@
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;分支&quot;&gt;分支&lt;/h4&gt;
&lt;h5 id=&quot;分支概述&quot;&gt;分支概述&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; 在版本控制过程中，使用多条线同时推进多个任务。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;分支好处&quot;&gt;分支好处&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;同时推进多个功能开发，提高生产效率。&lt;/li&gt;
&lt;li&gt;各个分支在开发过程中，如有某个分支失败，不会对其他分支有影响。失败的分支可以重新获取mastaer分支，进行再次开发。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;创建分支&quot;&gt;创建分支&lt;/h5&gt;
&lt;h4 id=&quot;查看分支&quot;&gt;查看分支&lt;/h4&gt;
&lt;h4 id=&quot;切换分支&quot;&gt;切换分支&lt;/h4&gt;
&lt;h4 id=&quot;合并分支&quot;&gt;合并分支&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;说明&lt;br/&gt;把指定分支的内容合并到当前分支&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;命令&lt;br/&gt;git merge 要合并内容的分支名
&lt;pre&gt;
&lt;code&gt;$ WebService % git branch -v
//查看当前分支
* hot_fix a360edf hox_fix one add
master  8a4e57d add new test2.txt
$ WebService % git checkout master
//切换到内容要合并到的分支
Switched to branch 'master'
$ WebService % git branch -v 
//再次确认切换后的分支
hot_fix a360edf hox_fix one add
* master  8a4e57d add new test2.txt
$ WebService % git merge hot_fix
//进行分支合并
Updating 8a4e57d..a360edf
Fast-forward
test2.txt | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
$ WebService % cat test2.txt//查看合并后的内容
aaaaaaaa
bbbbbbbb
cccccccc edit by hox_fix//次内容是hot_fix分支内容，证明已经合并成功。
$ WebService % git branch -v    
hot_fix a360edf hox_fix one add   //当两个分支内容一样的时候，此时两个分支的hash值是一样的。
* master  a360edf hox_fix one add //当两个分支内容一样的时候，此时两个分支的hash值是一样的。
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;解决合并冲突&quot;&gt;解决合并冲突&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;说明&lt;br/&gt;当要合并两个分支的时候，两个分支修改内容不一样，导致不能自动进行合并操作，所以需要手动进行合并操作。&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;解决思路&lt;br/&gt;1.删除冲突文件内容的特殊符号&lt;br/&gt;2.修改冲突内容&lt;br/&gt;3.修改后的文件添加到暂存区。（git add 文件名）&lt;br/&gt;4.从暂存区提交到本地仓库。&lt;br/&gt;（命令：git commit -m &quot;注释&quot;） 注：这里的commit命令不能带文件名称参数。
&lt;pre&gt;
&lt;code&gt;$ WebService % vim test2.txt //修改mster分支的test2文件
$ WebService % git add test2.txt
//把修改后的文件添加到暂存区
$ WebService % git commit test2.txt
//把暂存区文件提交到本地仓库
[master 4a902f1] updata master
 1 file changed, 1 insertion(+)
$ WebService % git branch -v
//查看当前分支
  hot_fix a360edf hox_fix one add
* master  4a902f1 updata master
$ WebService % 
$ WebService % git checkout hot_fix
//切换到hot_fix分支
Switched to branch 'hot_fix'
$ WebService % git branch -v //查看分支       
* hot_fix a360edf hox_fix one add
master  4a902f1 updata master
$ WebService % vim test2.txt //编辑test2.txt
$ WebService % git add test2.txt //修改后的文件添加到暂存区
  $ WebService % git commit -m &quot;updata hox_fix&quot; test2.txt //提交文件到本地仓库
[hot_fix ee3ae4c] updata hox_fix
 1 file changed, 1 insertion(+)
$ WebService % 
$ WebService % git merge master          //合并分支
Auto-merging test2.txt
CONFLICT (content): Merge conflict in test2.txt 
Automatic merge failed; fix conflicts and then commit the result.
//自动合并分支失败，接下来需要手动修改文件后在进行提交来解决冲突
$ WebService % ls -l
total 16
-rw-r--r--  1 jack  staff  126 Sep 27 11:02 test2.txt
-rw-r--r--  1 jack  staff  134 Sep 26 22:33 testGit.txt
$ WebService % vim test2.txt                       //打开文件进行手动合并文件内容
$ WebService % git status
//查看git状态
On branch hot_fix //在hot_fix分支上
You have unmerged paths.//没有合并的路径
  (fix conflicts and run &quot;git commit&quot;) //修理冲突并执行
  (use &quot;git merge --abort&quot; to abort the merge) //终止合并

Unmerged paths:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution) //使用git add &amp;lt;file&amp;gt; 命令去标记为解决
        both modified:   test2.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
$ WebService % git add test2.txt
//解决冲突后的文件添加到暂存区
$ WebService % git status       
On branch hot_fix
All conflicts fixed but you are still merging.//所有的冲突已经解决了，但是你仍然处于“合并中”状态。
  (use &quot;git commit&quot; to conclude merge)
//使用git commit 命令去变换”合并中“的状态

Changes to be committed:
        modified:   test2.txt

$ WebService % git commit -m &quot;resolve conflict&quot; test2.txt
fatal: cannot do a partial commit during a merge.
//注意：在这中特殊场合下的commit不能再后面使用文件名
$ WebService % git commit -m &quot;resolve conflict&quot;
//去掉文件名再次执行提交。
[hot_fix 0d62477] resolve conflict //冲突解决了。
$ WebService % git status
//查看git状态
On branch hot_fix
nothing to commit, working tree clean
$ WebService % vim test2.txt
//确认合并后的内容
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;
上面执行完merge命令后，test2.txt文件的内容，
&lt;pre&gt;
&lt;code&gt;aaaaaaaa
bbbbbbbb
cccccccc edit by hox_fix
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD  //指针版本内容
eeeeeeee add by hox_fix
=======
dddddddd add by master
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; master  //master版本内容
&lt;/code&gt;
&lt;/pre&gt;
上面修改后的文件内容
&lt;pre&gt;
&lt;code&gt;aaaaaaaa
bbbbbbbb
cccccccc edit by hox_fix
dddddddd add by master
eeeeeeee add by hox_fix
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;远程库操作&quot;&gt;远程库操作&lt;/h2&gt;
&lt;h3 id=&quot;注册账户&quot;&gt;注册账户&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;注册github账户&lt;/li&gt;
&lt;li&gt;注册码云账户&lt;/li&gt;
&lt;li&gt;两个账户任意一个即可&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建项目仓库&quot;&gt;创建项目仓库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建新仓库&lt;br/&gt;（在这里不做叙述）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;远程仓库别名设定&quot;&gt;远程仓库别名设定&lt;/h3&gt;
&lt;h3 id=&quot;查看远程仓库别名信息&quot;&gt;查看远程仓库别名信息&lt;/h3&gt;
&lt;h3 id=&quot;推送到远程仓库&quot;&gt;推送到远程仓库&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;说明&lt;br/&gt;把本地仓库的内容上传到远程仓库&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git push 远程库别名 分支名&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ WebService % git push origin hot_fix
Enumerating objects: 30, done.
Counting objects: 100% (30/30), done.
Delta compression using up to 16 threads
Compressing objects: 100% (22/22), done.
Writing objects: 100% (30/30), 2.52 KiB | 1.26 MiB/s, done.
Total 30 (delta 4), reused 0 (delta 0)
remote: Resolving deltas: 100% (4/4), done.
remote: 
remote: Create a pull request for 'hot_fix' on GitHub by visiting:
remote:      https://github.com/jack2019/WebService/pull/new/hot_fix
remote: 
To https://github.com/jack2019/WebService.git
 * [new branch]      hot_fix -&amp;gt; hot_fix
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;推送发生失败&quot;&gt;推送发生失败&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;当推送到远程仓库时莫名发生失败，此时可以进行强行推送&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git push 远程仓库名称.git 分支名 -f&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ WebService % git push origin master //首次推送
To https://github.com/jack2019/WebService.git
 ! [rejected]        master -&amp;gt; master (fetch first)
error: failed to push some refs to 'https://github.com/jack2019/WebService.git' //推送失败
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
$ WebService % git push origin master -f //进行强行推送
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/jack2019/WebService.git
 + 6cfbddc...4a902f1 master -&amp;gt; master (forced update) //强行推送成功，可以去github仓库查看是否已经有上传的内容。
$ WebService %
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;远程仓库克隆&quot;&gt;远程仓库克隆&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;说明&lt;br/&gt;当我们想从github或者码云下载他人的项目进行学习阅读的时候，我们可以使用克隆命令。&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git clone 远程仓库地址&lt;/li&gt;
&lt;li&gt;注意&lt;br/&gt;克隆操作在完成下载文件到本地的同时还完成了两件事情。分别是初始化远程仓库别名，初始话本地仓库（也就是git init命令执行过程。）&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;➜  IdeaProjects git clone https://github.com/jack2019/gitLearnning.git //克隆远程仓库库
Cloning into 'gitLearnning'...
remote: Enumerating objects: 52, done.
remote: Counting objects: 100% (52/52), done.
remote: Compressing objects: 100% (34/34), done.
remote: Total 52 (delta 10), reused 51 (delta 10), pack-reused 0
Unpacking objects: 100% (52/52), done. //克隆成功
➜  IdeaProjects cd gitLearnning //进入下载的文件夹
➜  gitLearnning git:(master) ls -al //查看下载的文件
total 16
drwxr-xr-x   5 jack  staff  160 Oct  6 21:34 .
drwxr-xr-x@ 21 jack  staff  672 Oct  6 21:34 ..
drwxr-xr-x  13 jack  staff  416 Oct  6 21:34 .git
-rw-r--r--   1 jack  staff  219 Oct  6 21:34 test2.txt
-rw-r--r--   1 jack  staff  134 Oct  6 21:34 testGit.txt
➜  gitLearnning git:(master) git status //查看git状态
On branch master
Your branch is up to date with 'origin/master'. //被下载到了origin/master下

nothing to commit, working tree clean
➜  gitLearnning git:(master) 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;从远程库拉取最新的内容&quot;&gt;从远程库拉取最新的内容&lt;/h3&gt;
&lt;h4 id=&quot;fetch操作&quot;&gt;fetch操作&lt;/h4&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li&gt;说明&lt;br/&gt;远程库的内容被更新后，我们想取得最新的到本地，这时候就用到了fetch命令。如果我们还想和本地的版本进行合并。我们还需要使用merge命令进行合并。&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git fetch 远程仓库别名 分支名&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;  $ git fetch origin master //抓取内容
  remote: Enumerating objects: 5, done.
  remote: Counting objects: 100% (5/5), done.
  remote: Compressing objects: 100% (2/2), done.
  remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
  Unpacking objects: 100% (3/3), done.
  From https://github.com/jack2019/WebService
   * branch            master     -&amp;gt; FETCH_HEAD
     f1a3142..da6a4ee  master     -&amp;gt; origin/master
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ ls -l
  total 2
  -rw-r--r-- 1 laofan 197121 100 九月 28 21:30 test2.txt
  -rw-r--r-- 1 laofan 197121 144 九月 28 21:30 testGit.txt
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ cat test2.txt
  aaaaaaaa
  bbbbbbbb
  cccccccc edit by hox_fix
  dddddddd add by master
  
  mmmmmmm push after updata!
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ git checkout origin/master //fetch下来的内容放在origin/master下，切换分支到origin、master下。
  Note: checking out 'origin/master'.
  
  You are in 'detached HEAD' state. You can look around, make experimental
  changes and commit them, and you can discard any commits you make in this
  state without impacting any branches by performing another checkout.
  
  If you want to create a new branch to retain commits you create, you may
  do so (now or later) by using -b with the checkout command again. Example:
  
    git checkout -b &amp;lt;new-branch-name&amp;gt;
  
  HEAD is now at da6a4ee... mac commit ,window fetch
  
  Window-PC MINGW64 /e/workspace/web/webservice ((da6a4ee...))
  $ git branch -v //查看当前分支
  * (HEAD detached at origin/master) da6a4ee mac commit ,window fetch
    master f1a3142 [behind 1] push after updata test2.txt //当前所处的分支是origin/master下
  
  Window-PC MINGW64 /e/workspace/web/webservice ((da6a4ee...))
  $ cat test2.txt //查看当前分支下的文件内容
  aaaaaaaa
  bbbbbbbb
  cccccccc edit by hox_fix
  dddddddd add by master
  
  mmmmmmm push after updata
  nnnnnnn macbook add! //当前分支新追加的内容
  
  Window-PC MINGW64 /e/workspace/web/webservice ((da6a4ee...))
  $ git checkout master  //切换分支到master
  Previous HEAD position was da6a4ee... mac commit ,window fetch
  Switched to branch 'master'
  Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.
    (use &quot;git pull&quot; to update your local branch)
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ git branch -v //查看当前分支
  * master f1a3142 [behind 1] push after updata test2.txt
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ cat test2.txt //查看当前分支内容
  aaaaaaaa
  bbbbbbbb
  cccccccc edit by hox_fix
  dddddddd add by master
  
  mmmmmmm push after updata!
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ git merge origin/master  //把origin/master分支内容合并到master
  Updating f1a3142..da6a4ee
  Fast-forward
   test2.txt | 3 ++-
   1 file changed, 2 insertions(+), 1 deletion(-)
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
  $ cat test2.txt //查看合并后的master分支文件内容
  aaaaaaaa
  bbbbbbbb
  cccccccc edit by hox_fix
  dddddddd add by master
  
  mmmmmmm push after updata
  nnnnnnn macbook add! //origin/master追加的内容
  
  Window-PC MINGW64 /e/workspace/web/webservice (master)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;pull操作&quot;&gt;pull操作&lt;/h4&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;说明&lt;br/&gt;pull操作等价于fetch操作 + merge操作&lt;/li&gt;
&lt;li&gt;命令&lt;br/&gt;git pull 远程仓库别名 分支名&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;使用例
&lt;pre&gt;
&lt;code&gt;$ git pull origin master
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/jack2019/WebService
 * branch            master     -&amp;gt; FETCH_HEAD
   da6a4ee..494ed55  master     -&amp;gt; origin/master
Updating da6a4ee..494ed55
Fast-forward
 test2.txt | 1 +
 1 file changed, 1 insertion(+)

Window-PC MINGW64 /e/workspace/web/webservice (master)
$ cat test2.txt
aaaaaaaa
bbbbbbbb
cccccccc edit by hox_fix
dddddddd add by master

mmmmmmm push after updata
nnnnnnn macbook add!
jjjjjjj macbook add2!

Window-PC MINGW64 /e/workspace/web/webservice (master)
$
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;协同开发冲突的解决&quot;&gt;协同开发冲突的解决&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;说明&lt;br/&gt;如果不基于远程库最新版本进行修改的话则不能推送，必须先拉取最新的远程库。拉取后发生冲突，则按照“分支冲突解决”的操作即可。&lt;/li&gt;
&lt;li&gt;例子&lt;br/&gt;mac端更新后提交github&lt;br/&gt;window端不拉取最新的github直接更新进行提交github。此时需要先拉取最新的远程库进行，并进行远程库和本地库的合并。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;跨团队协作&quot;&gt;跨团队协作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;说明&lt;br/&gt;当需要团队外部的人员进行代码的变更时，由于团队外的人没有push的权限，所以需要团队外人员对项目进行fork操作。&lt;/li&gt;
&lt;li&gt;正常流程&lt;br/&gt;1.github用户1fork用户2的项目&lt;br/&gt;（fork之后，在远程库自动创建一个同样的项目）&lt;br/&gt;2.clone到本地&lt;br/&gt;3.本地修改内容&lt;br/&gt;4.提交到暂存区，本地库&lt;br/&gt;5.push到github用户1&lt;br/&gt;6.向用户2申请提交请求&lt;br/&gt;pull requests&lt;br/&gt;new pull request&lt;br/&gt;7.用户2进行pull requestes的处理，并进行merge操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;git知识补充&quot;&gt;git知识补充&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Q：当不小心对整个系统的文件夹进行git inint操作后该如何取消？&lt;br/&gt;A：通过命令rm -rf .git对git文件进行删除操作就即可。&lt;/li&gt;
&lt;li&gt;Q：如何查看帮助文档？&lt;br/&gt;A：通过命令git help 要查看的命令 进行查看即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;记录点滴，记录成长，做好每一次笔记。（--致自己）&quot;&gt;记录点滴，记录成长，做好每一次笔记。（--致自己）&lt;/h2&gt;
</description>
<pubDate>Wed, 07 Oct 2020 12:44:00 +0000</pubDate>
<dc:creator>匠人码农</dc:creator>
<og:description>从0开始学习git，这一篇就够了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/worthycoder/p/13778998.html</dc:identifier>
</item>
<item>
<title>Hive窗口函数 - 孙晨c</title>
<link>http://www.cnblogs.com/sunbr/p/13778737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunbr/p/13778737.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics&quot;&gt;Hive官网，点我就进&lt;/a&gt;&lt;br/&gt;oracle,sqlserver都提供了窗口函数，但是在mysql5.5和5.6都没有提供窗口函数！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口函数： 窗口+函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;窗口： 函数运行时计算的数据集的范围&lt;/li&gt;
&lt;li&gt;函数： 运行的函数！&lt;br/&gt;&lt;strong&gt;仅仅支持以下函数：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;LEAD (scalar_expression [,offset] [,default])： 返回当前行以下N行的指定列的列值！如果找不到，就采用默认值&lt;/li&gt;
&lt;li&gt;LAG (scalar_expression [,offset] [,default])： 返回当前行以上N行的指定列的列值！如果找不到，就采用默认值&lt;/li&gt;
&lt;li&gt;FIRST_VALUE(列名,[false(默认)])：返回当前窗口指定列的第一个值，第二个参数如果为true,代表加入第一个值为null，跳过空值，继续寻找！&lt;/li&gt;
&lt;li&gt;LAST_VALUE(列名,[false(默认)])：返回当前窗口指定列的最后一个值，第二个参数如果为true,代表加入第一个值为null，跳过空值，继续寻找！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;排名分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RANK&lt;/li&gt;
&lt;li&gt;ROW_NUMBER&lt;/li&gt;
&lt;li&gt;DENSE_RANK&lt;/li&gt;
&lt;li&gt;CUME_DIST&lt;/li&gt;
&lt;li&gt;PERCENT_RANK&lt;/li&gt;
&lt;li&gt;NTILE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;mark&gt;注意：不是所有的函数在运行都是可以通过改变窗口的大小，来控制计算的数据集的范围！所有的排名函数和LAG,LEAD，支持使用over()，但是在over()中不能定义 window_clause&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式： 函数 over( partition by 字段 ,order by 字段 window_clause )&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;(rows | range) between (unbounded | [num]) preceding and ([num] preceding | current row | (unbounded | [num]) following)
(rows | range) between current row and (current row | (unbounded | [num]) following)
(rows | range) between [num] following and (unbounded | [num]) following
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;①在over()中既没有出现windows_clause，也没有出现order by，窗口默认为rows between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING&lt;/li&gt;
&lt;li&gt;②在over()中(没有出现windows_clause)，指定了order by，窗口默认为rows between UNBOUNDED PRECEDING and CURRENT ROW&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;①如果是分组操作，select后只能写分组后的字段&lt;/li&gt;
&lt;li&gt;②如果是窗口函数，窗口函数是在指定的窗口内，对每条记录都执行一次函数&lt;/li&gt;
&lt;li&gt;③如果是分组操作，有去重效果，而partition不去重！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(9) 查询前20%时间的订单信息&lt;br/&gt;精确算法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt; select *
 from
 (select name,orderdate,cost,cume_dist() over(order by orderdate ) cdnum
 from  business) tmp
 where cdnum&amp;lt;=0.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不精确计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt; select *
 from
 (select name,orderdate,cost,ntile(5) over(order by orderdate ) cdnum
 from  business) tmp
 where cdnum=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(8)查询顾客的购买明细及顾客最近三次cost花费&lt;/p&gt;
&lt;p&gt;最近三次： &lt;strong&gt;当前和之前两次&lt;/strong&gt; 或 &lt;strong&gt;当前+前一次+后一次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前和之前两次:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,sum(cost) over(partition by name order by orderdate rows between 2 PRECEDING and CURRENT  row) 
 from business 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前+前一次+后一次:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,sum(cost) over(partition by name order by orderdate rows between 1 PRECEDING and 1  FOLLOWING) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,cost+
 lag(cost,1,0) over(partition by name order by orderdate )+
 lead(cost,1,0) over(partition by name order by orderdate )
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(7) 查询顾客的购买明细及顾客本月最后一次购买的时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,LAST_VALUE(orderdate,true) over(partition by name,substring(orderdate,1,7) order by orderdate rows between CURRENT  row and UNBOUNDED  FOLLOWING) 
 from business 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(6) 查询顾客的购买明细及顾客本月第一次购买的时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,FIRST_VALUE(orderdate,true) over(partition by name,substring(orderdate,1,7) order by orderdate ) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) 查询顾客的购买明细及顾客下次的购买时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt; select name,orderdate,cost,lead(orderdate,1,'无数据') over(partition by name order by orderdate ) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）查询顾客的购买明细及顾客上次的购买时间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;  select name,orderdate,cost,lag(orderdate,1,'无数据') over(partition by name order by orderdate ) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）查询顾客的购买明细要将cost按照日期进行累加&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,orderdate,cost,sum(cost) over(partition by name order by orderdate ) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）查询顾客的购买明细及月购买总额&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt; select name,orderdate,cost,sum(cost) over(partition by name,substring(orderdate,1,7) ) 
 from business
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）查询在2017年4月份购买过的顾客及总人数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,count(*) over(rows between UNBOUNDED  PRECEDING and UNBOUNDED  FOLLOWING)
from business
where substring(orderdate,1,7)='2017-04'
group by name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select name,count(*) over()
from business
where substring(orderdate,1,7)='2017-04'
group by name
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 07 Oct 2020 12:01:00 +0000</pubDate>
<dc:creator>孙晨c</dc:creator>
<og:description>@ 官方文档地址 Hive官网，点我就进 oracle,sqlserver都提供了窗口函数，但是在mysql5.5和5.6都没有提供窗口函数！ 窗口函数： 窗口+函数 窗口： 函数运行时计算的数据集的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunbr/p/13778737.html</dc:identifier>
</item>
<item>
<title>「反演」学习笔记 - RubyonlyK</title>
<link>http://www.cnblogs.com/Rubyonly233/p/13778435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rubyonly233/p/13778435.html</guid>
<description>&lt;p&gt;&lt;s&gt;小声bb：本来看skyh推的博客，是来学容斥的，莫名其妙被强塞了反演&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;好多童鞋还不知道啥是反演，反正听起来挺牛逼的，&lt;s&gt;谁会谁被膜&lt;/s&gt;。&lt;/p&gt;
&lt;p&gt;比如说有两个未知量 &lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;，我们用 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 表达出来了 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，比如一个一次函数：&lt;/p&gt;
&lt;p&gt;\[y=kx+b \]&lt;/p&gt;
&lt;p&gt;那么我们用 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 就是：&lt;/p&gt;
&lt;p&gt;\[x=\frac{y-b}{k} \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(emmmm\)&lt;/span&gt;，这差不多就是个反演。&lt;/p&gt;
&lt;p&gt;然后我们就搞高级一点：&lt;/p&gt;
&lt;p&gt;假设有两个函数 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 满足：&lt;/p&gt;
&lt;p&gt;\[f[n] = \sum_{k}a_{n,k}\times g[k] \]&lt;/p&gt;
&lt;p&gt;已知 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 求 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt; 的过程就叫做「反演」。&lt;/p&gt;
&lt;h2 id=&quot;二项式反演&quot;&gt;二项式反演&lt;/h2&gt;
&lt;h3 id=&quot;例题&quot;&gt;例题&lt;/h3&gt;
&lt;p&gt;有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个小盆友，每个人有一个编号 &lt;span class=&quot;math inline&quot;&gt;\(1,2...,n\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;将这 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个小盆友排成一列，编号为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的小盆友不能在第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个位置。&lt;/p&gt;
&lt;p&gt;求出所能排队的方案数，&lt;span class=&quot;math inline&quot;&gt;\(n\leq 10^5\)&lt;/span&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;简单容斥（听说小学生都会？？）&quot;&gt;简单容斥（听说小学生都会？？）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;假设 &lt;span class=&quot;math inline&quot;&gt;\(n=3\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们拿出高一老师&lt;s&gt;（？？）&lt;/s&gt;常拿的韦恩图像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.uoj.ac/user/vfleaking/inclusion-exclusion.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 集合：编号为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的小盆友站到 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 集合：编号为 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 的小盆友站到 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 集合：编号为 &lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt; 的小盆友站到 &lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt; 的方案数。&lt;/p&gt;
&lt;p&gt;我们要求的就是 &lt;span class=&quot;math inline&quot;&gt;\(n! - |A\cup B\cup C|\)&lt;/span&gt;，用简单的容斥可得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(ans=n! - (|A|+|B|+|C|-|A\cap B|-|B\cap C|-|A\cap C|+ |A\cap B\cap C|)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;得出公式&quot;&gt;得出公式&lt;/h3&gt;
&lt;p&gt;我们可以大胆猜想：&lt;/p&gt;
&lt;p&gt;\[ans = \sum_{k=0}^{n}(-1)^k\times \binom{n}{k}\times (n - k)!\;(假设 0!=1) \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么意思？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\binom{n}{k}\times (n - k)!\)&lt;/span&gt; 表示强硬的将 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个人放到自己应该放的位置（&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 放到第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个位置），剩下 &lt;span class=&quot;math inline&quot;&gt;\(n-k\)&lt;/span&gt; 个人随便放的方案数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为啥要加一个 &lt;span class=&quot;math inline&quot;&gt;\((-1)^k\)&lt;/span&gt;？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如说你加上了一个 &lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt; 的方案数，强硬地将 &lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt; 个人，后面我们统计 &lt;span class=&quot;math inline&quot;&gt;\(k=3\)&lt;/span&gt; 时，我们会发现：在前面 &lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt; 时，可能有某个小盆友被放到了自己应该放的位置，所以要&lt;/p&gt;
&lt;p&gt;减去这些被多余统计的方案，加法同理。&lt;/p&gt;
&lt;h3 id=&quot;新定义&quot;&gt;新定义&lt;/h3&gt;
&lt;p&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个人随便站的方案数。&lt;/p&gt;
&lt;p&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个人都不站在自己应该在的位置的方案数。&lt;/p&gt;
&lt;p&gt;这样我们直接枚举有多少个人站错位置，便可求出 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;\[f[n]=\sum_{k=0}^{n}\times \binom{n}{k}\times g[k] \]&lt;/p&gt;
&lt;p&gt;但是我们会发现，我们可以直接用 &lt;span class=&quot;math inline&quot;&gt;\(f[n] = n!\)&lt;/span&gt; 求出 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt;，而且我们还不会求出 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt;，难受～～～&lt;/p&gt;
&lt;h3 id=&quot;小钥匙&quot;&gt;小钥匙&lt;/h3&gt;
&lt;p&gt;我们会发现之前解决那个例题的公式中有一个这个东东：&lt;/p&gt;
&lt;p&gt;\[\sum_{k=0}^{n}(-1)^k\times \binom{n}{k} \]&lt;/p&gt;
&lt;p&gt;易得：这个东东只有 &lt;span class=&quot;math inline&quot;&gt;\(n=0\)&lt;/span&gt; 时才为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，否则即为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们再引进一个神犇数学符号：&lt;span class=&quot;math inline&quot;&gt;\([P]\)&lt;/span&gt;，表示条件 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 符合时，为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;；否则即为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，（好像一个 &lt;span class=&quot;math inline&quot;&gt;\(bool\)&lt;/span&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以上面那个东东就可以化为：&lt;/p&gt;
&lt;p&gt;\[\sum_{k=0}^{n}(-1)^k\times \binom{n}{k}=[n=0] \]&lt;/p&gt;
&lt;h3 id=&quot;反演&quot;&gt;反演&lt;/h3&gt;
&lt;p&gt;之前我们新定义里：&lt;/p&gt;
&lt;p&gt;用 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt; 表示出了 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt;，然而我们并不知道 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt;，反而知道 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt;，我们就需要一些骚操作（&lt;s&gt;繁衍&lt;/s&gt;呸，反演），来求出 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;说一句废话：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m=0}^{n}[n=m]\times \binom{n}{m}\times g[m] \]&lt;/p&gt;
&lt;p&gt;改一下这个废话：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m=0}^{m}[n-m=0]\times \binom{n}{m}\times g[m] \]&lt;/p&gt;
&lt;p&gt;哦！！！中间那个条件，我们是不是可以用一下那个小钥匙？&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m=0}^{n} \sum_{k=0}^{n-m}(-1)^k\times \binom{n-m}{k}\times \binom{n}{m}\times g[m] \]&lt;/p&gt;
&lt;p&gt;看一看中间那两个恶心的组合数：&lt;/p&gt;
&lt;p&gt;可以考虑为从 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个物品里，先选 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个，再从 &lt;span class=&quot;math inline&quot;&gt;\(n-m\)&lt;/span&gt; 个里选 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个的方案数。&lt;/p&gt;
&lt;p&gt;可以变为为从 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个物品里，先选 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个，再从 &lt;span class=&quot;math inline&quot;&gt;\(n-k\)&lt;/span&gt; 个里选 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个的方案数，组合数可以变为： &lt;span class=&quot;math inline&quot;&gt;\(\binom{n-k}{m}\times \binom{n}{k}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;原式变为：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m=0}^{n} \sum_{k=0}^{n-m}(-1)^k\times \binom{n-k}{m}\times \binom{n}{k}\times g[m] \]&lt;/p&gt;
&lt;p&gt;交换一下：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m=0}^{n} \sum_{k=0}^{n-m}(-1)^k\times \binom{n-k}{m}\times g[m] \times \binom{n}{k} \]&lt;/p&gt;
&lt;p&gt;然后将 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 交换一下：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{k=0}^{n} \sum_{m=0}^{n-k}(-1)^k\times \binom{n-k}{m}\times g[m] \times \binom{n}{k} \]&lt;/p&gt;
&lt;p&gt;再次交换：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{k=0}^{n} (-1)^k\times \binom{n}{k} \sum_{m=0}^{n-k} \binom{n-k}{m}\times g[m] \]&lt;/p&gt;
&lt;p&gt;诶！！后面那个东东就是 &lt;span class=&quot;math inline&quot;&gt;\(f[n - k]\)&lt;/span&gt;，可，我们成功了！！！&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{k=0}^{n} (-1)^k\times \binom{n}{k} \times f[n-k] \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(emmmm\)&lt;/span&gt;，好丑，写好看一点：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{k=0}^{n} (-1)^{n-k}\times \binom{n}{k} \times f[k] \]&lt;/p&gt;
&lt;h3 id=&quot;得出结果&quot;&gt;得出结果&lt;/h3&gt;
&lt;p&gt;\[f[n]=\sum_{k=0}^{n}\times \binom{n}{k}\times g[k] \]&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{k=0}^{n} (-1)^{n-k}\times \binom{n}{k} \times f[k] \]&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这个好像就是二项式反演&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;可能与 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 层的巨佬们学的有点不同，有错误，请见谅我这个蒟蒻。&lt;/p&gt;
&lt;h2 id=&quot;莫比乌斯反演&quot;&gt;莫比乌斯反演&lt;/h2&gt;
&lt;h3 id=&quot;例题-2&quot;&gt;例题&lt;/h3&gt;
&lt;p&gt;小盆友学英语，他拿到 &lt;span class=&quot;math inline&quot;&gt;\(26\)&lt;/span&gt; 个小写字母，他拼出若干个长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串，求出有多少个字符串的循环节恰好为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(n\leq 10^9\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;连小盆友都知道循环节是啥，不用我说吧....&lt;s&gt;（最短的一个子串复制若干遍后拼起来跟原串相等的字符串）。&lt;/s&gt;&lt;/p&gt;
&lt;h3 id=&quot;新定义-2&quot;&gt;新定义&lt;/h3&gt;
&lt;p&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(f[n]\)&lt;/span&gt; 表示长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串的个数，显然是 &lt;span class=&quot;math inline&quot;&gt;\(26^n\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(g[n]\)&lt;/span&gt; 表示长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 且循环节长度为 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 的字符串的个数。&lt;/p&gt;
&lt;p&gt;可以得出：&lt;/p&gt;
&lt;p&gt;\[f[n] = \sum_{d|n}g[d] \]&lt;/p&gt;
&lt;h3 id=&quot;小钥匙-2&quot;&gt;小钥匙&lt;/h3&gt;
&lt;p&gt;上次我们用了一个条件表达式，打开了反演的关键，这个我们同样搞一个：&lt;/p&gt;
&lt;p&gt;定义一个 &lt;span class=&quot;math inline&quot;&gt;\(\mu[n]\)&lt;/span&gt; 满足：&lt;s&gt;（莫某某某搞的）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;\[\sum_{d|n}\mu[d] = [n=1] \]&lt;/p&gt;
&lt;p&gt;其实这个就是莫比乌斯函数，至于性质，可以看一眼&lt;a href=&quot;https://www.cnblogs.com/DZN2004/p/13720658.html&quot;&gt;龙蝶的&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;反演-2&quot;&gt;反演&lt;/h3&gt;
&lt;p&gt;同样，我们说一句废话：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m|n}[n=m]\times g[m] \]&lt;/p&gt;
&lt;p&gt;将条件表达式变一下：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m|n}[\frac{n}{m}=1]\times g[m] \]&lt;/p&gt;
&lt;p&gt;好，用我们的小钥匙：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{m|n}\sum_{d|\frac{n}{m}}\times \mu[d] \times g[m] \]&lt;/p&gt;
&lt;p&gt;上次我们将 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 进行了交换，这次怎么处理呢？&lt;/p&gt;
&lt;p&gt;我们会发现 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 能将 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 整除，&lt;span class=&quot;math inline&quot;&gt;\(\frac{n}{m}\)&lt;/span&gt; 能将 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 整除，所以我们可以得出 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 既能将 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 整除，又能将 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; 整除，这样我们就可以将 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 交换了。&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{d|n}\sum_{m|\frac{n}{d}}\times \mu[d] \times g[m] \]&lt;/p&gt;
&lt;p&gt;交换一下：&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{d|n} \times \mu[d]\sum_{m|\frac{n}{d}} \times g[m] \]&lt;/p&gt;
&lt;p&gt;不错，后面那个东东又可以化为我们的 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;，可&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{d|n} \times \mu[d]\times f[\frac{n}{d}] \]&lt;/p&gt;
&lt;h3 id=&quot;得出结果-2&quot;&gt;得出结果&lt;/h3&gt;
&lt;p&gt;\[f[n] = \sum_{d|n}g[d] \]&lt;/p&gt;
&lt;p&gt;\[g[n] = \sum_{d|n} \times \mu[d]\times f[\frac{n}{d}] \]&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这个好像就是莫比乌斯反演&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他反演敬请期待&quot;&gt;其他反演敬请期待&lt;/h2&gt;
</description>
<pubDate>Wed, 07 Oct 2020 10:57:00 +0000</pubDate>
<dc:creator>RubyonlyK</dc:creator>
<og:description>「反演」·「演反」</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rubyonly233/p/13778435.html</dc:identifier>
</item>
<item>
<title>最全总结 | 聊聊 Python 数据处理全家桶（配置篇） - AirPython</title>
<link>http://www.cnblogs.com/xingag/p/13778338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingag/p/13778338.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1466987-12159a5ab2a559d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;在实际项目中，经常会接触到各种各样的配置文件，它可以增强项目的可维护性&lt;/p&gt;
&lt;p&gt;常用配件文件的处理方式，包含：JSON、ini / config、YAML、XML 等&lt;/p&gt;
&lt;p&gt;本篇文章，我们将聊聊 Python 数据处理全家桶之配置文件大总结&lt;/p&gt;
&lt;h2 id=&quot;2json&quot;&gt;​2.JSON&lt;/h2&gt;
&lt;p&gt;Python 内置了 JSON 模块，可以非常方便操作 JSON 数据&lt;/p&gt;
&lt;p&gt;常见的 4 个方法分别是：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;json.load(json_file)&lt;/p&gt;
&lt;p&gt;解析 JSON 文件，转换为 Python 中对应的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;json.loads(json_string)&lt;/p&gt;
&lt;p&gt;解析 JSON 格式的字符串，结果为 Python 中的字典&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;json.dump(python_content,file_path)&lt;/p&gt;
&lt;p&gt;将 Python 数据，包含：dict、list 写入到文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;json.dumps(python_dict)&lt;/p&gt;
&lt;p&gt;将 Python 中 dict 转为 JSON 格式的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下面这段 JSON 配置文件为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#config.json
{
  &quot;mysql&quot;: {
    &quot;host&quot;: &quot;198.0.0.1&quot;,
    &quot;port&quot;: 3306,
    &quot;db&quot;: &quot;xh&quot;,
    &quot;username&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;123456&quot;,
    &quot;desc&quot;: &quot;Mysql配置文件&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、读取配置文件&lt;/p&gt;
&lt;p&gt;读取配置文件有两种方式，分别是：&lt;/p&gt;
&lt;p&gt;使用 json.load() 直接读取配置文件&lt;/p&gt;
&lt;p&gt;或者，先读取配置文件中的内容，然后使用 json.loads() 转换为 Python 数据类型&lt;/p&gt;
&lt;p&gt;需要指出的是，面对复杂层级的 JSON 配置文件，可以利用 jsonpath 进行读取；jsonpath 类似于 xpath，可以通过正则表达式快速读取数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import json

def read_json_file(file_path):
    &quot;&quot;&quot;
    读取json文件
    :param file_path:
    :return:
    &quot;&quot;&quot;
    with open(file_path, 'r', encoding='utf-8') as file:

        # 读取方式二选一
        # 方式一
        result = json.load(file)

        # 方式二
        # result = json.loads(file.read())

        # 解析数据
        host_mysql = result['mysql']['host']
        port_mysql = result['mysql']['port']
        db = result['mysql']['db']

        print('Mysql地址：', host_mysql, &quot;,端口号:&quot;, port_mysql, &quot;,数据库:&quot;, db)
​
    return result
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、保存配置文件&lt;/p&gt;
&lt;p&gt;使用 json 中的 json.dump() 方法，可以将一个字典写入到 JSON 文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def write_content_to_json_file(output_file, content):
    &quot;&quot;&quot;
    写入到json文件中
    :param output_file:
    :param content:
    :return:
    &quot;&quot;&quot;
    with open(output_file, 'w') as file:
        # 写入到文件中
        # 注意：为了保证中文能正常显示，需要设置ensure_ascii=False
        json.dump(content, file, ensure_ascii=False)

content_dict = {
    'mysql': {
        'host': '127.0.0.1',
        'port': 3306,
        'db': 'xh',
        'username': 'admin',
        'password': '123456',
        'desc': 'Mysql数据库'
    }
}

write_content_to_json_file('./output.json', content_dict)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、修改配置文件&lt;/p&gt;
&lt;p&gt;如果需要修改配置文件，只需要先从配置文件中读出内容，然后修改内容，最后将修改后的内容保存的配置文件中即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def modify_json_file():
    &quot;&quot;&quot;
    修改json配置文件
    :return:
    &quot;&quot;&quot;
    result = read_json_file('./config.json')

    # 修改
    result['mysql']['host'] = '198.0.0.1'

    write_content_to_json_file('./config.json', result)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3iniconfig&quot;&gt;3.ini/config&lt;/h2&gt;
&lt;p&gt;ini 配置文件和 config 配置文件的解析方式类似，仅仅是文件后缀不一致&lt;/p&gt;
&lt;p&gt;这里我们以 ini 配置文件为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# config.ini
[mysql]
host = 139.199.1.1
username = root
password = 123456
port = 3306
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ini 文件由 3 部分组成，分别是：节点（Section）、键（Key）、值（Value）&lt;/p&gt;
&lt;p&gt;常见的 Python 处理 ini 文件有两种方式，包含：&lt;/p&gt;
&lt;p&gt;我们先来看看内置的 configparser 模块&lt;/p&gt;
&lt;p&gt;3.1.1 读取配置文件&lt;/p&gt;
&lt;p&gt;实例化一个 ConfigParser 解析对象，使用 read() 方法读取 ini 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from configparser import ConfigParser

# 实例化解析对象
cfg = ConfigParser()

# 读取ini文件内容
cfg.read(file_path)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 sections()函数，可以获取所有的节点列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# sections() 得到所有的section，并以列表的形式返回
sections = cfg.sections()
print(sections)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要获取某一个节点下的所有键，可以使用 options(section_name) 函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取某一个区域的所有key
# cfg.options(section_name)
keys = cfg.options('mysql')
print(keys)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 items(section_name) 函数，可以获取某一个节点下的所有键值对&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取某一个区域下的键值对
items = cfg.items(&quot;mysql&quot;)
print(items)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要获取某一个节点下，某一个键下的值，使用 get(section_name,key_name) 函数即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 读取某一个区域下的某一个键值
host = cfg.get(&quot;mysql&quot;, &quot;host&quot;)
print(host)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.1.2 写入配置文件&lt;/p&gt;
&lt;p&gt;和读取配置文件类似，需要先实例化一个 ConfigParser 解析对象&lt;/p&gt;
&lt;p&gt;首先，使用 add_section(section_name) 函数添加一个节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 加入节点和键值对
# 添加一个节点
cfg.add_section(&quot;redis&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，就可以使用 set(section_name,key,value) 函数往某一个节点添加键值对&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 往节点内，添加键值对
cfg.set(&quot;redis&quot;, &quot;host&quot;, &quot;127.0.0.1&quot;)
cfg.set(&quot;redis&quot;, &quot;port&quot;, &quot;12345&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，使用 write() 函数写入到配置文件中去&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 写入到文件中
cfg.write(open('./raw/output.ini', 'w'))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.1.3 修改配置文件&lt;/p&gt;
&lt;p&gt;修改配置文件的步骤是，读取配置文件，然后通过 set(section_name,key,value) 进行修改操作，最后使用 write() 函数写入到文件中即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def modify_ini_file(file_path):
    &quot;&quot;&quot;
    修改ini文件
    :return:
    &quot;&quot;&quot;
    cfg.read(file_path)

    cfg.set(&quot;mysql&quot;, &quot;host&quot;, &quot;139.199.11.11&quot;)

    # 写入
    cfg.write(open(file_path, &quot;w&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们聊聊使用 configobj 操作 ini 配置文件的流程&lt;/p&gt;
&lt;p&gt;首先安装 configobj 依赖库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 依赖
# pip3 install configobj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.2.1 读取配置文件&lt;/p&gt;
&lt;p&gt;直接将 ini 配置文件路径作为参数，使用 ConfigObj 类构造一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from configobj import ConfigObj

# 实例化对象
config = ConfigObj(file_path, encoding='UTF8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看源码可以发现，ConfigObj 是 Section 节点的子类，而 Section 是 Dict 字典的子类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1466987-2746bc128848a10b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，可以直接通过键名 Key 获取节点和键值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# &amp;lt;class 'configobj.ConfigObj'&amp;gt;
print(type(config))

# &amp;lt;class 'configobj.Section'&amp;gt;
print(type(config['mysql']))

# 节点
print(config['mysql'])

# 某一个键对应的值
print(config['mysql']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.2.2 修改配置文件&lt;/p&gt;
&lt;p&gt;只需要读取配置文件，然后直接修改 ConfigObj 对象，最后使用 write() 方法，即可以达到修改配置文件的目的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def modify_ini_file(file_path):
    &quot;&quot;&quot;
    修改ini文件
    :param file_path:
    :return:
    &quot;&quot;&quot;
    # 读取配置文件
    config = read_ini_file(file_path)

    # 直接修改
    config['mysql']['host'] = '139.199.1.1'

    # 删除某个键值对
    try:
        del config['mysql']['db']
    except Exception as e:
        print('键不存在')
        pass

    # 写入
    config.write()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.2.3 写入配置文件&lt;/p&gt;
&lt;p&gt;写入配置文件，首先需要实例化一个 ConfigObj 对象，传入文件路径&lt;/p&gt;
&lt;p&gt;然后，设置节点、针对节点设置键值对&lt;/p&gt;
&lt;p&gt;最后，调用 write() 方法，写入到配置文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def write_to_ini_file(output):
    &quot;&quot;&quot;
    写入到ini文件中
    :param output:
    :return:
    &quot;&quot;&quot;
    config = ConfigObj(output, encoding='UTF8')
    config['website'] = {}
    config['website']['url'] = &quot;www.baidu.com&quot;
    config['website']['name'] = &quot;百度&quot;

    # 保存
    config.write()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4yaml&quot;&gt;4.YAML&lt;/h2&gt;
&lt;p&gt;Python 操作 YAML 文件，常见的 2 种方式分别是：pyyaml、ruamel.yaml&lt;/p&gt;
&lt;p&gt;使用 pip 安装依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装依赖
# 方式一
pip3 install pyyaml

# 方式二
pip3 install ruamel.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面以一个简单的 YAML 配置文件为例，通过两种方式进行说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 水果
Fruits:
  # 苹果
  - Apple:
      name: apple
      price:  1
      address:  广东
  # 桔子
  - Orange:
      name: orange
      price:  3
      address:  湖南
  # 香蕉
  - Banana:
      name: banana
      price:  2
      address:  海南
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来看看 pyyaml&lt;/p&gt;
&lt;p&gt;4.1.1 读取配置文件&lt;/p&gt;
&lt;p&gt;首先，读取配置文件，使用 yaml.safe_load() 加载数据，获取的数据类型是字典&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import yaml

with open(file_path, &quot;r&quot;) as file:
    data = file.read()

    # safe_load() 读取配置文件
    # 结果数据类型：dict
    result = yaml.safe_load(data)

    print(result)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，就可以通过 YAML 配置文件的层级关系，获取键值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 3、获取yaml中的值
name = result['Fruits'][0]['Apple']['name']
price = result['Fruits'][0]['Apple']['price']
address = result['Fruits'][0]['Apple']['address']
print(&quot;名称:&quot;, name, &quot;,price:&quot;, price, &quot;,address:&quot;, address)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.1.2 写入配置文件&lt;/p&gt;
&lt;p&gt;使用 YAML 中的 dump() 方法，可以将一个字典写入到 YAML 配置文件中&lt;/p&gt;
&lt;p&gt;需要注意的是，为了保证中文写入能正常显示，需要配置 allow_unicode=True&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def write_to_yaml_file(content, file_path):
    &quot;&quot;&quot;
    写入到yaml文件中
    :param content:
    :param file_path:
    :return:
    &quot;&quot;&quot;

    # 写入到文件中
    with open(file_path, 'w', encoding='utf-8') as file:
        yaml.dump(content, file, default_flow_style=False, encoding='utf-8', allow_unicode=True)

# 定义一个字典
content = {
   &quot;websites&quot;: [{&quot;baidu&quot;: {'url': &quot;www.baidu.com&quot;, 'name': '百度', &quot;price&quot;: 100}},{&quot;alibaba&quot;: {'url': &quot;www.taobao.com&quot;, 'name': '淘宝', &quot;price&quot;: 200}},{&quot;tencent&quot;: {'url': &quot;www.tencent.com&quot;, 'name': '腾讯', &quot;price&quot;: 300}},]
}

write_to_yaml_file(content, &quot;./raw/new.yaml&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.1.3 修改配置文件&lt;/p&gt;
&lt;p&gt;和修改 ini 文件类型，先读取配置文件，然后修改字典中的内容，最后使用上面的写入方法，即可以达到修改配置文件的目的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def modify_yaml_file():
    &quot;&quot;&quot;
    修改yaml文件
    :return:
    &quot;&quot;&quot;
    content = read_yaml_file('./raw/norm.yaml')
    print(content)

    # 修改dict
    content['Fruits'][0]['Apple']['price'] = 10086

    # 重新写入到一个新的yaml文件中
    write_to_yaml_file(content, './raw/output.yaml')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们来聊聊使用 ruamel 操作 YAML 配置文件的流程&lt;/p&gt;
&lt;p&gt;ruamel 是 pyyaml 的衍生版本，在传统 pyyaml 的基础上，增加了 RoundTrip 模式，保证 YAML 配置文件的读写顺序一致&lt;/p&gt;
&lt;p&gt;所以，在读取、修改、写入方式上和 pyyaml 类似&lt;/p&gt;
&lt;p&gt;4.2.1 读取配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from ruamel import yaml

def read_yaml_file(file_path):
    &quot;&quot;&quot;
    读取yaml文件
    :param file_path:
    :return:
    &quot;&quot;&quot;
    with open(file_path, 'r', encoding='utf-8') as file:
        data = file.read()

        # 解析yaml文件
        # 类型：ordereddict
        result = yaml.load(data, Loader=yaml.RoundTripLoader)

        name = result['Fruits'][0]['Apple']['name']
        price = result['Fruits'][0]['Apple']['price']
        address = result['Fruits'][0]['Apple']['address']
        print(&quot;名称:&quot;, name, &quot;,price:&quot;, price, &quot;,address:&quot;, address)

    return result
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.2.2 写入配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def write_to_yaml_file(filepath, data):
    &quot;&quot;&quot;
    写入到yaml文件中
    :param filepath:
    :param data:
    :return:
    &quot;&quot;&quot;
    with open(filepath, 'w', encoding='utf-8') as file:
        yaml.dump(data, file, Dumper=yaml.RoundTripDumper, allow_unicode=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.2.3 修改配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def modify_yaml_file():
    &quot;&quot;&quot;
    修改yaml文件
    :return:
    &quot;&quot;&quot;
    content = read_yaml_file('./raw/norm.yaml')

    print(content)

    # 修改dict
    content['Fruits'][0]['Apple']['price'] = 10086

    # 重新写入到一个新的yaml文件中
    write_to_yaml_file('./raw/output.yaml', content)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5xml&quot;&gt;5.XML&lt;/h2&gt;
&lt;p&gt;XML 作为一种标记语言，被用来设计存储和传输数据，很多项目经常使用 XML 作为配置文件和数据传输类型&lt;/p&gt;
&lt;p&gt;Python 内置的 xml 模块 可以很方便地处理 XML 配置文件&lt;/p&gt;
&lt;p&gt;以下面这段配置文件为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;dbconfig&amp;gt;
    &amp;lt;mysql&amp;gt;
        &amp;lt;host&amp;gt;127.0.0.1&amp;lt;/host&amp;gt;
        &amp;lt;port&amp;gt;3306&amp;lt;/port&amp;gt;
        &amp;lt;dbname&amp;gt;test&amp;lt;/dbname&amp;gt;
        &amp;lt;username&amp;gt;root&amp;lt;/username&amp;gt;
        &amp;lt;password&amp;gt;4355&amp;lt;/password&amp;gt;
    &amp;lt;/mysql&amp;gt;
&amp;lt;/dbconfig&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，使用 xml.dom.minidom.parser(file_path) 解析配置文件，利用 documentElement 属性获取 XML 根节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import xml.dom.minidom

# 读取配置文件
dom = xml.dom.minidom.parse(&quot;./raw.xml&quot;)

# 利用 documentElement 属性获取 XML 根节点
# 根节点
root = dom.documentElement
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，使用 getElementsByTagName(tag_name) 方法，获取某一节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 获取mysql节点
node_mysql = root.getElementsByTagName('mysql')[0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，使用 childNodes 属性，遍历节点的子 Node 节点，获取节点的名称和值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 遍历子节点，获取名称和值
for node in node_mysql.childNodes:
    # 节点类型
    # 1：Element
    # 2：Attribute
    # 3：Text
    # print(node.nodeType)
    if node.nodeType == 1:
        print(node.nodeName, node.firstChild.data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6最后&quot;&gt;6.最后&lt;/h2&gt;
&lt;p&gt;到此，Python 数据全家桶以全部完结！&lt;/p&gt;
&lt;p&gt;我已经将文中全部源码上传到后台，关注公众号「 &lt;strong&gt;AirPython&lt;/strong&gt; 」后回复「 &lt;strong&gt;dball&lt;/strong&gt; 」即可获得全部源码&lt;/p&gt;
&lt;p&gt;如果你觉得文章还不错，请大家 &lt;strong&gt;点赞、分享、留言&lt;/strong&gt;下，因为这将是我持续输出更多优质文章的最强动力！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486468&amp;amp;idx=2&amp;amp;sn=7c8cdfb478e5801496dad8b0ddf2061e&amp;amp;chksm=fc1b72c4cb6cfbd2e71861ddb8aa5d6c2ba3d4266ede047cfaf0558e6cd4e5b05a9ecca4dcdc&amp;amp;scene=21#wechat_redirect&quot;&gt;聊聊 Python 数据处理全家桶（Mysql 篇）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486487&amp;amp;idx=1&amp;amp;sn=78b344b45366c4b8ffd195b2ce300191&amp;amp;chksm=fc1b72d7cb6cfbc106f1a820db3d0f7ee07f22f0a7af0525952fb82a9ed87ef00675a2c18b3a&amp;amp;scene=21#wechat_redirect&quot;&gt;聊聊 Python 数据处理全家桶（Sqlite 篇）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486517&amp;amp;idx=1&amp;amp;sn=01d43b1cd83c7caef94f06614fd42c02&amp;amp;chksm=fc1b72f5cb6cfbe39cef5a63b64c332c6b9cd2e329cc4373a72d460ca84d44e7637d5c6ae06b&amp;amp;scene=21#wechat_redirect&quot;&gt;聊聊 Python 数据处理全家桶（Redis 篇）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486553&amp;amp;idx=1&amp;amp;sn=06c97f43e68be307a6826e74ec126f29&amp;amp;chksm=fc1b7299cb6cfb8f8a6e99598327c240f9147dffeb79627d8848d465727ae8c3081e818b204d&amp;amp;scene=21#wechat_redirect&quot;&gt;聊聊 Python 数据处理全家桶（Memc 篇）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1OTI0NjI1NQ==&amp;amp;mid=2247486582&amp;amp;idx=2&amp;amp;sn=a1ec46619e543046994823d82df48dd7&amp;amp;chksm=fc1b72b6cb6cfba0a875a4931f4ce482307725076c285c6a3210a0e75b8082041ea17ae7abab&amp;amp;scene=21#wechat_redirect&quot;&gt;聊聊 Python 数据处理全家桶（Mongo 篇）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Oct 2020 10:29:00 +0000</pubDate>
<dc:creator>AirPython</dc:creator>
<og:description>1.前言 在实际项目中，经常会接触到各种各样的配置文件，它可以增强项目的可维护性 常用配件文件的处理方式，包含：JSON、ini / config、YAML、XML&amp;amp;#160;等 本篇文章，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xingag/p/13778338.html</dc:identifier>
</item>
</channel>
</rss>