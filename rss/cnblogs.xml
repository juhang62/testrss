<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小代学Spring Boot之集成MyBatis - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11211077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11211077.html</guid>
<description>[unable to retrieve full-text content]想要获取更多文章可以访问我的博客 &quot;代码无止境&quot; 。 上一篇小代同学在Spring Boot项目中配置了数据源，但是通常来讲我们访问数据库都会通过一个ORM框架，很少会直接使用JDBC来执行数据库操作的。这么多ORM框架，选择哪个好呢？ 小代选ORM框架 小代同学最终选用的ORM框架是MyBatis</description>
<pubDate>Fri, 19 Jul 2019 00:18:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11211077.html</dc:identifier>
</item>
<item>
<title>.net持续集成cake篇之cake任务依赖、自定义配置荐及环境变量读取 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11211066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11211066.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;新建一个构建任务及任务依赖关系设置&quot;&gt;新建一个构建任务及任务依赖关系设置&lt;/h2&gt;
&lt;p&gt;上节我们通过新建一个HelloWorld示例讲解了如何编写build.cake以及如何下载build.ps1启动文件以及如何运行.实际项目中,我们使用最多的是对项目进行编译.本节我们讲解如何创建一个编译任务.&lt;/p&gt;
&lt;h3 id=&quot;添加一个编译任务&quot;&gt;添加一个编译任务&lt;/h3&gt;
&lt;p&gt;我们仍然使用上节使用的build.cake文件,我们复制一下Default任务,并把它改名为&lt;code&gt;BuildProject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Task(&quot;BuildProject&quot;)
.Does(() =&amp;gt; {
    Information(&quot;Hello World!&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上一节代码我们可以看到Information方法仅仅输出了一行信息,对我们构建可能并没太大作用.&lt;code&gt;Cake&lt;/code&gt;提供了一个&lt;code&gt;Msbuild&lt;/code&gt;方法,我们可以使用该方法来编译我们的项目,修改后的代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Task(&quot;BuildProject&quot;)
.Does(() =&amp;gt; {
    MSBuild(&quot;buildDemo.sln&quot;);//我的项目名称叫作buildDemo.sln,这里改为你的实际项目名
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完以上代码后我们运行,发现构建并没有执行,这是因为这里我们仅仅是定义了一个Task,并没有执行它,我们需要显式地执行这个任务&lt;/p&gt;
&lt;h3 id=&quot;修改runtarget方法&quot;&gt;修改RunTarget方法&lt;/h3&gt;
&lt;p&gt;最下面的Runtarget默认接收的参数叫作target,我们 把它替换为&lt;code&gt;BuildProject&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改后代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;RunTarget(&quot;BuildProject&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们再执行&lt;code&gt;build.ps1&lt;/code&gt;可以发现编译任务执行的(我们可以进到项目目录下,看到目录下生成了bin目录,bin目录下面生成了debug目录,里面有编译的文件),如果bin目录已经存在,我们可以把它删除了,然后再执行任务,看看是否生成了bin目录.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;RunTarget是通过任务的名称来确定要执行的任务的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过以上简单的命令我们就实现了自动编译一个.net项目,Cake的强大之处还有很多,远不止于此,后面我们会有更多小节来讲我解Cake的功能.&lt;/p&gt;
&lt;h3 id=&quot;设置任务依赖关系&quot;&gt;设置任务依赖关系&lt;/h3&gt;
&lt;p&gt;上面我们修改了&lt;code&gt;RunTarget&lt;/code&gt;的参数让它不再执行默认任务,而是来执行&lt;code&gt;BuildProject&lt;/code&gt;,如果我们想要执行Default任务又需要修改代码来让它执行默认任务,如果我们有很多个任务,这样修改很明显是很繁琐的,也与自动化构建格格不入(频繁修改脚本严重背离了自动化初衷)&lt;/p&gt;
&lt;p&gt;其实我们可能通过设置任务依赖,让默认任务依赖于构建任务,这样在执行default之前会先执行构建任务,达到了两个任务都被执行的目的.代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;Task(&quot;BuildProject&quot;)
.Does(() =&amp;gt; {
    MSBuild(&quot;buildDemo.sln&quot;);
});
Task(&quot;Default&quot;)
.IsDependentOn(&quot;BuildProject&quot;)
.Does(() =&amp;gt; {
    Information(&quot;Hello World!&quot;);
});

RunTarget(target);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Task的&lt;code&gt;IsDependentOn&lt;/code&gt;方法,我们可以设置Default任务依赖于&lt;code&gt;BuildProject&lt;/code&gt;任务&lt;/p&gt;
&lt;p&gt;通过以上我们仅仅是为了让&lt;code&gt;BuildProject&lt;/code&gt;和&lt;code&gt;Default&lt;/code&gt;两个任务同时运行,并不能看到任务依赖作用的具体体现,实际项目中,我们为了编译一个项目,首先要还原Nuget包,为了运行单元测试,首先要编译项目.如果步骤错了,将会导致构失败.&lt;/p&gt;
&lt;h2 id=&quot;变量的设置及读取&quot;&gt;变量的设置及读取&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;在一些复杂的构建任务中,往往不可能只运行一个固定脚本就万事大吉,还需要根据实际需要在构建时传入各种构建参数.将一些可能需要经常修改的项通过参数暴露出来往往也是一种良好的设计,极大地增加了构建的灵活性.当然一切还需要以实际需求为准,不能为了设计而设计,暴露过多配置项同时会增加使用者的压力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第一节HelloWorld示例中我们的代码里最前面是两段这样的代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var target = Argument(&quot;target&quot;, &quot;Default&quot;);
var configuration = Argument(&quot;configuration&quot;, &quot;Release&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面章节我们只讲解了任务及简单介绍了Setup和TearDown两个特殊任务,并没有讲解上面这两段代码的来龙去脉,这节我们把它们弄清楚.&lt;/p&gt;
&lt;p&gt;我们一开始就说过Cake文件里的代码都是C#代码,也都必须符合C#语法规范.上面两段代码都包含&lt;code&gt;var&lt;/code&gt;关键字,在C#里 &lt;code&gt;var&lt;/code&gt;是用来声明一个变量的,实际上这里也确实是声明了两个变量,其中&lt;code&gt;Argument&lt;/code&gt;带有括号,里面接收两个参数,在C#里它是方法,其中第一个参数是变量的名,第二个参数为变量的默认值.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在RunTarget方法里默认传入的是target变量,它的默认值是&lt;code&gt;Default&lt;/code&gt;,因此会去执行名字为&lt;code&gt;Default&lt;/code&gt;的任务,至此,我们应该明白为什么任务&lt;code&gt;Default&lt;/code&gt;会执行了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们输入下configuration看看它的值是什么&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var target = Argument(&quot;target&quot;, &quot;Default&quot;);
var configuration = Argument(&quot;configuration&quot;, &quot;Release&quot;);
Information($&quot;变量configuration的值是:{configuration}&quot;);
return;
//下面的代码省略&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们说过Cake代码实际上是C#代码,因此我们可以大但地使用C#语法,这里使用return是为了调试方便,程序运行到这里就中止了,以防执行的任务过多执行的时间过长.&lt;/p&gt;
&lt;p&gt;执行后我们可以看到输入的是&lt;code&gt;变量configuration的值是:Release&lt;/code&gt;,target的值是Default,configuration的值是Release,这和直接定义变量没有什么太大区别&lt;code&gt;比如直接定义var target=Default&lt;/code&gt;这样更为方便.&lt;/p&gt;
&lt;p&gt;前面我们说过,Argument方法接收两个参数,第一个是变量的名称,其中变量是可以通过外部传递进来的,这样就极大的增加了灵活性.&lt;/p&gt;
&lt;h2 id=&quot;执行启动脚本时传入参数&quot;&gt;执行启动脚本时传入参数&lt;/h2&gt;
&lt;p&gt;通过从外部传入参数,这样就极大增加了脚本的灵活性,我们可以根据传入的参数来决定要执行的逻辑从而不同的构建任务只需要修改参数而不需要修改脚本就能达到适应不同构建的目的.&lt;/p&gt;
&lt;p&gt;前面执行build.ps1脚本的时候我们什么参数也没有传入,这里我们传入configuration,代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;.\build.ps1 -ScriptArgs &quot;--configuration=Debug&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在powershell里执行以上脚本,我们可以看到输入的内容变量了&lt;code&gt;变量configuration的值是:Debug&lt;/code&gt;,可以看到Cake脚本Argument方法已经接收到了名为&lt;code&gt;configuration&lt;/code&gt;的变量的值,这里使用的是传入的值,而不再是默认值&lt;/p&gt;
&lt;h2 id=&quot;传入其它类型的值&quot;&gt;传入其它类型的值&lt;/h2&gt;
&lt;p&gt;上面定义的两个变量都是字符串类型的值,很多时候我们需要传入布尔值,或者int类型的值,当然我们可以通过c#内置的转换命令把字符串转换为目标类型,然而我们不需要这么做,Argument是一个泛型方法,可以接收泛型参数.例如以下会得到一个Int的变量&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var num=Argument&amp;lt;int&amp;gt;(&quot;num&quot;,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;默认值不是必须的,但是强烈建议代上默认值,如果没有默认值,则必须传入相应的参数,否则执行的时候就会报错.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;获取环境变量值&quot;&gt;获取环境变量值&lt;/h2&gt;
&lt;p&gt;对于一些复杂的构建,我们可能需要获取环境变量的值,当然我们可以通过.net内置的方法来获取环境变量的值,实际上Cake提供的简单的方法来获取环境变量的值,举例我们想要获取javahome环境变量的值,可以通过以下代码获取&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var javaHome=EnvironmentVariable(&quot;JAVA_HOME&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们都知道&lt;code&gt;JAVA_HOME&lt;/code&gt;为java_home环境变量的key,通过这个key来获取环境变量的值.&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;以上获取的都是简单的键值对,如果是复杂的对象,则无法通过上述方法获取,我们说过,这里再强调一遍,cake实际上使用的就是C#语言,因此我们可以通过自己写代码来解析xml,json或者文本文档等获取复杂的配置,并转成实体对象.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Jul 2019 00:09:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 新建一个构建任务及任务依赖关系设置 上节我们通过新建一个HelloWorld示例讲解了如何编写build.cake以及如何下载build.ps1启动文件以及如何运行.实际项目中,我们使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11211066.html</dc:identifier>
</item>
<item>
<title>springcloud-高可用部署 - 软件老王</title>
<link>http://www.cnblogs.com/ruanjianlaowang/p/11211052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruanjianlaowang/p/11211052.html</guid>
<description>&lt;h3 id=&quot;场景描述&quot;&gt;1.场景描述&lt;/h3&gt;
&lt;p&gt;前端时间只简单介绍了下springcloud的高可用方案（&lt;a href=&quot;https://www.cnblogs.com/ruanjianlaowang/p/11182716.html&quot;&gt;springcloud高可用方案&lt;/a&gt;），今天详细介绍下如何实施springcloud的高可用部署。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;2.解决方案&lt;/h3&gt;
&lt;h4 id=&quot;架构方案&quot;&gt;2.1 架构方案&lt;/h4&gt;
&lt;h5 id=&quot;架构图&quot;&gt;2.1.1 架构图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1727736/201907/1727736-20190719075817608-1087881069.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;访问地址&quot;&gt;2.1.2 访问地址&lt;/h5&gt;
&lt;p&gt;（1）Gateway访问地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; http://10.192.168.11:9000/client/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）Client地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://10.192.168.14:9001，http://10.192.168.14:9002/，http://10.192.168.15:9003/，http://10.192.168.15:9004/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）Eureka地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://10.192.168.12:8761/，http://10.192.168.13:8761/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;方案说明&quot;&gt;2.1.3 方案说明&lt;/h5&gt;
&lt;p&gt;（1）从springcloud架构中，可以了解到，注册中心和网关会成为单点故障率比较高的点，有可能会成为瓶颈。&lt;/p&gt;
&lt;p&gt;（2）高可用方案大概思路是：部署多个注册中心和多个应用，实现单点故障后自动切换，无须人工干预。（网关高可用最后有说明）&lt;/p&gt;
&lt;h4 id=&quot;注册中心部署&quot;&gt;2.2 注册中心部署&lt;/h4&gt;
&lt;p&gt;需修改配置文件：application.yml。&lt;/p&gt;
&lt;h5 id=&quot;注册中心配置&quot;&gt;2.2.1 注册中心配置&lt;/h5&gt;
&lt;p&gt;（1）注册中心1（10.192.168.12）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  application:
    name: registry
server:
  port: 8761
eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://10.192.168.13:8761/eureka&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）注册中心2（10.192.168.13）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  application:
    name: registry
server:
  port: 8761
eureka:
  client:
    register-with-eureka: false
    service-url:
      defaultZone: http://10.192.168.12:8761/eureka&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;说明&quot;&gt;2.2.2 说明&lt;/h5&gt;
&lt;p&gt;重点是defaultZone这个配置，注册中心1要作为客户端配置注册中心2的服务地址，注册中心2要作为客户端配置注册中心1的服务地址，这样就实现了互为注册，&lt;strong&gt;并且还有最重要的一点，注册的客户端也会在注册中心之间相互同步。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;应用部署&quot;&gt;2.3 应用部署&lt;/h4&gt;
&lt;h5 id=&quot;应用配置文件&quot;&gt;2.3.1 应用配置文件&lt;/h5&gt;
&lt;p&gt;需修改配置文件：application.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eureka:
    client:
        service-url:
            defaultZone:  http://10.66.211.12:8761/eureka/,http://10.66.211.13:8761/eureka/
        healthcheck:
            enabled: true
        instance:
            lease-expiration-duration-in-seconds: 30
            lease-renewal-interval-in-seconds: 10
        registry-fetch-interval-seconds: 5
server:
    port: 9001
spring:
    application:
         name: client
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;重点还是defaultZone这项配置，这里要写成两个注册中心的地址，以逗号分开，这样一台出现单点故障的话，另一台还能正常访问，并且故障注册中心恢复后，会自动从另一台注册中心同步注册客户端信息。&lt;/p&gt;
&lt;h5 id=&quot;应用部署-1&quot;&gt;2.3.2 应用部署&lt;/h5&gt;
&lt;p&gt;（1）将注册服务客户端在多台服务器部署，同一台服务器的话，以端口号区分下，只部署一台的话，可以使用默认端口号。&lt;/p&gt;
&lt;p&gt;（2）本项目是使用了在10.192.168.14和10.192.168.15服务器上都部署了两个应用实例。&lt;/p&gt;
&lt;p&gt;其中项目配置文件application.yml如上，重点说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
    application:
         name: client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：client是注册的名称，部署的实例都要是这个，路由会根据名称来查找应用，例如本项目部署了4个应用实例，默认实行轮询访问的方式。&lt;/p&gt;
&lt;h4 id=&quot;高可用访问&quot;&gt;2.4 高可用访问&lt;/h4&gt;
&lt;p&gt;访问地址（路由地址）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; http://10.192.168.11:9000/client/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求会在四个应用实例（9001-9004）之间进行轮询访问，这样就实现了注册中心与应用客户端的高可用。&lt;/p&gt;
&lt;h4 id=&quot;关于网关高可用&quot;&gt;2.5 关于网关高可用&lt;/h4&gt;
&lt;p&gt;关于网关的高可用，我们没有实际部署，不过可以参看greenplum的高可用方案（&lt;a href=&quot;https://www.cnblogs.com/ruanjianlaowang/p/11182499.html&quot;&gt;Greenplum高可用真的高吗？&lt;/a&gt;），结合keepalived来实现网关的高可用，参考架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1727736/201907/1727736-20190719075831637-1419687208.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;I'm 软件老王，如果觉得还可以的话，关注下呗！如有不准确或疑问的地方，可通过讨论区、QQ沟通，多谢！&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jul 2019 00:01:00 +0000</pubDate>
<dc:creator>软件老王</dc:creator>
<og:description>springcloud-高可用部署</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruanjianlaowang/p/11211052.html</dc:identifier>
</item>
<item>
<title>PCB SQL SERVER 数据库阻塞进程关系以思维导图方式呈现的实现方法 - pcbren</title>
<link>http://www.cnblogs.com/pcbren/p/11210887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pcbren/p/11210887.html</guid>
<description>&lt;p&gt;            最近公司数据库同步机制常发生阻塞,时不时的导致PCB工程系统卡死现象，只有找到阻塞源头并处理掉，才以消除阻塞，但数据库中查看会话阻塞是通过二维表方式展示的父子会话进程ID的，是很难清楚的展示各会话进程ID的关系图的。&lt;/p&gt;
&lt;p&gt;举例：这好比公路上的汽车我们开车前行，遇到前方塞车了，前方的车阻塞你，但后方又继续来车，你也成为后方的车阻塞者。&lt;/p&gt;
&lt;p&gt;如果能以思维导图的方式展示那不完美了，&lt;em id=&quot;__mceDel&quot;&gt;我们可以通过此图可很快的找找到阻焊塞的源头，只要把源头打通，道路才能保持畅通。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190719001803715-641406449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 一.阻塞查询相关SQL语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;em id=&quot;__mceDel&quot;&gt;查询当前数据库阻塞：&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sys.sysprocesses &lt;span&gt;where&lt;/span&gt; blocked&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询阻塞的会话在执行的SQL以及运行状态：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sys.sysprocesses &lt;span&gt;where&lt;/span&gt; spid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查询阻塞会话执行所有DB库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sys.sysdatabases &lt;span&gt;WHERE&lt;/span&gt; dbid &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过sql_handle句柄来查询正在跑的SQL的SQL_TEXT文本内容，即SQL内容:&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; ::FN_GET_SQL(&lt;span&gt;0x0300FF7F587A2F063508ED005E9B000001000000&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除进程会话ID&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt; 二.阻塞进程思维导图----展示效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过如图展示,非常清楚的知道阻塞进程源头来自哪个进程号了【源头:会话进程ID  536导致整个数据库阻塞】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201907/733296-20190718234911217-585814946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 三.HTML实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       HTML实现代码:(用百度他们家的echar套用数据即可实现)&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;p&gt;&lt;strong&gt; 四.阻塞进程数据源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;     &lt;span&gt;通过此SQL取出2部份数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     1.EChart nodes 节点数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2.EChart links 关连关系数据&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询当前数据库阻塞进程插入临时表&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; #sysprocesses &lt;span&gt;FROM&lt;/span&gt;  sys.sysprocesses &lt;span&gt;where&lt;/span&gt; blocked&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;获取进程节点【数据给到EChart nodes】  &lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;将数据按3个等级分类，按实例图展示效果&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   {category:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;  (&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; PerentCount &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; ChildCount &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;END&lt;/span&gt;)  &lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name: &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(spid &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;))  
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;, value : &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;  (&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; PerentCount &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; ChildCount &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;END&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;},&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
(
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;  
        (&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;FROM&lt;/span&gt; #sysprocesses  &lt;span&gt;WHERE&lt;/span&gt; blocked &lt;span&gt;=&lt;/span&gt;&lt;span&gt; t.spid) ChildCount
        ,(&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;COUNT&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;FROM&lt;/span&gt; #sysprocesses  &lt;span&gt;WHERE&lt;/span&gt; spid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; t.spid) PerentCount
        ,spid
    &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; 
    (
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; spid spid
    &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; #sysprocesses
    &lt;/span&gt;&lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; 
    &lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; blocked spid
    &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; #sysprocesses
    ) t
    &lt;/span&gt;&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; spid
) t


&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;获取节点之前的关连关系【数据给到EChart links】&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{source : &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(spid &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;, target : &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(blocked &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;, weight : 1},&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; #sysprocesses


&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; #sysprocesses
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Thu, 18 Jul 2019 16:31:00 +0000</pubDate>
<dc:creator>pcbren</dc:creator>
<og:description>最近公司数据库同步机制常发生阻塞,时不时的导致PCB工程系统卡死现象，只有找到阻塞源头并处理掉，才以消除阻塞，但数据库中查看会话阻塞是通过二维表方式展示的父子会话进程ID的，是很难清楚的展示各会话进程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pcbren/p/11210887.html</dc:identifier>
</item>
<item>
<title>公司技术大咖分享会--后记 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/11210880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/11210880.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;公司技术大咖分享会--后记&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天下午公司内部召开了个后台开发人员技术分享会，总共7个人，兵不在多；三个华为资深大咖给我们分享了程序员那些事，凭我仅有的记忆现在把它记下，希望对之后的职业生涯有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回想当时，分享的内容可以概括为三个大点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）关于设计文档那些事；&lt;br/&gt;2）大咖十几年开发经验分享；&lt;br/&gt;3）大家相互交流，提出意见和建议等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于设计文档那些事：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、做软件开发要接受一个现实，那就是软件开发就是不个断发现错误的过程，一定不是完美的，所以设计文档要速出，由粗到细，常见的问题就是完美主义(尤其是新手)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、设计文档做到一定程度，它其实是有套路的，主要组成如下：&lt;br/&gt;架构：数据模型、接口定义；&lt;br/&gt;流程：正常流程、异常场景；设计&lt;br/&gt;交叉影响：配置接口、数据库、可靠性、性能等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、设计文档中最重要的就是场景(处理过程)：正常场景、异常场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、在设计文档之前可以有个可行性探索。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、设计文档的好处：&lt;br/&gt;a. 逼迫思考场景(CASE的实质就是场景)，文档写得好，编码不乱；&lt;br/&gt;b. 设计文档能够指导整个开发流程，包括编码、接口文档和测试用例，所有出现的问题都可以追溯到设计文档中；&lt;br/&gt;c. 出了设计文档，可以工程方式编码(实现就是细节问题)；&lt;br/&gt;d. 提醒自己反复思考，提升理解，寻求更好的实现方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、设计文档最怕的就是设计遗漏了场景，及时地把发出来后，能够尽早发现问题，大家看了可以提出建议，比如自己设计漏了哪些场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、设计文档是用于指导自己下一步的工作，包括编码、接口文档和测试用例的全程指导，而不是写给领导看的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、设计文档写得详细了，让别人能够看得懂，才能给自己提意见，才可以使得自己做的事更好，设计存在的异常和漏洞就更少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、记得在设计文档里面列出一个提纲(包括文档中设计的各大功能点)，由提纲深入架构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10、写设计文档没有用吗？文档可以保证你开发点不漏，思路清晰，水平高的人，写设计文档水平也高，最高的就是去写标准，如HTTP、RFC等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11、为什么要研究标准呢？比如两个系统对接出了问题怎么办，谁改，改的依据是啥？通过浏览协议，发现协议上是这么定义的，某个字段定义了不能透传，传了那你就要改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12、写设计文档对于写作的功底还是有要求的，表达条理清晰，让自己和他人看得懂，也不要以为存在错别字并不重要，影响个人形象只是其一(假如某天你和Boss一起编写一个设计文档)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;13、实际上设计文档对应着就是一个分解的步骤，再难的事情，都可以分解成一件件小事去完成，对应着正常和异常的场景去设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14、要有机会去写设计文档，大胆地发出分享自己的设计文档，同时再简单的开发也要先完成设计文档后编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;14、设计文档中要配上原型图(低保真界面图)，手段不重要，不会画图也不是关键，有以下几个方式：&lt;br/&gt;a. 使用原型设计软件&lt;br/&gt;下载地址：&lt;a href=&quot;https://www.mockplus.cn/&quot; target=&quot;_blank&quot;&gt;https://www.mockplus.cn/&lt;/a&gt;，需要用邮箱注册个人免费版；&lt;br/&gt;b. 使用Excel表格画原型图；&lt;br/&gt;c. 手笔草稿画图，手机拍照上传。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;经验分享&amp;amp;意见建议&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1、经验从何而来，一切都顺利是否是好事呢？&lt;br/&gt;并非好事，因为如果一切都很顺利，那么成长值将为0；如果你总是在做增删改查，发现自己总是在重复劳动，那么成长就是零；应该像海绵一样去吸收相关的附加点，且遇到的问题越多越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、知识技能体系，成长体系？&lt;br/&gt;这些知识体系并不会因为你没有掌握和注意，该体系就不存在，体系实际是重要的成长目标牵引；比如MySQL这个体系，你也许会安装和简单的使用Mysql，但是比如Mysql优化和高级搜索里面的某些东西你不一定懂，而他确实是存在的，确实也是有开发人员掌握了的，此时自己要想办法覆盖这整个体系，完善自己的知识技能树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、问题处理是练兵的利器？&lt;br/&gt;问题单处理流程实际上是处理问题的通用流程；问题单处理多了，你自然就会思考，这个问题为什么要这样子处理，为何是这个流程呢？然后，慢慢的这个东西就会融入了你的血液，成为你身体的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、对于个人成长，当下最重要的是什么？&lt;br/&gt;最重要的是结合当前自己的工作，填充自己欠缺的知识技能，出色的完成上级安排的任务；因为如果连上班8小时，本职的工作都做不好，还能在其他的领域有杰出突破贡献吗？工作的思考：不要重复工作，对于那些必不得已得重复的工作要搞出花来，比如很快地完成或是搞个工具自带完成等待；一些优秀的书籍会限制你认识事物的上限；刚刚毕业1~2年的小伙子，最重要的是自己要学会思考，多上上心；开发人员的基本功最为重要，同时要覆盖自己的知识技能体系，你的对手永远都只是你自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、事务分解能力？&lt;br/&gt;包括问题处理和需求开发，再难的任务都可以分解成一件件小事去完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、作为后台开发人员，要怎么解决问题呢？&lt;br/&gt;首先是问题描述，该问题一定是可以复现的，现象出来后你的定位思路是如何，然后你的定位过程是如何，最终你解决的问题一定是你定位出来的而且是能重现的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发人员面对问题时有两种态度：&lt;br/&gt;1、遇到问题直接面对他，解决他；&lt;br/&gt;2、遇到问题绕过去，绕过去就是上面所提到的顺不顺利的问题，如果绕过去了，就失去了一个成长的机会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理问题：&lt;br/&gt;最重要的一点就是要先把问题复现，然后根据它的现象推测，有可能是哪些问题，再通过日志打印判断大概问题出在哪里，或是根据消息，查看消息里面携带的参数，看书在哪一步出的问题，正常的流程是怎样的，异常的又是怎样的，有可能是几种流程，大胆的猜测验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复现---&amp;gt;定界(前后端问题、哪个模块问题)---&amp;gt;推测---&amp;gt;打印、消息、日志、参数---&amp;gt;99%的问题都是可以通过Debug(本地Dubug和远程Debug)和日志解决。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;杨总给我的建议是：性格调整下，多与人沟通交流。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jul 2019 16:27:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>公司技术大咖分享会--后记 今天下午公司内部召开了个后台开发人员技术分享会，总共7个人，兵不在多；三个华为资深大咖给我们分享了程序员那些事，凭我仅有的记忆现在把它记下，希望对之后的职业生涯有所帮助。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/taojietaoge/p/11210880.html</dc:identifier>
</item>
<item>
<title>《ElasticSearch6.x实战教程》之简单的API - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11210870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11210870.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;万丈高楼平地起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES提供了多种操作数据的方式，其中较为常见的方式就是RESTful风格的API。&lt;/p&gt;
&lt;p&gt;简单的体验&lt;/p&gt;
&lt;p&gt;利用Postman发起HTTP请求（当然也可以在命令行中使用curl命令）。&lt;/p&gt;
&lt;h2 id=&quot;索引index&quot;&gt;索引Index&lt;/h2&gt;
&lt;h3 id=&quot;创建索引&quot;&gt;创建索引&lt;/h3&gt;
&lt;p&gt;创建一个名叫&lt;code&gt;demo&lt;/code&gt;的索引：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PUT http://localhost:9200/demo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;jso&quot;&gt;
&lt;code&gt;{
    &quot;acknowledged&quot;: true,
    &quot;shards_acknowledged&quot;: true,
    &quot;index&quot;: &quot;demo&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建索引时，可指定主分片和分片副本的数量：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PUT http://localhost:9200/demo&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;settings&quot;:{
        &quot;number_of_shards&quot;:1,
        &quot;number_of_replicas&quot;:1
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;jso&quot;&gt;
&lt;code&gt;{
    &quot;acknowledged&quot;: true,
    &quot;shards_acknowledged&quot;: true,
    &quot;index&quot;: &quot;demo&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看指定索引&quot;&gt;查看指定索引&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GET http://localhost:9200/demo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;demo&quot;: {
        &quot;aliases&quot;: {},
        &quot;mappings&quot;: {},
        &quot;settings&quot;: {
            &quot;index&quot;: {
                &quot;creation_date&quot;: &quot;1561110747038&quot;,
                &quot;number_of_shards&quot;: &quot;1&quot;,
                &quot;number_of_replicas&quot;: &quot;1&quot;,
                &quot;uuid&quot;: &quot;kjPqDUt6TMyywg1P7qgccw&quot;,
                &quot;version&quot;: {
                    &quot;created&quot;: &quot;5060499&quot;
                }, 
                &quot;provided_name&quot;: &quot;demo&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询es中的索引&quot;&gt;查询ES中的索引&lt;/h3&gt;
&lt;p&gt;查询ES中索引情况：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET http://localhost:9200/_cat/indices?v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;yellow&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;td&gt;demo&lt;/td&gt;
&lt;td&gt;wqkto5CCTpWNdP3HGpLfxA&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;810b&lt;/td&gt;
&lt;td&gt;810b&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;yellow&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;td&gt;.kibana&lt;/td&gt;
&lt;td&gt;pwKW9hJyRkO7_pE0MNE05g&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3.2kb&lt;/td&gt;
&lt;td&gt;3.2kb&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到当前ES中一共有2个索引，一个是我们刚创建的&lt;code&gt;demo&lt;/code&gt;，另一个是kibana创建的索引&lt;code&gt;.kibana&lt;/code&gt;。表格中有一些信息代表了索引的一些状态。&lt;/p&gt;
&lt;p&gt;health：健康状态，red表示不是所有的主分片都可用，即&lt;strong&gt;部分主分片可用&lt;/strong&gt;。yellow表示主分片可用备分片不可用，常常是单机ES的健康状态，greens表示所有的主分片和备分片都可用。（官方对集群健康状态的说明，&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/guide/master/cluster-health.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/guide/master/cluster-health.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;status：索引状态，open表示打开可对索引中的文档数据进行读写，close表示关闭此时索引占用的内存会被释放，但是此时索引不可进行读写操作。&lt;/p&gt;
&lt;p&gt;index：索引&lt;/p&gt;
&lt;p&gt;uuid：索引标识&lt;/p&gt;
&lt;p&gt;pri：索引的主分片数量&lt;/p&gt;
&lt;p&gt;rep：索引的分片副本数量，1表示有一个分片副本（有多少主分片就有多少备分片，此处表示5个备分片）。&lt;/p&gt;
&lt;p&gt;docs.count：文档数量&lt;/p&gt;
&lt;p&gt;docs.deleted：被删除的文档数量&lt;/p&gt;
&lt;p&gt;store.size：索引大小&lt;/p&gt;
&lt;p&gt;pri.store.size：主分片占用的大小&lt;/p&gt;
&lt;h3 id=&quot;删除索引&quot;&gt;删除索引&lt;/h3&gt;
&lt;p&gt;删除&lt;code&gt;demo&lt;/code&gt;索引，&lt;strong&gt;删除索引等同于删库跑路，请谨慎操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DELETE http://localhost:9200/demo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;acknowledged&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类型type同时定义映射mapping字段及类型&quot;&gt;类型Type（同时定义映射Mapping字段及类型）&lt;/h2&gt;
&lt;h3 id=&quot;创建类型&quot;&gt;创建类型&lt;/h3&gt;
&lt;p&gt;在前面&lt;strong&gt;基本术语&lt;/strong&gt;中我们提到类型Type类似关系型数据库中的表，映射Mapping定义表结构。创建类型Type时需要配合映射Mapping。&lt;/p&gt;
&lt;p&gt;创建索引&lt;code&gt;demo&lt;/code&gt;的类型为&lt;code&gt;example_type&lt;/code&gt;,包含两个字段：&lt;code&gt;created&lt;/code&gt;类型为date，&lt;code&gt;message&lt;/code&gt;类型为keyword：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT http://localhost:9200/demo/_mapping/example_type

{
    &quot;properties&quot;:{
        &quot;created&quot;:{
            &quot;type&quot;:&quot;date&quot;
        },
        &quot;message&quot;:{
            &quot;type&quot;:&quot;keyword&quot;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时再次执行查询索引的操作，已经可以发现类型Type被创建了，遗憾的是，如果类型Type（或者映射Mapping）一旦定义，就不能删除，只能修改，为了保证本教程顺利进行方式二创建类型，所以此处执行&lt;code&gt;DELETE http://localhost:9200/demo&lt;/code&gt;删除索引。删除索引后不要再创建索引，下面的这种方式是在创建索引的同时创建Type并定义Mapping&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT http://localhost:9200/demo
{
    &quot;mappings&quot;:{
        &quot;example_type&quot;:{
            &quot;properties&quot;:{
                &quot;created&quot;:{
                    &quot;type&quot;:&quot;date&quot;
                },
                &quot;message&quot;:{
                    &quot;type&quot;:&quot;keyword&quot;
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时执行&lt;code&gt;GET http://localhost:9200/demo&lt;/code&gt;，可以看到我们在ES中创建了第一个索引以及创建的表结构，接下来插入就是数据（即文档）。&lt;/p&gt;
&lt;h2 id=&quot;文档document&quot;&gt;文档Document&lt;/h2&gt;
&lt;h3 id=&quot;插入文档&quot;&gt;插入文档&lt;/h3&gt;
&lt;p&gt;系统定义&lt;code&gt;_id&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST http://localhost:9200/demo/example_type
{
    &quot;created&quot;:1561135459000,
    &quot;message&quot;:&quot;test1&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;example_type&quot;,
    &quot;_id&quot;: &quot;AWt67Ql_Tf0FgxupYlBX&quot;,
    &quot;_version&quot;: 1,
    &quot;result&quot;: &quot;created&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    },
    &quot;created&quot;: true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询文档&quot;&gt;查询文档&lt;/h3&gt;
&lt;p&gt;ElasticSearch的核心功能——搜索。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST http://localhost:9200/demo/example_type/_search?pretty&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;took&quot;: 183,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 5,
        &quot;successful&quot;: 5,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: 1,
        &quot;max_score&quot;: 1,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;demo&quot;,
                &quot;_type&quot;: &quot;example_type&quot;,
                &quot;_id&quot;: &quot;AWt67Ql_Tf0FgxupYlBX&quot;,
                &quot;_score&quot;: 1,
                &quot;_source&quot;: {
                    &quot;created&quot;: 1561135459000,
                    &quot;message&quot;: &quot;test1&quot;
                }
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于文档的查询是ElasticSearch的核心，后面的章节会详细介绍一些基本的简单查询和更为高级的复杂查询，此处仅作为对插入数据的验证，不做过多展开。&lt;/p&gt;
&lt;h3 id=&quot;修改文档&quot;&gt;修改文档&lt;/h3&gt;
&lt;p&gt;根据文档&lt;code&gt;_id&lt;/code&gt;修改&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST http://localhost:9200/demo/example_type/AWt67Ql_Tf0FgxupYlBX/_update
{
    &quot;doc&quot;:{
        &quot;message&quot;:&quot;updated&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;example_type&quot;,
    &quot;_id&quot;: &quot;AWt67Ql_Tf0FgxupYlBX&quot;,
    &quot;_version&quot;: 2,
    &quot;result&quot;: &quot;updated&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除文档&quot;&gt;删除文档&lt;/h3&gt;
&lt;p&gt;删除&lt;code&gt;_id&lt;/code&gt;为AWt67Ql_Tf0FgxupYlBX的文档&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DELETE http://localhost:9200/demo/example_type/AWt67Ql_Tf0FgxupYlBX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES的响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;found&quot;: true,
    &quot;_index&quot;: &quot;demo&quot;,
    &quot;_type&quot;: &quot;example_type&quot;,
    &quot;_id&quot;: &quot;AWt67Ql_Tf0FgxupYlBX&quot;,
    &quot;_version&quot;: 2,
    &quot;result&quot;: &quot;deleted&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关注公众号：CoderBuff，回复“es”获取《ElasticSearch6.x实战教程》完整版PDF，回复“抽奖”参与《从Lucene到Elasticsearch：全文检索实战》图书抽奖活动（7.17-7.21）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 18 Jul 2019 16:22:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>第三章 简单的API 万丈高楼平地起 ES提供了多种操作数据的方式，其中较为常见的方式就是RESTful风格的API。 简单的体验 利用Postman发起HTTP请求（当然也可以在命令行中使用curl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11210870.html</dc:identifier>
</item>
<item>
<title>ng-bootstrap 组件集中 tabset 组件的实现分析 - 冠军</title>
<link>http://www.cnblogs.com/haogj/p/11210861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haogj/p/11210861.html</guid>
<description>&lt;p class=&quot;md-end-block md-p&quot;&gt; 本文介绍了 ng-bootstrap 项目中，tabset 的实现分析。&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用方式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;code&gt;&amp;lt;ngb-tabset&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;作为容器元素，其中的每个页签以一个 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tab&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;元素定义，在 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tabset&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;中包含若干个 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tab&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;子元素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tab&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;元素中，使用 &lt;span&gt;&lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;模板来定义内容，内容分为两种：标题和内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标题使用 &lt;span&gt;&lt;code&gt;[ngbTabTitle]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;指令来声明，或者在 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tab&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;元素上使用 &lt;span&gt;&lt;code&gt;title&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;属性声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内容使用 &lt;span&gt;&lt;code&gt;[ngbTabContent]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;指令声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ngb-tabset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ngb-tab &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Simple&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Raw denim you probably haven't heard of them jean shorts Austin. Nesciunt tofu stumptown aliqua, retro synth
      master cleanse. Mustache cliche tempor, williamsburg carles vegan helvetica. Reprehenderit butcher retro keffiyeh
      dreamcatcher synth. Cosby sweater eu banh mi, qui irure terry richardson ex squid. Aliquip placeat salvia cillum
      iphone. Seitan aliquip quis cardigan american apparel, butcher voluptate nisi qui.&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ngb-tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ngb-tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabTitle&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Fancy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Food truck fixie locavore, accusamus mcsweeney's marfa nulla single-origin coffee squid.
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Exercitation +1 labore velit, blog sartorial PBR leggings next level wes anderson artisan four loko farm-to-table
      craft beer twee. Qui photo booth letterpress, commodo enim craft beer mlkshk aliquip jean shorts ullamco ad vinyl
      cillum PBR. Homo nostrud organic, assumenda labore aesthetic magna delectus mollit. Keytar helvetica VHS salvia
      yr, vero magna velit sapiente labore stumptown. Vegan fanny pack odio cillum wes anderson 8-bit, sustainable jean
      shorts beard ut DIY ethical culpa terry richardson biodiesel. Art party scenester stumptown, tumblr butcher vero
      sint qui sapiente accusamus tattooed echo park.&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ngb-tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ngb-tab &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Disabled&quot;&lt;/span&gt;&lt;span&gt; [disabled]&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Sed commodo, leo at suscipit dictum, quam est porttitor sapien, eget sodales nibh elit id diam. Nulla facilisi. Donec egestas ligula vitae odio interdum aliquet. Duis lectus turpis, luctus eget tincidunt eu, congue et odio. Duis pharetra et nisl at faucibus. Quisque luctus pulvinar arcu, et molestie lectus ultrices et. Sed diam urna, egestas ut ipsum vel, volutpat volutpat neque. Praesent fringilla tortor arcu. Vivamus faucibus nisl enim, nec tristique ipsum euismod facilisis. Morbi ut bibendum est, eu tincidunt odio. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Mauris aliquet odio ac lorem aliquet ultricies in eget neque. Phasellus nec tortor vel tellus pulvinar feugiat.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ngb-tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ngb-tabset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看到，外层元素是 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tabset&amp;gt;&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;每个 tab 使用元素 &lt;span&gt;&lt;code&gt;&amp;lt;ngb-tab&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;定义，tab 的内容使用 &lt;span&gt;&lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;模板定义， tab 中的内容分为两个部分：标题和内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面是使用模板的标题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabTitle&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Fancy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标题也可以在 &lt;span&gt;&lt;code&gt;ngb-tab&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;上使用 &lt;span&gt;&lt;code&gt;[title]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;属性定义。例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ngb-tab &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Disabled&quot;&lt;/span&gt;&lt;span&gt; [disabled]&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内容部分定义，这里使用了指令 &lt;span&gt;&lt;code&gt;[ngbTabContent]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;便于识别。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngbTabContent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Sed commodo, leo at suscipit dictum, quam est porttitor sapien, eget sodales nibh elit id diam. 
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;TabSet 组件定义&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;从前面的使用可以看出，所有 tab 的定义都是 &lt;span&gt;&lt;code&gt;ngb-tabset&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;元素的内容，它们在使用时定义，而不是在 &lt;span&gt;&lt;code&gt;ngb-tabse&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;自己的模板中定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所以找到它们需要使用 &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://angular.io/api/core/ContentChildren&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ContentChildren&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;md-plain&quot;&gt;来找到。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@ContentChildren(NgbTab) tabs: QueryList&amp;lt;NgbTab&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不使用 &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://angular.io/api/core/ContentChild&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ContentChild&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;md-plain&quot;&gt;的原因是它没有提供 &lt;span&gt;&lt;code&gt;descendants&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;的支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在 bootstrap 中，每个页签 实际上渲染成两个部分，一个标题的列表，和当前显示的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标题列表使用一个 &lt;span&gt;&lt;code&gt;ul&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;来处理。其中使用循环来将所有的标题显示出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;而 &lt;span&gt;&lt;code&gt;titleTpl&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;是由模板定义的，所以，使用了 &lt;span&gt;&lt;code&gt;[ngTemplateOutlet]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;来渲染出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;[class]&lt;/span&gt;&lt;span&gt;=&quot;'nav nav-' + type + (orientation == 'horizontal'?  ' ' + justifyClass : ' flex-column')&quot;&lt;/span&gt;&lt;span&gt; role&lt;/span&gt;&lt;span&gt;=&quot;tablist&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt; *ngFor&lt;/span&gt;&lt;span&gt;=&quot;let tab of tabs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;[id]&lt;/span&gt;&lt;span&gt;=&quot;tab.id&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; 
           [class.active]&lt;/span&gt;&lt;span&gt;=&quot;tab.id === activeId&quot;&lt;/span&gt;&lt;span&gt; 
           [class.disabled]&lt;/span&gt;&lt;span&gt;=&quot;tab.disabled&quot;&lt;/span&gt;&lt;span&gt;
           href (click)&lt;/span&gt;&lt;span&gt;=&quot;select(tab.id); $event.preventDefault()&quot;&lt;/span&gt;&lt;span&gt; 
           role&lt;/span&gt;&lt;span&gt;=&quot;tab&quot;&lt;/span&gt;&lt;span&gt; 
           [attr.tabindex]&lt;/span&gt;&lt;span&gt;=&quot;(tab.disabled ? '-1': undefined)&quot;&lt;/span&gt;&lt;span&gt;
           [attr.aria-controls]&lt;/span&gt;&lt;span&gt;=&quot;(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)&quot;&lt;/span&gt;&lt;span&gt;
          [attr.aria-selected]&lt;/span&gt;&lt;span&gt;=&quot;tab.id === activeId&quot;&lt;/span&gt;&lt;span&gt; [attr.aria-disabled]&lt;/span&gt;&lt;span&gt;=&quot;tab.disabled&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          {{tab.title}}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;[ngTemplateOutlet]&lt;/span&gt;&lt;span&gt;=&quot;tab.titleTpl?.templateRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;title 部分并列使用了两种来源&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{tab.title}}&amp;lt;ng-template [ngTemplateOutlet]=&quot;tab.titleTpl?.templateRef&quot;&amp;gt;&amp;lt;/ng-template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内容部分，由于具体内容也是使用模板定义出来，所以这里也是使用 &lt;span&gt;&lt;code&gt;[ngTemplateOutlet]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;渲染出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;ngFor let-tab [ngForOf]&lt;/span&gt;&lt;span&gt;=&quot;tabs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div
          &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab-pane {{tab.id === activeId ? 'active' : null}}&quot;&lt;/span&gt;&lt;span&gt;
          *ngIf&lt;/span&gt;&lt;span&gt;=&quot;!destroyOnHide || tab.id === activeId&quot;&lt;/span&gt;&lt;span&gt;
          role&lt;/span&gt;&lt;span&gt;=&quot;tabpanel&quot;&lt;/span&gt;&lt;span&gt;
          [attr.aria-labelledby]&lt;/span&gt;&lt;span&gt;=&quot;tab.id&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;{{tab.id}}-panel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-template &lt;/span&gt;&lt;span&gt;[ngTemplateOutlet]&lt;/span&gt;&lt;span&gt;=&quot;tab.contentTpl?.templateRef&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;投影内容需要在 &lt;span&gt;&lt;code&gt;Content&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;类型的事件中处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ngAfterContentChecked() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; auto-correct activeId that might have been set incorrectly as input&lt;/span&gt;
    let activeTab = &lt;span&gt;this&lt;/span&gt;._getTabById(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.activeId);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.activeId =&lt;span&gt; 
        activeTab &lt;/span&gt;? activeTab.id : (&lt;span&gt;this&lt;/span&gt;.tabs.length ? &lt;span&gt;this&lt;/span&gt;.tabs.first.id : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;两个指令定义&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;指令的定义非常简单，就是获取模板的引用，以便后继使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;可以看到属性名称为 &lt;span&gt;&lt;code&gt;templateRef&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Directive({selector: 'ng-template[ngbTabTitle]'&lt;span&gt;})
export class NgbTabTitle {
  constructor(public templateRef: TemplateRef&lt;/span&gt;&amp;lt;any&amp;gt;&lt;span&gt;) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这是 &lt;span&gt;&lt;code&gt;[ngbTabContent]&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;的定义，与上面相同，依然是定义了属性 &lt;span&gt;&lt;code&gt;templateRef&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Directive({selector: 'ng-template[ngbTabContent]'&lt;span&gt;})
export class NgbTabContent {
  constructor(public templateRef: TemplateRef&lt;/span&gt;&amp;lt;any&amp;gt;&lt;span&gt;) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-operator&quot;&gt;&lt;span class=&quot;cm-variable&quot;&gt;&lt;span class=&quot;cm-property&quot;&gt;&lt;span class=&quot;cm-string&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt;&lt;span class=&quot;cm-keyword&quot;&gt;&lt;span class=&quot;cm-def&quot;&gt;&lt;span&gt;&lt;span class=&quot;cm-property&quot;&gt;&lt;span class=&quot;cm-keyword&quot;&gt;&lt;span class=&quot;cm-def&quot;&gt;&lt;span class=&quot;cm-type&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;&lt;span class=&quot;cm-type&quot;&gt;&lt;span class=&quot;cm-operator&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Tab 定义&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;元素型的指令，所以连模板都没有了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Directive({selector: 'ngb-tab'})
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;内容是投影进来的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由于在 &lt;span&gt;&lt;code&gt;tab&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;中使用了模板，并且使用指令来标识出来，它们定义在组件的模板之内，所以这里使用了 &lt;span&gt;&lt;code&gt;ContentChildren&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;来识别。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@ContentChildren(NgbTabTitle, {descendants: &lt;span&gt;false&lt;/span&gt;}) titleTpls: QueryList&amp;lt;NgbTabTitle&amp;gt;&lt;span&gt;;
@ContentChildren(NgbTabContent, {descendants: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;}) contentTpls: QueryList&amp;lt;NgbTabContent&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;以后就可以使用 &lt;span&gt;&lt;code&gt;titleTpls&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;和 &lt;span&gt;&lt;code&gt;contentTpls&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;来使用模板了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由于是内容，需要在 &lt;span&gt;&lt;code&gt;content&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;的事件中处理，实际上，在每个页签中，我们只有一个标题和一个内容的声明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ngAfterContentChecked() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We are using @ContentChildren instead of @ContentChild as in the Angular version being used&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; only @ContentChildren allows us to specify the {descendants: false} option.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Without {descendants: false} we are hitting bugs described in:&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; https://github.com/ng-bootstrap/ng-bootstrap/issues/2240&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.titleTpl = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.titleTpls.first;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contentTpl = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contentTpls.first;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;See also&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Thu, 18 Jul 2019 16:17:00 +0000</pubDate>
<dc:creator>冠军</dc:creator>
<og:description>本文介绍了 ng-bootstrap 项目中，tabset 控件的实现分析。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haogj/p/11210861.html</dc:identifier>
</item>
<item>
<title>数据结构与算法---堆排序(Heap sort) - wanbf</title>
<link>http://www.cnblogs.com/justBobo/p/11204375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justBobo/p/11204375.html</guid>
<description>&lt;h2&gt;堆排序基本介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、堆排序是利用&lt;strong&gt;堆&lt;/strong&gt;这种数据结构而设计的一种排序算法，堆排序是一种&lt;strong&gt;选择排序&lt;/strong&gt;，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, &lt;strong&gt;注意&lt;/strong&gt; : 没有要求结点的左孩子的值和右孩子的值的大小关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、大顶堆举例说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190717222130188-739751002.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190717222233416-1988432242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、小顶堆举例说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190717222749594-1779999518.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小顶堆：arr[i] &amp;lt;= arr[2*i+1] &amp;amp;&amp;amp; arr[i] &amp;lt;= arr[2*i+2] // i 对应第几个节点，i从0开始编号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、一般升序采用大顶堆，降序采用小顶堆 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 堆排序的基本思想是：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;将待排序序列构造成一个大顶堆&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;此时，整个序列的最大值就是堆顶的根节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将其与末尾元素进行交换，此时末尾就为最大值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;堆排序步骤图解说明&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤一&lt;/span&gt; &lt;span&gt;构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆&lt;/span&gt;)。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) .假设给定无序序列结构如下&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233335311-1150110830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2).此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233415351-975896606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;3) .找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233443028-508541482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;4) &lt;span&gt;这时，交换导致了子根&lt;/span&gt;[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233457225-2066791980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;span&gt;此时，我们就将一个&lt;/span&gt;&lt;span&gt;无序&lt;/span&gt;&lt;span&gt;序列构造成了一个大顶堆。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二&lt;/span&gt; &lt;span&gt;将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;1) .将堆顶元素9和末尾元素4进行交换&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233526166-1205839775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;2) .重新调整结构，使其继续满足堆定义&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233537458-1310719956.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;3) .再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233550598-1246922178.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;4) &lt;span&gt;后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1653497/201907/1653497-20190718233607211-1792596988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;再简单总结下堆排序的基本思路：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;1)&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;.将&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;&lt;span&gt;无序&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;&lt;span&gt;序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆&lt;/span&gt;;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;2)&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;堆排序代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f8bd36e5-62dc-4943-a847-9318b36ed913')&quot; readability=&quot;53&quot;&gt;&lt;img id=&quot;code_img_closed_f8bd36e5-62dc-4943-a847-9318b36ed913&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f8bd36e5-62dc-4943-a847-9318b36ed913&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f8bd36e5-62dc-4943-a847-9318b36ed913',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f8bd36e5-62dc-4943-a847-9318b36ed913&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HeapSort {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要求将数组进行升序排序
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int arr[] = {4, 6, 8, 5, 9};
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建要给80000个的随机的数组&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[8000000&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 8000000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             arr[i] = (&lt;span&gt;int&lt;/span&gt;) (Math.random() * 8000000); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个[0, 8000000) 数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;排序前&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Date data1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         SimpleDateFormat simpleDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         String date1Str =&lt;span&gt; simpleDateFormat.format(data1);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;排序前的时间是=&quot; +&lt;span&gt; date1Str);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        heapSort(arr);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         Date data2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         String date2Str =&lt;span&gt; simpleDateFormat.format(data2);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;排序前的时间是=&quot; +&lt;span&gt; date2Str);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;排序后=&quot; + Arrays.toString(arr));&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编写一个堆排序的方法&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; heapSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arr[]) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; temp = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;堆排序!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分步完成
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        adjustHeap(arr, 1, arr.length);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;第一次&quot; + Arrays.toString(arr)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4, 9, 8, 5, 6
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;        
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        adjustHeap(arr, 0, arr.length);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        System.out.println(&quot;第2次&quot; + Arrays.toString(arr)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9,6,8,5,4
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成我们最终代码
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = arr.length / 2 -1; i &amp;gt;=0; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            adjustHeap(arr, i, arr.length);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;         * 2).将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;　　            3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = arr.length-1;j &amp;gt;0; j--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             temp =&lt;span&gt; arr[j];
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             arr[j] = arr[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             arr[0] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             adjustHeap(arr, 0&lt;span&gt;, j); 
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;数组=&quot; + Arrays.toString(arr)); &lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个数组(二叉树), 调整成一个大顶堆&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;     * 举例  int arr[] = {4, 6, 8, 5, 9}; =&amp;gt; i = 1 =&amp;gt; adjustHeap =&amp;gt; 得到 {4, 9, 8, 5, 6}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;     * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&amp;gt; 得到 {4, 9, 8, 5, 6} =&amp;gt; {9,6,8,5, 4}
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; arr 待调整的数组
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; i 表示非叶子结点在数组中索引
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lenght 表示对多少个元素继续调整， length 是在逐渐的减少
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; adjustHeap(&lt;span&gt;int&lt;/span&gt; arr[], &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lenght) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         
&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; temp = arr[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先取出当前元素的值，保存在临时变量
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始调整
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. k = i * 2 + 1 k 是 i结点的左子结点&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = i * 2 + 1; k &amp;lt; lenght; k = k * 2 + 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(k+1 &amp;lt; lenght &amp;amp;&amp;amp; arr[k] &amp;lt; arr[k+1]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明左子结点的值小于右子结点的值&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;                 k++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; k 指向右子结点&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr[k] &amp;gt; temp) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果子结点大于父结点&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;                 arr[i] = arr[k]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把较大的值赋给当前结点&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;                 i = k; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;!!! i 指向 k,继续循环比较&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt;         arr[i] = temp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将temp值放到调整后的位置&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;     
&lt;span&gt;90&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;堆排序的速度非常快，在我的机器上 8百万数据 3 秒左右。O(nlogn)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 15:41:00 +0000</pubDate>
<dc:creator>wanbf</dc:creator>
<og:description>堆排序基本介绍 1、堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 2、堆是具有以下性质的完全二叉树：每个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justBobo/p/11204375.html</dc:identifier>
</item>
<item>
<title>Hadoop现在怎么样了？ - 叁金</title>
<link>http://www.cnblogs.com/jixin/p/11210669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jixin/p/11210669.html</guid>
<description>&lt;p&gt;之前我们提到大数据的时候就会提到&lt;code&gt;Hadoop&lt;/code&gt;，&lt;code&gt;Hadoop&lt;/code&gt;是大数据的基础框架，是大数据技术的代表。提到&lt;code&gt;HDFS&lt;/code&gt;、&lt;code&gt;MapReduce&lt;/code&gt;、&lt;code&gt;Yarn&lt;/code&gt;，提到&lt;code&gt;HBase&lt;/code&gt;、&lt;code&gt;Hive&lt;/code&gt;、&lt;code&gt;TEZ&lt;/code&gt;等&lt;code&gt;Hadoop&lt;/code&gt;生态圈中的一个又一个开源组件。但是最近好像有点不一样了。&lt;/p&gt;
&lt;h3&gt;Hadoop三巨头&lt;/h3&gt;
&lt;p&gt;曾经的三巨头之一&lt;code&gt;MapR&lt;/code&gt;向加州就业发展局提交文件，称如果找不到新的投资人，公司将裁员 122 人，并关闭位于硅谷的总部公司。这曾经可是估值10亿美元的&lt;code&gt;Hadoop&lt;/code&gt;发行版厂商啊，说跪就要跪了，而另外两巨头则是抱团取暖，当然这也不能完全说明&lt;code&gt;Hadoop&lt;/code&gt;面临着一些问题。&lt;/p&gt;
&lt;p&gt;2003年，依据Google发表的三篇论文将Google的三驾马车从幕后搬到台前，奠定了后面十几年大数据的框架基础，形成了&lt;code&gt;Hadoop&lt;/code&gt;生态圈的第一圈：分布式文件系统&lt;code&gt;HDFS&lt;/code&gt;、分布式计算&lt;code&gt;MapReduce&lt;/code&gt;、&lt;code&gt;HBase&lt;/code&gt; &lt;code&gt;NoSQL&lt;/code&gt;数据库（&lt;code&gt;BigTable&lt;/code&gt;）和&lt;code&gt;Yarn&lt;/code&gt;资源调度服务。一时之间如日中天，&lt;code&gt;Hadoop&lt;/code&gt;生态蓬勃发展，&lt;code&gt;Hortonworks&lt;/code&gt;、&lt;code&gt;Cloudera&lt;/code&gt; 和 &lt;code&gt;MapR&lt;/code&gt;一直在进行技术更新，开发了一款又一款的基于&lt;code&gt;Hadoop&lt;/code&gt;的工具。&lt;code&gt;Hive&lt;/code&gt;的出现实现了类&lt;code&gt;SQL&lt;/code&gt;的支持，迅速占领了市场，后面基于&lt;code&gt;SQL On Hadoop&lt;/code&gt;的组件更是层出不穷，&lt;code&gt;Presto&lt;/code&gt;、&lt;code&gt;Impala&lt;/code&gt;、&lt;code&gt;Drill&lt;/code&gt;、&lt;code&gt;Spark&lt;/code&gt;、&lt;code&gt;Tez&lt;/code&gt;、&lt;code&gt;Sqoop&lt;/code&gt;等等。&lt;code&gt;Hadoop&lt;/code&gt;的生态圈越来越大，后面兴起的新型计算框架和查询框架都围绕着&lt;code&gt;Hadoop&lt;/code&gt;进行兼容，如&lt;code&gt;Presto&lt;/code&gt;兼容&lt;code&gt;Hive&lt;/code&gt;、&lt;code&gt;Spark&lt;/code&gt;兼容&lt;code&gt;HDFS&lt;/code&gt;存储和&lt;code&gt;Yarn&lt;/code&gt;调度，一切看起来都是美好的样子。&lt;/p&gt;
&lt;p&gt;但是，从之前的&lt;code&gt;Hadoop&lt;/code&gt;是大数据的基础框架到现在&lt;code&gt;Hadoop&lt;/code&gt;已经不能完全代表大数据了，&lt;code&gt;Hadoop&lt;/code&gt;只是大数据技术领域的一个分支，而其他分支正在努力的演化为新的大数据实现方式。&lt;/p&gt;
&lt;h3&gt;大数据技术栈&lt;/h3&gt;
&lt;p&gt;大数据的技术栈我们通常认为分为：资源调度层、分布式存储层、统一计算引擎层和统一接口层。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;资源调度层：为了更好的对资源进行管理，解决上层应用的问题，现在出现了很多新的技术，很多企业都开始利用容器编排技术来代替&lt;code&gt;YARN&lt;/code&gt;进行资源管理。当然，&lt;code&gt;Hadoop3&lt;/code&gt;之后&lt;code&gt;Yarn&lt;/code&gt;也支持调度&lt;code&gt;Docker&lt;/code&gt;应用了，算是&lt;code&gt;Hadoop&lt;/code&gt;的一个改进。&lt;/li&gt;
&lt;li&gt;分布式存储层：诚然&lt;code&gt;HDFS&lt;/code&gt;是一个较为通用的存储服务，但是它原生的痛点就是不支持小文件存储，而且由于存储特性无法实现高性能的随机读写。&lt;/li&gt;
&lt;li&gt;统一计算引擎：现在&lt;code&gt;MapReduce&lt;/code&gt;已经基本要被&lt;code&gt;Spark&lt;/code&gt;和&lt;code&gt;Flink&lt;/code&gt;所取代了，当然&lt;code&gt;Spark&lt;/code&gt;和&lt;code&gt;Flink&lt;/code&gt;也算&lt;code&gt;Hadoop&lt;/code&gt;生态中的一员，但是不要忘了，当&lt;code&gt;Spark&lt;/code&gt;底层存储基于&lt;code&gt;S3&lt;/code&gt;，调度基于&lt;code&gt;K8S&lt;/code&gt;就可以完全抛开&lt;code&gt;Hadoop&lt;/code&gt;了。毕竟谁还不是一个通用性的产品呢~&lt;/li&gt;
&lt;li&gt;统一接口层：通过统一的&lt;code&gt;SQL&lt;/code&gt;接口层来降低大数据技术的使用门槛是我们的共识，目前&lt;code&gt;SQL on Hadoop&lt;/code&gt;技术也在蓬勃发展，&lt;code&gt;SQL&lt;/code&gt;的支持度也在不断的提升，但是如果不依赖&lt;code&gt;HDFS&lt;/code&gt;存储可就不见得&lt;code&gt;SQL On Hadoop&lt;/code&gt;了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面说了这么多也不是在唱衰&lt;code&gt;Hadoop&lt;/code&gt;，只是&lt;code&gt;Hadoop&lt;/code&gt;目前看来确实好像遇到了瓶颈。但是&lt;code&gt;Hadoop3&lt;/code&gt;也增加了大量的功能，&lt;code&gt;Yarn&lt;/code&gt;支持&lt;code&gt;Docker&lt;/code&gt;容器、支持&lt;code&gt;TensorFlow&lt;/code&gt;的&lt;code&gt;GPU&lt;/code&gt;调度，提供了对&lt;code&gt;S3&lt;/code&gt;的支持。&lt;code&gt;Hive&lt;/code&gt;的&lt;code&gt;LLAP&lt;/code&gt;（低延时分析处理）、联邦数据查询和完全支持&lt;code&gt;ACID&lt;/code&gt;事务也让&lt;code&gt;Hive&lt;/code&gt;朝着更好的方向发展。不得不说现在所有的技术都在朝着云原生的方向前进，如果不能成功上云，可能终将被遗忘。&lt;/p&gt;
&lt;h3&gt;云原生下开源的YuniKorn&lt;/h3&gt;
&lt;p&gt;而&lt;code&gt;Hortonworks&lt;/code&gt;和&lt;code&gt;Cloudera&lt;/code&gt;的合并可能是&lt;code&gt;Hadoop&lt;/code&gt;发展的又一转折点，毕竟合并的战略目标是专注于云。就在昨天，19年7月17日，&lt;code&gt;Cloudera&lt;/code&gt; 官方博客发文开源了一个幕后工作很久的大数据存储和通用计算平台交叉的新项目——&lt;code&gt;YuniKorn&lt;/code&gt;。据介绍，&lt;code&gt;YuniKorn&lt;/code&gt; 是一种轻量级的通用资源调度程序，适用于容器编排系统，负责为大数据工作负载分配 / 管理资源，包括批处理作业和常驻运行的服务。有兴趣的可以关注一下&lt;code&gt;Github&lt;/code&gt;地址：&lt;a href=&quot;https://github.com/cloudera/yunikorn-core&quot;&gt;https://github.com/cloudera/yunikorn-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YuniKorn[‘ju:nikɔ:n]&lt;/code&gt; 是一个虚构的词，“Y”代表 &lt;code&gt;YARN&lt;/code&gt;，“K”代表 &lt;code&gt;K8s&lt;/code&gt;，“Uni”代表统一，其发音与“Unicorn”相同。创建它是为了最初支持这两个系统，但最终目的是创建一个可以支持任何容器协调器系统的统一调度程序。一方面在大规模，多租户环境中有效地实现各种工作负载的细粒度资源共享，另一方面可以动态地创建云原生环境。&lt;code&gt;YuniKorn&lt;/code&gt; 为混合工作负载提供统一的跨平台调度体验，包括无状态批处理工作负载和状态服务，支持但不限于 &lt;code&gt;YARN&lt;/code&gt; 和 &lt;code&gt;Kubernetes&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;YuniKorn 的主要模块&lt;/h3&gt;

&lt;div&gt;&lt;img alt=&quot;&quot; height=&quot;332&quot; id=&quot;img1563462519230&quot; src=&quot;https://img2018.cnblogs.com/other/585224/201907/585224-20190718231322675-1387427236.jpg&quot; width=&quot;613&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;YuniKorn -scheduler-interface&lt;/code&gt;：调度程序接口是资源管理平台（如 &lt;code&gt;YARN / K8s&lt;/code&gt;）将通过诸如 &lt;code&gt;GRPC&lt;/code&gt; / 编程语言绑定之类的 &lt;code&gt;API&lt;/code&gt; 与之交谈的抽象层。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YuniKorn Core&lt;/code&gt;：&lt;code&gt;YuniKorn Core&lt;/code&gt; 封装了所有调度算法，它从资源管理平台（如 &lt;code&gt;YARN / K8s&lt;/code&gt;）下面收集资源，并负责资源分配请求。它决定每个请求的最佳部署位置，然后将响应分配发送到资源管理平台。调度程序核心与下层平台无关，所有通信都通过调度程序接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scheduler Shim Layers&lt;/code&gt;：调度程序 &lt;code&gt;Shim&lt;/code&gt; 在主机系统内运行（如 &lt;code&gt;YARN / K8s&lt;/code&gt;），它负责通过调度程序接口转换主机系统资源和资源请求，并将它们发送到调度程序核心。在做出调度程序决策时，它负责实际的 pod / 容器绑定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scheduler UI&lt;/code&gt;：调度程序 UI 为已托管的节点，计算资源，应用程序和队列提供简单视图。&lt;/p&gt;
&lt;h3&gt;YuniKorn 的一些特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;调度功能支持批处理作业和长期运行 / 有状态服务&lt;/li&gt;
&lt;li&gt;具有最小 / 最大资源配额的分层池 / 队列&lt;/li&gt;
&lt;li&gt;队列，用户和应用程序之间的资源公平性&lt;/li&gt;
&lt;li&gt;基于公平性的跨队列抢占&lt;/li&gt;
&lt;li&gt;自定义资源类型（如 &lt;code&gt;GPU&lt;/code&gt;）调度支持&lt;/li&gt;
&lt;li&gt;丰富的编排约束支持&lt;/li&gt;
&lt;li&gt;根据策略自动将传入的容器请求映射到队列&lt;/li&gt;
&lt;li&gt;对节点使用专用配额 / &lt;code&gt;ACL&lt;/code&gt; 管理将大的集群拆分成若干子群集&lt;/li&gt;
&lt;li&gt;支持 &lt;code&gt;K8s&lt;/code&gt; 谓词。如 pod 亲和 / 反亲和，节点选择器&lt;/li&gt;
&lt;li&gt;支持持久化存储，配额申请等&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;configmap&lt;/code&gt; 动态加载调度程序配置（热刷新）&lt;/li&gt;
&lt;li&gt;可以在 &lt;code&gt;Kubernetes&lt;/code&gt; 之上部署&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YuniKorn&lt;/code&gt; Web 支持监视调度程序队列，资源使用，应用程序等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们不止一次听说过XX不是银弹，没有一种技术可以解决所有的问题，技术一直在发展。哪怕是在&lt;code&gt;Hadoop&lt;/code&gt;生态圈内，随着实时数据的处理能力提高，构建实时数仓，打造实时数据处理与计算平台已经比离线任务模式要吃香了。上云总归来说是一个大的趋势，对于大小公司都是如此，毕竟可以节省非常多的成本。但是也不排除云+本地的混合模式，毕竟数据现在可是金子~。不管怎么说，一直受&lt;code&gt;Hortonworks&lt;/code&gt;和&lt;code&gt;Cloudera&lt;/code&gt;的影响推动着&lt;code&gt;Hadoop&lt;/code&gt;相关组件的进步，基于他们的技术栈学到了很多招式，希望他们可以更好的走下去。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;https://www.infoq.cn/article/CkleCZg-UuMKFDHEf66r&quot;&gt;被“围攻”的 Hadoop 没有对手&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.infoq.cn/article/zpgr1p*uU6EYoLxSyagb&quot;&gt;2019 年，Hadoop 还是数据处理的可选方案吗?&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.infoq.cn/article/vk3CVzbBIjGdezd-WjSJ&quot;&gt;Cloudera 开源新项目：轻量级通用资源调度程序 YuniKorn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注我：叁金大数据&lt;/strong&gt;&lt;br/&gt;&lt;img alt=&quot;&quot; id=&quot;img1563462700941&quot; src=&quot;https://img2018.cnblogs.com/other/585224/201907/585224-20190718231304086-541109045.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jul 2019 15:14:00 +0000</pubDate>
<dc:creator>叁金</dc:creator>
<og:description>之前我们提到大数据的时候就会提到Hadoop，Hadoop是大数据的基础框架，是大数据技术的代表。提到HDFS、MapReduce、Yarn，提到HBase、Hive、TEZ等Hadoop生态圈中的一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jixin/p/11210669.html</dc:identifier>
</item>
<item>
<title>UEditor 之初体验后记 - 韩宗泽</title>
<link>http://www.cnblogs.com/hanzongze/p/js-ueditor.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanzongze/p/js-ueditor.html</guid>
<description>&lt;p&gt;本文初稿写于 3 年前，近期重新编辑整理，并进一步完善补充而成。&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;1、UEditor 基本介绍&lt;/h2&gt;
&lt;h4 id=&quot;11&quot;&gt;1.1、关于 UEditor&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这句话出自 UEditor 官方。在我看来，UEditor 的核心特点就是：产自大厂、开源免费、功能全面（相当全）、体验较为切合国人习惯。想了解 UEditor 的更多信息，可参考以下几个链接：&lt;/p&gt;
&lt;p&gt;另外，UEditor 官方还提供了一个 Mini 版，名字叫 &lt;a href=&quot;https://ueditor.baidu.com/website/umeditor.html#target_blank&quot; title=&quot;UMeditor演示&quot;&gt;UMeditor&lt;/a&gt;。说是为了满足广大门户网站对于简单发帖框，或者回复框需求所定制的版本。主要改进点在加载速度和加载失败率上，且功能与 UEditor 也略有不同，具体可参考 &lt;a href=&quot;https://github.com/fex-team/umeditor#target_blank&quot; title=&quot;UEditor 的 GitHub&quot;&gt;UMeditor 的 GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;12&quot;&gt;1.2、UEditor 现状&lt;/h4&gt;
&lt;p&gt;UEditor 的最新版本是 v1.4.3.3，UMEditor 的最新版本是 v1.2.3。最后一次发布都在 2016 年下半年，都快 3 年没更新了。不过基本功能该有的也都有，且社区也比较认同和推崇，有不少人或组织都提供了特色的改进版或增强版，官方也偶有跟进。&lt;/p&gt;
&lt;p&gt;综合来看，目前要在国内做相对复杂的资讯发布或留言功能，UEditor/UMEditor 依然是最好的选择之一。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;2、UEditor 简单使用&lt;/h2&gt;
&lt;h4 id=&quot;21&quot;&gt;2.1、将 UEditor 源码集成到项目中&lt;/h4&gt;
&lt;p&gt;如果你要在后端项目中集成 UEditor，那么直接下载对应语言版本的源码，解压之后拷贝到项目中即可。有两点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、官方只提供了 PHP、ASP、ASP.NET、JSP 四个版本，社区里有人提供了 Note.js、Python 等语言的版本。&lt;/li&gt;
&lt;li&gt;2、&lt;strong&gt;官方说提供的所有后端代码都仅为 DEMO 作用，切不可直接用到生产环境中。&lt;/strong&gt;平心而论，ASP.NET 版的后端代码写的确实水，不过前端能写出这些后端代码就已经很牛掰了，我是把用到的那部分代码从头到尾改了一遍才用到生产环境中的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你要在前端项目中集成 UEditor，那就看你需不需要上传图片等后端功能了。如果不需要，那么直接拷贝到前端项目中即可。但如果需要，那就得确保跑前端的 Web 服务器能解析对应的后端代码了。&lt;/p&gt;
&lt;p&gt;当然，如果你把 UEditor 单独部署到一个支持后端的 Web 服务器上也是可行的。另外，集成 UMeditor 的方法与集成 UEditor 方法完全一样。&lt;/p&gt;
&lt;h4 id=&quot;22&quot;&gt;2.2、让 UEditor 的 UI 呈现在页面中&lt;/h4&gt;
&lt;p&gt;1、首先，需要在页面中引入 UEditor 的 3 个 js 文件，示例如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 编辑器的配置文件，前端配置都在这个文件中，注释十分丰富 --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/ueditor-1.4.3/ueditor.config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- 编辑器的源码文件 --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/ueditor-1.4.3/ueditor.all.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!-- 编辑器的中文语言包 --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/ueditor-1.4.3/lang/zh-cn/zh-cn.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、然后，在页面中需要呈现 UEditor 的地方放置如下“占位符”代码（注意给个 ID，下一步要用）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 编辑器的容器 --&amp;gt;
&amp;lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:800px; height:300px;&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、最后，通过一句实例化编辑器的代码来获得编辑器实例（页面运行起来时 UI 就会呈现出来）：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;$(function () {
    var ue = UE.getEditor(&quot;editor&quot;); // 创建编辑器实例（这里的 editor 就是上一步中的 ID）
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到编辑器实例对象之后，就可以通过它来调用 UEditor 的哪些 API 了。具体有哪些 API 可用，参见 &lt;a href=&quot;https://ueditor.baidu.com/doc/#target_blank&quot; title=&quot;UEditor API&quot;&gt;UEditor API&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;23&quot;&gt;2.3、用 UEditor 的过程中遇到的两个坑&lt;/h4&gt;
&lt;p&gt;1、坑一，&lt;strong&gt;获取内容可以而设置内容却报错&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我用&lt;code&gt;getContent&lt;/code&gt;获取编辑器的内容并存入数据库，然后把存到数据库中的内容用&lt;code&gt;setContent&lt;/code&gt;赋给编辑器。结果运行起来发现保存入库可以，而打开编辑页面直接就报错了，编辑器也没显示出来。&lt;/p&gt;
&lt;p&gt;后来发现这个是因为编辑器还没准备好，所以就不能赋值，只需要把赋值操作放到&lt;code&gt;ready&lt;/code&gt;之后即可，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;ue.addListener(&quot;ready&quot;, function () {
    ue.setContent(&quot;@Model.Content&quot;); // 等编辑器准备好之后再赋值，否则报错
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了写这篇文章，我尝试了重现那个错误，结果编辑器又显示出来了，但依然会报错，错误消息是“Uncaught TypeError: Cannot set property 'innerHTML' of undefined”。&lt;/p&gt;
&lt;p&gt;从某种程度上说，这个问题并不算是坑。因为官方手册中就有相关说明和建议——“对编辑器的操作最好在编辑器ready之后再做”，不过我这人特别怕麻烦，凡是能凭猜测搞定的就不愿细看文档，所以第一次用的时候就掉坑了。&lt;/p&gt;
&lt;p&gt;2、坑二，&lt;strong&gt;编辑器内显示的是的 HTML，而不是文本内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一开始还怀疑这会不会是 UEditor 的 Bug，直到把这个问题解决之后，反过来想才发现这里面其实隐含了一个容易被忽略的“常识”，那就是网页的模版引擎一般都会编码字符串，比如我曾用过的 WebForms、NVelocity 和 RazorEngine 都是这样。&lt;/p&gt;
&lt;p&gt;换句话说，这时候编辑器拿到的是经过编码之后 HTML，也就是说只要我们能确保编辑器拿到的是编码前的 HTML 就行了。当然一开始我还没想到是这个原因，于是我的解决办法是根据曾使用其它编辑器的经验试出来的，就是直接把内容放到&lt;code&gt;script&lt;/code&gt;标签中，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:800px;height:300px;&quot;&amp;gt;
    @WebTools.RazorHelper.Raw(Model.Segment.Note)
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我意识到这个问题的始作俑者是网页模版引擎而不是 UEditor 的时候，我做了如下测试：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;ue.addListener(&quot;ready&quot;, function () {
    editor.setContent(&quot;@WebTools.RazorHelper.Raw(Model.Segment.Note)&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果然也是 OK 的，这也进一步证明了我的猜想是正确的！&lt;/p&gt;
&lt;h4 id=&quot;24&quot;&gt;2.4、将 UEditor 中的图片上传到云服务器上&lt;/h4&gt;
&lt;p&gt;由于 UEditor 默认是将图片上传到网站根目录下的一个子文件夹中，如果是企业内部的信息系统，这么做也还行，但如果是互联网项目，这种做法就显得既不安全、也不经济的了，最好还是上传到云服务器上。&lt;/p&gt;
&lt;p&gt;要把 UEditor 中的图片上传到云服务器上，只需要修改后端代码的上传逻辑即可。我做过用 ASP.NET 把 UEditor 1.4.3 中的图片上传到 &lt;a href=&quot;https://www.upyun.com/products/file-storage#target_blank&quot; title=&quot;又拍云 USS&quot;&gt;又拍云 USS&lt;/a&gt; 和把 UMeditor 1.2.2 中的图片上传到 &lt;a href=&quot;https://www.aliyun.com/product/oss#target_blank&quot; title=&quot;阿里云 OSS&quot;&gt;阿里云 OSS&lt;/a&gt;，其实思路是一样的。&lt;/p&gt;
&lt;p&gt;UEditor 的 ASP.NET 核心上传逻辑在&lt;code&gt;UploadHandler&lt;/code&gt;类的&lt;code&gt;Process&lt;/code&gt;方法中，将上传图片到本地的那部分代码替换成如下示例代码即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;try {
    // 校验文件类型、文件大小等......
    String fileMd5 = StringSecurity.GetMd5(uploadFileBytes); // 用文件的 MD5 值做文件名
    String fileName = fileMd5 + Path.GetExtension(uploadFileName);
    String filePath = $&quot;/images/{DateTime.Now.ToString(&quot;yyMMdd&quot;)}/{fileName}&quot;;
    // 调用又拍云的 SDK 来上传文件
    UpYun upyun = new UpYun(&quot;bucketname&quot;, &quot;username&quot;, &quot;password&quot;);
    upyun.setContentMD5(fileMd5);
    bool upyunResult = upyun.writeFile(filePath, uploadFileBytes, true);
    // ......
} catch (Exception e) {
    logger.Error(&quot;文件上传失败！&quot;, e);
    // ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UMeditor 的 ASP.NET 核心上传逻辑在&lt;code&gt;Uploader&lt;/code&gt;类的&lt;code&gt;upFile&lt;/code&gt;方法中，将上传图片到本地的那部分代码替换成如下示例代码即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;try {
    // 校验文件类型、文件大小等......
    String fileName = $&quot;{GuidHelper.LowerPureString}.{getFileExt()}&quot;;
    String filePath = $&quot;images/{DateTime.Now.ToString(&quot;yyMMdd&quot;)}/{fileName}&quot;;
    // 调用阿里云的 SDK 来上传文件
    var client = new OssClient(SrcPoint, AccessKeyId, AccessKeySecret, 
        new Aliyun.OSS.Common.ClientConfiguration() { IsCname = true });
    var putResult = client.PutObject(SrcBucket, filePath, uploadFile.InputStream);
    // ......
    var uri = client.GeneratePresignedUri(SrcBucket, filePath);
    URL = uri.GetLeftPart(UriPartial.Path); // 将文件路径赋值给编辑器引用的变量
} catch (Exception e) {
    logger.Error(&quot;文件上传失败！&quot;, e);
    // ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能你看到本文时，又拍云和阿里云的云存储 SDK 已经做了较大改动，这里附上二者的 GitHub 链接：&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;3、Web 编辑器杂谈&lt;/h2&gt;
&lt;h4 id=&quot;31&quot;&gt;3.1、我与 UEditor 的曲折历程&lt;/h4&gt;
&lt;p&gt;2016 年初，我基于学习的目的，业余做了一个带新闻发布功能的网站。在这之前，我曾先后用过 &lt;a href=&quot;http://www.freetextbox.com/#target_blank&quot; title=&quot;FreeTextBox 官网&quot;&gt;FreeTextBox&lt;/a&gt; 和 &lt;a href=&quot;https://ckeditor.com/#target_blank&quot; title=&quot;CKeditor 官网&quot;&gt;FCKeditor（已更名为 CKEditor）&lt;/a&gt;，印象中都还不错，但也都有着这样或者那样的问题，比如 &lt;a href=&quot;http://www.cnblogs.com/hanzongze/p/js-ueditor.html#32#target_blank&quot;&gt;CKEditor 中空格变问号的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我上网搜了一下，发现大家对 UEditor 的评价还不错，于是决定 Web 编辑器就用 UEditor，由于是第一次用，过程相对曲折。做完新闻发布功能之后，就顺带记录了一下，也就是本文初稿。&lt;/p&gt;
&lt;p&gt;两年之后，也就是去年，公司要做个带资讯发布功能的媒体网站，在我的建议下，最终选用了 UMeditor。但整个团队除我之外都没用过，尤其是那几个前端，连富文本编辑器是啥都不知道，最后就由我负责带领前端来做这块儿的功能。&lt;/p&gt;
&lt;p&gt;因为这次做的是实际项目，公司的编辑们都在用，后台的 UI 框架也由 jQuery 版的 EasyUI 变成了 React 版的 Ant Design，所以遇到的细节问题也比较多。其中对编辑器的各种配置和后端改造，都是由我统一解决好再跟前端对接的。&lt;/p&gt;
&lt;p&gt;又过了一年，也就是本月初，我在整理资料时再次看到了本文初稿。瞬间就想起我去年用 UMeditor 的过程中也做过一些记录，然后就想着干脆把两次的记录整合起来，结果怎么都找不到去年的记录，只好作罢。也许还留在那家公司的电脑里吧！&lt;/p&gt;
&lt;h4 id=&quot;32&quot;&gt;3.2、CKEditor 空格变问号的原因及解决办法&lt;/h4&gt;
&lt;p&gt;经查，导致该问题的根本原因是编码转换。在 UTF-8 里有一个特殊的编码&lt;code&gt;0xC2 0xA0&lt;/code&gt;，转换成字符的时候，表现为一个空格，跟普通的半角空格一样，不同的是它的宽度不会被压缩，因此常被用来做网页排版。而在 GB2312、Unicode 等字符集中却没有这个编码，因此如果简单地进行编码转换，这个编码就会被替换成问号。&lt;/p&gt;
&lt;p&gt;前些年在实际项目中还遇到过更奇葩的情况，文章保存之后，内容中的问号就全都没了。后来发现是别人也遇到了空格变问号的问题，但选错了解决方案，他是直接把问号又替换成空格，结果正常的问号也被毙掉了。&lt;/p&gt;
&lt;p&gt;正确的做法是，用 UTF-8 格式的编码进行替换，把那个特殊的空格替换为普通的空格，如果是 HTML 字符串，那就替换为&lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;。C# 代码替换 HTML 字符串的示例如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;byte[] space = new byte[]{0xc2,0xa0};
string utfSpace = Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(space);
htmlStr = htmlStr.Replace(utfSpace,&quot;&amp;amp;nbsp;&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在替换之前不能进行编码转换，一定要继续使用 UTF-8 编码。如果已经转换成其它编码，那就彻底没救了，因为这时候错误的问号和正常的问号之间已经没有分别了。&lt;/p&gt;
&lt;blockquote readability=&quot;6.6704225352113&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文链接&lt;/strong&gt;：&lt;a href=&quot;http://www.cnblogs.com/hanzongze/p/js-ueditor.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/hanzongze/p/js-ueditor.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;版权声明&lt;/strong&gt;：本文为博客园博主 &lt;a href=&quot;http://www.cnblogs.com/hanzongze/&quot;&gt;&lt;strong&gt;韩宗泽&lt;/strong&gt;&lt;/a&gt; 原创，作者保留署名权！欢迎通过转载、演绎或其它传播方式来使用本文，但必须在明显位置给出作者署名和本文链接！个人博客，能力有限，若有不当之处，敬请批评指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Jul 2019 15:08:00 +0000</pubDate>
<dc:creator>韩宗泽</dc:creator>
<og:description>UEditor 的核心特点就是：产自大厂、开源免费、功能全面（相当全）、体验较为切合国人习惯。只需要修改相应的后端代码，即可把 UEditor/UMeditor 中的图片上传到诸如又拍云 USS 或阿</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanzongze/p/js-ueditor.html</dc:identifier>
</item>
</channel>
</rss>