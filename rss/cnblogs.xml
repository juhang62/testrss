<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>定时任务方案大百科 - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/11669468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/11669468.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082748472-800378921.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.9230769230769&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://crossoverjie.top/&quot;&gt;https://crossoverjie.top&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;节前有更新一篇定时任务的相关文章&lt;a href=&quot;https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/&quot;&gt;《延时消息之时间轮》&lt;/a&gt;，有朋友提出希望可以完整的介绍下常见的定时任务方案，于是便有了这篇文章。&lt;/p&gt;

&lt;p&gt;本次会主要讨论大家使用较多的方案，首先第一个就是 &lt;code&gt;Timer&lt;/code&gt; 定时器，它可以在指定时间后运行或周期性运行任务；使用方法也非常简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082749039-433364477.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样便可创建两个简单的定时任务，分别在 &lt;code&gt;3s/5s&lt;/code&gt; 之后运行。&lt;/p&gt;
&lt;p&gt;使用起来确实很简单，但也有不少毛病，想要搞清楚它所存在的问题首先就要理解其实现原理。&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;定时任务要想做到按照我们给定的时间进行调度，那就得需要一个可以排序的容器来存放这些任务。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Timer&lt;/code&gt; 中内置了一个 &lt;code&gt;TaskQueue&lt;/code&gt; 队列，用于存放所有的定时任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082753914-1345922430.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实本质上是用数组来实现的一个&lt;code&gt;最小堆&lt;/code&gt;，它可以让每次写入的定时任务都按照执行时间进行排序，保证在堆顶的任务执行时间是最小的。&lt;/p&gt;
&lt;p&gt;这样在需要执行任务时，每次只需要取出堆顶的任务运行即可，所以它取出任务的效率很高为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082755044-777848992.jpg&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;结合代码会比较容易理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082756995-364244941.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在写入任务的时候会将一些基本属性存放起来（任务的调度时间、周期、初始化任务状态等），最后就是要将任务写入这个内置队列中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082757782-258774947.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082758526-1934890357.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在任务写入过程中最核心的方法便是这个 &lt;code&gt;fixUp()&lt;/code&gt; ,它会将写入的任务从队列的中部通过执行时间与前一个任务做比对，一直不断的向前比较。&lt;/p&gt;
&lt;p&gt;如果这个时间是最早执行的，那最后将会被移动到堆顶。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082759178-1024229828.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这个过程可以看出 &lt;code&gt;Timer&lt;/code&gt; 新增一个任务的时间复杂度为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082759622-1703409431.jpg&quot;/&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;再来看看它执行任务的过程，其实在初始化 &lt;code&gt;Timer&lt;/code&gt; 的时候它就会在后台启动一个线程用于从 &lt;code&gt;TaskQueue&lt;/code&gt; 队列中获取任务进行调度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082800133-1996729584.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082800625-1528801365.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们只需要看他的 &lt;code&gt;run()&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082801470-1675600648.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这段代码中很明显可以看出这个线程是一直不断的在调用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;task = queue.getMin();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来获取任务，最后使用 &lt;code&gt;task.run()&lt;/code&gt; 来执行任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082802451-1699575742.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;getMin()&lt;/code&gt; 方法中可以看出和我们之前说的一致，每次都是取出堆顶的任务执行。&lt;/p&gt;
&lt;p&gt;一旦取出来的任务执行时间满足要求便可运行，同时需要将它从这个最小堆实现的队列中删除；也就是调用的 &lt;code&gt;queue.removeMin()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082802933-55618152.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082804899-1488517932.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实它的核心原理和写入任务类似，只不过是把堆尾的任务提到堆顶，然后再依次比较将任务往后移，直到到达合适的位置。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从刚才的写入和删除任务的过程中其实也能看出，这个最小堆只是相对有序并不是绝对的有序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码看完了，自然也能得出它所存在的问题了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后台调度任务的线程只有一个，所以导致任务是阻塞运行的，一旦其中一个任务执行周期过长将会影响到其他任务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timer&lt;/code&gt; 本身没有捕获其他异常（只捕获了 &lt;code&gt;InterruptedException&lt;/code&gt;），一旦任务出现异常（比如空指针）将导致后续任务不会被执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然 &lt;code&gt;Timer&lt;/code&gt; 存在一些问题，于是在 &lt;code&gt;JDK1.5&lt;/code&gt; 中的并发包中推出了 &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 来替代 &lt;code&gt;Timer&lt;/code&gt;，从它所在包路径也能看出它本身是支持任务并发执行的。&lt;/p&gt;
&lt;p&gt;先来看看它的类继承图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082805962-1604017182.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到他本身也是一个线程池，继承了 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082807023-1337177645.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从他的构造函数中也能看出，本质上也是创建了一个线程池，只是这个线程池中的阻塞队列是一个自定义的延迟队列 &lt;code&gt;DelayedWorkQueue&lt;/code&gt;（与 &lt;code&gt;Timer&lt;/code&gt; 中的 &lt;code&gt;TaskQueue&lt;/code&gt; 作用一致）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;新建任务&quot;&gt;新建任务&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082808028-533537554.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们写入一个定时任务时，首先会将任务写入到 &lt;code&gt;DelayedWorkQueue&lt;/code&gt; 中，其实这个队列本质上也是使用数组实现的最小堆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082808819-1363571261.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建任务时最终会调用到 &lt;code&gt;offer()&lt;/code&gt; 方法，在这里也会使用 &lt;code&gt;siftUp()&lt;/code&gt; 将写入的任务移动到堆顶。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082810170-959047070.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082812432-847306402.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082813674-635466872.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原理就和之前的 &lt;code&gt;Timer&lt;/code&gt; 类似，只不过这里是通过自定义比较器来排序的，很明显它是通过任务的执行时间进行比较的。&lt;/p&gt;
&lt;h2 id=&quot;运行任务&quot;&gt;运行任务&lt;/h2&gt;
&lt;p&gt;所以这样就能将任务按照执行时间的顺序排好放入到线程池中的阻塞队列中。&lt;/p&gt;
&lt;p&gt;这时就得需要回顾一下之前线程池的知识点了：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在线程池中会利用初始化时候的后台线程从阻塞队列中获取任务，只不过在这里这个阻塞队列变为了 &lt;code&gt;DelayedWorkQueue&lt;/code&gt;，所以每次取出来的一定是按照执行时间排序在前的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082815932-1540589098.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082817010-765161458.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;Timer&lt;/code&gt; 类似，要在任务取出后调用 &lt;code&gt;finishPoll()&lt;/code&gt; 进行删除，也是将最后一个任务提到堆顶，然后挨个对比移动到合适的位置。&lt;/p&gt;
&lt;p&gt;而触发消费这个 &lt;code&gt;DelayedWorkQueue&lt;/code&gt; 队列的地方则是在写入任务的时候。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082817571-1617430740.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082818238-730883553.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本质上是调用 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的 &lt;code&gt;addWorker()&lt;/code&gt; 来写入任务的，所以消费 &lt;code&gt;DelayedWorkQueue&lt;/code&gt; 也是在其中触发的。&lt;/p&gt;
&lt;p&gt;这里更多的是关于线程池的知识点，不太清楚的可以先看看之前总结的线程池篇，这里就不再赘述。&lt;/p&gt;
&lt;p&gt;原理看完了想必也知道和 &lt;code&gt;Timer&lt;/code&gt; 的优势在哪儿了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;单线程阻塞&lt;/td&gt;
&lt;td&gt;多线程任务互不影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;异常时任务停止&lt;/td&gt;
&lt;td&gt;依赖于线程池，单个任务出现异常不影响其他任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以有定时任务的需求时很明显应当淘汰 &lt;code&gt;Timer&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;最后一个是基于时间轮的定时任务，这个我在上一篇&lt;a href=&quot;https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/&quot;&gt;《延时消息之时间轮》&lt;/a&gt;有过详细介绍。&lt;/p&gt;
&lt;p&gt;通过源码分析我们也可以来做一个对比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;写入效率&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082759622-1703409431.jpg&quot;/&gt;基于最小堆，任务越多效率越低&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082755044-777848992.jpg&quot;/&gt; 与 &lt;code&gt;HashMap&lt;/code&gt; 的写入类似，效率很高。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;执行效率&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082755044-777848992.jpg&quot;/&gt; 每次取出第一个，效率很高&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082755044-777848992.jpg&quot;/&gt; 每秒拨动一个指针取出任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以当写入的任务较多时，推荐使用时间轮，它的写入效率更高。&lt;/p&gt;
&lt;p&gt;但任务很少时其实 &lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 也不错，毕竟它不会每秒都去拨动指针消耗 &lt;code&gt;CPU&lt;/code&gt; ，而是一旦没有任务线程会阻塞直到有新的任务写入进来。&lt;/p&gt;
&lt;h2 id=&quot;ringbufferwheel-更新&quot;&gt;RingBufferWheel 更新&lt;/h2&gt;
&lt;p&gt;在之前的&lt;a href=&quot;https://crossoverjie.top/2019/09/27/algorithm/time%20wheel/&quot;&gt;《延时消息之时间轮》&lt;/a&gt;中自定义了一个基于时间轮的定时任务工具 &lt;code&gt;RingBufferWheel&lt;/code&gt; ，在网友的建议下这次顺便也做了一些调整，优化了 API 也新增了取消任务的 API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082819928-545902533.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在之前的 API 中，每当新增一个任务都要调用一下 &lt;code&gt;start()&lt;/code&gt;，感觉很怪异；这次直接将启动函数合并到 &lt;code&gt;addTask&lt;/code&gt; 中，使用起来更加合理。&lt;/p&gt;
&lt;p&gt;同时任务的写入也支持并发了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082822137-727852902.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082823486-583881832.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过这里需要注意的是 &lt;code&gt;start()&lt;/code&gt; 在并发执行的时候只能执行一次，于是就利用了 &lt;code&gt;CAS&lt;/code&gt; 来保证同时只有一个线程可以执行成功。&lt;/p&gt;
&lt;p&gt;同时在新增任务的时候会返回一个 &lt;code&gt;taskId&lt;/code&gt; ，利用此 ID 便可实现取消任务的需求（虽然是比较少见），使用方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431471/201910/1431471-20191014082825575-959107025.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的朋友可以看下源码也很容易理解。&lt;/p&gt;

&lt;p&gt;最后再扩展一下，上文我们所提到的所有方案都是单机版的，只能在单个进程中使用。&lt;/p&gt;
&lt;p&gt;一旦我们需要在分布式场景下实现定时任务的高可用、可维护之类的需求就得需要一个完善的分布式调度平台的支持。&lt;/p&gt;
&lt;p&gt;目前市面上流行的开源解决方案也不少：&lt;/p&gt;
&lt;p&gt;我个人在工作中只使用过前面两者，都能很好的解决分布式调度的需求；比如高可用、统一管理、日志报警等。&lt;/p&gt;
&lt;p&gt;当然这些开源工具其实在定时调度这个功能上和上文中所提到的一些方案是分不开的，只是需要结合一些分布式相关的知识；比远程调用、统一协调、分布式锁、负载均衡之类的。&lt;/p&gt;
&lt;p&gt;感兴趣的朋友可以自行查看下他们的源码或官方文档。&lt;/p&gt;

&lt;p&gt;一个小小的定时器其实涉及到的知识点还不少，包括数据结构、多线程等，希望大家看完多少有些帮助，顺便帮忙点赞转发搞起🥳。&lt;/p&gt;
&lt;p&gt;本文所涉及到的所有源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/cim&quot; class=&quot;uri&quot;&gt;https://github.com/crossoverJie/cim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 00:28:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>原文地址： 'https://crossoverjie.top' 前言 节前有更新一篇定时任务的相关文章 '《延时消息之时间轮》' ，有朋友提出希望可以完整的介绍下常见的定时任务方案，于是便有了这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/11669468.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-01-06.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-01-06.html</guid>
<description>&lt;p&gt;对于一个 .NET Core开发人员，你可能没有使用过Docker，但是你不可能没有听说过Docker。Docker是Github上最受欢迎的开源项目之一，它号称要成为所有云应用的基石，并把互联网升级到下一代。Docker是dotCloud公司开源的一款产品，从其诞生那一刻算起，在短短两三年时间里就成为了开源社区最火爆的项目。对于完全拥抱开源的.NET Core来说，它自然应该对Docker提供完美的支持。对于接下来的内容，我们假设你已经对Docker有了基本的了解，并且在你的机器上（Windows）上已经安装了Docker。&lt;/p&gt;

&lt;p&gt;我们将演示如何创建一个ASP.NET Core程序并将其编译成Docker镜像，并Docker环境针对该镜像创建一个容器来启动一个应用实例。简单起见，我们还是直接采用脚手架命令行的形式来创建这个ASP.NET Core应用。如下图1所示，我们执行&lt;strong&gt;dotnet new web&lt;/strong&gt;命令在“d:\projects\helloworld”目录下创建一个空的ASP.NET Core应用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082727442-2022590195.png&quot;&gt;&lt;img width=&quot;601&quot; height=&quot;316&quot; title=&quot;1-23&quot; alt=&quot;1-23&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082727804-1834914274.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们现在需要将这个ASP.NET Core应用制作成一个Docker镜像，为此我们需要在项目根目录下创建一个&lt;strong&gt;Dockerfile&lt;/strong&gt;文件（文件名就是Dokerfile，没有扩展名），并在该文件中定义如下的内容。如果我们对Dockerfile具有基本的了解，对于这个文件的内容应该不难理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# 1&lt;span&gt;. 指定编译和发布应用的镜像
FROM mcr.microsoft.com/dotnet/core/sdk:&lt;/span&gt;3.0&lt;span&gt; AS build

# &lt;/span&gt;2&lt;span&gt;. 指定（编译和发布）工作目录
WORKDIR /app

# &lt;/span&gt;3&lt;span&gt;. 拷贝.csproj到工作目录/app，然后执行dotnet restore恢复所有安装的NuGet包
COPY *.csproj ./
RUN dotnet restore

# &lt;/span&gt;4&lt;span&gt;. 拷贝所有文件到工作目录(/app)，然后执行dotnet publish命令将应用发布到/app/out目录下
COPY . ./
RUN dotnet publish -c Release -o out

# &lt;/span&gt;5&lt;span&gt;. 编译生成Docker镜像
# &lt;/span&gt;5.1&lt;span&gt;.设置基础镜像
FROM mcr.microsoft.com/dotnet/core/aspnet:&lt;/span&gt;3.0&lt;span&gt; AS runtime

# &lt;/span&gt;5.2&lt;span&gt;. 设置（运行）工作目录，并将发布文件拷贝到out子目录下
WORKDIR /app
COPY --from&lt;/span&gt;=&lt;span&gt; build /app/out .

# &lt;/span&gt;5.3&lt;span&gt;. 利用环境变量设置ASP.NET Core应用的监听地址
ENV ASPNETCORE_URLS http://&lt;/span&gt;0.0.0.0:3721&lt;span&gt;

# &lt;/span&gt;5.4&lt;span&gt;. 执行dotnet命令启动ASP.NET Core应用
ENTRYPOINT &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;dotnet&quot;, &quot;helloworld.dll&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个Dockerfile采用了一个中间层（build）来暂存ASP.NET Core MVC应用发布后的资源，其工作目录为“/app”。具体来说，这个层采用“&lt;strong&gt;microsoft/aspnetcore-build:2&lt;/strong&gt;”作为基础镜像，我们先将定义项目的.csproj文件（helloworld.csproj）拷贝到当前工作目录，然后运行“dotnet restore”命令恢复所有注册在这个项目文件中的NuGet包。接下来我们将当前项目的所有文件拷贝到当前工作目录，并执行dotnet publish对整个项目进行编译发布（针对Release模式），发布后的资源被保存到目录“/app/out”中。&lt;/p&gt;
&lt;p&gt;在真正将编译生成Docker镜像的时候，我们采用“&lt;strong&gt;mcr.microsoft.com/dotnet/core/aspnet:3.0&lt;/strong&gt;”作为基础镜像，由于应用在上面进行了预先发布，所以我们只需要将发布后的所有文件拷贝到当前工作目录就可以了。接下来我们通过环境变量设置了ASP.NET Core应用的监听地址（http://0.0.0.0:3721）。针对ENTRYPOINT的定义（ENTRYPOINT [&quot;dotnet&quot;, &quot;helloworld.dll&quot;]），我们知道当容器被启动的时候，“dotnet helloworld.dll”命令会被执行以启动这个ASP.NET Core应用。&lt;/p&gt;

&lt;p&gt;Dockerfile文件定义好之后，我们打开CMD命令行并切换到项目所在根目录（也就是Dockerfile文件所在的目录），然后执行“docker build -t helloworldapp .”命令，该命令会利用这个Dockerfile文件生成一个命名为helloworldapp”的Docker镜像。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082728209-1158666669.png&quot;&gt;&lt;img width=&quot;790&quot; height=&quot;902&quot; title=&quot;1-24&quot; alt=&quot;1-24&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082728771-1614378973.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;既然Docker镜像已经被成功创建出来了，那么余下的工作就很简单了，我们只需要针对这个镜像创建对应的容器，最终的ASP.NET Core应用的启动就可以直接通过启动该容器来完成。如下图所示，我们执行“&lt;strong&gt;docker run -d -p 8080:3721 --name myapp helloworldapp&lt;/strong&gt;”命令针对前面生成的Docker镜像（helloworldapp）创建并启动了一个命名为myapp（--name myapp）的容器。由于我们从外面访问这个应用，所以我们通过端口映射（-p 8080:3721）将内部监听端口3721映射为当前宿主机器的端口8080，所以我们利用地址“http://localhost:8080”访问这个通过Docker容器承载的ASP.NET Core应用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082729159-1871546107.png&quot;&gt;&lt;img width=&quot;515&quot; height=&quot;251&quot; title=&quot;1-25&quot; alt=&quot;1-25&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191014082729417-1698492428.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Windows [下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Mac OS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-01-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Linux&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-061.html&quot;&gt;[ASP.NET Core 3框架揭秘] 跨平台开发体验: Docker&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Oct 2019 00:27:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>对于一个 .NET Core开发人员，你可能没有使用过Docker，但是你不可能没有听说过Docker。Docker是Github上最受欢迎的开源项目之一，它号称要成为所有云应用的基石，并把互联网升级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-01-06.html</dc:identifier>
</item>
<item>
<title>TensorFlow2.0（六）：Dataset - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/11669452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/11669452.html</guid>
<description>&lt;pre&gt;
(&amp;lt;tf.Tensor: id=250, shape=(4, 3), dtype=int32, numpy=
array([[81, 53, 85],
       [13,  7, 25],
       [83, 25, 55],
       [53, 41, 11]], dtype=int32)&amp;gt;, &amp;lt;tf.Tensor: id=251, shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3], dtype=int32)&amp;gt;)
(&amp;lt;tf.Tensor: id=252, shape=(4, 3), dtype=int32, numpy=
array([[41, 58, 39],
       [44, 68, 55],
       [52, 34, 22],
       [66, 39,  5]], dtype=int32)&amp;gt;, &amp;lt;tf.Tensor: id=253, shape=(4,), dtype=int32, numpy=array([4, 5, 6, 7], dtype=int32)&amp;gt;)
(&amp;lt;tf.Tensor: id=254, shape=(2, 3), dtype=int32, numpy=
array([[73,  8, 20],
       [67, 71, 98]], dtype=int32)&amp;gt;, &amp;lt;tf.Tensor: id=255, shape=(2,), dtype=int32, numpy=array([8, 9], dtype=int32)&amp;gt;)
&lt;/pre&gt;</description>
<pubDate>Mon, 14 Oct 2019 00:13:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>在整个机器学习过程中，除了训练模型外，应该就属数据预处理过程消耗的精力最多，数据预处理过程需要完成的任务包括数据读取、过滤、转换等等。为了将用户从繁杂的预处理操作中解放处理，更多地将精力放在算法建模上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/11669452.html</dc:identifier>
</item>
<item>
<title>Spring使用ThreadPoolTaskExecutor自定义线程池及实现异步调用 - CREATE_17</title>
<link>http://www.cnblogs.com/createboke/p/11669241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/createboke/p/11669241.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;多线程一直是工作或面试过程中的高频知识点，今天给大家分享一下使用 ThreadPoolTaskExecutor 来自定义线程池和实现异步调用多线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一threadpooltaskexecutor&quot;&gt;一、ThreadPoolTaskExecutor&lt;/h3&gt;
&lt;p&gt;本文采用 Executors 的工厂方法进行配置。&lt;/p&gt;
&lt;h4 id=&quot;将线程池用到的参数定义到配置文件中&quot;&gt;1、将线程池用到的参数定义到配置文件中&lt;/h4&gt;
&lt;p&gt;在项目的 resources 目录下创建 executor.properties 文件，并添加如下配置：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# 异步线程配置
# 核心线程数
async.executor.thread.core_pool_size=5
# 最大线程数
async.executor.thread.max_pool_size=8
# 任务队列大小
async.executor.thread.queue_capacity=2
# 线程池中线程的名称前缀
async.executor.thread.name.prefix=async-service-
# 缓冲队列中线程的空闲时间
async.executor.thread.keep_alive_seconds=100&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;executors-的工厂配置&quot;&gt;2、Executors 的工厂配置&lt;/h4&gt;
&lt;h5 id=&quot;配置详情&quot;&gt;2.1、配置详情&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
// @PropertySource是找的target目录下classes目录下的文件，resources目录下的文件编译后会生成在classes目录
@PropertySource(value = {&quot;classpath:executor.properties&quot;}, ignoreResourceNotFound=false, encoding=&quot;UTF-8&quot;)
@Slf4j
public class ExecutorConfig {

    @Value(&quot;${async.executor.thread.core_pool_size}&quot;)
    private int corePoolSize;
    @Value(&quot;${async.executor.thread.max_pool_size}&quot;)
    private int maxPoolSize;
    @Value(&quot;${async.executor.thread.queue_capacity}&quot;)
    private int queueCapacity;
    @Value(&quot;${async.executor.thread.name.prefix}&quot;)
    private String namePrefix;
    @Value(&quot;${async.executor.thread.keep_alive_seconds}&quot;)
    private int keepAliveSeconds;

    @Bean(name = &quot;asyncTaskExecutor&quot;)
    public ThreadPoolTaskExecutor taskExecutor() {
        log.info(&quot;启动&quot;);
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 核心线程数
        executor.setCorePoolSize(corePoolSize);
        // 最大线程数
        executor.setMaxPoolSize(maxPoolSize);
        // 任务队列大小
        executor.setQueueCapacity(queueCapacity);
        // 线程前缀名
        executor.setThreadNamePrefix(namePrefix);
        // 线程的空闲时间
        executor.setKeepAliveSeconds(keepAliveSeconds);
        // 拒绝策略
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // 线程初始化
        executor.initialize();
        return executor;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;注解说明&quot;&gt;2.2、注解说明&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Configuration：&lt;/strong&gt;Spring 容器在启动时，会加载带有 @Configuration 注解的类，对其中带有 @Bean 注解的方法进行处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Bean：&lt;/strong&gt;是一个方法级别上的注解，主要用在 @Configuration 注解的类里，也可以用在 @Component 注解的类里。添加的 bean 的 id 为方法名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@PropertySource：&lt;/strong&gt;加载指定的配置文件。value 值为要加载的配置文件，ignoreResourceNotFound 意思是如果加载的文件找不到，程序是否忽略它。默认为 false 。如果为 true ，则代表加载的配置文件不存在，程序不报错。在实际项目开发中，最好设置为 false 。&lt;strong&gt;如果 application.properties 文件中的属性与自定义配置文件中的属性重复，则自定义配置文件中的属性值被覆盖，加载的是 application.properties 文件中的配置属性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Slf4j：&lt;/strong&gt;lombok 的日志输出工具，加上此注解后，可直接调用 log 输出各个级别的日志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@Value：&lt;/strong&gt;调用配置文件中的属性并给属性赋予值。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;线程池配置说明&quot;&gt;2.3、线程池配置说明&lt;/h5&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;核心线程数：&lt;/strong&gt;线程池创建时候初始化的线程数。当线程数超过核心线程数，则超过的线程则进入任务队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大线程数：&lt;/strong&gt;只有在任务队列满了之后才会申请超过核心线程数的线程。不能小于核心线程数。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;任务队列：&lt;/strong&gt;线程数大于核心线程数的部分进入任务队列。如果任务队列足够大，超出核心线程数的线程不会被创建，它会等待核心线程执行完它们自己的任务后再执行任务队列的任务，而不会再额外地创建线程。&lt;strong&gt;举例：&lt;/strong&gt;如果有20个任务要执行，核心线程数：10，最大线程数：20，任务队列大小：2。则系统会创建18个线程。这18个线程有执行完任务的，再执行任务队列中的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程的空闲时间：&lt;/strong&gt;当 线程池中的线程数量 大于 核心线程数 时，如果某线程空闲时间超过 keepAliveTime ，线程将被终止。这样，线程池可以动态的调整池中的线程数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拒绝策略：&lt;/strong&gt;如果（总任务数 - 核心线程数 - 任务队列数）-（最大线程数 - 核心线程数）&amp;gt; 0 的话，则会出现线程拒绝。举例：( 12 - 5 - 2 ) - ( 8 - 5 ) &amp;gt; 0，会出现线程拒绝。线程拒绝又分为 4 种策略，分别为：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CallerRunsPolicy()：&lt;/strong&gt;交由调用方线程运行，比如 main 线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AbortPolicy()：&lt;/strong&gt;直接抛出异常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DiscardPolicy()：&lt;/strong&gt;直接丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DiscardOldestPolicy()：&lt;/strong&gt;丢弃队列中最老的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;线程池配置个人理解&quot;&gt;2.4、线程池配置个人理解&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当一个任务被提交到线程池时，首先查看线程池的核心线程是否都在执行任务。如果没有，则选择一条线程执行任务。&lt;/li&gt;
&lt;li&gt;如果都在执行任务，查看任务队列是否已满。如果不满，则将任务存储在任务队列中。核心线程执行完自己的任务后，会再处理任务队列中的任务。&lt;/li&gt;
&lt;li&gt;如果任务队列已满，查看线程池（最大线程数控制）是否已满。如果不满，则创建一条线程去执行任务。如果满了，就按照策略处理无法执行的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二异步调用线程&quot;&gt;二、异步调用线程&lt;/h3&gt;
&lt;p&gt;通常 ThreadPoolTaskExecutor 是和 @Async 一起使用。在一个方法上添加 @Async 注解，表明是异步调用方法函数。@Async 后面加上线程池的方法名或 bean 名称，表明异步线程会加载线程池的配置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ThreadTest {
    /**
     * 每10秒循环一次，一个线程共循环10次。
     */
    @Async(&quot;asyncTaskExecutor&quot;)
    public void ceshi3() {
        for (int i = 0; i &amp;lt;= 10; i++) {
            log.info(&quot;ceshi3: &quot; + i);
            try {
                Thread.sleep(2000 * 5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;备注：一定要在启动类上添加 @EnableAsync 注解，这样 @Async 注解才会生效。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;三多线程使用场景&quot;&gt;三、多线程使用场景&lt;/h3&gt;
&lt;h4 id=&quot;定时任务-scheduled&quot;&gt;1、定时任务 @Scheduled&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在启动类上添加 @EnableScheduling 注解
@SpringBootApplication
@EnableScheduling
public class SpringBootStudyApplication {
   public static void main(String[] args) {
      SpringApplication.run(SpringBootStudyApplication.class, args);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @Component 注解将定时任务类纳入 spring bean 管理。
@Component
public class listennerTest3 {

    @Autowired
    private ThreadTest t;
    
    // 每1分钟执行一次ceshi3()方法
    @Scheduled(cron = &quot;0 0/1 * * * ?&quot;)
    public void run() {
        t.ceshi3();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ceshi3() 方法调用线程池配置，且异步执行。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ThreadTest {
    /**
     * 每10秒循环一次，一个线程共循环10次。
     */
    @Async(&quot;asyncTaskExecutor&quot;)
    public void ceshi3() {
        for (int i = 0; i &amp;lt;= 10; i++) {
            log.info(&quot;ceshi3: &quot; + i);
            try {
                Thread.sleep(2000 * 5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;程序一启动就异步执行多线程&quot;&gt;2、程序一启动就异步执行多线程&lt;/h4&gt;
&lt;p&gt;通过继承 CommandLineRunner 类实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class ListennerTest implements CommandLineRunner {

    @Autowired
    private ThreadTest t;

    @Override
    public void run(String... args) {
        for (int i = 1; i &amp;lt;= 10; i++) {
            t.ceshi();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ThreadTest {

    @Async(&quot;asyncTaskExecutor&quot;)
    public void ceshi() {
        log.info(&quot;ceshi&quot;);
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义一个-http-接口&quot;&gt;3、定义一个 http 接口&lt;/h4&gt;
&lt;p&gt;还可以通过接口的形式来异步调用多线程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;thread&quot;)
public class ListennerTest2 {

    @Autowired
    private ThreadTest t;

    @GetMapping(&quot;ceshi2&quot;)
    public void run() {
        for (int i = 1; i &amp;lt; 10; i++) {
            t.ceshi2();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ThreadTest {

    @Async(&quot;asyncTaskExecutor&quot;)
    public void ceshi2() {
        for (int i = 0; i &amp;lt;= 3; i++) {
            log.info(&quot;ceshi2&quot;);
        }
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试类&quot;&gt;4、测试类&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class ThreadRunTest {

    @Autowired
    private ThreadTest t;

    @Test
    public void thread1() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            t.ceshi4();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ThreadTest {
    @Async(&quot;asyncTaskExecutor&quot;)
    public void ceshi4() {
        log.info(&quot;ceshi4&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四总结&quot;&gt;四、总结&lt;/h3&gt;
&lt;p&gt;以上主要介绍了 ThreadPoolTaskExecutor 线程池的配置、使用、相关注解的意义及作用，也简单介绍了使用 @Async 来异步调用线程，最后又列举了多线程的使用场景，并配上了代码示例。希望大家喜欢。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117352/201910/1117352-20191014003522920-594091526.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 16:35:00 +0000</pubDate>
<dc:creator>CREATE_17</dc:creator>
<og:description>多线程一直是工作或面试过程中的高频知识点，今天给大家分享一下使用 ThreadPoolTaskExecutor 来自定义线程池和实现异步调用多线程。 一、ThreadPoolTaskExecutor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/createboke/p/11669241.html</dc:identifier>
</item>
<item>
<title>一步步剖析spring bean生命周期 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/11669091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/11669091.html</guid>
<description>&lt;p&gt; 关于spring bean的生命周期，是深入学习spring的基础，也是难点，本篇文章将采用代码+图文结论的方式来阐述spring bean的生命周期，&lt;/p&gt;
&lt;p&gt;本篇文章将阐述清楚下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191014001709580-686364900.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;一  项目结构及源码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.程序目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013225717398-729265938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.applicationContext.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.dao.UserDao&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;userDao&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;singleton&quot;&lt;/span&gt;&lt;span&gt; init-method&lt;/span&gt;&lt;span&gt;=&quot;myInit&quot;&lt;/span&gt;&lt;span&gt; destroy-method&lt;/span&gt;&lt;span&gt;=&quot;myDestroy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;userName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Alan_beijing&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.dao.MyBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;myBeanPostProcessor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.UserDao.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.beans.factory.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.config.BeanPostProcessor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContextAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDao &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean,
        DisposableBean{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.属性注入，注入属性为userName&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：注入属性userName=&quot;+&lt;span&gt;userName);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.无参构造函数，实例化时调用该构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDao() {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用构造函数UserDao()&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.实现BeanNameAware，获取bean id&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String s) {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用setBeanName()获取bean id,bean id=&quot; +&lt;span&gt; s);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.实现BeanFactoryAware,获取bean工厂&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBeanFactory(BeanFactory beanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用setBeanFactory()获取bean工厂,beanFactory=&quot; +&lt;span&gt; beanFactory);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.实现ApplicationContextAware,获取bean上下文&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setApplicationContext(ApplicationContext applicationContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用setApplicationContext()获取bean上下文,applicationContext=&quot; +&lt;span&gt; applicationContext);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.实现InitializingBean，获取afterPropertiesSet&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用afterPropertiesSet()&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.自定义初始化方法myInit()&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myInit() {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用自定义myInit()&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.实现DisposableBean，获取destroy()&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; destroy() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：destroy()&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.自定义销毁方法myDestroy()&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; myDestroy() {
        count&lt;/span&gt;++&lt;span&gt;;
        System.out.println(count &lt;/span&gt;+ &quot;：调用自定义destroy()&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
4.MyBeanPostProcessor.java
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.config.BeanPostProcessor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt; MyBeanPostProcessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;=====调用postProcessBeforeInitialization()=====&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        System.out.println(&lt;/span&gt;&quot;=====调用postProcessAfterInitialization()=====&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二  测试代码及测试结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.test.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.dao.UserDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.AbstractApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTest {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义容器并初始化
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&lt;/span&gt;
        AbstractApplicationContext applicationContext = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        applicationContext.getBean(UserDao.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有关闭容器时，才会调用destroy方法&lt;/span&gt;
&lt;span&gt;        applicationContext.registerShutdownHook();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013231408075-1910547129.png&quot; alt=&quot;&quot; width=&quot;1171&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 三 分析&lt;/p&gt;
&lt;p&gt;通过如上测试结果，bean生命周期流程大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013231528074-1711751939.png&quot; alt=&quot;&quot; width=&quot;967&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1.装配bean&lt;/p&gt;
&lt;p&gt;bean装配为bean生命周期第一环节。所谓装配bean,指将java对象转换为bean的过程。在该示例中，UserDao.jave和MyBeanPostProcessor通过xml方式转化为bean。&lt;/p&gt;
&lt;p&gt;注意：spring框架支持四种方式装配bean：xml方式，java代码方式，自动装配和混合装配方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013233338239-28049865.png&quot; alt=&quot;&quot; width=&quot;913&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.加载applicationContext.xml并实例化&lt;/p&gt;
&lt;p&gt;加载并实例化bean为bean生命周期的第二环节。本文示例通过ClassPathXmlApplicationContext()来加载并，当bean为singleton时，该过程就实例化对象，而不需要等待&lt;/p&gt;
&lt;p&gt;调用applicationContext.getBean()获取bean时才实例化对象，这与prototype是不一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013233202566-851293592.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.属性注入&lt;/p&gt;
&lt;p&gt;bean属性注入为bean生命周期第三环节，采用反射方式注入bean.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013234224352-851445831.png&quot; alt=&quot;&quot; width=&quot;1030&quot; height=&quot;646&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4.实现BeanNameAware,获取bean id&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期的第四环节，实现该接口，可以获取bean的id&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013234714642-1790697002.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.实现BeanFactoryAware,获取bean 工厂&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第五环节，通过实现BeanFactoryAware获取bean工厂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013234512792-913356768.png&quot; alt=&quot;&quot; width=&quot;861&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6.实现ApplicationContextAware,获取运用上下文&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第六环节，通过实现ApplicationContextAware接口，获取bean上下文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013234938379-1494058470.png&quot; alt=&quot;&quot; width=&quot;937&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7.调用Bean后置处理器,before&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第七环节，通过实现后置处理器BeanPostProcessor获取before和after,该过程是通过AOP方式实现的，在before和after之间，发生如下8，9过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235119000-79548969.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.实现InitializingBean的afterPropertiesSet(),获取初始化方法&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第八环节，通过实现InitializingBean，获取afterPropertiesSet()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235312356-935984014.png&quot; alt=&quot;&quot; width=&quot;897&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 9.调用自定义初始化方法,init-method&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第九环节，实现自定义初始化方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235508741-582899838.png&quot; alt=&quot;&quot; width=&quot;984&quot; height=&quot;538&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 10.调用Bean后置处理器after&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第十环节，后置处理器最后环节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235641412-499936050.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;523&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 11.关闭容器AbstractApplicationContext.registerShutDownHook()&lt;/p&gt;
&lt;p&gt;该环节为bean生命周期第十一环节，关闭容器&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235733388-1102096294.png&quot; alt=&quot;&quot; width=&quot;1020&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 12.调用DisposableBean的destroy()&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期第十二环节，实现DisposableBean接口，调用destroy()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191013235923424-1543455846.png&quot; alt=&quot;&quot; width=&quot;974&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 13.调用定制化销毁方法destroy-method&lt;/p&gt;
&lt;p&gt;该过程为bean生命周期最后环节，调用自定义销毁方法destroy-method&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201910/1066923-20191014000101877-316844359.png&quot; alt=&quot;&quot; width=&quot;930&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三  版权区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;  转载博客，必须注明博客出处&lt;/li&gt;
&lt;li&gt;   博主网址：http://www.cnblogs.com/wangjiming/&lt;/li&gt;
&lt;li&gt;   如您有新想法，欢迎提出，邮箱：2098469527@qq.com&lt;/li&gt;
&lt;li&gt;  专业.NET之家技术QQ群：490539956&lt;/li&gt;
&lt;li&gt;  专业化Java之家QQ群：924412846&lt;/li&gt;
&lt;li&gt;  有问必答QQ群：2098469527&lt;/li&gt;
&lt;li&gt;  一对一技术辅导QQ：2098469527&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 13 Oct 2019 16:17:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>关于spring bean的生命周期，是深入学习spring的基础，也是难点，本篇文章将采用代码+图文结论的方式来阐述spring bean的生命周期， 本篇文章将阐述清楚下图。 一 项目结构及源码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangjiming/p/11669091.html</dc:identifier>
</item>
<item>
<title>【JavaScript】使用纯JS实现多张图片的懒加载Lazy（附源码） - 彭胜光</title>
<link>http://www.cnblogs.com/pengshengguang/p/11669176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengshengguang/p/11669176.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、效果图如下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201910/1254758-20191013221352874-1049570631.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的效果图，效果需求如下&lt;/p&gt;
&lt;p&gt;        1、还没加载图片的时候，默认显示加载图片背景图&lt;/p&gt;
&lt;p&gt;        2、刚开始进入页面，自动加载第一屏幕的图片&lt;/p&gt;
&lt;p&gt;        3、下拉界面，当一张图片容器完全显露出屏幕，即刻加载图片，替换背景图&lt;/p&gt;
&lt;p&gt;        4、加载图片的时候，有渐进显示图片效果&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、难点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        1）如何Ajax请求数据&lt;/p&gt;
&lt;p&gt;        2）如何动态将json数据绑定到html中。&lt;/p&gt;
&lt;p&gt;        3）如何通过对图片的定位计算，触发图片懒加载机制&lt;/p&gt;
&lt;p&gt;        4）加分项，显示图片时有渐现的过渡动画&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、前期知识点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        1）Ajax相关知识，XMLHttpRequest对象，所有现代的浏览器都支持此对象。&lt;/p&gt;
&lt;p&gt;        2）innerHTML，数据绑定使用字符串拼接的方式&lt;/p&gt;
&lt;p&gt;        3）HTML DOM getAttribute() 方法，返回自定属性名的属性值（主要是用于返回自定义属性的属性值）&lt;/p&gt;
&lt;p&gt;        4）图片的 onload事件，当图片的src属性的属性值为正确（即能成功加载图片），才能触发图片的onload事件&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、难点逐一攻破&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  &lt;span&gt;1）如何Ajax请求数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;&lt;strong&gt;分四步走&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 1)首先创建一个Ajax对象
var xhr = new XMLHttpRequest;
// 2)打开我们需要请求的数据的那个文件地址
// URL地址后面加随机数目的：清除每一次请求数据时候（get请求）产生的缓存
// 因为每次访问的地址不一样，样浏览器就不会尝试缓存来自服务器的响应，读取本地缓存的数据。
xhr.open('get', 'json/newsList.txt?' + Math.random(), false); // false代表同步
 // 3)监听请求的状态
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 &amp;amp;&amp;amp; /^2\d{2}$/.test(xhr.status)) {
        var val = xhr.responseText;
        jsonData = utils.jsonParse(val);
    }
}
// 4)发送请求
xhr.send(null);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      &lt;strong&gt;  &lt;span&gt;2）如何动态将json数据绑定到html中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  字符串拼接的方式（数据绑定中最常用的方式），&lt;/strong&gt;即通过使用&lt;strong&gt;innerHTML&lt;/strong&gt;，对页面元素进行字符串拼接，再重新渲染到页面中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
var str = &quot;&quot;;
if (jsonData) {
    for (var i = 0, len = jsonData.length; i &amp;lt; len; i++) {
        var curData = jsonData[i];
        str += '&amp;lt;li&amp;gt;';
        str += '&amp;lt;div&amp;gt;&amp;lt;img src=&quot;&quot; trueImg=&quot;' + curData[&quot;img&quot;] + '&quot;&amp;gt;&amp;lt;/div&amp;gt;';
        str += '&amp;lt;div&amp;gt;&amp;lt;h2&amp;gt;' + curData[&quot;title&quot;] + '&amp;lt;/h2&amp;gt;';
        str += '&amp;lt;p&amp;gt;' + curData[&quot;desc&quot;] + '&amp;lt;/p&amp;gt;';
        str += '&amp;lt;/div&amp;gt;';
        str += '&amp;lt;/li&amp;gt;&amp;lt;/div&amp;gt;';
    }
    news.innerHTML += str;
}  &lt;strong&gt;  &lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      &lt;strong&gt;  优势&lt;/strong&gt;：数据绑定最常用的方式，因为浏览器只需要渲染一次（所有模板引擎数据绑定的原理就是字符串拼接，vue、angular、jade、kTemplate.js等等）&lt;br/&gt;                   事先把内容拼接好，最后统一添加到页面中，只引发一次回流&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  弊端&lt;/strong&gt;：我们把新凭借的字符串添加到#ul1中，原有的三个li的鼠标滑过效果都消失了（原来标签绑定的事件都消失了）&lt;br/&gt;                   原来，oUl.innerHTML的作用是把原来的标签以字符串的方式取出，原来作为标签的时候，对应事件绑定的东西已经没有了，然后进行字符串拼接，&lt;br/&gt;                   但是，拼接完成之后，还是字符串！最后再把字符串统一添加到页面中，浏览器还需要把字符串渲染成为对应的标签&lt;/p&gt;

&lt;p&gt;      &lt;strong&gt; &lt;span&gt; 3）如何通过对图片的定位计算，触发图片懒加载机制（&lt;/span&gt;&lt;span&gt;&lt;span&gt;最&lt;/span&gt;&lt;/span&gt;&lt;span&gt;关键点&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201910/1254758-20191014000925803-705942102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  &lt;/strong&gt;思路：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;         &lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;A：代表图片距离屏幕顶部的距离 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//这里使用了utils工具类中的offset方法，具体实现看下面源码
var A = utils.offset(curImgPar).offsetTop + curImgPar.offsetHeight； 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      &lt;strong&gt;          &lt;span&gt;B：代表一屏幕距离+滚动条滚动距离&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//这里使用了utils工具类中的win方法，具体实现看下面源码
var B = utils.win(&quot;clientHeight&quot;) + utils.win(&quot;scrollTop&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      &lt;strong&gt;          &lt;/strong&gt;当&lt;span&gt;&lt;strong&gt;A &amp;lt; B&lt;/strong&gt;&lt;/span&gt;的时候，此时懒加载的默认图片&lt;span&gt;&lt;strong&gt;才能完整显示出来&lt;/strong&gt;&lt;/span&gt;，这个时候就需要触发图片懒加载&lt;/p&gt;

&lt;p&gt;      &lt;strong&gt;  &lt;span&gt;4）加载图片的时候，有渐进显示图片效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;  &lt;/strong&gt;思路，利用window.setInterval 方法，通过对当前图片的透明度属性（curImg.style.opacity） 从透明0开始到透明度1，变化总时间为500ms即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// -&amp;gt;实现渐现效果
function fadeIn(curImg) {
    var duration = 500, // 总时间
    interval = 10, //10ms走一次
    target = 1; //总距离是1
    var step = (target / duration) * interval; //每一步的步长
    var timer = window.setInterval(function () {
        var curOp =  utils.getCss2SS(curImg, &quot;opacity&quot;);
        if (curOp &amp;gt;= 1) {
            curImg.style.opacity = 1;
            window.clearInterval(timer);
            return
        }
        curOp += step;
        curImg.style.opacity = curOp;
    }, interval);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、完整代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt; &lt;span&gt; &lt;/span&gt;&lt;span&gt;1）main.html&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;!--做移动端响应式布局页面，都需要加下面的meta--&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;!--meta:vp+tap一键生成--&amp;gt;
    &amp;lt;title&amp;gt;多张图片的延迟加载&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        * {
            margin: 0;
            padding: 0;
            font-family: &quot;Microsoft Sans Serif&quot;;
            font-size: 14px;
        }
        ul, li {
            list-style: none;
        }
        img {
            display: block;
            border: none;
        }
        .news {
            padding: 10px;
        }
        .news li {
            position: relative;
            height: 60px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        .news li &amp;gt; div:first-child {   /*意思是，li下面的子div，中的第一个*/
            position: absolute;
            top: 10px;
            left: 0;
            width: 75px;
            height: 60px;
            background: url(&quot;./img/loading.PNG&quot;) no-repeat center center #e1e1e1;
            background-size: 100% 100%;
        }
        /*移动端布局，最外层容器是不设置宽高的*/

        .news li &amp;gt; div:first-child img {
            display: none;
            width: 100%;
            height: 100%;
            opacity: 0;  /*这里设置为0的目的是，实现渐进的效果，后面的fadeIn函数，作用就是让图片透明都从0变成1*/
        }

        .news li &amp;gt; div:nth-child(2) {
            height: 60px;
            margin-left: 80px;
        }
        .news li &amp;gt; div:nth-child(2) h2 {
            height: 20px;
            line-height: 20px;
            /*实现文字超出一行自动裁切*/
            overflow: hidden;
            text-overflow: ellipsis; /*超出部分省略号显示*/
            white-space: nowrap; /*强制不换行*/
        }
        .news li &amp;gt; div:nth-child(2) p {
            line-height: 20px;
            font-size: 12px;
            color: #616161;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;ul id=&quot;news&quot; class=&quot;news&quot;&amp;gt;
        &amp;lt;!--&amp;lt;li&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;div&amp;gt;--&amp;gt;
                &amp;lt;!--&amp;lt;img src=&quot;./img/new1.PNG&quot; alt=&quot;&quot;&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;/div&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;div&amp;gt;--&amp;gt;
                &amp;lt;!--&amp;lt;h2&amp;gt;香港四大家族往事,香港四大家族往事,香港四大家族往事&amp;lt;/h2&amp;gt;--&amp;gt;
                &amp;lt;!--&amp;lt;p&amp;gt;香港四大家族往事：李嘉诚为郑裕彤扶灵香港四大家族往事：李嘉诚为郑裕彤扶灵&amp;lt;/p&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;/div&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/li&amp;gt;--&amp;gt;
    &amp;lt;/ul&amp;gt;




&amp;lt;script type=&quot;text/javascript&quot; src=&quot;./tool/utils.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var news = document.getElementById(&quot;news&quot;),
        imgList = news.getElementsByTagName(&quot;img&quot;);

    // 1、获取需要绑定的数据(通过Ajax)
    var jsonData = null;
    ~function () {
        // 1)首先创建一个Ajax对象
        var xhr = new XMLHttpRequest;
        // 2)打开我们需要请求的数据的那个文件地址
        // URL地址后面加随机数目的：清除每一次请求数据时候（get请求）产生的缓存
        // 因为每次访问的地址不一样，样浏览器就不会尝试缓存来自服务器的响应，读取本地缓存的数据。
        xhr.open('get', 'json/newsList.txt?' + Math.random(), false); // false代表同步
        // 3)监听请求的状态
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 &amp;amp;&amp;amp; /^2\d{2}$/.test(xhr.status)) {
                var val = xhr.responseText;
                jsonData = utils.jsonParse(val);
            }
        }
        // 4)发送请求
        xhr.send(null);
    }();
    console.log(jsonData);

    // 2、数据绑定（使用字符串拼接的方式）
    ~function () {
        var str = &quot;&quot;;
        if (jsonData) {
            for (var i = 0, len = jsonData.length; i &amp;lt; len; i++) {
                var curData = jsonData[i];
                str += '&amp;lt;li&amp;gt;';
                str += '&amp;lt;div&amp;gt;&amp;lt;img src=&quot;&quot; trueImg=&quot;' + curData[&quot;img&quot;] + '&quot;&amp;gt;&amp;lt;/div&amp;gt;';
                str += '&amp;lt;div&amp;gt;&amp;lt;h2&amp;gt;' + curData[&quot;title&quot;] + '&amp;lt;/h2&amp;gt;';
                str += '&amp;lt;p&amp;gt;' + curData[&quot;desc&quot;] + '&amp;lt;/p&amp;gt;';
                str += '&amp;lt;/div&amp;gt;';
                str += '&amp;lt;/li&amp;gt;&amp;lt;/div&amp;gt;';
            }
            news.innerHTML += str;
        }
    }();

    // 3、图片延迟加载
    // -&amp;gt;首先实现单张图片的延时加载
    function lazyImg(curImg) {
        var oImg = new Image;
        oImg.src = curImg.getAttribute(&quot;trueImg&quot;);
        oImg.onload = function() {
            curImg.src = this.src;
            curImg.style.display = &quot;block&quot;;
            fadeIn(curImg);
            oImg = null;
        }
        curImg.isLoad = true;
    }

    // -&amp;gt; 循环处理每一张图片
    function handleAllImg() {
        for (var i = 0, len = imgList.length; i &amp;lt; len; i++) {
            var curImg = imgList[i];
            if (curImg.isLoad) { // 当前图片处理过的话，就不需重新进行处理
                continue;
            }

            // -&amp;gt;只有当A小于B的时候再进行处理
//          var A = utils.offset(curImg).top + curImg.offsetHeight; // 这里A不能这么计算，因为此时图片是隐藏的，没有图片，他的offsetHeight当让也是为0
                                                                      // 如果我要的到图片的A值，我们可以通过拿到他父节点的容器就行了，哈哈
            var curImgPar = curImg.parentNode,
                A = utils.offset(curImgPar).offsetTop + curImgPar.offsetHeight,
                B = utils.win(&quot;clientHeight&quot;) + utils.win(&quot;scrollTop&quot;);
            if (A &amp;lt; B) {
                lazyImg(curImg);
            }
        }
    }

    // -&amp;gt;实现渐现效果
    function fadeIn(curImg) {
        var duration = 500, // 总时间
            interval = 10, //10ms走一次
            target = 1; //总距离是1
        var step = (target / duration) * interval; //每一步的步长
        var timer = window.setInterval(function () {
            var curOp =  utils.getCss2SS(curImg, &quot;opacity&quot;);
            if (curOp &amp;gt;= 1) {
                  curImg.style.opacity = 1;
                  window.clearInterval(timer);
                  return
            }
            curOp += step;
            curImg.style.opacity = curOp;
        }, interval);
    }

    // 4、开始的时候（过500ms）加载1屏幕的图片，当滚动条滚动的时候，加载其他图片
    window.setTimeout(handleAllImg, 500);
    window.onscroll = handleAllImg;
    
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      &lt;strong&gt;  &lt;span&gt;2）utils.js&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 为了与全局变量冲突，我们使用单例模式
var utils = {
  // jsonParse: 把JSON格式的字符串转化为JSON格式的对象
  jsonParse: function (str) {
      var val = null;
       try {
          val = JSON.parse(str);
      } catch (e) {
          val = eval('(' + str + ')');
      }
      return val;
  },

  getCss2SS : function(curEle, attr) {
      var val = null, reg = null;
      if ('getComputedStyle' in window) {
          val = window.getComputedStyle(curEle, null)[attr];
      } else {
          if (attr === 'opacity') {
              val = curEle.currentStyle[attr]; // -&amp;gt;返回 alpha(opacity=10)
              reg = /^alpha\(opacity=(\d+(?:\.\d+)?)\)$/i;  //  获取10这个数字
              val = reg.test(val)?reg.exec(val)[1]/100:1  // 超厉害，test与exec一起使用！！！
          }
          val = curEle.currentStyle[attr];
      }
      reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/i; //匹配的情况：纯数值或者带单位的数值
      return reg.test(val) ? parseFloat(val) : val;
  },

  offset : function(curEle) {
      var totalLeft = null,
          totalTop = null,
          par = curEle.offsetParent;
      // 首先把自己本身的进行累加
      totalLeft += curEle.offsetLeft;
      totalTop += curEle.offsetTop;

      while (par) {
          if (navigator.userAgent.indexOf(&quot;MSIE 8.0&quot;) === -1) {
              // 累加父级参照物边框
              totalTop += par.clientTop;
              totalLeft += par.clientLeft;
          }
          // 累加父级参照物本身的偏移
          totalTop += par.offsetTop;
          totalLeft += par.offsetLeft;
          par = par.offsetParent;
      }
      console.log('offsetTop: ' + totalTop + ', offsetLeft: ' + totalLeft);
      var result = {};
      result.offsetTop = totalTop;
      result.offsetLeft = totalLeft;
      return result;
  },

  win : function(attr, value) {
      if (value === undefined) {
          return document.documentElement[attr] || document.body[attr];
      }
      document.documentElement[attr] = value;
      document.body[attr] = value;
  }
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      &lt;strong&gt; &lt;span&gt; 3、json文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
[{&quot;img&quot;:&quot;./img/new1.PNG&quot;, &quot;title&quot;: &quot;1网络强国战略与“十三五”十四大战略&quot;, &quot;desc&quot;: &quot;1互联网是二十世纪人类最大的发明，互联网是二十世纪人类最大的发明&quot;},
 {&quot;img&quot;:&quot;./img/new2.PNG&quot;, &quot;title&quot;: &quot;2网络强国战略与“十三五”十四大战略&quot;, &quot;desc&quot;: &quot;2互联网是二十世纪人类最大的发明，互联网是二十世纪人类最大的发明&quot;},
 {&quot;img&quot;:&quot;./img/new3.PNG&quot;, &quot;title&quot;: &quot;3网络强国战略与“十三五”十四大战略&quot;, &quot;desc&quot;: &quot;3互联网是二十世纪人类最大的发明，互联网是二十世纪人类最大的发明&quot;}
]
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 13 Oct 2019 16:07:00 +0000</pubDate>
<dc:creator>彭胜光</dc:creator>
<og:description>一、效果图如下 上面的效果图，效果需求如下 1、还没加载图片的时候，默认显示加载图片背景图 2、刚开始进入页面，自动加载第一屏幕的图片 3、下拉界面，当一张图片容器完全显露出屏幕，即刻加载图片，替换背</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengshengguang/p/11669176.html</dc:identifier>
</item>
<item>
<title>Zygote家的大儿子 —— SystemServer - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11669031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11669031.html</guid>
<description>&lt;blockquote readability=&quot;3.9473684210526&quot;&gt;
&lt;p&gt;本文基于 Android 9.0 , 代码仓库地址 ： &lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45&quot;&gt;android_9.0.0_r45&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中源码链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/services/java/com/android/server/SystemServer.java&quot;&gt;SystemServer.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/services/core/java/com/android/server/SystemServiceManager.java&quot;&gt;SystemServiceManager.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/services/core/java/com/android/server/SystemService.java&quot;&gt;SystemService.java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先来回顾一下上篇文章 &lt;a href=&quot;https://juejin.im/post/5d8f73bf51882555b149dc64&quot;&gt;Java 世界的盘古和女娲 —— Zygote&lt;/a&gt; ，主要介绍了 Android 世界中的第一个 Java 进程 &lt;code&gt;Zygote&lt;/code&gt;，它的主要工作流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;registerServerSocketFromEnv()&lt;/code&gt;， 注册服务端 socket，用于和客户端进程通信&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preload()&lt;/code&gt;，预加载一系列资源，提高应用启动速度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forkSystemServer()&lt;/code&gt;，创建 &lt;code&gt;system_server&lt;/code&gt; 进程&lt;/li&gt;
&lt;li&gt;功成身退，调用 &lt;code&gt;runSelectLoop()&lt;/code&gt; 等待响应客户端请求，创建应用进程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇文章的主角 &lt;code&gt;system_server&lt;/code&gt; 进程是 &lt;code&gt;Zygote&lt;/code&gt; 进程 fork 出的第一个进程，它负责管理和启动整个 Framework 层。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/800205/201910/800205-20191013232540593-1330019818.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看看 &lt;a href=&quot;http://gityuan.com&quot;&gt;Gityuan&lt;/a&gt; 的这张图片，找一下 &lt;code&gt;System Server&lt;/code&gt; 的位置，它承载了各类系统服务的创建和启动。关于 &lt;code&gt;system_server&lt;/code&gt; 进程的创建流程，上篇文章中已经做了详细介绍，这里再简单看一下流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201910/800205-20191013232541146-1583950787.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终会调用到 &lt;code&gt;SystemServer.main()&lt;/code&gt; 方法。下面就以此为起点，来具体分析 SystemServer 都做了些什么。&lt;/p&gt;
&lt;h2 id=&quot;systemserver-启动流程&quot;&gt;SystemServer 启动流程&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    new SystemServer().run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看 &lt;code&gt;run()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void run() {
    try {
        ......
        // 如果设备时间早于 1970 年，很多 API 处理负数时会 crash。所以直接设置为 1970 年 1 月 1 日
        if (System.currentTimeMillis() &amp;lt; EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }

        // 未设置时区的话默认设为 GMT
        String timezoneProperty =  SystemProperties.get(&quot;persist.sys.timezone&quot;);
        if (timezoneProperty == null || timezoneProperty.isEmpty()) {
            Slog.w(TAG, &quot;Timezone not set; setting to GMT.&quot;);
            SystemProperties.set(&quot;persist.sys.timezone&quot;, &quot;GMT&quot;);
        }

        // 语言地区设置
        if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) {
            final String languageTag = Locale.getDefault().toLanguageTag();

            SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);
            SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);
            SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);
            SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);
        }

        // The system server should never make non-oneway calls
        Binder.setWarnOnBlocking(true);
        // The system server should always load safe labels
        PackageItemInfo.setForceSafeLabels(true);

        // Default to FULL within the system server.
        SQLiteGlobal.sDefaultSyncMode = SQLiteGlobal.SYNC_MODE_FULL;

        // Deactivate SQLiteCompatibilityWalFlags until settings provider is initialized
        SQLiteCompatibilityWalFlags.init(null);

        // Here we go!
        Slog.i(TAG, &quot;Entered the Android system server!&quot;);
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);
        if (!mRuntimeRestart) {
            MetricsLogger.histogram(null, &quot;boot_system_server_init&quot;, uptimeMillis);
        }

        // 设置虚拟机运行库路径
        SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());

        // Mmmmmm... more memory!
        // 清除虚拟机内存增长限制，允许应用申请更多内存
        VMRuntime.getRuntime().clearGrowthLimit();

        // 设置堆内存的有效利用率为 0.8，(可能被忽略)
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);

        // 确保指纹信息已经定义
        Build.ensureFingerprintProperty();

        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);

        // Within the system server, any incoming Bundles should be defused
        // to avoid throwing BadParcelableException.
        BaseBundle.setShouldDefuse(true);

        // Within the system server, when parceling exceptions, include the stack trace
        Parcel.setStackTraceParceling(true);

        // 确保系统的 Binder 调用总是运行在前台优先级
        BinderInternal.disableBackgroundScheduling(true);

        // Increase the number of binder threads in system_server
        BinderInternal.setMaxThreads(sMaxBinderThreads);

        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(
            android.os.Process.THREAD_PRIORITY_FOREGROUND);
            android.os.Process.setCanSelfBackground(false);
        // 1. 创建主线程 Looper
        Looper.prepareMainLooper();
        Looper.getMainLooper().setSlowLogThresholdMs(
                SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);

        // 初始化 native 服务，加载 libandroid_servers.so
        System.loadLibrary(&quot;android_servers&quot;);

        // 检查上次关机是否失败，可能不会有返回值
        performPendingShutdown();

        // 2. 初始化系统上下文
        createSystemContext();

        // 3. 创建系统服务管理 SystemServiceManager
        // 并将 mSystemServiceManager 注册到 sLocalServiceObjects 中
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        mSystemServiceManager.setStartInfo(mRuntimeRestart,
                mRuntimeStartElapsedTime, mRuntimeStartUptime);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
        // Prepare the thread pool for init tasks that can be parallelized
        SystemServerInitThreadPool.get();
    } finally {
        traceEnd();  // InitBeforeStartServices
    }

    // Start services.
    try {
        traceBeginAndSlog(&quot;StartServices&quot;);
        startBootstrapServices(); // 4. 启动系统引导服务
        startCoreServices();      // 5. 启动系统核心服务
        startOtherServices();     // 6. 启动其他服务
        SystemServerInitThreadPool.shutdown();
    } catch (Throwable ex) {
        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);
        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);
        throw ex;
    } finally {
        traceEnd();
    }

    StrictMode.initVmDefaults(null);

    if (!mRuntimeRestart &amp;amp;&amp;amp; !isFirstBootOrUpgrade()) {
        int uptimeMillis = (int) SystemClock.elapsedRealtime();
        MetricsLogger.histogram(null, &quot;boot_system_server_ready&quot;, uptimeMillis);
        final int MAX_UPTIME_MILLIS = 60 * 1000;
        if (uptimeMillis &amp;gt; MAX_UPTIME_MILLIS) {
            Slog.wtf(SYSTEM_SERVER_TIMING_TAG,
                    &quot;SystemServer init took too long. uptimeMillis=&quot; + uptimeMillis);
        }
    }

    // 7. Loop forever.
    Looper.loop();
    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码虽然比较长，但是逻辑很清晰。我在注释里标记了比较重要的 7 个步骤，逐一分析。&lt;/p&gt;
&lt;h3 id=&quot;looper.preparemainlooper&quot;&gt;Looper.prepareMainLooper()&lt;/h3&gt;
&lt;p&gt;初始化 Looper。关于 Handler 消息机制，可以阅读我的另一篇文章 &lt;a href=&quot;https://juejin.im/post/5d712cedf265da03ea5a9ecf&quot;&gt;深入理解 Handler 消息机制&lt;/a&gt; 。最后会调用 &lt;code&gt;Looper.loop()&lt;/code&gt; 开启消息循环，开始处理消息。&lt;/p&gt;
&lt;h3 id=&quot;createsystemcontext&quot;&gt;createSystemContext()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void createSystemContext() {
    // 创建 system_server 上下文信息
    ActivityThread activityThread = ActivityThread.systemMain();
    mSystemContext = activityThread.getSystemContext();
    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);

    final Context systemUiContext = activityThread.getSystemUiContext();
    // 设置主题，用于系统 dialog 等
    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建系统上下文。首先调用 &lt;code&gt;ActivityThread.systemMain()&lt;/code&gt; 方法获取 &lt;code&gt;ActivityThread&lt;/code&gt; 对象，然后再获取上下文。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static ActivityThread systemMain() {
    // 判断是否是大内存设备,在低内存设备上不启用硬件加速
    if (!ActivityManager.isHighEndGfx()) {
        ThreadedRenderer.disable(true);
    } else {
        ThreadedRenderer.enableForegroundTrimming();
    }
    ActivityThread thread = new ActivityThread();
    thread.attach(true, 0);
    return thread;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 &lt;code&gt;ActivityThread.attach()&lt;/code&gt; 方法这里不做具体分析了，后面文章说到应用启动时再来详细解析。&lt;/p&gt;
&lt;p&gt;创建完系统上下文，接下来就是启动各种系统服务了。源码中把服务大致分为了三类，再来回顾一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;startBootstrapServices(); // 4. 启动系统引导服务
startCoreServices();      // 5. 启动系统核心服务
startOtherServices();     // 6. 启动其他服务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逐一进行分析。&lt;/p&gt;
&lt;h3 id=&quot;startbootstrapservices&quot;&gt;startBootstrapServices()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void startBootstrapServices() {
    final String TAG_SYSTEM_CONFIG = &quot;ReadingSystemConfig&quot;;
    SystemServerInitThreadPool.get().submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG);

    // 阻塞等待与 installd 建立 socket 通道
    Installer installer = mSystemServiceManager.startService(Installer.class);

    // 启动 DeviceIdentifiersPolicyService，在 ActivityManagerService 之前
    mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);

    // 启动服务 ActivityManagerService
    mActivityManagerService = mSystemServiceManager.startService(
            ActivityManagerService.Lifecycle.class).getService();
    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
    mActivityManagerService.setInstaller(installer);

    // 启动服务 PowerManagerService
    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);

    // Now that the power manager has been started, let the activity manager
    // initialize power management features.
    mActivityManagerService.initPowerManagement();

    // 启动服务 RecoverySystemService
    mSystemServiceManager.startService(RecoverySystemService.class);

    // Now that we have the bare essentials of the OS up and running, take
    // note that we just booted, which might send out a rescue party if
    // we're stuck in a runtime restart loop.
    RescueParty.noteBoot(mSystemContext);

    // 启动服务 LightsService
    mSystemServiceManager.startService(LightsService.class);

    // Package manager isn't started yet; need to use SysProp not hardware feature
    if (SystemProperties.getBoolean(&quot;config.enable_sidekick_graphics&quot;, false)) {
        mSystemServiceManager.startService(WEAR_SIDEKICK_SERVICE_CLASS);
    }

    // 启动 DisplayManagerService，在 PackageManagerService 之前
    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);

    // We need the default display before we can initialize the package manager.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);

    // 正在加密设备时只运行核心 app
    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);
    if (ENCRYPTING_STATE.equals(cryptState)) {
        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);
        mOnlyCore = true;
    } else if (ENCRYPTED_STATE.equals(cryptState)) {
        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);
        mOnlyCore = true;
    }

    // 启动服务 PackageManagerService
    if (!mRuntimeRestart) {
        MetricsLogger.histogram(null, &quot;boot_package_manager_init_start&quot;,
                (int) SystemClock.elapsedRealtime());
    }
    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,
            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
    mFirstBoot = mPackageManagerService.isFirstBoot();
    mPackageManager = mSystemContext.getPackageManager();
    if (!mRuntimeRestart &amp;amp;&amp;amp; !isFirstBootOrUpgrade()) {
        MetricsLogger.histogram(null, &quot;boot_package_manager_init_ready&quot;,
                (int) SystemClock.elapsedRealtime());
    }
    if (!mOnlyCore) {
        boolean disableOtaDexopt = SystemProperties.getBoolean(&quot;config.disable_otadexopt&quot;,
                false);
        if (!disableOtaDexopt) {
            traceBeginAndSlog(&quot;StartOtaDexOptService&quot;);
            try {
                OtaDexoptService.main(mSystemContext, mPackageManagerService);
            } catch (Throwable e) {
                reportWtf(&quot;starting OtaDexOptService&quot;, e);
            } finally {
                traceEnd();
            }
        }
    }

    // 启动服务 UserManagerService
    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);

    // 初始化属性 cache 以缓存包资源
    AttributeCache.init(mSystemContext);

    // 设置 AMS
    mActivityManagerService.setSystemProcess();

    // DisplayManagerService needs to setup android.display scheduling related policies
    // since setSystemProcess() would have overridden policies due to setProcessGroup
    mDisplayManagerService.setupSchedulerPolicies();

    // 启动服务 OverlayManagerService
    OverlayManagerService overlayManagerService = new OverlayManagerService(
            mSystemContext, installer);
    mSystemServiceManager.startService(overlayManagerService);

    if (SystemProperties.getInt(&quot;persist.sys.displayinset.top&quot;, 0) &amp;gt; 0) {
        // DisplayManager needs the overlay immediately.
        overlayManagerService.updateSystemUiContext();
        LocalServices.getService(DisplayManagerInternal.class).onOverlayChanged();
    }

    // 在单独的线程中启动 SensorService
    mSensorServiceStart = SystemServerInitThreadPool.get().submit(() -&amp;gt; {
        TimingsTraceLog traceLog = new TimingsTraceLog(
                SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);
        startSensorService();
    }, START_SENSOR_SERVICE);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;startBootstrapServices()&lt;/code&gt; 方法中的都是系统启动过程中的关键服务，且相互依赖，主要下列服务 ：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;Installer&lt;/code&gt; &lt;code&gt;DeviceIdentifiersPolicyService&lt;/code&gt; &lt;code&gt;ActivityManagerService&lt;/code&gt; &lt;code&gt;PowerManagerService&lt;/code&gt; &lt;code&gt;RecoverySystemService&lt;/code&gt; &lt;code&gt;LightsService&lt;/code&gt; &lt;code&gt;StartSidekickService&lt;/code&gt; &lt;code&gt;DisplayManagerService&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY&lt;/strong&gt; (100)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PackageManagerService&lt;/code&gt; &lt;code&gt;UserManagerService&lt;/code&gt; &lt;code&gt;OverlayManagerService&lt;/code&gt; &lt;code&gt;SensorService&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一共启动了十二个核心服务。注意中间的 &lt;code&gt;SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY&lt;/code&gt;，它并不是代表什么系统服务，而是一个 int 值 &lt;code&gt;100&lt;/code&gt;,类似的 int 值还有一些，定义在 &lt;code&gt;SystemService&lt;/code&gt; 类中，它的作用是给服务启动过程划分阶段，每个阶段都有特定的含义，可以做不同的事情。这里先混个脸熟，等介绍完所有的服务，再回过头来总结一下有哪些阶段。&lt;/p&gt;
&lt;h3 id=&quot;startcoreservices&quot;&gt;startCoreServices()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void startCoreServices() {
    // 启动服务 BatteryService，需要 LightService
    mSystemServiceManager.startService(BatteryService.class);

    // 启动服务 UsageStatsService，统计应用使用情况
    mSystemServiceManager.startService(UsageStatsService.class);
    mActivityManagerService.setUsageStatsManager(
            LocalServices.getService(UsageStatsManagerInternal.class));

    // 检查是否存在可更新的 WebView。存在就启动服务 WebViewUpdateService
    if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) {
        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);
    }

    // 启动服务 BinderCallsStatsService，跟踪 Binder 调用的 cpu 时间消耗
    BinderCallsStatsService.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动了四个服务，&lt;code&gt;BatteryService&lt;/code&gt; &lt;code&gt;UsageStatsService&lt;/code&gt; &lt;code&gt;WebViewUpdateService&lt;/code&gt; 和 &lt;code&gt;BinderCallsStatsService&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;startotherservices&quot;&gt;startOtherServices()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;startOtherServices()&lt;/code&gt; 源码有一千多行，就像一个杂货铺，启动了一系列的服务。下面尽量精简一下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;KeyAttestationApplicationIdProviderService/KeyChainSystemService
SchedulingPolicyService/TelecomLoaderService/TelephonyRegistry

mContentResolver = context.getContentResolver();

AccountManagerService/ContentService

mActivityManagerService.installSystemProviders();
  
DropBoxManagerService/VibratorService/ConsumerIrService/AlarmManagerService

final Watchdog watchdog = Watchdog.getInstance();
watchdog.init(context, mActivityManagerService);

InputManagerService/WindowManagerService/VrManagerService/BluetoothService
IpConnectivityMetrics/NetworkWatchlistService/PinnerService
InputMethodManagerService/AccessibilityManagerService/StorageManagerService
StorageStatsService/UiModeManagerService/LockSettingsService
PersistentDataBlockService/OemLockService/DeviceIdleController
DevicePolicyManagerService/StatusBarManagerService/ClipboardService
NetworkManagementService/IpSecService/TextServicesManagerService
TextClassificationManagerService/NetworkScoreService/NetworkStatsService
NetworkPolicyManagerService/WifiScanningService/RttService
WifiAware/WifiP2P/Lowpan/Ethernet/ConnectivityService/NsdService
SystemUpdateManagerService/UpdateLockService/NotificationManagerService
DeviceStorageMonitorService/LocationManagerService/CountryDetectorService
SearchManagerService/WallpaperManagerService/AudioService/BroadcastRadioService
DockObserver/ThermalObserver/WiredAccessoryManager/MidiManager/UsbService
SerialService/HardwarePropertiesManagerService/TwilightService
ColorDisplayService/JobSchedulerService/SoundTriggerService/TrustManagerService
BackupManager/AppWidgerService/VoiceRecognitionManager/GestureLauncherService
SensorNotificationService/ContextHubSystemService/DiskStatsService
TimeZoneRulesManagerService/NetworkTimeUpdateService/CommonTimeManagementService
CertBlacklister/EmergencyAffordanceService/DreamManagerService/GraphicsStatsService
CoverageService/PrintManager/CompanionDeviceManager/RestrictionsManagerService
MediaSessionService/MediaUpdateService/HdmiControlService/TvInputManagerService
MediaResourceMonitorService/TvRemoteService/MediaRouterService/FingerprintService
BackgroundDexOptService/PruneInstantAppsJobService/ShortcutService
LauncherAppsService/CrossProfileAppsService/MediaProjectionManagerService
WearConfigService/WearConnectivityService/WearTimeService/WearLeftyService
WearGlobalActionsService/SliceManagerService/CameraServiceProxy/IoTSystemService
MmsServiceBroker/AutoFillService

// It is now time to start up the app processes...
vibrator.systemReady();
lockSettings.systemReady();

// 480
mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); 
// 500
mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); 

wm.systemReady();
mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
mPackageManagerService.systemReady();
mDisplayManagerService.systemReady(safeMode, mOnlyCore);

// Start device specific services
final String[] classes = mSystemContext.getResources().getStringArray(
        R.array.config_deviceSpecificSystemServices);
for (final String className : classes) {
    try {
        mSystemServiceManager.startService(className);
    } catch (Throwable e) {
        reportWtf(&quot;starting &quot; + className, e);
    }
}

// 520
mSystemServiceManager.startBootPhase(SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);

mActivityManagerService.systemReady(() -&amp;gt; {
    // 550
    mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
    
    startSystemUi(context, windowManagerF);
    
    networkManagementF.systemReady();
    ipSecServiceF.systemReady();
    networkStatsF.systemReady();
    connectivityF.systemReady();
    
    Watchdog.getInstance().start
    mPackageManagerService.waitForAppDataPrepared();

    // 600
    mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
    
    locationF.systemRunning();
    countryDetectorF.systemRunning();
    networkTimeUpdaterF.systemRunning();
    commonTimeMgmtServiceF.systemRunning();
    inputManagerF.systemRunning();
    telephonyRegistryF.systemRunning();
    mediaRouterF.systemRunning();
    mmsServiceF.systemRunning();
    incident.systemRunning();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码可以看到启动了相当多的系统服务。&lt;code&gt;startOtherServices()&lt;/code&gt; 方法共经历了五个启动阶段，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SystemService.PHASE_LOCK_SETTINGS_READY             // 480
SystemService.PHASE_SYSTEM_SERVICES_READY           // 500
SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY  // 520
SystemService.PHASE_ACTIVITY_MANAGER_READY          // 550
SystemService.PHASE_THIRD_PARTY_APPS_CAN_START      // 600&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用的 &lt;code&gt;mActivityManagerService.systemReady()&lt;/code&gt; 方法。该方法中会调用 &lt;code&gt;startHomeActivityLocked&lt;/code&gt; 来启动桌面 Activity，这样桌面应用就启动了。&lt;/p&gt;
&lt;h3 id=&quot;looper.loop&quot;&gt;Looper.loop()&lt;/h3&gt;
&lt;p&gt;至此，&lt;code&gt;system_server&lt;/code&gt; 进程的主要工作就算完成了，进入 Looper.loop() 状态,等待其他线程通过 Handler 发送消息到主线程并处理。&lt;/p&gt;
&lt;h2 id=&quot;systemserver-启动阶段分类&quot;&gt;SystemServer 启动阶段分类&lt;/h2&gt;
&lt;p&gt;回过头再来看看前面提到的启动阶段分类，定义在 &lt;code&gt;com.android.server.SystemService&lt;/code&gt; 类中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
 * Boot Phases
 * 
 * 启动阶段
 */
public static final int PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100; // maybe should be a dependency?

/**
 * After receiving this boot phase, services can obtain lock settings data.
 */
public static final int PHASE_LOCK_SETTINGS_READY = 480;

/**
 * After receiving this boot phase, services can safely call into core system services
 * such as the PowerManager or PackageManager.
 * 
 * 在这个阶段之后，可以安全的调用系统核心服务，如 PowerManager 和 PackageManager
 */
public static final int PHASE_SYSTEM_SERVICES_READY = 500;

/**
 * After receiving this boot phase, services can safely call into device specific services.
 * 
 * 在这个阶段之后，可以安全调用设备特定的服务
 */
public static final int PHASE_DEVICE_SPECIFIC_SERVICES_READY = 520;

/**
 * After receiving this boot phase, services can broadcast Intents.
 * 
 * 在这个阶段之后，服务可以广播
 */
public static final int PHASE_ACTIVITY_MANAGER_READY = 550;

/**
 * After receiving this boot phase, services can start/bind to third party apps.
 * Apps will be able to make Binder calls into services at this point.
 * 
 * 在这个阶段之后，服务可以启动/绑定第三方应用
 * 应用此时可以进行 Binder 调用
 */
public static final int PHASE_THIRD_PARTY_APPS_CAN_START = 600;

/**
 * After receiving this boot phase, services can allow user interaction with the device.
 * This phase occurs when boot has completed and the home application has started.
 * System services may prefer to listen to this phase rather than registering a
 * broadcast receiver for ACTION_BOOT_COMPLETED to reduce overall latency.
 * 
 * 在这个阶段之后，允许用户和设备交互。
 * 这个阶段发生在启动完成，home 应用已经开始。
 * 系统服务更倾向于监听这个阶段，而不是监听启动广播 ACTION_BOOT_COMPLETED，以降低延迟
 */
public static final int PHASE_BOOT_COMPLETED = 1000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;system_server&lt;/code&gt; 启动过程中各个阶段的位置大致如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void startBootstrapServices() {
    ...
    // 100
    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);
    ...
}

private void startOtherServices() {
    ...
    // 480
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    // 500
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);

    ...
    // 520
    mSystemServiceManager.startBootPhase(SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);

    mActivityManagerService.systemReady(() -&amp;gt; {
        mSystemServiceManager.startBootPhase(
                    SystemService.PHASE_ACTIVITY_MANAGER_READY); // 550
                    
        ...
        mSystemServiceManager.startBootPhase(
                    SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); // 600
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的 &lt;code&gt;SystemService.PHASE_BOOT_COMPLETED（1000）&lt;/code&gt; 在 AMS 的 &lt;code&gt;finishBooting()&lt;/code&gt; 方法中调用。另外注意 &lt;code&gt;480&lt;/code&gt; 和 &lt;code&gt;500&lt;/code&gt; 两个阶段是连在一起的，中间没有发生任何事情。&lt;/p&gt;
&lt;p&gt;那么，划分阶段的具体作用是什么呢？答案就在 &lt;code&gt;startBootPhase()&lt;/code&gt; 方法中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void startBootPhase(final int phase) {
    if (phase &amp;lt;= mCurrentPhase) {
        throw new IllegalArgumentException(&quot;Next phase must be larger than previous&quot;);
    }
    mCurrentPhase = phase;

    try {
        final int serviceLen = mServices.size();
        for (int i = 0; i &amp;lt; serviceLen; i++) {
            final SystemService service = mServices.get(i);
            long time = SystemClock.elapsedRealtime();
            try {
                // 回调系统服务的 onBootPhase() 方法
                service.onBootPhase(mCurrentPhase);
            } catch (Exception ex) {
                throw new RuntimeException(&quot;Failed to boot service &quot;
                        + service.getClass().getName()
                        + &quot;: onBootPhase threw an exception during phase &quot;
                        + mCurrentPhase, ex);
            }
            warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onBootPhase&quot;);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心就在于 &lt;code&gt;service.onBootPhase(mCurrentPhase);&lt;/code&gt;。所有系统服务都是继承于 &lt;code&gt;SystemService&lt;/code&gt; 的，&lt;code&gt;startBootPhase()&lt;/code&gt; 方法会回调当前阶段已经加入 &lt;code&gt;mServices&lt;/code&gt; 的所有系统服务的 &lt;code&gt;onBootPhase()&lt;/code&gt; 方法，在合适的阶段做一些合适的事情。以 AMS 为例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void onBootPhase(int phase) {
    mService.mBootPhase = phase;
    if (phase == PHASE_SYSTEM_SERVICES_READY) {
        mService.mBatteryStatsService.systemServicesReady();
        mService.mServices.systemServicesReady();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;systemserver-是如何启动服务的&quot;&gt;SystemServer 是如何启动服务的 ？&lt;/h2&gt;
&lt;p&gt;看完 SystemServer 的源码，它最重要的工作就是创建和启动各种系统服务。那么服务一般是如何创建的呢？下面以 &lt;code&gt;startBootstrapServices()&lt;/code&gt; 中创建的第一个服务 &lt;code&gt;Installer&lt;/code&gt; 为例来看一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Installer installer = mSystemServiceManager.startService(Installer.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入 &lt;code&gt;SystemServiceManager&lt;/code&gt; 的 &lt;code&gt;startService()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;T extends SystemService&amp;gt; T startService(Class&amp;lt;T&amp;gt; serviceClass) {
    try {
        // 获取服务名称
        final String name = serviceClass.getName();

        // Create the service.
        if (!SystemService.class.isAssignableFrom(serviceClass)) {
            throw new RuntimeException(&quot;Failed to create &quot; + name
                    + &quot;: service must extend &quot; + SystemService.class.getName());
        }
        final T service;
        try {
            // 获取服务类的构造器
            Constructor&amp;lt;T&amp;gt; constructor = serviceClass.getConstructor(Context.class);
            // 反射创建 service
            service = constructor.newInstance(mContext);
        } catch (InstantiationException ex) {
            throw new RuntimeException(&quot;Failed to create service &quot; + name
                    + &quot;: service could not be instantiated&quot;, ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(&quot;Failed to create service &quot; + name
                    + &quot;: service must have a public constructor with a Context argument&quot;, ex);
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(&quot;Failed to create service &quot; + name
                    + &quot;: service must have a public constructor with a Context argument&quot;, ex);
        } catch (InvocationTargetException ex) {
            throw new RuntimeException(&quot;Failed to create service &quot; + name
                    + &quot;: service constructor threw an exception&quot;, ex);
        }

        startService(service);
        return service;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建并启动一个系统服务。这个系统服务必须是 &lt;code&gt;com.android.server.SystemService&lt;/code&gt; 的子类。根据参数传入的 &lt;code&gt;Class&lt;/code&gt; 对象反射创建其实例，再调用重载方法 &lt;code&gt;startService()&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void startService(@NonNull final SystemService service) {
    // Register it.
    mServices.add(service);
    // Start it.
    long time = SystemClock.elapsedRealtime();
    try {
        // 回调系统服务的 onStart() 方法
        service.onStart();
    } catch (RuntimeException ex) {
        throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName()
            + &quot;: onStart threw an exception&quot;, ex);
    }
    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就两步。第一步，注册服务，&lt;code&gt;mServices&lt;/code&gt; 是一个 &lt;code&gt;ArrayList&amp;lt;SystemService&amp;gt;&lt;/code&gt; 对象，用来保存已经创建的系统服务。第二步，回调服务的 &lt;code&gt;onStart()&lt;/code&gt; 方法，还是以 &lt;code&gt;Installer&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void onStart() {
    if (mIsolated) {
        mInstalld = null;
    } else {
        connect();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个服务就启动完成了。这是一种比较普遍的启动方式，当然还有一些系统服务具有不一样的启动方式，这里就不一一分析了，后面有机会解析具体服务的时候再来分析。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SystemServer&lt;/code&gt; 的启动流程比较耿直，没有那么多弯弯绕，下面简单总结一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;语言、时区、地区等设置&lt;/li&gt;
&lt;li&gt;虚拟机内存设置&lt;/li&gt;
&lt;li&gt;指纹信息，Binder 调用设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Looper.prepareMainLooper()&lt;/code&gt; ，创建主线程 Looper&lt;/li&gt;
&lt;li&gt;初始化 native 服务，加载 &lt;code&gt;libandroid_servers.so&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createSystemContext()&lt;/code&gt;，初始化系统上下文&lt;/li&gt;
&lt;li&gt;创建系统服务管理 &lt;code&gt;SystemServiceManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;startBootstrapServices&lt;/code&gt;，启动系统引导服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;startCoreServices&lt;/code&gt;，启动系统核心服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;startOtherServices&lt;/code&gt;，启动其他服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Looper.loop()&lt;/code&gt;，开启消息循环&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外，在 &lt;code&gt;startOtherServices&lt;/code&gt; 的最后会调用 AMS 的 &lt;code&gt;onSystemReady()&lt;/code&gt; 方法启动桌面 Activity。&lt;/p&gt;
&lt;h2 id=&quot;预告&quot;&gt;预告&lt;/h2&gt;
&lt;p&gt;还记得 &lt;code&gt;Zygote&lt;/code&gt; 进程的 &lt;code&gt;runSelectLoop()&lt;/code&gt; 方法吗？Zygote 在创建完 &lt;code&gt;system_server&lt;/code&gt; 进程之后，就开始默默的等待客户端请求创建应用进程。下一篇，我们将从源码角度来捋一遍客户端是如何发送请求，Zygote 是如何处理请求，应用进程是如何创建的，敬请期待！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201910/800205-20191013232542531-1618509851.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 15:26:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>本文基于 Android 9.0 , 代码仓库地址 ： 'android_9.0.0_r45' 文中源码链接： 'SystemServer.java' 'SystemServiceManager.ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11669031.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第41期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/11667448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/11667448.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;.NET架构指南&quot; &quot;美妙的WebSharper：学术刊物&quot; &quot;.NET Core 3.0中Blazor Server的方案与性能&quot; &quot;Mono 6.4.0发布说明&quot; &quot;CapitolFSharp召集发言人&quot; 视频及幻灯片 &quot;函数式反应型编程中的实时流分析&quot; &quot;领域模型函数式化&quot; &quot;临近十月</description>
<pubDate>Sun, 13 Oct 2019 15:09:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '.NET架构指南' '美妙的WebSharper：学术刊物' '.NET Core 3.0中Blazor Server的方案与性能' 'Mono 6.4.0发布说明' 'CapitolFSha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/11667448.html</dc:identifier>
</item>
<item>
<title>.Net Core Serverless初体验 - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/11666872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/11666872.html</guid>
<description>&lt;p&gt;　　Serverless 是一个当今软件世界中比较新的话题。它并没有一个普遍公认的权威定义，每个人每个企业对它的解释可能都有不同，而 Serverless 正是在这种情况下不断发发展的。但是就算如此，有一些 Serverless 的特征还是被广泛认可的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端的主机和进程完全由供应商管理&lt;/li&gt;
&lt;li&gt;可以根据负载进行自动伸缩&lt;/li&gt;
&lt;li&gt;按照精确的使用情况来计费，就像水和电一样。（效用计算）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　引用掘金，原文地址：&lt;a href=&quot;https://juejin.im/post/5c68fdbfe51d4539a569f259&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5c68fdbfe51d4539a569f259&lt;/a&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013161631378-931541090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在这个发展历程中有以下几个渐进的里程碑事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过虚拟化技术将大型物理机虚拟成单个的VM资源。&lt;/li&gt;
&lt;li&gt;将虚拟化集群搬到云计算平台上，只做简单运维。&lt;/li&gt;
&lt;li&gt;把每一个VM按照运行空间最小化的原则切分成更细的Docker容器。&lt;/li&gt;
&lt;li&gt;基于Docker容器构建不用管理任何运行环境、仅需编写核心代码的Serverless架构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　引用阿里云，原文地址：&lt;a href=&quot;https://help.aliyun.com/knowledge_detail/65565.html?spm=a2c4g.11186631.2.1.4f811bbeDYGmvp&quot; target=&quot;_blank&quot;&gt;https://help.aliyun.com/knowledge_detail/65565.html?spm=a2c4g.11186631.2.1.4f811bbeDYGmvp&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;　　函数计算是事件驱动的全托管计算服务。使用函数计算，您无需采购与管理服务器等基础设施，只需编写并上传代码。函数计算为您准备好计算资源，弹性地可靠地运行任务，并提供日志查询、性能监控和报警等功能。&lt;/p&gt;
&lt;p&gt;借助函数计算，您可以快速构建任何类型的应用和服务，并且只需为任务实际消耗的资源付费。&lt;/p&gt;
&lt;p&gt;　　引用阿里云，原文地址：&lt;a href=&quot;https://help.aliyun.com/document_detail/52895.html?spm=a2c4g.11186623.6.541.23dc641aB3U3K0&quot; target=&quot;_blank&quot;&gt;https://help.aliyun.com/document_detail/52895.html?spm=a2c4g.11186623.6.541.23dc641aB3U3K0&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;　　1. 新建一个.net core控制台程序，这里命名为AliyunServerless。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013162905832-964556712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　2. 引用阿里云提供的函数计算组件Aliyun.Serverless.Core&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　Install-Package Aliyun.Serverless.Core
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013163126702-1735339238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. 按照函数计算的要求编写.Net Core的类与函数，这里用两个类与函数&lt;/p&gt;
&lt;p&gt;　　a. 打印执行日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 打印执行日志
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogHandler
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Handle(Stream input, IFcContext context)
        {
            ILogger logger &lt;/span&gt;=&lt;span&gt; context.Logger;
            logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Handle request: {context.RequestId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　b. 打印服务器IP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 打印服务器IP
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IpHandler
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Handle(Stream input, IFcContext context)
        {
            ILogger logger &lt;/span&gt;=&lt;span&gt; context.Logger;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ipHostInfo =&lt;span&gt; Dns.GetHostEntry(Dns.GetHostName());
            logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Handle request: {context.RequestId}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ipAddress &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ipHostInfo.AddressList)
            {
                logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP Address：{ipAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　 说明：&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013163600343-1609908070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　详情可参考原文地址：&lt;a href=&quot;https://help.aliyun.com/document_detail/112379.html?spm=a2c4g.11174283.6.567.206852120XSx37&quot; target=&quot;_blank&quot;&gt;https://help.aliyun.com/document_detail/112379.html?spm=a2c4g.11174283.6.567.206852120XSx37&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　4. 发布程序并打包成zip&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　dotnet publish -c Release
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013165131398-832138810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　1. &lt;a href=&quot;https://help.aliyun.com/document_detail/54301.html?spm=5176.8663048.0.0.71be3edcH42tMP#h4-u6267u884Cu65F6u95F4u8D39u7528&quot; target=&quot;_blank&quot;&gt;费用说明&lt;/a&gt;及免费额度&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013165553510-502008225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 选择函数执行的地区&lt;/p&gt;
&lt;p&gt;　　参考入口地址：&lt;a href=&quot;https://fc.console.aliyun.com/fc/overview/cn-shenzhen&quot; target=&quot;_blank&quot;&gt;https://fc.console.aliyun.com/fc/overview/cn-shenzhen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013204058170-728647408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　3. 创建服务及函数&lt;/p&gt;
&lt;p&gt;　　a. 创建函数&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013204218834-1972139468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　b. 选择“事件函数”，然后“下一步”&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013204442197-489803835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　c. 配置函数信息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013204855024-1866322782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其中：&lt;/p&gt;
&lt;p&gt;　　“所在服务”是分组，根据需要填写即可。&lt;/p&gt;
&lt;p&gt;　　“函数名称”是名称，根据需要填写即可。&lt;/p&gt;
&lt;p&gt;　　“运行环境”选择dotnetcore2.1。&lt;/p&gt;
&lt;p&gt;　　“函数入口”要按规定填写，模板是{程序集}::{命名空间}.{类名}::{函数名}，这里是：AliyunServerless::AliyunServerless.LogHandler::Handle&lt;/p&gt;
&lt;p&gt;　　“函数执行内存”，函数执行需要的内存。&lt;/p&gt;
&lt;p&gt;　　“超时时间”，函数执行不能超过设置的时间。&lt;/p&gt;

&lt;p&gt;　　d. 执行函数&lt;/p&gt;
&lt;p&gt;　　点击“执行”，可以看到执行摘要（执行时间、使用内存、执行状态等）及执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013210621138-1465760629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　e. 创建触发器&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013211828984-1448998613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里用的是“定时触发器”，支持Cron表达式，调度最高频率为1分钟，暂不支持秒级调度；除了“定时触发器”，还有以下的触发器类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013212035154-925597406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　有兴趣的朋友可以自行研究。&lt;/p&gt;
&lt;p&gt; 　　配完触发器以后，函数就会被定时触发，由于这里是打印日志，需要配置日志才能看到，本文没配置日志，就不演示触发效果了。&lt;/p&gt;


&lt;p&gt;　　按照创建函数的步骤，创建“打印服务器IP”函数，执行并进行跟踪，结果如下：&lt;/p&gt;
&lt;p&gt;　　1. 多次执行（5次不同的RequestId），服务器IP没变（都为21.0.3.3），说明分配到同一台服务器上&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013220446449-1284524763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013220658861-141399430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013220746140-1607866360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013221000691-244266637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013221049918-1558904409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 重新上传程序包，服务器IP会变，但同一个软件包服务器IP不变&lt;/p&gt;
&lt;p&gt;　　a. 第一次重新上传：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013221809263-728548070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013221907343-309628502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　b. 第二次重新上传：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013222221136-335307511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013222308072-694078892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3. 我选择的执行地区是“华南1（深圳）”，但是服务器IP是美国IP；因为无服务器信息，该结论仅供参考&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013222833777-416621043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013223049117-2110553971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013222950043-1737848741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　4. 调用统计会非实时（正常现象），大部分业务月免费额度应该足够使用&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/182190/201910/182190-20191013224247036-1495864971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;a href=&quot;https://github.com/ErikXu/AliyunServerless&quot; target=&quot;_blank&quot;&gt;https://github.com/ErikXu/AliyunServerless&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 14:46:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<og:description>什么是Serverless Serverless 是一个当今软件世界中比较新的话题。它并没有一个普遍公认的权威定义，每个人每个企业对它的解释可能都有不同，而 Serverless 正是在这种情况下不断</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Erik_Xu/p/11666872.html</dc:identifier>
</item>
<item>
<title>【线性表基础】顺序表和单链表的插入、删除等基本操作【Java版】 - Link_Chen</title>
<link>http://www.cnblogs.com/linkchen/p/11614091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linkchen/p/11614091.html</guid>
<description>&lt;h2 id=&quot;本文表述了线性表及其基本操作的代码java实现&quot;&gt;本文表述了线性表及其基本操作的代码【Java实现】&lt;/h2&gt;
&lt;p&gt;参考书籍 ：《数据结构 ——Java语言描述》/刘小晶 ，杜选主编&lt;/p&gt;
&lt;p&gt;线性表需要的基本功能有：动态地增长或收缩；对线性表的任何数据元素进行访问和查找；在线性表中的任何位置进行数据元素的插入和删除操作；求线性表中指定数据元素的前驱和后继等等。&lt;/p&gt;
&lt;p&gt;首先描述线性表的抽象类型，我们使用Java接口interface：&lt;/p&gt;
&lt;p&gt;Ilist.java:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package liner_list;

public interface IList
{
    public void clear();
    public boolean isEmpty();
    public int length();
    public Object get(int i) throws Exception;
    public void insertAt(int i,Object x) throws Exception;
    public void remove(int i) throws Exception;
    public int indexOf(Object x);
    public void display();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次描述顺序表，其特点有：在线性表中的逻辑上相邻的数据元素，在物理存储位置上也是相邻的；存储密度高，但需要预先分配”足够应用“的存储空间，这可能将会造成存储空间的浪费；便于随机存储；不便于插入和删除，因为在顺序表中进行插入和删除操作会引起大量数据元素的移位。我们用SqList类描述顺序表：&lt;/p&gt;
&lt;p&gt;SqList.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package liner_list;

// 规定方法中的参数i都为顺序表元素的索引（下标）
public class SqList implements IList
{
    public Object[] listItem; // 顺序表存储空间
    public int curLen; // 线性表的当前长度

    public SqList(int maxSize)
    {
        listItem = new Object[maxSize]; // 为顺序表分配maxSize个存储单元
        curLen = 0; // 置当前长度为0
    }

    public void clear()
    {
        curLen = 0; // 置当前长度为0，即规定为清空顺序表，但是内存中还有数据存在
    }

    public boolean isEmpty()
    {
        return curLen == 0;
    }

    public int length()
    {
        return curLen; // 返回当前长度
    }

    public Object get(int i) throws Exception // 得到下标为i的元素，同时判断异常
    {
        if (i &amp;gt;= curLen || i &amp;lt; 0) // 索引越界，0&amp;lt;=index&amp;lt;=curLen
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        return listItem[i];
    }

    public void insertAt(int i, Object x) throws Exception // 在下表为i的位置插入元素x，同时判断异常
    {
        if (curLen == listItem.length) // 判断表满
        {
            throw new Exception(&quot;SqList is full!&quot;);
        }
        if (i &amp;gt; curLen || i &amp;lt; 0) // 索引越界，可以在curLen的位置进行插入
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        for (int j = curLen; j &amp;gt; i; j--) // j从curLen的位置开始，即当前表最后一个元素的后一个位置，从而使得i位置及以后位置上的元素向后移一位
        {
            listItem[j] = listItem[j - 1];
        }
        listItem[i] = x; // 将x元素插入i位置
        curLen++; // 插入后表长加一
    }

    public void remove(int i) throws Exception
    {
        if (i &amp;gt;= curLen || i &amp;lt; 0) // i小于0或者大于等于表长时抛出异常
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        for (int j = i; j &amp;lt; curLen - 1; j++) // 从i位置开始向后，不能从最后开始，否则最后一个元素将覆盖所有元素，若想从后向前，必须将被覆盖的元素保留给下一个元素
        {
            listItem[j] = listItem[j + 1];
        }
        curLen--; // 删除完后curLen减一
    }

    public int indexOf(Object x) // 规定返回-1表示未找到元素x
    {
        for (int i = 0; i &amp;lt; curLen; i++)
        {
            if (listItem[i].equals(x))
            {
                return i;
            }
        }
        return -1;
//      书本代码，效果相同
//      int j = 0;
//      while (j &amp;lt; curLen &amp;amp;&amp;amp; !listItem[j].equals(x))
//      {
//          j++;
//      }
//      if (j &amp;lt; curLen)
//      {
//          return j;
//      } else
//      {
//          return -1;
//      }
    }

    public void display() // 输出顺序表中全部元素
    {
        System.out.println(&quot;****** SqList ******&quot;);
        for (int i = 0; i &amp;lt; curLen; i++)
        {
            System.out.print(listItem[i] + &quot; &quot;);
        }
        System.out.println();
        System.out.println(&quot;********************&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着测试我们的顺序表，使用SqListTest类来做测试：&lt;/p&gt;
&lt;p&gt;SqListTest.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package liner_list;

import java.util.Scanner;

public class SqListTest
{
    public static void main(String[] args) throws Exception
    {
        SqList sq1 = new SqList(10);
        sq1.insertAt(0, &quot;a0&quot;);
        sq1.insertAt(1, &quot;a1&quot;);
        sq1.insertAt(2, &quot;a2&quot;);
        sq1.insertAt(3, &quot;a3&quot;);
        sq1.insertAt(4, &quot;a4&quot;);
        sq1.insertAt(5, &quot;a5&quot;);
        int index = sq1.indexOf(&quot;a2&quot;);
        if (index != -1)
        {
            System.out.println(&quot;a2's index is &quot; + index + &quot;!&quot;);
        } else
        {
            System.out.println(&quot;a5 is not in this SqList!&quot;);
        }
        sq1.display();
        sq1.remove(2);
        System.out.println(&quot;After remove:&quot;);
        sq1.display();
        SqList sq2 = new SqList(10);
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;Please input element:&quot;);
        for (int i = 0; i &amp;lt; 8; i++)
        {
            sq2.insertAt(i, sc.next());
        }
        sc.close();
        sq2.display();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行我们的测试类，得到以下测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560524/201910/1560524-20191013224050542-1130018487.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后描述单链表，注意：我们推荐使用带头结点的单链表。这里总结以下关于头指针和头结点的问题：首先要清楚，head就是头指针，毋庸置疑；如果有头结点的话，head也头结点，这里头指针就是头结点，一般说成头指针指向头结点，而head.next是下标为0的元素，规定 head是下标为-1的元素；如果没有头结点的话，head本是就是下标为0的元素，这里没有头结点，但是head还是头指针。下面我们使用LinkList类来描述带头结点的单链表：&lt;/p&gt;
&lt;p&gt;LinkList.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package liner_list;

import java.util.Scanner;

//关于头结点与头指针的问题
//首先要清楚，head就是头指针，毋庸置疑
//如果有头结点的话，head也头结点，这里头指针就是头结点，一般说成头指针指向头结点，而head.next是下标为0的元素，规定 head是下标为-1的元素
//如果没有头结点的话，head本是就是下标为0的元素，这里没有头结点，但是head还是头指针
//建议写带头结点的单链表，此类就是一个典例
public class LinkList implements IList
{
    public Node head;

    public LinkList() // 无参构造方法，只构建头指针
    {
        head = new Node();
    }

    public LinkList(int len, boolean Order) throws Exception // 带有两个参数的构造方法，分别为表长和插入的方式，规定true表示尾插法，flase表示头插法
    {
        this();
        if (Order)
        {
            createAtEnd(len);
        } else
        {
            createAtHead(len);
        }
    }

    public void createAtHead(int n) throws Exception // 头插法
    {
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;Please input element:&quot;);
        for (int i = 0; i &amp;lt; n; i++)
        {
            insertAt(0, sc.next());
        }
//      sc.close();     // 不要关闭输入流
//      display();
    }

    public void createAtEnd(int n) throws Exception // 尾插法
    {
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;Please input element:&quot;);
        for (int i = 0; i &amp;lt; n; i++)
        {
            insertAt(length(), sc.next());
        }
//      sc.close();     // 不要关闭输入流
//      display();
    }

    @Override
    public void clear() // 置空链表
    {
        head.data = null;
        head.next = null;
    }

    @Override
    public boolean isEmpty() // 链表判空
    {
        return head.next == null;
    }

    @Override
    public int length() // 返回链表长度
    {
        Node p = head.next; // p指向首结点
        int length = 0;
        while (p != null)
        {
            p = p.next;
            length++;
        }
        return length;
    }

    @Override
    public Object get(int i) throws Exception
    {
        Node p = head.next;
        int j = 0;
        while (p != null &amp;amp;&amp;amp; j &amp;lt; i) // 从首结点开始向后查找，直到p指向第i个结点或者p为空
        {
            p = p.next; // 指针后移
            j++; // 计数加1
        }
        if (i &amp;lt; 0 || p == null) // i小于0或者大于表长减1时抛出异常
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        return p.data;
    }

    @Override
    public int indexOf(Object x) // 规定-1表示不在LinkList当中
    {
        Node p = head.next;
        int index = 0;
        while (p != null &amp;amp;&amp;amp; !p.data.equals(x))
        {
            p = p.next;
            index++;
        }
        if (p != null)
        {
            return index;
        } else
        {
            return -1;
        }
    }

    @Override
    public void insertAt(int i, Object x) throws Exception
    {
        Node p = head; // 插入时从头结点开始，因为可以插入在下标0的位置，也可以插入在下标为表长位置
        int j = -1;
        while (p != null &amp;amp;&amp;amp; j &amp;lt; i - 1) // 找出下标为i-1的结点，即i结点的前驱
        {
            p = p.next;
            j++;
        }
        if (i &amp;lt; 0 || p == null) // i小于0或者i大于表长时抛出异常
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        Node s = new Node(x);
        s.next = p.next;
        p.next = s;
    }

    @Override
    public void remove(int i) throws Exception
    {
        Node p = head;
        int j = -1;
        while (p != null &amp;amp;&amp;amp; j &amp;lt; i - 1) // 找到下标为i-1的结点，即i结点的前驱
        {
            p = p.next;
            j++;
        }
        if (i &amp;lt; 0 || p.next == null) // 抛出条件为i小于0或者i大于表长-1，所以此处为p.next==null
        {
            throw new Exception(&quot;Argument 'i' is out of range!&quot;);
        }
        p.next = p.next.next;
    }

    @Override
    public void display()
    {
        Node p = head.next;
        System.out.println(&quot;****** LinkList ******&quot;);
        while (p != null)
        {
            System.out.print(p.data.toString() + &quot; &quot;);
            p = p.next;
        }
        System.out.println();
        System.out.println(&quot;*********************&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后测试我们的单链表，使用LinkListTest类来做测试：&lt;/p&gt;
&lt;p&gt;LinkListTest.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package liner_list;

public class LinkListTest
{
    public static void main(String[] args) throws Exception
    {
        LinkList linkList = new LinkList(10, true);
        linkList.remove(0);
        linkList.remove(1);
        linkList.remove(linkList.length() - 1);
        System.out.println(&quot;After remove:&quot;);
        linkList.display();
        linkList.insertAt(linkList.length(), &quot;a9&quot;);
        System.out.println(&quot;After insert:&quot;);
        linkList.display();
        int index = linkList.indexOf(&quot;a2&quot;);
        if (index != -1)
        {
            System.out.println(&quot;a2's index is &quot; + index + &quot;!&quot;);
        } else
        {
            System.out.println(&quot;a2 is not in this LinkList!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行我们的测试类，得到以下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560524/201910/1560524-20191013224114742-358234718.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上便是线性表中顺序表和单链表最基础的代码描述，算法思想本文中没有写到，大家可以去看看前面说的那本参考书籍。此系列后面会陆续介绍更多有关数据结构的内容，也会更新一些关于数据结构的算法题目例子，谢谢大家支持！&lt;/p&gt;
</description>
<pubDate>Sun, 13 Oct 2019 14:42:00 +0000</pubDate>
<dc:creator>Link_Chen</dc:creator>
<og:description>本文表述了线性表及其基本操作的代码【Java实现】 参考书籍 ：《数据结构 ——Java语言描述》/刘小晶 ，杜选主编 线性表需要的基本功能有：动态地增长或收缩；对线性表的任何数据元素进行访问和查找；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linkchen/p/11614091.html</dc:identifier>
</item>
</channel>
</rss>