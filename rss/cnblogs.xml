<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>我为什么放弃MySQL？最终选择了MongoDB - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10146895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10146895.html</guid>
<description>&lt;p&gt;最近有个项目的功能模块，为了处理方便，需要操作集合类型的数据以及其他原因。考虑再三最终决定放弃使用MySQL，而选择MongoDB。&lt;/p&gt;
&lt;p&gt;两个数据库，大家应该都不陌生。他们最大的区别就是MySQL为关系型数据库，而MongoDB为非关系型数据库。常见的关系型数据库有：MySQL、Oracle、DB2、SQL Server、Postgre SQL等，非关系型数据库有MongoDB、Redis、Memcached、HBse等等。&lt;/p&gt;
&lt;h2 id=&quot;h1&quot;&gt;1、关系型数据库？ 非关系型数据库？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关系型数据库&lt;/strong&gt;可以理解为依赖一个模型来创建的数据库，比如我们使用的MySQL中的表是由横列和纵列组成的一个二维表格。关系型数据库可以通过关系模型使多个表的数据关联起来，比如我们平时说的 一对一、一对多、多对一。由于是建立在数据模型的基础上，所以我们可以通过SQL语句很方便的在多个表之间做复杂的查询操作。关系型数据库相对安全，因为直接存储在硬盘中所以突然的宕机、停电等意外不会导致数据丢失。MySQL的存储方式是由自身的引擎决定的,常用的引擎有Innodb和MyISAM。他们主要的区别就是MyISAM 不支持事务，强调的是性能，执行速度比Innodb要快，Innodb提供支持事务等高级数据库功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非关系型数据库&lt;/strong&gt;即我们常说的NoSQL数据库，部署起来都比较简单，没有关系型数据库那么复杂。Mongo的存储方式为虚拟内存+持久化存储，Mongo将数据写入内存中，再由虚拟内存管理器将其持久化到硬盘中，因此写操作会比关系型数据库快很多。NOSQL的存储格式是key-value形式，可以像关系型数据库那样存储基础数据类型的数据，也可以存储集合、对象等等。NoSQL虽然性能比较高，但是并不支持事物，也不能进行联表查询，一般用于较大规模数据的存储。&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;2、他们的优点、缺点有哪些&lt;/h2&gt;
&lt;p&gt;关系型数据库发展了很长一段时间，拥有非常成熟的体系。所占份额也在逐渐增加。而且支持事物的操作，保证数据的一致性，可以通过SQL语句完成复杂的操作。但是使用过程中当数据量到达一定程度时，关系型数据库的效率会有明显的下降。一个复杂的查询操作，一系列的组合索引都会消耗非常多的内存空间，此时我们需要对数据库进行读写分离操作，或者将数据库结构进行拆分(水平拆分、垂直拆分)将请求压力分担在不同的库中。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;垂直拆分是指将一张表拆分成多个表，表之间通过主键进行关联。&lt;br/&gt;水平拆分是按照某种规则拆分成多个表，比如通过用户角色进行拆分&lt;br/&gt;读写分离：所谓读写分离就是讲读操作(查询数据)和写操作(插入&amp;amp;更新)指向不同的数据库节点，他们中间通过某种机制实现数据的同步，如binlog。实际的应用中大部分压力还是来自读操作，所以主要是一主多从的架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非关系型数据库发展的这几年，深受人们的喜爱。免费开源、成本低、部署简单、非结构化存储等等明显的优势。而且它对海量数据处理能力非常强，内存级数据库，查询速度也非常快。存储的数据格式比较丰富，易于扩展，虽然不能使用sql进行复杂的查询，但是MongoDB支持JavaScript，所以可以通过js脚本进行复杂的数据库管理操作。关于NoSQL的缺点个人感觉目前就是不支持事物了吧，其他方面那都不是事儿。&lt;/p&gt;
&lt;h2 id=&quot;h3mongo&quot;&gt;3、什么时候用mongo&lt;/h2&gt;
&lt;p&gt;Mongo是用c++编写的，支持多种语言如：Java、Python、Ruby、PHP、C++、C# 等，有时候针对不同的业务需求，选择Mongo能够避免浪费很多不必要的资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统运行过程中产生的日志信息，一般种类较多、范围较大、内容也比较杂乱。通过MongoDB可以将这些杂乱的日志进行收集管理。不仅方便了管理，查找或者导出也会变得非常容易&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地理位置存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB支持地理位置、二维空间索引，可以存储经纬度，因此可以很快的计算出两点之间的距离，等位置信息。如查询附近的人、或者订餐系统、配送系统等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据规模增长很快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到过关系型数据库数据量过大时，需要进行分库分表，这样真正操作起来可能会比较麻烦。如果选择mongo进行分库分表操作时，就会变得很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保证高可用的环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mongo本身就拥有高可用及分区的解决方案，设置主从服务器非常方便，除此之外Mongo还可以快速并且安全的实现故障节点的转移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GridFS是MongoDB规范，用于存储和检索图片、音频、视频等大文件。GridFS虽然是文件存储的一种方式，可以存储超过16M的文件。但是它本身又是存储在MongoDB集合中的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如游戏开发中我们可以通过MongoDB存储用户信息、装备、积分等，除此之外物流系统、社交系统、甚至物联网系统，Mongo都能提供完美的数据存储服务。&lt;/p&gt;
&lt;h2 id=&quot;h4mysqlmongodb&quot;&gt;4.MySQL、MongoDB简单的性能测试&lt;/h2&gt;
&lt;p&gt;关于两个数据的性能，最有力的的说话还是通过实践来进行测试，网上看到一组测试数据，分享给大家。&lt;/p&gt;
&lt;p&gt;测试环境：Windows 10、内存8G、CPU i5 3.30GHZ。均无索引&lt;/p&gt;
&lt;p&gt;测试语言：Python&lt;/p&gt;
&lt;p&gt;链接工具：pymysql、pymongo&lt;/p&gt;
&lt;p&gt;MySQL &amp;amp;&amp;amp; Mongo 测试数据统计&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;提交次数&lt;/th&gt;
&lt;th&gt;单次提交个数&lt;/th&gt;
&lt;th&gt;MySQL运行时间（s）&lt;/th&gt;
&lt;th&gt;Mongo运行时间（s）&lt;/th&gt;
&lt;th&gt;数据量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;3912&lt;/td&gt;
&lt;td&gt;1622.02&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;1.61&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;5.77&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;2.35&lt;/td&gt;
&lt;td&gt;1.56&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;7.42&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;298.07&lt;/td&gt;
&lt;td&gt;5.29&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;496.18&lt;/td&gt;
&lt;td&gt;5.29&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;欢迎关注我的个人公众号：【程序员共成长】&lt;/p&gt;
&lt;h5&gt;一个专门面向程序员群体的圈子，专注分享日常学习总结、业内资讯、优质学习视频资源， 这里不光有技术、还有诗和远方…给新加入的小伙伴准备了见面礼，包括但不限于Java、Python、Linux、数据库、大数据、架构以及各方向电子书。公众号内回复[礼包]即可领取。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201812/1457234-20181219230641519-1517531011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 15:07:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>最近有个项目的功能模块，为了处理方便，需要操作集合类型的数据以及其他原因。考虑再三最终决定放弃使用MySQL，而选择MongoDB。 两个数据库，大家应该都不陌生。他们最大的区别就是MySQL为关系型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10146895.html</dc:identifier>
</item>
<item>
<title>【Netty】(7）---搭建websocket服务器 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10145083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10145083.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;:本篇博客是基于学习某网有关视频教学。&lt;br/&gt;&lt;code&gt;目的&lt;/code&gt;:创建一个websocket服务器,获取客户端传来的数据,同时向客户端发送数据&lt;/p&gt;
&lt;h2 id=&quot;一服务端&quot;&gt;&lt;span&gt;一、服务端&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;main主类&quot;&gt;&lt;span&gt;1、Main主类&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WSServer {
    public static void main(String[] args) throws Exception {

        // 定义一对线程组
        // 主线程组, 用于接受客户端的连接，
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        // 从线程组, 负责IO交互工作
        EventLoopGroup subGroup = new NioEventLoopGroup();
        try {
            //netty服务器的创建, 辅助工具类，用于服务器通道的一系列配置
            ServerBootstrap server = new ServerBootstrap();
            //绑定两个线程组
            server.group(mainGroup, subGroup)
                    //指定NIO的模式
                    .channel(NioServerSocketChannel.class)
                    //子处理器，用于处理workerGroup
                    .childHandler(new WSServerInitialzer());

            // 启动server，并且设置8088为启动的端口号，同时启动方式为同步
            ChannelFuture future = server.bind(8088).sync();
            // 监听关闭的channel，设置位同步方式
            future.channel().closeFuture().sync();
        } finally {
            //退出线程组
            mainGroup.shutdownGracefully();
            subGroup.shutdownGracefully();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;wsserverinitialzer类子处理器&quot;&gt;&lt;span&gt;2、WSServerInitialzer类(子处理器)&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WSServerInitialzer extends ChannelInitializer&amp;lt;SocketChannel&amp;gt; {

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();

        // websocket 基于http协议，所以要有http编解码器 服务端用HttpServerCodec
        pipeline.addLast(new HttpServerCodec());
        // 对写大数据流的支持
        pipeline.addLast(new ChunkedWriteHandler());

      /**
         * 我们通常接收到的是一个http片段，如果要想完整接受一次请求的所有数据，我们需要绑定HttpObjectAggregator，然后我们
         * 就可以收到一个FullHttpRequest-是一个完整的请求信息。
         *对httpMessage进行聚合，聚合成FullHttpRequest或FullHttpResponse
         * 几乎在netty中的编程，都会使用到此hanler
         */
        pipeline.addLast(new HttpObjectAggregator(1024*64));

        // ====================== 以上是用于支持http协议 , 以下是支持httpWebsocket   ======================

        /**
         * websocket 服务器处理的协议，用于指定给客户端连接访问的路由 : /ws
         * 本handler会帮你处理一些繁重的复杂的事
         * 会帮你处理握手动作： handshaking（close, ping, pong） ping + pong = 心跳
         * 对于websocket来讲，都是以frames进行传输的，不同的数据类型对应的frames也不同
         */
        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/ws&quot;));

        // 自定义的handler
        pipeline.addLast(new ChatHandler());
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;chathandler助手类&quot;&gt;&lt;span&gt;3、ChatHandler(助手类)&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @Description: 处理消息的handler
 * TextWebSocketFrame： 在netty中，是用于为websocket专门处理文本的对象，frame是消息的载体
 *  这里已经指定了类型 如果这里是Object 那么下面还需判断是不是TextWebSocketFrame类型
 */
public class ChatHandler extends SimpleChannelInboundHandler&amp;lt;TextWebSocketFrame&amp;gt; {

    // 用于记录和管理所有客户端的channle
    private static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg)
            throws Exception {
        // 获取客户端传输过来的消息
        String content = msg.text();
        System.out.println(&quot;接受到的数据：&quot; + content);

//      for (Channel channel: clients) {
//          channel.writeAndFlush(
//              new TextWebSocketFrame(
//                      &quot;[服务器在]&quot; + LocalDateTime.now()
//                      + &quot;接受到消息, 消息为：&quot; + content));
//      }
        // 下面这个方法，和上面的for循环，一致   向客户端发送数据
        clients.writeAndFlush(new TextWebSocketFrame(&quot;我是服务器,我收到你的消息为:&quot; + content));

    }

    /**
     * 当客户端连接服务端之后（打开连接）
     * 获取客户端的channle，并且放到ChannelGroup中去进行管理
     */
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        clients.add(ctx.channel());
    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        // 当触发handlerRemoved，ChannelGroup会自动移除对应客户端的channel,所以下面的remove不用我们再手写
//      clients.remove(ctx.channel());
        System.out.println(&quot;客户端断开，channle对应的长id为：&quot; + ctx.channel().id().asLongText());
        System.out.println(&quot;客户端断开，channle对应的短id为：&quot; + ctx.channel().id().asShortText());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里服务端已经写好了,和之前搭建的服务器大致没什么区别，主要区别在于ChannelPipeline添加了不同的Handel,助手类对websocket做了些处理工作。&lt;/p&gt;

&lt;h2 id=&quot;二客户端&quot;&gt;&lt;span&gt;二、客户端&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;客户端这边是采用Hbuilderx工具创建的前端项目，代码如下&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        
        &amp;lt;div&amp;gt;发送消息:&amp;lt;/div&amp;gt;
        &amp;lt;input type=&quot;text&quot; id=&quot;msgContent&quot;/&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;点我发送&quot; onclick=&quot;CHAT.chat()&quot;/&amp;gt;
        
        &amp;lt;div&amp;gt;接受消息：&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;receiveMsg&quot; style=&quot;background-color: gainsboro;&quot;&amp;gt;&amp;lt;/div&amp;gt;
        
        &amp;lt;script type=&quot;application/javascript&quot;&amp;gt;
            
            window.CHAT = {
                socket: null,
                init: function() {
                    &amp;lt;!--判断浏览器是否支持 websocket--&amp;gt;
                    if (window.WebSocket) {
                        &amp;lt;!--连接服务器websocket IP+端口号 ／ws是服务器WebSocketServerProtocolHandler添加的--&amp;gt;
                        CHAT.socket = new WebSocket(&quot;ws://127.0.0.1:8088/ws&quot;);
                        CHAT.socket.onopen = function() {
                            console.log(&quot;连接建立成功...&quot;);
                        },
                        CHAT.socket.onclose = function() {
                            console.log(&quot;连接关闭...&quot;);
                        },
                        CHAT.socket.onerror = function() {
                            console.log(&quot;发生错误...&quot;);
                        },
                        CHAT.socket.onmessage = function(e) {
                            console.log(&quot;接受到消息：&quot; + e.data);
                            var receiveMsg = document.getElementById(&quot;receiveMsg&quot;);
                            var html = receiveMsg.innerHTML;
                            receiveMsg.innerHTML = html + &quot;&amp;lt;br/&amp;gt;&quot; + e.data;
                        }
                    } else {
                        alert(&quot;浏览器不支持websocket协议...&quot;);
                    }
                },
                &amp;lt;!--onclick事件触发--&amp;gt;
                chat: function() {
                    
                    &amp;lt;!--获取消息,发送消息--&amp;gt;
                    var msg = document.getElementById(&quot;msgContent&quot;);
                    CHAT.socket.send(msg.value);
                }
            };
            
            &amp;lt;!--初始化方法--&amp;gt;
            CHAT.init();
            
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试&quot;&gt;&lt;span&gt;三、测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181219185500596-1330585977.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过测试可以总结&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、页面初始化的时候就已经成功和服务端websocket建立连接成功。
2、服务端收到客户端数据,并向客户端发送数据。
3、当关闭页面的时候,既相当于关闭了该websocket连接,服务端会自动移除。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 19 Dec 2018 14:57:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【Netty】(7） 搭建websocket服务器 :本篇博客是基于学习某网有关视频教学。 :创建一个websocket服务器,获取客户端传来的数据,同时向客户端发送数据 一、服务端 1、Main主类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10145083.html</dc:identifier>
</item>
<item>
<title>.Net core2.0+Mysql5.7部署到CentOS7.5完整实践经验 - jomz</title>
<link>http://www.cnblogs.com/jomzhang/p/10139798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jomzhang/p/10139798.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　　　本文为本人最近学习将.Net Core部署到Linux的一些经验总结，也提供点也和我一样对Linux接触不多的.Net Core开发者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一.部署用到的环境和工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;1.Linux采用最新的CentOS7.5版本，开发使用VS2017搭配的.Net Core 为2.0的SDK版本号2.1.202(可到微软官方下载：https://dotnet.microsoft.com/download/dotnet-core/2.0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;2.数据库为Mysql 5.7版本，同CentOS系统一样部署在同一个腾讯云服务器上（配置为1C2G1M）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.Linux的SSH2客户端使用XShell6，文件传输使用WinScp,可以自行下载，我这打包一份网上收集的（https://pan.baidu.com/s/1_tKLCcRQQYjDIpZ49fUEiQ 提取码: v9uu ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.在CentOS上用Git代码管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.反向代理工具使用jexus&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.CentOS发布环境搭建&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218203043348-1271249650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1.从0开始，重装了云服系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218203457298-66938738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2.使用XShell连接到云服。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.安装Mysql5.7&lt;/strong&gt;,本文参考的《Centos7安装mysql5.7》：https://www.jianshu.com/p/c76dc730a800&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第1步：下载mysql的rmp package&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218204350741-1505873232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第2步：安装repo&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# rpm -ivh mysql57-community-release-el7-&lt;span&gt;9&lt;/span&gt;.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218204625991-2014448474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第3步：安装mysql-server&lt;/strong&gt;,安装过程中出现2次选择一律按y回车，大概3到5分钟就安装完成了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# yum install mysql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218205340800-1785086101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218205245802-1547512134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;第4步：配置mysql密码和默认字符集&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# vim /etc/my.cnf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候要是不会用vi的人就有点懵了（我也是），我在这大概讲下操作，vi打开了my.cnf，无法使用鼠标，编辑前按i才能编辑，编辑完成后按Esc退出编辑状态，最后按:x回车保存退出。如果输错请不要用Ctrl+z来撤销用Ctrl+s保存，因为没用，文件写的混乱了可以用:q!不保存退出,注意有个英文冒号:不能漏了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;默认字符集一定要修改了，不然EF生成的数据库字符集编码不支持中文导致发布到Linux上程序出错&lt;/p&gt;
&lt;p&gt;　　在[mysqld]最下面添加字符集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
character-&lt;span&gt;set&lt;/span&gt;-server =&lt;span&gt; utf8mb4
collation&lt;/span&gt;-server = utf8mb4_general_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再添加权限过滤代码（后面改完密码要删除）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
character-&lt;span&gt;set&lt;/span&gt;-server =&lt;span&gt; utf8mb4
collation&lt;/span&gt;-server = utf8mb4_general_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后在下面添加[client]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[client]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt; = utf8mb4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后编辑样子为：&lt;strong&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218210350712-166154194.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　然后启动mysql:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218211810216-1219498639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　匿名登录mysql&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218211921762-16202477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更改mysql密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; update mysql.user &lt;span&gt;set&lt;/span&gt; authentication_string=PASSWORD(&lt;span&gt;'mima&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; and hosst=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更新权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
flush privileges;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212138142-1393466017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在输入quit退出mysql,打开之前编辑的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim /etc/my.cnf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把之前标记的跳过权限的代码删除后保存退出&lt;/p&gt;
&lt;p&gt; 　　重启myql（重启：service mysqld restart；开启：service mysql start;关闭 service mysqld stop）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212625287-1027455560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　使用mysql -u root -p登录mysql&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212743788-1297564267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再一次修改密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ALTER USER &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你的密码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218213124821-884807831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后配置远程连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mima&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; WITH GRANT OPTION;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218213647388-719576923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这样myslq环境就算是配置好了&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;4.安装DotCore 2.0 SDK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里安装DotCore SDK和安装jexus都是完全参考《.Net Core部署到CentOS》地址：https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;p&gt;　　4.1.配置dotnet产品Feed&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sudo rpm --import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&lt;/span&gt;
sudo sh -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo -e &quot;[packages-microsoft-com-prod]&lt;/span&gt;
name=packages-microsoft-com-&lt;span&gt;prod 
baseurl&lt;/span&gt;= https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod&lt;/span&gt;
enabled=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgkey&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&quot; &amp;gt; /etc/yum.repos.d/dotnetdev.repo'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.2.安装SDK，注意版本！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo yum update
sudo yum &lt;/span&gt;-&lt;span&gt;y install libunwind libicu
sudo yum install dotnet&lt;/span&gt;-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;202&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也是1路按y,这回等待时间有点长，15分钟差不多搞定。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220130985-1497226667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5.安装jexus&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jexus.org/release/x64/install.sh|sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220316607-1336063470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6&lt;strong&gt;.安装git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　参考yolo_bean的《linux（centos)下安装git并上传代码》：https://www.cnblogs.com/yolo-bean/p/7808767.html，本人只安装没做其他配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# yum  install  git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220826481-632723189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7&lt;strong&gt;.将代码库中代码用git下载到CentOS并发布&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone 你项目的SSH地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221243629-353996057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里会要求输入用户名和密码，输入密码时候是看不到的输完直接回车就完事。&lt;/p&gt;
&lt;p&gt;　　至此，我们看到root文件夹下有了一个项目，一个mysql的安装文件&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221408144-1267324434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在cd到启动的web项目中去执行dotnet build&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221743832-1919955131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后发布项目到/var/www/自定义文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv Ator.Site]# dotnet publish -o /var/www/Ae
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218222057982-1130218714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样项目就发布完成了，最后只要使用jexus代理&lt;/p&gt;
&lt;p&gt; 　　8&lt;strong&gt;.使用jexus代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　   参考自https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1、切换到Jexus配置文件目录&lt;/span&gt;
cd /usr/jexus/&lt;span&gt;siteconf
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2、复制默认的配置文件为Ae&lt;/span&gt;
cp &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Ae
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 3、编辑配置文件，这里端口为8080，若用80请把defualt中默认的80改为其他端口,Ator.Site.dll为Web项目生成的dll为主入口文件&lt;/span&gt;
&lt;span&gt;vi Ae

######################
# Web Site: Ae
########################################
port&lt;/span&gt;=&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
root&lt;/span&gt;=/ /&lt;span&gt;var&lt;/span&gt;/www/&lt;span&gt;Ae
hosts&lt;/span&gt;= *    #OR your.com,*&lt;span&gt;.your.com

AppHost&lt;/span&gt;={CmdLine=dotnet /&lt;span&gt;var&lt;/span&gt;/www/Ae/Ator.Site.dll;AppRoot=/&lt;span&gt;var&lt;/span&gt;/www/Ae/;Port=&lt;span&gt;5000&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218223056489-662778966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后重启下jexus&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果已启动 Jexus：&lt;/span&gt;
sh /usr/jexus/&lt;span&gt;jws restart

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果未启动 Jexus：&lt;/span&gt;
sh /usr/jexus/jws start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　然后就可以正常根据Ip地址和端口进行访问了。&lt;/p&gt;
&lt;p&gt;　完结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　参考博文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;p&gt;　　https://www.jianshu.com/p/c76dc730a800&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/yolo-bean/p/7808767.html&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 14:55:00 +0000</pubDate>
<dc:creator>jomz</dc:creator>
<og:description>本文为本人最近学习将.Net Core部署到Linux的一些经验总结，也提供点也和我一样对Linux接触不多的.Net Core开发者。 一.部署用到的环境和工具 1.Linux采用最新的CentOS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jomzhang/p/10139798.html</dc:identifier>
</item>
<item>
<title>asp.net core mcroservices 机构之 分布式日志（一） - 一夜寒江</title>
<link>http://www.cnblogs.com/ck0074451665/p/10146838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10146838.html</guid>
<description>&lt;p&gt;&lt;span&gt;  &lt;span&gt;    一 简介                                                                                                                                                        &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;             &lt;span&gt;无论是微服务还是其他任何分布式系统，都需要一个统一处理日志的系统，这个系统必须有收集，索引，分析查询的功能。asp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.net core自己的日志是同步方式的，正如文档所言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image%5B3%5D.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image_thumb%5B1%5D.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;184&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以必须自己提供一个日志提供程序，那正如文档所言，还有什么比kafka更合适的呢。从kafka往后那就是elasticsearch kibana，那是自然而然的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    二 asp.net core 日志详解                                                                                                                             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         概念：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                   类别：类别是以使用的用途进行分类的，比如var log= LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;();这一句，以StartUp类的全名作为一个分类，还有一些内置的system，Microsoft，主要是为了更细粒度控制日志。如果StartUp类出现了问题，打印日志就可以控制在StartUp这一类别下，为这个类别设置debug，仅仅打印这个类别这个级别的日志信息，使用filter功能可以很容易控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                  日志级别：Trace，debug，info，warning，error等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                                                              &lt;span&gt;   &lt;span&gt;Trace：这个级别开发一般不会用，是组件或者平台提供商为调试错误用的【windows专用】，因为可以看到组件内部运行状况，而且会有很大安全隐患，所以不建议在生产开启这个功能，比如mysql lib库的trace可以打印出数据库连接字符串的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                  日志提供程序：日志提供程序可以看作日志信息的的io重定向。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                             控制台：这个不用说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                             调试：就是debug，在 Linux 中，此提供程序将日志写入 /var/log/message。在windows中就是经典的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.debug&quot;&gt;System.Diagnostics.Debug&lt;/a&gt;功能，这是.net提供的调试功能，非常详细，在开发中非常有用。下面是vs中最常见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image%5B8%5D.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image_thumb%5B4%5D.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;362&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;                                                                                     &lt;span&gt;EventSource 提供程序在windows下可用，在linux下没可用但是没有相关事件，所以和没用一样。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;                                                                                    &lt;span&gt;Windows EventLog 提供程序和TraceSource 提供程序都是在windows环境下是使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     三 开发                                                                                                                                               &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;添加各种事件提供程序：因为是windows下所以EventSource事件是可以用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 var host = new WebHostBuilder().ConfigureAppConfiguration((webHostBuild,configBuild) =&amp;gt;
            {
                var env = webHostBuild.HostingEnvironment;

                configBuild.AddJsonFile(&quot;appsettings.json&quot;)
                .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;
                ,optional:true,reloadOnChange:true)
                .SetBasePath(Directory.GetCurrentDirectory());
            }).ConfigureLogging((hostingContext, logging) =&amp;gt; {
                logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;))
                .AddConsole()
                .AddDebug()
                .AddEventSourceLogger();
            }).UseKestrel()
            .UseStartup&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;();
             host.Start();
            Console.ReadKey();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;日志配置：默认日志debug,system分类info级别，Microsoft分类是info级别。这个LogLevel下的节点就是日志筛选功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181219225318663-430974659.png&quot;&gt;&lt;img title=&quot;image_thumb&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181219225319266-294033489.png&quot; alt=&quot;image_thumb&quot; width=&quot;244&quot; height=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印出来的框起来的都是EventSource的事件，我自定义的就是那些汉字部分，而debug的没有打印出来，因为debug使用net的trace日志系统，需要去配置Trace，而且只支持windows环境。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;            &lt;span&gt;总结：asp.net core中集成了很多以前.net的功能，虽然部分可以用上，部分用不上，比如debug模式，vs开发一直再用。而trace和debug技术体系一致，但是trace只能在.net freamwork平台上跑.一切应该都是为了兼容开发平台和运行环境吧。下一章我们一起来看看自定义日志提供以及与kafka的集成&lt;span&gt;&lt;span&gt;           &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>一夜寒江</dc:creator>
<og:description>一 简介 无论是微服务还是其他任何分布式系统，都需要一个统一处理日志的系统，这个系统必须有收集，索引，分析查询的功能。asp .net core自己的日志是同步方式的，正如文档所言： 所以必须自己提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10146838.html</dc:identifier>
</item>
<item>
<title>【分分钟内搭建一个带用户系统的博客程序（一）用户系统】asp.net core的Identity真香，EF真香！ - 不咬人的蚊子</title>
<link>http://www.cnblogs.com/oukichi/p/10134346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oukichi/p/10134346.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不用不知道，一用香到爆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老哥是个屌丝前端，但也想写点web应用耍一耍。之前弄过了NodeJs，也弄过JAVA，最近由于写游戏的原因用C#，索性上手一波asp.net core。&lt;/p&gt;
&lt;p&gt;这篇博客记录的是，&lt;span&gt;&lt;strong&gt;如何在分分钟内搭建一个博客程序。&lt;/strong&gt;&lt;/span&gt;包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发博客&lt;/li&gt;
&lt;li&gt;看博客&lt;/li&gt;
&lt;li&gt;用户注册登录&lt;/li&gt;
&lt;li&gt;用户权限设置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中用的就是微软提供的EntityFrame和Identity类库。简直他妈爽出翔。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;反正增删改查就那么回事儿，快速生成一个项目模板才是主要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217222547468-689529780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217222704260-519566749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我不想创建一个带Razor页面的项目。因为我只需要API。&lt;span&gt;老夫可是个前端！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217223022824-18884904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个时候按F5运行网站，然后就可以用Postman向 http://localhost:55536/api/values发送请求了。如果有过开发经验的人一眼就能看明白这是怎么回事儿。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;添加用户系统的意思是，允许用户注册和登录。&lt;/p&gt;
&lt;p&gt;如果我用NodeJs或者Java，我就要开始写数据库了，甚至设计数据表。可是微软已经把好用的东西给准备好了，那就是：Identity类库。这个类库老JB好了。我只需要轻轻点几下，一套完备的用户系统就能生成到我的代码上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217233821874-11452736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217233854809-650225880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217234451436-597206520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt; 我现在来解释一波我进行了什么操作。&lt;/p&gt;
&lt;p&gt;1.刚才我加的一大堆东西，其实就是最开始创建项目的时候，“身份验证”那一部分帮我们做的事。当时我没选，现在我手动加上。&lt;/p&gt;
&lt;p&gt;2.上面这个图，“替代所有文件”这部分如果选中，框架会帮我们生成相应的业务逻辑和Html模板（当然是Razor模板）。&lt;/p&gt;
&lt;p&gt;3.因为注册登录需要和数据库交互，所以“新建数据库上下文类”帮我们新生成了一个和数据库交互的上下文类。这个类是EntityFramework提供的。巨牛逼巨方便。&lt;/p&gt;
&lt;p&gt;4.“新建用户类”，这没什么好说的吧？这个用户类用于和数据库的用户表进行对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这下我们牛逼了。然后你会发现项目目录里多了一些文件，这些都是asp.net core帮我们生成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217235716768-456355879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以随便探索一下。那个Readme.txt文件可以读一下。是一个指导手册，告诉你接下来要怎么做。&lt;/p&gt;

&lt;p&gt;如readme文件所说，一步一步来。我还是贴出来readme文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Support &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ASP.NET Core Identity was added to your project
&lt;/span&gt;- The code &lt;span&gt;for&lt;/span&gt; adding Identity to your project was generated under Areas/&lt;span&gt;Identity.

Configuration of the Identity related services can be found &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the Areas/Identity/&lt;span&gt;IdentityHostingStartup.cs file.

If your app was previously configured to use Identity, then you should remove the call to the AddIdentity method &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; your ConfigureServices method.
&lt;span&gt;//生成的UI需要静态文件支持，用下面这段代码使你的app支持静态文件&lt;/span&gt;
The generated UI requires support &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; files. To add &lt;span&gt;static&lt;/span&gt;&lt;span&gt; files to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call app.UseStaticFiles() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your Configure method
&lt;span&gt;//用下面这段代码开启身份认证功能&lt;/span&gt;
To use ASP.NET Core Identity you also need to enable authentication. To authentication to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call app.UseAuthentication() &lt;span&gt;from&lt;/span&gt; your Configure method (after &lt;span&gt;static&lt;/span&gt;&lt;span&gt; files)
&lt;span&gt;//生成的UI需要MVC支持，用这面这段代码开启MVC功能&lt;/span&gt;
The generated UI requires MVC. To add MVC to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call services.AddMvc() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your ConfigureServices method
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. Call app.UseMvc() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your Configure method (after authentication)
&lt;span&gt;//生成的数据库结构需要你执行Migration来同步数据库&lt;/span&gt;
The generated database code requires Entity Framework Core Migrations. Run the following commands:&lt;br/&gt;&lt;span&gt;//在cmd中执行下面两个命令
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. dotnet ef migrations add CreateIdentitySchema
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. dotnet ef database update&lt;br/&gt;&lt;span&gt;//或者 在包管理命令行执行下面两个命令&lt;/span&gt;
 Or &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; the Visual Studio Package Manager Console:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Add-&lt;span&gt;Migration CreateIdentitySchema
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. Update-&lt;span&gt;Database

Apps that use ASP.NET Core Identity should also use HTTPS. To enable HTTPS see https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;go.microsoft.com/fwlink/?linkid=848054.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt; 按照上面的操作来撸好app以后。框架就搭成了。牛逼到爆。一行代码都没写，一个非常完备的基础架子已经OK了。&lt;/p&gt;
&lt;p&gt;需要注意的是，你要额外安装EntityFramework类库。这个百度教程太多了。我就不说了。&lt;/p&gt;
&lt;p&gt;当你执行完那两个命令后，你会发现你的数据库里多了一些表。酷！成功了。&lt;/p&gt;
&lt;p&gt;注：在这里执行命令的时候可能会说EntityFramework没安装什么的这时候不要虚，仔细看输出，会说你装了EF6和EFCore，你要指定一下用哪个EF来运行命令，asp.net core的话就用 &lt;span&gt;EntityFrameworkCore\Update-Database&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实注册的业务逻辑已经生成好了，直接拿来用就可以。去Areas/Identity/Pages/Account/Register.cshtml里面，可以看到这段代码。稍微改动一下就可以拿来用了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先是，我打算用Postman模拟用户前端的输入，后端在注册的时候接收3个值，邮箱，用户名，密码。于是俺创建一个类代表这个数据格式。强类型语言就是爽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserRegisterInput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; RememberMe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在开始写controller。新建一个APIController，这个简直不用再描述了。最后Controller代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.Areas.Identity.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.DTO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _userManager;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserController(UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; userManager)
        {
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
        }
        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)] &lt;span&gt;//这里是你的路由地址 post发往 https://localhost:55683/api/user/reg
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我用Postman发一波请求试试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181218235707230-1404476952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注册的最后，查看数据库，你的用户显然已经存在数据库里了。这些数据表都是asp.net core + EntityFramework给我们建立好的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219000059476-2012861077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我要做的是，给某个Action增加权限校验，说句白话就是，有的接口我希望登录用户才能访问，有的接口我希望管理员才能访问，或者有的接口我希望只有付费Vip才能访问。怎么做呢？&lt;/p&gt;
&lt;p&gt;这里用已经存在的ViewController来举例子。目前为止，ValueController的数据是谁都可以访问的。但是我来加一行代码，就一行！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;span&gt;[Authorize(Policy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &quot;VipOnly&quot;)]//很明显，从此这个Action只能是Vip才能访问。
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然我定制了一个策略，这个策略名字叫做VipOnly。那么接下来我要定义这个策略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;span&gt;services.AddAuthorization(options &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;
            {
                options.AddPolicy(&quot;VipOnly&quot;, policy =&amp;gt; policy.RequireClaim(&quot;Role&quot;, &quot;VipUser&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;));
            });&lt;/span&gt;
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在startup.cs里面加入这一行代码，应该显而易见。意思是：增加一个名为VipOnly的策略，这个策略的要求是，如果用户有一个属性Role，这个Role的值是VipUser，那么就符合这个策略。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Claim就是用户的一个属性。这个属性可以在任何时候创建。这个Claim也是Asp.net core提供给我们的工具！很方便。来看一波代码吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5.1 如何给用户添加一个Claim&lt;/h2&gt;
&lt;p&gt;我更改了一下注册流程，每一个注册用户都被默认设置为VipUser&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给用户增加一个Claim&lt;/span&gt;
            &lt;span&gt;var addClaimResult = await _userManager.AddClaimAsync(user, new System.Security.Claims.Claim(&quot;Role&quot;, &quot;VipUser&quot;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单到爆炸不是吗？我现在注册一个用户，就会看到这个用户被添加了一个Claim，Role=VipUser&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212612167-354450656.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212742905-396616178.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212819688-1444194035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 用户登录的原理是JWT。是一个独立知识点。这里我只提供代码。教程网上一堆。需要我写的话请留言，我再补充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IdentityModel.Tokens.Jwt;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Security.Claims;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.Areas.Identity.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.DTO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _userManager;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _config;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; SignInManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _signInManager;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserController(UserManager&amp;lt;TinyBlog2User&amp;gt; userManager, IConfiguration configuration, SignInManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; signInManager)
        {
            _config &lt;/span&gt;=&lt;span&gt; configuration;
            _signInManager &lt;/span&gt;=&lt;span&gt; signInManager;
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
        }
        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给用户增加一个Claim&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; addClaimResult = &lt;span&gt;await&lt;/span&gt; _userManager.AddClaimAsync(user, &lt;span&gt;new&lt;/span&gt; System.Security.Claims.Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Succeeded &amp;amp;&amp;amp;&lt;span&gt; addClaimResult.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将加密后的密码用JWT指定算法进行加密&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到当前登录用户&lt;/span&gt;
                TinyBlog2User currentUser = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.FindByEmailAsync(Input.Email);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户的Claims&lt;/span&gt;
                IList&amp;lt;Claim&amp;gt; claimsList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.GetClaimsAsync(currentUser);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; unSecruityToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityToken(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], _config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], claimsList, expires: DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;), signingCredentials: creds);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(unSecruityToken);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { user = user, token =&lt;span&gt; token });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 前后端分离，前端的登录请求发送到这里。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回200或者401，代表登录成功和失败，如果登录成功，返回一个token。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inputUser&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; {&quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6IjFAMS5jb20iLCJqdGkiOiI0ZDNiZGFjMC1hNjYzLTQwNTMtYjU1Yy02Njg2YjAyNjk0MmIiLCJFbWFpbCI6IjFAMS5jb20iLCJleHAiOjE1NDQxODgwMDcsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6NjM5MzkvIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo2MzkzOS8ifQ.GTFmUKiAfLTaOuv7rZ-g4Cns033RWehB8u3iFB59rFM&quot;}
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Login([FromBody]UserLoginInput inputUser)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到用户名和密码，用asp.net Core 自带的Identity来进行登录&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; _signInManager.PasswordSignInAsync(inputUser.UserName, inputUser.Password, inputUser.RememberMe, lockoutOnFailure: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把你自己的密码进行对称加密&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将加密后的密码用JWT指定算法进行加密，这个加密算法有很多，可以去JWT官网上看&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到当前登录用户&lt;/span&gt;
                TinyBlog2User user = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.FindByEmailAsync(inputUser.Email);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户的Claims&lt;/span&gt;
                IList&amp;lt;Claim&amp;gt; claimsList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.GetClaimsAsync(user);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用各种信息组成一个JWT&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; unSecruityToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityToken(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], _config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], claimsList, expires: DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;), signingCredentials: creds);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把JWT加密一下返回给客户端&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(unSecruityToken);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { token =&lt;span&gt; token });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Unauthorized();
            }
        }



        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UserController.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authentication.JwtBearer;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.HttpsPolicy;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateLifetime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidIssuer &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                    ValidAudience &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                    IssuerSigningKey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
                };
            });

            services.AddAuthorization(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipOnly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt; policy.RequireClaim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            });
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }
            app.UseStaticFiles();
            app.UseAuthentication();
            app.UseHttpsRedirection();
            app.UseMvc();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Startup.cs&lt;/span&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;现在用户登录以后就会得到一串JWT。以后每次发请求的时候在头部附带JWT，浏览器就会认出用户的身份，并且方便的做权限验证了。这里附上PostMan设置。美滋滋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219214106602-1125374063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219214444986-1873308762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219215449441-1003162976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;用户注册默认是依靠UserName来注册的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实用户系统才是最大的门槛。至于帖子的增删改查。可以用很简单的一篇博客就能搞定了。祝你开心。&lt;/p&gt;

&lt;p&gt;编程学习大篷车-不限技术栈 QQ群(516766232) 新建群，大家一起来交流嘛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219220705165-1908530434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 14:10:00 +0000</pubDate>
<dc:creator>不咬人的蚊子</dc:creator>
<og:description>一个前端的asp.net core上手笔记。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oukichi/p/10134346.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（四）双端队列 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</guid>
<description>&lt;p&gt;　　在介绍双端队列之前，我们需要先介绍队列的概念。和栈相对应，在许多算法设计中，需要一种&quot;&lt;strong&gt;先进先出(First Input First Output)&lt;/strong&gt;&quot;的数据结构，因而一种被称为&quot;&lt;strong&gt;队列(Queue)&lt;/strong&gt;&quot;的数据结构被抽象了出来(因为现实中的队列,就是先进先出的)。&lt;/p&gt;
&lt;p&gt;　　队列是一种线性表，将线性表的一端作为队列的头部，而另一端作为队列的尾部。队列元素从尾部入队，从头部出队(&lt;strong&gt;尾进头出，先进先出&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;双端队列(Double end Queue)&lt;/strong&gt;是一种&lt;strong&gt;特殊的队列结构&lt;/strong&gt;，和普通队列不同的是，双端队列的线性表两端都可以进行出队和入队操作。当只允许使用一端进行出队、入队操作时，双端队列等价于一个栈；当限制一端只能出队，另一端只能入队时，双端队列等价于一个普通队列。&lt;/p&gt;
&lt;p&gt;　　简洁起见，下述内容的&quot;&lt;strong&gt;队列&lt;/strong&gt;&quot;默认代表的就是&quot;&lt;strong&gt;双端队列&lt;/strong&gt;&quot;。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 双端队列 ADT接口
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Deque&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 头部元素插入
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addHead(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尾部元素插入
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addTail(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 头部元素删除
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E removeHead();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尾部元素删除
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E removeTail();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视头部元素(不删除)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peekHead();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视尾部元素(不删除)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peekTail();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回当前队列中元素的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前队列是否为空
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 如果当前队列中元素个数为0，返回true；否则，返回false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清除队列中所有元素
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得迭代器
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Iterator&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; iterator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.1 双端队列基于数组的实现（ArrayDeque）&lt;/h2&gt;
&lt;p&gt;　　双端队列作为一个线性表，一开始也许会考虑能否像栈一样，使用向量作为双端队列的底层实现。&lt;/p&gt;
&lt;p&gt;　　但是仔细思考就会发现：在向量中，头部元素的插入、删除会导致内部元素的整体批量的移动，效率很差。而队列具有&quot;先进先出&quot;的特性，对于频繁入队，出队的队列容器来说，O(n)时间复杂度的单位操作效率是无法容忍的。因此我们必须更进一步，从更为基础的数组结构出发，实现我们的双端队列。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.1 数组双端队列实现思路：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在进行代码细节的展开之前，让我们先来理解以下基本思路：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.&lt;/strong&gt;和向量一样，双端队列在内部数组容量不足时，能和向量一样动态的扩容。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt;双端队列内部维护着&quot;头部下标&quot;、&quot;尾部下标&quot;。&lt;strong&gt;头部下标&lt;/strong&gt;指向的是&lt;strong&gt;队列中第一位元素&lt;/strong&gt;，&lt;strong&gt;尾部下标&lt;/strong&gt;指向的是&lt;strong&gt;下一个尾部元素插入的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　   &lt;strong&gt;从头部下标起始，到尾部下标截止(左闭右开区间)，连续保存着队列中的全部元素&lt;/strong&gt;。在元素出队，入队时，通过移动头尾下标，进行队列中元素的插入、删除，从而避免了类似向量中大量内部元素的整体移动。&lt;/p&gt;
&lt;p&gt;　　   当&lt;strong&gt;头部元素入队时，头部下标向左移动一位&lt;/strong&gt;；&lt;strong&gt;头部元素出队时，头部下标向右移动一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　   当&lt;strong&gt;尾部元素入队时，尾部下标向右移动一位&lt;/strong&gt;；&lt;strong&gt;尾部元素出队时，尾部下标向左移动一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.&lt;/strong&gt;当元素下标的移动达到了边界时，需要将数组从逻辑上看成一个环，其头尾是相邻的：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;下标从数组第0位时，向左移动一位，会跳转到数组的最后一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;下标从数组最后一位时，向右移动一位，会跳转到数组的第0位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　下标越界时的跳转操作，在细节上是通过下标&lt;/strong&gt;取模实现的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181215122915929-644470376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.2 队列的基本属性：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　只有当队列为空时，头部节点和尾部节点的下标才会相等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 基于数组的 双端队列
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayDeque&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Deque&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部封装的数组
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] elements;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列默认的容量大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 16&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩容翻倍的基数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXPAND_BASE = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列头部下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列尾部下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tail;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayDeque() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小为默认&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[DEFAULT_CAPACITY];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化队列 头部,尾部下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = 0&lt;span&gt;;
    }
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.1.3 取模计算：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在jdk基于数组的双端队列实现中，强制保持内部数组容量为2的平方(初始化时容量为2的平方，每次自动扩容容量 * 2)，因此其取模运算可以通过按位与(&amp;amp;)运算来加快计算速度。&lt;/p&gt;
&lt;p&gt;　　取模运算在双端队列的基本接口实现中无处不在，相比jdk的双端队列实现，我们实现的双端队列实现更加原始，效率也较差。但相对的，我们的双端队列实现也较为简洁和易于理解。在理解了基础的实现思路之后，可以在这个初始版本的基础上进一步优化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取模运算
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMod(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; logicIndex){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; innerArrayLength = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于队列下标逻辑上是循环的

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当逻辑下标小于零时&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(logicIndex &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::加上当前数组长度&lt;/span&gt;
            logicIndex +=&lt;span&gt; innerArrayLength;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当逻辑下标大于数组长度时&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(logicIndex &amp;gt;=&lt;span&gt; innerArrayLength){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::减去当前数组长度&lt;/span&gt;
            logicIndex -=&lt;span&gt; innerArrayLength;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得真实下标&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logicIndex;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　取模运算时间复杂度：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;取模运算中只是进行了简单的整数运算，时间复杂度为O(1)，而在jdk的双端队列实现中，使用位运算的取模效率还要更高。&lt;/p&gt;
&lt;h3&gt;3.1.4 基于数组的双端&lt;strong&gt;队列常用操作接口实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　结合代码，我们再来回顾一下前面提到的基本思路：&lt;/p&gt;
&lt;p&gt;　　1. &lt;strong&gt;头部下标&lt;/strong&gt;指向的是&lt;strong&gt;队列中第一位元素&lt;/strong&gt;，&lt;strong&gt;尾部下标&lt;/strong&gt;指向的是&lt;strong&gt;下一个尾部元素插入的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　2. &lt;strong&gt;头部插入元素时，head下标左移一位&lt;/strong&gt;；&lt;strong&gt;头部删除元素时，head下标右移一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　    &lt;strong&gt;尾部插入元素时，tail下标右移一位&lt;/strong&gt;；&lt;strong&gt;尾部删除元素时，tail下标左移一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　3. &lt;strong&gt;内部数组被看成是一个环&lt;/strong&gt;，下标移动到边界临界点时，通过&lt;strong&gt;取模运算&lt;/strong&gt;来计算逻辑下标对应的真实下标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addHead(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部插入元素 head下标左移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = getMod(&lt;span&gt;this&lt;/span&gt;.head - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存放新插入的元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.head] =&lt;span&gt; e;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前队列大小 是否到达临界点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(head ==&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组扩容&lt;/span&gt;
&lt;span&gt;            expand();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addTail(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存放新插入的元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.tail] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::尾部插入元素 tail下标右移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.tail = getMod(&lt;span&gt;this&lt;/span&gt;.tail + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前队列大小 是否到达临界点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(head ==&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组扩容&lt;/span&gt;
&lt;span&gt;            expand();
        }
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeHead() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存需要被删除的数据&lt;/span&gt;
        E dataNeedRemove = (E)&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前头部元素引用释放&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.head] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部下标 右移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = getMod(&lt;span&gt;this&lt;/span&gt;.head + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataNeedRemove;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeTail() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得尾部元素下标(左移一位)&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = getMod(&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存需要被删除的数据&lt;/span&gt;
        E dataNeedRemove = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[lastIndex];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置尾部下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; lastIndex;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataNeedRemove;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekHead() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head];
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekTail() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得尾部元素下标(左移一位)&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = getMod(&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[lastIndex];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　队列常用接口时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;基于数组的队列在访问头尾元素时，进行了一次取模运算获得真实下标，由于数组的随机访问是常数时间复杂度(O(1))，因此队列常用接口的&lt;strong&gt;时间复杂度都为O(1)&lt;/strong&gt;，效率很高。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.5 扩容操作：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;可以看到，在入队插入操作结束后，会判断当前队列容量是否已经到达了临界点。&lt;/p&gt;
&lt;p&gt;　　前面提到，只有在队列为空时，头部下标才会和尾部下标重合；而当插入新的入队元素之后，使得头部下标等于尾部下标时，说明内部数组的容量已经达到了极限，需要进行扩容才能容纳更多的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们举一个简单的例子来理解扩容操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　尾部下标为2.头部下标为3，队列内的元素为头部下标到尾部下标(左闭右开)中的元素排布为(1，2，3，4，5，6)。&lt;/p&gt;
&lt;p&gt;　　目前队列刚刚在下标为2处的尾部入队元素&quot;7&quot;。尾部下标从2向右移动一位和头部下标重合，此时队列中元素排布为(1，2，3，4，5，6，7)，此时需要进行一次扩容操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在扩容完成之后，我们希望让队列的元素在内部数组中排列的更加自然：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1. 队列中元素的顺序不变，依然是(1，2，3，4，5，6，7)，内部数组扩容一定的倍数(两倍)&lt;/p&gt;
&lt;p&gt;　　　　2. 队列中第一个元素将位于内部数组的第0位，队列中的元素按照头尾顺序依次排列下去&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;扩容的大概思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1. 将&quot;头部下标&quot;直至&quot;当前内部数组尾部&quot;的元素按照顺序整体复制到新扩容数组的起始位置(&lt;strong&gt;红色背景的元素&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;　　　　2. 将&quot;当前内部数组头部&quot;直至&quot;尾部下标&quot;的元素按照顺序整体复制到新扩容数组中(位于第一步操作复制的数据区间之后)(&lt;strong&gt;蓝色背景的元素&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181218165731641-1927015579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容后：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181215230150746-765088169.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容代码的实现：　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组扩容
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; expand(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组 扩容两倍&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; elementsLength = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;
        Object[] newElements &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Object[elementsLength *&lt;span&gt; EXPAND_BASE];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将&quot;head -&amp;gt; 数组尾部&quot;的元素 复制在新数组的前面 (tips：使用System.arraycopy效率更高)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;this&lt;/span&gt;.head, j=0; i&amp;lt;elementsLength; i++,j++&lt;span&gt;){
            newElements[j] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将&quot;0 -&amp;gt; head&quot;的元素 复制在新数组的后面 (tips：使用System.arraycopy效率更高)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0, j=elementsLength-&lt;span&gt;this&lt;/span&gt;.head; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.head; i++,j++&lt;span&gt;){
            newElements[j] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化head,tail下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组指向 新扩容的数组&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements =&lt;span&gt; newElements;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　扩容操作时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　动态扩容的操作由于需要进行内部数组的整体copy，&lt;strong&gt;其时间复杂度是O(n)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;但是站在全局的角度，动态扩容只会在入队操作导致空间不足时&lt;strong&gt;偶尔&lt;/strong&gt;的被触发，&lt;strong&gt;整体来看，动态扩容的时间复杂度为O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;3.1.6 其它接口实现：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getMod(tail -&lt;span&gt; head);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当且仅当 头尾下标相等时 队列为空&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (head ==&lt;span&gt; tail);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; head = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tail = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(head !=&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[head] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            head &lt;/span&gt;= getMod(head + 1&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Itr();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.1.7 基于数组的双端队列——迭代器实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　迭代器从头部元素开始迭代，直至尾部元素终止。&lt;/p&gt;
&lt;p&gt;　　值得一提的是，虽然队列的api接口中没有提供直接删除队列中间(非头部、尾部)的元素，但是迭代器的remove接口却依然允许这种操作。由于必须要时刻保持队列内元素排布的连续性，因此在删除队列中间的元素后，需要整体的移动其他元素。&lt;/p&gt;
&lt;p&gt;　　此时，有两种选择：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;方案一&lt;/strong&gt;：将&quot;头部下标&quot;到&quot;被删除元素下标&quot;之间的元素整体向右平移一位&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;方案二&lt;/strong&gt;：将&quot;被删除元素下标&quot;到&quot;尾部下标&quot;之间的元素整体向左平移一位&lt;/p&gt;
&lt;p&gt;　　我们可以根据被删除元素所处的位置，计算出两种方案各自需要平移元素的数量，选择平移元素数量较少的方案，进行一定程度的优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列迭代器的remove操作中存在一些细节值得注意，我们使用一个简单的例子来帮助理解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1. 当前队列在迭代时需要删除元素&quot;7&quot;(红色元素)，采用方案一需要整体平移(1，2，3，4，5，6)六个元素，而方案二只需要整体平移(8，9，10，11，12)五个元素。因此采用平移元素更少的方案二，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;2. 这时由于(8，9，10，11，12)五个元素被物理上截断了，所以主要分三个步骤进行平移。&lt;/p&gt;
&lt;p&gt;　　　　第一步： 先将靠近尾部的 (8，9)两个元素整体向左平移一位(蓝色元素)&lt;/p&gt;
&lt;p&gt;　　　　第二步： 将内部数组头部的元素(10)，复制到内部数组的尾部(粉色元素)&lt;/p&gt;
&lt;p&gt;　　　　第三部 :  将剩下的元素(11，12)，整体向左平移一位(绿色元素)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove操作执行前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181218170424746-508873537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove操作执行后：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181216203219856-70700302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在remove操作中有多种可能的情况，由于思路相通，可以通过上面的举例说明帮助理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   /**&lt;/span&gt;&lt;span&gt;
     * 双端队列 迭代器实现
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前迭代下标 = head
         * 代表遍历从头部开始
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; currentIndex = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标终点下标 = tail
         * 代表遍历至尾部结束
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; targetIndex = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 上一次返回的位置下标
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastReturned;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标未到达终点，还存在下一个元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.currentIndex != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetIndex;
        }

        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存需要返回的元素&lt;/span&gt;
            E value = (E)ArrayDeque.&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::最近一次返回元素下标 = 当前迭代下标&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.lastReturned = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标 向后移动一位(需要取模)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex = getMod(&lt;span&gt;this&lt;/span&gt;.currentIndex + 1&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.lastReturned == -1&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IteratorStateErrorException(&quot;迭代器状态异常: 可能在一次迭代中进行了多次remove操作&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前迭代下标的元素&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; deleteFromTail = delete(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果从尾部进行收缩&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(deleteFromTail){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标前移一位&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.currentIndex = getMod(&lt;span&gt;this&lt;/span&gt;.currentIndex - 1&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了防止用户在一次迭代(next调用)中多次使用remove方法，将lastReturned设置为-1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.lastReturned = -1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 删除队列内部数组特定下标处的元素
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 指定的下标
         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 被删除的元素靠近尾部
         *         false 被删除的元素靠近头部
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
            Object[] elements &lt;/span&gt;= ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; head = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tail = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前下标 之前的元素个数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; beforeCount = getMod(currentIndex -&lt;span&gt; head);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前下标 之后的元素个数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; afterCount = getMod(tail -&lt;span&gt; currentIndex);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断哪一端的元素个数较少&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(beforeCount &amp;lt;&lt;span&gt; afterCount){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::距离头部元素较少，整体移动前半段元素

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断头部下标 是否小于 当前下标&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(head &amp;lt;&lt;span&gt; currentIndex){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::小于，正常状态  仅需要复制一批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前数组从&quot;头部下标&quot;开始，整体向右平移一位，移动的元素个数为&quot;当前下标 之前的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,head,elements,head+1&lt;span&gt;,beforeCount);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不小于，说明存在溢出环  需要复制两批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组从&quot;0下标处&quot;的元素整体向右平移一位，移动的元素个数为&quot;从0到当前下标之间的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,0,elements,1&lt;span&gt;,currentIndex);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组最尾部的数据设置到头部，防止被覆盖&lt;/span&gt;
                    elements[0] = elements[(elements.length-1&lt;span&gt;)];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组尾部的数据整体向右平移一位&lt;/span&gt;
                    System.arraycopy(elements,head,elements,head+1,(elements.length-head-1&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::释放被删除元素的引用&lt;/span&gt;
                elements[currentIndex] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部下标 向右移动一位&lt;/span&gt;
                ArrayDeque.&lt;span&gt;this&lt;/span&gt;.head = getMod(ArrayDeque.&lt;span&gt;this&lt;/span&gt;.head + 1&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有删除尾部元素 返回false&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::距离尾部元素较少，整体移动后半段元素

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断尾部下标 是否小于 当前下标&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(currentIndex &amp;lt;&lt;span&gt; tail){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::小于，正常状态  仅需要复制一批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前数组从&quot;当前&quot;开始，整体向左平移一位，移动的元素个数为&quot;当前下标 之后的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,currentIndex+1&lt;span&gt;,elements,currentIndex,afterCount);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不小于，说明存在溢出环  需要复制两批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组从&quot;当前下标处&quot;的元素整体向左平移一位，移动的元素个数为&quot;从当前下标到数组末尾的元素个数-1 ps：因为要去除掉被删除的元素&quot;&lt;/span&gt;
                    System.arraycopy(elements,currentIndex+1,elements,currentIndex,(elements.length-currentIndex-1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组头部的元素设置到末尾&lt;/span&gt;
                    elements[elements.length-1] = elements[0&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组头部的数据整体向左平移一位，移动的元素个数为&quot;从0到尾部下标之间的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,1,elements,0&lt;span&gt;,tail);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::尾部下标 向左移动一位&lt;/span&gt;
                ArrayDeque.&lt;span&gt;this&lt;/span&gt;.tail = getMod(ArrayDeque.&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除了尾部元素 返回true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 基于链表的链式双端队列&lt;/h2&gt;
&lt;p&gt;　　和向量不同，双向链表在头尾部进行插入、删除操作时，不需要额外的操作，效率极高。&lt;/p&gt;
&lt;p&gt;　　因此，我们可以使用之前已经封装好的的双向链表作为基础，轻松的实现一个链式结构的双端队列。限于篇幅，就不继续展开了，有兴趣的读者可以尝试自己完成这个任务。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;空间效率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;基于数组的双端队列：&lt;/strong&gt;数组空间结构非常紧凑，效率很高。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;基于链表的双端队列：&lt;/strong&gt;由于链式结构的节点存储了相关联的引用，空间效率比数组结构稍低。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;时间效率:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　对于双端队列常用的&lt;strong&gt;出队&lt;/strong&gt;、&lt;strong&gt;入队&lt;/strong&gt;操作，由于都是在头尾处进行操作，数组队列和链表队列的执行效率都非常高(&lt;strong&gt;时间复杂度(O(1))&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　　　需要注意的是，由于双端队列的迭代器&lt;strong&gt;remove&lt;/strong&gt;接口允许删除队列中间部位的元素，而删除中间队列元素的效率很低(&lt;strong&gt;时间复杂度O(n)&lt;/strong&gt;)，所以在使用迭代器&lt;strong&gt;remove&lt;/strong&gt;接口时需要谨慎。&lt;/p&gt;

&lt;p&gt;　　至此，我们实现了一个基础的、基于数组的双端队列。要想更近一步的学习双端队列，可以尝试着阅读jdk的java.util.ArrayDeque类并且按照自己的思路尝试着动手实现一个双端队列。我个人认为，如果事先没有一个明确的思路，直接去硬看源代码，很容易就陷入细节之中无法自拔，&quot;不识庐山真面目，只缘生在此山中&quot;。&lt;/p&gt;
&lt;p&gt;　　希望这篇博客能够让读者更好的理解双端队列，更好的理解自己所使用的数据结构，写出更高效，易维护的程序。&lt;/p&gt;
&lt;p&gt;　　博客的完整代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 14:09:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.双端队列介绍 在介绍双端队列之前，我们需要先介绍队列的概念。和栈相对应，在许多算法设计中，需要一种&quot;先进先出(First Input First Output)&quot;的数据结构，因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</dc:identifier>
</item>
<item>
<title>从源码学习设计模式之模板方法 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10146442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10146442.html</guid>
<description>&lt;p&gt;什么是模板方法模式？摘录 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95&quot;&gt;wiki&lt;/a&gt; 的介绍。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法模式定义了一个算法的步骤，并允许子类别为一个或多个步骤提供其实践方式。让子类别在不改变算法架构的情况下，重新定义算法中的某些步骤。在软件工程中，它是一种软件设计模式，和C++模板没有关连。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;模板设计方法存在目的在于某些算法逻辑存在一些相同处，而具体细节却不同。这样使用模板方法，可以抽取共用逻辑到父类，在子类实现具体算法细节，这样减少了重复代码。&lt;br/&gt;模板方法充分运用了多态与继承。使用抽象父类定义抽象操作,然后在公共逻辑调用抽象方法。子类方法只要继承父类关注自身实现细节。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Talk is cheap. Show me the code&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面拿支付接入支付渠道例子来使用模板方法。&lt;/p&gt;
&lt;p&gt;假设银行卡支付需要实现两家银行的支付功能。不同银行提供的接口，在参数，调用方式等肯定存在很大区别。这个时候我们就可以使用模板设计方法，父类实现支付前通用逻辑，用子类实现交互的不同。系统类结构如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/18/167c151b6d8f24d3?w=542&amp;amp;h=311&amp;amp;f=png&amp;amp;s=14987&quot; alt=&quot;系统类结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AgreementPay&lt;/strong&gt; 提供支付功能，&lt;strong&gt;AgreementBasePay&lt;/strong&gt; 为抽象类实现通用逻辑，&lt;strong&gt;AgreementCCBPay&lt;/strong&gt; 与 &lt;strong&gt;AgreementCMBPay&lt;/strong&gt; 实现具体的渠道支付方法。具体源码如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AgreementPay&lt;/strong&gt; 接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public interface AgreementPay {

    PayResponse payInChannel(PayReauest reauest);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;AgreementBasePay&lt;/strong&gt; 抽象方法实现通用逻辑。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public abstract class AgreementBasePay implements AgreementPay {

    public PayResponse pay(PayReauest reauest) {
        checkRequest(reauest);
        return this.payInChannel(reauest);
    }


    private void checkRequest(PayReauest reauest) {
        System.out.println(&quot;具体方法参数检查&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现类，实现具体渠道支付细节。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class AgreementCCBPay extends AgreementBasePay {
    @Override
    public PayResponse payInChannel(PayReauest reauest) {
        System.out.println(&quot;去建设银行支付&quot;);
        return new PayResponse();
    }
}

public class AgreementCMBPay extends AgreementBasePay {
    @Override
    public PayResponse payInChannel(PayReauest reauest) {
        System.out.println(&quot;去招商银行支付&quot;);
        return new PayResponse();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现模板方法的细节，我们来看 client 使用逻辑。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class Client {

    public static void main(String[] args) {
        System.out.println(&quot;使用招商银行支付&quot;);
        AgreementPay agreementPay = new AgreementCMBPay();
        PayRequest request = new PayRequest();
        agreementPay.payInChannel(request);
        System.out.println(&quot;使用建设银行支付&quot;);
        agreementPay = new AgreementCCBPay();
        agreementPay.payInChannel(request);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 client 逻辑，其实看起来还是有一些死板，且需要外部知道调用哪个渠道接口。但是如果真正提供一个对外接口，外部调用方法是不关心你具体使用那个子类支付。所以这里我们可以改进一下，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public static Map&amp;lt;String, AgreementPay&amp;gt; payCache = new HashMap&amp;lt;&amp;gt;();

    static {
        payCache.put(&quot;CMB&quot;, new AgreementCMBPay());
        payCache.put(&quot;CCB&quot;, new AgreementCCBPay());
    }


    public static void main(String[] args) {
        PayRequest request = new PayRequest();
        AgreementPay pa;
        switch (request.getBankCode()) {
            case &quot;CMB&quot;:
                pa = payCache.get(&quot;CMB&quot;);
                pa.payInChannel(request);
            case &quot;CCB&quot;:
                pa = payCache.get(&quot;CCB&quot;);
                pa.payInChannel(request);
            default:
                throw new RuntimeException();
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造之后我们先将其 AgreementPay 实例放入 map 中，然后调用时根据一个标志来选择具体实现类。&lt;/p&gt;
&lt;p&gt;从上面的细节我们可以看到模板方法其实设计思路与实现细节都比较简单。看完我们的示例代码，我们去看下 mybatis 如何使用模板方法。&lt;/p&gt;
&lt;h2 id=&quot;mybatis-模板方法应用&quot;&gt;mybatis 模板方法应用&lt;/h2&gt;
&lt;p&gt;在看源码之前，我们先看下我们不使用 mybatis 之前，如何查询数据。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.获得数据库的连接
        Connection conn = DriverManager.getConnection(URL, NAME, PASSWORD);
        //3.通过数据库的连接操作数据库，实现增删改查
        PreparedStatement pstmt = conn.prepareStatement(&quot;select user_name,age from imooc_goddess where id=?&quot;);
        pstmt.setInt(1, 21);
        ResultSet rs = pstmt.execute();
        
        while (rs.next()) {//如果对象中有数据，就会循环打印出来
            System.out.println(rs.getString(&quot;user_name&quot;) + &quot;,&quot; + rs.getInt(&quot;age&quot;));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到直接使用 JDBC 查询，十分麻烦，且需要我们自己将 java 类型转换成 jdbc 数据类型。&lt;/p&gt;
&lt;p&gt;ORM 框架重要作用在于把数据库表与 java，ORM 框架省去我们自己将 java 类型转化成 JDBC 类型的麻烦。JDBC 存在有那么多类型，如何做到转换的那？其实关键就是应用模板设计方法。&lt;/p&gt;
&lt;p&gt;mybatis 中存在一个接口 &lt;strong&gt;TypeHandler&lt;/strong&gt;，该接口方法主要如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public interface TypeHandler&amp;lt;T&amp;gt; {

  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

  T getResult(ResultSet rs, String columnName) throws SQLException;

  T getResult(ResultSet rs, int columnIndex) throws SQLException;

  T getResult(CallableStatement cs, int columnIndex) throws SQLException;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从方法上看，这个接口主要的方法为 &lt;strong&gt;PreparedStatement&lt;/strong&gt; 设置列参数，或者从 &lt;strong&gt;ResultSet&lt;/strong&gt; 获取列的值然后转换成相应的 java 数据类型。我们看下这个接口实现的类图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/18/167c18628ff6dd68?w=508&amp;amp;h=291&amp;amp;f=png&amp;amp;s=14837&quot; alt=&quot;TypeHandler 实现类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 &lt;strong&gt;BaseTypeHandler&lt;/strong&gt; 为 &lt;strong&gt;TypeHandler&lt;/strong&gt; 的具体抽象类，我们具体看下 &lt;strong&gt;TypeHandler getResult&lt;/strong&gt; 在抽象类中实现细节。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
  @Override
  public T getResult(ResultSet rs, String columnName) throws SQLException {
    T result;
    try {
      result = getNullableResult(rs, columnName);
    } catch (Exception e) {
      throw new ResultMapException(&quot;Error attempting to get column '&quot; + columnName + &quot;' from result set.  Cause: &quot; + e, e);
    }
    if (rs.wasNull()) {
      return null;
    } else {
      return result;
    }
  }

   public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到其最后调用抽象方法 &lt;strong&gt;getNullableResult&lt;/strong&gt;。其由具体的子类的实现。我们具体找一个子类 &lt;strong&gt;DateTypeHandler&lt;/strong&gt; 来查看具体实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class DateTypeHandler extends BaseTypeHandler&amp;lt;Date&amp;gt; {


    // 忽略其他方法
  @Override
  public Date getNullableResult(ResultSet rs, String columnName)
      throws SQLException {
    Timestamp sqlTimestamp = rs.getTimestamp(columnName);
    if (sqlTimestamp != null) {
      return new Date(sqlTimestamp.getTime());
    }
    return null;
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见其具体从 &lt;strong&gt;ResultSet&lt;/strong&gt; 取出 &lt;strong&gt;JDBC&lt;/strong&gt; 类型为 &lt;strong&gt;Timestamp&lt;/strong&gt;，然后转换成 java 类型的 &lt;strong&gt;Date&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实现具体的子类，那么在哪里使用了那？其实 mybatis 框架会把所有 TypeHandler 在 TypeHandlerRegistry 注册。具体类方法如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/18/167c1dc171482ba2?w=512&amp;amp;h=540&amp;amp;f=png&amp;amp;s=109681&quot; alt=&quot;TypeHandlerRegistry&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;其提供了相关 &lt;strong&gt;register&lt;/strong&gt; 方法注册 TypeHandler，然后又提供了相关 &lt;strong&gt;getTypeHandler&lt;/strong&gt; 方法取出具体 &lt;strong&gt;TypeHandler&lt;/strong&gt; 实现类。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用模板方法，将公共逻辑抽取出来，将具体实现细节交给子类。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/sunzhenchao/archive/2013/04/09/3009431.html&quot;&gt;Mybatis源代码分析之类型转换&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 19 Dec 2018 14:04:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>什么是模板方法模式？摘录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10146442.html</dc:identifier>
</item>
<item>
<title>基于CNN的图像缺陷分类 - BellaVita1</title>
<link>http://www.cnblogs.com/BellaVita/p/10142266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BellaVita/p/10142266.html</guid>
<description>&lt;h2&gt;1、前言　　&lt;/h2&gt;
&lt;p&gt;在工业产品缺陷检测中，基于传统的图像特征的缺陷分类的准确率达不到实际生产的要求，因此想采用CNN来进行缺陷分类。&lt;/p&gt;
&lt;p&gt;　　传统缺陷分类思路：&lt;/p&gt;
&lt;p&gt;　　1、缺陷图片分离：先采用复杂的图像处理方法，将缺陷从采集的图像中分离处理；&lt;/p&gt;
&lt;p&gt;　　2、特征向量构建：通过对不同缺陷种类的特征进行分析，定义需要提取的n维特征（比如缺陷长、宽、对比度、纹理特征、熵、梯度等），构成一组描述缺陷的&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　  特征向量；特征向量的构建需要对实际的问题有很深入的分析，并且需要有很深厚的图像处理知识；这也是传统分类问题中最难的部分。&lt;/p&gt;
&lt;p&gt;　　3、特征向量归一化：由于特征向量每个维度的度量差别很大（比如缺陷长50像素，对比度0.03），因此需要进行特征缩放，特征归一化；&lt;/p&gt;
&lt;p&gt;　　4、人工标记缺陷：将缺陷图片存储在人工标记的文件夹内；&lt;/p&gt;
&lt;p&gt;　　5、采用SVM对缺陷进行分类，分类准确率85%左右。&lt;/p&gt;
&lt;h2&gt;2、CNN网络构建&lt;/h2&gt;
&lt;p&gt;　　在缺陷图片分离和人工标记后，构建CNN网络模型；由于工业检测中对实时性要求很高，因此想采用比较简单的网络结构来提高训练的速度和检测速度；&lt;/p&gt;
&lt;p&gt;　　网络构建：本文采用LeNet网络结构的基本思路，构建一个简单的网络&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219184454699-61355323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219184150576-1951146645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1：Tensorflow输出的网络模型&lt;/p&gt;
&lt;h2&gt;3、模型训练和测试&lt;/h2&gt;
&lt;h3&gt;3.1 原始模型测试&lt;/h3&gt;
&lt;p&gt;　　开始以为模型可能会出现过拟合的问题，不过从精度和损失曲线看来，没有过拟合问题，到是模型初始迭代的时候陷入了一个局部循环状态，可能是没有得到特别好的特征或者是随机选择训练模型的数据集没有完全分散，也有可能是训练的次数太少了。训练集上的准确率有点低，因此需要用更好的模型，但是模型怎么改呢？？尽管CNN可以自己训练出FIlters，但是依然不能很清晰的看到图像被滤波后是怎么样的状态（图2,图3），对于一直做图像底层算法的人来说，有点很不爽。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219191141761-936009397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219191613956-34711441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2 ：卷积第一层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219191721775-1628942075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3：Relu激活函数层&lt;/p&gt;
&lt;p&gt;　　通过分析图2，发现滤波整体效果还不错，缺陷的地方都能清晰的反映出来；但是本来输入的缺陷是&lt;span&gt;往下凹的&lt;/span&gt;，滤波后的缺陷很多是&lt;span&gt;向上凸的&lt;/span&gt;，不符合实际情况。&lt;/p&gt;
&lt;p&gt;　　分析图3,发现经过Relu激活函数后，只留下了很明显向下凹的缺陷特征图片，但是有效的特征图片（FeatureMap）太少，只有2个。&lt;/p&gt;
&lt;p&gt;　　为了能得到更多的符合实际的缺陷特征图片，&lt;span&gt;考虑到需要更加突出缺陷边缘，以致不被周围大片图像的干扰，因此决定将卷积核变小&lt;/span&gt;；卷积核由默认的5x5改为3x3.&lt;/p&gt;
&lt;h3&gt;3.2 优化卷积核大小后&lt;/h3&gt;
&lt;p&gt;　　模型整体的精度有明显的上升，经过Relu后的有效FeatureMap增加了。&lt;span&gt;有点疑问的是validation数据集的准确率比训练还高5-8个点？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219193034570-1090445452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219193143229-1133057428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278543/201812/1278543-20181219193300753-1684735321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4、Code&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;103&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 18-7-25 下午2:33&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : DuanBin&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Email   : 20092758@cqu.edu.cn&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : catl_train.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; USAGE&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; python catl_train.py --dataset data --model catl.model&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; import the necessary packages&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageDataGenerator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.optimizers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Adam
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.preprocessing.image &lt;span&gt;import&lt;/span&gt;&lt;span&gt; img_to_array
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; to_categorical
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Model
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; load_model
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lenet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LeNet
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; imutils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paths
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; set the matplotlib backend so figures can be saved in the background&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib
matplotlib.use(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Agg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

dataPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
modelPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;catl_5_5.model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
plotPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;catl_plot_5_5_blog.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; initialize the number of epochs to train for, initia learning rate,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; and batch size&lt;/span&gt;
EPOCHS = 50&lt;span&gt;
INIT_LR &lt;/span&gt;= 0.001&lt;span&gt;
BS &lt;/span&gt;= 3&lt;span&gt;
classNumber &lt;/span&gt;= 3&lt;span&gt;
imageDepth &lt;/span&gt;= 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; initialize the data and labels&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[INFO] loading images...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
data &lt;/span&gt;=&lt;span&gt; []
labels &lt;/span&gt;=&lt;span&gt; []

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; grab the image paths and randomly shuffle them&lt;/span&gt;
imagePaths = sorted(list(paths.list_images(dataPath)))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; args[&quot;dataset&quot;])))&lt;/span&gt;
random.seed(42&lt;span&gt;)
random.shuffle(imagePaths)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; loop over the input images&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; imagePath &lt;span&gt;in&lt;/span&gt;&lt;span&gt; imagePaths:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; load the image, pre-process it, and store it in the data list&lt;/span&gt;
    image =&lt;span&gt; cv2.imread(imagePath, 0)
    image &lt;/span&gt;= cv2.resize(image, (28, 28&lt;span&gt;))
    image &lt;/span&gt;=&lt;span&gt; img_to_array(image)
    data.append(image)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; extract the class label from the image path and update the&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; labels list&lt;/span&gt;
    label = imagePath.split(os.path.sep)[-2&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; label == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        label &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; label == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        label &lt;/span&gt;= 1
    &lt;span&gt;elif&lt;/span&gt; label == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;valley&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        label &lt;/span&gt;= 2&lt;span&gt;
    labels.append(label)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; scale the raw pixel intensities to the range [0, 1]&lt;/span&gt;
data = np.array(data, dtype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) / 255.0&lt;span&gt;
labels &lt;/span&gt;=&lt;span&gt; np.array(labels)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; partition the data into training and testing splits using 75% of&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the data for training and the remaining 25% for testing&lt;/span&gt;
(trainX, testX, trainY, testY) = train_test_split(data, labels, test_size=0.3, random_state=42&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(trainX.shape)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert the labels from integers to vectors&lt;/span&gt;
trainY = to_categorical(trainY, num_classes=&lt;span&gt;classNumber)
testY &lt;/span&gt;= to_categorical(testY, num_classes=&lt;span&gt;classNumber)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(trainY.shape)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(testX.shape)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; construct the image generator for data augmentation&lt;/span&gt;
aug = ImageDataGenerator(rotation_range=30, width_shift_range=0.1&lt;span&gt;,
                         height_shift_range&lt;/span&gt;=0.1, shear_range=0.2, zoom_range=0.2&lt;span&gt;,
                         horizontal_flip&lt;/span&gt;=True, fill_mode=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nearest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # initialize the model&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[INFO] compiling model...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
model &lt;/span&gt;= LeNet.build(width=28, height=28, depth=imageDepth, classes=&lt;span&gt;classNumber)
opt &lt;/span&gt;= Adam(lr=INIT_LR, decay=INIT_LR /&lt;span&gt; EPOCHS)
model.compile(loss&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optimizer=&lt;span&gt;opt,
              metrics&lt;/span&gt;=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])

model.summary()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; train the network&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[INFO] training network...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
H &lt;/span&gt;= model.fit_generator(aug.flow(trainX, trainY, batch_size=&lt;span&gt;BS),
                        validation_data&lt;/span&gt;=(testX, testY), steps_per_epoch=len(trainX) //&lt;span&gt; BS,
                        epochs&lt;/span&gt;=EPOCHS, verbose=1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; save the model to disk&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[INFO] serializing network...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
model.save(modelPath)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; args[&quot;model&quot;])&lt;/span&gt;
model.save_weights(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;catl_5_5_wight.h5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; plot the training loss and accuracy&lt;/span&gt;
plt.style.use(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ggplot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.figure()
N &lt;/span&gt;=&lt;span&gt; EPOCHS
plt.plot(np.arange(0, N), H.history[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;train_loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(np.arange(0, N), H.history[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val_loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val_loss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(np.arange(0, N), H.history[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;train_acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.plot(np.arange(0, N), H.history[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val_acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val_acc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Training Loss and Accuracy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Epoch #&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Loss/Accuracy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lower left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.savefig(plotPath)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; args[&quot;plot&quot;])&lt;/span&gt;
&lt;span&gt;plt.show()

layer_outputs &lt;/span&gt;= [layer.output &lt;span&gt;for&lt;/span&gt; layer &lt;span&gt;in&lt;/span&gt;&lt;span&gt; model.layers]
activation_model &lt;/span&gt;= Model(inputs=model.input, outputs=&lt;span&gt;layer_outputs)
activations &lt;/span&gt;= activation_model.predict(testX[0].reshape(1, 28, 28, 1&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; display_activation(activations, col_size, row_size, act_index):
    activation &lt;/span&gt;=&lt;span&gt; activations[act_index]
    activation_index &lt;/span&gt;=&lt;span&gt; 0
    fig, ax &lt;/span&gt;= plt.subplots(row_size, col_size, figsize=(row_size * 2.5, col_size * 1.5&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0, row_size):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0, col_size):
            ax[row][col].imshow(activation[0, :, :, activation_index], cmap&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            activation_index &lt;/span&gt;+= 1&lt;span&gt;

    plt.show()


display_activation(activations, &lt;/span&gt;4, 5, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; import the necessary packages&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.convolutional &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Conv2D
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.convolutional &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MaxPooling2D
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Activation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flatten
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dropout
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeNet:
    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build(width, height, depth, classes):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; initialize the model&lt;/span&gt;
        model =&lt;span&gt; Sequential()
        inputShape &lt;/span&gt;=&lt;span&gt; (height, width, depth)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; if we are using &quot;channels first&quot;, update the input shape&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; K.image_data_format() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;channels_first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            inputShape &lt;/span&gt;=&lt;span&gt; (depth, height, width)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            inputShape &lt;/span&gt;=&lt;span&gt; (width, height, depth)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; first set of CONV =&amp;gt; RELU =&amp;gt; POOL layers&lt;/span&gt;
        model.add(Conv2D(20, (3, 3), padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, input_shape=&lt;span&gt;inputShape))
        model.add(Activation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        model.add(MaxPooling2D(pool_size&lt;/span&gt;=(2, 2), strides=(2, 2&lt;span&gt;)))

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; second set of CONV =&amp;gt; RELU =&amp;gt; POOL layers&lt;/span&gt;
        model.add(Conv2D(50, (3, 3), padding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;same&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        model.add(Activation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        model.add(MaxPooling2D(pool_size&lt;/span&gt;=(2, 2), strides=(2, 2&lt;span&gt;)))


        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; first (and only) set of FC =&amp;gt; RELU layers&lt;/span&gt;
&lt;span&gt;        model.add(Flatten())
        model.add(Dense(&lt;/span&gt;500&lt;span&gt;))
        model.add(Activation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; softmax classifier&lt;/span&gt;
&lt;span&gt;        model.add(Dense(classes))
        model.add(Activation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; return the constructed network architecture&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; model
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　&lt;/h2&gt;
</description>
<pubDate>Wed, 19 Dec 2018 14:00:00 +0000</pubDate>
<dc:creator>BellaVita1</dc:creator>
<og:description>1、前言 在工业产品缺陷检测中，基于传统的图像特征的缺陷分类的准确率达不到实际生产的要求，因此想采用CNN来进行缺陷分类。 传统缺陷分类思路： 1、缺陷图片分离：先采用复杂的图像处理方法，将缺陷从采集</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BellaVita/p/10142266.html</dc:identifier>
</item>
<item>
<title>.NET Core实战项目之CMS 第十二章 开发篇-Dapper封装GURD及仓储代码生成器实现 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10146311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10146311.html</guid>
<description>&lt;p&gt;本篇我将带着大家一起来对Dapper进行下封装并实现基本的增删改查、分页操作的同步异步方法的实现（已实现MSSQL，MySql，PgSQL）。同时我们再实现一下仓储层的代码生成器，这样的话，我们只需要结合业务来实现具体的业务部分的代码就可以了，可以大大减少我们重复而又繁琐的增删改查操作，多留点时间给生活充充电（不会偷懒的程序员不是一位好爸爸/好老公/好男朋友）。如果您觉得我的实现过程有所不妥的话，您可以在评论区留言，或者加入我们的千人.Net Core实战项目交流群637326624交流。另外如果您觉得我的文章对您有所帮助的话希望给个推荐以示支持。项目的源代码我会托管在GayHub上，地址在文章末尾会给出,自认为代码写的很工整，注释也很全，你应该能看懂！&lt;/p&gt;
&lt;blockquote readability=&quot;2.36&quot;&gt;
&lt;p&gt;本文已收录至《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10146311.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10146311.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;将近一周没有更新，鬼知道我这么长时间在干什么，你可以认为我在憋大招，在想着怎么给大家分享更多更实用的东西。其实这只是我偷懒的借口罢了！下面我们一起来对Dapper进行下封装吧，然后结合&lt;a href=&quot;https://github.com/ericdc1/Dapper.SimpleCRUD&quot;&gt;Dapper.SimpleCRUD&lt;/a&gt; 来实现基本的增删改查、分页操作。这部分功能实现完成后，往下我们也就是基于这些基本操作来实现我们的CMS的业务了，如：权限部分，菜单部分，文章部分的功能。接下来我会对这部分快速的实现，可能会很少更新了，因为这些都是基本的CMS的业务操作，没多少要分享的内容，毕竟每个人的系统业务都不一样，这部分的业务实现也是千差万别的。我后期会把成品直接分享给大家！敬请关注吧！&lt;/p&gt;
&lt;h2 id=&quot;dapper的封装&quot;&gt;Dapper的封装&lt;/h2&gt;
&lt;h3 id=&quot;idbconnection工厂类的封装&quot;&gt;IDbConnection工厂类的封装&lt;/h3&gt;
&lt;p&gt;这部分我实现了一个IDbConnection的工厂类，以便你可以很方便的根据数据库的类型来创建不同的IDbConnection对象，目前已实现对SqlServer，MySQL，PostgreSQL的实现，具体代码如下，根据传入的参数来进行相关的实现。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;       /// &amp;lt;summary&amp;gt;
    /// yilezhu
    /// 2018.12.13
    /// 数据库连接工厂类
    /// &amp;lt;/summary&amp;gt;
    public class ConnectionFactory
    {
        /// &amp;lt;summary&amp;gt;
        /// 获取数据库连接
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dbtype&quot;&amp;gt;数据库类型&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;conStr&quot;&amp;gt;数据库连接字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;数据库连接&amp;lt;/returns&amp;gt;
        public static IDbConnection CreateConnection(string dbtype, string strConn)
        {
            if (dbtype.IsNullOrWhiteSpace())
                throw new ArgumentNullException(&quot;获取数据库连接居然不传数据库类型，你想上天吗？&quot;);
            if (strConn.IsNullOrWhiteSpace())
                throw new ArgumentNullException(&quot;获取数据库连接居然不传数据库类型，你想上天吗？&quot;);
            var dbType = GetDataBaseType(dbtype);
            return CreateConnection(dbType,strConn);
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取数据库连接
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dbType&quot;&amp;gt;数据库类型&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;conStr&quot;&amp;gt;数据库连接字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;数据库连接&amp;lt;/returns&amp;gt;
        public static IDbConnection CreateConnection(DatabaseType dbType, string strConn)
        {
            IDbConnection connection = null;           
            if (strConn.IsNullOrWhiteSpace())
                throw new ArgumentNullException(&quot;获取数据库连接居然不传数据库类型，你想上天吗？&quot;);
            
            switch (dbType)
            {
                case DatabaseType.SqlServer:
                    connection = new SqlConnection(strConn);
                    break;
                case DatabaseType.MySQL:
                    connection = new MySqlConnection(strConn);
                    break;
                case DatabaseType.PostgreSQL:
                    connection = new NpgsqlConnection(strConn);
                    break;
                default:
                    throw new ArgumentNullException($&quot;这是我的错，还不支持的{dbType.ToString()}数据库类型&quot;);

            }
            if (connection.State == ConnectionState.Closed)
            {
                connection.Open();
            }
            return connection;
        }

        /// &amp;lt;summary&amp;gt;
        /// 转换数据库类型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dbtype&quot;&amp;gt;数据库类型字符串&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;数据库类型&amp;lt;/returns&amp;gt;
        public static DatabaseType GetDataBaseType(string dbtype)
        {
            if (dbtype.IsNullOrWhiteSpace())
                throw new ArgumentNullException(&quot;获取数据库连接居然不传数据库类型，你想上天吗？&quot;);
            DatabaseType returnValue = DatabaseType.SqlServer;
            foreach (DatabaseType dbType in Enum.GetValues(typeof(DatabaseType)))
            {
                if (dbType.ToString().Equals(dbtype, StringComparison.OrdinalIgnoreCase))
                {
                    returnValue = dbType;
                    break;
                }
            }
            return returnValue;
        }

        
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，我们怎么来使用这个工厂类呢？如下给出调用的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214032095-1971777158.png&quot; alt=&quot;1545221995138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很简单，感觉瞬间少了很多代码，这段代码摘录自代码生成器里面。有兴趣的自己去查看源码吧！&lt;/p&gt;
&lt;h3 id=&quot;crud及分页泛型方法的实现&quot;&gt;CRUD及分页泛型方法的实现&lt;/h3&gt;
&lt;ol readability=&quot;46&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;nuget安装Dapper.SimpleCRUD ，什么你要问我怎么安装？乖乖的回去看第二篇文章吧！那里会教你如何安装Nuget包？如果那篇文章里面没有，那你就好好想想为啥没有呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214031830-1277999500.png&quot; alt=&quot;1545222273003&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;28&quot;&gt;
&lt;p&gt;新建IBaseRepository泛型接口 定义如下的增删改查方法的同步异步接口，其中还包含分页的实现，具体的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2018/12/16 20:41:22                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： Czar.Cms.Core.Repository                                   
*│　接口名称： IBaseRepository                                      
*└──────────────────────────────────────────────────────────────┘
*/
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Czar.Cms.Core.Repository
{
    public interface IBaseRepository&amp;lt;T,TKey&amp;gt; :  IDisposable where T : class
    {
        #region 同步
        /// &amp;lt;summary&amp;gt;
        /// 通过主键获取实体对象
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;主键ID&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        T Get(TKey id);
        /// &amp;lt;summary&amp;gt;
        /// 获取所有的数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IEnumerable&amp;lt;T&amp;gt; GetList();
        /// &amp;lt;summary&amp;gt;
        /// 执行具有条件的查询，并将结果映射到强类型列表
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;whereConditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IEnumerable&amp;lt;T&amp;gt; GetList(object whereConditions);
        /// &amp;lt;summary&amp;gt;
        /// 带参数的查询满足条件的数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IEnumerable&amp;lt;T&amp;gt; GetList(string conditions, object parameters = null);
        /// &amp;lt;summary&amp;gt;
        /// 使用where子句执行查询，并将结果映射到具有Paging的强类型List
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;pageNumber&quot;&amp;gt;页码&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;rowsPerPage&quot;&amp;gt;每页显示数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;查询条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;orderby&quot;&amp;gt;排序&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        IEnumerable&amp;lt;T&amp;gt; GetListPaged(int pageNumber, int rowsPerPage, string conditions, string orderby, object parameters = null);
        /// &amp;lt;summary&amp;gt;
        /// 插入一条记录并返回主键值(自增类型返回主键值，否则返回null)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        int? Insert(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 更新一条数据并返回影响的行数
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        int Update(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 根据实体主键删除一条数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;主键&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        int Delete(TKey id);
        /// &amp;lt;summary&amp;gt;
        /// 根据实体删除一条数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;实体&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;返回影响的行数&amp;lt;/returns&amp;gt;
        int Delete(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 条件删除多条记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;whereConditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;commandTimeout&quot;&amp;gt;超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        int DeleteList(object whereConditions, IDbTransaction transaction = null, int? commandTimeout = null);
        /// &amp;lt;summary&amp;gt;
        /// 使用where子句删除多个记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;wher子句&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;commandTimeout&quot;&amp;gt;超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        int DeleteList(string conditions, object parameters = null, IDbTransaction transaction = null, int? commandTimeout = null);
        /// &amp;lt;summary&amp;gt;
        /// 满足条件的记录数量
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        int RecordCount(string conditions = &quot;&quot;, object parameters = null);
        #endregion
        #region 异步
        /// &amp;lt;summary&amp;gt;
        /// 通过主键获取实体对象
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;主键ID&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;T&amp;gt; GetAsync(TKey id);
        /// &amp;lt;summary&amp;gt;
        /// 获取所有的数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync();
        /// &amp;lt;summary&amp;gt;
        /// 执行具有条件的查询，并将结果映射到强类型列表
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;whereConditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync(object whereConditions);
        /// &amp;lt;summary&amp;gt;
        /// 带参数的查询满足条件的数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync(string conditions, object parameters = null);
        /// &amp;lt;summary&amp;gt;
        /// 使用where子句执行查询，并将结果映射到具有Paging的强类型List
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;pageNumber&quot;&amp;gt;页码&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;rowsPerPage&quot;&amp;gt;每页显示数据&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;查询条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;orderby&quot;&amp;gt;排序&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListPagedAsync(int pageNumber, int rowsPerPage, string conditions, string orderby, object parameters = null);
        /// &amp;lt;summary&amp;gt;
        /// 插入一条记录并返回主键值
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;int?&amp;gt; InsertAsync(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 更新一条数据并返回影响的行数
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; UpdateAsync(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 根据实体主键删除一条数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;id&quot;&amp;gt;主键&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; DeleteAsync(TKey id);
        /// &amp;lt;summary&amp;gt;
        /// 根据实体删除一条数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;实体&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;返回影响的行数&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; DeleteAsync(T entity);
        /// &amp;lt;summary&amp;gt;
        /// 条件删除多条记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;whereConditions&quot;&amp;gt;条件&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;commandTimeout&quot;&amp;gt;超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; DeleteListAsync(object whereConditions, IDbTransaction transaction = null, int? commandTimeout = null);
        /// &amp;lt;summary&amp;gt;
        /// 使用where子句删除多个记录
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;wher子句&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;transaction&quot;&amp;gt;事务&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;commandTimeout&quot;&amp;gt;超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;影响的行数&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; DeleteListAsync(string conditions, object parameters = null, IDbTransaction transaction = null, int? commandTimeout = null);
        /// &amp;lt;summary&amp;gt;
        /// 满足条件的记录数量
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;conditions&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;parameters&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;int&amp;gt; RecordCountAsync(string conditions = &quot;&quot;, object parameters = null);
        #endregion
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;55&quot;&gt;
&lt;p&gt;然后创建一个BaseRepository泛型类来实现上面的接口，其中多了两个成员，DbOpion以及IDbConnection，猜猜看这两个东西有什么用？后面给出答案&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：仓储类的基类                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2018/12/16 12:03:02                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： Czar.Cms.Core.Repository                                   
*│　类    名： BaseRepository                                      
*└──────────────────────────────────────────────────────────────┘
*/
using Czar.Cms.Core.DbHelper;
using Czar.Cms.Core.Options;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using Dapper;

namespace Czar.Cms.Core.Repository
{
    public class BaseRepository&amp;lt;T, TKey&amp;gt; : IBaseRepository&amp;lt;T, TKey&amp;gt; where T : class
    {
        protected DbOpion _dbOpion;
        protected IDbConnection _dbConnection;

        //public BaseRepository(DbOpion dbOpion)
        //{
        //    _dbOpion = dbOpion ?? throw new ArgumentNullException(nameof(DbOpion));
        //    _dbConnection = ConnectionFactory.CreateConnection(_dbOpion.DbType, _dbOpion.ConnectionString);
        //}

        #region 同步

        public T Get(TKey id) =&amp;gt; _dbConnection.Get&amp;lt;T&amp;gt;(id);
        public IEnumerable&amp;lt;T&amp;gt; GetList() =&amp;gt; _dbConnection.GetList&amp;lt;T&amp;gt;();

        public IEnumerable&amp;lt;T&amp;gt; GetList(object whereConditions) =&amp;gt; _dbConnection.GetList&amp;lt;T&amp;gt;(whereConditions);

        public IEnumerable&amp;lt;T&amp;gt; GetList(string conditions, object parameters = null) =&amp;gt; _dbConnection.GetList&amp;lt;T&amp;gt;(conditions, parameters);

        public IEnumerable&amp;lt;T&amp;gt; GetListPaged(int pageNumber, int rowsPerPage, string conditions, string orderby, object parameters = null)
        {
            return _dbConnection.GetListPaged&amp;lt;T&amp;gt;(pageNumber, rowsPerPage, conditions, orderby, parameters);
        }
        public int? Insert(T entity) =&amp;gt; _dbConnection.Insert(entity);
        public int Update(T entity) =&amp;gt; _dbConnection.Update(entity);

        public int Delete(TKey id) =&amp;gt; _dbConnection.Delete&amp;lt;T&amp;gt;(id);

        public int Delete(T entity) =&amp;gt; _dbConnection.Delete(entity);
        public int DeleteList(object whereConditions, IDbTransaction transaction = null, int? commandTimeout = null)
        {
            return _dbConnection.DeleteList&amp;lt;T&amp;gt;(whereConditions, transaction, commandTimeout);
        }

        public int DeleteList(string conditions, object parameters = null, IDbTransaction transaction = null, int? commandTimeout = null)
        {
            return _dbConnection.DeleteList&amp;lt;T&amp;gt;(conditions, parameters, transaction, commandTimeout);
        }
        public int RecordCount(string conditions = &quot;&quot;, object parameters = null)
        {
            return _dbConnection.RecordCount&amp;lt;T&amp;gt;(conditions, parameters);
        }
        #endregion

        #region 异步
        public async Task&amp;lt;T&amp;gt; GetAsync(TKey id)
        {
            return await _dbConnection.GetAsync&amp;lt;T&amp;gt;(id);
        }

        public async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync()
        {
            return await _dbConnection.GetListAsync&amp;lt;T&amp;gt;();
        }

        public async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync(object whereConditions)
        {
            return await _dbConnection.GetListAsync&amp;lt;T&amp;gt;(whereConditions);
        }

        public async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListAsync(string conditions, object parameters = null)
        {
            return await _dbConnection.GetListAsync&amp;lt;T&amp;gt;(conditions, parameters);
        }
        public async Task&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt; GetListPagedAsync(int pageNumber, int rowsPerPage, string conditions, string orderby, object parameters = null)
        {
            return await _dbConnection.GetListPagedAsync&amp;lt;T&amp;gt;(pageNumber, rowsPerPage, conditions, orderby, parameters);
        }
        public async Task&amp;lt;int?&amp;gt; InsertAsync(T entity)
        {
            return await _dbConnection.InsertAsync(entity);
        }
        public async Task&amp;lt;int&amp;gt; UpdateAsync(T entity)
        {
            return await _dbConnection.UpdateAsync(entity);
        }
        public async Task&amp;lt;int&amp;gt; DeleteAsync(TKey id)
        {
            return await _dbConnection.DeleteAsync(id);
        }

        public async Task&amp;lt;int&amp;gt; DeleteAsync(T entity)
        {
            return await _dbConnection.DeleteAsync(entity);
        }


        public async Task&amp;lt;int&amp;gt; DeleteListAsync(object whereConditions, IDbTransaction transaction = null, int? commandTimeout = null)
        {
            return await _dbConnection.DeleteListAsync&amp;lt;T&amp;gt;(whereConditions, transaction, commandTimeout);
        }

        public async Task&amp;lt;int&amp;gt; DeleteListAsync(string conditions, object parameters = null, IDbTransaction transaction = null, int? commandTimeout = null)
        {
            return await DeleteListAsync(conditions, parameters, transaction, commandTimeout);
        }
        public async Task&amp;lt;int&amp;gt; RecordCountAsync(string conditions = &quot;&quot;, object parameters = null)
        {
            return await _dbConnection.RecordCountAsync&amp;lt;T&amp;gt;(conditions, parameters);
        }
        #endregion

        #region IDisposable Support
        private bool disposedValue = false; // 要检测冗余调用

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: 释放托管状态(托管对象)。
                }

                // TODO: 释放未托管的资源(未托管的对象)并在以下内容中替代终结器。
                // TODO: 将大型字段设置为 null。

                disposedValue = true;
            }
        }

        // TODO: 仅当以上 Dispose(bool disposing) 拥有用于释放未托管资源的代码时才替代终结器。
        // ~BaseRepository() {
        //   // 请勿更改此代码。将清理代码放入以上 Dispose(bool disposing) 中。
        //   Dispose(false);
        // }

        // 添加此代码以正确实现可处置模式。
        public void Dispose()
        {
            // 请勿更改此代码。将清理代码放入以上 Dispose(bool disposing) 中。
            Dispose(true);
            // TODO: 如果在以上内容中替代了终结器，则取消注释以下行。
            // GC.SuppressFinalize(this);
        }
        #endregion
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没看错？我在16号就已经写好了，为什么这么晚才写博客分享出来呢？因为我懒~~~~~~~&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这里需要注意，需要安装SimpleCRUD的Nuget包。另外其他的仓储方法只需要继承这个接口以及实现就能够实现基本的增删改查操作了。这里你应该会想，既然继承就能实现，那何不写一个仓储的代码生成器来进行生成呢？说干就干，下面我们就来实现仓储的代码生成器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;仓储层代码生成器&quot;&gt;仓储层代码生成器&lt;/h2&gt;
&lt;p&gt;上篇生成数据库实体的代码生成器不知道大家看了没有，这里我们只需要在根据每个数据库表生成数据库实体的实体顺带着生成下仓储接口以及仓储代码就可以了。有了思路，我们就撸起袖子加油干吧&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先写一下仓储接口代码生成器的模板，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214031560-724433180.png&quot; alt=&quot;1545225197161&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;再写一下仓储层的代码实现，这里需要注意一下，需要根据注入的IOptionsSnapshot来生成_dbOpion以及_dbConnection，上面留给大家的思考题答案就在这里，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：{Comment}接口实现                                                    
*│　作    者：{Author}                                            
*│　版    本：1.0    模板代码自动生成                                                
*│　创建时间：{GeneratorTime}                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： {RepositoryNamespace}                                  
*│　类    名： {ModelName}Repository                                      
*└──────────────────────────────────────────────────────────────┘
*/
using Czar.Cms.Core.DbHelper;
using Czar.Cms.Core.Options;
using Czar.Cms.Core.Repository;
using Czar.Cms.IRepository;
using Czar.Cms.Models;
using Microsoft.Extensions.Options;
using System;

namespace {RepositoryNamespace}
{
    public class {ModelName}Repository:BaseRepository&amp;lt;{ModelName},{KeyTypeName}&amp;gt;, I{ModelName}Repository
    {
        public {ModelName}Repository(IOptionsSnapshot&amp;lt;DbOpion&amp;gt; options)
        {
            _dbOpion =options.Get(&quot;CzarCms&quot;);
            if (_dbOpion == null)
            {
                throw new ArgumentNullException(nameof(DbOpion));
            }
            _dbConnection = ConnectionFactory.CreateConnection(_dbOpion.DbType, _dbOpion.ConnectionString);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接着就是代码生成器生成IRepository以及生成Repository的代码了！这部分代码如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214031197-587900852.png&quot; alt=&quot;1545225567381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214030783-1486498495.png&quot; alt=&quot;1545225578141&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;测试代码&quot;&gt;测试代码&lt;/h2&gt;
&lt;ol readability=&quot;21&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重新执行下代码生成器的代码，测试的具体代码我已经放在GitHub上了，这里就不贴出来了，直接上生成结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214030447-810940199.png&quot; alt=&quot;1545225741822&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;如上图所示：一次性生成了Models以及Repository，IRepository的代码，然后到每个文件夹里面把对应的代码拷贝到对应的项目里面吧。然后我们随便打开一下仓储以及仓储接口看下生成后的代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：文章分类                                                    
*│　作    者：yilezhu                                              
*│　版    本：1.0   模板代码自动生成                                              
*│　创建时间：2018-12-18 13:28:43                           
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： Czar.Cms.IRepository                                   
*│　接口名称： IArticleCategoryRepository                                      
*└──────────────────────────────────────────────────────────────┘
*/
using Czar.Cms.Core.Repository;
using Czar.Cms.Models;
using System;

namespace Czar.Cms.IRepository
{
    public interface IArticleCategoryRepository : IBaseRepository&amp;lt;ArticleCategory, Int32&amp;gt;
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：文章分类接口实现                                                    
*│　作    者：yilezhu                                            
*│　版    本：1.0    模板代码自动生成                                                
*│　创建时间：2018-12-18 13:28:43                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： Czar.Cms.Repository.SqlServer                                  
*│　类    名： ArticleCategoryRepository                                      
*└──────────────────────────────────────────────────────────────┘
*/
using Czar.Cms.Core.DbHelper;
using Czar.Cms.Core.Options;
using Czar.Cms.Core.Repository;
using Czar.Cms.IRepository;
using Czar.Cms.Models;
using Microsoft.Extensions.Options;
using System;

namespace Czar.Cms.Repository.SqlServer
{
    public class ArticleCategoryRepository:BaseRepository&amp;lt;ArticleCategory,Int32&amp;gt;, IArticleCategoryRepository
    {
        public ArticleCategoryRepository(IOptionsSnapshot&amp;lt;DbOpion&amp;gt; options)
        {
            _dbOpion =options.Get(&quot;CzarCms&quot;);
            if (_dbOpion == null)
            {
                throw new ArgumentNullException(nameof(DbOpion));
            }
            _dbConnection = ConnectionFactory.CreateConnection(_dbOpion.DbType, _dbOpion.ConnectionString);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在仓储层以及仓储接口层添加对Czar.Cms.Core的引用，当然你也可以通过Nuget包来进行安装&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package Czar.Cms.Core -Version 0.1.3&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;最后在测试代码中进行测试，这里以ArticleCategoryRepository为例进行测试：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Fact]
        public void TestBaseFactory()
        {
            IServiceProvider serviceProvider = BuildServiceForSqlServer();
            IArticleCategoryRepository categoryRepository = serviceProvider.GetService&amp;lt;IArticleCategoryRepository&amp;gt;();
            var category = new ArticleCategory
            {
                Title = &quot;随笔&quot;,
                ParentId = 0,
                ClassList = &quot;&quot;,
                ClassLayer = 0,
                Sort = 0,
                ImageUrl = &quot;&quot;,
                SeoTitle = &quot;随笔的SEOTitle&quot;,
                SeoKeywords = &quot;随笔的SeoKeywords&quot;,
                SeoDescription = &quot;随笔的SeoDescription&quot;,
                IsDeleted = false,
            };
            var categoryId = categoryRepository.Insert(category);
            var list = categoryRepository.GetList();
            Assert.True(1 == list.Count());
            Assert.Equal(&quot;随笔&quot;, list.FirstOrDefault().Title);
            Assert.Equal(&quot;SQLServer&quot;, DatabaseType.SqlServer.ToString(), ignoreCase: true);
            categoryRepository.Delete(categoryId.Value);
            var count = categoryRepository.RecordCount();
            Assert.True(0 == count);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试结果如下所示，都已经测试成功了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214030192-1753432382.png&quot; alt=&quot;1545226136210&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;开原地址&quot;&gt;开原地址&lt;/h2&gt;
&lt;p&gt;这个系列教程的源码我会开放在GitHub以及码云上，有兴趣的朋友可以下载查看！觉得不错的欢迎Star&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/yilezhu/Czar.Cms&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/Czar.Cms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;码云：&lt;a href=&quot;https://gitee.com/yilezhu/Czar.Cms&quot; class=&quot;uri&quot;&gt;https://gitee.com/yilezhu/Czar.Cms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得这个系列对您有所帮助的话，欢迎以各种方式进行赞助，当然给个Star支持下也是可以滴！另外一种最简单粗暴的方式就是下面这种直接关注我们的公众号了： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181219214028999-969376684.png&quot; alt=&quot;img&quot;/&gt; &lt;/p&gt;
&lt;p&gt;第一时间收到更新推送。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一路走来，已经更新到第十二篇了，到这里大伙已经可以基于这个Dapper的封装进行自己的业务系统的开发了！当然接下来我会继续完成我们既定的CMS系统的业务功能开发，接下来可以用来分享的东西就很少了，所以我更多的是开发然后把代码更新到GitHub以及码云上，想看最新的代码就获取dev分支的代码，有问题的可以提issue或者群里讨论！敬请期待吧！&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 13:42:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>本篇我将带着大家一起来对Dapper进行下封装并实现基本的增删改查、分页操作的同步异步方法的实现（已实现MSSQL，MySql，PgSQL）。同时我们再实现一下仓储层的代码生成器，这样的话，我们只需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10146311.html</dc:identifier>
</item>
<item>
<title>.netcore 堆栈调用方法小记 - 范存威</title>
<link>http://www.cnblogs.com/fancunwei/p/10146151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/10146151.html</guid>
<description>&lt;p&gt;上午临近午饭时，公司同事反馈验证码被攻击灌水。我们匆忙查询验证码明细，对已频繁出现的IP插入黑名单，但IP仍然隔断时间频繁变动，不得已之下只能先封禁对应公司id的验证码发送功能。年初时候，专门对SSO站点的发送验证码升级到极验的验证，已经杜绝了普通的攻击，没想到没升级的这个系统又遭受洗礼...&lt;/p&gt;

&lt;p&gt;防灌水通用解决办法一般有几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ip+手机号限制&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;频繁变化ip和手机号时，此办法无效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;发送验证码页面端提供简单图形验证码&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;能解决部分攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;采取12306图片库或极验等复杂手段&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;能解决大部分攻击，但超过一定频率需要收费&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于调用发送验证码的方法非常多，在这个方法内只能定位到IP和手机号，定位不到Web层具体的Action,在此过程中了解到&lt;a href=&quot;https://www.cnblogs.com/huangtailang/p/4550177.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/huangtailang/p/4550177.html&lt;/a&gt;所提到的System.Diagnostics.StackTrace和System.Diagnostics.StackFrame定位到方法上层调用堆栈。然后就顺腾摸瓜把漏掉图形验证码的常用页面先补上，不常用的页面改掉发送接口。处理细节不再细述，只记录下Diagnostics的相关信息。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们定义一些代码来演示效果：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;
 &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;First
    {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-built_in&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;Start&lt;span class=&quot;hljs-params&quot;&gt;()
        {
           &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new Second().Start();
        }
    }

 &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Second
    {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-built_in&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;Start&lt;span class=&quot;hljs-params&quot;&gt;()
        {
          &lt;span class=&quot;hljs-keyword&quot;&gt;return  &lt;span class=&quot;hljs-keyword&quot;&gt;new Third().Start();
        }
    }

 &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Third
    {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-built_in&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;Start&lt;span class=&quot;hljs-params&quot;&gt;()
        {
            var msg = Utils.GetStackTraceModelName();
            &lt;span class=&quot;hljs-keyword&quot;&gt;return msg;
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Web层调用First.Start&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HomeController : Controller
    {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;Start&lt;span class=&quot;hljs-params&quot;&gt;()
        {
            var msg = &lt;span class=&quot;hljs-keyword&quot;&gt;new First().Start();
            &lt;span class=&quot;hljs-keyword&quot;&gt;return Content(msg);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问结果如下：&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Web&lt;span class=&quot;hljs-selector-class&quot;&gt;.Controllers&lt;span class=&quot;hljs-selector-class&quot;&gt;.HomeController&lt;span class=&quot;hljs-selector-class&quot;&gt;.Start()
&lt;span class=&quot;hljs-selector-tag&quot;&gt;-&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Venus&lt;span class=&quot;hljs-selector-class&quot;&gt;.Common&lt;span class=&quot;hljs-selector-class&quot;&gt;.First&lt;span class=&quot;hljs-selector-class&quot;&gt;.Start()
&lt;span class=&quot;hljs-selector-tag&quot;&gt;-&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Venus&lt;span class=&quot;hljs-selector-class&quot;&gt;.Common&lt;span class=&quot;hljs-selector-class&quot;&gt;.Second&lt;span class=&quot;hljs-selector-class&quot;&gt;.Start()
&lt;span class=&quot;hljs-selector-tag&quot;&gt;-&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Venus&lt;span class=&quot;hljs-selector-class&quot;&gt;.Common&lt;span class=&quot;hljs-selector-class&quot;&gt;.Third&lt;span class=&quot;hljs-selector-class&quot;&gt;.Start()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个调用信息是由Third.Start记录，可见能追踪到完整的调用链。这只是简单的演示，如更复杂的交叉调用，异步、并行等的并未在这里实践。&lt;/p&gt;

&lt;p&gt;以上方法适用于.netFramework和.netCore,可用于做日志记录，调用链等行为。&lt;br/&gt;asp.netcore里也有Microsoft.AspNetCore.Diagnostics，&lt;a href=&quot;https://www.cnblogs.com/linezero/p/Diagnostics.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linezero/p/Diagnostics.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;略作总结，本篇结束，那帮闲的蛋疼乱搞攻击的人，折腾了我一天。虽然已经禁了他们发送验证码，但还是一直在发请求，头疼ying....留个念头以待以后深思。&lt;/p&gt;
&lt;p&gt;安全和防护依然是重中之重啊！&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huangtailang/p/4550177.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/huangtailang/p/4550177.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 13:15:00 +0000</pubDate>
<dc:creator>范存威</dc:creator>
<og:description>背景 上午临近午饭时，公司同事反馈验证码被攻击灌水。我们匆忙查询验证码明细，对已频繁出现的IP插入黑名单，但IP仍然隔断时间频繁变动，不得已之下只能先封禁对应公司id的验证码发送功能。年初时候，专门对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/10146151.html</dc:identifier>
</item>
</channel>
</rss>