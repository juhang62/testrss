<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python 爬虫（30）：代理基础 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12117899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12117899.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191230084347107-1209867828.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/03/819896244/&quot;&gt;小白学 Python 爬虫（12）：urllib 基础使用（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/04/2992515886/&quot;&gt;小白学 Python 爬虫（13）：urllib 基础使用（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/05/104488944/&quot;&gt;小白学 Python 爬虫（14）：urllib 基础使用（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/07/2788855167/&quot;&gt;小白学 Python 爬虫（15）：urllib 基础使用（五）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/09/1691033431/&quot;&gt;小白学 Python 爬虫（16）：urllib 实战之爬取妹子图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/10/1910005577/&quot;&gt;小白学 Python 爬虫（17）：Requests 基础使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/11/1468953802/&quot;&gt;小白学 Python 爬虫（18）：Requests 进阶操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/12/3568648672/&quot;&gt;小白学 Python 爬虫（19）：Xpath 基操&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/13/2569867940/&quot;&gt;小白学 Python 爬虫（20）：Xpath 进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/15/2789385418/&quot;&gt;小白学 Python 爬虫（21）：解析库 Beautiful Soup（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/16/876770087/&quot;&gt;小白学 Python 爬虫（22）：解析库 Beautiful Soup（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/17/876770088/&quot;&gt;小白学 Python 爬虫（23）：解析库 pyquery 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/18/1275791678/&quot;&gt;小白学 Python 爬虫（24）：2019 豆瓣电影排行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/19/1066903974/&quot;&gt;小白学 Python 爬虫（25）：爬取股票信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/20/788803015/&quot;&gt;小白学 Python 爬虫（26）：为啥买不起上海二手房你都买不起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/22/151891020/&quot;&gt;小白学 Python 爬虫（27）：自动化测试框架 Selenium 从入门到放弃（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/24/1100772905/&quot;&gt;小白学 Python 爬虫（28）：自动化测试框架 Selenium 从入门到放弃（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/25/7469407721/&quot;&gt;小白学 Python 爬虫（29）：Selenium 获取某大型电商网站商品信息&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;我们在使用爬虫的时候，经常遇到一种情况，刚开始的运行的时候，都如丝般顺滑，可能一杯茶的功夫，就完犊子了，可能会出现各种各样的限制，比如 403 Forbidden 、 429 Too Many Request 等等。&lt;/p&gt;
&lt;p&gt;这时候，很有可能就是我们的 IP 被限制了。&lt;/p&gt;
&lt;p&gt;出现以上问题一般是因为网站的安全限制或者是机房的安全限制，有时候实在服务器上做检测，有时候是在网关处做检测，一旦发现某个 IP 在单位时间内的访问次数超过了当前限定的某个阀值，就会直接拒绝服务，这种情况我们统称为：&lt;strong&gt;封 IP&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;对于上面这种情况难道我们就这么认了么，当然不！&lt;/p&gt;
&lt;p&gt;代理就是为了解决这个问题的。&lt;/p&gt;
&lt;p&gt;代理解决上面这个问题的方式就是请求中间增加的代理服务器做转发，本来请求是由 A 直接访问到服务器 C 的，如： A -&amp;gt; C ，加了代理 B 之后就变成了这个样子： A -&amp;gt; B -&amp;gt; C 。&lt;/p&gt;
&lt;h2 id=&quot;代理的获取&quot;&gt;代理的获取&lt;/h2&gt;
&lt;p&gt;在做实战之前，我们先了解下如何获取代理。&lt;/p&gt;
&lt;p&gt;首先在百度上输入 “代理” 两个字进行查询，可以看到有很多提供代理服务的网站，当然哈，大多数都是收费的。但是其中不乏会有一部分免费的代理。&lt;/p&gt;
&lt;p&gt;当然免费的代理会有各种各样的坑，比如经常性连不通，比如网络延迟非常高等等等等。&lt;/p&gt;
&lt;p&gt;但是，人家免费啊，还要啥自行车。&lt;/p&gt;
&lt;p&gt;当然如果想要获得稳定的、网络延时低的代理服务，建议付费使用，毕竟用的少也花不了多少钞票。&lt;/p&gt;
&lt;p&gt;代理的站点小编就不列举了，是在太多，我们随便打开一个免费代理的网站：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191230084347816-1940839103.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，代理好像分两种，一种是高匿代理，还有一种是透明代理，这两个有什么区别呢？&lt;/p&gt;
&lt;p&gt;其实，除了高匿代理和透明代理以外，还有一种中间形态叫做匿名代理。&lt;/p&gt;
&lt;p&gt;这几种代理之间的区别在于转发请求的头部参数不同。&lt;/p&gt;
&lt;h3 id=&quot;透明代理&quot;&gt;透明代理&lt;/h3&gt;
&lt;p&gt;目标服务器可以知道我们使用了代理，并且也知道我们的真实 IP 。 透明代理访问目标服务器所带的 HTTP 头信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REMOTE_ADDR = 代理服务器IP&lt;/li&gt;
&lt;li&gt;HTTP_VIA = 代理服务器IP&lt;/li&gt;
&lt;li&gt;HTTP_X_FORWARDED_FOR = 我们的真实IP&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;透明代理还是将我们的真实IP发送给了对方服务器，因此无法达到隐藏身份的目的。&lt;/p&gt;
&lt;h3 id=&quot;匿名代理&quot;&gt;匿名代理&lt;/h3&gt;
&lt;p&gt;目标服务器可以知道我们使用了代理，但不知道我们的真实 IP 。匿名代理访问目标服务器所带的 HTTP 头信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REMOTE_ADDR = 代理服务器IP&lt;/li&gt;
&lt;li&gt;HTTP_VIA = 代理服务器IP&lt;/li&gt;
&lt;li&gt;HTTP_X_FORWARDED_FOR = 代理服务器IP&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;匿名代理隐藏了我们的真实IP，但是向目标服务器透露了我们是使用代理服务器访问他们的。&lt;/p&gt;
&lt;h3 id=&quot;高匿代理&quot;&gt;高匿代理&lt;/h3&gt;
&lt;p&gt;目标服务器不知道我们使用了代理，更不知道我们的真实 IP 。高匿代理访问目标服务器所带的 HTTP 头信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REMOTE_ADDR = 代理服务器IP&lt;/li&gt;
&lt;li&gt;HTTP_VIA 不显示&lt;/li&gt;
&lt;li&gt;HTTP_X_FORWARDED_FOR 不显示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;高匿代理隐藏了我们的真实 IP ，同时目标服务器也不知道我们使用了代理，因此隐蔽度最高。&lt;/p&gt;
&lt;p&gt;可以看到，处于中间态的匿名代理，事情做了一半没做完，反而是没什么用武之地的。&lt;/p&gt;
&lt;h2 id=&quot;代理设置&quot;&gt;代理设置&lt;/h2&gt;
&lt;p&gt;上面我们看到了一些代理服务，接下来我们看一下各种 HTTP 请求库设置代理的方式：&lt;/p&gt;
&lt;h3 id=&quot;urllib&quot;&gt;urllib&lt;/h3&gt;
&lt;p&gt;我们先使用 urllib 来做测试，测试的链接就选择：&lt;a href=&quot;https://httpbin.org/get&quot; class=&quot;uri&quot;&gt;https://httpbin.org/get&lt;/a&gt; 这个我们之前用过的测试链接，访问该站点可以得到请求的一些相关信息，其中 origin 字段就是请求来源的 IP，我们可以根据它来判断代理是否设置成功，也就是是否成功伪装了 IP ，代理嘛小编就在网上随便找了个免费的高匿代理，示例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from urllib.error import URLError
from urllib.request import ProxyHandler, build_opener

proxy_handler = ProxyHandler({
    'http': 'http://182.34.37.0:9999',
    'https': 'https://117.69.150.84:9999'
})
opener = build_opener(proxy_handler)
try:
    response = opener.open('https://httpbin.org/get')
    print(response.read().decode('utf-8'))
except URLError as e:
    print(e.reason)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单，我们看下执行结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept-Encoding&quot;: &quot;identity&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;
  }, 
  &quot;origin&quot;: &quot;117.69.150.84, 117.69.150.84&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，目标服务器已经认为我们是由代理访问的了， origin 参数显示的是我们的代理服务器的 IP 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里我们使用了 ProxyHandler 来进行代理设置，ProxyHandler 的参数类型是字典类型， key 是我们使用的协议，而值是我们具体所使用的代理，小编这里设置了两个代理，一个是 http 的还有一个是 https 的，当我们请求的链接是 http 的会自动的选择我们的 http 的代理，当我们的请求的链接是 https 的时候则会自动的选择我们设置的 https 的代理。&lt;/p&gt;
&lt;h3 id=&quot;requests&quot;&gt;Requests&lt;/h3&gt;
&lt;p&gt;对于 Requests 来讲，代理的设置更加的简单加直白。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests

proxies = {
    'http': 'http://59.52.186.117:9999',
    'https': 'https://222.95.241.6:3000',
}
try:
    response = requests.get('https://httpbin.org/get', proxies = proxies)
    print(response.text)
except requests.exceptions.ConnectionError as e:
    print('Error', e.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.22.0&quot;
  }, 
  &quot;origin&quot;: &quot;222.95.241.6, 222.95.241.6&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小编这里选择的还是高匿代理，所以这里显示出来的 IP 还是我们代理的 IP 。&lt;/p&gt;
&lt;h3 id=&quot;selenium&quot;&gt;Selenium&lt;/h3&gt;
&lt;p&gt;Selenium 同样可以设置代理，同时也非常简单，示例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver

proxy = '222.95.241.6:3000'
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--proxy-server=https://' + proxy)
driver = webdriver.Chrome(chrome_options=chrome_options)
driver.get('https://httpbin.org/get')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191230084348374-1745010186.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置 FireFox 浏览器和设置 Chrome 浏览器近乎一样，唯一的区别就是在初始化的时候初始化一个 FireFox ，并且在这是启动参数的是时候使用 &lt;code&gt;FirefoxOptions()&lt;/code&gt; 方法，其他的无任何区别，同学们可以自己尝试下。&lt;/p&gt;
&lt;h2 id=&quot;免费代理&quot;&gt;免费代理&lt;/h2&gt;
&lt;p&gt;因为免费代理的连通率和稳定性确实不高，小编这里找了几个免费代理的网站，仅供大家参考使用：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ip3366.net/&quot; class=&quot;uri&quot;&gt;http://www.ip3366.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kuaidaili.com/free/&quot; class=&quot;uri&quot;&gt;https://www.kuaidaili.com/free/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.xicidaili.com/&quot; class=&quot;uri&quot;&gt;https://www.xicidaili.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/proxy-set-demo&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/proxy-set-demo&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bb00a288ee5f&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/bb00a288ee5f&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： &amp;quot;小白学 Python 爬虫（1）：开篇&amp;quot; &amp;quot;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&amp;quot; &amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12117899.html</dc:identifier>
</item>
<item>
<title>Python的内存管理机制 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/12117900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/12117900.html</guid>
<description>&lt;p&gt;任何编程语言都会有一个内存模型，以便管理为变量分配的内存空间。不同的编程语言，如C、C++、Java、C#，Python，它们的内存模型都是不相同的，本文将以现在最流行的Python语言为例，来说明动态类型语言的内存管理方式。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 重复使用内存空间&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;赋值语句是Python语言中最简单的语句之一，虽然赋值语言很简单，但却内含玄机。&lt;/p&gt;&lt;p&gt;整数1是一个值，而n是一个对象。这是最简单不过的赋值语句了。那么在内存中是如何操作的呢？其实在Python中，任何值都可以看做是一个对象，例如，1是int类的实例，True是bool类的实例。所以将1赋给变量n，其实是n指向了int类型的对象，所以n本质上就是一个对象的引用。&lt;/p&gt;&lt;p&gt;Python作为动态语言，采用了引用与对象分离的策略，这也使得任何引用都可以指向任何对象，而且可以动态改变引用指向的对象类型，也就是说，可以将一个指向int类型的对象的引用重新指向bool类型的对象。所以可以将Python语言的对象模型看做是超市里的储物柜（这里只是用储物柜作为内存模型的比喻，不要与超市储物柜实际的操作进行比较）。&lt;/p&gt;&lt;div readability=&quot;142.5&quot;&gt;
&lt;p&gt;每一个小柜子相当于一块内存区域，这块内存区域保存了不同类型的值。对于像C++、Java一样的静态语言，一旦分配了某一个小柜子，就意味着这个柜子只能保存特定的物品，如只能放鞋子、只能放手套、只能放衣服。而对于打开小柜子的钥匙（相当于变量），同时也只能打开某一个特定的小柜子，相当于一个变量同时只能指向一个对象一样。当然，在钥匙上进行设置后，该钥匙可以指向其他同类型的小柜子（相当于改变变量指向的对象，如将一个指向int类型对象的变量指向了另外一个int类型的对象）。&lt;/p&gt;

&lt;p&gt;不过Python语言就不一样了。在Python版的储物柜中，每一个小柜子并不限定存储物品的类型，而一把钥匙经过设置后，可以打开任意一个小柜子（相当于任意改变变量指向的对象）。这样做的好处是更灵活，没必要为存储特定的物品，增加新的储物柜，只要还有空的小柜子，就可以放任何物品。但缺点也很明显，就是打开一个小柜子后，需要多进行一步判断的操作，判断这个小柜子到底是存储的什么物品。&lt;/p&gt;

&lt;p&gt;当然，对于同一个特定的小柜子，可能会配有多把钥匙，这些钥匙都可以打开这个特定的小柜子，这就相当于多个变量指向同一个对象。例如，&lt;/p&gt;

&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
x = 10&lt;span&gt;
y &lt;/span&gt;= 10&lt;span&gt;
z &lt;/span&gt;= 10
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;x、y和z三个变量的值都是10，这个10就相当于要保存在小柜子中的物品。x、y和z相当于3把钥匙。而3个变量中的值都是10，所以被认为是同一个值（物品），因此，就只需要动用一个小柜子保存10，而3个变量都会指向这个小柜子（由于计算机中值具有无限可复制性，所以只要有一个物品，就可以无限复制，所以不必考虑现实中将小柜子中的东西拿走了就为空的情况）。所以其实x、y和z这3个变量指向了同一个内存地址（相当于小柜子的序号）。可以用id函数验证这3个变量的内存地址是否相同，代码如下：&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(x))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(y))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(z))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;p&gt;4470531424&lt;/p&gt;
&lt;p&gt;4470531424&lt;/p&gt;
&lt;p&gt;4470531424&lt;/p&gt;

&lt;p&gt;也可以用下面的代码将内存地址转换为十六进制形式。&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(hex(id(x)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(hex(id(y)))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(hex(id(z)))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;0x10a76e560&lt;/p&gt;
&lt;p&gt;0x10a76e560&lt;/p&gt;
&lt;p&gt;0x10a76e560&lt;/p&gt;

&lt;p&gt;根据前面的输出结果，很显然，x、y和z指向的是同一个内存地址。读者可以将10换成其他的对象，如True、10.12、&quot;hello world&quot;，结果都是一样（由于机器不同，输出的内存地址可能不同，但3个变量的内存地址肯定都是相同的）。&lt;/p&gt;

&lt;p&gt;也可以用is运算符判断这3个变量是否指向同一个值。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(x &lt;span&gt;is&lt;/span&gt; y &lt;span&gt;is&lt;/span&gt; z) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但要注意，只有不可变类型，如int、float、bool、string等，才会使用同一个储物柜。如果是可变类型，如列表、对象，每次都会分配新的内存空间。这里的不可变是指值一旦确定，值本身无法修改。例如int类型的10，这个10是固定的，不能修改，如果修改成11，那么就是新的值了，需要申请新的小柜子。而列表，如空列表[]，以后还可以向空列表中添加任何类型的值，也可以修改和删除列表中的值。所以没有办法为所有的空列表分配同一个小柜子，因为有的空列表，现在是空，以后不一定是空。所以每一个列表类型的值都会新分配一个小柜子，但元组就不同了，由于元组是只读的，所以一开始是空的元组，那么这个元组今生今世将永远是空，所以可以为所有的空元组，以及所有相同元素个数和值的元组分配同一个小柜子。看下面代码：&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass:
&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
a &lt;/span&gt;=&lt;span&gt; []
b &lt;/span&gt;=&lt;span&gt; []
c &lt;/span&gt;=&lt;span&gt; MyClass()
d &lt;/span&gt;=&lt;span&gt; MyClass()
t1 &lt;/span&gt;= (1,2,3&lt;span&gt;)
t2 &lt;/span&gt;= (1,2,3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a &lt;span&gt;is&lt;/span&gt; b) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False 元素个数和类型相同的列表不会使用同一个内存空间（小柜子）&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(c &lt;span&gt;is&lt;/span&gt; d) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False MyClass类的不同实例不会使用同一个内存空间（小柜子）&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(t1 &lt;span&gt;is&lt;/span&gt; t2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True 元素个数和类型相同的元组会使用同一个内存空间（小柜子）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这种将相同，但不可变的值保存在同一个内存空间的方式也称为值的缓存，这样做非常节省内存空间，而且程序的执行效率更高。因为省去了大量分配内存空间的时间。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 引用计数器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在Python语言中是无法自己释放变量内存的，所以Python虚拟机提供了自动回收内存的机制，那么Python虚拟机是如何知道哪一个变量占用的内存可以被回收呢？通常的做法是为每一块被占用的内存设置一个引用计数器，如果该内存块没有被任何变量引用（也就是引用计数器为0），那么该内存块就可以被释放，否则无法被释放。&lt;/p&gt;

&lt;p&gt;在sys模块中有一个getrefcount函数，可以用来获取任何变量指向的内存块的引用计数器当前的值。用法如下：&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
 
a &lt;/span&gt;= [1, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(a)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出2&lt;/span&gt;
&lt;span&gt; 
b &lt;/span&gt;=&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(b)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出3&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(getrefcount(a)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出3&lt;/span&gt;
&lt;span&gt; 
x &lt;/span&gt;= 1
&lt;span&gt;print&lt;/span&gt;(getrefcount(x)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出1640&lt;/span&gt;
y = 1
&lt;span&gt;print&lt;/span&gt;(getrefcount(x)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出1641&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(getrefcount(y)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出1641&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;要注意，使用getrefcount函数获得引用计数器的值时，实际上会创建一个临时的引用，所以getrefcount函数返回的值会比实际的值多1。而对于具体的值（如本例的1），系统可能在很多地方都引用了该值，所以根据Python版本和当前运行的应用不同，getrefcount函数返回的值是不确定的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 对象引用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;像C++这样的编程语言，对象的传递分为值传递和指针传递。如果是值传递，就会将对象中的所有成员属性的值都一起复制，而指针传递，只是复制了对象的内存首地址。不过在Python中，并没有指针的概念。只有一个对象引用。也就是说，Python语言中对象的复制与C++中的对象指针复制是一样的。只是将对象引用计数器加1而已。具体看下面的代码：&lt;/p&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类的构造方法传入另外一个对象的引用&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(object):
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, other_obj):
self.other_obj &lt;/span&gt;= other_obj &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的other_obj与后面的data指向了同一块内存地址&lt;/span&gt;
&lt;span&gt; 
data &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:30&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(data)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出2&lt;/span&gt;
my =&lt;span&gt; MyClass(data)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(my.other_obj)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出4364264288&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(id(data)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出4364264288&lt;/span&gt;
 
&lt;span&gt;print&lt;/span&gt;(getrefcount(data)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
 &lt;/div&gt;
&lt;p&gt;在Python中，一切都是对象，包括值。如1、2、3、&quot;abcd&quot;等。所以Python会在使用这些值时，先将其保存在一块固定的内存区域，然后将所有赋给这些值的变量指向这块内存区域，同时引用计数器加1。&lt;/p&gt;

&lt;p&gt;例如，&lt;/p&gt;
&lt;p&gt;a = 1&lt;/p&gt;
&lt;p&gt;b = 1&lt;/p&gt;

&lt;p&gt;其中a和b指向了同一块内存空间，这两个变量其实都保存了对1的引用。使用id函数查看这两个变量的引用地址是相同的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 循环引用与拓扑图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果对象引用非常多，就可能会构成非常复杂的拓扑结果。例如，下面代码的引用拓扑关系就非常复杂。估计大多数同学都无法一下子看出这段程序中各个对象的拓扑关系。&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass1:
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, obj):
self.obj &lt;/span&gt;=&lt;span&gt; obj
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass2:
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,obj1,obj2):
self.obj1 &lt;/span&gt;=&lt;span&gt; obj1
self.obj2 &lt;/span&gt;=&lt;span&gt; obj2
 
data1 &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
data2 &lt;/span&gt;= [data1, MyClass1(data1),3,dict(data =&lt;span&gt; data1)]
data3 &lt;/span&gt;= [data1,data2,MyClass2(data1,data2),MyClass1(MyClass2(data1,data2))]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;看不出来也不要紧，可以使用objgraph模块绘制出某个变量与其他变量的拓扑关系，objgraph是第三方模块，需要使用pip install objgraph命令安装，如果机器上安装了多个Python环境，要注意看看pip命令是否属于当前正在使用的Python环境，不要将objgraph安装在其他的Python环境中。&lt;/p&gt;

&lt;p&gt;安装完objgraph后，可以使用下面命令看看data3与其他对象的引用关系。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; objgraph
objgraph.show_refs([data3], filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;对象引用关系.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;show_refs函数会在当前目录下生成一个”对象引用关系.png“的图像文件，如下图所示。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230083527058-1379214742.png&quot; alt=&quot;&quot; width=&quot;994&quot; height=&quot;595&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;128&quot;&gt;
&lt;p&gt;如果对象之间互相引用，有可能会形成循环引用。也就是a引用b，b引用a，见下面的代码。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; objgraph
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
a &lt;/span&gt;=&lt;span&gt; {}
b &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:a}
a[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; b
objgraph.show_refs([b], filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;循环引用1.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在这段代码中。a和b都是一个字典，b中的一个value引用了a，而a的一个value引用了b，所以产生了一个循环引用。这段代码的引用拓扑图如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230084611113-407613816.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/C63AAC87A981481AA48319444FA891D3&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;很明显，这两个字典是循环引用的。&lt;/p&gt;
&lt;p&gt;不光是多个对象之间的引用可以产生循环引用，只有一个对象也可以产生循环引用，代码如下：&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
a =&lt;span&gt; {}
a[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; a
a &lt;/span&gt;=&lt;span&gt; []
a.append(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(getrefcount(a))
objgraph.show_refs([a], filename&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;循环引用2.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在这段代码中，字典a的一个值是自身，拓扑图如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230084620750-1010504531.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/7B923FB34DAD42CDBE0EDFA196444AB1&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 减少引用计数的两种方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面一直说让引用计数器增加的方法，那么如何让引用计数器减少呢？通常有如下两种方法：&lt;/p&gt;
&lt;p&gt;（1）用del删除某一个引用&lt;/p&gt;
&lt;p&gt;（2）将变量指向另外一个引用，或设置为None，也就是引用重定向。&lt;/p&gt;


&lt;p&gt;（1）用del删除某一个引用&lt;/p&gt;

&lt;p&gt;del语句可以删除一个变量对某一个块内存空间的引用，也可以删除集合对象中的某个item，代码如下：&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
 
person &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:40&lt;span&gt;}
person1 &lt;/span&gt;=&lt;span&gt; person
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(person1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出3&lt;/span&gt;
 
&lt;span&gt;del&lt;/span&gt; person &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除person对字典的引用&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(getrefcount(person1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于引用少了一个，所以输出为2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(person) # 抛出异常 # 被删除的变量相当于重来没定义过，所以这条语句会抛出异常&lt;/span&gt;
 
&lt;span&gt;del&lt;/span&gt; person1[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除字典中key为age的值对&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(person1)
&lt;/pre&gt;&lt;/div&gt;
 &lt;/div&gt;
&lt;p&gt;（2）引用重定向&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
 
value1 &lt;/span&gt;= [1,2,3,4&lt;span&gt;]
value2 &lt;/span&gt;=&lt;span&gt; value1
value3 &lt;/span&gt;=&lt;span&gt; value2
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(value2)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出4&lt;/span&gt;
value1 = 20
&lt;span&gt;print&lt;/span&gt;(getrefcount(value2)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出3，因为value1重新指向了20&lt;/span&gt;
value3 =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(getrefcount(value2)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出2，因为value3被设置为None，也就是不指向任何内存空间，相当于空指针&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 垃圾回收&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;像Java、JavaScript、Python这样的编程语言，都不允许直接通过代码释放变量占用的内存，虚拟机会自动释放这些内存区域。所以很多程序员就会认为在这些语言中可以放心大胆地申请各种类型的变量，并不用担心变量的释放问题，因为系统会自动替我们完成这些烦人的工作。&lt;/p&gt;

&lt;p&gt;没错，这些语言的虚拟机会自动释放一些不需要的内存块，用专业术语描述就是：垃圾回收。 相当于为系统减肥或减负。因为不管你的计算机有多少内存，只要不断创建新的变量，哪怕该变量只占用了1个字节的内存空间，内存也有用完的一天。所以虚拟机会在适当的时候释放掉不需要的内存块。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230083941032-1433046840.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/9F7AC24A3BAD4541A04521830356EAF5&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在前面已经提到过，虚拟机会回收引用计数为0的内存块，因为这些内存块没有任何变量指向他们，所以留着没有任何意义。那么到底虚拟机在什么时候才会回收这些内存块呢？通常来讲，虚拟机会设置一个内存阈值，一旦超过了这个阈值，就会自动启动垃圾回收器来回收不需要的内存空间。对于不同编程语言的这个阈值是不同的。对于Python来说，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。&lt;/p&gt;

&lt;p&gt;我们可以通过gc模块的get_threshold()方法，查看该阈值:&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gc
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(gc.get_threshold())
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;输出的结果为：&lt;/p&gt;
&lt;p&gt;(700, 10, 10)&lt;/p&gt;

&lt;p&gt;这个700就是这个阈值。后面的两个10是与分代回收相关的阈值，后面会详细介绍。可以使用gc模块中的set_threshold方法设置这个阈值。&lt;/p&gt;

&lt;p&gt;由于垃圾回收是一项昂贵的工作，所以如果计算机的内存足够大，可以将这个阈值设置的大一点，这样可以避免垃圾回收器频繁调用。&lt;/p&gt;

&lt;p&gt;当然，如果觉得必要，也可以使用下面的代码手工启动垃圾回收器。不过要注意，手工启动垃圾回收器后，垃圾回收器也不一定会立刻启动，通常会在系统空闲时启动垃圾回收器。&lt;/p&gt;

&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gc.collect()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 变量不用了要设置为None&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;有大量内存被占用，是一定要被释放的。但释放这些内存有一个前提条件，就是这个内存块不能有任何变量引用，也就是引用计数器为0。如果有多个变量指向同一个内存块，而且有一些变量已经不再使用了，一个好的习惯是将变量设置为None，或用del删除该变量。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
person = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
value &lt;/span&gt;= [1,2,3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; person
value &lt;/span&gt;= None
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;当删除person变量，以及将value设置为None后，就不会再有任何变量指向字典和列表了，所以字典和列表占用的内存空间会被释放。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 解决循环引用的回收问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在前面讲了Python GC（垃圾回收器）的一种算法策略，就是引用计数法，这种方法是Python GC采用的主要方法。不过这种策略也有其缺点。下面就看一下引用计数法的优缺点。&lt;/p&gt;

&lt;p&gt;优点：简单，实时（一旦为0就会立刻释放内存空间，毫不犹豫）&lt;/p&gt;

&lt;p&gt;缺点： 维护性高（简单实时，但是额外占用了一部分资源，虽然逻辑简单，但是麻烦。好比你吃草莓，吃一次洗一下手，而不是吃完洗手。），不能解决循环引用的问题。&lt;/p&gt;

&lt;p&gt;那么Python到底是如何解决循环引用释放的问题呢？先看下面的代码。&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; objgraph
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; getrefcount
a &lt;/span&gt;=&lt;span&gt; {}
b &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:a}
a[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt; b
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在这段代码中，很明显，a和b互相引用。最后通过del语句删除a和b。由于a和b是循环引用，如果按前面引用计数器的方法，在删除a和b之前，两个字典分别由两个引用（引用计数器为2），一个是自身引用，另一个是a或b中的value引用的自己。如果只是删除了a和b，似乎这两个字典各自还剩一个引用。但其实这两个字典的内存空间已经释放。那么Python是如何做到的呢？&lt;/p&gt;

&lt;p&gt;其实Python GC在检测所有引用时，会检测哪些引用之间是循环引用，如果检测到某些变量之间循环引用，例如，a引用b，b引用a，就会在检测a时，将b的引用计数器减1，在检测b时，会将a的引用计数器减1。也就是说，Python GC当发现某些引用是循环引用后，会将这些引用的计数器多减一个1。所以这些循环引用指向的空间仍然会被释放。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;9. 分代回收&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果是多年的朋友，或一起做了多年的生意，有多年的业务往来，往往会产生一定的信任。通常来讲，合作的时间越长，产生的信任感就会越深。Python GC采用的垃圾回收策略中，也会使用这种信任感作为辅助算法，让GC运行得更有效率。这种策略就是分代（generation）回收。&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230084035665-2095685941.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/92B1FDCCF76D4C1AB6F233BDE1C44EF7&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;分代回收的策略有一个基本假设，就是存活的越久，越可能被经常使用，所以出于信任和效率，对这些“长寿”对象给予特殊照顾，在GC对所有对象进行检测时，就会尽可能少地检测这些“长寿”对象。就是现在有很多企业是免检企业一样，政府出于对这些企业的信任，给这些企业生产出的产品予以免检的特殊优待。&lt;/p&gt;

&lt;p&gt;那么Python对什么样的对象会给予哪些特殊照顾呢？Python将对象共分为3代，分别用0、1、2表示。任何新创建的对象是0代，不会给予任何特殊照顾，当某一个0代对象经过若干次垃圾回收后仍然存活，那么就会将这个对象归入1代对象，如果这个1代对象，再经过若干次回收后，仍然存活，就会将该对象归为2代对象。&lt;/p&gt;

&lt;p&gt;在前面的描述中，涉及到一个“若干次”回收，那么这个“若干次”是指什么呢？在前面使用get_threshold函数获取阈值时返回了(700,10,10），这个700就是引用计数策略的阈值，而后面的两个10与分代策略有关。第1个10是指第0代对象经过了10次垃圾回收后仍然存在，就会将其归为第1代对象。第2个10是指第1代对象经过了10次垃圾回收后仍然存在，就会将其归为第2代对象。也就是说，GC需要执行100次，才会扫描到第2代对象。当然，也可以通过set_threshold函数来调整这些值。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; gc gc.set_threshold(600, 5, 6)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;本文主要讲了Python如何自动释放内存。主要有如下3种策略：&lt;/p&gt;
&lt;p&gt;1. 引用计数策略（为0时释放）&lt;/p&gt;
&lt;p&gt;2. 循环引用策略（将相关引用计数器多减1）&lt;/p&gt;
&lt;p&gt;3. 分代策略（解决了GC的效率问题）&lt;/p&gt;

&lt;p&gt;通过这些策略的共同作用，可以让Python更加有效地管理内存，更进一步地提高Python的性能。&lt;/p&gt;

&lt;p&gt;获取更多学习资源，可以关注“极客起源”公众号&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/32818/201912/32818-20191230084347973-41352690.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AA44C7E8B5074036A462A46D37608C3C&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 30 Dec 2019 00:44:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>任何编程语言都会有一个内存模型，以便管理为变量分配的内存空间。不同的编程语言，如C、C++、Java、C#，Python，它们的内存模型都是不相同的，本文将以现在最流行的Python语言为例，来说明动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nokiaguy/p/12117900.html</dc:identifier>
</item>
<item>
<title>UVW平台运动控制算法以及matlab仿真 - 邵磊leo</title>
<link>http://www.cnblogs.com/futurelei/p/12117896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/futurelei/p/12117896.html</guid>
<description>&lt;p&gt;最近公司同事因为对某视觉对位平台的运动控制算法有疑问，所以来请教我。&lt;br/&gt;由于我也是第一次接触到UVW自动对位平台（也可以叫XXY自动对位平台），于是找了一些资料学习一下，大概了解了运动模式后，使用matlab模拟了此平台，并验证了UVW平台资料提供的运动控制算法的正确性。&lt;br/&gt; &lt;/p&gt;&lt;p&gt;1、这是一种可以实现以平面上任意一点为中心，进行旋转运动的装置，并可沿着任意的方向平移。&lt;br/&gt;2、此平台和视觉CCD纠偏系统对接在一起，可以很快完成高精度的纠偏工作，重复定位精度一般可达±1μm；&lt;/p&gt;&lt;p&gt;UVW平台和以前的xyθ平台相比，有以下几点不同：&lt;br/&gt;1、控制精度高于xyθ平台；&lt;br/&gt;2、UVW平台可以平面上任意一点为中心做旋转运动（包括无限远）；而xyθ平台由于仅仅依靠一个电机的转动控制，所以旋转中心必须是固定在平台上某处（θ电机连接处），且必须随平台一同运动。&lt;br/&gt;3、基于第二点的区别，显然UVW平台是需要一个绝对坐标系作为参考系，其旋转中心才有意义；而xyθ平台则必须是一个随平台动的坐标系作为参考系，这样控制计算方法便完全不一样了。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;仔细研究一下上述的公式，很容易发现，这只是简单的几何运算以及对二维坐标的求解问题。&lt;/p&gt;&lt;p&gt;简单说明一下视觉对位和运动控制思路：&lt;br/&gt;1、通过UVW平台供应商提供的说明书，找到机械参数，得到UVW三个轴的初始坐标（基于UVW平台原点坐标系）；&lt;br/&gt;2、通过视觉标定方法，确定相机坐标系到UVW平台坐标系的转换矩阵；确定标志物模板基于UVW平台原点坐标系的坐标值（x_m, y_m）；&lt;br/&gt;3、通过相机得到标志物模板位置和待纠偏标志物之间的x、y、θ偏移量（基于UVW平台原点坐标系）；&lt;br/&gt;4、按照上图公式，输入三个轴初始坐标，设置旋转中心为(0,0)，输入θ偏移量，可得到UVW三轴新的坐标值，以及待纠偏物体的新的坐标，以及三个电机对应的给进量A1、A2、A3；&lt;br/&gt;5、输入上一步求得的UVW三轴新的坐标值，另外通过上一步求得的待纠偏物体的新的坐标，计算得此时待纠偏物体到模板点位置的x2、y2偏移量；输入x2、y2偏移量，则可以得到三个电机对应的给进量B1、B2、B3；&lt;br/&gt;6、将5和6步获取的三个电机的给进量对应相加，分别得到对应电机给进量C1、C2、C3，并用此给进量驱动对应电机即可。即是，将运动过程拆解，变成平移和旋转部分，分别计算电机给进量。&lt;/p&gt;&lt;p&gt;接下来使用了一个matlab仿真实例，来验证自己的思路是正确的。&lt;/p&gt;&lt;p&gt;按照第二步的程序思路，写了以下matlab代码，以下代码省略了电机给进量的计算。基本都有注释，不过多解释。&lt;br/&gt;模拟效果如图所示：&lt;/p&gt;&lt;p&gt; 下面程序定义模板和待纠偏物体时，Template 数组和Rectify_deviation 数组的值都是可以任意改变的，这两个数组即是通过传感器输入的模板坐标及位姿和待纠偏物体坐标及位姿。&lt;/p&gt;&lt;div readability=&quot;169&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; %&lt;span&gt; 蓝色的o符号是待纠偏物体，初始位置；
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; %&lt;span&gt; 黑丝的o符号是待纠偏物体，在第一次旋转角度后的位置；
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; %&lt;span&gt; 红色的o符号是待纠偏物体，在第二次平移之后的位置
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; % 红色的*&lt;span&gt;符号是模板位置
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;  
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;close all; clear all; clc
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;  
&lt;span&gt;  8&lt;/span&gt; %%&lt;span&gt; 设置模板位置参数
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; figure(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; grid on;axis([-150,150,-150,150&lt;span&gt;]);hold on;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;  
&lt;span&gt; 12&lt;/span&gt; %&lt;span&gt; 定义生成模板物体mode:x,y,theta（基于UVW平台绝对坐标系）
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; Template = [25, 35 , pi*0.2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; %&lt;span&gt; 定义待纠偏物体re:x,y,theta（基于UVW平台绝对坐标系）
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; Rectify_deviation = [15, 22, pi*0.4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;  
&lt;span&gt; 17&lt;/span&gt;  %&lt;span&gt;求出第一次变换之前，模板与待纠偏物体的角度偏移（基于UVW平台绝对坐标系）
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; THETA_M = Template(3) - Rectify_deviation(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;  
&lt;span&gt; 20&lt;/span&gt; %%&lt;span&gt; 绘制模板和待纠偏物体
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; plot(Rectify_deviation(1), Rectify_deviation(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt; 绘制待纠偏物体re，蓝色o符号
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;hold on;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;  
&lt;span&gt; 24&lt;/span&gt; plot(Template(1), Template(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); hold on;% 绘制模板位置，红色的*&lt;span&gt;符号
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; draw_triangle(Template(1), Template(2), Template(3&lt;span&gt;));hold on;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;  
&lt;span&gt; 27&lt;/span&gt;  
&lt;span&gt; 28&lt;/span&gt; %%&lt;span&gt; UWV平台初始坐标参数
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; R = 72.837; %&lt;span&gt; 四轴到原点的半径
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; m = 51.504; %&lt;span&gt; 四个轴的坐标绝对值
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;  
&lt;span&gt; 32&lt;/span&gt; %&lt;span&gt; 轴初始坐标
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; Ux0 = -&lt;span&gt;m;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; Uy0 =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;  
&lt;span&gt; 36&lt;/span&gt; Vx0 =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; Vy0 =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;  
&lt;span&gt; 39&lt;/span&gt; Wx0 =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; Wy0 = -&lt;span&gt;m;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;  
&lt;span&gt; 42&lt;/span&gt; Ox0 = -&lt;span&gt;m;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; Oy0 = -&lt;span&gt;m;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;  
&lt;span&gt; 45&lt;/span&gt; %%&lt;span&gt; 绘制UVW平台以及待纠偏物体
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;draw_frame(Ux0,Uy0,Vx0,Vy0,Wx0,Wy0,Ox0,Oy0);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; draw_circle(Ox0, Oy0, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; draw_circle(Ux0, Uy0, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; draw_circle(Vx0, Vy0, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; draw_circle(Wx0, Wy0, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; draw_triangle(Rectify_deviation(1), Rectify_deviation(2), Rectify_deviation(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; %% 1--&lt;span&gt;先旋转
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; figure(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; grid on;axis([-150,150,-150,150&lt;span&gt;]);hold on;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; plot(Template(1), Template(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);hold on; % 绘制模板位置，红色的*&lt;span&gt;符号
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; draw_triangle(Template(1), Template(2), Template(3&lt;span&gt;));hold on;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;  
&lt;span&gt; 58&lt;/span&gt; X =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; Y =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; THETA =&lt;span&gt; THETA_M;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; %&lt;span&gt; 旋转中心
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; at =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; bt =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;  
&lt;span&gt; 65&lt;/span&gt; % U轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; ux = (Ux0 - at)*cos(THETA) - (Uy0 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; uy = (Ux0 - at)*sin(THETA) + (Uy0 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; % V轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; vx = (Vx0 - at)*cos(THETA) - (Vy0 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; vy = (Vx0 - at)*sin(THETA) + (Vy0 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; % W轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; wx = (Wx0 - at)*cos(THETA) - (Wy0 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; wy = (Wx0 - at)*sin(THETA) + (Wy0 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; %&lt;span&gt; O坐标
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; ox = (Ox0 - at)*cos(THETA) - (Oy0 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; oy = (Ox0 - at)*sin(THETA) + (Oy0 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;  
&lt;span&gt; 78&lt;/span&gt; %&lt;span&gt; ！！！！求出第一次旋转后，待纠偏物体新的位姿
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; rx1 = Rectify_deviation(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; rx2 = Rectify_deviation(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; Rectify_deviation(1) = (rx1 - at)*cos(THETA) - (rx2 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; Rectify_deviation(2) = (rx1 - at)*sin(THETA) + (rx2 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; Rectify_deviation(3) = Rectify_deviation(3) +&lt;span&gt; THETA_M;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;  
&lt;span&gt; 85&lt;/span&gt; plot(Rectify_deviation(1), Rectify_deviation(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt; 绘制待纠偏物体re，黑色o符号
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;hold on;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;  
&lt;span&gt; 88&lt;/span&gt; %&lt;span&gt; UVW平台新矩形位置
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;draw_frame(ux,uy,vx,vy,wx,wy,ox,oy);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; draw_circle(ux, uy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; draw_circle(vx, vy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; draw_circle(wx, wy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; draw_circle(ox, oy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; draw_triangle(Rectify_deviation(1), Rectify_deviation(2), Rectify_deviation(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;  
&lt;span&gt; 96&lt;/span&gt; %% 2--&lt;span&gt;再平移xy
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; figure(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; grid on;axis([-150,150,-150,150&lt;span&gt;]);hold on;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; plot(Template(1), Template(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); % 绘制模板位置，红色的*&lt;span&gt;符号
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;hold on;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; draw_triangle(Template(1), Template(2), Template(3&lt;span&gt;));hold on;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;  
&lt;span&gt;103&lt;/span&gt; %&lt;span&gt; 求出此时，模板位置相对于待纠偏物体的位姿
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; X_M = Template(1) - Rectify_deviation(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; Y_M = Template(2) - Rectify_deviation(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; THETA_M = Template(3) - Rectify_deviation(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;  
&lt;span&gt;108&lt;/span&gt; X =&lt;span&gt; X_M;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; Y =&lt;span&gt; Y_M;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; THETA =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; %&lt;span&gt; 旋转中心
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; at =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; bt =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;  
&lt;span&gt;115&lt;/span&gt; % U轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; ux = (ux - at)*cos(THETA) - (uy - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; uy = (ux - at)*sin(THETA) + (uy - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; % V轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; vx = (vx - at)*cos(THETA) - (vy - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; vy = (vx - at)*sin(THETA) + (vy - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; % W轴执行机构-&lt;span&gt;目标坐标
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; wx = (wx - at)*cos(THETA) - (wy - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; wy = (wx - at)*sin(THETA) + (wy - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; %&lt;span&gt; O坐标
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; ox = (ox - at)*cos(THETA) - (oy - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; oy = (ox - at)*sin(THETA) + (oy - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;  
&lt;span&gt;128&lt;/span&gt; %&lt;span&gt; ！！！！求出第二次平移后，待纠偏物体新的位姿
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; rx1 = Rectify_deviation(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; rx2 = Rectify_deviation(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; Rectify_deviation(1) = (rx1 - at)*cos(THETA) - (rx2 - bt)*sin(THETA) + at +&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; Rectify_deviation(2) = (rx1 - at)*sin(THETA) + (rx2 - bt)*cos(THETA) + bt +&lt;span&gt; Y;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; Rectify_deviation(3) = Rectify_deviation(3) +&lt;span&gt; THETA_M;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; plot(Rectify_deviation(1), Rectify_deviation(2),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); %&lt;span&gt; 绘制待纠偏物体re，红色的o符号
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;hold on;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;  
&lt;span&gt;137&lt;/span&gt; %&lt;span&gt; UVW平台新矩形位置
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;draw_frame(ux,uy,vx,vy,wx,wy,ox,oy);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; draw_circle(ux, uy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; draw_circle(vx, vy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; draw_circle(wx, wy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; draw_circle(ox, oy, 5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; draw_triangle(Rectify_deviation(1), Rectify_deviation(2), Rectify_deviation(3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;  
&lt;span&gt;145&lt;/span&gt; %%&lt;span&gt; 规定范围以及网格
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; grid on;axis([-150,150,-150,150&lt;span&gt;]);hold on;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;  
&lt;span&gt;148&lt;/span&gt; %%&lt;span&gt; 各种函数定义
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; %&lt;span&gt; 以inc_x和inc_y为中心，inc_r为半径画圆
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; function ret =&lt;span&gt; draw_circle(inc_x, inc_y, inc_r)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; r =&lt;span&gt; inc_r; 
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; theta=0:pi/100:2*&lt;span&gt;pi;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; x = r*cos(theta) +&lt;span&gt; inc_x; 
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; y = r*sin(theta) +&lt;span&gt; inc_y;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;  
&lt;span&gt;156&lt;/span&gt; plot(x,y,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);hold on; axis equal  %&lt;span&gt; 等圆
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; fill(x,y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) %&lt;span&gt; 填充颜色
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; ret =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;  
&lt;span&gt;161&lt;/span&gt; % 输入三个顶点的坐标，画直角三角形，角度30，60，90
&lt;span&gt;162&lt;/span&gt; function ret =&lt;span&gt; draw_triangle(inc_x, inc_y, inc_theta)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; %&lt;span&gt; 定义直角三角形abc三条边,设定斜边c为：
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;  
&lt;span&gt;165&lt;/span&gt; a = 8 * 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; b = 8 * sqrt(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; c = 8 * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;  
&lt;span&gt;169&lt;/span&gt; AX =&lt;span&gt; inc_x;
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; AY =&lt;span&gt; inc_y;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;  
&lt;span&gt;172&lt;/span&gt; BX = c * cos(inc_theta) +&lt;span&gt; inc_x;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; BY = c * sin(inc_theta) +&lt;span&gt; inc_y;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;  
&lt;span&gt;175&lt;/span&gt; CX = b * cos(inc_theta + pi/6) +&lt;span&gt; inc_x;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; CY = b * sin(inc_theta + pi/6) +&lt;span&gt; inc_y;
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;  
&lt;span&gt;178&lt;/span&gt; plot([AX,BX],[AY, BY],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; plot([AX,CX],[AY, CY],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; plot([BX,CX],[BY, CY],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;  
&lt;span&gt;182&lt;/span&gt; ret =&lt;span&gt; 0;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;  
&lt;span&gt;185&lt;/span&gt; %&lt;span&gt; 输入四个顶点的坐标,画矩形
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; function [] =&lt;span&gt; draw_frame(Ux0,Uy0,Vx0,Vy0,Wx0,Wy0,Ox0,Oy0)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;  
&lt;span&gt;188&lt;/span&gt; plot([Ux0,Vx0],[Uy0, Vy0],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; plot([Vx0,Wx0],[Vy0, Wy0],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; plot([Ox0,Wx0],[Oy0, Wy0],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; plot([Ox0,Ux0],[Oy0, Uy0],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);hold on;
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;end
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Mon, 30 Dec 2019 00:42:00 +0000</pubDate>
<dc:creator>邵磊leo</dc:creator>
<og:description>UVW平台运动控制算法以及matlab仿真 最近公司同事因为对某视觉对位平台的运动控制算法有疑问，所以来请教我。由于我也是第一次接触到UVW自动对位平台（也可以叫XXY自动对位平台），于是找了一些资料</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/futurelei/p/12117896.html</dc:identifier>
</item>
<item>
<title>.NETCore3.1中的Json互操作最全解读-收藏级 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/12116640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/12116640.html</guid>
<description>&lt;p&gt;本文比较长，我建议大家先点赞、收藏后慢慢阅读，点赞再看，形成习惯！&lt;/p&gt;
&lt;p&gt;我很高兴,.NETCore终于来到了3.1LTS版本，并且将支持3年，我们也准备让部分业务迁移到3.1上面，不过很快我们就遇到了新的问题，就是对于Json序列化的选择；我本着清真的原则，既然选择迁移到3.1，一切都应该用官方标准或者建议方案。所以我们信心满满的选择了System.Text.Json。本文将会全面介绍System.Text.Json 和 Newtonsoft.Json 的相同和异同之处，方便需要的同学做迁移使用，对未来，我们保持期待。&lt;/p&gt;

&lt;h2 id=&quot;几个重要的对象&quot;&gt;几个重要的对象&lt;/h2&gt;
&lt;p&gt;在 System.Text.Json 中，有几个重量级的对象，所有的JSON互操作，都是围绕这几个对象进行，只要理解了他们各自的用途用法，就基本上掌握了JSON和实体对象的互操作。&lt;/p&gt;
&lt;h3 id=&quot;jsondocument&quot;&gt;JsonDocument&lt;/h3&gt;
&lt;p&gt;提供用于检查 JSON 值的结构内容，而不自动实例化数据值的机制。JsonDocument 有一个属性 RootElement，提供对JSON文档根元素的访问，RootElement是一个JsonElement对象。&lt;/p&gt;
&lt;h2 id=&quot;jsonelement&quot;&gt;JsonElement&lt;/h2&gt;
&lt;p&gt;提供对JSON值的访问，在System.Text.Json 中，大到一个对象、数组，小到一个属性、值，都可以通过 JsonElement 进行互操作&lt;/p&gt;
&lt;h2 id=&quot;jsonproperty&quot;&gt;JsonProperty&lt;/h2&gt;
&lt;p&gt;JSON中最小的单元，提供对属性、值的访问&lt;/p&gt;
&lt;h2 id=&quot;jsonserializer&quot;&gt;JsonSerializer&lt;/h2&gt;
&lt;p&gt;提供JSON互操作的静态类，提供了一系列 Serializer/Deserialize 的互操作的方法，其中还有一些异步/流式操作方法。&lt;/p&gt;
&lt;h2 id=&quot;jsonserializeroptions&quot;&gt;JsonSerializerOptions&lt;/h2&gt;
&lt;p&gt;与上面的 JsonSerializer 配合使用，提供自定义的个性化互操作选项，包括命名、枚举转换、字符转义、注释规则、自定义转换器等等操作选项。&lt;/p&gt;
&lt;h2 id=&quot;utf8jsonwriterutf8jsonreader&quot;&gt;Utf8JsonWriter/Utf8JsonReader&lt;/h2&gt;
&lt;p&gt;这两个对象是整个 System.Text.Json 的核心对象，所有的JSON互操作几乎都是通过这两个对象进行，他们提供的高性能的底层读写操作。&lt;/p&gt;
&lt;h2 id=&quot;初始化一个简单的-json-对象&quot;&gt;初始化一个简单的 JSON 对象&lt;/h2&gt;
&lt;p&gt;在 System.Text.Json 中，并未提供像 JToken 那样非常便捷的创建对象的操作，想要创建一个 JSON 对象，其过程是比较麻烦的，请看下面的代码，进行对比&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // Newtonsoft.Json.Linq;
JToken root = new JObject();
root[&quot;Name&quot;] = &quot;Ron&quot;;
root[&quot;Money&quot;] = 4.5;
root[&quot;Age&quot;] = 30;
string jsonText = root.ToString();

// System.Text.Json
string json = string.Empty;
using (MemoryStream ms = new MemoryStream())
{
    using (Utf8JsonWriter writer = new Utf8JsonWriter(ms))
    {
        writer.WriteStartObject();
        writer.WriteString(&quot;Name&quot;, &quot;Ron&quot;);
        writer.WriteNumber(&quot;Money&quot;, 4.5);
        writer.WriteNumber(&quot;Age&quot;, 30);
        writer.WriteEndObject();
        writer.Flush();
    }
    json = Encoding.UTF8.GetString(ms.ToArray());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;System.Text.Json 的操作便利性在这方面目前处于一个比较弱的状态，不过，从这里也可以看出，可能官方并不希望我们去直接操作 JSON 源，而是通过操作实体对象以达到操作 JSON 的目的，也可能对互操作是性能比较自信的表现吧。&lt;/p&gt;
&lt;h2 id=&quot;封装和加载&quot;&gt;封装和加载&lt;/h2&gt;
&lt;p&gt;在对JSON文档进行包装的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var json = &quot;{\&quot;name\&quot;:\&quot;Ron\&quot;,\&quot;money\&quot;:4.5}&quot;;

var jDoc = System.Text.Json.JsonDocument.Parse(json);
var jToken = Newtonsoft.Json.Linq.JToken.Parse(json);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我发现MS这帮人很喜欢使用 Document 这个词,包括XmlDocument/XDocument等等。&lt;/p&gt;
&lt;h2 id=&quot;查找元素对象&quot;&gt;查找元素（对象）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;var json = &quot;{\&quot;name\&quot;:\&quot;Ron\&quot;,\&quot;money\&quot;:4.5}&quot;;
var jDoc = System.Text.Json.JsonDocument.Parse(json);
var obj = jDoc.RootElement[0];// 这里会报错，索引仅支持 Array 类型的JSON文档

var jToken = Newtonsoft.Json.Linq.JToken.Parse(json);
var name = jToken[&quot;name&quot;];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，到查找元素环节就体现出差异了，JsonDocuemnt 索引仅支持 Array 类型的JSON文档，而 JToken 则支持 object 类型的索引（充满想象），用户体验高下立判。&lt;br/&gt;那我们不禁要提问了，如何在 JsonDocument 中查找元素？答案如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var json = &quot;{\&quot;name\&quot;:\&quot;Ron\&quot;,\&quot;money\&quot;:4.5}&quot;;
var jDoc = System.Text.Json.JsonDocument.Parse(json);
var enumerate = jDoc.RootElement.EnumerateObject();
while (enumerate.MoveNext())
{
    if (enumerate.Current.Name == &quot;name&quot;)
        Console.WriteLine(&quot;{0}:{1}&quot;, enumerate.Current.Name, enumerate.Current.Value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码来看，JsonElement 存在两个迭代器，分别是EnumerateArray和EnumerateObject；通过迭代器，你可以实现查找元素的需求。你看，MS关上了一扇门，然后又为了打开了一扇窗，还是很人性化的了。在System.Text.Json中，一切对象都是Element，Object/Array/Property，都是Element，这个概念和XML一致，但是和Newtonsoft.Json不同，这是需要注意的地方。&lt;/p&gt;
&lt;p&gt;你也可以选择不迭代，直接获取对象的属性，比如使用下面的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var json = &quot;{\&quot;name\&quot;:\&quot;Ron\&quot;,\&quot;money\&quot;:4.5}&quot;;
var jDoc = System.Text.Json.JsonDocument.Parse(json);
var age = jDoc.RootElement.GetProperty(&quot;age&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码将抛出异常，因为属性 age 不存在，通常情况下，我们会立即想用一个 ContainsKey 来作一个判断，但是很可惜，JsonElement 并未提供该方法，而是提供了一个 TryGetProperty 方法；所以，除非你明确知道 json 对象中的属性，否则一般情况下，建议使用 TryGetProperty 进行取值。&lt;/p&gt;
&lt;p&gt;就算是这样，使用 GetProperty/TryGetProperty 得到的值，还是一个 JsonElement 对象，并不是你期望的“值”。所以 JsonElement 很人性化的提供了各种 GetIntxx/GetString 方法，但是就算如此，还是可能产生意外，思考下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var json = &quot;{\&quot;name\&quot;:\&quot;Ron\&quot;,\&quot;money\&quot;:4.5,\&quot;age\&quot;:null}&quot;;
var jDoc = System.Text.Json.JsonDocument.Parse(json);
var property = jDoc.RootElement.GetProperty(&quot;age&quot;);
var age = property.GetInt32();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码，最后一行将抛出异常，因为你尝试从一个 null 到 int32 的类型转换，怎么解决这种问题呢，又回到了 JsonElement 上面来，他又提供了一个对值进行检查的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (property.ValueKind == JsonValueKind.Number)
   {
       var age = property.GetInt32();
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候，程序运行良好，JsonValueKind 枚举提供了一系列的类型标识，为了进一步缩小内存使用率，Json团队用心良苦的将枚举值声明为：byte 类型（够抠）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum JsonValueKind : byte
{
    Undefined = 0,
    Object = 1,
    Array = 2,
    String = 3,
    Number = 4,
    True = 5,
    False = 6,
    Null = 7
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，你是不是有点想念 Newtonsoft.Json 了呢？别着急，下面我给大家介绍一个宝贝 System.Json.dll。&lt;/p&gt;

&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;System.Json 提供了对JSON 对象序列化的基础支持，但是也是有限的支持，请看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201912/26882-20191229213721197-1960257732.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;System.Json 目前已合并到 .NETCore-3.1 中，如果你希望使用他，需要单独引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package System.Json -Version 4.7.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个JSON互操作包提供了几个常用的操作类型，从下面的操作类不难看出，提供的支持是非常有限的，而且效率上也不好说&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Json.JsonArray
System.Json.JsonObject
System.Json.JsonPrimitive
System.Json.JsonValue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，JsonObject是实现 IDictionary 接口，并在内部维护一个 SortedDictionary&amp;lt;string, JsonValue&amp;gt; 字典，所以他具备字典类的一切操作，比如索引等等，JsonArray 就更简单，也是一样的实现 IList 接口，然后同样的在内部维护一个 List 链表，以实现数组功能，对象的序列化都是通过 JsonValue 进行操作，序列化的方式也是非常的简单，就是对对像进行迭代，唯一值得称道的地方是，采用了流式处理。&lt;/p&gt;
&lt;h2 id=&quot;使用system.json操作上面的查找过程如下&quot;&gt;使用System.Json操作上面的查找过程如下&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;var obj = System.Json.JsonObject.Parse(&quot;{\&quot;name\&quot;:\&quot;ron\&quot;}&quot;);
if (obj.ContainsKey(&quot;age&quot;))
{
    int age = obj[&quot;age&quot;];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;令人遗憾的是，虽然 System.Json 已经合并到 .NETCore-3.1 的路线图中；但是，System.Text.Json 不提供对 System.Json 的互操作性，我们期待以后 System.Text.Json 也能提供 System.Json 的操作便利性。&lt;/p&gt;

&lt;p&gt;基本知识已经介绍完成，下面我们进入 System.Text.Json 的内部世界一探究竟。&lt;/p&gt;
&lt;h2 id=&quot;互操作&quot;&gt;互操作&lt;/h2&gt;
&lt;p&gt;思考下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 序列化
var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30 };
var json = JsonSerializer.Serialize(user);

// 输出
{&quot;Name&quot;:&quot;Ron&quot;,&quot;Money&quot;:4.5,&quot;Age&quot;:30}

// 反序列化
user = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(json);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前为止，上面的代码工作良好。让我们对上面的代码稍作修改，将 JSON 字符串进行一个转小写的操作后再进行反序列化的操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 输出
{&quot;name&quot;:&quot;Ron&quot;,&quot;money&quot;:4.5,&quot;age&quot;:30}

// 反序列化
user = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(json);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码可以正常运行，也不会抛出异常，你可以得到一个完整的 user 对象；但是，user对象的属性值将会丢失！这是因为 System.Text.Json 默认采用的是区分大小写匹配的方式，为了解决这个问题，我们需要引入序列化操作个性化设置，请参考下面的代码，启用忽略大小写的设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 输出
{&quot;name&quot;:&quot;Ron&quot;,&quot;money&quot;:4.5,&quot;age&quot;:30}

var options = new JsonSerializerOptions()
   {
       PropertyNameCaseInsensitive = true
   };
// 反序列化
user = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(json,options);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;格式化json&quot;&gt;格式化JSON&lt;/h2&gt;
&lt;p&gt;现在你可以选择对序列化的JSON文本进行美化，而不是输出上面的压缩后的JSON文本，为了实现美化的效果，你仅仅需要在序列化的时候加入一个 WriteIndented 设置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var options = new JsonSerializerOptions()
    options.WriteIndented = true;
 var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark = &quot;你好，欢迎！&quot; };
 var json = JsonSerializer.Serialize(user, options);

 // 输出
{
  &quot;Name&quot;: &quot;Ron&quot;,
  &quot;Money&quot;: 4.5,
  &quot;Age&quot;: 30,
  &quot;Remark&quot;: &quot;\u4F60\u597D\uFF0C\u6B22\u8FCE\uFF01&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，就是这么简单，但是你也发现了，上面的 Remark 属性在序列化后，中文被转义了，这就是接下来要解决的问题&lt;/p&gt;
&lt;h2 id=&quot;字符转义的问题&quot;&gt;字符转义的问题&lt;/h2&gt;
&lt;p&gt;在默认情况下，System.Text.Json 序列化程序对所有非 ASCII 字符进行转义；这就是中文被转义的根本原因。但是在内部，他又允许你自定义控制字符集的转义行为，这个设置就是：Encoder，比如下面的代码，对中文进行转义的例外设置，需要创建一个 TextEncoderSettings 对象，并将 UnicodeRanges.All 加入允许例外范围内，并使用 JavaScriptEncoder 根据 TextEncoderSettings创建一个 JavaScriptEncoder 对象即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var encoderSettings = new TextEncoderSettings();
encoderSettings.AllowRanges(UnicodeRanges.All);
var options = new JsonSerializerOptions();
options.Encoder = JavaScriptEncoder.Create(encoderSettings);
options.WriteIndented = true;
var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark = &quot;你好，欢迎！&quot; };
var json = JsonSerializer.Serialize(user, options);

// 输出
{
  &quot;Name&quot;: &quot;Ron&quot;,
  &quot;Money&quot;: 4.5,
  &quot;Age&quot;: 30,
  &quot;Remark&quot;: &quot;你好，欢迎！&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有另外一种模式，可以不必设置例外而达到不转义的效果，这个模式就是“非严格JSON”模式，将上面的 JavaScriptEncoder.Create(encoderSettings) 替换为下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;序列化相关-异步流式&quot;&gt;序列化相关-异步/流式&lt;/h2&gt;
&lt;p&gt;System.Text.Josn 提供了一系列丰富的JSON互操作，这其中包含异步和流式处理，这点也是和 Newtonsoft.Json 最大的不同，但不管是那种方式，都要牢记，最后都是通过下面的两个类来实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Text.Json.Utf8JsonReader
System.Text.Json.Utf8JsonWriter&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义-json-名称和值&quot;&gt;自定义 JSON 名称和值&lt;/h2&gt;
&lt;p&gt;在默认情况下，输出的JSON属性名称保持和实体对象相同，包括大小写的都是一致的，枚举类型在默认情况下被序列化为数值类型。System.Text.JSON 提供了一系列的设置和扩展来帮助开发者实现各种自定义的需求。下面的代码可以设置默认的JSON属性名称，这个设置和 Newtonsoft.Json 基本一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    [JsonPropertyName(&quot;name&quot;)] public string Name { get; set; }
    public decimal Money { get; set; }
    public int Age { get; set; }
    public string Remark { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserInfo 的 属性 Name 在输出为 JSON 的时候，其字段名称将为：name，其他属性保持大小写不变&lt;/p&gt;
&lt;h2 id=&quot;对所有属性设置为-camel-大小写&quot;&gt;对所有属性设置为 camel 大小写&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;var options = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase
};

jsonSerializer.Serialize(user, options);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义名称策略&quot;&gt;自定义名称策略&lt;/h2&gt;
&lt;p&gt;比如我们的系统，目前采用全小写的模式，那么我可以自定义一个转换器，并应用到序列化行为中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LowerCaseNamingPolicy : JsonNamingPolicy
{
    public override string ConvertName(string name) =&amp;gt; name.ToLower();
}

var options = new JsonSerializerOptions();
// 应用策略
options.PropertyNamingPolicy = new LowerCaseNamingPolicy();

var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30};
var json = JsonSerializer.Serialize(user, options);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将枚举序列化为名称字符串而不是数值&quot;&gt;将枚举序列化为名称字符串而不是数值&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;var options = new JsonSerializerOptions();
// 添加转换器
options.Converters.Add(new JsonStringEnumConverter());

var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30;
var json = JsonSerializer.Serialize(user, options);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在默认情况下，所有公共属性将被序列化为JSON。 但是，如果你不想让某些属性出现在 JSON 中，可以通过下面的几种方式实现属性排除&lt;/p&gt;
&lt;h2 id=&quot;排除所有属性值为-null-属性&quot;&gt;排除所有属性值为 null 属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;var options = new JsonSerializerOptions();
options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;
options.IgnoreNullValues = true;
var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark =null};
var json = JsonSerializer.Serialize(user, options);

// 输出，可以看到，Remark 属性被排除
{&quot;name&quot;:&quot;Ron&quot;,&quot;Money&quot;:4.5,&quot;Age&quot;:30}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;排除指定标记属性&quot;&gt;排除指定标记属性&lt;/h2&gt;
&lt;p&gt;可以为某个属性应用 JsonIgnore 特性，标记为不输出到 JSON&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    [JsonPropertyName(&quot;name&quot;)] public string Name { get; set; }
    public decimal Money { get; set; }
    [JsonIgnore]public int Age { get; set; }
    public string Remark { get; set; }
}

var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark =null};
var json = JsonSerializer.Serialize(user);

// 输出，属性 Age  已被排除
{&quot;name&quot;:&quot;Ron&quot;,&quot;Money&quot;:4.5,&quot;Remark&quot;:null}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;排除所有只读属性&quot;&gt;排除所有只读属性&lt;/h2&gt;
&lt;p&gt;还可以选择对所有只读属性进行排查输出 JSON，比如下面的代码，Password 是不需要输出的，那么我们只需要将 Password 设置为 getter，并应用 IgnoreReadOnlyProperties = true 即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    [JsonPropertyName(&quot;name&quot;)] public string Name { get; set; }
    public decimal Money { get; set; }
    [JsonIgnore] public int Age { get; set; }
    public int Password { get; }
    public string Remark { get; set; }
}

var options = new JsonSerializerOptions
    {
        IgnoreReadOnlyProperties = true
    };
var user = new UserInfo { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark = null };
var json = JsonSerializer.Serialize(user, options);

// 输出
{&quot;name&quot;:&quot;Ron&quot;,&quot;Money&quot;:4.5,&quot;Remark&quot;:null}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;排除派生类的属性&quot;&gt;排除派生类的属性&lt;/h2&gt;
&lt;p&gt;在某些情况下，由于业务需求的不同，需要实现实体对象的继承，但是在输出 JSON 的时候，希望只输出基类的属性，而不要输出派生类型的属性，以避免产生不可控制的数据泄露问题；那么，我们可以采用下面的序列化设置。比如下面的 UserInfoExtension 派生自 UserInfo，并扩展了一个属性为身份证的属性，在输出 JSON 的时候，我们希望不要序列化派生类，那么我们可以在 Serialize 序列化的时候，指定序列化的类型为基类：UserInfo，即可达到隐藏派生类属性的目的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    [JsonPropertyName(&quot;name&quot;)] public string Name { get; set; }
    public decimal Money { get; set; }
    [JsonIgnore] public int Age { get; set; }
    public int Password { get; }
    public string Remark { get; set; }
}

public class UserInfoExtension : UserInfo
{
    public string IdCard { get; set; }
}

var user = new UserInfoExtension { Name = &quot;Ron&quot;, Money = 4.5m, Age = 30, Remark = null };
var json = JsonSerializer.Serialize(user, typeof(UserInfo));

// 输出
{&quot;name&quot;:&quot;Ron&quot;,&quot;Money&quot;:4.5,&quot;Password&quot;:0,&quot;Remark&quot;:null}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;仅输出指定属性排除属性的逆向操作&quot;&gt;仅输出指定属性（排除属性的逆向操作）&lt;/h2&gt;
&lt;p&gt;在 Newtonsoft.Json 中，我们可以通过指定 MemberSerialization 和 JsonProperty 来实现输出指定属性到 JSON 中，比如下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Newtonsoft.Json.JsonObject(Newtonsoft.Json.MemberSerialization.OptIn)]
public class UserInfo
{
    [Newtonsoft.Json.JsonProperty(&quot;name&quot;)] public string Name { get; set; }
    public int Age { get; set; }
}
 var user = new UserInfo() { Age = 18, Name = &quot;Ron&quot; };
var json = Newtonsoft.Json.JsonConvert.SerializeObject(user);

// 输出
{&quot;name&quot;:&quot;Ron&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，很遗憾的告诉大家，目前 System.Text.Json 不支持这种方式；为此，我特意去看了 corefx 的 issue，我看到了下面这个反馈&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201912/26882-20191229213802141-1128886045.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在可以方向了，当 .NETCore 合并到主分支 .NET 也就是 .NET5.0 的时候，官方将提供支持，在此之前，还是使用推荐 Newtonsoft.Json 。&lt;/p&gt;
&lt;h2 id=&quot;在反序列化的时候允许-json-文本包含注释&quot;&gt;在反序列化的时候，允许 JSON 文本包含注释&lt;/h2&gt;
&lt;p&gt;默认情况下，System.Text.JSON 不支持源JSON 文本包含注释，比如下面的代码，当你不使用 ReadCommentHandling = JsonCommentHandling.Skip 的设置的时候，将抛出异常，因为在字段 Age 的后面有注释 /* age */。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; var jsonText = &quot;{\&quot;Name\&quot;:\&quot;Ron\&quot;,\&quot;Money\&quot;:4.5,\&quot;Age\&quot;:30/* age */}&quot;;
var options = new JsonSerializerOptions
{
    ReadCommentHandling = JsonCommentHandling.Skip,
    AllowTrailingCommas = true,
};
var user = JsonSerializer.Deserialize&amp;lt;UserInfoExtension&amp;gt;(jsonText);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;允许字段溢出&quot;&gt;允许字段溢出&lt;/h2&gt;
&lt;p&gt;在接口数据出现变动时，极有可能出现源 JSON 文本和实体对象属性不匹配的问题，JSON 中可能会多出一些实体对象不存在的属性，这种情况我们称之为“溢出”，在默认情况下，溢出的属性将被忽略，如果希望捕获这些“溢出”的属性，可以在实体对象中声明一个类型为：Dictionary&amp;lt;string, object&amp;gt; 的属性，并对其应用特性标记：JsonExtensionData。&lt;/p&gt;
&lt;p&gt;为了演示这种特殊的处理，我们声明了一个实体对象 UserInfo，并构造了一个 JSON 源，该 JSON 源包含了一个 UserInfo 不存在的属性：Money，预期该 Money 属性将被反序列化到属性 ExtensionData 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    public string Name { get; set; }
    public int Age { get; set; }
    [JsonExtensionData] public Dictionary&amp;lt;string, object&amp;gt; ExtensionData { get; set; }
}

var jsonText = &quot;{\&quot;Name\&quot;:\&quot;Ron\&quot;,\&quot;Money\&quot;:4.5,\&quot;Age\&quot;:30}&quot;;
var user = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(jsonText);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201912/26882-20191229213741393-781687038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有意思的是，被特性 JsonExtensionData 标记的属性，在序列化为 JSON 的时候，他又会将 ExtensionData 的字典都序列化为单个 JSON 的属性，这里不再演示，留给大家去体验。&lt;/p&gt;

&lt;p&gt;System.Text.Json 内置了各种丰富的类型转换器，这些默认的转换器在程序初始化 JsonSerializerOptions 的时候就默认加载，在 JsonSerializerOptions 内部，维护着一个私有静态成员 s_defaultSimpleConverters，同时还有一个公有属性 Converters ，Converters 属性在 JsonSerializerOptions 的构造函数中被初始化；从下面的代码中可以看到，默认转换器集合和公有转换器集是相互独立的，System.Text.Json 允许开发人员通过 Converters 添加自定义的转换器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public sealed partial class JsonSerializerOptions
{
    // The global list of built-in simple converters.
    private static readonly Dictionary&amp;lt;Type, JsonConverter&amp;gt; s_defaultSimpleConverters = GetDefaultSimpleConverters();
    // The global list of built-in converters that override CanConvert().
    private static readonly List&amp;lt;JsonConverter&amp;gt; s_defaultFactoryConverters = GetDefaultConverters();
    // The cached converters (custom or built-in).
    private readonly ConcurrentDictionary&amp;lt;Type, JsonConverter&amp;gt; _converters = new ConcurrentDictionary&amp;lt;Type, JsonConverter&amp;gt;();

    private static Dictionary&amp;lt;Type, JsonConverter&amp;gt; GetDefaultSimpleConverters()
        {
            ...
        }

        private static List&amp;lt;JsonConverter&amp;gt; GetDefaultConverters()
        {
           ...
        }

        public IList&amp;lt;JsonConverter&amp;gt; Converters { get; }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内置转换器&quot;&gt;内置转换器&lt;/h2&gt;
&lt;p&gt;在 System.Text.Json 内置的转换器集合中，涵盖了所有的基础数据类型，这些转换器的设计非常精妙，他们通过注册一系列的类型映射，在通过 Utf8JsonWriter/Utf8JsonReader 的内置方法 GetTypeValue/TryGetTypeValue 方法得到值，代码非常精练，复用性非常高，下面是内置类型转换器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
private static IEnumerable&amp;lt;JsonConverter&amp;gt; DefaultSimpleConverters
{
    get
    {
        // When adding to this, update NumberOfSimpleConverters above.
        yield return new JsonConverterBoolean();
        yield return new JsonConverterByte();
        yield return new JsonConverterByteArray();
        yield return new JsonConverterChar();
        yield return new JsonConverterDateTime();
        yield return new JsonConverterDateTimeOffset();
        yield return new JsonConverterDouble();
        yield return new JsonConverterDecimal();
        yield return new JsonConverterGuid();
        yield return new JsonConverterInt16();
        yield return new JsonConverterInt32();
        yield return new JsonConverterInt64();
        yield return new JsonConverterJsonElement();
        yield return new JsonConverterObject();
        yield return new JsonConverterSByte();
        yield return new JsonConverterSingle();
        yield return new JsonConverterString();
        yield return new JsonConverterUInt16();
        yield return new JsonConverterUInt32();
        yield return new JsonConverterUInt64();
        yield return new JsonConverterUri();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义类型转换器&quot;&gt;自定义类型转换器&lt;/h2&gt;
&lt;p&gt;虽然 System.Text.Json 内置了各种各样丰富的类型转换器，但是在各种业务开发的过程中，总会根据业务需求来决定一些特殊的数据类型的数据，下面，我们就以经典的日期/时间转换作为演示场景。&lt;/p&gt;
&lt;p&gt;我们需要将日期类型输出为 Unix 时间戳而不是格式化的日期内容，为此，我们将实现一个自定义的时间格式转换器，该转换器继承自 JsonConverter。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class JsonConverterUnixDateTime : JsonConverter&amp;lt;DateTime&amp;gt;
{
    private static DateTime Greenwich_Mean_Time = TimeZoneInfo.ConvertTime(new DateTime(1970, 1, 1), TimeZoneInfo.Local);
    private const int Limit = 10000;
    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.Number)
        {
            var unixTime = reader.GetInt64();
            var dt = new DateTime(Greenwich_Mean_Time.Ticks + unixTime * Limit);
            return dt;
        }
        else
        {
            return reader.GetDateTime();
        }
    }
    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
    {
        var unixTime = (value - Greenwich_Mean_Time).Ticks / Limit;
        writer.WriteNumberValue(unixTime);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用自定义的时间转换器&quot;&gt;应用自定义的时间转换器&lt;/h2&gt;
&lt;p&gt;转换器的应用形式有两种，分别是将转换加入 JsonSerializerOptions.Converters 和给需要转换的属性添加特性标记 JsonConverter&lt;/p&gt;
&lt;h3 id=&quot;加入converters-方式&quot;&gt;加入Converters 方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;var options = new JsonSerializerOptions();
options.Converters.Add(new JsonConverterUnixDateTime());
var user = new UserInfo() { Age = 30, Name = &quot;Ron&quot;, LoginTime = DateTime.Now };
var json = JsonSerializer.Serialize(user, options);
var deUser = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(json, options);

// JSON 输出
{&quot;Name&quot;:&quot;Ron&quot;,&quot;Age&quot;:30,&quot;LoginTime&quot;:1577655080422}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;应用-jsonconverter-特性方式&quot;&gt;应用 JsonConverter 特性方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class UserInfo
{
    public string Name { get; set; }
    public int Age { get; set; }
    [JsonConverter(typeof(JsonConverterUnixDateTime))]
    public DateTime LoginTime { get; set; }
}

var user = new UserInfo() { Age = 30, Name = &quot;Ron&quot;, LoginTime = DateTime.Now };
var json = JsonSerializer.Serialize(user);
var deUser = JsonSerializer.Deserialize&amp;lt;UserInfo&amp;gt;(json);

// JSON 输出
{&quot;Name&quot;:&quot;Ron&quot;,&quot;Age&quot;:30,&quot;LoginTime&quot;:1577655080422}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的 UserInfo.LoginTime 的特性标记，当你想小范围的对某些属性单独应用转换器的时候，这种方式费用小巧而有效。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;本文全面的介绍了 System.Text.Json 在各种场景下的用法，并比较和 Newtonsoft.Json 使用上的不同，也通过实例演示了具体的使用方法，进一步深入讲解了 System.Text.Json 各种对象的原理，希望对大家在迁移到.NETCore-3.1 的时候有所帮助。&lt;/p&gt;
&lt;p&gt;最后，欢迎点赞！&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:40:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>前言 本文比较长，我建议大家先点赞、收藏后慢慢阅读，点赞再看，形成习惯！ 我很高兴,.NETCore终于来到了3.1LTS版本，并且将支持3年，我们也准备让部分业务迁移到3.1上面，不过很快我们就遇到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/12116640.html</dc:identifier>
</item>
<item>
<title>一张图帮你记忆，Spring Boot 应用在启动阶段执行代码的几种方式 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/12117888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/12117888.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有时候我们需要在应用启动时执行一些代码片段，这些片段可能是仅仅是为了记录 log，也可能是在&lt;a href=&quot;https://dayarch.top/p/pkix-certificate-import.html&quot;&gt;启动时检查与安装证书&lt;/a&gt; ，诸如上述业务要求我们可能会经常碰到&lt;/p&gt;
&lt;p&gt;Spring Boot 提供了至少 5 种方式用于在应用启动时执行代码。我们应该如何选择？本文将会逐步解释与分析这几种不同方式&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;commandlinerunner&quot;&gt;CommandLineRunner&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CommandLineRunner&lt;/code&gt; 是一个接口，通过实现它，我们可以在 &lt;code&gt;Spring 应用成功启动之后&lt;/code&gt; 执行一些代码片段&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
@Order(2)
public class MyCommandLineRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        log.info(&quot;MyCommandLineRunner order is 2&quot;);
        if (args.length &amp;gt; 0){
            for (int i = 0; i &amp;lt; args.length; i++) {
                log.info(&quot;MyCommandLineRunner current parameter is: {}&quot;, args[i]);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Spring Boot 在应用上下文中找到 &lt;code&gt;CommandLineRunner&lt;/code&gt; bean，它将会在应用成功启动之后调用 &lt;code&gt;run()&lt;/code&gt; 方法，并传递用于启动应用程序的命令行参数&lt;/p&gt;
&lt;p&gt;通过如下 maven 命令生成 jar 包:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn clean package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过终端命令启动应用，并传递参数:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar springboot-application-startup-0.0.1-SNAPSHOT.jar --foo=bar --name=rgyb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看运行结果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083733528-935935050.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里我们可以看出几个问题:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令行传入的参数并没有被解析，而只是显示出我们传入的字符串内容 &lt;code&gt;--foo=bar&lt;/code&gt;，&lt;code&gt;--name=rgyb&lt;/code&gt;，我们可以通过 &lt;code&gt;ApplicationRunner&lt;/code&gt; 解析，我们稍后看&lt;/li&gt;
&lt;li&gt;在重写的 &lt;code&gt;run()&lt;/code&gt; 方法上有 &lt;code&gt;throws Exception&lt;/code&gt; 标记，Spring Boot 会将 &lt;code&gt;CommandLineRunner&lt;/code&gt; 作为应用启动的一部分，如果运行 &lt;code&gt;run()&lt;/code&gt; 方法时抛出 Exception，应用将会终止启动&lt;/li&gt;
&lt;li&gt;我们在类上添加了 &lt;code&gt;@Order(2)&lt;/code&gt; 注解，当有多个 &lt;code&gt;CommandLineRunner&lt;/code&gt; 时，将会按照 &lt;code&gt;@Order&lt;/code&gt; 注解中的数字从小到大排序 (数字当然也可以用复数)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;h3 id=&quot;不要使用-order-太多&quot;&gt;⚠️不要使用 &lt;code&gt;@Order&lt;/code&gt; 太多&lt;/h3&gt;
&lt;p&gt;看到 order 这个 &quot;黑科技&quot; 我们会觉得它可以非常方便将启动逻辑按照指定顺序执行，但如果你这么写，说明多个代码片段是有相互依赖关系的，为了让我们的代码更好维护，我们应该减少这种依赖使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;如果我们只是想简单的获取以空格分隔的命令行参数，那 &lt;code&gt;MyCommandLineRunner&lt;/code&gt; 就足够使用了&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;applicationrunner&quot;&gt;ApplicationRunner&lt;/h2&gt;
&lt;p&gt;上面提到，通过命令行启动并传递参数，&lt;code&gt;MyCommandLineRunner&lt;/code&gt; 不能解析参数，如果要解析参数，那我们就要用到 &lt;code&gt;ApplicationRunner&lt;/code&gt; 参数了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
@Order(1)
public class MyApplicationRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        log.info(&quot;MyApplicationRunner order is 1&quot;);
        log.info(&quot;MyApplicationRunner Current parameter is {}:&quot;, args.getOptionValues(&quot;foo&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新打 jar 包，运行如下命令:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar springboot-application-startup-0.0.1-SNAPSHOT.jar --foo=bar,rgyb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083733954-1717924495.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里我们可以看出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同 &lt;code&gt;MyCommandLineRunner&lt;/code&gt; 相似，但 &lt;code&gt;ApplicationRunner&lt;/code&gt; 可以通过 run 方法的 &lt;code&gt;ApplicationArguments&lt;/code&gt; 对象解析出命令行参数，并且每个参数可以有多个值在里面，因为 &lt;code&gt;getOptionValues&lt;/code&gt; 方法返回 List 数组&lt;/li&gt;
&lt;li&gt;在重写的 &lt;code&gt;run()&lt;/code&gt; 方法上有 &lt;code&gt;throws Exception&lt;/code&gt; 标记，Spring Boot 会将 &lt;code&gt;CommandLineRunner&lt;/code&gt; 作为应用启动的一部分，如果运行 &lt;code&gt;run()&lt;/code&gt; 方法时抛出 Exception，应用将会终止启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationRunner&lt;/code&gt; 也可以使用 &lt;code&gt;@Order&lt;/code&gt; 注解进行排序，从启动结果来看，它与 &lt;code&gt;CommandLineRunner&lt;/code&gt; 共享 order 的顺序，稍后我们通过源码来验证这个结论&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结-1&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;如果我们想获取复杂的命令行参数时，我们可以使用 &lt;code&gt;ApplicationRunner&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;applicationlistener&quot;&gt;ApplicationListener&lt;/h2&gt;
&lt;p&gt;如果我们不需要获取命令行参数时，我们可以将启动逻辑绑定到 Spring 的 &lt;code&gt;ApplicationReadyEvent&lt;/code&gt; 上&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
@Order(0)
public class MyApplicationListener implements ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; {

    @Override
    public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {
        log.info(&quot;MyApplicationListener is started up&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序查看结果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083735502-847903179.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这我们可以看出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ApplicationReadyEvent&lt;/code&gt; &lt;strong&gt;当且仅当&lt;/strong&gt; 在应用程序就绪之后才被触发，甚至是说上面的 Listener 要在本文说的所有解决方案都执行了之后才会被触发，最终结论请稍后看&lt;/li&gt;
&lt;li&gt;代码中我用 &lt;code&gt;Order(0)&lt;/code&gt; 来标记，显然 ApplicationListener 也是可以用该注解进行排序的，按数字大小排序，应该是最先执行。但是，这个顺序仅用于同类型的 ApplicationListener 之间的排序，与前面提到的 &lt;code&gt;ApplicationRunners&lt;/code&gt; 和 &lt;code&gt;CommandLineRunners&lt;/code&gt; 的排序并不共享&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结-2&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;如果我们不需要获取命令行参数，我们可以通过 &lt;code&gt;ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt;&lt;/code&gt; 创建一些全局的启动逻辑，我们还可以通过它获取 &lt;a href=&quot;https://dayarch.top/p/spring-boot-configurationProperties-usage.html&quot;&gt;Spring Boot 支持的 configuration properties 环境变量参数&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果你看过我之前写的 &lt;strong&gt;Spring Bean 生命周期三部曲:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么你会对下面两种方式非常熟悉了&lt;/p&gt;
&lt;h2 id=&quot;postconstruct&quot;&gt;@PostConstruct&lt;/h2&gt;
&lt;p&gt;创建启动逻辑的另一种简单解决方案是提供一种在 bean 创建期间由 Spring 调用的初始化方法。我们要做的就只是将 &lt;code&gt;@PostConstruct&lt;/code&gt; 注解添加到方法中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
@DependsOn(&quot;myApplicationListener&quot;)
public class MyPostConstructBean {

    @PostConstruct
    public void testPostConstruct(){
        log.info(&quot;MyPostConstructBean&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看运行结果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083736519-1614467223.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面运行结果可以看出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring 创建完 bean之后 (&lt;strong&gt;在启动之前&lt;/strong&gt;)，便会立即调用 &lt;code&gt;@PostConstruct&lt;/code&gt; 注解标记的方法，因此我们无法使用 &lt;code&gt;@Order&lt;/code&gt; 注解对其进行自由排序，因为它可能依赖于 &lt;code&gt;@Autowired&lt;/code&gt; 插入到我们 bean 中的其他 Spring bean。&lt;/li&gt;
&lt;li&gt;相反，它将在依赖于它的所有 bean 被初始化之后被调用，如果要添加人为的依赖关系并由此创建一个排序，则可以使用 &lt;code&gt;@DependsOn&lt;/code&gt; 注解（虽然可以排序，但是不建议使用，理由和 &lt;code&gt;@Order&lt;/code&gt; 一样）&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结-3&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@PostConstruct&lt;/code&gt; 方法固有地绑定到现有的 Spring bean，因此应仅将其用于此单个 bean 的初始化逻辑；&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;initializingbean&quot;&gt;InitializingBean&lt;/h2&gt;
&lt;p&gt;与 &lt;code&gt;@PostConstruct&lt;/code&gt; 解决方案非常相似，我们可以实现 &lt;code&gt;InitializingBean&lt;/code&gt; 接口，并让 Spring 调用某个初始化方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class MyInitializingBean implements InitializingBean {


    @Override
    public void afterPropertiesSet() throws Exception {
        log.info(&quot;MyInitializingBean.afterPropertiesSet()&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看运行结果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083737614-564552931.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的运行结果中，我们得到了和 &lt;code&gt;@PostConstruct&lt;/code&gt; 一样的效果，但二者还是有差别的&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;postconstruct-和-afterpropertiesset-区别&quot;&gt;⚠️ &lt;code&gt;@PostConstruct&lt;/code&gt; 和 &lt;code&gt;afterPropertiesSet&lt;/code&gt; 区别&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;afterPropertiesSet，顾名思义「在属性设置之后」，调用该方法时，该 bean 的所有属性已经被 Spring 填充。如果我们在某些属性上使用 &lt;code&gt;@Autowired&lt;/code&gt;（常规操作应该使用构造函数注入），那么 Spring 将在调用&lt;code&gt;afterPropertiesSet&lt;/code&gt; 之前将 bean 注入这些属性。但 &lt;code&gt;@PostConstruct&lt;/code&gt; 并没有这些属性填充限制&lt;/li&gt;
&lt;li&gt;所以 &lt;code&gt;InitializingBean.afterPropertiesSet&lt;/code&gt; 解决方案比使用 &lt;code&gt;@PostConstruct&lt;/code&gt; 更安全，因为如果我们依赖尚未自动注入的 &lt;code&gt;@Autowired&lt;/code&gt; 字段，则 &lt;code&gt;@PostConstruct&lt;/code&gt; 方法可能会遇到 NullPointerExceptions&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;小结-4&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;如果我们使用构造函数注入，则这两种解决方案都是等效的&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;请打开你的 IDE (重点代码已标记注释):&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;MyCommandLineRunner&lt;/code&gt; 和 &lt;code&gt;ApplicationRunner&lt;/code&gt; 是在何时被调用的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开 &lt;code&gt;SpringApplication.java&lt;/code&gt; 类，里面有 &lt;code&gt;callRunners&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void callRunners(ApplicationContext context, ApplicationArguments args) {
    List&amp;lt;Object&amp;gt; runners = new ArrayList&amp;lt;&amp;gt;();
    //从上下文获取 ApplicationRunner 类型的 bean
    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());

    //从上下文获取 CommandLineRunner 类型的 bean
    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());

    //对二者进行排序，这也就是为什么二者的 order 是可以共享的了
    AnnotationAwareOrderComparator.sort(runners);

    //遍历对其进行调用
    for (Object runner : new LinkedHashSet&amp;lt;&amp;gt;(runners)) {
        if (runner instanceof ApplicationRunner) {
            callRunner((ApplicationRunner) runner, args);
        }
        if (runner instanceof CommandLineRunner) {
            callRunner((CommandLineRunner) runner, args);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;强烈建议完整看一下 &lt;code&gt;SpringApplication.java&lt;/code&gt; 的全部代码，Spring Boot 启动过程及原理都可以从这个类中找到一些答案&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后画一张图用来总结这几种方式（高清大图请查看原文：https://dayarch.top/p/spring-boot-execute-on-startup.html）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083739608-1694909545.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;上面程序运行结果， &lt;code&gt;afterPropertiesSet&lt;/code&gt; 方法调用先于 &lt;code&gt;@PostConstruct&lt;/code&gt; 方法，但这和我们在 &lt;a href=&quot;https://dayarch.top/p/spring-bean-lifecycle-creation.html&quot;&gt;Spring Bean 生命周期之缘起&lt;/a&gt; 中的调用顺序恰恰相反，你知道为什么吗？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyPostConstructBean&lt;/code&gt; 通过 &lt;code&gt;@DependsOn(&quot;myApplicationListener&quot;)&lt;/code&gt; 依赖了 MyApplicationListener，为什么调用结果前者先与后者呢？&lt;/li&gt;
&lt;li&gt;为什么不建议 &lt;code&gt;@Autowired&lt;/code&gt; 形式依赖注入&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在写 Spring Bean 生命周期时就有朋友问我与之相关的问题，显然他们在概念上有一些含混，所以，仔细理解上面的问题将会帮助你加深对 Spring Bean 生命周期的理解&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1583165/201912/1583165-20191230083744014-396259282.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:38:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>前言 有时候我们需要在应用启动时执行一些代码片段，这些片段可能是仅仅是为了记录 log，也可能是在 &amp;quot;启动时检查与安装证书&amp;quot; ，诸如上述业务要求我们可能会经常碰到 Spring B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/12117888.html</dc:identifier>
</item>
<item>
<title>dWebpack编译速度优化实战 - james·von</title>
<link>http://www.cnblogs.com/rock-roll/p/12093553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rock-roll/p/12093553.html</guid>
<description>&lt;p&gt;当你的应用的规模还很小时，你可能不会在乎Webpack的编译速度，无论使用3.X还是4.X版本，它都足够快，或者说至少没让你等得不耐烦。但随着业务的增多，嗖嗖嗖一下项目就有上百个组件了，也是件很简单的事情。这时候当你再独立编前端模块的生产包时，或者CI工具中编整个项目的包时，如果Webpackp配置没经过优化，那编译速度都会慢得一塌糊涂。编译耗时10多秒钟的和编译耗时一两分钟的体验是迥然不同的。出于开发时的心情的考虑，加上不能让我们前端的代码编译拖累整个CI的速度这两个出发点，迫使我们必须去加快编译速度。本文主要是探讨下可做编译速度优化的地方，对一些API使用上不会做太多讲解，需要的同学可以直接翻看文档中的介绍。笔者的Webpack版本为4.29.6，后文中内容都基于这个版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、已存在的针对编译速度的优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者这套Webpack架子源自CRA的eject，基于Webpack4.x，在Loader和Plugin的选择和设计上已是最佳实践方案，基本上无需改动什么。其原有的对编译的优化配置在于这三处：&lt;/p&gt;
&lt;p&gt;1. 通过terser-webpack-plugin的parallel和cache配置来并行处理并缓存之前的编译结果。terser-webpack-plugin是之前UglifyPlugin的一个替代品，因为UglifyPlugin已经没有继续维护了，从Webpack4.x起，已经推荐使用terser-webpack-plugin来进行代码压缩、混淆，以及Dead Code Elimination以实现Tree Shaking。对于parallel从整个设置的名称大家就会知道它有什么用，没错，就是并行，而cache也就是缓存该插件的处理结果，在下一次的编译中对于内容未改变的文件可以直接复用上一次编译的结果。&lt;/p&gt;
&lt;p&gt;2. 通过babel-loader的cache配置来缓存babel的编译结果。&lt;/p&gt;
&lt;p&gt;3. 通过IgnorePlugin设置对moment的整个locale本地化文件夹导入的正则匹配，来防止将所有的本地化文件进行打包。如果你确实需要某国语言，仅手动导入那国的语言包即可。&lt;/p&gt;
&lt;p&gt;在项目逐渐变大的过程中，生产包的编译时间也从十几秒增长到了一分多钟，这是让人受不了的，这就迫使着笔者必须进行额外的优化以加快编译速度，为编包节省时间。下面的段落就讲解下笔者做的几个额外优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、多线程（进程）支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上个段落的terser-webpack-plugin的parallel设置中，我们可以得到这个启发：启用多进程来模拟多线程，并行处理资源的编译。于是笔者引入了HappyPack，笔者之前的那套老架子也用了它，但之前没写东西来介绍那套架子，这里就一并说了。关于HappyPack，经常玩Webpack的同学应该不会陌生，网上也有一些关于其原理的介绍文章，也写得很不错。HappyPack的工作原理大致就是在Webpack和Loader之间多加了一层，改成了Webpack并不是直接去和某个Loader进行工作，而是Webpack test到了需要编译的某个类型的资源模块后，将该资源的处理任务交给了HappyPack，再由HappyPack再起内部进行线程调度，分配一个线程调用处理该类型资源的Loader来处理这个资源，完成后上报处理结果，最后HappyPack把处理结果返回给Webpack，最后由Webpack输出到目的路径。将都在一个线程内的工作，分配到了不同的线程中并行处理。&lt;/p&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;p&gt;首先引入HappyPack并创建线程池：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const HappyPack = require('happypack'&lt;span&gt;);
const happyThreadPool &lt;/span&gt;= HappyPack.ThreadPool({size: require('os').cpus().length - 1});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;替换之前的Loader为HappyPack的插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    test: &lt;/span&gt;/\.(js|mjs|jsx|ts|tsx)$/&lt;span&gt;,
    include: paths.appSrc,
    use: [&lt;/span&gt;'happypack/loader?id=babel-application-js'&lt;span&gt;],
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将原Loader中的配置，移动到对应插件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HappyPack({
    id: &lt;/span&gt;'babel-application-js'&lt;span&gt;,
    threadPool: happyThreadPool,
    verbose: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    loaders: [
        {
            loader: require.resolve(&lt;/span&gt;'babel-loader'&lt;span&gt;),
            options: {
                ...省略
            },
        },
    ],
}),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致使用方式如上所示，HappyPack的配置讲解文章有很多，不会配的同学可以自己搜索，本文这里只是顺带说说而已。&lt;/p&gt;
&lt;p&gt;HappyPack老早也没有维护了，它对url-loader的处理是有问题的，会导致经过url-loader处理的图片都无效，笔者之前也去提过一个Issue，有别的开发者也发现过这个问题。总之，用的时候一定要测试一下。&lt;/p&gt;
&lt;p&gt;对于多线程的优势，我们举个例子：&lt;br/&gt;比如我们有四个任务，命名为A、B、C、D。&lt;/p&gt;
&lt;p&gt;任务A：耗时5秒&lt;/p&gt;
&lt;p&gt;任务B：耗时7秒&lt;/p&gt;
&lt;p&gt;任务C：耗时4秒&lt;/p&gt;
&lt;p&gt;任务D：耗时6秒&lt;/p&gt;
&lt;p&gt;单线程串行处理的总耗时大约在22秒。&lt;/p&gt;
&lt;p&gt;改成多线程并行处理后，总耗时大约在7秒，也就是那个最耗时的任务B的执行时长，仅仅通过配置多线程处理我们就能得到大幅的编译速度提升。&lt;/p&gt;
&lt;p&gt;写到这里，大家是不是觉得编译速度优化就可以到此结束了？哈哈，当然不是，上面这个例子在实际的项目中根本不具有广泛的代表性，笔者实际项目的情况是这样的：&lt;/p&gt;
&lt;p&gt;我们有四个任务，命名为A、B、C、D。&lt;/p&gt;
&lt;p&gt;任务A：耗时5秒&lt;/p&gt;
&lt;p&gt;任务B：耗时60秒&lt;/p&gt;
&lt;p&gt;任务C：耗时4秒&lt;/p&gt;
&lt;p&gt;任务D：耗时6秒&lt;/p&gt;
&lt;p&gt;单线程串行处理的总耗时大约在75秒。&lt;/p&gt;
&lt;p&gt;改成多线程并行处理后，总耗时大约在60秒，从75秒优化到60秒，确实有速度上的提升，但是因为任务B的耗时太长了，导致整个项目的编译速度并没有发生本质上的变化。事实上笔者之前那套Webpack3.X的架子就是因为这个问题导致编译速度慢，所以，只靠引入多线程就想解决大项目编译速度慢的问题是不现实的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191225205903242-1856845420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们还有什么办法吗？当然有，我们还是可以从TerserPlugin得到灵感，那就是依靠缓存：在下一次的编译中能够复用上一次的结果而不执行编译永远是最快的。&lt;/p&gt;
&lt;p&gt;至少存在有这三种方式，可以让我们在执行构建时不进行某些文件的编译，从最本质上提升前端项目整体的构建速度：&lt;/p&gt;
&lt;p&gt;1. 类似于terser-webpack-plugin的cache那种方式，这个插件的cache默认生成在node_modules/.cache/terser-plugin文件下，通过SHA或者base64编码之前的文件处理结果，并保存文件映射关系，方便下一次处理文件时可以查看之前同文件（同内容）是否有可用缓存。其他Webpack平台的工具也有类似功能，但缓存方式不一定相同。&lt;/p&gt;
&lt;p&gt;2. 通过externals配置在编译的时候直接忽略掉外部库的依赖，不对它们进行编译，而是在运行的时候，通过&amp;lt;script&amp;gt;标签直接从CDN服务器下载这些库的生产环境文件。&lt;/p&gt;
&lt;p&gt;3. 将某些可以库文件编译以后保存起来，每次编译的时候直接跳过它们，但在最终编译后的代码中能够引用到它们，这就是Webpack DLLPlugin所做的工作，DLL借鉴至Windows动态链接库的概念。&lt;/p&gt;
&lt;p&gt;后面的段落将针对这几种方式做讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、Loader的Cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了段落一中提到的terser-webpack-plugin和babel-loader支持cache外，Webpack还直接另外提供了一种可以用来缓存前序Loader处理结果的Loader，它就是cache-loader。通常我们可以将耗时的Loader都通过cache-laoder来缓存编译结果。比如我们打生产环境的包，对于Less文件的缓存你可以这样使用它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    test: &lt;/span&gt;/\.less$/&lt;span&gt;,
    use: [
        {
            loader: MiniCssExtractPlugin.loader,
            options: {
                ...省略
            },
        },
        {
            loader: &lt;/span&gt;'cache-loader'&lt;span&gt;,
            options: {
                cacheDirectory: paths.appPackCacheCSS,
            }
        },
        { 
            loader: require.resolve(&lt;/span&gt;'css-loader'&lt;span&gt;),
            options: {
                ...省略
            },
        },
        {
            loader: require.resolve(&lt;/span&gt;'postcss-loader'&lt;span&gt;),
            options: {
                ...省略
            }
        }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Loader的执行顺序是从下至上，因此通过上述配置，我们可以通过cache-laoder缓存postcss-loader和css-loader的编译结果。&lt;/p&gt;
&lt;p&gt;但我们不能用cache-loader去缓存mini-css-extract-plugin的结果，因为它的作用是要从前序Loader编译成的含有样式字符串的JS文件中把样式字符串单独抽出来打成独立的CSS文件，而缓存这些独立CSS文件并不是cache-loader的工作。&lt;/p&gt;
&lt;p&gt;但如果是要缓存开发环境的Less编译结果，cache-loader可以缓存style-loader的结果，因为style-loader并没有从JS文件中单独抽出样式代码，只是在编译后的代码中添加了一些额外代码，让编译后的代码在运行时，能够创建包含样式的&amp;lt;style&amp;gt;标签并放入&amp;lt;head&amp;gt;标签内，这样的性能不是太好，所以基本上只有开发环境采用这种方式。&lt;/p&gt;
&lt;p&gt;在对样式文件配置cache-loader的时候，一定要记住上述这两点，要不然会出现样式无法正确编译的问题。&lt;/p&gt;
&lt;p&gt;除了对样式文件的编译结果进行缓存外，对其他类型的文件（除了会打包成独立的文件外）的编译结果进行缓存也是可以的。比如url-laoder，只要大小没有达到limitation的图片都会被打成base64，大于limitation的文件会打成单独的图片类文件，就不能被cache-loader缓存了，如果遇到了这种情况，资源请求会404，这是在使用cache-loader时需要注意的。&lt;/p&gt;
&lt;p&gt;当然，通过使用缓存能得到显著编译速度提升的，依旧是那些耗时的Loader，如果对某些类型的文件编译并不耗时，或者说文件本身数量太少，都可以先不必做缓存，因为即便做了缓存，编译速度的提升也不明显。&lt;/p&gt;
&lt;p&gt;最后笔者将所有Loader和Plugin的cache默认目录从node_modules/.cache/移到了项目根目录的build_pack_cache/目录（生产环境）和dev_pack_cache目录（开发环境），通过NODE_ENV自动区分。这么做是因为笔者的CI工程每次会删除之前的node_modules文件夹，并从node_modules.tar.gz解压一个新的node_modules文件夹，所以将缓存放在node_modules/.cache/目录里面会无效，笔者也不想去动CI的代码。通过这个改动，对cache文件的管理更直观一些，也能避免node_modules的体积一直增大。如果想清除缓存，直接删掉对应目录即可。当然了，这两个个目录是不需要被Git跟踪的，所以需要在.gitignore中添加上。CI环境中如果没有对应的缓存目录，相关Loader会自动创建。而且，因为开发环境和生产环境编译出的资源是不同的，在开发环境下对资源的编译往往都没有做压缩和混淆处理等，为了有效地缓存不同环境下的编译结果，需要区分开缓存目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、外部扩展externals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照Webpack官方的说法：我们的项目如果想用一个库，但我们又不想Webpack对它进行编译（因为它的源码很可能已是经过编译和优化的生产包，可以直接使用）。并且我们可能通过window全局方式来访问它，或者通过各种模块化的方式来访问它，那么我们就可以把它配置进extenals里。&lt;/p&gt;
&lt;p&gt;比如我要使用jquery可以这样配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;externals: {
    jquery: &lt;/span&gt;'jQuery'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我就可以这样使用了，就像我们直接引入一个在node_modules中的包一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import $ from 'jquery'&lt;span&gt;;

$(&lt;/span&gt;'.div').hide();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做能有效的前提就是我们在HTML文件中在上述代码执行以前就已经通过了&amp;lt;script&amp;gt;标签从CDN下载了我们需要的依赖库了，externals配置会自动在承载我们应用的html文件中加入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;https://code.jquery.com/jquery-1.1.14.js&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;externals还支持其他灵活的配置语法，比如我只想访问库中的某些方法，我们甚至可以把这些方法附加到window对象上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;externals : {
    subtract : {
        root: [&lt;/span&gt;&quot;math&quot;, &quot;subtract&quot;&lt;span&gt;]
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我就可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;window.math.subtract&lt;/span&gt; 来访问subtract方法了。&lt;/p&gt;
&lt;p&gt;对于其他配置方式如果有兴趣的话可以自行查看文档。&lt;/p&gt;
&lt;p&gt;但是，笔者的项目并没有这么做，因为在它最终交付给客户后，应该是处于一个内网环境（或者一个被防火墙严重限制的环境）中，极大可能无法访问任何互联网资源，因此通过&amp;lt;script&amp;gt;脚本请求CDN资源的方式将失效，前置依赖无法正常下载就会导致整个应用奔溃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、DllPlugin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上个段落中的结尾处，提到了笔者的项目在交付用户后会面临的网络困境，所以笔者必须选择另外一个方式来实现类似于externals配置能够提供的功能。那就是Webpack DLLPlugin以及它的好搭档DLLReferencePlugin。笔者有关DLLPlugin的使用都是在构建生产包的时候使用。&lt;/p&gt;
&lt;p&gt;要使用DLLPlugiin，我们需要单独开一个webpack配置，暂且将其命名为webpack.dll.config.js，以便和主Webpack的配置文件webpack.config.js进行区分。内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
'use strict';
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;process.env.NODE_ENV &lt;/span&gt;= 'production'&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
const webpack &lt;/span&gt;= require('webpack'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const {dll} &lt;/span&gt;= require('./dll'&lt;span&gt;);
const DllPlugin &lt;/span&gt;= require('webpack/lib/DllPlugin'&lt;span&gt;);
const TerserPlugin &lt;/span&gt;= require('terser-webpack-plugin'&lt;span&gt;);
const getClientEnvironment &lt;/span&gt;= require('./env'&lt;span&gt;);
const paths &lt;/span&gt;= require('./paths'&lt;span&gt;);
const shouldUseSourceMap &lt;/span&gt;= process.env.GENERATE_SOURCEMAP !== 'false'&lt;span&gt;;

module.exports &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt; (webpackEnv = 'production'&lt;span&gt;) {
    const isEnvDevelopment &lt;/span&gt;= webpackEnv === 'development'&lt;span&gt;;
    const isEnvProduction &lt;/span&gt;= webpackEnv === 'production'&lt;span&gt;;

    const publicPath &lt;/span&gt;= isEnvProduction ? paths.servedPath : isEnvDevelopment &amp;amp;&amp;amp; '/'&lt;span&gt;;

    const publicUrl &lt;/span&gt;= isEnvProduction ? publicPath.slice(0, -1) : isEnvDevelopment &amp;amp;&amp;amp; ''&lt;span&gt;;
    const env &lt;/span&gt;=&lt;span&gt; getClientEnvironment(publicUrl);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        mode: isEnvProduction &lt;/span&gt;?
            'production'&lt;span&gt; :
            isEnvDevelopment &lt;/span&gt;&amp;amp;&amp;amp; 'development'&lt;span&gt;,
        devtool: isEnvProduction &lt;/span&gt;?
            'source-map'&lt;span&gt; :
            isEnvDevelopment &lt;/span&gt;&amp;amp;&amp;amp; 'cheap-module-source-map'&lt;span&gt;,
        entry: dll,
        output: {
            path: isEnvProduction &lt;/span&gt;?&lt;span&gt; paths.appBuildDll : undefined,
            filename: &lt;/span&gt;'[name].dll.js'&lt;span&gt;,
            library: &lt;/span&gt;'[name]_dll_[hash]'&lt;span&gt;
        },
        optimization: {
            minimize: isEnvProduction,
            minimizer: [
                ...省略
            ]
        },
        plugins: [
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin(env.stringified),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllPlugin({
                context: path.resolve(__dirname),
                path: path.resolve(paths.appBuildDll, &lt;/span&gt;'[name].manifest.json'&lt;span&gt;),
                name: &lt;/span&gt;'[name]_dll_[hash]'&lt;span&gt;,
            }),
        ],
    };
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了方便DLL的管理，我们还单独开了个dll.js文件来管理webpack.dll.config.js的入口entry，我们把所有需要DLLPlugin处理的库都记录在这个文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
const dll =&lt;span&gt; {
    core: [
        &lt;/span&gt;'react'&lt;span&gt;,
        &lt;/span&gt;'@hot-loader/react-dom'&lt;span&gt;,
        &lt;/span&gt;'react-router-dom'&lt;span&gt;,
        &lt;/span&gt;'prop-types'&lt;span&gt;,
        &lt;/span&gt;'antd/lib/badge'&lt;span&gt;,
        &lt;/span&gt;'antd/lib/button'&lt;span&gt;,
        &lt;/span&gt;'antd/lib/checkbox'&lt;span&gt;,
        &lt;/span&gt;'antd/lib/col'&lt;span&gt;,
        ...省略
    ],
    tool: [
        &lt;/span&gt;'js-cookie'&lt;span&gt;,
        &lt;/span&gt;'crypto-js/md5'&lt;span&gt;,
        &lt;/span&gt;'ramda/src/curry'&lt;span&gt;,
        &lt;/span&gt;'ramda/src/equals'&lt;span&gt;,
    ],
    shim: [
        &lt;/span&gt;'whatwg-fetch'&lt;span&gt;,
        &lt;/span&gt;'ric-shim'&lt;span&gt;
    ],
    widget: [
        &lt;/span&gt;'cecharts'&lt;span&gt;,
    ],
};

module.exports &lt;/span&gt;=&lt;span&gt; {
    dll,
    dllNames: Object.keys(dll),
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于要把哪些库放入DLL中，请根据自己项目的情况来定，对于一些特别大的库，又没法做模块分割和不支持Tree Shaking的，比如Echarts，建议先去官网按项目所需功能定制一套，不要直接使用整个Echarts库，否则会白白消耗许多的下载时间，JS预处理的时间也会增长，减弱首屏性能。&lt;/p&gt;
&lt;p&gt;然后我们在webpack.config.js的plugins配置中加入DLLReferencePlguin来对DLLPlugin处理的库进行映射，好让编译后的代码能够从window对象中找到它们所依赖的库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    ...省略

    plugins: [
        ...省略
        
        &lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;这里的...用于延展开数组，因为我们的DLL有多个，每个单独的DLL输出都需要有一个DLLReferencePlguin与之对应，去获取DLLPlugin输出的manifest.json库映射文件。&lt;br/&gt;　　　　 // dev环境下暂不采用DLLPlugin优化。&lt;/span&gt;
        ...(isEnvProduction ?&lt;span&gt;
            dllNames.map(dllName &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DllReferencePlugin({
                context: path.resolve(__dirname),
                manifest: path.resolve(__dirname, &lt;/span&gt;'..', `build/static/dll/${dllName}.manifest.json`)
&lt;span&gt;            })) :
            []
        ),

        ...省略
    ]

    ...
}
            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还需要在承载我们应用的index.html模板中加入&amp;lt;script&amp;gt;，从webpack.dll.config.js里配置的output输出文件夹中前置引用这些DLL库。对于这个工作DLLPlguin和它的搭档不会帮我们做这件事情，而已有的html-webpack-plugin也不能帮助我们去做这件事情，因为我们没法通过它往index.html模板加入特定内容，但它有个增强版的兄弟script-ext-html-webpack-plugin可以帮我们做这件事情，笔者之前也用过这个插件内联JS到index.html中。但笔者懒得再往node_modules中加依赖包了，另辟了一个蹊径：&lt;/p&gt;
&lt;p&gt;CRA这套架子已经使用了DefinePlugin来在编译时创建全局变量，最常用的就是创建process环境变量，让我们的代码可以分辨是开发还是生产环境，既然已有这样的设计，何不继续使用，让DLLPlugn编译的独立JS文件名暴露在某个全局变量下，并在index.html模板中循环这个变量数组，循环创建&amp;lt;script&amp;gt;标签不就行了，在上面提到的dll.js文件中最后导出的 &lt;span class=&quot;cnblogs_code&quot;&gt;dllNames&lt;/span&gt; 就是这个数组。&lt;/p&gt;
&lt;p&gt;然后我们改造一下index.html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;%&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (process.env.NODE_ENV &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) { &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; process.env.DLL_NAMES.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dllName){ &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/static/dll/&amp;lt;%= dllName %&amp;gt;.dll.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; }) &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Please allow your browser to run JavaScript scripts.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;noscript&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们改造一下build.js脚本，加入打包DLL的步骤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; buildDll (previousFileSizes){
    let allDllExisted &lt;/span&gt;= dllNames.every(dllName =&amp;gt;&lt;span&gt;
        fs.existsSync(path.resolve(paths.appBuildDll, `${dllName}.dll.js`)) &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
        fs.existsSync(path.resolve(paths.appBuildDll, `${dllName}.manifest.json`))
    );
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (allDllExisted){
        console.log(chalk.cyan(&lt;/span&gt;'Dll is already existed, will run production build directly...\n'&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.resolve();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(chalk.cyan(&lt;/span&gt;'Dll missing or incomplete, first starts compiling dll...\n'&lt;span&gt;));
        const dllCompiler &lt;/span&gt;=&lt;span&gt; webpack(dllConfig);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
            dllCompiler.run((err, stats) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                ...省略
            })
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;checkBrowsers(paths.appPath, isInteractive)
    .then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start dll webpack build.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buildDll();
    })
    .then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, read the current file sizes in build directory.&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lets us display how much they changed later.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; measureFileSizesBeforeBuild(paths.appBuild);
    })
    .then(previousFileSizes &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove folders contains hash files, but leave static/dll folder.&lt;/span&gt;
&lt;span&gt;        fs.emptyDirSync(paths.appBuildCSS);
        fs.emptyDirSync(paths.appBuildJS);
        fs.emptyDirSync(paths.appBuildMedia);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Merge with the public folder&lt;/span&gt;
&lt;span&gt;        copyPublicFolder();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start the primary webpack build&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; build(previousFileSizes);
    })
    .then(({stats, previousFileSizes, warnings}) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        ... 省略
    })
    ... 省略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致逻辑就是如果xxx.dll.js文件存在且对应的xxx.manifest.json也存在，那么就不重新编译DLL，如果缺失任意一个，就重新编译。DLL的编译过程走完后再进行主包的编译。由于我们将DLLPlugin编译出的文件也放入build文件夹中，所以之前每次开始编译主包都需要清空整个build文件夹的操作也修改为了仅仅清空除了放置有dll.js和manifest.json的目录。&lt;/p&gt;
&lt;p&gt;如果我们的底层依赖库确实发生了变化，需要我们更新DLL，按照之前的检测逻辑，我们只需要删除整个某个dll.js文件即可，或者直接删除掉整个build文件夹。&lt;/p&gt;
&lt;p&gt;哈哈，到此所有的有关DLL的配置就完成了，大功告成。&lt;/p&gt;
&lt;p&gt;本段落开始时有提到过DLLPlugin的使用都是在生产环境下。因为开发环境下的打包情况很特殊而且复杂：&lt;/p&gt;
&lt;p&gt;在开发环境下整个应用是通过webpack-dev-server来打包并起一个Express服务来serve的。Express服务在内部挂载了webpack-dev-middleware作为中间件，webpack-dev-middleware可以实现serve由Webpack compiler编译出的所有资源、将所有的资源打入内存文件系统中的功能，并能结合dev-sever实现监听源文件改动并提供HRM。webpack-dev-server接收了一个Webpack compiler和一个有关HTTP配置的config作为实例化时的参数。这个compiler会在webpack-dev-middleware中执行，用监听方式启动compiler后，compiler的outputFileSystem会被webpack-dev-middleware替换成内存文件系统，其执行后打包出来的东西都没有实际落盘，而是存放在了这个内存文件系统中，而ouputFileSystem本身是在Node.js的fs模块基础上封装的。将编译结果存放进内存中是webpack-dev-middleware内部最奇妙的地方。&lt;/p&gt;
&lt;p&gt;当我们的在开发环境的前端界面中发起一个静态资源请求，请求到达dev-server后，经过路由的判断，这个静态资源都会被重定向到内存文件系统中去获取资源，资源在内存中是二进制格式，以返回流的形式来响应请求，并且在response的时候会为content-type加上对应的MIME类型，浏览器拿到数据流后再根据response header中content-type的值就能正确解析服务器返回的资源了。事实上就算将文件资源落盘，也必须先把文件从磁盘读到内存中，再以流的形式返回给客户端，这样一来会多一个从磁盘中将文件读进内存的步骤，反而还没有直接操作内存快。内存文件系统在npm start起得进程被干掉后，就被回收了，下一次再起进程的时候，会创建一个全新的内存文件系统。&lt;/p&gt;
&lt;p&gt;所有，由于开发环境打包的特殊性，怎么在开发环境使用DLLPlugin还需要再研究下。因此笔者只是在开发环境使用了多线程和各种缓存。由于开发环境下，编译的工作量少于生产环境，并且对所有资源的读写都是走内存的，因此速度很快，每次检测到源文件变动并进行重编译的过程也会很快。所以开发环境的编译速度在目前来看还可以接受，暂时不需要优化。&lt;/p&gt;
&lt;p&gt;这里顺带说一句，笔者之前在看有关DLLPlugin的文档和文章时，也注意到了一个现象，就是很多人都说DLLPlugin过时了，externals使用起来更方便，配置更简单，甚至在CRA、vue-cli这些最佳实践的脚手架中都已经没再继续使用DLLPlugin了，因为Webpack4.x的编译速度已经足够快了。笔者的体会就是：我这个项目就是基于Webpack4.X的，项目规模变大以后，没有觉得4.X有多么地快。笔者的项目在交付客户后也极大可能不能访问互联网，所以externals配置对笔者的项目来说没有用，只能通过使用DLLPlugin提高生产包的编译速度。我想这也是为什么Webpack到了4.X版本依然没有去掉DLLPlugin的原因，因为不是所有的前端项目都一定是互联网项目。还是那句话：实践出真知，不要人云亦云。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、编译速度提升了多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者开发机4和8线程，单核基础频率2.2GHz。所有测试都基于已对Echarts进行功能定制。&lt;/p&gt;
&lt;p&gt;1. 最原始的CRA脚手架编译笔者这个项目的速度。&lt;/p&gt;
&lt;p&gt;初次打包，无任何CRA原始配置的缓存，这和最初在CI上进行构建的情况完全一样，因为每次node_moduels都要删除重来，无法缓存任何结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226104518659-617059374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概1分10多秒。&lt;/p&gt;
&lt;p&gt;有缓存以后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226104710522-441434642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不定制Echarts的话，直接引入整个Echarts，在没缓存的时候大概会多5秒时间。&lt;/p&gt;

&lt;p&gt;2. 引入dll后。&lt;/p&gt;
&lt;p&gt;初次打包，并且无任何DLL文件和CRA原始配置的缓存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226110627311-829891264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先编译DLL，再编译主包，整个过程耗时直接变成了57秒。&lt;/p&gt;
&lt;p&gt;有DLL文件和缓存后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226110727481-236652564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;降到27秒多了。&lt;/p&gt;

&lt;p&gt;3.最后我们把多线程和cache-loader上了：&lt;/p&gt;
&lt;p&gt;无任何DLL文件、CRA原始配置的缓存以及cache-loader的缓存时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226113106045-179431004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概在接近60秒左右。&lt;/p&gt;
&lt;p&gt;有DLL文件和所有缓存后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986162/201912/986162-20191226113348555-1496284738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终，耗时已经下降至17秒左右了。在CI的服务器上执行，速度还会更快些。&lt;/p&gt;
&lt;p&gt;在打包速度上，比最原始的1分10多秒耗时已经有本质上的提升了。这才是我们想要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经将所有底层依赖DLL化了，几乎所有能做缓存的东西都缓存了，并支持多线程编译。当项目稳定后，无论项目规模多大，小幅度的修改将始终保持在这个编译速度，耗时不会有太大的变化。&lt;/p&gt;
&lt;p&gt;据说在Webpack5.X带来了全新的编译性能体验，很期待使用它的时候。谈及到此，笔者只觉得有淡淡的忧伤，那就是前端技术、工具、框架、开发理念这些的更新速度实在是太快了。就拿Webpack这套构建平台来说，当Webpack5.X普及后，Webpack4.X这套优化可能也就过时了，又需要重新学习了。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:26:00 +0000</pubDate>
<dc:creator>james&amp;#183;von</dc:creator>
<og:description>当你的应用的规模还很小时，你可能不会在乎Webpack的编译速度，无论使用3.X还是4.X版本，它都足够快，或者说至少没让你等得不耐烦。但随着业务的增多，嗖嗖嗖一下项目就有上百个组件了，也是件很简单的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rock-roll/p/12093553.html</dc:identifier>
</item>
<item>
<title>Redis安装（单机及各类集群，阿里云） - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12115156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12115156.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上周，我朋友突然悄悄咪咪地指着手机上的一篇博客说，这是你的博客吧。我看了一眼，是之前发布的《Rabbit安装（单机及集群，阿里云》。我朋友很哈皮地告诉我，我的博客被某个Java平台进行了微信推送。看到许多人阅读，并认同了我的博客，心理还是很开心的。&lt;/p&gt;
&lt;p&gt;好了，话题收回来。这次就Redis在实际服务器中的各种安装，进行详细描述。&lt;/p&gt;
&lt;p&gt;另外由于内容较多，并不一定能涵盖各个方面，万望见谅。如果存在什么问题，或者有什么需要添加的，请私信或@我。&lt;/p&gt;
&lt;p&gt;最后，由于打马赛克太麻烦了。并且我之后可能会开放安装视频，所以有的IP什么的，我并不方便打马赛克。但是希望你们不要做坏事儿哈。&lt;/p&gt;
&lt;h2 id=&quot;redis安装简述&quot;&gt;Redis安装简述&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;Redis是一款缓存中间件，其安装分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单机&lt;/li&gt;
&lt;li&gt;主从赋值&lt;/li&gt;
&lt;li&gt;哨兵机制&lt;/li&gt;
&lt;li&gt;哨兵集群&lt;/li&gt;
&lt;li&gt;分片集群&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;redis通过解压包中的src下的各类程序，直接应用。&lt;/p&gt;
&lt;p&gt;常用的程序有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis-server&lt;/li&gt;
&lt;li&gt;redis-cli&lt;/li&gt;
&lt;li&gt;redis-sentinel&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装环境&quot;&gt;安装环境&lt;/h3&gt;
&lt;p&gt;平台：阿里云&lt;/p&gt;
&lt;p&gt;ECS实例规格：ecs.t5-lc1m1.small (性能约束实例)&lt;/p&gt;
&lt;p&gt;CPU：单核&lt;/p&gt;
&lt;p&gt;内存：1G&lt;/p&gt;
&lt;p&gt;硬盘：40G&lt;/p&gt;
&lt;p&gt;操作系统：CentOS7.6（已经测试CentOS7.3会出现问题）&lt;/p&gt;
&lt;p&gt;购买ECS，用于平时测试，学习的话，四点建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只需要购买共享型，比较适合平时用得不多，测试也负担不大，偶尔压测。&lt;/li&gt;
&lt;li&gt;如果资金允许，直接购买将长时间，比较划算。日后需要也可以提升配置。&lt;/li&gt;
&lt;li&gt;阿里云部分地区有优惠（目前有两个地区）&lt;/li&gt;
&lt;li&gt;如果想要尝试集群等操作，并且打算购买多个服务器，请一定要在同一个内网内，这样才可以利用内网通信。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;防火墙&quot;&gt;防火墙&lt;/h3&gt;
&lt;p&gt;云服务器的防火墙，我依旧将其分为云平台的安全策略与服务器本身的防火墙服务。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;阿里云的官方CentOS7.6镜像，是不开启firewall&lt;/strong&gt;。可以通过systemctl status firewalld来进行确认。&lt;/p&gt;
&lt;p&gt;而云平台的安全策略是需要在安全组内进行设置的。这个部分网上很多资料，就不在此赘述了。&lt;/p&gt;
&lt;p&gt;而RabbitMQ需要开放6379端口（默认的redis通信接口，可以在配置文件中修改），26380（本次开放给哨兵的端口）两个端口。&lt;/p&gt;
&lt;h2 id=&quot;单机安装&quot;&gt;单机安装&lt;/h2&gt;
&lt;h3 id=&quot;下载程序包&quot;&gt;下载程序包&lt;/h3&gt;
&lt;p&gt;在阿里云的Linux上可以通过以下方式，进行下载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget http://download.redis.io/releases/redis-5.0.3.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样因为XXX缘故，速度可能会比较感人，这里同样提供网盘下载。&lt;/p&gt;
&lt;blockquote readability=&quot;3.1666666666667&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1-TaLbHCEKCeE5yF9J7gxqA&quot;&gt;redis-5.0.3&lt;/a&gt;：提取码：6loe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建文件夹&quot;&gt;创建文件夹&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /developer/redis/conf
mkdir /developer/redis/data
mkdir /developer/redis/logs&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解压文件&quot;&gt;解压文件&lt;/h3&gt;
&lt;p&gt;（说明一下，我的压缩包是放在/developer目录下的。如果不在此目录，请指定解压目录）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf redis-5.0.3.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;无配置默认配置启动&quot;&gt;无配置（默认配置）启动&lt;/h3&gt;
&lt;p&gt;为了避免由于目录，造成理解错误，这里采用绝对路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功启动后，会看到如下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223170112793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;为了避免”裸奔“，这里还是配置一下配置文件。&lt;/p&gt;
&lt;h4 id=&quot;新建配置文件&quot;&gt;新建配置文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;touch /developer/redis/conf/redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置文件-1&quot;&gt;配置文件&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    # 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改
    #后台启动的意思
    daemonize yes
    #端口号(如果同一台服务器上启动多个redis实例，注意要修改为不同的端口)
    port 6379
    # IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病。也可以直接注释
    #bind 0.0.0.0
    # 这个文件会自动生成(如果同一台服务器上启动，注意要修改为不同的端口)。多台服务器，直接默认即可
    #pidfile /var/run/redis_6379.pid
    # 关闭保护模式（默认是开启的。开启后，只能通过配置bind ip或者设置访问密码，才可以访问）
    protected-mode no
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件启动&quot;&gt;配置文件启动&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-server /developer/redis/conf/redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样启动后，会出现以下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223164926618.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;单机启动的各类问题&quot;&gt;单机启动的各类问题&lt;/h3&gt;
&lt;p&gt;单机启动时，会看到下面图片中标出的三个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223170230347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;修改linux内核参数&quot;&gt;修改Linux内核参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;WARNING The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo 1024 &amp;gt;/proc/sys/net/core/somaxconn&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;overcommit_memory问题&quot;&gt;overcommit_memory问题&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;vm.overcommit_memory = 1&quot; &amp;gt;&amp;gt; /etc/sysctl.conf

sysctl vm.overcommit_memory=1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;thp问题&quot;&gt;THP问题&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;校验&quot;&gt;校验&lt;/h3&gt;
&lt;p&gt;为了更好的校验，这里给大家提供一个工具-&lt;a href=&quot;https://redisdesktop.com/&quot;&gt;Redis-desktop-manager&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.375&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1crkJ-yUic9AZeGFqlts_gg&quot;&gt;redis-desktop-manager&lt;/a&gt;：提取码：jdc2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作为正版软件，会有14天的试用期。当然，如果几乎不用，也可以使用盗版。但是还是推荐正版的说（正版功能强大），貌似还有github提交，就可以免费的说法（起码以前是存在的，现在就不清楚了）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果看到以下画面，就表示OK了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223171049273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，可以通过以下命令校验：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli -p 6379 info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般看到如下画面即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223171315290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis主从复制&quot;&gt;Redis主从复制&lt;/h2&gt;
&lt;p&gt;Redis的主从复制还是较为简单的。&lt;/p&gt;
&lt;p&gt;主要分为两个方面，一方面是多个独立的Redis实例，另一方面是Redis的slaveof配置（共有三种方式）。&lt;/p&gt;
&lt;h3 id=&quot;redis文件发送&quot;&gt;Redis文件发送&lt;/h3&gt;
&lt;p&gt;通过以下命令，进行Redis的文件发送：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scp -r /developer/ root@172.26.40.224:/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述命令，是将当前服务器的/developer目录整个（-r 表示递归）发送给172.26.40.224服务器。&lt;/p&gt;
&lt;h3 id=&quot;slaveof配置&quot;&gt;slaveof配置&lt;/h3&gt;
&lt;p&gt;这里的Redis主服务器的地址为172.26.40.225，其端口为6379&lt;/p&gt;
&lt;h4 id=&quot;配置文件设置&quot;&gt;配置文件设置&lt;/h4&gt;
&lt;p&gt;在配置文件中添加以下语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;slaveof 172.26.40.225 6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常启动，控制台并不会有专门的提示，正常如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223172548949.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;redis-server启动时配置参数&quot;&gt;redis-server启动时配置参数&lt;/h4&gt;
&lt;p&gt;这种情况下，无法使用配置文件。&lt;/p&gt;
&lt;p&gt;起码没法直接使用，可能我的使用存在问题（平时不用这个）。囧&lt;/p&gt;
&lt;p&gt;正常使用，可以看到如下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223173853514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;redis-cli运行时设置&quot;&gt;redis-cli运行时设置&lt;/h4&gt;
&lt;p&gt;而通过redis-cli程序，在程序运行时，进行集群调整。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223174008108.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;脱离集群&quot;&gt;脱离集群&lt;/h3&gt;
&lt;p&gt;扩展一下，有的时候，我们需要将实例，移出当前集群。&lt;/p&gt;
&lt;p&gt;既然是运行时，那当然是通过redis-cli程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191223174144235.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;校验-1&quot;&gt;校验&lt;/h3&gt;
&lt;p&gt;可以通过以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli -p 6379 info replication&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别查看Redis实例信息。&lt;/p&gt;
&lt;p&gt;如果看到以下页面，表示Redis主从集群正常启动：&lt;/p&gt;
&lt;h4 id=&quot;redis主实例&quot;&gt;Redis主实例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224095514705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;redis从实例&quot;&gt;Redis从实例：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224095602283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读写分离应用&quot;&gt;读写分离应用&lt;/h3&gt;
&lt;p&gt;这里简单谈一下，程序如何使用读写分离，如Jedis如何实现读写分离。&lt;/p&gt;
&lt;p&gt;目前看到的主要有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立多个Jedis对象，并通过Jedsi.slaveof来设定主从&lt;/li&gt;
&lt;li&gt;在配置文件中建立多个redis数据源，并通过动态转换类，实现在不同需求时，注入不同的redis连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然上述编码并不友好，一方面这些硬编码在应用程序中（这个可以通过配置来解决），另一方面存在一致性与扩展性问题（程序中的设置，与Redis的集群本身耦合较高。至于这属于哪种级别的耦合，我忘了。囧）。&lt;/p&gt;
&lt;p&gt;当然，我们也可以只获取Redis主实例的连接信息，再通过拼接”info replication“命令等，来获取Redis从实例的连接信息。&lt;/p&gt;
&lt;p&gt;这样就提高了系统扩展性，因为不再受限于Redis从实例设置。但如果Redis主实例挂了，就比较尴尬了。不过，我们也可以继续深入去进行Redis主实例监听，从而便于进行主从切换等。&lt;/p&gt;
&lt;p&gt;而这儿，就引出了哨兵机制。&lt;/p&gt;
&lt;p&gt;（不是只谈安装嘛。但是一时忍不住，就简单谈一下自己的思路哈）&lt;/p&gt;
&lt;h2 id=&quot;哨兵机制&quot;&gt;哨兵机制&lt;/h2&gt;
&lt;p&gt;正如其名，哨兵机制类似于一个Redis主从集群的代理，对应用程序透明，从而避免应用程序与Redis集群机制的高度耦合。&lt;/p&gt;
&lt;p&gt;说个人话，哨兵会根据Redis集群情况，自行进行主从切换，从而确保为应用程序提供有效的Redis缓存服务。&lt;/p&gt;
&lt;p&gt;接下来就开始Redis哨兵机制的部署吧。&lt;/p&gt;
&lt;h3 id=&quot;启动redis主从集群&quot;&gt;启动Redis主从集群&lt;/h3&gt;
&lt;p&gt;Redis哨兵机制是基于Redis主从集群的。所以首先，需要根据前面的操作步骤，安装并启动Redis主从集群。&lt;/p&gt;
&lt;p&gt;前面有详谈，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;哨兵机制的配置&quot;&gt;哨兵机制的配置&lt;/h3&gt;
&lt;p&gt;话不多说，直接上配置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    # 配置文件：sentinel.conf，在sentinel运行期间是会被动态修改的
    # sentinel如果重启时，根据这个配置来恢复其之前所监控的redis集群的状态
    # 绑定IP
    #bind 0.0.0.0
    # 后台运行
    daemonize yes
    # 默认yes，没指定密码或者指定IP的情况下，外网无法访问
    protected-mode no
    # 哨兵的端口，客户端通过这个端口来发现redis
    port 26380
    # 哨兵自己的IP，手动设定也可自动发现，用于与其他哨兵通信
    # sentinel announce-ip
    # 临时文件夹
    dir &quot;/developer/redis/tmp&quot;
    # 日志
    logfile &quot;/developer/redis/logs/sentinel-26380.log&quot;
    # sentinel监控的master的名字叫做mymaster,(redis的master服务器，哨兵需要通过这个master获取集群信息）初始地址为 172.26.40.223 6379,2代表两个及以上哨兵认定为死亡，才认为是真的死亡，即客观下线。由于目前是单个哨兵，所以设置为1，即主观下线等同客观下线。
    #sentinel monitor mymaster 172.26.40.223 6379 2
    sentinel monitor mymaster 172.26.40.223 6379 1
    # 发送心跳PING来确认master是否存活
    # 如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了
    sentinel down-after-milliseconds mymaster 1000
    # 如果在该时间（ms）内未能完成failover操作，则认为该failover失败
    sentinel failover-timeout mymaster 3000
    # 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长（因为越多的从实例同步新主实例，新主实例的负载压力越大，对外提供的服务能力就越弱）
    sentinel parallel-syncs mymaster 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动哨兵&quot;&gt;启动哨兵&lt;/h3&gt;
&lt;p&gt;然后就是通过以下命令，启动哨兵：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-sentinel /developer/redis/conf/sentinel.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后，光从控制台的回馈是看不到任何东西的。&lt;/p&gt;
&lt;h3 id=&quot;校验-2&quot;&gt;校验&lt;/h3&gt;
&lt;p&gt;需要通过以下命令进行校验：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli -p 26380 info sentinel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看到以下页面，表示哨兵正常启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224101753581.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，还有一个验证方式，那就是查看哨兵配置（因为哨兵正常启动后，会将持久化信息，保存在配置中）。&lt;/p&gt;
&lt;p&gt;详见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224102114592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，不仅新增了两个从服务器的信息（哨兵通过info命令，与master交互获得），还改动了原来的几处配置（生成myid，替代ip:port等）。&lt;/p&gt;
&lt;h3 id=&quot;哨兵机制的自动主从切换&quot;&gt;哨兵机制的自动主从切换&lt;/h3&gt;
&lt;p&gt;正如前面提到的，哨兵机制可以自动进行主从切换。&lt;/p&gt;
&lt;p&gt;接下来会阐述一下哨兵机制进行主从切换的内在，不感兴趣的朋友可以直接跳过。&lt;/p&gt;
&lt;p&gt;就拿上面的服务器状态，进行尝试，直接关闭Redis主实例。&lt;/p&gt;
&lt;h4 id=&quot;原redis主实例&quot;&gt;原Redis主实例&lt;/h4&gt;
&lt;p&gt;其中最引人瞩目的，自然是原Redis主实例的变化，详见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224102910303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，在原Redis主实例刚启动时，它还是独立的Redis单机实例。&lt;/p&gt;
&lt;p&gt;但是在稍等一会儿（如十秒）后，原Redis主实例就会加入原来的集群中，成为原来集群的一个slave。&lt;/p&gt;
&lt;h4 id=&quot;新redis主实例&quot;&gt;新Redis主实例&lt;/h4&gt;
&lt;p&gt;再就是新Redis主实例的变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224103256900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新Redis主实例，会从原来的slave，晋级为master。这个晋级实例的选择并不是随机的，而是有着一定规则的，以后有机会再介绍。&lt;/p&gt;
&lt;h4 id=&quot;其它redis从实例&quot;&gt;其它Redis从实例&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224103435489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其它Redis从实例，将会改变集群中的master。&lt;/p&gt;
&lt;h4 id=&quot;配置变化&quot;&gt;配置变化&lt;/h4&gt;
&lt;p&gt;其实，更为直接的观察，可以查看配置。&lt;/p&gt;
&lt;p&gt;其实，我刚开始了解哨兵时，我非常好奇一个现象。那就是原Redis主实例，在重新上线后，再次加入集群的流程是怎样的？其中的持久化信息（如IP等）是保存在哪里的？&lt;/p&gt;
&lt;p&gt;经过一番思考后，我查看了Redis配置与哨兵配置，才发现这一切都在配置中有所体现：&lt;/p&gt;
&lt;h5 id=&quot;redis配置&quot;&gt;Redis配置&lt;/h5&gt;
&lt;p&gt;哨兵机制下，Redis配置的变化，有两个时间。一个是哨兵启动时，另一个是主从切换时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224104339381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红框标记的部分，表示该Redis实例，从172.26.40.224（master）处，进行复制。&lt;/p&gt;
&lt;p&gt;如果是Redis主实例，那么其配置的红框部分则为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Generated by CONFIG REWRITE
dir &quot;/root&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;哨兵配置&quot;&gt;哨兵配置&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019122410463988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于哨兵保留了整个集群的信息，所以它可以自由控制集群中各个实例节点的状态。&lt;/p&gt;
&lt;p&gt;这也解释了原Redis实例在离开集群，重启后，为什么可以迅速回归集群。因为其在哨兵配置中已经留有“案底“了。&lt;/p&gt;
&lt;h3 id=&quot;哨兵机制的应用&quot;&gt;哨兵机制的应用&lt;/h3&gt;
&lt;p&gt;简单说，使用哨兵机制后，客户端可以直连哨兵，而不再是Redis服务实例了。&lt;/p&gt;
&lt;p&gt;这里的哨兵将类似于一个代理。&lt;/p&gt;
&lt;h2 id=&quot;哨兵集群&quot;&gt;哨兵集群&lt;/h2&gt;
&lt;p&gt;当然之前的哨兵存在单点故障问题，所以需要将哨兵构造成集群。&lt;/p&gt;
&lt;p&gt;但是哨兵的集群搭建，其实和之前并没有区别，只不过这次启动了多个哨兵而已。&lt;/p&gt;
&lt;p&gt;当然哨兵的配置可以稍作修改，来提高哨兵集群的价值。&lt;/p&gt;
&lt;h3 id=&quot;哨兵配置-1&quot;&gt;哨兵配置&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    # 配置文件：sentinel.conf，在sentinel运行期间是会被动态修改的
    # sentinel如果重启时，根据这个配置来恢复其之前所监控的redis集群的状态
    # 绑定IP
    #bind 0.0.0.0
    # 后台运行
    daemonize yes
    # 默认yes，没指定密码或者指定IP的情况下，外网无法访问
    protected-mode no
    # 哨兵的端口，客户端通过这个端口来发现redis
    port 26380
    # 哨兵自己的IP，手动设定也可自动发现，用于与其他哨兵通信
    # sentinel announce-ip
    # 临时文件夹
    dir &quot;/developer/redis/tmp&quot;
    # 日志
    logfile &quot;/developer/redis/logs/sentinel-26380.log&quot;
    # sentinel监控的master的名字叫做mymaster,(redis的master服务器，哨兵需要通过这个master获取集群信息）初始地址为 172.26.40.224 6379,2代表两个及以上哨兵认定为死亡，才认为是真的死亡，即客观下线。
    sentinel monitor mymaster 172.26.40.224 6379 2
    # 发送心跳PING来确认master是否存活
    # 如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了
    sentinel down-after-milliseconds mymaster 1000
    # 如果在该时间（ms）内未能完成failover操作，则认为该failover失败
    sentinel failover-timeout mymaster 3000
    # 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长（因为越多的从实例同步新主实例，新主实例的负载压力越大，对外提供的服务能力就越弱）
    sentinel parallel-syncs mymaster 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实就是修改了 sentinel monitor mymaster 172.26.40.224 6379 2 ，&lt;/p&gt;
&lt;p&gt;数字1改为2，是为了确保故障转移的客观性（详情了解主观下线与客观下线）。&lt;/p&gt;
&lt;p&gt;IP地址的变换，是因为现在的master是172.26.40.224而已。&lt;/p&gt;
&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;
&lt;p&gt;只需要通过以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-sentinel /developer/redis/conf/sentinel.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次启动多个哨兵实例（甚至可以在一台服务器上启动，那就需要修改哨兵配置中的端口号）&lt;/p&gt;
&lt;h3 id=&quot;校验-3&quot;&gt;校验&lt;/h3&gt;
&lt;p&gt;启动后，通过以下命令验证各个哨兵实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/redis-cli -p 26380 info sentinel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看到以下页面，则表示启动成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191224111418352.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：页面中显示了哨兵监控的Redis集群master（哨兵可以监控多个Redis集群），对应Redis集群master0的相关信息（如name，状态，主服务器ip:port，以及从服务器数量，对应哨兵数量）等。&lt;/p&gt;
&lt;h3 id=&quot;哨兵集群的应用&quot;&gt;哨兵集群的应用&lt;/h3&gt;
&lt;p&gt;哨兵集群在应用中的使用与哨兵类似，不过这次需要在应用中配置哨兵集群（即配置多个哨兵地址）。&lt;/p&gt;
&lt;h3 id=&quot;扩展&quot;&gt;扩展&lt;/h3&gt;
&lt;p&gt;忍不住多说两句。&lt;/p&gt;
&lt;p&gt;哨兵的持久化信息是保存在哨兵配置中的。&lt;/p&gt;
&lt;p&gt;哨兵之间的通信是通过Redis的pubsub机制实现的（包括互相发现）。详见：&lt;a href=&quot;https://redis.io/topics/sentinel#pubsub-messages&quot;&gt;基于pubsub机制的哨兵通信&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分片集群多主多从的混合架构&quot;&gt;分片集群（多主多从的混合架构）&lt;/h2&gt;
&lt;p&gt;前面哨兵说得再骚气，也逃不过一个瓶颈，那就是Redis写瓶颈。毕竟是一主多从的。&lt;/p&gt;
&lt;p&gt;所以当写压力超过Redis单例上限时，就需要Redis分片集群了。毕竟多主可以多个Redis主实例进行写操作，所以可以突破主从架构的写瓶颈。&lt;/p&gt;
&lt;p&gt;当然多主多从的混合架构，才是目前的主流（即每个主，都有从服务器用于确保可用性）。&lt;/p&gt;
&lt;p&gt;而混合架构会比单纯的多主无从架构，复杂一些。所以这里直接上多主多从的混合架构。&lt;/p&gt;
&lt;h3 id=&quot;配置修改&quot;&gt;配置修改&lt;/h3&gt;
&lt;p&gt;为了开启分片集群，需要修改每个Redis的配置（即之前的redis.conf）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改
#后台启动的意思
daemonize yes
#端口号(如果同一台服务器上启动，注意要修改为不同的端口)
port 6379
# IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病。这里直接外网测试吧，比较方便，生产环境不要这样。
#bind 0.0.0.0
# 这个文件会自动生成(如果同一台服务器上启动，注意要修改为不同的端口)。多台服务器，直接默认即可
#pidfile /var/run/redis_6379.pid
# 关闭保护模式（默认是开启的）
protected-mode no

# 新增配置
# 数据保存目录
dir /developer/redis/data
# 开启AOF
appendonly yes


# just for cluster
# 开启集群
cluster-enabled yes
# 集群配置会自动生成在上述的data目录
cluster-config-file cluster_node_00.conf
# 集群节点失联时长判断
cluster-node-timeout 5000
# 如果是在单台集群部署集群，需要设置pidfile。这里由于每个服务器都只有一个实例，故采用默认设置（6379）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述新增配置，均有注释。这里简单提一下，这个配置只是令单个Redis实例有了成为Redis集群实例的资格。当这些Redis实例构成集群时，集群的配置信息会由集群生成，并由每个Redis实例保存至配置中设置的目录中。&lt;/p&gt;
&lt;p&gt;这里简单展示一下，集群生成的配置（切记，这个配置只有集群启动后才有。这里只是提前展示一下）：&lt;/p&gt;
&lt;h4 id=&quot;node0&quot;&gt;node0&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2e1714431f76910db0e1808ce3a3a9b645d2c38f 172.26.40.225:6379@16379 master - 0 1577441663610 7 connected 0-99 10923-16383
cf755c2ca1757c1828b8da972fc7841305b9b41f 172.26.40.224:6379@16379 master - 0 1577441665000 2 connected 5461-10922
29c4fc9d4807c1e25a56b1cc0c9387ba1e6f5831 172.26.40.226:6379@16379 slave 45c1607ecf3d80f08cf6056d53f73a529ffc17de 0 1577441664000 1 connected
7aaa3b4a7dc9ad6c2348f9d6227c4c555e24f3fb 172.26.40.228:6379@16379 slave 2e1714431f76910db0e1808ce3a3a9b645d2c38f 0 1577441665615 7 connected
24c8fefdb293087adb40eaa45cd9213a8d7d5191 172.26.40.227:6379@16379 slave cf755c2ca1757c1828b8da972fc7841305b9b41f 0 1577441664613 5 connected
45c1607ecf3d80f08cf6056d53f73a529ffc17de 172.26.40.223:6379@16379 myself,master - 0 1577441664000 1 connected 100-5460
vars currentEpoch 7 lastVoteEpoch 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;node1&quot;&gt;node1&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;2e1714431f76910db0e1808ce3a3a9b645d2c38f 172.26.40.225:6379@16379 master - 1577441665696 1577441663000 7 connected 0-99 10923-16383
45c1607ecf3d80f08cf6056d53f73a529ffc17de 172.26.40.223:6379@16379 master - 0 1577441664000 1 connected 100-5460
29c4fc9d4807c1e25a56b1cc0c9387ba1e6f5831 172.26.40.226:6379@16379 slave 45c1607ecf3d80f08cf6056d53f73a529ffc17de 0 1577441664687 1 connected
24c8fefdb293087adb40eaa45cd9213a8d7d5191 172.26.40.227:6379@16379 slave cf755c2ca1757c1828b8da972fc7841305b9b41f 0 1577441664000 5 connected
7aaa3b4a7dc9ad6c2348f9d6227c4c555e24f3fb 172.26.40.228:6379@16379 slave 2e1714431f76910db0e1808ce3a3a9b645d2c38f 1577441665696 1577441663000 7 connected
cf755c2ca1757c1828b8da972fc7841305b9b41f 172.26.40.224:6379@16379 myself,master - 0 1577441663000 2 connected 5461-10922
vars currentEpoch 7 lastVoteEpoch 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;node5&quot;&gt;node5&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;7aaa3b4a7dc9ad6c2348f9d6227c4c555e24f3fb 172.26.40.228:6379@16379 myself,slave 2e1714431f76910db0e1808ce3a3a9b645d2c38f 0 1577441661000 6 connected
cf755c2ca1757c1828b8da972fc7841305b9b41f 172.26.40.224:6379@16379 master - 1577441665165 1577441663696 2 connected 5461-10922
2e1714431f76910db0e1808ce3a3a9b645d2c38f 172.26.40.225:6379@16379 master - 0 1577441663000 7 connected 0-99 10923-16383
45c1607ecf3d80f08cf6056d53f73a529ffc17de 172.26.40.223:6379@16379 master - 0 1577441664000 1 connected 100-5460
24c8fefdb293087adb40eaa45cd9213a8d7d5191 172.26.40.227:6379@16379 slave cf755c2ca1757c1828b8da972fc7841305b9b41f 0 1577441664665 5 connected
29c4fc9d4807c1e25a56b1cc0c9387ba1e6f5831 172.26.40.226:6379@16379 slave 45c1607ecf3d80f08cf6056d53f73a529ffc17de 0 1577441664163 1 connected
vars currentEpoch 7 lastVoteEpoch 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动redis实例&quot;&gt;启动Redis实例&lt;/h3&gt;
&lt;p&gt;在配置完成后，需要将每个组成Redis集群的实例，通过以下指令，分别启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-server /developer/redis/conf/redis.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，集群启动后，也还是可以动态增删节点的。所以不必太过担心。&lt;/p&gt;
&lt;p&gt;这里的启动与验证，与之前Redis启动是一样的，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;创建集群&quot;&gt;创建集群&lt;/h3&gt;
&lt;p&gt;在集群基本构成的各个Redis实例节点都正常启动后，接下来就是将它们串联起来，构成Redis集群。&lt;/p&gt;
&lt;p&gt;通过以下指令，构建集群（该指令只适用于5.0+版本）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster create 172.26.40.223:6379 172.26.40.224:6379 172.26.40.225:6379 172.26.40.226:6379 172.26.40.227:6379 172.26.40.228:6379 --cluster-replicas 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单解释一下这个指令，前半部分就是通过redis-cli调用集群模式（--cluster）下的create指令，将上述6个Redis实例构成集群（通过ip:port定位，所以可以单机部署集群，虽然非常鸡肋就是了）。最后部分，就是通过--cluster-replicas参数设定这个集群每个master都有1个slave实例。这里可以设置多个slave实例，并且slave实例还可以设置自己的slave实例。&lt;/p&gt;
&lt;p&gt;成功运行后，可以见到如下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191227184914322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候，直接yes确认即可，如果需要修改，可以后续调整。&lt;/p&gt;
&lt;p&gt;确认后，可以看到如下图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229142332254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候就已经完成了分片集群的搭建。&lt;/p&gt;
&lt;h3 id=&quot;集群校验&quot;&gt;集群校验&lt;/h3&gt;
&lt;p&gt;通过以下命令，可以确认redis集群槽点分布的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli -c -p 6379 cluster nodes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看到以下画面，表示槽点分片OK：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229142859625.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;集群测试&quot;&gt;集群测试&lt;/h3&gt;
&lt;p&gt;为了确认Redis分片集群的功能，我们来做一个简单的测试。&lt;/p&gt;
&lt;p&gt;就是进入node2的redis实例（主实例），保存a=1数据。然后看是否可以通过node0（主实例，也可以从实例）来获取a对应的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229143204176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述图片中，还通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CLUSTER KEYSLOT a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来确认key=a的数据所在槽点，确实是node0重导向的15495槽点位。&lt;/p&gt;
&lt;h3 id=&quot;集群操作&quot;&gt;集群操作&lt;/h3&gt;
&lt;p&gt;前面已经完成了Redis分片集群的安全与确认，这里简单说一下集群操作，不感兴趣的朋友，可以直接跳过。&lt;/p&gt;
&lt;h4 id=&quot;槽点整理&quot;&gt;槽点整理&lt;/h4&gt;
&lt;p&gt;由于数据倾斜与访问倾斜问题，新master入集群（新master进入集群时是不会分配槽点的）等问题，可能我们对于原先的槽点分布并不满意，所以需要将一个master实例上的槽点，移动一定数量到另一个master槽点。&lt;/p&gt;
&lt;p&gt;可以通过以下指令实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster reshard 172.26.40.223:6379 --cluster-from 45c1607ecf3d80f08cf6056d53f73a529ffc17de --cluster-to 2e1714431f76910db0e1808ce3a3a9b645d2c38f --cluster-slots 100 --cluster-yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该指令，将从id为45c1607ecf3d80f08cf6056d53f73a529ffc17de的master实例，划分100个槽点到id为2e1714431f76910db0e1808ce3a3a9b645d2c38f的master实例。&lt;/p&gt;
&lt;p&gt;PS：master-id可以通过前面的cluster nodes等指令查看。&lt;/p&gt;
&lt;p&gt;可以看到以下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229144705699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster check 172.26.40.223:6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查集群的槽点状态，可以看到以下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229145030856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以明显看到槽点整理的结果。&lt;/p&gt;
&lt;h4 id=&quot;删除节点&quot;&gt;删除节点&lt;/h4&gt;
&lt;p&gt;接下来都比较简单，我就简单放上图片了。需要的地方，我会提示一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229145430566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：删除节点时，该实例不仅从当前集群移除，并且会被shutdown。&lt;/p&gt;
&lt;h4 id=&quot;增加节点&quot;&gt;增加节点&lt;/h4&gt;
&lt;p&gt;首先，启动对应节点。这里不再赘述。&lt;/p&gt;
&lt;p&gt;其次，通过以下指令，实现节点添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster add-node 172.26.40.226:6379 172.26.40.223:6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：上面两个连接信息，前者表示需要添加的新节点信息，后者表示集群中存在的节点信息（表示由该节点执行节点添加操作）。&lt;/p&gt;
&lt;p&gt;PS：如果添加的节点是之前存在过集群中的节点，则会出现以下报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229150123943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候，根据报错信息，删除redis配置相关信息即可。即删除之前配置的 /developer/redis/data/目录下的三个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229150620522.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229150639197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后启动目标实例（如果已经启动，请重启），即可成功运行，看到以下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201912291508413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，资料中也有提到，可能在某些情况下，还需要进行db清除操作（但是我这里并不需要）。&lt;/p&gt;
&lt;h4 id=&quot;增加从节点&quot;&gt;增加从节点&lt;/h4&gt;
&lt;p&gt;可以明显看出，上述的节点添加后，该节点直接成为了master节点。而我们往往需要添加从节点。&lt;/p&gt;
&lt;p&gt;通过以下命令，我们可以为集群添加从节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster add-node 172.26.40.226:6379 172.26.40.223:6379 --cluster-slave&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后，可以看到如下画面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229151625592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;紧接着，校验一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191229151646218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里默认是将新增从节点，分配给从节点数最少的主节点。&lt;/p&gt;
&lt;p&gt;如果希望将新增从节点分配给指定的主节点，则需要以下指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/developer/redis-5.0.3/src/redis-cli --cluster add-node 172.26.40.226:6379 172.26.40.223:6379 --cluster-slave --cluster-master-id &amp;lt;master-id&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体执行其实都是类似的，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;虽然分片集群有16384个槽点，理论可以支撑16384个Redis主实例，但是官方推荐是最多1000个实例（毕竟集群间通信等，还是存在瓶颈的）&lt;/li&gt;
&lt;li&gt;redis集群的每个节点使用TCP连接有其它每个节点连接（这也算解释了前面一条）&lt;/li&gt;
&lt;li&gt;数据倾斜与访问倾斜问题，需要通过调整key的策略，以及slot迁移实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里剽窃一下网易云给出的迁移流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在迁移目的节点执行cluster setslot IMPORTING 命令，指明需要迁移的slot和迁移源节点。&lt;/li&gt;
&lt;li&gt;在迁移源节点执行cluster setslot MIGRATING 命令，指明需要迁移的slot和迁移目的节点。&lt;/li&gt;
&lt;li&gt;在迁移源节点执行cluster getkeysinslot获取该slot的key列表。&lt;/li&gt;
&lt;li&gt;在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。&lt;/li&gt;
&lt;li&gt;在迁移源节点反复执行cluster getkeysinslot命令，直到该slot的列表为空。&lt;/li&gt;
&lt;li&gt;在迁移源节点和目的节点执行cluster setslot NODE ，完成迁移操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，Redis相关的各类安装操作，以及一些安装问题就全部说完了。&lt;/p&gt;
&lt;p&gt;有什么问题，或者需要补充的，可以私信或@我。&lt;/p&gt;
&lt;p&gt;觉得不错的话，可以帮忙点个推荐，以及分享给自己的小伙伴。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:22:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>Redis安装（单机及各类集群，阿里云） 前言 上周，我朋友突然悄悄咪咪地指着手机上的一篇博客说，这是你的博客吧。我看了一眼，是之前发布的《Rabbit安装（单机及集群，阿里云》。我朋友很哈皮地告诉我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12115156.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 + WebGL 的无人机 3D 可视化系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/12103090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/12103090.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;近年来，无人机的发展越发迅速，既可民用于航拍，又可军用于侦察，涉及行业广泛，也被称为“会飞的照相机”。但作为军事使用，无人机的各项性能要求更加严格、重要。本系统则是通过 &lt;strong&gt;Hightopo&lt;/strong&gt; 的  &lt;strong&gt;HT for Web &lt;/strong&gt; 产品来搭建的一款 无人机 3D 可视化系统，通过对无人机及其信息的全景展示来模拟无人机状态的监控。&lt;/p&gt;
&lt;p&gt;系统中包含 4 种展示模式：实体模式 、热力模式、线框模式和内部模式，通过飞机下方操作按钮即可进行模式切换。&lt;/p&gt;
&lt;p&gt;预览地址：&lt;a href=&quot;https://hightopo.com/demo/plane/&quot; target=&quot;_blank&quot;&gt; https://hightopo.com/demo/plane/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;实现过程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;加载界面采用 2D 拓扑组件进行绘制，全矢量化图标，与传统的 png、jpg 等格式的图片相比，完美适配移动端、PC 端、大屏等各种尺寸及分辨率屏幕，不会出现失真情况。&lt;/li&gt;
&lt;li&gt;无人机及周边信息面板采用 3D 引擎进行场景搭建，用户可从场景任意位置对无人机进行查看。&lt;/li&gt;
&lt;li&gt;动画过程采用产品提供的动画函数 ht.Default.startAnim 来驱动图形属性值的改变，应用其 Time-Based 的方式，只需要指定动画周期 duration 的毫秒数，由系统去计算帧数或 action 函数被调用的次数，以保证更加高效、平滑的进行动画过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;界面&lt;/h3&gt;
&lt;h2&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1905962/201912/1905962-20191226114900419-1529145139.gif&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;加载界面中通过动态改变图形的属性值来展现加载进度，加载完毕后通过动画的 finishFunc 调用 hidden2d 方法来改变图形的透明度，在此之后通过 moveCamera 将场景内视角拉近，从而实现淡出到淡入的效果（即离开加载界面进入到 3D 场景中）。与此同时改变图形在 3D 场景中位置来实现各形态的无人机合为一体以及将对应按钮分离。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
// 加载进度
function&lt;span&gt; loadAnim(){
  ht.Default.startAnim({
    duration: 6000&lt;span&gt;,
    easing: t =&amp;gt;&lt;span&gt; {
      return 1 - (--t) * t * t *&lt;span&gt; t;
    },
    action: (v, t) =&amp;gt;&lt;span&gt; { 
      loge.s('clip.percentage'&lt;span&gt;, v);
      percentText.s('text', Math.floor(v * 100&lt;span&gt;));
    },
    finishFunc: () =&amp;gt;&lt;span&gt; {&lt;span&gt;
      hidden2d()
    }
  })
}

// 隐藏 2d 图纸
function&lt;span&gt; hidden2d(){
  ht.Default.startAnim({
    duration: 500&lt;span&gt;,
    easing: t =&amp;gt;&lt;span&gt; {
      return&lt;span&gt; t;
    },
    action: (v, t) =&amp;gt;&lt;span&gt; { 
      dm2d.each(e =&amp;gt;&lt;span&gt; {
        e.s('opacity', 1 -&lt;span&gt; v);
      })
    },
    finishFunc: () =&amp;gt;&lt;span&gt; {
      dm2d.setBackground(''&lt;span&gt;);
      g3d.moveCamera(eye, center, {duration: 3000, easing: t =&amp;gt; {return 1 - (--t) * t * t *&lt;span&gt; t;}});
      planeFit();
      buttonSeparate();
    }
  })
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2D 界面的制作是绘制了一张图纸，而 logo 则是制作了一个图标，一个图标可以在图纸中进行多次使用，并可展示不同的样子。下图中右侧的四个 logo 就是同一个图标，分别展示了不同的裁切方式以及透明度，系统中 logo 的进度条效果就是动态的去改变图标的裁切比例来实现，而界面的淡出效果则是改变透明度。整个图标的制作是绘制不同的图形组合而成，这些图形我们也可以去改变颜色，形成左侧的 logo 样式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1905962/201912/1905962-20191226152949350-1604816308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;无人机形态切换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1905962/201912/1905962-20191226114910733-1317656655.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无人机主体形态分为三种：实体模式、线框模式和热力模式。通过点击下方按钮，可切换至按钮所对应的形态。切换的过程中，将目标形态进行显示，并分别上下移动目标形态和原形态，使用户可以短暂的进行同时查看，之后再回归原位并将原形态进行隐藏。隐藏的方式则有所不用，线框模式是改变线框颜色，其余两种模式则是调整模型的透明度。这里的线框是根据模型的轮廓生成的，通过 3D 引擎自动计算描绘，非常便捷。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
// 选择展示机型
function&lt;span&gt; select(data){
  const name =&lt;span&gt; data.getDisplayName();
  const moveData =&lt;span&gt; dm3d.getDataByTag(name);
  const normalP =&lt;span&gt; normalPlane.p3();

  ht.Default.startAnim({
    duration: 1000&lt;span&gt;,
    easing: t =&amp;gt;&lt;span&gt; {
      return 1 - (--t) * t * t *&lt;span&gt; t;
    },
    action: (v, t) =&amp;gt;&lt;span&gt; {
      if(name === 'linePlane'&lt;span&gt;){
        moveData.s('wf.color', 'rgba(64,173,152,' + v + ')'&lt;span&gt;);
      }
      else&lt;span&gt;{
        moveData.s('shape3d.opacity'&lt;span&gt;, v);
      }
      moveData.p3(normalP[0], normalP[1] + (4500 - normalP[1]) * v, normalP[2&lt;span&gt;]);
      isShow.p3(normalP[0], normalP[1] + (2500 - normalP[1]) * v, normalP[2&lt;span&gt;]);

      hiddenRing(v);
    },
    finishFunc: () =&amp;gt;&lt;span&gt; {
      isShow.s('shape3d.transparent', true&lt;span&gt;);

      ht.Default.startAnim({
        duration: 1000&lt;span&gt;,
        easing: t =&amp;gt;&lt;span&gt; {
          return 1 - (--t) * t * t *&lt;span&gt; t;
        },
        action: (v, t) =&amp;gt;&lt;span&gt; { 
          if(isShow.getTag() === 'linePlane'&lt;span&gt;){
            isShow.s('wf.color', 'rgba(64,173,152,' + (1 - v) + ')'&lt;span&gt;);
          }
          else&lt;span&gt;{
            isShow.s('shape3d.opacity', 1 -&lt;span&gt; v);
          }
          moveData.p3(normalP[0], 4500 + (normalP[1] - 4500) * v, normalP[2&lt;span&gt;]);
          isShow.p3(normalP[0], 2500 + (normalP[1] - 2500) * v, normalP[2&lt;span&gt;]);

          showRing(v);
        },
        finishFunc: () =&amp;gt;&lt;span&gt; {
          isShow =&lt;span&gt; moveData;
          if(moveData.getTag() === 'normalPlane'&lt;span&gt;){
            moveData.s('shape3d.transparent', false&lt;span&gt;);
          }
          isAnim = false&lt;span&gt;;
        }
      });
    }
  });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 3D 引擎，我们可以生成立体图形，也可以添加导入的模型，图形的位置由 x、y、z 三个方向的坐标来确认，而坐标轴汇聚的原点则是图形的锚点，无人机前方旋转的圆环则是将锚点调整到圆环中心后，操纵 rotation 属性进行转动 。在系统中线框状态的无人机则是像图中左侧的球体这样生成的，如果我们将图形的透明度调为 0，则只显示线框的样式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1905962/201912/1905962-20191226160721177-1828653367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;内部结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1905962/201912/1905962-20191226134530758-2023069293.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线框模式下，大家会发现按钮的上方出现了一个小按钮，点击它就可以进入到无人机的另一个状态，在这里我们除了可以看到线框，还能够接触到无人机的内部结构，查看它的每一个部件。进入的过程会将场景内的其它图形隐藏，将内部结构显示出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
// 内部模式
function&lt;span&gt; moveToInternal(){
  const width =&lt;span&gt; background.getWidth();   // 获取背景当前宽度
  const beginLeft = -(width / 2 - 960&lt;span&gt;);   // 计算两侧节点起始位置
  const beginRight = width / 2 + 960&lt;span&gt;;

  ht.Default.startAnim({
    duration: 2000&lt;span&gt;,
    easing: t =&amp;gt;&lt;span&gt; {
      return&lt;span&gt; t;
    },
    action: (v, t) =&amp;gt;&lt;span&gt; { 
      linePlane.s('wf.color', 'rgba(64,173,152,' + (1 - v) + ')'&lt;span&gt;);
      hiddenRing(v);
    },
    finishFunc: () =&amp;gt;&lt;span&gt; {
      dm3d.each(e =&amp;gt;&lt;span&gt; {
          e.s('3d.visible', false&lt;span&gt;)
      })

      linePlane_internal.each(e =&amp;gt;&lt;span&gt; {
        e.s('3d.visible', true&lt;span&gt;);
      })

      ht.Default.startAnim({
        duration: 1000&lt;span&gt;,
        easing: t =&amp;gt;&lt;span&gt; {
          return 1 - (--t) * t * t *&lt;span&gt; t;
        },
        action: (v, t) =&amp;gt;&lt;span&gt; { 
          title.setY(-50 + (70 + 50) *&lt;span&gt; v);
          returnButton.setY(1095 + (1020 - 1095) *&lt;span&gt; v);
          leftShape.setX(beginLeft + 130 *&lt;span&gt; v);
          rightShape.setX(beginRight - 130 *&lt;span&gt; v);
        }
      })
    }
  })
}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们探索一下进入内部模式时，从四周缓缓移入窗口的图形又是怎么实现的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191227140301727-259170537.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现如今，终端的屏幕分辨率各式各样，很多网页在开发前期都会选择响应式布局或自适应式布局，而 &lt;strong&gt;HT for Web&lt;/strong&gt; 的 2D 拓扑组件除了提供矢量绘制，还提供了一套相契合的布局方式。从上图中我们可以看到，红框中的部分是最开始的加载界面，而红框四周的部分则是内部模式中移入的部分，系统中的加载页面与此不同，正是因为添加了布局方式。&lt;/p&gt;
&lt;p&gt;首先我们将红框中背景图片选为整个页面根节点，修改它的 fullscreen 属性为 fill，并为其添加全屏锁定的方式。其次将根节点设置为其余节点的吸附节点，并为其余节点修改合适的布局方式。这样背景图片就会填充整个界面，而四周节点的位置则始终保持在背景图片的外侧，在加载界面中就不会显示出来了。内部模式将四周节点移动至界面内，也是通过修改位置来实现的，但是因为全屏锁定方式设置为垂直，所以背景的宽度被改变，左右两侧节点的移动则需要在获取到当前界面显示宽度后去计算移动位置。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;现如今，信息化快速发展，智能化工具成为了新生产力出现在我们的生活中。与此同时，工业互联网的概念也随之诞生，将人、数据、设备联系到了一起，而可视化界面则可以很好的将数据和设备进行展示，方便管理的同时也更加安全、高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HT for Web &lt;/strong&gt;提供了 2D、3D 两种模式的可视化方式，它功能强大的同时也易于学习使用，有兴趣的同学也可以来体验一下。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:09:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 近年来，无人机的发展越发迅速，既可民用于航拍，又可军用于侦察，涉及行业广泛，也被称为“会飞的照相机”。但作为军事使用，无人机的各项性能要求更加严格、重要。本系统则是通过&amp;#160;Hightop</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/12103090.html</dc:identifier>
</item>
<item>
<title>我们基于kaldi开发的嵌入式语音识别系统升级成深度学习啦 - davidtym</title>
<link>http://www.cnblogs.com/talkaudiodev/p/12085248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkaudiodev/p/12085248.html</guid>
<description>&lt;p&gt;先前的文章《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/11240033.html&quot;&gt;三个小白是如何在三个月内搭一个基于kaldi的嵌入式在线语音识别系统的&lt;/a&gt; 》说我们花了不到三个月的时间搭了一个基于kaldi的嵌入式语音识别系统，不过它是基于传统的GMM-HMM的，是给我们练手用的，通过搭这个系统我们累积了一定的语音识别领域的经验，接下来我们就要考虑做什么形态的产品了。语音识别可以分大词汇量连续语音识别（Large Vocabulary Continuous Speech Recognition， LVCSR）和关键词识别（Keyword Spotting， KWS）。LVCSR 要求很强的计算能力，这类方案主要在服务器上实现。KWS只要识别出关键词即可，对算力要求不是很高，可以在终端芯片上实现。由于我们公司的芯片主要用于终端产品上，算力不是很强，因此我们就准备做关键词识别。对于关键词识别又可分为几种应用场景。一是音频文献中关键词检索，用于快速找到音频文献中需要的内容。二是语音唤醒词识别，用于唤醒终端设备，让其工作（不唤醒时设备处于睡眠状态）。三是命令词识别，用于语音命令控制的场景，终端设备收到某个命令词后就执行相应的操作。比如智能家居场景中，当用户说出“打开空调”被识别到后就把空调打开了。经过讨论后我们决定做中文命令词识别，暂时把应用场景定在智能家居上，并定义了几个命令词，例如“打开空调”、“关闭空调”等。后面如果要做其他场景，只要改变命令词重新训练模型即可，代码部分是不需要改动的。&lt;/p&gt;

&lt;p&gt;先前的系统是基于GMM-HMM的，已out，我们想用深度神经网络（Deep Neural Networks，DNN）来做。kaldi中的DNN分为nnet1、nnet2、nnet3三种。nnet1是由Karel写的，使用的是DNN-HMM架构，这里DNN说白了就是MLP(MultiLayer Perceptron，多层感知机)。nnet2和nnet3是由Daniel写的，nnet2同样使用的是DNN-HMM架构，nnet3还包含了其他网络架构，有CNN/RNN/LSTM等。nnet1没有online decoder，nnet2和nnet3则有online decoder，比较下来我们决定用nnet2。DNN-HMM是基于GMM-HMM的，是用DNN替代GMM，因而我们前面的工作还可以用得上，所以这次的工作主要分两部分，一是模型训练，二是nnet2 online decoder相关代码的移植。上次负责模型训练的同学由于忙其他工作，这次模型训练就由我来做。nnet2 online decoder代码移植由另外一个同学负责。同时我们在前处理中把VAD（Voice Activity Detection，语音活动检测）加上，只把检测到语音的部分送到后面模块处理，这样降低了功耗。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这次我来弄模型训练。由于是新手，先得学习怎么训练模型，然后根据新的需求训练出新的模型。经过半个多月的学习，大体上搞清楚了模型训练的步骤。首先是数据准备，包括准备语料、字典和语言模型等。对于语料，可以花钱买，也可以自己录，要将其分成训练集、测试集和交叉验证集。字典表示一个词是由哪些音素组成的。语言模型通过专业的工具（如srilm的ngram-count）生成。然后处理语料得到scp/spk2utt/utt2spk等文件，处理字典、语言模型等得到FST等文件。再就是做MFCC得到每一帧的特征向量，最后进行各个阶段的训练得到相应的模型文件（final.mdl）。主要的阶段有单音素训练（mono）、三音素训练（tri1）、LDA_MLLT训练(tri2b)、SAT训练（tri3b）、quick训练（tri4b）,每一步训练都是基于上一步训练解码后对齐的结果。上面这几步是GMM-HMM的训练，如果要做深度神经网络(DNN)的训练，则还要把DNN训练这步加上去。我们这次做的是中文命令词的识别，先定好命令词，然后从thchs30里找到这些词的声韵母的写法，需要注意的是thchs30里声韵母的写法跟通常拼音的写法有些不一样，再根据这些命令词用工具把语言模型生成。我们的语料是自己录的，发动了周围的同学帮忙录，有男声和女声。这些都准备好后先处理语料得到scp等文件，再根据字典、语言模型等生成fst等文件，最后就开始各个阶段的训练了。先训练传统的GMM-HMM，不断的调整参数，直至WER有一个不错的值。GMM-HMM模型训练好后我把模型load进我们先前搭好的demo，实测下来效果还不错。这说明GMM-HMM的模型训练是OK的，接下来就要开始训练DNN(nnet2)的模型了。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我没有立刻去训练nnet2的模型，而是再去学习了下DNN的基础知识（以前简单学习过，一直没用到，理解的不深，有些已经忘记了），重点关注了梯度下降法和网络参数怎么更新，并写成了两篇博客：《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/11673028.html&quot;&gt;机器学习中梯度下降法原理及用其解决线性回归问题的C语言实现 》&lt;/a&gt;&amp;amp; 《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/11692611.html&quot;&gt;kaldi中CD-DNN-HMM网络参数更新公式手写推导》&lt;/a&gt;。接下来就去看怎么训练nnet2的模型了。先到kaldi的官方网站上看训练nnet2的相关内容，大致明白就开始基于我们自己录制的语料库调试了。nnet2的训练脚本较乱，一个脚本下有多个版本(nnet4a / nnet4b / nnet4c / nnet4d / nnet5c / nnet5d)。我刚开始不清楚孰优孰劣，把每个都调通。在网上搜索调查了一下，kaldi的作者Daniel Povey在一个论坛里说隐藏层用p-norm做激活函数的性能更好一些。于是决定用推荐的nnet4d（&lt;span&gt;激活函数&lt;/span&gt;就是用的&lt;span&gt;p-norm&lt;/span&gt;）来继续训练。经过多次参数tuning后得到了一个WER相对不错的模型。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;在我训练DNN模型的同时，负责代码移植的同学也在把nnet2 online decoder的相关代码往我们平台上移植，套路跟我先前的一样。同时kaldi也提供了一个应用程序（代码见online2-wav-nnet2-latgen-faster.cc），对WAV文件做nnet2的online decoder。我们先要把模型在这个应用程序上调通（通常kaldi代码是没有问题的，我们在这个应用程序里调通就说明模型训练是没有问题的，后面在我们自己的平台上去调试就有基准可参考了）。当我们把模型放进应用程序里运行，报了“Feature dimension is 113 but network expects 40”的错。调查下来发现kaldi应用程序要求MFCC是13维的，且有i-vector的功能（100维的），这样加起来就是113维的。而我训练的nnet2模型是基于tri3b的（DNN-HMM要利用GMM-HMM的训练解码对齐结果，对齐的越好DNN模型的识别率就越高），13维MFCC+26维delta+1维pitch，共40维，所以模型输入是40维的。讨论后为了降低复杂度，我们决定先把应用程序中的i-vector功能给去掉，同时我基于单音素的模型（13维MFCC）重新训练nnet2模型。基于新的模型运行应用程序不报错了，但是识别率很低。我们一时没有了方向，做了几次尝试还是识别率很低。后来我们开始比较我的训练处理流程和应用程序里的处理流程，发现我训练时用了CMVN（以前做GMM-HMM训练时就有），而应用程序代码处理流程里没有。于是在代码里把CMVN的处理加上，再去运行应用程序，识别率显著提升了。我们长舒了一口气，因为我们知道这个问题被解决了，从而心里有底了。再把应用程序的机制移植到我们平台上，同时另外一个同学也帮忙把webRTC的VAD也移植进来，有语音才会把那段语音往后面模块送，这跟应用程序中读WAV文件很类似，所以处理起来机制就很类似。用了两三天就把包含VAD、前处理(ANS、AGC)和nnet2 online decoder的系统联调好了。测试了一下，被训练过的人说命令词识别率大于90%，而未被训练过的识别率大于80%。但是有个严重的问题，就是集外词（out-of-vocabulary，OOV，就是命令词以外的词）都会被识别成一个集内词（命令词），即集外词没有被拒识。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;针对这个问题，我查了些资料并静下心来想了想，在当前架构下说出一个词，只会以WFST中路径最短的一个作为识别结果输出，所以才会有集外词被识别成了集内词。我们的系统目前只能识别那些指定的关键词，但是还不具备关键词识别系统的任何特点。我在前面的文章《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/10919725.html&quot;&gt;语音识别中唤醒技术调研》&lt;/a&gt; 中曾总结过实现关键词识别的三种方法，一是基于LVCSR来做，在终端芯片上不太可行。二是keyword/filler方法，说白了就是把一些垃圾词也放进模型里去训练（大意如下图），识别时说集外词很大可能是垃圾词作为识别结果而不输出从而实现集外词拒识，在终端芯片上可行。三是纯深度学习方法（相对于3，1和2是传统方法）。我们的架构是DNN-HMM，虽然也用了深度神经网络，但DNN是用来替代GMM的，本质上还是一种传统方法，所以我决定把keyword/filler方法用到我们的系统上。先从thchs30里找到几百个集外词（垃圾词），然后根据这些词录制语料并放进模型里训练。用新生成的模型去测试，集外词拒识率大幅提高，但是一些情况下集外词还是被识别为集内词。例如关键词是“深度科技”，如说成“深度科学”就有可能被识别成“深度科技”。针对这种情况，我把相关的词（常用的）都放进垃圾词里，如“深度科学”、“深度科普”、“深度科研”等，再去测试这些词就不会被识别成集内词了。再例如一些词发音跟集内词发音很相似，比如说“深度科器”会被识别成“深度科技”，我试了试百度的小度音箱，把唤醒词“小度小度”说成“角度角度”或者“巧度巧度”，小度音箱依旧会被唤醒。市面上已大规模商用的产品都有这个现象，我也就没管它。与此同时，我还在看一些集外词拒识的相关论文，发现好多都结合用置信度（conference measure）来解决这个问题，其中中科院自动化所的一篇博士论文《语音识别中的置信度研究与应用》讲的比较好。看后我明白了要想在传统架构下把集外词拒识问题解决好，一是要用上keyword/filler方法，二是要用上置信度。目前我是没有能力根据论文去实现置信度的，也没有找到开源的关于置信度的实现，于是在kaldi WFST lattice代码里想办法。通过大量的集内词和集外词的测试我发现可以用一些变量去做判断，但是有可能集外词拒识率提高了，集内词识别率也下降了（用置信度也会有同样的问题，这个度很难掌控。这块内容也是挺难的，尤其对我一个做工程的且做语音识别没多久的来说） 。经过一段时间的努力后集内词的识别率和集外词的拒识率都有了一个相当的水准，但离商用还有一段距离，后面还有很多事情要做，比如加大语料（我们目前只有一个几十人的语料库，没有好几百人并且覆盖男女以及不同年龄段的语料库是不能商用的），后面会越来越难！&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201912/1181527-20191226221803898-1486034028.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;马上就2019年过去了。回首这一年，三分之二的时间都用来做语音识别了，全是摸索着向前走，有痛苦，也有欢乐，从最初的什么都不懂到现在的懂一点。希望2020年自己在这个领域进步再大一点。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:09:00 +0000</pubDate>
<dc:creator>davidtym</dc:creator>
<og:description>先前的文章《三个小白是如何在三个月内搭一个基于kaldi的嵌入式在线语音识别系统的 》说我们花了不到三个月的时间搭了一个基于kaldi的嵌入式语音识别系统，不过它是基于传统的GMM-HMM的，是给我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/talkaudiodev/p/12085248.html</dc:identifier>
</item>
<item>
<title>工厂设计模式灵魂拷问-Java实现 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/12117851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/12117851.html</guid>
<description>&lt;blockquote readability=&quot;6.5961538461538&quot;&gt;
&lt;p&gt;show me the code and take to me,做的出来更要说的明白&lt;br/&gt;GitHub项目&lt;a href=&quot;https://github.com/buerbl/JavaHouse&quot;&gt;JavaHouse&lt;/a&gt;同步收录&lt;br/&gt;喜欢就点个赞呗! 你的支持是我分享的动力！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引入&quot;&gt;引入&lt;/h3&gt;
&lt;p&gt;我们经常听到工厂模式，比如说 Spring 用了工厂模式啦，面试也会被问到工厂模式等等，这见工厂模式是日常开发中比较重要的一种设计模式。其实工厂模式也是比较简单的一种设计模式，这年头似乎不了解工厂模式，你都不好意思说你学过 编程一样（手动狗头）。那么，允许我灵魂拷问一下，你真的了解工厂模式吗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229095619.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;uml类图&quot;&gt;UML类图&lt;/h3&gt;
&lt;p&gt;不急，我们先看看 UML 类图。学习一下怎么用 UML 类图 表示代码。先看如何表示一个实体类。代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class B {
    
    private String name;
    private String password;
    
    public void test(){
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个简单的实体类。他的 看 UML 类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229100609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完实体类，我们在来看看接口，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface B {
    void test();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个简单的接类。一般接口就放几个方法，不放属性。他的 看 UML 类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229100852.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完实体类和接口，我们来看看他们有什么关系吧。先看看继承关系如何表示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229101248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以一眼看到他的箭头特点---空心的。箭头指向父类。这就是继承关系表示。&lt;/p&gt;
&lt;p&gt;看完继承关系，我们在看看实现接口如何表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229101634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们可以看到与继承关系类似，不过实现变成虚线，箭头指向接口类。&lt;/p&gt;
&lt;p&gt;完了没有，没有，我们在看看依赖关系，这种关系比较弱，一般是一个类作为另一个类的参数表示， uml 图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229103657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依赖关系是虚线，半个箭头&lt;/p&gt;
&lt;p&gt;到这里，以上就是常见的 uml 类图表示。&lt;/p&gt;
&lt;h3 id=&quot;简单工厂&quot;&gt;简单工厂&lt;/h3&gt;
&lt;p&gt;进入正题，什么是工厂模式，我们先看看简单工厂模式，其实简单工厂模式并不是工厂模式，但是他可以帮助我们去了解工厂模式，所以我们先看看简单工厂模式。&lt;/p&gt;
&lt;p&gt;需求：我们需要做一个可以加减乘除的计算机，运用到简单工厂模式。&lt;/p&gt;
&lt;p&gt;UML 类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229144354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运算类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.Data;

@Data
public abstract class Operation {
    private Double numA;
    private Double numB;
    /**
     * 运算方法
     */
    abstract Double getResult();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加法类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OperationAdd extends Operation{

    @Override
    Double getResult() {
        return getNumA() + getNumB();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乘法类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OperationMul extends Operation{
    @Override
    Double getResult() {
        return getNumA() * getNumB();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除法类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OperationDiv extends Operation{
    @Override
    Double getResult() {
        if (getNumB() == 0){
            throw new RuntimeException(&quot;除数不能为零！&quot;);
        }
        return getNumA() / getNumB();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单工厂类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CreateOperationFactory {
    public static Operation createOperation(String operate){
        Operation operation = null;
        switch (operate){
            case &quot;+&quot;:
                operation = new OperationAdd();
                System.out.println(&quot;这是+法&quot;);
                break;
            case &quot;/&quot;:
                operation = new OperationDiv();
                System.out.println(&quot;这是/法&quot;);
                break;
            case &quot;*&quot;:
                operation = new OperationMul();
                System.out.println(&quot;这是*法&quot;);
                break;
        }
        return operation;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        Operation operation = CreateOperationFactory.createOperation(&quot;+&quot;);
        operation.setNumA(1D);
        operation.setNumB(2D);
        System.out.println(operation.getResult());

        operation = CreateOperationFactory.createOperation(&quot;*&quot;);
        operation.setNumA(1D);
        operation.setNumB(2D);
        System.out.println(operation.getResult());

        operation = CreateOperationFactory.createOperation(&quot;/&quot;);
        operation.setNumA(1D);
        operation.setNumB(2D);
        System.out.println(operation.getResult());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这是+法
3.0
这是*法
2.0
这是/法
0.5&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;工厂模式&quot;&gt;工厂模式&lt;/h3&gt;
&lt;p&gt;需求：要再添加一个减法运算，嗯？上面没有减法运算吗？我猜你们肯定没有发现上面没有减法运算。看到的也会以为我在偷懒了，蒙混过关呢。事情并没有这么简单。&lt;/p&gt;
&lt;p&gt;一般来说，加个减法嘛，简单，我直接就下 工厂类里面加一个分支不就完事了。哈哈，殊不知，这时候，我们已经违反一个重要的原则--开放关闭原则。所谓开放关闭原则，我们不应该修源码，祖传代码你敢动，试试看，而是通过继承父类或者实现接口去拓展代码，达到我们的目的。&lt;/p&gt;
&lt;p&gt;uml 类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229144723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IFactory {
    Operation createOperation(String operate);
}


public class OperationAddFactory implements IFactory{
    @Override
    public Operation createOperation(String operate) {
        Operation operation = new OperationAdd();
        System.out.println(&quot;这是+法&quot;);
        return operation;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;抬杠&quot;&gt;抬杠&lt;/h3&gt;
&lt;p&gt;没错，这里是自己杠自己的环节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191229135041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么工厂模式啊！我自己 &lt;code&gt;new&lt;/code&gt; 一个对应的对象不就解决问题了，为啥要写一个工厂类出来。（杠上杠啊，这是要搞事情）&lt;/p&gt;
&lt;p&gt;嗯？好像我无法反驳·····是不存在的（用我第三根手指推一推我的眼镜）。试想一下，一个地方用到就去 &lt;code&gt;new&lt;/code&gt; 一下。我们一下&lt;code&gt;new&lt;/code&gt;了十几个地方，然后发现要来类名，这时候，怎么办。一处一处改咯，自己&lt;code&gt;new&lt;/code&gt;的对象，哭着也要改完。但是如果用工厂类的话，我们只需要改一个地方就可以，就是这么简单。&lt;/p&gt;
&lt;p&gt;就这一个优点吗？我还是喜欢一个一个&lt;code&gt;new&lt;/code&gt;啊。&lt;/p&gt;
&lt;p&gt;肯定不是（这是一个杠精啊），当然简单一个&lt;code&gt;new&lt;/code&gt;对象,确实不需要写一个类出来。但是&lt;code&gt;new&lt;/code&gt;一个对象并不是那么简单，我们需要对象进行一个操作呢。Spring IOC机制默认创建对象是单例的，那么我们现在也需要对象是唯一的怎么办。这时候，我们就是可以在工厂类里面写一个单例模式，达到我们的目的。&lt;/p&gt;
&lt;p&gt;以上就是我的抬杠环节。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;不管什么设计模式，其实就是为了代码复用，少写代码，我们做明白什么模式是什么模式，更要理解这些的作用。正所谓，武术的目的是为了生发，战争的出发点是为了和平。总之，就是知其然知其所以然。&lt;/p&gt;
&lt;p&gt;看到这里的都是人才。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;https://juejin.im/post/5d318b485188255957377ac3#heading-4&lt;br/&gt;《大话设计模式》&lt;br/&gt;https://www.zhihu.com/question/24843188 -- 工厂设计模式有什么用？&lt;/p&gt;
&lt;h3 id=&quot;关注微信公众号随时移动端阅读&quot;&gt;关注微信公众号，随时移动端阅读&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://javahouse.xyz/20191212204326.png&quot; alt=&quot;公众号.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 30 Dec 2019 00:08:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>show me the code and take to me,做的出来更要说的明白 GitHub项目 &amp;quot;JavaHouse&amp;quot; 同步收录 喜欢就点个赞呗! 你的支持是我分享的动力！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhuantou/p/12117851.html</dc:identifier>
</item>
</channel>
</rss>