<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>win10使用WSL 2运行Docker Desktop，运行文件从C盘迁移到其他目录 - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13184398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13184398.html</guid>
<description>&lt;p&gt;前几天重装系统，把系统升到了Windows 10 2004，然后在安装Docker Desktop（2.3.0.3版本）时发现跟以前不太一样了。现在Docker Desktop默认使用WLS 2来运行，而不是以前的Hyper-V。&lt;/p&gt;

&lt;p&gt;WLS：适用于 Linux 的 Windows 子系统。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是适用于 Linux 的 Windows 子系统？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生虚拟机开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;什么是 WSL 2？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完后试了一下，最明显的感觉就是开启docker的速度大大提升！！！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623194114380-1616116229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是以前设置镜像位置的功能不见了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623194352720-365413236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;看官网说明，原来，启用WSL后，docker运行数据都在WSL发行版中，文件位置都只能由WSL管理！&lt;/p&gt;
&lt;p&gt;安装docker后，docker会自动创建2个发行版：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docker-desktop&lt;/li&gt;
&lt;li&gt;docker-desktop-data&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623195500964-442325184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WSL发行版默认都是安装在C盘，在%LOCALAPPDATA%/Docker/wsl目录&lt;br/&gt;docker的运行数据、镜像文件都存在%LOCALAPPDATA%/Docker/wsl/data/ext4.vhdx中，这对C盘空间紧张的人非常不友好。。。&lt;/p&gt;

&lt;p&gt;网上查了一下wsl发行版迁移，几乎都是说使用LxRunOffline.exe&lt;/p&gt;
&lt;p&gt;经过我试验，LxRunOffline.exe确实可以迁移自己安装的发行版，却迁移不了docker自动创建的2个发行版！&lt;/p&gt;
&lt;p&gt;最后只能去github提了个issues：&lt;a href=&quot;https://github.com/docker/for-win/issues/7348&quot;&gt;https://github.com/docker/for-win/issues/7348&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是操作方法：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;首先关闭docker&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关闭所有发行版：&lt;br/&gt;&lt;code&gt;wsl --shutdown&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将docker-desktop-data导出到D:\SoftwareData\wsl\docker-desktop-data\docker-desktop-data.tar（注意，原有的docker images不会一起导出）&lt;br/&gt;&lt;code&gt;wsl --export docker-desktop-data D:\SoftwareData\wsl\docker-desktop-data\docker-desktop-data.tar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注销docker-desktop-data：&lt;br/&gt;&lt;code&gt;wsl --unregister docker-desktop-data&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重新导入docker-desktop-data到要存放的文件夹：D:\SoftwareData\wsl\docker-desktop-data\：&lt;br/&gt;&lt;code&gt;wsl --import docker-desktop-data D:\SoftwareData\wsl\docker-desktop-data\ D:\SoftwareData\wsl\docker-desktop-data\docker-desktop-data.tar --version 2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623202849041-113421930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623202919822-213119905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需要迁移docker-desktop-data一个发行版就行，另外一个不用管，它占用空间很小。&lt;/p&gt;
&lt;p&gt;完成以上操作后，原来的%LOCALAPPDATA%/Docker/wsl/data/ext4.vhdx就迁移到新目录了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200623204037008-1551744168.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;重启docker，这下不用担心C盘爆满了！&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/wsl/&quot;&gt;https://docs.microsoft.com/zh-cn/windows/wsl/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/wsl/&quot;&gt;https://docs.docker.com/docker-for-windows/wsl/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 00:51:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 前几天重装系统，把系统升到了Windows 10 2004，然后在安装Docker Desktop（2.3.0.3版本）时发现跟以前不太一样了。现在Docker Desktop默认使用WLS 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13184398.html</dc:identifier>
</item>
<item>
<title>Refresh Java - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/refresh-java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/refresh-java.html</guid>
<description>&lt;p&gt;当你的知识来源于实践, 你可能会忽略很多细节.&lt;br/&gt;当你的知识来源于阅读, 你可能会很快的忘掉.&lt;br/&gt;那么, 不如在空闲之余, 浏览一遍, 把觉得有必要的记录下来, 也便于以后温故而知新, 何乐而不为呢?&lt;br/&gt;于是便有了这138条从Thinking In Java中记下来的条目.&lt;br/&gt;这本书不同于其他的Java教材, 它的作者更喜欢通过与C++进行对比来阐述Java的不同思想, 如果读者有一定C++知识储备, 会更好的理解Java的很多设计.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;无符号移位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for(1 : range(10))&lt;/code&gt;可实现计数器循环foreach&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printnb&lt;/code&gt;不会换行放在缓冲区, &lt;code&gt;print()&lt;/code&gt;将其输出&lt;/li&gt;
&lt;li&gt;带标签的&lt;code&gt;break&lt;/code&gt;与&lt;code&gt;continue&lt;/code&gt;可以跳出嵌套循环&lt;/li&gt;
&lt;li&gt;构造调用&lt;code&gt;this(xxx)&lt;/code&gt;只能调用一次,并且在最开始&lt;/li&gt;
&lt;li&gt;Java的&lt;code&gt;finalize&lt;/code&gt;是在垃圾回收时候调用的, 一般是配合释放ndk相关的底层空间&lt;/li&gt;
&lt;li&gt;静态对象只有在所属类被实创建时才会被加载&lt;/li&gt;
&lt;li&gt;构造方法其实也是静态方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int[] a&lt;/code&gt;与&lt;code&gt;int a[]&lt;/code&gt;都可以, 前一种更合理, 后一种像C++&lt;/li&gt;
&lt;li&gt;数组初始化花括号最后一个逗号可选, 即&lt;code&gt;{x,y,z,}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有写&lt;code&gt;package&lt;/code&gt;的类默认属于目录所在包&lt;/li&gt;
&lt;li&gt;即时类不是&lt;code&gt;public&lt;/code&gt;, 但是&lt;code&gt;main&lt;/code&gt;方法依旧可以被调用&lt;/li&gt;
&lt;li&gt;子类调用父类方法, 父类再调用&lt;code&gt;public&lt;/code&gt;方法则可能会调用到子类所继承的方法(如果覆盖的话), 如果该方法在父类是&lt;code&gt;private&lt;/code&gt;, 则只会调用父类方法, 因为不能覆盖, C++如果不是虚函数, 则只会调用父类的, 因为&lt;code&gt;this&lt;/code&gt;内函数地址编译时就确定了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;函数没有隐藏/屏蔽特性, &lt;code&gt;C++&lt;/code&gt;子类会同名函数会隐藏/屏蔽掉父类所有同名重载函数, 因为它会先查找函数名, 再找具体类型.&lt;/li&gt;
&lt;li&gt;早起&lt;code&gt;JVM&lt;/code&gt;会根据&lt;code&gt;final&lt;/code&gt;类型来内联函数, 现在已经有更先进的技术了, 只为了禁止覆盖.&lt;/li&gt;
&lt;li&gt;覆盖&lt;code&gt;private final&lt;/code&gt;其实是假象而已&lt;/li&gt;
&lt;li&gt;面向对象特性, 抽象, 继承, 多态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;除了&lt;code&gt;static&lt;/code&gt;与&lt;code&gt;final&lt;/code&gt;外函数都是后期绑定的, 即动态绑定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;构建子类时父类构造函数调用已被覆盖的函数会触发动态绑定, 但此时子类未完成构造, 所以类内对象都为空值. &lt;code&gt;C++&lt;/code&gt;在处理同样问题时更加合理, 由于虚表指针未完整建立, 所以不会触发动态绑定, 无论是构造还是析构函数, 都是直接调用而非虚调用, 为了避免问题, 尽量不要在构造函数内调用可被覆盖的函数, 可以调用&lt;code&gt;final&lt;/code&gt;函数来防止出错&lt;/li&gt;
&lt;li&gt;Java5加入被覆盖方法返回参数协变(向下转型)&lt;/li&gt;
&lt;li&gt;interface中定义的所有常量都是自动static fianl的&lt;/li&gt;
&lt;li&gt;类内部定义的private接口可以进行内部public的实现, 但在外部无法看出任何有关私有接口的类型信息, 即不可向上转型&lt;/li&gt;
&lt;li&gt;嵌套在接口内的接口自动public&lt;/li&gt;
&lt;li&gt;private接口不能在定义它的类之外被实现&lt;/li&gt;
&lt;li&gt;内部类持有的外部类对象学术名叫Enclosing Object(外围对象)&lt;/li&gt;
&lt;li&gt;创建非静态内部类必须通过&lt;code&gt;.new&lt;/code&gt;来创建, 即使用外部对象来创建内部对象&lt;/li&gt;
&lt;li&gt;private内部类可以帮助隐藏具体实现, 外部类可以提供其实例的向上转型&lt;/li&gt;
&lt;li&gt;内部类还可以放在方法里缩小scope, 作用于与局部变量一样&lt;/li&gt;
&lt;li&gt;匿名内部类没有命名构造器, 只有实例初始化传参, 或者通过final形参直接在内部使用&lt;/li&gt;
&lt;li&gt;static内部类叫作嵌套类, 它不持有外围对象&lt;/li&gt;
&lt;li&gt;接口内部可以放嵌套类, 可以这么搞个测试在里面&lt;/li&gt;
&lt;li&gt;内部类更重要的作用是有效的实现了&lt;code&gt;多重继承&lt;/code&gt;, 比如需要继承多个抽象类而不是接口&lt;/li&gt;
&lt;li&gt;Java使用内部类实例做回调来实现闭包功能&lt;/li&gt;
&lt;li&gt;Java通过接口+内部类可以结果C++多重继承所能解决的问题&lt;/li&gt;
&lt;li&gt;List/Set/Queue都继承Collection, Map独立有接口, 两者唯一的关系是Map提供一个返回Collection的entrySet与values&lt;/li&gt;
&lt;li&gt;Queue虽然继承于Collection, 但Queue有自己独立的接口, 创建Queue不需要Collection的方法&lt;/li&gt;
&lt;li&gt;LinkedList也继承于Dequeue&lt;/li&gt;
&lt;li&gt;当我们在异常处理的终止与恢复中选择时, 开始往往是恢复, 最后趋向终止&lt;/li&gt;
&lt;li&gt;对自定义异常的扩展可能没太大用, 因为更多的时候只关注异常类型&lt;/li&gt;
&lt;li&gt;重新抛异常会保留之前的信息, 不会新加入抛出点的信息, 除非调用fillInStackTrace()&lt;/li&gt;
&lt;li&gt;重新抛出新的异常则会清楚之前的信息&lt;/li&gt;
&lt;li&gt;Finally用来清理，C++靠的是析构函数&lt;/li&gt;
&lt;li&gt;即便有break，continue，return，finally始终都会被执行&lt;/li&gt;
&lt;li&gt;Finally中return会吃掉try内的异常&lt;/li&gt;
&lt;li&gt;Finally中抛异常会吃掉try内的异常&lt;/li&gt;
&lt;li&gt;基类构造抛出异常不用在子类限制必须抛出， 因为基类构造必须调用， 并且需要处理&lt;/li&gt;
&lt;li&gt;子类方法不能抛出基类未声明过的异常，这样直接调用基类接口不用处理，实际运行可能会出错&lt;/li&gt;
&lt;li&gt;子类方法可以抛出基类声明异常的子类异常&lt;/li&gt;
&lt;li&gt;对于构造需要清理的对象，如文件，应该将构造失败单独try/catch，而close方法放在内部的try/catch只对创建成功后进行清理&lt;/li&gt;
&lt;li&gt;字符串正则表达式查找find匹配任意位置，lookingAt只从开头匹配， matches匹配全部&lt;/li&gt;
&lt;li&gt;正则Pattern可以用&lt;code&gt;|&lt;/code&gt;与操作进行组合&lt;/li&gt;
&lt;li&gt;Java默认类型转换会RTTI，但是C++不会&lt;/li&gt;
&lt;li&gt;setAccessable只是控制是否安全检测，public默认仍是false，关闭后速度快&lt;/li&gt;
&lt;li&gt;泛型会被擦除， ArrayList跟ArrayList一样，通过getTypeParameters()也只能得到占位符&lt;/li&gt;
&lt;li&gt;C++泛型不会擦除， 所以编译的时候仍然可以获得具体使用类型，所以定义时泛型对象就可以调用实际类型的方法，Java得通过泛型extends来实现&lt;/li&gt;
&lt;li&gt;擦除主要是为了兼容低版本&lt;/li&gt;
&lt;li&gt;C++可以直接new T()而Java只能通过泛型当参数newInstance，对于没有默认构造的Java可以传入泛型工场进行构造&lt;/li&gt;
&lt;li&gt;泛型可以通过extends来限制边界, 并且可以通过&lt;code&gt;&amp;amp;&lt;/code&gt;增加多个边界, 类应该放在接口的前面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Clazz&amp;lt;Apple&amp;gt;&lt;/code&gt;只能向上转型为&lt;code&gt;Clazz&amp;lt;? extends Fruit&amp;gt;&lt;/code&gt;, 而不能&lt;code&gt;Clazz&amp;lt;Fruit&amp;gt;&lt;/code&gt;, &lt;code&gt;Clazz&amp;lt;Food&amp;gt;&lt;/code&gt;可以向下转型为&lt;code&gt;Clazz&amp;lt;? super Fruit&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends X&amp;gt;&lt;/code&gt;指定上界, 无法进行add操作, 因为它是由子类List向上转型来的, 子类多种多样不确定, 所以不让你放, 而get返回&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;&amp;lt;? super X&amp;gt;&lt;/code&gt;指定下届, 是由父类List向下转型来的, 可以add &lt;code&gt;X&lt;/code&gt;的子类, 内部可安全强转为同一个父类(X的某个父类), 但get就不清楚是哪个父类, 所以只能拿到&lt;code&gt;Object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;类不能实现泛型接口的两种变体&lt;/li&gt;
&lt;li&gt;自限定泛型继承, &lt;code&gt;class SelfBounded&amp;lt;T extends SelfBounded&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, 任何继承SelfBounded类的泛型类型必须也是SelfBounded的导出类&lt;/li&gt;
&lt;li&gt;继承自限定类可保证接口函数导入类唯一, 参数为限定类泛型指定&lt;/li&gt;
&lt;li&gt;C++可以通过&lt;code&gt;template&amp;lt;class T&amp;gt; : T&lt;/code&gt;来进行混型, 有一些AOP方面的思想&lt;/li&gt;
&lt;li&gt;Java可以通过继承多个接口, 并分别初始化的时候进行实现, 然后再代理进行混型&lt;/li&gt;
&lt;li&gt;Java也可以通过装饰器进行混型的概念, 但是由于装饰器其实只有最后一层是暴露的, 失去了内部各层的特性, 而混型是基于继承, 保留所有特性&lt;/li&gt;
&lt;li&gt;Java还可以通过动态代理, 将所有需要混型的实现与接口导入, 在invoke的时候查表得到对应的Delegate来调用方法, 实现混型, 但是不方便, 也不易懂, 不如C++静态的好&lt;/li&gt;
&lt;li&gt;对于一些脚本语言, 类型检测是在运行期, 所以可以使用潜在类型机制, 进行代码复用, 如Python, 只需要方法名一样, 或者称为鸭子类型机制, 只要走起来像鸭子, 叫起来像鸭子, 就当做鸭子...&lt;/li&gt;
&lt;li&gt;由于C++的泛型在编译器可以检测T支持的方法, 可以直接对泛型类型调用相应函数, 也可以做到类似Python的效果. 表面上看C++的泛型成了弱类型, 但实际上是安全的, 称之为具有通气门的强类型&lt;/li&gt;
&lt;li&gt;Java的泛型出现的晚, 已经不具备这种潜在类型机制了, 可以认为比他们更缺乏泛化性&lt;/li&gt;
&lt;li&gt;Java虽然不能潜在类型, 但可以通过泛型, 一定程度补偿了这样的灵活性&lt;/li&gt;
&lt;li&gt;虽然Java的Map有泛型, 但是&lt;code&gt;containsKey&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;之类的方法不受泛型约束, 而C++的Map是会在编译器检查类型的. 主要原因是泛型对于Java是后来引入的, 而对于C++在最初的标准版本里就引入了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Arrays.deepToString()&lt;/code&gt;可以给数组填充初始默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Arrays.fill()&lt;/code&gt;可以给数组填充指定值&lt;/li&gt;
&lt;li&gt;无法创建泛型数组, 但是类型可以被赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.newInstance&lt;/code&gt;用反射的Array可以生成任意类型, 指定大小的数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.arraycopy&lt;/code&gt;可以实现高效的数组内存拷贝&lt;/li&gt;
&lt;li&gt;自己实现Collection不一定需要支持所有的操作, 虽然平时用的List, Map, Set都实现了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Arrays.asList()&lt;/code&gt;生成的是固定大小数组, 不支持改变大小的操作, 使用会抛异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;实现了&lt;code&gt;Queue&lt;/code&gt;接口, 但是Java没有&lt;code&gt;Dequeue&lt;/code&gt;接口, 不过它已经实现了所需方法&lt;code&gt;getLast&lt;/code&gt;, 所以可以自己包装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeMap&lt;/code&gt;是唯一带&lt;code&gt;subMap&lt;/code&gt;的Map, 返回一个子树, 它是&lt;code&gt;SortedMap&lt;/code&gt;的唯一实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;的散列是一个LRU, 没有被使用的数据放在前面&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Collection.synchronized&lt;/code&gt;可以创建不同的线程同步子类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SoftReference&lt;/code&gt;跟&lt;code&gt;WeakReference&lt;/code&gt;都可以单独使用, 而&lt;code&gt;PhantomReference&lt;/code&gt;必须跟&lt;code&gt;ReferenceQueue&lt;/code&gt;一起使用&lt;/li&gt;
&lt;li&gt;普通对象被gc后会进入&lt;code&gt;Finalizable&lt;/code&gt;状态, finalize未被调用, 仍就可以有机会复生 (复写finalize), 当finalize调用后, 会进入&lt;code&gt;Finalized&lt;/code&gt;状态, 下次GC会被回收&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PhantomReference&lt;/code&gt;天生就是finalized状态, GC发生后就清掉了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;,&lt;code&gt;Vector&lt;/code&gt;都是1.0/1.1版本的东西, 为了兼容性而保留了&lt;/li&gt;
&lt;li&gt;1.4之后引入了&lt;code&gt;nio&lt;/code&gt;相较于之前的被称之为新IO&lt;/li&gt;
&lt;li&gt;1.1加入的Reader跟Writer是为了国际化兼容16位Unicode字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BufferedInputFile.read&lt;/code&gt;可以读取文件到Reader里, 在进行其他的包装, 如&lt;code&gt;StringReader&lt;/code&gt;, &lt;code&gt;BufferedReader&lt;/code&gt;, 没有快捷方式.&lt;/li&gt;
&lt;li&gt;写入文本可以使用&lt;code&gt;PrinterWriter&lt;/code&gt;简化, 直接&lt;code&gt;writer.println&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;System.out/in/err&lt;/code&gt;被称为标准IO, 通过&lt;code&gt;setOut/In/Err&lt;/code&gt;可以进行重定向&lt;/li&gt;
&lt;li&gt;&lt;code&gt;javap&lt;/code&gt;随jdk一起发布做反编译&lt;/li&gt;
&lt;li&gt;旧IO底层已经用nio重构过了&lt;/li&gt;
&lt;li&gt;旧的&lt;code&gt;FileInputStream&lt;/code&gt;, &lt;code&gt;FileOutputStream&lt;/code&gt;等被修改支持生成一个&lt;code&gt;Channel&lt;/code&gt;, Writer跟Reader不支持, 但是Channel有方法可以生成他们&lt;/li&gt;
&lt;li&gt;Channel通过&lt;code&gt;ByteBuffer&lt;/code&gt;进行读写, 写之前需要&lt;code&gt;flip&lt;/code&gt;准备缓冲区, 读之前需要&lt;code&gt;rewind&lt;/code&gt;回到数据头, 再通过&lt;code&gt;asCharBuffer&lt;/code&gt;转换后打印&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ByteBuffer.flip&lt;/code&gt;是将position设置为0, 将limit设置为当前位置, 准备写; &lt;code&gt;ByteBuffer.rewind&lt;/code&gt;是将position设置为0, 并将marker清除, 准备读; &lt;code&gt;mark&lt;/code&gt;会设置mark, &lt;code&gt;reset&lt;/code&gt;会把position指向mark&lt;/li&gt;
&lt;li&gt;通过ByteBuffer的&lt;code&gt;asCharBuffer&lt;/code&gt;或者别的方法, 可以获得所谓缓冲器视图, 对缓冲器进行对应类型的&lt;code&gt;put&lt;/code&gt;, 该缓冲器可通过其他as方法切换至其他的窗口进行输出&lt;/li&gt;
&lt;li&gt;如果直接向缓冲器内写入Bytes, 那么无法通过&lt;code&gt;asCharBuffer&lt;/code&gt;读出, 必须写入&lt;code&gt;UTF-16BE&lt;/code&gt;才对应格式, 按Char读出不会乱码&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;RandomAccesFile.map&lt;/code&gt;可以产生&lt;code&gt;MappedByteBuffer&lt;/code&gt;进行内存磁盘映射, 必须指定一个映射范围, 它的效率要比建立在nio之上的旧IO要快&lt;/li&gt;
&lt;li&gt;Object序列化的文件, 必须能在找到类定义的环境下才能被反序列化成功, 否则会ClassNotFoundException&lt;/li&gt;
&lt;li&gt;通过Serializable序列化, 内部有大量反射, 直接将二进制赋值, 不需要通过构造. 如果复写read/writeObject, 或者实现&lt;code&gt;Externalizable&lt;/code&gt;接口, 自己实现序列化, 则需要有public默认构造, 没有反射, 效率高&lt;/li&gt;
&lt;li&gt;静态成员变量不能自己序列化&lt;/li&gt;
&lt;li&gt;枚举在编译的时候编译器会给加入&lt;code&gt;values&lt;/code&gt;跟单参的&lt;code&gt;valueOf&lt;/code&gt;静态方法&lt;/li&gt;
&lt;li&gt;所以枚举向上转型Enum就没有values方法了, 但可以通过Class中&lt;code&gt;getEnumConstant&lt;/code&gt;方法反射&lt;/li&gt;
&lt;li&gt;构建枚举的枚举可以通过将枚举Class当构造参数传入枚举对象, 并且通过&lt;code&gt;geEnumConstant&lt;/code&gt;覆盖其values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EnumSet.allOf&lt;/code&gt;可以传入一个枚举类class, &lt;code&gt;of&lt;/code&gt;则是手动传入N个枚举类型&lt;/li&gt;
&lt;li&gt;枚举可以添加自定义方法, 每一个实例独自实现, 但是枚举实例不能像普通类一样作函数参数, 因为每一个实例其实是enum类型本身&lt;/li&gt;
&lt;li&gt;注解不能继承, 注解的字段要么定义默认值, 要么使用时传入, 不能为空&lt;/li&gt;
&lt;li&gt;线程设置为Deamon模式, 主线程结束后就被杀掉了&lt;/li&gt;
&lt;li&gt;Thread可以设置&lt;code&gt;setDefaultUncaughtExceptionHandler&lt;/code&gt;, 不设置就会被default处理&lt;/li&gt;
&lt;li&gt;测试资源竞争可以调用&lt;code&gt;Thread.yield&lt;/code&gt;增加几率&lt;/li&gt;
&lt;li&gt;Java也提供手动的&lt;code&gt;Lock&lt;/code&gt;, return要写在try里确保在finally的unlock之前调用&lt;/li&gt;
&lt;li&gt;如果想实现尝试获取, 不行放弃的话, 需要自己封装&lt;code&gt;ReentrantLock&lt;/code&gt;, 使用&lt;code&gt;tryLock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多核处理器上可视性比原子性问题多得多, volatile会解决可视性问题&lt;/li&gt;
&lt;li&gt;volatile如果已经被synchronized防护, 则不需要加; 如果只在一个任务中用, 也不用加; 如果依赖前值, 或者某个域的值, 那也无法工作&lt;/li&gt;
&lt;li&gt;在C++中自加可能是原子性的, 但是Java中肯定不是&lt;/li&gt;
&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt;最合理的是锁被调用对象this, 或者加方法上, 这样如果一个线程获得了锁, 其他synchronized的方法也都不能被别的线程调用了&lt;/li&gt;
&lt;li&gt;IO与Synchronized的阻塞无法被打断, 关闭资源才可以释放锁, 并打断线程, 锁阻塞续采用&lt;code&gt;Lock.lockInterruptibly&lt;/code&gt;才可以被打断&lt;/li&gt;
&lt;li&gt;线程被中断一般需要有清理逻辑, 通过try/catch/fanilly来做&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;, &lt;code&gt;yield()&lt;/code&gt;不会释放锁, &lt;code&gt;wait()&lt;/code&gt;期间对象锁会释放, 被notify后, 醒之前必须重新获得锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait&lt;/code&gt;一般跟while循环配合, 因为在即将被唤起之前(调用notify的前后), 可能条件已经发生了改变&lt;/li&gt;
&lt;li&gt;为了防止错过信号, 通常也需要通过while(cindition)来保护wait, 防止死锁&lt;/li&gt;
&lt;li&gt;因为wait会释放锁, 而notify在synchronized区间内, 会在之前获取锁, 而wait被唤醒又会重新获取锁, 所以实际上使用notifyAll也只能唤起在等待的一个任务, 同样, 使用notify的时候, 应使等待条件一致, 如果条件不一致, 则只能使用notifyAll&lt;/li&gt;
&lt;li&gt;可以synchronized锁Object以及wait/notify做同步, 也可以通过&lt;code&gt;ReentrantLock&lt;/code&gt;生成condition, 通过await/signal/lock/unlock来操控&lt;/li&gt;
&lt;li&gt;有时候使用一些同步对象也可以简化逻辑, 如&lt;code&gt;BlockingQueue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简单的线程同步也ke已用1.5引入的&lt;code&gt;CountDownLatch&lt;/code&gt;做&lt;/li&gt;
&lt;li&gt;相较于CountDown只能计数一边, &lt;code&gt;CyclicBarrier&lt;/code&gt;可以重复利用, 第一个参数传入parties个数, 当await数量达到时会停止等待, 并且调用第二个参数Runnable执行, 可以再次触发await, 这样可以形成一个循环, 或者闭环&lt;/li&gt;
&lt;li&gt;除了&lt;code&gt;BlockingQueue&lt;/code&gt;之外, 还有其他类似的同步队列, 但需要实现一定的接口, 如&lt;code&gt;DelayBlockingQueue&lt;/code&gt;, &lt;code&gt;PriorityBlockingQueue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SynchronousQueue&lt;/code&gt;的put必须等待take&lt;/li&gt;
&lt;li&gt;常用的Excutor有&lt;code&gt;CachedThreadPool&lt;/code&gt;, &lt;code&gt;ScheduledThreadPool&lt;/code&gt;, &lt;code&gt;FixedThreadPool&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;作为信号量, 可以设置次数, 多次acquire, 并通过release来释放信号, 区别于&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exchanger&lt;/code&gt;可以作为一个类似管道的东西, 同时传递生产到消费&lt;/li&gt;
&lt;li&gt;一般使用synchronized, 可读性强, 调优用Lock, 简单情况用Atomic, 有性能指标可以替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;内部使用整个数组的副本进行操作, 最终原子替换, 性能高一些, &lt;code&gt;ConcurrentHashMap&lt;/code&gt;与&lt;code&gt;ConcurrentLinkededQueue&lt;/code&gt;类似, 只不过是部分复制再操作. 这两者读取过程都有乐观锁处理, 所以性能要比synchronized List/Map好, 尤其是在很少写入的情况&lt;/li&gt;
&lt;li&gt;AtomicXXX有一些乐观加锁的函数, 如compareAndSet, 当提供的oldValue发生变化时, set失败&lt;/li&gt;
&lt;li&gt;读写锁(ReentrantReadWriteLock)保证了读取数据的一致性, 当写锁被持有的时候, 读锁将不能获取, 其他时候可多次获取读锁&lt;/li&gt;
&lt;li&gt;更多的时候多线程的问题要通过Task+消息队列, 但这个依赖于平台或者额外复杂的设计&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 24 Jun 2020 00:46:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<og:description>Thinking in Java 总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengdd/p/refresh-java.html</dc:identifier>
</item>
<item>
<title>搞定ReentrantReadWriteLock 几道小小数学题就够了 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/13185709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/13185709.html</guid>
<description>&lt;p&gt;| &lt;strong&gt;好看请赞，养成习惯&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084554199-997994831.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有了以上两篇文章的铺垫，来理解本文要介绍的既有独占式，又有共享式获取同步状态的 &lt;code&gt;ReadWriteLock&lt;/code&gt;，就非常轻松了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084554650-1070257189.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;readwritelock&quot;&gt;ReadWriteLock&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt; 直译过来为【读写锁】。现实中，读多写少的业务场景是非常普遍的，比如应用缓存&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个线程将数据写入缓存，其他线程可以直接读取缓存中的数据，提高数据查询效率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前提到的互斥锁都是排他锁，也就是说同一时刻只允许一个线程进行访问，当面对可共享读的业务场景，互斥锁显然是比较低效的一种处理方式。为了提高效率，读写锁模型就诞生了&lt;/p&gt;
&lt;p&gt;效率提升是一方面，但并发编程更重要的是在保证准确性的前提下提高效率&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个写线程改变了缓存中的值，其他读线程一定是可以 &lt;strong&gt;“感知”&lt;/strong&gt; 到的，否则可能导致查询到的值不准确&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以关于读写锁模型就了下面这 3 条规定：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;允许多个线程同时读共享变量&lt;/li&gt;
&lt;li&gt;只允许一个线程写共享变量&lt;/li&gt;
&lt;li&gt;如果写线程正在执行写操作，此时则禁止其他读线程读共享变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt; 是一个接口，其内部只有两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ReadWriteLock {
    // 返回用于读的锁
    Lock readLock();

    // 返回用于写的锁
    Lock writeLock();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以要了解整个读/写锁的整个应用过程，需要从它的实现类 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 说起&lt;/p&gt;
&lt;h3 id=&quot;reentrantreadwritelock-类结构&quot;&gt;ReentrantReadWriteLock 类结构&lt;/h3&gt;
&lt;p&gt;直接对比ReentrantReadWriteLock 与 ReentrantLock的类结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084555158-1388166534.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他们又很相似吧，根据类名称以及类结构，按照咱们前序文章的分析，你也就能看出 ReentrantReadWriteLock 的基本特性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084555709-4292919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中黄颜色标记的的 &lt;strong&gt;锁降级&lt;/strong&gt; 是看不出来的， 这里先有个印象，下面会单独说明&lt;/p&gt;
&lt;p&gt;另外，不知道你是否还记得，&lt;a href=&quot;https://dayarch.top/p/java-aqs-and-reentrantlock.html&quot;&gt;Java AQS队列同步器以及ReentrantLock的应用&lt;/a&gt; 说过，Lock 和 AQS 同步器是一种组合形式的存在，既然这里是读/写两种锁，他们的组合模式也就分成了两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读锁与自定义同步器的聚合&lt;/li&gt;
&lt;li&gt;写锁与自定义同步器的聚合&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084556162-374219872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只是提醒大家，模式没有变，不要被读/写两种锁迷惑&lt;/p&gt;
&lt;h4 id=&quot;基本示例&quot;&gt;基本示例&lt;/h4&gt;
&lt;p&gt;说了这么多，如果你忘了前序知识，整体理解感觉应该是有断档的，所以先来看个示例（模拟使用缓存）让大家对 ReentrantReadWriteLock 有个直观的使用印象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReentrantReadWriteLockCache {

        // 定义一个非线程安全的 HashMap 用于缓存对象
        static Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
        // 创建读写锁对象
        static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        // 构建读锁
        static Lock rl = readWriteLock.readLock();
        // 构建写锁
        static Lock wl = readWriteLock.writeLock();

        public static final Object get(String key) {
                rl.lock();
                try{
                        return map.get(key);
                }finally {
                        rl.unlock();
                }
        }

        public static final Object put(String key, Object value){
                wl.lock();
                try{
                        return map.put(key, value);
                }finally {
                        wl.unlock();
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你瞧，使用就是这么简单。但是你知道的，AQS 的核心是锁的实现，即控制同步状态 state 的值，ReentrantReadWriteLock 也是应用AQS的 state 来控制同步状态的，那么问题来了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个 int 类型的 state 怎么既控制读的同步状态，又可以控制写的同步状态呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然需要一点设计了&lt;/p&gt;
&lt;h3 id=&quot;读写状态设计&quot;&gt;读写状态设计&lt;/h3&gt;
&lt;p&gt;如果要在一个 int 类型变量上维护多个状态，那肯定就需要拆分了。我们知道 int 类型数据占32位，所以我们就有机会按位切割使用state了。我们将其切割成两部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高16位表示读&lt;/li&gt;
&lt;li&gt;低16位表示写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084556525-1033570473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，要想准确的计算读/写各自的状态值，肯定就要应用位运算了，下面代码是 JDK1.8，ReentrantReadWriteLock 自定义同步器 Sync 的位操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;abstract static class Sync extends AbstractQueuedSynchronizer {
       

        static final int SHARED_SHIFT   = 16;
        static final int SHARED_UNIT    = (1 &amp;lt;&amp;lt; SHARED_SHIFT);
        static final int MAX_COUNT      = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;
        static final int EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;


        static int sharedCount(int c) { 
          return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; 
        }

        static int exclusiveCount(int c) { 
          return c &amp;amp; EXCLUSIVE_MASK; 
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看真是有些复杂的可怕，别慌，咱们通过几道小小数学题就可以搞定整个位运算过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084556981-1165445002.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个 ReentrantReadWriteLock 中 读/写状态的计算就是反复应用这几道数学题，所以，在阅读下面内容之前，希望你搞懂这简单的运算&lt;/p&gt;
&lt;p&gt;基础铺垫足够了，我们进入源码分析吧&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;写锁分析&quot;&gt;写锁分析&lt;/h4&gt;
&lt;p&gt;由于写锁是排他的，所以肯定是要重写 AQS 中 &lt;code&gt;tryAcquire&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        protected final boolean tryAcquire(int acquires) {        
            Thread current = Thread.currentThread();
                // 获取 state 整体的值
            int c = getState();
            // 获取写状态的值
            int w = exclusiveCount(c);
            if (c != 0) {
                // w=0: 根据推理二，整体状态不等于零，写状态等于零，所以，读状态大于0，即存在读锁
                // 或者当前线程不是已获取写锁的线程
                // 二者之一条件成真，则获取写状态失败
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                // 根据推理一第 1 条，更新写状态值
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码 第 19 行 writerShouldBlock 也并没有什么神秘的，只不过是公平/非公平获取锁方式的判断（是否有前驱节点来判断）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084557358-1883840744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你瞧，写锁获取方式就是这么简单&lt;/p&gt;
&lt;h4 id=&quot;读锁分析&quot;&gt;读锁分析&lt;/h4&gt;
&lt;p&gt;由于读锁是共享式的，所以肯定是要重写 AQS 中 &lt;code&gt;tryAcquireShared&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        protected final int tryAcquireShared(int unused) {
            Thread current = Thread.currentThread();
            int c = getState();
                // 写状态不等于0，并且锁的持有者不是当前线程，根据约定 3，则获取读锁失败
            if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
                getExclusiveOwnerThread() != current)
                return -1;
                // 获取读状态值
            int r = sharedCount(c);
                // 这个地方有点不一样，我们单独说明
            if (!readerShouldBlock() &amp;amp;&amp;amp;
                r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
                compareAndSetState(c, c + SHARED_UNIT)) {
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                return 1;
            }
                // 如果获取读锁失败则进入自旋获取
            return fullTryAcquireShared(current);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;readerShouldBlock&lt;/code&gt; 和 &lt;code&gt;writerShouldBlock&lt;/code&gt; 在公平锁的实现上都是判断是否有前驱节点，但是在非公平锁的实现上，前者是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();
}

final boolean apparentlyFirstQueuedIsExclusive() {
  Node h, s;
  return (h = head) != null &amp;amp;&amp;amp;
    // 等待队列头节点的下一个节点
    (s = h.next)  != null &amp;amp;&amp;amp;
    // 如果是排他式的节点
    !s.isShared()         &amp;amp;&amp;amp;
    s.thread != null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，如果请求读锁的当前线程发现同步队列的 head 节点的下一个节点为排他式节点，那么就说明有一个线程在等待获取写锁（争抢写锁失败，被放入到同步队列中），那么请求读锁的线程就要阻塞，毕竟读多写少，如果还没有这点判断机制，写锁可能会发生【饥饿】&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上述条件都满足了，也就会进入 &lt;code&gt;tryAcquireShared&lt;/code&gt; 代码的第 14 行到第 25 行，这段代码主要是为了记录线程持有锁的次数。读锁是共享式的，还想记录每个线程持有读锁的次数，就要用到 ThreadLocal 了，因为这不影响同步状态 state 的值，所以就不分析了, 只把关系放在这吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084557747-524488303.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里读锁的获取也就结束了，比写锁稍稍复杂那么一丢丢，接下来就说明一下那个可能让你迷惑的锁升级/降级问题吧&lt;/p&gt;
&lt;h2 id=&quot;读写锁的升级与降级&quot;&gt;读写锁的升级与降级&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;个人理解：&lt;/strong&gt;读锁是可以被多线程共享的，写锁是单线程独占的，也就是说写锁的并发限制比读锁高，所以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084557993-1970515328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在真正了解读写锁的升级与降级之前，我们需要完善一下本文开头 ReentrantReadWriteLock 的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public static final Object get(String key) {
                Object obj = null;
                rl.lock();
                try{
      // 获取缓存中的值
                        obj = map.get(key);
                }finally {
                        rl.unlock();
                }
                // 缓存中值不为空，直接返回
                if (obj!= null) {
                        return obj;
                }
                
    // 缓存中值为空，则通过写锁查询DB，并将其写入到缓存中
                wl.lock();
                try{
      // 再次尝试获取缓存中的值
                        obj = map.get(key);
      // 再次获取缓存中值还是为空
                        if (obj == null) {
        // 查询DB
                                obj = getDataFromDB(key); // 伪代码：getDataFromDB
        // 将其放入到缓存中
                                map.put(key, obj);
                        }
                }finally {
                        wl.unlock();
                }
                return obj;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有童鞋可能会有疑问&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在写锁里面，为什么代码第19行还要再次获取缓存中的值呢？不是多此一举吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这里再次尝试获取缓存中的值是很有必要的，因为可能存在多个线程同时执行 get 方法，并且参数 key 也是相同的，执行到代码第 16 行 &lt;code&gt;wl.lock()&lt;/code&gt; ,比如这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084558222-916052898.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程 A，B，C 同时执行到临界区 wl.lock()， 只有线程 A 获取写锁成功，线程B，C只能阻塞，直到线程A 释放写锁。这时，当线程B 或者 C 再次进入临界区时，线程 A 已经将值更新到缓存中了，所以线程B，C没必要再查询一次DB，而是再次尝试查询缓存中的值&lt;/p&gt;
&lt;p&gt;既然再次获取缓存很有必要，我能否在读锁里直接判断，如果缓存中没有值，那就再次获取写锁来查询DB不就可以了嘛，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public static final Object getLockUpgrade(String key) {
                Object obj = null;
                rl.lock();
                try{
                        obj = map.get(key);
                        if (obj == null){
                                wl.lock();
                                try{
                                        obj = map.get(key);
                                        if (obj == null) {
                                                obj = getDataFromDB(key); // 伪代码：getDataFromDB
                                                map.put(key, obj);
                                        }
                                }finally {
                                        wl.unlock();
                                }
                        }
                }finally {
                        rl.unlock();
                }

                return obj;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这还真是不可以的，因为获取一个写入锁需要先释放所有的读取锁，如果有两个读取锁试图获取写入锁，且都不释放读取锁时，就会发生死锁，所以在这里，锁的升级是不被允许的&lt;/p&gt;
&lt;p&gt;读写锁的升级是不可以的，那么锁的降级是可以的嘛？这个是 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;Oracle 官网关于锁降级的示例&lt;/a&gt; ，我将代码粘贴在此处，大家有兴趣可以点进去连接看更多内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
        // 必须在获取写锁之前释放读锁，因为锁的升级是不被允许的
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        try {
          // 再次检查，原因可能是其他线程已经更新过缓存
          if (!cacheValid) {
            data = ...
            cacheValid = true;
          }
                                        //在释放写锁前，降级为读锁
          rwl.readLock().lock();
        } finally {
          //释放写锁，此时持有读锁
          rwl.writeLock().unlock(); 
        }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中声明了一个 volatile 类型的 cacheValid 变量，保证其可见性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先获取读锁，如果cache不可用，则释放读锁&lt;/li&gt;
&lt;li&gt;然后获取写锁&lt;/li&gt;
&lt;li&gt;在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true&lt;/li&gt;
&lt;li&gt;然后在&lt;strong&gt;释放写锁前获取读锁&lt;/strong&gt; 此时&lt;/li&gt;
&lt;li&gt;cache中数据可用，处理cache中数据，最后释放读锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个过程就是一个完整的锁降级的过程，目的是保证数据可见性，听起来很有道理的样子，那么问题来了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上述代码为什么在释放写锁之前要获取读锁呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果当前的&lt;strong&gt;线程A&lt;/strong&gt;在修改完cache中的数据后，没有获取读锁而是直接释放了写锁；假设此时另一个&lt;strong&gt;线程B&lt;/strong&gt; 获取了写锁并修改了数据，那么&lt;strong&gt;线程A&lt;/strong&gt;无法感知到数据已被修改，但线程A还应用了缓存数据，所以就可能出现数据错误&lt;/p&gt;
&lt;p&gt;如果遵循锁降级的步骤，&lt;strong&gt;线程A&lt;/strong&gt; 在释放写锁之前获取读锁，那么&lt;strong&gt;线程B&lt;/strong&gt;在获取写锁时将被阻塞，直到&lt;strong&gt;线程A&lt;/strong&gt;完成数据处理过程，释放读锁，从而保证数据的可见性&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那问题又来了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用写锁一定要降级吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你理解了上面的问题，相信这个问题已经有了答案。假如&lt;strong&gt;线程A&lt;/strong&gt;修改完数据之后， 经过耗时操作后想要再使用数据时，希望使用的是自己修改后的数据，而不是其他线程修改后的数据，这样的话确实是需要锁降级；如果只是希望最后使用数据的时候，拿到的是最新的数据，而不一定是自己刚修改过的数据，那么先释放写锁，再获取读锁，然后使用数据也无妨&lt;/p&gt;
&lt;p&gt;在这里我要额外说明一下你可能存在的误解：&lt;/p&gt;
&lt;p&gt;相信你到这里也理解了锁的升级与降级过程，以及他们被允许或被禁止的原因了&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要说明了 ReentrantReadWriteLock 是如何应用 state 做位拆分实现读/写两种同步状态的，另外也通过源码分析了读/写锁获取同步状态的过程，最后又了解了读写锁的升级/降级机制，相信到这里你对读写锁已经有了一定的理解。如果你对文中的哪些地方觉得理解有些困难，强烈建议你回看本文开头的两篇文章，那里铺垫了非常多的内容。接下来我们就看看在应用AQS的最后一个并发工具类 CountDownLatch 吧&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;读锁也没修改数据，还允许共享式获取，那还有必要设置读锁吗？&lt;/li&gt;
&lt;li&gt;在分布式环境中，你是如何保证缓存数据一致性的呢？&lt;/li&gt;
&lt;li&gt;当你打开看ReentrantReadWriteLock源码时，你会发现，WriteLock 中可以使用 Condition，但是ReadLock 使用Condition却会抛出UnsupportedOperationException，这是为什么呢？&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// WriteLock
public Condition newCondition() {
        return sync.newCondition();
}

// ReadLock
public Condition newCondition() {
        throw new UnsupportedOperationException();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://dayarch.top&quot;&gt;个人博客：https://dayarch.top&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/G7BXuZh0Qh1-mE6ts4LJqQ&quot;&gt;加我微信好友&lt;/a&gt;, 进群娱乐学习交流，备注「进群」&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号：「日拱一兵」&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总 | 回复「工具」&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取 | 回复「资料」&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200624084558605-1169887381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 00:46:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>| 好看请赞，养成习惯 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/13185709.html</dc:identifier>
</item>
<item>
<title>重复提交，你是如何处理的？ - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13185695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13185695.html</guid>
<description>&lt;p&gt;今天早上，新来的同事小王突然问我：“周哥，什么是幂等性啊？”。然后我就跟他解释了一番，幂等性就是说无论你执行几次请求，其结果是一样的。说到了幂等就不得不说重复提交了，你连续点击提交按钮，理论上来说这是同一条数据，数据库应该只能存入一条，而实际上存放了多条，这就违反了幂等性。因此我们就需要做一些处理，来保证连续点击提交按钮后，数据库只能存入一条数据。&lt;/p&gt;
&lt;p&gt;防止重复提交的方式很多，这里我就说一下我认为比较好用的一种。&lt;/p&gt;
&lt;h2 id=&quot;自定义注解aop实现&quot;&gt;自定义注解+Aop实现&lt;/h2&gt;
&lt;p&gt;我们通过获取用户ip及访问的接口来判断他是否重复提交，假如这个ip在一段时间内容多次访问这个接口，我们则认为是重复提交，我们将重复提交的请求直接处理即可，不让访问目标接口。&lt;/p&gt;
&lt;h3 id=&quot;自定义注解&quot;&gt;自定义注解&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface NoRepeatSubmit {

    /**
     * 默认1s钟以内算重复提交
     * @return
     */
    long timeout() default 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;aop处理逻辑&quot;&gt;Aop处理逻辑&lt;/h3&gt;
&lt;p&gt;我们将ip+接口地址作为key，随机生成UUID作为value，存入redis。每次请求进来，根据key查询redis，如果存在则说明是重复提交，抛出异常，如果不存在，则是正常提交，将key存入redis。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Aspect
@Component
public class NoRepeatSubmitAop {

        @Autowired
        private RedisService redisUtils;

        /**
         *      定义切入点
         */
        @Pointcut(&quot;@annotation(NoRepeatSubmit)&quot;)
        public void noRepeat() {}

        /**
         *      前置通知：在连接点之前执行的通知
         * @param point
         * @throws Throwable
         */
        @Before(&quot;noRepeat()&quot;)
        public void before(JoinPoint point) throws Exception{
                // 接收到请求，记录请求内容
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                HttpServletRequest request = attributes.getRequest();
                Assert.notNull(request, &quot;request can not null&quot;);

                // 此处可以用token或者JSessionId
                String token = IpUtils.getIpAddr(request);
                String path = request.getServletPath();
                String key = getKey(token, path);
                String clientId = getClientId();
                List&amp;lt;Object&amp;gt; lGet = redisUtils.lGet(key, 0, -1);
                // 获取注解
                MethodSignature signature = (MethodSignature) point.getSignature();
                Method method = signature.getMethod();
                NoRepeatSubmit annotation = method.getAnnotation(NoRepeatSubmit.class);
                long timeout = annotation.timeout();
                boolean isSuccess = false;
                if (lGet.size()==0 || lGet == null) {
                        isSuccess = redisUtils.lSet(key, clientId, timeout);
                }
                if (!isSuccess) {
                        // 获取锁失败，认为是重复提交的请求
                        redisUtils.lSet(key, clientId, timeout);
                        throw new Exception(&quot;不可以重复提交&quot;);
                }

        }

        private String getKey(String token, String path) {
                return token + path;
        }

        private String getClientId() {
                return UUID.randomUUID().toString();
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提供接口用来测试&quot;&gt;提供接口用来测试&lt;/h3&gt;
&lt;p&gt;在接口上添加上我们自定义的注解@NoRepeatSubmit&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(&quot;/test&quot;)
@NoRepeatSubmit
public String tt(HttpServletRequest request) {

    return &quot;1&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;我们在浏览器中连续请求两次接口。发现第一次接口响应正常内容：1，第二次接口响应了不可重复提交的异常信息。1s之后再点击接口，发现又响应了正常内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/06/13/naZHsrXzV9IM6bm.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这种防止重复提交的方式就介绍完了，这样我们就完美防止了接口重复提交。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 00:44:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>今天早上，新来的同事小王突然问我：“周哥，什么是幂等性啊？”。然后我就跟他解释了一番，幂等性就是说无论你执行几次请求，其结果是一样的。说到了幂等就不得不说重复提交了，你连续点击提交按钮，理论上来说这是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13185695.html</dc:identifier>
</item>
<item>
<title>几个超级实用但很少人知道的 VS 技巧 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13185674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13185674.html</guid>
<description>&lt;p&gt;大家好，今天分享几个我知道的实用 VS 技巧，而这些技巧我发现很多人都不知道。因为我经常在工作中遇到：我在同事电脑上解决问题，或在会议上演示代码示例时，使用了一些 VS “骚”操作，他们会好奇地问：你是怎么做到的？这给我的感觉，有时候你知道一些别人不知道的小技巧便可以让你显得更专业。&lt;/p&gt;
&lt;h2 id=&quot;1-扩展缩小选区&quot;&gt;1. 扩展/缩小选区&lt;/h2&gt;
&lt;p&gt;通过双击选中整个单词，这个操作大家应该都知道。但如何快速选择几个单词、或多个单词的字符串、或代码块呢？教大家一个快捷键，如何快速扩展选择代码区域。例如，当光标在一个字符串中时，使用下面的快捷键就可以选择整个字符串。&lt;/p&gt;
&lt;p&gt;按 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;=&lt;/code&gt; 扩展选区，按 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;-&lt;/code&gt; 缩小选区：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23103936&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你也可以使用 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;]&lt;/code&gt; 直接选中一个代码块。&lt;/p&gt;
&lt;h2 id=&quot;2-切换窗口停靠&quot;&gt;2. 切换窗口停靠&lt;/h2&gt;
&lt;p&gt;我们知道VS的窗口布局可以非常灵活的拖动，想摆哪摆哪。我们一般把常用的视图窗口固定停靠在编辑器的左边、右边或下边。但有时候为了查看方便，你可能需要临时把窗口拖到另一个位置（比如中心位置）。完了以后你还需要再次把它停靠到原来的位置，这样拖动起来就会比较麻烦。有一种非常快速的方法可以将窗口停靠到它之前停靠的位置。&lt;/p&gt;
&lt;p&gt;按 &lt;code&gt;Ctrl&lt;/code&gt; + 双击窗口标题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23105157&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-快速定位打开的文件&quot;&gt;3. 快速定位打开的文件&lt;/h2&gt;
&lt;p&gt;在 VS 中，你可以使用 &lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;T&lt;/code&gt; 打开 “Go To All” 搜索工具栏，通过搜索关键字轻松打开要找的文件。但是对于某些操作，比如重命名文件，你需要在解决方案资源管理器中找到该文件。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; 或使用下面的图标按钮可以快速定位到当前打开的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23113201&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-多行编辑&quot;&gt;4. 多行编辑&lt;/h2&gt;
&lt;p&gt;Visual Studio 允许同时编辑多行，这对于将相同的更改应用于多行非常有用，例如同时修改多个属性的修饰符。下面有 4 个多行编辑代码的技巧。&lt;/p&gt;
&lt;p&gt;按住 &lt;code&gt;Alt&lt;/code&gt; 键，使用鼠标拖选：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23113818&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按住 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; 键，再按上/下/左/右方向键选择：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23121030&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用多个光标同时编辑。按住 &lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Alt&lt;/code&gt; 键，点击或选择要插入或编辑的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23121334&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;匹配相同单词并编辑。先选择要编辑的单词或字符，再按一下 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;;&lt;/code&gt;，会自动匹配并选中所有相同的单词，然后开始编辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23122420&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你也可以使用 &lt;code&gt;Alt&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;.&lt;/code&gt; 只匹配选择下一个相同的单词。&lt;/p&gt;
&lt;h2 id=&quot;5-使用剪贴板历史粘贴&quot;&gt;5. 使用剪贴板历史粘贴&lt;/h2&gt;
&lt;p&gt;复制粘贴是写代码很常见的操作。我们在 Ctrl + V 时默认是粘贴你最后一次复制的内容，但有时你想使用上一次复制的内容，你可能会重新再复制一下。剪贴板一次只能包含一个内容。Visual Studio 附带了一个剪贴板历史记录，默认它包含你复制到剪贴板的最后 20 项记录。&lt;/p&gt;
&lt;p&gt;通过使用 &lt;code&gt;Ctrl&lt;/code&gt; + &lt;code&gt;Shift&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt;，可以打开剪贴板的历史记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23124443&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以将多个内容复制到剪贴板，并在稍后依次粘贴到相应的位置。&lt;/p&gt;
&lt;h2 id=&quot;6-整行上下移动&quot;&gt;6. 整行上下移动&lt;/h2&gt;
&lt;p&gt;有时候我们需要调整一下代码行的位置，比如将代码行上移或下移几行。可以按住 &lt;code&gt;Alt&lt;/code&gt;，然后使用上下方向键移动整行代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn-tc.geekgist.com/202006/23130000&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;本文只罗列了几个很多人都不知道的 VS 实用技巧，当然还有很多大多数人都知道的技巧，比如 Ctrl + D 复制当前行、Ctrl + X 剪切当前行、Shift + Enter 新启一行等等，在这里就不一一罗列了。&lt;/p&gt;
&lt;p&gt;你还知道哪些实用的 VS 使用技巧？欢迎留言分享！&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 00:36:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>大家好，今天分享几个我知道的实用 VS 技巧，而这些技巧我发现很多人都不知道。因为我经常在工作中遇到：我在同事电脑上解决问题，或在会议上演示代码示例时，使用了一些 VS “骚”操作，他们会好奇地问：你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13185674.html</dc:identifier>
</item>
<item>
<title>用Python进行实时计算——PyFlink快速入门 - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13185670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13185670.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3aa15e6c73fe?w=321&amp;amp;h=245&amp;amp;f=png&amp;amp;s=19355&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flink 1.9.0及更高版本支持Python，也就是PyFlink。&lt;/p&gt;
&lt;p&gt;在最新版本的Flink 1.10中，PyFlink支持Python用户定义的函数，使您能够在Table API和SQL中注册和使用这些函数。但是，听完所有这些后，您可能仍然想知道PyFlink的架构到底是什么？作为PyFlink的快速指南，本文将回答这些问题。&lt;/p&gt;

&lt;h2 id=&quot;python上的flink和flink上的python&quot;&gt;Python上的Flink和Flink上的Python&lt;/h2&gt;
&lt;p&gt;那么，PyFlink到底是什么？顾名思义，PyFlink就是Apache Flink与Python的组合，或者说是Python上的Flink。但是Flink on Python是什么意思？首先，两者的结合意味着您可以在Python中使用Flink的所有功能。而且，更重要的是，PyFlink还允许您在Flink上使用Python广泛的生态系统的计算功能，从而可以进一步促进其生态系统的开发。换句话说，这对双方都是双赢。如果您更深入地研究这个主题，您会发现Flink框架和Python语言的集成绝不是巧合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3aad180ed654?w=720&amp;amp;h=388&amp;amp;f=png&amp;amp;s=119665&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;python和大数据生态系统&quot;&gt;Python和大数据生态系统&lt;/h2&gt;
&lt;p&gt;python语言与大数据紧密相连。为了理解这一点，我们可以看一下人们正在使用Python解决的一些实际问题。一项用户调查显示，大多数人都在使用Python进行数据分析和机器学习应用程序。对于此类情况，大数据空间中还解决了一些理想的解决方案。除了扩大大数据产品的受众范围之外，Python和大数据的集成还通过将其独立体系结构扩展到分布式体系结构，极大地增强了Python生态系统的功能。这也解释了在分析大量数据时对Python的强烈需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3aaed5ca098e?w=711&amp;amp;h=267&amp;amp;f=png&amp;amp;s=65091&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么选择flink和python？&quot;&gt;为什么选择Flink和Python？&lt;/h2&gt;
&lt;p&gt;Python和大数据的集成与其他最近的趋势一致。但是，再次说明一下，为什么Flink现在支持Python，而不是Go或R或另一种语言？而且，为什么大多数用户选择PyFlink而不是PySpark和PyHive？&lt;/p&gt;
&lt;p&gt;为了理解原因，让我们首先考虑使用Flink框架的一些优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有利的体系结构：&lt;/strong&gt; Flink是具有统一流和批处理功能的纯流计算引擎。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新的活力：&lt;/strong&gt;根据ASF的客观统计，Flink是2019年最活跃的开源项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可靠性：&lt;/strong&gt;作为一个开源项目，Flink经过长期测试，并广泛应用于大数据公司的生产环境中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，让我们看看为什么Flink支持Python而不是其他语言。统计数据显示，Python是继Java和C之后最受欢迎的语言，并且自2018年以来一直在快速发展。Java和Scala是Flink的默认语言，但是Flink支持Python似乎是合理的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab098192049?w=743&amp;amp;h=271&amp;amp;f=png&amp;amp;s=123507&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PyFlink是相关技术发展的必然产物。但是，仅仅了解PyFlink的重要性是不够的，因为我们的最终目标是使Flink和Python用户受益并解决实际问题。因此，我们需要进一步探索如何实现PyFlink。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab22b93acc0?w=731&amp;amp;h=250&amp;amp;f=png&amp;amp;s=48433&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要实现PyFlink，我们需要知道要实现的关键目标和要解决的核心问题。PyFlink的主要目标是什么？简而言之，PyFlink的主要目标如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使所有Flink功能对Python用户可用。&lt;/li&gt;
&lt;li&gt;在Flink上运行Python的分析和计算功能，以提高Python解决大数据问题的能力。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在此基础上，让我们分析实现这些目标需要解决的关键问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab40fff61c5?w=670&amp;amp;h=333&amp;amp;f=png&amp;amp;s=82135&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使flink功能可供python用户使用&quot;&gt;使Flink功能可供Python用户使用&lt;/h2&gt;
&lt;p&gt;要实现PyFlink，是否需要像现有Java引擎一样在Flink上开发Python引擎？答案是NO。尝试在Flink 1.8版或更早版本中进行，但效果不佳。基本设计原则是以最小的成本实现给定的目标。最简单但最好的方法是提供一层Python API，并重用现有的计算引擎。&lt;/p&gt;
&lt;p&gt;那么，我们应该为Flink提供哪些Python API？他们对我们很熟悉：高级表API和SQL，以及有状态的DataStream API。现在，我们越来越接近Flink的内部逻辑，下一步是提供适用于Python的Table API和DataStream API。但是，剩下要解决的关键问题到底是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab5c111d161?w=611&amp;amp;h=205&amp;amp;f=png&amp;amp;s=54535&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然，关键问题在于在Python虚拟机（PyVM）和Java虚拟机（JVM）之间建立握手，这对于Flink支持多种语言至关重要。要解决此问题，我们必须选择适当的通信技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab756ae1657?w=659&amp;amp;h=159&amp;amp;f=png&amp;amp;s=43459&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择虚拟机通信技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前，有两种解决方案可用于实现PyVM和JVM之间的通信，它们是Beam和Py4J。前者是一个著名的项目，具有多语言和多引擎支持，而后者是用于PyVM和JVM之间通信的专用解决方案。我们可以从几个不同的角度比较和对比Apache Beam和Py4J，以了解它们之间的区别。首先，考虑一个比喻：要越过一堵墙，Py4J会像痣一样在其中挖一个洞，而Apache Beam会像大熊一样把整堵墙推倒。从这个角度来看，使用Apache Beam来实现VM通信有点复杂。简而言之，这是因为Apache Beam专注于通用性，在极端情况下缺乏灵活性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ab8e5a924e1?w=687&amp;amp;h=274&amp;amp;f=png&amp;amp;s=90971&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，Flink还需要交互式编程。此外，为了使Flink正常工作，我们还需要确保其API设计中的语义一致性，尤其是在其多语言支持方面。Apache Beam的现有体系结构无法满足这些要求，因此答案很明显，Py4J是支持PyVM和JVM之间通信的最佳选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3aba4458f5c5?w=671&amp;amp;h=269&amp;amp;f=png&amp;amp;s=60974&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在PyVM和JVM之间建立通信之后，我们已经实现了向Python用户提供Flink功能的第一个目标。我们已经在Flink 1.9版中实现了这一点。现在，让我们看一下Flink 1.9版中PyFlink API的体系结构：&lt;/p&gt;
&lt;p&gt;Flink 1.9版使用Py4J来实现虚拟机通信。我们为PyVM启用了网关，为JVM启用了网关服务器以接收Python请求。此外，我们还提供了Python API中的TableENV和Table之类的对象，这些对象与Java API中提供的对象相同。因此，编写Python API的本质是关于如何调用Java API。Flink 1.9版还解决了作业部署问题。它使您可以通过各种方式提交作业，例如运行Python命令以及使用Python Shell和CLI。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3abb9f0e250a?w=676&amp;amp;h=278&amp;amp;f=png&amp;amp;s=62190&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，此体系结构提供了哪些优势？首先，该体系结构很简单，并且可以确保Python API和Java API之间的语义一致性。其次，它还提供了与Java作业相当的出色Python作业处理性能。&lt;/p&gt;
&lt;h2 id=&quot;在flink上运行python的分析和计算功能&quot;&gt;在Flink上运行Python的分析和计算功能&lt;/h2&gt;
&lt;p&gt;上一节介绍了如何使Flink功能可供Python用户使用。本节说明如何在Flink上运行Python函数。通常，我们可以通过以下两种方式之一在Flink上运行Python函数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;选择一个典型的Python类库，并将其API添加到PyFlink。&lt;/strong&gt;该方法花费很长时间，因为Python包含太多的类库。在合并任何API之前，我们需要简化Python执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于现有的Flink Table API和Python类库的特征，我们可以将所有现有的Python类库函数视为用户定义的函数，并将其集成到Flink中。&lt;/strong&gt;Flink 1.10及更高版本中支持此功能。功能集成的关键问题是什么？同样，它取决于Python用户定义函数的执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，让我们为这个关键问题选择一种技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3abdb320fc80?w=661&amp;amp;h=238&amp;amp;f=png&amp;amp;s=92774&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择执行用户定义功能的技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，执行Python用户定义的函数非常复杂。它不仅涉及虚拟机之间的通信，还涉及以下所有方面：管理Python执行环境，解析Java和Python之间交换的业务数据，将Flink中的状态后端传递给Python以及监视执行状态。鉴于所有这些复杂性，现在是Apache Beam发挥作用的时候了。作为支持多种引擎和多种语言的大熊，Apache Beam可以在解决这种情况方面做很多工作，所以让我们看看Apache Beam如何处理执行Python用户定义的函数。&lt;/p&gt;
&lt;p&gt;下面显示了可移植性框架，该框架是Apache Beam的高度抽象的体系结构，旨在支持多种语言和引擎。当前，Apache Beam支持几种不同的语言，包括Java，Go和Python。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户定义的功能架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDF体系结构不仅需要实现PyVM与JVM之间的通信，还需要在编译和运行阶段满足不同的要求。在下面的PyLink用户定义功能架构图中，JVM中的行为以绿色表示，而PyVM中的行为以蓝色表示。让我们看看编译期间的局部设计。本地设计依赖于纯API映射调用。Py4J用于VM通信。&lt;/p&gt;
&lt;p&gt;现在，让我们看看Python API和Java API在此架构中的工作方式。在Java方面，JobMaster将作业分配给TaskManager，就像处理普通Java作业一样，并且TaskManager执行任务，这涉及到操作员在JVM和PyVM中的执行。在Python用户定义的函数运算符中，我们将设计各种gRPC服务，用于JVM和PyVM之间的通信。例如，用于业务数据通信的DataService和用于Python UDF的StateService来调用Java State后端。还将提供许多其他服务，例如日志记录和指标。&lt;/p&gt;

&lt;p&gt;了解了PyFlink的体系结构及其背后的思想之后，我们来看一下PyFlink的特定应用场景，以更好地了解其背后的方式和原因。&lt;/p&gt;
&lt;h2 id=&quot;pyflink的应用场景&quot;&gt;PyFlink的应用场景&lt;/h2&gt;
&lt;p&gt;PyFlink支持哪些业务方案？我们可以从两个角度分析其应用场景：Python和Java。请记住，PyFlink也适用于Java可以应用的所有情况。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;事件驱动的方案，&lt;/strong&gt;例如实时数据监控。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据分析，&lt;/strong&gt;例如库存管理和数据可视化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据管道，&lt;/strong&gt;也称为ETL方案，例如日志解析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机器学习，&lt;/strong&gt;例如有针对性的建议。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;您可以在所有这些情况下使用PyFlink。PyFlink也适用于特定于Python的方案，例如科学计算。在如此众多的应用场景中，您可能想知道现在可以使用哪些特定的PyFlink API。因此，现在我们也来研究这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3abff9816886?w=725&amp;amp;h=336&amp;amp;f=png&amp;amp;s=142954&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;pyflink安装&quot;&gt;PyFlink安装&lt;/h2&gt;
&lt;p&gt;在使用任何API之前，您需要安装PyFlink。当前，要安装PyFlink，请运行命令：&lt;code&gt;pip install apache-Flink&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;pyflink-api&quot;&gt;PyFlink API&lt;/h2&gt;
&lt;p&gt;PyFlink API与Java Table API完全一致，以支持各种关系和窗口操作。某些易于使用的PyFlink API比SQL API更为强大，例如特定于列操作的API。除了API，PyFlink还提供了多种定义Python UDF的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ac174c9ed83?w=668&amp;amp;h=365&amp;amp;f=png&amp;amp;s=163306&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;pyflink中用户定义的函数定义&quot;&gt;PyFlink中用户定义的函数定义&lt;/h2&gt;
&lt;p&gt;可以扩展ScalarFunction（例如，通过添加指标）以提供更多辅助功能。另外，PyFlink用户功能函数支持Python支持的所有方法定义，例如lambda，命名函数和可调用函数。&lt;/p&gt;
&lt;p&gt;定义完这些方法后，我们可以使用PyFlink Decorators进行标记，并描述输入和输出数据类型。我们还可以基于Python的类型提示功能进一步简化更高版本，以进行类型派生。以下示例将帮助您更好地了解如何定义用户定义的函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ac2e9972fda?w=642&amp;amp;h=262&amp;amp;f=png&amp;amp;s=85762&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义python用户定义函数的一种情况&quot;&gt;定义Python用户定义函数的一种情况&lt;/h2&gt;
&lt;p&gt;在本例中，我们将两个数字相加。首先，为此，导入必要的类，然后定义前面提到的函数。这非常简单，因此让我们进行一个实际案例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ac453b72062?w=1129&amp;amp;h=497&amp;amp;f=png&amp;amp;s=306404&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通常，使用PyFlink进行业务开发很简单。您可以通过SQL或Table API轻松描述业务逻辑，而无需了解基础实现。让我们看一下PyFlink的整体前景。&lt;/p&gt;
&lt;h2 id=&quot;目标驱动路线图&quot;&gt;目标驱动路线图&lt;/h2&gt;
&lt;p&gt;PyFlink的开发始终受到目标的推动，这些目标是使Flink功能可供Python用户使用并将Python函数集成到Flink中。根据下面显示的PyFlink路线图，我们首先在PyVM和JVM之间建立了通信。然后，在Flink 1.9中，我们提供了Python Table API，向Python用户开放了现有的Flink Table API功能。在Flink 1.10中，我们准备通过以下操作将Python函数集成到Flink：集成Apache Beam，设置Python用户定义的函数执行环境，管理Python对其他类库的依赖关系以及为用户定义用户定义的函数API，以便支持Python用户定义函数。&lt;/p&gt;
&lt;p&gt;为了扩展分布式Python的功能，PyFlink提供了对&lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;Pandas Series&lt;/a&gt;和&lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/dsintro.html&quot;&gt;DataFrame&lt;/a&gt;支持，以便用户可以在PyFlink中直接使用Pandas用户定义的函数。此外，将来会在SQL客户端上启用Python用户定义函数，以使PyFlink易于使用。PyFlink还将提供Python ML管道API，以使Python用户能够在机器学习中使用PyFlink。监视Python用户定义的函数执行对实际生产和业务至关重要。因此，PyFlink将进一步为Python用户定义函数提供度量管理。这些功能将包含在Flink 1.11中。&lt;/p&gt;
&lt;p&gt;但是，这些只是PyFlink未来发展计划的一部分。还有更多工作要做，例如优化PyFlink的性能，提供图形计算API以及为Flink上的Pandas支持Pandas的本机API。我们将继续向Python用户提供Flink的现有功能，并将Python的强大功能集成到Flink中，以实现扩展Python生态系统的最初目标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/24/172e3ac644cbd6c5?w=656&amp;amp;h=377&amp;amp;f=png&amp;amp;s=50523&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PyFlink的前景如何？您可能知道，PyFlink是Apache Flink的一部分，它涉及运行时和API层。&lt;/p&gt;
&lt;p&gt;PyFlink在这两层将如何发展？在运行时方面，PyFlink将构建用于JVM和PyVM之间通信的gRPC常规服务（例如控件，数据和状态）。在此框架中，将抽象化Java Python用户定义函数运算符，并构建Python执行容器以支持Python的多种执行方式。例如，PyFlink可以在Docker容器中甚至在外部服务集群中作为进程运行。特别是在外部服务群集中运行时，将以套接字的形式启用无限扩展功能。这一切在后续的Python集成中都起着至关重要的作用。&lt;/p&gt;
&lt;p&gt;在API方面，我们将在Flink中启用基于Python的API，以实现我们的使命。这也依赖于Py4J VM通信框架。PyFlink将逐渐支持更多的API，包括Flink中的Java API（例如Python Table API，UDX，ML Pipeline，DataStream，CEP，Gelly和State API）以及在Python用户中最受欢迎的Pandas API。基于这些API，PyFlink将继续与其他生态系统集成以便于开发；例如Notebook，Zeppelin，Jupyter和Alink，这是阿里巴巴的Flink开源版本。到目前为止，PyAlink已完全整合了PyFlink的功能。PyFlink也将与现有的AI系统平台集成，例如著名的TensorFlow。&lt;/p&gt;
&lt;p&gt;为此，PyFlink将一直保持活力。同样，PyFlink的任务是使Flink功能可供Python用户使用，并在Flink上运行Python分析和计算功能。&lt;/p&gt;
&lt;p&gt;更多实时数据分析相关博文与科技资讯，欢迎关注 “实时流式计算”&lt;br/&gt;关注 “实时流式计算” 回复 “电子书” 获取Flink 300页实战电子书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/22/172d968252276fa6?w=908&amp;amp;h=341&amp;amp;f=png&amp;amp;s=51856&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jun 2020 00:34:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>Flink 1.9.0及更高版本支持Python，也就是PyFlink。 在最新版本的Flink 1.10中，PyFlink支持Python用户定义的函数，使您能够在Table API和SQL中注册和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13185670.html</dc:identifier>
</item>
<item>
<title>正则匹配中的非贪婪匹配不是最短匹配 - 卷卷子</title>
<link>http://www.cnblogs.com/jrjrzivvv/p/13185636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jrjrzivvv/p/13185636.html</guid>
<description>[unable to retrieve full-text content]最近在工作中遇到一个需求，就是找出html中所有锚文字包含 联系方式 的超链接。刚开始我写了一个很简单的正则来解决这个问题&lt;a.*?联系方式.*?&lt;/a。但是在测试的时候却发现这个正则表达式并不像我想象的那样工作。 图中给出了一个正则表达式匹配的例子，可以看出在这段文字中有两个匹配，但是第一个匹配所</description>
<pubDate>Tue, 23 Jun 2020 18:00:00 +0000</pubDate>
<dc:creator>卷卷子</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fjrjrzivvv%2Fp%2F13185636.html</dc:identifier>
</item>
<item>
<title>Redis SDS 深入一点，看到更多！ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13180022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13180022.html</guid>
<description>[unable to retrieve full-text content]1、什么是SDS? Redis 自定的字符串存储结构，关于redis，你需要了解的几点！中我们对此有过简要说明。 Redis 底层是用C语言编写的，可是在字符存储上，并未使用C原生的String类型，而是定义了自己的字符串结构 Simple Dynamic Stirng，简称SDS。 SDS基本结构</description>
<pubDate>Tue, 23 Jun 2020 16:46:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fniejunlei%2Fp%2F13180022.html</dc:identifier>
</item>
<item>
<title>【String注解驱动开发】你了解@PostConstruct注解和@PreDestroy注解吗？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13185511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13185511.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6.4602960969044&quot;&gt;
&lt;p&gt;在之前的文章中，我们介绍了如何使用@Bean注解指定初始化和销毁的方法，小伙伴们可以参见《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247484985&amp;amp;idx=1&amp;amp;sn=bf7ec702113f433f6677d0e9f4f5ae7d&amp;amp;chksm=cee519f4f99290e2c509926a61a7f9604d8a358cd364a78d6de7929f45b3b2a84f57b93f8f87&amp;amp;token=1099992343&amp;amp;lang=zh_CN#rd&quot;&gt;【Spring注解驱动开发】如何使用@Bean注解指定初始化和销毁的方法？看这一篇就够了！！&lt;/a&gt;》，也介绍了使用InitializingBean和DisposableBean来处理bean的初始化和销毁，小伙伴们可以参见《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247485001&amp;amp;idx=1&amp;amp;sn=251bd90d3b04f2bd56c9d24f9df39f81&amp;amp;chksm=cee51984f992909216b2ab3e723561776b5032393d30e6cdf99af1c4c08e8facb790ea16955e&amp;amp;token=1099992343&amp;amp;lang=zh_CN#rd&quot;&gt;【Spring注解驱动开发】Spring中的InitializingBean和DisposableBean，你真的了解吗？&lt;/a&gt;》。除此之外，在JDK中也提供了两个注解能够在bean加载到Spring容器之后执行和在bean销毁之前执行，今天，我们就一起来看看这两个注解的用法。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;postconstruct注解&quot;&gt;@PostConstruct注解&lt;/h2&gt;
&lt;p&gt;@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。我们来看下@PostConstruct注解的源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package javax.annotation;
import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;
@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PostConstruct {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码可以看出，&lt;strong&gt;@PostConstruct注解是Java中的注解，并不是Spring提供的注解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;@PostConstruct注解被用来修饰一个非静态的void()方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init()方法之前执行。&lt;/p&gt;
&lt;p&gt;通常我们会是在Spring框架中使用到@PostConstruct注解，该注解的方法在整个Bean初始化中的执行顺序：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constructor(构造方法) -&amp;gt; @Autowired(依赖注入) -&amp;gt; @PostConstruct(注释的方法)。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;predestroy注解&quot;&gt;@PreDestroy注解&lt;/h2&gt;
&lt;p&gt;@PreDestroy注解同样是Java提供的，看下源码，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package javax.annotation;
import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;
@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PreDestroy {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。执行顺序如下所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用destroy()方法-&amp;gt;@PreDestroy-&amp;gt;destroy()方法-&amp;gt;bean销毁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：@PostConstruct，@PreDestroy是Java规范JSR-250引入的注解，定义了对象的创建和销毁工作，同一期规范中还有注解@Resource，Spring也支持了这些注解。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例程序&quot;&gt;案例程序&lt;/h2&gt;
&lt;p&gt;对@PostConstruct注解和@PreDestroy注解有了简单的了解之后，接下来，我们就写一个简单的程序来加深对这两个注解的理解。&lt;/p&gt;
&lt;p&gt;我们创建一个Cat类，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.mykit.spring.plugins.register.bean;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

/**
 * @author binghe
 * @version 1.0.0
 * @description 测试@PostConstruct注解和@PreDestroy注解
 */
public class Cat {

    public Cat(){
        System.out.println(&quot;Cat类的构造方法...&quot;);
    }

    public void init(){
        System.out.println(&quot;Cat的init()方法...&quot;);
    }

    @PostConstruct
    public void postConstruct(){
        System.out.println(&quot;Cat的postConstruct()方法...&quot;);
    }

    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;Cat的preDestroy()方法...&quot;);
    }

    public void destroy(){
        System.out.println(&quot;Cat的destroy()方法...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在Cat类中，我们提供了构造方法，init()方法、destroy()方法，使用 @PostConstruct注解标注的postConstruct()方法和只用@PreDestroy注解标注的preDestroy()方法。接下来，我们在AnimalConfig类中使用@Bean注解将Cat类注册到Spring容器中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
public Cat cat(){
    return new Cat();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，在BeanLifeCircleTest类中新建testBeanLifeCircle04()方法进行测试，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testBeanLifeCircle04(){
    //创建IOC容器
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AnimalConfig.class);
    //关闭IOC容器
    context.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行BeanLifeCircleTest类中的testBeanLifeCircle04()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Cat类的构造方法...
Cat的postConstruct()方法...
Cat的init()方法...
Cat的preDestroy()方法...
Cat的destroy()方法...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出的结果信息中，可以看出执行的顺序是： &lt;strong&gt;构造方法 -&amp;gt; @PostConstruct -&amp;gt; init()方法 -&amp;gt; @PreDestroy -&amp;gt; destroy()方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 23 Jun 2020 16:09:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在之前的文章中，我们介绍了如何使用@Bean注解指定初始化和销毁的方法，小伙伴们可以参见《【Spring注解驱动开发】如何使用@Bean注解指定初始化和销毁的方法？看这一篇就够了！！》，也介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13185511.html</dc:identifier>
</item>
<item>
<title>【原创】Linux中断子系统（四）-Workqueue - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/13185451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/13185451.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Workqueue&lt;/code&gt;工作队列是利用内核线程来异步执行工作任务的通用机制；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Workqueue&lt;/code&gt;工作队列可以用作中断处理的&lt;code&gt;Bottom-half&lt;/code&gt;机制，利用进程上下文来执行中断处理中耗时的任务，因此它允许睡眠，而&lt;code&gt;Softirq&lt;/code&gt;和&lt;code&gt;Tasklet&lt;/code&gt;在处理任务时不能睡眠；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来一张概述图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234247269-159961474.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在中断处理过程中，或者其他子系统中，调用&lt;code&gt;workqueue&lt;/code&gt;的调度或入队接口后，通过建立好的链接关系图逐级找到合适的&lt;code&gt;worker&lt;/code&gt;，最终完成工作任务的执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;21-总览&quot;&gt;2.1 总览&lt;/h2&gt;
&lt;p&gt;此处应有图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234305682-1117271769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先看看关键的数据结构：
&lt;ol&gt;&lt;li&gt;&lt;code&gt;work_struct&lt;/code&gt;：工作队列调度的最小单位，&lt;code&gt;work item&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workqueue_struct&lt;/code&gt;：工作队列，&lt;code&gt;work item&lt;/code&gt;都挂入到工作队列中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker&lt;/code&gt;：&lt;code&gt;work item&lt;/code&gt;的处理者，每个&lt;code&gt;worker&lt;/code&gt;对应一个内核线程；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;：&lt;code&gt;worker&lt;/code&gt;池（内核线程池），是一个共享资源池，提供不同的&lt;code&gt;worker&lt;/code&gt;来对&lt;code&gt;work item&lt;/code&gt;进行处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pool_workqueue&lt;/code&gt;：充当桥梁纽带的作用，用于连接&lt;code&gt;workqueue&lt;/code&gt;和&lt;code&gt;worker_pool&lt;/code&gt;，建立链接关系；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下边看看细节吧：&lt;/p&gt;
&lt;h2 id=&quot;22-work&quot;&gt;2.2 work&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;struct work_struct&lt;/code&gt;用来描述&lt;code&gt;work&lt;/code&gt;，初始化一个&lt;code&gt;work&lt;/code&gt;并添加到工作队列后，将会将其传递到合适的内核线程来进行处理，它是用于调度的最小单位。&lt;/p&gt;
&lt;p&gt;关键字段描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct work_struct {
        atomic_long_t data;     //低比特存放状态位，高比特存放worker_pool的ID或者pool_workqueue的指针
        struct list_head entry; //用于添加到其他队列上
        work_func_t func;       //工作任务的处理函数，在内核线程中回调
#ifdef CONFIG_LOCKDEP
        struct lockdep_map lockdep_map;
#endif
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图片说明下&lt;code&gt;data&lt;/code&gt;字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234322425-1856230121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;23-workqueue&quot;&gt;2.3 workqueue&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;struct workqueue_struct&lt;/code&gt;关键字段介绍如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct workqueue_struct {
        struct list_head        pwqs;           /* WR: all pwqs of this wq */   //所有的pool_workqueue都添加到本链表中
        struct list_head        list;           /* PR: list of all workqueues */    //用于将工作队列添加到全局链表workqueues中

        struct list_head        maydays;        /* MD: pwqs requesting rescue */    //rescue状态下的pool_workqueue添加到本链表中
        struct worker           *rescuer;       /* I: rescue worker */  //rescuer内核线程，用于处理内存紧张时创建工作线程失败的情况

        struct pool_workqueue   *dfl_pwq;       /* PW: only for unbound wqs */

        char                    name[WQ_NAME_LEN]; /* I: workqueue name */

        /* hot fields used during command issue, aligned to cacheline */
        unsigned int            flags ____cacheline_aligned; /* WQ: WQ_* flags */
        struct pool_workqueue __percpu *cpu_pwqs; /* I: per-cpu pwqs */     //Per-CPU都创建pool_workqueue
        struct pool_workqueue __rcu *numa_pwq_tbl[]; /* PWR: unbound pwqs indexed by node */    //Per-Node创建pool_workqueue
    ...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;24-worker&quot;&gt;2.4 worker&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每个&lt;code&gt;worker&lt;/code&gt;对应一个内核线程，用于对&lt;code&gt;work item&lt;/code&gt;的处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker&lt;/code&gt;根据工作状态，可以添加到&lt;code&gt;worker_pool&lt;/code&gt;的空闲链表或忙碌列表中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker&lt;/code&gt;处于空闲状态时并接收到工作处理请求，将唤醒内核线程来处理；&lt;/li&gt;
&lt;li&gt;内核线程是在每个&lt;code&gt;worker_pool&lt;/code&gt;中由一个初始的空闲工作线程创建的，并根据需要动态创建和销毁；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关键字段描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct worker {
        /* on idle list while idle, on busy hash table while busy */
        union {
                struct list_head        entry;  /* L: while idle */     //用于添加到worker_pool的空闲链表中
                struct hlist_node       hentry; /* L: while busy */ //用于添加到worker_pool的忙碌列表中
        };

        struct work_struct      *current_work;  /* L: work being processed */   //当前正在处理的work
        work_func_t             current_func;   /* L: current_work's fn */                  //当前正在执行的work回调函数
        struct pool_workqueue   *current_pwq; /* L: current_work's pwq */   //指向当前work所属的pool_workqueue

        struct list_head        scheduled;      /* L: scheduled works */    //所有被调度执行的work都将添加到该链表中

        /* 64 bytes boundary on 64bit, 32 on 32bit */

        struct task_struct      *task;          /* I: worker task */    //指向内核线程
        struct worker_pool      *pool;          /* I: the associated pool */    //该worker所属的worker_pool
                                                /* L: for rescuers */
        struct list_head        node;           /* A: anchored at pool-&amp;gt;workers */  //添加到worker_pool-&amp;gt;workers链表中
                                                /* A: runs through worker-&amp;gt;node */
    ...
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;25-worker_pool&quot;&gt;2.5 worker_pool&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;是一个资源池，管理多个&lt;code&gt;worker&lt;/code&gt;，也就是管理多个内核线程；&lt;/li&gt;
&lt;li&gt;针对绑定类型的工作队列，&lt;code&gt;worker_pool&lt;/code&gt;是Per-CPU创建，每个CPU都有两个&lt;code&gt;worker_pool&lt;/code&gt;，对应不同的优先级，nice值分别为0和-20；&lt;/li&gt;
&lt;li&gt;针对非绑定类型的工作队列，&lt;code&gt;worker_pool&lt;/code&gt;创建后会添加到&lt;code&gt;unbound_pool_hash&lt;/code&gt;哈希表中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;管理一个空闲链表和一个忙碌列表，其中忙碌列表由哈希管理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关键字段描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct worker_pool {
        spinlock_t              lock;           /* the pool lock */
        int                     cpu;            /* I: the associated cpu */     //绑定到CPU的workqueue，代表CPU ID
        int                     node;           /* I: the associated node ID */ //非绑定类型的workqueue，代表内存Node ID
        int                     id;             /* I: pool ID */
        unsigned int            flags;          /* X: flags */

        unsigned long           watchdog_ts;    /* L: watchdog timestamp */

        struct list_head        worklist;       /* L: list of pending works */  //pending状态的work添加到本链表
        int                     nr_workers;     /* L: total number of workers */    //worker的数量

        /* nr_idle includes the ones off idle_list for rebinding */
        int                     nr_idle;        /* L: currently idle ones */

        struct list_head        idle_list;      /* X: list of idle workers */   //处于IDLE状态的worker添加到本链表
        struct timer_list       idle_timer;     /* L: worker idle timeout */
        struct timer_list       mayday_timer;   /* L: SOS timer for workers */

        /* a workers is either on busy_hash or idle_list, or the manager */
        DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);   //工作状态的worker添加到本哈希表中
                                                /* L: hash of busy workers */

        /* see manage_workers() for details on the two manager mutexes */
        struct worker           *manager;       /* L: purely informational */
        struct mutex            attach_mutex;   /* attach/detach exclusion */
        struct list_head        workers;        /* A: attached workers */   //worker_pool管理的worker添加到本链表中
        struct completion       *detach_completion; /* all workers detached */

        struct ida              worker_ida;     /* worker IDs for task name */

        struct workqueue_attrs  *attrs;         /* I: worker attributes */
        struct hlist_node       hash_node;      /* PL: unbound_pool_hash node */    //用于添加到unbound_pool_hash中
    ...
} ____cacheline_aligned_in_smp;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;26-pool_workqueue&quot;&gt;2.6 pool_workqueue&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pool_workqueue&lt;/code&gt;充当纽带的作用，用于将&lt;code&gt;workqueue&lt;/code&gt;和&lt;code&gt;worker_pool&lt;/code&gt;关联起来；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关键字段描述如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct pool_workqueue {
        struct worker_pool      *pool;          /* I: the associated pool */    //指向worker_pool
        struct workqueue_struct *wq;            /* I: the owning workqueue */   //指向所属的workqueue

        int                     nr_active;      /* L: nr of active works */     //活跃的work数量
        int                     max_active;     /* L: max active works */   //活跃的最大work数量
        struct list_head        delayed_works;  /* L: delayed works */      //延迟执行的work挂入本链表
        struct list_head        pwqs_node;      /* WR: node on wq-&amp;gt;pwqs */      //用于添加到workqueue链表中
        struct list_head        mayday_node;    /* MD: node on wq-&amp;gt;maydays */   //用于添加到workqueue链表中
    ...
} __aligned(1 &amp;lt;&amp;lt; WORK_STRUCT_FLAG_BITS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;27-小结&quot;&gt;2.7 小结&lt;/h2&gt;
&lt;p&gt;再来张图，首尾呼应一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234341338-1527176258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-workqueue子系统初始化&quot;&gt;3.1 workqueue子系统初始化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;workqueue&lt;/code&gt;子系统的初始化分成两步来完成的：&lt;code&gt;workqueue_init_early&lt;/code&gt;和&lt;code&gt;workqueue_init&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;311-workqueue_init_early&quot;&gt;3.1.1 workqueue_init_early&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234356779-2073216201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;workqueue&lt;/code&gt;子系统早期初始化函数完成的主要工作包括：
&lt;ol&gt;&lt;li&gt;创建&lt;code&gt;pool_workqueue&lt;/code&gt;的SLAB缓存，用于动态分配&lt;code&gt;struct pool_workqueue&lt;/code&gt;结构；&lt;/li&gt;
&lt;li&gt;为每个CPU都分配两个&lt;code&gt;worker_pool&lt;/code&gt;，其中的nice值分别为0和&lt;code&gt;HIGHPRI_NICE_LEVEL&lt;/code&gt;，并且为每个&lt;code&gt;worker_pool&lt;/code&gt;从&lt;code&gt;worker_pool_idr&lt;/code&gt;中分配一个ID号；&lt;/li&gt;
&lt;li&gt;为unbound工作队列创建默认属性，&lt;code&gt;struct workqueue_attrs&lt;/code&gt;属性，主要描述内核线程的nice值，以及cpumask值，分别针对优先级以及允许在哪些CPU上执行；&lt;/li&gt;
&lt;li&gt;为系统默认创建几个工作队列，这几个工作队列的描述在上文的数据结构部分提及过，不再赘述；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从图中可以看出创建工作队列的接口为：&lt;code&gt;alloc_workqueue&lt;/code&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234411629-894680953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;alloc_workqueue&lt;/code&gt;完成的主要工作包括：
&lt;ol&gt;&lt;li&gt;首先当然是要分配一个&lt;code&gt;struct workqueue_struct&lt;/code&gt;的数据结构，并且对该结构中的字段进行初始化操作；&lt;/li&gt;
&lt;li&gt;前文提到过&lt;code&gt;workqueue&lt;/code&gt;最终需要和&lt;code&gt;worker_pool&lt;/code&gt;关联起来，而这个纽带就是&lt;code&gt;pool_workqueue&lt;/code&gt;，&lt;code&gt;alloc_and_link_pwqs&lt;/code&gt;函数就是完成这个功能：1）如果工作队列是绑定到CPU上的，则为每个CPU都分配&lt;code&gt;pool_workqueue&lt;/code&gt;并且初始化，通过&lt;code&gt;link_pwq&lt;/code&gt;将工作队列与&lt;code&gt;pool_workqueue&lt;/code&gt;建立连接；2）如果工作队列不绑定到CPU上，则按内存节点（NUMA，参考之前内存管理的文章）来分配&lt;code&gt;pool_workqueue&lt;/code&gt;，调用&lt;code&gt;get_unbound_pool&lt;/code&gt;来实现，它会根据wq属性先去查找，如果没有找到相同的就创建一个新的&lt;code&gt;pool_workqueue&lt;/code&gt;，并且添加到&lt;code&gt;unbound_pool_hash&lt;/code&gt;哈希表中，最后也会调用&lt;code&gt;link_pwq&lt;/code&gt;来建立连接；&lt;/li&gt;
&lt;li&gt;创建工作队列时，如果设置了&lt;code&gt;WQ_MEM_RECLAIM&lt;/code&gt;标志，则会新建&lt;code&gt;rescuer worker&lt;/code&gt;，对应&lt;code&gt;rescuer_thread&lt;/code&gt;内核线程。当内存紧张时，新创建&lt;code&gt;worker&lt;/code&gt;可能会失败，这时候由&lt;code&gt;rescuer&lt;/code&gt;来处理这种情况；&lt;/li&gt;
&lt;li&gt;最终将新建好的工作队列添加到全局链表&lt;code&gt;workqueues&lt;/code&gt;中；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;312-workqueue_init&quot;&gt;3.1.2 workqueue_init&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;workqueue&lt;/code&gt;子系统第二阶段的初始化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234427943-1188923468.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要完成的工作是给之前创建好的&lt;code&gt;worker_pool&lt;/code&gt;，添加一个初始的&lt;code&gt;worker&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;create_worker&lt;/code&gt;函数中，创建的内核线程名字为&lt;code&gt;kworker/XX:YY&lt;/code&gt;或者&lt;code&gt;kworker/uXX:YY&lt;/code&gt;，其中&lt;code&gt;XX&lt;/code&gt;表示&lt;code&gt;worker_pool&lt;/code&gt;的编号，&lt;code&gt;YY&lt;/code&gt;表示&lt;code&gt;worker&lt;/code&gt;的编号，&lt;code&gt;u&lt;/code&gt;表示&lt;code&gt;unbound&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;workqueue&lt;/code&gt;子系统初始化完成后，基本就已经将数据结构的关联建立好了，当有&lt;code&gt;work&lt;/code&gt;来进行调度的时候，就可以进行处理了。&lt;/p&gt;
&lt;h2 id=&quot;32-work调度&quot;&gt;3.2 work调度&lt;/h2&gt;
&lt;h3 id=&quot;321-schedule_work&quot;&gt;3.2.1 schedule_work&lt;/h3&gt;
&lt;p&gt;以&lt;code&gt;schedule_work&lt;/code&gt;接口为例进行分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234442557-560104262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;schedule_work&lt;/code&gt;默认是将&lt;code&gt;work&lt;/code&gt;添加到系统的&lt;code&gt;system_work&lt;/code&gt;工作队列中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;queue_work_on&lt;/code&gt;接口中的操作判断要添加&lt;code&gt;work&lt;/code&gt;的标志位，如果已经置位了&lt;code&gt;WORK_STRUCT_PENDING_BIT&lt;/code&gt;，表明已经添加到了队列中等待执行了，否则，需要调用&lt;code&gt;__queue_work&lt;/code&gt;来进行添加。注意了，这个操作是在关中断的情况下进行的，因为工作队列使用&lt;code&gt;WORK_STRUCT_PENDING_BIT&lt;/code&gt;位来同步&lt;code&gt;work&lt;/code&gt;的插入和删除操作，设置了这个比特后，然后才能执行&lt;code&gt;work&lt;/code&gt;，这个过程可能被中断或抢占打断；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;workqueue&lt;/code&gt;的标志位设置了&lt;code&gt;__WQ_DRAINING&lt;/code&gt;，表明工作队列正在销毁，所有的&lt;code&gt;work&lt;/code&gt;都要处理完，此时不允许再将&lt;code&gt;work&lt;/code&gt;添加到队列中，有一种特殊情况：销毁过程中，执行&lt;code&gt;work&lt;/code&gt;时又触发了新的&lt;code&gt;work&lt;/code&gt;，也就是所谓的&lt;code&gt;chained work&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;判断&lt;code&gt;workqueue&lt;/code&gt;的类型，如果是&lt;code&gt;bound&lt;/code&gt;类型，根据CPU来获取&lt;code&gt;pool_workqueue&lt;/code&gt;，如果是&lt;code&gt;unbound&lt;/code&gt;类型，通过node号来获取&lt;code&gt;pool_workqueue&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;get_work_pool&lt;/code&gt;获取上一次执行&lt;code&gt;work&lt;/code&gt;的&lt;code&gt;worker_pool&lt;/code&gt;，如果本次执行的&lt;code&gt;worker_pool&lt;/code&gt;与上次执行的&lt;code&gt;worker_pool&lt;/code&gt;不一致，且通过&lt;code&gt;find_worker_executing_work&lt;/code&gt;判断&lt;code&gt;work&lt;/code&gt;正在某个&lt;code&gt;worker_pool&lt;/code&gt;中的&lt;code&gt;worker&lt;/code&gt;中执行，考虑到缓存热度，放到该&lt;code&gt;worker&lt;/code&gt;执行是更合理的选择，进而根据该&lt;code&gt;worker&lt;/code&gt;获取到&lt;code&gt;pool_workqueue&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;判断&lt;code&gt;pool_workqueue&lt;/code&gt;活跃的&lt;code&gt;work&lt;/code&gt;数量，少于最大限值则将&lt;code&gt;work&lt;/code&gt;加入到&lt;code&gt;pool-&amp;gt;worklist&lt;/code&gt;中，否则加入到&lt;code&gt;pwq-&amp;gt;delayed_works&lt;/code&gt;链表中，如果&lt;code&gt;__need_more_worker&lt;/code&gt;判断没有&lt;code&gt;worker&lt;/code&gt;在执行，则唤醒&lt;code&gt;worker&lt;/code&gt;内核线程执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;schedule_work&lt;/code&gt;完成的工作是将&lt;code&gt;work&lt;/code&gt;添加到对应的链表中，而在添加的过程中，首先是需要确定&lt;code&gt;pool_workqueue&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pool_workqueue&lt;/code&gt;对应一个&lt;code&gt;worker_pool&lt;/code&gt;，因此确定了&lt;code&gt;pool_workqueue&lt;/code&gt;也就确定了&lt;code&gt;worker_pool&lt;/code&gt;，进而可以将&lt;code&gt;work&lt;/code&gt;添加到工作链表中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pool_workqueue&lt;/code&gt;的确定分为三种情况：1）&lt;code&gt;bound&lt;/code&gt;类型的工作队列，直接根据CPU号获取；2）&lt;code&gt;unbound&lt;/code&gt;类型的工作队列，根据node号获取，针对&lt;code&gt;unbound&lt;/code&gt;类型工作队列，&lt;code&gt;pool_workqueue&lt;/code&gt;的释放是异步执行的，需要判断&lt;code&gt;refcnt&lt;/code&gt;的计数值，因此在获取&lt;code&gt;pool_workqueue&lt;/code&gt;时可能要多次&lt;code&gt;retry&lt;/code&gt;；3）根据缓存热度，优先选择正在被执行的&lt;code&gt;worker_pool&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;322-worker_thread&quot;&gt;3.2.2 worker_thread&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;work&lt;/code&gt;添加到工作队列后，最终的执行在&lt;code&gt;worker_thread&lt;/code&gt;函数中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234459426-1610043203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在创建&lt;code&gt;worker&lt;/code&gt;时，创建内核线程，执行函数为&lt;code&gt;worker_thread&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;worker_thread&lt;/code&gt;在开始执行时，设置标志位&lt;code&gt;PF_WQ_WORKER&lt;/code&gt;，调度器在进行调度处理时会对task进行判断，针对&lt;code&gt;workerqueue worker&lt;/code&gt;有特殊处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;worker&lt;/code&gt;对应的内核线程，在没有处理&lt;code&gt;work&lt;/code&gt;的时候是睡眠状态，当被唤醒的时候，跳转到&lt;code&gt;woke_up&lt;/code&gt;开始执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;woke_up&lt;/code&gt;之后，如果此时&lt;code&gt;worker&lt;/code&gt;是需要销毁的，那就进行清理工作并返回。否则，离开&lt;code&gt;IDLE&lt;/code&gt;状态，并进入&lt;code&gt;recheck&lt;/code&gt;模块执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;recheck&lt;/code&gt;部分，首先判断是否需要更多的&lt;code&gt;worker&lt;/code&gt;来处理，如果没有任务处理，跳转到&lt;code&gt;sleep&lt;/code&gt;地方进行睡眠。有任务需要处理时，会判断是否有空闲内核线程以及是否需要动态创建，再清除掉&lt;code&gt;worker&lt;/code&gt;的标志位，然后遍历工作链表，对链表中的每个节点调用&lt;code&gt;process_one_worker&lt;/code&gt;来处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;sleep&lt;/code&gt;部分比较好理解，没有任务处理时，&lt;code&gt;worker&lt;/code&gt;进入空闲状态，并将当前的内核线程设置成睡眠状态，让出CPU；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管理&lt;code&gt;worker_pool&lt;/code&gt;的内核线程池时，如果有&lt;code&gt;PENDING&lt;/code&gt;状态的&lt;code&gt;work&lt;/code&gt;，并且发现没有正在运行的工作线程(&lt;code&gt;worker_pool-&amp;gt;nr_running == 0&lt;/code&gt;)，唤醒空闲状态的内核线程，或者动态创建内核线程；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;work&lt;/code&gt;已经在同一个&lt;code&gt;worker_pool&lt;/code&gt;的其他&lt;code&gt;worker&lt;/code&gt;中执行，不再对该&lt;code&gt;work&lt;/code&gt;进行处理；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;work&lt;/code&gt;的执行函数为&lt;code&gt;process_one_worker&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234516169-1429260376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;work&lt;/code&gt;可能在同一个CPU上不同的&lt;code&gt;worker&lt;/code&gt;中运行，直接退出；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;worker-&amp;gt;current_func()&lt;/code&gt;，完成最终&lt;code&gt;work&lt;/code&gt;的回调函数执行；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;33-worker动态管理&quot;&gt;3.3 worker动态管理&lt;/h2&gt;
&lt;h3 id=&quot;331-worker状态机变换&quot;&gt;3.3.1 worker状态机变换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234532984-1798342990.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;通过&lt;code&gt;nr_running&lt;/code&gt;字段来在不同的状态机之间进行切换；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;中有&lt;code&gt;work&lt;/code&gt;需要处理时，需要至少保证有一个运行状态的&lt;code&gt;worker&lt;/code&gt;，当&lt;code&gt;nr_running&lt;/code&gt;大于1时，将多余的&lt;code&gt;worker&lt;/code&gt;进入IDLE状态，没有&lt;code&gt;work&lt;/code&gt;需要处理时，所有的&lt;code&gt;worker&lt;/code&gt;都会进入IDLE状态；&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;work&lt;/code&gt;时，如果回调函数阻塞运行，那么会让&lt;code&gt;worker&lt;/code&gt;进入睡眠状态，此时调度器会进行判断是否需要唤醒另一个&lt;code&gt;worker&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;IDLE状态的&lt;code&gt;worker&lt;/code&gt;都存放在&lt;code&gt;idle_list&lt;/code&gt;链表中，如果空闲时间超过了300秒，则会将其进行销毁；&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;Running-&amp;gt;Suspend&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234548943-19840828.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;当&lt;code&gt;worker&lt;/code&gt;进入睡眠状态时，如果该&lt;code&gt;worker_pool&lt;/code&gt;没有其他的&lt;code&gt;worker&lt;/code&gt;处于运行状态，那么是需要唤醒一个空闲的&lt;code&gt;worker&lt;/code&gt;来维持并发处理的能力；&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;Suspend-&amp;gt;Running&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234602164-728199282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;睡眠状态可以通过&lt;code&gt;wake_up_worker&lt;/code&gt;来进行唤醒处理，最终判断如果该&lt;code&gt;worker&lt;/code&gt;不在运行状态，则增加&lt;code&gt;worker_pool&lt;/code&gt;的&lt;code&gt;nr_running&lt;/code&gt;值；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;332-worker的动态添加和删除&quot;&gt;3.3.2 worker的动态添加和删除&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;动态删除&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234615950-544979309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;worker_pool&lt;/code&gt;初始化时，注册了timer的回调函数，用于定时对空闲链表上的&lt;code&gt;worker&lt;/code&gt;进行处理，如果&lt;code&gt;worker&lt;/code&gt;太多，且空闲时间太长，超过了5分钟，那么就直接进行销毁处理了；&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;动态添加&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234629419-2008522737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;内核线程执行&lt;code&gt;worker_thread&lt;/code&gt;函数时，如果没有空闲的&lt;code&gt;worker&lt;/code&gt;，会调用&lt;code&gt;manage_workers&lt;/code&gt;接口来创建更多的&lt;code&gt;worker&lt;/code&gt;来处理工作；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Documentation/core-api/workqueue.rst&lt;/code&gt;&lt;br/&gt;&lt;code&gt;http://kernel.meizu.com/linux-workqueue.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;洗洗睡了，收工！&lt;/p&gt;
&lt;p&gt;欢迎关注公众号，不定期分享Linux内核机制文章&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200623234659953-118899668.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jun 2020 15:48:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 Read the fucking source code! --By 鲁迅 A picture is worth a thousand words. --By 高尔基 说明： Kernel版本：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/13185451.html</dc:identifier>
</item>
</channel>
</rss>