<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员英语二三事(4) - 应聘外企常用英语(1) - 从投简历开始 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-4-apply-job.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-4-apply-job.html</guid>
<description>
&lt;p&gt;应聘外企会有如下几个环节：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;投递简历&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;电话通知或电话面试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现场面试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拿到Offer入职。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先从投简历开始说起。 &lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li&gt;
&lt;p&gt;Resume：你的简历&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;CV / Cover Letter: 很久很久以前，外国在没有互联网的时候，因为地广人稀，是用传统的信件来应聘。那时候会针对具体每个职位写一封应聘信，附在简历上面。这就是Cover Letter，简称CV。这个传统在互联网时代延续下来了。&lt;/p&gt;
&lt;p&gt;那么Resume和CV的区别是什么呢？Resume是通用的简历，每个职位你都可以投递同样的Resume，可以有多页纸. CV是针对具体每个职位的，是不通用的，每个公司的每个职位都应该投递不同的CV，并且CV最好只有半页纸，最起码不能超过一页纸。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;label&gt;Cover Letter Text: 和CV是同一个东西，如果投简历页面同时出现Cover Letter Text和CV，只需要填一个就可以了。Cover Letter Text的意义就是让你输入更方便而已。&lt;/label&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Application: 应聘流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Withdraw Application: 撤销申请。当你投递了简历之后，后悔了。可以通过Withdraw Application来撤销申请。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Application status: 你应聘的状态，一般会有：Started(开始), Applied(已投递简历), In progress(已经进入面试流程), closed (流程结束)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Recruiter: 负责你的HR。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Recruiting Party: 在公司举办的Party, 会邀请应聘者参观公司。这个在美国十分常见，目前在中国只有少数外企有。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;外企投递简历之后，一般都会马上自动发email给你说你投递简历成功。&lt;/p&gt;

&lt;p&gt;最后说说今天.NET俱乐部招聘方面最新消息：&lt;/p&gt;
&lt;ol readability=&quot;-0.4339908952959&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;微软持续不断的在招聘，最新消息，内推群已经有2位朋友拿到Offer了。今天又发布了3个新的招聘职位信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上海某美企要招聘70位.NET开发。注意，是70位，而不是7位。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.40045766590389&quot;&gt;
&lt;div readability=&quot;8.0091533180778&quot;&gt;全国.NET社区联盟开始发挥作用了。目前建立了“年后从广州到上海工作的.NETer”小分队，帮助广州的.NETer去上海工作发展。希望今后.NETer到陌生的城市工作和出差可以得到当地.NET俱乐部的帮助。就像我现在到欧洲也是找当地的技术俱乐部了解情况。在此深深感谢&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/2018-12-16-hiking-bai-yun-hill-in-guang-zhou-dot-net-club.html&quot; target=&quot;_blank&quot;&gt;当年我到硅谷工作时给与我帮助的旧金山华人互助会的会长周大哥&lt;/a&gt;。&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前全国.NET社区联盟成员情况如下：&lt;/p&gt;
&lt;ol readability=&quot;1.8223495702006&quot;&gt;&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;微软技术俱乐部（苏州）- 484人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;.NET 西安社区 - 312人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;成都.NET微软技术俱乐部 - 137人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上海.NET微软技术俱乐部 - 126人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;北京.NET微软技术俱乐部 - 65人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;杭州 - 筹建中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宁波 - 筹建中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;长沙 - 筹建中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;专注于.NET开源项目的NCC(.NET Core Community) - 33人&lt;/li&gt;
&lt;/ol&gt;
&lt;div readability=&quot;9.463963963964&quot;&gt;实践证明, .NET的好工作一点都不比Java少, 然而好工作都是需要英语的. 我们&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/ReActive-GuangZhou-DotNet-Club.html&quot; target=&quot;_blank&quot;&gt;广州.NET微软技术俱乐部&lt;/a&gt;和中文.NET社区联盟将会持续的在帮助大家找到.NET好工作的道路上前进!&lt;/div&gt;

&lt;p&gt;Q&amp;amp;A&lt;/p&gt;
&lt;p&gt;等待大家提问中&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 20:03:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>实践证明, .NET的好工作一点都不比Java少, 然而好工作都是需要英语的. 我们广州.NET微软技术俱乐部和中文.NET社区联盟将会持续的在帮助大家找到.NET好工作的道路上前进!</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/English-Of-Software-Engineer-4-apply-job.html</dc:identifier>
</item>
<item>
<title>浅析Servlet执行原理 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10360327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10360327.html</guid>
<description>&lt;p&gt;     在JavaWeb学习研究中，Servlet扮演重要的作用，学好它，是后续JavaWeb学习的良好基础。无论是SSH，还是SSM，微服务JavaWeb技术，都应先学好Servlet，从而达到事半功倍的效果，本篇将主要分析Servlet的运行原理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一 UML&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 下图为Servlet UML关系图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190210224852746-252821748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中，可以看出：&lt;/p&gt;
&lt;p&gt;1.抽象类HttpServlet继承抽象类GenericServlet，其有两个比较关键的方法，doGet()和doPost()&lt;/p&gt;
&lt;p&gt;2.GenericServlet实现接口Servlet,ServletConfig,Serializable&lt;/p&gt;
&lt;p&gt;3.MyServlet(用户自定义Servlet类)继承HttpServlet，重写抽象类HttpServlet的doGet()和doPost()方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：任何一个用户自定义Servlet，只需重写抽象类HttpServlet的doPost()和doGet()即可，如上图的MyServlet&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 Servlet在容器中的执行过程&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; Servlet只有放在容器中，方可执行，且Servlet容器种类较多，如Tomcat,WebLogic等。下图为简单的 请求响应 模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190210235114200-2361046.png&quot; alt=&quot;&quot; width=&quot;1068&quot; height=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;1.浏览器向服务器发出GET请求(请求服务器ServletA)&lt;/p&gt;
&lt;p&gt;2.服务器上的容器逻辑接收到该url,根据该url判断为Servlet请求，此时容器逻辑将产生两个对象：请求对象(HttpServletRequest)和响应对象(HttpServletResponce)&lt;/p&gt;
&lt;p&gt;3.容器逻辑根据url找到目标Servlet(本示例目标Servlet为ServletA),且创建一个线程A&lt;/p&gt;
&lt;p&gt;4.容器逻辑将刚才创建的请求对象和响应对象传递给线程A&lt;/p&gt;
&lt;p&gt;5.容器逻辑调用Servlet的service()方法&lt;/p&gt;
&lt;p&gt;6.service()方法根据请求类型(本示例为GET请求)调用doGet()(本示例调用doGet())或doPost()方法&lt;/p&gt;
&lt;p&gt;7.doGet()执行完后，将结果返回给容器逻辑&lt;/p&gt;
&lt;p&gt;8.线程A被销毁或被放在线程池中&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在容器中的每个Servlet原则上只有一个实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.每个请求对应一个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.多个线程可作用于同一个Servlet(这是造成Servlet线程不安全的根本原因)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.每个线程一旦执行完任务，就被销毁或放在线程池中等待回收&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三 Servlet在JavaWeb中扮演的角色&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; Servlet在JavaWeb中，扮演两个角色：页面角色和控制器角色。&lt;/p&gt;
&lt;p&gt;有了jsp等动态页面技术后，Servlet更侧重于控制器角色，jsp+servlert+model 形成基本的三层架构&lt;/p&gt;
&lt;p&gt;（一）页面Page角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        request.setCharacterEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);
        response.setContentType(&lt;/span&gt;&quot;text/html;charset=utf-8&quot;&lt;span&gt;);
        PrintWriter out&lt;/span&gt;=&lt;span&gt;response.getWriter();
        out.println(&lt;/span&gt;&quot;Hello!Servlet.&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（二）控制器角色&lt;/p&gt;
&lt;p&gt; jsp充当页面角色，Servlet扮演控制器角色，两者组合构建基本的MVC三层架构模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211002208572-1570390738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四 Servlet在容器中的生命周期&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 下图为Servlet生命周期简要概图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211005507431-293281175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;第一步：容器先加载Servlet类&lt;/p&gt;
&lt;p&gt;第二步：容器实例化Servlet(Servlet无参构造函数执行)&lt;/p&gt;
&lt;p&gt;第三步：执行init()方法（在Servlet生命周期中，只执行一次，且在service()方法执行前执行）&lt;/p&gt;
&lt;p&gt;第四步：执行service()方法，处理客户请求，doPost()或doGet()&lt;/p&gt;
&lt;p&gt;第五步：执行destroy()，销毁线程&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 五 版权区&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 10 Feb 2019 17:10:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>在JavaWeb学习研究中，Servlet扮演重要的作用，学好它，是后续JavaWeb学习的良好基础。无论是SSH，还是SSM，微服务JavaWeb技术，都应先学好Servlet，从而达到事半功倍的效</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10360327.html</dc:identifier>
</item>
<item>
<title>Shell学习之Shell特性(一) - -零</title>
<link>http://www.cnblogs.com/-wenli/p/10360685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-wenli/p/10360685.html</guid>
<description>
&lt;h2&gt;目录&lt;/h2&gt;




&lt;p&gt; 这个不说了，我们在输入命令的时候，按tab键补全。&lt;/p&gt;



&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
history:历史命令记录
上下键:切换历史命令
!number:执行对应number的历史命令
!string:重新执行一遍含有string的最近的历史命令
!$:
!!:执行上一条命令
&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
alias:查看临时别名
alias 别名='命令':定义别名
unalias 别名:删除别名
\命令 [选项] [参数]:跳过别名，如果这个命令定义了别名，但是你不想使用别名，可以这么用
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
另外定义永久的别名：
超级用户root的配置文件:.bashrc
普通用户的配置文件:~username/.bashrc
(前面这个符号代表家目录)
&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
^R:搜索历史命令，通过命令里包含的字符
^D:退出,相当于exit
^A:将光标移到最前面
^E:将光标移到后面
^L:删除光标后面一个字符
^U:删除光标前面一个字符
^K:截去光标后面的内容
^S:锁屏
^Q:解屏
&lt;/pre&gt;&lt;/div&gt;





&lt;h2&gt;&amp;amp;命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
注：
1.需要用户交互的命令不要放在后台执行，否则机器一直等待输入
2.后台程序在执行时，执行结果仍然会输出到屏幕，干扰我们的工作， 建议将这样的信息重定向到某个文件
3.在命令后面加上&amp;amp;可以将命令放到后台执行，如果退出终端，则无效，只在本次会话有效
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
将这段代码放到后台执行，直接在后面加&amp;amp;。&lt;br/&gt;sleep 300 &amp;amp;

如果让这个命令能在下次登陆也能生效，怎么解决？
在命令前面加上nohup
nohup sleep 6000 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;brush:python;gutter:true;&quot;&gt;&lt;br/&gt;screen命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
，生成一个会话，可以一直使用
比如我们登陆到一个linux系统，先生成一个会话，不会影响你现在的工作，你该干什么干什么，会记录所有当前会话内容，下次登陆，可以切换到你上次工作的会话下。

screen:生成一个会话

screen -s [会话名]:生成一个命名的会话

screen -list:查看所有会话

screen -r [number]:切换会话
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;辅助命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
我们知道当有任务在前台工作时，任务会占用终端，你此时不能在终端工作，除非你再开启一个终端
^C:杀掉正在运行的前台任务
^Z:将正在运行的前台任务暂停到后台
bg:让任务在后台工作，bg [number]
fg:让任务回到前台工作，fg [number]
kill number：给pid为number的进程发信息
kill %[number]：给当前shell中作业号为number的发信息
ps: 列出系统中正在运行的进程
jobs:查看当前有多少在后台运行的命令
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;当我们在shell中执行命令的时候，每个进程都和三个打开的文件相联系，并使用文件描述符来引用这些文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
系统中实际上有12个描述符，可以任意使用文件描述符3－9
标准输入    对应文件描述符0，是命令的输入，默认是键盘
标准输出    对应文件描述符1，是命令的输出，默认是终端
标准错误    对应文件描述符2，是命令错误的输出，默认是终端
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
利用文件重定向功能对命令的标准输入，输出和错误进行修改：

常用文件重定向命令：
command &amp;gt;file：               标准输出重定向到一个文件,错误仍然输出屏幕
command &amp;gt;&amp;gt;file：   标准输出重定向到一个文件(追加) 
command 1&amp;gt;file1：     标准输出重定向到一个文件
command 2&amp;gt;&amp;gt;file2：      标准错误重定向到一个文件(追加)
command 1&amp;gt;file 2&amp;gt;&amp;amp;1：   标准输出和标准错误一起重定向到一个文件
command 1&amp;gt;&amp;gt;file 2&amp;gt;&amp;amp;1:      标准输出和标准错误一起重定向到一个文件(追加)
command &amp;lt; file1 &amp;gt;file2：以file1做为标准输入，file2做为标准输出
command &amp;lt;file：               以file做为文件标准输入

注：上面的command&amp;gt;file 2&amp;gt;&amp;amp;1 可以修改为command&amp;gt;file 2&amp;gt;&amp;gt;file
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;例子&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
重定向标准输出：
例： ls –l &amp;gt;&amp;gt;myfile.out

重定向标准输入：
例： sort &amp;lt; name.txt   &amp;gt; name.out
从name.txt读入数据进行排序，然后将排序结果输出到文件name.out中

重定向标准错误
例： ls ddd 2&amp;gt; /dev/null
ddd不存在，标准错误信息会输送到系统垃圾箱，而不会输送到屏幕如果标准错误信息有用，可以将其存放到错误文件中



使用文件重定向功能将MySQL-client-5.0.16-0.i386.rpm的包说明信息追加到
mysql_install.log 文件中。

rpm -qi MySQL-client-5.0.16-0.i386.rpm &amp;gt;&amp;gt;mysql_install.log



使用文件重定向功能将ls ddd的错误信息保存在错误日志error.log文件中， 说明：ddd 目录并不存在。
ls ddd 2&amp;gt;error.log


编写脚本，实现功能：读取文件myfile中一行数据，并通过echo打印出来
#!/bin/bash
read data &amp;lt;/root/myfile
echo $data
&lt;/pre&gt;&lt;/div&gt;





&lt;h2&gt;输出echo&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
echo命令：用来显示文本行或变量取值，或者把字符串输入到文件中。
格式：echo string

echo的常用功能：\c不换行 \f不进纸 \t跳格 \n换行
注意：
        对于linux系统，必须使用-e选项来使以上转义符生效
        例：$echo -e &quot;hello\tboy&quot;
            $hello     boy

        echo命令对特殊字符敏感，如果要输出特殊字符，需要用\屏蔽特殊含义
        常用的特殊字符：双引号&quot;&quot;
        例：$echo &quot;\&quot;\&quot;&quot;
            $&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;例子&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
编写shell脚本，借助echo命令分别输出系统中SHELL，PATH变量的取值

脚本：
echo $SHELL,$PATH


编写shell脚本，使用一个echo命令输出如下格式的内容（注意对齐格式）：
id      name    msg
01      mike    &quot;hello&quot;
02      john    &quot;hi&quot;

脚本：
echo -e &quot;id\tname\tmsg\n01\tmike\t\&quot;hello\&quot;\n02\tjohn\t\&quot;hi\&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;输入read&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
从键盘或者文件的某一行文本读入信息，并将其赋给一个变量。

格式：read var1 var2 ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：如果输入的值个数多于变量的个数，多余的值会赋给最后一个变量。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
编写shell脚本，实现功能：接收用户输入的值，并显示在屏幕。

脚本：
#!/bin/bash
read name
echo $name


编写shell脚本，使用read命令读取user和password变量
第一次：输入 mike 1234567
第二次：输入 mike 
第三次：输入mike john 123456
分别使用echo命令查看user,password的取值,比较有何不同？


脚本：
#!/bin/bash
read user password
echo $user $password
&lt;/pre&gt;&lt;/div&gt;






&lt;h2&gt;管道&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
可以通过管道把一个命令的输出传递给另一个命令做为输入
格式:命令1 | 命令2
示例：cat test.txt | grep 'hello'
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;例子&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
编写shell脚本，对文件file1，file2，file3内容合并，并对每行进行编号。


脚本：
cat -n file1 file2 file3 &amp;gt; file4.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tee命令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中，如果想看到输出的同时，把输出也同时拷入一个文件，这个命令很合适。

格式：tee -a file
-a 表示文件追加到末尾
file 表示保存输出信息的文件

tee命令一般和管道符 | 结合起来使用
例子:who | tee who.info
该命令的信息返回在屏幕上，同时保存在文件who.info中
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;例子&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1.使用tee命令将当前系统中所有进程信息保存到文件pid_info中


脚本：
#!/bin/bash
top | tee pid_info



2.使用tee命令和who命令将当前系统中登陆的终端信息追加到文件login_info中

脚本：
#!/bin/bash
who | tee -a login_info
&lt;/pre&gt;&lt;/div&gt;





&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
如果你想在执行多个命令，可以使用下面三种分隔符
; &amp;amp;&amp;amp; ||

； 不具备逻辑判断,不关心前面的命令是否执行成功，后面的命令怎样都会执行
示例：cd;cat file


&amp;amp;&amp;amp; 具备逻辑判断，前面的命令执行成功，后面的命令才能执行


|| 具备逻辑判断，前面的命令执行不成功，后面的命令才能执行
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sun, 10 Feb 2019 16:12:00 +0000</pubDate>
<dc:creator>-零</dc:creator>
<og:description>Shell学习之Shell特性 目录 命令和文件自动补齐功能 命令历史记忆功能 history、上下键、!number、!string、!$、!! 别名功能 alias、unalias cp、~use</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-wenli/p/10360685.html</dc:identifier>
</item>
<item>
<title>《Java编程思想》读书笔记-对象导论 - Lurker潜行者</title>
<link>http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;计算机是头脑延伸的工具，是一种不同类型的表达媒体。本文以背景性的和补充性的材料，介绍包括开发方法概述在内的面向对象程序设计(Object-oriented Programming,OOP)的基本概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文通过概念+代码的方式，来帮助读者了解面向对象程序设计的全貌。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;抽象过程&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;概念&lt;/h5&gt;
&lt;p&gt;机器模型：位于&lt;code&gt;解空间&lt;/code&gt;内，是对问题建模的地方；可以这样理解，汇编语言和命令式语言，在解决问题时要基于计算机的架构；因此架构限定了解决方案，所以说机器模型是解空间。&lt;/p&gt;
&lt;p&gt;实际待解决问题：&lt;code&gt;问题空间&lt;/code&gt;，是问题存在的地方&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;如何抽象&lt;/h5&gt;
&lt;p&gt;抽象的类型和质量，决定了人们所能够解决的问题的复杂性。抽象的类型指的是“所抽象的是什么”。一种是在机器模型和实际待解决问题的模型之间建立联系的抽象；另一种是只针对待解决问题建模。而面向对象则是向程序员提供表示问题空间中元素的工具，我们将问题空间中的元素及其在解空间中的表示称为“对象”。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;面向对象程序设计的特性：&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;万物皆是对象；&lt;/li&gt;
&lt;li&gt;程序是对象的集合，对象间方法的调用是程序运行的基本表现；&lt;/li&gt;
&lt;li&gt;对象可以包含其他对象；&lt;/li&gt;
&lt;li&gt;每个对象都拥有其特定的类型；&lt;/li&gt;
&lt;li&gt;某一特定类型的所有对象都可以接收同样的方法调用；&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;什么是对象？对象具有状态、行为和标识。每一个对象都可以拥有内部数据和方法，并且可以唯一的与其他对象区分开来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-&quot;&gt;每个对象都应该都归属于一个类或接口&lt;/h3&gt;
&lt;h5 id=&quot;-&quot;&gt;名词解释&lt;/h5&gt;
&lt;p&gt;对象：具有状态、行为和标识的实体。如银行存款账户是一个类，那么具体的每个人的银行存款账户就是这个类目下的对象。&lt;/p&gt;
&lt;p&gt;类：可以看作类型来考虑。比如说鸟类，是动物中的其中一种类型。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;类和对象&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所有的对象都是唯一的，但同时具有相同的特性和行为的对象也都归属于某个特定的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类在Java中用关键词class表示。每个类的对象都具有某种共性和个性，如银行存款账户，每个账户中都有余额的属性，但每个账户中的余额又不同。在实际中，面向对象程序设计语言都用class关键字来表示数据类型，换而言之，每一个类都是一个数据类型。程序员可以自由地添加新的类（数据类型）来扩展编程语言，对实际问题进行处理。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;对象的获取与方法调用&lt;/h5&gt;
&lt;p&gt;面向对象的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。&lt;/p&gt;
&lt;p&gt;获取有用对象，必须以某种方式对对象进行请求，使对象完成各种任务。类型决定接口，而接口决定对象能满足的请求。就比如鸟类型，其提供的接口有飞翔，因此其能满足飞翔的请求。在接口确定了某一特定对象能够发出的请求后，接口的实现掌控着请求的具体行为的展现方式。在类型中，每一个可能的请求都有一个方法与之关联，当向对象发送请求时，与之关联的方法就会被调用。&lt;/p&gt;
&lt;p&gt;以下代码是获取一个对象并调用其中的方法实例（你可以暂时不用理解，只需要知道形式即可，后面再反过来看就好）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Light&lt;/span&gt; &lt;/span&gt;{
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Light is on!&quot;&lt;/span&gt;);
  }
  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Light is off!&quot;&lt;/span&gt;);
  }

  
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt; &lt;/span&gt;{
    
    Light lt = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Light();
    lt.on();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;对象是服务提供者&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;程序通过调用其他对象提供的服务来向用户提供服务。程序员的目标就是去创建（或者最好是从现有的代码库中寻找）能够提供解决问题所需服务的一系列对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要把对象看作是服务提供者呢？&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这是将问题分解为对象集合的一种合理方式。比如说，你正在创建一个簿记系统，那么，这个系统可以拆分为：我需要一个包括了预定义的簿记输入屏幕的对象、一个执行簿记计算的对象集合以及一个处理在不同的打印机上打印支票和开发票的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;它有助于提高对象的内聚性。就像上面所定义的簿记系统，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事情。职能太多，可能会导致对象的内聚性降低。简而言之，每个对象只做它该做的事。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;程序访问权限控制&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;将程序开发人员按照角色划分为&lt;code&gt;类创建者&lt;/code&gt;和&lt;code&gt;客户端程序员&lt;/code&gt;。类创建者创建新的数据类型，而客户端程序员在其应用中使用类创建者创建的新数据类型。如此一来，客户端程序员的主要目的就是收集各种用来实现快速应用开发的类；而类创建者的目的则是构建类，并向客户端程序员暴露必须的部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么类创建者需要对类的某些部分进行隐藏呢？或者说，为什么需要进行访问权限控制呢？&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;让客户端程序员无法触及他们不该触及的部分，让客户端程序员分清楚，哪些东西对他们来说是必须的，哪些是可以忽略的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。因为对客户端程序员所提供的那一部分可见的内容总是不变的，而库设计者改变的是其中隐藏的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;java-&quot;&gt;Java的访问权限控制关键字&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;类内部&lt;/th&gt;
&lt;th&gt;同包&lt;/th&gt;
&lt;th&gt;子类&lt;/th&gt;
&lt;th&gt;任何地方&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;protected&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;-&quot;&gt;访问权限关键字的修饰范围&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;public：可以修饰外部类、属性、方法；&lt;/li&gt;
&lt;li&gt;protected：只能修饰属性和方法；&lt;/li&gt;
&lt;li&gt;private：只能修饰属性、方法、内部类；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;复用具体实现&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码复用是面向对象程序设计语言所提供的最了不起的优点之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码复用的基本方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接使用该类的一个对象；&lt;/li&gt;
&lt;li&gt;可以将某个类的一个对象置于一个新类中，作为新类的成员出现；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;类之家的关系&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关系是指事物之间存在单向或者相互的作用力或者影响力的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在两个类之间存在有关系和没关系两种情况，在有关系的情况下，其关系包括以下六种类型&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类关系&lt;/th&gt;
&lt;th&gt;英文名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;强权方&lt;/th&gt;
&lt;th&gt;UML图表示&lt;/th&gt;
&lt;th&gt;示例说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;继承&lt;/td&gt;
&lt;td&gt;extends&lt;/td&gt;
&lt;td&gt;父类与子类之间的关系：is-a&lt;/td&gt;
&lt;td&gt;父类&lt;/td&gt;
&lt;td&gt;空心三角+实线，空心三角指向父类&lt;/td&gt;
&lt;td&gt;鸟是动物&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;实现&lt;/td&gt;
&lt;td&gt;implements&lt;/td&gt;
&lt;td&gt;接口与实现类之间的关系：can-do&lt;/td&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;td&gt;空心三角+虚线，空心三角指向接口&lt;/td&gt;
&lt;td&gt;鸟实现了飞翔的接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;组合&lt;/td&gt;
&lt;td&gt;composition&lt;/td&gt;
&lt;td&gt;比聚合更强的关系：contains-a&lt;/td&gt;
&lt;td&gt;整体&lt;/td&gt;
&lt;td&gt;实心菱形+实线，实心菱形指向整体&lt;/td&gt;
&lt;td&gt;人类的头和身体是强组合关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;聚合&lt;/td&gt;
&lt;td&gt;aggregation&lt;/td&gt;
&lt;td&gt;暂时组装的关系：has-a&lt;/td&gt;
&lt;td&gt;组装方&lt;/td&gt;
&lt;td&gt;空心菱形+实线，空心菱形指向组装方&lt;/td&gt;
&lt;td&gt;狗和牵狗的绳子是聚合关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;依赖&lt;/td&gt;
&lt;td&gt;dependency&lt;/td&gt;
&lt;td&gt;一个类依赖于另一个类：depends-a&lt;/td&gt;
&lt;td&gt;被依赖方&lt;/td&gt;
&lt;td&gt;箭头+虚线，箭头指向被依赖方&lt;/td&gt;
&lt;td&gt;人喂小狗，小狗是喂这个动作的被依赖方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;关联&lt;/td&gt;
&lt;td&gt;association&lt;/td&gt;
&lt;td&gt;类与类之间存在互相平等的使用关系：links-a&lt;/td&gt;
&lt;td&gt;平等&lt;/td&gt;
&lt;td&gt;实线&lt;/td&gt;
&lt;td&gt;人与信用卡的关系，人用信用卡，信用卡可以读取个人信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;-&quot;&gt;继承关系&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以现有类为基础，复制它，然后通过添加和修改这个副本来创建新类。当源类发生变化时，被修改的副本也会反应出这种变动。生物学中对科目的定义，用于解释继承关系再恰当不过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;相关名词定义&lt;/h5&gt;
&lt;p&gt;父类：又称源类、基类、超类；&lt;/p&gt;
&lt;p&gt;子类：又称导出类、继承类；&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;父类和子类&lt;/h5&gt;
&lt;p&gt;父类和子类之间的类型层次结构同时体现了他们之间的相似性和差异性。当继承现有类型时，也就创造了新的类型，同时子类又归属于父类的类型。这个新的类型不仅包括现有类型的所有成员，而且更重要的是它复制了父类的接口，这意味着所有对父类对象的调用同时可可以对子类对象发起，这遵循了编程原则之一的里氏替换原则。&lt;/p&gt;
&lt;p&gt;如果只是简单地继承一个类而不做其他任何事情，那么在父类接口中的方法将会直接继承到子类中。当需要使父类和子类产生差异时，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接在子类中添加新的方法；在采用该种方案时需要仔细考虑是否存在父类也需要这些额外方法的可能性。&lt;/li&gt;
&lt;li&gt;覆写父类中的某个方法；该种方案需要在子类中定义与父类需覆写方法同名、同返回值类型、同方法参数类型的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么继承是否应该只覆写父类的方法呢？&lt;/p&gt;
&lt;p&gt;如果继承只覆写了父类的方法，那么子类对象可以完全替代父类对象，这通常称之为&lt;code&gt;替代原则&lt;/code&gt;，在这种情况下的类关系称为&lt;code&gt;is-a&lt;/code&gt;；但有时又的确需要在子类中添加新的接口，这种情况下父类无法访问新添加的接口，这种情况下类关系为&lt;code&gt;is-like-a&lt;/code&gt;，这时这种父类与子类之间的关系，被视为&lt;code&gt;非存粹替代&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;多态&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在处理类层次关系的时候，如果把任意一个特定类型的对象可以当作其基类对象来对待，就使得人们可以编写出不依赖于特定类型的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;相关概念&lt;/h5&gt;
&lt;p&gt;前期绑定：编译器将产生对一个具体函数名字的调用，而在运行时需要将这个调用解析到将要被执行的代码的绝对地址（意味着运行前就需要知道具体代码的位置）。&lt;/p&gt;
&lt;p&gt;后期绑定：编译器只确保调用的方法存在，而且调用参数和返回值类型正确；在运行时，通过特殊代码，解析具体将要执行的代码的具体位置。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;多态的实现理念&lt;/h5&gt;
&lt;p&gt;通过导出新的子类而轻松扩展设计的能力，是对改动进行封装的基本方式之一。&lt;/p&gt;
&lt;p&gt;在试图将子类对象当作其基类对象来看待时，需要解决的一个问题是：编译器无法精确地了解哪一段代码将会被执行。在OOP程序设计中，程序直到运行时才能够确定代码的位置。&lt;/p&gt;
&lt;p&gt;OOP程序设计语言使用了后期绑定的概念：编译器确保调用方法的存在，并对调用参数和返回值执行类型检查，但并不知道将被执行的确切代码。Java使用一小段特殊的代码来替代绝对地址调用，这段&lt;code&gt;特殊代码&lt;/code&gt;用来计算方法体的具体位置。Java默认是动态绑定的。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;向上转型&lt;/h5&gt;
&lt;p&gt;把子类对象看作父类对象的过程，称作&lt;code&gt;向上转型&lt;/code&gt;。原因是在类图中，父类总是位于类图的顶部，把子类对象视为父类对象，即将子类类型向上推导。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;单根继承&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java中所有的类最终都继承自单一的基类：Object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单根继承结构保证所有对象都具备某些功能。Object是任何类的默认父类，是在哲学方向上继续宁的延伸思考。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是谁？&lt;/strong&gt;getClass()说明本质上是谁，而toString()是当前类的名片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我从哪里来？&lt;/strong&gt;Object()构造方法是生产对象的基本方式；clone()是繁殖对象的另一种方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我到哪里去？&lt;/strong&gt;finalize()方法说明了对象的最终归属&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我是否是独一无二的？&lt;/strong&gt;hashCode()和equals()就是判断与其他元素是否相同的一组方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与其他人如何协调？&lt;/strong&gt;wait()和notify()方法是对象间通信和协作的一组方法。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-&quot;&gt;容器&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通常来说，如果不知道在解决某个特定问题时需要多少对象，或者他们将存活多久，那么就不可能知道如何存储这些对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java标准类库中提供了大量容器。不同的容器提供了不同类型的接口和外部行为，同时对某些操作具有不同的效率。如List中的ArrayList和LinkedList由于底层实现的不同，具备不同的应用场景。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;参数化类型&lt;/h5&gt;
&lt;p&gt;由于容器只存储Object，所以将对象引入置入容器时，被向上转型为Object，在取出类型时会丢失其类型。在一定程度上可以使用向下转型的方式来获取其实际类型，但是这样做存在风险。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; a;

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.*;

&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Container&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String [] args)&lt;/span&gt; &lt;/span&gt;{
    List list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList();
    list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;);
    list.add(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(Object o : list) {
      
      String a = (String) o;
      System.out.println(a);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么用什么方式使容器记住这些对象究竟使什么类型呢？解决方案称为参数化类型，在Java中也称为泛型。表示方法为一对尖括号，中间包含类型信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样一来，就限定了List中只能存放String类型的对象啦！当然，我们还是能够通过反射绕过这层验证，毕竟在编译后运行时，是去泛型的。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;对象的创建和生命周期&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在使用对象时，最关键的问题之一便是他们的生成和销毁方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;对象的创建&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;new Constructor();&lt;/strong&gt;：通过new关键词向堆中申请内存，通过Constructor来说明类的创建方式。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;生命周期&lt;/h5&gt;
&lt;p&gt;Java采用&lt;code&gt;动态内存分配&lt;/code&gt;的方式。动态方式有个一般性假设：对象趋于变得复杂，所以查找和释放内存空间的开销不会对对象的创建造成重大冲击。动态方式所带来的更大的灵活性是解决一般化编程问题的要点。&lt;/p&gt;
&lt;p&gt;Java提供了被称为&lt;code&gt;垃圾收集器&lt;/code&gt;的机制，用来处理内存释放问题。垃圾收集器的运行基础是&lt;code&gt;单根继承结构&lt;/code&gt;和&lt;code&gt;只能在堆上创建对象&lt;/code&gt;的特性。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;异常处理&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;错误处理始终是编程的难题之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;-&quot;&gt;什么是异常&lt;/h5&gt;
&lt;p&gt;异常是一种对象，其从出错点被&lt;code&gt;抛出&lt;/code&gt;，并被特定类型的异常处理器所&lt;code&gt;捕获&lt;/code&gt;。异常处理就像与程序正常执行路径并行的、在错误发生时执行的另一条路径。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;异常的处理&lt;/h5&gt;
&lt;p&gt;异常不能被忽略，它保证一定会在某处得到处理。异常提供了一种从错误状态进行可靠恢复的途径。Java一开始就内置了异常处理，并强制你必须使用它。它是唯一可接受的错误报告方式。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;并发编程&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在计算机编程中，存在着在同一时刻处理多个任务的思想。这些彼此独立运行的部分称为线程，同一时刻处理多个任务称为并发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在单一处理器中，线程只是一种为单一处理器分配执行时间的手段，换而言之，如果只有一个处理器，那么多线程程序的运行不过是多个任务竞争使用处理器的性能。在多处理器的情况下，实现的才是真正意义上的并发，多处理器并行计算。&lt;/p&gt;
&lt;p&gt;多线程同时存在一个隐患，在存在共享资源的时候，可能会造成资源之间的竞争，进而造成死锁。所以在多线程修改共享资源时，必然在共享资源使用期进行锁定。&lt;/p&gt;
&lt;p&gt;在Java中，JDK1.5后提供了concurrent包支持更好的并发特性。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;以上是对象导论的一些基本概念，是继续阅读后面章节的非必要补充性材料。对于文中的一些代码段或概念，暂时不理解的，可以先放一放，等后面看完了，再回过来看就恍然大悟了。&lt;/p&gt;
&lt;p&gt;下一节将讲解对象并写第一个Java程序。欢迎关注我的微信公众号，可以更方便的获取每日推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486497/201902/1486497-20190210235116712-1457876779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:46:00 +0000</pubDate>
<dc:creator>Lurker潜行者</dc:creator>
<og:description>计算机是头脑延伸的工具，是一种不同类型的表达媒体。本文以背景性的和补充性的材料，介绍包括开发方法概述在内的面向对象程序设计(Object-oriented Programming,OOP)的基本概念。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lurker-yaojiang/p/10360651.html</dc:identifier>
</item>
<item>
<title>你真的了解字典(Dictionary)吗? - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10360608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10360608.html</guid>
<description>&lt;p&gt;半年前,我参加我现在所在公司的面试,面试官给了一道题,说有一个Y形的链表,知道起始节点,找出交叉节点.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/chain.gif&quot; alt=&quot;Y形链表&quot;/&gt;&lt;br/&gt;为了便于描述,我把上面的那条线路称为线路1,下面的称为线路2.&lt;/p&gt;
&lt;h2 id=&quot;思路1&quot;&gt;思路1&lt;/h2&gt;
&lt;p&gt;先判断线路1的第一个节点的下级节点是否是线路2的第一个节点,如果不是,再判断是不是线路2的第二个,如果也不是,判断是不是第三个节点,一直到最后一个.&lt;br/&gt;如果第一轮没找到,再按以上思路处理线路一的第二个节点,第三个,第四个... 找到为止.&lt;br/&gt;时间复杂度n&lt;sup&gt;2&lt;/sup&gt;,相信如果我用的是这种方法,可肯定被Pass了.&lt;/p&gt;
&lt;h2 id=&quot;思路2&quot;&gt;思路2&lt;/h2&gt;
&lt;p&gt;首先,我遍历线路2的所有节点,把节点的索引作为key,下级节点索引作为value存入字典中.&lt;br/&gt;然后,遍历线路1中节点,判断字典中是否包含该节点的下级节点索引的key,即&lt;code&gt;dic.ContainsKey((node.next)&lt;/code&gt; ,如果包含,那么该下级节点就是交叉节点了.&lt;br/&gt;时间复杂度是n.&lt;br/&gt;那么问题来了,面试官问我了,为什么时间复杂度n呢?你有没有研究过字典的&lt;code&gt;ContainsKey&lt;/code&gt;这个方法呢?难道它不是通过遍历内部元素来判断Key是否存在的呢?如果是的话,那时间复杂度还是n&lt;sup&gt;2&lt;/sup&gt;才是呀?&lt;br/&gt;我当时支支吾吾,确实不明白字典的工作原理,厚着面皮说 &quot;不是的,它是通过哈希表直接拿出来的,不用遍历&quot;,面试官这边是敷衍过去了,但在我心里却留下了一个谜,已经入职半年多了,欠下的技术债是时候还了.&lt;/p&gt;

&lt;p&gt;在看这篇文章前,不知道您使用字典的时候是否有过这样的疑问.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字典为什么能无限地Add呢?&lt;/li&gt;
&lt;li&gt;从字典中取Item速度非常快,为什么呢?&lt;/li&gt;
&lt;li&gt;初始化字典可以指定字典容量,这是否多余呢?&lt;/li&gt;
&lt;li&gt;字典的桶&lt;code&gt;buckets&lt;/code&gt; 长度为素数,为什么呢?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管您以前有没有在心里问过自己这些问题,也不管您是否已经有了自己得答案,都让我们带着这几个问题接着往下走.&lt;/p&gt;

&lt;p&gt;什么是哈希函数?&lt;br/&gt;哈希函数又称散列函数,是一种从任何一种数据中创建小的数字“指纹”的方法。&lt;br/&gt;下面,我们看看JDK中Sting.GetHashCode()方法.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int hashCode() {
        int h = hash;
 //hash default value : 0 
        if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
 //value : char storage
            char val[] = value;

            for (int i = 0; i &amp;lt; value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,无论多长的字符串,最终都会返回一个int值,当哈希函数确定的情况下,任何一个字符串的哈希值都是唯一且确定的.&lt;br/&gt;当然,这里只是找了一种最简单的字符数哈希值求法,理论上只要能把一个对象转换成唯一且确定值的函数,我们都可以把它称之为哈希函数.&lt;br/&gt;这是哈希函数的示意图.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/HashFunction.svg?sanitize=true&quot; alt=&quot;哈希函数示意图&quot;/&gt;&lt;br/&gt;所以,&lt;code&gt;一个对象的哈希值是确定且唯一的!&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;如何把哈希值和在集合中我们要的数据的地址关联起来呢?解开这个疑惑前我来看看一个这样不怎么恰当的例子:&lt;/p&gt;
&lt;p&gt;有一天,我不小心干了什么坏事,警察叔叔没有逮到我本人,但是他知道是一个叫&lt;code&gt;阿宇&lt;/code&gt;的干的,他要找我肯定先去我家,他怎么知道我家的地址呢?他不可能在全中国的家庭一个个去遍历,敲门,问&lt;code&gt;阿宇&lt;/code&gt;是你们家的熊孩子吗?&lt;/p&gt;
&lt;p&gt;正常应该是通过我的名字,找到我的身份证号码,然后我的身份证上登记着我的家庭地址(我们假设一个名字只能找到一张身份证).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;阿宇&lt;/code&gt;-----&amp;gt; 身份证(身份证号码,家庭住址)------&amp;gt;我家&lt;/p&gt;
&lt;p&gt;我们就可以把由阿宇找到身份证号码的过程,理解为&lt;code&gt;哈希函数&lt;/code&gt;,身份证存储着我的号码的同时,也存储着我家的地址,身份证这个角色在字典中就是 &lt;code&gt;bucket&lt;/code&gt;,它起一个桥梁作用,当有人要找阿宇家在哪时,直接问它,准备错的,字典中,bucket存储着数据的内存地址(索引),我们要知道key对应的数据的内存地址,问buckets要就对了.&lt;/p&gt;
&lt;p&gt;key---&amp;gt;bucket的过程 ~= &lt;code&gt;阿宇&lt;/code&gt;-----&amp;gt;身份证 的过程.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable0.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;警察叔叔通过家庭住址找到了我家之后,我家除了住我,还住着我爸,我妈,他敲门的时候,是我爸开门,于是问我爸爸,&lt;code&gt;阿宇&lt;/code&gt;在哪,我爸不知道,我爸便问我妈,儿子在哪?我妈告诉警察叔叔,我在书房呢.很好,警察叔叔就这样把我给逮住了.&lt;/p&gt;
&lt;p&gt;字典也是这样,因为key的哈希值范围很大的,我们不可能声明一个这么大的数组作为buckets,这样就太浪费了,我们做法时HashCode%BucketSize作为bucket的索引.&lt;/p&gt;
&lt;p&gt;假设Bucket的长度3,那么当key1的HashCode为2时,它数据地址就问buckets&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/2%253=2&quot;&gt;2&lt;/a&gt;要,当key2的HashCode为5时,它的数据地址也是问buckets&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/5%253=2&quot;&gt;2&lt;/a&gt;要的.&lt;/p&gt;
&lt;p&gt;这就导致同一个bucket可能有多个key对应,即下图中的Johon Smith和Sandra Dee,但是bucket只能记录一个内存地址(索引),也就是警察叔叔通过家庭地址找到我家时,正常来说,只有一个人过来开门,那么,如何找到也在这个家里的我的呢?我爸记录这我妈在厨房,我妈记录着我在书房,就这样,我就被揪出来了,我爸,我妈,我 就是字典中的一个entry.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable1.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;如果有一天,我妈妈老来得子又生了一个小宝宝,怎么办呢?很简单,我妈记录小宝宝的位置,那么我的只能巴结小宝宝,让小宝宝来记录我的位置了.&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable2.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/DictionaryMini/master/Pic/hashtable3.svg?sanitize=true&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然大的原理明白了,是不是要看看源码,来研究研究代码中字典怎么实现的呢?&lt;/p&gt;

&lt;p&gt;上次在苏州参加苏州微软技术俱乐部成立大会时,有幸参加了&lt;code&gt;蒋金楠&lt;/code&gt; 老师讲的Asp .net core框架解密,蒋老师有句话让我印象很深刻,&quot;学好一门技术的最好的方法,就是模仿它的样子,自己造一个出来&quot;于是他弄了个Asp .net core mini,所以我效仿蒋老师,弄了个DictionaryMini&lt;/p&gt;
&lt;p&gt;其源代码我放在了Github仓库,有兴趣的可以看看:&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我觉得字典这几个方面值得了解一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据存储的最小单元的数据结构&lt;/li&gt;
&lt;li&gt;字典的初始化&lt;/li&gt;
&lt;li&gt;添加新元素&lt;/li&gt;
&lt;li&gt;字典的扩容&lt;/li&gt;
&lt;li&gt;移除元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;字典中还有其他功能,但我相信,只要弄明白的这几个方面的工作原理,我们也就恰中肯綮,他么问题也就迎刃而解了.&lt;/p&gt;
&lt;h2 id=&quot;数据存储的最小单元entry的数据结构&quot;&gt;数据存储的最小单元(Entry)的数据结构&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;   private struct Entry
        {
            public int HashCode;
            public int Next;
            public TKey Key;
            public TValue Value;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个Entry包括该key的HashCode,以及下个Entry的索引Next,该键值对的Key以及数据Vaule.&lt;/p&gt;
&lt;h2 id=&quot;字典初始化&quot;&gt;字典初始化&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        private void Initialize(int capacity)
        {
            int size = HashHelpersMini.GetPrime(capacity);
            _buckets = new int[size];
            for (int i = 0; i &amp;lt; _buckets.Length; i++)
            {
                _buckets[i] = -1;
            }

            _entries = new Entry[size];

            _freeList = -1;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字典初始化时,首先要创建int数组,分别作为buckets和entries,其中buckets的index是key的&lt;code&gt;哈希值%size&lt;/code&gt;,它的value是数据在entries中的index,我们要取的数据就存在entries中.当某一个bucket没有指向任何entry时,它的value为-1.&lt;br/&gt;另外,很有意思得一点,buckets的数组长度是多少呢?这个我研究了挺久,发现取的是大于capacity的最小质数.&lt;/p&gt;
&lt;h2 id=&quot;添加新元素&quot;&gt;添加新元素&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private void Insert(TKey key, TValue value, bool add)
        {
            if (key == null)
            {
                throw new ArgumentNullException();
            }
            //如果buckets为空,则重新初始化字典.
            if (_buckets == null) Initialize(0);
            //获取传入key的 哈希值
            var hashCode = _comparer.GetHashCode(key);
            //把hashCode%size的值作为目标Bucket的Index.
            var targetBucket = hashCode % _buckets.Length;
            //遍历判断传入的key对应的值是否已经添加字典中
            for (int i = _buckets[targetBucket]; i &amp;gt; 0; i = _entries[i].Next)
            {
                if (_entries[i].HashCode == hashCode &amp;amp;&amp;amp; _comparer.Equals(_entries[i].Key, key))
                {
                    //当add为true时,直接抛出异常,告诉给定的值已存在在字典中.
                    if (add)
                    {
                        throw new Exception(&quot;给定的关键字已存在!&quot;);
                    }
                    //当add为false时,重新赋值并退出.
                    _entries[i].Value = value;
                    return;
                }
            }
            //表示本次存储数据的数据在Entries中的索引
            int index;
            //当有数据被Remove时,freeCount会加1
            if (_freeCount &amp;gt; 0)
            {
                //freeList为上一个移除数据的Entries的索引,这样能尽量地让连续的Entries都利用起来.
                index = _freeList;
                _freeList = _entries[index].Next;
                _freeCount--;
            }
            else
            {
                //当已使用的Entry的数据等于Entries的长度时,说明字典里的数据已经存满了,需要对字典进行扩容,Resize.
                if (_count == _entries.Length)
                {
                    Resize();
                    targetBucket = hashCode % _buckets.Length;
                }
                //默认取未使用的第一个
                index = _count;
                _count++;
            }
            //对Entries进行赋值
            _entries[index].HashCode = hashCode;
            _entries[index].Next = _buckets[targetBucket];
            _entries[index].Key = key;
            _entries[index].Value = value;
            //用buckets来登记数据在Entries中的索引.
            _buckets[targetBucket] = index;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典的扩容&quot;&gt;字典的扩容&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Resize()
        {
            //获取大于当前size的最小质数
            Resize(HashHelpersMini.GetPrime(_count), false);
        }
 private void Resize(int newSize, bool foreNewHashCodes)
        {
            var newBuckets = new int[newSize];
            //把所有buckets设置-1
            for (int i = 0; i &amp;lt; newBuckets.Length; i++) newBuckets[i] = -1;
            var newEntries = new Entry[newSize];
            //把旧的的Enties中的数据拷贝到新的Entires数组中.
            Array.Copy(_entries, 0, newEntries, 0, _count);
            if (foreNewHashCodes)
            {
                for (int i = 0; i &amp;lt; _count; i++)
                {
                    if (newEntries[i].HashCode != -1)
                    {
                        newEntries[i].HashCode = _comparer.GetHashCode(newEntries[i].Key);
                    }
                }
            }
            //重新对新的bucket赋值.
            for (int i = 0; i &amp;lt; _count; i++)
            {
                if (newEntries[i].HashCode &amp;gt; 0)
                {
                    int bucket = newEntries[i].HashCode % newSize;
                    newEntries[i].Next = newBuckets[bucket];
                    newBuckets[bucket] = i;
                }
            }

            _buckets = newBuckets;
            _entries = newEntries;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;移除元素&quot;&gt;移除元素&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        //通过key移除指定的item
        public bool Remove(TKey key)
        {
            if (key == null)
                throw new Exception();

            if (_buckets != null)
            {
                //获取该key的HashCode
                int hashCode = _comparer.GetHashCode(key);
                //获取bucket的索引
                int bucket = hashCode % _buckets.Length;
                int last = -1;
                for (int i = _buckets[bucket]; i &amp;gt;= 0; last = i, i = _entries[i].Next)
                {
                    if (_entries[i].HashCode == hashCode &amp;amp;&amp;amp; _comparer.Equals(_entries[i].Key, key))
                    {
                        if (last &amp;lt; 0)
                        {
                            _buckets[bucket] = _entries[i].Next;
                        }
                        else
                        {
                            _entries[last].Next = _entries[i].Next;
                        }
                        //把要移除的元素置空.
                        _entries[i].HashCode = -1;
                        _entries[i].Next = _freeList;
                        _entries[i].Key = default(TKey);
                        _entries[i].Value = default(TValue);
                        //把该释放的索引记录在freeList中
                        _freeList = i;
                        //把空Entry的数量加1
                        _freeCount++;
                        return true;
                    }
                }
            }

            return false;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我对.Net中的Dictionary的源码进行了精简,做了一个DictionaryMini,有兴趣的可以到我的github查看相关代码.&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;字典为什么能无限地add呢&quot;&gt;字典为什么能无限地Add呢&lt;/h2&gt;
&lt;p&gt;向Dictionary中添加元素时,会有一步进行判断字典是否满了,如果满了,会用Resize对字典进行自动地扩容,所以字典不会向数组那样有固定的容量.&lt;/p&gt;
&lt;h2 id=&quot;为什么从字典中取数据这么快&quot;&gt;为什么从字典中取数据这么快&lt;/h2&gt;
&lt;p&gt;Key--&amp;gt;HashCode--&amp;gt;HashCode%Size--&amp;gt;Bucket Index--&amp;gt;Bucket--&amp;gt;Entry Index--&amp;gt;Value&lt;br/&gt;整个过程都没有通过&lt;code&gt;遍历&lt;/code&gt;来查找数据,一步到下一步的目的性时非常明确的,所以取数据的过程非常快.&lt;/p&gt;
&lt;h2 id=&quot;初始化字典可以指定字典容量这是否多余呢&quot;&gt;初始化字典可以指定字典容量,这是否多余呢&lt;/h2&gt;
&lt;p&gt;前面说过,当向字典中插入数据时,如果字典已满,会自动地给字典Resize扩容.&lt;br/&gt;扩容的标准时会把大于当前前容量的最小质数作为当前字典的容量,比如,当我们的字典最终存储的元素为15个时,会有这样的一个过程.&lt;br/&gt;new Dictionary()-------------------&amp;gt;size:3&lt;br/&gt;字典添加低3个元素----&amp;gt;Resize---&amp;gt;size:7&lt;br/&gt;字典添加低7个元素----&amp;gt;Resize---&amp;gt;size:11&lt;br/&gt;字典添加低11个元素---&amp;gt;Resize---&amp;gt;size:23&lt;/p&gt;
&lt;p&gt;可以看到一共进行了三次次Resize,如果我们预先知道最终字典要存储15个元素,那么我们可以用new Dictionary(15)来创建一个字典.&lt;/p&gt;
&lt;p&gt;new Dictionary(15)----------&amp;gt;size:23&lt;/p&gt;
&lt;p&gt;这样就不需要进行Resize了,可以想象,每次Resize都是消耗一定的时间资源的,需要把OldEnties Copy to NewEntries 所以我们在创建字典时,如果知道字典的中要存储的字典的元素个数,在创建字典时,就传入capacity,免去了中间的Resize进行扩容.&lt;/p&gt;
&lt;p&gt;Tips:&lt;br/&gt;即使指定字典容量capacity,后期如果添加的元素超过这个数量,字典也是会自动扩容的.&lt;/p&gt;
&lt;h2 id=&quot;为什么字典的桶buckets-长度为素数&quot;&gt;为什么字典的桶buckets 长度为素数&lt;/h2&gt;
&lt;p&gt;我们假设有这样的一系列keys,他们的分布范围时K={ 0, 1,..., 100 },又假设某一个buckets的长度m=12,因为3是12的一个因子,当key时3的倍数时,那么targetBucket也将会是3的倍数.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        Keys {0,12,24,36,...}
        TargetBucket将会是0.
        Keys {3,15,27,39,...}
        TargetBucket将会是3.
        Keys {6,18,30,42,...}
        TargetBucket将会是6.
        Keys {9,21,33,45,...}
        TargetBucket将会是9.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Key的值是均匀分布的(K中的每一个Key中出现的可能性相同),那么Buckets的Length就没有那么重要了,但是如果Key不是均匀分布呢?&lt;br/&gt;想象一下,如果Key在3的倍数时出现的可能性特别大,其他的基本不出现,TargetBucket那些不是3的倍数的索引就基本不会存储什么数据了,这样就可能有2/3的Bucket空着,数据大量第聚集在0,3,6,9中.&lt;br/&gt;这种情况其实时很常见的。 例如，又一种场景，您根据对象存储在内存中的位置来跟踪对象,如果你的计算机的字节大小是4，而且你的Buckets的长度也为4,那么所有的内存地址都会时4的倍数,也就是说key都是4的倍数,它的HashCode也将会时4的倍数,导致所有的数据都会存储在TargetBucket=0(Key%4=0)的bucket中,而剩下的3/4的Buckets都是空的. 这样数据分布就非常不均匀了.&lt;br/&gt;K中的每一个key如果与Buckets的长度m有公因子,那么该数据就会存储在这个公因子的倍数为索引的bucket中.为了让数据尽可能地均匀地分布在Buckets中,我们要尽量减少m和K中的key的有公因子出现的可能性.那么,把Bucket的长度设为质数就是最佳选择了,因为质数的因子时最少的.这就是为什么每次利用Resize给字典扩容时会取大于当前size的最小质数的原因.&lt;br/&gt;确实,这一块可能有点难以理解,我花了好几天才研究明白,如果小伙伴们没有看懂建议看看这里.&lt;br/&gt;&lt;a href=&quot;https://cs.stackexchange.com/questions/11029/why-is-it-best-to-use-a-prime-number-as-a-mod-in-a-hashing-function/64191#64191&quot; class=&quot;uri&quot;&gt;https://cs.stackexchange.com/questions/11029/why-is-it-best-to-use-a-prime-number-as-a-mod-in-a-hashing-function/64191#64191&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后,感谢大家耐着性子把这篇文章看完,欢迎fork DictionaryMini进行进一步的研究,谢谢大家的支持.&lt;br/&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/DictionaryMini&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/DictionaryMini&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:21:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>从一道亲身经历的面试题说起 半年前,我参加我现在所在公司的面试,面试官给了一道题,说有一个Y形的链表,知道起始节点,找出交叉节点. 为了便于描述,我把上面的那条线路称为线路1,下面的称为线路2. 思路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10360608.html</dc:identifier>
</item>
<item>
<title>语言之争与读书有感 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10360585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10360585.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;　　移动互联网无处不在的今天，不同的学习方式让我们受益颇多。有人喜欢通过手机阅读各类技术专家的公众号分享；有人喜欢通过逛逛不同的博客，来了解当前时下的技术；也有人喜欢通过社区的形式，跟优秀的导师们一起梳理和发展技术发展的脉络。而我依然坚持着古老的学习理念、追求纸质书籍的实质感和仪式感，通过阅读作者的精美作品的形式来获取知识。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　当然，某种意义上讲，这种方式获取的知识或许是成本比较高的一种形式，因为..书越来越贵了。犹记得多少年前购买的技术书籍，约300页，大概只需20-30元，而如今，基本上都是六十元。当然，这也是因为读者越来越少，而印书的成本越来越贵的原。真正的好书，本来也值得花一点点钱去认真的拜读、认真品味其中的妙处。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　过年几天时间，我在家里认真的拜读了由阿里巴巴中间件团队技术改造过程中的若干问题而整理输出的技术书籍《企业IT架构转型之道-阿里巴巴中台战略思想与架构实践》。这本书系统的介绍了阿里巴巴启动中台战略的原因及架构演变之路，以及阿里巴巴为何会使用共享服务中心、以及共享服务中心搭建的原则和技术选型、高可用和高并发等问题。众所周知，阿里巴巴的技术栈主要都是Java，而笔者是一名.NET开发者，一直以来也是从事企业级架构开发的路线，我觉得这本书，值得大家来阅读。尤其是在语言之争死灰复燃的今天，更具有学习价值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　阿里巴巴集团是国内开发者技术圈中梦想的技术殿堂，每一位阿里巴巴输出的优秀的技术人员，往往都会成为每家企业的开发者的典范，尤其是阿里巴巴输出的架构师，他们拥有丰富的高并发实战经验、具备广阔的视野和远景，更是成为IT业界最为珍贵的资源，阿里巴巴集团也输出了大量优秀的开源技术框架，这些无不令中国的开源技术社区获益颇多。可以毫不讳言的说，阿里巴巴集团对中国的开源技术社区做出的贡献几乎无可比拟。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　笔者认为，微软也是同样一家类似于阿里巴巴集团的优秀的技术企业，.NET也是一种优秀的技术，在过去若干年的发展历程中，如果不是由于微软的封闭政策，倒也不至于.NET与互联网逐渐绝缘。然而随着.NET CORE的开源，意味着这种局面实际上已经有所改观。.NET Core体系之中，提供了一系列的技术组件，可以让开发者们更加方便的应用，例如，.NET Core开发的服务，同样能够运行在容器之上，也可以使用UWP或Xamarin开发跨平台应用、同样也可以用.NET Core开发基于树莓派的程序，可以使用ML.NET进行机器学习的开发。可以说，其他语言能做的，.NET 同样可以实现。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　作为Java开发者，勿因为一时的所谓百分比而沾沾自喜，开发语言取得的美好成就，从来不是个人的成就，而是天时+地利+人和+偶然或必然。而作为.NET开发者，同样也无需自暴自弃，他山之石，可以攻玉的道理，大家实际上都非常清楚，作为.NET开发者，应当适当的涉猎与非本语言相关的技术资料来实现技术储备。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　笔者的上一篇文章中《由优劣语言之争引起的思考》,大部分的回复都是说，语言不过是解决问题的武器，优秀的开发者，往往善于使用不同的武器来解决问题，灵活的运用不同语言的特点，可以让开发者应对技术问题时，能够无往而不利。不管是.NET开发者也好，还是Java开发者也好，都承载着的是企业飞速发展的梦想，不同的语言，实际上都是为了推动企业快速进步的动力。尤其是在当今，微服务和容器技术的广泛应用，更是让语言不再成为企业开发者的鸿沟。在企业发展过程中，所遇到的无穷无尽的业务问题，才是开发者们真正需要考虑的核心问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　开发者应时刻保持创新精神。或许有相当一部分企业已经完成了企业级架构的建设，初步建设了较为完善的企业级信息化管理体系，这些系统的功能都已经比较稳定，或许只需要小范围的运营维护才行。然而，哪怕是百分之十的变更，也不得不让系统进行重构。如何让建设的系统能够成为宝贵的积累，而不是糟粕，让新的系统架构能够与时俱进，则往往需要开发者们具备创新意识。在企业级信息化体系中的创新者，不见得是来自于外部的创新者，而大部分往往是企业内部具有创新意识的优秀员工。尤其是掌握企业信息化系统核心业务流程和技术细节的开发者，更具有创新潜力。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　除此之外，作为开发者，最重要的心态，依然是开放的心态，海纳百川、包容万物，时刻学习。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>语言之争与读书有感 移动互联网无处不在的今天，不同的学习方式让我们受益颇多。有人喜欢通过手机阅读各类技术专家的公众号分享；有人喜欢通过逛逛不同的博客，来了解当前时下的技术；也有人喜欢通过社区的形式，跟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10360585.html</dc:identifier>
</item>
<item>
<title>Linux内核编程规范与代码风格 - trav</title>
<link>http://www.cnblogs.com/trav/p/10356415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/trav/p/10356415.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;source: https://www.kernel.org/doc/html/latest/process/coding-style.html&lt;br/&gt;translated by trav, travmymail@gmail.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一篇阐述Linux内核编程代码风格的文档，译者以学习为目的进行翻译。&lt;/p&gt;
&lt;h3 id=&quot;缩进&quot;&gt;1 缩进&lt;/h3&gt;
&lt;p&gt;Tab的宽度是八个字符，因此缩进的宽度也是八个字符。有些异教徒想让缩进变成四个字符，甚至是两个字符的宽度，这些人和那些把 PI 定义为 3 的人是一个路子的。&lt;/p&gt;
&lt;p&gt;注意：缩进的全部意义在于清晰地定义语句块的开始与结束，特别是当你盯着屏幕20个小时之后，你会发现长的缩进宽度的作用。&lt;/p&gt;
&lt;p&gt;现在有些人说八个字符的宽度太宽了，这会让代码往右移很远，在一块八十字符宽的屏幕上，这样的代码会很难阅读。对此的回答是，如果你写的代码需要超过三层的缩进，那么你把一切都搞砸了，你应该修复你的程序。&lt;/p&gt;
&lt;p&gt;简而言之，八个字符宽度的缩进让代码更容易阅读，并且额外的好处就是提醒你，不要在一个函数里写太多层的嵌套逻辑。请记住这个警示。&lt;/p&gt;
&lt;p&gt;switch语句的缩进方式是让case与switch对齐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (suffix) {
case 'G':
case 'g':
        mem &amp;lt;&amp;lt;= 30;
        break;
case 'M':
case 'm':
        mem &amp;lt;&amp;lt;= 20;
        break;
case 'K':
case 'k':
        mem &amp;lt;&amp;lt;= 10;
        /* fall through */
default:
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在单独一行里写多个语句，除非你想干什么不为人知的事：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition) do_this;
  do_something_everytime;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对了，不要把多个赋值语句放在同一行，内核的代码风格是十分简洁的，请尽量避免使用复杂的表达式。&lt;/p&gt;
&lt;p&gt;除了在注释、文档和Kconfig中，永远不要使用空格作为缩进，上面的例子是故意犯的错误。&lt;/p&gt;
&lt;p&gt;找一个像样的编辑器，不要在行末留有空格。&lt;/p&gt;
&lt;h3 id=&quot;换行&quot;&gt;2 换行&lt;/h3&gt;
&lt;p&gt;规范代码风格的目的是提高代码的可读性和维护性。&lt;/p&gt;
&lt;p&gt;单行的宽度限制为八十列，这是强烈推荐的设置。&lt;/p&gt;
&lt;p&gt;任何一行超过八十列宽度的语句都应该拆分成多个行，除非超过八十列的部分可以提高可读性且不会隐藏信息。拆分出来的子句长度总是应该比其主句要短，并且应该尽量靠右。这条法则同样适用于一个有很长的参数列表的函数头。然而，千万不要把用户可见的字符串，比如 printk 的信息，拆分成多行，因为这样会导致使用 grep 的时候找不到这些信息。&lt;/p&gt;
&lt;h3 id=&quot;括号与空格&quot;&gt;3 括号与空格&lt;/h3&gt;
&lt;p&gt;另一个关于 C 代码风格的议题就是大括号的位置。这个问题不像缩进那么具有技术性，我们并不能说某一种风格要在技术上优于另一种风格。但是我们更推荐的，就是有远见的 Kernighan 和 Ritchie 展示的方式，把左括号放在行末，把右括号放在行首：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (x is true) {
        we do y
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这同样适用于其他非函数的语句块 (if, switch, for, while, do) ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (action) {
case KOBJ_ADD:
        return &quot;add&quot;;
case KOBJ_REMOVE:
        return &quot;remove&quot;;
case KOBJ_CHANGE:
        return &quot;change&quot;;
default:
        return NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，有一个特殊的例子，就是函数：函数的左括号应该放在行首：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int function(int x)
{
        body of function
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异教徒们会认为这样的风格是不一致的，但是所有有脑子的人都知道尽管是 K&amp;amp;R 也是不一致的(译者注：K&amp;amp;R这本书的第一版和第二版有不一致的地方)。除此之外，我们知道函数是很特殊的，在 C 语言中，你不能有嵌套函数。&lt;/p&gt;
&lt;p&gt;注意到，右括号一般是单独成一行的，除非右括号之后紧随着紧密结合的语句，例如 do-while 语句和 if 语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;do {
        body of do-loop
} while (condition);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (x == y) {
        ..
} else if (x &amp;gt; y) {
        ...
} else {
        ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依据：K&amp;amp;R&lt;/p&gt;
&lt;p&gt;注意到，这种风格应该在不降低可读性的前提下尽可能减少空行的数量。想一想，在一块只有 25 行的屏幕上，无用的换行少了，那么就有更多的空行来写注释。&lt;/p&gt;
&lt;p&gt;当单行语句可以解决的时候，不要使用没必要的括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition)
        action();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition)
        do_this();
else
        do_that();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一点不适用于只有一个 case 有单行，其他 case 有多行的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition) {
        do_this();
        do_that();
} else {
        otherwise();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一个循环中超过一个语句的情况也同样需要使用括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (condition) {
        if (test)
                do_something();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.1 空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux 内核风格的空格主要用在一些关键字上，即在关键字之后添一个空格。值得关注的例外是一些长得像函数的关键字，比如：&lt;strong&gt;sizeof&lt;/strong&gt;, &lt;strong&gt;typeof&lt;/strong&gt;, &lt;strong&gt;alignof&lt;/strong&gt;, &lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt;&lt;/strong&gt;，在 Linux 中，这些关键字的使用都会带上一对括号，尽管在 C 语言的使用上并不需要带上括号。&lt;/p&gt;
&lt;p&gt;所以在下面这些关键字之后添加一个空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if, switch, case, for, do, while&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是不要添加在 &lt;strong&gt;sizeof&lt;/strong&gt;, &lt;strong&gt;typeof&lt;/strong&gt;, &lt;strong&gt;alignof&lt;/strong&gt;, &lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt;&lt;/strong&gt; 之后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = sizeof(struct file);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在括号周围多此一举的添加空格，下面这个例子糟透了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = sizeof( struct file );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在声明指针或者返回值为指针的函数时，星号的位置应该紧靠着变量名或函数名，而不是类型名，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char *linux_banner;
unsigned long long memparse(char *ptr, char **retptr);
char *match_strdup(substring_t *s);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在二元操作符和三元操作符周围添加一个空格，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;=  +  -  &amp;lt;  &amp;gt;  *  /  %  |  &amp;amp;  ^  &amp;lt;=  &amp;gt;=  ==  !=  ?  :&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是不要在一元操作符之后添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在后缀的自增自减一元操作符之前添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;++  --&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在前缀的自增自减一元操作符之后添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;++  --&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在结构体成员操作符周围添加空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.  -&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在行末添加多余的空格。一些编辑器的“智能”缩进会帮你在行首添加一些空格，好让你在下一行可以立即写代码。但是某些编辑器不会帮你把多余的空格给删掉，尽管你已经写完了一行代码。比如你只想留一行空行，但是编辑器却“好心”地帮你填上了一些空格。这样一来，你就在行末添加了多余的空格。&lt;/p&gt;
&lt;p&gt;Git 通常会警告你，让你除去这些多余的空格，并且可以帮你删掉这些东西。但是，如果你让 Git 一直帮你这样修补你的代码，这很可能导致代码行的上下错乱，之后的自动修补的失败。&lt;/p&gt;
&lt;h3 id=&quot;命名&quot;&gt;4 命名&lt;/h3&gt;
&lt;p&gt;C 是一种简洁粗旷的语言，因此，你的命名也应该是简洁的。C 程序员不会像 Modula-2 和 Pascal 程序员那样使用 ThisVariableIsATemporaryCounter 这种“可爱”的名字，一个 C 程序员会把这种变量命名为 tmp ，如此简洁易写。&lt;/p&gt;
&lt;p&gt;尽管看到一个混合大小写的名字让人皱眉，不过对于全局变量来说，一个具有描述性的名字还是很有必要的。去调用一个名为 foo 的全局函数同样让人难以接受。&lt;/p&gt;
&lt;p&gt;全局变量(只有当你真正需要的时候才用它)和全局函数需要使用描述性的名字。如果你有一个计算活跃用户数量的函数，你应该起这样一个名字 &lt;code&gt;count_active_users()&lt;/code&gt; 或者类似的，而不是这样一个名字 &lt;code&gt;cntusr()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;起一个包含函数类型的名字(匈牙利命名法)是摧残大脑的行为，编译器知道函数的类型并且会检查类型，这样的名字不会起到任何帮助，它仅仅会迷惑程序员。所以，也难怪微软做出了那么多充满了 bug 的程序。&lt;/p&gt;
&lt;p&gt;局部变量名应该简短，如果你需要写一个循环，定义一个计数器，在不产生歧义的情况下，你大可命名为 i ，命名为 loop_counter 是生产力很低的行为。同样地，tmp 可以是任何类型的临时变量。&lt;/p&gt;
&lt;p&gt;如果你担心会弄混变量名，那么你遇到了另一个问题，你患上了函数增长荷尔蒙失调综合症。&lt;/p&gt;
&lt;h3 id=&quot;typedefs&quot;&gt;5 Typedefs&lt;/h3&gt;
&lt;p&gt;请不要使用 vps_t 这种东西，这是 typedef 的错误用法，当你看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vps_t a;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种写法时，它究竟是个什么东西？相反，如果是这样的写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct virtual_container *a;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你就很容易知道 a 代表着什么。&lt;/p&gt;
&lt;p&gt;很多人认为 typedef 是用来帮助提高可读性的，但是事实往往不是这样的。typedef 仅仅有如下用处：&lt;/p&gt;
&lt;p&gt;a. 封装对象(typedef 可以方便的隐藏对象)&lt;/p&gt;
&lt;p&gt;例如，pte_t 会把对象封装起来，你仅仅只能通过合适的“访问函数”(成员函数)来访问这个对象。&lt;/p&gt;
&lt;p&gt;注意：封装和“访问函数”(成员函数)本身就不是好东西，我们使用 pte_t 这种东西的理由就是，它指向的对象本身绝对没有东西可以访问(我们压根儿不使用封装和成员函数那一套)。&lt;/p&gt;
&lt;p&gt;b. 指明整数类型，这种抽象可以帮助我们避免一些使用 int 和 long 的疑虑&lt;/p&gt;
&lt;p&gt;u8/u16/u32 是完美的使用 typedef 的例子。&lt;/p&gt;
&lt;p&gt;注意：你必须要有明确的理由来使用这些用法，如果一些地方使用的本身就是 unsigned long ，那么你没有任何理由这样做&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef unsigned long myflags_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果你有明确的理由来解释为什么在某种情况下使用 unsigned int，而在其他情况下使用 unsigned long，那么大可使用 typedef。&lt;/p&gt;
&lt;p&gt;c. 使用 sparse 去新建一个类型来做类型检查&lt;/p&gt;
&lt;p&gt;d. 在某些情况下新建一个与 C99 标准相等的类型&lt;/p&gt;
&lt;p&gt;尽管只需要花一小段眼睛和大脑的时间来适应新标准的类型，如 uint32_t，但是一些人还是反对使用他们。&lt;/p&gt;
&lt;p&gt;因此，你可以使用 Linux 独有的 u8/u16/u32/u64 和他们的有符号版本，也可以使用和他们等价的新标准的类型，他们的使用都不是强制的。&lt;/p&gt;
&lt;p&gt;当你所编辑的代码已经使用了某一种版本时，你应该按照原样使用相同的版本。&lt;/p&gt;
&lt;p&gt;e. 用户空间中的类型安全&lt;/p&gt;
&lt;p&gt;用户空间中的某些特定的结构体中，我们不能使用 C99 定义的新类型以及上述的 u32，取而代之，我们统一使用 __u32 之类的类型。&lt;/p&gt;
&lt;p&gt;也许还有其他情况，但是基本的规则就是，如果你不能满足上述其中一条情况，你就永远不要使用 typedef。&lt;/p&gt;
&lt;p&gt;通常，一个指针或者一个有可访问元素的结构体，都不应该使用 typedef。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;6 函数&lt;/h3&gt;
&lt;p&gt;函数应该短小精悍，一个函数只干一件事。一个函数的代码两个屏幕就应该装得下(ISO/ANSI标准屏幕大小是80x24)，简单说就是，做一件事并且把它做好。&lt;br/&gt;数的最大长度与函数的复杂度和缩进程度成反比，所以，如果你有一个简单的函数，函数里面只是需要处理一个又一个的 case，每个 case 只是干一些小事，函数长度长一些也没关系。&lt;/p&gt;
&lt;p&gt;然而，如果你的函数十分复杂，你怀疑一个不像你一样天才的高中生看不懂，你应该遵守函数最大的长度的限制，使用一些有描述性名称的辅助函数。如果你认为函数的性能至关重要，你可以让编译器把这些辅助函数编译成内联函数，一般情况下编译器可以比你做得更好。&lt;/p&gt;
&lt;p&gt;另一个测量函数的因素是局部变量的数量，他们不应该超出5-10个这个范围，否则你就犯了一些错误。重新思考这个函数，把它拆分成更小的几段。人类的大脑一般只能同时关注七件不同的事，更多需要关注的事情意味着更多的困扰。尽管你认为你是个天才，但是你也希望理解一段你两周之前写的代码。&lt;/p&gt;
&lt;p&gt;在源文件中，用一个空行分割不同的函数，如果函数需要导出到外部使用，那么它对应的 EXPORT 宏应当紧随在函数之后，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int system_is_up(void)
{
        return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数原型中，参数名应该与参数类型引起写出来，尽管 C 语言允许只写上参数类型，但是我们更推荐参数名，因为这是一种为读者提供有价值信息的简单方式。&lt;/p&gt;
&lt;p&gt;不要在函数原型之前使用&lt;code&gt;extern&lt;/code&gt;关键字，因为这是不必要且多余的。&lt;/p&gt;
&lt;h3 id=&quot;集中函数出口&quot;&gt;7 集中函数出口&lt;/h3&gt;
&lt;p&gt;尽管许多人反对，但是 goto 语句频繁地以无条件跳转的形式被编译器使用。&lt;/p&gt;
&lt;p&gt;当函数有多个出口，并且返回之前需要做很多相似的工作时，比如清理空间，这时候 goto 语句是十分方便的。当然了，如果没有类似的清理工作要在返回之前做，那么直接返回即可。&lt;/p&gt;
&lt;p&gt;根据 goto 的作用来决定一个 label 的名字，如果 goto 语言要去释放缓存，那么&lt;code&gt;out_free_buffer:&lt;/code&gt;会是一个好名字。避免使用 GW-BASIC 的命名方式，比如 &lt;code&gt;err1:&lt;/code&gt; &lt;code&gt;err2:&lt;/code&gt;，因为当你需要新加或者删除某些函数出口时，你就需要重新排列标签数字，这会让代码的正确性难以得到保证。&lt;/p&gt;
&lt;p&gt;使用 goto 的理由如下：&lt;/p&gt;
&lt;p&gt;无条件跳转易于理解和阅读&lt;/p&gt;
&lt;p&gt;可以减少嵌套&lt;/p&gt;
&lt;p&gt;可以减少修改个别函数出口代码所造成的错误&lt;/p&gt;
&lt;p&gt;算是帮助编译器做了一些优化的工作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fun(int a)
{
        int result = 0;
        char *buffer;

        buffer = kmalloc(SIZE, GFP_KERNEL);
        if (!buffer)
                return -ENOMEM;

        if (condition1) {
                while (loop1) {
                        ...
                }
                result = 1;
                goto out_free_buffer;
        }
        ...
out_free_buffer:
        kfree(buffer);
        return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个常见的 bug 被称作 one err bug，它长得像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err:
        kfree(foo-&amp;gt;bar);
        kfree(foo);
        return ret;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bug 在于某些 goto 语句跳转到此时，foo 仍然是 NULL，修复此 bug 的简单方式就是将一个 label 拆分成两个，&lt;code&gt;err_free_bar:&lt;/code&gt; 和 &lt;code&gt;err_free_foo:&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err_free_bar:
       kfree(foo-&amp;gt;bar);
err_free_foo:
       kfree(foo);
       return ret;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，你应该进行测试，模拟错误情况的发生，测试所有的出口代码。&lt;/p&gt;
&lt;h3 id=&quot;注释&quot;&gt;8 注释&lt;/h3&gt;
&lt;p&gt;注释是好的，但是要避免过分注释。永远不要去尝试解释你的代码如何工作，而是花时间在写出好的代码来，解释一段烂代码是浪费时间。&lt;/p&gt;
&lt;p&gt;一般来说，你应该去说明你的代码做了什么，而不是怎么做。同样地，尽量避免在函数体内写注释，如果你的函数如此复杂，以致于你需要在函数体内分几段注释来解释，那么你应该回到第六节去看看。你可以写一小段的注释来标记或者提醒大家哪些地方写得真聪明(或者真烂)，但是不要做得太过分。除此之外，你应该把注释写在函数开头，告诉人们这个函数干了什么，为什么要这样干。&lt;/p&gt;
&lt;p&gt;当你给 kernel API 进行注释的时候，请你使用 kernel-doc 的格式。具体参见 https://www.kernel.org/doc/html/latest/doc-guide/index.html#doc-guide&lt;/p&gt;
&lt;p&gt;多行注释推荐的格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * This is the preferred style for multi-line
 * comments in the Linux kernel source code.
 * Please use it consistently.
 *
 * Description:  A column of asterisks on the left side,
 * with beginning and ending almost-blank lines.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于在 net/ 和 drivers/net/ 中的文件，推荐的多行注释格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* The preferred comment style for files in net/ and drivers/net
 * looks like this.
 *
 * It is nearly the same as the generally preferred comment style,
 * but there is no initial almost-blank line.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对一些数据和变量进行注释也是必要的，无论他们是基本类型的还是派生类型的。为了进行注释，你应该在一行内只声明一个变量，不要使用逗号进行多个声明，这让你有地方对每一个变量进行注释。&lt;/p&gt;
&lt;h3 id=&quot;你已经弄得一团糟&quot;&gt;9 你已经弄得一团糟&lt;/h3&gt;
&lt;p&gt;没关系，我们都犯过错。你的那些 Unix 的老手朋友们可能会告诉你，GNU emacs 能帮你自动地对 C 代码进行排版，你也注意到它确实可以。但是它默认的排版方式真的很糟糕，事实上，即便是在键盘上乱敲也比它来的好看。相信我，无数的猴子在 GNU emacs 上乱敲是不会做出好的程序的。&lt;/p&gt;
&lt;p&gt;因此，你可以选择直接把 GNU emacs 给删了，或者修一修它，让它恢复正常。如果你选择了后者，那么请把下面的东西拷贝到你的 .emacs 文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(defun c-lineup-arglist-tabs-only (ignored)
  &quot;Line up argument lists by tabs, not spaces&quot;
  (let* ((anchor (c-langelem-pos c-syntactic-element))
         (column (c-langelem-2nd-pos c-syntactic-element))
         (offset (- (1+ column) anchor))
         (steps (floor offset c-basic-offset)))
    (* (max steps 1)
       c-basic-offset)))

(add-hook 'c-mode-common-hook
          (lambda ()
            ;; Add kernel style
            (c-add-style
             &quot;linux-tabs-only&quot;
             '(&quot;linux&quot; (c-offsets-alist
                        (arglist-cont-nonempty
                         c-lineup-gcc-asm-reg
                         c-lineup-arglist-tabs-only))))))

(add-hook 'c-mode-hook
          (lambda ()
            (let ((filename (buffer-file-name)))
              ;; Enable kernel mode for the appropriate files
              (when (and filename
                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)
                                       filename))
                (setq indent-tabs-mode t)
                (setq show-trailing-whitespace t)
                (c-set-style &quot;linux-tabs-only&quot;)))))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会让你的 emacs 更好地满足内核的代码风格。&lt;/p&gt;
&lt;p&gt;但是即使你不能让你的 emacs 恢复正常，也有解救方法：使用 indent 。&lt;/p&gt;
&lt;p&gt;同样的问题出现了，GNU indent 和 GNU emacs 有同样的问题，因此你需要一些命令行选项来进行配置。但是事情也没那么糟，因为 GNU indent 的制造者承认 K&amp;amp;R 的权威性，所以你只需要添加命令行参数 -kr -i8 (表示 K&amp;amp;R，8个字符宽的缩进)，或者使用 scripts/Lindent 也可以。&lt;/p&gt;
&lt;p&gt;indent 有很多命令行选项，特别是注释的格式化方面，你可以通过 man 帮助页面来查看，不过请记住：indent 不是用来修复烂程序的。&lt;/p&gt;
&lt;p&gt;注意：你也可以使用 clang-format 来完成这些格式化的工作，具体参见 https://www.kernel.org/doc/html/latest/process/clang-format.html#clangformat&lt;/p&gt;
&lt;h3 id=&quot;kconfig-配置文件&quot;&gt;10 Kconfig 配置文件&lt;/h3&gt;
&lt;p&gt;对于 Linux 中的 Kconfig 配置文件，他们的缩进是有所不同的。在 config 定义下的缩进是一个 tab，而里面的 help 文本是两个空格，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config AUDIT
      bool &quot;Auditing support&quot;
      depends on NET
      help
        Enable auditing infrastructure that can be used with another
        kernel subsystem, such as SELinux (which requires this for
        logging of avc messages output).  Does not do system-call
        auditing without CONFIG_AUDITSYSCALL.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于有可能导致危险的动作(比如特定文件系统的写支持)，你应该在提示文本中直接指出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config ADFS_FS_RW
      bool &quot;ADFS write support (DANGEROUS)&quot;
      depends on ADFS_FS
      ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体细节参见 Documentation/kbuild/kconfig-language.txt&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;11 数据结构&lt;/h3&gt;
&lt;p&gt;对于单线程环境里创建和销毁的一些数据结构，如果他们对于线程外是可见的，那么总是应该有引用计数。在内核里，垃圾收集器(GC)是不存在的，这意味着你必须对你使用过的数据进行引用计数。&lt;/p&gt;
&lt;p&gt;进行引用计数意味着你可以避免死锁，允许多个用户并行访问数据，并且不用担心数据因为睡眠或者其他原因而找不到。&lt;/p&gt;
&lt;p&gt;注意，锁不是引用计数的替代品。锁是为了保持数据的一致性，而引用计数是一种内存管理计数。通常这两种技术都是需要的，我们不要把他们搞混。&lt;/p&gt;
&lt;p&gt;当有多个不同类的使用者时，很多数据结构会使用二级引用计数。第二级的引用计数会统计第二级使用者的数量，只有当第二级引用计数递减至零时，全局的第一级引用计数才会减一。&lt;/p&gt;
&lt;p&gt;这种多级引用计数在内存管理(struct mm_struct: mm_users and mm_count)和文件系统(struct super_block: s_count and s_active)中都有使用。&lt;/p&gt;
&lt;p&gt;记住，如果其他线程可以发现并使用你的数据结构，而你却没有引用计数，那么这基本就是一个 bug。&lt;/p&gt;
&lt;h3 id=&quot;宏枚举与rtlreal-time-linux&quot;&gt;12 宏、枚举与RTL(Real Time Linux)&lt;/h3&gt;
&lt;p&gt;常量宏和枚举的命名都是大写的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CONSTANT 0x12345&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当定义一些有关联的常量时，使用枚举是一个很好的选择。&lt;/p&gt;
&lt;p&gt;定义宏一般都使用大写，但是函数宏可以使用小写。&lt;/p&gt;
&lt;p&gt;通常，我们更推荐把内联函数定义为宏。&lt;/p&gt;
&lt;p&gt;包含多条语句的宏应该包含在一个 do-while 循环体中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define macrofun(a, b, c)                       \
        do {                                    \
                if (a == 5)                     \
                        do_this(b, c);          \
        } while (0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用宏时应该避免的情况：&lt;/p&gt;
&lt;p&gt;1) 影响程序控制流的宏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(x)                                  \
        do {                                    \
                if (blah(x) &amp;lt; 0)                \
                        return -EBUGGERED;      \
        } while (0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个非常坏的坏主意。它看起来像个函数，然而却会导致调用者返回到上一层。宏的设计不要打断程序的控制流。&lt;/p&gt;
&lt;p&gt;2) 依赖局部变量的宏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(val) bar(index, val)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这看起来像个好东西，但其实糟透了，并且容易让人困扰。当其他人阅读这段代码时，他一个细微的改动可能导致严重的危害。&lt;/p&gt;
&lt;p&gt;3) 带参数的宏当作左值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FOO(x) = y;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有人把 FOO 变成内联函数，那么这段代码就错了。&lt;/p&gt;
&lt;p&gt;4) 忘了优先级&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用宏来定义常量的时候，必须要括上括号，带有参数的宏也要注意。&lt;/p&gt;
&lt;p&gt;5) 在定义宏函数时发生命名冲突&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FOO(x)                          \
({                                      \
        typeof(x) ret;                  \
        ret = calc_ret(x);              \
        (ret);                          \
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ret 是一个很容易和局部变量发生冲突的名字，而 __foo_ret 这样的名字则很少会发生冲突。&lt;/p&gt;
&lt;p&gt;C++ 手册全面地阐述了宏定义的细节，gcc 手册同样也阐述了汇编语言使用的 RTL 规则，具体请自行查看。&lt;/p&gt;
&lt;h3 id=&quot;打印内核信息&quot;&gt;13 打印内核信息&lt;/h3&gt;
&lt;p&gt;内核开发者喜欢被视为有素养的，好的英文拼写和准确的内核信息能给人留下好的印象，因此，不要使用一些单词的缩写，比如 dont，而是 do not 或者 don't。把提示信息写得尽可能准确、清晰、无二义。&lt;/p&gt;
&lt;p&gt;内核信息不需要在末尾加上句号&lt;/p&gt;
&lt;p&gt;在圆括号中打印数字(%d)没有任何意义，应该避免这样干。&lt;/p&gt;
&lt;p&gt;在&amp;lt;linux/device.h&amp;gt;中有许多驱动模型的诊断宏，你应该使用这些宏来确保消息匹配正确的设备和驱动，并正确的标记它们的级别：dev_err(), dev_warn(), dev_info(), and so forth。对于没有关联特定设备的消息，&amp;lt;linux/printk.h&amp;gt;中定义了 pr_notice(), pr_info(), pr_warn(), pr_err(), etc。&lt;/p&gt;
&lt;p&gt;编写好的调试信息是一项巨大的挑战，一旦你完成了，这些信息会对远程调试产生巨大帮助。调试信息与普通信息不同，pr_XXX() 函数在任何条件下都会进行打印，而 pr_debug() 却不是，这些与调试有关的函数默认都不会被编译，除非你定义了一个 DEBUG 宏或者 CONFIG_DYNAMIC_DEBUG 宏来显式地让编译器编译他们。还有一个惯例就是使用 VERBOSE_DEBUG 为那些已经开启 DEBUG 的用户添加 dev_vdbg() 消息。&lt;/p&gt;
&lt;p&gt;很多子系统在对应的 makefile 里都有 Kconfig 调试选项来打开 -DDEBUG，或者是在文件里定义宏 #define DEBUG。当调试信息可以被无条件打印，或者说已经编译了和调试有关的 #ifdef 段，那么 printk(KERN_DEBUG ...) 就可以用来打印调试信息。&lt;/p&gt;
&lt;h3 id=&quot;分配内存&quot;&gt;14 分配内存&lt;/h3&gt;
&lt;p&gt;内核提供了下面这些通用的内存分配器：kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc(), and vzalloc()。具体细节参见 API 文档。&lt;/p&gt;
&lt;p&gt;为一个结构体分配内存的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kmalloc(sizeof(*p), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种写出结构体名字的方式(sizeof(struct name))会破坏可读性并且给 bug 制造了机会：修改结构体名字却忘了修改对于的 sizeof 语句。&lt;/p&gt;
&lt;p&gt;另外，在 malloc 之前添加上一个强制的类型转换，把空类型的指针转换为特定类型的指针，这些是多此一举的操作，他们应当交给编译器来干，而不是你。&lt;/p&gt;
&lt;p&gt;分配一个数组的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kmalloc_array(n, sizeof(...), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分配一个零数组的形式最好是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p = kcalloc(n, sizeof(...), ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种形式都会检查溢出，并且溢出发生时返回一个空指针 NULL。&lt;/p&gt;
&lt;h3 id=&quot;内联之灾&quot;&gt;15 内联之灾&lt;/h3&gt;
&lt;p&gt;一个很常见的误解就是，人们认为 gcc 有一种让他们的程序跑得更快的魔法，就是内联。然而，内联往往也有不合适的用法(例如第十二节提到的替换宏)。inline 关键字的泛滥，会使内核变大，从而使整个系统运行速度变慢，因为大内核会占用更多的CPU高速缓存，同时会导致可用内存页缓存减少。想象一下，一次页缓存未命中就会导致一次磁盘寻址，这至少耗费5毫秒。5毫秒足够CPU运行很多很多的指令。&lt;/p&gt;
&lt;p&gt;一个基本的原则就是，如果一个函数有3行以上的代码，就不要把它变成内联函数。有一个例外，若某个参数是一个编译时常数，且你确定因为这个常量，编译器在编译时能优化掉函数的大部分代码，那么加上 inline 关键字。kmalloc() 就是个很好的例子。&lt;/p&gt;
&lt;p&gt;人们经常主张可以给只用一次的静态函数加上 inline 关键字，这样不会有任何损失。虽然从技术上来说这样没错，但是实际上 gcc 会自动内联这些函数。&lt;/p&gt;
&lt;h3 id=&quot;函数返回值与名称&quot;&gt;16 函数返回值与名称&lt;/h3&gt;
&lt;p&gt;函数可以返回不同种类的值，但是最普遍的就是表示运行成功或失败的值。这样的值可以用预先定义好的错误码表示(-Exxx = failure, 0 = success)，或者一个布尔值(0 = failure, non-zero = success)&lt;/p&gt;
&lt;p&gt;混合两种方式会使代码变得复杂，并且很难找到 bug。如果C语言能明确区分整型和布尔型，那么编译器会替我们发现这个问题……但是它不会那么做。为了避免这种问题，一定要谨记如下约定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果函数名是一个短语，表示的是一个动作，或者一个命令，那么返回值应该使用错误码的方式。
如果函数名是一句话，表示的是一个断言，那么应该使用布尔值的方式。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，add work 是一个动作，那么 add_work() 返回值为0则表示成功，-EBUSY表示失败。PCI device present是一个断言，那么 pci_dev_present() 返回值为1表示成功，0表示失败。&lt;/p&gt;
&lt;p&gt;可导出(EXPORT)的函数都应该遵守这个约定，私有(static)函数不需要，不过我建议你还是遵守。&lt;/p&gt;
&lt;p&gt;如果返回值是一些计算结果，那么当然不需要管这些东西。一般来说，计算结果出错了就表示失败了。典型的例子就是返回一个指针：使用 NULL 或者 ERR_PTR 来表示错误。&lt;/p&gt;
&lt;h3 id=&quot;不要重新发明内核宏&quot;&gt;17 不要重新发明内核宏&lt;/h3&gt;
&lt;p&gt;include/linux/kernel.h 头文件里定义了一些你可以使用的宏，你应该直接使用他们，而不是重新再定义一些新的宏。例如，如果你需要计算数组长度，使用提供的宏：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样地，如果你需要计算结构体中某个成员的大小，使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&amp;gt;f))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要，里面还有做类型检查的 min() 和 max() 宏。仔细看看头文件中还定义了那些东西，如果里面有了，你就不要在自己的代码中重新定义了。&lt;/p&gt;
&lt;h3 id=&quot;多此一举的编辑器&quot;&gt;18 多此一举的编辑器&lt;/h3&gt;
&lt;p&gt;有些编辑器可以识别源文件中的配置信息，例如 emacs 可以识别这样的标记：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-*- mode: c -*-&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
Local Variables:
compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;
End:
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Vim 可以识别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* vim:set sw=8 noet */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要在源代码中包含任何类似的内容。每个人都有自己的编辑器配置，你的源文件不应该影响他们。&lt;/p&gt;
&lt;h3 id=&quot;内联汇编&quot;&gt;19 内联汇编&lt;/h3&gt;
&lt;p&gt;在写一些与体系结构有关的代码中，你可能需要使用一些内联汇编调用CPU相关的接口或者和平台有关的功能，如果有这种需求，你大可使用汇编。但是如果C语言可以干的事，不要使用汇编。你应该尽可能地使用C语言来控制硬件。&lt;/p&gt;
&lt;p&gt;尽可能写一些辅助函数来实现相同的功能，而不是重复地写一些相同的代码，同时记住，内联汇编也可以使用C函数的参数。&lt;/p&gt;
&lt;p&gt;大的、重要的汇编函数应该独自写在一个 .S 文件中，并且编写对应的C头文件和函数原型，相应的函数原型应该添加 asmlinkage 关键字。&lt;/p&gt;
&lt;p&gt;你也许需要标记某些汇编代码为 volatile，避免 gcc 误把一些汇编移除掉。一般情况下，你不需要这样干，没必要的标记会影响优化。&lt;/p&gt;
&lt;p&gt;当一条汇编语句里包含多个指令时，每个指令分行写，并且除了最后一行外，在其他行的行末添加 \n\t 进行缩进和对齐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;asm (&quot;magic %reg1, #42\n\t&quot;
     &quot;more_magic %reg2, %reg3&quot;
     : /* outputs */ : /* inputs */ : /* clobbers */);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;条件编译&quot;&gt;20 条件编译&lt;/h3&gt;
&lt;p&gt;无论在哪，不要在 .c 文件中使用条件编译命令(#if, #ifdef)，这样干会导致代码可读性降低并且代码逻辑混乱。取而代之，应该在 .c 文件对应的头文件中使用这些条件编译，并且在每个 #else  分支注明对应的版本信息。&lt;/p&gt;
&lt;p&gt;把同一个版本的所有函数都写在一个 #ifdef 中，不要在其中写一部分，而又在外部写一部分。&lt;/p&gt;
&lt;p&gt;在 #endif 之后写上一个注释，注明这个 #ifdef 块对应的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifdef CONFIG_SOMETHING
...
#endif /* CONFIG_SOMETHING */&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;p&gt;The C Programming Language, Second Edition by Brian W. Kernighan and Dennis M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback).&lt;br/&gt;The Practice of Programming by Brian W. Kernighan and Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.&lt;br/&gt;GNU manuals - where in compliance with K&amp;amp;R and this text - for cpp, gcc, gcc internals and indent, all available from http://www.gnu.org/manual/&lt;br/&gt;WG14 is the international standardization working group for the programming language C, URL: http://www.open-std.org/JTC1/SC22/WG14/&lt;br/&gt;Kernel process/coding-style.rst, by greg@kroah.com at OLS 2002: http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:57:00 +0000</pubDate>
<dc:creator>trav</dc:creator>
<og:description>source: https://www.kernel.org/doc/html/latest/process/coding style.html translated by trav, travmym</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/trav/p/10356415.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——OData - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10360260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10360260.html</guid>
<description>&lt;p&gt;OData，即Open Data Protocol，是由微软在2007年推出的一款开放协议，旨在通过简单、标准的方式创建和使用查询式及交互式RESTful API。&lt;/p&gt;

&lt;p&gt;在.NET Core中想要使用OData功能的话需要添加&lt;code&gt;Microsoft.AspNetCore.OData&lt;/code&gt;包。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;dotnet add package Microsoft.AspNetCore.OData&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class Address
{
    public string City { get; set; }
    public string Street { get; set; }
}
public enum Category
{
    Book,
    Magazine,
    EBook
}
public class Press
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public Category Category { get; set; }
}
public class Book
{
    public int Id { get; set; }
    public string ISBN { get; set; }
    public string Title { get; set; }
    public string Author { get; set; }
    public decimal Price { get; set; }
    public Address Address { get; set; }
    public Press Press { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;OData使用EDM，即Entity Data Model来描述数据的结构。在Startup文件中添加创建方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static IEdmModel GetEdmModel()
{
    var builder = new ODataConventionModelBuilder();
    builder.EntitySet&amp;lt;Book&amp;gt;(&quot;Books&quot;);
    builder.EntitySet&amp;lt;Press&amp;gt;(&quot;Presses&quot;);
    return builder.GetEdmModel();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在Startup文件的ConfigureServices方法里注册OData服务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddOData();
services.AddMvc(options =&amp;gt;
    {
        options.EnableEndpointRouting = false;
    }).SetCompatibilityVersion(CompatibilityVersion.Version_2_2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意的是在.NET Core 2.2里，默认已经有终结点，所以要使用OData的终结点的话需要将默认选项禁用掉。&lt;/p&gt;

&lt;p&gt;同样在Startup文件里，在其Configure方法内将原来的注册路由内容改为注册OData的终结点。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMvc(b =&amp;gt;
{
    b.MapODataServiceRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());
});&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;运行程序后访问&lt;code&gt;https://localhost:5001/odata/$metadata&lt;/code&gt;地址，可以看到所有可用模型的元数据。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;edmx:Edmx xmlns:edmx=&quot;http://docs.oasis-open.org/odata/ns/edmx&quot; Version=&quot;4.0&quot;&amp;gt;
    &amp;lt;edmx:DataServices&amp;gt;
        &amp;lt;Schema xmlns=&quot;http://docs.oasis-open.org/odata/ns/edm&quot; Namespace=&quot;Default&quot;&amp;gt;
            &amp;lt;EntityType Name=&quot;Book&quot;&amp;gt;
                &amp;lt;Key&amp;gt;
                    &amp;lt;PropertyRef Name=&quot;Id&quot;/&amp;gt;
                &amp;lt;/Key&amp;gt;
                &amp;lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;ISBN&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Title&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Author&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Price&quot; Type=&quot;Edm.Decimal&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Address&quot; Type=&quot;Default.Address&quot;/&amp;gt;
                &amp;lt;NavigationProperty Name=&quot;Press&quot; Type=&quot;Default.Press&quot;/&amp;gt;
            &amp;lt;/EntityType&amp;gt;
            &amp;lt;EntityType Name=&quot;Press&quot;&amp;gt;
                &amp;lt;Key&amp;gt;
                    &amp;lt;PropertyRef Name=&quot;Id&quot;/&amp;gt;
                &amp;lt;/Key&amp;gt;
                &amp;lt;Property Name=&quot;Id&quot; Type=&quot;Edm.Int32&quot; Nullable=&quot;false&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Name&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Email&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Category&quot; Type=&quot;Default.Category&quot; Nullable=&quot;false&quot;/&amp;gt;
            &amp;lt;/EntityType&amp;gt;
            &amp;lt;ComplexType Name=&quot;Address&quot;&amp;gt;
                &amp;lt;Property Name=&quot;City&quot; Type=&quot;Edm.String&quot;/&amp;gt;
                &amp;lt;Property Name=&quot;Street&quot; Type=&quot;Edm.String&quot;/&amp;gt;
            &amp;lt;/ComplexType&amp;gt;
            &amp;lt;EnumType Name=&quot;Category&quot;&amp;gt;
                &amp;lt;Member Name=&quot;Book&quot; Value=&quot;0&quot;/&amp;gt;
                &amp;lt;Member Name=&quot;Magazine&quot; Value=&quot;1&quot;/&amp;gt;
                &amp;lt;Member Name=&quot;EBook&quot; Value=&quot;2&quot;/&amp;gt;
            &amp;lt;/EnumType&amp;gt;
            &amp;lt;EntityContainer Name=&quot;Container&quot;&amp;gt;
                &amp;lt;EntitySet Name=&quot;Books&quot; EntityType=&quot;Default.Book&quot;&amp;gt;
                    &amp;lt;NavigationPropertyBinding Path=&quot;Press&quot; Target=&quot;Presses&quot;/&amp;gt;
                &amp;lt;/EntitySet&amp;gt;
                &amp;lt;EntitySet Name=&quot;Presses&quot; EntityType=&quot;Default.Press&quot;/&amp;gt;
            &amp;lt;/EntityContainer&amp;gt;
        &amp;lt;/Schema&amp;gt;
    &amp;lt;/edmx:DataServices&amp;gt;
&amp;lt;/edmx:Edmx&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文实例中不考虑数据库的操作，故而使用hard code方式构建必要的模型对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BooksController : ODataController
{
    private static IList&amp;lt;Book&amp;gt; Books {get; set;}
    public BooksController()
    {
        Books = new List&amp;lt;Book&amp;gt;
        {
            new Book
            {
                Id = 1,
                ISBN = &quot;111-0-321-56789-1&quot;,
                Title = &quot;Calculus&quot;,
                Price = 66.6m,
                Address = new Address
                {
                    City = &quot;Shanghai&quot;,
                    Street = &quot;Beijin Xi Road&quot;
                },
                Press = new Press
                {
                    Id = 1,
                    Name = &quot;Shanghai Tongji&quot;,
                    Category = Category.Book
                }
            },
            new Book
            {
                Id = 2,
                ISBN = &quot;222-2-654-00000-2&quot;,
                Title = &quot;Linear Algebra&quot;,
                Price = 53.2m,
                Address = new Address
                {
                    City = &quot;Shanghai&quot;,
                    Street = &quot;Beijin Dong Road&quot;
                },
                Press = new Press
                {
                    Id = 2,
                    Name = &quot;Shanghai Fudan&quot;,
                    Category = Category.EBook
                }
            }            
        };   
    }

    [EnableQuery]
    public IActionResult Get()
    {
        return Ok(Books);
    }

    [EnableQuery]
    public IActionResult Get(int key)
    {
        return Ok(Books.FirstOrDefault(b =&amp;gt; b.Id == key));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EnableQuery特性在需要高级查询的场景时必须添加。&lt;/p&gt;

&lt;p&gt;加入Controller之后，访问&lt;code&gt;https://localhost:5001/odata/Books&lt;/code&gt;地址，可得到所有Book数据。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 1,
            &quot;ISBN&quot;: &quot;111-0-321-56789-1&quot;,
            &quot;Title&quot;: &quot;Calculus&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 66.6,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Xi Road&quot;
            }
        },
        {
            &quot;Id&quot;: 2,
            &quot;ISBN&quot;: &quot;222-2-654-00000-2&quot;,
            &quot;Title&quot;: &quot;Linear Algebra&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 53.2,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Dong Road&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问&lt;code&gt;https://localhost:5001/odata/Books(1)&lt;/code&gt;地址，可得到key值为1的Book数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books/$entity&quot;,
    &quot;Id&quot;: 1,
    &quot;ISBN&quot;: &quot;111-0-321-56789-1&quot;,
    &quot;Title&quot;: &quot;Calculus&quot;,
    &quot;Author&quot;: null,
    &quot;Price&quot;: 66.6,
    &quot;Address&quot;: {
        &quot;City&quot;: &quot;Shanghai&quot;,
        &quot;Street&quot;: &quot;Beijin Xi Road&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果想要使用OData查询的高级功能，可以在注册终结点时额外加上相应的配置。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMvc(b =&amp;gt;
{
    b.Select().Expand().Filter().OrderBy().MaxTop(100).Count();
    b.MapODataServiceRoute(&quot;odata&quot;, &quot;odata&quot;, GetEdmModel());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问网址时加上所需的查询内容：&lt;br/&gt;&lt;code&gt;https://localhost:5001/odata/Books?$select=Id,Title&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books(Id,Title)&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 1,
            &quot;Title&quot;: &quot;Calculus&quot;
        },
        {
            &quot;Id&quot;: 2,
            &quot;Title&quot;: &quot;Linear Algebra&quot;
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要按特定条件过滤数据内容的话也很容易：&lt;br/&gt;&lt;code&gt;https://localhost:5001/odata/Books?$filter=Price%20le%2060&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;@odata.context&quot;: &quot;https://localhost:5001/odata/$metadata#Books&quot;,
    &quot;value&quot;: [
        {
            &quot;Id&quot;: 2,
            &quot;ISBN&quot;: &quot;222-2-654-00000-2&quot;,
            &quot;Title&quot;: &quot;Linear Algebra&quot;,
            &quot;Author&quot;: null,
            &quot;Price&quot;: 53.2,
            &quot;Address&quot;: {
                &quot;City&quot;: &quot;Shanghai&quot;,
                &quot;Street&quot;: &quot;Beijin Dong Road&quot;
            }
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;不难看出，OData的真正魅力在于其对那些高级查询功能的支持，所以在创建RESTful API时，不妨考虑使用OData，这样应该能减少许多不必要的代码工作。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:55:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>简述 OData，即Open Data Protocol，是由微软在2007年推出的一款开放协议，旨在通过简单、标准的方式创建和使用查询式及交互式RESTful API。 类库 在.NET Core中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10360260.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（2.4-2.10） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/10360354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/10360354.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · .NET和Java之争（叶伟民）· 虽然不抱希望但也愿.Net和Java之争暂得平息（hiroshi_cnblogs）· 《.NET和Java之争》一点随想（Lemon丶）· 《.NET和Java之争》 读后感（虫师）· 基于.NetCore的Redis5.0.3（最新版）快速入门、</description>
<pubDate>Sun, 10 Feb 2019 13:45:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： · .NET和Java之争（叶伟民）· 虽然不抱希望但也愿.Net和Java之争暂得平息（hiroshi_cnblogs）· 《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/10360354.html</dc:identifier>
</item>
<item>
<title>[总结] 动态DP学习笔记 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/10360291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/10360291.html</guid>
<description>&lt;p&gt;学习了一下动态DP&lt;/p&gt;
&lt;p&gt;问题的来源：&lt;br/&gt;给定一棵 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个节点的树，点有点权，有 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次修改单点点权的操作，回答每次操作之后的最大带权独立集大小。&lt;/p&gt;
&lt;p&gt;首先一个显然的 &lt;span class=&quot;math inline&quot;&gt;\(O(nm)\)&lt;/span&gt; 的做法就是每次做一遍树形DP（这也是我在noip考场上唯一拿到的部分分），直接考虑如何优化这个东西。&lt;/p&gt;
&lt;p&gt;简化一下问题，假如这棵树是一条链，那就变得很简单了，可以直接拿线段树维护矩阵加速。&lt;/p&gt;
&lt;p&gt;可是如果每个点不止有一个儿子呢？&lt;br/&gt;我们首先树剖一下。&lt;br/&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(g[i][0]=\sum\limits_{j\in lightson} \max(f[j][0],f[j][1])\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(g[i][1]=a[i]+\sum\limits_{j\in lightson} f[j][0]\)&lt;/span&gt;&lt;br/&gt;即 &lt;span class=&quot;math inline&quot;&gt;\(g[i][0]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的所有轻儿子的 &lt;span class=&quot;math inline&quot;&gt;\(\max(f[j][0],f[j][1])\)&lt;/span&gt; 之和，&lt;span class=&quot;math inline&quot;&gt;\(g[i][1]\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的所有轻儿子的 &lt;span class=&quot;math inline&quot;&gt;\(g[j][0]\)&lt;/span&gt; 之和与 &lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt; 的和。&lt;/p&gt;
&lt;p&gt;那转移方程就可以改写为 &lt;span class=&quot;math inline&quot;&gt;\(f[i][0]=\max(g[i][0]+f[son[i]][0],g[i][0]+f[son[i]][1])\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f[i][1]=g[i][1]+f[son[i]][0]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就可以放在线段树上维护矩阵了。&lt;br/&gt;即每个点维护一个 &lt;span class=&quot;math inline&quot;&gt;\(\quad\begin{matrix}g[i][0]&amp;amp;g[i][0]\\-\infty&amp;amp;g[i][1]\end{matrix}\)&lt;/span&gt;。然后在线段树上维护连乘积就好。&lt;/p&gt;
&lt;p&gt;还有一点就是修改的时候，要一直跳 &lt;span class=&quot;math inline&quot;&gt;\(top\)&lt;/span&gt;，可以这样理解：假设当前更改了点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的点权，那么就会改变 &lt;span class=&quot;math inline&quot;&gt;\(f[top[x]]\)&lt;/span&gt; 的值，紧接着就会影响 &lt;span class=&quot;math inline&quot;&gt;\(g[fa[top[x]]]\)&lt;/span&gt; 的值，所以我们要一直向上跳 &lt;span class=&quot;math inline&quot;&gt;\(top\)&lt;/span&gt; 修改才能维护好。&lt;/p&gt;
&lt;p&gt;最后放一下代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#pragma GCC optimize(2)
#include&amp;lt;bits/stdc++.h&amp;gt;
using std::min;
using std::max;
using std::swap;
using std::vector;
typedef double db;
typedef long long ll;
#define pb(A) push_back(A)
#define pii std::pair&amp;lt;int,int&amp;gt;
#define all(A) A.begin(),A.end()
#define mp(A,B) std::make_pair(A,B)
const int N=1e5+5;
const int inf=1e9;
#define ls x&amp;lt;&amp;lt;1
#define rs x&amp;lt;&amp;lt;1|1
#define lss ls,l,mid,ql,qr
#define rss rs,mid+1,r,ql,qr

int tot,dfn[N],top[N],end[N];
int n,m,v[N],sze[N],son[N],f[N][2];
int cnt,head[N],g[N][2],fa[N],fs[N];

struct Edge{
    int to,nxt;
}edge[N&amp;lt;&amp;lt;1];

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

struct Mat{
    int a[3][3];
    Mat(){memset(a,0xcf,sizeof a);}
    friend Mat operator*(Mat x,Mat y){
        Mat z;
        for(int i=1;i&amp;lt;=2;i++)
            for(int k=1;k&amp;lt;=2;k++)
                for(int j=1;j&amp;lt;=2;j++)
                    z.a[i][j]=max(x.a[i][k]+y.a[k][j],z.a[i][j]);
        return z;
    }
}sum[N&amp;lt;&amp;lt;2],val[N];

int getint(){
    int X=0,w=0;char ch=getchar();
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=X*10+ch-48,ch=getchar();
    if(w) return -X;return X;
}

void dfs(int now){
    sze[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(sze[to]) continue;
        fa[to]=now;dfs(to);
        sze[now]=sze[to];
        son[now]=sze[son[now]]&amp;gt;sze[to]?son[now]:to;
    }
}

void dfs(int now,int low){
    dfn[now]=++tot;top[now]=low;fs[tot]=now;
    if(son[now]) dfs(son[now],low);
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(dfn[to]) continue;
        dfs(to,to);
        g[now][0]+=max(f[to][0],f[to][1]);
        g[now][1]+=f[to][0];
    } if(son[now]) end[now]=end[son[now]];
    else end[now]=now;
    g[now][1]+=v[now];
    f[now][0]=g[now][0]+max(f[son[now]][0],f[son[now]][1]);
    f[now][1]=g[now][1]+f[son[now]][0];
}

void pushup(int x){
    sum[x]=sum[ls]*sum[rs];
}

void build(int x,int l,int r){
    if(l==r) return sum[x]=val[fs[l]],void();
    int mid=l+r&amp;gt;&amp;gt;1; build(ls,l,mid),build(rs,mid+1,r);
    pushup(x);
}

void init(){
    for(int i=1;i&amp;lt;=n;i++)
        val[i].a[1][1]=val[i].a[1][2]=g[i][0],val[i].a[2][1]=g[i][1],val[i].a[2][2]=-inf;
    build(1,1,n);
}

Mat query(int x,int l,int r,int ql,int qr){
    if(ql&amp;lt;=l and r&amp;lt;=qr) return sum[x];
    int mid=l+r&amp;gt;&amp;gt;1;
    if(qr&amp;lt;=mid) return query(lss);
    if(ql&amp;gt;mid) return query(rss);
    return query(lss)*query(rss);
}

Mat ask(int x){
    return query(1,1,n,dfn[top[x]],dfn[end[x]]);
}

void modify(int x,int l,int r,int ql,int qr){
    if(l==r) return sum[x]=val[fs[l]],void();
    int mid=l+r&amp;gt;&amp;gt;1;
    ql&amp;lt;=mid?modify(lss):modify(rss);
    pushup(x);
}

void change(int x,int y){
    val[x].a[2][1]+=y-v[x]; v[x]=y;
    Mat pre,nxt;
    while(x){
        pre=ask(x);
        modify(1,1,n,dfn[x],dfn[x]);
        nxt=ask(x);
        x=fa[top[x]];
        val[x].a[1][1]+=max(nxt.a[1][1],nxt.a[2][1])-max(pre.a[1][1],pre.a[2][1]);
        val[x].a[1][2]=val[x].a[1][1];
        val[x].a[2][1]+=nxt.a[1][1]-pre.a[1][1];
    }
}

signed main(){
    n=getint(),m=getint();
    for(int i=1;i&amp;lt;=n;i++) v[i]=getint();
    for(int i=1;i&amp;lt;n;i++){
        int x=getint(),y=getint();
        add(x,y),add(y,x);
    } dfs(1),dfs(1,1),init();
    while(m--){
        int x=getint(),y=getint();
        change(x,y);
        Mat ans=ask(1);
        printf(&quot;%d\n&quot;,max(ans.a[1][1],ans.a[2][1]));
    } return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后两道例题：&lt;/p&gt;
&lt;h2 id=&quot;bzoj4712-洪水&quot;&gt;BZOJ4712 洪水&lt;/h2&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;给出一棵树，点有点权。多次增加某个点的点权，并在某一棵子树中询问：选出若干个节点，使得每个叶子节点到根节点的路径上至少有一个节点被选择，求选出的点的点权和的最小值。&lt;/p&gt;
&lt;h3 id=&quot;sol&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;还是动态DP。&lt;/p&gt;
&lt;p&gt;先把DP式子列出来： &lt;span class=&quot;math inline&quot;&gt;\(f[i]=\min(a[i],\sum\limits_{j\in son[i]} f[j])\)&lt;/span&gt;，然后套路设 &lt;span class=&quot;math inline&quot;&gt;\(g[i]=\sum\limits_{j\in lightson[i]} f[j]\)&lt;/span&gt;，于是 &lt;span class=&quot;math inline&quot;&gt;\(f[i]=\min(a[i],g[i]+f[son[i]])\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;又可以写成矩阵相乘的形式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{matrix}f[son[i]]\\0\end{matrix}\times \begin{matrix}g[i]&amp;amp;a[i]\\\infty&amp;amp;0\end{matrix}=\begin{matrix}f[i]\\0\end{matrix} \]&lt;/span&gt;&lt;br/&gt;然后动态DP就行了。&lt;/p&gt;
&lt;p&gt;需要注意一点的是在 &lt;span class=&quot;math inline&quot;&gt;\(change\)&lt;/span&gt; 函数里，&lt;span class=&quot;math inline&quot;&gt;\(pre,nxt\)&lt;/span&gt; 的矩阵应该是 &lt;span class=&quot;math inline&quot;&gt;\(ask(top[x])\)&lt;/span&gt; 而不是 &lt;span class=&quot;math inline&quot;&gt;\(ask(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;noip2018-保卫王国&quot;&gt;NOIP2018 保卫王国&lt;/h2&gt;
&lt;h3 id=&quot;题意-1&quot;&gt;题意&lt;/h3&gt;
&lt;p&gt;给出一棵树，点有点权。每次强制选或不选两个节点，求最小权覆盖集。&lt;/p&gt;
&lt;h3 id=&quot;sol-1&quot;&gt;Sol&lt;/h3&gt;
&lt;p&gt;首先有个定理：最小权覆盖集=全集-最大权独立集。然后就是luogu模板题了。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Feb 2019 13:20:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<og:description>动态DP。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/10360291.html</dc:identifier>
</item>
</channel>
</rss>