<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java初学复习 - 燃子</title>
<link>http://www.cnblogs.com/304979850w/p/12657750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/304979850w/p/12657750.html</guid>
<description>&lt;p&gt;作为学Java的小白，忽然想看一看自己学了些什么东西，话不多说，&lt;span&gt;(这都是新手弄的总结)&lt;/span&gt;让我们看一看：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.我们要先了解Java&lt;/strong&gt;&lt;strong&gt;技术&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Java SE：标准版java技术的基础和核心&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Java EE：企业版提供了企业级应用开发的完整解决方案&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;JavaME：微型版&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;．开发Java三步程序&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1编写源程序&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2编译源程序&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3运行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;3.Java&lt;/strong&gt;&lt;strong&gt;程序的结构&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;public class HelloWorld  {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;public static void main(String[ ] args)  {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;System.out.println(&quot;Hello  World!!!&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;．System.out.println()和System.out.print()有什么区别&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   \n和\t有什么区别&lt;/p&gt;
&lt;p&gt;  有ln会自动换行&lt;/p&gt;
&lt;p&gt;\n&lt;strong&gt;将光标移动到下一行的第一格 ，\t将光标移到下一个水平制表位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;strong&gt;变量&lt;/strong&gt;：一个数据储存空间的表示&lt;/p&gt;
&lt;p&gt;  八大基本数据类型：byte short char int long float double boolean  &lt;/p&gt;
&lt;p&gt;  声明变量步骤：&lt;/p&gt;
&lt;p&gt;      声明变量 赋值 使用变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408082546494-553157800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;．自动类型转换规则&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;规则1：如果一个操作数为double型，则整个表达式可提升为double型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;规则2：满足自动类型转换的条件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;两种类型要兼容&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;数值类型（整型和浮点型）互相兼容&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;目标类型大于源类型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例如：double 型大于 int 型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;strong&gt;运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  赋值运算符（=）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;算术运算符（+、 – 、*、/、%）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;关系运算符（&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、 ==、 !=）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;逻辑运算符（&amp;amp;&amp;amp; 、 ||  、 !）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;三元运算符：&lt;strong&gt;变量=（表达式）？ value1：value2；&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;算术运算符&amp;gt;关系运算符&amp;gt;逻辑运算符&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;8.Scanner&lt;/strong&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
 Scanner input=new Scanner（System.in）；
&lt;/pre&gt;
&lt;p align=&quot;left&quot;&gt; 接受从键盘获取输入的信息&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;9.if&lt;/strong&gt;&lt;strong&gt;选择结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本if选择结构处理单一或组合条件的情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;if-else选择结构：处理简单的条件分支情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;多重if选择结构：处理复杂的条件分支情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;嵌套if选择结构：用于较为复杂的流程控制&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;10.&lt;/strong&gt;&lt;strong&gt;产生随机数的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    int random=(int)(Math.random()*10);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;11.switch&lt;/strong&gt;&lt;strong&gt;选择结构&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;多重分支并且条件判断是等值判断的情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;strong&gt;比较switch和多重if选择结构&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;相同点&lt;/p&gt;
&lt;p&gt;   都是用来处理多分支条件的结构&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不同点&lt;/p&gt;
&lt;p&gt;switch选择结构只能处理等值条件判断的情况&lt;/p&gt;
&lt;p&gt;多重if选择结构没有switch选择结构的限制，特别适合某个变量处于某个连续区间时的情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;13.while  do-while&lt;/strong&gt;&lt;strong&gt;循环结构的异同&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408082948207-422010155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;区别：语法不同&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      执行次序不同&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      初始情况不满足循环条件时，while循环一次都不会执行，do-while循环不管任何情况都至少执行一次。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;14.&lt;/strong&gt;&lt;strong&gt;程序调试&lt;/strong&gt;（找出缺陷原因，修正缺陷）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  分析错误，设置断点——启动调试——单步运行——观察变量——修正代码，重新运行——解决问题&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;15. for&lt;/strong&gt; &lt;strong&gt;循环&lt;/strong&gt;（循环次数确定的情况下）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408083049049-643646949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;先执行，后判断&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;16. break&lt;/strong&gt; &lt;strong&gt;和 continue 和return&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;使用场合&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;break常用于switch结构和循环结构中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;continue一般用于循环结构中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;作用（循环结构中）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;break语句终止某个循环，程序跳转到循环块外的下一条语句&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;continue跳出本次循环，进入下一次循环&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;return 结束当前循环&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;17.&lt;/strong&gt;&lt;strong&gt;程序逻辑结构&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  顺序结构：是一种线性、有序的结构&lt;/p&gt;
&lt;p&gt;  选择结构：是根据条件成立与否选择程序执行的路径&lt;/p&gt;
&lt;p&gt;  循环结构：是在一定条件下反复执行一个或几个语句&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;跳转语句：是改变程序执行路径的语句&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;18.&lt;/strong&gt;&lt;strong&gt;数组&lt;/strong&gt;（声明数组就是在内存空间划出一块合适的空间）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;是一个变量，储存相同数据类型的一组数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;排序：（Arrays.sort() ）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;基本元素：标识符&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          数组元素&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          元素下标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          元素类型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如何使用数组：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.声明数组&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.分配空间&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.赋值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  int [ ] score={.. , .. , ..};&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  int [ ] score=new int [ ]{.. , .. , ..};&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  int [ ] score=new int [..];&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4.处理数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;19.&lt;/strong&gt; &lt;strong&gt;二重循环&lt;/strong&gt;（一个循环体内又包含另一个完整的循环结构）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在二重循环中，外层循环变量变化一次，内层循环变量要从初始值到结束值变化一遍&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在二重循环中可以使用break、continue语句控制程序的执行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;break：跳出本层循环&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;continue：继续本层的下一轮循环&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;20.&lt;/strong&gt; &lt;strong&gt;类和对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系：类是对象的类型，对象是类的实例&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;类：是模子，定义对象将会拥有的特征（属性）和行为（方法）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    是抽象的概念，仅仅是模板&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    不同于int类型：具有方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;定义类的步骤：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          定义类名&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          编写类的属性&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;          编写类的方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对象：用来描述客观事物的一个实体，由一组属性和方法构成       &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      是一个你能够看得到、摸得着的实体&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;属性：对象具有的特征&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   方法：对象执行的操作&lt;/p&gt;
&lt;p&gt;封装：对象同时具有属性和方法两项特性&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对象的属性和方法通常被封装在一起，共同体现事物的特性， 二者相辅相承，不能分割。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;创建对象&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  类名 对象名=new 类名（）；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;引用对象成员：使用 . 进行操作&lt;/p&gt;
&lt;p&gt;引用类的属性：对象名.属性&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;引用类的方法：对象名.方法名()&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;21.&lt;/strong&gt; &lt;strong&gt;面向对象的优点&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   与人类思维一致&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  信息隐藏，提高了程序的可维护性和安全性&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   提高了程序的可重用性&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;22.&lt;/strong&gt;&lt;strong&gt;类的无参方法&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;定义类的方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;方法名称 返回值类型 方法主体&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408083157581-776370682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果方法具有返回值，方法中必须使用关键字return返回该值，返回值类型为该返回值的类型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果方法没有返回值，返回值类型为void&lt;/p&gt;
&lt;p&gt;方法调用：方法是个“黑匣子”，完成某个特定的应用程序功能，并返回结果&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行方法中包含的语句&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;同类中，直接使用  方法名（）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;不同类的方法中，先创建对象再使用 对象名.方法名（）；调用&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;方法之间允许相互调用，不需要知道方法的具体实现，实现重用，提高效率 &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;23.&lt;/strong&gt;&lt;strong&gt;成员变量和局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;作用域不同&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;局部变量的作用域仅限于定义它的方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;成员变量的作用域在整个类内部都是可见的&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;初始值不同&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Java会给成员变量一个初始值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Java不会给局部变量赋予初始值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在同一个方法中，不允许有同名局部变量，在不同方法中，可以有同名局部变量&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在同一个类中，成员变量和局部变量同名时，局部变量具有更高的优先级&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;24.&lt;/strong&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;单行注释：//&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;多行注释:/* */&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;文档注释:/** */&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;25. 带参方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;形参&lt;/strong&gt;是在定义方法时对参数的称呼&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;实参&lt;/strong&gt;是在调用方法时传递给方法的实际的值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 定义带参的方法：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408083304381-1364196520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;调用带参方法：（要求实参与形参要匹配）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1831227/202004/1831227-20200408083322423-620044466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;解决类的同名问题——包&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;创建包使用关键字package&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;导入包使用关键字import&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;允许类组成较小的单元（类似文件夹），易于找到和使用相应的文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;防止命名冲突&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;更好的保护类、属性和方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;命名规范：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   包名由小写字母组成，不能以圆点开头或结尾&lt;/p&gt;
&lt;p&gt;包名之前最好加上唯一的前缀，通常使用组织倒置的网络域名&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;包名后续部分依不同机构内部的规范不同而不同&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;26.&lt;/strong&gt; &lt;strong&gt;字符串&lt;/strong&gt;（String）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;长度：length( )；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;比较：equals( )&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   ==比较的是地址，equals比较的是值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;连接：1.使用“+”&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      2.使用concat(　)方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;提取：int　 indexOf(　)搜索第一个出现的字符&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;int lastIndexOf(　)搜索最后一个出现的字符&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;substring(int index)　提取从位置索引开始的字符串部分&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;substring(int beginindex　,　int endindex)提取之间的部分&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;trim(　)　前后不含空格&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;拆分：split(　)方法&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;替换：replace（　）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;27． &lt;/strong&gt; &lt;strong&gt;StringBuffer&lt;/strong&gt;&lt;strong&gt;：String增强版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对字符串频繁修改（如字符串连接）时，使用StringBuffer类可以大大提高程序执行效率&lt;/p&gt;
&lt;p&gt;创建StringBuffer对象&lt;/p&gt;
&lt;p&gt;　　　　StringBuffer sb = new StringBuffer();&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;StringBuffer sb = new StringBuffer(&quot;aaa&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;StringBuffer的使用&lt;/p&gt;
&lt;p&gt;sb.toString();        //转化为String类型&lt;/p&gt;
&lt;p&gt;sb.append(&quot;**&quot;);     //追加字符串&lt;/p&gt;
&lt;p&gt;sb.insert (1, &quot;**&quot;);    //插入字符串&lt;/p&gt;


&lt;p&gt;好了，以上就是总结，虽然不全也是可以看看的，笑哭&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 00:35:00 +0000</pubDate>
<dc:creator>燃子</dc:creator>
<og:description>作为学Java的小白，忽然想看一看自己学了些什么东西，话不多说，(这都是新手弄的总结)让我们看一看： 1.我们要先了解Java技术 Java SE：标准版java技术的基础和核心 Java EE：企业</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/304979850w/p/12657750.html</dc:identifier>
</item>
<item>
<title>还不懂 ConcurrentHashMap ？这份源码分析了解一下 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/12657736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/12657736.html</guid>
<description>&lt;p&gt;上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？&lt;/p&gt;
&lt;h2 id=&quot;1-concurrenthashmap-17&quot;&gt;1. ConcurrentHashMap 1.7&lt;/h2&gt;
&lt;h3 id=&quot;1-存储结构&quot;&gt;1. 存储结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200405151029416.png&quot; alt=&quot;Java 7 ConcurrentHashMap 存储结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦&lt;strong&gt;初始化就不能改变&lt;/strong&gt;，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。&lt;/p&gt;
&lt;h3 id=&quot;2-初始化&quot;&gt;2. 初始化&lt;/h3&gt;
&lt;p&gt;通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * Creates a new, empty map with a default initial capacity (16),
     * load factor (0.75) and concurrencyLevel (16).
     */
    public ConcurrentHashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 默认初始化容量
     */
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    /**
     * 默认负载因子
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * 默认并发级别
     */
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看下这个有参构造函数的内部实现逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SuppressWarnings(&quot;unchecked&quot;)
public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) {
    // 参数校验
    if (!(loadFactor &amp;gt; 0) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0)
        throw new IllegalArgumentException();
    // 校验并发级别大小，大于 1&amp;lt;&amp;lt;16，重置为 65536
    if (concurrencyLevel &amp;gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    // 2的多少次方
    int sshift = 0;
    int ssize = 1;
    // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值
    while (ssize &amp;lt; concurrencyLevel) {
        ++sshift;
        ssize &amp;lt;&amp;lt;= 1;
    }
    // 记录段偏移量
    this.segmentShift = 32 - sshift;
    // 记录段掩码
    this.segmentMask = ssize - 1;
    // 设置容量
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量
    int c = initialCapacity / ssize;
    if (c * ssize &amp;lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数
    while (cap &amp;lt; c)
        cap &amp;lt;&amp;lt;= 1;
    // create segments and segments[0]
    // 创建 Segment 数组，设置 segments[0]
    Segment&amp;lt;K,V&amp;gt; s0 = new Segment&amp;lt;K,V&amp;gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap]);
    Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下在 Java 7 中 ConcurrnetHashMap 的初始化逻辑。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;必要参数校验。&lt;/li&gt;
&lt;li&gt;校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无惨构造&lt;strong&gt;默认值是 16.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;寻找并发级别 concurrencyLevel 之上最近的 &lt;strong&gt;2 的幂次方&lt;/strong&gt;值，作为初始化容量大小，&lt;strong&gt;默认是 16&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;记录 segmentShift 偏移量，这个值为【容量 = 2 的N次方】中的 N，在后面 Put 时计算位置时会用到。&lt;strong&gt;默认是 32 - sshift = 28&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化 segments[0]&lt;/strong&gt;，&lt;strong&gt;默认大小为 2&lt;/strong&gt;，&lt;strong&gt;负载因子 0.75&lt;/strong&gt;，&lt;strong&gt;扩容阀值是 2*0.75=1.5&lt;/strong&gt;，插入第二个值时才会进行扩容。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3-put&quot;&gt;3. put&lt;/h3&gt;
&lt;p&gt;接着上面的初始化参数继续查看 put 方法源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * &amp;lt;p&amp;gt; The value can be retrieved by calling the &amp;lt;tt&amp;gt;get&amp;lt;/tt&amp;gt; method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;, or
 *         &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there was no mapping for &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;
 * @throws NullPointerException if the specified key or value is null
 */
public V put(K key, V value) {
    Segment&amp;lt;K,V&amp;gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算
    // 其实也就是把高4位与segmentMask（1111）做与运算
    int j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask;
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        // 如果查找到的 Segment 为空，初始化
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */
@SuppressWarnings(&quot;unchecked&quot;)
private Segment&amp;lt;K,V&amp;gt; ensureSegment(int k) {
    final Segment&amp;lt;K,V&amp;gt;[] ss = this.segments;
    long u = (k &amp;lt;&amp;lt; SSHIFT) + SBASE; // raw offset
    Segment&amp;lt;K,V&amp;gt; seg;
    // 判断 u 位置的 Segment 是否为null
    if ((seg = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {
        Segment&amp;lt;K,V&amp;gt; proto = ss[0]; // use segment 0 as prototype
        // 获取0号 segment 里的 HashEntry&amp;lt;K,V&amp;gt; 初始化长度
        int cap = proto.table.length;
        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的
        float lf = proto.loadFactor;
        // 计算扩容阀值
        int threshold = (int)(cap * lf);
        // 创建一个 cap 容量的 HashEntry 数组
        HashEntry&amp;lt;K,V&amp;gt;[] tab = (HashEntry&amp;lt;K,V&amp;gt;[])new HashEntry[cap];
        if ((seg = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck
            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作
            Segment&amp;lt;K,V&amp;gt; s = new Segment&amp;lt;K,V&amp;gt;(lf, threshold, tab);
            // 自旋检查 u 位置的 Segment 是否为null
            while ((seg = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                // 使用CAS 赋值，只会成功一次
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;计算要 put 的 key 的位置，获取指定位置的 Segment。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果指定位置的 Segment 为空，则初始化这个 Segment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化 Segment 流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查计算得到的位置的 Segment 是否为null.&lt;/li&gt;
&lt;li&gt;为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。&lt;/li&gt;
&lt;li&gt;再次检查计算得到的指定位置的 Segment 是否为null.&lt;/li&gt;
&lt;li&gt;使用创建的 HashEntry 数组初始化这个 Segment.&lt;/li&gt;
&lt;li&gt;自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Segment.put 插入 key,value 值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。
    HashEntry&amp;lt;K,V&amp;gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&amp;lt;K,V&amp;gt;[] tab = table;
        // 计算要put的数据位置
        int index = (tab.length - 1) &amp;amp; hash;
        // CAS 获取 index 坐标的值
        HashEntry&amp;lt;K,V&amp;gt; first = entryAt(tab, index);
        for (HashEntry&amp;lt;K,V&amp;gt; e = first;;) {
            if (e != null) {
                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;amp;&amp;amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, first);
                int c = count + 1;
                // 容量大于扩容阀值，小于最大容量，进行扩容
                if (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;tryLock() 获取锁，获取不到使用 &lt;strong&gt;&lt;code&gt;scanAndLockForPut&lt;/code&gt;&lt;/strong&gt; 方法继续获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。&lt;/p&gt;
&lt;p&gt;如果这个位置上的 &lt;strong&gt;HashEntry 不存在&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果当前容量大于扩容阀值，小于最大容量，&lt;strong&gt;进行扩容&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;直接头插法插入。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果这个位置上的 &lt;strong&gt;HashEntry 存在&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断链表当前元素 Key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值&lt;/li&gt;
&lt;li&gt;不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。
&lt;ol&gt;&lt;li&gt;如果当前容量大于扩容阀值，小于最大容量，&lt;strong&gt;进行扩容&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;直接链表头插法插入。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 &lt;code&gt;tryLock()&lt;/code&gt; 获取锁。当自旋次数大于指定次数时，使用 &lt;code&gt;lock()&lt;/code&gt; 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, int hash, V value) {
    HashEntry&amp;lt;K,V&amp;gt; first = entryForHash(this, hash);
    HashEntry&amp;lt;K,V&amp;gt; e = first;
    HashEntry&amp;lt;K,V&amp;gt; node = null;
    int retries = -1; // negative while locating node
    // 自旋获取锁
    while (!tryLock()) {
        HashEntry&amp;lt;K,V&amp;gt; f; // to recheck first below
        if (retries &amp;lt; 0) {
            if (e == null) {
                if (node == null) // speculatively create node
                    node = new HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, null);
                retries = 0;
            }
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        }
        else if (++retries &amp;gt; MAX_SCAN_RETRIES) {
            // 自旋达到指定次数后，阻塞等到只到获取到锁
            lock();
            break;
        }
        else if ((retries &amp;amp; 1) == 0 &amp;amp;&amp;amp;
                 (f = entryForHash(this, hash)) != first) {
            e = first = f; // re-traverse if entry changed
            retries = -1;
        }
    }
    return node;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-扩容-rehash&quot;&gt;4. 扩容 rehash&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表&lt;strong&gt;头插法&lt;/strong&gt;插入到指定位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void rehash(HashEntry&amp;lt;K,V&amp;gt; node) {
    HashEntry&amp;lt;K,V&amp;gt;[] oldTable = table;
    // 老容量
    int oldCapacity = oldTable.length;
    // 新容量，扩大两倍
    int newCapacity = oldCapacity &amp;lt;&amp;lt; 1;
    // 新的扩容阀值 
    threshold = (int)(newCapacity * loadFactor);
    // 创建新的数组
    HashEntry&amp;lt;K,V&amp;gt;[] newTable = (HashEntry&amp;lt;K,V&amp;gt;[]) new HashEntry[newCapacity];
    // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。
    int sizeMask = newCapacity - 1;
    for (int i = 0; i &amp;lt; oldCapacity ; i++) {
        // 遍历老数组
        HashEntry&amp;lt;K,V&amp;gt; e = oldTable[i];
        if (e != null) {
            HashEntry&amp;lt;K,V&amp;gt; next = e.next;
            // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。
            int idx = e.hash &amp;amp; sizeMask;
            if (next == null)   //  Single node on list
                // 如果当前位置还不是链表，只是一个元素，直接赋值
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                // 如果是链表了
                HashEntry&amp;lt;K,V&amp;gt; lastRun = e;
                int lastIdx = idx;
                // 新的位置只可能是不便或者是老的位置+老的容量。
                // 遍历结束后，lastRun 后面的元素位置都是相同的
                for (HashEntry&amp;lt;K,V&amp;gt; last = next; last != null; last = last.next) {
                    int k = last.hash &amp;amp; sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry&amp;lt;K,V&amp;gt; p = e; p != lastRun; p = p.next) {
                    // 遍历剩余元素，头插法到指定 k 位置。
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp;amp; sizeMask;
                    HashEntry&amp;lt;K,V&amp;gt; n = newTable[k];
                    newTable[k] = new HashEntry&amp;lt;K,V&amp;gt;(h, p.key, v, n);
                }
            }
        }
    }
    // 头插法插入新的节点
    int nodeIndex = node.hash &amp;amp; sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。&lt;/p&gt;
&lt;h3 id=&quot;5-get&quot;&gt;5. get&lt;/h3&gt;
&lt;p&gt;到这里就很简单了，get 方法只需要两步即可。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算得到 key 的存放位置。&lt;/li&gt;
&lt;li&gt;遍历指定位置查找相同 key 的 value 值。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V get(Object key) {
    Segment&amp;lt;K,V&amp;gt; s; // manually integrate access methods to reduce overhead
    HashEntry&amp;lt;K,V&amp;gt;[] tab;
    int h = hash(key);
    long u = (((h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask) &amp;lt;&amp;lt; SSHIFT) + SBASE;
    // 计算得到 key 的存放位置
    if ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;amp;&amp;amp;
        (tab = s.table) != null) {
        for (HashEntry&amp;lt;K,V&amp;gt; e = (HashEntry&amp;lt;K,V&amp;gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp;amp; h)) &amp;lt;&amp;lt; TSHIFT) + TBASE);
             e != null; e = e.next) {
            // 如果是链表，遍历查找到相同 key 的 value。
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;amp;&amp;amp; key.equals(k)))
                return e.value;
        }
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-concurrenthashmap-18&quot;&gt;2. ConcurrentHashMap 1.8&lt;/h2&gt;
&lt;h3 id=&quot;1-存储结构-2&quot;&gt;1. 存储结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/java8_concurrenthashmap.png&quot; alt=&quot;Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 &lt;strong&gt;Segment 数组 + HashEntry 数组 + 链表&lt;/strong&gt;，而是 &lt;strong&gt;Node 数组 + 链表 / 红黑树&lt;/strong&gt;。当冲突链表达到一定长度时，链表会转换成红黑树。&lt;/p&gt;
&lt;h3 id=&quot;2-初始化-inittable&quot;&gt;2. 初始化 initTable&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node&amp;lt;K,V&amp;gt;[] initTable() {
    Node&amp;lt;K,V&amp;gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        ／／　如果 sizeCtl &amp;lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。
        if ((sc = sizeCtl) &amp;lt; 0)
            // 让出 CPU 使用权
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];
                    table = tab = nt;
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中可以发现 ConcurrentHashMap 的初始化是通过&lt;strong&gt;自旋和 CAS&lt;/strong&gt; 操作完成的。里面需要注意的是变量 &lt;code&gt;sizeCtl&lt;/code&gt; ，它的值决定着当前的初始化状态。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;-1 说明正在初始化&lt;/li&gt;
&lt;li&gt;-N 说明有N-1个线程正在进行扩容&lt;/li&gt;
&lt;li&gt;表示 table 初始化大小，如果 table 没有初始化&lt;/li&gt;
&lt;li&gt;表示 table 容量，如果 table　已经初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3-put-2&quot;&gt;3. put&lt;/h3&gt;
&lt;p&gt;直接过一遍 put 源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    // key 和 value 不能为空
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        // f = 目标位置元素
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值
        if (tab == null || (n = tab.length) == 0)
            // 数组桶为空，初始化数组桶（自旋+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出
            if (casTabAt(tab, i, null,new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 使用 synchronized 加锁加入节点
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    // 说明是链表
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                        // 循环加入新的或者覆盖节点
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        // 红黑树
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据 key 计算出 hashcode 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断是否需要进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果当前位置的 &lt;code&gt;hashcode == MOVED == -1&lt;/code&gt;,则需要进行扩容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果都不满足，则利用 synchronized 锁写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果数量大于 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 则要转换为红黑树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;4-get&quot;&gt;4. get&lt;/h3&gt;
&lt;p&gt;get 流程比较简单，直接过一遍源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V get(Object key) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; int n, eh; K ek;
    // key 所在的 hash 位置
    int h = spread(key.hashCode());
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
        (e = tabAt(tab, (n - 1) &amp;amp; h)) != null) {
        // 如果指定位置元素存在，头结点hash值相同
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek)))
                // key hash 值相等，key值相同，直接返回元素 value
                return e.val;
        }
        else if (eh &amp;lt; 0)
            // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {
            // 是链表，遍历查找
            if (e.hash == h &amp;amp;&amp;amp;
                ((ek = e.key) == key || (ek != null &amp;amp;&amp;amp; key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下 get 过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据 hash 值计算位置。&lt;/li&gt;
&lt;li&gt;查找到指定位置，如果头节点就是要找的，直接返回它的 value.&lt;/li&gt;
&lt;li&gt;如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。&lt;/li&gt;
&lt;li&gt;如果是链表，遍历查找之。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;总的来说 ConcruuentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，&lt;/p&gt;
&lt;h2 id=&quot;3--总结&quot;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;Java7 中 ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。&lt;/p&gt;
&lt;p&gt;Java8 中的 ConcruuentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 &lt;strong&gt;Segment 数组 + HashEntry 数组 + 链表&lt;/strong&gt; 进化成了 &lt;strong&gt;Node 数组 + 链表 / 红黑树&lt;/strong&gt;，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。&lt;/p&gt;
&lt;p&gt;有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的&lt;strong&gt;锁升级&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.0503597122302&quot;&gt;
&lt;p&gt;如果你喜欢这篇文章，可以关注公众号，一起成长。回复 666 还有资料获取。&lt;br/&gt;我的网站：&lt;a href=&quot;https://www.wdbyte.com&quot;&gt;https://www.wdbyte.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/201911/1202902-20191126090837925-1632441965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 00:33:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 了，作为线程安全的HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/12657736.html</dc:identifier>
</item>
<item>
<title>无聊系列 - 教你怎么正确处理异常 - 冲杀</title>
<link>http://www.cnblogs.com/chongsha/p/12657724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chongsha/p/12657724.html</guid>
<description>&lt;p&gt;在工作中，常遇见乱处理Exception的情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要么吞掉异常，不打印任何日志；&lt;/li&gt;
&lt;li&gt;要么记录日志时，日志级别不对、或者把重要的出错堆栈信息干掉，在做生产问题排查时，简直让人抓狂。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我这篇博文，也是对记录的一个开源组件，对异常自行K掉，造成我排查耗费了好久的时间--。&lt;a href=&quot;https://www.cnblogs.com/chongsha/p/11931109.html&quot;&gt;https://www.cnblogs.com/chongsha/p/11931109.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们用一段代码对&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;进行举例，该代码是网上随便搜的，原作者请勿见怪。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * 加密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * 1.构造密钥生成器
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * 2.根据ecnodeRules规则初始化密钥生成器
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * 3.产生密钥
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * 4.创建和初始化密码器
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   * 5.内容加密
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   * 6.返回字符串
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String AESEncode(String encodeRules,String content){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.构造密钥生成器，指定为AES算法,不区分大小写&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.根据ecnodeRules规则初始化密钥生成器
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个128位的随机源,根据传入的字节数组&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             keygen.init(128, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecureRandom(encodeRules.getBytes()));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.产生原始对称密钥&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             SecretKey original_key=&lt;span&gt;keygen.generateKey();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.获得原始对称密钥的字节数组&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt; [] raw=&lt;span&gt;original_key.getEncoded();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.根据字节数组生成AES密钥&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             SecretKey key=&lt;span&gt;new&lt;/span&gt; SecretKeySpec(raw, &quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.根据指定算法AES自成密码器&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             Cipher cipher=Cipher.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            cipher.init(Cipher.ENCRYPT_MODE, key);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt; [] byte_encode=content.getBytes(&quot;utf-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.根据密码器的初始化方式--加密：将数据加密&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt; [] byte_AES=&lt;span&gt;cipher.doFinal(byte_encode);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.将加密后的数据转换为字符串
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里用Base64Encoder中会找不到包
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决办法：
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             String AES_encode=&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BASE64Encoder().encode(byte_AES));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;11.将字符串返回&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AES_encode;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchPaddingException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidKeyException e) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalBlockSizeException e) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BadPaddingException e) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有错就返加nulll&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;         
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该段代码主要的问题是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;吃掉了异常，因为是公共类，连日志记录都没有&lt;/li&gt;
&lt;li&gt;出现异常后，仍然返回了一个null值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个方法在我们平时使用时，如果不读源码，直接使用，第一直觉是，返回正确结果，如果不正确，那就会抛出异常。但是这段代码却返回了null，使用者遇到时，会抓狂，这是什么情况啊，为啥不对，明明没有报错，万般无奈，进代码一看。。。原来是把异常给干掉了。&lt;/p&gt;
&lt;p&gt;对此代码做出的改进建议是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在方法上声明throws是&lt;/li&gt;
&lt;li&gt;如果你觉得1方案不爽，可以直接一个大的catch Exception，然后throw new RuntimeException(e.getMessage(), e)；&lt;/li&gt;
&lt;li&gt;出错了就是出错了，不能把错误自己干掉，然后返回一个null。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;要么记录日志时，日志级别不对、或者把重要的出错堆栈信息干掉，在做生产问题排查时，简直让人抓狂。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在用log4j记录日志时，请正确使用logger.error()来记录日志，请注意该方法的重载，不要使用 Exception的getMessage()方法只记录异常的消息，而把异常的错误堆栈给抛弃，异常的错误堆栈是很有用的信息，会告诉你在哪行代码出错了，这样你可以快速的定位错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; a = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; b = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             System.out.println(b /&lt;span&gt; a);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码的错误堆栈信息：&lt;/p&gt;
&lt;p&gt;java.lang.ArithmeticException: / by zero&lt;br/&gt;at com.demo.Test.main(Test.java:10)&lt;/p&gt;
&lt;p&gt;这行错误信息&lt;strong&gt;at com.demo.Test.main(Test.java:10)&lt;/strong&gt;标明了出错位置，可以快速定位是在什么地方。所以在记录日志的时候，请不要把错误堆栈信息干掉了。&lt;/p&gt;

</description>
<pubDate>Wed, 08 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>冲杀</dc:creator>
<og:description>在工作中，常遇见乱处理Exception的情况： 要么吞掉异常，不打印任何日志； 要么记录日志时，日志级别不对、或者把重要的出错堆栈信息干掉，在做生产问题排查时，简直让人抓狂。 我这篇博文，也是对记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chongsha/p/12657724.html</dc:identifier>
</item>
<item>
<title>面试问我，创建多少个线程合适？我该怎么说 - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/12657701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/12657701.html</guid>
<description>&lt;p&gt;| &lt;strong&gt;如果好看，请给个赞&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081625926-1357855565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用多线程？&quot;&gt;为什么要使用多线程？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;防止并发编程出错最好的办法就是不写并发程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081626228-1546375759.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然多线程编程容易出错，为什么它还经久不衰呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A：那还用说，肯定在某些方面有特长呗，比如你知道的【它很快，非常快】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我也很赞同这个答案，但说的不够具体&lt;/p&gt;
&lt;h2 id=&quot;并发编程适用于什么场景？&quot;&gt;并发编程适用于什么场景？&lt;/h2&gt;
&lt;p&gt;如果问你选择多线程的原因就是一个【快】字，面试也就不会出那么多幺蛾子了。你有没有问过你自己&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;并发编程在所有场景下都是快的吗？&lt;/li&gt;
&lt;li&gt;知道它很快，何为快？怎样度量？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;想知道这两个问题的答案，我们需要一个从【定性】到【定量】的分析过程&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度（我感觉你还是啥也没说）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将这句话翻译到硬件级别就是要充分的利用 CPU 和 I/O 的利用率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081626609-1913685954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个正确得到保证，也就能达到最大化利用 CPU 和 I/O的目的了。最关键是，如何做到两个【正确】？&lt;/p&gt;
&lt;p&gt;在聊具体场景的时候，我们必须要拿出我们的专业性来。送你两个名词 buff 加成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 密集型程序&lt;/li&gt;
&lt;li&gt;I/O 密集型程序&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cpu-密集型程序&quot;&gt;CPU 密集型程序&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如我们要计算 1+2+....100亿 的总和，很明显，这就是一个 CPU 密集型程序&lt;/p&gt;
&lt;p&gt;在【单核】CPU下，如果我们创建 4 个线程来分段计算，即：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程1计算 &lt;code&gt;[1,25亿）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...... 以此类推&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程4计算 &lt;code&gt;[75亿，100亿]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们来看下图他们会发生什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081627115-2062930188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于是单核 CPU，所有线程都在等待 CPU 时间片。按照理想情况来看，四个线程执行的时间总和与一个线程5独自完成是相等的，实际上我们还忽略了四个线程上下文切换的开销&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时如果在 4 核CPU下，同样创建四个线程来分段计算，看看会发生什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081627622-1660033389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;io密集型程序&quot;&gt;I/O密集型程序&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态&lt;/p&gt;
&lt;p&gt;同样在单核 CPU 的情况下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081628359-1320446911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看出，每个线程都执行了相同长度的 CPU 耗时和 I/O 耗时，如果你将上面的图多画几个周期，CPU操作耗时固定，将 I/O 操作耗时变为 CPU 耗时的 3 倍，你会发现，CPU又有空闲了，这时你就可以新建线程 4，来继续最大化的利用 CPU。&lt;/p&gt;
&lt;p&gt;综上两种情况我们可以做出这样的总结：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，相信你已经知道第一个【正确】使用多线程的场景了，那创建多少个线程是正确的呢？&lt;/p&gt;
&lt;h2 id=&quot;创建多少个线程合适？&quot;&gt;创建多少个线程合适？&lt;/h2&gt;
&lt;p&gt;面试如果问到这个问题，这可是对你理论和实践的统考。想完全答对，你必须要【精通/精通/精通】&lt;strong&gt;小学算术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面知道，我们有 CPU 密集型和 I/O 密集型两个场景，不同的场景当然需要的线程数也就不一样了&lt;/p&gt;
&lt;h3 id=&quot;cpu-密集型程序创建多少个线程合适？&quot;&gt;CPU 密集型程序创建多少个线程合适？&lt;/h3&gt;
&lt;p&gt;有些同学早已经发现，对于 CPU 密集型来说，理论上 &lt;code&gt;线程数量 = CPU 核数（逻辑）&lt;/code&gt; 就可以了，但是实际上，数量一般会设置为 &lt;code&gt;CPU 核数（逻辑）+ 1&lt;/code&gt;， 为什么呢？&lt;/p&gt;
&lt;p&gt;《Java并发编程实战》这么说：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;计算密（CPU）集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以对于CPU密集型程序， &lt;code&gt;CPU 核数（逻辑）+ 1&lt;/code&gt; 个线程数是比较好的经验值的原因了&lt;/p&gt;
&lt;h3 id=&quot;io密集型程序创建多少个线程合适？&quot;&gt;I/O密集型程序创建多少个线程合适？&lt;/h3&gt;
&lt;p&gt;上面已经让大家按照图多画几个周期（你可以动手将I/O耗时与CPU耗时比例调大，比如6倍或7倍），这样你就会得到一个结论，对于 I/O 密集型程序：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最佳线程数 = &lt;code&gt;(1/CPU利用率)&lt;/code&gt; = &lt;code&gt;1 + (I/O耗时/CPU耗时)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这么体贴，当然担心有些同学不理解这个公式，我们将上图的比例手动带入到上面的公式中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081629234-1893627689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个CPU核心的最佳线程数，如果多个核心，那么 I/O 密集型程序的最佳线程数就是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最佳线程数 = &lt;code&gt;CPU核心数&lt;/code&gt; * &lt;code&gt;(1/CPU利用率)&lt;/code&gt; = &lt;code&gt;CPU核心数&lt;/code&gt; * &lt;code&gt;1 + (I/O耗时/CPU耗时)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说到这，有些同学可能有疑问了，要计算 I/O 密集型程序，是要知道 CPU 利用率的，如果我不知道这些，那要怎样给出一个初始值呢？&lt;/p&gt;
&lt;p&gt;按照上面公式，假如几乎全是 I/O耗时，所以纯理论你就可以说是 &lt;strong&gt;2N（N=CPU核数），当然也有说 2N + 1的&lt;/strong&gt;，（我猜这个 1 也是 backup），没有找到具体的推倒过程，在【并发编程实战-8.2章节】截图在此，大家有兴趣的可以自己看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081629584-1820856617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理论上来说，理论上来说，理论上来说&lt;/strong&gt;，这样就能达到 CPU 100% 的利用率&lt;/p&gt;
&lt;p&gt;如果理论都好用，那就用不着实践了，也就更不会有调优的事出现了。&lt;strong&gt;不过在初始阶段，我们确实可以按照这个理论之作为伪标准， 毕竟差也可能不会差太多，这样调优也会更好一些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;谈完理论，咱们说点实际的，公式我看懂了（定性阶段结束），但是我有两个疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我怎么知道具体的 I/O耗时和CPU耗时呢？&lt;/li&gt;
&lt;li&gt;怎么查看CPU利用率？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没错，我们需要定量分析了&lt;/p&gt;
&lt;p&gt;幸运的是，我们并不是第一个吃螃蟹的仔儿，其实有很多 APM （Application Performance Manager）工具可以帮我们得到准确的数据，学会使用这类工具，也就可以结合理论，在调优的过程得到更优的线程个数了。我这里简单列举几个，具体使用哪一个，具体应用还需要你自己去调研选择，受篇幅限制，暂不展开讨论了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SkyWalking&lt;/li&gt;
&lt;li&gt;CAT&lt;/li&gt;
&lt;li&gt;zipkin&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面了解了基本的理论知识，那面试有可能问什么？又可能会以怎样的方式提问呢？&lt;/p&gt;
&lt;h2 id=&quot;面试小问&quot;&gt;面试小问&lt;/h2&gt;
&lt;h3 id=&quot;小问一&quot;&gt;小问一&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如何设计线程个数，使得可以在1s内处理完20个Transaction？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081630138-2037074409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance&lt;/p&gt;
&lt;h3 id=&quot;小问二&quot;&gt;小问二&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不知道请拿三年级期末考试题重新做（今天晚自习留下来），答案是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程数 = 8 * (1 + 100/5) = 168 (个)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081630823-2038496281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样，这是没有考虑 CPU 数目，接下来就又是细节调优的阶段了&lt;/p&gt;
&lt;p&gt;因为一次请求不仅仅包括 CPU 和 I/O操作，具体的调优过程还要考虑内存资源，网络等具体内容&lt;/p&gt;
&lt;h2 id=&quot;增加-cpu-核数一定能解决问题吗？&quot;&gt;增加 CPU 核数一定能解决问题吗？&lt;/h2&gt;
&lt;p&gt;看到这，有些同学可能会认为，即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？&lt;/p&gt;
&lt;p&gt;在讲互斥锁的内容是，我故意遗留了一个知识:&lt;/p&gt;
&lt;h3 id=&quot;&quot;/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081631315-749914814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么理解这个公式呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202004/1583165-20200408081631657-1435692358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个结论告诉我们，假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。&lt;/p&gt;
&lt;p&gt;如何简单粗暴的理解串行百分比（其实都可以通过工具得出这个结果的）呢？来看个小 Tips：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt; 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在你应该理解我在讲解 synchronized 关键字时所说的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最小化临界区范围，因为临界区的大小往往就是瓶颈问题的所在，不要像乱用try catch那样一锅端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;多线程不一定就比但线程高效，比如大名鼎鼎的 Redis （后面会分析），因为它是基于内存操作，这种情况下，单线程可以很高效的利用CPU。而多线程的使用场景一般时存在相当比例的I/O或网络操作&lt;/p&gt;
&lt;p&gt;另外，结合小学数学题，我们已经了解了如何从定性到定量的分析的过程，在开始没有任何数据之前，我们可以使用上文提到的经验值作为一个伪标准，其次就是结合实际来逐步的调优（综合 CPU，内存，硬盘读写速度，网络状况等）了&lt;/p&gt;
&lt;p&gt;最后，盲目的增加 CPU 核数也不一定能解决我们的问题，这就要求我们严格的编写并发程序代码了&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们已经知道创建多少个线程合适了，为什么还要搞一个线程池出来？&lt;/li&gt;
&lt;li&gt;创建一个线程都要做哪些事情？为什么说频繁的创建线程开销很大？&lt;/li&gt;
&lt;li&gt;多线程通常要注意共享变量问题，为什么局部变量就没有线程安全问题呢？&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下一篇文章，我们就来说说，你熟悉又陌生的线程池问题&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 并发编程实战&lt;/li&gt;
&lt;li&gt;Java 并发编程之美&lt;/li&gt;
&lt;li&gt;码出高效&lt;/li&gt;
&lt;li&gt;Java 并发编程的艺术&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 08 Apr 2020 00:17:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>| 如果好看，请给个赞 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/12657701.html</dc:identifier>
</item>
<item>
<title>.Net 微服务架构技术栈的那些事 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12635845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12635845.html</guid>
<description>&lt;p&gt;大家一直都在谈论微服务架构，园子里面也有很多关于微服务的文章，前几天也有一些园子的朋友问我微服务架构的一些技术，我这里就整理了微服务架构的技术栈路线图，这里就分享出来和大家一起探讨学习，同时让新手对微服务相关技术有一个更深入的了解。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;229.42040397124&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;大家一直都在谈论微服务架构，园子里面也有很多关于微服务的文章，前几天也有一些园子的朋友问我微服务架构的一些技术，我这里就整理了微服务架构的技术栈路线图，这里就分享出来和大家一起探讨学习，同时让新手对微服务相关技术有一个更深入的了解。&lt;/p&gt;
&lt;h2 id=&quot;二、技术栈&quot;&gt;二、技术栈&lt;/h2&gt;
&lt;h3 id=&quot;21-工欲善其事，必先利其器&quot;&gt;2.1 工欲善其事，必先利其器&lt;/h3&gt;
&lt;p&gt;现在互联网盛行的年代，互联网产品也层出不穷，受欢迎的互联网产品都有一个比较牛的技术团队，我这里分享下.net 微服务架构技术栈图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200406223103730-527609758.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;俗话说得好：工欲善其事，必先利其器。一个优秀的工程师应该善于使用框架和工具，在微服务这一块的技术选型并非一蹴而就，需要经过日积月累和落地的项目才能完善。&lt;br/&gt;下文我会一一分享技术栈中的主要框架和工具的使用场景，这篇文章就不一一分享实战例子。&lt;/p&gt;
&lt;h3 id=&quot;22-微服务&quot;&gt;2.2 微服务&lt;/h3&gt;
&lt;h4 id=&quot;微服务如何微？&quot;&gt;微服务如何“微”？&lt;/h4&gt;
&lt;p&gt;微服务，当然核心是主题是“微”，怎么微呢？应该如何微呢？在我刚来杭州的时候接触过一个电商系统的&lt;code&gt;单体架构&lt;/code&gt;，系统比较庞大，结合了各种电商该拥有的业务逻辑和场景，&lt;br/&gt;代码也比较难于维护，前前后后接手的人也比较多，代码耦合度太高，改个业务逻辑基本上是牵一发而动全身，跟我上个月分享的关于&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12447081.html&quot;&gt;Asp.Net Core 中IdentityServer4 授权中心之应用实战&lt;/a&gt;的文章中的电商系统最初的架构图类似，如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200310110017008-1660735876.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;那针对这个架构就有可“微”之谈了。&lt;/p&gt;
&lt;p&gt;这里针对该&lt;code&gt;单体架构&lt;/code&gt;可以做如下几个原则上进行“微”服务:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据业务来进行拆分，一个业务一个服务原则进行拆分，做到通用性业务服务模块，这样业务之间可以做到高内聚低耦合。后面随意改动哪一块业务，只需要去改动这一块的业务微服务即可，其他业务不会受到影响。&lt;/li&gt;
&lt;li&gt;一个业务模块一个独立的数据库为原则，相互平行的业务做到不需要相互依赖调用。&lt;/li&gt;
&lt;li&gt;外层API网关进行业务逻辑的整合。&lt;/li&gt;
&lt;li&gt;一个业务数据库一个微服务为原则。&lt;/li&gt;
&lt;li&gt;结合分布式服务，可以快速版本迭代，发布平滑发布，不受时间影响，没时每刻都可以发布，无需半夜等到12点进行发布。（比较痛苦的发布，犹如三日凌空般(有点夸张)，曾经有段时间是每周都有那么几个晚上痛苦的发布，一发布就可能是凌晨4，5点，很多时候发布完，还要经过各种测试，最后发现问题还得线上改bug，我们回去的时候别的同事已经来上班了；当时我们的技术大佬说过这么一句话：“他连续一周都没看到过他的儿子，回去的时候，他儿子早就睡着了，起来上班的时候，他儿子已经去学校了”，大家一定也有过这样的发布经历。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照上面的原则后，原来的电商单体架构微服务后架构图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200407074529141-1774838093.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;架构图粗略的画了下，能够表明意思即可，微服务、&lt;code&gt;Docker&lt;/code&gt;、&lt;code&gt;k8s&lt;/code&gt;那一块简要的概括，没有详细画出具体的图。&lt;/p&gt;
&lt;h4 id=&quot;微服务集群&quot;&gt;微服务集群&lt;/h4&gt;
&lt;p&gt;微服务已经“微”好了，那需要一个服务发现的数据中心，这里就该用到&lt;code&gt;Consul&lt;/code&gt;了，&lt;code&gt;Consul&lt;/code&gt;主要用来注册服务，及服务发现，以及服务的健康检查，我们可以根据需要针对某些业务服务进行自动扩容，添加服务器及扩张服务集群，一台服务挂了，Consul会自动选择可用的服务节点进行连接使用，这样整体电商系统稳定性大大增大。&lt;br/&gt;需要了解&lt;code&gt;Consul&lt;/code&gt;更加详细的特性和搭建，可以点击&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12629934.html&quot;&gt;5分钟看懂微服务架构下的Consul 特性及搭建&lt;/a&gt; 一文阅读。&lt;/p&gt;
&lt;h4 id=&quot;微服务如何保证数据的一致性&quot;&gt;微服务如何保证数据的一致性&lt;/h4&gt;
&lt;p&gt;以前单体架构应用，对于业务之间的耦合是通过事务保证数据的一致性的，那对于微服务而言怎么做到数据的一致性呢？上门也说了，微服务应该做到业务之间没有依赖关系，每一个业务都是独立的一个服务，那这样怎么保证业务与之间的数据的一致性也存在很大的一个问题，也是业界对微服务争议比较大的一个话题，那到底该如何保证数据的一致性？&lt;/p&gt;
&lt;p&gt;在分布式系统架构中有一个&lt;code&gt;CAP理论&lt;/code&gt;：任何分布式系统只可同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）中的两点，没法三者兼顾。对于分布式系统来说，分区容错性是基本要求，否则就失去了价值。因此，就只能在可用性和一致性之间做出选择。如果选择提供一致性需要付出在满足一致性之前阻塞其他并发访问的代价。这可能持续一个不确定的时间，尤其是在系统已经表现出高延迟时或者网络故障导致失去连接时。依据目前的成功经验，可用性一般是更好的选择，但是在服务和数据库之间维护数据一致性是非常根本的需求，微服务架构中选择满足最终一致性。&lt;/p&gt;
&lt;p&gt;最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达到一致的状态。&lt;br/&gt;这里所说的一段时间，也要是用户可接受范围内的一段时间。&lt;/p&gt;
&lt;p&gt;从一致性的本质来看，就是在一个业务逻辑中包含的所有服务要么都成功，要么都失败。那我们又该如何选择方向，来保证成功还是保证失败呢？就是就需要根据业务模式做出选择。实现最终一致性有三种模式：可靠事件模式、业务补偿模式、TCC模式，这里就不再延伸，后面有机会再来分享学习。&lt;/p&gt;
&lt;h3 id=&quot;23-微服务开源框架&quot;&gt;2.3 微服务开源框架&lt;/h3&gt;
&lt;p&gt;我这里微服务架构使用的是开源微服务框架 &lt;code&gt;core-grpc&lt;/code&gt; 开源框架源代码地址：&lt;a href=&quot;https://github.com/overtly/core-grpc&quot;&gt;https://github.com/overtly/core-grpc&lt;/a&gt;&lt;br/&gt;前面我分享过一篇关于 &lt;a href=&quot;https://www.cnblogs.com/jlion/p/12491505.html&quot;&gt;【.net core】电商平台升级之微服务架构应用实战（core-grpc）&lt;/a&gt;&lt;br/&gt;中简单描述了微服务的基本概念和利弊，这里就不再分享，具体应用也可以点击&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12491505.html&quot;&gt;【.net core】电商平台升级之微服务架构应用实战（core-grpc）&lt;/a&gt; 阅读&lt;/p&gt;
&lt;h3 id=&quot;24-orm框架&quot;&gt;2.4 ORM框架&lt;/h3&gt;
&lt;p&gt;微服务中使用的ORM Dapper ，而使用的的第三方开源组件是&lt;code&gt;core-data&lt;/code&gt;，开源作者对dapper 进行了一次封装，开源框架源代码地址：&lt;a href=&quot;https://github.com/overtly/core-data&quot;&gt;https://github.com/overtly/core-data&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;core-data主要优势：&quot;&gt;&lt;code&gt;core-data&lt;/code&gt;主要优势：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;官方建议使用DDD 领域驱动设计思想开发&lt;/li&gt;
&lt;li&gt;支持多种数据库，简单配置添加链接的配置即可&lt;/li&gt;
&lt;li&gt;多数据库的支持&lt;/li&gt;
&lt;li&gt;支持分表操作，自定义分表策略的支持&lt;/li&gt;
&lt;li&gt;支持表达式方式编写，减少写Sql语句机械性工作&lt;/li&gt;
&lt;li&gt;可对Dapper 进行扩展&lt;/li&gt;
&lt;li&gt;性能依赖于Dapper 本身的性能，Dapper 本身是轻量级ORM ，官方测试性能都强于其他的ORM&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;25-分布式跟踪系统&quot;&gt;2.5 分布式跟踪系统&lt;/h3&gt;
&lt;p&gt;随着微服务架构的流行，一些微服务架构下的问题也会越来越突出，比如一个请求会涉及多个服务，而服务本身可能也会依赖其他服务，整个请求路径就构成了一个网状的调用链，而在整个调用链中一旦某个节点发生异常，整个调用链的稳定性就会受到影响，所以会深深的感受到 “银弹” 这个词是不存在的，每种架构都有其优缺点 。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200405163431213-989808954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对以上情况， 我们就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这时候 APM（应用性能管理）工具就该闪亮登场了。&lt;br/&gt;目前主要的一些 APM 工具有: Cat、Zipkin、Pinpoint、SkyWalking，这里主要介绍 SkyWalking ，它是一款优秀的国产 APM 工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。&lt;/p&gt;
&lt;h4 id=&quot;26-系统日志集成&quot;&gt;2.6 系统日志集成&lt;/h4&gt;
&lt;p&gt;庞大的系统中离不开日志系统，排查问题，记录相关敏感信息等都需要一个日志系统，这里选择使用ExceptionLess 日志系统，日志写入到ES中，并支持可视化UI进行日志管理，查询，平常遇到问题，直接通过日志管理后台进行排查。&lt;/p&gt;
&lt;h3 id=&quot;27-消息队列&quot;&gt;2.7 消息队列&lt;/h3&gt;
&lt;p&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能、高可用、可伸缩和最终一致性架构。使用较多的消息队列有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ。&lt;/p&gt;
&lt;h3 id=&quot;28-任务调度&quot;&gt;2.8 任务调度&lt;/h3&gt;
&lt;p&gt;这里主要使用的是Quartz.Net 进行作业任务调度，任务调用有什么用处呢？，比如我们需要统计一个数据，但是实时统计需要一大堆的连表查询，并且比较损耗数据库的性能，因此可以选择使用任务调度的方案进行数据统计作业，半夜某个时间点去统计前一天的数据。&lt;/p&gt;
&lt;h3 id=&quot;29-nosql&quot;&gt;2.9 NoSql&lt;/h3&gt;
&lt;p&gt;Nosql 主要是非关系型数据库，比如MongDB、 Redis、Memcache等，可以用来在API网关和数据库层面做一层数据缓存，访问一些不是经常更新的数据，把它缓存起来，每次网络请求过来就可以先通过从分布式缓存中进行数据读取，减少对数据库的查询压力，提高系统的吞吐量。&lt;/p&gt;
&lt;h3 id=&quot;210-可视化数据管理及分析（kibana）&quot;&gt;2.10 可视化数据管理及分析（Kibana）&lt;/h3&gt;
&lt;p&gt;Kibana 是为 Elasticsearch设计的开源分析和可视化平台。你可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互。你可以很容易实现高级的数据分析和可视化，以图标的形式展现出来。&lt;br/&gt;Kibana 的使用场景，应该集中在两方面：&lt;/p&gt;
&lt;p&gt;实时监控&lt;br/&gt;通过 histogram 面板，配合不同条件的多个 queries 可以对一个事件走很多个维度组合出不同的时间序列走势。时间序列数据是最常见的监控报警了。&lt;br/&gt;问题分析&lt;/p&gt;
&lt;p&gt;关于 elk 的用途，可以参照其对应的商业产品 splunk 的场景：使用 Splunk 的意义在于使信息收集和处理智能化。而其操作智能化表现在：&lt;br/&gt;搜索，通过下钻数据排查问题，通过分析根本原因来解决问题；&lt;br/&gt;实时可见性，可以将对系统的检测和警报结合在一起，便于跟踪 SLA 和性能问题；&lt;br/&gt;历史分析，可以从中找出趋势和历史模式，行为基线和阈值，生成一致性报告。&lt;/p&gt;
&lt;h3 id=&quot;211-prometheus&quot;&gt;2.11 Prometheus&lt;/h3&gt;
&lt;p&gt;Prometheus是一套开源的系统监控报警框架。Prometheus作为新一代的云原生监控系统，相比传统监控监控系统（Nagios或者Zabbix）拥有如下优点。&lt;/p&gt;
&lt;h5 id=&quot;优势&quot;&gt;优势&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;易于管理&lt;/li&gt;
&lt;li&gt;轻易获取服务内部状态&lt;/li&gt;
&lt;li&gt;高效灵活的查询语句&lt;/li&gt;
&lt;li&gt;支持本地和远程存储&lt;/li&gt;
&lt;li&gt;采用http协议，默认pull模式拉取数据，也可以通过中间网关push数据&lt;/li&gt;
&lt;li&gt;支持自动发现&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;li&gt;易集成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了到了这里，大多已经介绍完了，其他几个大家都是比较常见常使用的技术，就不一一介绍了。&lt;/p&gt;
&lt;h3 id=&quot;212-net-core-虚拟化&quot;&gt;2.12 .Net Core 虚拟化&lt;/h3&gt;
&lt;p&gt;.Net Core 新一代的.Net Core 跨平台开发框架，可以脱离windows 环境，搭建在linux等平台上，那怎样搭建呢？当然可以使用当前比较流行的Docker容器，把.net core 项目虚拟化 搭建在Docker 容器中运行，不依赖于任何平台和环境，只需要通过命令制作好镜像即可，同时也可以借助&lt;code&gt;K8s&lt;/code&gt;来进行多容器应用部署、编排、更新等。&lt;/p&gt;
&lt;h4 id=&quot;什么是k8s呢？&quot;&gt;什么是k8s呢？&lt;/h4&gt;
&lt;p&gt;Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。&lt;/p&gt;
&lt;p&gt;Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。&lt;/p&gt;
&lt;p&gt;现在Kubernetes着重于不间断的服务状态（比如web服务器或者缓存服务器）和原生云平台应用（Nosql）,在不久的将来会支持各种生产云平台中的各种服务，例如，分批，工作流，以及传统数据库。&lt;/p&gt;
&lt;p&gt;在Kubenetes中，所有的容器均在Pod中运行,一个Pod可以承载一个或者多个相关的容器，在后边的案例中，同一个Pod中的容器会部署在同一个物理机器上并且能够共享资源。一个Pod也可以包含O个或者多个磁盘卷组（volumes）,这些卷组将会以目录的形式提供给一个容器，或者被所有Pod中的容器共享，对于用户创建的每个Pod,系统会自动选择那个健康并且有足够容量的机器，然后创建类似容器的容器,当容器创建失败的时候，容器会被node agent自动的重启,这个node agent叫kubelet,但是，如果是Pod失败或者机器，它不会自动的转移并且启动，除非用户定义了 replication controller。&lt;/p&gt;
&lt;p&gt;用户可以自己创建并管理Pod,Kubernetes将这些操作简化为两个操作：基于相同的Pod配置文件部署多个Pod复制品；创建可替代的Pod当一个Pod挂了或者机器挂了的时候。而Kubernetes API中负责来重新启动，迁移等行为的部分叫做“replication controller”，它根据一个模板生成了一个Pod,然后系统就根据用户的需求创建了许多冗余，这些冗余的Pod组成了一个整个应用，或者服务，或者服务中的一层。一旦一个Pod被创建，系统就会不停的监控Pod的健康情况以及Pod所在主机的健康情况，如果这个Pod因为软件原因挂掉了或者所在的机器挂掉了，replication controller 会自动在一个健康的机器上创建一个一摸一样的Pod,来维持原来的Pod冗余状态不变，一个应用的多个Pod可以共享一个机器。&lt;/p&gt;
&lt;p&gt;我们经常需要选中一组Pod，例如，我们要限制一组Pod的某些操作，或者查询某组Pod的状态，作为Kubernetes的基本机制，用户可以给Kubernetes Api中的任何对象贴上一组 key:value的标签，然后，我们就可以通过标签来选择一组相关的Kubernetes Api 对象，然后去执行一些特定的操作，每个资源额外拥有一组（很多） keys 和 values,然后外部的工具可以使用这些keys和vlues值进行对象的检索，这些Map叫做annotations（注释）。&lt;/p&gt;
&lt;p&gt;Kubernetes支持一种特殊的网络模型，Kubernetes创建了一个地址空间，并且不动态的分配端口，它可以允许用户选择任何想使用的端口，为了实现这个功能，它为每个Pod分配IP地址。&lt;/p&gt;
&lt;p&gt;现代互联网应用一般都会包含多层服务构成，比如web前台空间与用来存储键值对的内存服务器以及对应的存储服务，为了更好的服务于这样的架构，Kubernetes提供了服务的抽象，并提供了固定的IP地址和DNS名称，而这些与一系列Pod进行动态关联，这些都通过之前提到的标签进行关联，所以我们可以关联任何我们想关联的Pod，当一个Pod中的容器访问这个地址的时候，这个请求会被转发到本地代理（kube proxy）,每台机器上均有一个本地代理，然后被转发到相应的后端容器。Kubernetes通过一种轮训机制选择相应的后端容器，这些动态的Pod被替换的时候,Kube proxy时刻追踪着，所以，服务的 IP地址（dns名称），从来不变。&lt;/p&gt;
&lt;p&gt;所有Kubernetes中的资源，比如Pod,都通过一个叫URI的东西来区分，这个URI有一个UID,URI的重要组成部分是：对象的类型（比如pod），对象的名字，对象的命名空间，对于特殊的对象类型，在同一个命名空间内，所有的名字都是不同的，在对象只提供名称，不提供命名空间的情况下，这种情况是假定是默认的命名空间。UID是时间和空间上的唯一。&lt;/p&gt;
&lt;h3 id=&quot;213-自动化集成部署&quot;&gt;2.13 自动化集成部署&lt;/h3&gt;
&lt;h4 id=&quot;为什么需要自动化集成部署？&quot;&gt;为什么需要自动化集成部署？&lt;/h4&gt;
&lt;p&gt;我从以下几点来分析为什么需要自动化集成部署：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你要相信的是所有的人工部署、发布、更新都是不可靠的，自动化智能部署可以减少事故率。&lt;/li&gt;
&lt;li&gt;人为备份、发布更新都是效率非常低的。&lt;/li&gt;
&lt;li&gt;如果某个项目需要更新，但是这个微服务有十几台负载，那你人为一台一台服务器更新发布是不是很繁琐，更加容易出事故呢？&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;什么是自动化集成部署？&quot;&gt;什么是自动化集成部署？&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;jenkins&lt;/code&gt;、&lt;code&gt;gitlab&lt;/code&gt;、&lt;code&gt;docker&lt;/code&gt;等工具，以及依赖事先写好的脚本监听代码提交动态、自动化构造项目镜像、推送镜像到镜像仓库、Docker 拉起镜像、启动项目等系列自动化脚本处理，可以平滑的一台一台服务停止并且更新；一切操作无需人为的干预，甚至出现问题可以一键回滚操作。&lt;/p&gt;
&lt;h4 id=&quot;自动化集成部署有哪些优势&quot;&gt;自动化集成部署有哪些优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;一切自动化，无需人为干预，提高效率，专业的人做专业的事情，开发做好开发的事情即可，运维做好运维的事情。&lt;/li&gt;
&lt;li&gt;发布可追溯&lt;/li&gt;
&lt;li&gt;随时人为干预回滚（通过脚本回顾上一步自动化备份的项目镜像）&lt;/li&gt;
&lt;li&gt;平滑发布，不影响用户体验，一台一台服务器切断，发布更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、结束语&quot;&gt;三、结束语&lt;/h2&gt;
&lt;p&gt;今天写的有点多了，画了一张图就停不下来了，本文分析了.net core 微服务架构中用到的系列技术使用场景和用途，没有一点实战性东西，目的是让小白有一个明确的技术方向，进一步掌握微服务架构相关的技术；也让自己对以往的经验进行梳理和总结，这样才能朝着更大的目标前进。后面我会持续给大家带来更多的干货和实战性东西，欢迎关注【dotNET博士】微信公众号&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 07 Apr 2020 23:04:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>大家一直都在谈论微服务架构，园子里面也有很多关于微服务的文章，前几天也有一些园子的朋友问我微服务架构的一些技术，我这里就整理了微服务架构的技术栈路线图，这里就分享出来和大家一起探讨学习，同时让新手对微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12635845.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExcutor 原理探究 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/12467720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/12467720.html</guid>
<description>&lt;p&gt;线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络 sockets 等的数量。 例如，线程数一般取 cpu 数量 +2 比较合适，线程数过多会导致额外的线程切换开销。&lt;/p&gt;
&lt;p&gt;Java 中的线程池是用 ThreadPoolExecutor 类来实现的. 本文就对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。&lt;/p&gt;
&lt;p&gt;先看一下线程池的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/QQ20170331-004227.png&quot; alt=&quot;线程池的类图&quot; width=&quot;611&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图的目的主要是为了让大家知道线程池相关类之间的关系，至少赚个眼熟，以后看到不会有害怕的感觉。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;Executor 框架接口&lt;/h3&gt;
&lt;p&gt;Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架，目的是提供一种将”任务提交”与”任务如何运行”分离开来的机制。&lt;/p&gt;
&lt;p&gt;下面是 ThreadPoolExeCutor 类图。Executors 其实是一个工具类，里面提供了好多静态方法，这些方法根据用户选择返回不同的线程实例。&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/916005/202003/916005-20200314182152170-610419378.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图也可以看出来，ThreadPoolExeCutor 是线程池的核心。&lt;/p&gt;
&lt;p&gt;J.U.C 中有三个 Executor 接口：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Executor&lt;/strong&gt;：一个运行新任务的简单接口；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ExecutorService&lt;/strong&gt;：扩展了 Executor 接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ScheduledExecutorService&lt;/strong&gt;：扩展了 ExecutorService。支持 Future 和定期执行任务。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实通过这些接口就可以看到一些设计思想，每个接口的名字和其任务是完全匹配的。不会因为 Executor 中只有一个方法，就将其放到其他接口中。这也是很重要的单一原则。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;在去具体分析 ThreadPoolExeCutor 运行逻辑前，先看下面的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202003/916005-20200318232011542-502556595.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该图是 ThreadPoolExeCutor 整个运行过程的一个概括，整个源码的核心逻辑总结起来就是：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建线程：&lt;/strong&gt;要知道如何去创建线程，控制线程数量，线程的存活与销毁；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加任务：&lt;/strong&gt;任务添加后如何处理，是立刻执行，还是先保存；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;执行任务：&lt;/strong&gt;如何获取任务，任务执行失败后如何处理？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面将进入源码分析，来深入理解 ThreadPoolExeCutor 的设计思想。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;先来看构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
            keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();&lt;br/&gt;　　　　　&lt;span&gt;// 注意 workQueue, threadFactory, handler 是不可以为null 的，为空会直接抛出错误
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;corePoolSize 核心线程数&lt;/span&gt;：&lt;/strong&gt;表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到 corePoolSize，则会创建新的线程来执行所提交的任务，即使当前核心线程池有空闲的线程。如果当前核心线程池的线程个数已经达到了corePoolSize，则不再重新创建线程。如果调用了 &lt;code&gt;prestartCoreThread() &lt;/code&gt;或者 &lt;code&gt;prestartAllCoreThreads()&lt;/code&gt;，线程池创建的时候所有的核心线程都会被创建并且启动。若 corePoolSize == 0，则任务执行完之后，没有任何请求进入时，销毁线程池的线程。若 corePoolSize &amp;gt; 0，即使本地任务执行完毕，核心线程也不会被销毁。corePoolSize 其实可以理解为可保留的空闲线程数。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;maximumPoolSize：&lt;/strong&gt;&lt;/span&gt; 表示线程池能够容纳同时执行的最大线程数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过 maximumPoolSize 的话，就会创建新的线程来执行任务。注意 maximumPoolSize &amp;gt;= 1 必须大于等于 1。maximumPoolSize == corePoolSize ，即是固定大小线程池。&lt;strong&gt;实际上最大容量是由 CAPACITY 控制&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;keepAliveTime：&lt;/strong&gt;&lt;/span&gt; 线程空闲时间。当空闲时间达到 keepAliveTime值时，线程会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存和句柄资源。默认情况，当线程池的线程数 &amp;gt; corePoolSize 时，keepAliveTime 才会起作用。但当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 变量设置为 true 时，核心线程超时后会被回收。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;unit&lt;/span&gt;：&lt;/strong&gt;时间单位。为 keepAliveTime 指定时间单位。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;workQueue&lt;/strong&gt;&lt;/span&gt; 缓存队列。当请求的线程数 &amp;gt; maximumPoolSize时，线程进入 BlockingQueue 阻塞队列。可以使用 ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;threadFactory&lt;/span&gt; &lt;/strong&gt;创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，也方便查找问题原因。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;handler&lt;/strong&gt;&lt;/span&gt; 执行拒绝策略的对象。当线程池的阻塞队列已满和指定的线程都已经开启，说明当前线程池已经处于饱和状态了，那么就需要采用一种策略来处理这种情况。采用的策略有这几种：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;89&quot;&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;AbortPolicy&lt;/span&gt;： 直接拒绝所提交的任务，并抛出 &lt;strong&gt;RejectedExecutionException &lt;/strong&gt;异常；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;CallerRunsPolicy&lt;/span&gt;：只用调用者所在的线程来执行任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DiscardPolicy&lt;/span&gt;：不处理直接丢弃掉任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DiscardOldestPolicy&lt;/span&gt;：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;属性定义&lt;/h3&gt;
&lt;p&gt;看完构造函数之后，再来看下该类里面的变量，有助于进一步理解整个代码运行逻辑，下面是一些比较重要的变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// &lt;/span&gt;&lt;span&gt;用来标记线程池状态（高3位），线程个数（低29位）
&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;默认是 RUNNING 状态，线程个数为0&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;线程个数掩码位数，整型最大位数-3，可以适用于不同平台&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COUNT_BITS = Integer.SIZE - 3&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程最大个数(低29位)00011111111111111111111111111111&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：11100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：00000000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：00100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：01000000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：01100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取高三位 运行状态&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runStateOf(&lt;span&gt;int&lt;/span&gt; c)     { &lt;span&gt;return&lt;/span&gt; c &amp;amp; ~&lt;span&gt;CAPACITY; }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取低29位 线程个数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt; c)  { &lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算ctl新值，线程状态 与 线程个数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ctlOf(&lt;span&gt;int&lt;/span&gt; rs, &lt;span&gt;int&lt;/span&gt; wc) { &lt;span&gt;return&lt;/span&gt; rs | wc; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要对一些操作做些解释。 &lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Integer.SIZE：&lt;/strong&gt;&lt;/span&gt;对于不同平台，其位数不一样，目前常见的是 32 位；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1 &amp;lt;&amp;lt; COUNT_BIT&lt;/strong&gt;&lt;strong&gt;S) -&lt;/strong&gt; &lt;strong&gt;1：&lt;/strong&gt;&lt;/span&gt;首先是将 1 左移 COUNT_BITS 位，也就是第 COUNT_BITS + 1 位是1，其余都是 0；-1 操作则是将后面前面的 COUNT_BITS 位都变成 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-1 &amp;lt;&amp;lt; COUNT_BITS：&lt;/strong&gt;&lt;/span&gt;-1 的原码是 10000000 00000000 00000000 00000001 ，反码是 111111111 11111111 11111111 11111110 ，补码 +1，然后左移 29 位是 11100000 00000000 00000000 00000000；这里转为十进制是负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;~CAPACITY&lt;/span&gt; ：&lt;/strong&gt;取反，最高三位是1；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：这里巧妙利用 bit 操作来将线程数量和运行状态联系在一起，减少了变量的存在和内存的占用。其中五种状态的十进制排序：&lt;strong&gt;&lt;span&gt;RUNNING &amp;lt; SHUTDOWN &amp;lt; STOP &amp;lt; TIDYING &amp;lt; TERMINATED&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;线程池状态&lt;/h3&gt;
&lt;div&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程池状态含义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RUNNING：&lt;/span&gt;&lt;/strong&gt;接受新任务并且处理阻塞队列里的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SHUTDOWN：&lt;/span&gt;&lt;/strong&gt;拒绝新任务但是处理阻塞队列里的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;STOP：&lt;/strong&gt;&lt;/span&gt;拒绝新任务并且抛弃阻塞队列里的任务同时会中断正在处理的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;TIDYING：&lt;/span&gt;&lt;/strong&gt;所有任务都执行完（包含阻塞队列里面任务）当前线程池活动线程为 0，将要调用 terminated 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;TERMINATED：&lt;/span&gt;&lt;/strong&gt;终止状态。terminated 方法调用完成以后的状态；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程池状态转换：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;RUNNING -&amp;gt; SHUTDOWN：&lt;/span&gt;&lt;/strong&gt;显式调用 shutdown() 方法，或者隐式调用了 finalize()，它里面调用了shutdown（）方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RUNNING or SHUTDOWN)-&amp;gt; STOP：&lt;/strong&gt;&lt;/span&gt;显式 shutdownNow() 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SHUTDOWN -&amp;gt; TIDYING：&lt;/strong&gt;&lt;/span&gt;当线程池和任务队列都为空的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;STOP -&amp;gt; TIDYING：&lt;/strong&gt;&lt;/span&gt;当线程池为空的时候；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TIDYING -&amp;gt; TERMINATED：&lt;/strong&gt;&lt;/span&gt;当 terminated() hook 方法执行完成时候；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;h3&gt; 原码，反码，补码知识小剧场：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 原码：&lt;/strong&gt;&lt;/span&gt;原码就是符号位加上真值的绝对值, 即用第一位表示符号,其余位表示值. 比如如果是 8 位二进制:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[+1]&lt;sub&gt;原&lt;/sub&gt; = 0000 0001&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[-1]&lt;sub&gt;原&lt;/sub&gt; = 1000 0001&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;负数原码第一位是符号位. &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 反码：&lt;/strong&gt;&lt;/span&gt;反码的表示方法是，正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[+1] = [0000 0001]&lt;sub&gt;原&lt;/sub&gt; = [0000 0001]&lt;sub&gt;反&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[-1] = [1000 0001]&lt;sub&gt;原&lt;/sub&gt; = [1111 1110]&lt;sub&gt;反&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 补码：&lt;/strong&gt;&lt;/span&gt;补码的表示方法是，正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. (即在反码的基础上 +1)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[+1] = [0000 0001]&lt;sub&gt;原&lt;/sub&gt; = [0000 0001]&lt;sub&gt;反&lt;/sub&gt; = [0000 0001]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[-1] = [1000 0001]&lt;sub&gt;原&lt;/sub&gt; = [1111 1110]&lt;sub&gt;反&lt;/sub&gt; = [1111 1111]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. 总结&lt;br/&gt;在知道一个数原码的情况下:&lt;br/&gt;正数：&lt;span&gt;&lt;strong&gt;反码，补码 就是本身自己&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;负数：&lt;span&gt;&lt;strong&gt;反码是高位符号位不变，其余位取反。补码：反码+1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5. 左移：&lt;/strong&gt;&lt;/span&gt;当数值左、右移时，先将数值转化为其补码形式，移完后，再转换成对应的原码&lt;/p&gt;
&lt;p&gt;     左移：高位丢弃，低位补零&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [+1]  = [00000001]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [0000 0001]&lt;sub&gt;补&lt;/sub&gt; &amp;lt;&amp;lt; 1 = [0000 0010]&lt;sub&gt;补&lt;/sub&gt; = [0000 0010]&lt;sub&gt;原&lt;/sub&gt; = [+2]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [-1]  = [1000 0001]&lt;sub&gt;原&lt;/sub&gt; = [1111 1111]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [1111 1111]&lt;sub&gt;补&lt;/sub&gt; &amp;lt;&amp;lt; 1 = [1111 1110]&lt;sub&gt;补&lt;/sub&gt; = [1000 0010]&lt;sub&gt;原&lt;/sub&gt; = [-2]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，再次提醒，负数的补码是反码+1；负数的反码是补码-1；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 6. 右移：&lt;/strong&gt;&lt;/span&gt;高位保持不变，低位丢弃&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;   [+127] = [0111 1111]&lt;sub&gt;原&lt;/sub&gt; = [0111 1111]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [0111 1111]补 &amp;gt;&amp;gt; 1 = [0011 1111]&lt;sub&gt;补&lt;/sub&gt; = [0011 1111]&lt;sub&gt;原&lt;/sub&gt; = [+63]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [-127] = [1111 1111]&lt;sub&gt;原&lt;/sub&gt; = [1000 0001]&lt;sub&gt;补&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     [1000 0001]&lt;sub&gt;补&lt;/sub&gt; &amp;gt;&amp;gt; 1 = [1100 0000]&lt;sub&gt;补&lt;/sub&gt; = [1100 0000]&lt;sub&gt;原 &lt;/sub&gt;= [-64]&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;execute 方法分析&lt;/h2&gt;
&lt;p&gt;通过 ThreadPoolExecutor 创建线程池后，提交任务后执行过程是怎样的，下面来通过源码来看一看。execute 方法源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回包含线程数及线程池状态（头3位）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果工作线程数小于核心线程数，则创建线程任务执行&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果创建失败，防止外部已经在线程池中加入新任务，重新获取&lt;/span&gt;
        c =&lt;span&gt; ctl.get();
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有线程池处于 RUNNING 状态，且 入队列成功&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {
&lt;span&gt;    　　// 后面的操作属于double-check
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程池不是 RUNNING 状态，则将刚加入队列的任务移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
            reject(command);
            
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果之前的线程已被消费完，新建一个线程&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
            addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 核心池和队列都满了，尝试创建一个新线程&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 addWorker 返回是 false，即创建失败，则唤醒拒绝策略&lt;/span&gt;
&lt;span&gt;        reject(command);
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;execute 方法执行逻辑有这样几种情况：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果当前运行的线程少于 corePoolSize，则会创建新的线程来执行新的任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果运行的线程个数等于或者大于 corePoolSize，则会将提交的任务存放到阻塞队列 workQueue 中；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果当前 workQueue 队列已满的话，则会创建新的线程来执行任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果线程个数已经超过了 maximumPoolSize，则会使用饱和策略 RejectedExecutionHandler 来进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这里要注意一下 &lt;code&gt;addWorker(null, false) &lt;/code&gt;也就是创建一个线程，但并没有传入任务，因为任务已经被添加到 workQueue 中了，所以 worker 在执行的时候，会直接从 workQueue 中获取任务。所以，在 &lt;code&gt;workerCountOf(recheck) == 0 &lt;/code&gt;时执行 &lt;code&gt;addWorker(null, false) &lt;/code&gt;也是为了保证线程池在 RUNNING 状态下必须要有一个线程来执行任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，线程池的设计思想就是使用了&lt;strong&gt;核心线程池 corePoolSize，阻塞队列 workQueue 和线程池 maximumPoolSize&lt;/strong&gt;，这样的缓存策略来处理任务，实际上这样的设计思想在需要框架中都会使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意线程和任务之间的区别，任务是保存在 workQueue 中的，线程是从线程池里面取的，由 &lt;/span&gt;CAPACITY 控制容量。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt;addWorker 方法分析&lt;/h3&gt;
&lt;p&gt;addWorker 方法的主要工作是在线程池中创建一个新的线程并执行，firstTask 参数用于指定新增的线程执行的第一个任务，core 参数为 true 表示在新增线程时会判断当前活动线程数是否少于 corePoolSize，false 表示新增线程前需要判断当前活动线程数是否少于 maximumPoolSize，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
    retry:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取运行状态&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 这个if判断
         * 如果rs &amp;gt;= SHUTDOWN，则表示此时不再接收新任务；
         * 接着判断以下3个条件，只要有1个不满足，则返回false：
         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
         * 2. firsTask为空
         * 3. 阻塞队列不为空
         * 
         * 首先考虑rs == SHUTDOWN的情况
         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；
         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，
         * 因为队列中已经没有任务了，不需要再添加线程了
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
               firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
               !&lt;span&gt; workQueue.isEmpty()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为false则根据maximumPoolSize来比较。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试增加workerCount，如果成功，则跳出第一个for循环&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果增加workerCount失败，则重新获取ctl的值&lt;/span&gt;
            c = ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else CAS failed due to workerCount change; retry inner loop&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    Worker w &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据firstTask来创建Worker对象&lt;/span&gt;
        w = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每一个Worker对象都会创建一个线程&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
            mainLock.lock();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recheck while holding lock.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Back out on ThreadFactory failure or if
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; shut down before lock acquired.&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(ctl.get());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rs &amp;lt; SHUTDOWN表示是RUNNING状态；
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                    (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; workers是一个HashSet&lt;/span&gt;
&lt;span&gt;                    workers.add(w);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; largestPoolSize记录着线程池中出现过的最大线程数量&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                        largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                    workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                mainLock.unlock();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;                t.start();
                workerStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
            addWorkerFailed(w);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里需要注意有以下几点：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;在获取锁后重新检查线程池的状态，这是因为其他线程可可能在本方法获取锁前改变了线程池的状态，比如调用了shutdown方法。添加成功则启动任务执行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;code&gt;t.start()&lt;/code&gt;会调用 Worker 类中的 run 方法，Worker 本身实现了 Runnable 接口。原因在创建线程得时候，将 Worker 实例传入了 t 当中，可参见 Worker 类的构造函数。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;wc &amp;gt;= CAPACITY || wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))&lt;/span&gt; 每次调用 addWorker 来添加线程会先判断当前线程数是否超过了CAPACITY，然后再去判断是否超 corePoolSize 或 maximumPoolSize，说明线程数实际上是由 CAPACITY 来控制的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3&gt;内部类 Worker 分析&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;上面分析过程中，提到了一个 Worker 类，对于某些对源码不是很熟悉得同学可能有点不清楚，下面就来看看 Worker 的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker
        &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable
    {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 6138294804551838833L&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Thread this worker is running in.  Null if factory fails. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Thread thread;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Initial task to run.  Possibly null. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Runnable firstTask;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Per-thread task counter &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; completedTasks;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Creates with given first task and thread from ThreadFactory.
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; firstTask the first task (null if none)
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Worker(Runnable firstTask) {
            setState(&lt;/span&gt;-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; inhibit interrupts until runWorker&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.firstTask =&lt;span&gt; firstTask;&lt;br/&gt;&lt;span&gt;　　　　　　　// 注意此处传入的是this
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Delegates main run loop to outer runWorker. &lt;/span&gt;&lt;span&gt;*/ &lt;br/&gt;　　　　　// 这里其实会调用外部的 runWorker 方法来执行自己。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            runWorker(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Lock methods
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The value 0 represents the unlocked state.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The value 1 represents the locked state.&lt;/span&gt;

        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isHeldExclusively() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState() != 0&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {&lt;br/&gt;&lt;span&gt;　　　　　　　// 如果已经设置过1了，这时候在设置1就会返回false，也就是不可重入
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;)) {
                setExclusiveOwnerThread(Thread.currentThread());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
            setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            setState(&lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lock()        { acquire(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock()  { &lt;span&gt;return&lt;/span&gt; tryAcquire(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unlock()      { release(1&lt;span&gt;); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isLocked() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; isHeldExclusively(); }
&lt;span&gt;　　　　　// 提供安全中断线程得方法
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIfStarted() {
            Thread t;&lt;br/&gt;&lt;span&gt;　　　　　　　// 一开始 setstate(-1) 避免了还没开始运行就被中断可能
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;t.isInterrupted()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    t.interrupt();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先看到的是 Worker 继承了(AbstractQueuedSynchronizer) AQS，并实现了 Runnable 接口，说明 Worker 本身也是线程。然后看其构造函数可以发现，内部有两个属性变量分别是 Runnable 和 Thread 实例，该类其实就是对传进来得属性做了一个封装，并加入了获取锁的逻辑（继承了 AQS ）。具体可参考文章：&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/12554940.html&quot;&gt;透过 ReentrantLock 分析 AQS 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Worker 继承了 AQS，使用 AQS 来实现独占锁的功能。为什么不使用 ReentrantLock 来实现呢？可以看到 tryAcquire 方法，它是不允许重入的，而 ReentrantLock 是允许重入的：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;lock 方法一旦获取了独占锁，表示当前线程正在执行任务中；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果正在执行任务，则不应该中断线程；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;之所以设置为不可重入，是因为我们不希望任务在调用像 setCorePoolSize 这样的线程池控制方法时重新获取锁。如果使用 ReentrantLock，它是可重入的，这样如果在任务中调用了如 setCorePoolSize 这类线程池控制的方法，会中断正在运行的线程，因为 size 小了，需要中断一些线程 。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，Worker 继承自 AQS，用于判断线程是否空闲以及是否可以被中断。&lt;/p&gt;
&lt;p&gt;此外，在构造方法中执行了 &lt;code&gt;setState(-1);&lt;/code&gt;，把 state 变量设置为 -1，为什么这么做呢？是因为 AQS 中默认的 state 是 0，如果刚创建了一个 Worker 对象，还没有执行任务时，这时就不应该被中断，看一下 tryAquire 方法： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; unused) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;)) {
        setExclusiveOwnerThread(Thread.currentThread());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正因为如此，在 runWorker 方法中会先调用 Worker 对象的 unlock 方法将 state 设置为 0。tryAcquire 方法是根据 state 是否是 0 来判断的，所以，&lt;code&gt;setState(-1);&lt;/code&gt;将 state 设置为 -1 是为了禁止在执行任务前对线程进行中断。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; runWorker 方法分析&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;前面提到了内部类 Worker 的 run 方法调用了外部类 runWorker，下面来看下 runWork 的具体逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runWorker(Worker w) {
       Thread wt &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
       Runnable task &lt;/span&gt;=&lt;span&gt; w.firstTask;
       w.firstTask &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
       w.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; status 设置为0，允许中断，也可以避免再次加锁失败&lt;/span&gt;
       &lt;span&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;span&gt;               // 要派发task的时候，需要上锁
&lt;/span&gt;               w.lock();
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程池当前状态至少是stop，则设置中断标志;
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程池当前状态是RUNNININ，则重置中断标志，重置后需要重新
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查下线程池状态，因为当重置中断标志时候，可能调用了线程池的shutdown方法
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变了线程池状态。&lt;/span&gt;
               &lt;span&gt;if&lt;/span&gt; ((runStateAtLeast(ctl.get(), STOP) ||&lt;span&gt;
                    (Thread.interrupted() &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                     runStateAtLeast(ctl.get(), STOP))) &lt;/span&gt;&amp;amp;&amp;amp;
                   !&lt;span&gt;wt.isInterrupted())
                   wt.interrupt();

               &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务执行前干一些事情&lt;/span&gt;
&lt;span&gt;                   beforeExecute(wt, task);
                   Throwable thrown &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                       task.run();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行任务&lt;/span&gt;
                   } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException x) {
                       thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Error x) {
                       thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
                       thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(x);
                   } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务执行完毕后干一些事情&lt;/span&gt;
&lt;span&gt;                       afterExecute(task, thrown);
                   }
               } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                   task &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计当前worker完成了多少个任务&lt;/span&gt;
                   w.completedTasks++&lt;span&gt;;
                   w.unlock();
               }
           }
           completedAbruptly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
       } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行清了工作&lt;/span&gt;
&lt;span&gt;           processWorkerExit(w, completedAbruptly);
       }
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下 runWorker 方法的执行过程：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;while 循环不断地通过 getTask() 方法从阻塞队列中取任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;调用 &lt;code&gt;task.run()&lt;/code&gt;执行任务；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如果 task 为 null 则跳出循环，执行 processWorkerExit 方法；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;runWorker 方法执行完毕，也代表着 Worker 中的 run 方法执行完毕，销毁线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里的 beforeExecute 方法和 afterExecute 方法在 ThreadPoolExecutor 类中是空的，留给子类来实现。&lt;/p&gt;
&lt;p&gt;completedAbruptly 变量来表示在执行任务过程中是否出现了异常，在 processWorkerExit 方法中会对该变量的值进行判断。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;getTask 方法分析&lt;/h3&gt;
&lt;p&gt;getTask 方法是从阻塞队列里面获取任务，具体代码逻辑如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable getTask() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; timeOut变量的值表示上次从阻塞队列中取任务时是否超时&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; timedOut = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did the last poll() time out?&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check if queue empty only if necessary.&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 如果线程池状态rs &amp;gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：
         * 1. rs &amp;gt;= STOP，线程池是否正在stop；
         * 2. 阻塞队列是否为空。
         * 如果以上条件满足，则将workerCount减1并返回null。
         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP ||&lt;span&gt; workQueue.isEmpty())) {
            decrementWorkerCount();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Are workers subject to culling?
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed变量用于判断是否需要进行超时控制。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wc &amp;gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于超过核心线程数量的这些线程，需要进行超时控制&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt;&lt;span&gt; corePoolSize;
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * wc &amp;gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；
         * timed &amp;amp;&amp;amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时
         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；
         * 如果减1失败，则返回重试。
         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp;&lt;span&gt; timedOut))
            &lt;/span&gt;&amp;amp;&amp;amp; (wc &amp;gt; 1 ||&lt;span&gt; workQueue.isEmpty())) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndDecrementWorkerCount(c))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；
             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。
             * 
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Runnable r &lt;/span&gt;= timed ?&lt;span&gt;
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 r == null，说明已经超时，timedOut设置为true&lt;/span&gt;
            timedOut = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException retry) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试&lt;/span&gt;
            timedOut = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实到这里后，你会发现在 ThreadPoolExcute 内部有几个重要的检验：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;判断当前的运行状态&lt;/strong&gt;，根据运行状态来做处理，如果当前都停止运行了，那很多操作也就没必要了；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;判断当前线程池的数量&lt;/strong&gt;，然后将该数据和 corePoolSize 以及 maximumPoolSize 进行比较，然后再去决定下一步该做啥；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先是第一个 if 判断，当运行状态处于非 RUNNING 状态，此外 rs &amp;gt;= STOP（线程池是否正在 stop）或阻塞队列是否为空。则将 workerCount 减 1 并返回 null。为什么要减 1 呢，因为此处其实是去获取一个 task，但是发现处于停止状态了，也就是没必要再去获取运行任务了，那这个线程就没有存在的意义了。后续也会在 processWorkerExit 将该线程移除。&lt;/p&gt;
&lt;p&gt;第二个 if 条件目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行 execute 方法时，如果当前线程池的线程数量超过了 corePoolSize 且小于 maximumPoolSize，并且 workQueue 已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是 timedOut 为 true 的情况，说明 workQueue 已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于 corePoolSize 数量的线程销毁掉，保持线程数量在 corePoolSize 即可。&lt;/p&gt;
&lt;p&gt;什么时候会销毁？当然是 runWorker 方法执行完之后，也就是 Worker 中的 run 方法执行完，由 JVM 自动回收。&lt;/p&gt;
&lt;p&gt;getTask 方法返回 null 时，在 runWorker 方法中会跳出 while 循环，然后会执行 processWorkerExit 方法。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;processWorkerExit 方法&lt;/h3&gt;
&lt;p&gt;下面在看 processWorkerExit 方法的具体逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processWorkerExit(Worker w, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; completedAbruptly) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (completedAbruptly) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If abrupt, then workerCount wasn't adjusted&lt;/span&gt;
&lt;span&gt;        decrementWorkerCount();
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计完成的任务数&lt;/span&gt;
        completedTaskCount +=&lt;span&gt; w.completedTasks;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从workers中移除，也就表示着从线程池中移除了一个工作线程&lt;/span&gt;
&lt;span&gt;        workers.remove(w);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据线程池状态进行判断是否结束线程池&lt;/span&gt;
&lt;span&gt;    tryTerminate();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；
     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；
     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (runStateLessThan(c, STOP)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;completedAbruptly) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; min = allowCoreThreadTimeOut ? 0&lt;span&gt; : corePoolSize;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (min == 0 &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty())
                min &lt;/span&gt;= 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;gt;=&lt;span&gt; min)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replacement not needed&lt;/span&gt;
&lt;span&gt;        }
        addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，processWorkerExit 执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期。但是这有两点需要注意：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;大家想想什么时候才会调用这个方法，任务干完了才会调用。那么没事做了，就需要看下是否有必要结束线程池，这时候就会调用 tryTerminate。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果此时线程处于 STOP 状态以下，那么就会判断核心线程数是否达到了规定的数量，没有的话，就会继续创建一个线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3&gt;tryTerminate方法&lt;/h3&gt;
&lt;p&gt;tryTerminate 方法根据线程池状态进行判断是否结束线程池，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; tryTerminate() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 当前线程池的状态为以下几种情况时，直接返回：
         * 1. RUNNING，因为还在运行中，不能停止；
         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；
         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isRunning(c) ||&lt;span&gt;
            runStateAtLeast(c, TIDYING) &lt;/span&gt;||&lt;span&gt;
            (runStateOf(c) &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程数量不为0，则中断一个空闲的工作线程，并返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) != 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eligible to terminate&lt;/span&gt;
&lt;span&gt;            interruptIdleWorkers(ONLY_ONE);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ctl.compareAndSet(c, ctlOf(TIDYING, 0&lt;span&gt;))) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; terminated方法默认什么都不做，留给子类实现&lt;/span&gt;
&lt;span&gt;                    terminated();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置状态为TERMINATED&lt;/span&gt;
                    ctl.set(ctlOf(TERMINATED, 0&lt;span&gt;));
                    termination.signalAll();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry on failed CAS&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;interruptIdleWorkers(&lt;/code&gt;boolean onlyOne&lt;/span&gt;&lt;code&gt;&lt;span&gt;)&lt;/span&gt; 如果 ONLY_ONE = true 那么就的最多&lt;/code&gt;让一个空闲线程发生中断，ONLY_ONE = false 时是所有空闲线程都会发生中断。那线程什么时候会处于空闲状态呢？&lt;/p&gt;
&lt;p&gt;一是线程数量很多，任务都完成了；二是线程在 getTask 方法中执行 &lt;code&gt;workQueue.take() &lt;/code&gt;时，如果不执行中断会一直阻塞。&lt;/p&gt;
&lt;p&gt;所以每次在工作线程结束时调用 tryTerminate 方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;shutdown方法&lt;/h3&gt;
&lt;p&gt;shutdown 方法要将线程池切换到 SHUTDOWN 状态，并调用 interruptIdleWorkers 方法请求中断所有空闲的 worker，最后调用 tryTerminate 尝试结束线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown() {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 安全策略判断&lt;/span&gt;
&lt;span&gt;        checkShutdownAccess();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 切换状态为SHUTDOWN&lt;/span&gt;
&lt;span&gt;        advanceRunState(SHUTDOWN);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中断空闲线程&lt;/span&gt;
&lt;span&gt;        interruptIdleWorkers();
        onShutdown(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hook for ScheduledThreadPoolExecutor&lt;/span&gt;
    } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试结束线程池&lt;/span&gt;
&lt;span&gt;    tryTerminate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里思考一个问题：在 runWorker 方法中，执行任务时对 Worker 对象 w 进行了 lock 操作，为什么要在执行任务的时候对每个工作线程都加锁呢？&lt;/p&gt;
&lt;p&gt;下面仔细分析一下：&lt;/p&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;在 getTask 方法中，如果这时线程池的状态是 SHUTDOWN 并且 workQueue 为空，那么就应该返回 null 来结束这个工作线程，而使线程池进入 SHUTDOWN 状态需要调用shutdown 方法；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;shutdown 方法会调用 interruptIdleWorkers 来中断空闲的线程，interruptIdleWorkers 持有 mainLock，会遍历 workers 来逐个判断工作线程是否空闲。但 getTask 方法中没有mainLock；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在 getTask 中，如果判断当前线程池状态是 RUNNING，并且阻塞队列为空，那么会调用 &lt;code&gt;workQueue.take() &lt;/code&gt;进行阻塞；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;如果在判断当前线程池状态是 RUNNING 后，这时调用了 shutdown 方法把状态改为了 SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了 &lt;code&gt;workQueue.take() &lt;/code&gt;后会一直阻塞而不会被销毁，因为在 SHUTDOWN 状态下不允许再有新的任务添加到 workQueue 中，这样一来线程池永远都关闭不了了；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;由上可知，shutdown 方法与 getTask 方法（从队列中获取任务时）存在竞态条件；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;解决这一问题就需要用到线程的中断，也就是为什么要用 interruptIdleWorkers 方法。在调用 &lt;code&gt;workQueue.take() &lt;/code&gt;时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出 InterruptedException，解除阻塞的状态；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;所以 Worker 继承自 AQS，在工作线程处理任务时会进行 lock，interruptIdleWorkers 在进行中断时会使用 tryLock 来判断该工作线程是否正在处理任务，如果 tryLock 返回 true，说明该工作线程当前未执行任务，这时才可以被中断。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就来分析一下 interruptIdleWorkers 方法。&lt;/p&gt;
&lt;h3&gt;interruptIdleWorkers方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptIdleWorkers() {
    interruptIdleWorkers(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; interruptIdleWorkers(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyOne) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers) {
            Thread t &lt;/span&gt;=&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp;&lt;span&gt; w.tryLock()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    t.interrupt();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    w.unlock();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (onlyOne)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;interruptIdleWorkers 遍历 workers 中所有的工作线程，若线程没有被中断 tryLock 成功，就中断该线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么需要持有 mainLock ？因为 workers 是 HashSet 类型的，不能保证线程安全。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;shutdownNow方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; List&amp;lt;Runnable&amp;gt;&lt;span&gt; shutdownNow() {
    List&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; tasks;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        checkShutdownAccess();
        advanceRunState(STOP);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中断所有工作线程，无论是否空闲&lt;/span&gt;
&lt;span&gt;        interruptWorkers();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出队列中没有被执行的任务&lt;/span&gt;
        tasks =&lt;span&gt; drainQueue();
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
    tryTerminate();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tasks;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;shutdownNow 方法与 shutdown 方法类似，不同的地方在于：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;设置状态为 STOP；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;中断所有工作线程，无论是否是空闲的；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;取出阻塞队列中没有被执行的任务并返回。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;shutdownNow 方法执行完之后调用 tryTerminate 方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为 TERMINATED。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;线程池的监控&lt;/h3&gt;
&lt;p&gt;通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getTaskCount&lt;/strong&gt;：线程池已经执行的和未执行的任务总数；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getCompletedTaskCount&lt;/strong&gt;：线程池已完成的任务数量，该值小于等于 taskCount；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getLargestPoolSize&lt;/strong&gt;：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getPoolSize&lt;/strong&gt;：线程池当前的线程数量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getActiveCount&lt;/strong&gt;：当前线程池中正在执行任务的线程数量。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这些方法，可以对线程池进行监控，在 ThreadPoolExecutor 类中提供了几个空方法，如 beforeExecute 方法，afterExecute 方法和 terminated 方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自 ThreadPoolExecutor 来进行扩展。&lt;/p&gt;
&lt;p&gt;到此，关于 ThreadPoolExecutor 的内容就讲完了。&lt;/p&gt;

&lt;h3&gt; 参考文献&lt;/h3&gt;
&lt;h4 class=&quot;_1RuRku&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/3cc67876375f&quot; target=&quot;_blank&quot;&gt;Java中线程池ThreadPoolExecutor原理探究&lt;/a&gt;&lt;/h4&gt;
&lt;h3 class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/fanfan4569/article/details/100830565&quot; target=&quot;_blank&quot;&gt;【Java】 之ThreadPoolExcutor源码浅析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;_1RuRku&quot;&gt;&lt;a href=&quot;https://www.jianshu.com/p/125ccf0046f3&quot; target=&quot;_blank&quot;&gt;线程池ThreadPoolExecutor实现原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;post-title&quot;&gt;&lt;a href=&quot;http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot;&gt;深入理解Java线程池：ThreadPoolExecutor&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;a href=&quot;http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Tue, 07 Apr 2020 15:49:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概论 线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/12467720.html</dc:identifier>
</item>
<item>
<title>快速掌握算法时间复杂度与空间复杂度 - CrazyCatJack</title>
<link>http://www.cnblogs.com/CrazyCatJack/p/12657097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CrazyCatJack/p/12657097.html</guid>
<description>&lt;p&gt;一个算法的优劣好坏，会决定一个程序运行的时间、空间。也许当小数据量的时候，这种影响并不明显，但是当有巨量数据的时候，算法的好坏带来的性能差异就会出天差地别。可以说直接影响了一个产品的高度和广度。每个程序员都想用最优的算法解决问题，我们期待自己写出的代码是简洁、高效的。但是如何评判一个算法的好坏呢？时间复杂度和空间复杂度就是一个很好的标准。&lt;/p&gt;

&lt;h2 id=&quot;11-概念&quot;&gt;1.1 概念&lt;/h2&gt;
&lt;p&gt;执行算法所需要的计算工作量就是我们常说的时间复杂度。该值不一定等于接下来要介绍的基本执行次数。是一个大约的数值，具有统计意义。&lt;/p&gt;
&lt;h2 id=&quot;12-基本执行次数tn&quot;&gt;1.2 基本执行次数T(n)&lt;/h2&gt;
&lt;p&gt;根据计算，得出的该算法在输入数据量为n时的，实际执行次数。该值为准确的，具体的数值，有数学意义。&lt;/p&gt;
&lt;h2 id=&quot;13-时间复杂度&quot;&gt;1.3 时间复杂度&lt;/h2&gt;
&lt;p&gt;根据基本执行次数，去除系数、常数项等得到的渐进时间复杂度。用大O表示法。也就是说，随着数据量的剧增，不同常数项和系数，已经大致不能够影响该算法的基本执行次数。常数项和系数对于计算时间复杂度无意义&lt;/p&gt;
&lt;h2 id=&quot;14-举例说明&quot;&gt;1.4 举例说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;T(n) = 2: 该函数总共执行两条语句，所以基本执行次数为2；时间复杂度为O(1): 该函数的基本执行次数只有常数项，所以时间复杂度为O(1)&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int a;
    a = 10;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;T(n) = 2n: 该函数共循环n次，每次执行2条语句，所以基本执行次数为2n。时间复杂度舍弃系数，为O(n)&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int cnt;
    for (cnt = 0; cnt &amp;lt; n; cnt++) {
        int a;
        a= 10;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;T(n) = 2 * (1 + 2 + 3 + 4 + ... + n) + 1 = 2 * (1 + n) * n / 2 + 1 = n^2 + n + 1。因为共执行(1 + 2 + 3 + 4 + ... + n) 次循环，每次循环执行2条语句，所有循环结束后，最后又执行了1条语句，所以执行次数如上；时间复杂度为O(n^2)，因为n和常数项1忽略，它们在数据量剧增的时候，对于执行次数曲线几乎没有影响了&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int cnt1, cnt2;
    for (cnt1 = 0; cnt1 &amp;lt; n; cnt1++) {
        for (cnt2 = cnt1; cnt2 &amp;lt; n; cnt2++) {
            int a;
            a = 10;            
        }
    }
    a = 11;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;T(n) = 2 * logn 因为每次循环执行2条语句，共执行logn次循环；时间复杂度为O(logn)，忽略掉系数2&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int cnt;
    for (cnt = 1; cnt &amp;lt; n; cnt *= 2) {
        int a;
        a = 10;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;T(n) = n * logn * 2 因为每次循环2条语句，共执行n * logn次循环；时间复杂度为O(nlogn)，忽略掉系数2&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int cnt1, cnt2;
    for (cnt1 = 0; cnt1 &amp;lt; n; cnt1++) {
        for (cnt2 = 1; cnt2 &amp;lt; n; cnt2 *= 2) {
            int a;
            a = 10;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;T(n) = 2 * n^3 因为每次循环2条语句，共执行n^3 次循环；时间复杂度为O(n^3)，忽略掉系数2&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;void test(int n)
{
    int cnt1, cnt2, cnt3;
    for (cnt1 = 0; cnt1 &amp;lt; n; cnt1++) {
        for (cnt2 = 0; cnt2 &amp;lt; n; cnt2++) {
            for (cnt3 = 0; cnt3 &amp;lt; n; cnt3++) {
                int a;
                a = 10;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;斐波那契数列的递归实现，每次调用该函数都会分解，然后要再调用2次该函数。所以时间复杂度为O(2^n)&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int test(int n)
{
    if (n == 0 || n == 1) {
        return 1;
    }
    return (test(n-1) + test(n-2));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;15-时间复杂度比较&quot;&gt;1.5 时间复杂度比较&lt;/h2&gt;
&lt;p&gt;O(1) &amp;lt; O(log2n) &amp;lt; O(n) &amp;lt; O(nlog2n) &amp;lt; O(n^2) &amp;lt; O(n^3) &amp;lt; O(2^n) &amp;lt; O(n!) &amp;lt; O(n^n)&lt;/p&gt;

&lt;h2 id=&quot;21-概念&quot;&gt;2.1 概念&lt;/h2&gt;
&lt;p&gt;一个算法所占用的存储空间主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序本身所占用的空间&lt;/li&gt;
&lt;li&gt;输入输出变量所占用的空间&lt;/li&gt;
&lt;li&gt;动态分配的临时空间，通常指辅助变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;输入数据所占空间只取决于问题本身，和算法无关。我们所说的空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，即第三项。通常来说，只要算法不涉及到动态分配的空间以及递归、栈所需的空间，空间复杂度通常为0(1)。&lt;/p&gt;
&lt;h2 id=&quot;22-举例说明&quot;&gt;2.2 举例说明&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;S(n) = O(1).空间复杂度为O(1)，因为只有a, b, c, cnt四个临时变量。且临时变量个数和输入数据规模无关。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int test(int n)
{
    int a, b, c;
    int cnt;
    for (cnt = 0; cnt &amp;lt; n; cnt++) {
        a += cnt;
        b += a;
        c += b;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;S(n) = O(n).空间复杂度为O(n)，因为每次递归都会创建一个新的临时变量a。且共递归n次。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int test(int n)
{
    int a = 1;
    if (n == 0) {
        return 1;
    }
    n -= a;
    return test(n);
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在上面的例子中，我们通常都会舍弃掉系数和常数项。这是因为当输入量剧增，接近正无穷时，系数和常数项已经不能够影响执行次数曲线。不同的系数和常数项曲线会完全重合。我做了一个折线图用来比较当输入值n激增时，n^2 曲线和 2n^2 + 100 曲线。可以看到，当数据量剧增时，系数和常数项对于统计时间复杂度都不再有意义，两条曲线几乎完全重合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1061082/202004/1061082-20200407233212475-1089707261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图是我做的一个表格，整理了不同的排序算法的时间复杂度和空间复杂度供大家参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1061082/202004/1061082-20200407233220344-2124809133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;感谢大家的阅读，大家喜欢的请帮忙点下推荐。后面会继续出精彩的内容，敬请期待！&quot;&gt;感谢大家的阅读，大家喜欢的请帮忙点下推荐。后面会继续出精彩的内容，敬请期待！&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;敬告：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文原创，欢迎大家学习转载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;转载请在显著位置注明：&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;博主ID：CrazyCatJack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始博文链接地址：&lt;a href=&quot;https://www.cnblogs.com/CrazyCatJack/p/12657097.html&quot;&gt;https://www.cnblogs.com/CrazyCatJack/p/12657097.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;center&gt;CrazyCatJack&lt;/center&gt;
</description>
<pubDate>Tue, 07 Apr 2020 15:42:00 +0000</pubDate>
<dc:creator>CrazyCatJack</dc:creator>
<og:description>前言 一个算法的优劣好坏，会决定一个程序运行的时间、空间。也许当小数据量的时候，这种影响并不明显，但是当有巨量数据的时候，算法的好坏带来的性能差异就会出天差地别。可以说直接影响了一个产品的高度和广度。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CrazyCatJack/p/12657097.html</dc:identifier>
</item>
<item>
<title>谈谈surging 与多语言混合微服务构思 - fanly11</title>
<link>http://www.cnblogs.com/fanliang11/p/12656971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanliang11/p/12656971.html</guid>
<description>&lt;p&gt;微服务架构已成为目前互联网架构的趋势，关于微服务的讨论，几乎是各大技术论坛、技术大会的热门话题。而Surging是&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;高性能的模块化微服务引擎，&lt;/span&gt;&lt;/span&gt;是大家首选微服务引擎架构之一，而针对于框架有个突出的缺点就是只能支持基于.NET CORE开发，而现如今各大公司开发语言是多样的，每个业务线有各自开发的语言，所以出现了 多语言之间服务调用的问题。&lt;/p&gt;
&lt;p&gt;跨语言调用是大家比较关心的话题，在这里我也提出自己的构思，后面计划实现基于java的surging ，可以和.NET CORE 进行互相调用。在这篇文章也会大致讨论一下我的构思：&lt;/p&gt;
&lt;p&gt;而在开始之前，我想说下surging 是开源的，大家可以花时间去专研研究代码，也欢迎大家提供想法，贡献PR,但是如果你想节约时间，想深入了解surging,或者熟知如何部署，您可以购买作者的时间给你来四场一对多的直播，或者您有技术的疑难也可以通过购买企业服务的方式进行一对一的解答。而大家关心的事，有没有企业购买或者使用，在这里可以告诉你有，有很多。而且已经做了多场直播，还有购买OEM版权的。&lt;/p&gt;

&lt;p&gt;大家最初最常用的想要实现“跨语言”大多数方案是使用 http 协议做一层转换，最常见的手段莫过于借助 webapi 提供的 controller/action，间接通过httpclient调用webapi 提供的rest。这种方案的调用使得链路变长，tcp 通信之上又多了一层 http 通信,还需要写一套外层的webapi,不论是开发时间还是性能都有所拉长。&lt;/p&gt;
&lt;p&gt;   而针对于surging 是支持多种协议，surging内部提供了基于netty 的RPC协议之外，还有rest协议和grpc协议可供选择。这两者都是通用的跨语言协议。&lt;/p&gt;
&lt;p&gt;  rest 协议为满足 标准规范，在开发过程中引入了 GET、POST、PUT、DELETE 等特性，而这些特性可以通过元数据的方式注册到注册中心，对于习惯于编写传统rest 接口的人可以通过rest进行对接。&lt;/p&gt;
&lt;p&gt; Gprc 更可以通过Google Protocol Buffers做到跨协议调用&lt;/p&gt;
&lt;p&gt;RPC 跨协议调用就需要考虑 消息模型报文格式和序列化方案，而针对于消息报文包括了消息Id，消息类型，消息内容，而消息内容有两种类型，一种是远程调用消息，一种是远程调用结果消息。只要满足以上报文传递就可以了，而针对于报文必然要序列化和反序列化，而框架中提供了messagepack、ProtocolBuffers、Json.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/192878/202004/192878-20200407221506201-1326554725.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;谈到服务治理必然要谈到容错规则、负载均衡、服务路由，对于这些参数的适配，必然需要注册中心进行存储，而框架实现了基于consul 和 zookeeper 注册中心。&lt;/p&gt;
&lt;p&gt;而谈到多语言混合，必然针对于每种语言都要考虑如何把服务路由信息注册到注册中心，并且需要实现一套基于consul 的心跳方式交互，还有一套基于zookeeper 的watcher 机制交互，而针对于服务路由里面包含了服务地址列表，需要实现针对于每种语言写一套负载算法，包括了轮询、哈希、随机算法，还需要实现一套各语言容错规则的判断，再发生错误时，能通过容错规则发生熔断。&lt;/p&gt;

&lt;p&gt;而针对于框架实现了一套基于skywalking的服务链路跟踪，它支持基于rpc、rest、mqtt 协议服务跟踪，如果没有通过rest 主入口访问调用所产生的调用都是单链路的，而通过rest,可以产生调用链路，&lt;/p&gt;
&lt;p&gt;可以通过TraceId传递，来衔接多语言混合链路跟踪，并且需要把收集性能跟踪信息交互到skywalking,以下是实现的链路跟踪&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/192878/202004/192878-20200407235632349-23168161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;而针对于拦截器考虑到需要跨语言和扩展性，在框架内部已经把拦截器参数和ID抽象化到服务路由元数据当中。并且可以针对于拦截器进行扩展，而框架实现了ServiceCacheIntercept和ServiceLogIntercept，而针对于跨语言需要做的是解析元数据，转化成拦截器参数，再通过参数去实现业务拦截降级，而以下是基于consul 注册的服务路由，里面包含了拦截器元数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/192878/202004/192878-20200407232326445-1126296124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;以上是对于多语言混合微服务架构的一些构思，在以下日子里会去实现多语言混合架构，第一目标是先实现JAVA，还需要去花一些时间去做企业微服务培训和帮助企业更快熟悉如何构建微服务程序&lt;/p&gt;

</description>
<pubDate>Tue, 07 Apr 2020 15:31:00 +0000</pubDate>
<dc:creator>fanly11</dc:creator>
<og:description>1、前言 微服务架构已成为目前互联网架构的趋势，关于微服务的讨论，几乎是各大技术论坛、技术大会的热门话题。而Surging是高性能的模块化微服务引擎，是大家首选微服务引擎架构之一，而针对于框架有个突出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fanliang11/p/12656971.html</dc:identifier>
</item>
<item>
<title>数据仓库知识点梳理(2) - camash</title>
<link>http://www.cnblogs.com/shenfeng/p/datawarehouse_intro_2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenfeng/p/datawarehouse_intro_2.html</guid>
<description>&lt;p&gt;本文从业务分析的归因/相关性分析的方式，引入了维度建模，两者具有相同分析路径。然后介绍了维度建模的基础——事实表和维度表，它们关联之后的产物即星型模型。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;122.33735339677&quot;&gt;
&lt;blockquote readability=&quot;5.76&quot;&gt;
&lt;p&gt;接着上一篇&lt;a href=&quot;https://www.cnblogs.com/shenfeng/p/datawarehouse_intro_1.html&quot;&gt;文章&lt;/a&gt;介绍了数据仓库的发展历史和基本概念，本文将着重介绍数据仓库的主流建模方式——维度建模。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常见的业务分析过程，包含对分析对象的定性分析和定量分析。维度建模在确定一个主题后，会将数据存储在事实表和维度表。对比下这两个分类，非常巧合的，在维度模型里面维度表存放的是分析&lt;strong&gt;主题的属性&lt;/strong&gt;，对应于&lt;strong&gt;定性分析&lt;/strong&gt;；而事实表中存放的是属性组合下的&lt;strong&gt;数量度量&lt;/strong&gt;，对应于&lt;strong&gt;定量分析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以分析销售主题为例，对于销售可量化的数据如销售金额、销售数量等可以量化的数据是存在事情表中。对销售有影响的属性如，地区、产品、时间等。&lt;/p&gt;
&lt;p&gt;同时，每个主要的影响因子维度下，存在多种不同的粒度，比如地区可以按照省、市、区进行划分；时间可以按照季度、月度甚至节假日等进行划分。在分析业务时，可以使用鱼骨图将这些因子罗列起来。下图为使用鱼骨图做的销售主题的归因或者相关分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/670593/202004/670593-20200407221401371-853569399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上文中已经提到事实表中存放定量数据，按照Kimball在《The Data Warehouse Toolkit, 3rd Edition》的定义：在维度模型中，事实表存放业务事件的测度(perfromance measurement)结果。事件的测试，对于销售事件来说，常规的如金额、商品件数等。在维度模型下，获取的测度值需要在各个维度的最小粒度下获取。例如在产品维度上，原始系统数据一个订单上可能包含多个不同的产品，但因为若在产品维度上需要维持到SKU的粒度， 我们就需要对原始订单进行SKU拆分之后接入到事实表。&lt;/p&gt;
&lt;p&gt;事实表中的每一行数据必须保持在相同的粒度，否则就会重复数据。现实事件的每一次测度和事实表中的每一行记录是一一对应的，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/670593/202004/670593-20200407221417799-73035638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图的事实表中，可以看到其字段主要分为3种类型，包括用于每行记录的主键、关联维度表的外键以及测度结果值(如销售任务)。&lt;/p&gt;
&lt;p&gt;记录的主键，在上图中为单次交易的流水号，作为每条记录的唯一标识。&lt;/p&gt;
&lt;p&gt;事实表中的外键，用于关联维度表中的主键。通过外键关联，可以获取每条事实记录的维度在不同粒度下的值。并且，事实表的外键数量肯定是大于等于两个的。因为只有一个维度的情况下，在一行记录上给出所有的维度粒度即可，不需要再进行2次关联。&lt;/p&gt;
&lt;p&gt;测度结果值(通常都为数字类型)，可以分成3种类型：可加总型(additive)，半加总型(semi-additive)和非加总型(non-additive)。其中，可加总型是指类似于销售金额、销售件数等可以在所有维度都进行累加的值。半加总型是指类似于账户余额等可以在客户维度累加，但是不能在时间维度上累加的值。非加总型是指如件单价等在任何维度上累加都不存在实际意义的值。&lt;/p&gt;
&lt;p&gt;维度表中存储的是与测度事件相关的文本描述信息，用于说明每一条事件记录的“who, what, where, when, how, and why“。与事实表相比，维度表的行数相对要少很多，但是字段数量相对要多(与描述的属性粒度相关)。&lt;/p&gt;
&lt;p&gt;维度表中的每一个描述字段或者说「属性」是进行业务分析时作为查询约束、分组和数据标签的基础。维度属性值一般使用含义明确的文本方式表示，这样受众可以更好地理解数据处理的报表和分析结果。如果因为属性文本过大等情况，采用数值编码方式存储的属性在生成查询结果或报表时需要对数值编码进行解释。&lt;/p&gt;

&lt;p&gt;在建立分析主题的事实表和维度表之后，通过外键关系便可以将事实表和维度表关联起来。关联之后的ER图，呈放射状，称之为「星型模型」，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/670593/202004/670593-20200407221434504-1077425782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相对于关系数据库中的范式设计，维度设计中的星型模型不用考虑复杂的程序流程，是一种业务分析人员友好的数据组织方式。同时，在分组聚合时有更好的查询性能，具有较好的扩展性——支持增加维度和事实测度结果值。&lt;/p&gt;

&lt;p&gt;本文从业务分析的归因/相关性分析的方式，引入了维度建模，两者具有相同分析路径。然后介绍了维度建模的基础——事实表和维度表，以及关联之后得到星型模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎扫描二维码关注公众号&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/670593/201912/670593-20191201214002980-3085349.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 07 Apr 2020 14:16:00 +0000</pubDate>
<dc:creator>camash</dc:creator>
<og:description>本文从业务分析的归因/相关性分析的方式，引入了维度建模，两者具有相同分析路径。然后介绍了维度建模的基础——事实表和维度表，它们关联之后的产物即星型模型。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shenfeng/p/datawarehouse_intro_2.html</dc:identifier>
</item>
<item>
<title>数据源管理 | 基于JDBC模式，适配和管理动态数据源 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12656529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12656529.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、动态数据源&quot;&gt;1、动态数据源&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202004/1691717-20200407220621903-1604864869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态管理数据源的基本功能：数据源加载，容器维护，持久化管理。&lt;/p&gt;
&lt;h2 id=&quot;2、关系型数据库&quot;&gt;2、关系型数据库&lt;/h2&gt;
&lt;p&gt;不同厂商的关系型数据库，提供的链接方式，驱动包，驱动类名都是不一样的，Java数据库连接API，JDBC是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法，且适配大部分关系型数据库。&lt;/p&gt;
&lt;h2 id=&quot;3、适配要素&quot;&gt;3、适配要素&lt;/h2&gt;
&lt;p&gt;核心要素：驱动包、驱动类名、URL格式、默认端口。&lt;/p&gt;
&lt;p&gt;关系型数据库很多，这里一定是不全的，根据需要自行完善即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum DataSourceType {

    MySql(&quot;MySql&quot;, &quot;com.mysql.jdbc.Driver&quot;),
    Oracle(&quot;Oracle&quot;, &quot;oracle.jdbc.OracleDriver&quot;),
    DB2(&quot;DB2&quot;, &quot;com.ibm.db2.jcc.DB2Driver&quot;);

    private String dataSourceName;
    private String driverClassName;

    public static String getDriver (String dataSourceName) {
        DataSourceType[] types = DataSourceType.values();
        for (DataSourceType type : types) {
            if (type.getDataSourceName().equals(dataSourceName)) {
                return type.getDriverClassName();
            }
        }
        return null;
    }
    DataSourceType (String dataSourceName,String driverClassName){
        this.dataSourceName = dataSourceName ;
        this.driverClassName = driverClassName ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、jdbc基础api&quot;&gt;4、JDBC基础API&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DriverManager&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管理JDBC驱动程序的基本服务API。调用方法Class.forName，显式地加载驱动程序类，正好适用于动态数据源的业务场景，数据源类型未知情况。加载Driver类并在DriverManager类注册后，即可用来与数据库建立连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DataSource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DataSource接口，由驱动程序供应商实现，负责建立与数据库的连接，当在应用程序中访问数据库时，常用于获取操作数据的Connection对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Connection接口代表与特定的数据库的连接，要对数据库数据进行操作,首先要获取数据库连接，Connection实现就像在应用程序中与数据库之间开通了一条通道，通过DriverManager类或DataSource类都可获取Connection实例。&lt;/p&gt;

&lt;p&gt;这里几个核心类的封装思路：模块化功能，API分开封装，如果需要适配处理各类数据源类型，则分别可以向上抽象提取，向下自定义适配策略，设计模式影响下的基本意识。&lt;/p&gt;
&lt;h2 id=&quot;1、链接工具&quot;&gt;1、链接工具&lt;/h2&gt;
&lt;p&gt;基于DriverManager管理数据源的驱动加载，链接获取等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConnectionUtil {

    public static synchronized Connection getConnect(String driverClassName,String userName,
                                                  String passWord,String jdbcUrl) {
        Properties prop = new Properties();
        prop.put(&quot;user&quot;, userName);
        prop.put(&quot;password&quot;, passWord);
        return connect(driverClassName,prop,jdbcUrl) ;
    }

    private static synchronized Connection connect(String driverClassName,
                                                   Properties prop,String jdbcUrl) {
        try {
            Class.forName(driverClassName);
            DriverManager.setLoginTimeout(JdbcConstant.LOGIN_TIMEOUT);
            return DriverManager.getConnection(jdbcUrl, prop);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null ;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、api工具类&quot;&gt;2、API工具类&lt;/h2&gt;
&lt;p&gt;提供API配置获取类，加载需要的数据源API，关闭资源等基本操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class JdbcConfig {

    /**
     * 获取数据源连接
     */
    public Connection getConnection (ConnectionEntity connectionEntity){
        String dataTypeName = connectionEntity.getDataTypeName();
        String driverClassName = DataSourceType.getDriver(dataTypeName) ;
        if (driverClassName == null){
            throw new RuntimeException(&quot;不支持该数据源类型&quot;) ;
        }
        connectionEntity.setDriverClassName(driverClassName);
        return ConnectionUtil.getConnect(connectionEntity.getDriverClassName(),
                connectionEntity.getUserName(),
                connectionEntity.getPassWord(),
                connectionEntity.getJdbcUrl()) ;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、数据源容器&quot;&gt;3、数据源容器&lt;/h2&gt;
&lt;p&gt;维护一个Map容器，管理数据源的添加，删除，动态获取等基本需求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class DataSourceFactory {

    private volatile Map&amp;lt;Integer, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;();

    @Resource
    private JdbcConfig jdbcConfig ;
    @Resource
    private ConnectionMapper connectionMapper ;

    /**
     * 数据源API包装
     */
    private static DataSource getDataSource (ConnectionEntity connectionEntity){
        DruidDataSource datasource = new DruidDataSource();
        datasource.setUrl(connectionEntity.getJdbcUrl());
        datasource.setUsername(connectionEntity.getUserName());
        datasource.setPassword(connectionEntity.getPassWord());
        datasource.setDriverClassName(connectionEntity.getDriverClassName());
        return datasource ;
    }

    /**
     * 获取 JDBC 链接
     */
    public JdbcTemplate getById (Integer id){
        return new JdbcTemplate(dataSourceMap.get(id)) ;
    }

    /**
     * 移除 数据源
     */
    public void removeById (Integer id) {
        dataSourceMap.remove(id) ;
    }

    /**
     * 添加数据源管理
     * 注意这里的方法，连接验证之后直接调用
     */
    public void addDataSource (ConnectionEntity connectionEntity){
        DataSource dataSource = getDataSource(connectionEntity);
        dataSourceMap.put(connectionEntity.getId(),dataSource) ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、流程测试&quot;&gt;4、流程测试&lt;/h2&gt;
&lt;p&gt;基于动态的数据源，查询表数据，这里操作的表示已知的表结构，实际上动态数据源的表结构都是需要再次动态获取表字段，才能操作。(下节数据动态读取和写入会详说)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Api(value = &quot;JdbcQueryController&quot;)
@RestController
public class JdbcQueryController {

    @Resource
    private DataSourceFactory dataSourceFactory ;

    @GetMapping(&quot;getList&quot;)
    public List&amp;lt;ConnectionEntity&amp;gt; getList (@RequestParam(&quot;id&quot;) Integer id){
        String sql = &quot;SELECT * FROM jm_connection WHERE state='1'&quot; ;
        JdbcTemplate jdbcTemplate = dataSourceFactory.getById(id);
        List&amp;lt;ConnectionEntity&amp;gt; connectionEntities = jdbcTemplate.query(sql,
                new BeanPropertyRowMapper&amp;lt;&amp;gt;(ConnectionEntity.class));
        return connectionEntities ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;持久化数据源的配置信息，多了一步配置信息入库，和入库信息加载到容器，使用时动态获取。&lt;/p&gt;
&lt;h2 id=&quot;1、库表mapper结构&quot;&gt;1、库表Mapper结构&lt;/h2&gt;
&lt;p&gt;存储配置信息的表结构，转换Mapper文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;com.dynamic.add.mapper.ConnectionMapper&quot;&amp;gt;
    &amp;lt;!-- 通用查询映射结果 --&amp;gt;
    &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.dynamic.add.entity.ConnectionEntity&quot;&amp;gt;
        &amp;lt;id column=&quot;id&quot; property=&quot;id&quot; /&amp;gt;
        &amp;lt;result column=&quot;data_type_name&quot; property=&quot;dataTypeName&quot; /&amp;gt;
        &amp;lt;result column=&quot;driver_class_name&quot; property=&quot;driverClassName&quot; /&amp;gt;
        &amp;lt;result column=&quot;jdbc_url&quot; property=&quot;jdbcUrl&quot; /&amp;gt;
        &amp;lt;result column=&quot;user_name&quot; property=&quot;userName&quot; /&amp;gt;
        &amp;lt;result column=&quot;pass_word&quot; property=&quot;passWord&quot; /&amp;gt;
        &amp;lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&amp;gt;
        &amp;lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; /&amp;gt;
        &amp;lt;result column=&quot;state&quot; property=&quot;state&quot; /&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;getAllList&quot; resultMap=&quot;BaseResultMap&quot; &amp;gt;
        SELECT * FROM jm_connection WHERE state='1'
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、持久化管理&quot;&gt;2、持久化管理&lt;/h2&gt;
&lt;p&gt;测试数据源链接是否成功，可用的数据源链接，配置信息入库保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class ConnectionServiceImpl implements ConnectionService {

    @Resource
    private ConnectionMapper connectionMapper ;
    @Resource
    private JdbcConfig jdbcConfig ;
    @Resource
    private DataSourceFactory dataSourceFactory ;

    @Override
    public boolean testConnection(ConnectionEntity connectionEntity) {
        return jdbcConfig.getConnection(connectionEntity) !=null ;
    }

    @Override
    public boolean addConnection(ConnectionEntity connectionEntity) {
        Connection connection = jdbcConfig.getConnection(connectionEntity) ;
        if (connection !=null){
            int addFlag = connectionMapper.insert(connectionEntity);
            if (addFlag &amp;gt; 0){
                dataSourceFactory.addDataSource(connectionEntity) ;
                return true ;
            }
        }
        return false ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、动态加载&quot;&gt;3、动态加载&lt;/h2&gt;
&lt;p&gt;容器工厂类中，添加一个初始化的方法，加载入库的数据源配置信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class DataSourceFactory {
    /**
     * 初始化 JDBC 链接API
     */
    @PostConstruct
    public void init (){
        List&amp;lt;ConnectionEntity&amp;gt; connectionList = connectionMapper.getAllList();
        if (connectionList != null &amp;amp;&amp;amp; connectionList.size()&amp;gt;0){
            for (ConnectionEntity connectionEntity:connectionList) {
                Connection connection = jdbcConfig.getConnection(connectionEntity) ;
                if (connection != null){
                    DataSource dataSource = getDataSource(connectionEntity);
                    dataSourceMap.put(connectionEntity.getId(),dataSource) ;
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：数据管理&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Apr 2020 14:09:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、关系型数据源 1、动态数据源 动态管理数据源的基本功能：数据源加载，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12656529.html</dc:identifier>
</item>
</channel>
</rss>