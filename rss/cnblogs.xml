<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>11个教程中不常被提及的JavaScript小技巧 - 冷星1024</title>
<link>http://www.cnblogs.com/ld1024/p/10723827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ld1024/p/10723827.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这次我们主要来分享11个在日常教程中不常被提及的JavaScript小技巧，他们往往在我们的日常工作中经常出现，但是我们又很容易忽略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;过滤唯一值&quot;&gt;1、过滤唯一值&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;类型是在&lt;code&gt;ES6&lt;/code&gt;中新增的，它类似于数组，但是成员的值都是唯一的，没有重复的值。结合扩展运算符（...）我们可以创建一个新的数组，达到过滤原数组重复值的功能。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const array = [1, 2, 3, 3, 5, 5, 1];
const uniqueArray = [...new Set(array)];

console.log(uniqueArray); // [1, 2, 3, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ES6之前，我们如果想要实现这个功能的话，需要的处理代码要多很多。&lt;br/&gt;这个技巧的适用范围是数组中的数值的类型为：&lt;code&gt;undefined&lt;/code&gt;， &lt;code&gt;null&lt;/code&gt;， &lt;code&gt;boolean&lt;/code&gt;， &lt;code&gt;string&lt;/code&gt;， &lt;code&gt;number&lt;/code&gt;。当包涵&lt;code&gt;object&lt;/code&gt;， &lt;code&gt;function&lt;/code&gt;， &lt;code&gt;array&lt;/code&gt;时，则不适用。&lt;/p&gt;
&lt;h2 id=&quot;短路求值short-circuit-evaluation&quot;&gt;2、短路求值（Short-Circuit Evaluation）&lt;/h2&gt;
&lt;p&gt;三目运算符是一个很方便快捷的书写一些简单的逻辑语句的方式，&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;x &amp;gt; 100 ? 'Above 100' : 'Below 100';
x &amp;gt; 100 ? (x &amp;gt; 200 ? 'Above 200' : 'Between 100-200') : 'Below 100';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是有些时候当逻辑复杂之后，三目运算符书写起来可读性也会很难。这个时候，我们就可以使用逻辑与（&amp;amp;&amp;amp;）和逻辑或（||）运算符来改写我们的表达式。&lt;/p&gt;
&lt;p&gt;逻辑与和逻辑或操作符总是先计算其做操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。这被称为“短路求值（Short-Circuit Evaluation）”&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;与（&amp;amp;&amp;amp;）运算符将会返回第一个&lt;code&gt;false/‘falsy’&lt;/code&gt;的值。当所有的操作数都是&lt;code&gt;true&lt;/code&gt;时，将返回最后一个表达式的结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let one = 1, two = 2, three = 3;
console.log(one &amp;amp;&amp;amp; two &amp;amp;&amp;amp; three); // Result: 3

console.log(0 &amp;amp;&amp;amp; null); // Result: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或（||）运算符将返回第一个&lt;code&gt;true/‘truthy’&lt;/code&gt;的值。当所有的操作数都是&lt;code&gt;false&lt;/code&gt;时，将返回最后一个表达式的结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let one = 1, two = 2, three = 3;
console.log(one || two || three); // Result: 1

console.log(0 || null); // Result: null&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;场景举例&quot;&gt;场景举例&lt;/h3&gt;
&lt;p&gt;当我们从服务器端请求数据的过程中，我们在另一个位置来使用这个数据，但是获取数据的状态并不知道，如我们访问&lt;code&gt;this.state&lt;/code&gt;的&lt;code&gt;data&lt;/code&gt;属性。按照常规的方式我们会先去判断这个&lt;code&gt;this.state.data&lt;/code&gt;的有效性，之后根据有效性情况分别进行区分处理。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (this.state.data) {
  return this.state.data;
} else {
  return 'Fetching Data';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们可以通过上面的方式来简写这个逻辑处理&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;return (this.state.data || 'Fetching Data');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比发现这个方式更加的简洁方便。&lt;/p&gt;
&lt;h2 id=&quot;转换boolean型&quot;&gt;3、转换Boolean型&lt;/h2&gt;
&lt;p&gt;常规的boolean型值只有 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;，但是在JavaScript中我们可以将其他的值认为是 &lt;code&gt;‘truthy’&lt;/code&gt; 或者 &lt;code&gt;‘falsy’&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;0&lt;/code&gt;， &lt;code&gt;“”&lt;/code&gt;， &lt;code&gt;null&lt;/code&gt;， &lt;code&gt;undefined&lt;/code&gt;， &lt;code&gt;NaN&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;,其他的我们都可以认为是&lt;code&gt;‘truthy’&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;我们可以通过负运算符&lt;code&gt;！&lt;/code&gt;将一系列的变量转换成“boolean”型。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const isTrue  = !0;
const isFalse = !1;
const alsoFalse = !!0;

console.log(isTrue); // Result: true
console.log(typeof true); // Result: &quot;boolean&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换string型&quot;&gt;4、转换String型&lt;/h2&gt;
&lt;p&gt;我们可以通过&lt;code&gt;+&lt;/code&gt;连接运算符将一个number类型的变量转换成string类型。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const val = 1 + &quot;&quot;;

console.log(val); // Result: &quot;1&quot;
console.log(typeof val); // Result: &quot;string&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换number类型&quot;&gt;5、转换Number类型&lt;/h2&gt;
&lt;p&gt;和上面对应的，我们可以通过加法运算符&lt;code&gt;+&lt;/code&gt;将一个string类型的变量转回为number 类型的&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let int = &quot;15&quot;;
int = +int;

console.log(int); // Result: 15
console.log(typeof int); Result: &quot;number&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些上下文中，&lt;code&gt;+&lt;/code&gt;将被解释为连接操作符，而不是加法操作符。当这种情况发生时(您希望返回一个整数，而不是浮点数)，您可以使用两个波浪号:&lt;code&gt;~~&lt;/code&gt;。(需要注意为英文格式)&lt;/p&gt;
&lt;p&gt;一个波浪号&lt;code&gt;~&lt;/code&gt;，被称为“按位不运算符”，等价于 &lt;code&gt;- n - 1&lt;/code&gt;。所以&lt;code&gt;~15 = -16&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;使用两个&lt;code&gt;~~&lt;/code&gt;可以有效的否定运算。这是因为 &lt;code&gt;- (- n - 1) - 1 = n + 1 - 1 = n&lt;/code&gt;。也就是说 &lt;code&gt;~-16 = 15&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const int = ~~&quot;15&quot;

console.log(int); // Result: 15
console.log(typeof int); Result: &quot;number&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;快速求幂&quot;&gt;6、快速求幂&lt;/h2&gt;
&lt;p&gt;从&lt;code&gt;ES7&lt;/code&gt;开始，我们可以使用幂运算符 &lt;code&gt;**&lt;/code&gt; 作为求幂的简写，相对之前的&lt;code&gt;Math.pow(2, 3)&lt;/code&gt; 更加快捷。这是一个很简单实用的点，但是大部分的教程并不会专门介绍它。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(2 ** 3); // Result: 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这不应该与 &lt;code&gt;^&lt;/code&gt; 符号混淆，&lt;code&gt;^&lt;/code&gt; 符号通常用于表示指数，但在JavaScript中是位XOR操作符。&lt;/p&gt;
&lt;p&gt;在ES7之前，幂的简写主要依靠的是位左移位操作符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，几种写法的区别&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 下面几种写法是等价的

Math.pow(2, n);
2 &amp;lt;&amp;lt; (n - 1);
2**n;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中需要注意的是 &lt;code&gt;2 &amp;lt;&amp;lt; 3 = 16 等价于 2 ** 4 = 16&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速float转integer&quot;&gt;7、快速Float转Integer&lt;/h2&gt;
&lt;p&gt;我们平时可以使用&lt;code&gt;Math.floor(), Math.ceil()和Math.round()&lt;/code&gt;将&lt;code&gt;float&lt;/code&gt;类型转换成&lt;code&gt;integer&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;但是还有一种更快的方法可以使用&lt;code&gt;|(位或运算符)&lt;/code&gt;将浮点数截断为整数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(23.9 | 0);  // Result: 23
console.log(-23.9 | 0); // Result: -23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt; 的行为取决于处理的是正数还是负数，所以最好只在确定的情况下使用这个快捷方式。&lt;/p&gt;
&lt;p&gt;如果n是正数的，则 &lt;code&gt;n | 0&lt;/code&gt; 有效地向下舍入。如果n是负数的，它则有效地向上取整。更准确地说，该操作结果是直接删除小数点后的内容，将浮点数截断为整数，和上面提到的其他几个方法是有所区别的。&lt;/p&gt;
&lt;p&gt;您还可以使用 &lt;code&gt;~~&lt;/code&gt; 来获得相同的舍入效果，如上所述，实际上任何位操作符都会强制浮点数为整数。这些特殊操作之所以有效，是因为一旦强制为整数，值就保持不变。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;位或运算符可以用于从整数的末尾删除任意数量的数字。这意味着我们不必使用这样的代码在类型之间进行转换&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let str = &quot;1553&quot;; 
Number(str.substring(0, str.length - 1));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而是可以使用下面的方式来实现我们的功能&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(1553 / 10   | 0)  // Result: 155
console.log(1553 / 100  | 0)  // Result: 15
console.log(1553 / 1000 | 0)  // Result: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类中自动绑定&quot;&gt;8、类中自动绑定&lt;/h2&gt;
&lt;p&gt;我们可以在类中通过使用ES6增加的箭头函数的方式来实现隐形绑定作用域。而按照之前的处理，我们需要显式的去为我们写的方法进行绑定，类似于 &lt;code&gt;this.myMethod = this.myMethod.bind(this)&lt;/code&gt;这样。当我们的类中有很多方法时，会增加大量的绑定的代码的书写。现在我们就可以通过箭头函数的方式来简化这个过程。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React, { Component } from React;
export default class App extends Compononent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  myMethod = () =&amp;gt; {
    // 隐式绑定
  }
  render() {
    return (
      &amp;lt;&amp;gt;
        &amp;lt;div&amp;gt;
          {this.myMethod()}
        &amp;lt;/div&amp;gt;
      &amp;lt;/&amp;gt;
    )
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;截取数组&quot;&gt;9、截取数组&lt;/h2&gt;
&lt;p&gt;如果您想从数组的末尾删除值，有比使用&lt;code&gt;splice()&lt;/code&gt;更快的替代方法。&lt;/p&gt;
&lt;p&gt;例如，如果你知道原始数组的长度，就可以通过重新定义它的&lt;code&gt;length&lt;/code&gt;属性来实现截取&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
array.length = 4;
console.log(array); // Result: [0, 1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个特别简洁的解决方案。但是，slice()方法的运行时更快。如果速度是你的主要目标，考虑使用下面的方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
array = array.slice(0, 4);

console.log(array); // Result: [0, 1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取数组中的最后的元素&quot;&gt;10、获取数组中的最后的元素&lt;/h2&gt;
&lt;p&gt;数组方法slice()可以接受负整数，如果提供它，它将从数组的末尾开始截取数值，而不是开头&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

console.log(array.slice(-1)); // Result: [9]
console.log(array.slice(-2)); // Result: [8, 9]
console.log(array.slice(-3)); // Result: [7, 8, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;格式化json代码&quot;&gt;11、格式化JSON代码&lt;/h2&gt;
&lt;p&gt;我们可能在处理一些JSON相关的处理时很多时候都会使用到&lt;code&gt;JSON.stringify&lt;/code&gt;，但是你是否意识到它可以帮助缩进JSON呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stringify()&lt;/code&gt;方法接受两个可选参数:一个&lt;code&gt;replacer&lt;/code&gt;函数和一个&lt;code&gt;space&lt;/code&gt;值，&lt;code&gt;replacer&lt;/code&gt;函数可以用来过滤显示的JSON。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;space&lt;/code&gt;值接受一个整数，表示需要的空格数或一个字符串(如&lt;code&gt;'\t'&lt;/code&gt;来插入制表符)，它可以使读取获取的JSON数据变得容易得多。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(JSON.stringify({ alpha: 'A', beta: 'B' }, null, '\t'));

// Result:
// '{
//     &quot;alpha&quot;: A,
//     &quot;beta&quot;: B
// }'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总的来说，我希望当您看到这些技巧时能够和我第一次看到它们一样觉得有用。如果您有自己发现的小技巧，也希望能够留言中写下，我们一起来分享。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;2.0744680851064&quot;&gt;
&lt;p&gt;原文地址(需要友好上网😅)：&lt;br/&gt;&lt;a href=&quot;https://medium.com/@bretcameron/12-javascript-tricks-you-wont-find-in-most-tutorials-a9c9331f169d&quot;&gt;11 JavaScript Tricks You Won’t Find in Most Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 17 Apr 2019 07:27:00 +0000</pubDate>
<dc:creator>冷星1024</dc:creator>
<og:description>这次我们主要来分享11个在日常教程中不常被提及的JavaScript小技巧，他们往往在我们的日常工作中经常出现，但是我们又很容易忽略。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ld1024/p/10723827.html</dc:identifier>
</item>
<item>
<title>python进程和线程（四） - 彭方炎QAQ</title>
<link>http://www.cnblogs.com/pengfy/p/10723823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengfy/p/10723823.html</guid>
<description>&lt;h2&gt;同步条件（event）&lt;/h2&gt;
&lt;p&gt;        下面是官方文档对event的一些解释：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;An event is a simple synchronization object;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;the event represents an internal flag, and threads&lt;/span&gt;&lt;br/&gt;&lt;span&gt;can wait for the flag to be set, or set or clear the flag themselves.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;event = threading.Event()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;# a client thread can wait for the flag to be set&lt;/span&gt;&lt;br/&gt;&lt;span&gt;event.wait()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;# a server thread can set or reset it&lt;/span&gt;&lt;br/&gt;&lt;span&gt;event.set()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;event.clear()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;If the flag is set, the wait method doesn’t do anything.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;If the flag is cleared, wait will block until it becomes set again.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Any number of threads may wait for the same event&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          也就是说：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;event.isSet()：返回event的状态值；

event.wait()：如果 event.isSet()&lt;/span&gt;==&lt;span&gt;False将阻塞线程；

event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；

event.clear()：恢复event的状态值为False。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;          通过Event，我们可以实现两个或多个线程间的交互，下面是一个红绿灯的例子，即起动一个线程做交通指挥灯，生成几个线程做车辆，车辆行驶按红绿灯的规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2abb1034-2323-4d07-a1ad-0c1ef642e372')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_2abb1034-2323-4d07-a1ad-0c1ef642e372&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2abb1034-2323-4d07-a1ad-0c1ef642e372&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2abb1034-2323-4d07-a1ad-0c1ef642e372',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2abb1034-2323-4d07-a1ad-0c1ef642e372&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; light():
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; event.isSet():
        event.set() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;wait就不阻塞 #绿灯状态&lt;/span&gt;
    count =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; count &amp;lt; 10:          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绿灯10s&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[42;1m--green light on---\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; count &amp;lt;13:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;黄灯3s&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[43;1m--yellow light on---\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; count &amp;lt;20:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;红灯7s&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; event.isSet():
                event.clear()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[41;1m--red light on---\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;重新开始第二轮红绿灯&lt;/span&gt;
            count =&lt;span&gt; 0
            event.set() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开绿灯&lt;/span&gt;
        time.sleep(1&lt;span&gt;)
        count &lt;/span&gt;+=1
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; car(n):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
        time.sleep(random.randrange(&lt;/span&gt;10&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;  event.isSet(): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;car [%s]正常行驶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; n)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;car [%s]在等红绿灯...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    event &lt;/span&gt;=&lt;span&gt; threading.Event()
    Light &lt;/span&gt;= threading.Thread(target=&lt;span&gt;light)
    Light.start()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4&lt;span&gt;):
        t &lt;/span&gt;= threading.Thread(target=car,args=&lt;span&gt;(i,))
        t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        运行之后就会看到4辆车在红绿灯时的状态了，非常简单，再看一个小例子就行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('23951193-9973-4e51-b927-0172bbd59496')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_23951193-9973-4e51-b927-0172bbd59496&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_23951193-9973-4e51-b927-0172bbd59496&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('23951193-9973-4e51-b927-0172bbd59496',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_23951193-9973-4e51-b927-0172bbd59496&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mom(threading.Thread):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈：孩子们快回来吃饭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(event.isSet())# False&lt;/span&gt;
&lt;span&gt;        event.set()
        time.sleep(&lt;/span&gt;5&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈：吃红烧肉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(event.isSet())
        event.set()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Son(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):

        event.wait()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    一旦event被设定，等同于pass&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一个孩子问：吃什么啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        event.clear()
        event.wait()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一个孩子说：OhYeah!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    event&lt;/span&gt;=&lt;span&gt;threading.Event()

    threads&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
        threads.append(Son())
    threads.append(Mom())
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
        t.start()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; threads:
        t.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ending.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;信号量（Semaphore）&lt;/h2&gt;
&lt;p&gt;       之前讲的同步锁，是只允许一个线程去操作数据，而Semaphore就是同时允许一定数量的线程去操作数据。怎么说呢，比如100个人去洗脚城洗脚，只有五个技师，那一次只能同时五个人洗脚，后面的就只能排队等着了。原理也比较简单，就是BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。&lt;/p&gt;
&lt;p&gt;      BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数 器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('76594a4a-9b6a-424a-8c24-3b63d71c825e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_76594a4a-9b6a-424a-8c24-3b63d71c825e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_76594a4a-9b6a-424a-8c24-3b63d71c825e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('76594a4a-9b6a-424a-8c24-3b63d71c825e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_76594a4a-9b6a-424a-8c24-3b63d71c825e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; myThread(threading.Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; semaphore.acquire():
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name)
            time.sleep(&lt;/span&gt;3&lt;span&gt;)
            semaphore.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    semaphore&lt;/span&gt;=threading.Semaphore(5&lt;span&gt;)

    thrs&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
        thrs.append(myThread())
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; thrs:
        t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      运行后，也可能出现我们同步锁里面说的并排打印的问题，这个就要看你个人需求了。&lt;/p&gt;
&lt;h2&gt;线程队列（queue）&lt;/h2&gt;
&lt;p&gt;      之前我们在学校学过什么堆栈、队列的知识，在这里，没有堆栈这个概念，只有队列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;创建一个“队列”对象
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
q &lt;/span&gt;= Queue.Queue(maxsize = 10&lt;span&gt;)
Queue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。

&lt;strong&gt;将一个值放入队列中&lt;/strong&gt;
q.put(&lt;/span&gt;10&lt;span&gt;)
调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为
&lt;/span&gt;1&lt;span&gt;。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。

&lt;strong&gt;将一个值从队列中取出&lt;/strong&gt;
q.get()
调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。&lt;br/&gt;如果队列为空且block为False，队列将引发Empty异常。

&lt;strong&gt;Python Queue模块有三种队列及构造函数:
&lt;/strong&gt;&lt;/span&gt;1、Python Queue模块的FIFO队列先进先出。  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.Queue(maxsize)
&lt;/span&gt;2、LIFO类似于堆，即先进后出。             &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.LifoQueue(maxsize)
&lt;/span&gt;3、还有一种是优先级队列级别越低越先出来。   &lt;span&gt;class&lt;/span&gt;&lt;span&gt; queue.PriorityQueue(maxsize)

&lt;strong&gt;此包中的常用方法(q &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; Queue.Queue()):&lt;/strong&gt;
q.qsize() 返回队列的大小
q.empty() 如果队列为空，返回True,反之False
q.full() 如果队列满了，返回True,反之False
q.full 与 maxsize 大小对应
q.get([block[, timeout]]) 获取队列，timeout等待时间
q.get_nowait() 相当q.get(False)
非阻塞 q.put(item) 写入队列，timeout等待时间
q.put_nowait(item) 相当q.put(item, False)
q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号
q.join() 实际上意味着等到队列为空，再执行别的操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        现在有一个需求，比如我有一个列表，要用多线程去移除列表最后一个元素，我们一般是这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('15cc6e6c-e276-4715-98d5-21e06954257f')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_15cc6e6c-e276-4715-98d5-21e06954257f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_15cc6e6c-e276-4715-98d5-21e06954257f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('15cc6e6c-e276-4715-98d5-21e06954257f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_15cc6e6c-e276-4715-98d5-21e06954257f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading,time

li&lt;/span&gt;=[1,2,3,4&lt;span&gt;]


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pri():
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; li:
        a&lt;/span&gt;=li[-1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        li.remove(a)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; try:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     li.remove(a)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; except Exception as e:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print('----',a,e)&lt;/span&gt;
&lt;span&gt;
t1&lt;/span&gt;=threading.Thread(target=pri,args=&lt;span&gt;())
t1.start()
t2&lt;/span&gt;=threading.Thread(target=pri,args=&lt;span&gt;())
t2.start()
t1.join()
t2.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       但是运行过程中我们会发现报错，&lt;strong&gt;&lt;span&gt;ValueError: list.remove(x): x not in list&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，同时操作这个元素的时候，发现这个元素已经被其他线程移除了，所以报错。这里想说明的是，列表在多线程中的操作是不安全的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       下面这个例子，是通过queue，来实现一个生产者和消费者模型，也就是说边做边吃&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('df30fd1f-ba3d-454b-9fe0-65274946fcb1')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_df30fd1f-ba3d-454b-9fe0-65274946fcb1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_df30fd1f-ba3d-454b-9fe0-65274946fcb1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('df30fd1f-ba3d-454b-9fe0-65274946fcb1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_df30fd1f-ba3d-454b-9fe0-65274946fcb1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue,threading
q &lt;/span&gt;=&lt;span&gt; queue.Queue()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Producer(name):
  count &lt;/span&gt;=&lt;span&gt; 0
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;20&lt;span&gt;:
    time.sleep(random.randrange(&lt;/span&gt;5&lt;span&gt;))
    q.put(count)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Producer %s has produced %s baozi..&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name, count))
    count &lt;/span&gt;+=1
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Consumer(name):
  count &lt;/span&gt;=&lt;span&gt; 0
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;20&lt;span&gt;:
    time.sleep(random.randrange(&lt;/span&gt;4&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; q.empty():
        data &lt;/span&gt;=&lt;span&gt; q.get()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1mConsumer %s has eat %s baozi...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name, data))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----no baozi anymore----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    count &lt;/span&gt;+=1&lt;span&gt;
p1 &lt;/span&gt;= threading.Thread(target=Producer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
c1 &lt;/span&gt;= threading.Thread(target=Consumer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
c2 &lt;/span&gt;= threading.Thread(target=Consumer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
p1.start()
c1.start()
c2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;       A是生产者，一直在做包子，做20个，B和C就是消费者，就是一直在吃包子，没有包子就喊。这里我们用的是q.empty()来判断队列中有没有包子，我们也可以通过q.task_done()和q.join（）来完成这件事：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c77f74ed-0238-4bdf-b164-daec5120e0d6')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_c77f74ed-0238-4bdf-b164-daec5120e0d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c77f74ed-0238-4bdf-b164-daec5120e0d6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c77f74ed-0238-4bdf-b164-daec5120e0d6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c77f74ed-0238-4bdf-b164-daec5120e0d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue,threading

q &lt;/span&gt;=&lt;span&gt; queue.Queue()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Producer(name):
  count &lt;/span&gt;=&lt;span&gt; 0
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;10&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;making........&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    q.put(count)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Producer %s has produced %s baozi..&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name, count))
    count &lt;/span&gt;+=1&lt;span&gt;
    q.task_done()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; q.join()&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Consumer(name):
  count &lt;/span&gt;=&lt;span&gt; 0
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; count &amp;lt;10&lt;span&gt;:
        time.sleep(random.randrange(&lt;/span&gt;4&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; if not q.empty():&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting.....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        q.join()
        data &lt;/span&gt;=&lt;span&gt; q.get()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eating....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;4&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; q.task_done()&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1mConsumer %s has eat %s baozi...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name, data))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; else:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print(&quot;-----no baozi anymore----&quot;)&lt;/span&gt;
        count +=1&lt;span&gt;

p1 &lt;/span&gt;= threading.Thread(target=Producer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A君&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
c1 &lt;/span&gt;= threading.Thread(target=Consumer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B君&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
c2 &lt;/span&gt;= threading.Thread(target=Consumer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C君&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
c3 &lt;/span&gt;= threading.Thread(target=Consumer, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D君&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))

p1.start()
c1.start()
c2.start()
c3.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       就是说A君做好包子了，告诉队列，顾客这边在jion状态，包子没做好就一直等着，知道队列收到了包子做好的消息，也会告诉顾客能吃包子了，所以这里q.task_done()和q.join（）是成对出现的，单个使用没什么意义，你也可以试试在厨师和顾客中调换位置使用。&lt;/p&gt;
&lt;p&gt;       线程的知识就讲到这里了，下面要说的是进程的内容，如果前面线程都掌握了，进程就相当简单，大同小异了。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 07:26:00 +0000</pubDate>
<dc:creator>彭方炎QAQ</dc:creator>
<og:description>线程同步条件、信号量及队列 同步条件（event） 下面是官方文档对event的一些解释： An event is a simple synchronization object; the event</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengfy/p/10723823.html</dc:identifier>
</item>
<item>
<title>Python后台开发Django（ 模板 与 值匹配 ） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10497245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10497245.html</guid>
<description>&lt;h2&gt; 模板文件（templates）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在setting.py中，设置模板存放位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201903/1485202-20190308170941287-207411060.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在APP中view的使用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
from django.shortcuts import render #导入
def&lt;span&gt; homex(requestx):
   return render(requestx,&quot;loginx.html&quot;) #返回文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面模板&lt;/p&gt;
&lt;p&gt;实现页面的布局重复利用，建立模板中内部的名字如果在匹配中没有进行值替换，则显示原数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立页面模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在需要替换值的地方写入如下即可，其中dongdata1为内部名字，模板文件名任意，如tempx.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% block dongdata1 %} &amp;lt;span&amp;gt;555&amp;lt;/span&amp;gt; {% endblock %&lt;span&gt;}
{% block dongdata2 %} &amp;lt;spna&amp;gt;666&amp;lt;/spna&amp;gt;{% endblock %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用页面模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用模板的HTML文件中进行值替换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!--继承模板的文件名，只能有一个 --&amp;gt;&lt;span&gt;
{% extends &quot;tempx.html&quot; %&lt;span&gt;}

&amp;lt;!--替换模板的对应值--&amp;gt;&lt;span&gt;
{% block dongdata1 %&lt;span&gt;}
&amp;lt;div&amp;gt;222222222222222222&amp;lt;/div&amp;gt;&lt;span&gt;
{% endblock %&lt;span&gt;}

{% block dongdata3 %&lt;span&gt;}
&amp;lt;h1&amp;gt;东小东&amp;lt;/h1&amp;gt;&lt;span&gt;
{% endblock %}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;页面模板2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入HTML片段，在指定的地方引入，一个文件中可以多出引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{% include &quot;tempx2.html&quot; %}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;值匹配&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单值替换：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传递单独变量，也可以是字典和列表&lt;/p&gt;
&lt;p&gt;模板（templates）的html文件中，注册变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{dongkk1}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{dongkk2}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;APP控制器（views）设置匹配值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt; render &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; render(requestx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginx.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongkk1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换值1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongkk2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换值2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;列表：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; render(requestx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginx.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listxto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{{listxto.0}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;字典：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; render(requestx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginx.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dictxto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong22&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{{dictxto.d2}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;条件判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% &lt;span&gt;if&lt;/span&gt; dongx &amp;gt; 19 %&lt;span&gt;}
  &lt;/span&gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/img/an.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
{&lt;/span&gt;% &lt;span&gt;else&lt;/span&gt; %&lt;span&gt;}
   &lt;/span&gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/img/kkz.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
{&lt;/span&gt;% endif %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;循环替换：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于PHP的volist功能，实现在视图文件中进行列表的循环遍历，最常会使用其进行数据库表格的遍历显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201903/1485202-20190308173926049-1991402904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;APP控制器（views）设置匹配值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt; render &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; listx =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; listx.append({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; listx.append({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; listx.append({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; render(requestx, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loginx.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listxto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:listx})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板（templates）的html文件中，注册变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格头&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;昵称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格内容&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;循环遍历&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;               {% for rowx in listxto %}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{rowx.id}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{rowx.user}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{rowx.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;              {% endfor %}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环特殊匹配值&lt;/p&gt;
&lt;pre&gt;
为循环添加升序序号，起始为1：【&amp;lt;&lt;strong&gt;td&lt;/strong&gt;&amp;gt;{{forloop.counter}}&amp;lt;/&lt;strong&gt;td&lt;/strong&gt;&amp;gt;】
&lt;/pre&gt;
&lt;pre&gt;
为循环添加升序序号，起始为0：【&amp;lt;&lt;strong&gt;td&lt;/strong&gt;&amp;gt;{{forloop.counter0}}&amp;lt;/&lt;strong&gt;td&lt;/strong&gt;&amp;gt;】
&lt;/pre&gt;
&lt;pre&gt;
为循环添加倒序序号，起始为1：【&amp;lt;&lt;strong&gt;td&lt;/strong&gt;&amp;gt;{{forloop. revcounter}}&amp;lt;/&lt;strong&gt;td&lt;/strong&gt;&amp;gt;】
&lt;/pre&gt;
&lt;pre&gt;
为循环添加倒序序号，起始为0：【&amp;lt;&lt;strong&gt;td&lt;/strong&gt;&amp;gt;{{forloop.revcounter0}}&amp;lt;/&lt;strong&gt;td&lt;/strong&gt;&amp;gt;】
&lt;/pre&gt;
&lt;pre&gt;
查看是否是第一条循环，返回bool【{{forloop.first}}】
&lt;/pre&gt;
&lt;pre&gt;
查看是否是最后一条循环，返回bool【{{forloop.last}}】
&lt;/pre&gt;
&lt;h2&gt;匹配值修饰符：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是否支持&lt;span lang=&quot;EN-US&quot;&gt;html代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值匹配时如果传递的值是&lt;span lang=&quot;EN-US&quot;&gt;html的代码，显示时会以原字符串显示，不会被浏览器解释，如果加上【&lt;span lang=&quot;EN-US&quot;&gt;|safe】则表示此值可以被浏览器解释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{{ dongname|safe}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;自定义修饰符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span lang=&quot;EN-US&quot;&gt;Django工程的&lt;span lang=&quot;EN-US&quot;&gt;setting.py的【&lt;span lang=&quot;EN-US&quot;&gt;INSTALLED_APPS = []】添加对应&lt;span lang=&quot;EN-US&quot;&gt;APP的名字【&lt;span lang=&quot;EN-US&quot;&gt;'dongapp2',】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
在对应的&lt;span lang=&quot;EN-US&quot;&gt;APP下建立&lt;span lang=&quot;EN-US&quot;&gt;templatetags目录，并在目录下建立任意名字的&lt;span lang=&quot;EN-US&quot;&gt;Python文件，如&lt;span lang=&quot;EN-US&quot;&gt;Dongtemp.py&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span lang=&quot;EN-US&quot;&gt;Dongtemp.py下：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django &lt;span&gt;import&lt;/span&gt;&lt;span&gt; template
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; register =&lt;span&gt; template.Library()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;*****方式一****************************&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不带参数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dongstr():
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;东小东小&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;带参数,参数可有任意个&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dongcom(x,y):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x+&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;*****方式二**************************&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最多带两个参数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;@register.filter
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dongstr222(x,y):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;带一个参数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@register.filter
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dongstr333(x):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; str(x).upper()
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
在视图模板中使用
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{% load Dongtemp %&lt;span&gt;}
&amp;lt;div&amp;gt;{% dongstr %}&amp;lt;/div&amp;gt; &amp;lt;!--  东小东小  --&amp;gt;
&amp;lt;div&amp;gt;{% dongcom 10 30 %}&amp;lt;/div&amp;gt;&amp;lt;!--  40  --&amp;gt;
&amp;lt;div&amp;gt;{{&quot;参数1&quot;|dongstr222:&quot;参数2&quot;}}&amp;lt;/div&amp;gt;&amp;lt;!-- 参数1--参数2   --&amp;gt;
&amp;lt;div&amp;gt;{{&quot;xYz&quot;|dongstr333}}&amp;lt;/div&amp;gt;&amp;lt;!--  XYZ  --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 17 Apr 2019 06:56:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>模板文件（templates） 在setting.py中，设置模板存放位置 在APP中view的使用 页面模板 实现页面的布局重复利用，建立模板中内部的名字如果在匹配中没有进行值替换，则显示原数据 建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10497245.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 56 IS4使用OpenID Connect添加用户认证 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10723291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10723291.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　在前二篇中讲到了客户端授权的二种方式: GrantTypes.ClientCredentials凭据授权和GrantTypes.ResourceOwnerPassword密码授权，都是OAuth2.0协议。本篇使用OpenID Connect添加用户认证，客户端授权是GrantTypes.Implicit隐式流授权，是OCID协议。 本篇示例中只有二个项目：一个IdentityServer的mvc应用程序，一个客户端mvc应用程序(用户client端)。&lt;/p&gt;
&lt;p&gt;　　　　下面介绍身份认证交互流程：&lt;/p&gt;
&lt;p&gt;　　　　　　(1) 先启动IdentityServer程序http://localhost:5000&lt;/p&gt;
&lt;p&gt;　　　　　　(2) 启动客户端MvcClient程序http://localhost:5002&lt;/p&gt;
&lt;p&gt;　　　　　　(3) Client用户访问http://localhost:5002/Secure时，想获取个人信息和资料信息，如果用户没有进行身份认证，OIDC会重定向&lt;/p&gt;
&lt;p&gt;　　　　　　(4) 重定向到IdentityServer服务端站点的登录页：http://localhost:5000/Account/Login?ReturnUrl=xxx&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190417141635895-1363003408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(5) 用户登录成功后。自动跳回到MvcClient客户端站点，访问地址http://localhost:5002/Home/Secure。获取了当前个人信息和资料信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190417141724821-1348921339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的步骤了解到：Client用户要访问个人信息时，必须先进行，交互式用户身份验证Account/Login，验证通过后，客户端浏览器会保存服务令牌在cookie中。 &lt;span&gt;需要注意的是：在隐式授权中，令牌是通过浏览器传输，在MvcClient客户端程序中用HttpClient获取cookie中的令牌来请求api,返回是http 401状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　从&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Samples/tree/master/Quickstarts/3_ImplicitFlowAuthentication&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;中下载开源项目，可以快速入门启动OpenID Connect协议的交互式用户身份验证支持。在实际项目中，也可以将示例中的控制器，视图，模型和CSS整合到自己项目的IdentityServer Web应用程序中。&lt;/p&gt;

&lt;h3&gt;二. IdentityServer MVC应用程序&lt;/h3&gt;
&lt;p&gt; 　　因为是交互式用户身份验证，必须有UI界面，所以IdentityServer是一个MVC应用程序。下面是示例项目目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190417142434719-1577563495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　Account：客户端站点重定向到服务端站点，用于用户登录或注销。&lt;/p&gt;
&lt;p&gt;　　　　Grants： 用于撤销客户端访问权限。&lt;/p&gt;
&lt;p&gt;　　　　Consent ：是用户登录成功后，跳转到授权许可的UI界面。用户可以决定是否要将他的身份信息发布到客户端应用程序。&lt;/p&gt;
&lt;p&gt;　　　　Device ：是设备流交互服务。&lt;/p&gt;
&lt;p&gt;　　　　Diagnostics： 是诊断查看个人身份认证cookie信息。&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;strong&gt;1.1 定义客户端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　在config.cs类中，定义客户端，将 OpenID Connect隐式流添加到客户端。基于OpenID Connect的客户端与OAuth 2.0客户端非常相似。但由于OIDC中的流程始终是交互式的，因此我们需要在配置中添加一些重定向URL。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no interactive user, use the clientid/secret for authentication&lt;/span&gt;
                    AllowedGrantTypes =&lt;span&gt; GrantTypes.ClientCredentials,

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; secret for authentication&lt;/span&gt;
                    ClientSecrets =&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scopes that client has access to&lt;/span&gt;
                    AllowedScopes = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; resource owner password grant client&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro.client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPassword,

                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                    AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;// OpenID Connect implicit flow client (MVC)&lt;/span&gt;
                &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; Client&lt;/strong&gt;&lt;/span&gt;
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MVC Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.Implicit,
                     
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OIDC中的流程始终是交互式的
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录后要重定向到哪里&lt;/span&gt;
                    RedirectUris = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注销后重定向到哪里&lt;/span&gt;
                    PostLogoutRedirectUris = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与OAuth 2.0类似，OpenID Connect也使用范围概念，与OAuth相比，&lt;span&gt;&lt;strong&gt;OIDC中的范围不代表API，而是代表用户ID，名称或电子邮件地址等身份数据&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;
                    AllowedScopes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主题id，也是用户唯一ID(最低要求)&lt;/span&gt;
&lt;span&gt;                        IdentityServerConstants.StandardScopes.OpenId,
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;个人信息的claims，名称或电子邮件地址等身份数据&lt;/span&gt;
&lt;span&gt;                        IdentityServerConstants.StandardScopes.Profile
                    }
                }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　1.2 定义OIDC范围&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; GetIdentityResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile(),
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;1.3 在Startup启动类中启动 IdentityServer服务&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; services.AddIdentityServer()
                .AddInMemoryIdentityResources(Config.&lt;span&gt;GetIdentityResources&lt;/span&gt;())
                .AddInMemoryApiResources(Config.GetApis())
                .AddInMemoryClients(Config.GetClients())
                .AddTestUsers(Config.GetUsers());    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二. MvcClient 客户端应用程序&lt;/h3&gt;
&lt;p&gt;　　2.1 Startup启动类&lt;/p&gt;
&lt;p&gt;　　　　添加对OpenID Connect身份验证的支持，在启动时将以下代码添加到ConfigureServices方法中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭了JWT声明类型映射&lt;/span&gt;
&lt;span&gt;            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加authentication 到服务集合中&lt;/span&gt;
            services.AddAuthentication(options =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用cookie本地登录用户&lt;/span&gt;
                    options.DefaultScheme = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户登录时，使用OpenID连接协议。&lt;/span&gt;
                    options.DefaultChallengeScheme = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                })
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加对cookie的处理支持&lt;/span&gt;
                .AddCookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;oidc处理程序&lt;/span&gt;
                .AddOpenIdConnect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;受信任的IdentityServer服务地址&lt;/span&gt;
                    options.Authority = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端标识&lt;/span&gt;
                    options.ClientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IdentityServer中的令牌持久化到cookie中（客户端浏览器中）&lt;/span&gt;
                    options.SaveTokens = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    
                });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个请求都能执行身份验证服务&lt;/span&gt;
&lt;span&gt;            app.UseAuthentication();

            app.UseStaticFiles();
            app.UseMvcWithDefaultRoute();
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.2 访问个人信息　　&lt;/p&gt;
&lt;p&gt;　　　　由于使用的是OpenID Connect，是基于浏览器的交互式身份认证。在action中添加一个[Authorize],会触发身份验证握手。下面Secure方法，显示当前用户的声明以及cookie属性。 握手时重定向到IdentityServer服务站点下进行登录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;身份验证握手，采用oidc，重定向到IdentityServer进行登录&lt;/span&gt;
&lt;span&gt;        [Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Secure()
        {
            ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secure page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面是Secure视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using Microsoft.AspNetCore.Authentication

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Claims&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 显示用户声明&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
    @foreach (var claim in User.Claims)
    {
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@claim.Type&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@claim.Value&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Properties&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 显示身份认中的cookie &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
    @foreach (var prop in (await Context.AuthenticateAsync()).Properties.Items)
    {
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@prop.Key&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@prop.Value&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.3 注销&lt;/p&gt;
&lt;p&gt;　　　　使用IdentityServer等身份验证服务，仅清除本地应用程序cookie是不够的(客户端浏览器)。此外，还需要向IdentityServer进行往返以清除中央单点登录会话。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　public&lt;/span&gt;&lt;span&gt; IActionResult Logout()
　　　　{
   　　　　 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SignOut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　触发Logout后，会清除本地cookie(客户端浏览器)，然后重定向到IdentityServer。IdentityServer将清除其cookie(服务端浏览器)，然后为用户提供返回MVC应用程序的链接。&lt;/p&gt;

&lt;p&gt;　参考文献&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/quickstarts/3_interactive_login.html#&quot; target=&quot;_blank&quot;&gt;使用OpenID Connect添加用户认证&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 06:53:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 在前二篇中讲到了客户端授权的二种方式: GrantTypes.ClientCredentials凭据授权和GrantTypes.ResourceOwnerPassword密码授权，都是OAu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10723291.html</dc:identifier>
</item>
<item>
<title>Qt教程——从零开始的学生管理系统 - suvvm</title>
<link>http://www.cnblogs.com/suvvm/p/10723449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suvvm/p/10723449.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一、项目设计&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;　　1、需求分析&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　记录并处理学生成绩信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1）添加新的学生数据；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2）根据学号对已有的学生数据进行修改；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3）根据学号删除已存在的学生信息；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4）根据学号查询学生信息；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5）根据各门成绩与平均成绩进行排序。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　2、窗口设计&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　1）菜单窗口；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2）添加学生窗口；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3）修改信息窗口（包括删除信息）；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4）查询学生窗口&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5）排序窗口；&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　3、数据结构设计&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　以一个类StudentInfo储存单个学生信息，学生类中包括：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　姓名（字符串）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　学号（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　数学成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　英语成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　C语言程序设计成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　平均成绩（双浮点数）&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;二、项目制作&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;       1、建立项目&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　打开Qt Creator 文件-&amp;gt;新建文件或项目（Ctrl+N）-&amp;gt;其他项目-&amp;gt;空的Qt项目（Empty qmacke Project）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417135537743-346606840.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;       2、添加窗口&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　将其命名为StudentManagementSystem_Qt一路下一步到结束。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　右击项目名称-&amp;gt;Add New-&amp;gt;Qt -&amp;gt; Qt设计师界面模板选择Widget下一步，我们当前建立的是菜单窗口，所以将其类名命名为MenuWidget一路下一步到结束。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　以同样的方式建立添加学生窗口：AddStudentWidget、修改信息窗口：ModifyWidget、查询窗口：SelectWidget、排序窗口：SortWidget。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　完成后的项目资源管理器页面中应该有如下文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417135642056-2079261753.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　我们可以看到Qt中建立模板为widget的设计师界面就是建立了一个c++类（继承自QWidget）与其对应的ui文件 ，这个ui文件便是Qt Designer设计文件，它会在编译时生成一个ui_*.h文件，这样我们便可以用c++的方式对其进行调用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Qt Designer的详细使用方法可以看官方的手册：&lt;a href=&quot;https://doc.qt.io/archives/qt-4.8/designer-manual.html&quot;&gt;https://doc.qt.io/archives/qt-4.8/designer-manual.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　之后打开我们的menuwidget.h，会发现其中存在错误。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417135819172-1344535597.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;229&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这是因为我们的项目中没有连接Qt Widgets库，在StudentManagementSystem_Qt.pro中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
QT += widgets
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;可解决问题。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　3、实现窗口之间的切换&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　现在，就是实现我们新建立的几个窗口之间的窗口切换问题的时候了，这里我打算使用QStackedLayout实现窗口切换。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QStackedLayout继承自QLayout，提供了多页面切换的布局，一次只能看到一个界面，在我的Qt5——从零开始的Hello World教程(Qt Creator) 中提到过，大部分控件都继承自QFrame，而QFrame又继承自QWidget，所以QStackedLayout完全可以实现窗口之间的切换。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　现在我们用与上一步相同的方法建立一个窗口MainWidget。并添加一个main.cpp来写main函数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417135901363-1389249971.png&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417135912811-1823331648.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在mainwidget.h中修改MainWidget的定义，为其添加成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MenuWidget *menuwidget;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单窗口&lt;/span&gt;
AddStudentWidget *addstudentwidget;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加学生窗口&lt;/span&gt;
SelectWidget *selectwidget;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询窗口&lt;/span&gt;
ModifyWidget *modifywidget;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改窗口&lt;/span&gt;
SortWidget *sortwidget;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序窗口&lt;/span&gt;
QStackedLayout *stackLayout;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;QStackedLayout布局&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        当然，也需要引用其对应的头文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QStackedLayout&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;menuwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addstudentwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;selectwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifywidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sortwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;        在MainWidget.cpp中将MainWidget设为stackLayout布局，声明我们需要的窗口，并将其加入stackLayout布局中去。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        在MainWidget.cpp中显示调用MainWidget构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MainWidget::MainWidget(QWidget *&lt;span&gt;parent) :
    QWidget(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::MainWidget)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　处添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
menuwidget = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuWidget;
addstudentwidget &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddStudentWidget;
selectwidget &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SelectWidget;
modifywidget &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModifyWidget;
sortwidget &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SortWidget;
stackLayout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QStackedLayout;

stackLayout&lt;/span&gt;-&amp;gt;&lt;span&gt;addWidget(menuwidget);
stackLayout&lt;/span&gt;-&amp;gt;&lt;span&gt;addWidget(addstudentwidget);
stackLayout&lt;/span&gt;-&amp;gt;&lt;span&gt;addWidget(selectwidget);
stackLayout&lt;/span&gt;-&amp;gt;&lt;span&gt;addWidget(modifywidget);
stackLayout&lt;/span&gt;-&amp;gt;&lt;span&gt;addWidget(sortwidget);

setLayout(stackLayout);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;    之后就需要使用Qt designer 设计页面了（当然在对应类中手动添加成员控件也没有任何问题）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       双击mainwidget.ui就打开了设计页面&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       在menuwidget中添加如下按钮（push button）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417140255883-1145969539.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　以同样的方法在addstudentwidget,selectwidget,modifywidget,sortwidget中都添加一个返回按钮returnButton。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417140423744-971443667.png&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　为这些按钮设计点击槽函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;menuwidget.h:
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_addButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_selectButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_modifyButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_sortButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; on_exitButton_clicked();
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;    还需要一个方法作为stackLayout切换页面的信号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt; number);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;    在menuwidget.cpp中给出函数定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MenuWidget::on_addButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MenuWidget::on_selectButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MenuWidget::on_modifyButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MenuWidget::on_sortButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MenuWidget::on_exitButton_clicked(){
    QApplication::exit();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;emit  把connect把信号和槽进行关联，emit某个信号，就相当于调用这个信号connect时所关联的槽函数。至于更多关于 emit信息诸位可以搜索或者看帮助文档。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;之后为addstudentwidget,selectwidget,modifywidget,sortwidget窗口中的按钮设计信号与槽函数&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在（类名）.h中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; on_returnButton_clicked();
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;在（类名）.cpp中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; （类名）::on_returnButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　现在可以使用的只有退出按钮，跳转按钮还需要在mainwidget.cpp中用connect函数连接。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　到此为止便完成了页面切换功能。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　到次为止的源码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              &lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　4、完善窗口设计&lt;/h3&gt;
&lt;h4 align=&quot;left&quot;&gt;       1：AddStudentWidget&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;       我们需要提示标签来指明输入的数据，也需要输入框来接收用户的输入，QLabel与QLineEdit可以满足我们的要求。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QLabel，QLineEdit有方法setText(“内容”)来改变其显示的文字，有方法setGeometry (起始横坐标，起始纵坐标，宽， 高)来设置左上角起始位置与大小。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　当然这些都可以在Qt Designer中直接设置。打开addstudentwidget.ui。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　根据之前设计的数据结构，需要nameLineEdit、idLineEdit、mathLineEdit、enLineEdit、cLineEdit五个QLineEdit接收学生的姓名、学号、数学成绩、英语成绩、C语言成绩（平均成绩由计算得出），需要nameLabel、idLabel、mathLabel、enLabel、cLabel五个QLabel提醒用户输入数据，需要addButton 一个QPushButton来添加学生。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　最终将addstudentwidget页面设计为。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417141128411-873116665.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　2：modifyWidget&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;　　我们需要nameLineEdit、idLineEdit、mathLineEdit、enLineEdit、cLineEdit五个QLineEdit接收学生的姓名、学号、数学成绩、英语成绩、C语言成绩（平均成绩由计算得出），需要nameLabel、idLabel、mathLabel、enLabel、cLabel五个QLabel提醒用户输入数据，需要deleteButton、modifyButton 两个QPushButton来根据学号删除学生，和根据学号修改学生信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417141145625-303859315.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　3：selectwidget&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;　　我们需要idLabel一个QLabel提醒用户输入数据，需要idLineEdit一个QLineEdit接收学生的学号，之后需要nameLabel、avgLabel、mathLabel、enLabel、cLabel五个QLabel提醒用户显示的数据，需要showNameLabel、showMathLabel、showEnLabel、showCLabel、showAvgLabel五个QLabel来接收查询到的数据，需要selectButton一个QPushButton来提交查询。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417141209265-1987825417.png&quot; alt=&quot;&quot; width=&quot;340&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　4：sortwidget&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;　　QRadioButton单选框可以解决我们的排序根据选择问题&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　（当然，许多方法都可以，这里只演示QRadioButton）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QTableWidget表格可以用来显示排序后的信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　我们需要mathRadioButton、enRadioButton、cRadioButton、avgRadioButton四个QRadioButton来选择排序的根据，需要sortButton一个QPushButton来提交排序，需要tableWidget一个 QTableWidget来显示排序结果。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417141240402-1168770826.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;199&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;到此为止的源码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_1(uiOnly)&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_1(uiOnly)&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　5、完成学生类的设计&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;       之前在数据结构设计中我们已经设计好了，以一个类StudentInfo储存单个学生信息，学生类中包括：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   姓名（字符串）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   学号（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   数学成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   英语成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   C语言程序设计成绩（整型）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   平均成绩（双浮点数）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在着手去实现它&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       右击项目Add New选择C++ C++Class 为它起名叫StudentInfo之后下一步到完成，在studentinfo.h中为其创建对应的私有变量，及其对应的get与set函数。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　studentinfo.h&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentInfo
{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    QString name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, math, english, languageC;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; avg;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    StudentInfo();
    StudentInfo(QString tname, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tid, &lt;span&gt;int&lt;/span&gt; tmath, &lt;span&gt;int&lt;/span&gt; tenglish, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tlanguageC){
        name &lt;/span&gt;=&lt;span&gt; tname;
        id &lt;/span&gt;=&lt;span&gt; tid;
        math &lt;/span&gt;=&lt;span&gt; tmath;
        english &lt;/span&gt;=&lt;span&gt; tenglish;
        languageC &lt;/span&gt;=&lt;span&gt; tlanguageC;
        avg &lt;/span&gt;= (tmath + tenglish + tlanguageC) / &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    QString getName(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getMath(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; math;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getEnglish(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; english;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLanguageC(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; languageC;
    }
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; getAvg(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; avg;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; tid){
        id &lt;/span&gt;=&lt;span&gt; tid;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(QString tname){
        name &lt;/span&gt;=&lt;span&gt; tname;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setMath(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; tmath){
        math &lt;/span&gt;=&lt;span&gt; tmath;
        avg &lt;/span&gt;= (math + english + languageC) / &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setEnglish(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; tenglish){
        english &lt;/span&gt;=&lt;span&gt; tenglish;
        avg &lt;/span&gt;= (math + english + languageC) / &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setLanguageC(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; tlanguageC){
        languageC &lt;/span&gt;=&lt;span&gt; tlanguageC;
        avg &lt;/span&gt;= (math + english + languageC) / &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;　　6、完善添加学生信息&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;       打开addstudentwidget.h为”添加”按钮设计点击槽函数，由于我们设计用文件对学生信息进行储存，所以需要引用QFile，这里我使用对话框来提示用户操作中的各种问题，所以需要引入QMessageBox。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QMessageBox中有很多类型的对话框，各对话框的用法这里就不详细介绍了，这里我们只介绍我们即将用到的QMessageBox::about&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QMessageBox::about(NULL, &quot;About&quot;, &quot;About this application&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　其中三个参数分别对应，父窗口对象， 对话框标题， 对话框内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在addstudentwidget.cpp中给出函数定义：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在lineEdit中取出用户输入的数据，lineEdit拥有text()方法，会返回一个QString，而QString中又拥有入toInt() toDouble()等各种类型转换函数，可以适应我们的大多数要求。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　打开数据文件将我们刚刚获取的数据追加在文件结尾。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　addstudentwidget.h&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef ADDSTUDENTWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; ADDSTUDENTWIDGET_H&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QFile&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QMessageBox&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddStudentWidget;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; AddStudentWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; AddStudentWidget(QWidget *parent =&lt;span&gt; nullptr);
    &lt;/span&gt;~&lt;span&gt;AddStudentWidget();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Ui::AddStudentWidget &lt;/span&gt;*&lt;span&gt;ui;
signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_returnButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_addButton_clicked();
};
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ADDSTUDENTWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 align=&quot;left&quot;&gt;　　addstudentwidget.cpp&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addstudentwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_addstudentwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
AddStudentWidget::AddStudentWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::AddStudentWidget)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}
AddStudentWidget::&lt;/span&gt;~&lt;span&gt;AddStudentWidget()
{
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AddStudentWidget::on_returnButton_clicked(){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;主菜单&quot;按钮点击&lt;/span&gt;
    emit display(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AddStudentWidget::on_addButton_clicked(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;添加&quot;按钮点击&lt;/span&gt;
    QString name = ui-&amp;gt;nameLineEdit-&amp;gt;&lt;span&gt;text();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的姓名由nameLineEdit取出&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; id = ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的学号由idLineEdit取出，并转换为整型&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; math = ui-&amp;gt;mathLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的学号由mathLineEdit取出，并转换为整型&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; english = ui-&amp;gt;enLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的学号由enLineEdit取出，并转化为整型&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; languageC = ui-&amp;gt;cLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的学号由cLineEdit取出，并转化为整型&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;nameLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;idLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;mathLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;enLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;cLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的五项数据都不能为空，否则在读取文件时会出现问题。&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;存在空项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    QFile file(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个QFile file为我们的数据文件student.txt&lt;/span&gt;
    file.open(QIODevice::WriteOnly|QIODevice::Text|&lt;span&gt;QIODevice::Append);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;open()可以用来打开文件这里QIODevice::WriteOnly代表将文件以只写的方式打开
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QIODevice::Text代表我们打开的是文本文件，QIODevice::Text会对end-of-line结束符进行转译
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QIODevice::Append以追加的方式打开，新增加的内容将被追加到文件末尾&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据文件没有打开，弹出对话框提示用户&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    QTextStream &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(&amp;amp;&lt;span&gt;file);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QTextStream可以进行一些基本的文本读写，比如QString int char之类的数据QDataStream可以进行一个如QMap QPoint之类数据的读写。&lt;/span&gt;
    &lt;span&gt;out&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;  id &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; math &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; english &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; languageC;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将我们刚刚获取的数据写入文件&lt;/span&gt;
&lt;span&gt;    file.close();
    QMessageBox::about(NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;插入成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    ui&lt;/span&gt;-&amp;gt;nameLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;mathLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;enLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;cLineEdit-&amp;gt;&lt;span&gt;clear();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将用户输入的数据清空&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;运行一下&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417142628997-69777435.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417142640980-133161709.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417142717069-1580996710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　显示插入成功，打开项目文件夹所在目录build-StudentManagementSystem开头的文件夹，我们的数据文件student就会出现在此处&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417142740686-400229227.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;打开看一看&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1447131/201904/1447131-20190417142801933-2073656640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;这样，我们的添加信息模块就完成了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以上源代码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_2(add)&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_2(add)&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;　　7、完善修改信息&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　打开modifywidget.h为”删除”与”修改”按钮设计点击槽函数,在modifywidget.cpp中给出函数定义。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　对于删除和修改操作这里我打算以文件中的数据建立一个数据类型为StudentInfo的QVector容器，容器中盛放全体学生信息。对容器进行删改操作，最后以容器内的数据覆盖原有的数据即可。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;　　modifywidget.h&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef MODIFYWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MODIFYWIDGET_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QFile&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QMessageBox&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QtDebug&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QVector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentinfo.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModifyWidget;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ModifyWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; ModifyWidget(QWidget *parent =&lt;span&gt; nullptr);
    &lt;/span&gt;~&lt;span&gt;ModifyWidget();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Ui::ModifyWidget &lt;/span&gt;*&lt;span&gt;ui;
signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; on_returnButton_clicked(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击主菜单按钮&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; on_deleteButton_clicked(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击删除按钮&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; on_modifyButton_clicked(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击修改按钮&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MODIFYWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 align=&quot;left&quot;&gt;　　modifywidget.cpp&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;modifywidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_modifywidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

ModifyWidget::ModifyWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::ModifyWidget)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}

ModifyWidget::&lt;/span&gt;~&lt;span&gt;ModifyWidget()
{
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ModifyWidget::on_returnButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ModifyWidget::on_deleteButton_clicked(){
    QVector&lt;/span&gt;&amp;lt;StudentInfo&amp;gt; allStudentInfo;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据类型为StudentInfo的QVector容器&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;idLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt;){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果id输入栏为空则输出错误提示并返回&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id不得为空!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    QFile file(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file.open(QIODevice::ReadOnly&lt;/span&gt;|&lt;span&gt;QIODevice::Text);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只读 的方式打开文本文件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据文件没有打开，弹出对话框提示用户&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QIODevice::Truncate在写入时会从文件开始处写入，覆盖原有内容&lt;/span&gt;
    QTextStream inp(&amp;amp;&lt;span&gt;file);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以file建立一个QT的文本流&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;inp.atEnd()){
        QString name;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, math, english, languageC;
        inp &lt;/span&gt;&amp;gt;&amp;gt; name &amp;gt;&amp;gt; id &amp;gt;&amp;gt; math &amp;gt;&amp;gt; english &amp;gt;&amp;gt;&lt;span&gt; languageC;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入姓名 学号 数学成绩 英语成绩 C语言成绩&lt;/span&gt;
&lt;span&gt;        allStudentInfo.push_back(StudentInfo(name, id, math, english, languageC));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用之前建立的构造函数实例化一个StudentInfo对象并将其加入allStudentInfo&lt;/span&gt;
&lt;span&gt;    }
    allStudentInfo.pop_back();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件最后会多读一个无用数据，将其拿出&lt;/span&gt;
&lt;span&gt;    file.close();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id = ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取用户输入的id&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录是否进行过删除&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(QVector&amp;lt;StudentInfo&amp;gt;::iterator it = allStudentInfo.begin(); it != allStudentInfo.end(); it++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用迭代器遍历allStudentInfo&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(it-&amp;gt;getId() == id){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到有id与该id相同的学生，就进行删除&lt;/span&gt;
&lt;span&gt;            allStudentInfo.erase(it);
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果进行过删除，弹出对话框并更新文件&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        file.open(QIODevice::WriteOnly&lt;/span&gt;|QIODevice::Text|&lt;span&gt;QIODevice::Truncate);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只写覆盖的方式打开文本文件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据文件没有打开，弹出对话框提示用户&lt;/span&gt;
            QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        QTextStream &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(&amp;amp;&lt;span&gt;file);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(auto i : allStudentInfo){
            &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; &amp;lt;&amp;lt; i.getName() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getId() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getMath() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getEnglish() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getLanguageC() &amp;lt;&amp;lt;&lt;span&gt; endl;
        }
        file.close();
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有进行删除，弹出不存在对话框&lt;/span&gt;
         QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id不存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
    ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;clear();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空id输入框&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ModifyWidget::on_modifyButton_clicked(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;nameLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;idLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;mathLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;enLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || ui-&amp;gt;cLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;){
        QMessageBox::about(NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;存在空项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    QVector&lt;/span&gt;&amp;lt;StudentInfo&amp;gt; allStudentInfo;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据类型为StudentInfo的QVector容器&lt;/span&gt;
    QFile file(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file.open(QIODevice::ReadOnly&lt;/span&gt;|&lt;span&gt;QIODevice::Text);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只读 的方式打开文本文件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据文件没有打开，弹出对话框提示用户&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QIODevice::Truncate在写入时会从文件开始处写入，覆盖原有内容&lt;/span&gt;
    QTextStream inp(&amp;amp;&lt;span&gt;file);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以file建立一个QT的文本流&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;inp.atEnd()){
        QString name;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, math, english, languageC;
        inp &lt;/span&gt;&amp;gt;&amp;gt; name &amp;gt;&amp;gt; id &amp;gt;&amp;gt; math &amp;gt;&amp;gt; english &amp;gt;&amp;gt;&lt;span&gt; languageC;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入姓名 学号 数学成绩 英语成绩 C语言成绩&lt;/span&gt;
&lt;span&gt;        allStudentInfo.push_back(StudentInfo(name, id, math, english, languageC));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用之前建立的构造函数实例化一个StudentInfo对象并将其加入allStudentInfo&lt;/span&gt;
&lt;span&gt;    }
    allStudentInfo.pop_back();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件最后会多读一个无用数据，将其拿出&lt;/span&gt;
&lt;span&gt;    file.close();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id = ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    QString name &lt;/span&gt;= ui-&amp;gt;nameLineEdit-&amp;gt;&lt;span&gt;text();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; math = ui-&amp;gt;mathLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; english = ui-&amp;gt;enLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; languageC = ui-&amp;gt;cLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(QVector&amp;lt;StudentInfo&amp;gt;::iterator it = allStudentInfo.begin(); it != allStudentInfo.end(); it++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(it-&amp;gt;getId() ==&lt;span&gt; id){
            it&lt;/span&gt;-&amp;gt;&lt;span&gt;setName(name);
            it&lt;/span&gt;-&amp;gt;&lt;span&gt;setMath(math);
            it&lt;/span&gt;-&amp;gt;&lt;span&gt;setEnglish(english);
            it&lt;/span&gt;-&amp;gt;&lt;span&gt;setLanguageC(languageC);
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果进行过修改，弹出对话框并更新文件&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        file.open(QIODevice::WriteOnly&lt;/span&gt;|QIODevice::Text|&lt;span&gt;QIODevice::Truncate);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只写覆盖的方式打开文本文件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果数据文件没有打开，弹出对话框提示用户&lt;/span&gt;
            QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        QTextStream &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(&amp;amp;&lt;span&gt;file);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(auto i : allStudentInfo){
            &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; &amp;lt;&amp;lt; i.getName() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getId() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getMath() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getEnglish() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i.getLanguageC() &amp;lt;&amp;lt;&lt;span&gt; endl;
        }
        file.close();
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有进行修改，弹出不存在对话框&lt;/span&gt;
         QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id不存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
    ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;nameLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;mathLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;enLineEdit-&amp;gt;&lt;span&gt;clear();
    ui&lt;/span&gt;-&amp;gt;cLineEdit-&amp;gt;&lt;span&gt;clear();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空所有输入框&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;这样，修改模块就完成了&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以上源代码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt%20_3(add%2Cmodify)&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt%20_3(add%2Cmodify)&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;8、查询模块&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　打开selectwidget.h为”删除”与”修改”按钮设计点击槽函数,在selectwidget.cpp中给出函数定义。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　查询可以在从文件读取时判断是否会读取到id为输入id的学生，也可以向修改一样江所有学生信息先读入到数据类型为StudentInfo的QVector容器中，在从容器中查询数据，这里我选择读入到容器的方法。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;selectwidget.h&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef SELECTWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; SELECTWIDGET_H&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QtDebug&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QFile&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QVector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QMessageBox&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentinfo.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SelectWidget;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SelectWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; SelectWidget(QWidget *parent =&lt;span&gt; nullptr);
    &lt;/span&gt;~&lt;span&gt;SelectWidget();

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Ui::SelectWidget &lt;/span&gt;*&lt;span&gt;ui;
 
signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
 
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_returnButton_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_selectButton_clicked();
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SELECTWIDGET_H&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 align=&quot;left&quot;&gt;selectwidget.cpp&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;selectwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_selectwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

SelectWidget::SelectWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::SelectWidget)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}

SelectWidget::&lt;/span&gt;~&lt;span&gt;SelectWidget()
{
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SelectWidget::on_returnButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SelectWidget::on_selectButton_clicked(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;idLineEdit-&amp;gt;text() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;){
        QMessageBox::about(NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    QFile file(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file.open(QIODevice::ReadOnly&lt;/span&gt;|&lt;span&gt;QIODevice::Text);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只读的方式打开文本文件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    QTextStream inp(&lt;/span&gt;&amp;amp;&lt;span&gt;file);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以file作为Qt文本流&lt;/span&gt;
    QVector&amp;lt;StudentInfo&amp;gt;&lt;span&gt; allStudentInfo;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据类型为StudentInfo的QVector容器&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(!inp.atEnd()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读到文件结尾&lt;/span&gt;
&lt;span&gt;        QString name;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, math, english, languageC;
        inp &lt;/span&gt;&amp;gt;&amp;gt; name &amp;gt;&amp;gt; id &amp;gt;&amp;gt; math &amp;gt;&amp;gt; english &amp;gt;&amp;gt;&lt;span&gt; languageC;
        allStudentInfo.push_back(StudentInfo(name, id, math, english, languageC));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用之前建立的构造函数实例化一个StudentInfo对象并将其加入allStudentInfo&lt;/span&gt;
&lt;span&gt;    }
    allStudentInfo.pop_back();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扔掉最后的无用数据&lt;/span&gt;
&lt;span&gt;    file.close();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; id = ui-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;text().toInt();
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(auto i : allStudentInfo){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i.getId() ==&lt;span&gt; id){
            ui&lt;/span&gt;-&amp;gt;showNameLabel-&amp;gt;&lt;span&gt;setText(i.getName());
            ui&lt;/span&gt;-&amp;gt;showMathLabel-&amp;gt;&lt;span&gt;setText(QString::number(i.getMath()));
            ui&lt;/span&gt;-&amp;gt;showEnLabel-&amp;gt;&lt;span&gt;setText(QString::number(i.getEnglish()));
            ui&lt;/span&gt;-&amp;gt;showCLabel-&amp;gt;&lt;span&gt;setText(QString::number(i.getLanguageC()));
            ui&lt;/span&gt;-&amp;gt;showAvgLabel-&amp;gt;&lt;span&gt;setText(QString::number(i.getAvg()));
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;flag){
       QMessageBox::about(NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id不存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    ui&lt;/span&gt;-&amp;gt;idLineEdit-&amp;gt;&lt;span&gt;clear();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;以上源代码&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_4(add%2Cmodify%2Cselect)&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_4(add%2Cmodify%2Cselect)&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;9、排序模块&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　老样子，将数据从文件中读入数据类型为StudentInfo的QVector容器后进行排序就容易很多了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　我们需要排序时只能根据数学、英语、C语言、平均成绩中的一种进行排序，所以我们要做到代表这四种排序方式的QRedioButton有且只有一个能被选中，我们可以将其加入一个QButtonGroup，这样便可以实现这个需求，至于显示排序后的数据我们可以显示在表格控件QTableWidget中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QButtonGroup直接继承自QObject，他有一个属性exclusive当这个属性为真时，所有在QButtonGroup内的按钮同一时间只有一个可以被选择。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QButtonGroup我们用到了addButton添加按钮 与checkedId获取选中按钮的id两个方法，其他方法诸位可以自己去搜索。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QTableWidget继承自QTableView，QTableView可以自定义的数据模型显示内容(setModel)但是QTableWidget不行，QTableWidget有固定的数据模型，在像其中填入数据时只需要一个单元格一个单元格的填好就可以了（setItem）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　QTableWidget我们用到了setHorizontalHeaderLabels设置水平表头标签horizontalHeader()-&amp;gt;setSectionResizeMode(QHeaderView::Stretch); 设置根据总宽度调整列宽；setRowCount设置行数；setItem设置单元格，其他方法诸位可以自己去搜索。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;sortwidget.h&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef SORTWIDGET_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; SORTWIDGET_H&lt;span&gt;
 
#include &lt;/span&gt;&amp;lt;QWidget&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QButtonGroup&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QVector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QFile&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QMessageBox&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentinfo.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SortWidget;
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SortWidget : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QWidget
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; SortWidget(QWidget *parent =&lt;span&gt; nullptr);
    &lt;/span&gt;~&lt;span&gt;SortWidget();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Ui::SortWidget &lt;/span&gt;*&lt;span&gt;ui;
    QButtonGroup &lt;/span&gt;*&lt;span&gt;sortButtonGroup;
signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; display(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number);
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; on_returnButton_clicked(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回菜单&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; on_sortButton_clicked();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SORTWIDGET_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 align=&quot;left&quot;&gt;sortwidget.cpp&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sortwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_sortwidget.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;

SortWidget::SortWidget(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QWidget(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::SortWidget)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    sortButtonGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QButtonGroup();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化sortButtonGroup&lt;/span&gt;
    sortButtonGroup-&amp;gt;addButton(ui-&amp;gt;mathRadioButton, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将代表数学的单选框加入sortButtonGroup并将其id设为0
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不建议使用默认id，默认id是由-2开始依次递减的&lt;/span&gt;
    sortButtonGroup-&amp;gt;addButton(ui-&amp;gt;enRadioButton, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将代表英语的单选框加入sortButtonGroup并将其id设为1&lt;/span&gt;
    sortButtonGroup-&amp;gt;addButton(ui-&amp;gt;cRadioButton, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将代表C语言的单选框加入sortButtonGroup并将其id设为2&lt;/span&gt;
    sortButtonGroup-&amp;gt;addButton(ui-&amp;gt;avgRadioButton, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将代表平均的单选框加入sortButtonGroup并将其id设为3&lt;/span&gt;
    ui-&amp;gt;avgRadioButton-&amp;gt;setChecked(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;平均成绩默认选中&lt;/span&gt;
    ui-&amp;gt;tableWidget-&amp;gt;setColumnCount(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    QStringList headerLabels;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;QStringList headerLabels用来记录表格表头数据&lt;/span&gt;
    headerLabels &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C语言&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt;&amp;lt; tr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;平均&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;&lt;span&gt;setHorizontalHeaderLabels(headerLabels);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; void setHorizontalHeaderLabels(const QStringList &amp;amp;labels);设置水平表头标签&lt;/span&gt;
    ui-&amp;gt;tableWidget-&amp;gt;horizontalHeader()-&amp;gt;&lt;span&gt;setSectionResizeMode(QHeaderView::Stretch);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置根据总宽度调整列宽&lt;/span&gt;
    ui-&amp;gt;tableWidget-&amp;gt;setRowCount(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始行数设为一行&lt;/span&gt;
&lt;span&gt;}

SortWidget::&lt;/span&gt;~&lt;span&gt;SortWidget()
{
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SortWidget::on_returnButton_clicked(){
    emit display(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}
 
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; getStudentInfo(QVector&amp;lt;StudentInfo&amp;gt; &amp;amp;allStudentInfo){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取信息成功返回true 否则返回false&lt;/span&gt;
    QFile file(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    file.open(QIODevice::ReadOnly&lt;/span&gt;|&lt;span&gt;QIODevice::Text);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以只读方式打开文本文件student.txt&lt;/span&gt;
    QTextStream inp(&amp;amp;&lt;span&gt;file);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!file.isOpen()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!inp.atEnd()){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读到文件结尾&lt;/span&gt;
&lt;span&gt;        QString name;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, math, english, languageC;
        inp &lt;/span&gt;&amp;gt;&amp;gt; name &amp;gt;&amp;gt; id &amp;gt;&amp;gt; math &amp;gt;&amp;gt; english &amp;gt;&amp;gt;&lt;span&gt; languageC;
        allStudentInfo.push_back(StudentInfo(name, id, math, english, languageC));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用之前声明的构造函数实例化一个StudentInfo对象并将其加入allStudentInfo&lt;/span&gt;
&lt;span&gt;    }
    allStudentInfo.pop_back();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扔掉最后的无用数据&lt;/span&gt;
&lt;span&gt;    file.close();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; cmp_math(StudentInfo a, StudentInfo b){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数学排序&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; a.getMath() &amp;gt;&lt;span&gt; b.getMath();
}
 
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; cmp_English(StudentInfo a, StudentInfo b){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;英语排序&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; a.getEnglish() &amp;gt;&lt;span&gt; b.getEnglish();
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; cmp_languageC(StudentInfo a, StudentInfo b){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;C语言排序&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; a.getLanguageC() &amp;gt;&lt;span&gt; b.getLanguageC();
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; cmp_avg(StudentInfo a, StudentInfo b){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平均成绩排序&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; a.getAvg() &amp;gt;&lt;span&gt; b.getAvg();
}
 
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; SortWidget::on_sortButton_clicked(){
    ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;&lt;span&gt;clearContents();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空除表头外的所有数据
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若想清除表头可使用clear()&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sortTag = sortButtonGroup-&amp;gt;&lt;span&gt;checkedId();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得当前选中的单选框的id&lt;/span&gt;
    QVector&amp;lt;StudentInfo&amp;gt;&lt;span&gt; allStudentInfo;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据类型为StudentInfo的QVector容器&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!getStudentInfo(allStudentInfo)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从文件读取数据到allStudentInfo&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取失败直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(allStudentInfo.empty()){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;allStudentInfo中没有数据&lt;/span&gt;
        QMessageBox::about(NULL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;反馈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有学生信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (sortTag) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sortTag==0根据数学进行排序&lt;/span&gt;
&lt;span&gt;            std::sort(allStudentInfo.begin(), allStudentInfo.end(), cmp_math);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sortTag==1根据英语进行排序&lt;/span&gt;
&lt;span&gt;            std::sort(allStudentInfo.begin(), allStudentInfo.end(), cmp_English);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sortTag==2根据C语言进行排序&lt;/span&gt;
&lt;span&gt;            std::sort(allStudentInfo.begin(), allStudentInfo.end(), cmp_languageC);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sortTag==3根据平均成绩进行排序&lt;/span&gt;
&lt;span&gt;            std::sort(allStudentInfo.begin(), allStudentInfo.end(), cmp_avg);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;&lt;span&gt;setRowCount(allStudentInfo.size());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将表格的行数设为与学生数量相同
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则setItem添加单元格不会生效&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; allStudentInfo.size(); i++&lt;span&gt;){
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(allStudentInfo[i].getName()));
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(QString::number(allStudentInfo[i].getId())));
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(QString::number(allStudentInfo[i].getMath())));
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(QString::number(allStudentInfo[i].getEnglish())));
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(QString::number(allStudentInfo[i].getLanguageC())));
        ui&lt;/span&gt;-&amp;gt;tableWidget-&amp;gt;setItem(i, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTableWidgetItem(QString::number(allStudentInfo[i].getAvg())));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置各单元格的数据，非QString类型的数据需要转换为QString&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;到此为止我们整个项目便完成了，以后可能还会继续完善。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;源代码&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_5(all)&quot;&gt;https://github.com/suvvm/StudentManagementSystem_Qt/tree/master/StudentManagementSystem_Qt_5(all)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 06:44:00 +0000</pubDate>
<dc:creator>suvvm</dc:creator>
<og:description>Qt教程——从零开始的学生管理系统（文件） 一、项目设计 1、需求分析 记录并处理学生成绩信息。 1）添加新的学生数据； 2）根据学号对已有的学生数据进行修改； 3）根据学号删除已存在的学生信息； 4</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suvvm/p/10723449.html</dc:identifier>
</item>
<item>
<title>负载均衡实现之随机数 - 梓&amp;艺</title>
<link>http://www.cnblogs.com/love-wzy/p/10718972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-wzy/p/10718972.html</guid>
<description>&lt;p&gt;负载均衡(LoadBalance)，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的请求。&lt;/p&gt;
&lt;p&gt;​ 常见的负载均衡的实现方法有多种，如随机、轮询、hash一致性等。本文使用随机法实现负载均衡。&lt;/p&gt;
&lt;p&gt;​ 随机数法就是几个数中随机获取一个数字，然后获取这个数据对应的服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 服务器类
 */
public class Server {
    
    private String serverName;
    
    public Server(String name) {
        this.serverName = name;
    }
    
    public String getServerName() {
        return serverName;
    }
    public void setServerName(String serverName) {
        this.serverName = serverName;
    }

    @Override
    public String toString() {
        return &quot;Server{serverName:&quot;+this.getServerName()+&quot;}&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class LoadBalance_Random {
    //用来存放所有的服务器
    static List&amp;lt;Server&amp;gt; ServerList = new ArrayList&amp;lt;Server&amp;gt;();
    //随机数生成器
    private static final Random r = new Random();
    
    //初始化   模拟集群中提供服务的服务器
    static{
        Server server1 = new Server(&quot;server1&quot;);
        Server server2 = new Server(&quot;server2&quot;);
        Server server3 = new Server(&quot;server3&quot;);
        ServerList.add(server1);
        ServerList.add(server2);
        ServerList.add(server3);
    }
    
    public static void main(String[] args) {
        //模拟10个请求来获取对应的服务器
        for(int i=0;i&amp;lt;10;i++){
            Server server_random = doSelect(ServerList);
            System.out.println(server_random);
        }
    }

    /**
     * 选择服务器
     * @param serverList
     * @return
     */
    private static Server doSelect(List&amp;lt;Server&amp;gt; serverList) {
        Server server = null;
        //服务器的个数
        int serverNum = serverList.size();
        //随机获取一个
        int serverIndex = r.nextInt(serverNum);
        server = serverList.get(serverIndex);
        return server;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 执行main方法测试，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1570156/201904/1570156-20190416182854232-1401455517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 在每台服务器的配置性能等各方面都一样时，使用这种随机方法也是可取的，因为每台服务器获取的要处理的请求的数据量的概率是一样的。但是有时候，我们的服务器不一定都是相同的配置，每一台服务器的性能都有一定的差异性，导致服务器提供服务的能力的差异，比如上边我们有3台服务器，Server1每秒可处理5个请求，Server2每秒只能处理3个请求，Server3每秒只能处理2个请求，此时如果我们有10个请求过来了，我们分别给3个Server3个请求处理，由于Server3只能处理2个请求，这时就会导致服务3不可用。&lt;/p&gt;
&lt;p&gt;​ 对这种不同服务能力的服务实现负载均衡，我们可以使用加权随机法。对每个服务标记权重，提高处理能力强的服务器的权重，降低服务能力若的服务器的权重，即根据能力的大小分配对应比例的请求数。&lt;/p&gt;
&lt;p&gt;​ 修改上述代码，给服务加权重&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 服务器类
 */
public class Server {
    
    private String serverName;
    private int weight;//权重
    
    public Server(String name, int weight) {
        this.serverName = name;
        this.weight = weight;
    }
    
    @Override
    public String toString() {
        return &quot;Server{serverName:&quot;+this.getServerName()+&quot;,weight:&quot;+this.getWeight()+&quot;}&quot;;
    }
    
    // 省略getter 和 setter方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 初始化时指定服务器的权重&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //初始化   模拟集群中提供服务的服务器
    static{
        Server server1 = new Server(&quot;server1&quot;, 5);
        Server server2 = new Server(&quot;server2&quot;, 3);
        Server server3 = new Server(&quot;server3&quot;, 2);
        ServerList.add(server1);
        ServerList.add(server2);
        ServerList.add(server3);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 根据权重值获取服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static Server doSelectWithWeight(List&amp;lt;Server&amp;gt; serverList) {
        Server server = null;
        int totalWeight = 0; //所有服务器的总权重
        boolean isSame = true;//默认所有服务器的权重都相同
        
        for(int i=0; i&amp;lt;serverList.size(); i++){
            //获取当前服务器得权重
            int serverWeight = serverList.get(i).getWeight();
            //权重累加
            totalWeight = totalWeight + serverWeight;
            //i = 0时默认还是权重都一样
            //从第二个开始检测每个服务器得权重是不是都一样，只需要与它得前一个服务得权重相比就可以了
            if(isSame &amp;amp;&amp;amp; i&amp;gt;0){
                int preServerWeight = serverList.get(i-1).getWeight();
                if(serverWeight != preServerWeight){//当前服务器权重和前一个服务器得权重不相同
                    isSame = false;
                }
            }
        }
        
        if(!isSame){//服务器得权重不是都一样
            //在总权重下获取一个随机数 
            int index = r.nextInt(totalWeight);
            //
            for(int i=0;i&amp;lt;serverList.size();i++){
                int serverWeight = serverList.get(i).getWeight();
                //判断获取得随机数落在总权重得哪一个区间
                //3台服务器得得权重分别为5 3 2  总和为10  [0到5)这个区间属于服务器1  [5到8)这个区间属于服务器2 【8到10)这个区间属于服务器3
                //如 获取到得随机数是6  6-5=1   大于0  说明不在服务器1得区间，遍历  1-3= -2 小于0  说明它落在了服务器2所在得区间  就可以得对应服务器
                index = index - serverWeight;
                if(index &amp;lt; 0){
                    return serverList.get(i);
                }
            }
        }else{
            //所有服务器权重都一样时，按照完全随机法随机获取一个服务器
            server = doSelect(serverList);
        }
        return server;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 使用main方法测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
        //模拟20个请求获取对应的服务
        for(int i=0;i&amp;lt;20;i++){
            Server server_random_weight = doSelectWithWeight(ServerList);
            System.out.println(server_random_weight);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1570156/201904/1570156-20190416182914482-1214167976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从测试结果图中可以看到，权重大的获取到的请求数多，相反权重小的获取到的请求数越小。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 06:31:00 +0000</pubDate>
<dc:creator>梓&amp;amp;艺</dc:creator>
<og:description>负载均衡(LoadBalance)，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/love-wzy/p/10718972.html</dc:identifier>
</item>
<item>
<title>.NET Framework和 .Net Core实现不一致的API之 `EmailAddressAttribute` - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/emailaddressattribute-diff-implement-in-netfx-and-netcore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/emailaddressattribute-diff-implement-in-netfx-and-netcore.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;现在我们的类库项目大多是 NETStandard2.0 项目，但是 netstandard2.0 只是一个标准接口定义，具体的实现还是要看实际运行的框架，如 netfx47 或 netcoreapp2.1，可能在大部分情况下，对外表现是一致的，但是，某一些 API 可能会不一致，这里就开一篇文章收集我所遇到的表现不一致的API。&lt;/p&gt;
&lt;h2 id=&quot;emailaddressattribute&quot;&gt;EmailAddressAttribute&lt;/h2&gt;
&lt;p&gt;这个 &lt;code&gt;EmailAddressAttribute&lt;/code&gt; 是用来验证输入的邮箱地址是否合法，在 dotnetframework 下的实现是用一个很复杂正则表达式去验证的，而 dotnetcore 下的实现则比较简单，并没有使用正则表达式去验证，只是验证了输入是否包含而且仅包含一个“@”，并且“@”不是第一个字符也不是最后一个字符，具体可以参考下面的链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-bc9542d991aa9515.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dotnet fx 472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dotnet fx 472 使用的正则表达式如下（看到我就已经头晕了。。。）：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;const string pattern = @&quot;^((([a-z]|\d|[!#\$%&amp;amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;amp;'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的还有一点，就是上图中的 &lt;code&gt;AppSettings.DisableRegEx&lt;/code&gt;，来看实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-9e7429f8fb2e7067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AppSettings.DisableRegEx&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到默认是 false，然而从 net472 之后默认就会是 true，会表现出和 .netcore 一致的行为，然而我用的是 net471，于是就发现了不一致，，，从上面的截图可以看到我们也可以在 app.config/web.config 文件中设置 AppSettings 节点，设置 key 为 &lt;code&gt;dataAnnotations:dataTypeAttribute:disableRegEx&lt;/code&gt; ，value 为 &lt;code&gt;true&lt;/code&gt; 来禁用使用正则。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#System.ComponentModel.DataAnnotations/DataAnnotations/EmailAddressAttribute.cs,c3ae85dfd8a9f58c&quot;&gt;dotnet fx472 source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-d5d6216a796504a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dotnet core&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://source.dot.net/#System.ComponentModel.Annotations/System/ComponentModel/DataAnnotations/EmailAddressAttribute.cs,c3ae85dfd8a9f58c&quot;&gt;dotnet core source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet core 实现&lt;a href=&quot;https://github.com/dotnet/corefx/blob/master/src/System.ComponentModel.Annotations/src/System/ComponentModel/DataAnnotations/EmailAddressAttribute.cs&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;memo&quot;&gt;Memo&lt;/h2&gt;
&lt;p&gt;如果你希望 &lt;code&gt;EmailAddressAttribute&lt;/code&gt; 不修改配置就实现完全一致的行为，那么你可以升级 framework 到 &lt;code&gt;net472&lt;/code&gt; 或者放弃使用这个，自己定义一个正则，使用 &lt;code&gt;RegularExpressionAttribute&lt;/code&gt;，你可以用 &lt;code&gt;[RegularExpression(@&quot;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$&quot;)]&lt;/code&gt; 来代替 &lt;code&gt;[EmailAddress]&lt;/code&gt;，这个正则仅供参考，可以修改为适用自己的正则~~&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 06:30:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>现在我们的类库项目大多是 NETStandard2.0 项目，但是 netstandard2.0 只是一个标准接口定义，具体的实现还是要看实际运行的框架，如 netfx47 或 netcoreapp2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/emailaddressattribute-diff-implement-in-netfx-and-netcore.html</dc:identifier>
</item>
<item>
<title>复刻smartbits的国产网络测试工具minismb简介 - minismb</title>
<link>http://www.cnblogs.com/minismb/p/10723145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minismb/p/10723145.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;&lt;img id=&quot;uploading_image_39981&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;       复刻smartbits的国产网络性能测试工具minismb&lt;span&gt;，是一款专门用于测试智能路由器，网络交换机的性能和稳定性的软硬件相结合的工具。可以通过此工具测试任何&lt;/span&gt;ip网络设备的端口吞吐率，带宽，并发连接数和最大连接数等诸多参数指标。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;       Minismb软件在性能上与Spirent公司的smartbits软件一样，可以给用户的产品生命周期中的各个阶段提供各种分析解决方案。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;      在操作界面上也与&lt;/span&gt;Spirent公司的smartbits软件几乎一样，为用户提供图形化界面，为每个板卡模块提供交互式测试环境。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;    minismb软件工作主界面&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417135816845-1381812043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在图中最底部即为系统的状态栏，该栏右边显示了当前&lt;/span&gt;MiniSMB网络测试仪表的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在下图中红色方框标注的部分即为&lt;/span&gt;MiniSMB网络测试仪表的测试端口，每一个竖形的长方形代表一个物理端口。在该竖形长方形中Full字符代表了当前物理端口的工作状态是全双工模式。1Gb代表了当前物理端口通过自动协商达到1Gbps的端口速率。绿色的灯代表了当前的端口的状态是LinkUP，也就是激活状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417135849298-524933799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;     PCAP数据包回放&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;       可以将通过&lt;/span&gt;Wireshark等软件抓下来的数据包原样或经过任意修改后重新回放。允许你对报文做任意的修改（主要是指对2层、3层、4层报文头），指定重放报文的速度等，这样minismb就可以用来复现抓包的情景以定位bug，以极快的速度重放从而实现压力测试。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417135925241-1249671186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417135947894-1280197117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417135954311-505169642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         可以根据需要对相关参数进行修改，从而满足测试要求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140029904-1313027414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;        Minsmb网络测试仪最多可以加载16K的数据流。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140106789-1846992401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;     数据报文捕获&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;       MiniSMB网络测试仪表提供了一个非常重要的功能，就是可以实时采集数据端口的网络数据报文，该功能在对目标网络设备进行功能性测试及稳定性测试时能够起到非常重要的作用。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;       用户只需要在指定的端口图标中，点击&lt;/span&gt;start capture键，将会弹出窗体，供用户选择在本地安装的wireshark软件连接，从而Windows系统会自动起用wireshark应用程序，通过点击该程序的左上角第一个图标即可得到如下捕获数据报文的界面&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140156740-1485877054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140210140-1803665938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;     操作技巧&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       当在&lt;/span&gt;MiniSMB中定义了一条数据流，可以在Streams Setup界面中，选中此数据流，并按ctrl+c，ctrl+v复制为多条数据流。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140232173-1919772115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;         可以按&lt;/span&gt;ctrl+a，选中所有数据流，右键，在右键菜单中选择相关参数，对所有数据流进行修改。如统一修改源ip地址：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140249912-2047141965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140315010-290759467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140328600-1318543221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140336256-2127582564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;          也可以在&lt;/span&gt;Streams Setup界面中，通过鼠标点击某条数据流的某一列，进行相关修改。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140355514-2117470440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1625881/201904/1625881-20190417140402665-787632322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Apr 2019 06:05:00 +0000</pubDate>
<dc:creator>minismb</dc:creator>
<og:description>复刻smartbits的国产网络性能测试工具minismb，是一款专门用于测试智能路由器，网络交换机的性能和稳定性的软硬件相结合的工具。可以通过此工具测试任何ip网络设备的端口吞吐率，带宽，并发连接数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minismb/p/10723145.html</dc:identifier>
</item>
<item>
<title>实例解析云计算的概念 - SUBMAIL赛邮云通信</title>
<link>http://www.cnblogs.com/submail/p/10723100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/submail/p/10723100.html</guid>
<description>&lt;p&gt;&lt;span&gt;甲：我们公司的资料不让存放到个人电脑上，一般都存到云上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;乙：别逗了，你们单位就十几个人，两台服务器，没有虚拟化也没有分布式，能叫云？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;甲：咋了？几百块钱的西数NAS都叫云呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上述对话看得出甲大概是个普通人，乙是个技术宅，对话也反映出不同人眼中不同的云。那究竟什么是云呢？事实上已经有不下于一百种的定义（或许更多），相信对于大多数的小伙伴来说都是一脸懵逼，啥是云？云计算又是干哈的？别急，且听小编我慢慢道来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/fa4e056c381a645f431e1a5494fa9018.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我相信有些小伙伴肯定尝试过去了解云计算的概念，可能还查询过一些资料，本着内事不决问老婆，外事不决问百度的态度，我们先看看度娘的解释——“云计算是继1980年代大型计算机到客户端-服务器的大转变之后的又一种巨变。用户不再需要了解“云”中基础设施的细节，不必具有相应的专业知识，也无需直接进行控制。云计算描述了一种基于互联网的新的IT服务增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展而且经常是虚拟化的资源”。如果你觉得度娘不靠谱，那我们去看看度娘他娘——谷歌，不好意思，度娘他娘也是这么解释的。如果有人在我不了解专业知识之前这么回答我，我只能回复他两个字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/b2d1441dda89268ae3e346e66cfe767c.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是不是有种你在逗我的感觉，当然度娘也告诉你了，你不需要去了解细节，不必具有相应的知识。但是小编还是觉得了解一下岂不是更好。太过专业的对于外行来说听起来总是云里雾里，那下面我们还是通过实例来了解吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1878年，爱迪生发明了一种划时代的新产品——电灯泡，为了点亮它，爱先生再接再厉又发明了电流表、发电机等，这是一套完整的供电系统：爱迪生灯具公司制造灯泡，爱迪生电器公司制造发电机，爱迪生电线公司生产电线。当时，爱先生的产品只支持直流电。直流电有一个很大的缺陷，那就是不能进行长距离运输。于是，无论是个人还是企业开始独立发电，来点亮爱先生的灯泡。独立发电使得小型私人电厂遍地开花。爱先生的灯泡、电线、发电机比iPhone7卖的还火。结果就是爱先生大赚特赚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候有个叫英萨尔的出现了，他更推崇交流电。交流电可以长距离运输，有了这个基础，大量效率低的私人电厂，就能整合成一个中央电厂，通过一根电线，电能就能运输到各处使用。当然爱先生对于交流电是拒绝的，因为这会断掉他的财路：他的兴趣在于，私人电厂越多，他的设备就会卖得越好。最终，在这场交锋中，信赖交流电的英萨尔胜出了。通过中央电厂，英萨尔实现了大规模的公用电网。如此一来，原先建立私人电厂的企业或个人，就可以避免采购设备昂贵的发电设备。他们只需付一定费用，墙面的插座就能提供源源不断的电力，而不必关心这些电来自何方。这就是远见和眼光，对于英萨尔同志我只能说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/88530d8bcd7aeb1e9cd57f076006e443.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实故事中取代私人发电厂的公共电网，就是电气时代的云计算。1971年，英特尔公司发明了微型电脑。由于价格低廉，且能够完成各种任务，微型电脑很快取代主计算机，成为公司电脑运算的中心。其后，原来的主计算机被改造成了私人服务器，这些服务器下面连接着许多个人电脑。爱先生的灯泡只能搭配直流发电厂，这些个人电脑也只能使用服务器上的程序。这种模式(C/S模式)一直延续至今。正如电气时代每个企业都必须自建一个私人发电厂一样，每个企业必须配备一个私人数据中心。私人发电厂不能实现远距离传输，服务器内的信息也只能在局域网传播。私人电厂只供企业和个人使用，数据中心的信息也只供企业内部使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2005年2月，一个伟大的时刻来了，Google在俄勒冈州北部买下三十亩地准备建立一个庞大的服务器技术中心。于是，信息的公用电网出现了，这就是云计算。在这里，包含着数万、甚至数十万廉价CPU和硬盘组成的服务器，这就是信息时代的中央电厂，它把原来企业内部的服务器整合为一台机器集中处理。从此，企业再不用采购昂贵的设备，不必再培养一支庞大的技术队伍。他们只要相信，手里有一台连接网络的计算机就行，而不必担心数据存储在什么地方。随后云计算迅速地进入到我们的生活。看看YouTube每月8亿独立访问用户，但运营这些网站的，往往只有几个人，他们租用亚马逊的服务器提供服务，节省了大批资本投资。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小伙伴们，我们现在回过头看一下：是不是电线相当于宽带，电灯泡相当于电脑，私人电厂相当于私人服务器，公用电网就相当于现在的云计算。现在你是不是有一种豁然开朗的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/bb20db0d596c2217bcedee65bf1ac60d.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，还没结束，小编曾经看过一本书，书中畅想了一下未来，有一点给小编的印象很深。未来个人电脑会是什么样的？是的，电脑主机将消失，可能只剩下显示器和鼠标键盘了。因为主机上的核心部件CPU和显卡之类的运算处理功能都将由云计算服务器来代替，自然也就不需要那些多余的主机部件了。看到这里，小编总是在想，这样的日子赶紧到来吧，作为一个屌丝游戏玩家，因为自己的电脑配置太低总是被队友嘲讽为小霸王学习机，不说了，这感觉你无法理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/603fb50f0d4f939f91b73fe1f558f2d6.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我们再回到真正的云计算领域去深入了解一下，大家都知道小编目前是从事&lt;a href=&quot;http://submail.cn/&quot;&gt;云通讯&lt;/a&gt;服务的。这么说吧，云通讯算是目前云计算领域相对比较成熟的行业。除了我们SUBMAIL之外，还有一些江湖大咖，比如阿里云、AWS、Twilio等等。那具体是做什么服务的呢？比如你一个企业有短信、邮件、语音验证码、手机流量分发这样的需求，都可以找我们寻求解决。用法很简单，登录我们的平台，按部就班根据提示自助操作，几分钟就能帮你解决需要。是不是很方便快捷。当然说到这里肯定有人怀疑小编在吹牛，好吧我们现在想象一下假如没有我们这样的云通讯平台会怎么样？就拿短信来说吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先你需要去和通信运营商商谈开通一个通道，当然这个时间也许是半年，也许是一年。好了等你的通道谈妥了，你得拥有相应的开发人员，通常不是一个，而是一群。开发独立的&lt;a href=&quot;http://submail.cn/sms&quot;&gt;短信平台&lt;/a&gt;，开发完成后还得需要配置独立的服务器进行运营。这些都完成后你可以开始自己发送短信了。是不是很麻烦，需要花费大量的人力物力。千万别问我你为什么不能用手机自己一条一条的发送短信，请问一万条短信或者是十万条短信，你用手机一条一条发送，你觉得这样真的好吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/900e8acf595018fa1d1d8990ef130516.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正因为有我们，所以你现在不需要为了发送短信而完成上面的步骤，无需独立开发，无需和运营商扯皮，也不需要独立的通道，登录平台按照提示就能满足你短信发送的需求。简直比方便面还方便，比快捷键更快捷。现在相信小编不是在吹牛了吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好吧，今天就说到这里，想必小伙伴们对于云计算的概念应该有个比较全面的了解了。最后小编我表示只是做了一点微小的工作，目的是希望对大家有一定的帮助，有需要欢迎去我们网站使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://libraries.mysubmail.com/public/ad4d2541ae6c2e114b1146456876ccc9/images/97569835fad8db868bdac3d033654b57.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 05:59:00 +0000</pubDate>
<dc:creator>SUBMAIL赛邮云通信</dc:creator>
<og:description>甲：我们公司的资料不让存放到个人电脑上，一般都存到云上。 乙：别逗了，你们单位就十几个人，两台服务器，没有虚拟化也没有分布式，能叫云？ 甲：咋了？几百块钱的西数NAS都叫云呢。 通过上述对话看得出甲大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/submail/p/10723100.html</dc:identifier>
</item>
<item>
<title>在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务) - Rector</title>
<link>http://www.cnblogs.com/bobositlife/p/create-daemon-service-with-topshelf-in-csharp-application.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobositlife/p/create-daemon-service-with-topshelf-in-csharp-application.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文首发于：&lt;a href=&quot;https://codedefault.com/p/create-daemon-service-with-topshelf-in-csharp-application&quot;&gt;码友网&lt;/a&gt;&lt;/strong&gt;--一个专注.NET/.NET Core开发的编程爱好者社区。&lt;/p&gt;
&lt;h2 id=&quot;文章目录&quot;&gt;文章目录&lt;/h2&gt;
&lt;p&gt;C#/.NET基于Topshelf创建Windows服务的系列文章目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/create-windows-service-with-topshelf-in-csharp-console-application&quot;&gt;C#/.NET基于Topshelf创建Windows服务程序及服务的安装和卸载&lt;/a&gt; (1)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/create-daemon-service-with-topshelf-in-csharp-application&quot;&gt;在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务)&lt;/a&gt; (2)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codedefault.com/p/launch-a-gui-application-from-a-windows-service-on-windows&quot;&gt;C#/.NET基于Topshelf创建Windows服务的守护程序作为服务启动的客户端桌面程序不显示UI界面的问题分析和解决方案&lt;/a&gt; (3)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://codedefault.com/p/create-windows-service-with-topshelf-in-csharp-console-application&quot;&gt;《C#/.NET基于Topshelf创建Windows服务程序及服务的安装和卸载》&lt;/a&gt;中，我们了解发C#/.NET创建基于Topshelf Windows服务程序的大致流程，参数配置以及服务的安装和卸载。同时，我们也使用一个简单的定时任务演示了Topshelf服务的执行情况。&lt;/p&gt;
&lt;p&gt;今天我将继续为大家分享关于Topshelf主题的技术文章。本文主要演示在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务)。&lt;/p&gt;
&lt;h2 id=&quot;创建一个演示应用程序&quot;&gt;创建一个演示应用程序&lt;/h2&gt;
&lt;p&gt;首先，打开之前我们创建的[TopshelfDemoService.sln]解决方案。在这个解决方案中再创建一个名为&lt;code&gt;TopshelfDemo.Client&lt;/code&gt;的客户端控制台应用程序，这个客户端程序即是我们需要使用[TopshelfDemoService]守护的。只是为了演示，所以客户端并没有实际意义的逻辑和功能，在&lt;code&gt;Program.cs&lt;/code&gt;文件中，添加如下示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;

namespace TopshelfDemo.Client
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;这是一个由[码友网]创建的ERP系统示例程序，目前正在运行...&quot;);
            Console.WriteLine(&quot;技术支持：码友网(https://codedefautl.com) by Rector&quot;);
            Console.ReadLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅此而已。&lt;/p&gt;
&lt;p&gt;编写好后，生成或者运行一下这个项目。你会看到一个控制台应用程序界面，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://statics.codedefault.com/uploads/u/2019/04/drq4o3sbc3.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现守护程序功能&quot;&gt;实现守护程序功能&lt;/h2&gt;
&lt;p&gt;再回到项目[TopshelfDemoService]中，打开类文件&lt;code&gt;HealthMonitorService.cs&lt;/code&gt;，其中的定时功能演示的是一个检查某系统健康状况的任务，现在我们把定时任务功能改为守护某个或者某些应用程序。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里为了演示方便，没有重新创建服务类，在实际项目中，你也可以根据自己的情况创建不同的服务类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改其中代码为如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Timers;

namespace TopshelfDemoService
{
    internal class HealthMonitorService
    {
        /// &amp;lt;summary&amp;gt;
        /// 检测周期计时器
        /// &amp;lt;/summary&amp;gt;
        private readonly Timer _timer;
        /// &amp;lt;summary&amp;gt;
        /// 检测周期(秒)
        /// &amp;lt;/summary&amp;gt;
        private int _monitorInterval = 10;
        /// &amp;lt;summary&amp;gt;
        /// 要守护的应用程序列表
        /// &amp;lt;/summary&amp;gt;
        private List&amp;lt;DaemonApplicationInfo&amp;gt; _daemonApps { get; set; }

        public HealthMonitorService()
        {
            // 初始化要守护的应用程序列表
            // 实际项目中，你可以将这里的初始化参数放到配置文件/数据库/缓存中(怎么方便怎么来)
            _daemonApps = new List&amp;lt;DaemonApplicationInfo&amp;gt; {
                new DaemonApplicationInfo {
                    ProcessName =&quot;TopshelfDemo.Client&quot;,  // 请根据你的情况填写
                    AppDisplayName =&quot;TopshelfDemo Client&quot;, // 请根据你的情况填写
                    AppFilePath =@&quot;D:\Projects\github\TopshelfDemoService\TopshelfDemo.Client\bin\Debug\TopshelfDemo.Client.exe&quot; // 这里的路径请根据你的实际情况填写
                }
            };
            _timer = new Timer(_monitorInterval*1000) { AutoReset = true };
            _timer.Elapsed += (sender, eventArgs) =&amp;gt; Monitor();
        }

        /// &amp;lt;summary&amp;gt;
        /// 守护应用程序的方法
        /// &amp;lt;/summary&amp;gt;
        private void Monitor()
        {
            foreach (var app in _daemonApps)
            {
                // 判断当前进程是存已启动
                if (ProcessorHelper.IsProcessExists(app.ProcessName))
                {
                    Console.WriteLine(&quot;Application[{0}] already exists.&quot;, app.ProcessName);
                    return;
                }
                try
                {
                    // 当前主机进程列表中没有需要守护的进程名称，则启动这个进程对应的应用程序
                    ProcessorHelper.RunProcess(app.AppFilePath, app.Args);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(&quot;Start application failed:{0}&quot;, ex);
                }
            }            
        }

        public void Start()
        {
            _timer.Start();
        }
        public void Stop()
        {
            _timer.Stop();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建类&lt;code&gt;DaemonApplicationInfo.cs&lt;/code&gt;和&lt;code&gt;ProcessorHelper.cs&lt;/code&gt;，编写如下代码。&lt;/p&gt;
&lt;p&gt;DaemonApplicationInfo.cs(需守护的应用程序实体类)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TopshelfDemoService
{
    /// &amp;lt;summary&amp;gt;
    /// 需守护的应用程序实体
    /// &amp;lt;/summary&amp;gt;
    public class DaemonApplicationInfo
    {
        /// &amp;lt;summary&amp;gt;
        /// 进程中显示的名称
        /// &amp;lt;/summary&amp;gt;
        public string ProcessName { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 应用程序安装路径
        /// &amp;lt;/summary&amp;gt;
        public string AppFilePath { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 应用程序的名称
        /// &amp;lt;/summary&amp;gt;
        public string AppDisplayName { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 参数
        /// &amp;lt;/summary&amp;gt;
        public string Args { get; set; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProcessorHelper.cs(进程处理帮助类)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TopshelfDemoService
{
    /// &amp;lt;summary&amp;gt;
    /// 进程处理帮助类
    /// &amp;lt;/summary&amp;gt;
    internal class ProcessorHelper
    {
        /// &amp;lt;summary&amp;gt;
        /// 获取当前计算机所有的进程列表(集合)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static List&amp;lt;Process&amp;gt; GetProcessList()
        {
            return GetProcesses().ToList();
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取当前计算机所有的进程列表(数组)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Process[] GetProcesses()
        {
            var processList = Process.GetProcesses();
            return processList;
        }

        /// &amp;lt;summary&amp;gt;
        /// 判断指定的进程是否存在
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;processName&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static bool IsProcessExists(string processName)
        {
            return Process.GetProcessesByName(processName).Length &amp;gt; 0;
        }

        /// &amp;lt;summary&amp;gt;
        /// 启动一个指定路径的应用程序
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;applicationPath&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void RunProcess(string applicationPath, string args = &quot;&quot;)
        {
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = applicationPath,
                    WindowStyle = ProcessWindowStyle.Normal,
                    Arguments = args
                };
                Process.Start(psi);
            }
            catch{}
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成以上编码后，我们将项目程序[TopshelfDemo.Client]和[TopshelfDemoService]先都关闭掉(如果已运行)，接着运行项目[TopshelfDemoService]，下面就是见证奇迹的时刻啦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://statics.codedefault.com/uploads/u/2019/04/k4wik5y9d4.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，守护程序[TopshelfDemoService]自动启动了客户端程序[TopshelfDemo.Client.exe]，并且只会启动一个客户端实例程序。当我们把客户端关闭后，下次守护程序检测的时候客户端程序又会被重启。&lt;/p&gt;
&lt;h2 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h2&gt;
&lt;p&gt;如果你正高高兴兴地将TopshelfDemoService作为Windows服务安装，那么你可能会遇到这个问题，即守护进程正常运行，客户端程序也能正常地被守护并且启动，在Windows的&quot;任务管理器&quot;中也可以找到客户端的进程，但却看不到客户端程序的UI界面。&lt;/p&gt;
&lt;p&gt;这是怎么回事呢？？？是不是哪里出错了呢？？？应该如何解决呢？？？&lt;/p&gt;
&lt;p&gt;预知后事如何请听下回分解（未完待续）...&lt;/p&gt;
&lt;p&gt;好了，今天的在C#/.NET应用程序开发中创建一个基于Topshelf的应用程序守护进程(服务)的分享就到这里。&lt;/p&gt;
&lt;p&gt;我是Rector，希望本文对C#/.NET开发的你有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;源代码下载&quot;&gt;源代码下载&lt;/h2&gt;
&lt;p&gt;本示例代码托管地址可以在原出处找到：&lt;a href=&quot;https://codedefault.com/p/create-daemon-service-with-topshelf-in-csharp-application&quot;&gt;示例代码下载地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Apr 2019 05:55:00 +0000</pubDate>
<dc:creator>Rector</dc:creator>
<og:description>在上一篇文章《C#/.NET基于Topshelf创建Windows服务程序及服务的安装和卸载》中，我们了解发C#/.NET创建基于Topshelf Windows服务程序的大致流程，参数配置以及服务的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobositlife/p/create-daemon-service-with-topshelf-in-csharp-application.html</dc:identifier>
</item>
</channel>
</rss>