<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>php 学习笔记之关于时区的那点事 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10949856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10949856.html</guid>
<description>&lt;h2 id=&quot;科普一下什么是时区&quot;&gt;科普一下什么是时区&lt;/h2&gt;
&lt;p&gt;众所周知,地球绕着太阳转的同时也会自转,因此同一时刻不同地区所接收到太阳照射的情况不同,所以有的地区是日出,有的地区是日落,还有的地区可能是黑夜.&lt;/p&gt;
&lt;p&gt;既然地球上的不同地区时间不同,那总要有统一的时间刻度才能方便文化科技交流吧,不然大家说的都是当地时间,这样岂不是乱套了?&lt;/p&gt;
&lt;p&gt;有问题就要解决问题,不同地区时间不同就要统一时间标准,而统一时间标准的前提就是要弄清楚全球的时间差异到底在哪以及各地的当地时间如何互相转换.&lt;/p&gt;
&lt;p&gt;原来的时间标准是&lt;strong&gt;格林尼治标准时间&lt;/strong&gt;,随着精确计时的发展需要,已被新的时间标准所取代,目前的时间标准是&lt;strong&gt;世界协调时&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在有了统一的时间标准,不同地区的时间就可以统一换算成世界协调时再转换成当地时间了,再也不会出现同一时刻不同时间了!&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;北京时间(&lt;code&gt;UTC+8&lt;/code&gt;) : &lt;code&gt;2019-05-30 13:30:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;世界时间(&lt;code&gt;UTC&lt;/code&gt;) : &lt;code&gt;2019-05-30 05:30:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;东部时间(&lt;code&gt;UTC-5&lt;/code&gt;) : &lt;code&gt;2019-05-30 00:30:00&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;格林尼治标准时间&quot;&gt;格林尼治标准时间&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;格林尼治标准时间&lt;/strong&gt;(又称&lt;strong&gt;格林威治平均时间&lt;/strong&gt;或&lt;strong&gt;格林威治标准时间&lt;/strong&gt;,英文是&lt;strong&gt;GreenwichMeanTime&lt;/strong&gt;,简称&lt;strong&gt;GMT&lt;/strong&gt; ),格林尼治标准时间的正午是指当太阳横穿&lt;strong&gt;格林尼治子午线&lt;/strong&gt;时(也就是在格林尼治时)的时间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;格林尼治&lt;/strong&gt;是英国伦敦的一个小镇,是&lt;strong&gt;地理经度&lt;/strong&gt;的起点,&lt;strong&gt;本初子午线&lt;/strong&gt;所在的经度是&lt;strong&gt;零度经度,&lt;/strong&gt;所在的时区是&lt;strong&gt;零时区&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;我们知道一天共有 &lt;code&gt;24&lt;/code&gt; 小时,对应着全球 &lt;code&gt;24&lt;/code&gt; 个时区,而地球&lt;strong&gt;自西向东&lt;/strong&gt;自转,零时区后依次是东一区到东十一区,然后是东十二区.紧接着是西十二区,西十一区到西一区,最后又回到零时区.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其中东十二区和西十二区是&lt;strong&gt;同一个时区&lt;/strong&gt;,又被称为&lt;strong&gt;东西十二区&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说,时区分为东十二区和西十二区以及零时区,其中东西十二区是同一个时区,因此共有 &lt;code&gt;24&lt;/code&gt; 个时区.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-62a6690d44ab960d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;php-timezone-method-gmt-geo.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;由于北京位于东八区,比零时区多个 &lt;code&gt;8&lt;/code&gt; 个时区,意味着北京时间比格林标准时间&lt;strong&gt;快&lt;/strong&gt; &lt;code&gt;8&lt;/code&gt; 个小时.&lt;/p&gt;
&lt;p&gt;所以,北京时间中午 12 点整的时候,格林尼治才清早 4 点钟,估计还在睡觉呢! ( &lt;code&gt;GMT+8&lt;/code&gt; 就是北京时间)&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;格林尼治标准时间与&lt;strong&gt;地球自转&lt;/strong&gt;有关,不能满足精确计时的需求,因此不再作为&lt;strong&gt;标准时间&lt;/strong&gt;,取而代之的是协调世界时.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;协调世界时&quot;&gt;协调世界时&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;协调世界时&lt;/strong&gt;(又称&lt;strong&gt;世界统一时间&lt;/strong&gt;或&lt;strong&gt;世界标准时间&lt;/strong&gt;或&lt;strong&gt;国际协调时间&lt;/strong&gt;,英文是&lt;strong&gt;Coordinated Universal Time&lt;/strong&gt;,简称&lt;strong&gt;UTC&lt;/strong&gt; ),协调世界时是以&lt;strong&gt;原子时&lt;/strong&gt;秒长为基础,在时刻上尽量接近于&lt;strong&gt;格林尼治标准时间&lt;/strong&gt;的一种时间计量系统.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;strong&gt;不需要精确到秒&lt;/strong&gt;的情况下, &lt;code&gt;GMT&lt;/code&gt; 和 &lt;code&gt;UTC&lt;/code&gt; 基本一致,但 &lt;code&gt;UTC&lt;/code&gt; 是以更加精确的原子时为基础,因此常用于科学计算领域,也是目前时间计量的统一标准.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;北京时间 &lt;code&gt;12:00&lt;/code&gt; ,换算成 &lt;code&gt;GMT&lt;/code&gt; 或 &lt;code&gt;UTC&lt;/code&gt; 时间都是 &lt;code&gt;04:00&lt;/code&gt; ( &lt;code&gt;UTC+8&lt;/code&gt; 也是北京时间)&lt;/p&gt;
&lt;h3 id=&quot;北京时间&quot;&gt;北京时间&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;北京时间&lt;/strong&gt;(又称&lt;strong&gt;中国标准时间&lt;/strong&gt;),是首都北京所在的时区作为中国的标准时间,比&lt;strong&gt;格林尼治标准时间&lt;/strong&gt;快8小时.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我国幅员辽阔,从西到东横跨东五,东六,东七,东八和东九等&lt;strong&gt;五个&lt;/strong&gt;时区.所以全国统一采用&lt;strong&gt;首都北京&lt;/strong&gt;所在的&lt;strong&gt;东八时区&lt;/strong&gt;的区时作为标准时间,也就是北京时间.&lt;/p&gt;
&lt;h3 id=&quot;时区信息数据库&quot;&gt;时区信息数据库&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;时区信息数据库,又称 Olson数据库,是一个主要应用于电脑程序以及操作系统的可&lt;strong&gt;协作编辑世界时区信息&lt;/strong&gt;的数据库.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时区信息数据库采用按“区域/位置”命名规范,方便应用于计算机世界,其中英文地名中的空格用下划线“_”代替,连词符“-”只在英文地名本身包含时使用.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Asia/Hong_Kong&lt;/code&gt; : 亚洲/香港&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Macau&lt;/code&gt; : 亚洲/澳门&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Shanghai&lt;/code&gt; : 亚洲/上海&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Taipei&lt;/code&gt; : 亚洲/台北&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Urumqi&lt;/code&gt; : 亚洲/乌鲁木齐&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.021978021978&quot;&gt;
&lt;p&gt;上述时区主要是 &lt;code&gt;php&lt;/code&gt; 中所支持的中国时区,参考 &lt;a href=&quot;https://www.php.net/manual/zh/timezones.asia.php&quot;&gt;亚洲所支持的时区列表&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于时区的编程实现&quot;&gt;关于时区的编程实现&lt;/h2&gt;
&lt;p&gt;时区不仅仅是现实生活的问题,计算机编程世界也有时间,自然也离不开时区的概念.&lt;/p&gt;
&lt;p&gt;在计算机世界中,一切都是数据,最好时区的概念也能体现在相关数据库中,幸运的是已经有前辈为我们提供了&lt;strong&gt;时区信息数据库&lt;/strong&gt;,而各类语言基本都会提供时区的工具类.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;php&lt;/code&gt; 中的&lt;strong&gt;日期时间函数库&lt;/strong&gt;是 &lt;code&gt;php&lt;/code&gt; &lt;strong&gt;内置函数库&lt;/strong&gt;,我们可以方便地操作时间,设置时区等.&lt;/p&gt;
&lt;p&gt;正常情况下, &lt;code&gt;date&lt;/code&gt; 扩展默认是启用的,我们可以输入 &lt;code&gt;phpinfo&lt;/code&gt; 打印出 &lt;code&gt;php&lt;/code&gt; 的基本信息,然后搜索关键字 &lt;code&gt;date&lt;/code&gt; 就可以找到关于 &lt;code&gt;date&lt;/code&gt; 扩展的相关信息.&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
// 获取默认时区
echo &quot;默认时区: &quot;.ini_get(&quot;date.timezone&quot;).&quot;&amp;lt;br/&amp;gt;&quot;;

// 获取当前时区
echo &quot;当前时区: &quot;.date_default_timezone_get().&quot;&amp;lt;br/&amp;gt;&quot;;

// 当前时间
echo &quot;当前时间: &quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;&amp;lt;br&amp;gt;&quot;;

// 打印 php 信息
phpinfo();
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认时区:&lt;br/&gt;当前时区: UTC&lt;br/&gt;当前时间: 2019-05-30 05:30:00&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;date/time support(日期时间支持情况)&lt;/td&gt;
&lt;td&gt;enabled(已启用)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;timelib version(时间库版本)&lt;/td&gt;
&lt;td&gt;2016.05(&lt;code&gt;2016.05&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;Olson&quot; Timezone Database Version(&lt;code&gt;Olson&lt;/code&gt; 时区数据库版本)&lt;/td&gt;
&lt;td&gt;2018.5(&lt;code&gt;2018.5&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Timezone Database(时区数据库)&lt;/td&gt;
&lt;td&gt;internal(内部的)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Default timezone(默认时区)&lt;/td&gt;
&lt;td&gt;UTC(协调世界时)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;由此可见,假设不设置时区的话,默认时区是&lt;strong&gt;协调世界时&lt;/strong&gt;,该时区和北京时间相比慢 &lt;code&gt;8&lt;/code&gt; 个小时!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设置时区的三种姿势&quot;&gt;设置时区的三种姿势&lt;/h2&gt;
&lt;p&gt;翻阅 &lt;code&gt;php&lt;/code&gt; 开发文档中可以找到目前&lt;a href=&quot;https://www.php.net/manual/en/timezones.php&quot;&gt;所有支持时区&lt;/a&gt;列表,下面整理出关于中国的主要时区.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Asia/Hong_Kong&lt;/code&gt; : 亚洲/香港&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Macau&lt;/code&gt; : 亚洲/澳门&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Shanghai&lt;/code&gt; : 亚洲/上海&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Taipei&lt;/code&gt; : 亚洲/台北&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Asia/Urumqi&lt;/code&gt; : 亚洲/乌鲁木齐&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;常用时区是上海,并没有北京,当然也可以设置成 &lt;code&gt;PRC&lt;/code&gt; (中华人民共和国)!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有设置时区的话,默认时区应该是协调世界时(&lt;code&gt;UTC&lt;/code&gt;),虽说是通用的时间标准,但转换成当地时间还是需要一定换算的,而且看起来也不太舒服.&lt;/p&gt;
&lt;p&gt;所以最好还是修改一下时区的设置项,如果业务不考虑国际化需求,那么永久性把时区固定就可以了,如果有国际化的业务场景,那么最好能够动态设置时区,这样就能清楚知道当地时间了.&lt;/p&gt;
&lt;p&gt;因此,下面主要提供两种方式来设置时区,分别是静态设置和动态设置,其中动态设置又提供了两种方法.&lt;/p&gt;
&lt;h3 id=&quot;静态修改-php-配置&quot;&gt;静态修改 &lt;code&gt;php&lt;/code&gt; 配置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;php&lt;/code&gt; 的配置文件默认位于 : &lt;code&gt;/private/etc/php.ini&lt;/code&gt; ,打开文件后修改 &lt;code&gt;date.timezone&lt;/code&gt; 选项.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于这种方法是直接修改配置文件,因此时区设置后适用于所有脚本,只不过需要重启服务器方可生效.&lt;/p&gt;
&lt;pre class=&quot;ini&quot;&gt;
&lt;code&gt;[Date]
; Defines the default timezone used by the date functions
; http://php.net/date.timezone
;date.timezone =

; http://php.net/date.default-latitude
;date.default_latitude = 31.7667

; http://php.net/date.default-longitude
;date.default_longitude = 35.2333

; http://php.net/date.sunrise-zenith
;date.sunrise_zenith = 90.583333

; http://php.net/date.sunset-zenith
;date.sunset_zenith = 90.583333&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;ini&quot;&gt;
&lt;code&gt;# 去掉;并设置时区,取值可以是PRC,也可以是Asia/Shanghai等时区
date.timezone = PRC&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.8888888888889&quot;&gt;
&lt;p&gt;详情请参考: &lt;a href=&quot;http://php.net/date.timezone&quot; class=&quot;uri&quot;&gt;http://php.net/date.timezone&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;动态设置-php-配置&quot;&gt;动态设置 &lt;code&gt;php&lt;/code&gt; 配置&lt;/h3&gt;
&lt;blockquote readability=&quot;4.3518518518519&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.php.net/manual/zh/function.ini-set.php&quot;&gt;ini_set&lt;/a&gt; 支持设置当前脚本的默认时区选项.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态设置时区仅仅适合时区固定的情况,如果需要动态切换时区,修改配置文件就不能满足这种情况了.&lt;/p&gt;
&lt;p&gt;因此,&lt;code&gt;php&lt;/code&gt; 中还提供了动态修改 &lt;code&gt;php.ini&lt;/code&gt; 配置文件的方法,&lt;code&gt;ini_set()&lt;/code&gt; 方法刚好支持动态设置时区.&lt;/p&gt;
&lt;blockquote readability=&quot;6.1592920353982&quot;&gt;
&lt;p&gt;不用重启服务器,但仅仅针对&lt;strong&gt;当前脚本&lt;/strong&gt;生效,其中 &lt;code&gt;ini_set&lt;/code&gt; 方法支持的 &lt;a href=&quot;https://www.php.net/manual/zh/ini.list.php&quot;&gt;php.ini 配置选项列表&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;// 设置当前时区
ini_set(&quot;date.timezone&quot;, &quot;Asia/Tokyo&quot;);

// 获取默认时区
echo &quot;当前时区: &quot;.ini_get(&quot;date.timezone&quot;).&quot;&amp;lt;br/&amp;gt;&quot;;

// 当前时间
echo &quot;当前时间: &quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;&amp;lt;br&amp;gt;&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前时区: Asia/Tokyo&lt;br/&gt;当前时间: 2019-05-30 14:30:00&lt;/p&gt;
&lt;h3 id=&quot;动态设置-php-时区&quot;&gt;动态设置 &lt;code&gt;php&lt;/code&gt; 时区&lt;/h3&gt;
&lt;blockquote readability=&quot;3.2638888888889&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.php.net/manual/zh/function.date-default-timezone-set.php&quot;&gt;date_default_timezone_set&lt;/a&gt; 方法用于设置当前脚本的默认时区.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ini_set&lt;/code&gt; 虽然支持设置时区选项,但毕竟不是专业设置时区的方法,&lt;code&gt;date_default_timezone_set&lt;/code&gt; 才是专门设置时区的方法.&lt;/p&gt;
&lt;p&gt;这两个方法都属于动态设置时区,也都是针对当前脚本生效,也都不用重启服务器就能立马生效.&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;// 获取当前时区
echo &quot;当前时区: &quot;.date_default_timezone_get().&quot;&amp;lt;br/&amp;gt;&quot;;

// 设置当前时区
date_default_timezone_set(&quot;UTC&quot;);

// 获取当前时区
echo &quot;当前时区: &quot;.date_default_timezone_get().&quot;&amp;lt;br/&amp;gt;&quot;;

// 当前时间
echo &quot;当前时间: &quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;&amp;lt;br&amp;gt;&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前时区: Asia/Tokyo&lt;br/&gt;当前时区: UTC&lt;br/&gt;当前时间: 2019-05-30 05:30:00&lt;/p&gt;
&lt;h2 id=&quot;关于时区的一些总结&quot;&gt;关于时区的一些总结&lt;/h2&gt;
&lt;p&gt;时区和时间密切相关,统一时间说的其实是统一时间的标准,这样一个地区的当地时间就可以轻易转换成另一个地区的当地时间了.&lt;/p&gt;
&lt;p&gt;目前世界上统一的时间标准是&lt;strong&gt;协调时间时&lt;/strong&gt;(&lt;code&gt;UTC&lt;/code&gt;),中国的时间标准是&lt;strong&gt;北京时间&lt;/strong&gt;,北京时间比协调时间时快 &lt;code&gt;8&lt;/code&gt; 个小时.&lt;/p&gt;
&lt;p&gt;现实世界的时区也要反映到计算机世界,其中&lt;strong&gt;时区信息数据库&lt;/strong&gt;就是用于表示现实世界的时区概念.&lt;/p&gt;
&lt;p&gt;由此可见,时区是一个通用概念,不仅 &lt;code&gt;php&lt;/code&gt; 有时区,&lt;code&gt;java&lt;/code&gt; 和 &lt;code&gt;js&lt;/code&gt; 等语言也有时区概念,可以说只要有时间的地方都离不开时区.&lt;/p&gt;
&lt;p&gt;关于时区的小技能,你 &lt;code&gt;get&lt;/code&gt; 到了吗?&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;美剧&amp;lt;&amp;lt;闪电侠&amp;gt;&amp;gt;当地时间是星期二晚上八点开播,请问北京时间何时开播?&lt;/li&gt;
&lt;li&gt;英剧&amp;lt;&amp;lt;神探夏洛克&amp;gt;&amp;gt;北京时间凌晨四点半开播,请问当地时间是何时开播?&lt;/li&gt;
&lt;li&gt;泰剧&amp;lt;&amp;lt;新铁石心肠&amp;gt;&amp;gt;当地时间是晚上九点二十开播,请问北京时间是何时?&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Thu, 30 May 2019 07:31:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>科普一下什么是时区 众所周知,地球绕着太阳转的同时也会自转,因此同一时刻不同地区所接收到太阳照射的情况不同,所以有的地区是日出,有的地区是日落,还有的地区可能是黑夜. 既然地球上的不同地区时间不同,那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snowdreams1006/p/10949856.html</dc:identifier>
</item>
<item>
<title>降维打击！为什么我认为数据结构与算法对前端开发很重要 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10949774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10949774.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h6&gt;&amp;gt; &lt;em&gt;事情要从 GitHub 上的一个 issue 谈起：&lt;/em&gt;&lt;em&gt;http&lt;/em&gt;&lt;em&gt;s://&lt;/em&gt;&lt;em&gt;github.com/LeuisK&lt;/em&gt;&lt;em&gt;en/leuisken.github.io/issues/2，需求里面的我指代为 &lt;/em&gt;issue 里面&lt;em&gt;的我&lt;/em&gt;&lt;em&gt;。&lt;/em&gt;&lt;/h6&gt;
&lt;h3 id=&quot;hhttpsgithubcomleuiskenleuiskengithubioissues2&quot;&gt;&lt;a href=&quot;https://github.com/LeuisKen/leuisken.github.io/issues/2&quot;&gt;从一个需求谈起&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在我之前的项目中，曾经遇到过这样一个需求，编写一个级联选择器，大概是这样：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.githubusercontent.com/assets/7701575/15245665/849fb522-193a-11e6-98b2-5f4f39c63034.png&quot;&gt;&lt;img title=&quot;1&quot; src=&quot;https://cloud.githubusercontent.com/assets/7701575/15245665/849fb522-193a-11e6-98b2-5f4f39c63034.png&quot; alt=&quot;1&quot;/&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图中的示例使用的是 Ant-Design 的 Cascader 组件。&lt;/p&gt;
&lt;p&gt;要实现这一功能，我需要类似这样的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var data = [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;浙江&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;children&quot;: [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;杭州&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;children&quot;: [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;西湖&quot;&lt;br/&gt;}]&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;children&quot;: [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成都&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;children&quot;: [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;锦里&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;方所&quot;&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;阿坝&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;children&quot;: [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;九寨沟&quot;&lt;br/&gt;}]&lt;br/&gt;}]&lt;br/&gt;}]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个具有层级结构的数据，实现这个功能非常容易，因为这个结构和组件的结构是一致的，递归遍历就可以了。&lt;/p&gt;
&lt;p&gt;但是，由于后端通常采用的是关系型数据库，所以返回的数据通常会是这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var data = [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;浙江&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;杭州&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;西湖&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成都&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;锦里&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成都&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;方所&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;阿坝&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;九寨沟&quot;&lt;br/&gt;}]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前端这边想要将数据转换一下其实也不难，因为要合并重复项，可以参考数据去重的方法来做，于是我写了这样一个版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot; readability=&quot;14.5&quot;&gt;&lt;span class=&quot;hljs-string&quot; readability=&quot;29&quot;&gt;'use strict'&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var transObject = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;tableData, keys) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let hashTable = {}, res = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for( &lt;span class=&quot;hljs-keyword&quot;&gt;let i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; tableData.length; i++ ) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if(!hashTable[tableData[i][keys[&lt;span class=&quot;hljs-number&quot;&gt;0]]]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let len = res.push({&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;value: tableData[i][keys[&lt;span class=&quot;hljs-number&quot;&gt;0]],&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;children: []&lt;br/&gt;})&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var data = [{&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;浙江&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;杭州&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;西湖&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成都&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;锦里&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成都&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;方所&quot;&lt;br/&gt;}, {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;province&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;四川&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;city&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;阿坝&quot;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;九寨沟&quot;&lt;br/&gt;}]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var keys = [&lt;span class=&quot;hljs-string&quot;&gt;'province', &lt;span class=&quot;hljs-string&quot;&gt;'city', &lt;span class=&quot;hljs-string&quot;&gt;'name']&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(transObject(data, keys))&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还好 keys 的长度只有 3 ，这种东西长了根本没办法写，很明显可以看出来这里面有重复的部分，可以通过循环搞定，但是想了很久都没有思路，就搁置了。&lt;/p&gt;
&lt;p&gt;后来，有一天晚饭后不是很忙，就跟旁边做数据的同事聊了一下这个需求，请教一下该怎么用循环来处理。他看了一下，就问我：“你知道 trie 树吗？”。我头一次听到这个概念，他简单的给我讲了一下，然后说感觉处理的问题有些类似，让我可以研究一下 trie 树的原理并试着优化一下。&lt;/p&gt;
&lt;p&gt;讲道理， trie 树这个数据结构网上确实有很多资料，但很少有使用 JavaScript 实现的，不过原理倒是不难。尝试之后，我就将 &lt;code&gt;transObject&lt;/code&gt; 的代码优化成了这样。（关于 trie 树，还请读者自己阅读相关材料）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var transObject = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;tableData, keys) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let hashTable = {}, res = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;let i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; tableData.length; i++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let arr = res, cur = hashTable&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;let j = &lt;span class=&quot;hljs-number&quot;&gt;0; j &amp;lt; keys.length; j++) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let key = keys[j], filed = tableData[i][key]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (!cur[filed]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let pusher = {&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;value: filed&lt;br/&gt;}, tmp&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (j !== (keys.length - &lt;span class=&quot;hljs-number&quot;&gt;1)) {&lt;br/&gt;tmp = []&lt;br/&gt;pusher.children = tmp&lt;br/&gt;}&lt;br/&gt;cur[filed] = { &lt;span class=&quot;hljs-attr&quot;&gt;$$pos: arr.push(pusher) - &lt;span class=&quot;hljs-number&quot;&gt;1 }&lt;br/&gt;cur = cur[filed]&lt;br/&gt;arr = tmp&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else {&lt;br/&gt;cur = cur[filed]&lt;br/&gt;arr = arr[cur.$$pos].children&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return res&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，解决方案就和 keys 的长短无关了。&lt;/p&gt;
&lt;p&gt;这种解决方案正如《三体》里面使用「二向箔」对宇宙文明进行降维打击一般干净利落！&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/MisterBooo/myBlogPic/master/20190530093132.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你对「Trie」树的相关概念不了解的话，可以继续往下查看进行阅读学习。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这是之前的写的一篇旧文，小吴这里进行了一定的修改和排版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;htrie&quot;&gt;Trie树&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Trie 这个名字取自“retrieval”，检索，因为 Trie 可以只用一个前缀便可以在一部字典中找到想要的单词。&lt;br/&gt;虽然发音与「Tree」一致，但为了将这种 字典树 与 普通二叉树 以示区别，程序员小吴一般读「Trie」尾部会重读一声，可以理解为读「TreeE」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Trie 树，也叫“字典树”。顾名思义，它是一个&lt;strong&gt;树形结构&lt;/strong&gt;。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。&lt;/p&gt;
&lt;p&gt;此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如 pan 是 panda 的前缀）。&lt;/p&gt;
&lt;p&gt;它的key都为字符串，能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;htrie-1&quot;&gt;Trie树的特点&lt;/h3&gt;
&lt;p&gt;假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？&lt;/p&gt;
&lt;p&gt;如果将这 5 个字符串组织成下图的结构，从肉眼上扫描过去感官上是不是比查找起来会更加迅速。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;Trie树样子&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b54e82cd?w=1922&amp;amp;h=1074&amp;amp;f=png&amp;amp;s=102217&quot; alt=&quot;Trie树样子&quot;/&gt;Trie树样子&lt;/p&gt;
&lt;p&gt;通过上图，可以发现 Trie树 的三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根节点不包含字符，除根节点外每一个节点都只包含一个字符&lt;/li&gt;
&lt;li&gt;从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串&lt;/li&gt;
&lt;li&gt;每个节点的所有子节点包含的字符都不相同&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过动画理解 Trie 树构造的过程。在构造过程中的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot; Trie 树构造&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b5365880?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=125312&quot; alt=&quot; Trie 树构造&quot;/&gt; Trie 树构造&lt;/p&gt;
&lt;h3 id=&quot;htrie-2&quot;&gt;Trie树的插入操作&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;Trie树的插入操作&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b51f4db2?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=223535&quot; alt=&quot;Trie树的插入操作&quot;/&gt;Trie树的插入操作&lt;/p&gt;
&lt;p&gt;Trie树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词&lt;code&gt;cook&lt;/code&gt;，就有下面几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;插入第一个字母 &lt;code&gt;c&lt;/code&gt;，发现 &lt;code&gt;root&lt;/code&gt; 节点下方存在子节点 &lt;code&gt;c&lt;/code&gt;，则共享节点 &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入第二个字母 &lt;code&gt;o&lt;/code&gt;，发现 &lt;code&gt;c&lt;/code&gt; 节点下方存在子节点 &lt;code&gt;o&lt;/code&gt;，则共享节点 &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入第三个字母 &lt;code&gt;o&lt;/code&gt;，发现 &lt;code&gt;o&lt;/code&gt; 节点下方不存在子节点 &lt;code&gt;o&lt;/code&gt;，则创建子节点 &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;插入第三个字母 &lt;code&gt;k&lt;/code&gt;，发现 &lt;code&gt;o&lt;/code&gt; 节点下方不存在子节点 &lt;code&gt;k&lt;/code&gt;，则创建子节点 &lt;code&gt;k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;至此，单词 &lt;code&gt;cook&lt;/code&gt; 中所有字母已被插入 Trie树 中，然后设置节点 &lt;code&gt;k&lt;/code&gt; 中的标志位，标记路径 &lt;code&gt;root-&amp;amp;gt;c-&amp;amp;gt;o-&amp;amp;gt;o-&amp;amp;gt;k&lt;/code&gt;这条路径上所有节点的字符可以组成一个单词&lt;code&gt;cook&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;htrie-3&quot;&gt;Trie树的查询操作&lt;/h3&gt;
&lt;p&gt;在 Trie 树中查找一个字符串的时候，比如查找字符串 &lt;code&gt;code&lt;/code&gt;，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;code的匹配路径&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b57767ae?w=1928&amp;amp;h=1084&amp;amp;f=png&amp;amp;s=149652&quot; alt=&quot;code的匹配路径&quot;/&gt;code的匹配路径&lt;/p&gt;
&lt;p&gt;如果要查找的是字符串&lt;code&gt;cod&lt;/code&gt;(鳕鱼)呢？还是可以用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串&lt;code&gt;cod&lt;/code&gt;匹配的路径。但是，路径的最后一个节点「d」并不是橙色的，并不是单词标志位，所以&lt;code&gt;cod&lt;/code&gt;字符串不存在。也就是说，&lt;code&gt;cod&lt;/code&gt;是某个字符串的前缀子串，但并不能完全匹配任何字符串。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;cod的匹配路径&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b7443080?w=1920&amp;amp;h=1082&amp;amp;f=png&amp;amp;s=138065&quot; alt=&quot;cod的匹配路径&quot;/&gt;cod的匹配路径&lt;/p&gt;
&lt;h3 id=&quot;htrie-4&quot;&gt;Trie树的删除操作&lt;/h3&gt;
&lt;p&gt;Trie树的删除操作与二叉树的删除操作有类似的地方，需要考虑删除的节点所处的位置，这里分三种情况进行分析：&lt;/p&gt;
&lt;h4 id=&quot;hhi&quot;&gt;删除整个单词（比如 hi ）&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;删除整个单词&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c049b68802a6?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=177162&quot; alt=&quot;删除整个单词&quot;/&gt;删除整个单词&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从根节点开始查找第一个字符&lt;code&gt;h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;h&lt;/code&gt;子节点后，继续查找&lt;code&gt;h&lt;/code&gt;的下一个子节点&lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;是单词&lt;code&gt;hi&lt;/code&gt;的标志位，将该标志位去掉&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;节点是&lt;code&gt;hi&lt;/code&gt;的叶子节点，将其删除&lt;/li&gt;
&lt;li&gt;删除后发现&lt;code&gt;h&lt;/code&gt;节点为叶子节点，并且不是单词标志位，也将其删除&lt;/li&gt;
&lt;li&gt;这样就完成了&lt;code&gt;hi&lt;/code&gt;单词的删除操作&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;hcod&quot;&gt;删除前缀单词（比如 cod ）&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;删除前缀单词&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c04a41644ab1?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=193343&quot; alt=&quot;删除前缀单词&quot;/&gt;删除前缀单词&lt;br/&gt;这种方式删除比较简单。&lt;br/&gt;只需要将&lt;code&gt;cod&lt;/code&gt;单词整个字符串查找完后，&lt;code&gt;d&lt;/code&gt;节点因为不是叶子节点，只需将其单词标志去掉即可。&lt;/p&gt;

&lt;h4 id=&quot;hcook&quot;&gt;删除分支单词（比如 cook ）&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;删除分支单词&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c04a415421ef?w=957&amp;amp;h=536&amp;amp;f=gif&amp;amp;s=173918&quot; alt=&quot;删除分支单词&quot;/&gt;删除分支单词&lt;br/&gt;与 &lt;strong&gt;删除整个单词&lt;/strong&gt; 情况类似，区别点在于删除到 &lt;code&gt;cook&lt;/code&gt; 的第一个 &lt;code&gt;o&lt;/code&gt; 时，该节点为非叶子节点，停止删除，这样就完成&lt;code&gt;cook&lt;/code&gt;字符串的删除操作。&lt;/p&gt;

&lt;h3 id=&quot;htrie-5&quot;&gt;Trie树的应用&lt;/h3&gt;
&lt;p&gt;事实上 Trie树 在日常生活中的使用随处可见，比如这个：&lt;/p&gt;
&lt;p&gt;具体来说就是经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。&lt;/p&gt;
&lt;h4 id=&quot;h1&quot;&gt;1. 前缀匹配&lt;/h4&gt;
&lt;p&gt;例如：找出一个字符串集合中所有以 &lt;code&gt;五分钟&lt;/code&gt; 开头的字符串。我们只需要用所有字符串构造一个 trie树，然后输出以 五−&amp;gt;分−&amp;gt;钟 开头的路径上的关键字即可。&lt;/p&gt;
&lt;p&gt;trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;google搜索&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/2/1680c04a4167a729?w=1430&amp;amp;h=1210&amp;amp;f=png&amp;amp;s=392579&quot; alt=&quot;google搜索&quot;/&gt;google搜索&lt;/p&gt;
&lt;h4 id=&quot;h2&quot;&gt;2. 字符串检索&lt;/h4&gt;
&lt;p&gt;给出 N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词。&lt;/p&gt;
&lt;p&gt;检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。&lt;/li&gt;
&lt;li&gt;如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;htrie-6&quot;&gt;Trie树的局限性&lt;/h3&gt;
&lt;p&gt;如前文所讲，Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。&lt;/p&gt;
&lt;p&gt;假设字符的种数有&lt;code&gt;m&lt;/code&gt;个，有若干个长度为n的字符串构成了一个 Trie树 ，则每个节点的出度为 &lt;code&gt;m&lt;/code&gt;（即每个节点的可能子节点数量为&lt;code&gt;m&lt;/code&gt;），Trie树 的高度为&lt;code&gt;n&lt;/code&gt;。很明显我们浪费了大量的空间来存储字符，此时Trie树的最坏空间复杂度为&lt;code&gt;O(m^n)&lt;/code&gt;。也正由于每个节点的出度为&lt;code&gt;m&lt;/code&gt;，所以我们能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时Trie树的最坏时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这正是空间换时间的体现，也是利用公共前缀降低查询时间开销的体现。&lt;/p&gt;
&lt;p&gt;LeetCode 第 208 号问题就是 &lt;strong&gt;实现 Trie (前缀树)&lt;/strong&gt;，感兴趣的小伙伴可以去实操一下。&lt;/p&gt;
&lt;p&gt;希望今天的这篇文章能帮大家认识到掌握好了数据结构可以在工作中带来多大的帮助，大家加油：）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/MisterBooo/myBlogPic/master/20190530152152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 07:22:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>从一个需求谈起 在我之前的项目中，曾经遇到过这样一个需求，编写一个级联选择器，大概是这样： 1 图中的示例使用的是 Ant-Design 的 Cascader 组件。 要实现这一功能，我需要类似这样的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fivestudy/p/10949774.html</dc:identifier>
</item>
<item>
<title>自定义Spring Security的身份验证失败处理 - 程序猿Knight</title>
<link>http://www.cnblogs.com/xjknight/p/10949636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjknight/p/10949636.html</guid>
<description>&lt;h3 id=&quot;概述&quot;&gt;1.概述&lt;/h3&gt;
&lt;p&gt;在本快速教程中，&lt;strong&gt;我们将演示如何在Spring Boot应用程序中自定义Spring Security的身份验证失败处理&lt;/strong&gt;。目标是使用表单登录方法对用户进行身份验证。&lt;/p&gt;
&lt;h3 id=&quot;认证和授权authentication-and-authorization&quot;&gt;2.认证和授权(Authentication and Authorization)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;身份验证和授权通常结合使用，因为它们在授予系统访问权限时起着重要且同样重要的作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;它们具有不同的含义，并在验证请求时应用不同的约束&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;身份验证&lt;/strong&gt; - 在授权之前;它是关于验证收到的凭证;我们验证用户名和密码是否与我们的应用程序识别的用户名和密码相匹配&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;授权&lt;/strong&gt; - 用于验证成功通过身份验证的用户是否有权访问应用程序的某个功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以&lt;strong&gt;自定义身份验证和授权失败处理&lt;/strong&gt;，但是，在此应用程序中，我们将专注于身份验证失败。&lt;/p&gt;
&lt;h3 id=&quot;spring-security的authenticationfailurehandler&quot;&gt;3. Spring Security的AuthenticationFailureHandler&lt;/h3&gt;
&lt;p&gt;Spring Security提供了一个默认处理身份验证失败的组件。&lt;/p&gt;
&lt;p&gt;但是，我们发现于默认行为不足以满足实际要求的情况是很常见的。&lt;br/&gt;如果是这种情况，&lt;strong&gt;我们可以创建自己的组件并通过实现AuthenticationFailureHandler接口提供我们想要的自定义行为&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CustomAuthenticationFailureHandler 
  implements AuthenticationFailureHandler {
  
    private ObjectMapper objectMapper = new ObjectMapper();
 
    @Override
    public void onAuthenticationFailure(
      HttpServletRequest request,
      HttpServletResponse response,
      AuthenticationException exception) 
      throws IOException, ServletException {
  
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        Map&amp;lt;String, Object&amp;gt; data = new HashMap&amp;lt;&amp;gt;();
        data.put(
          &quot;timestamp&quot;, 
          Calendar.getInstance().getTime());
        data.put(
          &quot;exception&quot;, 
          exception.getMessage());
 
        response.getOutputStream()
          .println(objectMapper.writeValueAsString(data));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，&lt;strong&gt;Spring使用包含错误信息的请求参数将用户重定向回登录页面&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在此应用程序中，我们将返回401响应，其中包含有关错误的信息以及错误发生的时间戳。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DelegatingAuthenticationFailureHandler将AuthenticationException子类委托给不同的AuthenticationFailureHandler&lt;/strong&gt;，这意味着我们可以为AuthenticationException的不同实例创建不同的行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExceptionMappingAuthenticationFailureHandler根据AuthenticationException的完整类名将用户重定向到特定的URL&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无论AuthenticationException的类型如何&lt;/strong&gt;，ForwardAuthenticationFailureHandler都会将用户转发到指定的URL&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SimpleUrlAuthenticationFailureHandler是默认使用的组件&lt;/strong&gt;，如果指定，它会将用户重定向到failureUrl;否则，它只会返回401响应&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们已&lt;strong&gt;经创建了自定义AuthenticationFailureHandler，让我们配置我们的应用程序并覆盖Spring的默认处理程序&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
public class SecurityConfiguration 
  extends WebSecurityConfigurerAdapter {
 
    @Override
    protected void configure(AuthenticationManagerBuilder auth) 
      throws Exception {
        auth
          .inMemoryAuthentication()
          .withUser(&quot;baeldung&quot;)
          .password(&quot;baeldung&quot;)
          .roles(&quot;USER&quot;);
    }
 
    @Override
    protected void configure(HttpSecurity http) 
      throws Exception {
        http
          .authorizeRequests()
          .anyRequest()
          .authenticated()
          .and()
          .formLogin()
          .failureHandler(customAuthenticationFailureHandler());
    }
 
    @Bean
    public AuthenticationFailureHandler customAuthenticationFailureHandler() {
        return new CustomAuthenticationFailureHandler();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意failureHandler（）调用，我们可以告诉Spring使用我们的自定义组件而不是使用默认组件。&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;4.结论&lt;/h3&gt;
&lt;p&gt;在此示例中，&lt;strong&gt;我们使用Spring的AuthenticationFailureHandler接口自定义了应用程序的身份验证失败处理程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可&lt;strong&gt;以&lt;a href=&quot;https://github.com/eugenp/tutorials/tree/master/spring-security-mvc-login&quot;&gt;在Github项目中找&lt;/a&gt;到此示例的实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在本地运行时，&lt;strong&gt;您可以在localhost：8080上访问和测试应用程序&lt;/strong&gt;.&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 07:07:00 +0000</pubDate>
<dc:creator>程序猿Knight</dc:creator>
<og:description>1.概述 在本快速教程中， 我们将演示如何在Spring Boot应用程序中自定义Spring Security的身份验证失败处理 。目标是使用表单登录方法对用户进行身份验证。 2.认证和授权(Aut</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xjknight/p/10949636.html</dc:identifier>
</item>
<item>
<title>ABP开发框架前后端开发系列---（4）Web API调用类的封装和使用 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/10932139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/10932139.html</guid>
<description>&lt;p&gt;在前面随笔介绍ABP应用框架的项目组织情况，以及项目中领域层各个类代码组织，以及简化了ABP框架的各个层的内容，使得我们项目结构更加清晰。上篇随笔已经介绍了字典模块中应用服务层接口的实现情况，并且通过运行Web API的宿主程序，可以在界面上进行接口测试了，本篇随笔基于前面介绍的基础上，介绍Web API调用类的封装和使用，使用包括控制台和Winform中对调用封装类的使用。&lt;/p&gt;
&lt;p&gt;在上篇随笔《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/10931243.html&quot;&gt;ABP开发框架前后端开发系列---（3）框架的分层和文件组织&lt;/a&gt;》中我绘制了改进后的ABP框架的架构图示，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190527161908601-1357832797.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;904&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个项目分层里面的 03-Application.Common 应用服务通用层，我们主要放置在各个模块里面公用的DTO和应用服务接口类。有了这些DTO文件和接口类，我们就不用在客户端（如Winform客户、控制台、WPF/UWP等）重复编写这部分的内容，直接使用即可。&lt;/p&gt;
&lt;p&gt;这些DTO文件和接口类文件，我们的主要用途是用来封装客户端调用Web API的调用类，使得我们在界面使用的时候，调用更加方便。&lt;/p&gt;
&lt;h3&gt;1）Web API调用类封装&lt;/h3&gt;
&lt;p&gt;为了更方便在控制台客户端、Winform客户端等场景下调用Web API的功能，我们需要对应用服务层抛出的Web API接口进行封装，然后结合DTO类实现一个标准的接口实现。&lt;/p&gt;
&lt;p&gt;由于这些调用类可能在多个客户端中进行共享，因此根据我们在混合框架中积累的经验，我们把它们独立为一个项目进行管理，如下项目视图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530114550201-1170997055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中DictDataApiCaller 就是对应领域对象 &amp;lt;领域对象&amp;gt;ApiCaller的命名规则。&lt;/p&gt;
&lt;p&gt;如对于字典模块的API封装类，它们继承一个相同的基类，然后实现特殊的自定义接口即可，这样可以减少常规的Create、Get、GetAll、Update、Delete等操作的代码，这些全部由调用基类进行处理，而只需要实现自定义的接口调用即可。如下是字典模块DictType和DictData两个业务对象的API封装关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530120526048-666463411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如对于字典类型的API封装类定义代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 字典类型对象的Web API调用处理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DictTypeApiCaller : AsyncCrudApiCaller&amp;lt;DictTypeDto, &lt;span&gt;string&lt;/span&gt;, DictTypePagedDto, CreateDictTypeDto, DictTypeDto&amp;gt;&lt;span&gt;, IDictTypeAppService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提供单件对象使用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DictTypeApiCaller Instance
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Singleton&amp;lt;DictTypeApiCaller&amp;gt;&lt;span&gt;.Instance;
            }
        }

......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以通过单件的方式来使用字典类型API的封装类实例 DictTypeApiCaller.Instance&lt;/p&gt;
&lt;p&gt;对于Web API的调用，我们知道，一般需要使用WebClient或者HttpRequest的底层类进行Url的访问处理，通过提供相应的数据，获取对应的返回结果。&lt;/p&gt;
&lt;p&gt;而对于操作方法的类型，是使用POST、GET、INPUT、DELETE的不同，需要看具体的接口，我们可以通过Swagger UI 呈现出来的进行处理即可，如下所示的动作类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530121438595-1856242385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果处理动作不匹配，如本来是Post的用Get方法，或者是Delete的用Post方法，都会出错。&lt;/p&gt;
&lt;p&gt;在Abp.Web.Api项目里面有一个AbpWebApiClient的封装方法，里面实现了POST方法，可以参考来做对应的WebClient的封装调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530121728490-1994708055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在它的基础上扩展了实现方法，包括了Get、Put、Delete方法的调用。&lt;/p&gt;
&lt;p&gt;我们使用的时候，初始化它就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apiClient = &lt;span&gt;new&lt;/span&gt; AbpWebApiClient();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，我们对于常规的用户登录处理，它的API调用封装的操作代码如下所示，这个是一个POST方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对用户身份进行认证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;username&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;password&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;AuthenticateResult&amp;gt; Authenticate(&lt;span&gt;string&lt;/span&gt; username, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; password)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}/api/TokenAuth/Authenticate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ServerRootAddress);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; input = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                UsernameOrEmailAddress &lt;/span&gt;=&lt;span&gt; username,
                Password &lt;/span&gt;=&lt;span&gt; password
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; apiClient.PostAsync&amp;lt;AuthenticateResult&amp;gt;&lt;span&gt;(url, input);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于业务接口来说，我们都是基于约定的规则来命名接口名称和地址的，如对于GetAll这个方法来说，字典类型的地址如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/api/services/app/DictData/GetAll
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还包括服务器的基础地址，从而构建一个完整的调用地址如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:21021/api/services/app/DictData/GetAll&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于这些规则确定，因此我们可以通过动态构建这个API地址即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;string&lt;/span&gt; url = GetActionUrl(MethodBase.GetCurrentMethod());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取访问API的地址（未包含参数）&lt;/span&gt;
            url += &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?SkipCount={0}&amp;amp;MaxResultCount={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, dto.SkipCount, dto.MaxResultCount);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而对于GetAll函数来说，这个定义如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Task&amp;lt;PagedResultDto&amp;lt;TEntityDto&amp;gt;&amp;gt; GetAll(TGetAllInput input)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它是需要根据一定的条件进行查询的，不仅仅是 SkipCount 和 MaxResultCount两个属性，因此我们需要动态组合它的url参数，因此建立一个辅助类来动态构建这些输入参数地址。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有对象列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;input&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;获取所有条件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;PagedResultDto&amp;lt;TEntityDto&amp;gt;&amp;gt;&lt;span&gt; GetAll(TGetAllInput input)
        {
            AddRequestHeaders();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入认证的token头信息&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; url = GetActionUrl(MethodBase.GetCurrentMethod());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取访问API的地址（未包含参数）&lt;/span&gt;
            url =&lt;span&gt; GetUrlParam(input, url);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; apiClient.GetAsync&amp;lt;PagedResultDto&amp;lt;TEntityDto&amp;gt;&amp;gt;&lt;span&gt;(url);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们这个API的调用封装类的基类就实现了常规的功能了。效果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530123111352-1184342573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而字典类型的API封装类，我们只需要实现特定的自定义接口即可，省却我们很多的工作量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MyProject.Caller
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 字典类型对象的Web API调用处理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DictTypeApiCaller : AsyncCrudApiCaller&amp;lt;DictTypeDto, &lt;span&gt;string&lt;/span&gt;, DictTypePagedDto, CreateDictTypeDto, DictTypeDto&amp;gt;&lt;span&gt;, IDictTypeAppService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提供单件对象使用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DictTypeApiCaller Instance
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Singleton&amp;lt;DictTypeApiCaller&amp;gt;&lt;span&gt;.Instance;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DictTypeApiCaller()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DomainName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DictType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定域对象名称，用于组装接口地址&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; GetAllType(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; dictTypeId)
        {
            AddRequestHeaders();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入认证的token头信息&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; url = GetActionUrl(MethodBase.GetCurrentMethod());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取访问API的地址（未包含参数）&lt;/span&gt;
            url += &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?dictTypeId={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dictTypeId);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; apiClient.GetAsync&amp;lt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(url);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result; 
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IList&amp;lt;DictTypeNodeDto&amp;gt;&amp;gt; GetTree(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; pid)
        {
            AddRequestHeaders();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入认证的token头信息&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; url = GetActionUrl(MethodBase.GetCurrentMethod());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取访问API的地址（未包含参数）&lt;/span&gt;
            url += &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?pid={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pid);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; apiClient.GetAsync&amp;lt;IList&amp;lt;DictTypeNodeDto&amp;gt;&amp;gt;&lt;span&gt;(url);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2）API封装类的调用&lt;/h3&gt;
&lt;p&gt;前面小节介绍了针对Web API接口的封装，以适应客户端快速调用的目的，这个封装作为一个独立的封装层，以方便各个模块之间进行共同调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530143531470-2009189625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里为止，我们还没有测试过具体的调用，还没有了解实际调用过程中是否有问题，当然我们在开发的时候，一般都是一步步来的，但也是确保整个路线没有问题的。&lt;/p&gt;
&lt;p&gt;实际情况如何，是骡是马拉出来溜溜就知道了。&lt;/p&gt;
&lt;p&gt;首先我们创建一个基于.net Core的控制台程序，项目情况如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530144245440-98702868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在其中我们定义这个项目的模块信息，它是依赖于APICaller层的模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RemoteApiConsoleApp
{
    [DependsOn(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CallerModule))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyModule : AbpModule
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Initialize()
        {
            IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ABP里面，模块是通过一定顺序启动的，如果我们通过AbpBootstrapper类来启动相关的模块，启动模块的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用AbpBootstrapper创建类来处理&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; bootstrapper = AbpBootstrapper.Create&amp;lt;MyModule&amp;gt;&lt;span&gt;())
{
    bootstrapper.Initialize();

        ..........&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块启动后，系统的IOC容器会为我们注册好相关的接口对象，那么调用API封装类的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用AbpBootstrapper创建类来处理&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; bootstrapper = AbpBootstrapper.Create&amp;lt;MyModule&amp;gt;&lt;span&gt;())
                {
                    bootstrapper.Initialize();

                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Role
                    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = bootstrapper.IocManager.ResolveAsDisposable&amp;lt;RoleApiCaller&amp;gt;&lt;span&gt;())
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; caller =&lt;span&gt; client.Object;

                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging in with TOKEN based auth...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = caller.Authenticate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123qwe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;
                        Console.WriteLine(token.ToJson());

                        caller.RequestHeaders.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NameValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; token.AccessToken));

                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Getting roles...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pagerDto = &lt;span&gt;new&lt;/span&gt; PagedResultRequestDto() { SkipCount = &lt;span&gt;0&lt;/span&gt;, MaxResultCount = &lt;span&gt;10&lt;/span&gt;&lt;span&gt; };
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; caller.GetAll(pagerDto);
                        Console.WriteLine(result.ToJson());

                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create role...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; permission = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;() { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pages.Roles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; createRoleDto = &lt;span&gt;new&lt;/span&gt; CreateRoleDto { DisplayName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Permissions =&lt;span&gt; permission };
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; roleDto =&lt;span&gt; caller.Create(createRoleDto).Result;
                        Console.WriteLine(roleDto.ToJson());

                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singleDto = &lt;span&gt;new&lt;/span&gt; EntityDto&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;() { Id =&lt;span&gt; roleDto.Id };
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Getting role by id...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        roleDto &lt;/span&gt;=&lt;span&gt; caller.Get(singleDto).Result;
                        Console.WriteLine(roleDto);

                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delete role...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; delResult =&lt;span&gt; caller.Delete(singleDto);
                        Console.WriteLine(delResult.ToJson());

                        Console.ReadLine();
                    }
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是对角色的相关接口操作，如果对于我们之前创建的字典模块，那么它的操作代码类似，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#region&lt;/span&gt; DictType

    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = bootstrapper.IocManager.ResolveAsDisposable&amp;lt;DictTypeApiCaller&amp;gt;&lt;span&gt;())
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; caller =&lt;span&gt; client.Object;

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging in with TOKEN based auth...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = caller.Authenticate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123qwe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;
        Console.WriteLine(token.ToJson());

        caller.RequestHeaders.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NameValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; token.AccessToken));

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get All ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pagerDto = &lt;span&gt;new&lt;/span&gt; DictTypePagedDto() { SkipCount = &lt;span&gt;0&lt;/span&gt;, MaxResultCount = &lt;span&gt;10&lt;/span&gt;&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; caller.GetAll(pagerDto).Result;
        Console.WriteLine(result.ToJson());

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get All by condition ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pagerdictDto = &lt;span&gt;new&lt;/span&gt; DictTypePagedDto() { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;民族&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        result &lt;/span&gt;=&lt;span&gt; caller.GetAll(pagerdictDto).Result;
        Console.WriteLine(result.ToJson());
        
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get count by condition ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        pagerdictDto &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DictTypePagedDto() {};
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; caller.Count(pagerdictDto).Result;
        Console.WriteLine(count);
        Console.WriteLine();

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create DictType...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; createDto = &lt;span&gt;new&lt;/span&gt; CreateDictTypeDto { Id = Guid.NewGuid().ToString(), Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dictDto =&lt;span&gt; caller.Create(createDto).Result;
        Console.WriteLine(dictDto.ToJson());

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Update DictType...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        dictDto.Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; updateDto =&lt;span&gt; caller.Update(dictDto).Result;
        Console.WriteLine(updateDto.ToJson());

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (updateDto != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delete DictType...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            caller.Delete(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; EntityDto&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;() { Id =&lt;span&gt; dictDto.Id });
        }

    }
    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试字典模块的处理，执行效果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530145241676-227871079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除内容，我们是配置为软删除的，因此可以通过数据库记录查看是否标记为删除了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530145526516-897210532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，我们可以看到审计日志里面，有对相关应用层接口的调用记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530145722279-1136019168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是.net core控制台程序中对于API封装接口的调用，上面代码如果需要在.net framework里面跑，也是一样的，我同样也做了一个基于.net framework控制台程序，代码调用都差不多的，它的ApiCaller我们做成了 .net standard程序类库的，因此都是通用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201905/8867-20190530150109339-1518062592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面我们提到，我们的APICaller的类，设计了单件的实例调用，因此我们调用起来更加方便，除了上面使用ABP的启动模块的方式调用外，我们可以用传统的方式进行调用，也就是创建一个ApiCaller的实例对象的方式进行调用，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;string&lt;/span&gt; loginName = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.txtUserName.Text.Trim();
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; password = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.txtPassword.Text;
    AuthenticateResult result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        result &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; DictTypeApiCaller.Instance.Authenticate(loginName, password);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(AbpException ex)
    {
        MessageDxUtil.ShowTips(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户帐号密码不正确。\r\n错误信息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于篇幅的原因，基于winform界面模块的调用，我在后面随笔在另起一篇随笔进行介绍吧，毕竟那是毕竟漂亮的字典模块呈现了。&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 07:05:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<og:description>在前面随笔介绍ABP应用框架的项目组织情况，以及项目中领域层各个类代码组织，以及简化了ABP框架的各个层的内容，使得我们项目结构更加清晰。上篇随笔已经介绍了字典模块中应用服务层接口的实现情况，并且通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuhuacong/p/10932139.html</dc:identifier>
</item>
<item>
<title>【WEB基础】HTML &amp; CSS 基础入门（9）CSS盒子 - 青衫烟雨客</title>
<link>http://www.cnblogs.com/nnzhang/p/10949418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnzhang/p/10949418.html</guid>
<description>&lt;p&gt;网页上的元素辣么多，我该用什么办法让它们排列整齐、间距合理呢。常干家务的朋友们就容易理解了，用收纳盒呀！&lt;/p&gt;
&lt;p&gt;所以用CSS做网页布局就涉及一个盒子的概念，简单理解，我们可以把页面上的所有HTML元素看作一个个的盒子，网页上所展示出来的具体内容，如：文字、图片等都可以理解为内容，是放在盒子里面的东西。&lt;/p&gt;
&lt;p&gt;这些装着内容的盒子排列在网页上，盒子与盒子存在着一定的间隙，我们称为&lt;span&gt;外边距&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;每个盒子都有&lt;span&gt;边框&lt;/span&gt;，每条边框都可以设置自己的样式，边框与内容之间也可以存在一定的间隙，我们称为&lt;span&gt;内边距&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;外边距、边框、内边距按顺时针方向又都可以分为上、右、下、左四个部分，注意，这四个部分我们都是可以单独设置其样式的哟！&lt;/p&gt;
&lt;p&gt;有图有真相，下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530143628958-1436156565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上述可知，盒子由外到内可以列出以下四个属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530142606792-1108467622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;♐外边距margin和内边距padding&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;外边距margin和内边距padding以边框为分界线，它们分四个方向可以分别设置四个不同的值，按顺时针方向分别是上、右、下、左，如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;🅰 &lt;strong&gt;外边距：&lt;/strong&gt;&lt;/span&gt;margin-top（上）、margin -right（右）、margin -bottom（下）、margin -left（左）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;🅱 &lt;strong&gt;内边距：&lt;/strong&gt;&lt;/span&gt;padding-top（上）、padding-right（右）、padding-bottom（下）、padding-left（左）&lt;/p&gt;
&lt;p&gt;具体写法有三种，分别如下所示（margin和padding写法类似，以padding为例）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530142836670-1647102238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;♐&lt;/strong&gt;&lt;strong&gt;Border（边框）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Border(边框)有三个属性值需要设置，分别为边框的宽度（border-width）、边框的样式（border-style）、边框的颜色（border-color）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530145325086-952198137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;♐宽度width和高度height&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元素的宽度width和高度height是针对内容而言的，不包括内边距（padding），可参看上面的图示。另外，只有块元素能设置width和height，行内元素无法设置width和height。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    #div1
    &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将DIV转换为inline-block元素&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px solid green&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置外层DIV的边框样式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    #div2
    &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将DIV转换为inline-block元素&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40px 80px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置内边距上下为40px,左右为80px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;40px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置外边距上为40px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        margin-right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;60px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置外边距右为60px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        margin-bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;80px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置外边距下为80px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置外边距左为100px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;另一写法：margin:40px 60px 80px 100px;顺时针方向&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;5px dotted red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;DIV的边框宽度为5px、样式为点线、颜色为红&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#FCE9B8&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置背景色&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    span&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px solid blue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#C5FCDF&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;CSS盒子模型&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530143910870-1341697705.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是实际的运行效果，有点太单薄，加上点注释说明，下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190530145357481-212918535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;------------------&lt;/em&gt;-------- &lt;/span&gt;END &lt;em&gt;------------------&lt;/em&gt;--------&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 07:04:00 +0000</pubDate>
<dc:creator>青衫烟雨客</dc:creator>
<og:description>网页上的元素辣么多，我该用什么办法让它们排列整齐、间距合理呢。常干家务的朋友们就容易理解了，用收纳盒呀！ 所以用CSS做网页布局就涉及一个盒子的概念，简单理解，我们可以把页面上的所有HTML元素看作一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nnzhang/p/10949418.html</dc:identifier>
</item>
<item>
<title>ArrayList相关方法介绍及源码分析 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10949552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10949552.html</guid>
<description>&lt;h2 id=&quot;arraylist简介&quot;&gt;ArrayList简介：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;java.util.ArrayList&lt;/strong&gt; 是我们最常用的一个类，ArrayList 底层是动态数组，读者可以把它理解为数组的实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码我们可以看到 ArrayList 继承了 AbstractList() 抽象类，并实现了 List, RandomAccess, Cloneable, Serializable 接口&lt;/p&gt;
&lt;h4 id=&quot;abstractlist&quot;&gt;AbstractList :&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractList&amp;lt;E&amp;gt; extends AbstractCollection&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到AbstractList 继承了 AbstractCollection 接口, 并实现了List 接口&lt;/p&gt;
&lt;h4 id=&quot;abstractcollection&quot;&gt;AbstractCollection :&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractCollection&amp;lt;E&amp;gt; implements Collection&amp;lt;E&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractCollection 是一个抽象类，实现了Collection 接口，并提供了某些方法的具体实现。&lt;/p&gt;
&lt;h4 id=&quot;collection&quot;&gt;Collection：&lt;/h4&gt;
&lt;p&gt;Collection 是一个顶级接口，是很多集合类的顶级接口，继承了Iterable ，支持轻量级遍历其中元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;list&quot;&gt;List :&lt;/h4&gt;
&lt;p&gt;ArrayList 实现了List接口，List 也是一个和Collection 媲美的顶级接口，继承了Collection 接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是许多集合类的父类,&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List list = new ArrayList();
List list2 = new LinkedList();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;randomaccess&quot;&gt;RandomAccess&lt;/h4&gt;
&lt;p&gt;RandomAccess 也是一个顶级接口，实现了此接口的类支持随机访问&lt;/p&gt;
&lt;h4 id=&quot;cloneable&quot;&gt;Cloneable&lt;/h4&gt;
&lt;p&gt;Cloneable 接口是一个顶级接口，实现了此接口的类支持浅拷贝&lt;/p&gt;
&lt;h4 id=&quot;serializable&quot;&gt;Serializable&lt;/h4&gt;
&lt;p&gt;实现此接口的类支持序列化的功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类之间的继承关系如图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530145824311-1437226242.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;arraylist-相关方法介绍&quot;&gt;ArrayList 相关方法介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530145843786-745346313.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530145857708-528007363.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;trimToSize()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190530145859369-713909340.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码表示&quot;&gt;代码表示&lt;/h3&gt;
&lt;p&gt;实践才是检验真理最好的方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.*;

/**
 * 详述ArrayList 基本用法
 */
public class ArrayListTest {

    private static class SortList implements Comparator&amp;lt;String&amp;gt; {

        @Override
        public int compare(String o1, String o2) {
            Integer i1 = Integer.valueOf(o1);
            Integer i2 = Integer.valueOf(o2);
            if(i1 &amp;lt; i2){
                return -1;
            }else if(i1 == i2){
                return 0;
            }
            return 1;
        }
    }

    // 使用可变参数，能够接受任意个参数
    public Set&amp;lt;String&amp;gt; putSet(String...args){
        Set&amp;lt;String&amp;gt; sets = new HashSet&amp;lt;&amp;gt;();
        for(String str : args){
            sets.add(str);
        }
        return sets;
    }

    public static void main(String[] args) {
        ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&quot;111&quot;);
        list.add(&quot;222&quot;);

        // 在指定位置添加元素
        list.add(0,&quot;333&quot;);
        System.out.println(list);

        // 进行外部排序
        list.sort(new SortList());
        System.out.println(list);

        list.clear();
        System.out.println(list.size());

        // 使用addAll添加元素
        ArrayListTest at = new ArrayListTest();
        list.addAll(at.putSet(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;));

        Iterator&amp;lt;String&amp;gt; it = list.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
            // 移除所有元素
            it.remove();
        }

        System.out.println(&quot;list是否为空 ? &quot; + list.isEmpty());

        list.add(&quot;111&quot;);
        // 在指定位置添加一个set集合
        list.addAll(0,at.putSet(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;));
        System.out.println(list);

        // 是否包含指定元素
        if(list.contains(&quot;111&quot;)) {
            list.remove(&quot;111&quot;);
        }
        System.out.println(list);

        System.out.println(list.indexOf(&quot;1&quot;));
        // 注意subList()这个方法是左开右闭区间，Java 中很多都是类似的
        System.out.println(list.subList(0,3));

        // 扩大list的容量
        list.ensureCapacity(10);
        // 去掉list空闲的容量
        list.trimToSize();

        // 获取某个特定的元素
        System.out.println(list.get(1));

        // 创建一个list的双向链表
        ListIterator&amp;lt;String&amp;gt; listIterator = list.listIterator();
        while(listIterator.hasNext()){
            // 移到list的末端
            System.out.println(listIterator.next());
        }
        System.out.println(&quot;--------------------------&quot;);
        while (listIterator.hasPrevious()){
            // 移到list的首端
            System.out.println(listIterator.previous());
        }

        // 把list转换为数组
        Object[] objects = list.toArray();
        System.out.println(&quot;objects = &quot; + objects);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;相关方法源码分析&quot;&gt;相关方法源码分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;源码的具体分析是根据上面的代码示例得出，因为只看源码好像并不能看懂什么，需要根据具体的代码一步一步debug 进行跟踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：添加指定的元素在list的末尾&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 添加指定的元素在list的末尾
     */
    // 假设第一次添加的是 &quot;111&quot;
    public boolean add(E e) {
        // size是0，所以size + 1 传的是1
        ensureCapacityInternal(size + 1); 
        // elementData[0] = 111 , size++ = 1
        elementData[size++] = e;
        return true;
    }
    
    // 此方法用来进行list 扩容
    private void ensureCapacityInternal(int minCapacity) {
        // 此时elementData 并没有存储元素，为0
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 则minCapacity 取默认初始容量和minCapacity 的最大值 (取1 和 10的最大值)
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        // 确保清晰的容量(最小容量与List元素的比较)
        ensureExplicitCapacity(minCapacity);
    }

    // 在list中添加了一个元素，所以会导致结构化的修改，&quot;结构化的修改&quot;见下面解释
    // 此时minCapacity 为 10
    private void ensureExplicitCapacity(int minCapacity) {
        // 次数 + 1 
        // 这个列表被修改结构的次数(比如添加和删除元素)会用modCount表示. 结构化修改是指的是能够
        // 改变列表容量的操作，或者其他方式改变它，导致遍历的过程会产生错误的结果。
        modCount++;

        // overflow-conscious code
        // 10 - 0 &amp;gt; 0 走grow 方法
        if (minCapacity - elementData.length &amp;gt; 0)
            grow(minCapacity);
    }

    /**
     * 增加容量确保容纳足够的元素
     * 
     * 参数传过来的是10
     */
    private void grow(int minCapacity) {
        // overflow-conscious code
        // oldCapacity = 0
        int oldCapacity = elementData.length;
        // newCapacity = 0
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
        // newCapacity - minCapacity = -10
        if (newCapacity - minCapacity &amp;lt; 0)
            // newCapacity = 10
            newCapacity = minCapacity;
        
        // MAX_ARRAY_SIZE = 数组分配的最大空间 = 2147483639
        // 一般情况下不会比 MAX_ARRAY_SIZE 还要大
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        // 底层还是用的System.arraycopy(), 关于System.arrayCopy() 读者可以参考我的另一篇博客
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关常用的基本数据类型包装类的值： Java基本数据类型包装类常用的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add(int index, E element)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：在list中指定位置插入指定的元素，如果当前位置有元素，就移动当前位置的元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    /**
     * 在list中指定位置插入指定的元素，如果当前位置有元素，就移动当前位置的元素
     * 要插入的位置的后面所有元素的位置向前 + 1
     *
     */
    public void add(int index, E element) {
        // 检查 0 这个位置是否越界
        rangeCheckForAdd(index);

        // 不再赘述，读者可以自行debug
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // 因为从当前位置插入元素，所以当前位置及后面的元素都会向后移动
        // 使用System.arraycopy 进行数组复制
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        // 为当前元素赋值
        elementData[index] = element;
        size++;
    }

    /**
     * 为add 和 addall 提供的范围检查, 不符合条件，抛出IndexOutOfBoundsException 异常
     */
    private void rangeCheckForAdd(int index) {
        if (index &amp;gt; size || index &amp;lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Clear()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：移除列表中的所有元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 移除list列表中所有的元素，列表会变为空列表在调用此方法后
     *
     */
    public void clear() {
        // 修改次数 + 1
        modCount++;

        // clear to let GC do its work
        // 把每个变量置空，GC进行回收
        for (int i = 0; i &amp;lt; size; i++)
            elementData[i] = null;

        // 列表的长度变为0
        size = 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的源码理解起来还是比较简单的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collection&amp;lt;? extends E&amp;gt; c)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释： 把一个Collection集合添加到list末尾&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 把一个Collection集合(实现了此接口的类)添加到list的末尾，按着迭代的顺序返回。
     * 此操作的行为是如果在此方法调用的过程中修改了Collection(实现了此接口的类)的话，
     * 那么这个操作不会成功
     */
    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        // 把Collection 转换为 Object[] 数组
        Object[] a = c.toArray();
        // 数组中有三个元素
        int numNew = a.length;
        // 因为上面的操作调用了一次list.clear()方法，所以list.size = 0
        ensureCapacityInternal(size + numNew);  // Increments modCount
        // 一句话解释： 把a 数组中0个位置的元素 复制到 elementData数组中 第size个位置的元素，
        // 复制的长度为 numNew
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }

    // toArray()方法： 

    /**
     * 返回一个数组，包含了所有的元素(从第一个元素到最后一个元素)
     * 返回的数组是很&quot;安全的&quot;因为列表没有引用可以维持(换句话说，这个方法必须分配一个新数组)
     * 调用者因此可以任意修改返回的数组
     * 这个方法是数组 和 集合之间的桥梁
     */
    public Object[] toArray() {
        return Arrays.copyOf(elementData, size);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;iterator(), hasNext(), next()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：Iterator方法用于遍历list中的元素，返回一个Itr 的内部类，hasNext()方法用于判断list 中是否还有未遍历的元素，next()方法用于获取下一个元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 以适当的顺序返回此列表中元素的迭代器
     * 返回的iterator 支持fail-fast 机制
     */
    public Iterator&amp;lt;E&amp;gt; iterator() {
        return new Itr();
    }

    /**
     * Itr 是一个内部类，实现了Iterator接口，可支持快速遍历
     */
    private class Itr implements Iterator&amp;lt;E&amp;gt; {
        // 下一个元素返回的下标
        int cursor;       // index of next element to return
        // 最后一个元素返回的下标， 如果没有返回-1
        int lastRet = -1; // index of last element returned; -1 if no such
        // expectedModCount 期望的修改次数，默认是和modCount(修改次数相同，用于iterator判断fail-fast机制)
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public E next() {
            // 判断遍历的过程中是否触发fail-fast机制
            checkForComodification();
            int i = cursor;
            if (i &amp;gt;= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i &amp;gt;= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            // 如果lastRet &amp;lt; 0，说明 lastRet 没有被改变，
            // 所以应该是没有调用next()就调用了remove()
            if (lastRet &amp;lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i &amp;gt;= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i &amp;gt;= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size &amp;amp;&amp;amp; modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        // 如果修改次数不满足预期修改次数的话，抛出异常
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;addAll(int index,Collection&amp;lt;? extends E&amp;gt; c)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：在某个位置添加Collection集合&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 在指定的位置下标插入一个Collection集合
     */
    public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        // 需要移动的元素个数
        int numMoved = size - index;
        if (numMoved &amp;gt; 0)
            // 第一次数组复制，从elementData中的index位置开始，复制到index + numNew位置上，复制numMoved个元素
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);

        // 第二次数组复制,从a 数组中的第0个位置开始，复制到elementData第index位置上你，复制numNew个元素
        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }

    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;contains(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：判断list列表是否包含某个元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 返回true，如果这个列表包含指定的元素
     * 更进一步来说，当且仅当list包含至少一个元素的情况下，返回true
     */
    public boolean contains(Object o) {
        return indexOf(o) &amp;gt;= 0;
    }

    /**
     * 返回列表中第一次出现指定元素的下标值，如果不包含指定元素，则返回-1。
     * 更进一步来说，返回最小的索引当(o == null ? get(i) == null : o.equals(get(i)))的时候
     * 或者返回-1 没有此下标值
     *
     */
    public int indexOf(Object o) {
        // 如果o这个对象等于null，就判断elementData中是否有空元素，如果有，返回
        if (o == null) {
            for (int i = 0; i &amp;lt; size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            // 如果不为null，返回这个值的存储位置
            for (int i = 0; i &amp;lt; size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;remove(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：移除list中的某个元素&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 如果存在，则移除list中某个第一次出现的元素。如果这个list不包含指定元素，就不会改变
     *
     */
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index &amp;lt; size; index++)
                if (elementData[index] == null) {
                    //快速移除某个指定元素
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index &amp;lt; size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    /*
     * 私有的移除方法，并且不返回被移除的元素,这个源码比较简单
     */
    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &amp;gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;indexOf(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：检索某个元素的位置&lt;/p&gt;
&lt;p&gt;此源码和contains(Object o)中调用的indexOf 源码相同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;subList(int fromIndex, int toIndex)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：返回list列表的一个片段&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 返回list列表中的一部分视图(相当于list片段),[fromIndex,toIndex)，如果fromIndex 和
     * toIndex 相同的话，表明这个list为空，这个返回的list被返回，所以在list中并没有结构的改变
     * 这个返回的list片段支持所有的list操作
     */
    public List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex) {
        // subList 范围检查
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }

    static void subListRangeCheck(int fromIndex, int toIndex, int size) {
        if (fromIndex &amp;lt; 0)
            throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
        if (toIndex &amp;gt; size)
            throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
        if (fromIndex &amp;gt; toIndex)
            throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
                                               &quot;) &amp;gt; toIndex(&quot; + toIndex + &quot;)&quot;);
    }

    private class SubList extends AbstractList&amp;lt;E&amp;gt; implements RandomAccess {
        
        private final AbstractList&amp;lt;E&amp;gt; parent;
        private final int parentOffset;
        private final int offset;
        int size;

        SubList(AbstractList&amp;lt;E&amp;gt; parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ensureCapacity(int minCapacity)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：扩大list的容量&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 增加ArrayList实例的容量，如果必须的话，确保它能持有最小容量的元素
     */
    public void ensureCapacity(int minCapacity) {
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It's already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;

        if (minCapacity &amp;gt; minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;trimToSize()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释：去掉list空闲的容量&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 去掉ArrayList中的多余空间
     */
    public void trimToSize() {
        modCount++;
        if (size &amp;lt; elementData.length) {
            elementData = (size == 0)
              ? EMPTY_ELEMENTDATA
              : Arrays.copyOf(elementData, size);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;sort(Comparator&amp;lt;? super E&amp;gt; c)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort 方法接收一个自定义比较器进行自定义比较，下面来看具体的源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void sort(Comparator&amp;lt;? super E&amp;gt; c) {
        // 根据上面代码分析，此时modCounnt 已经被修改过三次(添加了三个元素)
        final int expectedModCount = modCount;
        // 数组外部排序
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 30 May 2019 06:59:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] ArrayList简介： java.util.ArrayList 是我们最常用的一个类，ArrayList 底层是动态数组，读者可以把它理解为数组的实现 如上代码我们可以看到 ArrayL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10949552.html</dc:identifier>
</item>
<item>
<title>机器学习框架ML.NET学习笔记【4】多元分类之手写数字识别 - seabluescn</title>
<link>http://www.cnblogs.com/seabluescn/p/10941580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seabluescn/p/10941580.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、问题与解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过多元分类算法进行手写数字识别，手写数字的图片分辨率为8*8的灰度图片、已经预先进行过处理，读取了各像素点的灰度值，并进行了标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190529060046262-1369222179.png&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中第0列是序号（不参与运算）、1-64列是像素值、65列是结果。&lt;/p&gt;
&lt;p&gt;我们以64位像素值为特征进行多元分类，算法采用SDCA最大熵分类算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、源码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 先贴出全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1fed2aea-86f7-4315-af96-2dad5573c431')&quot; readability=&quot;79&quot;&gt;&lt;img id=&quot;code_img_closed_1fed2aea-86f7-4315-af96-2dad5573c431&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1fed2aea-86f7-4315-af96-2dad5573c431&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1fed2aea-86f7-4315-af96-2dad5573c431',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1fed2aea-86f7-4315-af96-2dad5573c431&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;153&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MulticlassClassification_Mnist
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TrainDataPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optdigits-full.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ModelPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SDCA-Model.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            MLContext mlContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MLContext(seed: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
          
            TrainAndSaveModel(mlContext);
            TestSomePredictions(mlContext);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hit any key to finish the app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
              

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TrainAndSaveModel(MLContext mlContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 1: 准备数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fulldata =&lt;span&gt; mlContext.Data.LoadFromTextFile(path: TrainDataPath,
                    columns: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PixelValues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;65&lt;/span&gt;&lt;span&gt;)
                    },
                    hasHeader: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    separatorChar: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    );

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainTestData = mlContext.Data.TrainTestSplit(fulldata, testFraction: &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainData =&lt;span&gt; trainTestData.TrainSet;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testData =&lt;span&gt; trainTestData.TestSet;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 2: 配置数据处理管道        &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; dataProcessPipeline = mlContext.Transforms.Conversion.MapValueToKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, keyOrdinality: ValueToKeyMappingEstimator.KeyOrdinality.ByValue);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 3: 配置训练算法&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; trainer = mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy(labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PixelValues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainingPipeline =&lt;span&gt; dataProcessPipeline.Append(trainer)
              .Append(mlContext.Transforms.Conversion.MapKeyToValue(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 4: 训练模型使其与数据集拟合&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=============== Train the model fitting to the DataSet ===============&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);           

            ITransformer trainedModel &lt;/span&gt;=&lt;span&gt; trainingPipeline.Fit(trainData);         


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 5:评估模型的准确性&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===== Evaluating Model's accuracy with Test data =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; predictions =&lt;span&gt; trainedModel.Transform(testData);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = mlContext.MulticlassClassification.Evaluate(data: predictions, labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, scoreColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            PrintMultiClassClassificationMetrics(trainer.ToString(), metrics);
         
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; STEP 6:保存模型              &lt;/span&gt;
            mlContext.ComponentCatalog.RegisterAssembly(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DebugConversion).Assembly);
            mlContext.Model.Save(trainedModel, trainData.Schema, ModelPath);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The model is saved to {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ModelPath);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestSomePredictions(MLContext mlContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load Model           &lt;/span&gt;
            ITransformer trainedModel = mlContext.Model.Load(ModelPath, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; modelInputSchema);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create prediction engine &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predEngine = mlContext.Model.CreatePredictionEngine&amp;lt;InputData, OutPutData&amp;gt;&lt;span&gt;(trainedModel);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;num 1&lt;/span&gt;
            InputData MNIST1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputData()
            {               
                PixelValues &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[] { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; }
            }; 
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultprediction1 =&lt;span&gt; predEngine.Predict(MNIST1);
            resultprediction1.PrintToConsole();           
        }      
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; InputData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; Serial;
        [VectorType(&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;[] PixelValues;               
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; Number;       
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutPutData : InputData
    {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;[] Score;  
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 整体流程和二元分类没有什么区别，下面解释一下有差异的两个地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1、加载数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      //&lt;/span&gt;&lt;span&gt; STEP 1: 准备数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fulldata =&lt;span&gt; mlContext.Data.LoadFromTextFile(path: TrainDataPath,
                    columns: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PixelValues&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;&lt;span&gt;),
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextLoader.Column(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, DataKind.Single, &lt;span&gt;65&lt;/span&gt;&lt;span&gt;)
                    },
                    hasHeader: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    separatorChar: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  这次我们不是通过实体对象来加载数据，而是通过列信息来进行加载，其中PixelValues是特征值，Number是标签值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、训练通道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            //&lt;/span&gt;&lt;span&gt; STEP 2: 配置数据处理管道        &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; dataProcessPipeline = &lt;span&gt;mlContext.Transforms.Conversion.MapValueToKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, keyOrdinality: ValueToKeyMappingEstimator.KeyOrdinality.ByValue)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;br/&gt;&lt;/span&gt;&lt;span&gt;            //&lt;/span&gt;&lt;span&gt; STEP 3: 配置训练算法&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; trainer = mlContext.MulticlassClassification.Trainers.SdcaMaximumEntropy(labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;PixelValues&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainingPipeline =&lt;span&gt; dataProcessPipeline.Append(trainer) &lt;br/&gt;.Append(mlContext.Transforms.Conversion.MapKeyToValue(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); &lt;/span&gt;&lt;span&gt;            //&lt;/span&gt;&lt;span&gt; STEP 4: 训练模型使其与数据集拟合&lt;/span&gt; &lt;span&gt;&lt;br/&gt;ITransformer trainedModel &lt;/span&gt;= trainingPipeline.Fit(trainData);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 首先通过MapValueToKey方法将Number值转换为Key类型，多元分类算法要求标签值必须是这种类型（类似枚举类型，二元分类要求标签为BOOL类型）。关于这个转换的原因及编码方式，下面详细介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、键值类型编码与独热编码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; MapValueToKey功能是将（字符串）值类型转换为KeyTpye类型。&lt;/p&gt;
&lt;p&gt;有时候某些输入字段用来表示类型（类别特征），但本身并没有特别的含义，比如编号、电话号码、行政区域名称或编码等，这里需要把这些类型转换为1到一个整数如1-300来进行重新编号。&lt;/p&gt;
&lt;p&gt;举个简单的例子，我们进行图片识别的时候，目标结果可能是“猫咪”、“小狗”、“人物”这些分类，需要把这些分类转换为1、2、3这样的整数。但本文的标签值本身就是1、2、3，为什么还要转换呢？因为我们这里的一二三其实不是数学意义上的数字，而是一种标志，可以理解为壹、贰、叁，所以要进行编码。&lt;/p&gt;
&lt;p&gt; MapKeyToValue和MapValueToKey相反，它把将键类型转换回其原始值（字符串）。就是说标签是文本格式，在运算前已经被转换为数字枚举类型了，此时预测结果为数字，通过MapKeyToValue将其结果转换为对应文本。&lt;/p&gt;
&lt;p&gt;MapValueToKey一般是对标签值进行编码，一般不用于特征值，如果是特征值为字符串类型的，建议采用独热编码。独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。例如：&lt;/p&gt;
&lt;p&gt;自然状态码为：0,1,2,3,4,5&lt;br/&gt;独热编码为：000001,000010,000100,001000,010000,100000&lt;/p&gt;
&lt;p&gt;怎么理解这个事情呢？举个例子，假如我们要进行人的身材的分析，但我们希望加入地域特征，比如：“黑龙江”、“山东”、“湖南”、“广东”这种特征，但这种字符串机器学习是不认识的，必须转换为浮点数，刚才提到MapKeyToValue可以把字符串转换为数字，为什么这里要采用独热编码呢？简单来说，假设把地域名称转换为1到10几个数字，在欧氏几何中1到3的欧拉距离和1到9的欧拉距离是不等的，但经过独热编码后，任意两点间的欧拉距离都是相等的，而我们这里的地域特征仅仅是想表达分类关系，彼此之间没有其他逻辑关系，所以应该采用独热编码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190529090627423-1050852733.png&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、进度调试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般机器算法的数据拟合过程时间都比较长，有时程序跑了两个小时还没结束，也不知道还需要多长时间，着实让人着急，所以及时了解学习进度，是很有必要的。&lt;/p&gt;
&lt;p&gt;由于机器学习算法一般都有“递归直到收敛”这种操作，所以我们是没有办法预先知道最终运算次数的，能做到的只能打印一些过程信息，看到程序在动，心里也有点底，当系统跑过一次之后，基本就大致知道需要多少次拟合了，后面再调试就可以大致了解进度了。补充一句，可不可以在测试阶段先减少样本数据进行快速调试，调试通过后再切换到全样本进行训练？其实不行，有时候样本数量小，可能会引起指标震荡，时间反而长了。&lt;/p&gt;
&lt;p&gt;之前在Githube上看到有人通过MLContext.LOG事件来打印调试信息，我试了一下，发现没法控制筛选内容，不太方便，后来想到一个方法，就是新增一个自定义数据处理通道，这个通道不做具体事情，就打印调试信息。&lt;/p&gt;
&lt;p&gt;类定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MulticlassClassification_Mnist
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DebugConversionInput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Serial { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DebugConversionOutput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DebugFeature { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    [CustomMappingFactoryAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DebugConversionAction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DebugConversion : CustomMappingFactory&amp;lt;DebugConversionInput, DebugConversionOutput&amp;gt;&lt;span&gt;
    {       &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; TotalCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CustomAction(DebugConversionInput input, DebugConversionOutput output)
        {
            output.DebugFeature &lt;/span&gt;= &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt;;  &lt;br/&gt;TotalCount++;&lt;/span&gt;&lt;span&gt;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DebugConversion.CustomAction's debug info.TotalCount={TotalCount} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);                      
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Action&amp;lt;DebugConversionInput, DebugConversionOutput&amp;gt;&lt;span&gt; GetMapping()
              &lt;/span&gt;=&amp;gt;&lt;span&gt; CustomAction;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; dataProcessPipeline = mlContext.Transforms.CustomMapping(&lt;span&gt;new&lt;/span&gt; DebugConversion().GetMapping(), contractName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DebugConversionAction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
       .Append(...)
       .Append(mlContext.Transforms.Concatenate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Features&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RealFeatures&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DebugFeature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过CustomMapping加载我们自定义的数据处理通道，由于数据集是懒加载（Lazy）的，所以必须把我们自定义数据处理通道的输出加入为特征值，才能参与运算，然后算法在操作每一条数据时都会调用到CustomAction方法，这样就可以打印进度信息了。为了不影响运算结果，我们把这个数据处理通道的输出值固定为1.0f 。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、资源获取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码下载地址：https://github.com/seabluescn/Study_ML.NET&lt;/p&gt;
&lt;p&gt;工程名称：MulticlassClassification_Mnist&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;点击查看机器学习框架ML.NET学习笔记系列文章目录&quot; href=&quot;https://www.cnblogs.com/seabluescn/p/10904391.html&quot; target=&quot;_blank&quot;&gt;点击查看机器学习框架ML.NET学习笔记系列文章目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 06:52:00 +0000</pubDate>
<dc:creator>seabluescn</dc:creator>
<og:description>通过多元分类算法实现手写数字识别。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seabluescn/p/10941580.html</dc:identifier>
</item>
<item>
<title>Django学习笔记（13）——Django的用户认证组件，视图层和QuerySet API - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/10065929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/10065929.html</guid>
<description>&lt;h2&gt;用户认证组件的学习&lt;/h2&gt;
&lt;p&gt;　　用户认证是通过取表单数据根数据库对应表存储的值做比对，比对成功就返回一个页面，不成功就重定向到登录页面。我们自己写的话当然也是可以的，只不过多写了几个视图，冗余代码多，当然我们也可以封装成函数，简单代码。不过推荐使用Django提供的一套用户认证组件，原理其实类似，只不过功能更强大。&lt;/p&gt;
&lt;h3&gt;1，用户认证——auth模块&lt;/h3&gt;
&lt;p&gt;　　在进行用户登录验证的时候，如果是自己写代码，就必须要先查询数据库，看用户输入的用户名是否存在于数据库中；如果用户存在于数据库中，然后在验证用户输入的密码，这样一来，自己就需要编写大量的代码。&lt;/p&gt;
&lt;p&gt;　　事实上，Django已经提供了内置的用户认证功能，在使用“python manage.py makemigrations” 和 “python manage.py migrate” 迁移完成数据库之后，根据配置文件settings.py中的数据库段生成的数据表中已经包含了6张进行认证的数据表，分别是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201904/1226410-20190416184947663-1211078340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而要进行用户认证的数据表示auth_user。&lt;/p&gt;
&lt;p&gt;　　要使用Django自带的认证功能，首先导入auth模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# auth主认证模块
from django.contrib.auth.models import auth
# 对应数据库，可以创建添加记录
from django.contrib.auth.models import User
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　django.contrib.auth中提供了许多方法，这里主要介绍其中三个：&lt;/p&gt;
&lt;h4&gt;1.1 authenticate()&lt;/h4&gt;
&lt;p&gt;　　提供了用户认证，即验证用户名以及密码是否正确，一般需要username，password 两个关键字参数。&lt;/p&gt;
&lt;p&gt;　　如果认证信息有效，会返回一个user对象。authenticate()会在User对象上设置一个属性标识那种认证后端认证了该用户，且该信息在后面的登录过程中是需要的。当我们试图登录一个从数据库中直接取出来不经过authenticate()的User对象会报错的！&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    user=authenticate(username=&quot;uaername&quot;,password=&quot;password&quot;)
    
    login(HttpResponse,user)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个函数接受一个HTTPRequest对象，以及一个通过authenticate() 函数认证的User对象。&lt;/p&gt;

&lt;h4&gt;1.2 login(HttpRequest，user)&lt;/h4&gt;
&lt;p&gt;　　该函数接受一个HttpRequest对象 ，以及一个认证了的User对象，此函数使用django的session框架给某个已认证的用户附加上session id等信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import redirect, HttpResponse
from django.contrib.auth import authenticate, login

def auth_view(request):
  username = request.POST['username']
  password = request.POST['password']
  user = authenticate(username=username, password=password)
  if user is not None:
    login(request, user)
    # Redirect to a success page.
    return redirect(&quot;/index/&quot;)
  else:
    # Return an 'invalid login' error message.
    return HttpResponse(&quot;username or password is incorrect&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该函数实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据。&lt;/p&gt;
&lt;h4&gt;1.3 logout(request)注销用户&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth import logout

def logout_view(request):
  logout(request)
  # Redirect to a success page.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该函数接受一个HttpRequest对象，无返回值。当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错。&lt;/p&gt;
&lt;p&gt;　　虽然使用的logout()函数，但是其本质上还是使用的是fulsh() 。我们可以查看 auth.logout()函数的源码&lt;/p&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190528162848945-214551415.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;602&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;　　从源码中发现，验证完之后，还是使用  request.session.flush() 进行删除session信息。&lt;/p&gt;
&lt;h3&gt;2，User对象&lt;/h3&gt;
&lt;p&gt;　　User对象属性：username，password（必填项） password用哈希算法保存到数据库。&lt;/p&gt;
&lt;p&gt;django Auth模块自带User模型所包含字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
username：用户名

email: 电子邮件

password：密码

first_name：名

last_name：姓

is_active: 是否为活跃用户。默认是True

is_staff: 是否为员工。默认是False

is_superuser: 是否为管理员。默认是False

date_joined: 加入日期。系统自动生成。
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; 2.1  user对象的is_authenticated()&lt;/h4&gt;
&lt;p&gt;　　如果是真正的User对象，返回值恒为True，用于检查用户是否已经通过了认证。通过认证并不意味着用户认证拥有任何权限，甚至也不检查该用户是否处于激活状态，这只是表明用户成功的通过了认证。这个方法很重要，在后台用request.user.is_authenticated()判断用户是否已经登录，如果true则可以向前台展示request.user.name。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，用户登录后才能访问某些页面&lt;/li&gt;
&lt;li&gt;2，如果用户没有登录就访问该页面的话直接跳到登录页面&lt;/li&gt;
&lt;li&gt;3，用户在跳转的登录界面中完成登录后，自动访问跳转到之前访问的地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def  my_view(request):
    if  not  request.user.is_authenticated()：
        return  redirect(&quot;%s?next=%s&quot;%(settings.LOGIN_URL, request.path))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;　　django已经为我们设计好了一个用于此种情况的装饰器：login_required()&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;login_required()：用来快捷的给某个视图添加登录校验的装饰器工具。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.decorators import login_required
      
@login_required
def my_view(request):
  ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若用户没有登录，则会跳转到django默认的登录URL ‘/accounts/login/’并传递当前访问url的绝对路径（登录成功后，会重定向到该路径）。&lt;/p&gt;
&lt;p&gt;　　如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
LOGIN_URL = '/login/'  # 这里配置成你项目登录页面的路由
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.2 创建用户&lt;/h4&gt;
&lt;p&gt;　　使用create_user辅助函数创建用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.models import User

user = User.objects.create_user(username=&quot; &quot; , password =&quot; &quot;, email=&quot; &quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用create_superuser()创建超级用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.models import User

user = User.objects.create_superuser（username='用户名',password='密码',email='邮箱',...）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　is_authenticated()用来判断当前请求是否通过了认证。&lt;/p&gt;
&lt;p&gt;　　用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def my_view(request):
  if not request.user.is_authenticated():
    return redirect('%s?next=%s' % (settings.LOGIN_URL, request.path))
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.3  检查密码是否正确&lt;/h4&gt;
&lt;p&gt; 　　使用check_password(passwd)来检查密码是否正确，密码正确的话返回True，否则返回False。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
ok = user.check_password('密码')
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.4  修改密码&lt;/h4&gt;
&lt;p&gt;　　使用set_password() 来修改密码，接受要设置的新密码作为参数。&lt;/p&gt;
&lt;p&gt;　　用户需要修改密码的时候，首先让他输入原来的密码，如果给定的字符串通过了密码检查，返回True&lt;/p&gt;
&lt;p&gt;　　注意：设置完一定要调用用户对象的save方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
user = User.objects.get(username = ' ' ）
user.set_password(password ='')
user.save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改密码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.models import User
from django.shortcuts import HttpResponse

def register(request):
    # 创建用户
    user_obj = User.objects.create_user(username='james', password='123')
    # 检查密码（一般用于修改密码前验证）
    ret = user_obj.check_password('123')
    print(ret)  # 返回False
    # 修改密码
    user_obj.set_password('1234')
    # 修改后保存
    user_obj.save()
    # 修改后检查
    ret = user_obj.check_password('1234')
    print(ret)  # 返回True
    return HttpResponse(&quot;OK&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.5  示例一：使用set_password() 方法来修改密码&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import render,redirect,HttpResponse
from django.contrib.auth.models import User
    
def create_user(request):
    
        msg=None
    
        if request.method==&quot;POST&quot;:
            username=request.POST.get(&quot;username&quot;,&quot; &quot;)           # 获取用户名，默认为空字符串
            password=request.POST.get(&quot;password&quot;,&quot; &quot;)           # 获取密码，默认为空字符串
            confirm=request.POST.get(&quot;confirm_password&quot;,&quot; &quot;)    # 获取确认密码，默认为空字符串
    
            if password == &quot;&quot; or confirm==&quot;&quot; or username==&quot;&quot;:   # 如果用户名，密码或确认密码为空
                msg=&quot;用户名或密码不能为空&quot;
            elif password !=confirm:                            # 如果密码与确认密码不一致
                msg=&quot;两次输入的密码不一致&quot;
            elif User.objects.filter(username=username):        # 如果数据库中已经存在这个用户名
                msg=&quot;该用户名已存在&quot;
            else:
                new_user=User.objects.create_user(username=username,password=password)  
                 #创建新用户 
                new_user.save()
            
                return redirect(&quot;/index/&quot;)
        
        return render(request,&quot;login.html&quot;,{&quot;msg&quot;:msg})
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.6 示例二：使用login_required 装饰器 来修改密码&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import render, redirect, HttpResponse
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User


@login_required
def change_passwd(request):
    user = request.user  # 获取用户名
    msg = None

    if request.method == 'POST':
        old_password = request.POST.get(&quot;old_password&quot;, &quot;&quot;)  # 获取原来的密码，默认为空字符串
        new_password = request.POST.get(&quot;new_password&quot;, &quot;&quot;)  # 获取新密码，默认为空字符串
        confirm = request.POST.get(&quot;confirm_password&quot;, &quot;&quot;)  # 获取确认密码，默认为空字符串

        if user.check_password(old_password):  # 到数据库中验证旧密码通过
            if new_password or confirm:  # 新密码或确认密码为空
                msg = &quot;新密码不能为空&quot;
            elif new_password != confirm:  # 新密码与确认密码不一样
                msg = &quot;两次密码不一致&quot;

            else:
                user.set_password(new_password)  # 修改密码
                user.save()

                return redirect(&quot;/index/&quot;)
        else:
            msg = &quot;旧密码输入错误&quot;

    return render(request, &quot;change_passwd.html&quot;, {&quot;msg&quot;: msg})
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3，基于用户认证组件的示例&lt;/h3&gt;
&lt;p&gt;　　功能就是用session记录登录验证状态，但是前提是要使用Django自带的auth_user，所以我们需要创建超级用户。下面都会说到。其用户认证组件最大的优点就是 request.user 是一个全局变量，在任何视图和模板中都能直接使用。&lt;/p&gt;
&lt;p&gt;　　重点是下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if not:
    auth.logout(request, user)
    #此时返回的对象 request.user == AnonymousUser()
else:
    request.user == 登录对象
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.1 基于用户认证组件的登录验证信息存储功能&lt;/h4&gt;
&lt;p&gt;　　下面我们完成一个登陆验证信息存储功能，我们使用的就是上面讲到的auth模块的authenticate()函数。上面也说到了，authenticate()提供了用户认证，即验证用户名和密码是否正确，如果认证信息有效的话，会返回一个user对象。&lt;/p&gt;
&lt;p&gt;　　由于User表不是我们创建的，而且人家密码是加密的，如何加密我们并不知道。所以提取认证方式只能使用人家设置的认证方式。&lt;/p&gt;
&lt;p&gt;　　我们要的是，创建一个超级用户，然后写一个登录验证函数，如果验证成功，进入索引界面。如果验证失败，则继续留在验证页面。&lt;/p&gt;
&lt;p&gt;　　首先，我们创建一个超级用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
python manage.py createsuperuser 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　名称为 james， 密码为 123。我们在数据库的 auth_user中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529085809877-916415693.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;77&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我们完成登录验证函数和简单的索引函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import render, HttpResponse, redirect

# Create your views here.
from django.contrib import auth
from django.contrib.auth.models import User
from auth_demo import models

def login(request):
    if request.method == 'POST':
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        # if 验证成功返回 user 对象，否则返回None
        user = auth.authenticate(username=user, password=pwd)

        if user:
            # request.user ： 当前登录对象
            auth.login(request, user)
            # return HttpResponse(&quot;OK&quot;)
            return redirect('/auth/index')


    return render(request, 'auth/login.html')

def index(request):
    print('request.user', request.user.username)
    print('request.user', request.user.id)
    # 下面是判断是是否是匿名
    print('request.user', request.user.is_anonymous)

    if request.user.is_anonymous:
    # if not request.user.authenticated():
        return redirect('/auth/login')
    username = request.user.username

    return render(request, 'auth/index.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面写一个简单的login页面 和 index页面。&lt;/p&gt;
&lt;p&gt;　　login.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;


&amp;lt;h1&amp;gt;login  page&amp;lt;/h1&amp;gt;

&amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;
    {% csrf_token %}
    &amp;lt;p&amp;gt;username:&amp;lt;input type=&quot;text&quot; name=&quot;user&quot; &amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;password:&amp;lt;input type=&quot;password&quot; name=&quot;pwd&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;this is index page&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;{{ username }}&amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面进入登录界面，如果登录成功，则进入索引界面，我们输入正确的账号和密码。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529085843029-1478569213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击提交如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529085912823-593440088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3.2 基于用户认证组件的注销功能&lt;/h4&gt;
&lt;p&gt;　　上面我们也说了，用户注销的话，我们可以使用request.session.fulsh()。但是Django自带了auth.logout()函数，为什么使用这个呢？其实我们前面也看了源码。在进行验证后，使用request.session.fulsh()，但是他最后使用了匿名函数 AnonymousUser()。&lt;/p&gt;
&lt;p&gt;　　下面我们写一个注销函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def logout(request):
    auth.logout(request)
    return redirect(request, '/auth/login/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实非常简单，注销后，将页面重定向到登录页面。我们在前台索引页面，加上一个注销的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;this is index page&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;{{ username }}&amp;lt;/p&amp;gt;

&amp;lt;a href=&quot;/auth/login&quot;&amp;gt;注销&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　点进去索引界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529091443179-945967203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们点击注销，则返回到登录页面，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529091512367-1623691654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　点击注销后，我们可以去数据库查看 django_session 的内容，会发现，注销后，一条记录就没有了。&lt;/p&gt;
&lt;h4&gt;3.3 基于用户认证组件的注册用户功能&lt;/h4&gt;
&lt;p&gt;　　在上面用户登录的时候，我们会发现有一行代码，是&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
user = auth.authenticate(username=user, password=pwd)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也就是说，数据库已经存在了数据，那么要是没数据的话，我们怎么办？&lt;/p&gt;
&lt;p&gt;　　下面我们演示一个注册用户的功能。&lt;/p&gt;
&lt;p&gt;我们将数据从前台拿过来，我们下面就是插入数据到User表中，这里注意的是，我们不能直接插入，比如下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
user = User.objects.create(username=user, password=pwd)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面插入时是明文插入，但是我们不能这样，我们需要插入的是加密后的密码，所以使用下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
user = User.objects.create_user(username=user, password=pwd)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　OK，说完注意点，我们写注册视图函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def register(request):
    if request.method == 'POST':
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        user = User.objects.create_user(username=user, password=pwd)
        return HttpResponse(&quot;OK&quot;)

    return render(request, 'auth/register.html')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们注册成功后，显示OK即可（简单方便）。&lt;/p&gt;
&lt;p&gt;       注册页面和登录类似，我们展示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;


&amp;lt;h1&amp;gt;register  page&amp;lt;/h1&amp;gt;

&amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;
    {% csrf_token %}
    &amp;lt;p&amp;gt;username:&amp;lt;input type=&quot;text&quot; name=&quot;user&quot; &amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;password:&amp;lt;input type=&quot;password&quot; name=&quot;pwd&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注册页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529093443281-276049707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们注册一个 durant，我们在 auth_user 数据库中查看结果：&lt;/p&gt;
&lt;p&gt;　　注册成功如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529093546825-1082443120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　auth_user 数据表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529093628079-219157756.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这表明我们注册成功了。&lt;/p&gt;
&lt;h4&gt;3.4 基于用户认证组件的认证装饰器功能&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;为什么要用认证装饰器呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在以后的代码中，我们肯定需要很多认证登录，如果验证成功，则进入登录页面，如果验证不成功，则返回到登录页面。那么为了避免代码的冗余，我们可以写一个装饰器的东西，不过Django已经为我们准备好了，我们只需要用就行。&lt;/p&gt;
&lt;p&gt;　　验证装饰器：看那些页面需要登录才能访问，如果没有登录跳转设置的页面去。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：在settings.py中设置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 用于auth模块 装饰器校验返回页面
LOGIN_URL = '/login/'  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在django项目中，经常看有下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User


@login_required
def my_view(request):
    pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　里面有一个@login_required标签。其作用就是告诉程序，使用这个方法是要求用户登录的。&lt;/p&gt;
&lt;p&gt;　　下面举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def index(request):
    username = request.user.username

    return render(request, 'auth/index.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们访问上面已经完成的 index页面，我们会发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529100441752-2047661845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当我们给 index 视图函数加上装饰器，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.contrib.auth.decorators import login_required

@login_required
def index(request):
    username = request.user.username
return render(request, 'auth/index.html', locals())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们再来访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529102056896-1898642496.png&quot; alt=&quot;&quot; width=&quot;545&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面说一下，URL是什么意思呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529102128246-61991987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1，如果用户还没有登录，默认会跳转到'/accounts/login/'。这个值可以在settings文件中通过LOGIN_URL参数来设定。（后面还会自动加上你请求的url作为登录后跳转的地址，如：/accounts/login/?next=/auth/index/ 登录完成之后，会去请求）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 如果不添加该行，则在未登陆状态打开页面的时候验证是否登陆的装饰器跳转到/accounts/login/下面
# 第一张方法就是修改settings.py 中的 LOGIN_URL
LOGIN_URL = &quot;/login/&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529101830389-2069576939.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为什么会报错呢？因为我们没有设置其路径。&lt;/p&gt;
&lt;p&gt;　　我们在settings.py中设置登录URL（当然这是我自己的路由地址）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 这里配置成项目登录页面的路由
LOGIN_URL = '/auth/login'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面访问 index则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190529102157538-209462659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　没有用户没有登录的话，则直接跳转到登录页面。&lt;/p&gt;
&lt;p&gt;　　我们不能讲登录视图函数的代码写死，这里改进一下，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def login(request):
    if request.method == 'POST':
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        # if 验证成功返回 user 对象，否则返回None
        user = auth.authenticate(username=user, password=pwd)

        if user:
            # request.user ： 当前登录对象
            auth.login(request, user)
            next_url = request.GET.get('next', 'auth/index')
            return redirect(next_url)


    return render(request, 'auth/login.html')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果验证成功，我们跳转到 next_url，如果获取不到，则跳转到index页面。&lt;/p&gt;
&lt;p&gt;　　2，如果用户登录了，那么该方法就可以正常执行&lt;/p&gt;
&lt;p&gt;　　如果LOGIN_URL使用默认值，那么在urls.py中还需要进行如下设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 第二种解决方法是在 url 中匹配该url

(r'^accounts/login/$', 'django.contrib.auth.views.login'),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样的话，如果未登录，程序会默认跳转到“templates/registration/login/html” 这个模板。&lt;/p&gt;
&lt;p&gt;　　如果想换个路径，那就在加个template_name参数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
(r'^accounts/login/$', 'django.contrib.auth.views.login', 
{'template_name': 'myapp/login.html'}),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样程序就会跳转到 template/myapp/login.html 中。&lt;/p&gt;

&lt;h2&gt;Django视图层的学习&lt;/h2&gt;
&lt;p&gt;　　我在之前的&lt;a href=&quot;https://www.cnblogs.com/yuanchenqi/articles/9064397.html&quot; target=&quot;_blank&quot;&gt;Django学习笔记（2）：模板后台管理和视图的学习&lt;/a&gt; 中学习了视图层，并对其有了大概的理解。现在再进一层的学习视图层中request属性和HttpResponse对象的方法。&lt;/p&gt;
&lt;h3&gt;1，视图函数&lt;/h3&gt;
&lt;p&gt;　　一个视图函数，简称视图，是一个简单的Python函数，它接受Web请求并返回Web响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片...是任何东西都可以。无论视图本身包含什么逻辑，都要返回响应。为了将代码放在某处，约定是将视图放置在项目或者应用程序目录中的名为 views.py 的问卷中。&lt;/p&gt;
&lt;p&gt;　　下面是一个返回当前日期和时间作为HTML 文档的视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, redirect
import datetime

def current_datetime(request):
    now = datetime.datetime.now()
    html = &quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It is now %s.&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; % now
    return HttpResponse(html)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们来逐行阅读上面的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，我们从django.shortcuts 模块导入了 HttpResponse类，以及Python的datetime库。&lt;/li&gt;
&lt;li&gt;接着，我们定义了current_datetime函数。它就是视图函数，每个视图函数都使用HttpRequest对象作为第一个参数，并且通常称之为 request。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：视图函数的名称并不重要，不需要用一个统一的命名方式来命名。以便让Django能够识别它，我们将其命名为current_datetime，是因为这个名称能够精准的反映出其功能*（我认为啊）&lt;/li&gt;
&lt;li&gt;这个视图会返回一个HttpResponse对象。其中包含生成的响应。每个视图函数都负责返回一个HttpResponse对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　而视图层中，熟练掌握两个对象：&lt;strong&gt;请求对象（request）&lt;/strong&gt;和&lt;strong&gt;响应对象（HttpResponse）&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2，request属性&lt;/h3&gt;
&lt;p&gt;　　django将请求报文中的请求行，首部信息，内容主体封装成 HttpRequest 类中的属性。除了特殊说明之外，其他的均为只读。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1.HttpRequest.GET

　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。

2.HttpRequest.POST

　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。

　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是
表单中没有任何的数据，QueryDict 对象依然会被创建。
   因此，不应该使用 if request.POST  来检查使用的是否是POST 方法；
应该使用 if request.method == &quot;POST&quot;
　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。
   
   注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：
        request.POST.getlist(&quot;hobby&quot;)

3.HttpRequest.body

　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，
例如：二进制图片、XML,Json等。

　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。


4.HttpRequest.path

　　一个字符串，表示请求的路径组件（不含域名）。
　　例如：&quot;/music/bands/the_beatles/&quot;

5.HttpRequest.method

　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。
　　例如：&quot;GET&quot;、&quot;POST&quot;


6.HttpRequest.encoding

　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 
DEFAULT_CHARSET 的设置，默认为 'utf-8'）。
   这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。
   接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。
   如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。


7.HttpRequest.META

 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端
和服务器，下面是一些示例：

    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。
    CONTENT_TYPE —— 请求的正文的MIME 类型。
    HTTP_ACCEPT —— 响应可接收的Content-Type。
    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。
    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。
    HTTP_HOST —— 客服端发送的HTTP Host 头部。
    HTTP_REFERER —— Referring 页面。
    HTTP_USER_AGENT —— 客户端的user-agent 字符串。
    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。
    REMOTE_ADDR —— 客户端的IP 地址。
    REMOTE_HOST —— 客户端的主机名。
    REMOTE_USER —— 服务器认证后的用户。
    REQUEST_METHOD —— 一个字符串，例如&quot;GET&quot; 或&quot;POST&quot;。
    SERVER_NAME —— 服务器的主机名。
    SERVER_PORT —— 服务器的端口（是一个字符串）。
 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何
 HTTP 首部转换为 META 的键时，都会将所有字母大写并将连接符替换为下划线最后加上 
HTTP_  前缀。
    所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。

8.HttpRequest.FILES

　　一个类似于字典的对象，包含所有的上传文件信息。
   FILES 中的每个键为&amp;lt;input type=&quot;file&quot; name=&quot;&quot; /&amp;gt; 中的name，值则为对应的数据。
　　注意，FILES 只有在请求的方法为POST 且提交的&amp;lt;form&amp;gt; 带有
enctype=&quot;multipart/form-data&quot; 的情况下才会包含数据。否则，FILES 将为一个空的
类似于字典的对象。


9.HttpRequest.COOKIES

　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。



10.HttpRequest.session

 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。
    完整的细节参见会话的文档。


11.HttpRequest.user(用户认证组件下使用)

　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。

　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 
的一个实例。你可以通过 is_authenticated() 区分它们。

    例如：

    if request.user.is_authenticated():
        # Do something for logged-in users.
    else:
        # Do something for anonymous users.


     　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。

     -------------------------------------------------------------------------------------

    
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;匿名函数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
匿名用户
    class models.AnonymousUser

    django.contrib.auth.models.AnonymousUser 类实现了
django.contrib.auth.models.User 接口，但具有下面几个不同点：

    id 永远为None。
    username 永远为空字符串。
    get_username() 永远返回空字符串。
    is_staff 和 is_superuser 永远为False。
    is_active 永远为 False。
    groups 和 user_permissions 永远为空。
    is_anonymous() 返回True 而不是False。
    is_authenticated() 返回False 而不是True。
    set_password()、check_password()、save() 和delete() 引发 NotImplementedError。
    New in Django 1.8:
    新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3，request常用方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1.HttpRequest.get_full_path()

　　返回 path，如果可以将加上查询字符串。

　　例如：&quot;/music/bands/the_beatles/?print=true&quot;


2.HttpRequest.is_ajax()

　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 
HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。

　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 
XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 
可以工作。

　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形
式的缓存例如Django 的 cache middleware，
   你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图
以让响应能够正确地缓存。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4，HttpResponse对象&lt;/h3&gt;
&lt;p&gt;　　响应对象主要有三种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HttpResponse()&lt;/li&gt;
&lt;li&gt;render()&lt;/li&gt;
&lt;li&gt;redirect()&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;4.1  HttpResponse()&lt;/h4&gt;
&lt;p&gt;　　对于HttpRequest对象来说，是由Django自动创建的，但是HttpResponse对象就必须由我们自己创建，每个view请求处理方法必须返回一个HttpRequest对象。&lt;/p&gt;
&lt;p&gt;　　但是需要注意的是，无论是下面的render() 还是 redirect() 最终还是调用HttpResponse，只不过在过程中使用Django的模板语法封装了内容。&lt;/p&gt;
&lt;p&gt;　　我们下面展示一下render()  redirect()的源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190528170158508-1385856504.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201905/1226410-20190528170241355-2133192516.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面直接看着两个响应对象。&lt;/p&gt;
&lt;h4&gt;4.2  render()&lt;/h4&gt;
&lt;p&gt;　　在实际运用中，加载模板，传递参数，返回HttpResponse对象是一整套再长不过的操作了，为了节省力气，Django提供了一个快捷方式：render()函数，一步到位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
render(request, template_name[, context]）
 
结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request： 用于生成相应的请求对象&lt;/li&gt;
&lt;li&gt;template_name：要使用的模板的完整名称，可选的参数&lt;/li&gt;
&lt;li&gt;context：添加到模板上下文的一个字典，默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　总之，render方法就是将一个模板页面中的模板语法进行渲染，最终渲染成一个HTML页面作为响应体。render() 函数第一个位置参数就是请求对象（就是view函数的第一个参数），第二个位置参数是模板，还可以有一个可选择的第三个参数，一个字典，包含需要传递给模板的数据，最后render函数返回一个经过字典数据渲染过的模板封装而成的HttpResponse对象。&lt;/p&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def logout(request):
    # del request.session['is_login']
    request.session.flush()
    return render(request, 'session/a.html')
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.3 redirect()&lt;/h4&gt;
&lt;p&gt; 　　传递要重定向的一个硬编码的URL&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def my_view(request):
    ...
    return redirect('/some/url/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以是一个完整的URL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def my_view(request):
    ...
    return redirect('http://example.com/')　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　key：两次请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1）301和302的区别。

　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码
后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取
  （用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），
搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转
到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301

 

2）重定向原因：
（1）网站调整（如改变网页目录结构）；
（2）网页被移到一个新地址；
（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。
        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问
客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的 网站，
也需要通过重定向让访问这些域名的用户自动跳转到主站点等。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def order(request):
    if not request.user.is_authenticated:
        return redirect('auth/login/')
    return render(request, 'auth/order.html')
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.4  render()和 redirect() 的区别&lt;/h4&gt;
&lt;p&gt;1，if render 的页面需要模板语言渲染，需要的将数据库的数据加载到HTML，那么所有的这一部分除了写在视图函数中，必须还要写在login中，没有解耦。&lt;/p&gt;
&lt;p&gt;2，render()是渲染变量到模板中，而redirect是HTTP中的1个跳转的函数，一般会生成302 状态码。&lt;/p&gt;

&lt;h4&gt;4.5 返回404 错误&lt;/h4&gt;
&lt;p&gt;　　下面我们编写一个具体问卷文本内容的视图，如果访问的话，请求问卷的ID不存在，那么会弹出一个Http404 错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.http import Http404
from django.shortcuts import render
from .models import Question

# ...
def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404(&quot;Question does not exist&quot;)

    return render(request, 'polls/detail.html', {'question': question})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，就像render函数一样，Django同样为我们提供一个偷懒的方式，替代上面的多行代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快捷方式 ： get_object_or_404()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　修改代码入下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.shortcuts import get_object_or_404, render
from .models import Question
# ...

def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': question})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先，get_object_or_404()方法也是需要从Django内置的快捷方式模块中导出。&lt;/p&gt;
&lt;p&gt;　　其次，get_object_or_404()方法将一个Django模型作为第一个位置参数，后面可以跟上任意个数的关键字参数，如果对象不存在则弹出Http404错误。&lt;/p&gt;
&lt;p&gt;　　同样，还有一个 get_list_or_404() 方法，和上面的 get_object_or_404() 类似，只不过用来替代 filter() 函数，当查询列表为空时弹出404错误。&lt;/p&gt;
&lt;h2&gt;ORM中QuerySet API的学习&lt;/h2&gt;
&lt;p&gt;　　Django ORM用到三个类：Manager，QuerySet，Model。&lt;/p&gt;
&lt;p&gt;　　Manager定义表级方法（表级方法就是影响一条或多条记录的方法），我们可以以model.Manager为父类，定义自己的manager，增加表级方法；&lt;/p&gt;
&lt;p&gt;　　QuerySet：Manager类的一些方法会返回QuerySet实例，QuerySet是一个可遍历结构，包含一个或多个元素，每个元素都是一个Model实例，它里面的方法也是表级方法；&lt;/p&gt;
&lt;p&gt;　　Model是指django.db.models模块中的Model类，我们定义表的model时，就是继承它，它的功能很强大，通过自定义model的instance可以获取外键实体等，它的方法都是基类级方法，不要在里面定义类方法，比如计算记录的总数，查看所有记录，这些应该放在自定义的manager类中。&lt;/p&gt;
&lt;h3&gt;1，QuerySet简介&lt;/h3&gt;
&lt;p&gt; 　　每个Model都有一个默认的manager实例，名为objects，QuerySet有两种来源：通过manager的方法得到，通过QuerySet的方法得到。manager的方法和QuerySet的方法大部分同名，同意思，如 filter()，update()等，但是也有些不同，如 manager有 create()，get_or_create()，而QuerySet有delete() 等，看源码就可以很容易的清楚Manager类和QuerySet类的关系，Manager类的绝大部分方法是基于QuerySet的。一个QuerySet包含一个或多个model instance。QuerySet类似于Python中的list，list的一些方法QuerySet也有，比如切片，遍历。&lt;/p&gt;
&lt;h4&gt; 注意：object和QuerySet的区别！！&lt;/h4&gt;
&lt;p&gt;　　QuerySet是查询集，就是传到服务器上的url里面的内容，Django会对查询返回的结果集QuerySet进行缓存，这是为了提高查询效率。也就是说，在创建一个QuerySet对象的时候，Django不会立即向数据库发出查询命令，只有在你需要用到这个QuerySet的时候才会去数据库查询。&lt;/p&gt;
&lt;p&gt;　　object是Django实现的MCV框架中的数据层（model）M，django中的模型类都有一个object对象，他是django中定义的QuerySet类型的对象，他包含了模型对象的实例。&lt;/p&gt;
&lt;p&gt;　　简单来说，object是单个对象，QuerySet是多个对象。&lt;/p&gt;
&lt;h4&gt;1.1 QuerySet 何时被提交&lt;/h4&gt;
&lt;p&gt;　　在内部，创建，过滤，切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。&lt;/p&gt;
&lt;p&gt;　　可以使用下列方法对QuerySet提交查询操作。&lt;/p&gt;
&lt;p&gt;　　QuerySet是可迭代的，在首次迭代查询集中执行的实际数据库查询。例如，下面的语句会将数据库中所有entry的headline打印出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
for e in Entry.objects.all():
    print(e.headline)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;切片&lt;/strong&gt;：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Pickling/缓存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;repr()&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;len()&lt;/strong&gt;：当你对QuerySet调用len()时， 将提交数据库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;list()&lt;/strong&gt;：对QuerySet调用list()将强制提交操作&lt;code&gt;entry_list = list(Entry.objects.all())&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bool()&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　测试布尔值，像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if Entry.objects.filter(headline=&quot;Test&quot;):
   print(&quot;There is at least one Entry with the headline Test&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用exists() 将更加高效。&lt;/p&gt;
&lt;h4&gt;1.2 QuerySet的定义&lt;/h4&gt;
&lt;p&gt;　　下面对QuerySet正式定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class QuerySet(model=None, query=None, using=None)[source]
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;QuerySet类具有两个公有属性用于内省：&lt;/li&gt;
&lt;li&gt;ordered：如果QuerySet是排好序的则为True，否则为False。&lt;/li&gt;
&lt;li&gt;db：如果现在执行，则返回使用的数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3  惰性机制&lt;/h4&gt;
&lt;p&gt;　　所谓惰性机制：Publisher.objects.all() 或者.filter()等都只是返回了一个QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QuerySet特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，可迭代的&lt;/li&gt;
&lt;li&gt;2，可切片&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#objs=models.Book.objects.all()#[obj1,obj2,ob3...]

    #QuerySet:   可迭代

    # for obj in objs:#每一obj就是一个行对象
    #     print(&quot;obj:&quot;,obj)
    # QuerySet:  可切片

    # print(objs[1])
    # print(objs[1:4])
    # print(objs[::-1])
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1.4  QuerySet的高效使用&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;1&amp;gt;Django的queryset是惰性的

     Django的queryset对应于数据库的若干记录（row），通过可选的查询来过滤。

例如，下面的代码会得到数据库中名字为‘Dave’的所有的人:person_set = Person.objects.filter(first_name=&quot;Dave&quot;)上面的代码并没有运行任何的数据库查询。
你可以使用person_set，给它加上一些过滤条件，或者将它传给某个函数，这些操作都不
会发送给数据库。这是对的，因为数据库查询是显著影响web应用性能的因素之一。


&amp;lt;2&amp;gt;要真正从数据库获得数据，你可以遍历queryset或者使用if queryset,总之你用到
数据时就会执行sql.为了验证这些,需要在settings里加入 LOGGING(验证方式)
        obj=models.Book.objects.filter(id=3)
        # for i in obj:
        #     print(i)

        # if obj:
        #     print(&quot;ok&quot;)


&amp;lt;3&amp;gt;queryset是具有cache的
     当你遍历queryset时，所有匹配的记录会从数据库获取，然后转换成Django的model。
这被称为执行（evaluation）.这些model会保存在queryset内置的cache中，这样如果你
再次遍历这个queryset， 你不需要重复运行通用的查询。
        obj=models.Book.objects.filter(id=3)

        # for i in obj:
        #     print(i)
                          ## models.Book.objects.filter(id=3).update(title=&quot;GO&quot;)
                          ## obj_new=models.Book.objects.filter(id=3)
        # for i in obj:
        #     print(i)   #LOGGING只会打印一次


&amp;lt;4&amp;gt; 简单的使用if语句进行判断也会完全执行整个queryset并且把数据放入cache，虽然你并
不需要这些数据！为了避免这个，可以用exists()方法来检查是否有数据：

            obj = Book.objects.filter(id=4)
            #  exists()的检查可以避免数据放入queryset的cache。
            if obj.exists():
                print(&quot;hello world!&quot;)


&amp;lt;5&amp;gt;当queryset非常巨大时，cache会成为问题
   处理成千上万的记录时，将它们一次装入内存是很浪费的。更糟糕的是，巨大的queryset
可能会锁住系统 进程，让你的程序濒临崩溃。要避免在遍历数据的同时产生queryset cache，
可以使用iterator()方法 来获取数据，处理完数据就将其丢弃。
        objs = Book.objects.all().iterator()
        # iterator()可以一次只从数据库获取少量数据，这样可以节省内存
        for obj in objs:
            print(obj.name)
        #BUT,再次遍历没有打印,因为迭代器已经在上一次遍历(next)到最后一次了,没得遍历了
        for obj in objs:
            print(obj.name)

     #当然，使用iterator()方法来防止生成cache，意味着遍历同一个queryset时会重复执行
查询。所以使用iterator()的时候要当心，确保你的代码在操作一个大的queryset时没有重复执行查询


总结:
    queryset的cache是用于减少程序对数据库的查询，在通常的使用下会保证只有在需要的时候
才会查询数据库。使用exists()和iterator()方法可以优化程序对内存的使用。不过，由于它们并
不会生成queryset cache，可能会造成额外的数据库查询。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2，Django中不返回QuerySet的API&lt;/h3&gt;
&lt;p&gt;　　以下的方法不会返回QuerySets，但是作用非常强大，尤其是粗体显示的方法，需要背下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201903/1226410-20190323183134445-873819194.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;716&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;1，get()&lt;/h4&gt;
&lt;p&gt;　　get(**kwargs)&lt;/p&gt;
&lt;p&gt;　　返回按照查询参数匹配到的单个对象，参数的格式应该符合Field lookups的要求。&lt;/p&gt;
&lt;p&gt;　　如果匹配到的对象个数不止一个的话，触发MultipleObjectsReturned异常&lt;/p&gt;
&lt;p&gt;　　如果根据给出的参数匹配不到对象的话，触发DoesNotExist异常。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Entry.objects.get(id='foo') # raises Entry.DoesNotExist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DoesNotExist异常从django.core.exceptions.ObjectDoesNotExist 继承，可以定位多个DoesNotExist异常，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from django.core.exceptions import ObjectDoesNotExist
try:
    e = Entry.objects.get(id=3)
    b = Blog.objects.get(id=1)
except ObjectDoesNotExist:
    print(&quot;Either the entry or blog doesn't exist.&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果希望查询器只返回一行，则可以使用get() 而不使用任何参数来返回该行的对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
entry = Entry.objects.filter(...).exclude(...).get()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2，create()&lt;/h4&gt;
&lt;p&gt;　　create（**kwargs）&lt;/p&gt;
&lt;p&gt; 　　在一步操作中同时创建并且保存对象的便捷方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
p = Person.objects.create(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　等于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
p = Person(first_name=&quot;Bruce&quot;, last_name=&quot;Springsteen&quot;)
p.save(force_insert=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数force_insert表示强制创建对象。如果model中有一个你手动设置的主键，并且这个值已经存在了数据库中，调用create()将会失败，并且触发IntegrityError因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。&lt;/p&gt;
&lt;h4&gt;3，get_or_create()&lt;/h4&gt;
&lt;p&gt; 　　get_or_create(defaults=None, **kwargs)&lt;/p&gt;
&lt;p&gt;　　通过kwargs来查询对象的便捷方法（如果模型中的所有字段都有默认值，可以为空），如果该对象不存在则创建一个新对象。&lt;/p&gt;
&lt;p&gt;　　该方法返回一个由（object，created）组成的元组，元组中的object是一个查询到的或者是被创建的对象，created是一个表示是否创建了新的对象的布尔值。&lt;/p&gt;
&lt;p&gt;　　对于下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果模型的字段数量较大的话，这种模式就变的非常不易使用了。上面的示例可以用get_or_create()重写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
obj, created = Person.objects.get_or_create(
    first_name='John',
    last_name='Lennon',
    defaults={'birthday': date(1940, 10, 9)},
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　任何传递给get_or_create()的关键字参数，除了一个可选的defaults，都将传递给get()调用，如果查到一个对象，返回一个包含匹配到的对象以及False组成的元组。如果查到的对象超过一个以上，将引发MultipleObjectsReturned。如果查找不到对象，get_or_create() 将会实例化并保存一个新的对象，返回一个由新的对象以及True组成的元组。新的对象将会按照以下的逻辑创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
params = {k: v for k, v in kwargs.items() if '__' not in k}
params.update({k: v() if callable(v) else v for k, v in defaults.items()})
obj = self.model(**params)
obj.save()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它表示从非'defaults' 且不包含双下划线的关键字参数开始。然后将defaults的内容添加进来，覆盖必要的键，并使用结果作为关键字参数传递给模型类。&lt;/p&gt;
&lt;p&gt; 　　如果有一个名为defaults_exact 的字段，并且想在 get_or_create() 时用它作为精确查询，只需要使用defaults，像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当你使用手动指定的主键时，get_or_create()方法与create()方法有相似的错误行为。如果需要创建一个对象而该对象的主键早已存在于数据库中，IntergrityError异常将会被触发。&lt;/p&gt;
&lt;p&gt;　　这个方法假设进行的是原子操作，并且正确地配置了数据库和正确的底层数据库行为。如果数据库级别没有对&lt;code&gt;get_or_create&lt;/code&gt;中用到的kwargs强制要求唯一性（unique和unique_together），方法容易导致竞态条件，可能会有相同参数的多行同时插入。（简单理解，kwargs必须指定的是主键或者unique属性的字段才安全。）&lt;/p&gt;
&lt;p&gt;　　最后建议只在Django视图的POST请求中使用get_or_create()，因为这是一个具有修改性质的动作，不应该使用在GET请求中，那样不安全。&lt;/p&gt;
&lt;p&gt;　　可以通过ManyToManyField属性和反向关联使用&lt;code&gt;get_or_create()&lt;/code&gt;。在这种情况下，应该限制查询在关联的上下文内部。 否则，可能导致完整性问题。&lt;/p&gt;
&lt;p&gt;例如下面的模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class Chapter(models.Model):
    title = models.CharField(max_length=255, unique=True)

class Book(models.Model):
    title = models.CharField(max_length=256)
    chapters = models.ManyToManyField(Chapter)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过Book的chapters字段使用get_or_create()，但是它只会获取该Book内部的上下文：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; book = Book.objects.create(title=&quot;Ulysses&quot;)
&amp;gt;&amp;gt;&amp;gt; book.chapters.get_or_create(title=&quot;Telemachus&quot;)
(&amp;lt;Chapter: Telemachus&amp;gt;, True)
&amp;gt;&amp;gt;&amp;gt; book.chapters.get_or_create(title=&quot;Telemachus&quot;)
(&amp;lt;Chapter: Telemachus&amp;gt;, False)
&amp;gt;&amp;gt;&amp;gt; Chapter.objects.create(title=&quot;Chapter 1&quot;)
&amp;lt;Chapter: Chapter 1&amp;gt;
&amp;gt;&amp;gt;&amp;gt; book.chapters.get_or_create(title=&quot;Chapter 1&quot;)
# Raises IntegrityError
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发生这个错误是因为尝试通过Book “Ulysses”获取或者创建“Chapter 1”，但是它不能，因为它与这个book不关联，但因为title 字段是唯一的它仍然不能创建。&lt;/p&gt;
&lt;p&gt;在Django1.11在defaults中增加了对可调用值的支持。&lt;/p&gt;
&lt;h4&gt; 4，update_or_create()&lt;/h4&gt;
&lt;p&gt;　　update_or_create(defaults=None, **kwargs)&lt;/p&gt;
&lt;p&gt; 　　类似于上面的 get_or_create()&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;通过给出的kwargs来更新对象的便捷方法， 如果没找到对象，则创建一个新的对象&lt;/strong&gt;。defaults是一个由 (field, value)对组成的字典，用于更新对象。defaults中的值可以是可调用对象（也就是说函数等）。&lt;/p&gt;
&lt;p&gt;　　该方法返回一个由(object, created)组成的元组,元组中的object是一个创建的或者是被更新的对象， created是一个标示是否创建了新的对象的布尔值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　update_or_create&lt;/code&gt;方法尝试通过给出的kwargs 去从数据库中获取匹配的对象。 如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。&lt;/p&gt;
&lt;p&gt;　　像下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
defaults = {'first_name': 'Bob'}
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
    for key, value in defaults.items():
        setattr(obj, key, value)
    obj.save()
except Person.DoesNotExist:
    new_values = {'first_name': 'John', 'last_name': 'Lennon'}
    new_values.update(defaults)
    obj = Person(**new_values)
    obj.save()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果模型的字段数量较大的话，这种模式就变的非常不易用了。上面的示例可以用update_or_create()重写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
obj, created = Person.objects.update_or_create(
    first_name='John', last_name='Lennon',
    defaults={'first_name': 'Bob'},
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　和&lt;code&gt;get_or_create()&lt;/code&gt;一样，这个方法也容易导致竞态条件，如果数据库层级没有前置唯一性会让多行同时插入。&lt;/p&gt;
&lt;p&gt;在Django1.11在defaults中增加了对可调用值的支持。&lt;/p&gt;
&lt;h4&gt;5，bulk.create()&lt;/h4&gt;
&lt;p&gt;　　 bulk_create(objs , batch_size = None)&lt;/p&gt;
&lt;p&gt;　　以高效的方式（通常只有一个查询，无论有多少对象）将提供的对象列表插入到数据库中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.bulk_create([
...     Entry(headline='This is a test'),
...     Entry(headline='This is only a test'),
... ])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不会调用模型的save()方法，并且不会发送&lt;code&gt;pre_save&lt;/code&gt;和&lt;code&gt;post_save&lt;/code&gt;信号。&lt;/li&gt;
&lt;li&gt;不适用于多表继承场景中的子模型。&lt;/li&gt;
&lt;li&gt;如果模型的主键是AutoField，则不会像save()那样检索并设置主键属性，除非数据库后端支持。&lt;/li&gt;
&lt;li&gt;不适用于多对多关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;batch_size参数控制在单个查询中创建的对象数。&lt;/p&gt;
&lt;h4&gt;6，count()&lt;/h4&gt;
&lt;p&gt;　　count()&lt;/p&gt;
&lt;p&gt;　　返回在数据库中对应的QuerySet对象的个数，count（）永远不会引发异常。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 返回总个数.
Entry.objects.count()
# 返回包含有'Lennon'的对象的总数
Entry.objects.filter(headline__contains='Lennon').count()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;7，in_bulk()&lt;/h4&gt;
&lt;p&gt;　　in_bulk(id_list = None)&lt;/p&gt;
&lt;p&gt;　　获取主键值的列表，并返回将每个主键值映射到具有给定ID的对象的实例的字典。 如果未提供列表，则会返回查询集中的所有对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.in_bulk([1])
{1: &amp;lt;Blog: Beatles Blog&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; Blog.objects.in_bulk([1, 2])
{1: &amp;lt;Blog: Beatles Blog&amp;gt;, 2: &amp;lt;Blog: Cheddar Talk&amp;gt;}
&amp;gt;&amp;gt;&amp;gt; Blog.objects.in_bulk([])
{}
&amp;gt;&amp;gt;&amp;gt; Blog.objects.in_bulk()
{1: &amp;lt;Blog: Beatles Blog&amp;gt;, 2: &amp;lt;Blog: Cheddar Talk&amp;gt;, 3: &amp;lt;Blog: Django Weblog&amp;gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果向in_bulk()传递一个空列表，会得到一个空的字典。&lt;/p&gt;
&lt;p&gt;　　在旧版本中，id_list是必须的参数，现在是一个可选参数。&lt;/p&gt;
&lt;h4&gt;8，iterator()&lt;/h4&gt;
&lt;p&gt;　　iterator()&lt;/p&gt;
&lt;p&gt;　　提交数据库操作，获取QuerySet，并返回一个迭代器。&lt;/p&gt;
&lt;p&gt;Q　　uerySet通常会在内部缓存其结果，以便在重复计算时不会导致额外的查询。而iterator()将直接读取结果，不在QuerySet级别执行任何缓存。对于返回大量只需要访问一次的对象的QuerySet，这可以带来更好的性能，显著减少内存使用。&lt;/p&gt;
&lt;p&gt;　　请注意，在已经提交了的iterator()上使用QuerySet会强制它再次提交数据库操作，进行重复查询。此外，使用iterator()会导致先前的&lt;code&gt;prefetch_related()&lt;/code&gt;调用被忽略，因为这两个一起优化没有意义。&lt;/p&gt;
&lt;h4&gt;9，latest()&lt;/h4&gt;
&lt;p&gt;　　latest(field_name=None)&lt;/p&gt;
&lt;p&gt;　　使用日期字段field_name，按日期返回最新对象。&lt;/p&gt;
&lt;p&gt;　　下例根据Entry的'pub_date'字段返回最新发布的entry：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Entry.objects.latest('pub_date')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果模型的Meta指定了&lt;code&gt;get_latest_by&lt;/code&gt;，则可以将latest()参数留给earliest()或者&lt;code&gt;field_name&lt;/code&gt;。 默认情况下，Django将使用&lt;code&gt;get_latest_by&lt;/code&gt;中指定的字段。&lt;/p&gt;
&lt;p&gt;　　earliest()和latest()可能会返回空日期的实例,可能需要过滤掉空值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Entry.objects.filter(pub_date__isnull=False).latest('pub_date')
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;10，earliest()&lt;/h4&gt;
&lt;p&gt;　　earliest(field_name = None)&lt;/p&gt;
&lt;p&gt;　　类同latest()&lt;/p&gt;
&lt;h4&gt;11，first()&lt;/h4&gt;
&lt;p&gt;　　first()&lt;/p&gt;
&lt;p&gt; 　　返回结果集的第一个对象，当没有找到时候，返回None，如果QuerySet没有设置排序，则将自动按主键进行排序。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
p = Article.objects.order_by('title', 'pub_date').first()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　first()是一个简便方法，下面的例子和上面的代码效果是一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
try:
    p = Article.objects.order_by('title', 'pub_date')[0]
except IndexError:
    p = None
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;12，last()&lt;/h4&gt;
&lt;p&gt;　　last()&lt;/p&gt;
&lt;p&gt;　　工作方式类似于first() ，只是返回的是查询集中最后一个对象。&lt;/p&gt;
&lt;h4&gt;13，aggregate()&lt;/h4&gt;
&lt;p&gt;　　aggregate(*args, **kwargs)&lt;/p&gt;
&lt;p&gt;　　返回汇总值的字典（平均值，总和等）,通过QuerySet进行计算。每个参数指定返回的字典中将要包含的值。&lt;/p&gt;
&lt;p&gt;　　使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation 的名称。 匿名参数的名称将基于聚合函数的名称和模型字段生成。 复杂的聚合不可以使用匿名参数，必须指定一个关键字参数作为别名。&lt;/p&gt;
&lt;p&gt;　　例如，想知道Blog Entry 的数目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.aggregate(Count('entry'))
{'entry__count': 16}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过使用关键字参数来指定聚合函数，可以控制返回的聚合的值的名称：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.aggregate(number_of_entries=Count('entry'))
{'number_of_entries': 16}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　&lt;/h4&gt;
&lt;h4&gt;14，exists()&lt;/h4&gt;
&lt;p&gt;　　exists()&lt;/p&gt;
&lt;p&gt;　　如果QuerySet包含任何结果，则返回True，否则返回False。&lt;/p&gt;
&lt;p&gt;　　查找具有唯一性字段（例如primary_key）的模型是否在一个QuerySet中的最高效的方法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
entry = Entry.objects.get(pk=123)
if some_queryset.filter(pk=entry.pk).exists():
    print(&quot;Entry contained in queryset&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它将比下面的方法快很多，这个方法要求对QuerySet求值并迭代整个QuerySet：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if entry in some_queryset:
   print(&quot;Entry contained in QuerySet&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若要查找一个QuerySet是否包含任何元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if some_queryset.exists():
    print(&quot;There is at least one object in some_queryset&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将快于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
if some_queryset:
    print(&quot;There is at least one object in some_queryset&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;15，update()&lt;/h4&gt;
&lt;p&gt;　　update(**kwargs)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　对指定的字段执行批量更新操作，并返回匹配的行数&lt;/strong&gt;（如果某些行已具有新值，则可能不等于已更新的行数）。&lt;/p&gt;
&lt;p&gt;　　例如，要对2010年发布的所有博客条目启用评论，可以执行以下操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以同时更新多个字段 （没有多少字段的限制）。 例如同时更新comments_on和headline字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　update()方法无需save操作。唯一限制是它只能更新模型主表中的列，而不是关联的模型，例如不能这样做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.update(blog__name='foo') # Won't work!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　仍然可以根据相关字段进行过滤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog__id=1).update(comments_on=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　update()方法返回受影响的行数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(id=64).update(comments_on=True)
1
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(slug='nonexistent-slug').update(comments_on=True)
0
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
132
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果你只是更新一下对象，不需要为对象做别的事情，最有效的方法是调用update()，而不是将模型对象加载到内存中。 例如，不要这样做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
e = Entry.objects.get(id=10)
e.comments_on = False
e.save()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　建议如下操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Entry.objects.filter(id=10).update(comments_on=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用update()还可以防止在加载对象和调用save()之间的短时间内数据库中某些内容可能发生更改的竞争条件。&lt;/p&gt;
&lt;p&gt;　　如果想更新一个具有自定义save()方法的模型的记录，请循环遍历它们并调用save()，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
for e in Entry.objects.filter(pub_date__year=2010):
    e.comments_on = False
    e.save()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;16，delete()&lt;/h4&gt;
&lt;p&gt;　　delete()&lt;/p&gt;
&lt;p&gt;　　批量删除QuerySet中的所有对象，并返回删除的对象个数和每个对象类型的删除次数的字典。&lt;/p&gt;
&lt;p&gt;　　elete()动作是立即执行的。&lt;/p&gt;
&lt;p&gt;　　不能在QuerySet上调用delete()。&lt;/p&gt;
&lt;p&gt;　　例如，要删除特定博客中的所有条目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; b = Blog.objects.get(pk=1)
# Delete all the entries belonging to this Blog.
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(blog=b).delete()
(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　默认情况下，Django的ForeignKey使用SQL约束ON DELETE CASCADE，任何具有指向要删除的对象的外键的对象将与它们一起被删除。 像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; blogs = Blog.objects.all()
# This will delete all Blogs and all of their Entry objects.
&amp;gt;&amp;gt;&amp;gt; blogs.delete()
(5, {'weblog.Blog': 1, 'weblog.Entry': 2, 'weblog.Entry_authors': 2})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种级联的行为可以通过的ForeignKey的on_delete参数自定义。（什么时候要改变这种行为呢？比如日志数据，就不能和它关联的主体一并被删除！）&lt;/p&gt;
&lt;p&gt;delete()会为所有已删除的对象（包括级联删除）发出&lt;code&gt;pre_delete&lt;/code&gt;和&lt;code&gt;post_delete&lt;/code&gt;信号。&lt;/p&gt;
&lt;h4&gt;17，as_manager()&lt;/h4&gt;
&lt;p&gt;　　classmethod as_manager()&lt;/p&gt;
&lt;p&gt;　　一个类方法，返回Manager的实例与QuerySet的方法的副本。&lt;/p&gt;


&lt;h3&gt; &lt;/h3&gt;

&lt;p&gt;详情参考django官方文档：https://django-chinese-docs-14.readthedocs.io/en/latest/ref/models/options.html&lt;/p&gt;
&lt;p&gt; https://www.cnblogs.com/yuanchenqi/articles/8876856.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/feixuelove1009/p/8425054.html&lt;/p&gt;
&lt;p&gt;（这里主要是做了自己的学习笔记，用来记录于此）&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 06:39:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>用户认证组件的学习 用户认证是通过取表单数据根数据库对应表存储的值做比对，比对成功就返回一个页面，不成功就重定向到登录页面。我们自己写的话当然也是可以的，只不过多写了几个视图，冗余代码多，当然我们也可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wj-1314/p/10065929.html</dc:identifier>
</item>
<item>
<title>敏捷大会 II 极致进化-敏捷进化型企业的未来畅想 - Worktile</title>
<link>http://www.cnblogs.com/worktile/p/10949360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/worktile/p/10949360.html</guid>
<description>&lt;center class=&quot;unindent&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/255bbf67-4f47-46a9-b71c-8a035cba0f88&quot; alt=&quot;aa069d6df620192c9e7ce3044c90c596.jpg&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;关志光--国内大型高科技企业教练负责人,敏捷研发提效和教练专家&lt;/p&gt;
&lt;p&gt;我们现在接触的很多所谓的敏捷理念，让很多人认为这只是一个理念而已，但实际上你可以看到国内所有的敏捷流派都有来源，西方国家所有的研究都是基于科学理念的，所以如果我们对敏捷有深入认识，会知道敏捷是一种经过验证、真实有效果的一种实践。&lt;/p&gt;
&lt;p&gt;这里有句话叫“A mind is like a parachute.It doesn’t work if it’s not open.”&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/79a7b579-8e7d-4fc5-bc22-25fee46258d0&quot; alt=&quot;屏幕快照 2019-05-30 上午10.05.14.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;这是美国教育家讲的一句话：每个人的心里就像降落伞，如果不打开是不能工作的。&lt;/p&gt;
&lt;p&gt;我接触敏捷很多年，最后我总结的经验是： 所有敏捷一般都跟日常经验相反 。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;全球敏捷研发历史的回顾与反思&lt;/h3&gt;
&lt;p&gt;很多人都知道2001年发生了一件关于敏捷的事情，美国有几位敏捷大牛在那里探讨了三天三夜，谁都说服不了谁。他们建立了一个网站把敏捷思维发上去了，之所以敏捷今天这么受欢迎，背后就是因为大家非常认可它的价值观和它的原则。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/20938472-340c-40f6-a3bc-55bc2f02b4e0&quot; alt=&quot;屏幕快照 2019-05-30 上午10.11.38.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;我们从这个时间轴来看，敏捷这件事情在1968年 康威定律 发表的那一天这个事情就发芽了。&lt;/p&gt;
&lt;p&gt;1968年Melvin E.Conway发表了《How Do Committees Invent》 ，怎样写组织架构？怎样写代码？最核心的思想就是康威定律。&lt;/p&gt;
&lt;p&gt;1986年哈佛商学院发表了一篇文章《新新产品开发游戏》 ，日本当时有很多领先企业，他们虽然做的是制造业，但他们的流程已经改变了，出现了迭代，这是一篇相当重要的文件。&lt;/p&gt;
&lt;p&gt;1995年发表了Scrum框架。&lt;/p&gt;
&lt;p&gt;1999年Kent Beck写了一本书叫《Extreme Programming Explained: Embrace Change》，他在项目里把经验进行了回顾总结。&lt;/p&gt;
&lt;p&gt;2007年David J·Anderson &amp;amp; Rick Garber 在芝加哥发表《Lean New Product Dev Conference》 ，他提供了一些新的视角，将日本企业的精益思想进行了保留，这是Scrum方法的来源。&lt;/p&gt;
&lt;p&gt;2008年Scrum Gathering Lyssa Adkins在芝加哥发表了Agile Coach ，要打造一个新的工具，仅仅靠流程是不够的，领导力要进行重塑，要用新的方法来引导，这是非常核心的。Agile Coach第一次发表出来，马上引起了很多新的讨论。&lt;/p&gt;
&lt;p&gt;2011年有了产品级别敏捷/规模化敏捷/大规模Scrum/SAFe 。&lt;/p&gt;
&lt;p&gt;2017年很多公司都在讲企业级敏捷/精益企业，重塑组织，还有小规模人在谈青色进化领导力。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/94e87f90-cf41-4cca-a2ce-138f7abeaa4b&quot; alt=&quot;屏幕快照 2019-05-30 上午10.18.55.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;敏捷讲的是要有构建基础理论，与它对应的就是X理论，Y理论则是来自麦克格里格。&lt;/p&gt;
&lt;p&gt;X理论对人的态度是不信任的，Y理论对人的态度是信任并促进人的改善；&lt;br/&gt;X理论对人的假设认为根本上是懒惰的，Y理论对人的假设是需要有所成就愿意承担责任并勤奋工作；&lt;br/&gt;X理论对工作的兴趣是不感兴趣的，Y理论对工作的兴趣是合适的环境下工作与游戏休闲一样有趣；&lt;br/&gt;X理论对努力工作的条件是要靠惩罚的压力或者靠金钱的动力，Y理论努力工作的条件是可与内心的召唤而工作。&lt;/p&gt;
&lt;p&gt;20世纪之前对人类历史影响很大的一本书是泰勒的 《科学管理》 ，他认为 科学管理如同节省劳动的机器一样，其目的在于提高每一单位劳动的产量 。&lt;/p&gt;
&lt;p&gt;我们今天整个环境已经完全改变了， 《驱动力3.0》 讲到三个阶段。&lt;/p&gt;
&lt;p&gt;驱动力1.0 是生物驱动力，强调的是身体需求和心理欲求；&lt;br/&gt;驱动力2.0 是来自外在动机，强调的是环境要求；&lt;br/&gt;驱动力3.0 来自内在动机，强调的是内在维度。更多指的是诸如感情、意义、价值、使命感等，强调自主性。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/db3a0307-053d-4dd7-9046-cd8976ba6999&quot; alt=&quot;屏幕快照 2019-05-30 上午10.23.43.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;最近都说“996.ICU”，驱动力3.0告诉你 自主、专精、目的 ，国内讲的996究竟能不能一直成为真正的驱动力发动机？也许现在这样是没错的，但再往看真的是这样吗？&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/284e09d0-3cf5-41b2-a786-426ff9b6215a&quot; alt=&quot;屏幕快照 2019-05-30 上午10.29.45.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;如果不“996”我们怎么办？&lt;/p&gt;
&lt;p&gt;美国的施德明做的《休假的力量》，25岁年前是学习，25岁到65岁一直在“996”，65岁到80岁基本就在ICU了。&lt;/p&gt;
&lt;p&gt;现在很多人真的变成了这种状态，施德明的方法就是这样的，每工作六年会休息一年，这一年他什么都不干，到处寻找灵感，到处周游世界，然后不断进行学习。有人觉得这样好像风险很大，不工作就没收入，但实际上现在很多人都是在休息的过程中产生了创意灵感，远远超过忙碌日子带来的价值。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/81f56ef2-ff01-4029-a30c-0ebecb7db4d9&quot; alt=&quot;屏幕快照 2019-05-30 上午10.30.36.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;孔子讲 “废寝忘食，乐以忘忧，不知老之将至。” 最近也有裁员的事情，很多人在吐槽，不管是个人还是企业都要居安思危，你的工作必须要具有一定的挑战，但不能太过挑战，太多挑战会很焦虑。如果你太舒服会很无聊，对个人跟企业都是这样的。 寻找有挑战的事情是可以的，但每个人要有自己的选择。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/e3408b41-d20c-4366-8ea0-3fd07b40d060&quot; alt=&quot;屏幕快照 2019-05-30 上午10.32.16.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;h3 id=&quot;-&quot;&gt;当下中国的敏捷研发与暗流涌动。&lt;/h3&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/8da2927d-485a-4545-96d3-d4e628524c03&quot; alt=&quot;屏幕快照 2019-05-30 上午10.35.14.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;Scrum现在基本是业界最流行的方法，所有公司说要做敏捷，首先都要把团队拆分，设置很多的团队，然后把节奏拉起来。《Large-Scale Scrum》中讲到Scrum hits an ideal balance between abstract principles and concrete practices. 一个优秀的方法论要能够让大众广泛接受，拿过来马上就能用，能符合原理而不会太困难。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/782ef702-92dc-4a13-b34b-8292e109d3fc&quot; alt=&quot;屏幕快照 2019-05-30 上午10.38.28.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;在大规模敏捷里，如果你的团队很多，你就要用到LeSS框架。LeSS框架的核心是Build Your Method Up-Don’t Tailor It Down。Scrum给你一个最小的集合，你可以在里面加东西，让你从中进行裁剪，Scrum理论是精简的。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/de9a05a8-a2ec-440c-b7b4-8f2b23cb8779&quot; alt=&quot;屏幕快照 2019-05-30 上午10.40.53.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;有句话叫More with LeSS，在一个组织架构里：&lt;/p&gt;
&lt;p&gt;需要LeSS Roles，不需要More Responsible Teams；&lt;br/&gt;需要的是LeSS Artifacts，不需要More Customer-Focused Teams Building Useful Products；&lt;br/&gt;需要LeSS Process，不需要More Team Ownership of Process &amp;amp; More Meaningful Work。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/7214f12d-737f-4475-9359-1c3e059ef926&quot; alt=&quot;屏幕快照 2019-05-30 上午10.43.14.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;如果你要管理一个比较大的团队，核心一定是只有一个Backlog，而且必须只能有One Dedicated ScrumMaster for 1-3 teams，并且要有One Sprint Backlog per team。这个过程是要看全局的。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/5c8f81ce-8a0d-44eb-ad81-408876c06fc6&quot; alt=&quot;屏幕快照 2019-05-30 上午10.46.30.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;可能很多人学过“自主思考”这门课，他的导向是学习型组织，你一旦进到这个LeSS里，你要学习大量的系统方法，特别是要设立一个新角色时，要找到这个角色里的各种行为，导向是学习型组织。学习型组织就是让你这个人不会处于一样的状态，每一个迭代会做出新的挑战，这个人的角色会被打破。原来你是开发的，但最后开发要做测试，测试也要做开发，需要找很多智慧不断驱动，所以在LeSS的企业里，每个人都不会那么无聊，总有很多需要挑战的东西。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/859e532e-6a50-4f49-9105-55485bac33aa&quot; alt=&quot;屏幕快照 2019-05-30 上午10.52.54.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;据我所知诺基亚现在也在往这个方向来做，企业里的各种事情都要考虑到，包括怎么做预算，怎么招聘，财务制度怎么修改，领导力怎么重塑，团队怎么搭建。在这些框架里一上来SAFe就告诉你角色，要改变工作方式,中国往后这个框架会越来越流行，还可能会涉及到文化变革。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/b04af4ce-e7de-4114-bbb3-46ae68733565&quot; alt=&quot;屏幕快照 2019-05-30 上午10.53.42.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;SAFe的核心是精益价值流，我在企业里开会，很多人问你这个公司搞敏捷，但我原来是财务的，我原来是物流的，我的位置在哪里？很多人很迷惑。&lt;/p&gt;
&lt;p&gt;SAFe就是通过所有的精益价值流，会分析每一个角色在各个价值的交付领域的角色是什么，一个是运营价值流，一个是开发价值流，这两个如果吃透了，你就知道你在整个企业里是什么位置。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;中外敏捷研发文化的对比与突破&lt;/h3&gt;
&lt;p&gt;终极一问：2001年雪鸟聚会，发表敏捷宣言的初心是什么？&quot;Y理论&quot;&lt;/p&gt;
&lt;p&gt;日本的Konosuke Matsushita讲过一段话：&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/75979967-8720-4bc7-ae83-58b637ed5ddf&quot; alt=&quot;屏幕快照 2019-05-30 上午11.05.48.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/8f940b3b-36d3-484d-8852-fc18c3e01595&quot; alt=&quot;屏幕快照 2019-05-30 上午11.06.40.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;现在企业的寿命变得越来越短了，鲍勃迪伦说“要么走向重生，要么走向死亡。”&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/0e8cf20f-27a4-4e2a-98d3-abddf50d7cb1&quot; alt=&quot;屏幕快照 2019-05-30 上午11.10.07.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;这个图是“失控与必然”，往后可能会变得越来越混沌。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/06b39a8e-a572-4c2f-9f42-3a3937d1f01c&quot; alt=&quot;屏幕快照 2019-05-30 上午11.14.23.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;2017年全球人力资源报告指出，全球88%的CEO认为当前他们面临的最大问题是未来组织的问题，未来组织应该怎么办？企业面临劳动力、工作场所以及工作世界的根本性转变。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/2a77ed20-8cad-4ced-ac51-968e6d90c7b6&quot; alt=&quot;屏幕快照 2019-05-30 上午11.15.05.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;《论弥尔顿》提出“研究显示城市规模每扩大一倍，人均创新力或生产力提升15%，然而企业员工的创新力或生产力会随着企业规模的增大而降低。”企业规模扩大，效率降低怎么办？&lt;/p&gt;
&lt;p&gt;未来的组织至少要这样发展：未来组织极大限度通过管理激发人们的“善”、需要信任、身心完整、自律使人自由、组织是无边界的、动态的。&lt;/p&gt;
&lt;p&gt;未来企业的每一个人可能都是自主管理、身心完善、进化宗旨/使命驱动的。很多企业的执行力不够，怎么办？&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/ba7876c8-0a9c-4459-939c-8585dd2f9c42&quot; alt=&quot;屏幕快照 2019-05-30 上午11.18.51.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;怎样构建组织？怎样让每个人具有使命感？目前全球最高效的一种组织架构叫做合弄制，通过张力的驱动构建高效极简的团队。我们在企业里如果要改变组织架构，一般都是高层、CEO、董事会来决定，而现在如果改企业的组织架构，只需要通过简单的会议，在一天之内就可以把组织架构改了。现在全球至少有1500家这样的企业，这种企业跟我们当下看到的组织是完全不一样的，它是一种新的企业形态。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/bc4c92d7-d370-4a72-9a88-c77c92bf859d&quot; alt=&quot;屏幕快照 2019-05-30 上午11.19.18.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;在这种组织里，每一个人都具有强大的使命感。在非常进化的企业里，将这模型利用到每一个人的身上，通过强有力的组织架构来保障，每一个员工都可以改组织架构，通过会议形式，每个人非常清晰自己的职责。至少我们知道未来的方向大概是这样的，现在在欧洲、硅谷有很多公司在实行这种新的企业架构。&lt;/p&gt;

&lt;p&gt;文章来源：&lt;a href=&quot;https://worktile.com/blog/scrum?utm_source=cnblogs&amp;amp;utm_medium=meiyang&quot; target=&quot;_blank&quot;&gt;Worktile敏捷博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎访问交流更多关于技术及协作的问题。&lt;/p&gt;
&lt;p&gt;文章转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Thu, 30 May 2019 06:32:00 +0000</pubDate>
<dc:creator>Worktile</dc:creator>
<og:description>关志光--国内大型高科技企业教练负责人,敏捷研发提效和教练专家 我们现在接触的很多所谓的敏捷理念，让很多人认为这只是一个理念而已，但实际上你可以看到国内所有的敏捷流派都有来源，西方国家所有的研究都是基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/worktile/p/10949360.html</dc:identifier>
</item>
<item>
<title>Spark-2.4.0源码：sparkContext - syui</title>
<link>http://www.cnblogs.com/cnblogs-syui/p/10948471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnblogs-syui/p/10948471.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在看sparkContext之前，先回顾一下Scala的语法。Scala构造函数分主构造和辅构造函数，辅构造函数是关键字def+this定义的，而类中不在方法体也不在辅构造函数中的代码就是主构造函数，实例化对象的时候主构造函数都会被执行，例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; person(name String,age Int){
    println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主构造函数被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    def &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(name String,age Int){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;辅构造函数&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt; ()    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须先调用主构造函数&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age
    }
    
    def introduce(){
        println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;-&lt;/span&gt;&lt;span&gt;age :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; age)
    }
}

&lt;/span&gt;&lt;span&gt;val jack = new&lt;/span&gt; person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;)&lt;p&gt;jack.introduce()
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　主构造函数被调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name  :jack-age :2&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　切入正题，看sparkContext的主构造函数比较重要的一些代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create the Spark execution environment (cache, map output tracker, etc)&lt;/span&gt;
        _env =&lt;span&gt; createSparkEnv(_conf, isLocal, listenerBus)
        SparkEnv.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(_env)
        
        ...
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to register &quot;HeartbeatReceiver&quot; before &quot;createTaskScheduler&quot; because Executor will
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retrieve &quot;HeartbeatReceiver&quot; in the constructor. (SPARK-6640)&lt;/span&gt;
        _heartbeatReceiver =&lt;span&gt; env.rpcEnv.setupEndpoint(
        HeartbeatReceiver.ENDPOINT_NAME, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HeartbeatReceiver(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;))

        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create and start the scheduler&lt;/span&gt;
        val (sched, ts) = SparkContext.createTaskScheduler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, master, deployMode)
        _schedulerBackend &lt;/span&gt;=&lt;span&gt; sched
        _taskScheduler &lt;/span&gt;=&lt;span&gt; ts
        _dagScheduler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DAGScheduler(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
        _heartbeatReceiver.ask[Boolean](TaskSchedulerIsSet)
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start TaskScheduler after taskScheduler sets DAGScheduler reference in DAGScheduler's
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constructor&lt;/span&gt;
&lt;span&gt;        _taskScheduler.start()
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先：&lt;/p&gt;
&lt;pre&gt;
　　 _env =&lt;span&gt; createSparkEnv(_conf, isLocal, listenerBus)
    SparkEnv.set&lt;span&gt;(_env)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　 _heartbeatReceiver =&lt;span&gt; env.rpcEnv.setupEndpoint(
    HeartbeatReceiver.ENDPOINT_NAME, new HeartbeatReceiver(this&lt;span&gt;))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 　　这里是在sparkContext中创建rpcEnv，并通过 setupEndpoint 向 rpcEnv 注册一个心跳的 Endpoint。&lt;/p&gt;
&lt;p&gt;　　接着：&lt;/p&gt;
&lt;pre&gt;
 val (sched, ts) = SparkContext.createTaskScheduler(this&lt;span&gt;, master, deployMode)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　调的sparkContext自己的方法，创建taskScheduler，返回的是一个 (SchedulerBackend, TaskScheduler) 元组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; def createTaskScheduler(
      sc: SparkContext,
      master: String,
      deployMode: String): (SchedulerBackend, TaskScheduler) &lt;/span&gt;=&lt;span&gt; {
    import SparkMasterRegex._

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; When running locally, don't try to re-execute tasks on failure.&lt;/span&gt;
    val MAX_LOCAL_TASK_FAILURES = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    master match {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;standalone的提交模式&lt;/span&gt;
      &lt;span&gt;case&lt;/span&gt; SPARK_REGEX(sparkUrl) =&amp;gt;&lt;span&gt;
        val scheduler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskSchedulerImpl(sc)
        val masterUrls &lt;/span&gt;= sparkUrl.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; _)
        val backend &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandaloneSchedulerBackend(scheduler, sc, masterUrls)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用初始化方法&lt;/span&gt;
&lt;span&gt;&lt;span&gt;        scheduler.initialize(backend)&lt;/span&gt;
        (backend, scheduler)
    }
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方法内部根据master参数判断不同的提交模式，创建不同的(SchedulerBackend, TaskScheduler) ，拿standalon模式举例，根据入参创建TaskSchedulerImpl和StandalonSchedulerBackend，再调用TaskSchedulerImpl的初始化方法，最后返回一个元组。&lt;/p&gt;
&lt;p&gt;　　 scheduler.initialize(backend)，其实就是根据不同的schedulingMode创建不同的schedulableBuilder，它就是对Scheduleable tree的封装,负责对taskSet的调度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def initialize(backend: SchedulerBackend) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.backend =&lt;span&gt; backend&lt;/span&gt;
    schedulableBuilder =&lt;span&gt; {
      schedulingMode match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; SchedulingMode.FIFO =&amp;gt;
          &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FIFOSchedulableBuilder(rootPool)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; SchedulingMode.FAIR =&amp;gt;
          &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FairSchedulableBuilder(rootPool, conf)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt;
          &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unsupported $SCHEDULER_MODE_PROPERTY: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
          s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$schedulingMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      }
    }
    schedulableBuilder.buildPools()
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着下面两行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　_dagScheduler = new DAGScheduler(this&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　创建DAG有向无环图，实现类面向stage的调度机制的高层次调度层，他会为每个stage计算DAG(有向无环图)，追踪RDD和stage的输出是否被物化(写入磁盘或内存)，并且寻找一个最少消耗的调度机制来运行job。它会将stage作为taskSets提交到底层的TaskSchedulerImpl上来在集群运行。除了处理stage的DAG，它还负责决定运行每个task的最佳位置，基于当前的缓存状态，将最佳位置提交给底层的TaskSchedulerImpl，此外，他会处理由于每个shuffle输出文件导致的失败，在这种情况下旧的stage可能会被重新提交。一个stage内部的失败，如果不是由于shuffle文件丢失导致的失败，会被taskScheduler处理，它会多次重试每个task，还不行才会取消整个stage。&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;  _heartbeatReceiver.ask[Boolean](TaskSchedulerIsSet)&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt; 　　在上面创建好了TaskScheduler和SchedulerBackend后，告诉 HeartbeatReceiver（心跳） 的监听端。&lt;/p&gt;
&lt;p&gt; 　　最后：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　_taskScheduler.start()&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; 　　在TaskSchedulerImpl的start()方法中调的是SchedulerBackend的start()方法，所以start()方法运行的是这段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;override&lt;/span&gt;&lt;span&gt; def start() {
    super.start()

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SPARK-21159. The scheduler backend should only try to connect to the launcher when in client
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mode. In cluster mode, the code that submits the application to the Master needs to connect
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to the launcher instead.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (sc.deployMode == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
      launcherBackend.connect()
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数设置&lt;/span&gt;
&lt;span&gt;    
    val appDesc &lt;/span&gt;=&lt;span&gt; ApplicationDescription(sc.appName, maxCores, sc.executorMemory, command,
      webUrl, sc.eventLogDir, sc.eventLogCodec, coresPerExecutor, initialExecutorLimit)
    client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StandaloneAppClient(sc.env.rpcEnv, masters, appDesc, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, conf)
    client.start()
    launcherBackend.setState(SparkAppHandle.State.SUBMITTED)
    waitForRegistration()
    launcherBackend.setState(SparkAppHandle.State.RUNNING)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里创建了两个对象：AppliactionDescription和AppClient，AppliactionDescription顾名思义就是对Application的描述类，比如它需要的资源等；AppClient负责负责为application与spark集群通信。SchedulerBackend的start()最终调用了AppClient的start()，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def start() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just launch an rpcEndpoint; it will call back into the listener.&lt;/span&gt;
    endpoint.&lt;span&gt;set&lt;/span&gt;(rpcEnv.setupEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientEndpoint(rpcEnv)))
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　启动一个rpcEndPoint并回调给监听器，RPC原理可看这篇 &lt;a href=&quot;https://www.cnblogs.com/superhedantou/p/7570692.html&quot;&gt;https://www.cnblogs.com/superhedantou/p/7570692.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; 　　最后画个大概流程图&lt;img src=&quot;https://img2018.cnblogs.com/blog/1510907/201905/1510907-20190530142437427-488677510.png&quot; alt=&quot;&quot; width=&quot;895&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 30 May 2019 06:27:00 +0000</pubDate>
<dc:creator>syui</dc:creator>
<og:description>在看sparkContext之前，先回顾一下Scala的语法。Scala构造函数分主构造和辅构造函数，辅构造函数是关键字def+this定义的，而类中不在方法体也不在辅构造函数中的代码就是主构造函数，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnblogs-syui/p/10948471.html</dc:identifier>
</item>
</channel>
</rss>