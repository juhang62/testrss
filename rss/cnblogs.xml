<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Angular学习资料大全和常用语法汇总（让后端程序员轻松上手） - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/14315774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/14315774.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　首先为什么要写这样的一篇文章呢？主要是因为前段时间写过一些关于Angualr的相关实战文章，有些爱学习的小伙伴对这方面比较感兴趣，但是又不知道该怎么入手（因为认识我的大多数小伙伴都是后端的同学），所以今天准备出一篇Angular学习资料汇总和日常开发中使用比较频繁的语法总结。让更多的后端程序员更好的了解学习Angualr，拓展自己的技术栈。&lt;/p&gt;
&lt;h2&gt;Angular简介：&lt;/h2&gt;
&lt;p&gt;　　Angular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用。&lt;/p&gt;
&lt;h2&gt;学习资料推荐：&lt;/h2&gt;
&lt;h3&gt;Angular-GitHub仓库地址：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular&quot; target=&quot;_blank&quot;&gt;https://github.com/angular/angular&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Angualr官方文档教程（推荐）：&lt;/h3&gt;
&lt;p&gt;　　对于我们而言无论是学习什么技术，首先一点不要忽视了官网的重要性，而且Angular官网还有中文版的相对而言更容易上手。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://angular.cn/docs&quot; target=&quot;_blank&quot;&gt;https://angular.cn/docs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;AngularJS 文档教程 | 菜鸟教程：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/angularjs-tutorial.html%20&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/angularjs/angularjs-tutorial.html &lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;AngularJS 文档教程 | W3Cschool：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/angularjs/&quot; target=&quot;_blank&quot;&gt;https://www.w3cschool.cn/angularjs/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;Angular入门，开发环境搭建，使用Angular CLI创建你的第一个Angular项目：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/14166192.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/14166192.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;0.084337349397591&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wendellhu95/blog/issues/10&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;js-issue-title&quot;&gt;https://github.com/wendellhu95/blog/issues/10&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36385830&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;js-issue-title&quot;&gt;https://zhuanlan.zhihu.com/p/36385830&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;video-title&quot; title=&quot;Angular教程_Angular8 Angular9入门实战视频教程-2020年更新【IT营】&quot;&gt;&lt;span class=&quot;tit&quot;&gt;Angular教程_Angular8 Angular9入门实战视频教程（推荐）：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;tit&quot;&gt;对于一些初学者而言，假如不知道该怎么做的话最好推荐先看看视频，熟悉一下Angualr的开发的基本流程。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1bt411e71b?from=search&amp;amp;seid=14846265447217622438&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;tit&quot;&gt;https://www.bilibili.com/video/BV1bt411e71b?from=search&amp;amp;seid=14846265447217622438&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;AngularJS视频教程_免费AngularJS教程在线学习-php中文网课程：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.php.cn/course/list/20.html&quot; target=&quot;_blank&quot;&gt;https://www.php.cn/course/list/20.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 class=&quot;video-title&quot; title=&quot;2020最新Angular实战教程&quot;&gt;&lt;span class=&quot;tit&quot;&gt;Angular实战教程视频：&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1i741157Fj?from=search&amp;amp;seid=14846265447217622438&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;tit&quot;&gt;https://www.bilibili.com/video/BV1i741157Fj?from=search&amp;amp;seid=14846265447217622438&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Angular常用语法：&lt;/h2&gt;
&lt;h4&gt;1、事件绑定  （）:&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;button (click) = &quot;share()&quot;&amp;gt; share &amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;2、click&lt;/strong&gt; 点击事件：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;button (click) = &quot;share()&quot;&amp;gt; share &amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;3、ng-hide/&lt;/strong&gt;ng-show设置应用部分是否可见：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;p ng-hide=&quot;true&quot;&amp;gt; //隐藏
&amp;lt;p ng-hide=&quot;false&quot;&amp;gt;//显示
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4、ngModelChange选择改变事件：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
=============Html=============
 &amp;lt;div class=&quot;set-select&quot;&amp;gt;
    &amp;lt;label for=&quot;rankbutton&quot;&amp;gt;选择平台&amp;lt;/label&amp;gt;
    &amp;lt;select id=&quot;rankbutton&quot; [(ngModel)]=&quot;platform&quot; (ngModelChange)=&quot;set_platform()&quot;&amp;gt; 
    &amp;lt;select id=&quot;rankbutton&quot; [(ngModel)]=&quot;platform&quot;&amp;gt;
      &amp;lt;option *ngFor=&quot;let item of platforms&quot; [value]='item.key'&amp;gt;{{item.value}}&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
  &amp;lt;/div&amp;gt;

============Ts================
platform = 'wx';
platforms: any = [
    { key: 'wx', value: '微信' },
    { key: 'tt', value: '百度' },
    { key: 'wb', value: '微博' },
    { key: 'bjh', value: '抖音' },
    { key: 'zcool', value: '淘宝' },
  ];
  
set_platform() {
     this.platform
     console.log('this.platform:',this.platform)
   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;_1RuRku&quot;&gt;5、input事件在用户输入时触发：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;input placeholder=&quot;input here&quot; (input)=&quot;onInput($event)&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6、属性绑定   [ ]  语法：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 &amp;lt;a [title]=&quot;product.name+'描述'&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;code&gt;7、[(ngModel)]&lt;/code&gt; ：双向绑定：&lt;/h4&gt;
&lt;p&gt;NgModel 指令允许你显示数据属性并在用户进行更改时更新该属性。这是一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
src/app/app.component.html (NgModel example)
content_copy
&amp;lt;input [(ngModel)]=&quot;currentItem.name&quot; id=&quot;example-ngModel&quot; name='currentName'&amp;gt; //注意某些情况下需要加name表示唯一标识，不加的话可能会报错
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入 FormsModule 以使用 ngModel&lt;br/&gt;要想在双向数据绑定中使用 ngModel 指令，必须先导入 FormsModule 并将其添加到 NgModule 的 imports 列表中。要了解关于 FormsModule 和 ngModel 的更多信息，参阅表单一章。&lt;/p&gt;
&lt;p&gt;记住，要导入 FormsModule 才能让 [(ngModel)] 可用，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
src/app/app.module.ts (FormsModule import)
content_copy
import { FormsModule } from '@angular/forms'; // &amp;lt;--- JavaScript import from Angular
/* . . . */
@NgModule({
/* . . . */

imports: [
BrowserModule,
FormsModule // &amp;lt;--- import into the NgModule
],
/* . . . */
})
export class AppModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://angular.cn/guide/built-in-directives#ngModel&quot; target=&quot;_blank&quot;&gt;https://angular.cn/guide/built-in-directives#ngModel&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;interpolation-&quot;&gt;8、插值语法 &lt;code&gt;{{...}}：&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;花括号之间的文本通常是组件属性的名字。Angular 会把这个名字替换为响应组件属性的字符串值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;p&amp;gt;{{title}}&amp;lt;/p&amp;gt;
&amp;lt;div&amp;gt;&amp;lt;img src=&quot;{{itemImageUrl}}&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;9、Angular使用[InnerHtml]中正常显示富文本内容：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;text&quot; [innerHTML]=&quot;richText&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/a1056244734/article/details/106802008&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/a1056244734/article/details/106802008&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;10、Angular ngFor循环的使用:&lt;/h4&gt;
&lt;p&gt;属性index、count、first、last、even、odd&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index属性提供当前对象的索引&lt;/li&gt;
&lt;li&gt;count提供当前数据集的长度，类似于datasource.length&lt;/li&gt;
&lt;li&gt;first返回当前列表项是否为第一个&lt;/li&gt;
&lt;li&gt;last返回当前列表项是否为最后一个&lt;/li&gt;
&lt;li&gt;even返回当前列表项index是否为偶数，通常用在增加样式用来区分行与行之间&lt;/li&gt;
&lt;li&gt;odd返回当前列表项index是否为奇数&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;ul&amp;gt;
&amp;lt;li *ngFor=&quot;let item of datasource; let o=odd,let e=even&quot; [ngClass]=&quot;{odd-action: o,even-action: e}&quot;&amp;gt;
&amp;lt;card-item [item]=&quot;item&quot;&amp;gt;&amp;lt;/card-item&amp;gt;
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a35dc3e283cd&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/a35dc3e283cd&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;11、AngularJS &lt;code&gt;ng-repeat&lt;/code&gt; 循环使用：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;h1 ng-repeat=&quot;x in records&quot;&amp;gt;{{x}}&amp;lt;/h1&amp;gt;

&amp;lt;script&amp;gt;
var app = angular.module(&quot;myApp&quot;, []);
app.controller(&quot;myCtrl&quot;, function($scope) {
  $scope.records = [
    &quot;菜鸟教程1&quot;,
    &quot;菜鸟教程2&quot;,
    &quot;菜鸟教程3&quot;,
    &quot;菜鸟教程4&quot;,
  ]
});
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Angular ng-if判断使用：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
//在angular中没有else只能都通过ng-if来判断
&amp;lt;p ng-if=&quot;OwnStatus==0&quot;&amp;gt;准备中&amp;lt;/p&amp;gt;
&amp;lt;p ng-if=&quot;OwnStatus==1&quot;&amp;gt;进行中&amp;lt;/p&amp;gt;
&amp;lt;p ng-if=&quot;OwnStatus==2&quot;&amp;gt;已经完成&amp;lt;/p&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;AngularJS 指令大全：&lt;/h4&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;43.27579519007&quot;&gt;&lt;tr&gt;&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-app.html&quot;&gt;ng-app&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定义应用程序的根元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7021276595745&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-bind.html&quot;&gt;ng-bind&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;绑定 HTML 元素到应用程序数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7777777777778&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-bind-html.html&quot;&gt;ng-bind-html&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;绑定 HTML 元素的 innerHTML 到应用程序数据，并移除 HTML 字符串中危险字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4576271186441&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-bind-template.html&quot;&gt;ng-bind-template&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定要使用模板替换的文本内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-blur.html&quot;&gt;ng-blur&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定 blur 事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6727272727273&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-change.html&quot;&gt;ng-change&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定在内容改变时要执行的表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4736842105263&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-checked.html&quot;&gt;ng-checked&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定元素是否被选中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6363636363636&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-class.html&quot;&gt;ng-class&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定 HTML 元素使用的 CSS 类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5593220338983&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-class-even.html&quot;&gt;ng-class-even&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;类似 ng-class，但只在偶数行起作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5862068965517&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-class-odd.html&quot;&gt;ng-class-odd&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;类似 ng-class，但只在奇数行起作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6190476190476&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-click.html&quot;&gt;ng-click&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定义元素被点击时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6666666666667&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-cloak.html&quot;&gt;ng-cloak&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在应用正要加载时防止其闪烁&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4090909090909&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-controller.html&quot;&gt;ng-controller&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定义应用的控制器对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-copy.html&quot;&gt;ng-copy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定拷贝事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6470588235294&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-csp.html&quot;&gt;ng-csp&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;修改内容的安全策略&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6470588235294&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-cut.html&quot;&gt;ng-cut&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定剪切事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4358974358974&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-dblclick.html&quot;&gt;ng-dblclick&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定双击事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5111111111111&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-disabled.html&quot;&gt;ng-disabled&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定一个元素是否被禁用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5555555555556&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-focus.html&quot;&gt;ng-focus&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定聚焦事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ng-form&lt;/td&gt;
&lt;td&gt;指定 HTML 表单继承控制器表单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-hide.html&quot;&gt;ng-hide&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;隐藏或显示 HTML 元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6315789473684&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-href.html&quot;&gt;ng-href&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;为 the &amp;lt;a&amp;gt; 元素指定链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7826086956522&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-if.html&quot;&gt;ng-if&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;如果条件为 false 移除 HTML 元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5121951219512&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-include.html&quot;&gt;ng-include&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在应用中包含 HTML 文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-init.html&quot;&gt;ng-init&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定义应用的初始化值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ng-jq&lt;/td&gt;
&lt;td&gt;定义应用必须使用到的库，如：jQuery&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5454545454545&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-keydown.html&quot;&gt;ng-keydown&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定按下按键事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5111111111111&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-keypress.html&quot;&gt;ng-keypress&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定按下按键事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6190476190476&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-keyup.html&quot;&gt;ng-keyup&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定松开按键事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6585365853659&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-list.html&quot;&gt;ng-list&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;将文本转换为列表 (数组)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6862745098039&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-model.html&quot;&gt;ng-model&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;绑定 HTML 控制器的值到应用数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-model-options.html&quot;&gt;ng-model-options&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定如何更新模型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5102040816327&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mousedown.html&quot;&gt;ng-mousedown&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定按下鼠标按键时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5357142857143&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mouseenter.html&quot;&gt;ng-mouseenter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定鼠标指针穿过元素时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5357142857143&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mouseleave.html&quot;&gt;ng-mouseleave&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定鼠标指针离开元素时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6571428571429&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mousemove.html&quot;&gt;ng-mousemove&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定鼠标指针在指定的元素中移动时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6065573770492&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mouseover.html&quot;&gt;ng-mouseover&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定鼠标指针位于元素上方时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6774193548387&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-mouseup.html&quot;&gt;ng-mouseup&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定当在元素上松开鼠标按钮时的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4827586206897&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-non-bindable.html&quot;&gt;ng-non-bindable&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定元素或子元素不能绑定数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-open.html&quot;&gt;ng-open&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定元素的 open 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5918367346939&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-options.html&quot;&gt;ng-options&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在 &amp;lt;select&amp;gt; 列表中指定 &amp;lt;options&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5555555555556&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-paste.html&quot;&gt;ng-paste&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定粘贴事件的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ng-pluralize&lt;/td&gt;
&lt;td&gt;根据本地化规则显示信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4883720930233&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-readonly.html&quot;&gt;ng-readonly&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定元素的 readonly 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6086956521739&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-repeat.html&quot;&gt;ng-repeat&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;定义集合中每项数据的模板&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4883720930233&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-selected.html&quot;&gt;ng-selected&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定元素的 selected 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-show.html&quot;&gt;ng-show&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;显示或隐藏 HTML 元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-src.html&quot;&gt;ng-src&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定 &amp;lt;img&amp;gt; 元素的 src 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6086956521739&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-srcset.html&quot;&gt;ng-srcset&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定 &amp;lt;img&amp;gt; 元素的 srcset 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5675675675676&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-style.html&quot;&gt;ng-style&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;指定元素的 style 属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6949152542373&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-submit.html&quot;&gt;ng-submit&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定 onsubmit 事件发生时执行的表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6326530612245&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-switch.html&quot;&gt;ng-switch&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定显示或隐藏子元素的条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ng-transclude&lt;/td&gt;
&lt;td&gt;规定填充的目标位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5294117647059&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/ng-ng-value.html&quot;&gt;ng-value&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;规定 input 元素的值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/angularjs/angularjs-reference.html&quot; target=&quot;_blank&quot;&gt;https://www.runoob.com/angularjs/angularjs-reference.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;


</description>
<pubDate>Fri, 22 Jan 2021 16:41:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 首先为什么要写这样的一篇文章呢？主要是因为前段时间写过一些关于Angualr的相关实战文章，有些爱学习的小伙伴对这方面比较感兴趣，但是又不知道该怎么入手（因为认识我的大多数小伙伴都是后端的同学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/14315774.html</dc:identifier>
</item>
<item>
<title>.NET 项目中的单元测试 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14316093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14316093.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;“不会写单元测试的程序员不是合格的程序员，不写单元测试的程序员不是优秀的工程师。”&lt;/p&gt;
&lt;p&gt;—— 一只想要成为一个优秀程序员的渣逼程序猿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题来了，什么是单元测试，如何做单元测试。&lt;/p&gt;
&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;h3 id=&quot;单元测试的定义&quot;&gt;单元测试的定义&lt;/h3&gt;
&lt;p&gt;按照维基百科上的说法，单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。在面向对象编程中，最小单元就是方法，包括基类、抽象类、或者派生类（子类）中的方法。 按照通俗的理解，一个单元测试判断某个特定场条件下某个特定方法的行为，如斐波那契数列算法，冒泡排序算法。&lt;/p&gt;
&lt;blockquote readability=&quot;9.3987341772152&quot;&gt;
&lt;p&gt;单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。 对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义， 如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。 总的来说，单元就是人为规定的最小的被测功能模块。 单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。&lt;/p&gt;
&lt;p&gt;—— 百度百科 &lt;a href=&quot;http://baike.baidu.com/view/106237.htm&quot; target=&quot;_blank&quot;&gt;http://baike.baidu.com/view/106237.htm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单元测试的好处&quot;&gt;单元测试的好处&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;6.5834932821497&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它是一种验证行为&lt;/p&gt;
&lt;p&gt;程序中的每一项功能都是测试来验证它的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;它是一种设计行为&lt;/p&gt;
&lt;p&gt;编写单元测试将使我们从调用者观察、思考。 特别是先写测试（test-first），迫使我们把程序设计成易于调用和可测试的，有利于程序的解耦和模块化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;它是一种编写文档的行为&lt;/p&gt;
&lt;p&gt;单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;它具有回归性&lt;/p&gt;
&lt;p&gt;自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.4959349593496&quot;&gt;
&lt;p&gt;高效&lt;/p&gt;
&lt;p&gt;自动化的单元测试节省了开发上调试BUG的时间，绝大多数BUG可以通过单元测试测试出来，并且可以减少测试人员的测试时间。有时候通过写单元测试能够更好的完善自己程序的逻辑，让程序变得更加美好。&lt;/p&gt;
&lt;p&gt;—— 单元测试的优点 &lt;a href=&quot;http://jingyan.baidu.com/article/d713063522ab4e13fdf47533.html&quot; target=&quot;_blank&quot;&gt;http://jingyan.baidu.com/article/d713063522ab4e13fdf47533.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;单元测试的原则&quot;&gt;单元测试的原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;可重复运行的&lt;/li&gt;
&lt;li&gt;持续长期有效，并且返回一致的结果&lt;/li&gt;
&lt;li&gt;在内存中运行，没有外部依赖组件（比如说真实的数据库，真实的文件存储等）&lt;/li&gt;
&lt;li&gt;快速返回结果&lt;/li&gt;
&lt;li&gt;一个测试方法只测试一个问题&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;net-中的测试框架&quot;&gt;.NET 中的测试框架&lt;/h2&gt;
&lt;p&gt;现在比较流行的测试框架包括微软的 MS Test(VS Test)、NUnit、XUnit&lt;/p&gt;
&lt;h3 id=&quot;ms-test&quot;&gt;MS Test&lt;/h3&gt;
&lt;p&gt;VS单元测试的主要类：Assert、StringAssert、CollectionAssert，具体可参照 &lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/Microsoft.VisualStudio.TestTools.UnitTesting.aspx&quot; target=&quot;_blank&quot;&gt;MSDN&lt;/a&gt;介绍&lt;/p&gt;
&lt;p&gt;有些时候我们需要对测试的方法用到的数据或配置进行初始化，有几个特殊的测试方法。&lt;/p&gt;
&lt;p&gt;如果需要针对测试中的所有虚拟用户迭代仅执行一次初始化操作，请使用 &lt;code&gt;TestInitializeAttribute&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;初始化方法的运行顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用 &lt;code&gt;AssemblyInitializeAttribute&lt;/code&gt; 标记的方法。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;ClassInitializeAttribute&lt;/code&gt; 特性标记的方法。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;TestInitializeAttribute&lt;/code&gt; 特性标记的方法。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;TestMethodAttribute&lt;/code&gt; 特性标记的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用 VS Test 的时候，首先我们需要标记测试方法所在类 &lt;code&gt;TestClass&lt;/code&gt;，测试方法标记为 &lt;code&gt;TestMethod&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;nunit&quot;&gt;NUnit&lt;/h3&gt;
&lt;p&gt;NUnit 测试框架使用方法与 MS Test 类似&lt;/p&gt;
&lt;p&gt;有一些是 NUnit 中的，但是MS Test框架中是没有的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Assert.IsNaN&lt;/code&gt;/&lt;code&gt;Assert.IsEmpty&lt;/code&gt;/&lt;code&gt;Assert.IsNotEmpty&lt;/code&gt;/&lt;code&gt;Assert.Greater&lt;/code&gt;/&lt;code&gt;Assert.GreaterOrEqual&lt;/code&gt; 等&lt;/p&gt;
&lt;p&gt;想要同时使用 VS Test 和 NUnit 的话可以使用宏来区分不同的测试框架，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;#if !NUNIT
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Category = Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute;
#else
using NUnit.Framework;
using TestClass = NUnit.Framework.TestFixtureAttribute;
using TestMethod = NUnit.Framework.TestAttribute;
using TestInitialize = NUnit.Framework.SetUpAttribute;
using TestCleanup = NUnit.Framework.TearDownAttribute;
using TestContext = System.Object;
using ClassCleanup = NUnit.Framework.TestFixtureTearDownAttribute;
using ClassInitialize = NUnit.Framework.TestFixtureSetUpAttribute;
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看得出来 nunit 很多东西和 vs test 是很类似的，声明测试类，测试方法，初始化方法等&lt;/p&gt;
&lt;h3 id=&quot;xunit&quot;&gt;XUnit&lt;/h3&gt;
&lt;p&gt;XUnit 是另一个测试框架，个人觉得 XUnit 测试更加简洁一些，初始化和释放资源不需要标记单独的方法，初始化直接放在构造方法里，资源释放实现 &lt;code&gt;IDisposable&lt;/code&gt; 接口，在 &lt;code&gt;Dispose&lt;/code&gt; 方法中进行测试的清理工作即可，相比 ms test（vs test）和 NUnit，我觉得 Xunit 更方便一些，并且对于 &lt;code&gt;Assert&lt;/code&gt; ，xunit 更简洁，例如： 在 ms test 中的 &lt;code&gt;Assert.IsNull(null);&lt;/code&gt;/&lt;code&gt;Assert.IsTrue(1 == 1);&lt;/code&gt; 在 xunit 中则是 &lt;code&gt;Assert.Null(null);&lt;/code&gt;/&lt;code&gt;Assert.True(1 == 1);&lt;/code&gt;，虽然看上去差不多，但是写的多了就会觉得 xunit 更简洁一些。&lt;/p&gt;
&lt;p&gt;xunit 不需要对测试方法所在类型标记 &lt;code&gt;TestClass&lt;/code&gt; ，只需要在测试方法上标记 &lt;code&gt;Fact&lt;/code&gt; 或者使用数据驱动的 &lt;code&gt;Theory&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;xunit-的基本使用&quot;&gt;XUnit 的基本使用&lt;/h2&gt;
&lt;p&gt;使用 XUnit 来写测试方法可以使得测试代码更为简洁，更加简单，推荐使用 xunit 来测试自己的代码&lt;/p&gt;
&lt;p&gt;测试示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class ResultModelTest
{
    [Fact]
    public void SuccessTest()
    {
        var result = ResultModel.Success();
        Assert.Null(result.ErrorMsg);
        Assert.Equal(ResultStatus.Success, result.Status);
    }

    [Theory]
    [InlineData(ResultStatus.Unauthorized)]
    [InlineData(ResultStatus.NoPermission)]
    [InlineData(ResultStatus.RequestError)]
    [InlineData(ResultStatus.NotImplemented)]
    [InlineData(ResultStatus.ResourceNotFound)]
    [InlineData(ResultStatus.RequestTimeout)]
    public void FailTest(ResultStatus resultStatus)
    {
        var result = ResultModel.Fail(&quot;test error&quot;, resultStatus);
        Assert.Equal(resultStatus, result.Status);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最基本的测试，使用 &lt;code&gt;Fact&lt;/code&gt; 标记测试方法，使用 &lt;code&gt;Assert&lt;/code&gt; 来断言自己对结果的预期&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;Theory&lt;/code&gt; 来自己指定一批数据来进行测试，来实现测试数据驱动测试，简单的数据可以通过 &lt;code&gt;InlineData&lt;/code&gt; 直接指定，也可以使用 &lt;code&gt;MemberData&lt;/code&gt; 来指定一个方法来返回用于测试的数据，也可以自定义一个继承于 &lt;code&gt;DataAttribute&lt;/code&gt; 的 Data Provider&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;我觉得在我们开发过程中测试是非常重要的一部分，高质量项目的一个重要指标就是测试覆盖率，，一个高质量的开源项目一定是有比较完善的测试项目的，所以对于测试非常有必要了解一下，并将它集成到自己的项目中持续保证项目的高质量，同时完善的测试对于项目重构也是非常有好处的，能够很大程度上检测是否有发生一些破坏性的变更。&lt;/p&gt;
&lt;p&gt;总而言之，开始写单元测试吧，为成为一个优秀的工程师而努力~~&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 22 Jan 2021 16:11:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>.NET 中的单元测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14316093.html</dc:identifier>
</item>
<item>
<title>利用sklearn进行字典&amp;文本的特征提取 - noor9</title>
<link>http://www.cnblogs.com/xp-thebest/p/14315948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xp-thebest/p/14315948.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;这篇博客主要内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用DictVectorizer实现对类别特征进行数值化、离散化&lt;/li&gt;
&lt;li&gt;应用CountVectorizer实现对文本特征进行数值化&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;特征提取api&quot;&gt;特征提取API&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;sklearn.feature_extraction
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字典特征提取&quot;&gt;字典特征提取&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：对字典数据进行特征值化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sklearn.feature_extraction.DictVectorizer(sparse=True,…)
&lt;ul&gt;&lt;li&gt;DictVectorizer.fit_transform(X) X:字典或者包含字典的迭代器返回值：返回sparse矩阵&lt;/li&gt;
&lt;li&gt;DictVectorizer.inverse_transform(X) X:array数组或者sparse矩阵 返回值:转换之前数据格式&lt;/li&gt;
&lt;li&gt;DictVectorizer.get_feature_names() 返回类别名称&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 数据
[{'city': '北京','temperature':100}
{'city': '上海','temperature':60}
{'city': '深圳','temperature':30}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 代码
from sklearn.feature_extraction import DictVectorizer

def dict_demo():
    data = [{'city': '北京','temperature':100}, {'city': '上海','temperature':60}, {'city': '深圳','temperature':30}]
        # 1、实例化一个转换器类
    transfer  = DictVectorizer(sparse=False)
    # 2、调用fit_transform
    data_new = transfer.fit_transform(data)
    print(&quot;data_new：\n&quot;,data_new)
    # 打印特征名字
    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())
    
    return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;DictVectorizer&lt;/code&gt;默认是true，输出为稀疏矩阵，false输出为普通矩阵&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1529113/202101/1529113-20210122231431207-1856311557.png&quot; alt=&quot;不指定sparse=False结果&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1529113/202101/1529113-20210122231211827-2018861690.png&quot; alt=&quot;指定sparse=False结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;文本特征提取&quot;&gt;文本特征提取&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：对文本数据进行特征值化&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;sklearn.feature_extraction.text.CountVectorizer(stop_words=[])&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回词频矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CountVectorizer.fit_transform(X) X:文本或者包含文本字符串的可迭代对象 返回值：返回sparse矩阵&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CountVectorizer.inverse_transform(X) X:array数组或者sparse矩阵 返回值:转换之前数据格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CountVectorizer.get_feature_names() 返回值:单词列表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;sklearn.feature_extraction.text.TfidfVectorizer&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 数据
[&quot;life is short,i like python&quot;,
&quot;life is too long,i dislike python&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 代码
from sklearn.feature_extraction.text import CountVectorizer

def count_demo():
    data = [&quot;life is short,i like like python&quot;, &quot;life is too long,i dislike python&quot;]
    transfer  = CountVectorizer()
    data_new = transfer.fit_transform(data)
    print(&quot;data_new：\n&quot;,data_new.toarray())
    print(&quot;特征名字：\n&quot;,transfer.get_feature_names())
    return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意代码中的使用了&lt;code&gt;toarray()&lt;/code&gt;，可以不加这个方法，再运行一下看看📑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1529113/202101/1529113-20210122231938308-1794718277.png&quot; alt=&quot;运行结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 15:21:00 +0000</pubDate>
<dc:creator>noor9</dc:creator>
<og:description>利用sklearn进行字典&amp;文本的简单特征提取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xp-thebest/p/14315948.html</dc:identifier>
</item>
<item>
<title>写给 Linux 初学者的一封信 - 肖邦linux</title>
<link>http://www.cnblogs.com/liwei0526vip/p/14315856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei0526vip/p/14315856.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;54.898808095352&quot;&gt;
&lt;p&gt;大家好，我是&lt;strong&gt;肖邦&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章是写给 Linux 初学者的，我会分享一些作为初学者应该知道的一些东西，这些内容都是本人从事 Linux 开发工作多年的心得体会，相信会对初学者有所帮助。如果你是 Linux 老鸟，那可能就不需要再往下看了&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/linux-001.jpg&quot; alt=&quot;linux&quot; title=&quot;linux&quot;/&gt;linux
&lt;h2 id=&quot;hlinux&quot;&gt;&lt;span&gt;为啥要学Linux&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;作为从事 IT 工作的同学，对 Linux 系统一定不陌生。如今我们在各种领域都能看得到它的身影，比如，手机、服务器、嵌入式、电信设备、大型计算机，以及各种电子类产品都离不开 Linux，它已经渗透到互联网世界的方方面面了。&lt;/p&gt;
&lt;p&gt;包括那些火热的技术，比如云计算、虚拟化、容器、大数据、人工智能，几乎都是基于 Linux 技术的，那些平台系统，电商、团购、社交、新闻、快递，都是部署在服务器端，也几乎都是基于 Linux 技术的。&lt;/p&gt;
&lt;p&gt;在编程的世界中，Linux 就是主流，不会 Linux 你就可能会格格不入。如果你想进大公司，想学新技术，Linux 一定是一道绕不过去的砍，只有进入了 Linux 系统这扇大门，你才可能成为合格的软件工程师。&lt;/p&gt;
&lt;p&gt;企业服务器环境绝大部分都是 Linux 系统，所以不管你是从事前端、后端、运维、测试中的哪一类工作，Linux 都是你必须掌握的基础知识，只是不同类型工作需要学习 Linux 的方向不同而已。&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;经验与建议&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;下边分享的内容是本人从事 Linux 开发多年的一些经验总结，相信对 Linux 初学者会有所帮助，当然如果有不准确的地方，还请指正。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一定要自己搭建Linux环境&lt;/strong&gt;。Linux 系统学习是很重实践的，仅学习理论知识是不能真正掌握 Linux 的。我推荐在个人电脑上安装虚拟机，虚拟机的方式非常灵活，既可以提供 Linux 环境，也不会影响宿主机的正常使用。对于&lt;strong&gt;虚拟机软件的选择&lt;/strong&gt;，可以考虑使用 &lt;code&gt;VMware&lt;/code&gt; 或 &lt;code&gt;VirtualBox&lt;/code&gt; 。虚拟机的&lt;strong&gt;快照&lt;/strong&gt;功能一定要用好，尤其是对新手来说，它可以将你不小心搞坏的环境恢复到初始化状态，就像是重新安装了操作系统一样，从此妈妈再也不用担心我 &lt;code&gt;rm -rf /*&lt;/code&gt; 了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux发行版的选择&lt;/strong&gt;。由于 Linux 的强大，目前存在太多的发行版本了，有些同学在选择上可能会有些纠结。这里我推荐选择使用 CentOS 就行，由于免费且稳定，国内企业服务器使用最多的就是 CentOS 了，使用上和 RedHat 几乎没有什么区别。当然你可以选择 Ubuntu 系统，国内服务器使用份额仅次于 CentOS。其实所有发行版都是基于 Linux 内核的，只是扩展了相关的系统组件和软件库，本质上都是 Linux 系统，学会了 CentOS 后就很容易上手其它版本的系统了，所以无需太关注和纠结这个问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一定要使用命令行&lt;/strong&gt;。大部分初学者经常喜欢安装图形桌面，因为我们之前都习惯了 win 或 mac 的图形操作。但我强烈建议，安装系统时不要安装桌面，平时的操作和学习都坚持使用命令行。学习前期可能会比较痛苦，但熬过了阵痛期，熟练使用之后，就能享受到命令行带来的强大功能。命令行不仅功能强大，而且可以极大的提高效率，因为命令行就意味着能够自动化，自动化能为你释放很多重复性的工作，让你有充足的时间去学习更有价值的知识。另外，图形界面在 linux 系统上作为一个独立软件存在，会额外消耗服务器的资源，企业的服务器一定是不会安装图形的，所以需要你一定要在 Linux 世界中&lt;strong&gt;忘掉 windows 的思维方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux 是开源的&lt;/strong&gt;。开源意味着你能够查看 Linux 源码，可以从代码层面理解系统实现的原理，这些可以让你达到一通百通、醍醐灌顶的效果，而不是简单的使用它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;养成安全严谨的良好习惯&lt;/strong&gt;。对于初学者来说，虽然大部分时间是在虚拟机上操作，有快照的加持，可以毫无顾忌的进行各种实验性的操作。但我还是强烈建议初学者一定要养成良好的操作习惯：&lt;em&gt;1.&lt;/em&gt;经常备份重要的数据；&lt;em&gt;2.&lt;/em&gt;少用 root 用户进行各种操作；&lt;em&gt;3.&lt;/em&gt;敲命令不是越快越好；&lt;em&gt;4.&lt;/em&gt;服务器密码尽可能的复杂些，不要使用 &lt;code&gt;123456&lt;/code&gt; 这类弱密码，服务器很可能被侵入当肉鸡；&lt;em&gt;5.&lt;/em&gt;服务器密码不要简单记录在文档上或 U 盘之类的移动设备上；&lt;em&gt;6.&lt;/em&gt;对生产环境一定要有&lt;strong&gt;敬畏心&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;如何学习？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;高效的学习方法往往能够帮助你事半功倍，下边是我分享的一些自己的学习心得和方法，希望对大家有帮助。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一定要多实践&lt;/strong&gt;。Linux 是一门实操性非常强的学科，初学者需要多敲命令，多实践和练习。与学习其它东西是一样的，大多时候我们不需要非得先将理论知识学的通透后才来实践动手，而是从实践中发现问题后再深度学习，这样效果可能会更好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有效的学习方式&lt;/strong&gt;。说到学习方式，每个人学习的方式可能不太一样。我推荐 &lt;strong&gt;视频&lt;/strong&gt; + &lt;strong&gt;看书&lt;/strong&gt; 的方式，视频教程可以让你快速上手，快速了解相关的概念，而看书可以更加全面的学习具体的细节，会让你有更多的思考，看书可以作为视频的补充和扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;思考，总结与归纳&lt;/strong&gt;。不管以什么形式来学习，我们都需要对学习中的每个问题和概念认真思考，需要从 &lt;em&gt;what&lt;/em&gt;、&lt;em&gt;how&lt;/em&gt;、&lt;em&gt;why&lt;/em&gt; 三个角度进行学习，作为学习的问题模板。学习任何新技术，我们都需要知道这个技术知识点的&lt;em&gt;应用场景&lt;/em&gt;，以及能够&lt;em&gt;解决什么问题&lt;/em&gt;，是否有类似的&lt;em&gt;解决方案&lt;/em&gt;，此技术点有什么&lt;em&gt;优势&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出是一种高效学习方法&lt;/strong&gt;。在学习过程中，必不可少的一个环节就是归纳和总结，总结就要输出，可以是文档形式的笔记或者其它。我比较推荐&lt;em&gt;写博客&lt;/em&gt;，有条件的话一定要写，因为写博客可以帮助你更有效地、更系统的总结和学习。写博客是一种 &lt;em&gt;教&lt;/em&gt; 的形式，如果能够将自己学到的知识在博客上清晰的讲清楚，教会别人，那才说明你是真正的掌握了它。如果博客写的不错的话也能为自己够&lt;em&gt;积累影响力&lt;/em&gt;，对自己将来的求职也会有帮助。另外如果别人从你博客学习到了东西而且觉着不错的话，会给你点赞、留言、赞赏，这都是对你写博客和学习的&lt;em&gt;正反馈&lt;/em&gt;，同时也能够刺激你保持学习的兴奋和激情，呵呵。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;制定明确的学习目标&lt;/strong&gt;。做任何事，有了目标才能够走的更远，少走弯路。我们学习 Linux 也一样，需要根据自己的实际情况，制定适合自己的学习目标。个人建议目标不要太大，时间周期也不要太长，要切合实际，比如制定&lt;em&gt;三个月&lt;/em&gt;的学习目标。有了目标后，就要确定详细的学习计划，细化到每周需要完成的任务列表。注意，你需要为计划任务指定结果检验的方式，比如写一篇博客文章或是笔记，计划真实落地才是最困难的，因为&lt;em&gt;执行力&lt;/em&gt;是一种稀缺资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;坚持与激情，获得正反馈&lt;/strong&gt;。学习是一件逆人性的事情，大部分人在遇到诸多问题后就很容易会放弃。&lt;em&gt;1.&lt;/em&gt;合理的学习计划和结果输出，能够让你继续保持学习的激情；&lt;em&gt;2.&lt;/em&gt;写博客、讨论交流等方式也可以获得正向的反馈，从而激励着你继续向前；&lt;em&gt;3.&lt;/em&gt;坚持学习也能够帮你养成良好的习惯，无形中提高自己的执行力，个人认为这些收获可能远比具体的技术知识更加重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何解决问题&lt;/strong&gt;。在学习 Linux 技术的时候，初学者肯定会遇到各种 &lt;em&gt;奇怪&lt;/em&gt; 的问题，面对这些问题时，我们要学会分析错误信息，尝试以目前学习到的技术来思考找答案，如果解决不了，可以使用搜索引擎，对于初学者遇到的问题，百度一般都能够解决。如果实在解决不了，可以请教身边的高手，不过提问问题时，一定要描述清楚问题，带着谦虚请教的态度。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;应该学习的基础知识&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Linux 系统涉及的技术知识点非常广泛，学习者可以根据自己的实际情况，选择相应的主题方向进行学习，不可盲目的跟随他人的学习路线，有可能适得其反，学习效果事倍功半，得不偿失，所以选择适合自己的学习路线非常重要。&lt;/p&gt;
&lt;p&gt;因为每个人将来从事的工作和方向不同，需要重点学习的内容也不一样，而且本文目标也只是分享给 Linux 初学者一些实用的经验心得，所以后边内容中只简单罗列了最通用和实用的一些技术，这些是学习 Linux 技术的所有同学都应该知道的技术知识点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;学习 vim&lt;/strong&gt;。在 Linux 系统下，基本没有什么可以与之竞争的编辑器（不接受反驳），你只需要花费 &lt;code&gt;1-2&lt;/code&gt; 天的时间来熟悉 vim 的基本使用操作即可，无需研究那些高大上的各种插件使用技巧。要知道 vim 的学习是有难度的，不过一旦熟练使用后，就会得心应手，能极大提高编辑效率。这里推荐陈皓的《&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明 vim 练级攻略&lt;/a&gt;》。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单的文件管理&lt;/strong&gt;。这些都是一些非常基础的操作与文件的管理命令，如：&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;less&lt;/code&gt;、&lt;code&gt;head&lt;/code&gt;、&lt;code&gt;tail&lt;/code&gt;、&lt;code&gt;du&lt;/code&gt;、&lt;code&gt;df&lt;/code&gt;、&lt;code&gt;ln&lt;/code&gt; 等，当然 &lt;code&gt;find&lt;/code&gt; 是查找文件的非常有用的命令，功能非常强大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础的网络管理&lt;/strong&gt;。常用的网络管理命令，一定要学会使用，这对平时工作或学习时的网络诊断和网络配置非常有用。比如 &lt;code&gt;ip&lt;/code&gt; 或 &lt;code&gt;ifconfig&lt;/code&gt; 等网络命令，还有网络诊断工具 &lt;code&gt;netstat&lt;/code&gt;、&lt;code&gt;ping&lt;/code&gt;、&lt;code&gt;traceroute&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学些 shell 脚本编程&lt;/strong&gt;。我们知道 Linux 特点之一就是命令行，上边我们说过，命令行就意味着可以自动化，自动化后就能够规模化。shell 脚本就是我们实现自动化的最有效的方式，因为 shell 程序是最擅长与 Linux 内核打交道的。我们可以利用 shell 脚本帮我们做很多重复性的工作，来释放我们工程师的双手去创造更大的价值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;熟悉作业管理&lt;/strong&gt;。我们需要经常在命令行终端上管理应用程序，启动或关闭程序。你需要知道这些概念，如：进程、进程组、会话、终端，学会使用 &lt;code&gt;jobs&lt;/code&gt;、&lt;code&gt;fg&lt;/code&gt;、&lt;code&gt;bg&lt;/code&gt;、&lt;code&gt;kill&lt;/code&gt;、&lt;code&gt;Ctrl-C&lt;/code&gt;、&lt;code&gt;Ctrl-Z&lt;/code&gt;，以及信号的相关操作，需要知道 &lt;code&gt;kill -9&lt;/code&gt; 到底是在干什么。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习使用软件包的管理&lt;/strong&gt;。国内最常用的 Linux 发行版是 &lt;code&gt;ubuntu&lt;/code&gt;、&lt;code&gt;centos&lt;/code&gt;，需要学会使用 &lt;code&gt;apt-get&lt;/code&gt;、&lt;code&gt;yum&lt;/code&gt; 命令来查找和安装相关的软件包，当然也要学会试着从源码编译方式安装软件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习简单的数据处理&lt;/strong&gt;。我们在工作和学习中也会经常需要处理文本信息，Linux 在这方面提供了很多的工具，组合起来能够非常方便的实现强大的功能。常见的命令 &lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;uniq&lt;/code&gt;、&lt;code&gt;cut&lt;/code&gt;、&lt;code&gt;split&lt;/code&gt;，还有 Linux 经典的三剑客 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;，这三个工具都是上古神器，功能非常强大，&lt;em&gt;awk&lt;/em&gt; 还有专门的书籍来讲解它，可见功能之强大与复杂，我们初学者只需要熟练掌握一些常用的功能即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学会看文档&lt;/strong&gt;。虽然不是具体的技术知识，但它却非常重要，初学者在学习命令时总是希望能记住所有的参数和选项，其实这些参数我们不需要记忆（大脑是用来思考的而不是存储的），我们可以通过 Linux 手册来查看，通常使用 &lt;code&gt;man ifconfig&lt;/code&gt; 就能够查看该命令的官方文档说明，既准确又清晰。当然在遇到问题时，也可以查看手册来确认命令的使用方法是否正确。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Linux 系统涉及的技术知识点非常复杂，上述所分享的仅是一些必学基础知识，如果能够认真学习并够掌握好，基本上算是入门 Linux（存活的级别）。如果你是&lt;strong&gt;运维方向&lt;/strong&gt;，至少需要更深入的学习：用户管理、磁盘管理、系统日常管理、常见服务的搭建、高可用集群、系统监控等运维知识；如果你是&lt;strong&gt;后台开发方向&lt;/strong&gt;，至少需要更深入学些 Linux 操作系统、进程与线程、进程间通信、信号、网络编程、系统调用、Linux 内核等知识；如果你是&lt;strong&gt;嵌入式方向&lt;/strong&gt;，你至少需要深入研究 Linux 内核源码、设备驱动程序了。&lt;/p&gt;
&lt;p&gt;本篇文章到此结束，后边还会更新 Linux 系列文章，文章内容风格会尽量保持通俗易懂、重实践和实用性，尽可能地帮助到有需要的同学，如果感兴趣的话，可以继续关注后续 Linux 系列文章。&lt;/p&gt;
&lt;p&gt;谢谢大家，我是&lt;strong&gt;肖邦&lt;/strong&gt;，欢迎关注后续的精彩分享。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/bcxy-001.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 22 Jan 2021 14:56:00 +0000</pubDate>
<dc:creator>肖邦linux</dc:creator>
<og:description>大家好，我是肖邦。 这篇文章是写给 Linux 初学者的，我会分享一些作为初学者应该知道的一些东西，这些内容都是本人从事 Linux 开发工作多年的心得体会，相信会对初学者有所帮助。如果你是 Linu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liwei0526vip/p/14315856.html</dc:identifier>
</item>
<item>
<title>Graph Explore的使用介绍 - 老王717</title>
<link>http://www.cnblogs.com/sharepointonline/p/14300522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sharepointonline/p/14300522.html</guid>
<description>&lt;p&gt;我在Graph API开发中用的最多的测试工具就是Graph Explore，这个是微软开发的网页版的Graph API的测试工具，能满足我大部分需求。&lt;/p&gt;
&lt;p&gt;访问网址是：&lt;a href=&quot;https://developer.microsoft.com/en-us/graph/graph-explorer&quot;&gt;Graph Explorer - Microsoft Graph&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210120230058395-1699024788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 基本上分成4个区域&lt;/p&gt;
&lt;p&gt;1.用户登录&lt;/p&gt;
&lt;p&gt;2.Graph API查询的样例和查询历史&lt;/p&gt;
&lt;p&gt;3.用户查询&lt;/p&gt;
&lt;p&gt;4.返回结果&lt;/p&gt;
&lt;p&gt; 下面来一个个说明一下具体的作用。&lt;/p&gt;
&lt;p&gt;1.用户登录&lt;/p&gt;
&lt;p&gt;你可以用自己申请到的office 365开发者账号登录。登录后，点击登录名右边的齿轮图标，可以进行下面的一些设置。第一项会引导你去Office 365的网站导入一些测试用的用户、文档等，如果你的Office 365网站没有任何数据，使用沙箱是非常好的一个办法。第三项是设置权限，你可以在这里提前授权你需要的权限，如果没做也没关系，后面在每一条请求的时候，也可以做类似的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210121223127645-1672232564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.查询样例和历史&lt;/p&gt;
&lt;p&gt;这里提供了很多Graph API的查询样例，双击后就可以直接显示到右边的查询窗口，非常方便。但是这里提供的大多是最基本的一些查询，更多的还是需要自己在查询窗口自行创建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210121224032015-1658753380.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 历史tab下面可以保存你过去30天所有的查询记录，包括成功的和失败的。你也可以导出和删除所有记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210121224446659-837098146.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面来说一说最重要的两个部分。&lt;/p&gt;
&lt;p&gt;3. 用户查询。&lt;/p&gt;
&lt;p&gt;首先是选择HTTP请求的方法，一共有5个方法可选。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122221423080-643579105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后选择Graph API的版本，大部分情况下使用1.0就可以了。有的查询命令只在beta里面有，但是微软官方说在beta中的查询命令，可能随着新版本的发布会进入到1.0中，然后从beta里面删除，所以开发中还是尽量使用1.0版本，以免程序后续查询失败。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122221532612-1317354323.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 查询命令输入，这里测试一条查询，得到我的Office 365测试环境中所有的用户数。返回结果一会儿再看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122222034880-1438826661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Request Body里面是使用Post，Put，Patch，Delete方法时，输入一些查询条件。比如下面示例，是在Office 365中新增一个用户。Request body里面就是这个用户的一些详细信息，通常是JSON格式的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122222517528-102486727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Request Header里面是填写HTTP request headers。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122222724571-920898296.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 当你的查询请求返回401未授权结果时，就可以到Modify permissions下面检查你的权限。如果没授予权限的时候，status栏的consent会是一个蓝色按钮，按下即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122223002996-896240327.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后的Access Token，你可以复制它，用于测试，也可以点击大括号按钮，去jwt.ms网站查看token的具体内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122223803863-2073142873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 4. 查询结果&lt;/p&gt;
&lt;p&gt;首先最上面是查询返回结果的状态，常见的200，401，404.&lt;/p&gt;
&lt;p&gt;Response preview。可以看到之前查询的返回结果是23.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122224146425-2023350406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Response headers&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122224636342-88608651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Code snippets，这里是对开发人员最有用的部分了。根据你的查询，这里会给出相应的C#，JavaScript的代码片段。但是要注意的是，不是任何查询都给出代码片段的，个人感觉应该是最常用的一些查询会有代码片段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122224727312-176286186.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Toolkit component 和 Adaptive cards也不是所有查询都会有显示结果。在开发中用到的机会也不多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/367039/202101/367039-20210122225011882-1886042498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以上就是Graph Explore使用介绍了，以后有机会再写写用Postman进行查询测试的方法。&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jan 2021 14:54:00 +0000</pubDate>
<dc:creator>老王717</dc:creator>
<og:description>我在Graph API开发中用的最多的测试工具就是Graph Explore，这个是微软开发的网页版的Graph API的测试工具，能满足我大部分需求。 访问网址是：Graph Explorer -</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sharepointonline/p/14300522.html</dc:identifier>
</item>
<item>
<title>Android事件分发机制二：viewGroup与view对事件的处理 - 一只修仙的猿</title>
<link>http://www.cnblogs.com/huan89/p/14315809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huan89/p/14315809.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;很高兴遇见你~&lt;/p&gt;
&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://juejin.cn/post/6918272111152726024&quot; target=&quot;_blank&quot;&gt;Android事件分发机制一：事件是如何到达activity的？&lt;/a&gt; 中，我们讨论了触摸信息从屏幕产生到发送给具体 的view处理的整体流程，这里先来简单回顾一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac07f9a992324f0ea6dfe6b5f4236a67~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;整体流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;触摸信息从手机触摸屏幕时产生，通过IMS和WMS发送到viewRootImpl&lt;/li&gt;
&lt;li&gt;viewRootImpl把触摸信息传递给他所管理的view&lt;/li&gt;
&lt;li&gt;view根据自身的逻辑对事件进行分发&lt;/li&gt;
&lt;li&gt;常见的如Activity布局的顶层viewGroup为DecorView，他对事件分发方法进行了重新，会优先回调windowCallBack也就是Activity的分发方法&lt;/li&gt;
&lt;li&gt;最后事件都会交给viewGroup去分发给子view&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前面的分发步骤我们清楚了，那么viewGroup是如何对触摸事件进行分发的呢？View又是如何处理触摸信息的呢？正是本文要讨论的内容。&lt;/p&gt;
&lt;p&gt;事件处理中涉及到的关键方法就是 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; ，不管是viewGroup还是view。在viewGroup中，&lt;code&gt;dispatchTouchEvent&lt;/code&gt; 方法主要是把事件分发给子view，而在view中，&lt;code&gt;dispatchTouchEvent&lt;/code&gt; 主要是处理消费事件。而主要的消费事件内容是在 &lt;code&gt;onTouchEvent&lt;/code&gt; 方法中。下面讨论的是viewGroup与view的默认实现，而在自定义view中，通常会重写 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; 和 &lt;code&gt;onTouchEvent&lt;/code&gt; 方法，例如DecorView等。&lt;/p&gt;
&lt;p&gt;秉着逻辑先行源码后到的原则，本文虽然涉及到大量的源码，但会优先讲清楚流程，有时间的读者仍然建议阅读完整源码。&lt;/p&gt;
&lt;h2 id=&quot;理解motionevent&quot;&gt;理解MotionEvent&lt;/h2&gt;
&lt;p&gt;事件分发中涉及到一个很重要的点：多点触控，这是在很多的文章中没有体现出来的。而要理解viewGroup如何处理多点触控，首先需要对触摸事件信息类：MotionEvent，有一定的认识。MotionEvent中承载了触摸事件的很多信息，理解它更有利于我们理解viewGroup的分发逻辑。所以，首先需要先理解MotionEvent。&lt;/p&gt;
&lt;p&gt;触摸事件的基本类型有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACTION_DOWN: 表示手指按下屏幕&lt;/li&gt;
&lt;li&gt;ACTION_MOVE: 手指在屏幕上滑动时，会产生一系列的MOVE事件&lt;/li&gt;
&lt;li&gt;ACTION_UP: 手指抬起，离开屏幕&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一个完整的触摸事件系列是：从ACTION_DOWN开始，到ACTION_UP结束&lt;/strong&gt; 。这其实很好理解，就是手指按下开始，手指抬起结束。&lt;/p&gt;
&lt;p&gt;手指可能会在屏幕上滑动，那么中间会有大量的ACTION_MOVE事件，例如：ACTION_DOWN、ACTION_MOVE、ACTION_MOVE...、ACTION_UP。&lt;/p&gt;
&lt;p&gt;这是正常的情况，而如果出现了一些异常的情况，事件序列被中断，那么会产生一个取消事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACTION_CANCEL：当出现异常情况事件序列被中断，会产生该类型事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，完整的事件序列是：&lt;strong&gt;从ACTION_DOWN开始，到ACTION_UP或者ACTION_CANCEL结束&lt;/strong&gt; 。当然，这是我们一个手指的情况，那么在多指操作的情况是怎么样的呢？这里需要引入另外的事件类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACTION_POINTER_DOWN: 当已经有一个手指按下的情况下，另一个手指按下会产生该事件&lt;/li&gt;
&lt;li&gt;ACTION_POINTER_UP: 多个手指同时按下的情况下，抬起其中一个手指会产生该事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;区别于ACTION_DOWN和ACTION_UP，使用另外两个事件类型来表示手指的按下与抬起，使得&lt;strong&gt;ACTION_DOWN和ACTION_UP可以作为一个完整的事件序列的边界&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时，一个手指的事件序列，是从ACTION_DOWN/ACTION_POINTER_DOWN开始，到ACTION_UP/ACTION_POINTER_UP/ACTION_CANCEL结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这里先简单做个小结：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;触摸事件的类型有：ACTION_DOWN、ACTION_MOVE、ACTION_UP、ACTION_POINTER_DOWN、ACTION_POINTER_UP，他们分别代表不同的场景。&lt;/p&gt;
&lt;p&gt;一个完整的事件序列是从ACTION_DOWN开始，到ACTION_UP或者ACTION_CANCEL结束。&lt;br/&gt;&lt;strong&gt;一个手指&lt;/strong&gt;的完整序列是从ACTION_DOWN/ACTION_POINTER_DOWN开始，到ACTION_UP/ACTION_POINTER_UP/ACTION_CANCEL结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;第二，我们需要理解MotionEvent中所携带的信息。&lt;/p&gt;
&lt;p&gt;假如现在屏幕上有两个手指按下，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93e3ab6b29548c49bc5b28686eba4a8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;触摸点a先按下，而触摸点b&lt;strong&gt;后&lt;/strong&gt;按下，那么自然而然就会产生两个事件：ACTION_DOWN和ACTION_POINTER_DOWN。那么是不是ACTION_DOWN事件就只包含有触摸点a的信息，而ACTION_POINTER_DOWN只包含触摸点b的信息呢？换句话说，这两个事件是不是会独立发出触摸事件？答案是：不是。&lt;/p&gt;
&lt;p&gt;每一个触摸事件中，都包含有所有触控点的信息。例如上述的点b按下时产生的ACTION_POINTER_DOWN事件中，就包含了触摸点a和触摸点b的信息。那么他是如何区分这两个点的信息？我们又是如何知道ACTION_POINTER_DOWN这个事件类型是属于触摸点a还是触摸点b？&lt;/p&gt;
&lt;p&gt;在MotionEvent对象内部，维护有一个数组。这个数组中的每一项对应不同的触摸点的信息，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ea91173329439d819540981ae37f45~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数组下标称为触控点的索引，每个节点，拥有一个触控点的完整信息。这里要注意的是，一个触控点的索引并不是一成不变的，而是会随着触控点的数目变化而变化。例如当同时按下两个手指时，数组情况如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dea3347932984b77986556107412ba73~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当手指a抬起后，数组的情况变为下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bb140f2b37e4f569f132b3edce5afc8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到触控点b的索引改变了。所以&lt;strong&gt;跟踪一个触控点必须是依靠一个触控点的id，而不是他的索引&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;现在我们知道每一个MotionEvent内部都维护有所有触控点的信息，那么我们怎么知道这个事件是对应哪个触控点呢？这就需要看到MotionEvent的一个方法：&lt;code&gt;getAction&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个方法返回一个整型变量，他的低1-8位表示该事件的类型，高9-16位表示触控点索引。我们只需要将这16位进行分离，就可以知道触控点的类型和所对应的触控点。同时，MotionEvent有两个获取触控点坐标的方法：&lt;code&gt;getX()/getY()&lt;/code&gt; ，他们都需要传入一个触控点索引来表示获取哪个触控点的坐标信息。&lt;/p&gt;
&lt;p&gt;同时还要注意的是，MOVE事件和CANCEL事件是没有包含触控点索引的，只有DOWN类型和UP类型的事件才包含触控点索引。这里是因为非DOWN/UP事件，不涉及到触控点的增加与删除。&lt;/p&gt;
&lt;p&gt;这里我们再来小结一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;一个MotionEvent对象内部使用一个数组来维护所有触控点的信息&lt;/li&gt;
&lt;li&gt;UP/DOWN类型的事件包含了触控点索引，可以根据该索引做出对应的操作&lt;/li&gt;
&lt;li&gt;触控点的索引是变化的，不能作为跟踪的依据，而必须依据触控点id&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;关于MotionEvent需要了解一个更加重要的点：事件分离。&lt;/p&gt;
&lt;p&gt;首先需要知道事件分发的一个原则：&lt;strong&gt;一个view消费了某一个触点的down事件后，该触点事件序列的后续事件，都由该view消费&lt;/strong&gt; 。这也比较符合我们的操作习惯。当我们按下一个控件后，只要我们的手指一直没有离开屏幕，那么我们希望这个手指滑动的信息都交给这个view来处理。换句话说，一个触控点的事件序列，只能给一个view消费。&lt;/p&gt;
&lt;p&gt;经过前面的描述我们知道，一个事件是包含所有触摸点的信息的。当viewGroup在派发事件时，每个触摸点的信息就需要分开分别发送给感兴趣的view，这就是事件分离。&lt;/p&gt;
&lt;p&gt;例如Button1接收了触摸点a的down事件，Button2接收了触摸点b的down事件，那么当一个MotionEvent对象到来时，需要将他里面的触摸点信息，把触摸点a的信息拆开发送给button1，把触摸点b的信息拆开发送给button2。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0007635a8ced425ab58bf61f7ab78ae7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;事件分离&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，可不可以不进行分离？当然可以。这样的话每次都把所有触控点的信息发送给子view。这可以通过FLAG_SPLIT_MOTION_EVENTS这个标志进行设置是否要进行分离。&lt;/p&gt;
&lt;p&gt;小结一下：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;一个触控点的序列一般情况下只给一个view处理，当一个view消费了一个触控点的down事件后，该触控点的事件序列后续事件都会交给他处理。&lt;/p&gt;
&lt;p&gt;事件分离是把一个motionEvent中的触控点信息进行分离，只向子view发送其感兴趣的触控点信息。&lt;/p&gt;
&lt;p&gt;我们可以通过设置FLAG_SPLIT_MOTION_EVENTS标志让viewGroup是否对事件进行分离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;到这里关于MotionEvent的内容就讲得差不多，当然在分离的时候，还需要进行一定的调整，例如坐标轴的更改、事件类型的更改等等，放在后面讲，接下来看看ViewGroup是如何分发事件的。&lt;/p&gt;
&lt;h2 id=&quot;viewgroup对于事件的分发&quot;&gt;ViewGroup对于事件的分发&lt;/h2&gt;
&lt;p&gt;这一步可以说是事件分发中的重头戏了。不过在理解了上面的MotionEvent之后，对于ViewGroup的分发细节也就容易理解了。&lt;/p&gt;
&lt;p&gt;整体来说，ViewGroup分发事件分为三个大部分，后面的内容也会围绕着三大部分展开：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拦截事件：在一定情况下，viewGroup有权利选择拦截事件或者交给子view处理&lt;/li&gt;
&lt;li&gt;寻找接收事件序列的控件：每一个需要分发给子view的down事件都会先寻找是否有适合的子view，让子view来消费整个事件序列&lt;/li&gt;
&lt;li&gt;派发事件：把事件分发到感兴趣的子view中或自己处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大体的流程是：每一个事件viewGroup会先判断是否要拦截，如果是down事件（这里的down事件表示ACTION_DOWN和ACTION_POINTER_DOWN，下同），还需要挨个遍历子view看看是否有子view消费了down事件，最后再把事件派发下去。&lt;/p&gt;
&lt;p&gt;在开始解析之前，必须先了解一个关键对象：TouchTarget。&lt;/p&gt;
&lt;h4 id=&quot;touchtarget&quot;&gt;TouchTarget&lt;/h4&gt;
&lt;p&gt;前面我们讲到：一个触控点的序列一般情况下只给一个view处理，当一个view消费了一个触控点的down事件后，该触控点的事件序列后续事件都会交给他处理。对于viewGroup来说，他有很多个子view，如果不同的子view接受了不同的触控点的down事件，那么ViewGroup如何记录这些信息并精准把事件发送给对应的子view呢？答案就是：TouchTarget。&lt;/p&gt;
&lt;p&gt;TouchTarget中维护了每个子view以及所对应的触控点id，这里的id可以不止一个。TouchTarget本身是个链表，每个节点记录了子view所对应的触控点id。在viewGroup中，该链表的链表头是mFirstTouchTarget，如果他为null，表示没有任何子view接收了down事件。&lt;/p&gt;
&lt;p&gt;TouchTarget有个非常神奇的设计，他只使用一个整型变量来记录所有的触控id。整型变量中哪一个二进制位为1，则对应绑定该id的触控点。&lt;/p&gt;
&lt;p&gt;例如 00000000 00000000 00000000 10001000，则表示绑定了id为3和id为7的两个触控点，因为第3位和第7位的二进制位是1。这里可以间接说明系统支持的最大多点触控数是32，当然实际上一般是8比较多。当要判断一个TouchTarget绑定了哪些id时，只需要通过一定的位操作即可，既提高了速度，也优化了空间占用。&lt;/p&gt;
&lt;p&gt;当一个down事件来临时，viewGroup会为这个down事件寻找适合的子view，并为他们创建一个TouchTarget加入到链表中。而当一个up事件来临时，viewGroup会把对应的TouchTarget节点信息删除。那接下来，就直接看到viewGroup中的&lt;code&gt;dispatchTouchEvent&lt;/code&gt; 是如何分发事件的。首先看到源码中的第一部分：事件拦截。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;事件拦截&quot;&gt;事件拦截&lt;/h4&gt;
&lt;p&gt;这里的拦截分为两部分：安全拦截和逻辑拦截。&lt;/p&gt;
&lt;p&gt;安全拦截是一直被忽略的一种情况。当一个控件a被另一个非全屏控件b遮挡住的时候，那么有可能被恶意软件操作发生危险。例如我们看到的界面是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b766a612077941c0afff0e7eb4515e3a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但实际上，我们看到的这个按钮时不可点击的，实际上触摸事件会被分发到这个按钮后面的真正接收事件的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb1b9bdc5bb4b8cb365accad3fef120~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就白给了。这个安全拦截行为由两个标志控制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FILTER_TOUCHES_WHEN_OBSCURED：这个标志可以手动给控件设置，表示被非全屏控件覆盖时，直接过滤掉所有触摸事件。&lt;/li&gt;
&lt;li&gt;FLAG_WINDOW_IS_OBSCURED：这个标志表示当前窗口被一个非全屏控件覆盖。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的源码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;View.java api29
public boolean onFilterTouchEventForSecurity(MotionEvent event) {
    // 两个标志，前者表示当被覆盖时不处理；后者表示当前窗口是否被非全屏窗口覆盖
    if ((mViewFlags &amp;amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
            &amp;amp;&amp;amp; (event.getFlags() &amp;amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
        // Window is obscured, drop this touch.
        return false;
    }
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种拦截是逻辑拦截。如果当前viewGroup中没有TouchTarget，而且这个事件不是down事件，这就意味着viewGroup自己消费了先前的down事件，那么这个事件就无须分发到子view必须自己消费，也就不需要拦截这种情况的事件。除此之外的事件都是需要分发到子view，那么viewGroup就可以对他们进行判断是否进行拦截。简单来说，&lt;strong&gt;只有需要分发到子view的事件才需要拦截&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;判断是否拦截主要依靠两个因素：FLAG_DISALLOW_INTERCEPT标志和 &lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子view可以通过requestDisallowInterupt方法强制要求viewGroup不要拦截事件，viewGroup中会设置一个FLAG_DISALLOW_INTERCEPT标志表示不拦截事件。但是当前事件序列结束后，这个标志会被清除。如果需要的话需要再次调用requestDisallowInterupt方法进行设置。&lt;/li&gt;
&lt;li&gt;如果子view没有强制要求不拦截，那么会调用&lt;code&gt;onInterceptTouchEvent()&lt;/code&gt; 方法判断是否需要拦截。onInterceptTouchEvent方法默认只对一种特殊情况作了拦截。一般情况下我们会重写这个方法来拦截事件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 只对一种特殊情况做了拦截
// 鼠标左键点击了滑动块
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
            &amp;amp;&amp;amp; ev.getAction() == MotionEvent.ACTION_DOWN
            &amp;amp;&amp;amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
            &amp;amp;&amp;amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;viewGroup的 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; 方法逻辑中对于事件拦截部分的源码分析如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ViewGroup.java api29
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
        
    // 对遮盖状态进行过滤
    if (onFilterTouchEventForSecurity(ev)) {
        
        ...

        // 判断是否需要拦截
        final boolean intercepted;
        // down事件或者有target的非down事件则需要判断是否需要拦截
        // 否则不需要进行拦截判断，因为一定是交给自己处理
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            // 此标志为子view通过requestDisallowInterupt方法设置
            // 禁止viewGroup拦截事件
            final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 调用onInterceptTouchEvent判断是否需要拦截
                intercepted = onInterceptTouchEvent(ev);
                // 恢复事件状态
                ev.setAction(action); 
            } else {
                intercepted = false;
            }
        } else {
            // 自己消费了down事件，那么后续的事件非down事件都是自己处理
            intercepted = true;
        }
        ...;
    }
    ...;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;寻找消费down事件的子控件&quot;&gt;寻找消费down事件的子控件&lt;/h4&gt;
&lt;p&gt;对于每一个down事件，不管是ACTION_DOWN还是ACTION_POINTER_DOWN，viewGroup都会优先在控件树中寻找合适的子控件来消费他。因为对于每一个down事件，标志着一个触控点的一个崭新的事件序列，viewGroup会尽自己的最大能力寻找合适的子控件。如果找不到合适的子控件，才会自己处理down事件。因为，消费了down事件，意味着接下来该触控点的事件序列事件都会交给该view消费，如果viewGroup拦截了事件，那么子view就无法接收到任何事件消息。&lt;/p&gt;
&lt;p&gt;viewGroup寻找子控件的步骤也不复杂。首先viewGroup会为他的子控件构造一个控件列表，构造的顺序是view的绘制顺序的逆序，也就是一个view的z轴系数越高，显示高度越高，在列表的顺序就会越靠前。这其实比较好理解，显示越高的控件肯定是优先接收点击的。除了默认情况，我们也可以进行自定义列表顺序，这里就不展开了。&lt;/p&gt;
&lt;p&gt;viewGroup会按顺序遍历整个列表，判断触控点的位置是否在该view的范围内、该view是否可以点击等，寻找合适的子view。如果找到合适的子view，则会把down事件分发给他，如果该view接收事件，则会为他创建一个TouchTarget，将该触控id和view进行绑定，之后该触控点的事件就可以直接分发给他了。&lt;/p&gt;
&lt;p&gt;而如果没有一个控件适合，那么会默认选取TouchTarget链表的最新一个节点。也就是当我们多点触控时，两次手指按下，如果没有找到合适的子view，那么就被认为是和上一个手指点击的是同个view。因此，如果viewGroup当前有正在消费事件的子控件，那么viewGroup自己是不会消费down事件的。&lt;/p&gt;
&lt;p&gt;接下来我们看看源码分析(代码有点长，需要慢慢分析理解）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ViewGroup.java api29
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
         
    // 对遮盖状态进行过滤
    if (onFilterTouchEventForSecurity(ev)) {
        
        // action的高9-16位表示索引值
        // 低1-8位表示事件类型
        // 只有down或者up事件才有索引值
        final int action = ev.getAction();
        // 获取到真正的事件类型
        final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

        ...

        // 拦截内容的逻辑
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            ...
        } 

        ...

        // 三个变量：
        // split表示是否需要对事件进行分裂，对应多点触摸事件
        // newTouchTarget 如果是down或pointer_down事件的新的绑定target
        // alreadyDispatchedToNewTouchTarget 表示事件是否已经分发给targetview了
        final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        
        // 如果没有取消和拦截进入分发
        if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        ...
                        // down或pointer_down事件，表示新的手指按下了，需要寻找接收事件的view
            if (actionMasked == MotionEvent.ACTION_DOWN
                || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                
                // 多点触控会有不同的索引，获取索引号
                // 该索引位于MotionEvent中的一个数组，索引值就是数组下标值
                // 只有up或down事件才会携带索引值
                final int actionIndex = ev.getActionIndex(); 
                // 这个整型变量记录了TouchTarget中view所对应的触控点id
                // 触控点id的范围是0-31，整型变量中哪一个二进制位为1，则对应绑定该id的触控点
                // 例如 00000000 00000000 00000000 10001000
                // 则表示绑定了id为3和id为7的两个触控点
                // 这里根据是否需要分离，对触控点id进行记录，
                // 而如果不需要分离，则默认接收所有触控点的事件
                final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;

                // down事件表示该触控点事件序列是一个新的序列
                // 清除之前绑定到到该触控id的TouchTarget
                removePointersFromTouchTargets(idBitsToAssign);

                final int childrenCount = mChildrenCount;
                // 如果子控件数目不为0而且还没绑定到新的id
                if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                    // 使用触控点索引获取触控点位置
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 从前到后创建view列表
                    final ArrayList&amp;lt;View&amp;gt; preorderedList = buildTouchDispatchChildList();
                    // 判断是否是自定义view顺序
                    final boolean customOrder = preorderedList == null
                        &amp;amp;&amp;amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    
                    // 遍历所有子控件
                    for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                        // 从子控件列表中获取到子控件
                        final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);
                        
                        ...

                        // 检查该子view是否可以接受触摸事件和是否在点击的范围内
                        if (!child.canReceivePointerEvents()
                            || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        // 检查该子view是否在touchTarget链表中
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // 链表中已经存在该子view，说明这是一个多点触摸事件
                            // 即两次都触摸到同一个view上
                            // 将新的触控点id绑定到该TouchTarget上
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }

                        resetCancelNextUpFlag(child);
                        // 找到合适的子view，把事件分发给他，看该子view是否消费了down事件
                        // 如果消费了，需要生成新的TouchTarget
                        // 如果没有消费，说明子view不接受该down事件，继续循环寻找合适的子控件
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 保存该触控事件的相关信息
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &amp;lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 保存该view到target链表
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            // 标记已经分发给子view，退出循环
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        ...
                    }// 这里对应for (int i = childrenCount - 1; i &amp;gt;= 0; i--)
                    ...
                }// 这里对应判断：(newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0)

                if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                    // 没有子view接收down事件，直接选择链表尾的view作为target
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
                
            }// 这里对应if (actionMasked == MotionEvent.ACTION_DOWN...)
        }// 这里对应if (!canceled &amp;amp;&amp;amp; !intercepted)
        ...
    }// 这里对应if (onFilterTouchEventForSecurity(ev))
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;派发事件&quot;&gt;派发事件&lt;/h4&gt;
&lt;p&gt;经过了拦截与寻找消费down事件的控件之后，无论前面的处理结果如何，最终都是需要将事件进行派发，不管是派发给自己还是子控件。这里派发的对象只有两个：viewGroup自身或TouchTarget。&lt;/p&gt;
&lt;p&gt;经过了前面的寻找消费down事件子控件步骤，那么每个触控点都找到了消费自己事件序列的控件并绑定在了TouchTarget中；而如果没有找到合适的子控件，那么消费的对象就是viewGroup自己。因此派发事件的主要任务就是：&lt;strong&gt;把不同触控点的信息分发给合适的viewGroup或touchTarget。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;派发的逻辑需要结合前面MotionEvent和TouchTarget的内容。我们知道MotionEvent包含了当前屏幕所有触控点信息，而viewGroup的每个TouchTarget则包含了不同的view所感兴趣的触控点。&lt;br/&gt;如果不需要进行事件分离，那么直接将当前的所有触控点的信息都发送给每个TouchTarget即可；&lt;br/&gt;如果需要进行事件分离，那么会将MotionEvent中不同触控点的信息拆开分别创建新的MotionEvent，并发送给感兴趣的子控件；&lt;br/&gt;如果TouchTarget链表为空，那么直接分发给viewGroup自己；所以touchTarget不为空的情况下，viewGroup自己是不会消费事件的，这也就意味着viewGroup和其中的view不会同时消费事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/21/6Myj1AaF2XeRVq9.png&quot; alt=&quot;事件分离派发事件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了需要事件分离的情况下进行的事件分发。&lt;/p&gt;
&lt;p&gt;在把原MotionEvent拆分成多个MotionEvent时，不仅需要把不同的触控点信息进行分离，还需要对坐标进行转换和改变事件类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们接收到的触控点的位置信息并不是基于屏幕坐标系，而是基于当前view的坐标系。所以当viewGroup往子view分发事件时，需要把触控点的信息转换成对应view的坐标系。&lt;/li&gt;
&lt;li&gt;viewGroup收到的事件类型和子view收到的事件类型并不是完全一致的，在分发给子view的时候，viewGroup需要对事件类型进行修改，一般有以下情况需要修改：
&lt;ol&gt;&lt;li&gt;viewGroup收到一个ACTION_POINTER_DOWN事件分发给一个子view，但是该子view前面没有收到其他的down事件，所以对于该view来说这是一个崭新的事件序列，所以需要把这个ACTION_POINTER_DOWN事件类型改为ACTION_DOWN再发送给子view。&lt;/li&gt;
&lt;li&gt;viewGroup收到一个ACTION_POINTER_DOWN或ACTION_POINTER_UP事件，假设这个事件类型对应触控点2，但是有一个子view他只对触控点1的事件序列感兴趣，那么在分离出触控点1的信息之后，还需要把事件类型改为ACTION_MOVE再分发给该子view。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;注意，把原MotionEvent对象拆分为多个MotionEvent对象之后，触控点的索引也发生了改变，如果需要分发一个ACTION_POINTER_DOWN/UP事件给子view，那么需要注意更新触控点的索引值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;viewGroup中真正执行事件派发的关键方法是 &lt;code&gt;dispatchTransformedTouchEvent&lt;/code&gt; ，该方法会完成关键的事件分发逻辑。源码分析如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ViewGroup.java api29
// 该方法接收原MotionEvent事件、是否进行取消、目标子view、以及目标子view感兴趣的触控id
// 如果不是取消事件这个方法会把原MotionEvent中的触控点信息拆分出目标view感兴趣的触控点信息
// 如果是取消事件则不需要拆分直接发送取消事件即可
private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    final boolean handled;

    // 如果是取消事件，那么不需要做其他额外的操作，直接派发事件即可，然后直接返回
    // 因为对于取消事件最重要的内容就是事件本身，无需对事件的内容进行设置
    final int oldAction = event.getAction();
    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
        event.setAction(MotionEvent.ACTION_CANCEL);
        if (child == null) {
            handled = super.dispatchTouchEvent(event);
        } else {
            handled = child.dispatchTouchEvent(event);
        }
        event.setAction(oldAction);
        return handled;
    }

    // oldPointerIdBits表示现在所有的触控id
    // desirePointerIdBits来自于该view所在的touchTarget，表示该view感兴趣的触控点id
    // 因为desirePointerIdBits有可能全是1，所以需要和oldPointerIdBits进行位与
    // 得到真正可接收的触控点信息
    final int oldPointerIdBits = event.getPointerIdBits();
    final int newPointerIdBits = oldPointerIdBits &amp;amp; desiredPointerIdBits;

    // 控件处于不一致的状态。正在接受事件序列却没有一个触控点id符合
    if (newPointerIdBits == 0) {
        return false;
    }

    // 来自原始MotionEvent的新的MotionEvent，只包含目标感兴趣的触控点
    // 最终派发的是这个MotionEvent
    final MotionEvent transformedEvent;
    
    // 两者相等，表示该view接受所有的触控点的事件
    // 这个时候transformedEvent相当于原始MotionEvent的复制
    if (newPointerIdBits == oldPointerIdBits) {
        // 当目标控件不存在通过setScaleX()等方法进行的变换时，
        // 为了效率会将原始事件简单地进行控件位置与滚动量变换之后
        // 发送给目标的dispatchTouchEvent()方法并返回。
        if (child == null || child.hasIdentityMatrix()) {
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                final float offsetX = mScrollX - child.mLeft;
                final float offsetY = mScrollY - child.mTop;
                event.offsetLocation(offsetX, offsetY);

                handled = child.dispatchTouchEvent(event);

                event.offsetLocation(-offsetX, -offsetY);
            }
            return handled;
        }
        // 复制原始MotionEvent
        transformedEvent = MotionEvent.obtain(event);
    } else {
        // 如果两者不等，说明需要对事件进行拆分
        // 只生成目标感兴趣的触控点的信息
        // 这里分离事件包括了修改事件的类型、触控点索引等
        transformedEvent = event.split(newPointerIdBits);
    }

    // 对MotionEvent的坐标系，转换为目标控件的坐标系并进行分发
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        // 计算滚动量偏移
        final float offsetX = mScrollX - child.mLeft;
        final float offsetY = mScrollY - child.mTop;
        transformedEvent.offsetLocation(offsetX, offsetY);
        // 存在scale等变换，需要进行矩阵转换
        if (! child.hasIdentityMatrix()) {
            transformedEvent.transform(child.getInverseMatrix());
        }
                // 调用子view的方法进行分发
        handled = child.dispatchTouchEvent(transformedEvent);
    }

    // 分发完毕，回收MotionEvent
    transformedEvent.recycle();
    return handled;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，了解完上面的内容，来看看viewGroup的 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; 中派发事件的代码部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ViewGroup.java api29
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
        
    // 对遮盖状态进行过滤
    if (onFilterTouchEventForSecurity(ev)) {
                ...

                
        if (mFirstTouchTarget == null) {
            // 经过了前面的处理，到这里touchTarget依旧为null，说明没有找到处理down事件的子控件
            // 或者down事件被viewGroup本身消费了，所以该事件由viewGroup自己处理
            // 这里调用了dispatchTransformedTouchEvent方法来分发事件
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                                                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 已经有子view消费了down事件
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            // 遍历所有的TouchTarget并把事件分发下去
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                    // 表示事件在前面已经处理了，不需要重复处理
                    handled = true;
                } else {
                    // 正常分发事件或者分发取消事件
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                    // 这里调用了dispatchTransformedTouchEvent方法来分发事件
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                                                      target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果发送了取消事件，则移除该target
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // 如果接收到取消获取up事件，说明事件序列结束
        // 直接删除所有的TouchTarget
        if (canceled
            || actionMasked == MotionEvent.ACTION_UP
            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 清除记录的信息
            resetTouchState();
        } else if (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex);
            // 如果仅仅只是一个PONITER_UP
            // 清除对应触控点的触摸信息
            removePointersFromTouchTargets(idBitsToRemove);
        }
        
    }// 这里对应if (onFilterTouchEventForSecurity(ev))

    if (!handled &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;到这里，viewGroup的事件分发源码就解析完成了，这里再来小结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个触控点的事件序列，只能给一个view消费；如果一个view消费了一个触控点的down事件，那么该触控点的后续事件都会给他处理。&lt;/li&gt;
&lt;li&gt;每一个事件到达viewGroup，如果需要分发到子view，那么viewGroup会新判断是否要拦截。
&lt;ul&gt;&lt;li&gt;当viewGroup的touchTarget!=null || 事件的类型为down 需要进行判断是否拦截；&lt;/li&gt;
&lt;li&gt;判断是否拦截受两个因素影响：onInterceptTouchEvent和FLAG_DISALLOW_INTERCEPT标志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果该事件是down类型，那么需要遍历所有的子控件判断是否有子控件消费该down事件
&lt;ul&gt;&lt;li&gt;当有新的down事件被消费时，viewGroup会把该view和对应的触控点id绑定起来存储到touchTarget中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据前面的处理情况，将事件派发到viewGroup自身或touchTarget中
&lt;ul&gt;&lt;li&gt;如果touchTarget==null，说明没有子控件消费了down事件，那么viewGroup自己处理事件&lt;/li&gt;
&lt;li&gt;否则将事件分离成多个MotionEvent，每个MotionEvent只包含对应view感兴趣的触控点的信息，并派发给对应的子view&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;viewGroup中的源码很多，但大体的逻辑也就这三大部分。理解好MotionEvent和TouchTarget的设计，那么理解viewGroup的事件分发源码也是手到擒来。上面的源码我省略了一些细节内容，下面附上完整的viewGroup分发代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ViewGroup.java api29
public boolean dispatchTouchEvent(MotionEvent ev) {
    // 一致性检验器，用于调试用途
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
        
    // 辅助功能，用于辅助有障碍人群使用;
    // 如果这个事件是辅助功能事件，那么他会带有一个target view，要求事件必须分发给该view
    // 如果setTargetAccessibilityFocus(false)，表示取消辅助功能事件，按照常规的事件分发进行
    // 这里表示如果当前是目标target view，则取消标志，直接按照普通分发即可
    // 后面还有很多类似的代码，都是同样的道理
    if (ev.isTargetAccessibilityFocus() &amp;amp;&amp;amp; isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }   

    boolean handled = false;
    // 对遮盖状态进行过滤
    if (onFilterTouchEventForSecurity(ev)) {
        
        // action的高9-16位表示索引值
        // 低1-8位表示事件类型
        // 只有down或者up事件才有索引值
        final int action = ev.getAction();
        // 获取到真正的事件类型
        final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

        // ACTION_DOWN事件，表示这是一个全新的事件序列，会清除所有的touchTarget，重置所有状态
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        // 判断是否需要拦截
        final boolean intercepted;
        // down事件或者有target的非down事件则需要判断是否需要拦截
        // 否则直接拦截自己处理
        if (actionMasked == MotionEvent.ACTION_DOWN
            || mFirstTouchTarget != null) {
            // 此标志为子view通过requestDisallowInterupt方法设置
            // 禁止viewGroup拦截事件
            final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                // 调用onInterceptTouchEvent判断是否需要拦截
                intercepted = onInterceptTouchEvent(ev);
                // 恢复事件状态
                ev.setAction(action); 
            } else {
                intercepted = false;
            }
        } else {
            // 自己消费了down事件
            intercepted = true;
        }

        // 如果已经被拦截、或者已经有了目标view，取消辅助功能的target标志
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }

        // 判断是否需要取消
        // 这里有很多种情况需要发送取消事件
        // 最常见的是viewGroup拦截了子view的ACTION_MOVE事件，导致事件序列中断
        // 那么需要发送cancel事件告知该view，让该view做一些状态恢复工作
        final boolean canceled = resetCancelNextUpFlag(this)
            || actionMasked == MotionEvent.ACTION_CANCEL;

        // 三个变量：
        // 是否需要对事件进行分裂，对应多点触摸事件
        // newTouchTarget 如果是down或pointer_down事件的新的绑定target
        // alreadyDispatchedToNewTouchTarget 是否已经分发给target view了
        final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        
        // 下面部分的代码是寻找消费down事件的子控件
        // 如果没有取消和拦截进入分发
        if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        // 如果是辅助功能事件，我们会寻找他的target view来接收这个事件
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                    ? findChildWithAccessibilityFocus() : null;
            
                        // down或pointer_down事件，表示新的手指按下了，需要寻找接收事件的view
            if (actionMasked == MotionEvent.ACTION_DOWN
                || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                
                // 多点触控会有不同的索引，获取索引号
                // 该索引位于MotionEvent中的一个数组，索引值就是数组下标值
                // 只有up或down事件才会携带索引值
                final int actionIndex = ev.getActionIndex(); 
                
                // 这个整型变量记录了TouchTarget中view所对应的触控点id
                // 触控点id的范围是0-31，整型变量中哪一个二进制位为1，则对应绑定该id的触控点
                // 例如 00000000 00000000 00000000 10001000
                // 则表示绑定了id为3和id为7的两个触控点
                // 这里根据是否需要分离，对触控点id进行记录，
                // 而如果不需要分离，则默认接收所有触控点的事件
                final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;

                // 清除之前获取到该触控id的TouchTarget
                removePointersFromTouchTargets(idBitsToAssign);

                // 如果子控件的数量等于0，那么不需要进行遍历只能给viewGroup自己处理
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                    // 使用触控点索引获取触控点位置
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // 从前到后创建view列表
                    final ArrayList&amp;lt;View&amp;gt; preorderedList = buildTouchDispatchChildList();
                    // 这一句判断是否是自定义view顺序
                    final boolean customOrder = preorderedList == null
                        &amp;amp;&amp;amp; isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    
                     // 遍历所有子控件
                    for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                        // 获得真正的索引和子view
                        final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);

                        // 如果是辅助功能事件，则优先给对应的target先处理
                        // 如果该view不处理，再交给其他的view处理
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }

                        // 检查该子view是否可以接受触摸事件和是否在点击的范围内
                        if (!child.canReceivePointerEvents()
                            || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }

                        // 检查该子view是否在touchTarget链表中
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // 链表中已经存在该子view，说明这是一个多点触摸事件
                            // 将新的触控点id绑定到该TouchTarget上
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                                                
                        // 设置取消标志
                        // 下一次再次调用这个方法就会返回true
                        resetCancelNextUpFlag(child);
                        
                        // 找到合适的子view，把事件分发给他，看该子view是否消费了down事件
                        // 如果消费了，需要生成新的TouchTarget
                        // 如果没有消费，说明子view不接受该down事件，继续循环寻找合适的子控件
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // 保存信息
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j &amp;lt; childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            // 保存该view到target链表
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            // 标记已经分发给子view，退出循环
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }

                        // 辅助功能事件对应的targetView没有消费该事件，则继续分发给普通view
                        ev.setTargetAccessibilityFocus(false);
                        
                    }// 这里对应for (int i = childrenCount - 1; i &amp;gt;= 0; i--)
                    
                    if (preorderedList != null) preorderedList.clear();
                    
                }// 这里对应判断：(newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0)

                if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                    // 没有子view接收down事件，直接选择链表尾的view作为target
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }// 这里对应if (actionMasked == MotionEvent.ACTION_DOWN...)
        }// 这里对应if (!canceled &amp;amp;&amp;amp; !intercepted)

        if (mFirstTouchTarget == null) {
            // 经过了前面的处理，到这里touchTarget依旧为null，说明没有找到处理down事件的子控件
            // 或者down事件被viewGroup本身消费了，所以该事件由viewGroup自己处理
            // 这里调用了dispatchTransformedTouchEvent方法来分发事件
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                                                    TouchTarget.ALL_POINTER_IDS);
        } else {
            // 已经有子view消费了down事件
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            // 遍历所有的TouchTarget并把事件分发下去
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                    // 表示事件在前面已经处理了，不需要重复处理
                    handled = true;
                } else {
                    // 正常分发事件或者分发取消事件
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                    // 这里调用了dispatchTransformedTouchEvent方法来分发事件
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                                                      target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    // 如果发送了取消事件，则移除该target
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }

        // 如果接收到取消获取up事件，说明事件序列结束
        // 直接删除所有的TouchTarget
        if (canceled
            || actionMasked == MotionEvent.ACTION_UP
            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // 清除记录的信息
            resetTouchState();
        } else if (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex);
            // 如果仅仅只是一个PONITER_UP
            // 清除对应触控点的触摸信息
            removePointersFromTouchTargets(idBitsToRemove);
        }
        
    }// 这里对应if (onFilterTouchEventForSecurity(ev))

    if (!handled &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;view对于事件的分发&quot;&gt;View对于事件的分发&lt;/h2&gt;
&lt;p&gt;不管是viewGroup自己处理事件，还是view处理事件，如果没有被子类拦截（子类重写方法），最终都会调用到 &lt;code&gt;view.dispatchTouchEvent&lt;/code&gt; 方法来处理事件。view处理事件的逻辑就比viewGroup简单多了，因为它不需要向下去分发事件，只需要自己处理。整体的逻辑如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先判断是否被其他非全屏view覆盖。这和上面viewGroup的安全性检查是一样的&lt;/li&gt;
&lt;li&gt;经过检查之后先检查是否有onTouchListener监听器，如果有则调用它&lt;/li&gt;
&lt;li&gt;如果第2步没有消费事件，那么会调用onTouchEvent方法来处理事件
&lt;ul&gt;&lt;li&gt;这个方法是view处理事件的核心，里面包含了点击、双击、长按等逻辑的处理需要重点关注。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们先看到 &lt;code&gt;view.dispatchTouchEvent&lt;/code&gt; 方法源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;View.java api29
public boolean dispatchTouchEvent(MotionEvent event) {
    // 首先处理辅助功能事件
    if (event.isTargetAccessibilityFocus()) {
        // 本控件没有获取到焦点，不处理事件
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // 获取到焦点，按照常规处理事件
        event.setTargetAccessibilityFocus(false);
    }

    // 表示是否消费事件
    boolean result = false;

    // 一致性检验器，检验事件是否一致
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    } 

    // 如果是down事件，停止嵌套滑动
    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        stopNestedScroll();
    }

    // 安全过滤，本窗口位于非全屏窗口之下时，可能会阻止控件处理触摸事件
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
            // 如果事件为鼠标拖动滚动条
            result = true;
        }
        // 先调用onTouchListener监听器
        // 当我们设置onTouchEventListener之后，L
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        // 若onTouchListener没有消费事件，调用onTouchEvent方法
        if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
            result = true;
        }
    }

    // 一致性检验
    if (!result &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // 如果是事件序列终止事件或者没有消费down事件，终止嵌套滑动
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;amp;&amp;amp; !result)) {
        stopNestedScroll();
    }

    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码内容不长，主要的逻辑内容上面已经讲了，其他的都是一些细节的处理。onTouchListener一般情况下我们是不会使用，那么接下来我们直接看到onTouchEvent方法。&lt;/p&gt;
&lt;p&gt;onTouchEvent总体上就做一件事：&lt;strong&gt;根据按下情况选择触发onClickListener或者onLongClickListener&lt;/strong&gt; ，也就是判断是单击还是长按事件，其他的源码都是实现细节。onTouchEvent方法正确处理每一个事件类型，来确保点击与长按监听器可以被准确地执行。理解onTouchEvent的源码之前，有几个重要的点需要先了解一下。&lt;/p&gt;
&lt;p&gt;我们的操作模式有按键模式、触摸模式。按键模式对应的是外接键盘或者以前的老式键盘机，在按键模式下我们要点击一个按钮通常都是先使用方向光标选中一个button（也就是让该button获取到focus），然后再点击确认按下一个button。但是在触摸模式下，button却不需要获取焦点。&lt;strong&gt;如果一个view在触摸模式下可以获取焦点，那么他将无法响应点击事件，也就是无法调用onClickListener监听器&lt;/strong&gt; ，例如EditText。&lt;/p&gt;
&lt;p&gt;view辨别单击和长按的方法是&lt;strong&gt;设置延时任务&lt;/strong&gt;，在源码中会看到很多的类似的代码，这里延时任务使用handler来实现。当一个down事件来临时，会添加一个延时任务到消息队列中。如果时间到还没有接收到up事件，说明这是个长按事件，那么就会调用onLongClickListener监听器，而如果在延时时间内收到了up事件，那么说明这是个单击事件，取消这个延时的任务，并调用onClickListener。判断是否是一个长按事件，调用的是 &lt;code&gt;checkForLongClick&lt;/code&gt; 方法来设置延时任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 接收四个参数：
// delay:延时的时长；x、y: 触控点的位置；classification：长按类型分类
private void checkForLongClick(long delay, float x, float y, int classification) {
    // 只有是可以长按或者长按会显示工具提示的view才会创建延时任务
    if ((mViewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        // 标志还没触发长按
        // 如果延迟时间到，触发长按监听，这个变量 就会被设置为true
        // 那么当up事件到来时，就不会触摸单击监听，也就是onClickListener
        mHasPerformedLongPress = false;

        // 创建CheckForLongPress
        // 这是一个实现Runnable接口的类，run方法中回调了onLongClickListener
        if (mPendingCheckForLongPress == null) {
            mPendingCheckForLongPress = new CheckForLongPress();
        }
        // 设置参数
        mPendingCheckForLongPress.setAnchor(x, y);
        mPendingCheckForLongPress.rememberWindowAttachCount();
        mPendingCheckForLongPress.rememberPressedState();
        mPendingCheckForLongPress.setClassification(classification);
        // 使用handler发送延时任务
        postDelayed(mPendingCheckForLongPress, delay);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个方法的逻辑还是比较简单的，下面看看 &lt;code&gt;CheckForLongPress&lt;/code&gt; 这个类:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final class CheckForLongPress implements Runnable {
...
    @Override
    public void run() {
        if ((mOriginalPressedState == isPressed()) &amp;amp;&amp;amp; (mParent != null)
                &amp;amp;&amp;amp; mOriginalWindowAttachCount == mWindowAttachCount) {
            recordGestureClassification(mClassification);
            // 在延时时间到之后，就会运行这个任务
            // 调用onLongClickListener监听器
            // 并设置mHasPerformedLongPress为true
            if (performLongClick(mX, mY)) {
                mHasPerformedLongPress = true;
            }
        }
    }
...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;延迟时间结束后，就会运行 &lt;code&gt;CheckForLongPress&lt;/code&gt; 对象，回调onLongClickListener，这样就表示这是一个长按的事件了。&lt;/p&gt;
&lt;p&gt;另外，在默认的情况下，当我们按住一个view，然后手指滑动到该view所在的范围之外，那么系统会认为你对这个view已经不感兴趣，所以无法触发单击和长按事件。当然，很多时候并不是如此，这就需要具体的view来重写onTouchEvent逻辑了，但是view的默认实现是这样的逻辑。&lt;/p&gt;
&lt;p&gt;好了，那么接下来就来看一下完整的 &lt;code&gt;view.onTouchEvent&lt;/code&gt; 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;View.java api29
public boolean onTouchEvent(MotionEvent event) {
    // 获取触控点坐标
    // 这里我们发现他是没有传入触控点索引的
    // 所以默认情况下view是只处理索引为0的触控点
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 判断是否是可点击的
    final boolean clickable = ((viewFlags &amp;amp; CLICKABLE) == CLICKABLE
            || (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

    // 一个被禁用的view如果被设置为clickable，那么他仍旧是可以消费事件的
    if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
            // 如果是按下状态，取消按下状态
            setPressed(false);
        }
        mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
        // 返回是否可以消费事件
        return clickable;
    }
    
    // 如果设置了触摸事件代理你，那么直接调用代理来处理事件
    // 如果代理消费了事件则返回true
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    // 如果该控件是可点击的，或者长按会出现工具提示
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                // 如果是长按显示工具类标志，回调该方法
                if ((viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                // 如果是不可点击的view，同时会清除所有的标志，恢复状态
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                
                // 判断是否是按下状态
                boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // 如果可以获取焦点但是没有获得焦点，请求获取焦点
                    // 正常的触摸模式下是不需要获取焦点，例如我们的button
                    // 但是如果在按键模式下，需要先移动光标选中按钮，也就是获取focus
                    // 再点击确认触摸按钮事件
                    boolean focusTaken = false;
                    if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // 确保用户看到按下状态
                        setPressed(true, x, y);
                    }

                    // 两个参数分别是：长按事件是否已经响应、是否忽略本次up事件
                    if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                        // 这是一个单击事件，还没到达长按的时间，移除长按标志
                        removeLongPressCallback();

                        // 只有不能获取焦点的控件才能触摸click监听
                        if (!focusTaken) {
                            // 这里使用发送到消息队列的方式而不是立即执行onClickListener
                            // 原因在于可以在点击前触发一些其他视觉效果
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }

                    // 取消按下状态
                    // 这里也是个post任务
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // 如果发送到队列失败，则直接取消
                        mUnsetPressedState.run();
                    }

                    // 移除单击标志
                    removeTapCallback();
                }
                // 忽略下次up事件标志设置为false
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                // 输入设备源是否是可触摸屏幕
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                // 标志是否是长按
                mHasPerformedLongPress = false;

                // 如果是不可点击的view，说明是长按提示工具的view
                // 直接检查是否发生了长按
                if (!clickable) {
                    // 这个方法会发送一个延迟的任务
                    // 如果延迟时间到还是按下状态，那么就会回调onLongClickListener接口
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }

                // 判断是否是鼠标右键或者手写笔的第一个按钮
                // 特殊处理直接返回
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // 向上遍历view查看是否在一个可滑动的容器中
                boolean isInScrollingContainer = isInScrollingContainer();

                // 如果在一个可滑动的容器中，那么需要延迟一小会再响应反馈
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    // 利用消息队列来延迟检测一个单击事件，延迟时间是ViewConfiguration.getTapTimeout()
                    // 这个时间是100ms
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // 没有在可滑动的容器中，直接响应触摸反馈
                    // 设置按下状态为true
                    setPressed(true, x, y);
                    checkForLongClick(
                            ViewConfiguration.getLongPressTimeout(),
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                // 取消事件，恢复所有的状态
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                break;

            case MotionEvent.ACTION_MOVE:
                // 通知view和drawable热点改变
                // 暂时不知道什么意思
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture =
                        motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                
                // view已经被设置了长按标志且目前的事件标志是模糊标志
                // 系统并不知道用户的意图，所以即使滑出了view的范围，并不会取消长按标志
                // 而是延长越界的误差范围和检查长按的时间
                // 因为这个时候系统并不知道你是想要长按还是要滑动，结果就是两种行为都没有响应
                // 由你接下来的行为决定
                if (ambiguousGesture &amp;amp;&amp;amp; hasPendingLongPressCallback()) {
                    final float ambiguousMultiplier =
                            ViewConfiguration.getAmbiguousGestureMultiplier();
                    // 判断此时触控点的位置是否还在view的范围内
                    // touchSlop是一个小范围的误差，超出view位置slop距离依旧判定为在view范围内
                    if (!pointInView(x, y, touchSlop)) {
                       // 移除原来的长按标志
                        removeLongPressCallback();
                        // 延长等待时间，这里是原来长按等待的两倍
                        long delay = (long) (ViewConfiguration.getLongPressTimeout()
                                * ambiguousMultiplier);
                        // 减去已经等待的时间
                        delay -= event.getEventTime() - event.getDownTime();
                        // 添加新的长按标志
                        checkForLongClick(
                                delay,
                                x,
                                y,
                                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= ambiguousMultiplier;
                }

                // 判断此时触控点的位置是否还在view的范围内
                // touchSlop是一个小范围的误差，超出view位置slop距离依旧判定为在view范围内
                if (!pointInView(x, y, touchSlop)) {
                    // 如果已经超出范围，直接移除点击标志和长按标志，点击和长按事件均无法响应
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                        // 取消按下标志
                        setPressed(false);
                    }
                    mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                }

                final boolean deepPress =
                        motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                // 表示用户在屏幕上用力按压，加快长按响应速度
                if (deepPress &amp;amp;&amp;amp; hasPendingLongPressCallback()) {
                    // 移除原来的长按标志，直接响应长按事件
                    removeLongPressCallback();
                    checkForLongClick(
                            0 /* 延迟时间为0 */,
                            x,
                            y,
                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }

        return true;
    } // 对应if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) 

    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你能看到这里，说明你对于viewGroup和view的事件处理源码已经了如指掌了。（高兴之余不如给笔者点个赞？(: ~)&lt;/p&gt;
&lt;p&gt;最后这里再来总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;触摸事件，从屏幕产生后，经过系统服务的处理，最终会发送到viewRootImpl来进行分发；&lt;/li&gt;
&lt;li&gt;viewRootImpl会调用它所管理的view的 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; 方法来分发事件，那么这里就会分为两种情况：
&lt;ol&gt;&lt;li&gt;如果是view，那么会直接处理事件&lt;/li&gt;
&lt;li&gt;如果是viewGroup，那么会向下派发事件&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;viewGroup会为每个触控点尽量寻找感兴趣的子view，最后再自己处理事件。viewGroup的任务就是把事件分发按照原则精准地分发给他子view。
&lt;ul&gt;&lt;li&gt;事件分发中一个非常重要的原则就是：一个触控点的事件序列，只能给一个view消费，除了特殊情况，如被viewGroup拦截。&lt;/li&gt;
&lt;li&gt;viewGroup为了践行这个原则，touchTarget的设计是非常重要的；他将view与触控点进行绑定，让一个触控点的事件只会给一个view消费&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;view的 &lt;code&gt;dispatchTouchEvent&lt;/code&gt; 主要内容是处理事件。首先会调用onTouchListener，如果其没有处理则会调用onTouchEvent方法。
&lt;ul&gt;&lt;li&gt;onTouchEvent的默认实现中的主要任务就是辨别单击与长按事件，并回调onClickListener与onLongClickListener&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此本文的内容就结束了，事件分发的整体流程回顾、学了事件分发有什么作用、高频面试题相关文章，将会在后续继续创作。&lt;/p&gt;

&lt;h2 id=&quot;优秀文献&quot;&gt;优秀文献&lt;/h2&gt;
&lt;p&gt;在学习过程中，以下相关资料给了我非常大的帮助，都是非常优秀的文章：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《深入理解android卷Ⅲ》：学习android系统必备，作者对于android系统的理解非常透彻，可以帮助我们认识到最本质的知识，而不是停留在表层。但对于新手可能会比较难以读懂。&lt;/li&gt;
&lt;li&gt;《Android开发艺术探索》：进阶学习android必备，作者讲得比较通俗易懂。深度可能相对而言可能较浅，但对新手比较友好，例如笔者。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.viseator.com/2017/11/02/android_view_event_3/&quot; target=&quot;_blank&quot;&gt;Android 触摸事件分发机制（三）View触摸事件分发机制&lt;/a&gt; : 这篇文章采用拆分源码的思路来讲解源码，更好地吸收源码中的内容，笔者也是借鉴了他的写法来创作本文。文中对于源码的分析非常到位，值得一看。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gcssloop.com/customview/dispatch-touchevent-source&quot; target=&quot;_blank&quot;&gt;安卓自定义View进阶-事件分发机制详解&lt;/a&gt; : 作者言语幽默，通俗易懂，不可多得的好文。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/54136311&quot; target=&quot;_blank&quot;&gt;Android事件分发机制 详解攻略，您值得拥有&lt;/a&gt; : 著名博主carson_Ho的文章。特点是干货满满。全文无废话，只讲重要知识点，适合用来复习知识点。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/09/19/android-touch/&quot; target=&quot;_blank&quot;&gt;Android事件分发机制&lt;/a&gt; : gityuan大佬的博客，对于源码的研究都很深入。但对于一些源码细节并没有做过多的解释，有些地方难以理解。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7.7&quot;&gt;
&lt;p&gt;全文到此，原创不易，觉得有帮助可以点赞收藏评论转发。&lt;br/&gt;笔者才疏学浅，有任何想法欢迎评论区交流指正。&lt;br/&gt;如需转载请评论区或私信交流。&lt;/p&gt;
&lt;p&gt;另外欢迎光临笔者的个人博客：&lt;a href=&quot;https://qwerhuan.gitee.io&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 22 Jan 2021 14:41:00 +0000</pubDate>
<dc:creator>一只修仙的猿</dc:creator>
<og:description>前言 很高兴遇见你~ 在上一篇文章 Android事件分发机制一：事件是如何到达activity的？ 中，我们讨论了触摸信息从屏幕产生到发送给具体 的view处理的整体流程，这里先来简单回顾一下： 触</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huan89/p/14315809.html</dc:identifier>
</item>
<item>
<title>《Go 语言并发之道》读后感 - 第四章 - 尚墨</title>
<link>http://www.cnblogs.com/shangmo/p/14315713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shangmo/p/14315713.html</guid>
<description>&lt;p&gt;约束可以减轻开发者的认知负担以便写出有更小临界区的并发代码。确保某一信息再并发过程中仅能被其中之一的进程进行访问。程序中通常存在两种可能的约束：特定约束和词法约束。&lt;/p&gt;
&lt;h2 id=&quot;特定约束&quot;&gt;特定约束&lt;/h2&gt;
&lt;p&gt;通过公约实现约束，无论是由语言社区、你所在的团队，还是你的代码库设置。在 Go 语言官方默认安装 gofmt 去格式化你的代码，争取让大家都写一样的代码&lt;/p&gt;
&lt;h2 id=&quot;词法约束&quot;&gt;词法约束&lt;/h2&gt;
&lt;p&gt;设计使用词法作用域仅公开用于多个并发进程的正确数据和并发原语，这使得做错事是不可能的，例如：Go 中 goroutine 和 channel ，而不是使用 Thread 包（无论是官方，第三方）。在 Go 的世界里操作系统线程不用程序员管理，需要并发 go 就可以了。&lt;/p&gt;

&lt;p&gt;在 Go 语言中你经常看到 for-select 循环。它的结构类似这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;for{     // 无限循环或者用 range 语句循环
    select {
        // 使用 channel 的任务
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;向-channel-发送数据&quot;&gt;向 channel 发送数据&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;for _,v := range []string{&quot;jisdf&quot;,&quot;jisdf&quot;,&quot;ier&quot;}{
    select {
    case &amp;lt;- done:
        return
    case stringChan &amp;lt;- v:
        // 做些什么
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;循环等待停止&quot;&gt;循环等待停止&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 第一种保持 select 语句尽可能短： 
// 如果完成的 channel 未关闭，我们将退出 select 语句并继续执行 for 循环
for {
    select {
    case &amp;lt;- done:
        return
    default:    
    }
    // 非抢占业务
}

// 第二种将工作嵌入 select 的 default 中
// 如果完成的 channel 尚未关闭，则执行 default 内容的任务
for {
    select {
    case &amp;lt;- done:
        return
    default:
        // 非抢占业务
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;线程安全，是每一个程序员经常讨论的话题。 在 Go 中对应的是 goroutine 协程，虽然 goroutine 开销非常小，非常廉价，但是过多的 goroutine 未得到释放或终止，也是会消耗资源的。goroutine 有以下几种方式被终止：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当它完成了它的工作。&lt;/li&gt;
&lt;li&gt;因为不可恢复的错误，它不能继续工作。&lt;/li&gt;
&lt;li&gt;当它被告知需要终止工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前两种方式非常简单明了，并且隐含在你的程序中。那么我们如何来取消工作？Go 程序在运行时默认会有一个主 goroutine （main goroutine），他会将一些没有工作的 goroutine 设置为自旋，这会导致内存利用率的下降。思考下，既然 main goroutine 能够将其他 goroutine 设置自旋，那么它能不能通知其他 goroutine 停止或退出呢？Of sure ，首先我们需要一个 channel 辅助 main goroutine，它可以包含多种指令，例如超时、异常、特定条件等 。它通常被命名为 done，并且只读。举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;doWork := func(done &amp;lt;- chan int ,s &amp;lt;-chan string) &amp;lt;-chan s{
    terminated := make(chan int)
    go func () {
        // 当前函数 return 后打印一条信息用于验证，for {} 死循环是否被终止
        defer fmt.Println(&quot;doWork exited&quot;)
        defer close(termainted)
        for {
            select {
            case l := &amp;lt;- s:
                fmt.Println(l)
            case &amp;lt;- done: // 由于 select 会相对均匀的挑选 case ，当 done 被读取，则 return 跳出整个并发
                return
            }
        }
    }()
    return terminated
}

// 创建控制并发的 channel done
done := make(chan int)
terminated := doWork(done, &quot;a&quot;)

// 启动一个 goroutine 在 1s 后关闭 done channel
go func() {
    time.Sleep(1 * time.Second)
    fmt.Println(&quot;取消工作的 goroutine&quot;)
    close(done)
}()

// main goroutine 中读出 termainated 中的数据，验证我们是否成功通知工作的 goroutine 终止工作
&amp;lt;- terminated 
fmt.Println(&quot;Done&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个 goroutine 阻塞了向channel 进行写入的请求，我们可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;newRandstream := func(done &amp;lt;-chan interface{}) &amp;lt;- chan int{
    randStream := make(chan int)
    go func(){
        defer fmt.Println(&quot;newRanstream 关闭了&quot;)
        defer close(randStream)
        for{
            select {
            case randStream &amp;lt;- rand.int():
            case &amp;lt;-done:
                return 
            }
        }
    }()
    return
}

done := make(chan interface{})
randStream := newRandStream(done)
fmt.Println(&quot;遍历三次&quot;)
for i := 1; i&amp;lt;=3;i++{
    fmt.Println(&quot;%d: %d\n&quot;,i,&amp;lt;-randStream)
}

close(done)
// 模拟正在进行的工作，暂停 1s
time.Sleap(1 * time.Second)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;以上部分我们了解到单一条件下如何取消 goroutine 防止泄露。如果我们有多种条件触发取消 goroutine ，我们要怎么办呢？让我来了解下 or-channel，创建一个复合 done channel 来处理这种复杂情况。&lt;/p&gt;
&lt;p&gt;我们以使用更多的 goroutine 为代价，实现了简洁性。f(x)=x/2 ，其中 x 是 goroutine 的数量，但你要记住 Go 语言种的一个优点就是能够快速创建，调度和运行 goroutine ，并且该语言积极鼓励使用 goroutine 来正确建模问题。不必担心在这里创建的 goroutine 的数量可能是一个不成熟的优化。此外，如果在编译时你不知道你正在使用多少个 done channel ，则将会没有其他方式可以合并 done channel。&lt;/p&gt;

&lt;p&gt;说到错误处理，也许很多程序程序员觉得 Go 语言错误处理简直太糟糕了。漫天的 &lt;code&gt;if err != nil{}&lt;/code&gt; ，try catch 捕捉并打印错误多么好。我要说首先我们需要注意 Go 的并发模式，与其他语言有着很大的区别。Go 项目开发者希望我们将错误视为一等公民，合并入我们定义的消息体内，channel 中的数据被读出的时候我们进行判断，程序并发过程中是否出现错误。这避免了多进程多线程模型下，try catch 丢失一些报错，在故障回顾的时候非常麻烦。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 建议的消息体
type MyMessage struct{
    Data string
    Err error
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让错误成为一等公民合并进你的结构体中，代码也许会更易懂&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type MyMessage struct{
    N int
    Err error
}
func myfuncation(n string) MyMessage{
    var mm MyMessage
    mm.N,mm.Err = anotherFunc(n)
    return mm
}
func anotherFunc(n string) (int,error){
    i,err := strconv.Atoi(n)
    if err !=nil{
        return i,err
    }
    return i,nil
}
func main(){
    mymsg := myfuncation(&quot;Concurrency In GO&quot;)
    if mymsg.Err != nil{
        // 这里可以换成其他的 log 框架，部分 log 框架会自动识别 error 来源。例如：func (m *MyMessage) myfuncation() 这样的函数就会被抓到错误来自于哪里。
        fmt.Println(mymsg.Err)
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我曾经在祖传代码中见到一个约 2000 行的函数。我希望看见这篇文章的你，不要这么做。我们已经了解了数据如何在两个或多个 goroutine 之间通过 channel 传递，那我我们把这样的程序用多个 channel组合在一起，其中的每一次读出，或写入channel 都是这一环上的一个 stage（步），这就是 pipeline。Go 语言的并发模式，让我们很方便，快捷，安全的在一个进程中实现了流式处理。我们来看一个官方 pipeline 的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;sync&quot;
        &quot;time&quot;
)

func gen(nums ...int) &amp;lt;-chan int {
        genOut := make(chan int)
        go func() {
                for _, n := range nums {
                        genOut &amp;lt;- n
                }
                fmt.Println(&quot;Input gen Channel number =&amp;gt;&quot;, len(genOut))
                close(genOut)
        }()
        return genOut
}

func sq(done &amp;lt;-chan struct{}, in &amp;lt;-chan int) &amp;lt;-chan int {
        sqOut := make(chan int)
        go func() {
                // 这个 close(sqOut) 一定要先写，执行的时候优先压入栈，待函数执行完成关闭 sqOut channel
                defer close(sqOut)
                for n := range in {
            // 利用 select {} 均衡调度 channel 
                        select {
                        case sqOut &amp;lt;- n * n:
                                fmt.Printf(&quot;=&amp;gt; %v &amp;lt;= write into sqOut channel \n&quot;, n*n)
                        case &amp;lt;-done:
                                return
                        }
                }
                //fmt.Printf(&quot;Wait close the chan =&amp;gt; %v\n&quot;, len(sqOut))
        }()
        return sqOut
}

// merge Fan-In 函数合并多个结果
func merge(done &amp;lt;-chan struct{}, cs ...&amp;lt;-chan int) &amp;lt;-chan int {
        var wg sync.WaitGroup
        mergeOut := make(chan int, 1)

        output := func(c &amp;lt;-chan int) {
                defer wg.Done()
                for n := range c {
                        select {
                        case mergeOut &amp;lt;- n:
                        case &amp;lt;-done:
                                return
                        }
                }
        }

        wg.Add(len(cs))

        for _, c := range cs {
                go output(c)
        }

        go func() {
                wg.Wait()
                close(mergeOut)
        }()
        return mergeOut

}

// pfnumber 计算算数平方数
func pfnumber() {
    // 定义 don channel 用于终止 pipeline
        don := make(chan struct{}, 3)
        don &amp;lt;- struct{}{}
        don &amp;lt;- struct{}{}
        close(don)
    // 传入 don 通知发送方停止发送
        for n := range sq(don, sq(don, gen(3, 4, 2))) {
                fmt.Println(&quot;Last result &quot;, n)
        }
        fmt.Println(&quot;============================================&quot;)
}

func fanInOut() {
        don := make(chan struct{}, 3)
        in := gen(2, 3)
        c1 := sq(don, in)
        c2 := sq(don, in)

        for n := range merge(don, c1, c2) {
                fmt.Println(n)
        }

        don &amp;lt;- struct{}{}
        don &amp;lt;- struct{}{}
        don &amp;lt;- struct{}{}
        fmt.Println(&quot;Finish channel len =&amp;gt; &quot;, len(don))
        &amp;lt;-don
        close(don)

}

func f1(i chan int) {
        fmt.Println(&amp;lt;-i)
}

func runf1() {
        out := make(chan int)
        go f1(out)
        time.Sleep(2 * time.Second)
        out &amp;lt;- 2
        time.Sleep(2 * time.Second)
}

func main() {
        //runf1()

        pfnumber()
    // FanIn and FanOut
        //fanInOut()

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单总结一下如何正确构建一个 pipeline:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当所有的发送已完成，stage 应该关闭输出 channel&lt;/li&gt;
&lt;li&gt;stage 应该持续从只读 channel 中读出数据，除非 channel 关闭或主动通知到发送方停止发送&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903864462737415&quot; target=&quot;_blank&quot;&gt;Golang Pipeline Blog 译文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/pipelines&quot; target=&quot;_blank&quot;&gt;Golang Pipeline Blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;扇出模式优先的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它不依赖于之前的 stage 计算的值&lt;/li&gt;
&lt;li&gt;需要运行很长时间，例如：I/O 等待，远程调用，访问 REST full API等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扇入模式优先：&lt;/p&gt;
&lt;p&gt;扇入意味着多个数据流复用或者合并成一个流。例如：上文 pipeline 中的 merge 函数，可以通过打开 fanInOut() 函数执行一下试试。&lt;/p&gt;

&lt;p&gt;在防止 goroutine 泄露，pipeline 中我们都在函数执行过程中嵌入了 done channel 以便终止需要停止的 goroutine。我们可以看出他们有个统一的特点，传入 done ,jobChannel ，返回 resultChannel 。那么我们可以把它封装起来，像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;orDone := func(done ,c &amp;lt;-chan interface{}) &amp;lt;- chan interface{}{
    valStream := make(chan interface{})
    go func(){
        defer close(valStream)
        for {
            select{
            case &amp;lt;- done:
            case v,ok := &amp;lt;- c:
                if ok == false{
                    return
                }
                select{
                case valStream &amp;lt;- v:
                case &amp;lt;-done:
                }
            }
        }
    }()
    return valStream
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可能需要将同一个结果发送给两个接收者，这个时候就需要用到 tee-channel 的方式。&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流量镜像&lt;/li&gt;
&lt;li&gt;操作审计&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;tee := func(done &amp;lt;- chan interface{},in &amp;lt;-chan interface{}
           )(_,_ &amp;lt;- chan interface{}) { &amp;lt;-chan interface{}) {
    out1 := make(chan interface{})
    out2 := make(chan interface{})
    go func(){
        defer close(out1)
        defer close(out2)
        for val := range orDone(done, in){
            var out1,out2 = out1,out2
            for i:=0;i&amp;lt;2; i++{
                select{
                case &amp;lt;- done:
                case out1 &amp;lt;- val:
                    out1 = nil
                case out2 &amp;lt;- val:
                    out2 = nil
                }
            }
        }
    }()
    return out1,out2
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;桥接-channel&quot;&gt;桥接 channel&lt;/h2&gt;
&lt;p&gt;在 channel 中传递 channel 。笔者学术才浅，纸上谈兵多，动手实践少，着实想不到合适的场景，希望读者能为我补充一下。&lt;/p&gt;
&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;p&gt;队列可能是我们第一次看见 channel 的感受，这玩意一个队列，非常具备队列的特性。&lt;/p&gt;
&lt;p&gt;队列在什么样的情况下可以提升整体性能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果在一个 stage 批处理请求可以节省时间。&lt;/li&gt;
&lt;li&gt;需要缓存的场景，例如：批量日志刷盘，热数据缓存等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前文中经常会定义 done channel 的做法，防止 goroutine 泄露，或者主动中断需要停止的 pipeline 。难道我们每次构建 pipeline 的时候都要创建 done channel 吗？答案是否定的，Go 团队为我们准备了 context 包，专用于干类似的工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type Context interface {
    // 当该 context 工作的 work 被取消时，返回超时时间
    Deadline() (deadline time.Time, ok bool)
    // done 返回停止 pipeline 的 channel 
    Done() &amp;lt;chan struct{}
    // error 一等公民。
    // 如果 context 被取消，超时，返回取消，超时的原因，以 error 形式返回。 
    Err() error
    // 返回与此 context 关联的 key
    Value(key interface{}) interface{}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;context 包有两个主要目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供一个可以取消你的调用意图中分支的 API.&lt;/li&gt;
&lt;li&gt;提供用于通过呼叫传输请求范围数据的数据包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 防止 goroutine 泄露中学到，函数中的取消有三个方面，context 包可以帮你管理它：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;goroutine 的父 goroutine 可能想要取消它。&lt;/li&gt;
&lt;li&gt;一个 goroutine 可能想要取消它的子 goroutine。&lt;/li&gt;
&lt;li&gt;goroutine 中任何阻塞操作都必须是可抢占的 ，以便它可以被取消。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Context.Value(key interface{}) ，由于使用 interface{} 作为函数参数，这里我们需要强调一下使用注意事项，及建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虽然可以在 context.Context 中出传递 value，但是并不建议这么做，因为我们需要保证这个值必须是安全的，可以被多个 goroutine 访问。要知道不通的 goroutine 处理逻辑可能是不同的。&lt;/li&gt;
&lt;li&gt;值传递适合在远程 API 调用时使用，请勿在进程内使用。&lt;/li&gt;
&lt;li&gt;数据应该时不可变的。&lt;/li&gt;
&lt;li&gt;使用简单类型，例如：int,float,string 等基础类型。&lt;/li&gt;
&lt;li&gt;数据应该是数据，而不是类型与方法。&lt;/li&gt;
&lt;li&gt;数据应该用于修饰操作，而不是驱动操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第四章可以称之为全书核心章节，它将前面的部分总结归纳，并形成很多的 Go 语言并发技巧讲解，可以帮助我们写出可维护的并发代码。熟悉了这些并发模式，我们可以将多种模式组合，以帮助我们编写大型系统。&lt;/p&gt;
&lt;p&gt;笔者能力优先，才疏学浅，希望读者能够翻阅原书，深入理解并充分运用在工作中。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 14:15:00 +0000</pubDate>
<dc:creator>尚墨</dc:creator>
<og:description>约束 约束可以减轻开发者的认知负担以便写出有更小临界区的并发代码。确保某一信息再并发过程中仅能被其中之一的进程进行访问。程序中通常存在两种可能的约束：特定约束和词法约束。 特定约束 通过公约实现约束，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shangmo/p/14315713.html</dc:identifier>
</item>
<item>
<title>【高并发】ReadWriteLock怎么和缓存扯上关系了？！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14315619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14315619.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在实际工作中，有一种非常普遍的并发场景：那就是读多写少的场景。在这种场景下，为了优化程序的性能，我们经常使用缓存来提高应用的访问性能。因为缓存非常适合使用在读多写少的场景中。而在并发场景中，Java SDK中提供了ReadWriteLock来满足读多写少的场景。本文我们就来说说使用ReadWriteLock如何实现一个通用的缓存中心。&lt;/p&gt;
&lt;p&gt;本文涉及的知识点有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210119200727183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章已收录到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;读写锁&quot;&gt;读写锁&lt;/h2&gt;
&lt;p&gt;说起读写锁，相信小伙伴们并不陌生。总体来说，读写锁需要遵循以下原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个共享变量允许同时被多个读线程读取到。&lt;/li&gt;
&lt;li&gt;一个共享变量在同一时刻只能被一个写线程进行写操作。&lt;/li&gt;
&lt;li&gt;一个共享变量在被写线程执行写操作时，此时这个共享变量不能被读线程执行读操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这里，需要小伙伴们注意的是：读写锁和互斥锁的一个重要的区别就是：读写锁允许多个线程同时读共享变量，而互斥锁不允许。所以，在高并发场景下，读写锁的性能要高于互斥锁。但是，读写锁的写操作是互斥的，也就是说，使用读写锁时，一个共享变量在被写线程执行写操作时，此时这个共享变量不能被读线程执行读操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读写锁支持公平模式和非公平模式，具体是在&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;的构造方法中传递一个boolean类型的变量来控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;另外，需要注意的一点是：在读写锁中，读锁调用newCondition()会抛出UnsupportedOperationException异常，也就是说：读锁不支持条件变量。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;缓存实现&quot;&gt;缓存实现&lt;/h2&gt;
&lt;p&gt;这里，我们使用ReadWriteLock快速实现一个缓存的通用工具类，总体代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReadWriteLockCache&amp;lt;K,V&amp;gt; {
    private final Map&amp;lt;K, V&amp;gt; m = new HashMap&amp;lt;&amp;gt;();
    private final ReadWriteLock rwl = new ReentrantReadWriteLock();
    // 读锁
    private final Lock r = rwl.readLock();
    // 写锁
    private final Lock w = rwl.writeLock();
    // 读缓存
    public V get(K key) {
        r.lock();
        try { return m.get(key); }
        finally { r.unlock(); }
    }
    // 写缓存
    public V put(K key, V value) {
        w.lock();
        try { return m.put(key, value); }
        finally { w.unlock(); }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在ReadWriteLockCache中，我们定义了两个泛型类型，K代表缓存的Key，V代表缓存的value。在ReadWriteLockCache类的内部，我们使用Map来缓存相应的数据，小伙伴都都知道HashMap并不是线程安全的类，所以，这里使用了读写锁来保证线程的安全性，例如，我们在get()方法中使用了读锁，get()方法可以被多个线程同时执行读操作；put()方法内部使用写锁，也就是说，put()方法在同一时刻只能有一个线程对缓存进行写操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意的是：无论是读锁还是写锁，锁的释放操作都需要放到&lt;code&gt;finally{}&lt;/code&gt;代码块中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在以往的经验中，有两种向缓存中加载数据的方式，&lt;strong&gt;一种是：项目启动时，将数据全量加载到缓存中，一种是在项目运行期间，按需加载所需要的缓存数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210119200740440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就分别来看看全量加载缓存和按需加载缓存的方式。&lt;/p&gt;
&lt;h2 id=&quot;全量加载缓存&quot;&gt;全量加载缓存&lt;/h2&gt;
&lt;p&gt;全量加载缓存相对来说比较简单，就是在项目启动的时候，将数据一次性加载到缓存中，这种情况适用于缓存数据量不大，数据变动不频繁的场景，例如：可以缓存一些系统中的数据字典等信息。整个缓存加载的大体流程如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210119200754479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将数据全量加载到缓存后，后续就可以直接从缓存中读取相应的数据了。&lt;/p&gt;
&lt;p&gt;全量加载缓存的代码实现比较简单，这里，我就直接使用如下代码进行演示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReadWriteLockCache&amp;lt;K,V&amp;gt; {
    private final Map&amp;lt;K, V&amp;gt; m = new HashMap&amp;lt;&amp;gt;();
    private final ReadWriteLock rwl = new ReentrantReadWriteLock();
    // 读锁
    private final Lock r = rwl.readLock();
    // 写锁
    private final Lock w = rwl.writeLock();
    
    public ReadWriteLockCache(){
        //查询数据库
        List&amp;lt;Field&amp;lt;K, V&amp;gt;&amp;gt; list = .....;
        if(!CollectionUtils.isEmpty(list)){
            list.parallelStream().forEach((f) -&amp;gt;{
                                m.put(f.getK(), f.getV);
                        });
        }
    }
    // 读缓存
    public V get(K key) {
        r.lock();
        try { return m.get(key); }
        finally { r.unlock(); }
    }
    // 写缓存
    public V put(K key, V value) {
        w.lock();
        try { return m.put(key, value); }
        finally { w.unlock(); }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;按需加载缓存&quot;&gt;按需加载缓存&lt;/h2&gt;
&lt;p&gt;按需加载缓存也可以叫作懒加载，就是说：需要加载的时候才会将数据加载到缓存。具体来说：就是程序启动的时候，不会将数据加载到缓存，当运行时，需要查询某些数据，首先检测缓存中是否存在需要的数据，如果存在，则直接读取缓存中的数据，如果不存在，则到数据库中查询数据，并将数据写入缓存。后续的读取操作，因为缓存中已经存在了相应的数据，直接返回缓存的数据即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210119200806324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种查询缓存的方式适用于大多数缓存数据的场景。&lt;/p&gt;
&lt;p&gt;我们可以使用如下代码来表示按需查询缓存的业务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class ReadWriteLockCache&amp;lt;K,V&amp;gt; {
    private final Map&amp;lt;K, V&amp;gt; m = new HashMap&amp;lt;&amp;gt;();
    private final ReadWriteLock rwl =  new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();
    V get(K key) {
        V v = null;
        //读缓存
        r.lock();        
        try {
            v = m.get(key);
        } finally{
            r.unlock();    
        }
        //缓存中存在，返回
        if(v != null) {  
            return v;
        }  
        //缓存中不存在，查询数据库
        w.lock();     
        try {
                   //再次验证缓存中是否存在数据
            v = m.get(key);
            if(v == null){ 
                //查询数据库
                v=从数据库中查询出来的数据
                m.put(key, v);
            }
        } finally{
            w.unlock();
        }
        return v; 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，在get()方法中，首先从缓存中读取数据，此时，我们对查询缓存的操作添加了读锁，查询返回后，进行解锁操作。判断缓存中返回的数据是否为空，不为空，则直接返回数据；如果为空，则获取写锁，之后再次从缓存中读取数据，如果缓存中不存在数据，则查询数据库，将结果数据写入缓存，释放写锁。最终返回结果数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里，有小伙伴可能会问：为啥程序都已经添加写锁了，在写锁内部为啥还要查询一次缓存呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是因为在高并发的场景下，可能会存在多个线程来竞争写锁的现象。例如：第一次执行get()方法时，缓存中的数据为空。如果此时有三个线程同时调用get()方法，同时运行到 &lt;code&gt;w.lock()&lt;/code&gt;代码处，由于写锁的排他性。此时只有一个线程会获取到写锁，其他两个线程则阻塞在&lt;code&gt;w.lock()&lt;/code&gt;处。获取到写锁的线程继续往下执行查询数据库，将数据写入缓存，之后释放写锁。&lt;/p&gt;
&lt;p&gt;此时，另外两个线程竞争写锁，某个线程会获取到锁，继续往下执行，如果在&lt;code&gt;w.lock()&lt;/code&gt;后没有 &lt;code&gt;v = m.get(key);&lt;/code&gt; 再次查询缓存的数据，则这个线程会直接查询数据库，将数据写入缓存后释放写锁。最后一个线程同样会按照这个流程执行。&lt;/p&gt;
&lt;p&gt;这里，实际上第一个线程已经查询过数据库，并且将数据写入缓存了，其他两个线程就没必要再次查询数据库了，直接从缓存中查询出相应的数据即可。所以，在&lt;code&gt;w.lock()&lt;/code&gt;后添加 &lt;code&gt;v = m.get(key);&lt;/code&gt; 再次查询缓存的数据，能够有效的减少高并发场景下重复查询数据库的问题，提升系统的性能。&lt;/p&gt;
&lt;h2 id=&quot;读写锁的升降级&quot;&gt;读写锁的升降级&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于锁的升降级，小伙伴们需要注意的是：在ReadWriteLock中，锁是不支持升级的，因为读锁还未释放时，此时获取写锁，就会导致写锁永久等待，相应的线程也会被阻塞而无法唤醒。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然不支持锁升级，但是ReadWriteLock支持锁降级，例如，我们来看看官方的ReentrantReadWriteLock示例，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class CachedData {
    Object data;
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    void processCachedData() {
        rwl.readLock().lock();
        if (!cacheValid) {
            // Must release read lock before acquiring write lock
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            try {
                // Recheck state because another thread might have
                // acquired write lock and changed state before we did.
                if (!cacheValid) {
                    data = ...
                    cacheValid = true;
                }
                // Downgrade by acquiring read lock before releasing write lock
                rwl.readLock().lock();
            } finally {
                rwl.writeLock().unlock(); // Unlock write, still hold read
            }
        }

        try {
            use(data);
        } finally {
            rwl.readLock().unlock();
        }
    }
}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据同步问题&quot;&gt;数据同步问题&lt;/h2&gt;
&lt;p&gt;首先，这里说的数据同步指的是数据源和数据缓存之间的数据同步，说的再直接一点，就是数据库和缓存之间的数据同步。&lt;/p&gt;
&lt;p&gt;这里，我们可以采取三种方案来解决数据同步的问题，如下图所示&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210119200821243.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;超时机制&quot;&gt;超时机制&lt;/h3&gt;
&lt;p&gt;这个比较好理解，就是在向缓存写入数据的时候，给一个超时时间，当缓存超时后，缓存的数据会自动从缓存中移除，此时程序再次访问缓存时，由于缓存中不存在相应的数据，查询数据库得到数据后，再将数据写入缓存。&lt;/p&gt;
&lt;p&gt;采用这种方案需要注意缓存的穿透问题，有关缓存穿透、击穿、雪崩的知识，小伙伴们可以参见《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247489193&amp;amp;idx=1&amp;amp;sn=6d8912a62f5fd09c85a3d44a189e7ef9&amp;amp;chksm=cf55a1a8f82228be7c76699df36377e57347249e1d15b48bad9ef15f2497e9254a36b8d24bad&amp;amp;token=456594555&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;【高并发】面试官：讲讲什么是缓存穿透？击穿？雪崩？如何解决？&lt;/a&gt;》&lt;/p&gt;
&lt;h3 id=&quot;定时更新缓存&quot;&gt;定时更新缓存&lt;/h3&gt;
&lt;p&gt;这种方案是超时机制的增强版，在向缓存中写入数据的时候，同样给一个超时时间。与超时机制不同的是，在程序后台单独启动一个线程，定时查询数据库中的数据，然后将数据写入缓存中，这样能够在一定程度上避免缓存的穿透问题。&lt;/p&gt;
&lt;h3 id=&quot;实时更新缓存&quot;&gt;实时更新缓存&lt;/h3&gt;
&lt;p&gt;这种方案能够做到数据库中的数据与缓存的数据是实时同步的，可以使用阿里开源的Canal框架实现MySQL数据库与缓存数据的实时同步。&lt;strong&gt;也可以使用我个人开源的mykit-data框架哦（推荐使用）~~&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;mykit-data开源地址：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信：sun_shine_lyz，我拉你进群，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 13:54:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在实际工作中，有一种非常普遍的并发场景：那就是读多写少的场景。在这种场景下，为了优化程序的性能，我们经常使用缓存来提高应用的访问性能。因为缓存非常适合使用在读多写少的场景中。而在并发场景中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14315619.html</dc:identifier>
</item>
<item>
<title>Spring事务管理 - 笑忘书丶</title>
<link>http://www.cnblogs.com/acknowledge/p/14315547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/acknowledge/p/14315547.html</guid>
<description>&lt;p&gt;Spring的事务管理简化了传统的事务管理流程，提高了开发效率。但是首先先要了解Spring的数据库编程。&lt;/p&gt;
&lt;h2 id=&quot;spring的数据库编程&quot;&gt;Spring的数据库编程&lt;/h2&gt;
&lt;p&gt;数据库编程是互联网编程的基础，Spring框架为开发者提供了JDBC模板模式，即jdbcTemplate，它可以简化许多代码，但在实际应用中jdbcTemplate使用并不常见，在大多数时候都采用Spring结合MyBatis进行开发。在这里，只讲述Spring的jdbcTemplate开发。&lt;/p&gt;
&lt;h3 id=&quot;springjdbc的配置&quot;&gt;SpringJDBC的配置&lt;/h3&gt;
&lt;p&gt;本节Spring数据库编程主要使用的是SpringJDBC模块的core和DataSource包，core是JDBC的核心包，包括常用的JdbcTemplate类，DataSource是访问数据源的工具类包。如果要使用SpringJDBC操作数据库，需要进行配置，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--配置数据源--&amp;gt;
&amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
    &amp;lt;!--Mysql驱动--&amp;gt;
    &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
    &amp;lt;!--连接的url--&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf-8&quot;/&amp;gt;
    &amp;lt;!--用户名密码的配置--&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!--配置JDBC模板--&amp;gt;
&amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述示例中，配置JDBC模板需要将dataSource注入到jdbcTemplate，而在数据访问层（Dao）中需要使用jdbcTemplate时也需要将jdbcTemplate注入到对应的bean中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Repository(&quot;testDao&quot;)
public class TestDaoImpl implements TestDao {
    @Autowired //按照类型注入
    private JdbcTemplate jdbcTemplate;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;jdbctemplate的常用方法&quot;&gt;JDBCTemplate的常用方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;public int update(String sql,Object args[])&lt;/code&gt;：该方法可以对数据表进行增加、修改、删除。使用args[]设置参数，函数返回的是更新的行数。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String insertSQL=&quot;insert into user values(NULL,?,?)&quot;;
Onject param[] = {&quot;chencheng&quot;,&quot;m&quot;};
jdbcTemplate.update(insertSQL,param);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;public List&amp;lt;T&amp;gt; query(String sql,RowMapper&amp;lt;T&amp;gt; rowmapper,Object args[])&lt;/code&gt;：该方法可以对数据表进行查询操作，rowMapper将结果集映射到用户自定义的类中（前提是类的属性名与字段名相同）。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jdbcTemplate.query(sql,new BeanPropertyRowMapper&amp;lt;User&amp;gt;(User.class),param);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;具体的实现步骤&quot;&gt;具体的实现步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建并编辑配置文件applicationContext.xml&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
    &amp;lt;!--指定需要扫描的包--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.ch5&quot;/&amp;gt;
    &amp;lt;!--配置数据源--&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;!--Mysql驱动--&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;!--连接的url--&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf-8&quot;/&amp;gt;
        &amp;lt;!--用户名密码的配置--&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--配置JDBC模板--&amp;gt;
    &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建映射数据库的实体类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5;

public class User {
    private Integer id;
    private String name;
    private double money;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, money=&quot; + money +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建数据库访问层TestDao和TestDaoImpl&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.dao;
import com.ch5.User;
import java.util.List;
public interface TestDao {
    public int update(String sql,Object[] param);
    public List&amp;lt;User&amp;gt; query(String sql,Object[] param);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.dao.Impl;
import com.ch5.User;
import com.ch5.dao.TestDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import java.util.List;
@Repository(&quot;testDao&quot;)
public class TestDaoImpl implements TestDao {
    @Autowired //按照类型注入
    private JdbcTemplate jdbcTemplate;
    @Override
    public int update(String sql, Object[] param) {
        return jdbcTemplate.update(sql,param);
    }
    @Override
    public List&amp;lt;User&amp;gt; query(String sql, Object[] param) {
        return jdbcTemplate.query(sql,new BeanPropertyRowMapper&amp;lt;User&amp;gt;(User.class),param);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;编写测试类JdbcTemplateTest&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.Test;

import com.ch5.User;
import com.ch5.dao.TestDao;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.List;

public class JdbcTemplateTest {
    public static void main(String[] args) {
        ApplicationContext appCo = new ClassPathXmlApplicationContext(&quot;appliationContext.xml&quot;);
        TestDao testDao=(TestDao)appCo.getBean(&quot;testDao&quot;);
        String insertSql=&quot;insert into account values(null,?,?)&quot;;
        Object param[] = {&quot;chencheng&quot;,1050.0};
        testDao.update(insertSql,param);
        String selectSql=&quot;select * from account&quot;;
        List&amp;lt;User&amp;gt; list=testDao.query(selectSql,null);
        for (User user : list) {
            System.out.println(user);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编程式事务管理&quot;&gt;编程式事务管理&lt;/h2&gt;
&lt;p&gt;在代码中显式的调用&lt;code&gt;beginTransaction&lt;/code&gt;、&lt;code&gt;commit&lt;/code&gt;、&lt;code&gt;rollback&lt;/code&gt;等与事务处理相关的方法，这就是编程式事务管理，当只有少数事务操作时，编程式事务管理才比较适合。&lt;/p&gt;
&lt;h3 id=&quot;基于xml的aop实现事务控制&quot;&gt;基于XML的AOP实现事务控制&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;编写事务管理的类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.itheima.utils;
/**
 * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接
 */
public class TransactionManager {
    private ConnectionUtils connectionUtils;
    public void setConnectionUtils(ConnectionUtils connectionUtils) {
        this.connectionUtils = connectionUtils;
    }
    /**
     * 开启事务
     */
    public  void beginTransaction(){
        try {
            connectionUtils.getThreadConnection().setAutoCommit(false);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /**
     * 提交事务
     */
    public  void commit(){
        try {
            connectionUtils.getThreadConnection().commit();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /**
     * 回滚事务
     */
    public  void rollback(){
        try {
            connectionUtils.getThreadConnection().rollback();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    /**
     * 释放连接
     */
    public  void release(){
        try {
            connectionUtils.getThreadConnection().close();//还回连接池中
            connectionUtils.removeConnection();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;配置aop&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 配置事务管理器--&amp;gt;
&amp;lt;bean id=&quot;txManager&quot; class=&quot;com.itheima.utils.TransactionManager&quot;&amp;gt;
    &amp;lt;!-- 注入ConnectionUtils --&amp;gt;
   &amp;lt;property name=&quot;connectionUtils&quot; ref=&quot;connectionUtils&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..)&quot;/&amp;gt;
        &amp;lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&amp;gt;
        &amp;lt;!--配置前置事务，开启事务--&amp;gt;
            &amp;lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;/&amp;gt;
        &amp;lt;!--配置后置事务，提交事务--&amp;gt;
            &amp;lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;/&amp;gt;
        &amp;lt;!--配置异常事务，回滚事务--&amp;gt;
            &amp;lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;/&amp;gt;
        &amp;lt;!--配置最终事务，释放连接--&amp;gt;
            &amp;lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于底层api的编程式事务管理&quot;&gt;基于底层API的编程式事务管理&lt;/h3&gt;
&lt;p&gt;基于底层API的编程式事务管理就是根据&lt;code&gt;PlatformTransactionManager&lt;/code&gt;，&lt;code&gt;TransactionDefinition&lt;/code&gt;和&lt;code&gt;TeansactionStatus&lt;/code&gt;等几个核心接口，通过编程的方式进行事务管理，下面通过一个实例描述底层API的事务管理实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给数据源配置事务管理器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--配置事务管理器--&amp;gt;
&amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建数据访问类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.dao.Impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Repository(&quot;codeTransaction&quot;)
public class CodeTransaction {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Autowired
    private DataSourceTransactionManager transactionManager;
    public String testTransaction(){
        //默认事务定义
        TransactionDefinition definition=new DefaultTransactionDefinition();
        //开启事务
        TransactionStatus transactionStatus = transactionManager.getTransaction(definition);
        String message=&quot;执行成功，没有回滚&quot;;
        try{
            String sql = &quot;delete * from account&quot;;
            String insertSql = &quot;insert into account values(?,?,?)&quot;;
            Object param[] = {&quot;1&quot;,&quot;chenheng&quot;,2000};
            jdbcTemplate.update(sql);
            //id重复,因此发生错误。
            jdbcTemplate.update(insertSql,param);
            jdbcTemplate.update(insertSql,param);
            //提交事务
            transactionManager.commit(transactionStatus);
        }catch (Exception e){
            //出现异常，回滚
            transactionManager.rollback(transactionStatus);
            message=&quot;事务回滚&quot;;
            e.printStackTrace();
        }
        return message;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;定义测试类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.Test;

import com.ch5.dao.Impl.CodeTransaction;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TransactionMangagerTest {
    public static void main(String[] args) {
        ApplicationContext appCo=new ClassPathXmlApplicationContext(&quot;appliationContext.xml&quot;);
        CodeTransaction codeTransaction = (CodeTransaction)appCo.getBean(&quot;codeTransaction&quot;);
        String result = codeTransaction.testTransaction();
        System.out.println(result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于transactiontemplate的编程式事务管理&quot;&gt;基于&lt;code&gt;TransactionTemplate&lt;/code&gt;的编程式事务管理&lt;/h3&gt;
&lt;p&gt;事务处理的代码散落在业务逻辑代码中，破坏了原有代码的条理性，并且每一个事务都会有类似的启动事务，提交以及回滚事务的代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TransactionTemplate&lt;/code&gt;的&lt;code&gt;excute&lt;/code&gt;方法有一个&lt;code&gt;TransactionCallback&lt;/code&gt;接口类型的参数，该接口定义了一个&lt;code&gt;DoInTransaction&lt;/code&gt;的方法，通常以匿名内部类的方式实现&lt;code&gt;TransactionCallback&lt;/code&gt;接口，并在其&lt;code&gt;doInTransaction&lt;/code&gt;方法中写业务逻辑代码。在这里可以使用默认的事务提交和回滚规则，在业务代码中不需要显式调用任何事务处理的API，&lt;code&gt;doInTransaction&lt;/code&gt;方法有一个&lt;code&gt;TransactionStatus&lt;/code&gt;类型的参数，可以在方法的任何位置调用该参数的&lt;code&gt;setRollbackOnly&lt;/code&gt;方法将事务标识为回滚，以执行事务回滚。&lt;/p&gt;
&lt;p&gt;根据默认规则，如果在执行回调方法的过程中抛出未检查异常，或者显式调用了&lt;code&gt;setRollbackOnly&lt;/code&gt;方法，则回滚事务；如果事务执行完成或者抛出了checked类型的异常，则提交事务。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;TransactionTemplate&lt;/code&gt;的编程式事务管理的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为事务管理添加事务模板：在基于底层的API开发的applicationContext.xml配置文件上使用&lt;code&gt;springframwork&lt;/code&gt;提供的&lt;code&gt;org,springframework,transaction.support.TransactionTemplate&lt;/code&gt;类为事务管理器添加事务模板。完整的配置文件如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
    &amp;lt;!--指定需要扫描的包--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.ch5&quot;/&amp;gt;
    &amp;lt;!--配置数据源--&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;!--Mysql驱动--&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;!--连接的url--&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf-8&quot;/&amp;gt;
        &amp;lt;!--用户名密码的配置--&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--配置事务管理器--&amp;gt;
    &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--为事务管理器txManager创建transactionTemplate--&amp;gt;
    &amp;lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--配置JDBC模板--&amp;gt;
    &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建数据访问类&lt;code&gt;TransactionTemplateDao&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
@Repository(&quot;transactionTemplateDao&quot;)
public class TransactionTemplateDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @Autowired
    private TransactionTemplate transactionTemplate;
    String message = &quot;&quot;;
    public String TransactionTemplateTest(){
        //以你命好内部类的方式实现TransactionCallback接口。使用默认的事务规则。
        transactionTemplate.execute(new TransactionCallback&amp;lt;Object&amp;gt;() {
            @Override
            public Object doInTransaction(TransactionStatus status) {
                String insertSql = &quot;insert into account values(?,?,?)&quot;;
                Object param[] = {9,&quot;chen&quot;,5000.0};
                try{
                    jdbcTemplate.update(insertSql,param);
                    jdbcTemplate.update(insertSql,param);
                    message=&quot;执行成功，未回滚&quot;;
                }catch (Exception e){
                    message=&quot;事务回滚&quot;;
                }
                return message;
            }
        });
        return message;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建测试类&lt;code&gt;TransactionTemplateDaoTest&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ch5.Test;

import com.ch5.TransactionTemplateDao;
import com.ch5.dao.Impl.CodeTransaction;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TransactionTemplateDaoTest {
    public static void main(String[] args) {
        ApplicationContext appCo=new ClassPathXmlApplicationContext(&quot;appliationContext.xml&quot;);
        TransactionTemplateDao transactionTemplateDao = appCo.getBean(&quot;transactionTemplateDao&quot;, TransactionTemplateDao.class);
        String result = transactionTemplateDao.TransactionTemplateTest();
        System.out.println(result);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;声明式事务管理&quot;&gt;声明式事务管理&lt;/h2&gt;
&lt;p&gt;Spring的声明式事务管理是通过AOP技术实现的事务管理，其本质是对方法前后拦截，然后再目标方法开始之前创建一个事务，在执行完成后提交或回滚事务。&lt;/p&gt;
&lt;p&gt;与编程式事务管理相比较，声明式事务唯一不足的地方是最细粒度只能作用到方法级别，无法做到像编程式事务管理那样可以作用到代码块级别，但即便有这样的需要，可以通过变通方法进行解决。例如可以将要进行事务处理的代码块单独封装为方法。&lt;/p&gt;
&lt;p&gt;Spring声明式事务管理可以通过两种方式实现，一是基于XML方式，二是基于&lt;code&gt;@Transactional&lt;/code&gt;注解的方式&lt;/p&gt;
&lt;h3 id=&quot;基于xml方式的声明式事务管理&quot;&gt;基于XML方式的声明式事务管理&lt;/h3&gt;
&lt;p&gt;基于XML方式的声明式事务管理是通过在配置文件中配置事务规则的相关声明来实现的。Spring提供了tx命名空间来配置事务管理，提供了&lt;code&gt;&amp;lt;tx:advice&amp;gt;&lt;/code&gt;元素来配置事务的通知，在配置&lt;code&gt;&amp;lt;tx:advice&amp;gt;&lt;/code&gt;时一般要指定id和transaction-manager属性，其中id是配置文件的唯一标识。transaction-manager指定了事务管理器。另外还需要配置&lt;code&gt;&amp;lt;tx:attributes&amp;gt;&lt;/code&gt;子元素，该子元素可配置多个&lt;code&gt;&amp;lt;tx:method&amp;gt;&lt;/code&gt;子元素决定执行事务的细节。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;&amp;lt;tx:advice&amp;gt;&lt;/code&gt;元素配置了事务的增强处理后就可以通过编写AOP配置让Spring自动对目标对象生成代理，下面通过实例演示XML方式让Spring实现声明式事务管理。为了体现事务管理的流程，创建Dao、Service、Controller3层实现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建Dao接口和实现类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.dao;

public interface TestDao {
    public int save(String sql,Object param[]);
    public int delete(String sql,Object param[]);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.dao.Impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import statment.dao.TestDao;
@Repository(&quot;testDao&quot;)
public class TestDaoImpl implements TestDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    public int save(String sql, Object[] param) {
        return jdbcTemplate.update(sql,param);
    }

    public int delete(String sql, Object[] param) {
        return jdbcTemplate.update(sql,param);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建Service接口和实现类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.Service;

public interface TestService {
    public void test();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.Service.Impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import statment.Service.TestService;
import statment.dao.TestDao;
@Service(&quot;testService&quot;)
public class TestServiceImpl implements TestService {
    @Autowired
    private TestDao testDao;

    public void test() {
        String deleteSql=&quot;delete from account&quot;;
        String saveSql=&quot;insert into account values(?,?,?)&quot;;
        Object param[] = {1,&quot;shitji&quot;,5000};
        testDao.delete(deleteSql,null);
        testDao.save(saveSql,param);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建Controller类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import statment.Service.TestService;
@Controller
public class StatementController {
    @Autowired
    private TestService testService;
    public void test(){
        testService.test();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;编写配置文件bean.xml&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;statment&quot;/&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;txManager&quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;tx:method name=&quot;*&quot;/&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;txPonintCut&quot; expression=&quot;execution(* statment.Service.*.*(..))&quot;/&amp;gt;
        &amp;lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;txPonintCut&quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;编写测试类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.Test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import statment.controller.StatementController;
public class XMLTest {
    public static void main(String[] args) {
        ApplicationContext appCo=new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        StatementController controller = appCo.getBean(&quot;statementController&quot;, StatementController.class);
        controller.test();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于注解的声明式事务管理&quot;&gt;基于注解的声明式事务管理&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package statment.Service.Impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import statment.Service.TestService;
import statment.dao.TestDao;
@Service(&quot;testService&quot;)
@Transactional
public class TestServiceImpl implements TestService {
    @Autowired
    private TestDao testDao;

    public void test() {
        String deleteSql=&quot;delete from account&quot;;
        String saveSql=&quot;insert into account values(?,?,?)&quot;;
        Object param[] = {1,&quot;shitji&quot;,5000};
        testDao.delete(deleteSql,null);
        testDao.save(saveSql,param);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;加入&lt;code&gt;@Transactional&lt;/code&gt;，就可以指定这个类需要受到Spring的事务管理，注意该注解只针对public修饰的方法添加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在事务处理中捕获异常&quot;&gt;在事务处理中捕获异常&lt;/h3&gt;
&lt;p&gt;声明式事务处理的流程是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring根据配置完成事务定义，设置事务属性。&lt;/li&gt;
&lt;li&gt;执行开发者的代码逻辑。&lt;/li&gt;
&lt;li&gt;如果开发者的代码产生异常并且满足事务回滚的配置条件，则事务回滚，否则提交事务。&lt;/li&gt;
&lt;li&gt;事务资源释放。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果开发者在代码逻辑中加入&lt;code&gt;try...catch&lt;/code&gt;语句，Spring不能在声明式事务处理中正常执行事务的回滚。原因是Spring只在发生未被捕获的&lt;code&gt;RuntimeException&lt;/code&gt;时才会回滚事务。因此需要处理这种问题。&lt;/p&gt;
&lt;h4 id=&quot;基于xml方式的声明式事务管理中捕获异常&quot;&gt;基于XML方式的声明式事务管理中捕获异常&lt;/h4&gt;
&lt;p&gt;在基于XML方式的声明式事务管理捕获异常，需要补充两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改声明事务的配置&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;tx:method name=&quot;*&quot; rollback-for=&quot;java.lang.Exception&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在catch语句中添加&lt;code&gt;throw new RuntimeException();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;基于注解方式的声明式事务管理中捕获异常&quot;&gt;基于注解方式的声明式事务管理中捕获异常&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;修改注解内容，添加rollbackFor属性&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(rollbackFor = {Exception.class})
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在catch语句中添加&lt;code&gt;throw new RuntimeException();&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 22 Jan 2021 13:39:00 +0000</pubDate>
<dc:creator>笑忘书丶</dc:creator>
<og:description>Spring事务管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/acknowledge/p/14315547.html</dc:identifier>
</item>
<item>
<title>《进击吧！Blazor！》第一章 2.Hello Blazor - MicrosoftReactor</title>
<link>http://www.cnblogs.com/MSReactor/p/14315549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MSReactor/p/14315549.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第二次写专栏，开头还是不知道说什么，所以……先来段广告😁&lt;br/&gt;《进击吧！Blazor！》是本人与张善友老师合作的Blazor零基础入门系列视频，此系列能让一个从未接触过Blazor的程序员掌握开发Blazor应用的能力。&lt;br/&gt;视频地址：https://space.bilibili.com/483888821/channel/detail?cid=151273&lt;br/&gt;本系列文章是基于《进击吧！Blazor！》直播内容编写，升级.Net5，改进问题，讲解更全面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一个教程的第一个Demo都是Hello，巧了，Blazor的默认模板就是一个现成的Hello Blazor，我们就从他的默认模板开始。&lt;/p&gt;

&lt;p&gt;IDE：Visual Studio 16.8&lt;/p&gt;


&lt;ol&gt;&lt;li&gt;选择Blazor应用&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194130379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;580&quot; height=&quot;385&quot;/&gt;&lt;/li&gt;
&lt;li&gt;设置项目名称，这里我取名“BlazorToDo”是因为接下来第一个完整Demo是一个待办事项小程序。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194149777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;582&quot; height=&quot;386&quot;/&gt;&lt;/li&gt;
&lt;li&gt;选择Blazor应用模式，我们接下来开发主要以Blazor WebAssembly App进行。&lt;br/&gt;&lt;code&gt;ASP.NET Core hosted&lt;/code&gt;选项用于控制是否生成带有托管Blazor程序的ASP.NET Core服务端程序，我们勾上。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194250567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;592&quot; height=&quot;410&quot;/&gt;&lt;/li&gt;
&lt;li&gt;我们将&lt;code&gt;BlazorToDo.Server&lt;/code&gt;设为启动项，然后启动，应该能看到&lt;code&gt;Hello, world!&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194338705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;594&quot; height=&quot;325&quot;/&gt;&lt;br/&gt;到这里Hello Blazor项目创建完毕😀&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图是项目结构&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194501201.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;BlazorToDo.Client&lt;/h2&gt;
&lt;p&gt;Blazor项目，本身就是一个Asp.Net Core项目，如果只做前端，就可以直接拿这个项目进行发布和部署。之后我们的分享就围绕着这个项目进行。&lt;/p&gt;
&lt;h3&gt;Program.cs&lt;/h3&gt;
&lt;p&gt;程序入口，这里与Web项目的差异就是Builder使用了WebAssemblyHostBuilder。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; WebAssemblyHostBuilder.CreateDefault(args);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     builder.RootComponents.Add&amp;lt;App&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     builder.Services.AddScoped(sp =&amp;gt; &lt;span&gt;new&lt;/span&gt; HttpClient { BaseAddress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(builder.HostEnvironment.BaseAddress) });
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; builder.Build().RunAsync();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;_Imports.razor&lt;/h3&gt;
&lt;p&gt;全局导入配置，在这里使用&lt;code&gt;using&lt;/code&gt;引入后，相当于在所有&lt;code&gt;razor&lt;/code&gt;文件中都进行了引入。&lt;/p&gt;
&lt;h3&gt;App.razor&lt;/h3&gt;
&lt;p&gt;Blazor的根组件，通过&lt;code&gt;Program.cs&lt;/code&gt;中的&lt;code&gt;builder.RootComponents.Add&amp;lt;App&amp;gt;&lt;/code&gt;进行映射。&lt;/p&gt;
&lt;h3&gt;wwwroot&lt;/h3&gt;
&lt;p&gt;静态文件存放位置，用途和Aps.net core相同，里面的index.html文件就是主页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!--index.html--&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Loading...&amp;lt;/div&amp;gt;

    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blazor-error-ui&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        An unhandled error has occurred.
        &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Reload&amp;lt;/a&amp;gt;
        &amp;lt;a &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dismiss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;🗙&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_framework/blazor.webassembly.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Program.cs&lt;/code&gt;文件中&lt;code&gt;builder.RootComponents.Add&amp;lt;App&amp;gt;(&quot;#app&quot;);&lt;/code&gt;中的选择器&lt;code&gt;#app&lt;/code&gt;必须能在&lt;code&gt;index.html&lt;/code&gt;中找到正确的元素，不然程序无法正常显示。&lt;/p&gt;
&lt;h3&gt;Pages&lt;/h3&gt;
&lt;p&gt;业务组件存放位置，Blazor都是由组件组成的，页面就是含有路由配置的组件。组件文件扩展名&lt;code&gt;razor&lt;/code&gt;，自然使用的是&lt;code&gt;Razor&lt;/code&gt;语法，以&lt;code&gt;Index.razor&lt;/code&gt;文件为例，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@page &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;span&gt;

Welcome to your &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; app.

&lt;/span&gt;&amp;lt;SurveyPrompt Title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How is Blazor working for you?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Razor&lt;/code&gt;语法的使用方法在后续分享中重点介绍，此处就不展开了。&lt;/p&gt;
&lt;h3&gt;Shared&lt;/h3&gt;
&lt;p&gt;共享组件存放位置。&lt;/p&gt;
&lt;h2&gt;BlazorToDo.Server&lt;/h2&gt;
&lt;p&gt;服务端程序，也是一个Asp.Net Core项目，可以用他给前端提供WebAPI，并且承载了Client编译的静态文件，如果我们前后端部署在一起，那么直接发布他即可，这也是结构最简单部署方式。&lt;/p&gt;
&lt;h2&gt;BlazorToDo.Shared&lt;/h2&gt;
&lt;p&gt;共享项目，这就是Blazor相对于其他前端开发解决方案的最大的优势，Blazor的前后端使用了相同的语言、相同的框架和语言规范。因此我们可以把前后端共享的代码放入此项目，比如Dto，常用组件库，相同的业务等&lt;/p&gt;

&lt;h2&gt;Counter.razor&lt;/h2&gt;
&lt;p&gt;点击按钮后数字跳动，效果如下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111194600270.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;下面是&lt;code&gt;Counter.razor&lt;/code&gt;的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@page &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;Current count: @currentCount&amp;lt;/p&amp;gt;

&amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; @onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IncrementCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Click me&amp;lt;/button&amp;gt;&lt;span&gt;

@code {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; currentCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; IncrementCount()
    {
        currentCount&lt;/span&gt;++&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码很简洁，意思如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;声明了变量&lt;code&gt;currentCount&lt;/code&gt;，要在页面上显示可以使用&lt;code&gt;@currentCount&lt;/code&gt;，这里使用@符号从HTML转换为c#。&lt;/li&gt;
&lt;li&gt;html元素&lt;code&gt;button&lt;/code&gt;中我们使用&lt;code&gt;@onclick&lt;/code&gt;捕获事件，让他触发&lt;code&gt;IncrementCount&lt;/code&gt;函数，这个函数中累加&lt;code&gt;currentCount&lt;/code&gt;变量。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于razor语法将来后续分享中重点介绍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我将通过一个ToDo示例介绍路由的工作原理，Blazor组件的页面制作方法。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jan 2021 13:39:00 +0000</pubDate>
<dc:creator>MicrosoftReactor</dc:creator>
<og:description>第二次写专栏，开头还是不知道说什么，所以……先来段广告&amp;#128513;《进击吧！Blazor！》是本人与张善友老师合作的Blazor零基础入门系列视频，此系列能让一个从未接触过Blazor的程序员掌</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MSReactor/p/14315549.html</dc:identifier>
</item>
</channel>
</rss>