<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 中的 ObjectPool 对象重用（一） - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/11974574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/11974574.html</guid>
<description>&lt;blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象池是一种设计模式，一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的对象可以从池中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁他，他是一种特殊的工厂对象。&lt;br/&gt;若初始化、实例化的代价高，且有需求需要经常实例化，但每次实例化的数量较小的情况下，使用对象池可以过得显著的性能提升。从池子中取得对象的时间是可测的，但新建一个实际所需要的时间是不确定的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;对象池的优势&quot;&gt;对象池的优势&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;说到池我们就会联想到很多的概念，如线程池、数据库连接池、内存池等等在多线程设计中可以通过池化机制来进行对象的复用从而提高性能。池的核心优势是 &lt;strong&gt;对象复用&lt;/strong&gt;，这样就免去了对象创建的开销以及回收产生的内容开销，尤其创建对象这是一个很耗时的事情比如IO操作.&lt;br/&gt;拿我们最常见的线程池为例，线程这个对象是可以复用的，程序要执行的任务，这些任务可以交给复用的线程来处理，而线程池创建恰恰又是一个比较耗时的操作，我们通过线程对象的池化技术达到复用线程的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098068/201912/1098068-20191203082347748-1294482853.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;concurrentbag实现对象池&quot;&gt;ConcurrentBag实现对象池&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;池化中需要注意的是多线程中保证线程安全，.NET Framework 4 引入了 System.Collections.Concurrent 命名空间，其中包含多个线程安全且可缩放的集合类。 多个线程可以安全高效地从这些集合添加或删除项，而无需在用户代码中进行其他同步。 编写新代码时，只要将多个线程同时写入到集合时，就使用并发集合类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectPool&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Get方法用于从对象池获取到可用对象，如果对象不可用则创建对象并返回出来&lt;/li&gt;
&lt;li&gt;Return方法用户将对象返回到对象池&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public class ObjectPool&amp;lt;T&amp;gt;
    {
        private ConcurrentBag&amp;lt;T&amp;gt; _object;
        private Func&amp;lt;T&amp;gt; _objectGenerator;

        public ObjectPool(Func&amp;lt;T&amp;gt; objectGenerator) {
            _object = new ConcurrentBag&amp;lt;T&amp;gt;();
            _objectGenerator = objectGenerator;
        }
        /// &amp;lt;summary&amp;gt;
        ///     取出
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public T CheckOut() {
            T item;
            if (_object.TryTake(out item)) return item;
            return _objectGenerator();
        }
        /// &amp;lt;summary&amp;gt;
        ///     归还
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;obj&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public void CheckIn(T obj) {
            _object.Add(obj);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    class Program
    {
        static void Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();

            // Create an opportunity for the user to cancel.
            Task.Run(() =&amp;gt;
            {
                if (Console.ReadKey().KeyChar == 'c' || Console.ReadKey().KeyChar == 'C')
                    cts.Cancel();
            });

            ObjectPool&amp;lt;MyClass&amp;gt; pool = new ObjectPool&amp;lt;MyClass&amp;gt;(() =&amp;gt; new MyClass());

            // Create a high demand for MyClass objects.
            Parallel.For(0, 1000000, (i, loopState) =&amp;gt;
            {
                MyClass mc = pool.CheckOut();
                Console.CursorLeft = 0;
                // This is the bottleneck in our application. All threads in this loop
                // must serialize their access to the static Console class.
                Console.WriteLine(&quot;{0:####.####}&quot;, mc.GetValue(i));

                pool.CheckIn(mc);
                if (cts.Token.IsCancellationRequested)
                    loopState.Stop();

            });
            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);
            Console.ReadLine();
            cts.Dispose();
        }

        class MyClass
        {
            public int[] Nums { get; set; }
            public double GetValue(long i)
            {
                return Math.Sqrt(Nums[i]);
            }
            public MyClass()
            {
                Nums = new int[1000000];
                Random rand = new Random();
                for (int i = 0; i &amp;lt; Nums.Length; i++)
                    Nums[i] = rand.Next();
            }
        }


    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个简单的对象池实现，在实际的场景中还需要考虑最小值，最大值，异常处理等等&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;在创建资源时会消耗一定的系统资源，尤其在及其复杂的结构中效果相对来说是挺明显的，再加上频繁的创建，实例化消耗的资源是很昂贵的.对象池对这些提成是相当有帮助的.&lt;/p&gt;
&lt;p&gt;并非任何情况下都需要使用对象池，在复用生成某种对象的操作成为影响性能因素的时候，才适合采用对象池。如果对象池提成性能提高并不重要的话，还是建议不采用对象池，保持代码简单.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh-cn/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&quot;&gt;https://zh.m.wikipedia.org/zh-cn/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-create-an-object-pool&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/how-to-create-an-object-pool&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 00:24:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>前言 对象池是一种设计模式，一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的对象可以从池中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁他，他是一种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/11974574.html</dc:identifier>
</item>
<item>
<title>关于盘点和总结的那点事儿 - 张飞洪</title>
<link>http://www.cnblogs.com/jackyfei/p/11971685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/11971685.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本月的功能在踉跄中勉强上线了，这个月有实验的味道，有摸索的代价，有分工和衔接上的问题，有技术储备方面的不足，有业务梳理方面的欠缺，也有个人能力和意识上的不足，梳理整个开发流程，目前存在的几大问题：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;描述分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;&lt;strong&gt;1.性能层面&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　从综合维度看，代码质量好坏取决于开发人员整体的编程经验：比如操作系统，设计模式，数据结构和算法，网络原理，数据库，前端等等因素。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　就目前系统整体上看，&lt;strong class=&quot;ql-author-13832613&quot;&gt;性能&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;可能会出现的地方，从优先级权重来排列，主要集中在：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;数据库&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;优化技术偏弱。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;不看执行计划&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;对索引的理解比较浅，没用好索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;SQL优化经验薄弱&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;数据库查询和脚本问题。&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;关联查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;索引缺失&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;请求频率&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;减少&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;请求&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;次数。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;减少接口对数据库请求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;减少前端图片请求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;减少前端css/js请求&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;善用&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;缓存&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;静态文件CDN缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;基础数据共享缓存&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;内容&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;压缩&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;图片压缩&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;请求文件压缩&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;富文本内容压缩&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;主站可能出现的&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;高并发&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;查询。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;网络&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;带宽&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;延迟。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　&lt;strong&gt;　2.规范层面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;命名随意性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　有些规范是可以文档化的。比如全局变量全部大写，局部变量驼峰命名，文件前后缀命名等等比较容易约定俗成；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　有些规范无法约定的。比如作业调度有些人命名jobs，有些人命名schedule。如果要想规范必须把业务考虑进来。如果只是想表达定时作业，属于技术术语job可能比较合适；如果是业务层面的任务调度可能schedule比较合适。也就是说如果碰到模棱两可的命名的时候，需要增加考虑因子，通过扩大“视野”来更精确的命名它。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　如果碰到一个问题始终不清楚要如何命名的时候，首先应该要反省的是自己对业务熟悉不熟悉，对系统整体熟悉不熟悉。如果实在无法确认，最好请教和沟通，一般都能做好命名。说不定能发现一些自己无知的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　如果真的觉得用名字无法描述清楚，言不尽意，模棱两可，那就增加代码注释。代码注释的前提是自解释，实在无法达意才去做注释，因为注释太多也是有成本的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;一致性优先，也就是说一致性是可读性的基础，否则数据库一种命名，业务代码一种命名就是错乱了。比如公司叫Company，但是业务命名叫Supplier，会员叫Member。这里会出现这种不一致的命名，主要原因还是对业务领域不清楚导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　所以在底层命名非常关键，比如数据模型的表和字段的命名，如果底层命名错误，从上下往上只能将错就错，让人改也不是，不改也不是。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　总之，代码命名和给孩子取名字一样，其实都是需要慎之又慎，不可随意叫个阿猫阿狗什么的。这里有个原则就是要遵循：简单，可读，统一和优雅的原则，当然优雅是最高的要求。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;规范不是万能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　规范仅仅写个规范文档是很不够的，写好并持续完善规范文档只是万里长征第一步。只有规范文档，没有落地检查，文档也会变成一纸空文。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　定个原则是比较容易和简单的，如果细细追究，里面有很多坑。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　首先大家对简单，可读，统一的理解各不相同，最后生成的代码必然是千人前面，理论上需要对业务的深入了解，需要有很好的英文功底，同时在整体上要做经常性的检查和复盘。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　但是引入代码审查又需要成本，假设一个月审查一次，那么对每个成员编写的一个月的代码，从月初到月底进行一番梳理和纠正，没有1-2天是无法完成的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　所以审查是有成本的，要不要审查呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　权衡利弊，必须要审查，而且要按照规范，引入严苛的代码审查机制，每个月做一次代码规范和代码质量的检查和考核。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　为什么要严苛来做代码审核呢？因为代码质量反应了我们的产品质量，代码的好坏决定了未来运维的成本，技术债务的危害怎么形容都不为过，轻则系统局部异常，中等的会导致修改困难，严重的推翻重来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　如果因为进度一时妥协，回头又忘记了修改，中间又出现人员变动，那么这份代码的后患是无穷的，因为没有规范的代码，对交接人来说从心态上是本能反抗的，但是又不得不改，于是就一通乱改，能贴膏药就贴膏药，能运行就可以，管他规范不规范。这样导致的结果是对规范来说，只能从不规范走向更加不规范，最后走向无法维护。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;落地解决：&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　&lt;strong&gt;　1.性能层面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;任务分解和文档化&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;磨刀不负砍柴功，开发之前进行技术评估，识别出其中技术复杂度和难度，及早发现性能方面可能会产生的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;把评估的内容逐条分解罗列并做文档化，对容易的功能尽量不要有心态上的藐视。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;遇到没有把握的技术问题，及时的拿出来讨论，不要觉得不好意思。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;数据库层面：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;通过个人持续学习和提高数据库优化技能：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;学会查看执行计划&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;了解索引的底层原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;深入理解关联查询的底层原理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;主站需要生成静态页面进行缓存。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;增加页面静态缓存技术&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;增加CDN技术&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;多研究学习和参考别人写的代码，做好底层的技术沉淀，平时多练练内功。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;通过针对性内部培训来提高个人薄弱环节，让技术均衡发展，又各有特长。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　&lt;strong&gt;2.规范层面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;编写规范的文档，并持续更新和完善&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;严格遵循规范来写代码，如果规范当中没有的，需要适当讨论并做迭代规范。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;按照规范进行代码审查，每个开发人员都参与其中，每隔两周轮流进行代码的检查和盘点。直到团队形成默契，可以在后期适当的减少审查频率。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;基本的规范审查并不难，比如命名，函数的长度等，只要遵循文档来做就可以了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;难的是对没有接触过的技术应该如何做？比如单点登录，路由规则等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;参与前期的需求分析，如果没有则后期自行了解，比如以询问的方式进行了解。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;了解技术评估和技术原理。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;查看当事人的源代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;描述分析：&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;周期：每个月集中到最后一周进行测试和发布时间太紧迫，如果中间缺少交互和确认，很难保证结果不偏离方向。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;人设：测试人员对业务和测试流程缺少前置准备，包括业务的烂熟于心，测试工具和测试数据的知识储备，导致测试时候不知道如何测试，在本来时间不足的情况下，增加沟通成本。同时测试水平只停留在简单浅层的黑盒测试层面，对于深层次的问题，比如压力测试，DDos攻击，安全层面的往往就测试不到了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;功能测试：测试力度远远不足。原因有如下几种：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;边测试边修改边上线，修改速度不及测试速度，导致开发紊乱。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;前期测试重视不够，部分业务理解异常，等到测试出来，修改的周期可能会很长，这样其他积累下来的BUG处理起来就只能长时间等待了……&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;集成测试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;功能分工导致的个人只测试和自己相关的功能，但是系统是一个整体，在测试边界处是需要双方集成测试的，比如Message的来往功能。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;落地&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;解决：&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;周期：改进交付时间，每隔两周就交付测试&lt;span class=&quot;ql-author-13832613&quot;&gt;，增加&lt;span&gt;&lt;strong&gt;交付频率&lt;/strong&gt;&lt;/span&gt;，尽早发现和解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;人设：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;增加测试人员May和Kaka的前期业务培训和接受业务熟练度的考核，减少测试的遗漏。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;增加对测试人员包括开发测试的测试技能培训，提升测试人员的测试水平。比如对测试人员来说，需要学习产品经理的思维和设计原理，增加测试人员的主动性，让测试人员能站在用户的角度来进行测试，而不是简单的鼠标点点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;从心态上重视测试，测试是闭环的最后一个环节，缺一不可。对测试要有敬畏感，测试并不是简单的点一点鼠标的问题，测试的水可深可浅。测试人员需要的是综合能力，测试技能怎么强调都是不为过的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;编写&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;测试用例&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;文档。测试既要有心态上的重视，也要有可落地的操作方法，而测试用例文档可以很好的指导每个测试人员进行统一测试，避免测试的遗漏和不足。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;文档内容涵盖测试的各个维度，该文档编写人员尽量对产品的理解要达到设计人员的水平，对每个角落的测试用例要尽可能详尽。该测试用例模板必须要规范，用来指导开发和测试人员进行完整详尽的测试。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;开发人员内测：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;功能测试：执行交换角色测试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;集成测试：交换角色测试，负责人集中测试。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;描述分析：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　1.业务层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;业务理解不透彻导致的代码BUG，比如Message系统模块，收发人员流程无法打通；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;对数据库模型理解偏差导致的功能BUG，例子同上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;开发任务分工和配合不足；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;开发交付频率不足，导致的过程脱节和问题集中积压，最后处理缓慢和延迟；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;2.技术层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;前端技术积累薄弱，遇到复杂一点的前端做起来比较耗时；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;技术复杂度预估不足，导致的开发延迟。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;分工导致的集成薄弱，比如集成测试，需求和开发沟通成本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;3&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;落地&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;解决：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　&lt;strong&gt;1.业务层面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;业务培训：产品需求文档需要提前发布&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;预热&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;，培训后需要做业务&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;复述&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;，复杂的需要做详细的&lt;strong class=&quot;ql-author-13832613&quot;&gt;设计文档&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;，直到产品经理觉得正确后再进行开发设计。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;对于复杂功能的业务，采用&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;专题会议&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;的方式，反复讨论，进行头脑风暴，把业务掰开揉碎讲清楚，直到当事人能复述通过为止。针对个别复杂的业务，比如公共询盘功能，需要出详细的需求文档。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　&lt;strong&gt;2.技术层面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;前端技术难点：自研解决，实在无法解决再去考虑外包和招聘。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;开发前需要做&lt;span&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;任务分解&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;，识别出技术复杂度，对没有把握的技术要及早提出疑问，通过团队的力量拿出合理的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;功能层面，进行&lt;strong class=&quot;ql-author-13832613&quot;&gt;角色&lt;span&gt;互换测试&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;。比如Arvin测试Ive的Message模块，Ive测试Arvin的机械表单模块。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;以下从三个方面总结一下成员开发过程中的意识问题。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;树立严谨心态&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　对开发来说，各个环节要持有严谨和一丝不苟的态度，树立简单并不简单的意识。对于完成的功能，如果时间上允许，需要反复回头检查可能出现的问题，不要满目乐观，或者觉得某个功能很简单，要站在可能出现问题的立场上来看待正常的功能。因为我们要打造的是产品，而不是项目，不是小孩过家家的功能。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;重构意识&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　好的代码是不断重构出来的，因为业务和需求是不断叠加的，不可能写出一成不变的代码。当业务倍增，需求变革的时候，再好的代码都会出现生锈，腐蚀和坏味道。所以在不忙的时候，需要经常性的整理自己的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;重构解决的是长远的质量和可维护，可扩展的根本问题。技术债务，如果不及时解决，随着时间的推进和人员变动，后续花费的成本会逐渐叠加甚至无法解决，好比盖房子，在有问题的基础上盖房子，盖得越高危险越大，到了晚期可能就只能推倒重建。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;重视讨论&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　三个臭皮匠赛过诸葛亮，技术越讨论越进步，业务越讨论越明白。对于模棱两可或者完全不懂的问题，尽量多请教和讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　讨论的印象是最深刻的，对个人的成长和帮助也是最大的。比如对Vue的学习和上手，对数据库脚本的编写，对ES的学习和讨论等等……&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　树立不懂不丢人，不懂装懂才丢人的意识。不要忌讳或者不好意思讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　讨论讲究效率和默契。要集中时间，充分准备。 有些开发人员经常问些没头没脑的问题，既没有背景铺垫，也没有上下文，然后想一出一个问题，频繁的打断别人的思路而不自知。这种沟通是很浪费时间和成本的。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Dec 2019 00:22:00 +0000</pubDate>
<dc:creator>张飞洪</dc:creator>
<og:description>本月的功能在踉跄中勉强上线了，这个月有实验的味道，有摸索的代价，有分工和衔接上的问题，有技术储备方面的不足，有业务梳理方面的欠缺，也有个人能力和意识上的不足，梳理整个开发流程，目前存在的几大问题： 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackyfei/p/11971685.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 + WebGL 的宇宙(太阳系) 3D 可视化系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/11969545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/11969545.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;近年来随着引力波的发现、黑洞照片的拍摄、火星上存在水的证据发现等科学上的突破，以及文学影视作品中诸如《三体》、《流浪地球》、《星际穿越》等的传播普及，宇宙空间中那些原本遥不可及的事物离我们越来越近，人们对未知文明的关注和对宇宙空间的好奇达到了前所未有的高度。站在更高的立足点上，作为人类这个物种中的一员，我们理所应当对我们生活的星球、所在的太阳系有一定的认识，对 8 大行星各自的运行轨道、质量、资源存储量甚至是地形有一定的了解。&lt;/p&gt;
&lt;p&gt;本系统采用 Hightopo 的 HT for Web 产品来构造轻量化的 3D 可视化场景。&lt;/p&gt;
&lt;p&gt;Solar System 这套系统主要用于两种场景：&lt;/p&gt;
&lt;p&gt;　　1.作为科研成果、新发现的载体，做 3D 太空数据可视化呈现，用于向普通民众科普太阳系的构成、各行星组织结构等知识，可置于博物馆大屏、学校大屏，也可用于互联网产品，作为航空航天类网站的门户页、展示页。&lt;/p&gt;
&lt;p&gt;　　2.作为宇航局、航空航天相关研究机构的驾驶舱，在 3D 可视化界面中对行星相对位置、星体状态、星体气象、星体地形有一个直观快速的了解，在宇宙空间探索越来越成功的当下，在数据传输技术得到速度和质量上的突破后，甚至可以通过该系统对行星状态做实时监控呈现，对宇航员的作业点、作业情况做在线监控。在配置上人造卫星轨道、监控区域的数据后，本系统可用作卫星系统，描述覆盖范围和呈现观测数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预览地址： &lt;a href=&quot;https://www.hightopo.com/demo/solar-system/&quot;&gt;https://www.hightopo.com/demo/solar-system/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;界面简介及效果预览 &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题一：太阳系检测系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202105518082-1149423209.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 本系统主要展示8大行星绕太阳公转轨道、相对位置、星体质量、资源含量等信息。&lt;/p&gt;
&lt;p&gt;右上角行星按钮会触发视角切换，切换至相对应的行星观测点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.g3d.flyTo(data, {
    animation: {
        duration: &lt;/span&gt;1000&lt;span&gt;,
        easing: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (t) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (2-t) *&lt;span&gt; t;
        }
    },
    distance: &lt;/span&gt;2000&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202111127214-413520931.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该主题提供两种视角，鸟瞰和斜视，其它视角可以通过鼠标自行旋转&lt;/p&gt;
&lt;p&gt;两种视角的切换由右上角第二、三个圆形按钮触发。&lt;/p&gt;
&lt;p&gt;调用 moveCamera 方法重新设置相机位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 切换镜头
 * @param {Number} num - 主题编号
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
triggerThemeCamera(num) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.g3d.moveCamera(
        [ &lt;/span&gt;6742.5, 4625.6, -836.7&lt;span&gt;],
        [&lt;/span&gt;0, 0, 0&lt;span&gt;],
        {
            duration: &lt;/span&gt;500&lt;span&gt;,
            easing: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (t) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (2-t) *&lt;span&gt; t;
            }
        }
    );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202111643274-438048643.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;信息框默认采用跟随星体一起旋转，这可以达到俯视视角不出现信息框，看起来更清爽。&lt;/p&gt;
&lt;p&gt;如果需要查看星体详情，可以通过点击右上角播放按钮，该按钮会触发所有信息框朝向屏幕方向。&lt;/p&gt;
&lt;p&gt;通过改变消息面板 style.autorotate 来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setBillboardToCamera(flag) {
    const list &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dm3d.getDatas();
    list.each( item &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Node) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (/_board$/&lt;span&gt;.test(item.getTag())) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
                    item.s(&lt;/span&gt;'shape3d.autorotate', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    item.s(&lt;/span&gt;'shape3d.autorotate', &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202112510175-1284206715.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题二：戴森球星体 3D 拓扑结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202113109604-556350210.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系统主要展示用户所点选的行星与其它星际物质的相互作用，也可用于展示行星周围卫星的分布情况，以及展示星体间引力、辐射范围等的拓扑结构。&lt;/p&gt;
&lt;p&gt;鼠标悬停在一个星体上会触发选中状态，右侧会监控该星体的相关数据。&lt;/p&gt;
&lt;p&gt;通过监听 mousemove 后调用 resetPinkOutside 方法，将粉色边框重新设置到悬停的 node 位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 重新设置边框
 * @param node
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
resetPinkOutside(node) {
    const pinkOutside &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.dm3d.getDataByTag('billboard4'&lt;span&gt;);
    pinkOutside.setPosition3d(node.getPosition3d()[&lt;/span&gt;0],node.getPosition3d()[1],node.getPosition3d()[2&lt;span&gt;]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202114142778-2119091604.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题三：星体气象、地形检测系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202114442311-1008744205.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该主题主要用于呈现在场景二中点选的星体上具体的检测点位，点位周边的等高线在左侧自动生成一个 3D 的地形和闪烁的点位示意，并与右侧的检测点位一一对应。&lt;/p&gt;
&lt;p&gt;该功能可用于地形的呈现，也可以用于星体大气层的气象状态展示。&lt;/p&gt;
&lt;p&gt;左下角实时监控点位的地质热量、气象流动数据。&lt;/p&gt;
&lt;p&gt;点选右侧对应检测点，会触发右侧点的缩放动画，同时左侧对应的 3D 点位也会同步变化，其它的点则调用 setAnimation(null)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setTwinkleToPoints(flag) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (point1_3D &amp;amp;&amp;amp;&lt;span&gt; point1) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.animationFlags.twinklePointNum === 1&lt;span&gt;) {
                point1_3D.setAnimation({
                    change: {},
                    start: [&lt;/span&gt;&quot;change&quot;&lt;span&gt;]
                });
                point1.setAnimation({
                    width: {},
                    height: {},
                    start: [&lt;/span&gt;&quot;width&quot;, &quot;height&quot;&lt;span&gt;]
                });
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                SolarSystem.disableTwinkle(point1_3D, point1);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            SolarSystem.disableTwinkle(point1_3D, point1);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202145356811-15886543.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联：三个主题（系统）的联动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三个系统是互相关联的，相互切换的方式有三种。&lt;/p&gt;
&lt;p&gt;　　1.点选左上角的切换按钮：&lt;/p&gt;
&lt;p&gt;　　左上角部分均为导航栏的响应范围，鼠标悬停时会改变动画控制器 animationFlags 的对应值，触发导航栏落下来，悬停和点选按钮会通过 setImage 方法设置不同的背景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.g2d.getView().addEventListener('mousemove', event =&amp;gt;&lt;span&gt; {
    const node &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.g2d.getDataAt(event);
    let tag &lt;/span&gt;= ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node) {
        tag &lt;/span&gt;=&lt;span&gt; node.getTag();
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;('navigator' ===&lt;span&gt; tag){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.animationFlags.navigatorRotate &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animationFlags.navAnimationDone){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationFlags.navAnimationDone = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationControl(0, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetButtonStyle();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (/^navButton/&lt;span&gt;.test(tag)) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationFlags.navButtonOnHover = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止动画过快导致无法点选按钮&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetButtonStyle();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!node.a('buttonOnClick'&lt;span&gt;)) {
            node.setImage(&lt;/span&gt;'buttonOnHover'&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetButtonStyle();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationFlags.navButtonOnHover = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.animationFlags.navigatorRotate &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animationFlags.navAnimationDone){
            setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animationFlags.navButtonOnHover){
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationFlags.navButtonOnHover = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationFlags.navAnimationDone = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.animationControl(0, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                }
            }, &lt;/span&gt;500&lt;span&gt;);
        }
    }
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202120109144-1555983146.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.点击最下方的标尺栏，分别对应 3 个模块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202120257218-1659066245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3.点选主题一中的行星跳转到的主题二的拓扑结构，点选主题二的星体跳转主题三的地形，主题三无法向前关联，只能通过前两种方式进行跳转：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191202134308830-717474833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该系统使用轻量高效的 ht 库，矢量平面信息与 3D 对象进行关联，并采用 3D 拓扑可视化呈现，相对位置清晰直观，3D 地形与等高线图对应，海拔高度和相互遮挡关系都可以准确把握。&lt;/p&gt;
&lt;p&gt;该系统满足了最基本的太空场景和数据呈现的框架，更为详尽的数据呈现和业务功能有待相关的工作人员根据具体的业务场景提出更详尽的需求。&lt;/p&gt;

</description>
<pubDate>Tue, 03 Dec 2019 00:14:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 近年来随着引力波的发现、黑洞照片的拍摄、火星上存在水的证据发现等科学上的突破，以及文学影视作品中诸如《三体》、《流浪地球》、《星际穿越》等的传播普及，宇宙空间中那些原本遥不可及的事物离我们越来越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/11969545.html</dc:identifier>
</item>
<item>
<title>Java 大黑话讲解设计模式 -- UML类图 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11946754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11946754.html</guid>
<description>&lt;p&gt;前言&lt;br/&gt;关于UML类图的这篇文章，我觉得把它放在设计模式专栏的篇首最为合适，因为在学习设计模式的时候，经常会遇到有关UML类图，没有去专门学过的童鞋肯定会感觉很复杂。学到后面，发现不掌握UML类图，对设计模式或者某一个框架没有整体的把控。所以学好UML类图，你将会更加有自信！&lt;/p&gt;
&lt;p&gt;如果你对类之间的依赖、聚合、关联、组合等关系还很抵制的话，那么这篇文章就很有必要看了，随着对设计模式的慢慢深入了解，或许你也会发现，UML类图就显得格外重要了，是的，UML类图主要是用来描述类之间的轮廓图，而类之间的常见关系就是泛化（Generalization）、实现（Realization）、依赖（Dependence）、关联（Association）、聚合（Aggregation）、组合（Composition）等。类之间关系的强弱：依赖 &amp;lt; 关联 &amp;lt; 聚合 &amp;lt; 组合 &amp;lt; 泛化（继承）&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;h2 id=&quot;啥是uml类图&quot;&gt;1、啥是UML类图？&lt;/h2&gt;
&lt;p&gt;首先来看一个专业一点的定义【来自维基百科】&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;UML即&lt;strong&gt;统一建模语言&lt;/strong&gt;（Unified Modeling Language）,它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不得不说，越专业的描述越让人看得越发懵逼...&lt;/p&gt;
&lt;p&gt;其实吧，简单的说就是UML它也是一种语言，只不过这种语言比较特殊，UML图有很多种，其中最为重要的就是UML类图了，所以我们的重心就是UML类图。uml类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解.&lt;/p&gt;
&lt;h2 id=&quot;uml类图有啥用&quot;&gt;2、UML类图有啥用？&lt;/h2&gt;
&lt;p&gt;这么说吧，2019年11月27号，程序员宜春给程序员老王打电话，两哥们聊着聊着就聊起了设计模式，宜春说了一大堆关于工厂模式的应用场景举例，有场景有实例，可谓声情并茂。然而老王却是听的一脸懵逼：你寻思啥啊，说了一大堆 * 话，别哔哔了，直接给我画上UML类图就得了，一天天的就会装b，我忍你很久了...&lt;/p&gt;
&lt;p&gt;是的，通过上面的这段对话，我相信各位也应该能身临其境的体会到UML类图的核心作用了，那我就不再多哔哔了...&lt;/p&gt;
&lt;h2 id=&quot;正式理解uml类图&quot;&gt;3、正式理解UML类图&lt;/h2&gt;
&lt;p&gt;绝大多数的类图分为三个部分。部分类图有五个部分。我们这里主要讲绝大多数的类图。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127105556866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;UML类图的构建有很多种工具或者插件，可以用PowerDesign 来构建 UML图，当然像我这么优（懒）秀（癌）的人肯定是用idea自带的功能自动生成，同时eclipse也是支持的！&lt;/p&gt;
&lt;h2 id=&quot;使用idea画第一个uml类图&quot;&gt;4、使用idea画第一个UML类图&lt;/h2&gt;
&lt;p&gt;首先去Setting中设置一下UML类图的显示设置，上一节也说过，绝大部分类图都是前三部分，因此勾选前三个勾就OK了，操作如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127111622182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;下面宜春就以身试水用idea来展示一段简单的UML图：&lt;/p&gt;
&lt;p&gt;首先编写一段简单的Weixin类代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class WeiXin{
    public int a;  //公有的public属性  ====1
    private int b; //私有的private属性 ====2
    
    public String WXInfo(){  //成员方法====3
      
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把刚编写的Weixin类进行如下操作：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127111220536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这也忒简单了吧，小白们都笑出声来了。当然也可以在idea中安装一些UML图插件，这里就不再阐述了。&lt;/p&gt;
&lt;h2 id=&quot;类之间的关系图必须牢记&quot;&gt;5、类之间的关系图【必须牢记】&lt;/h2&gt;
&lt;p&gt;UML类图主要是用来描述类之间的轮廓图，而类之间的常见关系就是泛化、实现、依赖、关联、聚合、组合等。表示关系的强弱：依赖 &amp;lt; 关联 &amp;lt; 聚合 &amp;lt; 组合 &amp;lt; 泛化（继承）&lt;/p&gt;
&lt;p&gt;在讲解类之间的关系之前，我们很有必要来了解关系线条图，这个特别重要简直就是UML类图的灵魂&lt;span&gt;【必须牢记】&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127150054872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类之间的关系&quot;&gt;6、类之间的关系&lt;/h2&gt;
&lt;p&gt;有了上面关系线条图的概念后，我们正式开始来学习类之间的关系！&lt;/p&gt;
&lt;h3 id=&quot;依赖&quot;&gt;6.1、依赖&lt;/h3&gt;
&lt;p&gt;依赖关系是类与类之间最弱的关系，B调用A的方法或者属性，A变化会影响B，反之不成立。&lt;span&gt;&lt;strong&gt;依赖&lt;/strong&gt;差不多就是&lt;strong&gt;使用&lt;/strong&gt;的意思&lt;/span&gt;，B使用了A的方法或属性这个时候我们就称为B依赖A。说简单点就是一个类使用了另一个类，这种关系具有临时性特征，一个类的改变由于另一类而受影响。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class A{
    public void methodA(){ }
}

class B{
  public A a;

  public void methodB(){
    a.methodA();
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码： B依赖A&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127161028232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依赖小结：&lt;br/&gt;1、依赖就是类中使用到了对方&lt;br/&gt;2、使用可以包括：使用其成员属性、作为返回类型、作为参数类型、方法中使用到&lt;/p&gt;
&lt;h3 id=&quot;泛化&quot;&gt;6.2、泛化&lt;/h3&gt;
&lt;p&gt;泛化就是继承，注意一点就是泛化也是依赖关系的一种特例&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;6.3、实现&lt;/h3&gt;
&lt;p&gt;实现就是接口的实现，太简单了，小白都笑了....&lt;/p&gt;
&lt;h3 id=&quot;关联&quot;&gt;6.4、关联&lt;/h3&gt;
&lt;p&gt;关联关系是一种比较强的关系，同样也是依赖关系的特例，关联具有导航型：单向关联、双向关联&lt;br/&gt;怎么理解呢，比如有两个类，一个Person类，一个身份证IDcard类&lt;/p&gt;
&lt;p&gt;单向关联&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class IDcard{
}

class Person{
  private IDcard card;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双向关联&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class IDcard{
  private Person person;
}

class Person{
  private IDcard card;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127162005151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;聚合&quot;&gt;6.5、聚合&lt;/h3&gt;
&lt;p&gt;聚合关系是一种特殊的关联关系，聚合关系强调的是整体和部分的关系，其中部分&lt;span&gt;&lt;strong&gt;可以脱离整体而存在&lt;/strong&gt;&lt;/span&gt;。比如电视机和遥控器。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class TV{
}

class Telecontrol{  //遥控器类
  private TV tv;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127164051529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;组合&quot;&gt;6.6、组合&lt;/h3&gt;
&lt;p&gt;组合关系也是一种特殊的关联关系，它与聚合关系很像，组合关系强调的也是整体和部分的关系，其中部分&lt;span&gt;&lt;strong&gt;不可以脱离整体而存在&lt;/strong&gt;&lt;/span&gt;。有种同生共死的意思！比如：高尚的说就是宜春可以没有头发但是不能没有脑袋，可怜一点的说就是宜春可以没有手和脚但是不能没有脑袋！头发、手、脚这些并不是必须要有的，组合强调的是不可分离而可以存在！如果你在大街上看到宜春没有头发，不是很正常嘛？没有手没有脚也能接受理解。那你在大街上看到宜春没有脑袋，这....（这例子举的我自己都服了）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Hair{ //头发
}

class Head{ //脑袋
}

class YiChun{  //宜春
  Head head = new Head(); //Head与宜春同生共死
  private Hair hair;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127165907366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单总结类之间的六种关系&quot;&gt;7、简单总结类之间的六种关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191127150054872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;1、依赖就是类中使用到了对方。使用：使用其成员属性、作为返回类型、作为参数类型、方法中使用到&lt;br/&gt;2、泛化就是继承，泛化也是依赖关系的一种特例&lt;br/&gt;3、实现就是接口的实现，太简单了，小白都笑了....&lt;br/&gt;4、关联是一种比较强的关系，是依赖关系的特例，关联具有导航型：单向关联、双向关联&lt;br/&gt;5、聚合是一种特殊的关联关系，聚合强调整体和部分的关系，可有可无！&lt;br/&gt;6、组合是一种特殊的关联关系，与聚合关系很像，同生共死！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类之间关系的强弱：依赖 &amp;lt; 关联 &amp;lt; 聚合 &amp;lt; 组合 &amp;lt; 泛化（继承）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 00:09:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 关于UML类图的这篇文章，我觉得把它放在设计模式专栏的篇首最为合适，因为在学习设计模式的时候，经常会遇到有关UML类图，没有去专门学过的童鞋肯定会感觉很复杂。学到后面，发现不掌握UML类图，对设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11946754.html</dc:identifier>
</item>
<item>
<title>从BWM生产学习工厂模式 - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/11974171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/11974171.html</guid>
<description>&lt;p&gt;工厂模式应用非常之广，在&lt;code&gt;JDK&lt;/code&gt;底层源码以及各大主流框架中随处可见，一般以&lt;code&gt;Factory&lt;/code&gt;结尾命名的类，比如&lt;code&gt;Mybatis&lt;/code&gt;中的&lt;code&gt;SqlSessionFactory&lt;/code&gt;，&lt;code&gt;Spring&lt;/code&gt;中的&lt;code&gt;BeanFactory&lt;/code&gt;等，都是工厂模式的典型代表。&lt;/p&gt;
&lt;h2 id=&quot;一简单工厂模式&quot;&gt;一、简单工厂模式&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;1.1 概念&lt;/h3&gt;
&lt;p&gt;简单工厂模式又称为静态工厂模式，属于设计模式中的创建型模式。简单工厂模式通过对外提供一个静态方法来统一为类创建实例，目的是实现类与类之间解耦:客户端不需要知道这个对象是如何被穿创建出来的，只需要调用简单工厂模式的方法来统一创建就可以了，从而明确了各个类的职责。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;1.2 示例&lt;/h3&gt;
&lt;p&gt;简单工厂模式，以生产汽车轮胎为例。&lt;/p&gt;
&lt;h4 id=&quot;实体类&quot;&gt;1.2.1 实体类&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;轮胎通用属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Tire {
    /**
     * 通用属性
     */
    private String common;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;奔驰车轮胎&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含通用属性外还有自己的特有属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TireForBenz extends Tire{


    Tire tire;
    /**
     * 特有属性
     */
    private String benz;

    public TireForBenz() {
        this.benz = &quot;得到 Benz 轮胎&quot;;
    }


    @Override
    public String toString() {
        return &quot;[&quot;+this.benz +&quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;宝马车轮胎&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含通用属性外还有自己的特有属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TireForBwm extends Tire{

    Tire tire;

    /**
     * 特有属性
     */
    private String bwm;

    public TireForBwm() {
        this.bwm = &quot;得到 Bwm 轮胎&quot;;
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.bwm +&quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生产工艺&quot;&gt;1.2.2 生产工艺&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;生产轮胎的抽象方法，各个产线有自己的方式生产&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface TireFactory {

    Tire produceTire();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;奔驰汽车轮胎产线&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;重写生产轮胎的方法返回奔驰型轮胎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BenzTireFactory implements TireFactory {

    /**
     * 生产奔驰轮胎
     */
    @Override
    public Tire produceTire() {
        System.out.println(&quot;奔驰轮胎生产中。。。&quot;);
        return new TireForBenz();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;宝马汽车轮胎产线&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;重写生产轮胎的方法返回宝马型轮胎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BwmTireFactory implements TireFactory {

    /**
     * 生产宝马轮胎
     */
    @Override
    public TireForBwm produceTire() {
        System.out.println(&quot;宝马轮胎生产中。。。&quot;);
        return new TireForBwm();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;轮胎工厂类&quot;&gt;1.2.3 轮胎工厂类&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过传入的品牌名称调用相应产线生产相应品牌的轮胎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SimpleFactoryMode {

    public static TireFactory produceCar(String name) {
        if (&quot;BenzTireFactory&quot;.equals(name)) {
            return new BenzTireFactory();
        }
        if (&quot;BwmTireFactory&quot;.equals(name)) {
            return new BwmTireFactory();
        }
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;1.2.4 测试&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;客户端通过工厂类获取实例对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Test
public void simpleFactoryModeTest() {
    // 造奔驰轮胎
    TireFactory benz = SimpleFactoryMode.produceCar(&quot;BenzTireFactory&quot;);
    if (null != benz) {
        benz.produceTire();
    }else {
        System.out.println(&quot;工厂暂时无法生产奔驰轮胎&quot;);
    }
    // 造宝马轮胎
    TireFactory bwm = SimpleFactoryMode.produceCar(&quot;BwmTireFactory&quot;);
    if (null != bwm) {
        bwm.produceTire();
    }else {
        System.out.println(&quot;工厂暂时无法生产宝马轮胎&quot;);
    }
    // 造本田汽轮胎(工厂无该方法)
    TireFactory honda = SimpleFactoryMode.produceCar(&quot;Honda&quot;);
    if (null != honda) {
        honda.produceTire();
    }else {
        System.out.println(&quot;工厂暂时无法生产本田轮胎&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;奔驰轮胎生产中。。。
宝马轮胎生产中。。。
工厂暂时无法生产本田轮胎&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方式确实能完成不同品牌的轮胎生产，但是，有个问题：&lt;strong&gt;方法参数是字符串，可控性有待提升。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单工厂模式优化&quot;&gt;1.3 简单工厂模式优化&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不要通过传入的字符串来判断需要创建对象，而是客户端想要创建什么对象，只需要传入具体的实现类就可以了，然后通过&lt;code&gt;Java&lt;/code&gt;的反射来创建对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static TireFactory produceCar(Class&amp;lt;? extends TireFactory&amp;gt; clazz) {
    try {
        // 通过Java的反射来创建对象
        return clazz.newInstance();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次创建对象都是通过反射来创建的，所以在性能上是有一定的损耗。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void simpleFactoryModeUpgradeTest() {
    // 造奔驰轮胎
    TireFactory benzTire = SimpleFactoryMode.produceCar(BenzTireFactory.class);
    TireForBenz benz = (TireForBenz) benzTire.produceTire();
    System.out.println(benz.toString());
    // 造宝马轮胎
    TireFactory bwmTire = SimpleFactoryMode.produceCar(BwmTireFactory.class);
    TireForBwm bwm = (TireForBwm) bwmTire.produceTire();
    System.out.println(bwm.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;奔驰轮胎生产中。。。
[得到 Benz 轮胎]
宝马轮胎生产中。。。
[得到 Bwm 轮胎]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;1.4 小结&lt;/h3&gt;
&lt;p&gt;简单工厂模式确实在一定程度上实现代码的解耦，而这种解耦的特点在于，这种模式将对象的创建和使用分离。这种模式的本质在于通过一个传入的参数，做&lt;code&gt;if...else&lt;/code&gt;判断，来达到返回不同类型对象的目的。缺点也很明显，不符合&lt;a href=&quot;https://juejin.im/post/5dd67b8ff265da47b60c03fe&quot;&gt;开闭原则&lt;/a&gt;（比如新增一个保时捷轮胎的生产，除了需要增加实体和生产方法，还需要修改工厂类&lt;code&gt;SimpleFactoryMode.java&lt;/code&gt;）。因此，如果需要增加新的类型，就不得不去修改原来的代码，违反开闭原则。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单工厂模式优点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;简单优化了软件体系结构，明确了各自功能模块的职责和权利；&lt;/li&gt;
&lt;li&gt;通过工厂类，外界不需要直接创建具体产品对象，只需要负责消费，不需要关心内部如何创建对象。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;简单工厂模式缺点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;改进前的简单工厂模式全部创建逻辑都集中在一个工厂类中，能创建的类只能是考虑到的，如果需要添加新的类，就必须改变工厂类了;&lt;/li&gt;
&lt;li&gt;改进前的简单工厂模式随着具体产品的不断增多，可能会出现共产类根据不同条件创建不同实例的需求，这种对条件的判断和对具体产品类型的判断交错在一起，很难避免功能模块的蔓延，对系统的维护和扩展不利;&lt;/li&gt;
&lt;li&gt;改进后的简单工厂模式主要是使用反射效率会低一些。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二工厂方法模式&quot;&gt;二、工厂方法模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;简单工厂模式之所以违反开闭原则，关键在于什么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那就是它把所有对象的创建都集中在同一个工厂类里面了，因此，当新增一个新对象时，必然会需要修改这个共享工厂类，违反开闭原则自然不可避免。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然问题关键在于，所有对象的创建都跟这个唯一的工厂类耦合了，那我每个对象各自都配置一个单独的工厂类，这个工厂类只创建各自类型的对象，那这样不就解决耦合的问题了吗？&lt;/p&gt;
&lt;h3 id=&quot;概念-1&quot;&gt;2.1 概念&lt;/h3&gt;
&lt;p&gt;工厂方法模式是指定义一个创建对象的接口，但&lt;strong&gt;让实现这个接口的类来决定实例化哪个类&lt;/strong&gt;。工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，而且加入新的产品符合开闭原则。&lt;/p&gt;
&lt;h3 id=&quot;示例-1&quot;&gt;2.2 示例&lt;/h3&gt;
&lt;p&gt;工厂方法模式，以生产发动机为例。&lt;/p&gt;
&lt;h4 id=&quot;实体&quot;&gt;2.2.1 实体&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;发动机的通用属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Engine {

    /**
     * 型号
     */
    private String common;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;奔驰发动机&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含通用属性外还有自己的特有属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EngineForBenz extends Engine{

    Engine engine;
    /**
     * 特有属性
     */
    private String benz;

    public EngineForBenz() {
        this.benz = &quot;得到 Benz 发动机&quot;;
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.benz +&quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;宝马发动机&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含通用属性外还有自己的特有属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EngineForBwm extends Engine{

    Engine engine;
    /**
     * 特有属性
     */
    private String bwm;

    public EngineForBwm() {
        this.bwm = &quot;得到 Bwm 发动机&quot;;
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.bwm +&quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生产工艺发动机的工厂类&quot;&gt;2.2.2 生产工艺（发动机的工厂类）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;抽象工厂类，定义生产发动机的方法，各个产线自己的去实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface EngineFactory&amp;lt;T&amp;gt; {

    Engine produceEngine();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建奔驰子工厂，实现其的工艺&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BenzEngineFactory implements EngineFactory&amp;lt;EngineForBenz&amp;gt; {

    /**
     * 生产奔驰发动机
     */
    @Override
    public Engine produceEngine() {
        System.out.println(&quot;奔驰发动机生产中。。。&quot;);
        return new EngineForBenz();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建宝马子工厂，实现其的工艺&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BwmEngineFactory implements EngineFactory&amp;lt;EngineForBwm&amp;gt; {

    /**
     * 生产宝马发动机
     */
    @Override
    public Engine produceEngine() {
        System.out.println(&quot;宝马发动机生产中。。。&quot;);
        return new EngineForBwm();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试-1&quot;&gt;2.2.3 测试&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void factoryModeTest() {
    // 造奔驰发动机
    EngineFactory car = new BenzEngineFactory();
    EngineForBenz benz = (EngineForBenz) car.produceEngine();
    System.out.println(benz.toString());
    // 造宝马发动机
    EngineFactory carFactory = new BwmEngineFactory();
    EngineForBwm bwm = (EngineForBwm) carFactory.produceEngine();
    System.out.println(bwm.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;奔驰发动机生产中。。。
[得到 Benz 发动机]
宝马发动机生产中。。。
[得到 Bwm 发动机]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结-1&quot;&gt;2.3 小结&lt;/h3&gt;
&lt;p&gt;工厂方法模式轻松解决了简单工厂模式的问题，符合开闭原则。在上面例子中，当需要新增一个保时捷汽车，此时只需要提供一个对应的&lt;code&gt;EngineForBSJ.java&lt;/code&gt;实现&lt;code&gt;produceEngine()&lt;/code&gt;方法即可，对于原先代码再不需要做任何修改。&lt;/p&gt;
&lt;p&gt;但是每个类型的对象都会有一个与之对应的工厂类。如果对象的类型非常多，意味着会需要创建很多的工厂实现类，造成类数量膨胀，对后续维护带来一些麻烦。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端（应用层）不依赖于产品类实例如何被创建、实现等细节；&lt;/li&gt;
&lt;li&gt;一个类通过其子类来指定创建哪个对象。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;类的个数容易过多，增加复杂度；&lt;/li&gt;
&lt;li&gt;增加了系统的抽象性和理解难度。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三抽象工厂模式&quot;&gt;三、抽象工厂模式&lt;/h2&gt;
&lt;p&gt;抽象工厂模式出现，就是为了解决上述工厂方法模式存在的问题，可以看成是工厂方法模式的升级。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;3.1 背景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;类数量膨胀的情景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;工厂方法模式创建的对象其实归根到底都是同一类对象。以汽车生产为例，无论是轮胎还是发动机，都是汽车生产的一部分，都是属于汽车生产的过程。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/2/16ec756a342065cc?w=797&amp;amp;h=609&amp;amp;f=png&amp;amp;s=22530&quot; alt=&quot;风尘博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图我们可以发现，虽然分为奔驰车和宝马车，但是从工厂方法角度，他们都属于汽车这一类别，这就导致了需要单独为每一个零件指定各自的工厂类，从而导致了类数量膨胀的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然这样，我们可以把每类汽车指定一个工厂，然后再让不同产线去生产他需要的产品，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/3/16ec757205840ab1?w=791&amp;amp;h=609&amp;amp;f=png&amp;amp;s=21730&quot; alt=&quot;风尘博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样当每一类物品组件数量特别多，可以把它称为&lt;strong&gt;产品族&lt;/strong&gt;。抽象工厂模式就是为了创建一系列以产品族为单位的对象，这样在需要创建大量系列对象时可以大大提高开发效率，降低维护成本。&lt;/p&gt;
&lt;h3 id=&quot;示例-2&quot;&gt;3.2 示例&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为奔驰轮胎/宝马轮胎/奔驰发动机/宝马发动机的实体在前面已经创建过，这里就直接用了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;汽车工厂类顶层抽象工厂类&quot;&gt;3.2.1 汽车工厂类(顶层抽象工厂类)&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该类已包含轮胎/发动机生产，具体实体键一/二中相关实体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface CarFactory {

    /**
     * 准备生产
     */
    void init();

    /**
     * 生产轮胎
     * @return
     */
    Tire produceTire();

    /**
     * 生产发动机
     * @return
     */
    Engine produceEngine();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;奔驰汽车产品族奔驰汽车工厂类&quot;&gt;3.2.2 奔驰汽车产品族（奔驰汽车工厂类）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BenzCarFactory implements CarFactory{


    @Override
    public void init() {
        System.out.println(&quot;----------------------- 奔驰汽车准备生产 -----------------------&quot;);
    }

    @Override
    public Tire produceTire() {
        System.out.println(&quot;正在生产奔驰轮胎&quot;);
        return new TireForBenz();
    }

    @Override
    public Engine produceEngine() {
        System.out.println(&quot;正在生产奔驰发动机&quot;);
        return new EngineForBenz();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;宝马汽车产品族宝马汽车工厂类&quot;&gt;3.2.2 宝马汽车产品族（宝马汽车工厂类）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BwmCarFactory implements CarFactory{


    @Override
    public void init() {
        System.out.println(&quot;----------------------- 宝马汽车准备生产 -----------------------&quot;);
    }

    @Override
    public Tire produceTire() {
        System.out.println(&quot;正在生产宝马轮胎&quot;);
        return new TireForBwm();
    }

    @Override
    public Engine produceEngine() {
        System.out.println(&quot;正在生产宝马发动机&quot;);
        return new EngineForBwm();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试-2&quot;&gt;3.2.3 测试&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void abstractFactoryModeTest() {
    // 生产奔驰整车的零部件
    CarFactory benz = new BenzCarFactory();
    benz.init();
    TireForBenz benzTire = (TireForBenz) benz.produceTire();
    System.out.println(benzTire.toString());

    EngineForBenz benzEngine = (EngineForBenz) benz.produceEngine();
    System.out.println(benzEngine.toString());

    // 生成宝马整车的零部件d
    CarFactory bwm = new BwmCarFactory();
    bwm.init();
    TireForBwm bwmTire = (TireForBwm) bwm.produceTire();
    System.out.println(bwmTire.toString());

    EngineForBwm bwmEngine = (EngineForBwm) bwm.produceEngine();
    System.out.println(bwmEngine.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;----------------------- 奔驰汽车准备生产 -----------------------
正在生产奔驰轮胎
[得到 Benz 轮胎]
正在生产奔驰发动机
[得到 Benz 发动机]
----------------------- 宝马汽车准备生产 -----------------------
正在生产宝马轮胎
[得到 Bwm 轮胎]
正在生产宝马发动机
[得到 Bwm 发动机]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;思考&quot;&gt;3.3 思考&lt;/h3&gt;
&lt;p&gt;既然说抽象工厂模式是工厂方法模式的升级，那到底升级了啥？&lt;/p&gt;
&lt;p&gt;其实是&lt;strong&gt;由原来的单一产品的生产升级成为了系列产品的生产&lt;/strong&gt;。设想一下，假设上面汽车的例子中，每一品牌汽车中就只生产一种部件，比如就只生产发动机，不生产轮胎等其他组件了，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/3/16ec757830f58e1f?w=791&amp;amp;h=609&amp;amp;f=png&amp;amp;s=23331&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现了什么没有？&lt;strong&gt;抽象工厂模式居然转变为我们之前讲过的工厂方法模式&lt;/strong&gt;了！换句话说，当你的产品族中只生产一种产品的时候，你的抽象工厂模式其实已经退化为工厂方法模式了。反过来说，当生产多种产品时，工厂方法模式就进化为抽象工厂模式。&lt;/p&gt;
&lt;h3 id=&quot;小结-2&quot;&gt;3.4 小结&lt;/h3&gt;
&lt;p&gt;抽象工厂模式在创建大量系列对象时可以大大提高开发效率，就是为生产产品族而生的，而对于生产单一产品却无能为力。&lt;/p&gt;
&lt;p&gt;如果需要添加一个新的产品族，那就简单了，比如新增一个保时捷汽车，那就只需要添加一个保时捷汽车的工厂实现类就好了，并不会对原有的代码造成任何影响。&lt;/p&gt;
&lt;p&gt;但是，如果假设在汽车中，我需要再加一个组件，比如倒车影像，怎么操作？你需要在&lt;code&gt;CarFactory&lt;/code&gt;接口中添加返回倒车影像对象的接口。这一加不得了了......&lt;strong&gt;所有品牌汽车实现类全部需要修改并追加该方法的实现，违反了开闭原则&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象工厂模式优点：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建大量系列对象时可以大大提高开发效率，降低维护成本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象工厂模式缺点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；&lt;/li&gt;
&lt;li&gt;增加了系统的抽象性和理解难度。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;h3 id=&quot;如何选择&quot;&gt;4.1 如何选择&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;工厂模式的三种形式都介绍完了，那我们实际开发中该如何去选择呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;从设计原则来说，简单工厂模式不符合开闭原则。但是很神奇，在实际场景中，简单工厂模式确实用的最多的。&lt;/li&gt;
&lt;li&gt;工厂方法模式是专门用于解决单个对象创建工作，本身模式没问题，也符合开闭原则。但是存在工厂类数量膨胀的问题。如果需要创建的工厂类不是很多，是一种不错的选择。&lt;/li&gt;
&lt;li&gt;抽象工厂模式天生就是为生产产品族而生的。所以如果你需要创建的对象非常之多，但是对象之间存在明显产品族特征，那么这个时候用抽象工厂模式非常合适。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;示例源码&quot;&gt;4.2 示例源码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vanDusty/Design-Patterns/tree/master/factory-demo&quot;&gt;Github 示例代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;技术交流&quot;&gt;4.3 技术交流&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.dustyblog.cn&quot;&gt;风尘博客：https://www.dustyblog.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/user/5d5ea68e6fb9a06afa328f56/posts&quot;&gt;风尘博客-掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/vandusty/&quot;&gt;风尘博客-博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vanDusty&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;公众号&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/21/16e8dd90c8c749be?w=400&amp;amp;h=400&amp;amp;f=png&amp;amp;s=15087&quot; alt=&quot;风尘博客&quot;/&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dujunchen/Duava/blob/master/DesignPatterns/articles/%E8%AE%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF%7C%E2%91%A2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 03 Dec 2019 00:06:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>工厂模式应用非常之广，在 底层源码以及各大主流框架中随处可见，一般以 结尾命名的类，比如 中的 ，`Spring BeanFactory`等，都是工厂模式的典型代表。 一、简单工厂模式 1.1 概念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/11974171.html</dc:identifier>
</item>
<item>
<title>SpringSecurity代码实现JWT接口权限授予与校验 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11974554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11974554.html</guid>
<description>&lt;p&gt;通过笔者前两篇文章的说明，相信大家已经知道JWT是什么，怎么用，该如何结合Spring Security使用。那么本节就用代码来具体的实现一下JWT登录认证及鉴权的流程。&lt;/p&gt;
&lt;h2 id=&quot;一环境准备工作&quot;&gt;一、环境准备工作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;建立Spring Boot项目并集成了Spring Security，项目可以正常启动&lt;/li&gt;
&lt;li&gt;通过controller写一个HTTP的GET方法服务接口，比如：“/hello”&lt;/li&gt;
&lt;li&gt;实现最基本的动态数据验证及权限分配，即实现UserDetailsService接口和UserDetails接口。这两个接口都是向Spring Security提供用户、角色、权限等校验信息的接口&lt;/li&gt;
&lt;li&gt;如果你学习过Spring Security的formLogin登录模式，请将HttpSecurity配置中的formLogin()配置段全部去掉。因为JWT完全使用JSON接口，没有from表单提交。&lt;/li&gt;
&lt;li&gt;HttpSecurity配置中一定要加上csrf().disable()，即暂时关掉跨站攻击CSRF的防御。这样是不安全的，我们后续章节再做处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上的内容，我们在之前的文章中都已经讲过。如果仍然不熟悉，可以翻看本号之前的文章。&lt;/p&gt;
&lt;p&gt;## 二、开发JWT工具类&lt;br/&gt;通过maven坐标引入JWT工具包jjwt&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在application.yml中加入如下自定义一些关于JWT的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jwt: 
  header: JWTHeaderName
  secret: aabbccdd  
  expiration: 3600000   &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中header是携带JWT令牌的HTTP的Header的名称。虽然我这里叫做JWTHeaderName，但是在实际生产中可读性越差越安全。&lt;/li&gt;
&lt;li&gt;secret是用来为JWT基础信息加密和解密的密钥。虽然我在这里在配置文件写死了，但是在实际生产中通常不直接写在配置文件里面。而是通过应用的启动参数传递，并且需要定期修改。&lt;/li&gt;
&lt;li&gt;expiration是JWT令牌的有效时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;写一个Spring Boot配置自动加载的工具类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@ConfigurationProperties(prefix = &quot;jwt&quot;)    //配置自动加载，prefix是配置的前缀
@Component
public class JwtTokenUtil implements Serializable {

    private String secret;
    private Long expiration;
    private String header;


    /**
     * 生成token令牌
     *
     * @param userDetails 用户
     * @return 令token牌
     */
    public String generateToken(UserDetails userDetails) {
        Map&amp;lt;String, Object&amp;gt; claims = new HashMap&amp;lt;&amp;gt;(2);
        claims.put(&quot;sub&quot;, userDetails.getUsername());
        claims.put(&quot;created&quot;, new Date());
        return generateToken(claims);
    }

    /**
     * 从令牌中获取用户名
     *
     * @param token 令牌
     * @return 用户名
     */
    public String getUsernameFromToken(String token) {
        String username;
        try {
            Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        } catch (Exception e) {
            username = null;
        }
        return username;
    }

    /**
     * 判断令牌是否过期
     *
     * @param token 令牌
     * @return 是否过期
     */
    public Boolean isTokenExpired(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(new Date());
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * 刷新令牌
     *
     * @param token 原令牌
     * @return 新令牌
     */
    public String refreshToken(String token) {
        String refreshedToken;
        try {
            Claims claims = getClaimsFromToken(token);
            claims.put(&quot;created&quot;, new Date());
            refreshedToken = generateToken(claims);
        } catch (Exception e) {
            refreshedToken = null;
        }
        return refreshedToken;
    }

    /**
     * 验证令牌
     *
     * @param token       令牌
     * @param userDetails 用户
     * @return 是否有效
     */
    public Boolean validateToken(String token, UserDetails userDetails) {
        SysUser user = (SysUser) userDetails;
        String username = getUsernameFromToken(token);
        return (username.equals(user.getUsername()) &amp;amp;&amp;amp; !isTokenExpired(token));
    }


    /**
     * 从claims生成令牌,如果看不懂就看谁调用它
     *
     * @param claims 数据声明
     * @return 令牌
     */
    private String generateToken(Map&amp;lt;String, Object&amp;gt; claims) {
        Date expirationDate = new Date(System.currentTimeMillis() + expiration);
        return Jwts.builder().setClaims(claims)
                            .setExpiration(expirationDate)
                            .signWith(SignatureAlgorithm.HS512, secret)
                            .compact();
    }

    /**
     * 从令牌中获取数据声明,如果看不懂就看谁调用它
     *
     * @param token 令牌
     * @return 数据声明
     */
    private Claims getClaimsFromToken(String token) {
        Claims claims;
        try {
            claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
        } catch (Exception e) {
            claims = null;
        }
        return claims;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就是使用io.jsonwebtoken.jjwt提供的方法开发JWT令牌生成、刷新的工具类。&lt;/p&gt;
&lt;h2 id=&quot;三开发登录接口获取token的接口&quot;&gt;三、开发登录接口（获取Token的接口）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&quot;/authentication&quot;接口用于登录验证，并且生成JWT返回给客户端&lt;/li&gt;
&lt;li&gt;&quot;/refreshtoken&quot;接口用于刷新JWT，更新JWT令牌的有效期&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@RestController
public class JwtAuthController {

    @Resource
    private JwtAuthService jwtAuthService;

    @PostMapping(value = &quot;/authentication&quot;)
    public AjaxResponse login(@RequestBody Map&amp;lt;String, String&amp;gt; map) {
        String username = map.get(&quot;username&quot;);
        String password = map.get(&quot;password&quot;);
        if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) {
            return AjaxResponse.error(
                new CustomException(CustomExceptionType.USER_INPUT_ERROR,&quot;用户名密码不能为空&quot;));
        }
        return AjaxResponse.success(jwtAuthService.login(username, password));
    }

    @PostMapping(value = &quot;/refreshtoken&quot;)
    public AjaxResponse refresh(@RequestHeader(&quot;${jwt.header}&quot;) String token) {
        return AjaxResponse.success(jwtAuthService.refreshToken(token));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心的token业务逻辑写在JwtAuthService 中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;login方法中首先使用用户名、密码进行登录验证。如果验证失败抛出BadCredentialsException异常。如果验证成功，程序继续向下走，生成JWT响应给前端&lt;/li&gt;
&lt;li&gt;refreshToken方法只有在JWT token没有过期的情况下才能刷新，过期了就不能刷新了。需要重新登录。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Service
public class JwtAuthService {
    @Resource
    private AuthenticationManager authenticationManager;
    @Resource
    private UserDetailsService userDetailsService;
    @Resource
    private JwtTokenUtil jwtTokenUtil;

    public String login(String username, String password) {
        //使用用户名密码进行登录验证
        UsernamePasswordAuthenticationToken upToken = 
                    new UsernamePasswordAuthenticationToken( username, password );
        Authentication authentication = authenticationManager.authenticate(upToken);  
        SecurityContextHolder.getContext().setAuthentication(authentication);
        //生成JWT
        UserDetails userDetails = userDetailsService.loadUserByUsername( username );
        return jwtTokenUtil.generateToken(userDetails);
    }

    public String refreshToken(String oldToken) {
        if (!jwtTokenUtil.isTokenExpired(oldToken)) {
            return jwtTokenUtil.refreshToken(oldToken);
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用到了AuthenticationManager ,所以在继承WebSecurityConfigurerAdapter的SpringSecurity配置实现类中，将AuthenticationManager 声明为一个Bean。并将&quot;/authentication&quot;和 &quot;/refreshtoken&quot;开放访问权限，如何开放访问权限，我们之前的文章已经讲过了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Bean(name = BeanIds.AUTHENTICATION_MANAGER)
@Override
public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四接口访问鉴权过滤器&quot;&gt;四、接口访问鉴权过滤器&lt;/h2&gt;
&lt;p&gt;当用户第一次登陆之后，我们将JWT令牌返回给了客户端，客户端应该将该令牌保存起来。在进行接口请求的时候，将令牌带上，放到HTTP的header里面，header的名字要和jwt.header的配置一致，这样服务端才能解析到。下面我们定义一个拦截器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拦截接口请求，从请求request获取token，从token中解析得到用户名&lt;/li&gt;
&lt;li&gt;然后通过UserDetailsService获得系统用户（从数据库、或其他其存储介质）&lt;/li&gt;
&lt;li&gt;根据用户信息和JWT令牌，验证系统用户与用户输入的一致性，并判断JWT是否过期。如果没有过期，至此表明了该用户的确是该系统的用户。&lt;/li&gt;
&lt;li&gt;但是，你是系统用户不代表你可以访问所有的接口。所以需要构造UsernamePasswordAuthenticationToken传递用户、权限信息，并将这些信息通过authentication告知Spring Security。Spring Security会以此判断你的接口访问权限。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;@Slf4j
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Resource
    private MyUserDetailsService userDetailsService;

    @Resource
    private JwtTokenUtil jwtTokenUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
    
       // 从这里开始获取 request 中的 jwt token
        String authHeader = request.getHeader(jwtTokenUtil.getHeader());
        log.info(&quot;authHeader：{}&quot;, authHeader);
        // 验证token是否存在
        if (authHeader != null &amp;amp;&amp;amp; StringUtils.isNotEmpty(authHeader)) {
           // 根据token 获取用户名
            String username = jwtTokenUtil.getUsernameFromToken(authHeader);
            if (username != null &amp;amp;&amp;amp; SecurityContextHolder.getContext().getAuthentication() == null) {
                // 通过用户名 获取用户的信息
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                
                // 验证JWT是否过期
                if (jwtTokenUtil.validateToken(authHeader, userDetails)) {
                    //加载用户、角色、权限信息，Spring Security根据这些信息判断接口的访问权限
                    UsernamePasswordAuthenticationToken authentication 
                            = new UsernamePasswordAuthenticationToken(userDetails, null, 
                                                                      userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource()
                                            .buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在spring Security的配置类（即WebSecurityConfigurerAdapter实现类的configure(HttpSecurity http)配置方法中，加入如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.sessionManagement()
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
    .and()
.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;因为我们使用了JWT，表明了我们的应用是一个前后端分离的应用，所以我们可以开启STATELESS禁止使用session。当然这并不绝对，前后端分离的应用通过一些办法也是可以使用session的，这不是本文的核心内容不做赘述。&lt;/li&gt;
&lt;li&gt;将我们的自定义jwtAuthenticationTokenFilter，加载到UsernamePasswordAuthenticationFilter的前面。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五测试一下&quot;&gt;五、测试一下：&lt;/h2&gt;
&lt;p&gt;测试登录接口，即：获取token的接口。输入正确的用户名、密码即可获取token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191203075402956-794523188.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们访问一个我们定义的简单的接口“/hello”,但是不传递JWT令牌，结果是禁止访问。当我们将上一步返回的token，传递到header中，就能正常响应hello的接口结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191203075403195-621342826.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Mon, 02 Dec 2019 23:54:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>通过笔者前两篇文章的说明，相信大家已经知道JWT是什么，怎么用，该如何结合Spring Security使用。那么本节就用代码来具体的实现一下JWT登录认证及鉴权的流程。 一、环境准备工作 建立Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11974554.html</dc:identifier>
</item>
<item>
<title>软件工程六大设计原则总结，案例演示 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/11974550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/11974550.html</guid>
<description>&lt;blockquote readability=&quot;1.8269230769231&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/model-arithmetic-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/model-arithmetic-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对类来说的，即一个类应该只负责一项职责。如果一个类负责两个职责，可能存在职责1变化，引起职责2变化的情况。可以基于抽象逻辑，或者业务逻辑对类进行细化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里基于方法和类的细化都可以，可以根据实际业务选择。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Animal {
    public void dogVoice (){
        System.out.println(&quot;狗叫声：旺旺&quot;);
    }
    public void cowVoice (){
        System.out.println(&quot;牛叫声：哞哞&quot;);
    }
}
class DogVoice {
    public String getDogVoice (){
        return &quot;旺旺&quot; ;
    }
}
class CowVoice {
    public String getCowVoice (){
        return &quot;哞哞&quot; ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;减少代码一处变更引起的程序大规模改动情况，降低类的复杂度，提高类的可读性，可维护性。通常情况下，需要遵守单一职责原则，可以适当违反单一职责原则。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;客户端不应该依赖它不需要的接口，一个类对另一个类的依赖，应该建立在最小的接口上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface ReadBlog {
    String getBlog () ;
}
interface AdminBlog {
    Boolean insertBlog () ;
    Boolean updateBlog () ;
    Boolean deleteBlog () ;
}
/**
 * 读者只开放博客阅读接口
 */
class Reader implements ReadBlog {
    @Override
    public String getBlog() {
        return null;
    }
}
/**
 * 管理员有博客全部的管理权限
 */
class AdminUser implements AdminBlog,ReadBlog {
    @Override
    public String getBlog() {
        return null;
    }
    @Override
    public Boolean insertBlog() {
        return null;
    }
    @Override
    public Boolean updateBlog() {
        return null;
    }
    @Override
    public Boolean deleteBlog() {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接口的设计粒度越小，则应用系统程序越灵活，程序变得灵活也就意味同时结构复杂性提高，开发开发和理解的难度也会变大，可维护性降低。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;高层模块不应该依赖低层模块，两者应依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；中心思想是面向接口编程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C01_FarmFactory {
    public static void main(String[] args) {
        Animal animal = new Dog() ;
        FarmFactory farm = new Farming() ;
        farm.breed(animal) ;
        animal = new Pig() ;
        farm.breed(animal) ;
    }
}
/**
 * 接口声明依赖对象
 */
interface FarmFactory {
    void breed (Animal animal) ;
}
class Farming implements FarmFactory {
    @Override
    public void breed(Animal animal) {
        System.out.println(&quot;农场饲养：&quot;+animal.getAnimalName());
    }
}
interface Animal {
    String getAnimalName () ;
}
class Dog implements Animal {
    @Override
    public String getAnimalName() {
        return &quot;牧羊犬&quot;;
    }
}
class Pig implements Animal {
    @Override
    public String getAnimalName() {
        return &quot;土猪一号&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;相对于系统开发的多变性，抽象的相对稳定。以抽象为基础搭建的架构比以细节为基础的架构要稳定灵活。下层模块尽量都要有抽象类或接口，程序稳定性更好。变量的声明类型尽量是抽象类或接口,这样变量引用和实际对象之间存在一个过渡空间，利于程序扩展和优化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设如下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存在，一个类型T1，和实例的对象O1&lt;/li&gt;
&lt;li&gt;存在，一个类型T2，和实例的对象O2&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果将所有类型为T1的对象O1都替换成类型T2的对象O2，程序的行为不发生改变。那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C01_Calculate {
    public static void main(String[] args) {
        BizCalculate bizCalculate = new BizCalculate() ;
        System.out.println(bizCalculate.add(2,3));
    }
}
class Calculate { }
class BaseCalculate extends Calculate {
    public int add (int a,int b){
        return a+b;
    }
}
/**
 * 这里使用组合的方式完成计算
 */
class BizCalculate extends Calculate {
    private BaseCalculate baseCalculate = new BaseCalculate() ;
    public int add (int a,int b){
        return this.baseCalculate.add(a,b);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法;子类可以扩展父类的功能，但不能改变原有父类的功能；在适当的情况下，可以通过聚合，组合，依赖等方式解决问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;开闭原则是编程中最基础、最重要的设计原则，在代码结构的设计设计时，应该考虑对扩展开放，对修改关闭，抽象思维搭建结构，具体实现扩展细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C01_BookPrice {
    public static void main(String[] args) {
        ParityBook parityBook = new DiscountBook(&quot;Java&quot;,100.00) ;
        System.out.println(parityBook.getPrice());
    }
}
interface Book {
    String getName () ;
    Double getPrice () ;
}
/**
 * 平价书籍
 */
class ParityBook implements Book {
    private String name ;
    private Double price ;
    public ParityBook(String name, Double price) {
        this.name = name;
        this.price = price;
    }
    @Override
    public String getName() {
        return this.name ;
    }
    @Override
    public Double getPrice() {
        return this.price ;
    }
}
/**
 * 打折数据扩展价格计算策略
 */
class DiscountBook extends ParityBook {
    public DiscountBook(String name, Double price) {
        super(name, price);
    }
    @Override
    public Double getPrice() {
        double oldPrice = super.getPrice();
        return oldPrice * 0.8 ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;基于开闭原则设计的代码结构可以提高复用性和可维护性，通过接口或抽象类可以约束类的变化行为，基于指定策略对变化行为进行封装，并且能够实现对扩展开放，使用设计模式的基本原则就是遵循开闭原则。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1、概念描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;迪米特原则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外开放任何信息。类与类关系越密切，耦合度越大，耦合的方式很多，依赖，关联，组合，聚合等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;直接朋友概念&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;两个对象之间有耦合关系，就说这两个对象之间是朋友关系。其中出现成员变量，方法参数，方法返回值中的类称为直接朋友，而出现在局部变量中的类不是直接朋友。从原则上说，陌生的类最好不要以局部变量的形式出现在类的内部。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C01_Employee {
    public static void main(String[] args) {
        HeadCompanyEmpManage empManage = new HeadCompanyEmpManage() ;
        BranchCompanyEmpManage branchEmp = new BranchCompanyEmpManage() ;
        empManage.printEmp(branchEmp);
    }
}
/**
 * 总公司员工
 */
class HeadCompanyEmp {
    public String name ;
    public HeadCompanyEmp(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;HeadCompanyEmp{name='&quot; + name + '}';
    }
}
/**
 * 分公司员工
 */
class BranchCompanyEmp {
    public String name ;
    public BranchCompanyEmp(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;BranchCompanyEmp{name='&quot; + name + '}';
    }
}
/**
 * 分公司员工管理
 */
class BranchCompanyEmpManage {
    // 添加分公司员工
    public List&amp;lt;BranchCompanyEmp&amp;gt; addEmp (){
        List&amp;lt;BranchCompanyEmp&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() ;
        for (int i = 1 ; i &amp;lt;= 3 ; i++){
            list.add(new BranchCompanyEmp(&quot;分公司员工&quot;+i)) ;
        }
        return list ;
    }
    // 获取分公司员工
    public void printBranchCompanyEmp (){
        List&amp;lt;BranchCompanyEmp&amp;gt; list = addEmp () ;
        for (BranchCompanyEmp emp:list){
            System.out.println(emp);
        }
    }
}
/**
 * 总公司员工管理,基于迪米特原则,不出现陌生类
 */
class HeadCompanyEmpManage {
    // 添加总公司员工
    public List&amp;lt;HeadCompanyEmp&amp;gt; addHeadEmp (){
        List&amp;lt;HeadCompanyEmp&amp;gt; list = new ArrayList&amp;lt;&amp;gt;() ;
        for (int i = 1 ; i &amp;lt;= 3 ; i++){
            list.add(new HeadCompanyEmp(&quot;总公司员工&quot;+i)) ;
        }
        return list ;
    }
    public void printEmp (BranchCompanyEmpManage empManage){
        // 打印分公司员工
        empManage.printBranchCompanyEmp();
        List&amp;lt;HeadCompanyEmp&amp;gt; headEmpList = addHeadEmp () ;
        for (HeadCompanyEmp headCompanyEmp:headEmpList){
            System.out.println(headCompanyEmp);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;迪米特原则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此可以降低耦合关系。降低耦合关系，并不是要求完全没有依赖关系，过度的使用迪米特原则，容易产生大量的中间类，导致复杂度变大。所以在使用迪米特原则时要根据实际业务权衡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;设计模式和设计原则的核心思想都是：判断业务应用中可能会变化模块，并且把这些模块独立出来，基于指定的策略进行封装，不要和那些变化的不大的模块耦合在一起，封装思想上基于接口和抽象类，而不是针对具体的实现编程。核心目的就是降低交互对象之间的松耦合度。设计模式和原则都不是可以生搬硬套的公式，个人理解：只要形似，神韵就自然不差。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/model-arithmetic-parent
GitEE·地址
https://gitee.com/cicadasmile/model-arithmetic-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 23:37:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' [toc] 一、单一职责原则 1、概念描述 对类来说的，即一个类应该只负责一项职责。如果一个类负责两个职责，可能存在职责1变化，引起</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/11974550.html</dc:identifier>
</item>
<item>
<title>都9012了，Java8中的日期时间API你还没有掌握？ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/11974355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/11974355.html</guid>
<description>&lt;p&gt;工作这么久了，对于Java中时间日期的操作一直很蛋疼，一会用Date，一会用Calendar一会用LocalDateTime，始终没有认真总结过它们的联系与区别。迷迷糊糊用了好几年了，今天终于搞清楚了！&lt;/p&gt;
&lt;h2 id=&quot;一java8日期时间api产生的前因后果&quot;&gt;一，Java8日期时间API产生的前因后果&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.1 为什么要重新定义一套日期时间API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作不方便：java中最初的Date不能直接对&lt;strong&gt;指定字段进行加减&lt;/strong&gt;操作也不支持&lt;strong&gt;国际化&lt;/strong&gt;，后来新增了Calendar，但是Calendar又不支持格式化操作，需要转换成Date再进行格式化，总之一直在填坑，使用起来一点都不够优雅。&lt;/li&gt;
&lt;li&gt;线程不安全：Date，Caleandar，SimpleDateFormat都是可变的，线程不安全的，所以你需要编写额外的代码处理线程安全问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.2 Java8重新定义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对时间日期相关操作进行细分：时间，日期，日期&amp;amp;时间，时间戳，时间段，日期段，格式化等&lt;/li&gt;
&lt;li&gt;所有类都是不可变的，线程安全&lt;/li&gt;
&lt;li&gt;兼容旧的日期时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201912/1055780-20191203010218008-347765558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.3Java8兼容就版本的Date，同时也规范了日期时间的转换流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201912/1055780-20191203010218284-38976930.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一给人读的-localdatetime-localdate-localtime&quot;&gt;一，给人读的( LocalDateTime &amp;amp; LocalDate &amp;amp; LocalTime)&lt;/h2&gt;
&lt;p&gt;java8中将时间和日期进行的区分，用LocalDateTime表示日期和时间，LocalDate用来表示日期而LocalTime表示时间。内部实现也非常好理解，&lt;strong&gt;LocalDateTime = LocalDate + LocalTime&lt;/strong&gt;，并且他们的内部api也一致，所以笔者就结合工作中的经验，介绍他们最常见的用法。&lt;/p&gt;
&lt;p&gt;1.1 获取当前时间&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime localDateTime = LocalDateTime.now();
// 打印结果: 2019-12-02T22:09:20.503&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.2 获取指定时间&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取 2019年12月02号 23 : 59 : 59 
LocalDateTime localDateTime2 = LocalDateTime.of(2019, 12, 2, 23, 59, 59);
// 打印结果： 2019-12-02T13:20:20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.3 日期/时间加减操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// localDateTime2的基础上加1天零1s
LocalDateTime localDateTime3 = localDateTime2.plusDays(1).plusSeconds(1);
// 打印结果：2019-12-04T00:00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.4 获取指定的字段(年月日时分秒，纳秒，不支持毫秒)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(&quot;现在是: &quot; + localDateTime.getYear() + &quot; 年中的第 &quot; + localDateTime.getDayOfYear() +&quot; 天&quot;);
// 打印结果：现在是: 2019 年中的第 336 天 
// 画外音： 快过年了呀，感觉这一年又没啥收获&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二给计算机读的instant&quot;&gt;二，给计算机读的(Instant)&lt;/h2&gt;
&lt;p&gt;小知识:地球上不同地区经度不同会划分时区，以零度经线上为准(格林尼治天文台旧址，UTC时区)为准，将地球上各个部分分为了24个时区。向西走，每过一个时区，就要把表拨慢1个小时；同理每向东走一个时区，就要把表拨快1个小时。最后，中国处于东8区。&lt;/p&gt;
&lt;p&gt;2.1 获取UTC时间(格林尼治时间)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Instant instant = Instant.now();
// 打印结果： 2019-12-02T14:31:41.661Z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.2 获取北京时间(东8区)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// OffsetTime表示有时差的时间，除了UTC时间，都是OffsetTime
OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
// 打印结果： 2019-12-02T22:31:41.661+08:00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.3 获取毫秒数(1970-01-01T00:00:00Z开始计算)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long epochMilli = instant.toEpochMilli()
// 打印结果：1575297101661&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.4 定义时间戳&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Instant instant1 = Instant.ofEpochSecond(59);
// 打印结果： 1970-01-01T00:00:59Z
instant2 = instant1.plusSeconds(99)
// 打印结果：2019-12-02T14:43:00.402Z
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-时间间隔duration&quot;&gt;三, 时间间隔(Duration)&lt;/h2&gt;
&lt;p&gt;3.1 计算日期间隔(参数位置影响结果哦)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Instant instant1 = Instant.now();
Instant instant2 = instant1.plusSeconds(99);

Duration duration1 = Duration.between(instant1, instant2);
Duration duration2 = Duration.between(instant2, instant1);
// 打印结果 duration1：PT1M39S
// 打印结果 duration2：PT-1M-39S

long duration1Seconds = duration1.getSeconds();
long duration2Seconds = duration1.getSeconds();
// 打印结果 duration1Seconds： 90
// 打印结果 duration2Seconds： -90&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.2 操作时间间隔&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Duration duration3 = duration1.plusDays(1);
// 打印结果：PT24H1M39S&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 : 仅支持时间操作(Instant， LocalTime，LocalDateTime)，不支持日期(LocalDate)&lt;/p&gt;
&lt;h2 id=&quot;四日期间隔period&quot;&gt;四，日期间隔(Period)&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDate localDate1 = LocalDate.now();
LocalDate localDate2 = localDate1.plusDays(1);
Period period = Period.between(localDate1, localDate2);
long days =  period.getDays();
// 打印结果 peroid： P1D
// 打印结果 days： 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五日期时间校正器temporaladjuster&quot;&gt;五，日期/时间校正器(TemporalAdjuster)&lt;/h2&gt;
&lt;p&gt;5.1 获取指定日期或时间&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime localDateTime1 = LocalDateTime.now();
LocalDateTime localDateTime2 = localDateTime.withDayOfMonth(20);
// 打印结果 localDateTime1：2019-12-02T22:57:47.674
// 打印结果 localDateTime2：2019-12-20T22:57:47.674&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.2 获取下一个固定日期(下一个星期天)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime localDateTime3 = localDateTime.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
// 打印结果 localDateTime33：2019-12-08T23:00:43.101&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.3 自定义矫正器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取下一个工作日
    LocalDateTime localDateTime4 = localDateTime.with((tempDateTime) -&amp;gt; {
            LocalDateTime localDateTime5 = (LocalDateTime) tempDateTime;
            DayOfWeek dayOfWeek = localDateTime5.getDayOfWeek();
            if (dayOfWeek.equals(DayOfWeek.FRIDAY)) {
                    return localDateTime5.plusDays(3);
            } else if (dayOfWeek.equals(DayOfWeek.SATURDAY)) {
                    return localDateTime5.plusDays(2);
            } else {
                    return localDateTime5.plusDays(1);
            }
    });
// 打印结果 localDateTime4：2019-12-03T23:00:43.101&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六日期时间格式化&quot;&gt;六，日期时间格式化&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
LocalDateTime localDateTime = LocalDateTime.now();
String dateStr =dateTimeFormatter.format(localDateTime);
// 打印结果: 2019-12-02 23:08:55
LocalDateTime localDateTime2 = LocalDateTime.parse(dateStr, dateTimeFormatter);
// 打印结果: 2019-12-02T23:08:55
LocalDate localDate = LocalDate.parse(dateStr, dateTimeFormatter);
// 打印结果: 2019-12-02&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;七基于instant进行转换&quot;&gt;七，基于Instant进行转换&lt;/h2&gt;
&lt;p&gt;java8api对于时间戳，日期时间以及老版本的Date对象之间的转换也进行了兼容和适配，所有的转换操作都可以基于Instant对象进行。由于LocalDate，LocalTime和LocalDateTime三个类的操作完全一样，所以下文仍使用LocalDateTime演示。&lt;/p&gt;
&lt;p&gt;7.1 时间戳转LocalDate，LocalDate，LocalDateTime&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;long timestamp = Instant.now().toEpochMilli();
LocalDateTime localDateTime = Instant.ofEpochMilli(timestamp).atOffset(ZoneOffset.ofHours(8)).toLocalDateTime();
// 打印结果:2019-12-02T23:20:25.791&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.2 LocalDate，LocalDate，LocalDateTime转时间戳&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime localDateTime = LocalDateTime.now();
long timestamp = localDateTime.toInstant(ZoneOffset.ofHours(8)).toEpochMilli();
// 打印结果：1575300368099 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.3 兼容就版本Date&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime localDateTime3 = LocalDateTime.now();Date date = 
Date.from(localDateTime.atZone(ZoneOffset.ofHours(8)).toInstant());LocalDateTime localDateTime4  = 
localDateTime3.atZone(ZoneOffset.ofHours(8)).toLocalDateTime();
// 打印结果 date：Mon Dec 02 23:32:53 CST 2019
// 打印结果 lcoalDateTime4：2019-12-02T23:32:53.188&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;八-qa&quot;&gt;八， Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;上一篇问题：在java中通常使用synchronized来实现方法同步，AQS中通过CAS保证了修改同步状态的一致性问题，那么对比synchronized，cas有什么优势不同与优势呢？你还知道其他无锁并发的策略吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.1 Answer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java中的无锁并发策略可以分为三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于乐观锁的CAS操作&lt;/li&gt;
&lt;li&gt;Copy On Write：写时复制是指：在并发访问的情景下，当需要修改JAVA中Containers的元素时，不直接修改该容器，而是先复制一份副本，在副本上进行修改。修改完成之后，将指向原来容器的引用指向新的容器(副本容器)&lt;/li&gt;
&lt;li&gt;ThreadLocal：线程本地存储，就是为每一个线程创建一个变量，只有本线程可以在该变量中查看和修改值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;8.2 Question&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这是一道送分题：正如上文提到的，Java8之前的日期时间以及格式化类是线程不安全的，你知道怎么编写测试代码吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果优雅得获取昨天0点整的毫秒值？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;学习Java过程中可能遇到问题和困惑，关注我vx公众号 “cruder” ,后台留言，笔者帮你一起解决！（需要学习资料的请关注后后台留言，主要都是java相关，java基础，并发，mysql，redis，es，mq等都都有！）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201912/1055780-20191203010219149-2029822186.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 17:02:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>工作这么久了，对于Java中时间日期的操作一直很蛋疼，一会用Date，一会用Calendar一会用LocalDateTime，始终没有认真总结过它们的联系与区别。迷迷糊糊用了好几年了，今天终于搞清楚了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/11974355.html</dc:identifier>
</item>
<item>
<title>源码分析— java读写锁ReentrantReadWriteLock - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11973977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11973977.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天看Jraft的时候发现了很多地方都用到了读写锁，所以心血来潮想要分析以下读写锁是怎么实现的。&lt;/p&gt;
&lt;p&gt;先上一个doc里面的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class CachedData {
  Object data;
  volatile boolean cacheValid;
  final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

  void processCachedData() {
      //加上一个读锁
    rwl.readLock().lock();
    if (!cacheValid) {
      // Must release read lock before acquiring write lock
      //必须在加写锁之前释放读锁
      rwl.readLock().unlock();
      rwl.writeLock().lock();
      try {
        // Recheck state because another thread might have
        // acquired write lock and changed state before we did.
          //双重检查
        if (!cacheValid) {
            //设置值
          data = ...
          cacheValid = true;
        }
        // Downgrade by acquiring read lock before releasing write lock
          //锁降级，反之则不行
        rwl.readLock().lock();
      } finally {
          //释放写锁，但是仍然持有写锁
        rwl.writeLock().unlock(); // Unlock write, still hold read
      }
    }

    try {
      use(data);
    } finally {
        //释放读锁
      rwl.readLock().unlock();
    }
  }
}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们一般实例化一个ReentrantReadWriteLock，一般是调用空的构造器创建，所以默认使用的是非公平锁&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ReentrantReadWriteLock() {
    this(false);
}


public ReentrantReadWriteLock(boolean fair) {
      //默认使用的是NonfairSync
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
//分别调用writeLock和readLock会返回读写锁实例
public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ReentrantReadWriteLock内部类Sync&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 6317671515068378041L;
      //位移量
      //在读写锁中，state是一个32位的int，所以用state的高16位表示读锁，用低16位表示写锁
    static final int SHARED_SHIFT   = 16;
      //因为读锁是高16位，所以用1向左移动16位表示读锁每次锁状态变化的量
    static final int SHARED_UNIT    = (1 &amp;lt;&amp;lt; SHARED_SHIFT);
      //最大的可重入次数
    static final int MAX_COUNT      = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;
      //用来计算低16位的写锁状态
    static final int EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;

    //获取高16位读锁state次数，重入次数
    static int sharedCount(int c)    { return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }
    //获取低16位写锁state次数，重入次数
    static int exclusiveCount(int c) { return c &amp;amp; EXCLUSIVE_MASK; }

    //用来记录每个线程持有的读锁数量
    static final class HoldCounter {
        int count = 0;
        // Use id, not reference, to avoid garbage retention
        final long tid = getThreadId(Thread.currentThread());
    }

    
    static final class ThreadLocalHoldCounter
        extends ThreadLocal&amp;lt;HoldCounter&amp;gt; {
        public HoldCounter initialValue() {
            return new HoldCounter();
        }
    }

    private transient ThreadLocalHoldCounter readHolds;
      // 用于缓存，记录&quot;最后一个获取读锁的线程&quot;的读锁重入次数
    private transient HoldCounter cachedHoldCounter;
      // 第一个获取读锁的线程(并且其未释放读锁)，以及它持有的读锁数量
    private transient Thread firstReader = null;
    private transient int firstReaderHoldCount;

    Sync() {
          // 初始化 readHolds 这个 ThreadLocal 属性
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    }
    ....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;因为int是32位的，所以在ReentrantReadWriteLock中将state分为两部分，高16位作为读锁的状态控制器，低16位作为写锁的状态控制器。&lt;/li&gt;
&lt;li&gt;每次要获取读锁的当前状态都需要调用sharedCount传入当前的state，将state向右移动16位来获取&lt;/li&gt;
&lt;li&gt;要获取低16位则需要将1左移16位减一，获得一个低16位全是1的数，然后和传入的state进行取与操作获取state的低16位的值&lt;/li&gt;
&lt;li&gt;cachedHoldCounter里面保存了最新的读锁的线程和调用次数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;firstReader&lt;/strong&gt; 和 &lt;strong&gt;firstReaderHoldCount&lt;/strong&gt; 将”第一个”获取读锁的线程记录在 firstReader 属性中，这里的&lt;strong&gt;第一个&lt;/strong&gt;不是全局的概念，等这个 firstReader 当前代表的线程释放掉读锁以后，会有后来的线程占用这个属性的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;读锁获取&quot;&gt;读锁获取&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//readLock#lock
public void lock() {
      //这里会调用父类AQS的acquireShared，尝试获取锁
    sync.acquireShared(1);
}
//AQS#acquireShared
public final void acquireShared(int arg) {
      //返回值小于 0 代表没有获取到共享锁
    if (tryAcquireShared(arg) &amp;lt; 0)
          //进入到阻塞队列，然后等待前驱节点唤醒
        doAcquireShared(arg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的tryAcquireShared是调用ReentrantReadWriteLock的内部类Sync的tryAcquireShared的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final int tryAcquireShared(int unused) {
      //获取当前线程
    Thread current = Thread.currentThread();
      //获取AQS中的state属性值
    int c = getState();
    //exclusiveCount方法是用来获取写锁状态，不等于0代表有写锁
    if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
          //如果不是当前线程获取的写锁，那么直接返回-1
        getExclusiveOwnerThread() != current)
        return -1;
      //获取读锁的锁定次数
    int r = sharedCount(c);
      // 读锁获取是否需要被阻塞
    if (!readerShouldBlock() &amp;amp;&amp;amp;
        r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
        //因为高16位代表共享锁，所以CAS需要加上一个SHARED_UNIT
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
              //记录一下首次读线程
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
               //firstReader 重入获取读锁
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
              // 如果 cachedHoldCounter 缓存的不是当前线程，设置为缓存当前线程的 HoldCounter
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
           // return 大于 0 的数，代表获取到了共享锁
        return 1;
    }
    return fullTryAcquireShared(current);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;首先会去调用exclusiveCount方法来查看写锁是否被占用，如果被占用，那么查看当前线程是否是占用读锁的线程，如果不是则返回-1。通过这里可以看出可以先占用读锁再占用写锁&lt;/li&gt;
&lt;li&gt;调用readerShouldBlock方法获取是否需要阻塞读锁获取，然后检查一下高16位读锁重入次数是否超过了2^16-1，最后通过CAS操作将state高16进行加1操作，如果没有其他线程抢占就会成功&lt;/li&gt;
&lt;li&gt;如果state的高16位为零，那么就设置首次读线程和首次数次数，如果不是则校验首次读线程是不是当前线程，是的话将firstReaderHoldCount次数加1。如果不是首次读线程，那么校验一下最后一次读线程是不是当前线程，不是的话就从readHolds中获取，并将HoldCounter计数加1，如果最后读线程是当前线程那么计数加1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;readerShouldBlock&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//NonfairSync#readerShouldBlock
final boolean readerShouldBlock() {
    return apparentlyFirstQueuedIsExclusive();
}
//AQS
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;amp;&amp;amp;
        (s = h.next)  != null &amp;amp;&amp;amp;
        !s.isShared()         &amp;amp;&amp;amp;
        s.thread != null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在非公平模式中readerShouldBlock会调用AQS的方法，判断当前头节点的下一个节点，如果不是共享节点，那么readerShouldBlock就返回true，读锁就会阻塞。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//FairSync#readerShouldBlock
final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
//AQS
public final boolean hasQueuedPredecessors() {
   
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;amp;&amp;amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在公平模式中会去看看队列里有没有其他元素在队列里等待获取锁，如果有那么读锁就进行阻塞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReentrantReadWriteLock#fullTryAcquireShared&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final int fullTryAcquireShared(Thread current) {
   
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
          //检查是否写锁被占用
        if (exclusiveCount(c) != 0) {
               //被占用，但是占用读锁线程不是当前线程，返回阻塞
            if (getExclusiveOwnerThread() != current)
                return -1;
            // else we hold the exclusive lock; blocking here
            // would cause deadlock.
            //检查读锁是否应该被阻塞
        } else if (readerShouldBlock()) {
            // Make sure we're not acquiring read lock reentrantly
              //首次读线程是当前线程，下面直接CAS
            if (firstReader == current) {
                // assert firstReaderHoldCount &amp;gt; 0;
            } else {
                if (rh == null) {
                       //设置最后一次读线程
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) {
                        rh = readHolds.get();
                        if (rh.count == 0)
                               //如果发现 count == 0，也就是说，纯属上一行代码初始化的，那么执行 remove
                            readHolds.remove();
                    }
                }
                   //如果最后读取线程次数为0，那么阻塞
                if (rh.count == 0)
                    return -1;
            }
        }
          //如果读锁重入次数达到上限，抛异常
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
          //尝试CAS读锁重入次数加1
        if (compareAndSetState(c, c + SHARED_UNIT)) {
               // 这里 CAS 成功，那么就意味着成功获取读锁了
            // 下面需要做的是设置 firstReader 或 cachedHoldCounter
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                  // 下面这几行，就是将 cachedHoldCounter 设置为当前线程
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
              // 返回大于 0 的数，代表获取到了读锁
            return 1;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法主要是用来处理重入锁操作的。首先校验一下写锁是否被占用，如果没有被占用则判断当前线程是否是第一次读线程，如果不是则判断最后一次读线程是不是当前线程，如果不是则从readHolds获取，并判断HoldCounter实例中获取读锁次数如果为0，那么就不是重入。&lt;/p&gt;
&lt;p&gt;如果可以判断当前线程是重入的，那么则对state高16进行加1操作，操作成功，则对firstReader或cachedHoldCounter进行设置，并返回1，表示获取到锁。&lt;/p&gt;
&lt;p&gt;到这里我们看完了tryAcquireShared方法，我再把acquireShared方法贴出来：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireShared(arg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面看doAcquireShared方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doAcquireShared(int arg) {
      //实例化一个共享节点入队
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
              //获取当前节点的上一个前置节点
            final Node p = node.predecessor();
              //前置节点如果是头节点，那么代表队列里没有别的节点，先调用tryAcquireShared尝试获取锁
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                       //醒队列中其他共享节点
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                       //响应中断
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
              //设置前置节点waitStatus状态
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                  //阻塞当前线程
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;doAcquireShared方法中会实例化一个共享节点并入队。如果当前节点的前置节点是头节点，那么直接调用tryAcquireShared先获取一次锁，如果返回大于0，那么表示可以获取锁，调用setHeadAndPropagate唤醒队列中其他的线程；如果没有返回则会调用shouldParkAfterFailedAcquire方法将前置节点的waitStatus设值成SIGNAL，然后调用parkAndCheckInterrupt方法阻塞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AQS#setHeadAndPropagate&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
      //把node节点设值为头节点
    setHead(node); 
      //因为是propagate大于零才进这个方法，所以这个必进这个if
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
        (h = head) == null || h.waitStatus &amp;lt; 0) {
          //获取node的下一个节点
        Node s = node.next;
          //判断下一个节点是否为空，或是共享节点
        if (s == null || s.isShared())
              //往下看
            doReleaseShared();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法主要是替换头节点为当前节点，然后调用doReleaseShared进行唤醒节点的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AQS#doReleaseShared&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doReleaseShared() { 
    for (;;) {
        Node h = head;
        // 1. h == null: 说明阻塞队列为空
        // 2. h == tail: 说明头结点可能是刚刚初始化的头节点，
        //   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了
        // 所以这两种情况不需要进行唤醒后继节点
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
               //后面的节点会把前置节点设置为Node.SIGNAL
            if (ws == Node.SIGNAL) {
                    //1
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                    // 唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;amp;&amp;amp;
                        //2
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
          //3 如果被唤醒的节点已经占领head了，那么继续循环，否则跳出循环
        if (h == head)                   // loop if head changed
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;unparkSuccessor这里会唤醒下一个节点，那么下一个节点也会调用setHeadAndPropagate进行抢占头节点；如果同时有当前线程和被唤醒的下一个线程同时走到这里，那么只会有一个成功，另一个返回false的就不进行唤醒操作&lt;/li&gt;
&lt;li&gt;这里CAS失败的原因可能是一个新的节点入队，然后将前置节点设值为了Node.SIGNAL，所以导致当前的CAS失败&lt;/li&gt;
&lt;li&gt;如果被唤醒的节点抢占头节点成功，那么h == head 就不成立，那么会进行下一轮的循环，否则就是head没有被抢占成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;AQS#unparkSuccessor&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void unparkSuccessor(Node node) {
    //如果当前节点小于零，那么作为头节点要被清除一下状态
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待
    // 从队尾往前找，找到waitStatus&amp;lt;=0的所有节点中排在最前面的
    Node s = node.next;
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    if (s != null)
          // 唤醒线程
        LockSupport.unpark(s.thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里加读锁的代码就讲解完毕了&lt;/p&gt;
&lt;h2 id=&quot;读锁释放&quot;&gt;读锁释放&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ReadLock
public void unlock() {
    sync.releaseShared(1);
}
// Sync
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared(); 
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看tryReleaseShared&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sync#tryReleaseShared&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
      //如果当前是firstReader，那么需要进行重置或重入减一
    if (firstReader == current) {
        // assert firstReaderHoldCount &amp;gt; 0;
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    } else {
          // 判断 cachedHoldCounter 是否缓存的是当前线程，不是的话要到 ThreadLocal 中取
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count &amp;lt;= 1) {
               // 这一步将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了
            readHolds.remove();
               //unlock了几次的话会抛异常
            if (count &amp;lt;= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    for (;;) {
        int c = getState();
           // nextc 是 state 高 16 位减 1 后的值
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            // 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了
            // 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程
            return nextc == 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个读锁的释放，主要就是将 hold count 减 1，如果减到 0 的话，还要将 ThreadLocal 中的 remove 掉。然后是在 for 循环中将 state 的高 16 位减 1，如果发现读锁和写锁都释放光了，那么唤醒后继的获取写锁的线程，因为只有读锁是不会被阻塞的，所以等待的线程只可能是写锁的线程。&lt;/p&gt;
&lt;h2 id=&quot;写锁的获取&quot;&gt;写锁的获取&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//WriteLock
public void lock() {
    sync.acquire(1);
}
//sync
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//AQS
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
      //获取state的低16位
    int w = exclusiveCount(c);
      //不为零说明读锁或写锁被持有了
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        // 看下这里返回 false 的情况：
        //   c != 0 &amp;amp;&amp;amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有)
        //   c != 0 &amp;amp;&amp;amp; w !=0 &amp;amp;&amp;amp; current != getExclusiveOwnerThread(): 其他线程持有写锁
        //   也就是说，只要有读锁或写锁被占用，这次就不能获取到写锁
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
          // 这里不需要 CAS，仔细看就知道了，能到这里的，只可能是写锁重入，不然在上面的 if 就拦截了
        setState(c + acquires);
        return true;
    }
      //检查写锁是否需要block
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
      //走到这里说明写锁不需要block，并且CAS成功了
    setExclusiveOwnerThread(current);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看writerShouldBlock&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//NonfairSync
final boolean writerShouldBlock() {
    return false; // writers can always barge
}
//FairSync
final boolean writerShouldBlock() {
    return hasQueuedPredecessors();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是非公平模式，那么 lock 的时候就可以直接用 CAS 去抢锁，抢不到再排队&lt;/p&gt;
&lt;p&gt;如果是公平模式，那么如果阻塞队列有线程等待的话，就乖乖去排队&lt;/p&gt;
&lt;h2 id=&quot;写锁释放&quot;&gt;写锁释放&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unlock() {
    sync.release(1);
}

//sync
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
          //如果独占锁释放&quot;完全&quot;，唤醒后继节点
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

//Sync
protected final boolean tryRelease(int releases) {
      //检查一下持有所的线程是不是当前线程
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
      //将state减1
    int nextc = getState() - releases;
    //查看低16位是否为0
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
          //如果为0，那么说明写锁释放
        setExclusiveOwnerThread(null);
      //设置状态
    setState(nextc);
    return free;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 02 Dec 2019 15:27:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>前言 今天看Jraft的时候发现了很多地方都用到了读写锁，所以心血来潮想要分析以下读写锁是怎么实现的。 先上一个doc里面的例子： 我们一般实例化一个ReentrantReadWriteLock，一般</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11973977.html</dc:identifier>
</item>
<item>
<title>函数计算进行自动化运维专题 - 阿里巴巴云原生</title>
<link>http://www.cnblogs.com/alisystemsoftware/p/11973926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alisystemsoftware/p/11973926.html</guid>
<description>&lt;p&gt;通常来说，自动化运维有两种类型的运维方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定时的脚本任务， 比如定时更换云服务的 acess key secret , 定时检查 ecs 对外暴露的端口等&lt;/li&gt;
&lt;li&gt;报警事件的紧急处理, 比如 ecs 实例发生异常重启&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在传统的运维中，对于定时任务的处理通常用crontab脚本来实现，但是一旦管理的机器多了，必定会对脚本进行集中管理，这个时候对集中管理脚本的机器的可用性、脚本里面会散落密码明文等相关信息以及定时任务执行的记录都是一个很大的挑战；而对于事件驱动的报警处理，要么是通过短信报警告知运维人员，要么需要自建服务来处理报警信息, 无论是哪种方式，财务成本和运维成本都很大。本文探讨一种新的运维方式，利用函数计算做自动化运维，以极低的成本就可以获得一个高可靠，高质量的运维服务。&lt;/p&gt;

&lt;p&gt;阿里云&lt;a href=&quot;https://help.aliyun.com/document_detail/52895.html?spm=a2c4g.11186623.6.539.AdoN1O&quot;&gt;函数计算&lt;/a&gt;是一个事件驱动的serverless计算服务。通过函数计算，您无需管理服务器等基础设施，只需编写代码并上传。函数计算会为您准备好计算资源，以弹性、可靠的方式运行您的代码，具体表现为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无需采购和管理服务器等基础设施&lt;/li&gt;
&lt;li&gt;按需付费，比如对运维管控这类低频调用的系统，财务成本通常能节约90%以上&lt;/li&gt;
&lt;li&gt;专注业务逻辑的开发，能极大提高开发效率，比如&lt;a href=&quot;https://yq.aliyun.com/articles/603554?spm=a2c4e.11153959.0.0.31bb4424Tl5LTf&quot;&gt;十分钟上线弹性高可用的图片处理服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;稳定高可用，毫秒级别弹性伸缩，快速实现底层扩容以应对峰值压力&lt;/li&gt;
&lt;li&gt;提供日志查询、性能监控、报警等功能快速排查故障&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数计算给用户极大的自由来实现自定义的功能，一旦和自定义自动化运维相遇，会擦出不一样的火花。下面就本文就传统的自动化运维和函数计算进行自动运维在两种不同类型维度上做一个对比:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/0f65c67a428d69e3820851a2600ab8bbfb5f7cfc.png&quot; alt=&quot;_&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;定时任务示例场景1&quot;&gt;定时任务示例场景1&lt;/h2&gt;
&lt;p&gt;某些云服务账号acess key secret需要定期更换，以确保 acess key secret安全&lt;/p&gt;
&lt;h2 id=&quot;定时任务示例场景2&quot;&gt;定时任务示例场景2&lt;/h2&gt;
&lt;p&gt;定期检查自己 ecs 对应暴露的端口，确保安全。比如你的ecs是一个网站服务器，可能只需要对外暴露 80 端口就行，如果出现 0.0.0.0/0 这种允许所有人访问的漏洞，需要出现报警或者自动修复。&lt;/p&gt;


&lt;h2 id=&quot;事件驱动示例场景1&quot;&gt;事件驱动示例场景1&lt;/h2&gt;
&lt;p&gt;假设两台 ECS 机器 A, B, A 机器出现了宕机，这个时候需要把A机器上的 eip 迁移到备用机器 B 上，可利用云监控的报警和函数计算可以实现 eip 的自动迁移， 云监控检测到A宕机这个事件，然后触发函数执行，函数实现 eip 的自动迁移。&lt;/p&gt;

&lt;h2 id=&quot;事件驱动示例场景2&quot;&gt;事件驱动示例场景2&lt;/h2&gt;
&lt;p&gt;假设之前一台 ecs 发生系统错误而重启，用户可能会紧急起来做一些验证或者创建快照的处理， 在下面的实战中，我们对一台因为系统错误实例重启或者因实例错误而重启的机器进行自动化处理，比如成功重启后创建快照处理。&lt;/p&gt;


&lt;p&gt;用函数计算进行自动化运维，对进行自动化运维处理的函数进行可视化的管理、监控，函数的运行具有弹性，高可用，安全性高等有点；同时在驱动函数的事件源上，云监控提供了丰富事件，并且事件还在不断丰富中（&lt;a href=&quot;https://help.aliyun.com/document_detail/66940.html?spm=a2c4g.11186623.6.644.7f1d6db3pfgDf3&quot;&gt;云产品系统事件监控&lt;/a&gt;），丰富的事件触发自定义处理的函数，高可用的定时器，这些都可以保证我们可以实现更加完美的的自动化运维。&lt;br/&gt;&lt;strong&gt;如果对&lt;code&gt;函数计算进行自动化运维&lt;/code&gt;这个运用场景感兴趣, 请点击收藏本页，我们会在这边&lt;code&gt;函数计算进行自动化运维&lt;/code&gt;这个专题主页持续更新相关内容和实战案例。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 15:14:00 +0000</pubDate>
<dc:creator>阿里巴巴云原生</dc:creator>
<og:description>前言 通常来说，自动化运维有两种类型的运维方式： 定时的脚本任务， 比如定时更换云服务的 acess key secret , 定时检查 ecs 对外暴露的端口等 报警事件的紧急处理, 比如 ecs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/alisystemsoftware/p/11973926.html</dc:identifier>
</item>
</channel>
</rss>