<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS开发你不知道的事-编译&amp;链接 - 鸟菜小</title>
<link>http://www.cnblogs.com/xsxtx/p/10848873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xsxtx/p/10848873.html</guid>
<description>&lt;p&gt;对于平常的应用程序开发，我们很少需要关注&lt;code&gt;编译&lt;/code&gt;和&lt;code&gt;链接&lt;/code&gt;过程。我们平常&lt;code&gt;Xcode&lt;/code&gt;开发就是集成的的开发环境&lt;code&gt;（IDE）&lt;/code&gt;,这样的IDE一般都将&lt;code&gt;编译&lt;/code&gt;和&lt;code&gt;链接&lt;/code&gt;的过程一步完成，通常将这种&lt;code&gt;编译&lt;/code&gt;和&lt;code&gt;链接&lt;/code&gt;合并在一起的过程称为&lt;code&gt;构建&lt;/code&gt;，即使使用命令行来编译一个源代码文件,简单的一句&lt;code&gt;gcc hello.c&lt;/code&gt;命令就包含了非常复杂的过程!&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;正是因为集成开发环境的强大，很多系统软件的&lt;code&gt;运行机制与机理&lt;/code&gt;被掩盖，其程序的很多莫名其妙的错误让我们无所适从，面对程序运行时种种性能瓶颈我们束手无策。我们看到的是这些问题的现象，但是却很难看清本质，所有这些问题的本质就是&lt;code&gt;软件运行背后的机理及支撑软件运行的各种平台和工具&lt;/code&gt;，如果能深入了解这些机制，那么解决这些问题就能够游刃有余，收放自如了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;编译流程分析&quot;&gt;编译流程分析&lt;/h2&gt;
&lt;p&gt;现在我们通过一个C语言的经典例子，来具体了解一下这些机制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main(){
    printf(&quot;Hello World&quot;);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在linux下只需要一个简单的命令（假设源代码文件名为hello.c）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gcc hello.c
$ ./a.out
Hello World
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实上述过程可以分解为四步:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预处理（Prepressing）&lt;/li&gt;
&lt;li&gt;编译（Compilation）&lt;/li&gt;
&lt;li&gt;汇编（Assembly）&lt;/li&gt;
&lt;li&gt;链接（Linking）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-eb7c62958635fa85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;预编译&quot;&gt;预编译&lt;/h3&gt;
&lt;p&gt;首先是源代码文件&lt;code&gt;hello.c&lt;/code&gt;和相关的头文件（如&lt;code&gt;stdio.h&lt;/code&gt;等）被预编译器&lt;code&gt;cpp&lt;/code&gt;预编译成一个&lt;code&gt;.i&lt;/code&gt;文件。第一步预编译的过程相当于如下命令（-E 表示只进行预编译）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gcc –E hello.c –o hello.i
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以下面的表达&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cpp hello.c &amp;gt; hello.i
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预编译过程主要处理源代码文件中以”#”开头的预编译指令。比如&lt;code&gt;#include、#define&lt;/code&gt;等，主要处理规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将所有的&lt;code&gt;#define&lt;/code&gt;删除，并展开所有的宏定义&lt;/li&gt;
&lt;li&gt;处理所有条件预编译指令，比如&lt;code&gt;#if，#ifdef，#elif，#else，#endif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;处理&lt;code&gt;#include&lt;/code&gt;预编译指令，将被包含的文件插入到该预编译指令的位置。&lt;/li&gt;
&lt;li&gt;删除所有的注释&lt;code&gt;//&lt;/code&gt;和&lt;code&gt;/**/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加行号和文件名标识，比如&lt;code&gt;#2 “hello.c” 2。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保留所有的&lt;code&gt;#pragma&lt;/code&gt;编译器指令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;截图个大家看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-f78cba413a151114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过预编译后的文件&lt;code&gt;（.i文件）&lt;/code&gt;不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经插入到&lt;code&gt;.i文件&lt;/code&gt;中，所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。&lt;/p&gt;
&lt;h3 id=&quot;编译compliation&quot;&gt;编译（compliation）&lt;/h3&gt;
&lt;p&gt;编译过程就是把预处理完的文件进行一系列的：&lt;code&gt;词法分析&lt;/code&gt;、&lt;code&gt;语法分析&lt;/code&gt;、&lt;code&gt;语义分析&lt;/code&gt;及&lt;code&gt;优化后生产相应的汇编代码文件&lt;/code&gt;，此过程是整个程序构建的核心部分，也是最复杂的部分之一。其编译过程相当于如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gcc –S hello.i –o hello.s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-efd2a604ec7ee34a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图我们不难得出，通过命令得到汇编输出文件&lt;code&gt;hello.s&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;汇编assembly&quot;&gt;汇编（assembly）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎对应一条机器令。&lt;/code&gt;所以汇编器的汇编过程相对于编译器来讲比较简单，它没复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。其汇编过程相当于如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;as hello.s –o hello.o
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gcc –c hello.s –o hello.o
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者使用&lt;code&gt;gcc&lt;/code&gt;命令从&lt;code&gt;C源代码文件&lt;/code&gt;开始，经过预编译、编译和汇编直接输出目标文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gcc –c hello.c –o hello.o
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;链接linking&quot;&gt;链接（linking）&lt;/h3&gt;
&lt;p&gt;链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？为什么要链接？下面让我们来看看怎么样调用&lt;code&gt;ld&lt;/code&gt;才可以产生一个能够正常运行的&lt;code&gt;Hello World&lt;/code&gt;程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注意默认情况没有gcc / 记得 ：
$ brew install gcc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链接相应的库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-cd0dbfa074f1c2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面在贴出我们的写出的源代码是如何变成目标代码的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-7520cba50bce6393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要通过我们的编译器做了以下任务：&lt;strong&gt;扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这我们就可以得到以下的文件，不知道你是否有和我一起操作，玩得感觉还是不错，继续往下面看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-925547bd17f9245c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ios的编译器&quot;&gt;iOS的编译器&lt;/h3&gt;
&lt;p&gt;iOS现在为了达到更牛逼的速度和优化效果，采用了&lt;code&gt;LLVM&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1.LLVM核心库:&lt;br/&gt;&lt;code&gt;LLVM&lt;/code&gt;提供一个独立的链接代码优化器为许多流行&lt;code&gt;CPU&lt;/code&gt;（以及一些不太常见的&lt;code&gt;CPU&lt;/code&gt;）的代码生成支持。这些库是围绕一个指定良好的代码表示构建的，称为&lt;code&gt;LLVM中间表示（“LLVM IR”）&lt;/code&gt;。&lt;code&gt;LLVM&lt;/code&gt;还可以充当&lt;code&gt;JIT编译器 - 它支持x86 / x86_64和PPC / PPC64程序集生成&lt;/code&gt;，并具有针对编译速度的快速代码优化。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2.&lt;code&gt;LLVM IR&lt;/code&gt; 生成器&lt;code&gt;Clang: Clang是一个“LLVM原生”C / C ++ / Objective-C编译器，&lt;/code&gt;旨在提供惊人的快速编译（例如，在调试配置中编译&lt;strong&gt;Objective-C代码时比GCC快3倍）&lt;/strong&gt;，非常有用的错误和警告消息以及提供构建优秀源代码工具的平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;3.&lt;code&gt;LLDB&lt;/code&gt;项目:&lt;br/&gt;&lt;code&gt;LLDB&lt;/code&gt;项目以&lt;code&gt;LLVM&lt;/code&gt;和&lt;code&gt;Clang&lt;/code&gt;提供的库为基础，提供了一个出色的本机调试器。它使用&lt;code&gt;Clang AST&lt;/code&gt;和&lt;code&gt;表达式解析器&lt;/code&gt;，&lt;code&gt;LLVM JIT，LLVM反汇编程序&lt;/code&gt;等，以便提供“正常工作”的体验。在加载符号时，&lt;strong&gt;它也比GDB快速且内存效率更高。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;4.&lt;code&gt;libc&lt;/code&gt;和&lt;code&gt;libc++&lt;/code&gt;:&lt;br/&gt;&lt;code&gt;libc&lt;/code&gt; 和&lt;code&gt;libc++&lt;/code&gt; ABI项目提供了&lt;code&gt;C ++&lt;/code&gt;标准库的标准符合性和高性能实现，包括对&lt;code&gt;C ++ 11&lt;/code&gt;的完全支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;5.&lt;code&gt;lld项目&lt;/code&gt;:&lt;br/&gt;&lt;code&gt;lld项目&lt;/code&gt;旨在成为&lt;code&gt;clang / llvm的内置链接器&lt;/code&gt;。目前，clang必须调用系统链接器来生成可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;LLVM采用三相设计，前端Clang负责解析，验证和诊断输入代码中的错误，然后将解析的代码转换为LLVM IR，后端LLVM编译把IR通过一系列改进代码的分析和优化过程提供，然后被发送到代码生成器以生成本机机器代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-dccbfc1ef463f696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译器前端的任务是进行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;生成中间代码(intermediate representation )&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2257417-085a576b31b03b7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上图解内容所做的是事情和&lt;code&gt;gcc&lt;/code&gt;编译一模模一样样！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;ios程序-详细编译过程&quot;&gt;iOS程序-详细编译过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.写入辅助文件：将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件，方便后面使用；并且创建一个 &lt;code&gt;.app&lt;/code&gt; 包，后面编译后的文件都会被放入包中；&lt;/li&gt;
&lt;li&gt;2.运行预设脚本：&lt;code&gt;Cocoapods&lt;/code&gt; 会预设一些脚本，当然你也可以自己预设一些脚本来运行。这些脚本都在 &lt;code&gt;Build Phases&lt;/code&gt;中可以看到；&lt;/li&gt;
&lt;li&gt;3.编译文件：针对每一个文件进行编译，生成可执行文件 &lt;code&gt;Mach-O&lt;/code&gt;，这过程 &lt;code&gt;LLVM&lt;/code&gt; 的完整流程，前端、优化器、后端；&lt;/li&gt;
&lt;li&gt;4.链接文件：将项目中的多个可执行文件合并成一个文件；&lt;/li&gt;
&lt;li&gt;5.拷贝资源文件：将项目中的资源文件拷贝到目标包；&lt;/li&gt;
&lt;li&gt;6.编译 &lt;code&gt;storyboard&lt;/code&gt; 文件：&lt;code&gt;storyboard&lt;/code&gt; 文件也是会被编译的；&lt;/li&gt;
&lt;li&gt;7.链接 &lt;code&gt;storyboard&lt;/code&gt; 文件：将编译后的 &lt;code&gt;storyboard&lt;/code&gt; 文件链接成一个文件；&lt;/li&gt;
&lt;li&gt;8.编译 &lt;code&gt;Asset&lt;/code&gt; 文件：我们的图片如果使用 &lt;code&gt;Assets.xcassets&lt;/code&gt; 来管理图片，那么这些图片将会被编译成机器码，除了 &lt;code&gt;icon&lt;/code&gt; 和 &lt;code&gt;launchImage&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;9.运行 &lt;code&gt;Cocoapods&lt;/code&gt; 脚本：将在编译项目之前已经编译好的依赖库和相关资源拷贝到包中。&lt;/li&gt;
&lt;li&gt;10.生成 &lt;code&gt;.app&lt;/code&gt; 包&lt;/li&gt;
&lt;li&gt;11.将 &lt;code&gt;Swift&lt;/code&gt; 标准库拷贝到包中&lt;/li&gt;
&lt;li&gt;12.对包进行签名&lt;/li&gt;
&lt;li&gt;13.完成打包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;编译过程的确是个比较复杂的过程，还有链接！并不是说难就不需要掌握，我个人建议每一个进阶路上iOS开发人员，都是要了解一下的。不需要你多么牛逼，但是你能在平时的交流讨论，面试中能点出一个两个相应的点，我相信绝对是逼格满满！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 May 2019 07:41:00 +0000</pubDate>
<dc:creator>鸟菜小</dc:creator>
<og:description>对于平常的应用程序开发，我们很少需要关注 和`链接 Xcode （IDE） 编译 链接 编译 链接 构建 gcc hello.c`命令就包含了非常复杂的过程! 正是因为集成开发环境的强大，很多系统软件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xsxtx/p/10848873.html</dc:identifier>
</item>
<item>
<title>.net core 发送邮件 - 千金不如一默</title>
<link>http://www.cnblogs.com/jixiaosa/p/10848857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jixiaosa/p/10848857.html</guid>
<description>&lt;p&gt;　　在.net core2.0以上版本中 发送所用到的API与.net framework一致。1.0版本好像有差别，好在高版本解决了这个问题。&lt;/p&gt;

&lt;p&gt;为了方便查看效果，以控制台程序为例。 邮箱服务器以现在比较大众化&lt;strong&gt;QQ邮箱&lt;/strong&gt;为例&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.获取QQ邮箱的授权码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在使用QQ邮箱发送邮件时，需要额外的一个授权码。不同于我们平时所用的登录密码，是在开启SMTP服务之后生成的一个密码。它是用于登录第三方客户端的专用密码。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 进入QQ邮箱首页，在最上方点击 &lt;span&gt;设置&lt;/span&gt; 按钮，进入下一页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511150808178-867708738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 点击 &lt;span&gt;账户&lt;/span&gt; 选项卡 ，划到大概中间部分，有一个服务选项区。经实验开启前两个就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511151137350-2018946913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 点击下方的 &lt;span&gt;生成授权码，&lt;span&gt;在开启服务之后会自动生成一次。这一步如果绑定了密保，会先进行一次身份验证。验证之后会发放一个授权码。这个授权码，在程序里会用到。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511151548508-187166846.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511151639117-1915427436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在拿到授权码之后就可以在代码实现功能了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 创建控制台项目，代码如下。 示例是用我的QQ邮箱给我的Gmail邮箱发送一封测试邮件。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            MailMessage mailMsg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MailMessage();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化对象&lt;/span&gt;
            mailMsg.From = &lt;span&gt;new&lt;/span&gt; MailAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;923974733@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;季某人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;源邮件地址和发件人&lt;/span&gt;
            mailMsg.To.Add(&lt;span&gt;new&lt;/span&gt; MailAddress(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaomaprincess@gmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收件人地址&lt;/span&gt;
            mailMsg.Subject = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮件发送测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送邮件的标题&lt;/span&gt;
            StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            sb.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试测试测试测试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            sb.Append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;嘿嘿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            mailMsg.Body &lt;/span&gt;= sb.ToString();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送邮件的内容
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定smtp服务地址（根据发件人邮箱指定对应SMTP服务器地址）&lt;/span&gt;
            SmtpClient client = &lt;span&gt;new&lt;/span&gt; SmtpClient();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式：smtp.126.com  smtp.164.com&lt;/span&gt;
            client.Host = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smtp.qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要用587端口&lt;/span&gt;
            client.Port = &lt;span&gt;587&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加密&lt;/span&gt;
            client.EnableSsl = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过用户名和密码验证发件人身份&lt;/span&gt;
            client.Credentials = &lt;span&gt;new&lt;/span&gt; NetworkCredential(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;923974733@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxxxxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送邮件&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                client.Send(mailMsg);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SmtpException ex)
            {

            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮件已发送，请注意查收！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();

            &lt;/span&gt;
&lt;span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.2 启动程序： 被告知已发送成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511153043343-1632724674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.3 打开Gmail确认是否发送了邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511153305923-1123361786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1237235/201905/1237235-20190511153333583-1879229853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成功接收！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来就可以把代码封装一下什么的以便于调用。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 May 2019 07:37:00 +0000</pubDate>
<dc:creator>千金不如一默</dc:creator>
<og:description>在.net core2.0以上版本中 发送所用到的API与.net framework一致。1.0版本好像有差别，好在高版本解决了这个问题。 为了方便查看效果，以控制台程序为例。 邮箱服务器以现在比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jixiaosa/p/10848857.html</dc:identifier>
</item>
<item>
<title>如何根据用例图写出用例描述 - SSS翱翔万里</title>
<link>http://www.cnblogs.com/SSSzhanglingzhi/p/10848840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SSSzhanglingzhi/p/10848840.html</guid>
<description>&lt;p&gt;&lt;span&gt;如何根据用例图写出用例描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;:&lt;/strong&gt;&lt;strong&gt;因为用例描述中的执行者和用例名很容易通过用例图得出来,&lt;/strong&gt;&lt;strong&gt;所以下面讲的主要内容是如何通过用例图获得用例描述中的&lt;span&gt;交互动作序列&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;A.用例分类是什么???&lt;/h2&gt;
&lt;p&gt;  用例分类是指把有关系(包含或扩展)的用例放到一起,与其他用例无关系的用例单独成排。&lt;/p&gt;
&lt;h2&gt;B.为什么要进行用例分类这步操作???(Benefits)&lt;/h2&gt;
&lt;p&gt;  1对于有关系的用例而言.它们的用例描述修改更方便。&lt;/p&gt;
&lt;p&gt;  2.能够有效提高书写用例描述的速度与质量。&lt;/p&gt;
&lt;h2&gt;C.如何进行用例分类???&lt;/h2&gt;
&lt;p&gt;分类标准:有无包含或扩展关系&lt;/p&gt;
&lt;p&gt;例如:在教务管理系统中有学生和教师这两个不同的执行者,&lt;/p&gt;
&lt;p&gt;  1.对于学生的”查询课表”用例而言,该用例是需要单独进行用例描述的&lt;/p&gt;
&lt;p&gt;      原因:与用例图中的其他用例无关系&lt;/p&gt;
&lt;p&gt;  2.而对于教师的”管理课表信息”用例而言,该用例是要放在一堆进行用例描述的&lt;/p&gt;
&lt;p&gt;      原因:管理课表信息还包括增加课程信息用例&lt;/p&gt;

&lt;p&gt;我们以学生在教务管理系统中查询课程信息为例来讲解操作流程P的具体使用方法。&lt;/p&gt;
&lt;p&gt;操作流程P的目的:写出用例描述中的交互动作序列&lt;/p&gt;
&lt;p&gt;操作流程P如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   a.1&lt;/strong&gt;&lt;strong&gt;找到执行者需要操作的信息和系统对执行者所发出的信息的反馈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       学生需要操作的信息:输入课程编号&lt;/p&gt;
&lt;p&gt;       系统的反馈:教务管理系统上显示课程的信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  a.2&lt;/strong&gt; &lt;strong&gt;执行者做了….&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       学生输入课程编号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  a.3&lt;/strong&gt;&lt;strong&gt;系统给出什么什么样的信息或者系统提示什么什么样的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       系统给出课程信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  a.4&lt;/strong&gt;&lt;strong&gt;检查逻辑性与语句是否通顺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       逻辑性:正确&lt;/p&gt;
&lt;p&gt;       语句是否通顺:是&lt;/p&gt;
&lt;p&gt;所以得到的交互动作序列如下所示:&lt;/p&gt;
&lt;p&gt;  1学生输入课程编号&lt;/p&gt;
&lt;p&gt;  2系统给出课程信息&lt;/p&gt;
&lt;p&gt;因此查询课程信息完整的用例描述如下所示&lt;/p&gt;
&lt;p&gt;  用例名:查询课程信息&lt;/p&gt;
&lt;p&gt;  执行者:学生&lt;/p&gt;
&lt;p&gt;  交互动作序列:&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;1学生输入课程编号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      2系统给出课程信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为关系有包含和拓展这两个关系&lt;/p&gt;
&lt;p&gt;所以对于有关系的用例要分以下两种情况讨论&lt;/p&gt;
&lt;h2&gt;A.包含:&lt;/h2&gt;
&lt;p&gt;第一步,把所有的包含用例列出来&lt;/p&gt;
&lt;p&gt;第二步,按照下面提供的模板写出交互动作序列&lt;/p&gt;
&lt;p&gt;模板: 1.执行者选择&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;、&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;……..或&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;n&lt;/span&gt; （n根据情况而定）&lt;/p&gt;
&lt;p&gt;            1.1执行者选择包含用例1:执行&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;            1.2执行者选择包含用例2:执行&lt;span&gt;包含用例2&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;  &lt;span&gt;  &lt;strong&gt;……….&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            1.n执行者选择包含用例n:执行&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;然后再把&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;、&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;……..或&lt;span&gt;包含用例&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;单独看成用例进行用例描述就行了。&lt;/p&gt;
&lt;p&gt;例如在图书管理系统中有如下用例描述&lt;/p&gt;
&lt;p&gt;   用例名:管理图书信息&lt;/p&gt;
&lt;p&gt;   执行者:图书管理员&lt;/p&gt;
&lt;p&gt;   交互动作序列:&lt;/p&gt;
&lt;p&gt;       1图书管理员选择&lt;span&gt;增加图书信息&lt;/span&gt;、&lt;span&gt;删除图书信息&lt;/span&gt;、&lt;span&gt;修改图书信息&lt;/span&gt;或&lt;span&gt;查询图书信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          1.1图书管理员选择增加图书信息: 执行&lt;span&gt;增加图书信息&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;          1.2图书管理员选择删除图书信息: 执行&lt;span&gt;删除图书信息&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;          1.3图书管理员选择修改图书信息: 执行&lt;span&gt;修改图书信息&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;          1.4图书管理员选择查询图书信息: 执行&lt;span&gt;查询图书信息&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;          &lt;span&gt; 增加图书信息&lt;/span&gt;子流程&lt;/p&gt;
&lt;p&gt;           1.图书管理员增加图书信息&lt;/p&gt;
&lt;p&gt;           2.系统提示图书信息增加成功&lt;/p&gt;
&lt;p&gt;        &lt;span&gt; 删除图书信息&lt;/span&gt;子流程:&lt;/p&gt;
&lt;p&gt;          1.图书管理员删除图书信息&lt;/p&gt;
&lt;p&gt;          2.系统提示图书信息删除成功&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;修改图书信息&lt;/span&gt;子流程:&lt;/p&gt;
&lt;p&gt;         1.图书管理员修改图书信息&lt;/p&gt;
&lt;p&gt;         2.系统提示图书信息修改成功&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;查询图书信息&lt;/span&gt;子流程:&lt;/p&gt;
&lt;p&gt;        1.图书管理员输入图书的编号&lt;/p&gt;
&lt;p&gt;        2.系统给出图书的详细信息&lt;/p&gt;
&lt;h2&gt;B.扩展&lt;/h2&gt;
&lt;p&gt;1.按照操作流程P写出正常情况下的交互动作序列&lt;/p&gt;
&lt;p&gt;2.再在后面加上拓展动作序列(异常情况)即可&lt;/p&gt;
&lt;p&gt;那么如何书写拓展动作序列呢???&lt;/p&gt;
&lt;p&gt;模板如下:&lt;/p&gt;
&lt;p&gt;1.a如果执行者+异常情况&lt;/p&gt;
&lt;p&gt;   1.a.1执行者干了…&lt;/p&gt;
&lt;p&gt;   1.a.2 系统给出或提示….&lt;/p&gt;
&lt;p&gt;例如在图书管理系统中,用户在登录时忘记密码了,那么忘记密码就是登录的一种异常情况&lt;/p&gt;
&lt;p&gt;所以登录的扩展动作序列如下所示&lt;/p&gt;
&lt;p&gt;1.a如果用户忘记密码&lt;/p&gt;
&lt;p&gt;   1.a.1用户发送找回密码请求&lt;/p&gt;
&lt;p&gt;   1.a.2系统给出改密链接&lt;/p&gt;
&lt;p&gt;   1.a.3 用户执行改密操作&lt;/p&gt;
&lt;p&gt;   1.a.4 系统提示改密成功&lt;/p&gt;

&lt;p&gt;1关系指的是包含或扩展关系&lt;/p&gt;
&lt;p&gt;2包含用例指的是小范围的用例。&lt;/p&gt;
&lt;p&gt;   例如: 对于管理图书信息和增加图书信息这两个用例而言,小范围的用例是增加图书信息,因此包含用例指的是增加图书信息。&lt;/p&gt;
&lt;p&gt;3.用例描述的基本结构如下&lt;/p&gt;
&lt;p&gt;  用例名:xxxxx&lt;/p&gt;
&lt;p&gt;  执行者:xxx&lt;/p&gt;
&lt;p&gt;  交互动作序列:xxxxxxxxxxxx&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于本人水平有限,所以本随笔可能会存在一些问题。望您能及时指出，谢谢您的支持。&lt;/strong&gt;&lt;strong&gt;同时也欢迎您在评论区发表你的任何看法。&lt;/strong&gt;&lt;strong&gt;最后感谢您的阅读。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 May 2019 07:34:00 +0000</pubDate>
<dc:creator>SSS翱翔万里</dc:creator>
<og:description>如何根据用例图写出用例描述 前言:因为用例描述中的执行者和用例名很容易通过用例图得出来,所以下面讲的主要内容是如何通过用例图获得用例描述中的交互动作序列。 第一步 用例分类 A.用例分类是什么???</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SSSzhanglingzhi/p/10848840.html</dc:identifier>
</item>
<item>
<title>支付渠道路由系统进化史 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10848843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10848843.html</guid>
<description>&lt;p&gt;支付系统一般需要对接多个支付渠道，一是为了保证系统的可靠性，不能因为单一渠道的问题影响整个支付系统。二是为了提高支付能力，不同渠道提供支付能力不同。三是为了降低支付成本。&lt;/p&gt;
&lt;p&gt;对接多个支付渠道以后，为了可以正确选择支付渠道支付，因此设计渠道路由系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558169256-15e8c953-61d3-4e2e-8dce-c3ede1e4751a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到路由系统功能其实很简单，分发支付请求到正确的渠道。但就是这个简单系统，也经过几次系统改造升级，最终才成为现在的样子。下面就来说说这个系统是如何演进。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下面假设对接支付渠道为支付宝与微信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;初期&quot;&gt;初期&lt;/h2&gt;
&lt;p&gt;支付系统初期，这个阶段业务需求较简单，仅仅需要满足一个支付场景（例如使用支付宝支付）。为了快速上线，设计方案就简单粗暴，对外直接暴露支付服务接口，由业务系统发起直接调用。&lt;/p&gt;
&lt;p&gt;系统设计图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558195734-f56b2af2-5983-48c0-b702-6a7b7f538c37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个阶段由于只有一个支付渠道，所以也不需要有路由系统，直接由业务系统调用支付服务接口发起支付。&lt;/p&gt;
&lt;p&gt;这个设计方案存在很多问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务系统与支付系统位于同一个系统，系统任何一次变更都会影响整个系统。&lt;/li&gt;
&lt;li&gt;扩展性问题。接入新支付渠道，如微信，需要新暴露一个微信支付服务接口。业务系统需要改动代码。从另一方面讲，业务系统承担路由系统的功能。&lt;/li&gt;
&lt;li&gt;复用性。新支付渠道，其实除了与支付渠道交互相关代码之外，其他代码可以复用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;针对以上问题，将系统进行了相应改造。&lt;/p&gt;
&lt;p&gt;首先是将支付系统与业务系统单独拆分出来，成为两套单独的系统。支付系统对外暴露一组通用接口。业务系统仅对接这组接口。业务系统若想指定支付渠道支付，接口参数传入渠道标识即可。这样就将耦合在业务系统中路由功下沉到支付系统。&lt;/p&gt;
&lt;p&gt;其次梳理渠道接口文档，抽象出共性接口。接入新支付渠道，只要继承接口，实现相关方法即可，简化渠道开发难度。&lt;/p&gt;
&lt;p&gt;改版后的系统实现图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558239646-5806ad80-c2f5-414b-b635-b0dfd150f44a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，路由系统知识支付系统的一个模块，具体实现如下。&lt;/p&gt;
&lt;p&gt;首先定义通用渠道接口，其中 &lt;strong&gt;channelName&lt;/strong&gt; 方法，返回渠道渠道唯一标识，如支付宝渠道返回 &lt;strong&gt;aliPay&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558264457-c6bac4bb-077f-4dad-b197-8bb33345983e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后根据 &lt;strong&gt;Spring ApplicationContext getBeansOfType&lt;/strong&gt; 方法，获取实现同一个接口的所有 &lt;strong&gt;Bean&lt;/strong&gt;.最后将其放入 Map 缓存中，其中键值为 &lt;strong&gt;channelName&lt;/strong&gt; 方法返回渠道标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558278244-6a64cce2-d481-47bf-a55f-ec4061adfd2c.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个阶段方案的问题在于支付系统所有模块位于同一工程。有些模块需要频繁发布，而有些模块，如渠道模块，路由模块改动就很少。这样就导致系统任一改动发布，影响整个支付系统可用性。&lt;/p&gt;
&lt;h2 id=&quot;中期&quot;&gt;中期&lt;/h2&gt;
&lt;p&gt;针对初期后面的问题，进行了相应改造。&lt;/p&gt;
&lt;p&gt;首先还是进行拆分，将支付系统按照模块拆分。路由系统，渠道系统，成为独立系统，独立部署维护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558294307-e5e382cd-8cb5-4a15-9143-ebd8642f0d8a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统之间调用采用 RPC 通讯，使用 Dubbo 框架。&lt;/p&gt;
&lt;p&gt;相关实现如下：&lt;/p&gt;
&lt;p&gt;相关接口逻辑不变，只是将同一进程内调用变成跨系统的调用。&lt;/p&gt;
&lt;p&gt;渠道系统提供服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558310084-41c9b01a-dc0e-45c7-bd8c-5baa053bcc27.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里改动，将渠道标识放入 Dubbo 服务 &lt;strong&gt;group&lt;/strong&gt; 字段，借助 Dubbo 分组功能标识中唯一的渠道系统。&lt;/p&gt;
&lt;p&gt;路由系统引用渠道系统的服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558332575-d80f014c-c6b5-423a-817c-18189be97d6b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里同样需要设置 &lt;strong&gt;group&lt;/strong&gt; 且需要和服务提供者一致。然后在路由系统中将服务注册到缓存中，使用渠道标识为 key，渠道服务名为 value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558342097-e514538a-9921-4064-8ee5-723d45a3f29a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后路由系统借助 &lt;strong&gt;Spring ApplicationContext getBean&lt;/strong&gt; 获取具体的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558355530-0b6c9d0d-5311-475b-8592-d0c014a54922.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个设计的问题在于：&lt;/p&gt;
&lt;p&gt;路由系统中需要手动引用渠道系统服务，然后再注册。这样在增加渠道系统就比较繁琐。那是不是可以做到增加渠道系统时，无需修改路由系统，路由系统自动发现服务？&lt;/p&gt;
&lt;p&gt;借助 &lt;strong&gt;Dubbo API&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;后期&quot;&gt;后期&lt;/h2&gt;
&lt;p&gt;查看 &lt;a href=&quot;https://dubbo.apache.org/zh-cn/docs/user/configuration/api.html&quot;&gt;Dubbo 文档&lt;/a&gt;，可以直接使用 ReferenceConfig 直接查找服务提供者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558370850-a844af4a-344a-4704-b7d8-732ede9a0041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方文档建议：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里使用&lt;a href=&quot;https://dubbo.apache.org/zh-cn/docs/user/demos/reference-config-cache.html&quot;&gt;ReferenceConfigCache&lt;/a&gt;，用于缓存 &lt;strong&gt;ReferenceConfig&lt;/strong&gt; 实例。&lt;/p&gt;
&lt;p&gt;去除之前所有引用服务配置文件以及缓存注册代码，引入 &lt;strong&gt;ReferenceConfigCache&lt;/strong&gt;，改造如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1557558407643-2a4bb2e3-c491-45d3-a93e-b6c86f8b352e.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;回顾上文路由系统，可以看到初期没有路由系统，整个系统可以运行下去。但是随着系统复杂度提高，初期系统架构已经不能满足系统的高效运行，所以才一步步改进系统。改进的过程中，不断发现方案不足处，然后一步步迭代演进。这个过程中，要善于利用现有框架的功能，加速功能的开发。&lt;/p&gt;
</description>
<pubDate>Sat, 11 May 2019 07:34:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>支付系统一般需要对接多个支付渠道，一是为了保证系统的可靠性，不能因为单一渠道的问题影响整个支付系统。二是为了提高支付能力，不同渠道提供支付能力不同。三是为了降低支付成本。 对接多个支付渠道以后，为了可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10848843.html</dc:identifier>
</item>
<item>
<title>Java并发之等待/通知机制 - 狼爷</title>
<link>http://www.cnblogs.com/powercto/p/10848825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powercto/p/10848825.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;本篇文章默认大家对&lt;code&gt;synchronized&lt;/code&gt;跟&lt;code&gt;ReentrantLock&lt;/code&gt;有一定了解。&lt;/p&gt;
&lt;h2 id=&quot;先来段代码放松一下&quot;&gt;1.1 先来段代码放松一下&lt;/h2&gt;
&lt;p&gt;下面一段简单的代码，主要是通过3个线程对count进行累计来进行模拟多线程的场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * zhongxianyao
 */
public class Test {
    private static final int N = 3;
    private int count = 0;

    public void doSomething() {
        // 实际业务中，这里可能是远程获取数据之类的耗时操作
        for (int i=0; i&amp;lt;1000_000; i++) {
            synchronized (this) {
                count ++;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Test test = new Test();
        for (int i=0; i&amp;lt;N; i++) {
            Runnable runnable = () -&amp;gt; test.doSomething();
            new Thread(runnable).start();
        }

        Thread.sleep(1000);
        System.out.println(test.count);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在多线程编程中，一旦调用start()后，什么时候真正分配CPU时间片运行是不确定的，运行多久也是不确定的，所以有时候可能根据经验，预估一下程序的运行时间，然后进行sleep，最后获取结果。但这种方式太low了，有没有那么一种方式，当程序获取到结果后进行通知呢？下面将引出今天要讲的等待/通知机制。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;一段入门代码&quot;&gt;2.1 一段入门代码&lt;/h2&gt;
&lt;p&gt;先来一段代码看一下wait()/notify()的基本用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * zhongxianyao
 */
public class Test {

    private static final int N = 3;
    private int count = 0;
    private int finishCount = 0;

    public void doSomething() {
        for (int i=0; i&amp;lt;1000_000; i++) {
            synchronized (this) {
                count ++;
            }
        }
        synchronized (this) {
            finishCount ++;
            notify();
        }
    }

    public static void main(String[] args) {
        Test test = new Test();
        for (int i=0; i&amp;lt;N; i++) {
            Runnable runnable = () -&amp;gt; test.doSomething();
            new Thread(runnable).start();
        }

        synchronized (test) {
            try {
                while (test.finishCount != N) {
                    test.wait();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println(test.count);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果输出&lt;code&gt;3000000&lt;/code&gt;，结果是正确，是自己想要的。&lt;/p&gt;
&lt;h2 id=&quot;问题三连击&quot;&gt;2.2 问题三连击&lt;/h2&gt;
&lt;h3 id=&quot;a.为什么官方说wait-要放在while里面&quot;&gt;a.为什么官方说wait() 要放在while里面？&lt;/h3&gt;
&lt;p&gt;接口描述如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:
     synchronized (obj) {
         while (&amp;lt;condition does not hold&amp;gt;)
             obj.wait();
         ... // Perform action appropriate to condition
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译一下：在一个论点版本中，中断跟虚假唤醒是可能，所以这个方法应始终放在一个循环中。&lt;/p&gt;
&lt;p&gt;加上一句自己的解释：一般在项目中，一个线程不可能无缘无故等待，总是需要在某种条件下进行等待，而且其他线程唤醒这个线程的时候，可能用的是notifyAll()，数据被其他线程消费了，这里需要在判断一下是否满足特定的条件再继续运行。&lt;/p&gt;
&lt;h3 id=&quot;b.为什么wait必须在同步方法代码块中调用&quot;&gt;b.为什么wait()必须在同步方法/代码块中调用？&lt;/h3&gt;
&lt;p&gt;解释1：wait()本身设计的逻辑就是在释放锁进行等待，如果没有获取锁，谈何释放。&lt;/p&gt;
&lt;p&gt;解释2：通常在wait()的方法前面都会有while语句的判断，在这两条语句中会有时间间隔，可能会破坏程序，需要加上synchronized同步代码块来保证原子操作。&lt;/p&gt;
&lt;h3 id=&quot;c.为什么wait-notify-和-notifyall是定义在object里面而不是在thread里面&quot;&gt;c.为什么wait(), notify() 和 notifyAll()是定义在Object里面而不是在Thread里面？&lt;/h3&gt;
&lt;p&gt;因为wait()等方法都是锁级别操作，再者Java提供的锁都是对象级别的而不是线程级别的，每个对象都有锁。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。&lt;/p&gt;
&lt;h2 id=&quot;waitlong-timeout&quot;&gt;2.3 wait(long timeout)&lt;/h2&gt;
&lt;p&gt;在上面的例子中，如果&lt;code&gt;notify();&lt;/code&gt;那行代码删除，&lt;code&gt;wait()&lt;/code&gt;改为&lt;code&gt;wait(100)&lt;/code&gt;，如下，那么程序是否可以获取到正确的结果呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * zhongxianyao
 */
public class Test {

    private static final int N = 3;
    private int count = 0;
    private int finishCount = 0;

    public void doSomething() {
        for (int i=0; i&amp;lt;1000_000; i++) {
            synchronized (this) {
                count ++;
            }
        }
        synchronized (this) {
            finishCount ++;
            //notify();
        }
    }

    public static void main(String[] args) {
        Test test = new Test();
        for (int i=0; i&amp;lt;N; i++) {
            Runnable runnable = () -&amp;gt; test.doSomething();
            new Thread(runnable).start();
        }

        synchronized (test) {
            try {
                while (test.finishCount != N) {
                    test.wait(100);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        System.out.println(test.count);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是&lt;code&gt;3000000&lt;/code&gt;，是正确的结果，看了一下文档，发现这个字段跟直觉理解的不一样，直觉告诉我，这个是最长等多久，等太久了就&lt;code&gt;InterruptedException&lt;/code&gt;，结果不是。这个方法设置的时间，是说等待多久就唤醒自己。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;用condition进行替换&quot;&gt;3.1 用Condition进行替换&lt;/h2&gt;
&lt;p&gt;下面的代码，把前一个例子中的synchronized代码块，换成了lock()/unlock，notify()换成了condition.signal()，wait()换成了condition.await()。运行结果也是正确的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * zhongxianyao
 */
public class Test {

    private static final int N = 3;
    private int count = 0;
    private int finishCount = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void doSomething() {
        for (int i=0; i&amp;lt;1000_000; i++) {
            synchronized (this) {
                count ++;
            }
        }
        lock.lock();
        finishCount ++;
        if (finishCount == N) {
            condition.signal();
        }
        lock.unlock();
    }

    public static void main(String[] args) {
        Test test = new Test();
        for (int i=0; i&amp;lt;N; i++) {
            Runnable runnable = () -&amp;gt; test.doSomething();
            new Thread(runnable).start();
        }

        test.lock.lock();
        try {
            test.condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            test.lock.unlock();
        }

        System.out.println(test.count);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;signal方法后不建议添加逻辑&quot;&gt;3.2 signal()方法后不建议添加逻辑&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class ConditionTest {

    public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        new Thread(() -&amp;gt; {
            try {
                long time = System.currentTimeMillis();
                lock.lock();
                System.out.println(&quot;await start&quot;);
                condition.await();
                System.out.println(&quot;await end &quot; + (System.currentTimeMillis() - time) + &quot;ms&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, &quot;Thread-await&quot;).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        new Thread(() -&amp;gt; {
            try {
                lock.lock();
                System.out.println(&quot;signal start&quot;);
                TimeUnit.SECONDS.sleep(5);
                condition.signal();
                System.out.println(&quot;signal end&quot;);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
                System.out.println(&quot;signal unlock&quot;);
            }
        }, &quot;Thread-signal&quot;).start();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多次运行，结果都是一样的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;await start
signal start
signal end
signal unlock
await end 5005ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从运行结果可以看出，await()后，锁就释放了，但signal()后，锁不释放，一定要在unlock()之后，锁才释放，await()才会往下执行。&lt;/p&gt;
&lt;p&gt;既然唤醒了其他线程，又不释放锁，可以调整唤醒的时机。一般在实际代码中，也是不建议signal()方法后添加逻辑，应该直接释放锁。&lt;/p&gt;
&lt;p&gt;同理，上面的notify()也是在synchronized代码块结束后，wait()后面的语句才能真正执行。&lt;/p&gt;
&lt;h2 id=&quot;boolean-awaitlong-time-timeunit-unit&quot;&gt;3.3 boolean await(long time, TimeUnit unit)&lt;/h2&gt;
&lt;p&gt;把上面的&lt;code&gt;condition.await()&lt;/code&gt;改为&lt;code&gt;condition.await(1, TimeUnit.SECONDS)&lt;/code&gt;,然后获取返回值，运行结果返回的是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个时候，如果把&lt;code&gt;TimeUnit.SECONDS.sleep(5)&lt;/code&gt;，&lt;code&gt;condition.signal()&lt;/code&gt;这两行代码顺序调换一下，那么&lt;code&gt;await&lt;/code&gt;的返回值就是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再看到官方文档对这个返回值的描述，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{@code false} if the waiting time detectably elapsed
before return from the method, else {@code true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;翻译过来，大致意思就是“如果等待时间可以在方法返回之前检测到返回false，否则返回true”。但实际测试结果却是&lt;code&gt;await()&lt;/code&gt;被唤醒的时候，而不是方法返回的时候。&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;Object wait() notify() 搭配synchronized使用&lt;/li&gt;
&lt;li&gt;Condition await() signal() 搭配Lock使用&lt;/li&gt;
&lt;li&gt;Object notify() 是随机唤醒一个&lt;/li&gt;
&lt;li&gt;Condition signal() 是唤醒第一个await()的线程&lt;/li&gt;
&lt;li&gt;Object wait()有虚假唤醒，而Condition await() 没有&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html&lt;/li&gt;
&lt;li&gt;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html&lt;/li&gt;
&lt;li&gt;https://stackoverflow.com/questions/2779484/why-must-wait-always-be-in-synchronized-block&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 11 May 2019 07:31:00 +0000</pubDate>
<dc:creator>狼爷</dc:creator>
<og:description>描述Object wait()/notify()跟Condition await()/signal()的基本用法，三连问：解释为什么wait() 要放在while里面？为什么wait()方法放在Obj</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powercto/p/10848825.html</dc:identifier>
</item>
<item>
<title>深度学习工作站攒机指南 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/deeplearning-workstation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/deeplearning-workstation.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;接触深度学习已经快两年了，之前一直使用&lt;a href=&quot;https://colab.research.google.com&quot;&gt;Google Colab&lt;/a&gt;和&lt;a href=&quot;https://www.kaggle.com/kernels&quot;&gt;Kaggle Kernel&lt;/a&gt;提供的免费GPU（Tesla K80）训练模型（最近Google将Colab的GPU升级为&lt;strong&gt;Tesla T4&lt;/strong&gt;，计算速度又提升了一个档次），不过由于内地网络的原因，Google和Kaggle连接十分不稳定，经常断线重连，一直是很令人头痛的问题，而且二者均有很多限制，例如Google Colab一个脚本运行的最长时间为12h，Kaggle的为6h，数据集上传也存在问题，需要使用一些Trick才能达成目的，模型的保存、下载等都会耗费很多精力，总之体验不是很好，不过免费的羊毛让大家撸，肯定会有一些限制，也是可以理解的。&lt;/p&gt;
&lt;p&gt;对于租用云服务器，之前也尝试过，租用了一家小平台的GPU服务器，也存在一些操作上的困难，不适合程序调试，而且价格也不便宜。&lt;/p&gt;
&lt;p&gt;很早之前就想要搭建一个自己的深度学习工作站，不过机器成本的昂贵，一直阻碍着我攒机计划的进行。工欲善其事，必先利其器！最近终于下定决心，置办一个深度学习工作站主机。本文将我在这段时间选择、购置硬件的心得体会，分享给大家。&lt;/p&gt;
&lt;h2 id=&quot;配置清单&quot;&gt;配置清单&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel 酷睿i7 6950X 至尊版&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3300&lt;/td&gt;
&lt;td&gt;散片&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;主板&lt;/td&gt;
&lt;td&gt;华硕 RAMPAGE V EXTREME X99 主板&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1085&lt;/td&gt;
&lt;td&gt;二手&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;海盗船 复仇者LPX 16GB DDR4 2400&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1920&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;HDD&lt;/td&gt;
&lt;td&gt;西部数据 WD40EZRZ 蓝盘 4TB&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;550&lt;/td&gt;
&lt;td&gt;OEM&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SSD&lt;/td&gt;
&lt;td&gt;西数 WDS100T2X0C 黑盘 1TB&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1220&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;显卡&lt;/td&gt;
&lt;td&gt;影驰 GeForce RTX 2070 大将&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3400&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;机箱&lt;/td&gt;
&lt;td&gt;爱国者（aigo）月光宝盒 破晓&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;264&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;电源&lt;/td&gt;
&lt;td&gt;鑫谷 GP1350G 1250W&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;680&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;散热器&lt;/td&gt;
&lt;td&gt;爱国者（aigo）冰塔T240 极光版&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;299&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;风扇&lt;/td&gt;
&lt;td&gt;金河田 光影炫光 12CM&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;全新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;12778&lt;/td&gt;
&lt;td&gt;总计&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以上就是我主机的配置清单，目前只买了一张2070，后期会升级加入多卡，下面将详细分析一下各个配件的选购过程。&lt;/p&gt;
&lt;h2 id=&quot;配件选购指南&quot;&gt;配件选购指南&lt;/h2&gt;
&lt;h3 id=&quot;主板&quot;&gt;主板&lt;/h3&gt;
&lt;p&gt;有很多朋友在进行选购主机的时候认为应该先选CPU再选主板，个人认为配件选购的顺序和主机的用途是有关系的，对于搭建深度学习工作站而言，在正式进行硬件选购前，最重要的是需要确认一个问题，到底需要单卡（GPU）主机还是多卡主机，如果只需要搭建单显卡的主机，那么在选购主板的过程中，不需要花费太多精力，大量主板可以满足要求，如果想要搭建双卡、三卡或是四卡主机，则需要在主板上下点功夫，为了日后升级方便，我的目标是使用可支持四显卡的主机，所以在主板选择方面，会很注重PCIE扩展接口数量。&lt;/p&gt;
&lt;p&gt;在初期选择主板时，网上各式各样型号的主板会使小萌新（我）很是懵逼，在网上查找了些资料，了解了些主板的知识。为了保证CPU和主板搭配合理，装到一起能正常工作，首先我们需要了解各主板芯片组和CPU接口的具体含义。例如，下图为京东的主板截图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/1557387815846.png&quot; alt=&quot;京东主板商品截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到大多数商品名称后面都会有一个类似（AMD A320/Socket AM4）或（Intel H310/LGA 1151）的注释，其实这些就是影响你CPU和主板能否匹配的最重要参数了，在商品详情页，我们也可以找到这个参数，前面的“Intel H310”或“AMD A320”指的就是主板的芯片组，而后面的“LGA 1151”或“Socket AM4”指的就是主板上CPU插槽的类型了。&lt;/p&gt;
&lt;h4 id=&quot;芯片组&quot;&gt;芯片组&lt;/h4&gt;
&lt;p&gt;芯片组示主板的核心芯片，选对芯片组，主板和CPU才能兼容。目前主流的主板分为Intel和AMD两个系列，分别对应不同品牌的处理器。而每个系列又按照芯片组类型的不同，分为很多子系列。以Intel系列主板为例，在市面上可以看到华硕、技嘉、七彩虹等近十个品牌的产品，不同品牌的主板在外观和技术上会有一些差别，但他们使用的芯片组都是由Intel提供的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/intel%20chipset.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过，虽然同属于Intel系列主板，但根据处理器的不同，需要搭配对应芯片组的主板才能成功组建出一台可以使用的主机。比如目前Intel最新的九代酷睿 i9-9900k 处理器需要搭配Z390、Z370或H370芯片组的主板来使用。而AMD的Ryzen 3/5/7系列CPU和APU产品则可以搭配X370、B350或A320芯片组的主板。&lt;/p&gt;
&lt;p&gt;那么不同芯片组的主板又有什么区别呢？有的时候，多个芯片组的主板虽然可以支持同一款处理器，但在主板的规格上还是有一定区别的。这些区别包括但不限于原生USB及磁盘接口数量、是否支持CPU超频、是否支持多显卡互联等。这对于不太了解主板的用户来说确实很难选择，简单总结一下：&lt;/p&gt;
&lt;p&gt;B系列（如B360、B250）属于入门级产品，不具备超频和多卡互联的功能，同时接口及插槽数量也相对要少一些。&lt;br/&gt;H系列（如H310）比B系列略微高端一些，可以支持多卡互联，接口及插槽数量有所增长。&lt;br/&gt;Z系列（如Z390、Z370）除了具备H系列的特点支持，还能够对CPU进行超频，并且接口和插槽数量也非常丰富。&lt;br/&gt;X系列（如X99、X299）可支持Intel至尊系列高端处理器，同时具备Z系列的各项特点。&lt;/p&gt;
&lt;p&gt;同时，Intel的100系列和200系列主板可以搭配6代及7代酷睿处理器，300系列主板需要搭配8代酷睿处理器，X299系列主板需要搭配7代至尊系列酷睿处理器。&lt;/p&gt;
&lt;p&gt;对于单路CPU的主板，能够同时支持四张显卡卡的神板，毫无疑问就只有X99/X299系列的主板了，当然你也可以考虑intel 服务器C系列多路CPU主板，可以支持两个CPU在一张主板上。我的目标是使用单路CPU，所以也就没有关注C系列主板。&lt;/p&gt;
&lt;p&gt;对于X299和X99之间的选择，有的朋友会主张买新不买旧，我个人的建议还是性价比高才是好的，较新的X299板子相比X99主板要贵大几百甚至1k左右，功能上的提升并不是很大，对于我们大多数Deep Learning开发者而言，X99的板子足够了，毕竟要把钱花在刀刃上，GPU才是大手笔。X99板子主要推荐以下三款：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.asus.com.cn/Motherboards/X99E_WSUSB_31/&quot;&gt;Asus/华硕 X99-E WS/USB 3.1&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/x99ews.png&quot; alt=&quot;Asus/华硕 X99-E WS/USB 3.1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.asus.com.cn/Motherboards/RAMPAGE_V_EXTREMEU31/overview/&quot;&gt;Asus/华硕 RAMPAGE V EXTREME/U3.1&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/R5E.jpg&quot; alt=&quot;Asus/华硕 RAMPAGE V EXTREME/U3.1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.msi.com/Motherboard/X99S-GAMING-7.html&quot;&gt;MSI/微星 X99S GAMING 7&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/gaming7.png&quot; alt=&quot;MSI/微星 X99S GAMING 7&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对比&quot;&gt;对比&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;主芯片组&lt;/td&gt;
&lt;td&gt;Intel X99&lt;/td&gt;
&lt;td&gt;Intel X99&lt;/td&gt;
&lt;td&gt;Intel X99&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CPU插槽&lt;/td&gt;
&lt;td&gt;LGA 2011-v3&lt;/td&gt;
&lt;td&gt;LGA 2011-v3&lt;/td&gt;
&lt;td&gt;LGA 2011-v3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;内存规格&lt;/td&gt;
&lt;td&gt;8×DDR4 DIMM 四通道&lt;/td&gt;
&lt;td&gt;8×DDR4 DIMM 四通道&lt;/td&gt;
&lt;td&gt;8×DDR4 DIMM 四通道&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;最大内存容量&lt;/td&gt;
&lt;td&gt;128GB&lt;/td&gt;
&lt;td&gt;128GB&lt;/td&gt;
&lt;td&gt;128GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PCI-E标准&lt;/td&gt;
&lt;td&gt;PCI-E 3.0&lt;/td&gt;
&lt;td&gt;PCI-E 3.0&lt;/td&gt;
&lt;td&gt;PCI-E 3.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PCI-E插槽&lt;/td&gt;
&lt;td&gt;4×PCI-E X16 插槽&lt;/td&gt;
&lt;td&gt;5×PCI-E X16 插槽&lt;br/&gt;1×PCI-E X1 插槽&lt;/td&gt;
&lt;td&gt;7×PCI-E X16 插槽&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;存储接口&lt;/td&gt;
&lt;td&gt;10×SATA III&lt;br/&gt;1×SATA Express&lt;br/&gt;1×M.2（10Gb/s）&lt;/td&gt;
&lt;td&gt;1×M.2&lt;br/&gt;2×SATA Express&lt;br/&gt;8×SATA III&lt;/td&gt;
&lt;td&gt;1×M.2&lt;br/&gt;2×SATA Express&lt;br/&gt;8×SATA III&lt;br/&gt;2×eSATA&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;USB接口&lt;/td&gt;
&lt;td&gt;6×USB2.0（2背板+4内置）&lt;br/&gt;12×USB3.0（4背板+8内置）&lt;/td&gt;
&lt;td&gt;14×USB3.0（4内置+10背板）&lt;br/&gt;6×USB2.0（4内置+2背板）&lt;/td&gt;
&lt;td&gt;14×USB3.0（4内置+10背板）&lt;br/&gt;4×USB2.0（4内置）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;主板板型&lt;/td&gt;
&lt;td&gt;ATX板型&lt;/td&gt;
&lt;td&gt;E-ATX板型&lt;/td&gt;
&lt;td&gt;E-ATX板型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;外形尺寸&lt;/td&gt;
&lt;td&gt;30.5×24.4cm&lt;/td&gt;
&lt;td&gt;30.5×27.2cm&lt;/td&gt;
&lt;td&gt;30.5×26.7cm&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;多显卡技术&lt;/td&gt;
&lt;td&gt;NVIDIA 3-Way SLI&lt;br/&gt;NVIDIA 3-Way SLI&lt;/td&gt;
&lt;td&gt;NVIDIA 4-Way SLI&lt;br/&gt;AMD 4-Way CrossFireX&lt;/td&gt;
&lt;td&gt;NVIDIA 4-Way SLI&lt;br/&gt;AMD 4-Way CrossFire&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到这三款主板，均为X99芯片组，CPU插槽均为 LGA 2011-v3 ，而且有8个内存插槽，支持四通道，最高128G的内存容量，内存容量这部分个人很喜欢，对于大型数据集数据预处理的过程，对内存容量和CPU要求都很高，而且足够的内存容量使你不用再为多开窗口卡顿现象而担忧。三者都支持多显卡扩展，华硕R5E和华硕X99 E-WS均支持4显卡交火，微星X99S Gaming 7支持3显卡交火，不过显卡交火，对于深度学习计算没有任何的帮助，对游戏确是有一些提升，我们日常所说的多显卡训练模型，也不是用到交火技术，而是Data Parallel或Model Parallel，所以交火与否我们不需要关注，需要关注的时PCIE ×16扩展插槽的有效个数（有的间距太近，无法全插）。&lt;/p&gt;
&lt;p&gt;起初最想购买的是“华硕 X99-E WS”，经典的工作站主板，很多深度学习开发者的首选，支持四路显卡交火，更为优秀的是竟然有7个×16全速PCIE 3.0扩展插槽，但是对于这类主板虽然有如此强大的扩展功能，但在真正插显卡的时候，由于PCIE接口之间的空间限制，你是无法插满插槽的，而且现在显卡都很厚，很可能会造成接口的浪费。这个板子已经停产，不过在天猫的华硕旗舰店仍然有存货，售价“3899元”，还是很贵的。其中有很多功能，对于我们日常使用、训练模型来讲并不是很用得上，会造成没必要的开销。最后我选择了在淘宝购买二手的“华硕 RAMPAGE V EXTREME”，毕竟便宜。如果经费充足的朋友，我仍然建议购买“华硕 X99 E-WS”这个主板。&lt;/p&gt;
&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;p&gt;对于CPU的选取是基于确定主板CPU插槽类型为前提的，例如我们上文中我们选择的X99系列三款主板，CPU插槽类型均为“LGA 2011-v3”，我们就要选与此匹配的CPU，各插槽类型的CPU具体有哪些型号，可以去&lt;a href=&quot;http://detail.zol.com.cn/cpu/&quot;&gt;中关村在线&lt;/a&gt;查询，里面还有一些性能测评的文章和排行榜信息，值得推荐。&lt;/p&gt;
&lt;p&gt;为了能够为CPU做出明智的选择，我们首先需要了解CPU以及它与深度学习的关系。CPU为深度学习做了什么？当你在GPU上运行深度网络时，CPU几乎不会进行任何计算。它主要的作用是：（1）启动GPU函数调用，（2）执行CPU函数。&lt;/p&gt;
&lt;p&gt;CPU对于数据预处理的过程却起重要作用。有两种常见的数据处理策略，它们具有不同的CPU需求。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 一、在训练时进行数据预处理
for train_step in range(tot_train_step):
    load_mini_batch()
    preprocess_mini_batch()
    train_on_mini_batch()

# 二、在训练前进行数据预处理
preprocess_data()
for train_step in range(tot_train_step):
    load_preprocessed_mini_batch()
    train_on_mini_batch()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第一个策略，为避免CPU的性能成为训练模型的速度的瓶颈，具有高主频多内核的CPU可以显著提高性能，加快训练速度。对于第二种策略，由于是预先进行数据预处理，在训练时的速度取决于GPU性能，与CPU无关，理论上CPU的性能不会成为瓶颈。但是我个人的观点还是，在经费允许的情况下，尽管CPU的性能越强大越好，但是也不一定非要追求最新款、最强大的CPU，性价比和个人需求才是最关键的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当然，此处附加一点说明，如果攒机后不仅需要训练模型，而且偶尔也会玩一些游戏消遣的话，尽量选择高主频的主机，志强系列多核心低主频CPU不适合游戏玩家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;pcie-通道&quot;&gt;PCIe 通道&lt;/h4&gt;
&lt;p&gt;CPU的PCIe通道对模型训练的影响网上也纵说纷云，首先让我们先了解一下什么是CPU的PCIe通道&lt;/p&gt;
&lt;blockquote readability=&quot;7.6126315789474&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/PCI-Express&quot;&gt;PCI-Express&lt;/a&gt;(peripheral component interconnect express)是一种高速串行计算机扩展总线标准，它原来的名称为“3GIO”，是由&lt;a href=&quot;https://baike.baidu.com/item/%E8%8B%B1%E7%89%B9%E5%B0%94/305730&quot;&gt;英特尔&lt;/a&gt;在2001年提出的，旨在替代旧的PCI，PCI-X和AGP总线标准。PCIe属于高速串行点对点双通道高带宽传输，所连接的设备分配独享通道带宽，不共享总线带宽，主要支持主动电源管理，错误报告，端对端的可靠性传输，热插拔以及服务质量(&lt;a href=&quot;https://baike.baidu.com/item/QOS&quot;&gt;QOS&lt;/a&gt;)等功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，PCIe通道就是主机中各组件进行数据交互的信道，PCIe通道分两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CPU直连通道，主流消费级只给你16条(8700K)，高端&amp;amp;服务器上才会多给(7980XE)。&lt;/li&gt;
&lt;li&gt;DMI3总线PCH芯片分发出来的，是主板的属性。例如Z370主板声称有24条PCIE通道，其实这24条就是PCH通道，要共享DMI3等效直连PCIe ×4的带宽。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就PCH而言，在很多高性能扩展面前没有智联通道强大，所以对于CPU的直连通道数就显得至关重要了。&lt;/p&gt;
&lt;p&gt;Tim Dettmers大神在他的博文《&lt;a href=&quot;https://timdettmers.com/2018/12/16/deep-learning-hardware-guide/&quot;&gt;A Full Hardware Guide to Deep Learning&lt;/a&gt;》中也做出了对PCIe通路的见解，Tim认为在单机少量（小于4）GPU的主机中，PCIe通路对模型训练的影响并不是很大，但对于大于4个GPU或GPU集群PCIe通路的影响就会很显著。在文章中，Tim对比了不同通道数量在模型训练过程中的速度传输速度对比。&lt;/p&gt;
&lt;blockquote readability=&quot;39.872593950504&quot;&gt;
&lt;p&gt;&lt;strong&gt;CPU and PCI-Express&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;People go crazy about PCIe lanes! However, the thing is that it has almost no effect on deep learning performance. If you have a single GPU, PCIe lanes are only needed to transfer data from your CPU RAM to your GPU RAM quickly. However, an ImageNet batch of 32 images (32x225x225x3) and 32-bit needs 1.1 milliseconds with 16 lanes, 2.3 milliseconds with 8 lanes, and 4.5 milliseconds with 4 lanes. These are theoretic numbers, and in practice you often see PCIe be twice as slow — but this is still lightning fast! PCIe lanes often have a latency in the nanosecond range and thus latency can be ignored.&lt;/p&gt;
&lt;p&gt;Putting this together we have for an ImageNet mini-batch of 32 images and a ResNet-152 the following timing:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Forward and backward pass: 216 milliseconds (ms)&lt;/li&gt;
&lt;li&gt;16 PCIe lanes CPU-&amp;gt;GPU transfer: About 2 ms (1.1 ms theoretical)&lt;/li&gt;
&lt;li&gt;8 PCIe lanes CPU-&amp;gt;GPU transfer: About 5 ms (2.3 ms)&lt;/li&gt;
&lt;li&gt;4 PCIe lanes CPU-&amp;gt;GPU transfer: About 9 ms (4.5 ms)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Thus going from 4 to 16 PCIe lanes will give you a performance increase of roughly 3.2%. However, if you use &lt;a href=&quot;https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader&quot;&gt;PyTorch’s data loader&lt;/a&gt; with pinned memory you gain exactly 0% performance. So do not waste your money on PCIe lanes if you are using a single GPU!&lt;/p&gt;
&lt;p&gt;When you select CPU PCIe lanes and motherboard PCIe lanes make sure that you select a combination which supports the desired number of GPUs. If you buy a motherboard that supports 2 GPUs, and you want to have 2 GPUs eventually, make sure that you buy a CPU that supports 2 GPUs, but do not necessarily look at PCIe lanes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PCIe Lanes and Multi-GPU Parallelism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Are PCIe lanes important if you train networks on multiple GPUs with data parallelism? I have &lt;a href=&quot;https://arxiv.org/abs/1511.04561&quot;&gt;published a paper on this at ICLR2016&lt;/a&gt;, and I can tell you if you have 96 GPUs then PCIe lanes are really important. However, if you have 4 or fewer GPUs this does not matter much. If you parallelize across 2-3 GPUs, I would not care at all about PCIe lanes. With 4 GPUs, I would make sure that I can get a support of 8 PCIe lanes per GPU (32 PCIe lanes in total). Since almost nobody runs a system with more than 4 GPUs as a rule of thumb: Do not spend extra money to get more PCIe lanes per GPU — it does not matter!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过依我个人的看法，还是要选支持PCIe通道数大一点的CPU，毕竟M.2 NVME SSD就会占据四条通道，如果我们CPU只支持16通道，并且有两个GPU的话，每个GPU只能分到×4的速度，这个总感觉不太好。显卡已经花了那么多钱，我们当然希望它能全速跑，不要由于CPU PCIe通路的短板影响整体的性能，得不偿失。所以我更倾向于选择40条通路的CPU。目前主流CPU大多支持16通道、24通道，对于至尊系列CPU会有支持40通道的，对于大部分志强系列服务器CPU大多数支持44通道。&lt;/p&gt;
&lt;h4 id=&quot;对比-1&quot;&gt;对比&lt;/h4&gt;
&lt;p&gt;对于志强系列，网上所有渠道都基本是拆机CPU，很多是外国服务器淘汰下的CPU，质量方面，由于没有使用过，不妄加评论。志强系列U特点是核心多，单核主频低，如果对于高并发有需求的朋友，可以优先选择志强系列U，搭配双路服务器主板。但对于我个人来讲，对单核主频要求高一些，所以我更倾向于桌面级CPU。&lt;/p&gt;
&lt;p&gt;在我选择CPU的过程中，&lt;a href=&quot;https://diy.pconline.com.cn/tiantitu/cpu/&quot;&gt;CPU天梯图&lt;/a&gt;对我很有帮助，很直观的展现了Intel/AMD所有CPU的性能排行，也推荐给大家。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/cputianti.png&quot; alt=&quot;CPU天梯图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过反复的对比，最终锁定了两款CPU“i7-6850K”和“i7-6950X”，首先首先我先解释一下为什么没有选择最新的九代酷睿系列，目前九代酷睿发布没多久，例如“I9-9900K”也是炒的很火热， 虽然最新系列的CPU单核主频都有所提高，但是核心数并没有太大改善，致使CPU整体性能（多核性能）并不是越新越好，从上方的天梯图我们也可以看出，“I7-6950X”排在&quot;I9-9900K&quot;前面，第二个原因就是，CPU是一个没什么损耗的器件，如果没有变态超频使用的话，全新和二手的U新能没什么区别，对于这些已经停产的CPU，网上流通的都是拆机的二手版本，只要选择正式版（不要&lt;a href=&quot;http://www.lotpc.com/yjzs/6996.html&quot;&gt;QS/ES版本&lt;/a&gt;），其实都可以的，而且价格便宜，性价比极高，例如我们Intel官网可以看到“i7-6950X”的官方报价为￥11053.74，上万元！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/intel6950x.png&quot; alt=&quot;6950X官网&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在淘宝等渠道购买的正式版I7-6950X散片，只有3400元，价格差距如此之大。对于这种旧款CPU的散片（正式版）性价比还是蛮高的，所以推荐大家购买散片CPU（当然也会有很多朋友担心散片CPU的质量问题，这个确实不能保证每个渠道的U都是好的，看人品吧~）。下面对比一下“i7-6850K”、“I7-6950X”、“i75960X”以及“I7-6900K”这几款CPU。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;发行日期&lt;/td&gt;
&lt;td&gt;Q2'16&lt;/td&gt;
&lt;td&gt;Q2'16&lt;/td&gt;
&lt;td&gt;Q3'14&lt;/td&gt;
&lt;td&gt;Q2'16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;光刻&lt;/td&gt;
&lt;td&gt;14 nm&lt;/td&gt;
&lt;td&gt;14 nm&lt;/td&gt;
&lt;td&gt;22 nm&lt;/td&gt;
&lt;td&gt;14 nm&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;内核&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;线程&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;基本频率&lt;/td&gt;
&lt;td&gt;3.00 GHz&lt;/td&gt;
&lt;td&gt;3.60 GHz&lt;/td&gt;
&lt;td&gt;3.00 GHz&lt;/td&gt;
&lt;td&gt;3.20 GHz&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;睿频频率&lt;/td&gt;
&lt;td&gt;3.50 GHz&lt;/td&gt;
&lt;td&gt;3.80 GHz&lt;/td&gt;
&lt;td&gt;3.50 GHz&lt;/td&gt;
&lt;td&gt;3.70 GHz&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;缓存&lt;/td&gt;
&lt;td&gt;25 MB&lt;/td&gt;
&lt;td&gt;15 MB&lt;/td&gt;
&lt;td&gt;20 MB&lt;/td&gt;
&lt;td&gt;20 MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;TDP&lt;/td&gt;
&lt;td&gt;140 W&lt;/td&gt;
&lt;td&gt;140 W&lt;/td&gt;
&lt;td&gt;140 W&lt;/td&gt;
&lt;td&gt;140 W&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;最大内存&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;内存类型&lt;/td&gt;
&lt;td&gt;DDR4 2400/2133&lt;/td&gt;
&lt;td&gt;DDR4 2400/2133&lt;/td&gt;
&lt;td&gt;DDR4 1600/1866/2133&lt;/td&gt;
&lt;td&gt;DDR4 2400/2133&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;内存通道&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PCIe通道&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，四者均支持40条直通PCIe通道，当主板支持四路交火时，以“华硕RAMPAGE V EXTREME”为例，四张显卡分别占用（×8，×8，×8，×8）的速度，不会对性能产生太大影响。“I7-5960X”仅支持最高64GB的内存容量，这个对于我们的板子就略显不足了，相比“I7-6850K”和“I7-6900K”，在单核主频方面6850k基本频率为3.60GHz高于6900K的3.20GHz，不过核心数却没有胜出，二者基本属于同一等级的CPU，整体性能6900K略高于6850K，不过从性价比方面来看（散片），6850K的性价比还是略高的，散片售价仅2500元左右。“I7-6950X”是这几款U中性能最强劲的，虽然单核主频只有3.00GHz但是10核心20线程使其整体性能遥遥领先，可以从上文中的CPU天梯图中看到，尽管这个U是16年推出的，不过在当日的排行版也能排列到十几名，表现还是很出色的，唯一的不足就是价格略显昂贵，散片价格为3400元，之前一直想买2500元的6850K，后来一咬牙买了6950X。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/6950X_.jpg&quot; alt=&quot;I7-6950X散片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总之，在选购CPU时，建议需要以下顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;筛选与主板插槽类型匹配的CPU。&lt;/li&gt;
&lt;li&gt;查看&lt;a href=&quot;https://diy.pconline.com.cn/tiantitu/cpu/&quot;&gt;CPU天梯图&lt;/a&gt;，了解CPU的整体性能排序。&lt;/li&gt;
&lt;li&gt;在intel官网上将预选出的商品进行详细参数对比。&lt;/li&gt;
&lt;li&gt;淘宝、京东对比散片价格，考虑入手性价比高的U。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;个人建议：由于CPU这个东东如果正常使用基本没什么损耗，在选购散片时，会发现各个商家价格会有所差别，其实不一定要买最贵的，价格的不同可能是由于商家进货渠道引起的，只要认准“正式版”即可，避开“QS/ES”版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内存&quot;&gt;内存&lt;/h3&gt;
&lt;p&gt;内存是相对好选的组件，就没有必要多说了，以我个人来看，当然容量越大越好，毕竟现在内存价格低谷，抓紧买！&lt;/p&gt;
&lt;p&gt;建议“海盗船复仇者”系列，我在选购内存的时候，基本把淘宝翻了个遍，看了很多厂家，价格都很贵，而且有很多都是小厂。对于海盗船复仇者系列内存，很多DIY玩家的首选，也不是没有原因的，现在一条16G的台式内存，只卖不到500元，很是便宜！而且口碑一直不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/Vengeance_LPX_DDR4_BOX.png&quot; alt=&quot;海盗船 复仇者系列&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;频率&quot;&gt;频率&lt;/h4&gt;
&lt;p&gt;目前市场上的内存大多在频率上做了很多营销手段，我们可以看到（2133 MHz、2400MHz、3000MHz、3200MHz以至于更高）的内存频率，同容量不同频率的内存条价格也相差很多，贵几百元的都有。但是我们是否有必要追求高频率的内存呢？&lt;/p&gt;
&lt;p&gt;经过阅读网上一些大牛的文章，大多数人的观点都是，RAM频率对性能方面没有明显的提升，尤其是在做深度学习方面。其实频率只是各个厂商的一种营销手段，RAM公司会引诱大家购买“更快”的内存，其性价比并不高。有追求频率的钱，还不如多加一条内存。此处可参阅“&lt;a href=&quot;https://www.youtube.com/watch?v=D_Yt4vSZKVk&quot;&gt;Does RAM speed REALLY matter?&lt;/a&gt;”&lt;/p&gt;
&lt;p&gt;所以我入手了“海盗船 复仇者”系列单条16GB最便宜的内存&lt;strong&gt;2400 MHz&lt;/strong&gt;，一共上了4条，总共64GB。主板有8个内存插槽，先插四条构成四通道，剩余的留作扩展，不过此处一定注意， 在安装内存条的时候需要阅读主板说明书，基本每个主板都会给出推荐的插法，看好个插槽所在的通道，一定不要插错了。&lt;/p&gt;
&lt;h3 id=&quot;ssd&quot;&gt;SSD&lt;/h3&gt;
&lt;p&gt;在初期选购固态硬盘的朋友可能会经常看到SATA3固态硬盘与M.2固态硬盘，可能有朋友会有疑问：M.2是什么意思？和SATA3固态硬盘有什么区别？下面我们就简单科普M.2接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/M.2SSD.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;m.2接口&quot;&gt;M.2接口&lt;/h4&gt;
&lt;p&gt;M.2是一种固态硬盘新接口，是Intel推出的一种替代MSATA新的接口规范，也就是我们以前经常提到的NGFF，英文全称为：Next Generation Form Factor。&lt;/p&gt;
&lt;p&gt;M.2接口固态硬盘主要优势在于体积相比传统的SATA3.0、MSATA更小，并且读取速度更快，对于一些移动设备兼容性更好。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;M.2和SATA3固态硬盘的区别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前固态硬盘（SSD）常用的接口主要有3种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;SATA3&lt;/strong&gt; - 外形尺寸是2.5寸硬盘的标准尺寸，与2.5寸机械硬盘可以互换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mSATA&lt;/strong&gt; - 接口尺寸与笔记本内置无线网卡相同，不过mSATA SSD的外形尺寸比无线网卡更大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M.2&lt;/strong&gt; - 初期称为NGFF接口，是近两年新出的接口，为专门为超小尺寸而设计的，使用PCI-E通道，体积更小，速度更快。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;值得一提的是&lt;strong&gt;M.2接口固态硬盘又分为：SATA和PCI-E两种，虽说长得一模一样，但性能却是差之千里&lt;/strong&gt;。此外，有些主板的M.2接口不一定对其支持，所以在买M.2固态硬盘的时候，还需要了解下接口兼容性，在购买主板和SSD时关注一下接口信息即可。&lt;/p&gt;
&lt;p&gt;M.2有两种接口定义：Socket 2和Socket 3。Socket 2支持SATA或PCIe ×2通道的SSD，Socket 3专为高性能存储设计，支持PCIe ×4通道。在购买SSD时一定要确认是否走PCIe ×4通道，这样才性能最佳。&lt;/p&gt;
&lt;h4 id=&quot;容量&quot;&gt;容量&lt;/h4&gt;
&lt;p&gt;在容量方面，大多数用户512G就够用了，毕竟SSD不是作为数据存储盘使用，而是作为系统盘安装程序使用，但由于目前SSD价格下滑，决定还是入手一个1T的，这样更充足。&lt;/p&gt;
&lt;p&gt;经过仔细挑选，最终筛选出两款SSD，“Samsung/三星 MZ-V7S1T0BW 970 EVO Plus 1TB”和“WD/西部数据 WDS100T2X0C 1TB”，比较推荐三星这款，三星的固态一直是业界最好的，速度最快的，不过西数的SSD也在第一梯队，二者价格相差300元左右，“三星970 EVO Plus”速度略高于“西数WDS100T2X0C”，官方宣传三星这款读取速度3500Mb/s、写入速度3300Mb/s，西数这款读取速度3400Mb/s、写入速度2800Mb/s，如果经费允许的朋友推荐三星这款，不过我选择了较为便宜的西数SSD。其他品牌的没用过，不能妄加评论，但是三星和西数的固态硬盘一定是第一梯队了。&lt;/p&gt;
&lt;h3 id=&quot;机械硬盘&quot;&gt;机械硬盘&lt;/h3&gt;
&lt;p&gt;机械硬盘容量视个人情况而定，对于计算机视觉工程师，如果需要存放大体积数据集，就买大一点的，毕竟HDD不贵（但一定记住避开希捷、避开希捷、避开希捷！之前笔记本加装过希捷硬盘，太渣了）。我最后入手了“西部数据 WD40EZRZ 4TB 蓝盘”，买的OEM版本，比官方价格低100多，用着还不错。&lt;/p&gt;
&lt;h3 id=&quot;显卡&quot;&gt;显卡&lt;/h3&gt;
&lt;p&gt;显卡的选择，Tim Dettmers的《&lt;a href=&quot;https://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/&quot;&gt;Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning&lt;/a&gt;》一文已经分析的非常透彻，我也是参考了他的文章购置了RTX 2070显卡，各位朋友可以深入阅读该文章，此处只做简要阐述。&lt;/p&gt;
&lt;h4 id=&quot;性能对比&quot;&gt;性能对比&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/performance_RTX.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GPU和TPU的标准化性能数据。越高越好。RTX卡使用16位计算。使用PyTorch 1.0.1和CUDA 10完成基准测试。&lt;/p&gt;
&lt;h4 id=&quot;性价比分析&quot;&gt;性价比分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/performance_per_dollar_RTX.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卷积网络（CNN），循环网络（RNN）和Transformer的性能/价格。越高越好。RTX 2060的成本效率是Tesla V100的5倍以上。使用PyTorch 1.0.1和CUDA 10完成基准测试。&lt;/p&gt;
&lt;blockquote readability=&quot;1.44&quot;&gt;
&lt;p&gt;注：以上图转载自《&lt;a href=&quot;https://timdettmers.com/2019/04/03/which-gpu-for-deep-learning/&quot;&gt;Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过Tim的分析，更倾向于购买RTX 20系列显卡，因为其独有的“Tensor core”可以支持加速FP16的运算，减少显存的支出，也能减少计算复杂度，&lt;/p&gt;
&lt;h4 id=&quot;整体建议转载&quot;&gt;整体建议（转载）&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;最佳GPU&lt;/strong&gt;：RTX 2070&lt;br/&gt;&lt;strong&gt;避开GPU&lt;/strong&gt;：任何Tesla; 任何Quadro卡; Titan RTX，Titan V，Titan XP&lt;br/&gt;&lt;strong&gt;实惠但价格昂贵&lt;/strong&gt;：RTX 2070经济&lt;br/&gt;&lt;strong&gt;实惠且价格便宜&lt;/strong&gt;：RTX 2060，GTX 1060（6GB）。&lt;br/&gt;&lt;strong&gt;我有点钱&lt;/strong&gt;：GTX 1060（6GB）&lt;br/&gt;&lt;strong&gt;我几乎没有钱&lt;/strong&gt;：GTX 1050 Ti（4GB）。或者：CPU（原型设计）+ AWS / TPU（训练）; 或者Colab。&lt;br/&gt;&lt;strong&gt;我做Kaggle：RTX 2070&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;计算机视觉或机器翻译研究员&lt;/strong&gt;：GTX 2080 Ti，如果您训练非常大的网络获得RTX Titans。&lt;br/&gt;&lt;strong&gt;NLP研究员&lt;/strong&gt;：RTX 2080 Ti使用16位。&lt;br/&gt;&lt;strong&gt;我开始深入学习并且我认真对待它&lt;/strong&gt;：从RTX 2070开始。在6-9个月之后购买更多RTX 2070并且您仍然希望投入更多时间进行深度学习。根据您接下来选择的区域（启动，Kaggle，研究，应用深度学习），销售GPU并在大约两年后购买更合适的东西。&lt;br/&gt;&lt;strong&gt;我想尝试深度学习，但我并不认真&lt;/strong&gt;：GTX 1050 Ti（4或2GB）。这通常适合您的标准桌面，不需要新的PSU。如果它适合，不要购买新电脑！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;选购&quot;&gt;选购&lt;/h4&gt;
&lt;p&gt;看了Tim给出的建议，我最终选择了RTX 2070显卡，虽然只有8G显存，不过使用16位运算，主流网络也都能跑起来。对于品牌的选购我只建议&lt;strong&gt;不要买灯效、不要买超频&lt;/strong&gt;，你要相信一点，同一个型号的显卡（例如RTX 2070），任何厂家任何款式的商品在性能上均没有什么性能差距，价格差距主要体现在所谓的超频、灯光效果上，我个人的建议是完全没有必要把钱花费在这上面，关注一下散热，一线厂商的用料都不会太差。&lt;/p&gt;
&lt;p&gt;我选购了“影驰 RTX2070 大将”，3400元。对于经费充裕的朋友，RTX 2080 Ti也是一个非常好的选择，我之后扩展可能会入手2080 Ti&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/rtx2070.jpg&quot; alt=&quot;影驰 RTX2070 大将&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;电源&quot;&gt;电源&lt;/h3&gt;
&lt;p&gt;通常，我们需要一个足以容纳所有未来GPU的电源。电源的稳定性也对组件的寿命有很大影响，因此购买一个优质的电源是很有意义的。&lt;/p&gt;
&lt;p&gt;因为一个主机最终要的功耗组件是GPU和CPU，我们可以通过将CPU和GPU的功耗累加，并且附加其他组件大约额外10％W来计算所需的功率。网上也有很多计算功率的网站，但大多组件不是很全面，没有什么参考价值， 我的建议就是尽量上大功率电源，留作之后升级显卡使用。还要注意，模组电源支持的PCIE口数量，例如上面我所购买的RTX2070影驰大将，电源接口为8+6pin的，占用默许电源两个8pin的PCIe供电口，如果电源给的供电口只有6个8pin供电口，那么我们只能给3张显卡供电。这个问题需要注意一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/psu.png&quot; alt=&quot;电源&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于电源，我有两款产品推荐：“鑫谷GP1350G 额定1250W 全模组”和“长城巨龙服务器电源 1250W 全模组”，二者价格差不多，我买的鑫谷这款。&lt;/p&gt;
&lt;h3 id=&quot;散热器&quot;&gt;散热器&lt;/h3&gt;
&lt;p&gt;CPU散热部分，之前一直想上一个风冷节省支出，但是由于I7-6950X已经140W了，风冷根本压不住，所以上了240双冷排的水冷，在选购散热器时注意与商家咨询该散热器是否能压住该功率CPU。我入手的“爱国者（aigo）冰塔T240 极光版”，散热效果很好。&lt;/p&gt;
&lt;h3 id=&quot;机箱&quot;&gt;机箱&lt;/h3&gt;
&lt;p&gt;机箱看个人喜好吧，尽量大一点，散热能好些。我入手的“爱国者（aigo）月光宝盒 破晓”。&lt;/p&gt;
&lt;h3 id=&quot;风扇&quot;&gt;风扇&lt;/h3&gt;
&lt;p&gt;风扇这个东西还挺贵的，普通的大约20多一个，真是不明白贵在哪里，购买风扇踩了个坑，以为各种风扇都一样，买便宜的就好，入手了京东最便宜的风扇10元一个，看标注风力之类的都比爱国者极光好，但是实测风力没有爱国者极光风扇强大，不过极光风扇噪音有点大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/fan.png&quot; alt=&quot;机箱风扇&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;组装&quot;&gt;组装&lt;/h2&gt;
&lt;p&gt;装机部分随便上张图意思一下吧~总之是忙了一整天才弄好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/zhuangji.jpg&quot; alt=&quot;装机&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/%E4%B8%BB%E6%9C%BA%E6%AD%A3%E9%9D%A2%E5%9B%BE.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/%E4%B8%BB%E6%9C%BA%E4%BE%A7%E9%9D%A2%E5%9B%BE.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/ludashi.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/cpu-z1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/AIDA.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pr2cmdtfq.bkt.clouddn.com/ssd.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 May 2019 07:06:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<og:description>[TOC] 引言 接触深度学习已经快两年了，之前一直使用 'Google Colab' 和 'Kaggle Kernel' 提供的免费GPU（Tesla K80）训练模型（最近Google将Colab</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/deeplearning-workstation.html</dc:identifier>
</item>
<item>
<title>玩转 matlab 之二维 gauss 数值积分公式使用及 matlab 源代码(1)-常量区间 - 孙振威</title>
<link>http://www.cnblogs.com/sunzhenwei/p/10848686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunzhenwei/p/10848686.html</guid>
<description>&lt;p&gt;继续上一篇一维gauss积分的讨论，本文讨论二维gauss数值积分公式的使用，并给出数值实验。&lt;/p&gt;

&lt;p&gt;按照一维情况类似方式，首先给出如下二重积分公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I = \int_{-1}^1dx\int_{-1}^1 f(x,y)dy=\Sigma_{k=1}^m\Sigma_{l=1}^mA_{kl}f(x_k,y_l). \]&lt;/span&gt;&lt;br/&gt;这是标准的二维gauss积分 &lt;span class=&quot;math inline&quot;&gt;\(m\times m\)&lt;/span&gt; (即 x 轴和 y 轴分别取 m 个点对应&lt;span class=&quot;math inline&quot;&gt;\(m^2\)&lt;/span&gt;个点)公式的表达式，其中，&lt;span class=&quot;math inline&quot;&gt;\(x_{kl}\)&lt;/span&gt; 称作gauss积分点，&lt;span class=&quot;math inline&quot;&gt;\(A_{kl}\)&lt;/span&gt;称作&lt;span class=&quot;math inline&quot;&gt;\(x_{kl}\)&lt;/span&gt; 点处的权重。&lt;span class=&quot;math inline&quot;&gt;\(m=1,2,3\)&lt;/span&gt; 时候草图如下所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190511081306750.?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bnpoZW53ZWkxOTkw,size_16,color_FFFFFF,t_70&quot; alt=&quot;gauss&quot;/&gt;&lt;br/&gt;下面给出部分gauss积分点和权重对应列表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1 (&lt;span class=&quot;math inline&quot;&gt;\(1\times 1\)&lt;/span&gt;)&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_1=y_1=0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;=4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;4 (&lt;span class=&quot;math inline&quot;&gt;\(2 \times 2\)&lt;/span&gt;)&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{1}=-1/\sqrt{3},y_{1}=-1/\sqrt{3}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{2}=1/\sqrt{3},y_{2}=-1/\sqrt{3}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{3}=1/\sqrt{3},y_{3}=1/\sqrt{3}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{4}=-1/\sqrt{3},y_{4}=1/\sqrt{3}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1=A_2=A_3=A_4=1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;16&quot;&gt;&lt;td&gt;9 (&lt;span class=&quot;math inline&quot;&gt;\(3 \times 3\)&lt;/span&gt;)&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(gpt=\sqrt{3/5}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_1=-gpt,y_1=-gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_2=gpt,y_2=-gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_3=gpt,y_3=gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_4=-gpt,y_4=gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_5=0,y_5=-gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_6=gpt,y_6=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_7=0,y_7=gpt\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_8=-gpt,y_8=0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_9=0,y_9=0\)&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1=A_2=A_3=A_4=25/81\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_5=A_6=A_7=A_8=40/81\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_9=64/81\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一般二重积分近似值也就是使用 &lt;span class=&quot;math inline&quot;&gt;\(2\times 2,\quad 3\times 3\)&lt;/span&gt; 公式就完全足够了。所以不需要太多的点，徒增计算量。因此就可以得到gauss积分的坐标表达式为:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I = \int_{-1}^1dx\int_{-1}^1 f(x,y)dy=\Sigma_{i=1}^{m^2}A_{i}f(x_i,y_i). \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;对于一般区间，先考虑区间端点为常量情况（下一节介绍区间为变量情况），即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I = \int_{a}^bdx\int_{c}^d f(x,y)dy. \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(a,b,c,d\)&lt;/span&gt; 都是已知常数。与一维情况类似，只需要做变量变换，于是&lt;span class=&quot;math inline&quot;&gt;\([s,t]\in[-1,1]\times [-1,1]\)&lt;/span&gt;（通俗讲就是换元法）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 令 \quad x =\frac{b+a+(b-a)s}{2},\qquad 则\quad dx=\frac{b-a}{2}ds,\\ \quad y =\frac{d+c+(d-c)t}{2},\qquad 则\quad dy=\frac{d-c}{2}dt.\\ 记\qquad jac = \frac{(b-a)(d-c)}{4},\qquad 则 \quad dxdy=jac\times dsdt \]&lt;/span&gt;&lt;br/&gt;于是二重积分就变成了&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I = \int_{a}^bdx\int_{c}^d f(x,y)dy =jac\times\int_{-1}^1ds\int_{-1}^1f(\frac{b+a+(b-a)s}{2},\frac{d+c+(d-c)t}{2})dt.\\=jac\times\Sigma_{i=1}^{m^2}A_{i}f(\frac{b+a+(b-a)s_i}{2},\frac{d+c+(d-c)t_i}{2}). \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\((s_i,t_i)\)&lt;/span&gt; 即为上表中的 gauss 节点，对应的权重因子为 &lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;使用matlab2018a 计算结果，并且与matlab自带函数 &lt;strong&gt;integral2&lt;/strong&gt; 计算的结果进行比较给出误差。&lt;/p&gt;
&lt;p&gt;算例如下:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 计算定积分 I = \int_{a}^bdx\int_{c}^d f(x,y)dy \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(a=1.4,b=2,c=1,d=1.5,f(x,y)=ln(x+2*y), ln\)&lt;/span&gt;是以e为底对数函数。使用matlab的integral2 函数计算结果为&lt;span class=&quot;math inline&quot;&gt;\(I =0.429554527548275\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;自己编程计算结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;4(&lt;span class=&quot;math inline&quot;&gt;\(2\times 2\)&lt;/span&gt;)&lt;/td&gt;
&lt;td&gt;0.429556088022242&lt;/td&gt;
&lt;td&gt;1.56E-06&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;9(&lt;span class=&quot;math inline&quot;&gt;\(3\times 3\)&lt;/span&gt;)&lt;/td&gt;
&lt;td&gt;0.429554531152490&lt;/td&gt;
&lt;td&gt;3.60E-09&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ol&gt;&lt;li&gt;从实验数据可以发现，二重gauss数值积分使用&lt;span class=&quot;math inline&quot;&gt;\(2\times 2\)&lt;/span&gt; 4个点的情况下，结果已经很准确了，达到了1e-6的误差，所以在实际计算中，一般使用4点或者9点的gauss公式就可以满足要求了。&lt;/li&gt;
&lt;li&gt;下一节介绍当积分区间在变系数下的二重gauss公式的计算方法&lt;/li&gt;
&lt;li&gt;欢迎与我交流，数值分析，矩阵计算，PDE数值解等，QQ群 315241287&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&quot;matlab&quot;&gt;
&lt;code&gt;clc;clear;
%   compute int_a^b [int_c)^d    f(x,y)]
%   (x,y) \in [a,b] X [c,d]
%%  setup the integral interval and gauss point and weight
a = 1.4;    b = 2;
c = 1;      d =1.5;
fun=@(x,y)    log(x+2*y);
fprintf('***********************************************\n')
for gauss = 2:3 %    m points rule in 2 dimensional case
    if gauss == 2
        fprintf('*******  2X2 points gauss rule result *******')
        gpt=1/sqrt(3);
        s(1) = -gpt;  t(1) = -gpt;
        s(2) =  gpt;  t(2) = -gpt;
        s(3) =  gpt;  t(3) =  gpt;
        s(4) = -gpt;  t(4) =  gpt;
        wt = [1 1 1 1];        
    elseif gauss == 3
        gpt=sqrt(0.6);
        fprintf('*******   3X3 points gauss rule     *******')
        s(1) = -gpt; t(1) = -gpt; wt(1)=25/81;
        s(2) =  gpt; t(2) = -gpt; wt(2)=25/81;
        s(3) =  gpt; t(3) =  gpt; wt(3)=25/81;
        s(4) = -gpt; t(4) =  gpt; wt(4)=25/81;
        s(5) =  0.0; t(5) = -gpt; wt(5)=40/81;
        s(6) =  gpt; t(6) =  0.0; wt(6)=40/81;
        s(7) =  0.0; t(7) =  gpt; wt(7)=40/81;
        s(8) = -gpt; t(8) =  0.0; wt(8)=40/81;
        s(9) =  0.0; t(9) =  0.0; wt(9)=64/81;        
    end
    %%   区间变换到   [-1,1] X [-1,1]
    jac = (b-a)*(d-c)/4;
    x = (b+a+(b-a)*s)/2;
    y = (d+c+(d-c)*t)/2;
    f = fun(x,y);
    comp = wt(:) .* f(:) .* jac;%无论一个向量是行还是列，写成x(:)都会变成列向量
    
    format long
    comp = sum(comp)
    exact = integral2(fun,a,b,c,d);
    
    fprintf('the error is norm(comp-exact)=%10.6e\n\n',norm(comp-exact))
    
end
fprintf('******************************************\n')
fprintf('matlab  built-in function ''integral2''\n')
exact
format short&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 11 May 2019 06:59:00 +0000</pubDate>
<dc:creator>孙振威</dc:creator>
<og:description>继续上一篇一维gauss积分的讨论，本文讨论二维gauss数值积分公式的使用，并给出数值实验。 [TOC] 一. 标准区间 按照一维情况类似方式，首先给出如下二重积分公式： $$ I = \int_{</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunzhenwei/p/10848686.html</dc:identifier>
</item>
<item>
<title>TensorFlow从1到2（十四）评估器的使用和泰坦尼克号乘客分析 - 俺踏月色而来</title>
<link>http://www.cnblogs.com/andrewwang/p/10848549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andrewwang/p/10848549.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/tf-logo-card-2.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三种开发模式&quot;&gt;三种开发模式&lt;/h4&gt;
&lt;p&gt;使用TensorFlow 2.0完成机器学习一般有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用底层逻辑&lt;br/&gt;这种方式使用Python函数自定义学习模型，把数学公式转化为可执行的程序逻辑。接着在训练循环中，通过tf.GradientTape()迭代，使用tape.gradient()梯度下降，使用optimizer.apply_gradients()更新模型权重，逐次逼近，完成模型训练。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用Keras高层接口&lt;br/&gt;TensorFlow 1.x的开发中，Keras就作为第三方库存在。2.0中，更是已经成为标准配置。我们前面大多的例子都是基于Keras或者自定义Keras模型配合底层训练循环完成。从网上的一些开源项目来看，这已经是应用最广泛的方式。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;今天要介绍的评估器tf.estimator&lt;br/&gt;评估器是TensorFlow官方推荐的内置高级API，层次上看跟Keras实际处于同样位置，只是似乎大家都视而不见了，以至于现在从用户的实际情况看用的人要远远少于Keras。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-struct-1.png&quot;/&gt;&lt;br/&gt;通常认为评估器因为内置的紧密结合，运行速度要高于Keras。Keras一直是一个通用的高层框架，除了支持TensorFlow作为后端，还同时支持Theano和CNTK。高度的抽象肯定会影响Keras的速度，不过本人并未实际对比测试。我觉的，对于大量数据导致的长时间训练来说，这点效率上的差异不应当成为大问题，否则Python这种解释型的语言就不会成为优选的机器学习基础平台了。&lt;br/&gt;在TensorFlow 1.x中可以使用tf.estimator.model_to_estimator方法将Keras模型转换为TensorFlow评估器。TensorFlow 2.0中，统一到了tf.keras.estimator.model_to_estimator方法。所以如果偏爱评估器的话，使用Keras也不会成为障碍。&lt;/p&gt;
&lt;h4 id=&quot;评估器基本工作流程&quot;&gt;评估器基本工作流程&lt;/h4&gt;
&lt;p&gt;其实从编程逻辑来看，这些高层API所提供的工作方式是很相似的。使用评估器开发机器学习大致分为如下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;载入数据&lt;/li&gt;
&lt;li&gt;数据清洗和数据预处理&lt;/li&gt;
&lt;li&gt;编写数据流水线输入函数&lt;/li&gt;
&lt;li&gt;定义评估器模型&lt;/li&gt;
&lt;li&gt;训练&lt;/li&gt;
&lt;li&gt;评估&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个流程里面，只有“编写数据流水线输入函数”这一步是跟Keras模型是不同的。在Keras模型中，我们直接准备数据集，把数据集送入到模型即可。而在评估器中，数据的输入，需要指定一个函数供评估器调用。&lt;/p&gt;
&lt;h4 id=&quot;使用评估器的实例&quot;&gt;使用评估器的实例&lt;/h4&gt;
&lt;p&gt;这一个来自官方文档的实例比较残酷，使用泰坦尼克号的乘客名单，评估在沉船事件发生后，客户能生存下来的可能性。&lt;br/&gt;数据格式是csv，建议先下载，保存到工作目录：&lt;br/&gt;训练集数据：&lt;a href=&quot;https://storage.googleapis.com/tf-datasets/titanic/train.csv&quot; class=&quot;uri&quot;&gt;https://storage.googleapis.com/tf-datasets/titanic/train.csv&lt;/a&gt;&lt;br/&gt;评估集数据：&lt;a href=&quot;https://storage.googleapis.com/tf-datasets/titanic/eval.csv&quot; class=&quot;uri&quot;&gt;https://storage.googleapis.com/tf-datasets/titanic/eval.csv&lt;/a&gt;&lt;br/&gt;文件下载后不要修改名称。&lt;/p&gt;
&lt;p&gt;数据包含如下属性维度：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;sex&lt;/td&gt;
&lt;td&gt;乘客性别&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;age&lt;/td&gt;
&lt;td&gt;乘客年龄&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;n_siblings_spouses&lt;/td&gt;
&lt;td&gt;随行兄弟或者配偶数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;parch&lt;/td&gt;
&lt;td&gt;随行父母或者子女数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;fare&lt;/td&gt;
&lt;td&gt;船费金额&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;船舱等级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;deck&lt;/td&gt;
&lt;td&gt;甲板编号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;embark_town&lt;/td&gt;
&lt;td&gt;登船地点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;alone&lt;/td&gt;
&lt;td&gt;是否为独自旅行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从这些属性中能看出，数据的收集者是非常用心的。&lt;br/&gt;比如随行兄弟或者配偶、随行父母或者子女这种特征，在大多人的传统观念中，肯定会用类似“随行家属数量”这样的维度合并在一起。&lt;br/&gt;但在这个案例中，两个不同的维度，对于最终存活影响肯定是不同的。&lt;/p&gt;
&lt;h4 id=&quot;基本数据分析&quot;&gt;基本数据分析&lt;/h4&gt;
&lt;p&gt;这部分的工作其实跟评估器的使用没有什么关系，但这正是大数据时代的魅力所在，所以我们还是延续官方文档的思路来看一看。&lt;/p&gt;
&lt;p&gt;先在命令行执行Python，启动交互环境。然后把下面这部分代码拷贝到Python执行。这些代码完成引用扩展库、载入数据等基本工作。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 引入扩展库
from __future__ import absolute_import, division, print_function, unicode_literals

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf

# 载入数据
dftrain = pd.read_csv('train.csv')
dfeval = pd.read_csv('eval.csv')
# 分离标注字段
y_train = dftrain.pop('survived')
y_eval = dfeval.pop('survived')

dftrain.head()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候命令行看起来大致是这个样子：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python3
Python 3.7.3 (default, Mar 27 2019, 09:23:39) 
[Clang 10.0.0 (clang-1000.11.45.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; # 引入扩展库
... from __future__ import absolute_import, division, print_function, unicode_literals
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; import pandas as pd
&amp;gt;&amp;gt;&amp;gt; import matplotlib.pyplot as plt
&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; # 载入数据
... dftrain = pd.read_csv('train.csv')
&amp;gt;&amp;gt;&amp;gt; dfeval = pd.read_csv('eval.csv')
&amp;gt;&amp;gt;&amp;gt; # 分离标注字段
... y_train = dftrain.pop('survived')
&amp;gt;&amp;gt;&amp;gt; y_eval = dfeval.pop('survived')
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; dftrain.head()
      sex   age  n_siblings_spouses  parch     fare  class     deck  embark_town alone
0    male  22.0                   1      0   7.2500  Third  unknown  Southampton     n
1  female  38.0                   1      0  71.2833  First        C    Cherbourg     n
2  female  26.0                   0      0   7.9250  Third  unknown  Southampton     y
3  female  35.0                   1      0  53.1000  First        C  Southampton     n
4    male  28.0                   0      0   8.4583  Third  unknown   Queenstown     y
&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是列出的训练集头5条记录。&lt;br/&gt;我们先看看乘客的年龄分布(后续的代码都是直接拷贝到Python命令行执行)：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dftrain.age.hist(bins=20)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-age-0.png&quot;/&gt;&lt;br/&gt;直方图中显示，乘客年龄主要分布在20岁至30岁之间。&lt;br/&gt;再来看看性别分布：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dftrain.sex.value_counts().plot(kind='barh')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-sex-0.png&quot;/&gt;&lt;br/&gt;男性乘客的数量，几乎是女性乘客的两倍。&lt;br/&gt;接着是船舱等级的分布，这个参数能间接体现乘客的经济实力：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dftrain['class'].value_counts().plot(kind='barh')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-class-0.png&quot;/&gt;&lt;br/&gt;图中显示，大多数乘客还是在三等舱。&lt;br/&gt;继续看乘客上船的地点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dftrain['embark_town'].value_counts().plot(kind='barh')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-town-0.png&quot;/&gt;&lt;br/&gt;大多数乘客来自南安普顿。&lt;br/&gt;继续，把性别跟最后生存标注关联起来：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pd.concat([dftrain, y_train], axis=1).groupby('sex').survived.mean().plot(kind='barh').set_xlabel('% survive')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-sex-1.png&quot;/&gt;&lt;br/&gt;女性的存活率几乎超过男性的5倍。&lt;br/&gt;再来一个更复杂的统计，我们首先把年龄分段，然后看看不同年龄段的乘客最终存活率：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def calc_age_section(n, lim):
    return'[%.f,%.f)' % (lim*(n//lim), lim*(n//lim)+lim)  # map function

addone = pd.Series([calc_age_section(s, 10) for s in dftrain.age])
dftrain['ages'] = addone
pd.concat([dftrain, y_train], axis=1).groupby('ages').survived.mean().plot(kind='barh').set_xlabel('% survive');
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-survive-ages-0.png&quot;/&gt;&lt;br/&gt;10岁以下儿童和80岁以上的老人得到了最多的生存机会。&lt;br/&gt;在那个寒冷、慌乱的沉船夜晚，弱者反而更多的活了下来。&lt;/p&gt;
&lt;h4 id=&quot;数据的预处理&quot;&gt;数据的预处理&lt;/h4&gt;
&lt;p&gt;数据预处理这个话题我们讲了很多次，这是通常机器学习研发工作中，工程师需要做的最多工作。&lt;br/&gt;泰坦尼克号乘客名单的数据虽然不复杂，也属于典型的结构化数据。&lt;br/&gt;其中主要包含两类，一种是分类型的数据，比如船舱等级，比如上船城市名称。另一类则是简单的数值，比如年龄和购票价格。&lt;br/&gt;对于数值型的数据可以直接规范化后进入模型，对于分类型的数据，则还需要做编码，我们这里还是使用最常见的one-hot。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 定义所需的数据列，分为分类型属性和数值型属性分别定义
CATEGORICAL_COLUMNS = ['sex', 'n_siblings_spouses', 'parch', 'class', 'deck', 
                       'embark_town', 'alone']
NUMERIC_COLUMNS = ['age', 'fare']

# 辅助函数，把给定数据列做one-hot编码
def one_hot_cat_column(feature_name, vocab):
    return tf.feature_column.indicator_column(
        tf.feature_column.categorical_column_with_vocabulary_list(feature_name,
                                                                  vocab))

# 最终使用的数据列，先置空
feature_columns = []
for feature_name in CATEGORICAL_COLUMNS:
    # 分类的属性都要做one-hot编码，然后加入数据列
    vocabulary = dftrain[feature_name].unique()
    feature_columns.append(one_hot_cat_column(feature_name, vocabulary))

for feature_name in NUMERIC_COLUMNS:
    # 数值类的属性直接入列
    feature_columns.append(tf.feature_column.numeric_column(feature_name,
                                                            dtype=tf.float32))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据输入函数&quot;&gt;数据输入函数&lt;/h4&gt;
&lt;p&gt;评估器的训练、评估都需要使用数据输入函数作为参数。输入函数本身不接受任何参数，返回一个tf.data.Dataset对象给模型用于供给数据。&lt;br/&gt;因为除了数据集不同，训练和评估模型所使用的数据格式通常都是一样的。所以经常会在程序代码上，共用一个函数，然后用参数来区分用于评估还是用于训练。&lt;br/&gt;然而输入函数相当于回调函数，由评估器控制着调用，这过程中并没有参数传递。所以比较聪明的做法可以使用嵌套函数的方法来定义，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是一个很少量数据的样本，直接把整个数据集当做一批
NUM_EXAMPLES = len(y_train)
# 输入函数的构造函数
def make_input_fn(X, y, n_epochs=None, shuffle=True):
    def input_fn():
        dataset = tf.data.Dataset.from_tensor_slices((dict(X), y))
        # 乱序
        if shuffle:
            dataset = dataset.shuffle(NUM_EXAMPLES)
        # 训练时让数据重复尽量多的次数
        dataset = dataset.repeat(n_epochs)
        dataset = dataset.batch(NUM_EXAMPLES)
        return dataset
    return input_fn

# 训练、评估所使用的数据输入函数，区别只是数据是否乱序以及迭代多少次
train_input_fn = make_input_fn(dftrain, y_train)
eval_input_fn = make_input_fn(dfeval, y_eval, shuffle=False, n_epochs=1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;模型和源码&quot;&gt;模型和源码&lt;/h4&gt;
&lt;p&gt;本例中我们直接使用预定义的评估器模型(pre-made estimator)。所以代码非常简单，定义、训练、评估都是只需要一行代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 使用线性分类器作为模型
linear_est = tf.estimator.LinearClassifier(feature_columns)

# 训练
linear_est.train(train_input_fn, max_steps=100)

# 评估
result = linear_est.evaluate(eval_input_fn)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看看完整代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python3

# 引入扩展库
from __future__ import absolute_import, division, print_function, unicode_literals

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf

# 载入数据
dftrain = pd.read_csv('train.csv')
dfeval = pd.read_csv('eval.csv')
# 分离标注字段
y_train = dftrain.pop('survived')
y_eval = dfeval.pop('survived')

################################################################
# 定义所需的数据列，分为分类型属性和数值型属性分别定义
CATEGORICAL_COLUMNS = ['sex', 'n_siblings_spouses', 'parch', 'class', 'deck', 
                       'embark_town', 'alone']
NUMERIC_COLUMNS = ['age', 'fare']

# 辅助函数，把给定数据列做one-hot编码
def one_hot_cat_column(feature_name, vocab):
    return tf.feature_column.indicator_column(
        tf.feature_column.categorical_column_with_vocabulary_list(feature_name,
                                                                  vocab))

# 最终使用的数据列，先置空
feature_columns = []
for feature_name in CATEGORICAL_COLUMNS:
    # 分类的属性都要做one-hot编码，然后加入数据列
    vocabulary = dftrain[feature_name].unique()
    feature_columns.append(one_hot_cat_column(feature_name, vocabulary))

for feature_name in NUMERIC_COLUMNS:
    # 数值类的属性直接入列
    feature_columns.append(tf.feature_column.numeric_column(feature_name,
                                                            dtype=tf.float32))

################################################################
# 这是一个很少量数据的样本，直接把整个数据集当做一批
NUM_EXAMPLES = len(y_train)
# 输入函数的构造函数
def make_input_fn(X, y, n_epochs=None, shuffle=True):
    def input_fn():
        dataset = tf.data.Dataset.from_tensor_slices((dict(X), y))
        # 乱序
        if shuffle:
            dataset = dataset.shuffle(NUM_EXAMPLES)
        # 训练时让数据重复尽量多的次数
        dataset = dataset.repeat(n_epochs)
        dataset = dataset.batch(NUM_EXAMPLES)
        return dataset
    return input_fn

# 训练、评估所使用的数据输入函数，区别只是数据是否乱序以及迭代多少次
train_input_fn = make_input_fn(dftrain, y_train)
eval_input_fn = make_input_fn(dfeval, y_eval, shuffle=False, n_epochs=1)

# 使用线性分类器作为模型
linear_est = tf.estimator.LinearClassifier(feature_columns)

# 训练
linear_est.train(train_input_fn, max_steps=100)

# 评估
result = linear_est.evaluate(eval_input_fn)
print(&quot;----------------------------------&quot;)
print(pd.Series(result))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行的最后显示了评估的结果，在我的电脑上显示的结果是这样的：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;----------------------------------
accuracy                  0.765152
accuracy_baseline         0.625000
auc                       0.832844
auc_precision_recall      0.789631
average_loss              0.478908
label/mean                0.375000
loss                      0.478908
precision                 0.703297
prediction/mean           0.350790
recall                    0.646465
global_step             100.000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正确率不算太高。&lt;br/&gt;评估器的模型使用起来很简单，我们尝试换用另外一种模型，比如提升树分类器。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 以下代码放在程序最后，因为这个数据集非常小，速度很快，所以做两次学习也并不感觉慢
n_batches = 1
est = tf.estimator.BoostedTreesClassifier(feature_columns,
                                          n_batches_per_layer=n_batches)

# 训练
est.train(train_input_fn, max_steps=100)

# 评估
result = est.evaluate(eval_input_fn)
print(&quot;----------------------------------&quot;)
print(pd.Series(result))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次得到的结果是这样的：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;----------------------------------
accuracy                  0.825758
accuracy_baseline         0.625000
auc                       0.872360
auc_precision_recall      0.857325
average_loss              0.411853
label/mean                0.375000
loss                      0.411853
precision                 0.784946
prediction/mean           0.382282
recall                    0.737374
global_step             100.000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然准确率仍然并不高，但比起来线性分类器，提高还是算的上明显。&lt;/p&gt;
&lt;h4 id=&quot;性能评价&quot;&gt;性能评价&lt;/h4&gt;
&lt;p&gt;评价机器学习模型的性能，除了看刚才的统计信息，绘图是非常好的一种方式，可以更直观，某些问题也能体现的一目了然。&lt;br/&gt;我们在上面程序的最后再增加几行代码，绘制预测概率的统计信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 绘制预测概率直方图
pred_dicts1 = list(linear_est.predict(eval_input_fn))
pred_dicts2 = list(bt_est.predict(eval_input_fn))
probs1 = pd.Series([pred['probabilities'][1] for pred in pred_dicts1])
probs2 = pd.Series([pred['probabilities'][1] for pred in pred_dicts2])

plt.figure(figsize=(14, 5))
plt.subplot(1, 2, 1)
probs1.plot(kind='hist', bins=20, title='linear-est predicted probabilities');
plt.subplot(1, 2, 2)
probs2.plot(kind='hist', bins=20, title='bt-est predicted probabilities');
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-predicted-probabilities-0.png&quot;/&gt;&lt;br/&gt;大量集中在图形左侧的数据簇，显示了乘客九死一生的悲惨命运。&lt;br/&gt;因为我们的预测结果只有两种可能：0表示未能生存；1表示生存下来。所以预测的结果，应当明显的尽量靠近0和1两端。中间悬而未决的部分应当尽可能少。从图形的情况看，如果不考虑分类准确率问题，提升树分类器效果要更好一些。&lt;br/&gt;当然作为成熟的预定义模型，模型都是很优秀的，只是提升树可能更适合本应用的场景。&lt;/p&gt;
&lt;p&gt;尽管这个例子很简单，但现在的分类算法实际越来越复杂。预测结果在不同类别数据上表现并不不均衡，使得使用正确率这样的传统标准不能恰当的反应分类器的性能，本例中也已经出现了这种倾向。或者说，分类器，对于不同类别的样本，性能表现是不一致的。&lt;br/&gt;这种情况，使用ROC(Receiver Operating Characteristic)观察者操作曲线能够表现的更清楚。&lt;br/&gt;对于一个分类器的分类结果，一般有以下四种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;真阳性（TP）：判断为1，实际上也为1。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;伪阳性（FP）：判断为1，实际上为0。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;真阴性（TN）：判断为0，实际上也为0。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;伪阴性（FN）：判断为0，实际上为1。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ROC图中，左上角是真阳性的极点，曲线越接近左上角，意味着分类器性能越好。所以左上角是分类器追求的方向。&lt;br/&gt;下面代码，请接续在上面代码之后，用来绘制ROC曲线：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 绘制ROC(Receiver Operating Characteristic)曲线
from sklearn.metrics import roc_curve

def plot_roc(probs, title):
    fpr, tpr, _ = roc_curve(y_eval, probs)
    plt.plot(fpr, tpr)
    plt.title(title)
    plt.xlabel('false positive rate')
    plt.ylabel('true positive rate')
    plt.xlim(0,)
    plt.ylim(0,)
plt.figure(figsize=(14, 5))
plt.subplot(1, 2, 1)
plot_roc(probs1, &quot;linear-est ROC&quot;)
plt.subplot(1, 2, 2)
plot_roc(probs2, &quot;bt-est ROC&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://files.17study.com.cn/201904/tensorFlow2/est-predicted-ROC-1.png&quot;/&gt;&lt;br/&gt;从ROC曲线看，在本例中使用提升树模型的优势更为明显。&lt;/p&gt;
&lt;p&gt;（待续...）&lt;/p&gt;
</description>
<pubDate>Sat, 11 May 2019 06:18:00 +0000</pubDate>
<dc:creator>俺踏月色而来</dc:creator>
<og:description>三种开发模式 使用TensorFlow 2.0完成机器学习一般有三种方式： 使用底层逻辑 这种方式使用Python函数自定义学习模型，把数学公式转化为可执行的程序逻辑。接着在训练循环中，通过tf.Gr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andrewwang/p/10848549.html</dc:identifier>
</item>
<item>
<title>kafka系列二：多节点分布式集群搭建 - 码农大卫</title>
<link>http://www.cnblogs.com/fengweiweicoder/p/10841637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengweiweicoder/p/10841637.html</guid>
<description>&lt;p&gt;上一篇分享了单节点伪分布式集群搭建方法，本篇来分享一下多节点分布式集群搭建方法。多节点分布式集群结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190509214411984-1185532915.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了方便查阅，本篇将和上一篇一样从零开始一步一步进行集群搭建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、安装Jdk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　具体安装步骤可参考 &lt;a href=&quot;https://www.cnblogs.com/fengweiweicoder/p/10777032.html&quot; target=&quot;_blank&quot;&gt;linux安装jdk&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装与配置zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　下载地址：&lt;a href=&quot;https://www-us.apache.org/dist/zookeeper/stable/&quot; target=&quot;_black&quot;&gt;https://www-us.apache.org/dist/zookeeper/stable/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下载二进制压缩包 &lt;span class=&quot;cnblogs_code&quot;&gt;zookeeper-3.4.14.tar.gz&lt;/span&gt;，然后上传到linux服务器指定目录下，本次上传目录为 &lt;span class=&quot;cnblogs_code&quot;&gt;/software&lt;/span&gt; ，然后执行如下命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /software&lt;br/&gt;tar -zxvf zookeeper-&lt;span&gt;3.4&lt;/span&gt;.&lt;span&gt;14&lt;/span&gt;.tar.gz&lt;br/&gt;mv zookeeper-3.4.14 /usr/local/zookeeper&lt;br/&gt;cd /usr/local/zookeeper/conf&lt;br/&gt;mv zoo_sample.cfg zoo1.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编辑 &lt;span class=&quot;cnblogs_code&quot;&gt;zoo1.cfg&lt;/span&gt; ,配置相关参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tickTime=2000&lt;span&gt;
initLimit=5&lt;span&gt;
syncLimit=2&lt;span&gt;
dataDir=/usr/local/zookeeper/&lt;span&gt;data/zookeeper1
clientPort=2181&lt;span&gt;
server.1=192.168.184.128:2888:3888&lt;span&gt;
server.2=192.168.184.128:2889:3889&lt;span&gt;
server.3=192.168.184.128:2890:3890&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;tickTime&lt;/span&gt; ：Zookeeper最小的时间单位，用于丈量心跳和超时时间，一般设置默认值2秒；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;initLimit&lt;/span&gt; ：指定follower节点初始时连接leader节点的最大tick此处，设置为5，表示follower必须在  &lt;span class=&quot;cnblogs_code&quot;&gt;5xtickTime&lt;/span&gt;  即10秒内连接上leader,否则视为超时；&lt;/p&gt;
&lt;p&gt; 　　&lt;span class=&quot;cnblogs_code&quot;&gt;syncLimit&lt;/span&gt; ：设定follower节点与leader节点进行同步的最大时间，设置为2，表示最大时间为  &lt;span class=&quot;cnblogs_code&quot;&gt;2xtickTime&lt;/span&gt; 即4秒时间；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;dataDir&lt;/span&gt; ：Zookeeper会在内存中保存系统快照，并定期写入该路径指定的文件夹中，生产环境需要特别注意该文件夹的磁盘占用情况；　&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;clientPort&lt;/span&gt; ：Zookeeper监听客户端连接的端口号，默认为2181，同一服务器上不同实例之间应该有所区别；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;server.X=host:port1:port2&lt;/span&gt;  :此处X的取值范围在1~255之间，必须是全局唯一的且和myid文件中的数字对应（myid文件后面说明）,host是各个节点的主机名，port1通常是2888，用于使follower节点连接leader节点，port2通常是3888，用于leader选举，zookeeper在不同服务器上的时候，不同zookeeper服务器的端口号可以重复，在同一台服务器上的时候需要有所区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置zoo.cfg文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　单节点安装zookeeper的时候，仅有一份zoo.cfg文件，多节点安装的时候，每个zookeeper服务器就应该有一个zoo.cfg配置文件。如果在一台服务器安装zookeeper多实例集群，则需要在conf目录下分别配置每个实例的zoo.cfg，同时创建每个zookeeper实例自己的数据存储目录。本次在一台服务器上配置多个zookeeper实例，执行如下命令创建数据存储目录并复制配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mkdir -p /usr/local/zookeeper/data/&lt;span&gt;zookeeper1
mkdir &lt;/span&gt;-p /usr/local/zookeeper/data/&lt;span&gt;zookeeper2
mkdir &lt;/span&gt;-p /usr/local/zookeeper/data/&lt;span&gt;zookeeper3
cd &lt;/span&gt;/usr/local/zookeeper/conf/&lt;span&gt;
cp zoo1.cfg zoo2.cfg
cp zoo1.cfg zoo3.cfg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复制后分别修改 &lt;span class=&quot;cnblogs_code&quot;&gt;zoo2.cfg&lt;/span&gt; , &lt;span class=&quot;cnblogs_code&quot;&gt;zoo3.cfg&lt;/span&gt; 中的配置，修改后的配置如下：&lt;/p&gt;
&lt;p&gt;　　zoo1.cfg的配置如下:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510230427864-356154607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　zoo2.cfg的配置如下:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510230521847-1988449762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　zoo3.cfg中的配置如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510230603700-189086822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.myid文件创建与配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面提到zoo.cfg文件中的server.X中的X应该与myid中的数字相对应。除此之外，myid文件必须存放在每个zookeeper实例的data目录下，对应本次安装应该位于 &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/local/zookeeper/data/zookeeper1，2,3&lt;/span&gt; 目录下，执行如下命令进行配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt; /usr/local/zookeeper/data/zookeeper1/myid&lt;br/&gt;echo '2' &amp;gt; /usr/local/zookeeper/data/zookeeper2/myid&lt;br/&gt;echo '3' &amp;gt; /usr/local/zookeeper/data/zookeeper3/myid
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.启动zookeeper服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用如下命令启动zookeeper集群:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /usr/local/zookeeper/bin/&lt;br/&gt;./zkServer.sh start ../conf/zoo1.cfg&lt;br/&gt;./zkServer.sh start ../conf/zoo2.cfg&lt;br/&gt;./zkServer.sh start ../conf/zoo3.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动后，使用如下命令查看集群状态:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /usr/local/zookeeper/bin/&lt;br/&gt;&lt;span&gt;./zkServer.sh status ../conf/zoo1.cfg
&lt;/span&gt;&lt;span&gt;./zkServer.sh status ../conf/zoo2.cfg
./zkServer.sh status ../conf/zoo3.cfg&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回显信息如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510214638262-164924036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到有两个follower节点，一个leader节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三、安装与配置kafka集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下载地址：&lt;a href=&quot;http://kafka.apache.org/downloads.html&quot; target=&quot;_black&quot;&gt;http://kafka.apache.org/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.数据目录和配置文件创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前最新版本是2.2.0,本次下载2.1.1版本的安装包，然后上传压缩包到服务器指定目录，本次上传目录为  &lt;span class=&quot;cnblogs_code&quot;&gt;/software&lt;/span&gt; ，然后执行以下命令进行安装: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
tar -zxvf kafka_2.&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.tgz&lt;br/&gt;mv kafka_2.12-2.1.1 /usr/local/kafka&lt;br/&gt;mkdir -p /usr/local/kafka/logs/kafka1&lt;br/&gt;mkdir -p /usr/local/kafka/logs/kafka2&lt;br/&gt;mkdir -p /usr/local/kafka/logs/kafka3&lt;br/&gt;cd /usr/local/kafka/config/&lt;br/&gt;mv server.properties server1.properties&lt;br/&gt;cp server1.properties server2.properties&lt;br/&gt;cp server1.properties server3.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过执行上面的命令，我们在 &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/local/kafka/logs&lt;/span&gt; 文件夹中创建了 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka1,kafka2,kafka3&lt;/span&gt; 三个文件夹用于存放三个kafka实例的数据，同时在 &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/local/kafka/config/&lt;/span&gt; 文件夹下复制了三份 &lt;span class=&quot;cnblogs_code&quot;&gt;server.properties&lt;/span&gt; 文件分别用于配置各个kafka实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.配置属性文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来分别配置三个 &lt;span class=&quot;cnblogs_code&quot;&gt;server.properties&lt;/span&gt; 文件，主要配置参数如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;broker.id=1&lt;/span&gt; ：设置kafka broker的id，本次分别为1,2,3；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;delete.topic.enable=&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; :开启删除topic的开关；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;listeners=PLAINTEXT:&lt;span&gt;//192.168.184.128&lt;/span&gt;&lt;span&gt;:9092&lt;/span&gt;&lt;/span&gt; ：设置kafka的监听地址和端口号，本次分别设置为9092,9093,9094；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;log.dirs=/usr/local/kafka/logs/kafka1&lt;/span&gt; ：设置kafka日志数据存储路径；&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;zookeeper.connect=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2181,192.168.184.128:2182,192.168.184.128:2183&lt;/span&gt;&lt;/span&gt; ：设置kafka连接的zookeeper访问地址,集群环境需要配置所有zookeeper的访问地址;&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;unclean.leader.election.enable=&lt;span&gt;false&lt;/span&gt;&lt;/span&gt; ：为true则代表允许选用非isr列表的副本作为leader，那么此时就意味着数据可能丢失，为false的话，则表示不允许，直接抛出NoReplicaOnlineException异常，造成leader副本选举失败。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;　　 &lt;span class=&quot;cnblogs_code&quot;&gt;zookeeper.connection.timeout.ms=&lt;span&gt;6000&lt;/span&gt;&lt;/span&gt; ：设置连接zookeeper服务器超时时间为6秒。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;　　配置完成后，各个配置文件中配置如下:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　server1.properties配置：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510225407711-716349638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　server2.properties配置：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510225453491-1714421402.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　server3.properties配置:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510225542334-1528866714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.启动kafka&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过如下命令启动kafka集群:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin/&lt;br/&gt;./kafka-server-start.sh -daemon ../config/server1.properties&lt;br/&gt;./kafka-server-start.sh -daemon ../config/server2.properties&lt;br/&gt;./kafka-server-start.sh -daemon ../config/server3.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　使用 java的命令jps来查看kafka进程:&lt;span class=&quot;cnblogs_code&quot;&gt;jps |grep -i kafka&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190510225733336-438564418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明kafak启动正常，至此kafka集群搭建完成。本次使用一台服务器作为演示，如果需要在多个服务器上配置集群，配置方法和以上类似，只是不需要像上面那样配置多个数据目录和配置文件，每台服务器的配置保持相同，并且注意在防火墙配置端口号即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.topic创建与删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先创建一个测试topic，名为testTopic，为了充分利用3个实例（服务器节点），创建3个分区，每个分区都分配3个副本，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin/&lt;br/&gt;./kafka-topics.sh --zookeeper 192.168.184.128:2181 192.168.184.128:2182 192.168.184.128:2183 --create --topic testTopic --partitions 3 --replication-factor 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回显 &lt;span class=&quot;cnblogs_code&quot;&gt;Created topic &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testTopic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.&lt;/span&gt; 则表明testTopic创建成功。执行如下命令进行验证并查看testTopic的信息:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
./kafka-topics.sh --zookeeper &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2182&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2183&lt;/span&gt; --list testTopic&lt;br/&gt;./kafka-topics.sh --zookeeper 192.168.184.128:2181 192.168.184.128:2182 192.168.184.128:2183 --describe --topic testTopic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上几条命令回显信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511113654398-1651097549.png&quot; alt=&quot;&quot; width=&quot;1225&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来测试topic删除，使用如下命令进行删除:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./kafka-topics.sh --zookeeper &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2181&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2182&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;184.128&lt;/span&gt;:&lt;span&gt;2183&lt;/span&gt; --delete --topic testTopic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行该条命令后，回显信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511114052882-349475853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，testTopic已经被标记为删除，同时第二行提示表明当配置了 &lt;span class=&quot;cnblogs_code&quot;&gt;delete.topic.enable&lt;/span&gt; 属性为 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 的时候topic才会删除，否则将不会被删除，本次安装的时候该属性设置的值为 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.测试消息发送与消费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先使用第一步topic创建命令，先创建testTopic这个topic，然后进行消息发送与消费测试。&lt;/p&gt;
&lt;p&gt;　　控制台测试消息发送与消费需要使用kafka的安装目录 &lt;span class=&quot;cnblogs_code&quot;&gt;/usr/local/kafka/bin&lt;/span&gt; 下的 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-console-producer.sh&lt;/span&gt; 来发送消息，使用 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-console-consumer.sh&lt;/span&gt; 来消费消息。因此本次打开两个控制台，一个用于执行 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-console-producer.sh&lt;/span&gt;来发送消息，另一个用于执行 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-console-consumer.sh&lt;/span&gt; 来消费消息。&lt;/p&gt;
&lt;p&gt;　　消息发送端命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin&lt;br/&gt;./kafka-console-producer.sh --broker-list 192.168.184.128:9092,192.168.184.128:9093,192.168.184.128:9094 --topic testTopic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　消息接收端命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin&lt;br/&gt;./kafka-console-consumer.sh --bootstrap-server 192.168.184.128:9092,192.168.184.128:9093,192.168.184.128:9094 --topic testTopic --from-beginning
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当发送端和接收端都登录后，在发送端输入需要发送的消息并回车，在接收端可以看到刚才发送的消息：&lt;/p&gt;
&lt;p&gt;　　发送端：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511120914271-936400162.png&quot; alt=&quot;&quot; width=&quot;1213&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接收端：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511120957413-217921093.png&quot; alt=&quot;&quot; width=&quot;1215&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上就是简单地生产消息与消费消息的测试，在测试消费消息的时候时候，命令里边加了个参数 &lt;span class=&quot;cnblogs_code&quot;&gt;--&lt;span&gt;from&lt;/span&gt;-beginning&lt;/span&gt; 表示接收该topic从创建开始的所有消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.生产者吞吐量测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;对于任何一个消息引擎而言，吞吐量是一个至关重要的性能指标。对于Kafka而言，它的吞吐量指每秒能够处理的消息数或者字节数。kafka为了提高吞吐量，采用追加写入方式将消息写入操作系统的页缓存，读取的时候从页缓存读取，因此它不直接参与物理I/O操作，同时使用以sendfile为代表的零拷贝技术进行数据传输提高效率。&lt;/p&gt;
&lt;p&gt;　　kafka提供了 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-producer-perf-test.sh&lt;/span&gt; 脚本用于测试生产者吞吐量，使用如下命令启动测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin&lt;br/&gt;./kafka-producer-perf-test.sh --topic testTopic --num-records 50000 --record-size 200 --throughput -1 --producer-props bootstrap.servers=192.168.184.128:9092,192.168.184.128:9093,192.168.184.128:9094 acks=-1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511123428038-1042849279.png&quot; alt=&quot;&quot; width=&quot;1234&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上回显信息表明这台服务器上每个producer每秒能发送6518个消息，平均吞吐量是1.24MB/s，平均延迟2.035秒，最大延迟3.205秒，平均有50%的消息发送需要2.257秒，95%的消息发送需要3.076秒，99%的消息发送需要3.171秒，99.9%的消息发送需要3.205秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.消费者吞吐量测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　与生产者吞吐量测试类似，kafka提供了 &lt;span class=&quot;cnblogs_code&quot;&gt;kafka-consumer-perf-test.sh&lt;/span&gt; 脚本用于消费者吞吐量测试，可以执行以下命令进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cd /usr/local/kafka/bin&lt;br/&gt;./kafka-consumer-perf-test.sh --broker-list 192.168.184.128:9092,192.168.184.128:9093,192.168.184.128:9094 --messages 50000 --topic testTopic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671546/201905/1671546-20190511125424563-1296290397.png&quot; alt=&quot;&quot; width=&quot;1228&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上是测试50万条消息的consumer吞吐量，结果表明该consumer在1秒总共消费了9.5366MB消息。&lt;/p&gt;

&lt;p&gt;　　以上就是kafka集群的搭建以及测试，如有错误之处，烦请指正。&lt;/p&gt;

&lt;p&gt;参考资料：《Apache kafka实战》&lt;/p&gt;






</description>
<pubDate>Sat, 11 May 2019 04:59:00 +0000</pubDate>
<dc:creator>码农大卫</dc:creator>
<og:description>上一篇分享了单节点伪分布式集群搭建方法，本篇来分享一下多节点分布式集群搭建方法。多节点分布式集群结构如下图所示： 为了方便查阅，本篇将和上一篇一样从零开始一步一步进行集群搭建。 一、安装Jdk 具体安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengweiweicoder/p/10841637.html</dc:identifier>
</item>
<item>
<title>数值分析Python实现系列—— 一、拉格朗日插值法 - NCUT-Y先生</title>
<link>http://www.cnblogs.com/MyBlog-MrY/p/10847938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyBlog-MrY/p/10847938.html</guid>
<description>&lt;h2&gt;1.原理:&lt;/h2&gt;
&lt;p&gt;拉格朗日插值法:给定n个观测值(x&lt;sub&gt;k&lt;/sub&gt;,y&lt;sub&gt;k&lt;/sub&gt;)找到一组(n个)基函数 l&lt;sub&gt;k&lt;/sub&gt;(x)  , 使得L(x) 为这组基函数的线性组合,并且使得L(x)是经过这些点的多项式&lt;/p&gt;
&lt;p&gt;我们发现其中的一种找发是  :  满足这样线性组合的系数 是 观测值y&lt;sub&gt;k&lt;/sub&gt; (n个)&lt;/p&gt;
&lt;p&gt;满足这样线性组合的基函数形如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1375896/201905/1375896-20190511093517269-36468662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.Python实现:&lt;/h2&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;1.观察发现基函数的分母与x无关,是观测值x的组合,可以先计算出来,留着以后用&lt;/p&gt;
&lt;p&gt;2.每一个预测值先计算分子,再把每一个分子乘以每一个预测值,除以每一个分母,最终加和&lt;/p&gt;
&lt;p&gt;3.使用matplotlib里的plot展示结果,蓝色点为观测值,红色点为预测值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reduce
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; % matplotlib inline (jupyter notebook用户建议打开)&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; lagrange():
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     points = eval(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入一个包含2个以上坐标的列表:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     pre = eval(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入预测值列表:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     length =&lt;span&gt; len(points)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     result =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; l_k_den用于存储每一个基函数的分母数值(在计算不同预测值时可以共用)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     l_k_den = [reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: x * y, [num[0] - i[0] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; points &lt;span&gt;if&lt;/span&gt; i[0] != num[0]]) &lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt;&lt;span&gt; points]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pre:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; l_k_num用于存储每一个基函数的分子数值(每一个预测值都不一样)&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         l_k_num = [reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: x * y, [number - i[0] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; points &lt;span&gt;if&lt;/span&gt; i[0] != one[0]]) &lt;span&gt;for&lt;/span&gt; one &lt;span&gt;in&lt;/span&gt;&lt;span&gt; points]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         result.append(sum([l_k_num[i] * points[i][1] / l_k_den[i] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(length)]))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     plt.plot([i[0]&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; points], [i[1] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; points], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     plt.plot(pre, result, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     plt.show() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pycharm用户建议使用&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; lagrange()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 3.效果展示:&lt;/h2&gt;
&lt;p&gt;Pycharm:&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1375896/201905/1375896-20190511094120343-1502220681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1375896/201905/1375896-20190511094143973-245362152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jupyter中:&lt;/p&gt;
&lt;p&gt;输入输出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1375896/201905/1375896-20190511094241674-1256737614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.学习总结:&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;reduce()&lt;/strong&gt; 函数会对参数序列中元素进行累积。 语法: &lt;span class=&quot;cnblogs_code&quot;&gt;reduce(function, iterable[, initializer])&lt;/span&gt;  例子: &lt;span class=&quot;cnblogs_code&quot;&gt;reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: x+y, [1,2,3,4,5]) &lt;span&gt;#&lt;/span&gt; &lt;span&gt;使用 lambda 匿名函数&lt;/span&gt;&lt;/span&gt; 结果:17&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 11 May 2019 04:27:00 +0000</pubDate>
<dc:creator>NCUT-Y先生</dc:creator>
<og:description>一、拉格朗日插值法 1.原理: 拉格朗日插值法:给定n个观测值(xk,yk)找到一组(n个)基函数 lk(x) , 使得L(x) 为这组基函数的线性组合,并且使得L(x)是经过这些点的多项式 我们发现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MyBlog-MrY/p/10847938.html</dc:identifier>
</item>
</channel>
</rss>