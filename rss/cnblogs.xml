<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ThreadPoolExcutor 线程池 异常处理 （下篇） - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/10639914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/10639914.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;因为这是之前面试的一个题目，所以印象比较深刻，前几天写了一篇文章：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10588637.html&quot;&gt;ThreadPoolExcutor 线程池 异常处理 （上篇）&lt;/a&gt; 中已经介绍了线程池异常的一些问题以及一步步分析了里面的一些源代码，今天就来继续说下如何防范这种情况。&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;这里直接抛出结论，然后再一个个分析:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常&lt;/li&gt;
&lt;li&gt;使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理&lt;/li&gt;
&lt;li&gt;重写ThreadPoolExecutor.afterExecute方法，处理传递到afterExecute方法中的异常&lt;/li&gt;
&lt;li&gt;为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常 (不推荐)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分析解读&quot;&gt;分析解读&lt;/h3&gt;
&lt;h4 id=&quot;runnable的run方法中捕获任务代码可能抛出的所有异常&quot;&gt;Runnable的run方法中捕获任务代码可能抛出的所有异常&lt;/h4&gt;
&lt;p&gt;这个其实最简单，但是往往面试官问这个问题 考察的点也不在这里。具体的方式可以参考我之前的一篇文章：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10163855.html&quot;&gt;论如何优雅的自定义ThreadPoolExecutor线程池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心代码如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230118126-1684676217.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用executorservice.submit执行任务利用返回的future对象的get方法接收抛出的异常&quot;&gt;使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常&lt;/h4&gt;
&lt;p&gt;1， 使用submit执行异步任务，然后通过Future的get方法来接收异常。演示如下：&lt;br/&gt;冲图片可以看到，使用了get方法后，这里直接接收到了异常信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230149378-621228438.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2， 这里newTaskFor返回的是FutureTask，然后传递给了execute方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230417485-252989006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3， 接着我们继续往下跟踪execute方法，发现这里调用的是ThreadExecutor中的execute方法，在&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10588637.html&quot;&gt;ThreadPoolExcutor 线程池 异常处理 （上篇）&lt;/a&gt; 我们已经分析过这里，最终会到addWorker方法中执行线程的start()方法，因为我们在上一张图片传递的是FutureTask， 所以我们继续跟踪FutureTask中的run方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230309326-772071217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4， 到了FutureTask.run() 方法中，一切似乎都已经明了，这里会有catch捕获当前线程抛出的异常，紧接着我们看看setException做了什么事情：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230439250-1080357118.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5，setExcetion首先是将一个异常信息赋值给一个全局变量outcome，并且将全局的任务状态state字段通过CAS更新为3(异常状态)&lt;br/&gt;然后最后做一些清理工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230459542-163001258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6，finishCompletion后续是做一些线程池的清理工作，这里涉及到线程池以及线程池中的等待队列的操作，不清楚的同学可以看下线程池实现代码。到了这里线程池中的线程执行已经完毕了，下面再去跟踪一下FutureTask.get()方法。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230519817-1743901553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7，这里是FutureTask.get()的底层实现，这里其实会拿上面的setException方法中设置的outcome和state做一些逻辑判断，到了这里就直接往上抛出了异常，所以我们在最开始的main方法中才能够捕获到这个异常。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230536195-1283380565.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重写threadpoolexecutor.afterexecute方法处理传递到afterexecute方法中的异常&quot;&gt;重写ThreadPoolExecutor.afterExecute方法，处理传递到afterExecute方法中的异常&lt;/h3&gt;
&lt;p&gt;这里为何要重写afterExecute方法呢？因为线程执行完毕后一定会执行此方法，源码如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230557717-1313608072.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以重写此方法来达到接收异常的目的。&lt;/p&gt;
&lt;h3 id=&quot;为工作者线程设置uncaughtexceptionhandler在uncaughtexception方法中处理异常-不推荐&quot;&gt;为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常 (不推荐)&lt;/h3&gt;
&lt;p&gt;1，我们在之前ThreadExecutor-&amp;gt;Worker-&amp;gt;run方法中直接往上抛出了异常，但是这些异常抛到哪里了呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230617110-288596807.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，通过查询JVM的一些资料，最终的异常会到Thread.dispatchUncaughtException中，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230637292-850368941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3，所以当我们自定义UncaughtExceptionHandler时就可以捕获到&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230659293-453513283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试singleThreadPool异常问题
 *
 * @author: wangmeng
 * @date: 2019/3/25 23:40
 */
public class ThreadPoolException {
    private final static Logger LOGGER = LoggerFactory.getLogger(ThreadPoolException.class);

    public static void main(String[] args) throws InterruptedException {
        ExecutorService execute = new ThreadPoolExecutor(1, 1,
                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), new ThreadFactoryBuilder().setUncaughtExceptionHandler(new MyHandler()).build());

        execute.execute(new Runnable() {
            @Override
            public void run() {
                LOGGER.info(&quot;=====11=======&quot;);
            }
        });

        TimeUnit.SECONDS.sleep(5);
        execute.execute(new Run1());
    }


    private static class Run1 implements Runnable {
        @Override
        public void run() {
            int count = 0;
            while (true) {
                count++;
                LOGGER.info(&quot;-------222-------------{}&quot;, count);

                if (count == 10) {
                    System.out.println(1 / 0);
                    try {
                    } catch (Exception e) {
                        LOGGER.error(&quot;Exception&quot;,e);
                    }
                }

                if (count == 20) {
                    LOGGER.info(&quot;count={}&quot;, count);
                    break;
                }
            }
        }
    }
}

class MyHandler implements Thread.UncaughtExceptionHandler {
    private final static Logger LOGGER = LoggerFactory.getLogger(MyHandler.class);
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        LOGGER.error(&quot;threadId = {}, threadName = {}, ex = {}&quot;, t.getId(), t.getName(), e.getMessage());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面说了其实是不推荐重写UncaughtExceptionHandler 的，因为UncaughtExceptionHandler 只有在&lt;code&gt;execute.execute()&lt;/code&gt;方法中才生效，在&lt;code&gt;execute.submit&lt;/code&gt;中是无法捕获到异常的。&lt;/p&gt;
&lt;p&gt;由于本人水平有限，文章中如果有不严谨的地方还请提出来，愿闻其详。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 15:07:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 因为这是之前面试的一个题目，所以印象比较深刻，前几天写了一篇文章： 'ThreadPoolExcutor 线程池 异常处理 （上篇）' 中已经介绍了线程池异常的一些问题以及一步步分析了里面的一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-meng/p/10639914.html</dc:identifier>
</item>
<item>
<title>frp源码剖析-frp中的mux模块 - MnCu</title>
<link>http://www.cnblogs.com/MnCu8261/p/10639897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MnCu8261/p/10639897.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;frp几乎所有的连接处理都是构建在mux模块之上的，重要性不必多说，来看一下这是个啥吧&lt;/p&gt;
&lt;p&gt;ps: 安装方法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go get &quot;github.com/fatedier/golib/net/mux&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模块很小，不到300行，分为两个文件：&lt;code&gt;mux.go&lt;/code&gt;和&lt;code&gt;rule.go&lt;/code&gt;。&lt;br/&gt;因为&lt;code&gt;rule.go&lt;/code&gt;文件相对简单一些，我们先来看这个。&lt;/p&gt;
&lt;h2 id=&quot;role.go文件&quot;&gt;role.go文件&lt;/h2&gt;
&lt;p&gt;首先看其中所命名的函数类型&lt;code&gt;MatchFunc&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MatchFunc func(data []byte) (match bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类型的函数用来判断&lt;code&gt;data&lt;/code&gt;属于什么协议。&lt;/p&gt;
&lt;p&gt;那么具体如何判断呢，这里也实现了三个例子:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var (
    HttpsNeedBytesNum uint32 = 1
    HttpNeedBytesNum  uint32 = 3
    YamuxNeedBytesNum uint32 = 2
)

var HttpsMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(HttpsNeedBytesNum) {
        return false
    }

    if data[0] == 0x16 {
        return true
    } else {
        return false
    }
}

// From https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
var httpHeadBytes = map[string]struct{}{
    &quot;GET&quot;: struct{}{},
    &quot;HEA&quot;: struct{}{},
    &quot;POS&quot;: struct{}{},
    &quot;PUT&quot;: struct{}{},
    &quot;DEL&quot;: struct{}{},
    &quot;CON&quot;: struct{}{},
    &quot;OPT&quot;: struct{}{},
    &quot;TRA&quot;: struct{}{},
    &quot;PAT&quot;: struct{}{},
}

var HttpMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(HttpNeedBytesNum) {
        return false
    }

    _, ok := httpHeadBytes[string(data[:3])]
    return ok
}

// From https://github.com/hashicorp/yamux/blob/master/spec.md
var YamuxMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(YamuxNeedBytesNum) {
        return false
    }

    if data[0] == 0 &amp;amp;&amp;amp; data[1] &amp;gt;= 0x0 &amp;amp;&amp;amp; data[1] &amp;lt;= 0x3 {
        return true
    }
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个函数分别实现了区分&lt;code&gt;HTTPS&lt;/code&gt;,&lt;code&gt;HTTP&lt;/code&gt;以及go中特有的&lt;code&gt;yamux&lt;/code&gt;(实际上这是一个库，可以参考&lt;a href=&quot;http://fishu.cn/blog/%E5%9F%BA%E4%BA%8E-go-%E5%AE%9E%E7%8E%B0i/o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%80/&quot;&gt;Go中的I/O多路复用&lt;/a&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;mux.go文件&quot;&gt;mux.go文件&lt;/h2&gt;
&lt;p&gt;先来看其中的&lt;code&gt;struct&lt;/code&gt;，第一个是&lt;code&gt;Mux&lt;/code&gt;第二个是&lt;code&gt;listener&lt;/code&gt;，这里先来看一下较为简单的&lt;code&gt;listener&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;listener结构体&quot;&gt;listener结构体&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type listener struct {
    mux *Mux

    priority     int
    needBytesNum uint32
    matchFn      MatchFunc

    c  chan net.Conn
    mu sync.RWMutex
}

// Accept waits for and returns the next connection to the listener.
func (ln *listener) Accept() (net.Conn, error) {
    ...
}

// Close removes this listener from the parent mux and closes the channel.
func (ln *listener) Close() error {
    ...
}

func (ln *listener) Addr() net.Addr {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刚看到这个结构体我们可能很迷惑，不知道都是干啥的，而且网络编程中一般listener这种东西要绑定在一个套接字上，但很明显&lt;code&gt;listener&lt;/code&gt;没有，不过其唯一跟套接字相关的可能是其&lt;code&gt;c&lt;/code&gt;字段，其是一个由&lt;code&gt;net&lt;/code&gt;包中的&lt;code&gt;Conn&lt;/code&gt;接口组成的&lt;code&gt;chanel&lt;/code&gt;；然后&lt;code&gt;mu&lt;/code&gt;字段就是&lt;a href=&quot;https://www.zhihu.com/question/66733477&quot;&gt;读写锁&lt;/a&gt;了，这个很简单；然后&lt;code&gt;mux&lt;/code&gt;字段则是上面提到的两个结构体中的另一个结构体&lt;code&gt;Mux&lt;/code&gt;的指针；接下来到了&lt;code&gt;priority&lt;/code&gt;字段上，顾名思义，这个似乎跟优先级有关系，暂且存疑；&lt;code&gt;needBytesNum&lt;/code&gt;则更有些蒙了，不过感觉其是跟读取byte的数量有关系，最后是&lt;code&gt;matchFn&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;好，初步认识了这个结构体的结构后，我们看看其方法。三个方法的&lt;code&gt;listener&lt;/code&gt;实现了&lt;code&gt;net&lt;/code&gt;模块中的&lt;code&gt;Listener&lt;/code&gt;接口:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// A Listener is a generic network listener for stream-oriented protocols.
//
// Multiple goroutines may invoke methods on a Listener simultaneously.
type Listener interface {
    // Accept waits for and returns the next connection to the listener.
    Accept() (Conn, error)

    // Close closes the listener.
    // Any blocked Accept operations will be unblocked and return errors.
    Close() error

    // Addr returns the listener's network address.
    Addr() Addr
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后先来分析其&lt;code&gt;Accept&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Accept() (net.Conn, error) {
    conn, ok := &amp;lt;-ln.c
    if !ok {
        return nil, fmt.Errorf(&quot;network connection closed&quot;)
    }
    return conn, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法很简单，就是从&lt;code&gt;c&lt;/code&gt;这个由&lt;code&gt;Conn&lt;/code&gt;组成的&lt;code&gt;channel&lt;/code&gt;中，获取&lt;code&gt;Conn&lt;/code&gt;对象，好这里我们就明白了，这个&lt;code&gt;listener&lt;/code&gt;和普通的不一样，他很特别，普通的&lt;code&gt;listener&lt;/code&gt;监听的是套接字，而他监听的是&lt;code&gt;channel&lt;/code&gt;，另外，肯定有某个地方在不停的往&lt;code&gt;c&lt;/code&gt;这个&lt;code&gt;channel&lt;/code&gt;中放&lt;code&gt;Conn&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来是&lt;code&gt;Close&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Close() error {
    if ok := ln.mux.release(ln); ok {
        // Close done to signal to any RLock holders to release their lock.
        close(ln.c)
    }
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们暂且先把这个&lt;code&gt;ln.mux.release(ln)&lt;/code&gt;放到一边，因为还不知道这个东西干了啥，暂且只需关注&lt;code&gt;close(ln.c)&lt;/code&gt;，我们知道这个函数是用来关闭&lt;code&gt;channel&lt;/code&gt;的，go推荐由发送端调用，但这里似乎&lt;code&gt;listener&lt;/code&gt;是一个消费端，可以看一下&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32529039&quot;&gt;如何优雅的关闭Go Channel&lt;/a&gt;，看来重点在于&lt;code&gt;ln.mux.release(ln)&lt;/code&gt;这里，我们暂且&lt;sup&gt;存疑[1]&lt;/sup&gt;，留待下面解决。&lt;/p&gt;
&lt;p&gt;最后是&lt;code&gt;Addr&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Addr() net.Addr {
    if ln.mux == nil {
        return nil
    }
    ln.mux.mu.RLock()
    defer ln.mux.mu.RUnlock()
    if ln.mux.ln == nil {
        return nil
    }
    return ln.mux.ln.Addr()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，&lt;code&gt;mu&lt;/code&gt;字段就用上了，加读锁，然后返回&lt;code&gt;mux&lt;/code&gt;字段中的&lt;code&gt;ln&lt;/code&gt;字段的&lt;code&gt;Addr&lt;/code&gt;方法。也就是这句&lt;code&gt;return ln.mux.ln.Addr()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;mux结构体&quot;&gt;Mux结构体&lt;/h3&gt;
&lt;h4 id=&quot;字段以及相关函数&quot;&gt;字段以及相关函数&lt;/h4&gt;
&lt;p&gt;Mux结构体则相对来说复杂很多，先来看一下他的字段定义:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Mux struct {
    ln net.Listener

    defaultLn *listener

    // sorted by priority
    lns             []*listener
    maxNeedBytesNum uint32

    mu sync.RWMutex
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，第一个字段&lt;code&gt;ln&lt;/code&gt;是一个&lt;code&gt;Listener&lt;/code&gt;接口；然后&lt;code&gt;defaultLn&lt;/code&gt;是一个&lt;code&gt;listener&lt;/code&gt;的指针；&lt;code&gt;lns&lt;/code&gt;则是由&lt;code&gt;listener&lt;/code&gt;的指针组成的切片，根据注释&lt;code&gt;// sorted by priority&lt;/code&gt;，我们终于知道&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;priority&lt;/code&gt;字段是干啥的了；接下来是&lt;code&gt;maxNeedBytesNum&lt;/code&gt;字段，好奇怪，比起&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;needBytesNum&lt;/code&gt;多了个“Max”，所以我们推测这个值取得是&lt;code&gt;lns&lt;/code&gt;以及&lt;code&gt;defaultLn&lt;/code&gt;字段中所有&lt;code&gt;listener&lt;/code&gt;中&lt;code&gt;needBytesNum&lt;/code&gt;值最大的；最后的&lt;code&gt;mu&lt;/code&gt;字段我们就不说了。&lt;/p&gt;
&lt;p&gt;需要注意的是：我们可能会发现&lt;code&gt;Mux&lt;/code&gt;和&lt;code&gt;listener&lt;/code&gt;存在相互引用，但在&lt;code&gt;Go&lt;/code&gt;中我们倒也不用太担心，因为&lt;code&gt;Go&lt;/code&gt;采用“标记-回收”或者其变种的垃圾回收算法，感兴趣可以参考&lt;a href=&quot;http://legendtkl.com/2017/04/28/golang-gc/&quot;&gt;Golang 垃圾回收剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mux.go&lt;/code&gt;文件中定义了&lt;code&gt;Mux&lt;/code&gt;的生成函数&lt;code&gt;NewMux&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewMux(ln net.Listener) (mux *Mux) {
    mux = &amp;amp;Mux{
        ln:  ln,
        lns: make([]*listener, 0),
    }
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，需要注意的是&lt;code&gt;ln&lt;/code&gt;字段存储的一般&lt;strong&gt;不是&lt;/strong&gt;&lt;code&gt;listener&lt;/code&gt;这样的非常规Listener，一般是&lt;code&gt;TCPListener&lt;/code&gt;这样具体的绑定了套接字的监听器。&lt;/p&gt;
&lt;h4 id=&quot;mux方法&quot;&gt;Mux方法&lt;/h4&gt;
&lt;p&gt;接下来看&lt;code&gt;Mux&lt;/code&gt;结构体的方法，首先看&lt;code&gt;Listen&lt;/code&gt;和&lt;code&gt;copyLns&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// priority
func (mux *Mux) Listen(priority int, needBytesNum uint32, fn MatchFunc) net.Listener {
    // 1
    ln := &amp;amp;listener{
        c:            make(chan net.Conn),
        mux:          mux,
        priority:     priority,
        needBytesNum: needBytesNum,
        matchFn:      fn,
    }

    mux.mu.Lock()
    defer mux.mu.Unlock()
    // 2
    if needBytesNum &amp;gt; mux.maxNeedBytesNum {
        mux.maxNeedBytesNum = needBytesNum
    }

    // 3
    newlns := append(mux.copyLns(), ln)
    sort.Slice(newlns, func(i, j int) bool {
        if newlns[i].priority == newlns[j].priority {
            return newlns[i].needBytesNum &amp;lt; newlns[j].needBytesNum
        }
        return newlns[i].priority &amp;lt; newlns[j].priority
    })
    mux.lns = newlns
    return ln
}

func (mux *Mux) copyLns() []*listener {
    lns := make([]*listener, 0, len(mux.lns))
    for _, l := range mux.lns {
        lns = append(lns, l)
    }
    return lns
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copyLns&lt;/code&gt;方法很简单，就是跟名字的含义一样，生成一个&lt;code&gt;lns&lt;/code&gt;字段的副本并返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Listen&lt;/code&gt;基本做了三步:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成一个&lt;code&gt;listener&lt;/code&gt;结构体实例，并获取互斥锁&lt;/li&gt;
&lt;li&gt;根据情况更新&lt;code&gt;needBytesNum&lt;/code&gt;字段&lt;/li&gt;
&lt;li&gt;将新生成的&lt;code&gt;listener&lt;/code&gt;实例按照优先级放入&lt;code&gt;lns&lt;/code&gt;字段对应的slice中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来是&lt;code&gt;ListenHttp&lt;/code&gt;和&lt;code&gt;ListenHttps&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) ListenHttp(priority int) net.Listener {
    return mux.Listen(priority, HttpNeedBytesNum, HttpMatchFunc)
}

func (mux *Mux) ListenHttps(priority int) net.Listener {
    return mux.Listen(priority, HttpsNeedBytesNum, HttpsMatchFunc)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个差不多，所以放到一起说，基本都是专门写了一个方法让我们能方便的创建处理&lt;code&gt;Http&lt;/code&gt;或者&lt;code&gt;Https&lt;/code&gt;的&lt;code&gt;listener&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;DefaultListener&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) DefaultListener() net.Listener {
    mux.mu.Lock()
    defer mux.mu.Unlock()
    if mux.defaultLn == nil {
        mux.defaultLn = &amp;amp;listener{
            c:   make(chan net.Conn),
            mux: mux,
        }
    }
    return mux.defaultLn
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，基本就是有则返回没有则生成然后返回的套路。不过我们要注意&lt;code&gt;defaultLn&lt;/code&gt;字段中的&lt;code&gt;listener&lt;/code&gt;是不放入&lt;code&gt;lns&lt;/code&gt;字段中的。&lt;/p&gt;
&lt;p&gt;接下来是&lt;code&gt;Server&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Serve handles connections from ln and multiplexes then across registered listeners.
func (mux *Mux) Serve() error {
    for {
        // Wait for the next connection.
        // If it returns a temporary error then simply retry.
        // If it returns any other error then exit immediately.
        conn, err := mux.ln.Accept()
        if err, ok := err.(interface {
            Temporary() bool
        }); ok &amp;amp;&amp;amp; err.Temporary() {
            continue
        }

        if err != nil {
            return err
        }

        go mux.handleConn(conn)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，当我们调用&lt;code&gt;NewMux&lt;/code&gt;函数以后，接下来就会调用&lt;code&gt;Server&lt;/code&gt;方法，该方法基本上就是阻塞监听某个套接字，当有连接建立成功后立即另起一个goroutine调用&lt;code&gt;handleConn&lt;/code&gt;方法；当连接建立失败根据&lt;code&gt;err&lt;/code&gt;是否含有&lt;code&gt;Temporary&lt;/code&gt;方法，如果有则执行并忽略错误，没有则返回错误。&lt;/p&gt;
&lt;p&gt;现在我们看看&lt;code&gt;handleConn&lt;/code&gt;方法干了些啥:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) handleConn(conn net.Conn) {
    // 1
    mux.mu.RLock()
    maxNeedBytesNum := mux.maxNeedBytesNum
    lns := mux.lns
    defaultLn := mux.defaultLn
    mux.mu.RUnlock()
    
    // 2
    sharedConn, rd := gnet.NewSharedConnSize(conn, int(maxNeedBytesNum))
    data := make([]byte, maxNeedBytesNum)

    conn.SetReadDeadline(time.Now().Add(DefaultTimeout))
    _, err := io.ReadFull(rd, data)
    if err != nil {
        conn.Close()
        return
    }
    conn.SetReadDeadline(time.Time{})
    // 3
    for _, ln := range lns {
        if match := ln.matchFn(data); match {
            err = errors.PanicToError(func() {
                ln.c &amp;lt;- sharedConn
            })
            if err != nil {
                conn.Close()
            }
            return
        }
    }

    // No match listeners
    if defaultLn != nil {
        err = errors.PanicToError(func() {
            defaultLn.c &amp;lt;- sharedConn
        })
        if err != nil {
            conn.Close()
        }
        return
    }

    // No listeners for this connection, close it.
    conn.Close()
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;handleConn&lt;/code&gt;方法也不算复杂，大体可以分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前状态&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;conn&lt;/code&gt;中读取数据，注意：&lt;code&gt;shareConn&lt;/code&gt;和&lt;code&gt;rd&lt;/code&gt;存在单向关系，如果从&lt;code&gt;rd&lt;/code&gt;中读取数据的话，数据也会复制一份放到&lt;code&gt;shareConn&lt;/code&gt;中，反过来就不成立了&lt;/li&gt;
&lt;li&gt;读取到的数据会被遍历，最终选出&lt;code&gt;与matchFunc&lt;/code&gt;匹配的最高优先级的&lt;code&gt;listener&lt;/code&gt;，并将&lt;code&gt;shareConn&lt;/code&gt;放入该&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;c&lt;/code&gt;字段中，如果没有匹配到则放到&lt;code&gt;defaultLn&lt;/code&gt;中的&lt;code&gt;c&lt;/code&gt;字段中，如果&lt;code&gt;defaultLn&lt;/code&gt;是&lt;code&gt;nil&lt;/code&gt;的话就不处理，直接关闭&lt;code&gt;conn&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后来到了&lt;code&gt;release&lt;/code&gt;方法了:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) release(ln *listener) bool {
    result := false
    mux.mu.Lock()
    defer mux.mu.Unlock()
    lns := mux.copyLns()

    for i, l := range lns {
        if l == ln {
            lns = append(lns[:i], lns[i+1:]...)
            result = true
            break
        }
    }
    mux.lns = lns
    return result
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;release方法意思很明确：把对应的&lt;code&gt;listener&lt;/code&gt;从&lt;code&gt;lns&lt;/code&gt;中移除，并把结果返回，整个过程有互斥锁，我们回到&lt;sup&gt;存疑1&lt;/sup&gt;，尽管有互斥锁，但在这种情况下：当某个goroutine运行到&lt;code&gt;handleConn&lt;/code&gt;已经执行到了第三阶段的开始状态(也就是还没有找到匹配的&lt;code&gt;listener&lt;/code&gt;)时，且&lt;code&gt;Go&lt;/code&gt;运行在多核状态下，当另一个goroutine运行完&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;Close&lt;/code&gt;方法时，这时就可能发生往一个已经关闭的&lt;code&gt;channel&lt;/code&gt;中send数据，但请注意&lt;code&gt;handleConn&lt;/code&gt;的第三步的这段代码:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;err = errors.PanicToError(func() { // 就是这里了
    ln.c &amp;lt;- sharedConn
})
if err != nil {
    conn.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;PanicToError&lt;/code&gt;是这样的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func PanicToError(fn func()) (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf(&quot;Panic error: %v&quot;, r)
        }
    }()

    fn()
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本上就是执行了&lt;code&gt;recover&lt;/code&gt;然后将错误打印出来，结合下面的对err的判断，就会将send失败的conn关闭。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Mux&lt;/code&gt;中包含了一个初始监听器，基本上所有的事件(比如说新的连接建立，之所以叫事件是因为我实在想不出更精确的词语了)都起源于此&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listener&lt;/code&gt;实现了&lt;code&gt;net.Listener&lt;/code&gt;接口，可以作为二级监听器使用(比如传给&lt;code&gt;net/http.Server&lt;/code&gt;结构体的&lt;code&gt;Server&lt;/code&gt;方法进行处理)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mux&lt;/code&gt;包含了一个由&lt;code&gt;listener&lt;/code&gt;组成的有序slice，当有事件产生时就会遍历这个slice找出合适的&lt;code&gt;listener&lt;/code&gt;并将事件传给他。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;讲到这里基本上是完事了。整个&lt;code&gt;mux&lt;/code&gt;模块还是比较简单的，起码是由一个个简单的东西组合而成。那么一起来意淫一下整体流程吧。&lt;/p&gt;
&lt;p&gt;假如我要实现这么一个网络程序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;绑定监听一个基于tcp的套接字&lt;/li&gt;
&lt;li&gt;我们允许其应用层可支持多个(比如说支持http https这两个吧，尽管http和https可以说是一个协议。。)，不同的应用层协议对应不同的处理函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就这么两个很简单的要求，不难吧。&lt;/p&gt;
&lt;p&gt;那么我们一起来实现吧:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
type HandleFunc func(c net.Conn) (n int, err error) 

type MyServer struct {
    l net.Listener
    hFunc Handle
}

func (h *MyServer) Server() (err error) {
    for {
        conn, err := h.l.Accept()
        if err != nil {
            return
        }
        go h.hFunc(conn)
    }
}

func HandleHttp(c net.Conn)(n int, err error){
    n, err = c.Write([]byte(&quot;Get Off! Don't you know that it is not safe?&quot;))
}

func HandleHttps(c net.Conn)(n int, err error){
    n, err = c.Write([]byte(&quot;Get Off! Don't you know that this is more complicated than http?&quot;))
}


func main() (err error){
    ln, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:12345&quot;)
    if err != nil {
        err = fmt.Errorf(&quot;Create server listener error, %v&quot;, err)
        return
    }
    muxer = mux.NewMux(ln)
    
    var lHttp, lHttps net.Listener
    lHttp = muxer.ListenHttp(1)
    httpServer := *MyServer{lHttp, HandleHttp}
    
    lHttps = muxer.ListenHttps(2)
    httpsServer := *MyServer{lHttps, HandleHttps}
    
    go httpServer.Server()
    go httpsServer.Server()

    err = muxer.Serve()
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 01 Apr 2019 15:04:00 +0000</pubDate>
<dc:creator>MnCu</dc:creator>
<og:description>前言 frp几乎所有的连接处理都是构建在mux模块之上的，重要性不必多说，来看一下这是个啥吧 ps: 安装方法 该模块很小，不到300行，分为两个文件： 和`rule.go`。 因为 文件相对简单一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MnCu8261/p/10639897.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]扩展属性（替代多表关联Join提升性能） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_extend.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_extend.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 743+）&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;XCode不支持多表关联查询，单表查询利于优化以及分表分库，一切Join都可以借助扩展属性实现，配合缓存使用可以达到更好的效果！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（XCode前期支持多表关联，直到2008年才正式废除）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;“扩展属性”是2007年起XCode特有叫法，不同于其它任何场景的意义（如Silverlight/WPF）&lt;/p&gt;

&lt;p&gt;前文&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;《实体类详解》&lt;/a&gt;中有提到一个学生班级的实体类模型，一个典型需求是查询学生列表时希望暂时班级名称或者其它信息。于是有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; s.&lt;span&gt;*&lt;/span&gt;, c.name &lt;span&gt;where&lt;/span&gt; student s &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; class c &lt;span&gt;on&lt;/span&gt; s.classid&lt;span&gt;=&lt;/span&gt;c.id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sql语法千变万化，如果要支持多表关联join，就很难做到统一查询风格，更是难以优化。&lt;/p&gt;
&lt;p&gt;于是XCode放弃支持多表关联，宁可拆分为多次查询。令人惊讶的是，不仅性能没有下降，反而大大提升了，主要因为单表小查询有多级缓存的加持！&lt;/p&gt;


&lt;p&gt;使用扩展属性来实现关联查询，本质上就是多次查询！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401220650886-1686847874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，这是一个经典的多表关联场景，学生表带有班级ID字段，同样还有产品和分类表等等。&lt;/p&gt;
&lt;p&gt;这是XCode根据模型文件自动生成的代码，因为字段名ClassID刚好是Class表加上它的主键ID，并且都是整型。&lt;/p&gt;
&lt;p&gt;对于实体对象来说，student.Name是学生名称，student.ClassName是班级名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;看起来它们就像是一张表的属性字段，这就是扩展属性的由来，不仅仅是多表关联属性，还可以是其它属性，为区别于数据字段属性，统称为扩展属性！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扩展属性先准备一个Class属性，再加一个ClassName，主要是为了方便某些场合使用 student.Class。&lt;/p&gt;
&lt;p&gt;当然，执行一次查询得到student后，不敢是访问student.Class还是访问student.ClassName，都会触发一次Class.FindByID，可以理解为执行一次查询（不一定是数据库）。&lt;/p&gt;
&lt;p&gt;在Web页面上，如果每页显示20个学生，那么先要执行 select * from student limit 20，然后展示学生列表时，因为需要班级名称，触发扩展属性查询。&lt;/p&gt;
&lt;p&gt;可以认为，理论上这个页面需要查询1+20次。&lt;/p&gt;

&lt;p&gt;扩展属性为什么不写成 public Class Class =&amp;gt; Class.FindByID(ClassID) 呢？&lt;/p&gt;
&lt;p&gt;其实虽然看起来简单，但是还得考虑一个可能，同一个student对象可能多次访问student.ClassName，这么写岂不是每次访问都会执行Class.FindByID？&lt;/p&gt;
&lt;p&gt;因此，XCode设计了扩展集合Extends，可以认为是一个字典，每个扩展属性都经过它走一遭，如果查询过一次就缓存起来，避免反复查询。&lt;/p&gt;
&lt;p&gt;Extends.Get第一个属性是扩展属性名，决定是否有缓存，第二个是没有缓存时要执行的委托。&lt;/p&gt;
&lt;p&gt;这就是扩展属性缓存，默认缓存时间10秒，足够抗住短期内成千上万次重复调用。&lt;/p&gt;


&lt;p&gt;尽管有Extends扩展属性缓存支持，但每个对象还是要执行一次Class.FindByID查询，损耗还是不小的。&lt;/p&gt;
&lt;p&gt;在XCode里面，根据主键而设计的查询（如FindByID）往往带有很好的缓存优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401222840449-878153953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，这是XCode默认生成的代码，当Class表数据不足1000行时，走实体缓存。&lt;/p&gt;
&lt;p&gt;也就是说，Meta.Cache时执行一次 select * from student 返回所有行，并缓存起来。后面的Find实际上是在缓存中查找。实体缓存有效期默认10秒。&lt;/p&gt;
&lt;p&gt;只有数据表达到1000行，才走 Find(_.ID==id) 数据库查询 select * from class where id=? 。然而XCode下层还有一个数据层缓存，相同select查询默认缓存10秒&lt;/p&gt;
&lt;p&gt;此外，也可以根据业务特点采用单对象缓存，例如跨境电商的产品种类特别多（10万+），可以采用字典式的单对象缓存。&lt;/p&gt;

&lt;p&gt;因此，在学生类那边看起来访问属性会触发多次Class.FindByID，殊不知它内部别有洞天，三级缓存（实体缓存、对象缓存、数据缓存）等着伺候！（后续专文介绍缓存）&lt;/p&gt;

&lt;p&gt;回到开头的例子，一个列表页显示20个学生，理论查询次数1+20次，在多级缓存加持的扩展属性下，99.99%的时候只会查询1次，而班级表的关联，完全在内存缓存中进行。&lt;/p&gt;
&lt;p&gt;一次简单的单表查询，显然要比join班级表的查询要快得多！&lt;/p&gt;


&lt;p&gt;在上述扩展属性中，注意到ClassName属性上有一个Map特性。&lt;/p&gt;
&lt;p&gt;它表示映射，本对象的ClassID字段，映射到Class类的ID字段。&lt;/p&gt;
&lt;p&gt;在魔方列表页中，本来显示冷冰冰ClassID的地方，就会变为显示友好的ClassName。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224441197-814418010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在魔方表单页中，本来显示数字框ClassID的地方，也会变成显示下拉列表框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224520001-1814489048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果下拉列表库内容很多，可以精简Map特性，只要第一个参数指明本地字段，而不需要第二第三字段表示的目标字段。此时在魔方表单页会显示数字框，但是后面显示ClassName&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224601176-1568398835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;到此，你还认为多次查询一定比单次Join慢吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:47:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>XCode不支持多表关联查询，单表查询利于优化以及分表分库，一切Join都可以借助扩展属性实现，配合缓存使用可以达到更好的效果！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_extend.html</dc:identifier>
</item>
<item>
<title>工程实践：让变量命名做到&quot;自解释&quot; - Matrix海子</title>
<link>http://www.cnblogs.com/dolphin0520/p/10639167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphin0520/p/10639167.html</guid>
<description>&lt;p&gt;工程实践：让变量命名做到&quot;自解释&quot;&lt;/p&gt;
&lt;p&gt;　　在上一篇文章中跟大家分享了关于函数命名的一些实践心得，今天我们继续命名这个话题，来讲一讲如何对变量命名。&lt;/p&gt;
&lt;p&gt;　　以下是本文的目录大纲：&lt;/p&gt;
&lt;p&gt;　　一. 变量命名风格&lt;/p&gt;
&lt;p&gt;　　二. 变量命名最高境界&lt;/p&gt;
&lt;p&gt;　　三. 变量命名最佳实践&lt;/p&gt;
&lt;p&gt;　　若有不正之处请多多谅解，并欢迎批评指正。&lt;/p&gt;
&lt;p&gt;　　请尊重作者劳动成果，转载请标明原文链接：&lt;/p&gt;
&lt;p&gt;    　https://www.cnblogs.com/dolphin0520/p/10639167.html&lt;/p&gt;

&lt;h2&gt;一.变量命名风格&lt;/h2&gt;
&lt;p&gt;　　变量命名风格通常会根据不同的变量类型来区分，以Java语言为例，根据变量类型不同有两种命名风格：&lt;/p&gt;
&lt;p&gt;1）类成员变量、局部变量&lt;/p&gt;
&lt;p&gt;　　类成员变量、局部变量通常采用&lt;strong&gt;驼峰命名&lt;/strong&gt;风格，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String userName;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）静态成员变量、枚举值、常量&lt;/p&gt;
&lt;p&gt;　　静态成员变量、枚举值、常量通常采用&lt;strong&gt;所有字母大写、多个单词以英文下划线连接&lt;/strong&gt;，如：&lt;/p&gt;

&lt;h2&gt;二.变量命名最高境界&lt;/h2&gt;
&lt;p&gt;　　在函数命名那篇中我们说的函数命名最高境界是见字如面，那么对于变量命名来说，最高境界是什么呢？ 我认为是：自解释，即&quot;代码即注释&quot;。&lt;/p&gt;
&lt;p&gt;　　为什么这么说呢，因为通常来说一个函数是会有函数注释的，即使函数名字取的不好，如果注释写的比较清楚，对于后续维护人员来说也是了解函数具体功能的一种方式。&lt;/p&gt;
&lt;p&gt;　　而变量则不同，在一个工程里面，变量的数量远远大于函数的数量，所以不太可能对于每个变量都去写注释，所以如果一个工程的变量命名很糟糕，那么对于后续维护人员来说将是毁灭性的打击，因为每读到一个变量，可能就需要去猜测变量的含义，我想没有哪个人愿意读到这样的代码，永远记住一点：&quot;代码是写给人看的，不是写给机器看的&quot;。&lt;/p&gt;
&lt;p&gt;　　譬如下面这段代码的命名就非常糟糕：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ppn = (cpn &amp;gt; 1) ? (cpn - 1) : cpn;
npn = (cpn &amp;lt; tpn) ? (cpn + 1) : tpn;
​
p = new Page(ppn, cpn, npn, tpn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这段代码估计只有原作者清楚地知道各个变量的含义是啥了，&lt;/p&gt;
&lt;p&gt;　　如果修改为下面这种写法，可读性会好很多，并且一目了然，很容易知道其大概意图是计算分页信息：&lt;/p&gt;

&lt;h2&gt;三.变量命名最佳实践&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）采用名词或者形容词来命名变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　变量一般情况下建议使用名词、名字组合或者形容词，因为变量一般形容的是一种事物或者事物的属性，所以用名词或者名词组合更容易让人理解，而形容词一般用于bool类型的变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）避免使用单字母变量，尽量细化变量含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在程序中，尽量避免使用单字母变量，唯一可以接受使用单字母变量的场景只有for循环，不过还是不太推荐在for循环中使用单字母变量(用pos、index比for循环的i、j、k要好很多)。&lt;/p&gt;
&lt;p&gt;　　举个例子，比如下面这行代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3）变量命名前后用词需统一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在同一个工程或者一个场景下，变量命名风格需前后统一，比如total和sum都能表示总计的意思，那么所有需要用到&quot;总计&quot;含义的地方要么全部使用total、要么全部使用sum。&lt;/p&gt;
&lt;p&gt;　　保持前后命名风格统一是保证工程代码良好可读性的关键保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）集合变量用类型或者复数s作为后缀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在java中，有很多集合，比如List、Map、Set等，那么集合变量该怎么命名呢？&lt;/p&gt;
&lt;p&gt;　　一般可采取两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;使用复数s结尾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上面两种方式均可，没有比较明显的偏好，根据实际场景决定。第一种方式相对更简洁，第二种在局部作用域里面有多种相关的集合变量时区分度更大，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
List&amp;lt;Student&amp;gt; studentList = new ArrayList&amp;lt;&amp;gt;();
Map&amp;lt;Long, Student&amp;gt; studentMap = Maps.newHashMap();
​
for (Student stu : studentList) {
  studentMap.put(stu.getId, stu);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我的建议是如果局部作用域只有一种类型的集合，那么推荐使用复数形式；如果局部作用域有多个相关的集合类型，那么推荐用类型结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）禁止使用is作为bool类型的类成员变量前置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在java中，禁止用is作为bool类型的类成员变量的前缀，因为is作为前缀会导致序列化/反序列出现问题，阿里的java代码规范中也明确提到了这一点，所以在写代码的时候最好还是遵守公认的规范，不然哪天说不定就踩坑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）尽量避免使用缩写进行命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有些时候，变量名可能有点长，不利于代码可读性，因此很多时候在写代码的时候喜欢用缩写来命名，但这个不是一个好的习惯，除非使用的缩写是大家都会使用的约定俗称的缩写。&lt;/p&gt;
&lt;p&gt;　　比如下面这个命名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int averageStudentAge;  =&amp;gt;  int avgStudentAge;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为avg大家都知道是average的缩写，所以这么写问题不大，不会引起歧义；&lt;/p&gt;
&lt;p&gt;　　但是下面这种缩写命名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
res
tmp
cnt
dep
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就不是好的缩写命名，因为不同的人阅读可能会有不同的理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
res =&amp;gt; response、resource、result
tmp =&amp;gt; temporary、template
cnt =&amp;gt; count、content、context
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　附上一些约定俗称的缩写：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;全称&lt;/td&gt;
&lt;td&gt;缩写&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;identification&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;average&lt;/td&gt;
&lt;td&gt;avg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;maximum&lt;/td&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;minimum&lt;/td&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;buffer&lt;/td&gt;
&lt;td&gt;buf&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;msg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;img&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;library&lt;/td&gt;
&lt;td&gt;lib&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;position&lt;/td&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;data transfer object&lt;/td&gt;
&lt;td&gt;dto&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;view object&lt;/td&gt;
&lt;td&gt;vo&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;7）抛弃掉flag变量&lt;/p&gt;
&lt;p&gt;　　国内一些早期的教材上，到处充斥着各种flag风格的变量，这种命名方式对于大型工程简直就是噩梦，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int flag = getDoctorFlag(doctorId);
if (flag == 1) {
  //....
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看到这段代码，读者会有疑问flag变量的含义是什么？flag值为1的时候又代表什么含义？是医生的值班/在岗状态、还是医生的身体状态？估计读者的内心是崩溃的。&lt;/p&gt;
&lt;p&gt;　　如果优化成下面这种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
DutyStatus doctorDutyStatus = getDoctorDutyStatus(doctorId);
if (doctorDutyStatus == DutyStatus.ONLINE) {
  // ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就比上面的形式清晰多了，很容易看出来判断的是医生的值班/在岗状态。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:34:00 +0000</pubDate>
<dc:creator>Matrix海子</dc:creator>
<og:description>工程实践：让变量命名做到&quot;自解释&quot; 在上一篇文章中跟大家分享了关于函数命名的一些实践心得，今天我们继续命名这个话题，来讲一讲如何对变量命名。 以下是本文的目录大纲： 一. 变量命名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphin0520/p/10639167.html</dc:identifier>
</item>
<item>
<title>深度解密Go语言之Slice - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10631989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10631989.html</guid>
<description>&lt;p&gt;Go 语言的 &lt;code&gt;slice&lt;/code&gt; 很好用，不过也有一些坑。&lt;code&gt;slice&lt;/code&gt; 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它。而且在我写这篇文章的过程中，发现绝大部分文章都存在一些问题，文章里会讲到，这里先不展开。&lt;/p&gt;
&lt;p&gt;我希望本文可以终结这个话题，下次再有人想和你讨论 &lt;code&gt;slice&lt;/code&gt;，直接把这篇文章的链接丢过去就行了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 翻译成中文就是&lt;code&gt;切片&lt;/code&gt;，它和&lt;code&gt;数组（array）&lt;/code&gt;很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。&lt;/p&gt;
&lt;p&gt;了解 slice 的本质，最简单的方法就是看它的源代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗，&lt;code&gt;slice&lt;/code&gt; 共有三个属性：&lt;br/&gt;&lt;code&gt;指针&lt;/code&gt;，指向底层数组；&lt;br/&gt;&lt;code&gt;长度&lt;/code&gt;，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；&lt;br/&gt;&lt;code&gt;容量&lt;/code&gt;，底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55270142-876c2000-52d6-11e9-99e5-2e921fc2d430.png&quot; alt=&quot;切片数据结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。&lt;/p&gt;

&lt;p&gt;创建 slice 的方式有以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;直接声明&lt;/td&gt;
&lt;td&gt;&lt;code&gt;var slice []int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;new&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := *new([]int)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;字面量&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := []int{1,2,3,4,5}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;make&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := make([]int, 5, 10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;从切片或数组“截取”&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := array[1:5]&lt;/code&gt; 或 &lt;code&gt;slice := sourceSlice[1:5]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;直接声明&quot;&gt;直接声明&lt;/h2&gt;
&lt;p&gt;第一种创建出来的 slice 其实是一个 &lt;code&gt;nil slice&lt;/code&gt;。它的长度和容量都为0。和&lt;code&gt;nil&lt;/code&gt;比较的结果为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里比较混淆的是&lt;code&gt;empty slice&lt;/code&gt;，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 &lt;code&gt;0xc42003bda0&lt;/code&gt;。空切片和 &lt;code&gt;nil&lt;/code&gt; 比较的结果为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它们的内部结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54864985-ac720780-4d99-11e9-8386-68ef68880c8d.png&quot; alt=&quot;nil slice 与 empty slice&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;方式一&lt;/td&gt;
&lt;td&gt;var s1 []int&lt;/td&gt;
&lt;td&gt;var s2 = []int{}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;方式二&lt;/td&gt;
&lt;td&gt;var s4 = *new([]int)&lt;/td&gt;
&lt;td&gt;var s3 = make([]int, 0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;容量&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;和 &lt;code&gt;nil&lt;/code&gt; 比较&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 &lt;code&gt;nil&lt;/code&gt; 切片。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;nil slice&lt;/code&gt;和&lt;code&gt;empty slice&lt;/code&gt;的探索可以参考公众号“码洞”作者老钱写的一篇文章《深度解析 Go 语言中「切片」的三种特殊状态》，地址附在了参考资料部分。&lt;/p&gt;
&lt;h2 id=&quot;字面量&quot;&gt;字面量&lt;/h2&gt;
&lt;p&gt;比较简单，直接用&lt;code&gt;初始化表达式&lt;/code&gt;创建。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s1 := []int{0, 1, 2, 3, 8: 100}
    fmt.Println(s1, len(s1), cap(s1))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[0 1 2 3 0 0 0 0 100] 9 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;唯一值得注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 &lt;code&gt;0 值&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;make&quot;&gt;make&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。&lt;/p&gt;
&lt;p&gt;上篇文章&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10562216.html&quot;&gt;《走进Go的底层》&lt;/a&gt;中，我们学到了汇编这个工具，这次我们再次请出汇编来更深入地看看&lt;code&gt;slice&lt;/code&gt;。如果没看过上篇文章，建议先回去看完，再继续阅读本文效果更佳。&lt;/p&gt;
&lt;p&gt;先来一小段玩具代码，使用 &lt;code&gt;make&lt;/code&gt; 关键字创建 &lt;code&gt;slice&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    slice := make([]int, 5, 10) // 长度为5，容量为10
    slice[2] = 2 // 索引为2的元素赋值为2
    fmt.Println(slice)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行如下命令，得到 Go 汇编代码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool compile -S main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只关注main函数：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;0x0000 00000 (main.go:5)TEXT    &quot;&quot;.main(SB), $96-0
0x0000 00000 (main.go:5)MOVQ    (TLS), CX
0x0009 00009 (main.go:5)CMPQ    SP, 16(CX)
0x000d 00013 (main.go:5)JLS     228
0x0013 00019 (main.go:5)SUBQ    $96, SP
0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)
0x001c 00028 (main.go:5)LEAQ    88(SP), BP
0x0021 00033 (main.go:5)FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x0021 00033 (main.go:5)FUNCDATA    $1, gclocals·57cc5e9a024203768cbab1c731570886(SB)
0x0021 00033 (main.go:5)LEAQ    type.int(SB), AX
0x0028 00040 (main.go:6)MOVQ    AX, (SP)
0x002c 00044 (main.go:6)MOVQ    $5, 8(SP)
0x0035 00053 (main.go:6)MOVQ    $10, 16(SP)
0x003e 00062 (main.go:6)PCDATA  $0, $0
0x003e 00062 (main.go:6)CALL    runtime.makeslice(SB)
0x0043 00067 (main.go:6)MOVQ    24(SP), AX
0x0048 00072 (main.go:6)MOVQ    32(SP), CX
0x004d 00077 (main.go:6)MOVQ    40(SP), DX
0x0052 00082 (main.go:7)CMPQ    CX, $2
0x0056 00086 (main.go:7)JLS     221
0x005c 00092 (main.go:7)MOVQ    $2, 16(AX)
0x0064 00100 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)
0x0069 00105 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_2+72(SP)
0x006e 00110 (main.go:8)MOVQ    DX, &quot;&quot;..autotmp_2+80(SP)
0x0073 00115 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+48(SP)
0x007c 00124 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+56(SP)
0x0085 00133 (main.go:8)LEAQ    type.[]int(SB), AX
0x008c 00140 (main.go:8)MOVQ    AX, (SP)
0x0090 00144 (main.go:8)LEAQ    &quot;&quot;..autotmp_2+64(SP), AX
0x0095 00149 (main.go:8)MOVQ    AX, 8(SP)
0x009a 00154 (main.go:8)PCDATA  $0, $1
0x009a 00154 (main.go:8)CALL    runtime.convT2Eslice(SB)
0x009f 00159 (main.go:8)MOVQ    16(SP), AX
0x00a4 00164 (main.go:8)MOVQ    24(SP), CX
0x00a9 00169 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_1+48(SP)
0x00ae 00174 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_1+56(SP)
0x00b3 00179 (main.go:8)LEAQ    &quot;&quot;..autotmp_1+48(SP), AX
0x00b8 00184 (main.go:8)MOVQ    AX, (SP)
0x00bc 00188 (main.go:8)MOVQ    $1, 8(SP)
0x00c5 00197 (main.go:8)MOVQ    $1, 16(SP)
0x00ce 00206 (main.go:8)PCDATA  $0, $1
0x00ce 00206 (main.go:8)CALL    fmt.Println(SB)
0x00d3 00211 (main.go:9)MOVQ    88(SP), BP
0x00d8 00216 (main.go:9)ADDQ    $96, SP
0x00dc 00220 (main.go:9)RET
0x00dd 00221 (main.go:7)PCDATA  $0, $0
0x00dd 00221 (main.go:7)CALL    runtime.panicindex(SB)
0x00e2 00226 (main.go:7)UNDEF
0x00e4 00228 (main.go:7)NOP
0x00e4 00228 (main.go:5)PCDATA  $0, $-1
0x00e4 00228 (main.go:5)CALL    runtime.morestack_noctxt(SB)
0x00e9 00233 (main.go:5)JMP     0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先说明一下，Go 语言汇编 &lt;code&gt;FUNCDATA&lt;/code&gt; 和 &lt;code&gt;PCDATA&lt;/code&gt; 是编译器产生的，用于保存一些和垃圾收集相关的信息，我们先不用 care。&lt;/p&gt;
&lt;p&gt;以上汇编代码行数比较多，没关系，因为命令都比较简单，而且我们的 Go 源码也足够简单，没有理由看不明白。&lt;/p&gt;
&lt;p&gt;我们先从上到下扫一眼，看到几个关键函数：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;CALL    runtime.makeslice(SB)
CALL    runtime.convT2Eslice(SB)
CALL    fmt.Println(SB)
CALL    runtime.morestack_noctxt(SB)&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;创建slice&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;类型转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;打印函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;栈空间扩容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;1&lt;/code&gt;是创建 slice 相关的；&lt;code&gt;2&lt;/code&gt;是类型转换；调用 &lt;code&gt;fmt.Println&lt;/code&gt;需要将 slice 作一个转换； &lt;code&gt;3&lt;/code&gt;是打印语句；&lt;code&gt;4&lt;/code&gt;是栈空间扩容函数，在函数开始处，会检查当前栈空间是否足够，不够的话需要调用它来进行扩容。暂时可以忽略。&lt;/p&gt;
&lt;p&gt;调用了函数就会涉及到参数传递，Go 的参数传递都是通过 栈空间完成的。接下来，我们详细分析这整个过程。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;main&lt;/code&gt;函数定义，栈帧大小为 &lt;code&gt;96B&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;2-4&lt;/td&gt;
&lt;td&gt;判断栈是否需要进行扩容，如果需要则跳到 &lt;code&gt;228&lt;/code&gt;，这里会调用 &lt;code&gt;runtime.morestack_noctxt(SB)&lt;/code&gt; 进行栈扩容操作。具体细节后续还会有文章来讲&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5-9&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;caller BP&lt;/code&gt; 压栈，具体细节后面会讲到&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;10-15&lt;/td&gt;
&lt;td&gt;调用 &lt;code&gt;runtime.makeslice(SB)&lt;/code&gt; 函数及准备工作。*_type表示的是 &lt;code&gt;int&lt;/code&gt;，也就是 &lt;code&gt;slice&lt;/code&gt; 元素的类型。这里对应的源码是第6行，也就是调用 &lt;code&gt;make&lt;/code&gt; 创建 &lt;code&gt;slice&lt;/code&gt; 的那一行。&lt;code&gt;5&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 分别代表长度和容量，函数参数会在栈顶准备好，之后执行函数调用命令 &lt;code&gt;CALL&lt;/code&gt;，进入到被调用函数的栈帧，就会按顺序从 &lt;code&gt;caller&lt;/code&gt; 的栈顶取函数参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;16-18&lt;/td&gt;
&lt;td&gt;接收 &lt;code&gt;makeslice&lt;/code&gt;的返回值，通过 &lt;code&gt;move&lt;/code&gt; 移动到寄存器中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;19-21&lt;/td&gt;
&lt;td&gt;给数组索引值为 &lt;code&gt;2&lt;/code&gt; 的元素赋上值 &lt;code&gt;2&lt;/code&gt;，因为是 &lt;code&gt;int&lt;/code&gt; 型的 &lt;code&gt;slice&lt;/code&gt;，元素大小为8字节，所以 &lt;code&gt;MOVQ $2, 16(AX)&lt;/code&gt; 此命令就是将 &lt;code&gt;2&lt;/code&gt; 搬到索引为 &lt;code&gt;2&lt;/code&gt; 的位置。这里还会对索引值的大小进行检查，如果越界，则会跳转到 &lt;code&gt;221&lt;/code&gt;，执行 &lt;code&gt;panic&lt;/code&gt; 函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;22-26&lt;/td&gt;
&lt;td&gt;分别通过寄存器 &lt;code&gt;AX，CX，DX&lt;/code&gt; 将 &lt;code&gt;makeslice&lt;/code&gt; 的返回值 &lt;code&gt;move&lt;/code&gt; 到内存的其他位置，也称为局部变量，这样就构造出了 &lt;code&gt;slice&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54982728-5fcf3c00-4fe6-11e9-819b-9c5b45cc93bf.png&quot; alt=&quot;makeslice 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边是栈上的数据，右边是堆上的数据。&lt;code&gt;array&lt;/code&gt; 指向 &lt;code&gt;slice&lt;/code&gt; 的底层数据，被分配到堆上了。注意，栈上的地址是从高向低增长；堆则从低向高增长。栈左边的数字表示对应的汇编代码的行数，栈右边箭头则表示栈地址。（48）SP、（56）SP 表示的内容接着往下看。&lt;/p&gt;
&lt;p&gt;注意，在图中，栈地址是从下往上增长，所以 SP 表示的是图中 &lt;code&gt;*_type&lt;/code&gt; 所在的位置，其它的依此类推。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;27-32&lt;/td&gt;
&lt;td&gt;准备调用 &lt;code&gt;runtime.convT2Eslice(SB)&lt;/code&gt;的函数参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;33-36&lt;/td&gt;
&lt;td&gt;接收返回值，通过AX，CX寄存器 &lt;code&gt;move&lt;/code&gt; 到(48)SP、（56）SP&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;convT2Eslice&lt;/code&gt; 的函数声明如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func convT2Eslice(t *_type, elem unsafe.Pointer) (e eface) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是指针 &lt;code&gt;*_type&lt;/code&gt;，&lt;code&gt;_type&lt;/code&gt;是一个表示类型的结构体，这里传入的就是 &lt;code&gt;slice&lt;/code&gt;的类型 &lt;code&gt;[]int&lt;/code&gt;；第二个参数则是元素的指针，这里传入的就是 &lt;code&gt;slice&lt;/code&gt; 底层数组的首地址。&lt;/p&gt;
&lt;p&gt;返回值 &lt;code&gt;eface&lt;/code&gt; 的结构体定义如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type eface struct {
    _type *_type
    data  unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们会调用 &lt;code&gt;fmt.Println(slice)&lt;/code&gt;，看下函数原型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Println(a ...interface{}) (n int, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Println&lt;/code&gt; 接收 interface 类型，因此我们需要将 &lt;code&gt;slice&lt;/code&gt; 转换成 interface 类型。由于 &lt;code&gt;slice&lt;/code&gt; 没有方法，是个“&lt;code&gt;空 interface&lt;/code&gt;”。因此会调用 &lt;code&gt;convT2Eslice&lt;/code&gt; 完成这一转换过程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;convT2Eslice&lt;/code&gt; 函数返回的是类型指针和数据地址。源码就不贴了，大体流程是：调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配一块内存，把数据 &lt;code&gt;copy&lt;/code&gt; 进到新的内存，然后返回这块内存的地址，&lt;code&gt;*_type&lt;/code&gt; 则直接返回传入的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55271648-2d298a00-52eb-11e9-9dd0-e1bcc1fe33d0.png&quot; alt=&quot;convT2Eslice 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;32(SP)&lt;/code&gt; 和 &lt;code&gt;40(SP)&lt;/code&gt; 其实是 &lt;code&gt;makeslice&lt;/code&gt; 函数的返回值，这里可以忽略。&lt;/p&gt;
&lt;p&gt;还剩 &lt;code&gt;fmt.Println(slice)&lt;/code&gt; 最后一个函数调用了，我们继续。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;37-40&lt;/td&gt;
&lt;td&gt;准备 &lt;code&gt;Println&lt;/code&gt; 函数参数。共3个参数，第一个是类型地址，还有两个 &lt;code&gt;1&lt;/code&gt;，这块暂时还不知道为什么要传，有了解的同学可以在文章后面留言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以调用 &lt;code&gt;fmt.Println(slice)&lt;/code&gt; 时，实际是传入了一个 &lt;code&gt;slice类型的eface地址&lt;/code&gt;。这样，&lt;code&gt;Println&lt;/code&gt;就可以访问类型中的数据，最终给“打印”出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55271702-1f283900-52ec-11e9-9d3f-d8eb754ef23c.png&quot; alt=&quot;fmt.Println 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们看下 &lt;code&gt;main&lt;/code&gt; 函数栈帧的开始和收尾部分。&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;0x0013 00019 (main.go:5)SUBQ    $96, SP
0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)
0x001c 00028 (main.go:5)LEAQ    88(SP), BP
…………………………
0x00d3 00211 (main.go:9)MOVQ    88(SP), BP
0x00d8 00216 (main.go:9)ADDQ    $96, SP
RET&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BP&lt;/code&gt;可以理解为保存了当前函数栈帧栈底的地址，&lt;code&gt;SP&lt;/code&gt;则保存栈顶的地址。&lt;/p&gt;
&lt;p&gt;初始，&lt;code&gt;BP&lt;/code&gt; 和 &lt;code&gt;SP&lt;/code&gt; 分别有一个初始状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数执行的时候，先根据 &lt;code&gt;main&lt;/code&gt; 函数栈帧大小确定 &lt;code&gt;SP&lt;/code&gt; 的新指向，使得 &lt;code&gt;main&lt;/code&gt; 函数栈帧大小达到 &lt;code&gt;96B&lt;/code&gt;。之后把老的 &lt;code&gt;BP&lt;/code&gt; 保存到 &lt;code&gt;main&lt;/code&gt; 函数栈帧的底部，并使 &lt;code&gt;BP&lt;/code&gt; 寄存器重新指向新的栈底，也就是 &lt;code&gt;main&lt;/code&gt; 函数栈帧的栈底。&lt;/p&gt;
&lt;p&gt;最后，当 &lt;code&gt;main&lt;/code&gt; 函数执行完毕，把它栈底的 &lt;code&gt;BP&lt;/code&gt; 给回弹回到 &lt;code&gt;BP&lt;/code&gt; 寄存器，恢复调用前的初始状态。一切都像是没有发生一样，完美的现场。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54874022-24821100-4e1e-11e9-805b-408c29b3c1c4.png&quot; alt=&quot;栈帧变化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分，又详细地分析了一遍函数调用的过程。一方面，让大家复习一下上一篇文章讲的内容；另一方面，向大家展示如何找到 Go 中的一个函数背后真实调用了哪些函数。像例子中，我们就看到了 &lt;code&gt;make&lt;/code&gt; 函数背后，实际上是调用了 &lt;code&gt;makeslice&lt;/code&gt; 函数；还有一点，让大家对汇编不那么“惧怕”，可以轻松地分析一些东西。&lt;/p&gt;
&lt;h2 id=&quot;截取&quot;&gt;截取&lt;/h2&gt;
&lt;p&gt;截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。&lt;/p&gt;
&lt;p&gt;基于已有 slice 创建新 slice 对象，被称为 &lt;code&gt;reslice&lt;/code&gt;。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。&lt;/p&gt;
&lt;p&gt;值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 &lt;code&gt;append&lt;/code&gt; 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，&lt;code&gt;问题的关键在于两者是否会共用底层数组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;截取操作采用如下方式：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt; data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
 slice := data[2:4:6] // data[low, high, max]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 &lt;code&gt;data&lt;/code&gt; 使用3个索引值，截取出新的 &lt;code&gt;slice&lt;/code&gt;。这里 &lt;code&gt;data&lt;/code&gt; 可以是数组或者 &lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;low&lt;/code&gt; 是最低索引值，这里是闭区间，也就是说第一个元素是 &lt;code&gt;data&lt;/code&gt; 位于 &lt;code&gt;low&lt;/code&gt; 索引处的元素；而 &lt;code&gt;high&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 则是开区间，表示最后一个元素只能是索引 &lt;code&gt;high-1&lt;/code&gt; 处的元素，而最大容量则只能是索引 &lt;code&gt;max-1&lt;/code&gt; 处的元素。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;max &amp;gt;= high &amp;gt;= low&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;high == low&lt;/code&gt; 时，新 &lt;code&gt;slice&lt;/code&gt; 为空。&lt;/p&gt;
&lt;p&gt;还有一点，&lt;code&gt;high&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 必须在老数组或者老 &lt;code&gt;slice&lt;/code&gt; 的容量（&lt;code&gt;cap&lt;/code&gt;）范围内。&lt;/p&gt;
&lt;p&gt;来看一个例子，来自雨痕大佬《Go学习笔记》第四版，P43页，参考资料里有开源书籍地址。这里我会进行扩展，并会作详细说明：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s1 := slice[2:5]
    s2 := s1[2:6:7]

    s2 = append(s2, 100)
    s2 = append(s2, 200)

    s1[2] = 20

    fmt.Println(s1)
    fmt.Println(s2)
    fmt.Println(slice)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看下代码运行的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来走一遍代码，初始状态如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
s1 := slice[2:5]
s2 := s1[2:6:7]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;s1&lt;/code&gt; 从 &lt;code&gt;slice&lt;/code&gt; 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。&lt;br/&gt;&lt;code&gt;s2&lt;/code&gt; 从 &lt;code&gt;s1&lt;/code&gt; 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54960948-c5490b80-4f99-11e9-8772-66d102caae8e.png&quot; alt=&quot;slice origin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，向 &lt;code&gt;s2&lt;/code&gt; 尾部追加一个元素 100：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s2 = append(s2, 100)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;s2&lt;/code&gt; 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 &lt;code&gt;s1&lt;/code&gt; 都可以看得到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54960896-8ca93200-4f99-11e9-86de-df4d85cca135.png&quot; alt=&quot;append 100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次向 &lt;code&gt;s2&lt;/code&gt; 追加元素200：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s2 = append(s2, 100)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，&lt;code&gt;s2&lt;/code&gt; 的容量不够用，该扩容了。于是，&lt;code&gt;s2&lt;/code&gt; 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 &lt;code&gt;append&lt;/code&gt; 带来的再一次扩容，&lt;code&gt;s2&lt;/code&gt; 会在此次扩容的时候多留一些 &lt;code&gt;buffer&lt;/code&gt;，将新的容量将扩大为原始容量的2倍，也就是10了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54961368-4654d280-4f9b-11e9-9b00-de96c6eedea9.png&quot; alt=&quot;append 200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，修改 &lt;code&gt;s1&lt;/code&gt; 索引为2位置的元素：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s1[2] = 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次只会影响原始数组相应位置的元素。它影响不到 &lt;code&gt;s2&lt;/code&gt; 了，人家已经远走高飞了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54961330-29200400-4f9b-11e9-88d0-a29308a818ae.png&quot; alt=&quot;s1[2]=20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再提一点，打印 &lt;code&gt;s1&lt;/code&gt; 的时候，只会打印出 &lt;code&gt;s1&lt;/code&gt; 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。&lt;/p&gt;
&lt;p&gt;至于，我们想在汇编层面看看到底它们是如何共享底层数组的，限于篇幅，这里不再展开。感兴趣的同学可以在公众号后台回复：&lt;code&gt;切片截取&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我会给你详细分析函数调用关系，对共享底层数组的行为也会一目了然。二维码见文章底部。&lt;/p&gt;

&lt;p&gt;slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。&lt;/p&gt;
&lt;p&gt;数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 &lt;code&gt;[3]int&lt;/code&gt; 和 &lt;code&gt;[4]int&lt;/code&gt; 就是不同的类型。&lt;/p&gt;
&lt;p&gt;而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。&lt;/p&gt;

&lt;p&gt;先来看看 &lt;code&gt;append&lt;/code&gt; 函数的原型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func append(slice []Type, elems ...Type) []Type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 &lt;code&gt;...&lt;/code&gt; 传入 slice，直接追加一个切片。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt;函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;append(slice, elem1, elem2)
append(slice, anotherSlice...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以上面的用法是错的，不能编译通过。&lt;/p&gt;
&lt;p&gt;使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 &lt;code&gt;len-1&lt;/code&gt; 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。&lt;/p&gt;
&lt;p&gt;这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 &lt;code&gt;slice&lt;/code&gt; 的容量是留了一定的 &lt;code&gt;buffer&lt;/code&gt; 的。否则，每次添加元素的时候，都会发生迁移，成本太高。&lt;/p&gt;
&lt;p&gt;新 slice 预留的 &lt;code&gt;buffer&lt;/code&gt; 大小是有一定规律的。网上大多数的文章都是这样描述的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当原 slice 容量小于 &lt;code&gt;1024&lt;/code&gt; 的时候，新 slice 容量变成原来的 &lt;code&gt;2&lt;/code&gt; 倍；原 slice 容量超过 &lt;code&gt;1024&lt;/code&gt;，新 slice 容量变成原来的&lt;code&gt;1.25&lt;/code&gt;倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在这里先说结论：以上描述是错误的。&lt;/p&gt;
&lt;p&gt;为了说明上面的规律是错误的，我写了一小段玩具代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s := make([]int, 0)

    oldCap := cap(s)

    for i := 0; i &amp;lt; 2048; i++ {
        s = append(s, i)

        newCap := cap(s)

        if newCap != oldCap {
            fmt.Printf(&quot;[%d -&amp;gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n&quot;, 0, i-1, oldCap, i, newCap)
            oldCap = newCap
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我先创建了一个空的 &lt;code&gt;slice&lt;/code&gt;，然后，在一个循环里不断往里面 &lt;code&gt;append&lt;/code&gt; 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 &lt;code&gt;slice&lt;/code&gt; 里的元素。这样，我就可以观察，新老 &lt;code&gt;slice&lt;/code&gt; 的容量变化情况，从而找出规律。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[0 -&amp;gt;   -1] cap = 0     |  after append 0     cap = 1   
[0 -&amp;gt;    0] cap = 1     |  after append 1     cap = 2   
[0 -&amp;gt;    1] cap = 2     |  after append 2     cap = 4   
[0 -&amp;gt;    3] cap = 4     |  after append 4     cap = 8   
[0 -&amp;gt;    7] cap = 8     |  after append 8     cap = 16  
[0 -&amp;gt;   15] cap = 16    |  after append 16    cap = 32  
[0 -&amp;gt;   31] cap = 32    |  after append 32    cap = 64  
[0 -&amp;gt;   63] cap = 64    |  after append 64    cap = 128 
[0 -&amp;gt;  127] cap = 128   |  after append 128   cap = 256 
[0 -&amp;gt;  255] cap = 256   |  after append 256   cap = 512 
[0 -&amp;gt;  511] cap = 512   |  after append 512   cap = 1024
[0 -&amp;gt; 1023] cap = 1024  |  after append 1024  cap = 1280
[0 -&amp;gt; 1279] cap = 1280  |  after append 1280  cap = 1696
[0 -&amp;gt; 1695] cap = 1696  |  after append 1696  cap = 2304&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在老 slice 容量小于1024的时候，新 slice 的容量的确是老 slice 的2倍。目前还算正确。&lt;/p&gt;
&lt;p&gt;但是，当老 slice 容量大于等于 &lt;code&gt;1024&lt;/code&gt; 的时候，情况就有变化了。当向 slice 中添加元素 &lt;code&gt;1280&lt;/code&gt; 的时候，老 slice 的容量为 &lt;code&gt;1280&lt;/code&gt;，之后变成了 &lt;code&gt;1696&lt;/code&gt;，两者并不是 &lt;code&gt;1.25&lt;/code&gt; 倍的关系（1696/1280=1.325）。添加完 &lt;code&gt;1696&lt;/code&gt; 后，新的容量 &lt;code&gt;2304&lt;/code&gt; 当然也不是 &lt;code&gt;1696&lt;/code&gt; 的 &lt;code&gt;1.25&lt;/code&gt; 倍。&lt;/p&gt;
&lt;p&gt;可见，现在网上各种文章中的扩容策略并不正确。我们直接搬出源码：源码面前，了无秘密。&lt;/p&gt;
&lt;p&gt;从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 &lt;code&gt;growslice&lt;/code&gt; 函数，所以我们直接看它的代码。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        if old.len &amp;lt; 1024 {
            newcap = doublecap
        } else {
            for newcap &amp;lt; cap {
                newcap += newcap / 4
            }
        }
    }
    // ……
    
    capmem = roundupsize(uintptr(newcap) * ptrSize)
    newcap = int(capmem / ptrSize)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗？如果只看前半部分，现在网上各种文章里说的 &lt;code&gt;newcap&lt;/code&gt; 的规律是对的。现实是，后半部分还对 &lt;code&gt;newcap&lt;/code&gt; 作了一个&lt;code&gt;内存对齐&lt;/code&gt;，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 &lt;code&gt;大于等于&lt;/code&gt; 老 slice 容量的 &lt;code&gt;2倍&lt;/code&gt;或者&lt;code&gt;1.25倍&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。&lt;/p&gt;
&lt;p&gt;最后，向 &lt;code&gt;growslice&lt;/code&gt; 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;append&lt;/code&gt;，我们最后来看一个例子，来源于参考资料部分的【Golang Slice的扩容规则】。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s := []int{1,2}
    s = append(s,4,5,6)
    fmt.Printf(&quot;len=%d, cap=%d&quot;,len(s),cap(s))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;len=5, cap=6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。&lt;/p&gt;
&lt;p&gt;那上面代码的运行结果就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;len=5, cap=8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        // ……
    }
    // ……
    
    capmem = roundupsize(uintptr(newcap) * ptrSize)
    newcap = int(capmem / ptrSize)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数的参数依次是 &lt;code&gt;元素的类型，老的 slice，新 slice 最小求的容量&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子中 &lt;code&gt;s&lt;/code&gt; 原来只有 2 个元素，&lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;cap&lt;/code&gt; 都为 2，&lt;code&gt;append&lt;/code&gt; 了三个元素后，长度变为 3，容量最小要变成 5，即调用 &lt;code&gt;growslice&lt;/code&gt; 函数时，传入的第三个参数应该为 5。即 &lt;code&gt;cap=5&lt;/code&gt;。而一方面，&lt;code&gt;doublecap&lt;/code&gt; 是原 &lt;code&gt;slice&lt;/code&gt;容量的 2 倍，等于 4。满足第一个 &lt;code&gt;if&lt;/code&gt; 条件，所以 &lt;code&gt;newcap&lt;/code&gt; 变成了 5。&lt;/p&gt;
&lt;p&gt;接着调用了 &lt;code&gt;roundupsize&lt;/code&gt; 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）&lt;/p&gt;
&lt;p&gt;我们再看内存对齐，搬出 &lt;code&gt;roundupsize&lt;/code&gt; 函数的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/runtime/msize.go:13
func roundupsize(size uintptr) uintptr {
    if size &amp;lt; _MaxSmallSize {
        if size &amp;lt;= smallSizeMax-8 {
            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
        } else {
            //……
        }
    }
    //……
}

const _MaxSmallSize = 32768
const smallSizeMax = 1024
const smallSizeDiv = 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，我们最终将返回这个式子的结果：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 &lt;code&gt;Go&lt;/code&gt; 源码中有关内存分配的两个 &lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;class_to_size&lt;/code&gt;通过 &lt;code&gt;spanClass&lt;/code&gt;获取 &lt;code&gt;span&lt;/code&gt;划分的 &lt;code&gt;object&lt;/code&gt;大小。而 &lt;code&gt;size_to_class8&lt;/code&gt; 表示通过 &lt;code&gt;size&lt;/code&gt; 获取它的 &lt;code&gt;spanClass&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31}

var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们传进去的 &lt;code&gt;size&lt;/code&gt; 等于 40。所以 &lt;code&gt;(size+smallSizeDiv-1)/smallSizeDiv = 5&lt;/code&gt;；获取 &lt;code&gt;size_to_class8&lt;/code&gt; 数组中索引为 &lt;code&gt;5&lt;/code&gt; 的元素为 &lt;code&gt;4&lt;/code&gt;；获取 &lt;code&gt;class_to_size&lt;/code&gt; 中索引为 &lt;code&gt;4&lt;/code&gt; 的元素为 &lt;code&gt;48&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终，新的 slice 的容量为 &lt;code&gt;6&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;newcap = int(capmem / ptrSize) // 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于，上面的两个&lt;code&gt;魔法数组&lt;/code&gt;的由来，暂时就不展开了。&lt;/p&gt;

&lt;p&gt;其实 &lt;code&gt;nil slice&lt;/code&gt; 或者 &lt;code&gt;empty slice&lt;/code&gt; 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 &lt;code&gt;mallocgc&lt;/code&gt; 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的&lt;code&gt;nil slice&lt;/code&gt; 或 &lt;code&gt;empty slice&lt;/code&gt;，然后摇身一变，成为“真正”的 &lt;code&gt;slice&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。&lt;/p&gt;
&lt;p&gt;当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。&lt;/p&gt;
&lt;p&gt;值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。&lt;/p&gt;
&lt;p&gt;通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 &lt;code&gt;s[i]=10&lt;/code&gt; 这种操作改变 slice 底层数组元素值。&lt;/p&gt;
&lt;p&gt;另外，啰嗦一句，Go 语言的函数参数传递，只有值传递，没有引用传递。后面会再写一篇相关的文章，敬请期待。&lt;/p&gt;
&lt;p&gt;再来看一个年幼无知的代码片段：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

func main() {
    s := []int{1, 1, 1}
    f(s)
    fmt.Println(s)
}

func f(s []int) {
    // i只是一个副本，不能改变s中元素的值
    /*for _, i := range s {
        i++
    }
    */

    for i := range s {
        s[i] += 1
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，程序输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[2 2 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 &lt;code&gt;f&lt;/code&gt; 函数中，&lt;code&gt;s&lt;/code&gt; 只是 &lt;code&gt;main&lt;/code&gt; 函数中 &lt;code&gt;s&lt;/code&gt; 的一个拷贝。在&lt;code&gt;f&lt;/code&gt; 函数内部，对 &lt;code&gt;s&lt;/code&gt; 的作用并不会改变外层 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要想真的改变外层 &lt;code&gt;slice&lt;/code&gt;，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func myAppend(s []int) []int {
    // 这里 s 虽然改变了，但并不会影响外层函数的 s
    s = append(s, 100)
    return s
}

func myAppendPtr(s *[]int) {
    // 会改变外层 s 本身
    *s = append(*s, 100)
    return
}

func main() {
    s := []int{1, 1, 1}
    newS := myAppend(s)

    fmt.Println(s)
    fmt.Println(newS)

    s = newS

    myAppendPtr(&amp;amp;s)
    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[1 1 1]
[1 1 1 100]
[1 1 1 100 100]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myAppend&lt;/code&gt; 函数里，虽然改变了 &lt;code&gt;s&lt;/code&gt;，但它只是一个值传递，并不会影响外层的 &lt;code&gt;s&lt;/code&gt;，因此第一行打印出来的结果仍然是 &lt;code&gt;[1 1 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;newS&lt;/code&gt; 是一个新的 &lt;code&gt;slice&lt;/code&gt;，它是基于 &lt;code&gt;s&lt;/code&gt; 得到的。因此它打印的是追加了一个 &lt;code&gt;100&lt;/code&gt; 之后的结果： &lt;code&gt;[1 1 1 100]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，将 &lt;code&gt;newS&lt;/code&gt; 赋值给了 &lt;code&gt;s&lt;/code&gt;，&lt;code&gt;s&lt;/code&gt; 这时才真正变成了一个新的slice。之后，再给 &lt;code&gt;myAppendPtr&lt;/code&gt; 函数传入一个 &lt;code&gt;s 指针&lt;/code&gt;，这回它真的被改变了：&lt;code&gt;[1 1 1 100 100]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到此，关于 &lt;code&gt;slice&lt;/code&gt; 的部分就讲完了，不知大家有没有看过瘾。我们最后来总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;切片是对底层数组的一个抽象，描述了它的一个片段。&lt;/li&gt;
&lt;li&gt;切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。&lt;/li&gt;
&lt;li&gt;多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append&lt;/code&gt; 函数会在切片容量不够的情况下，调用 &lt;code&gt;growslice&lt;/code&gt; 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。&lt;/li&gt;
&lt;li&gt;扩容策略并不是简单的扩为原切片容量的 &lt;code&gt;2&lt;/code&gt; 倍或 &lt;code&gt;1.25&lt;/code&gt; 倍，还有内存对齐的操作。扩容后的容量 &amp;gt;= 原容量的 &lt;code&gt;2&lt;/code&gt; 倍或 &lt;code&gt;1.25&lt;/code&gt; 倍。&lt;/li&gt;
&lt;li&gt;当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，如果你觉得本文对你有帮助的话，帮我点一下右下角的“推荐”吧，感谢！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【码洞《深度解析 Go 语言中「切片」的三种特殊状态》】&lt;a href=&quot;https://juejin.im/post/5bea58df6fb9a049f153bca8&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5bea58df6fb9a049f153bca8&lt;/a&gt;&lt;br/&gt;【老钱 数组】&lt;a href=&quot;https://juejin.im/post/5be53bc251882516c15af2e0&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5be53bc251882516c15af2e0&lt;/a&gt;&lt;br/&gt;【老钱 切片】&lt;a href=&quot;https://juejin.im/post/5be8e0b1f265da614d08b45a&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5be8e0b1f265da614d08b45a&lt;/a&gt;&lt;br/&gt;【golang interface源码】&lt;a href=&quot;https://i6448038.github.io/2018/10/01/Golang-interface/&quot; class=&quot;uri&quot;&gt;https://i6448038.github.io/2018/10/01/Golang-interface/&lt;/a&gt;&lt;br/&gt;【golang interface源码】&lt;a href=&quot;http://legendtkl.com/2017/07/01/golang-interface-implement/&quot; class=&quot;uri&quot;&gt;http://legendtkl.com/2017/07/01/golang-interface-implement/&lt;/a&gt;&lt;br/&gt;【interface】&lt;a href=&quot;https://www.jishuwen.com/d/2C9z#tuit&quot; class=&quot;uri&quot;&gt;https://www.jishuwen.com/d/2C9z#tuit&lt;/a&gt;&lt;br/&gt;【雨痕开源Go学习笔记】&lt;a href=&quot;https://github.com/qyuhen/book&quot; class=&quot;uri&quot;&gt;https://github.com/qyuhen/book&lt;/a&gt;&lt;br/&gt;【slice 图很漂亮】&lt;a href=&quot;https://halfrost.com/go_slice/&quot; class=&quot;uri&quot;&gt;https://halfrost.com/go_slice/&lt;/a&gt;&lt;br/&gt;【Golang Slice的扩容规则】&lt;a href=&quot;https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99&quot;&gt;https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99&lt;/a&gt;&lt;br/&gt;【slice作为参数】&lt;a href=&quot;https://www.cnblogs.com/fwdqxl/p/9317769.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fwdqxl/p/9317769.html&lt;/a&gt;&lt;br/&gt;【源码】&lt;a href=&quot;https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/&quot;&gt;https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/&lt;/a&gt;&lt;br/&gt;【append机制 译文】&lt;a href=&quot;https://brantou.github.io/2017/05/24/go-array-slice-string/&quot; class=&quot;uri&quot;&gt;https://brantou.github.io/2017/05/24/go-array-slice-string/&lt;/a&gt;&lt;br/&gt;【slice 汇编】&lt;a href=&quot;http://xargin.com/go-slice/&quot; class=&quot;uri&quot;&gt;http://xargin.com/go-slice/&lt;/a&gt;&lt;br/&gt;【slice tricks】&lt;a href=&quot;https://colobu.com/2017/03/22/Slice-Tricks/&quot; class=&quot;uri&quot;&gt;https://colobu.com/2017/03/22/Slice-Tricks/&lt;/a&gt;&lt;br/&gt;【有图】&lt;a href=&quot;https://i6448038.github.io/2018/08/11/array-and-slice-principle/&quot; class=&quot;uri&quot;&gt;https://i6448038.github.io/2018/08/11/array-and-slice-principle/&lt;/a&gt;&lt;br/&gt;【slice的本质】&lt;a href=&quot;https://www.flysnow.org/2018/12/21/golang-sliceheader.html&quot; class=&quot;uri&quot;&gt;https://www.flysnow.org/2018/12/21/golang-sliceheader.html&lt;/a&gt;&lt;br/&gt;【slice使用技巧】&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;br/&gt;【slice/array、内存增长】&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:23:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>slice 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它，这是一个新的世界。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10631989.html</dc:identifier>
</item>
<item>
<title>基于async/non-blocking高性能redis组件库BeetleX.Redis - smark</title>
<link>http://www.cnblogs.com/smark/p/10639573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10639573.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;code&gt;BeetleX.Redis&lt;/code&gt;是基于&lt;code&gt;async/non-blocking&lt;/code&gt;模式实现的高性能&lt;code&gt;redis&lt;/code&gt;组件库，组件支持redis基础指令集，并封装更简便的&lt;code&gt;List&lt;/code&gt;,&lt;code&gt;Hashset&lt;/code&gt;和&lt;code&gt;Subscribe&lt;/code&gt;操作。除了在基础操作功能上，组件还提供多服务备份方式和多连接池机制，从而让组件提供高可用和高性能的访问方案;在数据格式上组件默认集成了&lt;code&gt;json&lt;/code&gt;和&lt;code&gt;protobuf&lt;/code&gt;可以根据自己的需求来选择相应的存储格式。接下来大概看一下组件的性能和应用功能。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;性能&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;针对Order结构进行一个&lt;code&gt;GET/SET&lt;/code&gt;性能测试，分别测试&lt;code&gt;BeetleX&lt;/code&gt;和&lt;code&gt;StackExchange&lt;/code&gt;在这两个操作下不同线程的压测，由于在8以上线程数测试&lt;code&gt;StackExchange&lt;/code&gt;经常抛timeout错误....，所以只测了1,2和4线程情况。详细测试代码:&lt;a href=&quot;https://github.com/IKende/BeetleX.Redis/tree/master/PerformanceTest&quot;&gt;https://github.com/IKende/BeetleX.Redis/tree/master/PerformanceTest&lt;/a&gt;（代码里集成了一个轻巧的性能测试功能类，用起来非常方便，只需要简单编写测试用例就可以列表出测试时间和并发等相关数据，以下测试结果列表由这个测试类输出。）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;10255&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CustomerID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RICSU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EmployeeID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-07-12T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequiredDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-08-09T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShippedDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-07-15T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipVia&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Freight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;148.33&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Richter Supermarkt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starenweg 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipCity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Genève&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipPostalCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1204&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipCountry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Switzerland&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.Set(item.OrderID.ToString(), item);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;await&lt;/span&gt; RedisDB.Get&amp;lt;Order&amp;gt;(i.ToString());
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;StackExchange&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.StringSetAsync(item.OrderID.ToString(), Newtonsoft.Json.JsonConvert.SerializeObject(item));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.StringGetAsync(i.ToString());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; item = Newtonsoft.Json.JsonConvert.DeserializeObject&amp;lt;Northwind.Data.Order&amp;gt;(data);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;测试结果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-------------------------------------------------------------------------------
|Name                          | Round| Threads|     Count| Use time(s)|   Sec|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;5.22&lt;/span&gt;| &lt;span&gt;19157&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;6.97&lt;/span&gt;| &lt;span&gt;14357&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;6.62&lt;/span&gt;| &lt;span&gt;15103&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;5.41&lt;/span&gt;| &lt;span&gt;18487&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.48&lt;/span&gt;| &lt;span&gt;13378&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.09&lt;/span&gt;| &lt;span&gt;14105&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.03&lt;/span&gt;| &lt;span&gt;14216&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;8.69&lt;/span&gt;| &lt;span&gt;11504&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;8.36&lt;/span&gt;| &lt;span&gt;11963&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.55&lt;/span&gt;| &lt;span&gt;39246&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.97&lt;/span&gt;| &lt;span&gt;25199&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.56&lt;/span&gt;| &lt;span&gt;28069&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.78&lt;/span&gt;| &lt;span&gt;35946&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|         &lt;span&gt;4.1&lt;/span&gt;| &lt;span&gt;24364&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.72&lt;/span&gt;| &lt;span&gt;26907&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.59&lt;/span&gt;| &lt;span&gt;27871&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;4.75&lt;/span&gt;| &lt;span&gt;21035&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;4.55&lt;/span&gt;| &lt;span&gt;21976&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.04&lt;/span&gt;| &lt;span&gt;48956&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.37&lt;/span&gt;| &lt;span&gt;42220&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.15&lt;/span&gt;| &lt;span&gt;46541&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.14&lt;/span&gt;| &lt;span&gt;46822&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.58&lt;/span&gt;| &lt;span&gt;38789&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.24&lt;/span&gt;| &lt;span&gt;44619&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.49&lt;/span&gt;| &lt;span&gt;40238&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.06&lt;/span&gt;| &lt;span&gt;32708&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.76&lt;/span&gt;| &lt;span&gt;36264&lt;/span&gt;|
-------------------------------------------------------------------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;组件使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;组件默认就支持数据对象操作，而数据存储的格式则由相应创建的DB数据类型决定，所以在使用和处理数据上都比较方便。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisDB();
DB.AddWriteHost(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.2.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set password&lt;/span&gt;
DB.AddWriteHost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.2.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;json-&quot;&gt;Json 数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt; RedisDB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; JsonFormater());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;protobuf-&quot;&gt;Protobuf 数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt; RedisDB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ProtobufFormater());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;基础操作&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; DB.Decr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Decrby(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Dump(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Exists(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Expire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Expireat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1293840000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetBit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetRange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, -&lt;span&gt;3&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mycounter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Incrby(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.IncrbyFloat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0.1f&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Keys(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t??&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MGet&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MGet&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MSet(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MSetNX(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;there&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Move(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.PSetEX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Persist(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Pexpire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Pexpireat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1555555555005&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; DB.Ping();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.PTtl(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; DB.Randomkey();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Rename(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Renamenx(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;henryfan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetBit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetEX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetNX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetRange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Type(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;列表操作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建列表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; list = DB.CreateList&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;列表操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.BLPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.BRPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.BRPopLPush(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Index(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Insert(&lt;span&gt;true&lt;/span&gt;, GetEmployee(&lt;span&gt;2&lt;/span&gt;), GetEmployee(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.Len();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.Pop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Push(GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Push(GetEmployee(&lt;span&gt;1&lt;/span&gt;), GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; myotherlist.PushX(GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Rem(-&lt;span&gt;2&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Set(-&lt;span&gt;2&lt;/span&gt;, GetEmployee(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Trim(&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.RPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPopLPush(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherlist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPush(GetEmployee(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPush(GetEmployee(&lt;span&gt;1&lt;/span&gt;), GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPushX(GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Range(-&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;hashtable-&quot;&gt;HashTable结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; table = DB.CreateHashTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myhash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相关操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; table.Del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Exists(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; table.Keys();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; table.Len();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee, Order&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee, Order, Customer&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.MSet(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;)][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetCustomer(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.SetNX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;订阅&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建订阅&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; sub =&lt;span&gt; db.Subscribe();
            sub.Register&lt;/span&gt;&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            sub.Receive &lt;/span&gt;= (o, e) =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now}]{e.Channel}-{e.Type}:{e.Data}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
            sub.Listen();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过&lt;code&gt;Retister&lt;/code&gt;方法注册订阅频道，在注册的时候必须指定数据类型，对象反序列化的格式依据库数据的格式类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; DB.Publish(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(i));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是发布消息到频道&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以上是&lt;code&gt;BeetleX.Redis&lt;/code&gt;现有版本的功能，集群功能暂没有实现；但提供主备功能可以根据自己的需要添加多个WriteHost或ReadHost，默认连接池机制随意应对高并发应用；组件希望打造一个高性能简便的Redis .net core组件,但要发挥组件的性能特色就要适应完全基于await的方法进行组件操作。 项目开源地址：&lt;a href=&quot;https://github.com/IKende/BeetleX.Redis&quot;&gt;https://github.com/IKende/BeetleX.Redis&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:09:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>BeetleX.Redis是基于async/non-blocking模式实现的高性能redis组件库，组件支持redis基础指令集，并封装更简便的List,Hashset和Subscribe操作。除了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/10639573.html</dc:identifier>
</item>
<item>
<title>消息中间件RabbitMQ(一) - MicroHeart！</title>
<link>http://www.cnblogs.com/MicroHeart/p/10635611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MicroHeart/p/10635611.html</guid>
<description>&lt;h2&gt;1、消息中间件&lt;/h2&gt;
&lt;p&gt;　　消息队列中间件是指利用高效可靠地消息传递机制传递消息。有两种传递模式：点对点模式、发布/订阅模式。流行的消息中间件有RabblitMQ、Kafka、RockerMQ。它们都提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的消息中间件通信。&lt;/p&gt;
&lt;h2&gt;2、组成部分&lt;/h2&gt;
&lt;p&gt;　　RabbitMQ的整体模型架构如图。RabbitMQ的组成由 生产者、交换器、绑定、队列、消费者组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401132546731-1153934974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.1 连接&lt;/h3&gt;
&lt;p&gt;　　生产者和消费者都需要和RabbitMQ Broker建立连接，连接是TCP连接。一旦TCP连接建立起来，客户端紧接着创建一个AMQP信道(Channel)。信道是建立在TCP Connection之上的虚拟连接，RabbitMQ处理每条AMQP指令都是通过信道完成的。因为建立和销毁TCP连接开销大，所以选择TCP连接复用，减少开销。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401145906405-137287053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.1 生产者和消费者&lt;/h3&gt;
&lt;p&gt;　　生产者：创造消息，发布到RabbitMQ中。消息包含两个部分：标签和消息体。标签是为了描述这条消息，生产者把消息交由RabbitMQ之后会根据标签把消息发送给感兴趣的消费者。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，&lt;/p&gt;
&lt;p&gt;　　消费者：接受消息。消费者连接到RabbitMQ 服务器，并订阅到队列上。消费者只能得到消息体，也就不知道消息的生产者是谁。&lt;/p&gt;
&lt;h3&gt;2.2 绑定和路由键&lt;/h3&gt;
&lt;p&gt;　　路由键：生产者将消息发送给交换器的时候，指定RoutingKey.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401143842850-128846212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　绑定键：通过绑定键将交换器和队列联系起来。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401143417786-1973514535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 交换器&lt;/h3&gt;
&lt;p&gt;　　生产者将消息发送到交换器，由交换器将消息路由到一个或多个对列中。如果路由不到，直接丢弃消息或者返回给生产者。&lt;span&gt;队列是生产者和消费者传递消息的一个中介，所有消息都必须通过交换器将消息放入队列中，不能直接将消息放到队列中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　交换器类型：　　&lt;/p&gt;
&lt;p&gt;Fanout：会将所有发送到交换器的消息路由到所有与改交换器绑定的队列中。这种情况BingKey和RoutingKey相当于不起作用。&lt;/p&gt;
&lt;p&gt;Direct：会把消息路由到BindingKey和RoutingKey完全匹配的队列中。如下图 消息只会进入队列一中。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401150936979-1488620642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Topic：会按照一定规则将BindingKey和RoutingKey相匹配的队列中。BindingKey可以存在两种特殊字符串&quot;*&quot;和&quot;#&quot;。“#”号用于匹配一个单词，“*”匹配多个单词。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401151935686-2093328583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Headers：Headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。&lt;/p&gt;
&lt;p&gt;路由键、交换器类型、绑定键三者共同决定了消息进入哪些队列中。&lt;/p&gt;
&lt;h3&gt;2.4 队列　　&lt;/h3&gt;
&lt;p&gt;用于存储消息。RabbitMQ中消息只能存储在队列后中。&lt;span&gt;多个消费者可以订阅同一个队列，队列中的消息会被平均分摊给多个消费者。RabbitMQ 不支持队列层面的广播消费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;附上一张完整的结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401180726782-2144189515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、消息确认&lt;/h2&gt;
&lt;p&gt;　　在生产者发送消息到消费者消费消息的流程中，有两个地方需要消费确认：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生产者要确认发出的消息到达RabbitMQ。&lt;/li&gt;
&lt;li&gt;消息从队列到达消费者的过程。队列要确认发出的消息被消费者消费，才会将消息从队列中删除。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/794803/201904/794803-20190401165011049-1872316650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了保证，生产者的消息到达RabbitMQ，可以通过事务机制和发送方确认机制实现。&lt;/p&gt;
&lt;h4&gt;　　事务实现：&lt;/h4&gt;
&lt;p&gt;　　　　Channel.TxSelect 将当前信道设置成事务模式&lt;/p&gt;
&lt;p&gt;　　　　Channel.TxCommit 提交事务&lt;/p&gt;
&lt;p&gt;　　　　Channel.TxRollback 事务回滚&lt;/p&gt;
&lt;h4&gt;　　发送方确认机制：&lt;/h4&gt;
&lt;p&gt;　　　生产者将信道设置成confirm(确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从l开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认(Basic.Ack) 给生产者(包含消息的唯一ID) ，这就使得生产者知晓消息已经正确到达了目的地了(如上图的流程1)。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。&lt;/p&gt;
&lt;p&gt;　　　生产者调用channel.ConfirmSelect将信道设置为confirm模式，事务机制和Publisher confirm机制确保的是消息能够正确地发送至RabbitMQ，这里的“发送至RabbitMQ”的含义指消息被正确地发送到交换器。&lt;/p&gt;
&lt;p&gt;　　　事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下， 发送方确认机制最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息。&lt;/p&gt;

&lt;p&gt;为了保证队列中发出的消息被消费者消费，RabbitMQ提供了消息确认机制。&lt;/p&gt;
&lt;p&gt;　　消费者订阅队列时，可以指定autoAck参数，autoAck等于false，RabbitMQ会等待消费者显示地回复确认信号才能从队列后中删除(如上图的流程2)。autoAck等于true,会在消息发送去后删除，不管消费者是否真正消费到这条消息。当autoAck 参数置为false ，对于RabbitMQ 服务端而言，队列中的消息分成了两个部分:一部分是等待投递给消费者的消息、一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。&lt;/p&gt;
&lt;p&gt;　　如果RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;span&gt;　　4.1 创建连接&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory
 {
       UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;118.21.96.213&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 };
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection();&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; channel = connection.CreateModel();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4.2 声明交换器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ExchangeDeclare(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; type, &lt;span&gt;bool&lt;/span&gt; durable, &lt;span&gt;bool&lt;/span&gt; autoDelete, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments);
&lt;span&gt;//声明交换器后，不需要等待交换器返回。但如果服务器未完成创建，而客户端使用了这个交换器，会发生异常。
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ExchangeDeclareNoWait(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; type, &lt;span&gt;bool&lt;/span&gt; durable, &lt;span&gt;bool&lt;/span&gt; autoDelete, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;exchange：交换器名称&lt;/li&gt;
&lt;li&gt;type：交换器的类型&lt;/li&gt;
&lt;li&gt;durable：是否持久化&lt;/li&gt;
&lt;li&gt;autoDelete：是否自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定， 之后所有与这个交换器绑定的队列或者交换器都与此解绑&lt;/li&gt;
&lt;li&gt;internal：设置是否内置。如果为true,客户端无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式&lt;/li&gt;
&lt;li&gt;arguments：参数设置。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　   4.3 删除交换器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ExchangeDelete(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ifUnused);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ExchangeDeleteNoWait(&lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;bool&lt;/span&gt; ifUnused);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ifUnused：为true，表示没有被使用的情况下才会被删除。设置为false，无论如何都要被删除&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　4.4 声明队列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;QueueDeclareOk&lt;/span&gt; QueueDeclare(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;bool&lt;/span&gt; durable, &lt;span&gt;bool&lt;/span&gt; exclusive, &lt;span&gt;bool&lt;/span&gt; autoDelete, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; QueueDeclareNoWait(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;bool&lt;/span&gt; durable, &lt;span&gt;bool&lt;/span&gt; exclusive, &lt;span&gt;bool&lt;/span&gt; autoDelete, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Queue：队列名称&lt;/li&gt;
&lt;li&gt;Durable：是否持久化。持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。&lt;/li&gt;
&lt;li&gt;Exclusive：设置是否排他。&lt;/li&gt;
&lt;li&gt;AutoDelete：设置是否自动删除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如果队列为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。排他队列是基于连接(Connection)可见的，同一个连接的不同信道(Channel)是可以同事访问同一连接创建的排他队列。  “首次”是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的。即使该队列是持久化的，一旦连接关闭或者客户端退出，改排他队列都会被自动删除。&lt;/p&gt;
&lt;p&gt;　　自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。&lt;/p&gt;
&lt;h3&gt;　　4.5 删除队列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//返回队列删除期间清除的消息数&lt;/span&gt;&lt;br/&gt;uint&lt;/span&gt; QueueDelete(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;bool&lt;/span&gt; ifUnused, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ifEmpty);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; QueueDeleteNoWait(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;bool&lt;/span&gt; ifUnused, &lt;span&gt;bool&lt;/span&gt; ifEmpty);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ifUnused：为true，表示没有被使用的情况下才会被删除。设置为false，无论如何都要被删除&lt;/li&gt;
&lt;li&gt;ifEmpty：为true，表示在队列为空(队列里面没有任何消息堆积)的情况下才能够删除。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　4.6 队列绑定&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; QueueBind(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; routingKey, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; QueueBindNoWait(&lt;span&gt;string&lt;/span&gt; queue, &lt;span&gt;string&lt;/span&gt; exchange, &lt;span&gt;string&lt;/span&gt; routingKey, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4.7 交换器绑定/解除绑定&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre readability=&quot;17&quot;&gt;
&lt;span&gt;void&lt;/span&gt; ExchangeBind(&lt;span&gt;string&lt;/span&gt; destination, &lt;span&gt;string&lt;/span&gt; source, &lt;span&gt;string&lt;/span&gt; routingKey, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ExchangeBindNoWait(&lt;span&gt;string&lt;/span&gt; destination, &lt;span&gt;string&lt;/span&gt; source, &lt;span&gt;string&lt;/span&gt; routingKey, IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments);&lt;p&gt;void ExchangeUnbind(string destination, string source, string routingKey, IDictionary&amp;lt;string, object&amp;gt; arguments);&lt;/p&gt;&lt;p&gt;void ExchangeUnbindNoWait(string destination, string source, string routingKey, IDictionary&amp;lt;string, object&amp;gt; arguments);
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;destination：交换器名称&lt;/li&gt;
&lt;li&gt;source：交换器名称 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;消息从source交换器发送到destination交换器中。&lt;/p&gt;
&lt;h3&gt;　　4.8 发送消息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
void BasicPublish(string exchange, string routingKey, bool mandatory, IBasicProperties basicProperties, byte[] body);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;exchange：消息发送到的交换器&lt;/li&gt;
&lt;li&gt;routingKey：路由键&lt;/li&gt;
&lt;li&gt;mandatory：当为true时，交换机无法根据自身类型和路由键找到符合条件的队列，消息会返回给生产者。当为false时，消息直接丢弃。&lt;/li&gt;
&lt;li&gt;basicProperties：其他参数设置&lt;/li&gt;
&lt;li&gt;body：消息字节数组&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 01 Apr 2019 13:50:00 +0000</pubDate>
<dc:creator>MicroHeart！</dc:creator>
<og:description>1、消息中间件 消息队列中间件是指利用高效可靠地消息传递机制传递消息。有两种传递模式：点对点模式、发布/订阅模式。流行的消息中间件有RabblitMQ、Kafka、RockerMQ。它们都提供了基于存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MicroHeart/p/10635611.html</dc:identifier>
</item>
<item>
<title>微信授权登录mock（在没有真实微信账号的情况下测试大量微信账户授权登录的情况） - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/10608877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/10608877.html</guid>
<description>&lt;h2&gt;场景介绍&lt;/h2&gt;
&lt;p&gt;对于构建在微信公众号的系统，帐号体系往往使用微信授权登录（如各类微信商城应用系统）。&lt;/p&gt;
&lt;p&gt;这样操作不仅可以实现静默注册，对用户几乎是无感的，同时也达到了区分用户，获取用户基本信息（头像，昵称等）。&lt;/p&gt;
&lt;p&gt;使用微信授权的模式可以说一次性替代用户注册及用户登录。&lt;/p&gt;


&lt;p&gt;因为这种帐号体系是以微信帐号为主体的，平时我们如果要对该类系统进行测试，就必须使用到真实的微信帐号完成登录或注册。&lt;/p&gt;
&lt;p&gt;如果想要对登录或注册曾经进行性能方面的测试那会比较棘手（因为我们可能没有足够的微信号）&lt;/p&gt;


&lt;p&gt;以下图为例我们先分析这个注册/登录流程&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170127318-912914262.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如图上面的1，2，3步都是在微信APP里完成的（与我们作为测试对象的应用服务器未产生联系）&lt;/p&gt;
&lt;p&gt;直到第4步骤微信浏览器才向我们的应用服务器发送了请求（该请求负责将前面步骤得到的code传递到我们自己的业务服务，该请求才是我们自己业务服务器开始验证登录的开始）&lt;/p&gt;
&lt;p&gt;一般我们的服务器得到code后，会在向微信服务请求用户信息，拿到用户信息后处理自己的业务逻辑（注册或是登录）&lt;/p&gt;
&lt;p&gt;所以能看出来，登录或测试的关键就是第4步这个接口。&lt;/p&gt;
&lt;p&gt;我们在进行性能测试时，设计的登录或注册逻辑（事务）主要就在于第4步请求测试数据的准备。&lt;/p&gt;
&lt;p&gt;因为我们应用服务从第4步拿到code后会用此code向微信查询用户信息，即这个code是微信即时生成的，我们是不可能提前拿到一批能用的code用来测试的。&lt;/p&gt;
&lt;p&gt;现在如果为了测试可以选择修改服务逻辑让其接收虚拟code，对虚拟code进行特殊处理完成虚拟的注册。但是这样为了测试来改变远工程的逻辑是十分不可取的，测试的对象应尽量与实际用户使用到的维持一致，而且这里的场景就是为了测试注册或登录的性能，为了测试而故意改了一份针对测试的注册或登录的逻辑显然不合适。&lt;/p&gt;

&lt;p&gt;我们进一步分析业务服务的逻辑，业务服务器会拿获得的code向微信换取用户信息&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170138529-2072550915.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170149118-1990757832.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;如上图业务服务器使用code向微信服务器换来了openid 及 access_token等关键信息 （第一幅图是微信接口说明，第二副图是应用服务器向微信请求的一个实例）&lt;/p&gt;
&lt;p&gt;这时其实拿到openid即可以确定用户是新用户还是老用户，如果新用户可以进行新建用户的操作，如果是老用户则可以进行用户登录的逻辑。&lt;/p&gt;
&lt;p&gt;当然现实中应用服务可能还会使用access_token去向微信拉取用户头像，昵称等信息（https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;amp;openid=OPENID&amp;amp;lang=zh_CN），这取决于大家产品自己的业务。&lt;/p&gt;

&lt;p&gt;如上所述不难发现，如果使用错误的code，微信服务一定会返回错误，导致注册或登录业务中断。现在我们要克服的就是，如何让错误的code也能有正常的返回。接口是微信的，微信显然不会做这种事情。那我们在不更改业务服务的任何逻辑的同时能不能在我们应用服务器的网络层面上mock微信的这个接口，让不被微信承认的code也能返回正常的数据。&lt;/p&gt;

&lt;div readability=&quot;7.6329113924051&quot;&gt;答案是可以的，上面这个需求是可以通过FreeHttp来完成对。借助FreeHttp可以截获使用code换openid及access_token的请求，然后返回我们自己构建的测试数据给业务服务使用。（FreeHttp 的说明及安装可以看这里 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html&lt;/a&gt;）&lt;/div&gt;

&lt;p&gt;下面以一个实际微信登录场景为例说明如何使用FreeHttp完成微信认证&lt;/p&gt;

&lt;h2&gt;1：配置代理（Fiddler）&lt;/h2&gt;
&lt;p&gt;为了完成需求，我们首先要为业务服务器配置HTTP代理到我们的Fiddler上。&lt;/p&gt;
&lt;p&gt;一般我们的服务器都是Linux，这里我们以CentOS，应用容器Tomcat 为例说明代理配置过程&lt;/p&gt;
&lt;p&gt;配置机器全局代理很容易&lt;/p&gt;
&lt;p&gt;修改 /etc/profile 文件&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170209373-214761365.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;添加上面的信息即可&lt;/p&gt;
&lt;p&gt;不过JVM可能不会使用系统HTTP代理，所以我们需要单独配置Tomcat的代理 &lt;/p&gt;
&lt;p&gt;通过设置jvm的proxyhost来实现设置tomcat中引用程序的代理&lt;/p&gt;
&lt;p&gt;在tomcat的配置文件catalina.bat/sh中设置-Dhttp.proxySet=true -Dhttp.proxyHost=proxyserver -Dhttp.proxyPort=8888&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170221951-1244879403.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;配置示例如上图在以上位置加上指定参数即可（不同应用容器或服务框架都有自己的代理设置方式，大家可以在网络上搜索到）&lt;/p&gt;
&lt;p&gt;添加配置信息后重启tomcat即可（记得服务器与代理服务所在网络上必须是能连通的）&lt;/p&gt;
&lt;p&gt;还有一步添加fiddler证书到服务器（为了能解析HTTPS请求）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170301324-6615409.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图在我们自己的电脑中导出证书&lt;/p&gt;

&lt;p&gt;在服务器上进行如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装 ca-certificates 包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;yum install ca-certificates&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启用 dynamic CA configuration&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;update-ca-trust enable&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加证书到指定目录 （fiddler证书）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cp FiddlerRoot.cer /etc/pki/ca-trust/source/anchors/&lt;/p&gt;
&lt;p&gt;update-ca-trust extract&lt;/p&gt;


&lt;p&gt;以上步骤完成后可以测试一下Fiddler是否能获取服务器发送的请求&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170315860-791943205.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;触发服务器向外发送请求，我们在Fiddler上应该能捕获相应请求（上图就是一个我们应用服务器发送给微信的https请求）&lt;/p&gt;

&lt;h2&gt;2:配置FreeHttp&lt;/h2&gt;

&lt;p&gt;按照我们前面的分析，实际应用服务器是需要向微信发送code（https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;amp;secret=SECRET&amp;amp;code=CODE&amp;amp;grant_type=authorization_code）&lt;/p&gt;
&lt;p&gt;应用服务器需要根据返回数据再进处理一步业务逻辑&lt;/p&gt;
&lt;p&gt;那我们现在直接篡改这条请求返回值，让他对不合法code的请求也返回正常的返回数据&lt;/p&gt;

&lt;p&gt;先添加一个参数化数据（用于使每次返回数据都不一样）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170327415-1341823861.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图，我们添加一个逐步递增的openid参数数据（按图标注1，2，3步骤添加即可，注意红框部分选择参数类型及参数的格式）&lt;/p&gt;
&lt;p&gt;这个参数表示以0001开始每次取值逐步递增(在类表处选取该参数，可以重置或设置该参数的值)&lt;/p&gt;

&lt;p&gt;再添加一个用于产生合规响应的Response Replace规则 &lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170339018-1387954169.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图添加一个Response Replace规则&lt;/p&gt;
&lt;p&gt;因为是替换响应不需要将真实发送到微信的服务器这里勾选Response Direct（同时为了模拟真实场景加上50ms的延时，反复测试微信的这条接口响应时间都控制在50ms到100ms）&lt;/p&gt;
&lt;p&gt;在图最大编辑框中设置相应数据（正确响应数据应该是什么格式，抓取一个正常的请求就可以得到），同时我们为返回json里openid添加一个参数数化数据（实际就是TestOpenId加上一个递增的ID，这个递增ID就是前面设置的参数化数据，这里为了方便演示，仅对openid进行说明，实际其他几个返回项也是有意义的）&lt;/p&gt;
&lt;p&gt;红线处*#test_openid(+)*#即表示前面添加的用户参数（因为使用到用户参数，需要鼠标右键在弹出框中把use Parameter Data 勾上）&lt;/p&gt;
&lt;p&gt;设置完成后，点击右下角绿色确认按钮添加规则&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170349751-18193265.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;完成以上设置后，后注意在右侧Response Rule列表处，设置启用Response Rule,及勾选需要执行的规则（上图红框区域）&lt;/p&gt;

&lt;h2&gt;3：测试规则&lt;/h2&gt;
&lt;p&gt;前面最开始我们也分析过https://业务域名及路径?code=061v6AGK1pOTj40nF0EK1LNwGK1v6AGV&amp;amp;state=辅助参数 (文中第一张图的第4步，这个地址也是在前面第2步的回调地址中设置的)&lt;/p&gt;
&lt;p&gt;我们使用Fiddler的Composer构造这个请求（当然您可以通过其他测试工具甚至是浏览器构建请求进行调试）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170359404-349332617.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;p&gt;如上图我们主要关注的code（我们这里自己构造code，实际这个code不是一个真实的code）&lt;/p&gt;

&lt;p&gt;点击Execute发送测试请求&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170407228-257896364.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170423061-2074727872.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图，可以看到服务器发给微信的请求已经被我们替换掉了，而且返回我们设置的“合法数据”。（我们我应用服务器这个时候会认为是openid为TestOpenId0001的用户来登录或注册了，然后会进入相应的业务）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170431006-1037291458.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过数据库验证用户是否成功创建成功（当然正常情况下按不同业务需求，注册一个用户还有许多数据需要验证）&lt;/p&gt;

&lt;h4&gt;4：开始登录测试&lt;/h4&gt;
&lt;p&gt;对登录业务进行压力测试，同样可以使用很多工具，我这里使用常用的JMeter进行演示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201904/209007-20190401104519943-33935756.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我们使用先使用JMeter依次发送https://业务域名及路径?code=TestOpenId0001&amp;amp;state= （使code逐步递增，这里递增是为了防止应用服务有缓存策略）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170438549-1169201128.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;注意JMeter默认不使用系统代理，所以需要如上图手动配置代理&lt;/p&gt;

&lt;div readability=&quot;8&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170448101-2124639321.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 这里使用100个用户同时登录（持续时间30秒，当然实际测试中有更加复杂的业务，持续时间跟用户数也会更多）&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170459698-1398001671.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过对数据库的检查，我们基本上可以确认30秒里这10个用户创建了311个账户（而实际上我们并没有使用311个微信号）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170514599-419425118.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;简单的测试我们应用服已经表现出性能瓶颈（平均响应达到了8秒）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170527673-2111345487.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/209007/201903/209007-20190327170538268-528467738.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 同时添加服务器监控，可以查看测试中服务器的压力情况（上图表面测试中应用线程数量明显增多，JVM的GC也加快了，可以反复尝试增加压力观察是否存在瓶颈）&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;最后我们就可以根据自己的业务，添加更多的业务场景进行有针对性的测试。&lt;/p&gt;

&lt;p&gt;上面只是一个例子，演示如何通过截获服务器与微信认证服务器的请求，以达到测试自己业务微信认证登录的过程。&lt;/p&gt;
&lt;p&gt;大家可以利用这个思路，结合自己的需求，进行有针对性的测试。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 12:56:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>场景介绍 对于构建在微信公众号的系统，帐号体系往往使用微信授权登录（如各类微信商城应用系统）。 这样操作不仅可以实现静默注册，对用户几乎是无感的，同时也达到了区分用户，获取用户基本信息（头像，昵称等）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lulianqi/p/10608877.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】Android安全之（一）权限篇 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10638446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10638446.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;从Android6.0开始，Android系统对权限的处理产生了很大的变化。如果APP运行的设备系统版本为Android6.0或更高，并且target在23或更高，那么dangerious级别的权限将由之前的安装时授予变成运行时动态申请。这样一来，当运用到系统权限相关的功能时，就需要手动处理好权限申请的用户交互问题。本文将结合官网中的介绍，来全方位了解权限相关知识点，并介绍一些实际工作中可能用到的技巧。&lt;/p&gt;
&lt;p&gt;       本文的主要内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401192952411-1166545841.png&quot; alt=&quot;&quot; width=&quot;705&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、为什么要引入“权限”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      Android系统引入权限的目的是为了保护Android用户的隐私。Android安全架构设计中一个明确点，默认情况下App是没有权限对其他App、操作系统和用户进行有害的操作。这些有害操作包括读写用户的隐私数据（如通讯录、电子邮件等）、读写其它App的文件、调起硬件设备（如蓝牙、Wifi、相机等），访问网络等。App如果想要进行这些操作，就需要申请相应的权限，如下网址提供了Android系统定义的所有权限【&lt;a href=&quot;https://developer.android.google.cn/reference/android/Manifest.permission&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/reference/android/Manifest.permission&lt;/a&gt;】，均以常量的形式供开发者使用，开发者可以通过Manifest.permission.X的方式调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、Android权限与官网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       官网（中文版：&lt;a href=&quot;https://developer.android.google.cn&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn&lt;/a&gt;）中对Andrid权限有非常全面的描述和使用指导，依次通过 首页 》 文档 》 指南，可以看到如下界面，和权限相关的知识点主要都在这里。咱们先了解一下里面都有些什么内容吧！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190330125343708-428571567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    1、Overview&lt;/p&gt;
&lt;p&gt;      宏观上介绍了权限相关联的知识点，整体内容如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190330125230562-31167846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （1）Permission approval&lt;/p&gt;
&lt;p&gt;       该部分主要从用户交互角度介绍了当前原声机上申请权限的交互形式。比如对话框显示怎样的内容等。&lt;/p&gt;
&lt;p&gt;    （2）Permissions for optional hardware feature&lt;/p&gt;
&lt;p&gt;       这部分主要讲手机硬件特征和与之相关的权限问题。比如手机没有相机时，是否允许安装需要申请相机权限的app等。&lt;/p&gt;
&lt;p&gt;    （3）Permission enforcement&lt;/p&gt;
&lt;p&gt;       这部分主要讲Permission在四大组件中的其它用法。Permission不仅仅只能用于请求系统功能，还可以通过自定义权限，来限制谁有权限启动/调用或访问指定的组件/数据等。Activity、Service、Broadcast Receiver和Content Provider这四大组件可以结合Permission这方面的功能，来防止被任意访问或修改。&lt;/p&gt;
&lt;p&gt;    （4）Automatic permission adjustments&lt;/p&gt;
&lt;p&gt;       这部分主要讲权限与版本前后兼容的问题。比如在高版本中才定义的新权限，在低版本中如何表现的问题等。&lt;/p&gt;
&lt;p&gt;    （5）Protection levels  &lt;/p&gt;
&lt;p&gt;       App不同的操作，所可能产生的风险也是不一样的。比如获取当前的网络状态，最多也只会让App探测到周围的网络情况，而读写用户的通讯录则不同，用户的信息则有被篡改和道窃的风险。所以，根据可能产生的风险程度，系统将“权限”分为了不同的保护等级。对于第三方app而言，有三个等级，严重程度有轻到重依次为：普通权限（Normal Permission）、签名权限（Signature Permission）和危险权限（Dangerous Permission）。&lt;/p&gt;
&lt;p&gt;      1）普通权限&lt;/p&gt;
&lt;p&gt;       普通权限的覆盖区域为，app需要访问“沙盒”以外的数据以及资源的权限，这些对用户隐私和对其它app的操作产生的风险微乎其微。比如，修改系统时区、获取网络状态等。这部分还列出了一些常用的普通权限.&lt;/p&gt;
&lt;p&gt;      2）签名权限&lt;/p&gt;
&lt;p&gt;       系统会在安装app的时候授予该类权限，但是只有当这个试图使用这个权限的app和定义这个权限的app被相同的证书签名的时候，才能生效。有些签名权限就不用于第三方app的。该部分还列出了一些常见的可以供第三方app使用的签名权限。&lt;/p&gt;
&lt;p&gt;      3）危险权限&lt;/p&gt;
&lt;p&gt;       危险权限覆盖了如下情形，当用户需要的数据和资源涉及到用户隐私信息，或者可能影响到用户的存储数据或其它app的操作，比如读取用户的联系人的能力就是一个危险权限。该部分还列出了一些常见的危险权限。&lt;/p&gt;
&lt;p&gt;      4）特殊权限&lt;/p&gt;
&lt;p&gt;       除了上述的3中主要的权限分类外，还有两个特殊的权限：SYSTEM_ALART_WINDOW和WRITE_SETTINGS。至于其特殊性，咱们在后面的章节单独来介绍。&lt;/p&gt;
&lt;p&gt;    （6）Permission groups&lt;/p&gt;
&lt;p&gt;       该部分介绍了权限组相关的知识点。&lt;/p&gt;
&lt;p&gt;    （7）View an app`s permissions&lt;/p&gt;
&lt;p&gt;       该部分介绍了两个adb命令 ，一个用于查看app的权限申请情况，另外一个用于给app授予所有的权限。&lt;/p&gt;
&lt;p&gt;    （8）Additional resources&lt;/p&gt;
&lt;p&gt;       提供了一些链接，用于了解更多关于Android权限相关的知识。&lt;/p&gt;
&lt;p&gt;  2、Request app permission&lt;/p&gt;
&lt;p&gt;       这篇文章主要讲解如何在代码中实现权限检查，权限请求，以及如何处理拒绝/同样授权后的代码逻辑。这里面提供了Android API中的接口，具体的代码示例等。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190330155919856-2006721448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、App permissions best practices&lt;/p&gt;
&lt;p&gt;       这边文章主要是从用于体验的角度来指导开发者，如何设计交互，如何做好测试，以及需要注意的原则等。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190330160238220-1103438597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  4、Define custom permissions &lt;/p&gt;
&lt;p&gt;       这篇文章主要指导开发者如何自定义权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190330160539320-1562582483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、特殊权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;上一节中简单提到了特殊权限，其实就是两个权限：SYSTEM_ALART_WINDOW和WRITE_SETTINGS。Android6.0开始，除了危险权限需要动态申请外，这两个特殊权限也是一样需要动态申请。他们尤其敏感，行为也和其他的权限不一样，所以对于大多数app来说一般不应该使用它们。如果app需要其中一个权限，必须在manifest文件中申明，并发送一个intent请求用户授权。系统会显示一个详细的管理界面给用户，让用户决定是否来授权。如下截图是以“微信”为例，在设置中可以看到如下界面，“高级”模块中显示的两项，就是设置这两项权限的入口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401173119304-387845617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  1、WRITE_SETTINGS&lt;/p&gt;
&lt;p&gt;       在Android6.0及以后，该权限的保护等级已经由原来的dangerious升级为signature，这意味着我们的APP需要用系统签名或者成为系统预装软件才能够申请该权限，并且还需要提示用户跳转到修改系统的设置界面去授予此权限。这就意味着，要想申请该权限，apk必须要签名而且打包，debug模式将无法申请该权限。&lt;/p&gt;
&lt;p&gt;    （1）官网描述&lt;/p&gt;
&lt;p&gt;       官网【&lt;a href=&quot;https://developer.android.google.cn/reference/android/Manifest.permission.html#WRITE_SETTINGS&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/reference/android/Manifest.permission.html#WRITE_SETTINGS&lt;/a&gt;】对该权限的描述如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401172704035-2024496458.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）权限设置界面&lt;/p&gt;
&lt;p&gt;       点击“高级”中的“修改系统设置”项，可以进入到该权限的授予界面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401173550781-1546628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （3）权限申请使用示例&lt;/p&gt;
&lt;p&gt;       在第四节中将会讲解危险权限检测和申请的具体实例，但是WRITE_SETTINGS权限不能通过这种方式来处理。如果使用checkPermissions()检测该权限，无论你是否已经授权，它都会返回false。如下展示了具体处理该权限的实例：&lt;/p&gt;
&lt;p&gt;        首先，在AndroidManifest.xml文件中申请该权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.WRITE_SETTINGS&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       然后，根据官网中的描述，先通过API中的canWrite()方法判断是否允许修改，再通过指定的action跳转到设置界面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 申请权限
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; requestWriteSettings()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;=&lt;span&gt; Build.VERSION_CODES.M)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;大于等于23 请求权限&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;Settings.System.canWrite(getApplicationContext()))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Intent intent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 intent.setData(Uri.parse(&quot;package:&quot; +&lt;span&gt; getPackageName()));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                startActivityForResult(intent, REQUEST_CODE_WRITE_SETTINGS );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小于23直接设置&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       最后，根据回调方法和requestCode来处理授权/拒绝逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode, Intent data)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityResult(requestCode, resultCode, data);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestCode ==&lt;span&gt; REQUEST_CODE_WRITE_SETTINGS)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;=&lt;span&gt; Build.VERSION_CODES.M)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Settings.System.canWrite方法检测授权结果&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Settings.System.canWrite(getApplicationContext()))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取了权限&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拒绝了权限&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  2、SYSTEM_ALART_WINDOW&lt;/p&gt;
&lt;p&gt;    （1）官网描述&lt;/p&gt;
&lt;p&gt;       官网【&lt;a href=&quot;https://developer.android.google.cn/reference/android/Manifest.permission.html#SYSTEM_ALERT_WINDOW&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/reference/android/Manifest.permission.html#SYSTEM_ALERT_WINDOW&lt;/a&gt;】的描述如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401182656148-1150274141.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （2）权限设置界面&lt;/p&gt;
&lt;p&gt;       点击“高级”中的“显示在其它应用的上层”项，可以进入到该权限的授予界面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401182903766-298722753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    （3）权限申请示例&lt;/p&gt;
&lt;p&gt;       该权限的申请和WRITE_SETTINGS类似，咱们这里参照前面，就不给出全部代码，仅提供一些关键函数：&lt;/p&gt;
&lt;p&gt;       在清单文件中声明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       结合官网中的说明，使用系统提供的API来判断和跳转授权设置界面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否已经授予权限&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!Settings.canDrawOverlays(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若未授权则请求权限&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前往设置界面授予权限&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getOverlayPermission() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Intent intent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     intent.setData(Uri.parse(&quot;package:&quot; +&lt;span&gt; getPackageName()));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     startActivityForResult(intent, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode, Intent data){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据requestCode来处理授权/拒绝逻辑。&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       从官网上的说明可以看到，这两个特殊权限的权限级别都是“signature”，可见这两个权限并不是独立的权限级别。   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、动态申请权限示例代码记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;如下代码是笔者平时工作当中经常使用的一个实例，方便实用，无需再引入第三方jar包。数组变量permissionRequest中定义了一个相机权限作为实例，读者可以根据需要拓展为多个。一般来说，申请权限是在进入app时第一个Activity中，或者在需要用到该权限的地方进行，所以checkAndRequestPermissions()一般在第一个Activity的onCreate()方法中调用，或者在需要使用该权限的地方调用。其他地方代码逻辑比较简单，就不赘述了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String[] permissionRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            Manifest.permission.CAMERA
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isNeedRequestPermission = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; REQUEST_PERMISSION = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkAndRequestPermissions() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;=&lt;span&gt; Build.VERSION_CODES.M) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String permissionStr : permissionRequest) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ActivityCompat.checkSelfPermission(&lt;span&gt;this&lt;/span&gt;, permissionStr) !=&lt;span&gt; PackageManager.PERMISSION_GRANTED) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     isNeedRequestPermission = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     isNeedRequestPermission = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isNeedRequestPermission) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                requestPermissions(permissionRequest, REQUEST_PERMISSION);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do what you want&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;......
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onRequestPermissionsResult(&lt;span&gt;int&lt;/span&gt; requestCode, @NonNull String[] permissions, @NonNull &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] grantResults) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onRequestPermissionsResult(requestCode, permissions, grantResults);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; grantResults.length; index++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (PackageManager.PERMISSION_DENIED ==&lt;span&gt; grantResults[index]) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                finish();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do what you want&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;五、一种在Service中申请权限的方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Android中申请权限的函数requestPermissions()和回调函数onRequestPermissionsResult()都是Acitivity.java中提供的，所以在Activity或Fragment中很容易调用这两方法来处理权限问题。但是在Service中就不容易处理了，因为Service中Android API没有提供类似的接口。而且Android中有不少应用是通过IPC方式，用Service向其它APP提供功能，没有Activity或Fragment，这样就无法直接请求权限了。这里介绍一种采用间接的方式处理权限的方案：需要申请权限时，跳转到一个透明的Activity中来完成权限的申请。&lt;/p&gt;
&lt;p&gt;       PermissionDemoActivity直接继承自Activity，在清单文件中如下设置theme，这样就成了一个透明的Activity。在onRusume()方法中调用finish()方法，否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activity
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;       &lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;.PermissionDemoActivity&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;      android:theme&lt;/span&gt;&lt;span&gt;=&quot;@android:style/Theme.NoDisplay&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       结合上一节中的代码示例，在PermissionDemoActivity的onCreate()方法中申请权限，这样就间接地通过一个透明的Acitivity来实现权限的申请了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、常用的与Permission相关的adb命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      android工具adb提供了一些命令，可以方便查看、授权、取消应用的权限，可以为调试程序带来不少的方便，下面简单介绍几个常见的命令。&lt;/p&gt;
&lt;p&gt;  1、查看指定app中权限申请情况&lt;/p&gt;
&lt;p&gt;       命令：adb shell dumpsys package [包名]&lt;/p&gt;
&lt;p&gt;       用途：该命令用于获取该app的package信息，Permission信息只是其中的一部分。&lt;/p&gt;
&lt;p&gt;       命令使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; adb shell dumpsys &lt;span&gt;package&lt;/span&gt; cn.aaa.bbb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       如下下截图为该命令中关于权限的部分信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190329100458806-1781758923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       该图显示了4部分权限：&lt;/p&gt;
&lt;p&gt;    （1）declared permissions。该应用自己声明（即自定义）的权限，这里显示了权限名，权限等级，以及在什么时候获取该权限（INSTALLED 表示安装的时候就会授予该权限）。&lt;/p&gt;
&lt;p&gt;    （2）requested permissions。这里列出的是AndroidManifest.xml文件中所有request的权限，可以看出这里面包含了动态申请的权限和安装时申请的权限。&lt;br/&gt;    （3）install permissions：安装的时候就赋予的权限。可以和requested permissions对比一下，这里面少了一&quot;android.permission.CAMERA&quot;权限，该权限为动态申请权限。该列表中还展示了权限对应的授予情况，如granted所示，true表示已经被授予了权限。&lt;/p&gt;
&lt;p&gt;    （4）runtime permissions。这里显示的是运行时才需要申请的权限，即dangerous permission。&lt;/p&gt;
&lt;p&gt;  2、查看权限的声明者和使用者&lt;/p&gt;
&lt;p&gt;       命令：adb shell dumpsys package permission &amp;lt;权限名&amp;gt;&lt;/p&gt;
&lt;p&gt;       用途：该命令可以查看指定权限是谁声明的，有哪些应用申请了该权限。&lt;/p&gt;
&lt;p&gt;      命令使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; adb shell dumpsys &lt;span&gt;package&lt;/span&gt; permission cn.aaa.bbb.TEST_PERMISSION
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下节选了该权限的定义信息和其中一个使用该权限的应用的关键信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Permissions:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  Permission [cn.aaa.bbb.TEST_PERMISSION] (d4d8316):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     sourcePackage=&lt;span&gt;cn.aaa.bbb
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     uid=10078 gids=&lt;span&gt;null&lt;/span&gt; type=0 prot=signature|&lt;span&gt;privileged
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     perm=&lt;span&gt;Permission{f5b497 cn.aaa.bbb.TEST_PERMISSION}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     packageSetting=PackageSetting{96e1684 cn.aaa.bbb/10078&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Packages:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  Package [cn.xxx.xxx] (5d0f51b):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    declared permissions:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    requested permissions:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    install permissions:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       cn.aaa.bbb.TEST_PERMISSION: granted=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; ......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   3、移除指定权限&lt;/p&gt;
&lt;p&gt;      命令：adb shell pm revoke [packageName] [permissionName]&lt;/p&gt;
&lt;p&gt;      用途：移除packageName应用的permissionName权限（可以同时移除多项权限）。&lt;/p&gt;
&lt;p&gt;      命令使用示例（如下为删除包名为cn.aaa.bbb 的相机权限）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; adb shell pm revoke cn.aaa.bbb android.permission.CAMERA
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完该命令后，用前文提到的命令“adb shell dumpsys package cn.aaa.bbb”查看该权限的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190329095910204-1012599802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过实验发现，该命令对runtime permissions有效，却对install permissions无效，如以下异常信息所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201903/472002-20190329100249064-112650602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  4、授予指定权限&lt;/p&gt;
&lt;p&gt;       命令：adb shell pm grant [packageName] [permissionName]&lt;/p&gt;
&lt;p&gt;       用途：为packageName应用授予permissionName权限（可以同时授予多项权限）。该命令和上一条移除命令相对应。&lt;/p&gt;
&lt;p&gt;       参照上一条命令的实例，实验结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401105535859-446687529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  5、查看系统定义的所有权限&lt;/p&gt;
&lt;p&gt;       命令：adb shell pm list permissions -s[option] 不加-s会显系统中定义的所有权限名列表，加了-s会显示对这些权限的用途说明。&lt;/p&gt;
&lt;p&gt;      参考：【&lt;a href=&quot;https://developer.android.google.cn/guide/topics/permissions/overview#viewing&quot; target=&quot;_blank&quot;&gt;Viewing an app's permissions：https://developer.android.google.cn/guide/topics/permissions/overview#viewing&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       下面截图分别展示了命令不加-s和加了-s后的显示结果（重定向到文本中查看），其中不加-s的截图中，一共显示了571条权限，这里截取了一部分，其中可以看到不少自定义的权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401110431929-1669867895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401105941242-1324815855.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  6、按组查看权限&lt;/p&gt;
&lt;p&gt;       命令：adb shell pm list permissions -d -g&lt;/p&gt;
&lt;p&gt;       用途：查看权限的分组情况。这部分是上面一条命令的补充，参数可以根据自己的需要选择。&lt;/p&gt;
&lt;p&gt;       参考：【&lt;a href=&quot;https://developer.android.google.cn/training/permissions/usage-notes#testing&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/training/permissions/usage-notes#testing&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;       下列截图为结果的一部分。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201904/472002-20190401110740044-521065987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  7、授予所有权限&lt;/p&gt;
&lt;p&gt;       命令：adb shell install -g MyApp.apk&lt;/p&gt;
&lt;p&gt;       用途：当安装MyApp.apk到模拟器或测试机上时，如果加上-g，可以自动授予所有权限。这一点笔者没有实验过，读者可以自行测试。&lt;/p&gt;
&lt;p&gt;       参考：该处和第4点一样参考官网说明。&lt;/p&gt;

&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://blog.csdn.net/u013553529/article/details/53167072&quot; target=&quot;_blank&quot;&gt;Android权限的一些细节https://blog.csdn.net/u013553529/article/details/53167072&lt;/a&gt;】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Anroid权限知识点其实没有太多需要理解的逻辑问题，一般都是一些需要记住的知识点。本文的一些实际操作技巧，很多都是笔者工作中用到的，具有较强的实践参考作用。由于笔者的经验和水平有限，如果有描述不妥当或不准确的地方，请不吝赐教，谢谢！&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 11:43:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>从Android6.0开始，Android系统对权限的处理产生了很大的变化。如果APP运行的设备系统版本为Android6.0或更高，并且target在23或更高，那么dangerious级别的权限将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10638446.html</dc:identifier>
</item>
<item>
<title>谈谈 TCP 的 TIME_WAIT - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/10637964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/10637964.html</guid>
<description>&lt;h2 id=&quot;由来&quot;&gt;由来&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;最近有同事在用 ab 进行服务压测，到 QPS 瓶颈后怀疑是起压机的问题，来跟我借测试机，于是我就趁机分析了一波起压机可能成为压测瓶颈的可能，除了网络 I/O、机器性能外，还考虑到了网络协议的问题。&lt;/p&gt;
&lt;p&gt;当然本文的主角并不是压测，后来分析证明同事果然还是想多了，瓶颈是在服务端。&lt;/p&gt;
&lt;p&gt;分析起压机瓶颈的过程中，对于 TCP TIME_WAIT 状态的一个猜想引起了我的兴趣。由于之前排查问题时，简单地接触过这个状态，但并未深入了解，于是决定抽时间分析一下，拆解一下我的猜想。&lt;/p&gt;
&lt;p&gt;转载随意，文章会持续修订，请注明来源地址：&lt;a href=&quot;https://zhenbianshu.github.io/&quot;&gt;https://zhenbianshu.github.io&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;tcp-的状态转换&quot;&gt;TCP 的状态转换&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;我们都知道 TCP 的三次握手，四次挥手，说来简单，但在不稳定的物理网络中，每一个动作都有可能失败，为了保证数据被有效传输，TCP 的具体实现中也加入了很多对这些异常状况的处理。&lt;/p&gt;
&lt;h4 id=&quot;状态分析&quot;&gt;状态分析&lt;/h4&gt;
&lt;p&gt;先用一张图来回想一下 TCP 的状态转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/tcp_state.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一眼看上去，这么多种状态，各个方向的连线，让人感觉有点懵。但细细分析下来，还是有理可循的。&lt;/p&gt;
&lt;p&gt;首先，整个图可以被划分为三个部分，即上半部分建连过程，左下部分主动关闭连接过程和右下部分被动关闭连接过程。&lt;/p&gt;
&lt;p&gt;再来看各个部分：建连过程就是我们熟悉的三次握手，只是这张图上多了一个服务端会存在的 LISTEN 状态；而主动关闭连接和被动关闭连接，都是四次挥手的过程。&lt;/p&gt;
&lt;h4 id=&quot;查看连接状态&quot;&gt;查看连接状态&lt;/h4&gt;
&lt;p&gt;在 Linux 上，我们常用 &lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt; 来查看网络连接的状态。当然我们还可以使用更快捷高效的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ss&lt;/code&gt; (Socket Statistics) 来替代 netstat。&lt;/p&gt;
&lt;p&gt;这两个工具都会列出此时机器上的 socket 连接的状态，通过简单的统计就可以分析出此时服务器的网络状态。&lt;/p&gt;
&lt;h2 id=&quot;time_wait&quot;&gt;TIME_WAIT&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;我们从上面的图中可以看出来，当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态。而且我们在机器上 curl 一个 url 创建一个 TCP 连接后，使用 ss 等工具可以在一定时长内持续观察到这个连续处于 TIME_WAIT 状态。&lt;/p&gt;
&lt;p&gt;所以TIME_WAIT 是这么一种状态：TCP 四次握手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接在一段时间内不可用。&lt;/p&gt;
&lt;p&gt;那么，保持这么一个状态有什么用呢？&lt;/p&gt;
&lt;h4 id=&quot;原因&quot;&gt;原因&lt;/h4&gt;
&lt;p&gt;上文中提到过，对于复杂的网络状态，TCP 的实现提出了多种应对措施，TIME_WAIT 状态的提出就是为了应对其中一种异常状况。&lt;/p&gt;
&lt;p&gt;为了理解 TIME_WAIT 状态的必要性，我们先来假设没有这么一种状态会导致的问题。暂以 A、B 来代指 TCP 连接的两端，A 为主动关闭的一端。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;四次挥手中，A 发 FIN， B 响应 ACK，B 再发 FIN，A 响应 ACK 实现连接的关闭。而如果 A 响应的 ACK 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 FIN 包。&lt;/p&gt;
&lt;p&gt;如果没有 TIME_WAIT 状态，A 不再保存这个连接的信息，收到一个不存在的连接的包，A 会响应 RST 包，导致 B 端异常响应。&lt;/p&gt;
&lt;p&gt;此时， TIME_WAIT 是为了保证全双工的 TCP 连接正常终止。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;我们还知道，TCP 下的 IP 层协议是无法保证包传输的先后顺序的。如果双方挥手之后，一个网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 B 接收，A 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 B，那么这个数据包就会让 B 以为是 A 刚发过来的。&lt;/p&gt;
&lt;p&gt;此时， TIME_WAIT 的存在是为了保证网络中迷失的数据包正常过期。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由以上两个原因，TIME_WAIT 状态的存在是非常有意义的。&lt;/p&gt;
&lt;h4 id=&quot;时长的确定&quot;&gt;时长的确定&lt;/h4&gt;
&lt;p&gt;由原因来推实现，TIME_WAIT 状态的保持时长也就可以理解了。确定 TIME_WAIT 的时长主要考虑上文的第二种情况，保证关闭连接后这个连接在网络中的所有数据包都过期。&lt;/p&gt;
&lt;p&gt;说到过期时间，不得不提另一个概念: 最大分段寿命（MSL, Maximum Segment Lifetime），它表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃。&lt;/p&gt;
&lt;p&gt;TIME_WAIT 状态由主动关闭的 A 来保持，那么我们来考虑对于 A 来说，可能接到上一个连接的数据包的最大时长：A 刚发出的数据包，能保持 MSL 时长的寿命，它到了 B 端后，B 端由于关闭连接了，会响应 RST 包，这个 RST 包最长也会在 MSL 时长后到达 A，那么 A 端只要保持 TIME_WAIT 到达 2MS 就能保证网络中这个连接的包都会消失。&lt;/p&gt;
&lt;p&gt;MSL 的时长被 RFC 定义为 2分钟，但在不同的 unix 实现上，这个值不并确定，我们常用的 centOS 上，它被定义为 30s，我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/net/ipv4/tcp_fin_timeout&lt;/code&gt; 这个文件查看和修改这个值。&lt;/p&gt;
&lt;h2 id=&quot;ab-的奇怪表现&quot;&gt;ab 的”奇怪”表现&lt;/h2&gt;
&lt;hr/&gt;&lt;h4 id=&quot;猜想&quot;&gt;猜想&lt;/h4&gt;
&lt;p&gt;由上文，我们知道由于 TIME_WAIT 的存在，每个连接被主动关闭后，这个连接就要保留 2MSL（60s） 时长，一个网络四元组也要被冻结 60s。而我们机器默认可被分配的端口号约有 30000 个（可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt;文件查看）。&lt;/p&gt;
&lt;p&gt;那么如果我们使用 curl 对服务器请求时，作为客户端，都要使用本机的一个端口号，所有的端口号分配到 60s 内，每秒就要控制在 500 QPS，再多了，系统就无法再分配端口号了。&lt;/p&gt;
&lt;p&gt;可是在使用 ab 进行压测时时，以每秒 4000 的 QPS 运行几分钟，起压机照样正常工作，使用 ss 查看连接详情时，发现一个 TIME_WAIT 状态的连接都没有。&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;
&lt;p&gt;一开始我以为是 ab 使用了连接复用等技术，仔细查看了 ss 的输出发现本地端口号一直在变，到底是怎么回事呢？&lt;/p&gt;
&lt;p&gt;于是，我在一台测试机启动了一个简单的服务，端口号 8090，然后在另一台机器上起压，并同时用 tcpdump 抓包。&lt;/p&gt;
&lt;p&gt;结果发现，第一个 FIN 包都是由服务器发送的，即 ab 不会主动关闭连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhenbianshu.github.io/images/2018/time_wait_tcpdump.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登上服务器一看，果然，有大量的 TIME_WAIT 状态的连接。&lt;/p&gt;
&lt;p&gt;但是由于服务器监听的端口会复用，这些 TIME_WAIT 状态的连接并不会对服务器造成太大影响，只是会占用一些系统资源。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;当然，高并发情况下，太多的 TIME_WAIT 也会给服务器造成很大的压力，毕竟维护这么多 socket 也是要消耗资源的，关于如何解决 TIME_WAIT 过多的问题，可以看 &lt;a href=&quot;https://blog.csdn.net/yunhua_lee/article/details/8146830&quot;&gt;tcp短连接TIME_WAIT问题解决方法大全（1）——高屋建瓴&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;多了解原理遇到问题才能更快地找到根源解决，网络相关的知识还要继续巩固啊。&lt;/p&gt;
&lt;p&gt;关于本文有什么疑问可以在下面留言交流，如果您觉得本文对您有帮助，欢迎关注我的 &lt;a href=&quot;https://weibo.com/u/5715965217&quot;&gt;微博&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/zhenbianshu/&quot;&gt;GitHub&lt;/a&gt; 。您也可以在我的 &lt;a href=&quot;https://github.com/zhenbianshu/zhenbianshu.github.io&quot;&gt;博客REPO&lt;/a&gt; 右上角点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;Watch&lt;/code&gt; 并选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;Releases only&lt;/code&gt; 项来 &lt;code class=&quot;highlighter-rouge&quot;&gt;订阅&lt;/code&gt; 我的博客，有新文章发布会第一时间通知您。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 10:07:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<og:description>由来 最近有同事在用 ab 进行服务压测，到 QPS 瓶颈后怀疑是起压机的问题，来跟我借测试机，于是我就趁机分析了一波起压机可能成为压测瓶颈的可能，除了网络 I/O、机器性能外，还考虑到了网络协议的问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/10637964.html</dc:identifier>
</item>
</channel>
</rss>