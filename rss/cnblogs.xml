<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>智能英文单词提取翻译工具 - devgis</title>
<link>http://www.cnblogs.com/devgis/p/10191008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/devgis/p/10191008.html</guid>
<description>&lt;ul&gt;&lt;li&gt;这个工具用于分析文本文件中所有的英语单词&lt;/li&gt;
&lt;li&gt;并且通过内置字典数据库工具对这些单词进行解析&lt;/li&gt;
&lt;li&gt;可以生成表格形式 并且支持导出到excel文件中&lt;/li&gt;
&lt;li&gt;用于学习单词&lt;/li&gt;
&lt;li&gt;本代码禁止商业用途 如需要商业用途请联系我&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编译报错 请直接使用nuget还原包在线下载所有引用包 包括npoi 和 sqlite库。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/devgis/WordsTool&quot; href=&quot;https://github.com/devgis/WordsTool&quot; target=&quot;_blank&quot;&gt;https://github.com/devgis/WordsTool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家提出宝贵意见。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 07:48:00 +0000</pubDate>
<dc:creator>devgis</dc:creator>
<og:description>这个工具用于分析文本文件中所有的英语单词 并且通过内置字典数据库工具对这些单词进行解析 可以生成表格形式 并且支持导出到excel文件中 用于学习单词</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/devgis/p/10191008.html</dc:identifier>
</item>
<item>
<title>dotnet core开源博客系统XBlog介绍 - smark</title>
<link>http://www.cnblogs.com/smark/p/10190998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10190998.html</guid>
<description>&lt;p&gt;XBlog是&lt;code&gt;dotnet core&lt;/code&gt;平台下的个人博客开源系统，它只需要通过Copy的方式即可以部署到Linux和windows系统中；如果你有安全证书那只需要简单配置一下即可提供安全的&lt;code&gt;Https&lt;/code&gt;服务。接下来主要介绍XBlog功能、部署和基础设置。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;技术要点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基于&lt;code&gt;dotnet core&lt;/code&gt;平台，可以运行在windows和linux系统上&lt;/li&gt;
&lt;li&gt;完全基于&lt;a href=&quot;https://github.com/IKende/FastHttpApi&quot;&gt;&lt;code&gt;BeetleX.FastHttpAp&lt;/code&gt;&lt;/a&gt;框架开发&lt;/li&gt;
&lt;li&gt;前后端分离，完全脱离后端视图引擎；基于vuejs和webapi模式&lt;/li&gt;
&lt;li&gt;混合HTTP和Websocket，当浏览器兼容Websocket的情况下请求会使用Websocket.&lt;/li&gt;
&lt;li&gt;基于javascript前端Markdown,降低文章在服务端解释的损耗&lt;/li&gt;
&lt;li&gt;支持HTTPS满足安全访问的需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　项目地址:&lt;a href=&quot;https://github.com/IKende/XBlog&quot;&gt;https://github.com/IKende/XBlog&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;XBlog提供了博客的基础功能主要包括：文章管理，分类管理，评论管理，文件管理，系统资源监控和文章搜索功能.&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;首页预览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AkHMDam.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;后台预览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/K9MAypS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;设置&lt;/h3&gt;
&lt;p&gt;主要配置博客信息如&lt;code&gt;Title&lt;/code&gt;,&lt;code&gt;ElasticSearch服务地址&lt;/code&gt;,&lt;code&gt;关于&lt;/code&gt;,&lt;code&gt;JWT KEY&lt;/code&gt;和&lt;code&gt;设置用户密码&lt;/code&gt;等。 &lt;img src=&quot;https://i.imgur.com/1k4vgV8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;XBlog部署非常简单，把编译好的文件复制运行即可。&lt;/p&gt;
&lt;p&gt;下载编译好的文件包：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IKende/XBlog/blob/master/Publish/XBlog.zip&quot;&gt;https://github.com/IKende/XBlog/blob/master/Publish/XBlog.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;获取源代码:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IKende/XBlog&quot;&gt;https://github.com/IKende/XBlog&lt;/a&gt;自己编译&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;运行环境要求&lt;/h4&gt;
&lt;p&gt;提供.net core 2.1或更高版本的linux、windows系统。把编译好的代码复制到相关目录下运行以下命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet BeetleX.Blog.dll
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;-elasticsearch&quot;&gt;配置ElasticSearch&lt;/h4&gt;
&lt;p&gt;由于XBlog的数据分类检索都是使用ElasticSearch的功能，安装ElasticSearch可以查看以下文章，需要安装中文分词插件IK&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ikende.com/blog/87.html&quot;&gt;https://www.ikende.com/blog/87.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成后只需要在系统管理后台设置一下即可，默认是指向&lt;code&gt;http://localhost:9200&lt;/code&gt;根据地址配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hOEIdoL.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统检测到ElasticSearch可用的情况，边框为绿色；如果检测错误会红色并有相关错误信息。检测成功后可以通过测试分词按钮来测试一下分词效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VSCsBR9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;安全配置&lt;/h4&gt;
&lt;p&gt;系统默认用户名&lt;code&gt;admin&lt;/code&gt;,密码&lt;code&gt;123456&lt;/code&gt;建议运行后修改密码，还有&lt;code&gt;JWT Key&lt;/code&gt;也得新创建一个新的，确保Key和其他运行环境不一致。&lt;/p&gt;
&lt;h4 id=&quot;-https&quot;&gt;配置访问端口和Https&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;BeetleX.FastHttpAp&lt;/code&gt;是支持https功能，所以只需要在&lt;code&gt;HttpConif.json&lt;/code&gt;设置三项内容即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CertificateFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c:\\ikende.com.pfx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CertificatePassword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;端口默认是&lt;code&gt;8080&lt;/code&gt;如果需要80需要自行修改，开启&lt;code&gt;https&lt;/code&gt;分别是开启SSL,设置证书文件和对应的密码(linux和windows设置方式一样)默认端口是443。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;如果使用或扩展中存在问题可以提交到 &lt;a href=&quot;https://github.com/IKende/XBlog/issues&quot;&gt;https://github.com/IKende/XBlog/issues&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 07:47:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>XBlog是dotnet core平台下的个人博客开源系统，它只需要通过Copy的方式即可以部署到Linux和windows系统中；如果你有安全证书那只需要简单配置一下即可提供安全的Https服务。接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/10190998.html</dc:identifier>
</item>
<item>
<title>jvm详情——4、分代垃圾回收详述 - 低调人生</title>
<link>http://www.cnblogs.com/lemon-flm/p/10191000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lemon-flm/p/10191000.html</guid>
<description>&lt;p&gt;虚拟机中的共划分为三个代：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;年轻代（Young Generation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;年老点（Old Generation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;持久代（Permanent Generation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182892/201812/1182892-20181228135442836-130152693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、年轻代:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。&lt;span&gt;&lt;strong&gt;年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。&lt;/strong&gt;&lt;/span&gt;大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、年老代:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、持久代:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&amp;lt;N&amp;gt;进行设置。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么情况下触发垃圾回收&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：&lt;span&gt;&lt;strong&gt;Scavenge GC和Full GC&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Scavenge GC&lt;/span&gt;&lt;br/&gt;一般情况下，当新对象生成，并且&lt;strong&gt;在Eden申请空间失败时，就会触发Scavenge GC&lt;/strong&gt;，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代因为大部分对象都是从Eden区开始的，&lt;strong&gt;同时Eden区不会分配的很大，所以Eden区的GC会频繁进行&lt;/strong&gt;。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;Full GC&lt;/span&gt;&lt;br/&gt;对&lt;strong&gt;整个堆进行整理，包括Young、Tenured和Perm&lt;/strong&gt;。Full GC因为需要对整个对进行回收，所以比ScavengeGC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。&lt;br/&gt;有如下原因可能导致Full GC：&lt;br/&gt;&lt;strong&gt;· 年老代（Tenured）被写满&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;· 持久代（Perm）被写满&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;· System.gc()被显示调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182892/201812/1182892-20181228154710978-238236604.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 07:47:00 +0000</pubDate>
<dc:creator>低调人生</dc:creator>
<og:description>虚拟机中的共划分为三个代： 年轻代（Young Generation） 年老点（Old Generation） 持久代（Permanent Generation） 其中持久代主要存放的是Java类的类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lemon-flm/p/10191000.html</dc:identifier>
</item>
<item>
<title>003.Docker容器管理 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10190608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10190608.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 docer运行应用&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1 常见容器运行&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker                              #查看docker相关命令
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker run -d -p 80:80 httpd         #从docker hub下载httpd镜像，启动httpd容器，并将容器的80端口映射到宿主机的80端口
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker run centos:7 echo &quot;hello world&quot;
&lt;span&gt;  4&lt;/span&gt; hello world
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker ps                   #查看运行的容器情况
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;参数说明:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;CONTAINER ID:容器ID&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;NAMES:自动分配的容器名称&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker logs 634cf027ad85    #查看容器内的标准输出
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker stop 634cf027ad85 #停止容器
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker ps                        #再次查看
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如ubuntu仓库源里，有15.10、14.04等多个不同的版本，我们使用 REPOSTITORY:TAG 来定义不同的镜像。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;若运行docker时不指定tag，则默认使用latest镜像。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2 交互式运行容器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -i -t centos:7 /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;各个参数解析：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;-t:在新容器内指定一个伪终端或终端。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-i:允许你对容器内的标准输入 (STDIN) 进行交互。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二 运行Web应用及其他操作&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 容器后端运行&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker pull training/webapp
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker run -d -P training/webapp python app.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参数说明:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;-d:让容器在后台运行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-P:将容器内部使用的网络端口映射到我们使用的主机上。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker ps
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145849213-172514931.png&quot;&gt;&lt;img title=&quot;08_thumb2&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145849499-1901138139.png&quot; alt=&quot;08_thumb2&quot; width=&quot;1475&quot; height=&quot;74&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可知此docker开放了5000端口映射到主机端口32768上。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145849722-1542046235.png&quot;&gt;&lt;img title=&quot;09_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145849949-53827168.png&quot; alt=&quot;09_thumb1&quot; width=&quot;747&quot; height=&quot;216&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试访问。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145850141-802233018.png&quot;&gt;&lt;img title=&quot;10_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145850427-50150447.png&quot; alt=&quot;10_thumb1&quot; width=&quot;355&quot; height=&quot;93&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.2 指定端口运行容器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d -p 8080:5000 training/webapp python app.py                  #使用-p参数来绑定指定端口。
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker run -d -p 9090:5000/tcp --name web training/webapp python app.py   #使用--name标记可以为容器命名
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker ps
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145850713-414015164.png&quot;&gt;&lt;img title=&quot;11_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145851016-1920651415.png&quot; alt=&quot;11_thumb1&quot; width=&quot;1488&quot; height=&quot;111&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：容器的名称是唯一的，若命名了一个叫web的容器，当再次使用web这个名称时，需要用docker rm删除之前创建的容器，也可以再执行docker run的时候加—rm标记来停止旧的容器，并删除，rm和-d参数是不兼容的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试新绑定的端口。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145851231-1972992641.png&quot;&gt;&lt;img title=&quot;12_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145851428-1451132870.png&quot; alt=&quot;12_thumb1&quot; width=&quot;270&quot; height=&quot;93&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker port 25cbcff93d56
&lt;span&gt;  2&lt;/span&gt; 5000/tcp -&amp;gt; 0.0.0.0:8080
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker port 95b731acd6b5
&lt;span&gt;  4&lt;/span&gt; 5000/tcp -&amp;gt; 0.0.0.0:32768
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145851637-341268928.png&quot;&gt;&lt;img title=&quot;13_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145851851-899538104.png&quot; alt=&quot;13_thumb1&quot; width=&quot;399&quot; height=&quot;72&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.3 进入容器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker exec -it 5e7ad2db2304 /bin/bash
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker exec -it web /bin/bash
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;2.4 容器其他操作&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker logs -f 95b731acd6b5         #查看运行日志
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker inspect web                       #查看Docker容器的配置和状态信息
&lt;span&gt;  3&lt;/span&gt; root@docker:~# docker restart 5e7ad2db2304              #重启docker
&lt;span&gt;  4&lt;/span&gt; root@docker:~# docker stop 95b731acd6b5         #停止docker
&lt;span&gt;  5&lt;/span&gt; root@docker:~# docker kill 25cbcff93d56         #停止docker
&lt;span&gt;  6&lt;/span&gt; root@docker:~# docker ps -a                             #查看所有容器情况
&lt;span&gt;  7&lt;/span&gt; root@docker:~# docker start 95b731acd6b5                #运行已停止的docker
&lt;span&gt;  8&lt;/span&gt; root@docker:~# docker rm 95b731acd6b5           #删除该docker
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：删除容器时，容器必须是停止状态，查看容器详细信息可输入前部分ID，如docker inspect 6b52。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker pause 5e7ad2db2304           #暂停容器
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker unpause 5e7ad2db2304              #恢复容器
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt;三 容器生命周期管理&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 容器生命周期&lt;/h3&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145852153-645285430.png&quot;&gt;&lt;img title=&quot;14_thumb1&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181228145852574-325546064.png&quot; alt=&quot;14_thumb1&quot; width=&quot;1082&quot; height=&quot;466&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;四 docker资源限制&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;用户内存限制就是对容器能使用的内存和交换分区的大小作出限制。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1 资源限制意义&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;主机运行若干容器，每个容器都需要cpu、内存以及IO资源，为避免因为单个容器占用过多资源而影响到所有其他容器乃至整个宿主机的性能，需要对容器资源进行限制。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;五 docker内存限制&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;5.1 内存限制&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Docker 提供的内存限制功能有以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;容器能使用的内存和交换分区大小。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;容器的核心内存大小。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;容器虚拟内存的交换行为。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;容器内存的软性限制。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;是否杀死占用过多内存的容器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;容器被杀死的优先级。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般情况下，达到内存限制的容器过段时间后就会被系统杀死。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.2 内存限制相关参数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;执行docker run命令时能使用的和内存限制相关的所有选项如下。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;164&quot;/&gt;&lt;col width=&quot;403&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9597-1534429540690-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;选项&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9597-1534429540690-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;-m,--memory&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-1-1&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;内存限制，格式是数字加单位，单位可以为 b,k,m,g。最小为4M&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--memory-swap&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;内存+交换分区大小总限制，格式同上，必须比-m设置的值大&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--memory-reservation&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-3-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;内存的软性限制，格式同上&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--oom-kill-disable&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-4-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;是否阻止 OOM killer 杀死容器，默认没设置&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-5-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--oom-score-adj&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-5-1&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;容器被 OOM killer 杀死的优先级，范围是[-1000, 1000]，默认为 0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-6-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--memory-swappiness&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-6-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用于设置容器的虚拟内存控制行为。值为 0~100 之间的整数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-7-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--kernel-memory&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;9597-1534429540690-cell-7-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;核心内存限制。格式同上，最小为 4M&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-m，--memory选项的参数最小为 4 M；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;--memory-swap不是交换分区，而是内存加交换分区的总大小，所以--memory-swap必须比-m,--memory大；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;若不设置-m,--memory和--memory-swap，容器默认可用完宿主机所有内存和swap分区。但容器占宿主机所有内存和swap分区超过一段时间后，会被宿主机系统杀死（若没有设置--00m-kill-disable=true）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.3 内存设置方式&lt;/h3&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置-m,--memory，不设置--memory-swap&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_01 -m 1G --memory-swap 0 ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器能使用的内存大小为1G，能使用的 swap 分区大小也为1G，容器内的进程能申请到的总内存大小为2G。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：使用-m或--memory设置一个不小于 4M 的a值，不设置--memory-swap，或将--memory-swap设置为 0。则表示容器能使用的内存大小为 a，能使用的交换分区大小也为 a。因为 Docker 默认容器交换分区的大小和内存相同。若容器中运行一个一直不停申请内存的程序，则该程序最终能使用的内存大小为 2a。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置-m,--memory=a，--memory-swap=b，且b &amp;gt; a&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_02 -m 1G --memory-swap 3G ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器能使用的内存大小为 1G，能使用的 swap 分区大小为 2G。容器内的进程能申请到的总内存大小为 3G。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：使用-m或--memory设置一个不小于 4M 的a值，且b必须大于a，使用--memory-swap设置一个参数 b。则表示容器能使用的内存大小为 a，能使用的交换分区+内存大小为 b，b-a 即为容器能使用的 swap 分区大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;设置-m,--memory=a，--memory-swap=-1&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_03 -m 1G --memory-swap -1 ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器能使用的内存大小为 1G，且不限制容器使用swap分区大小，即1G+宿主机swap大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：使用-m或--memory设置一个不小于 4M 的a值，使用--memory-swap设置一个参数-1，则表示限制容器能使用的内存大小为 a，且不限制容器使用 swap 分区大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：若出现如下提示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WARNING: Your kernel does not support swap limit capabilities or the cgroup is not mounted. Memory limited without swap.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可打开内核内存限制的操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# vi /etc/default/grub
&lt;span&gt;  2&lt;/span&gt; GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;
&lt;span&gt;  3&lt;/span&gt; root@docker:~# update-grub              #重启系统
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;5.4 内存软性限制&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;设置--memory-reservation。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_04 -m 2G --memory-reservation 1G ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器能使用的内存大小为 2G，当宿主机内存资源紧张时，系统会回收1G内存，以便尝试将容器的内存锁紧到 1G 以下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：Memory reservation是一种软性限制，用于节制容器内存使用。使用--memory-reservation设置一个比-m小的值后，虽然容器最多可以使用-m设置的内存大小，但在宿主机内存资源紧张时，在系统的下次内存回收时，系统会回收容器的部分内存页，强迫容器的内存占用回到--memory-reservation设置的值大小。没有设置时（默认情况下）--memory-reservation的值则--memory-reservation和-m的限定的值相同。将它设置为 0 或设置的比-m的参数大等同于没有设置。这种软性机制，它不保证任何时刻容器使用的内存不会超过--memory-reservation限定的值，它只是确保容器不会长时间占用超过--memory-reservation限制的内存大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.5 OOM killer&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_05 -m 1G --oom-kill-disable ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器能使用的内存大小为 1G，并禁止了 OOM killer。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：OOM killer机制指默认情况下，在出现 out-of-memory(OOM) 错误时，系统会杀死容器内的进程来获取更多空闲内存。通过设置--oom-kill-disable选项来禁止 OOM killer 杀死容器内进程。但请确保只有在使用了-m/--memory选项时才使用--oom-kill-disable禁用 OOM killer。如果没有设置-m选项，却禁用了 OOM-killer，可能会造成出现 out-of-memory 错误时，系统通过杀死宿主机进程或获取更改内存。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.6 --memory-swappiness&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_06 --memory-swappiness=0 ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#该容器关闭了匿名页面交换，可以保持容器的工作集，避免交换代理的性能损失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用：默认情况下，容器的内核可以交换出一定比例的匿名页。--memory-swappiness可设置从 0 到 100这个比例。0 表示关闭匿名页面交换。100 表示所有的匿名页都可以交换。默认情况下，如果不使用--memory-swappiness，则该值从父进程继承而来。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：--memory-swappiness=0 表示禁用容器 swap 功能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;六 CPU限制&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Docker 的资源限制和隔离完全基于 Linux cgroups。对 CPU 资源的限制方式也和 cgroups 相同。Docker 提供的 CPU 资源限制选项可以在多核系统上限制容器能利用哪些 vCPU。而对容器最多能使用的 CPU 时间有两种限制方式：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;当多个 CPU 密集型的容器竞争 CPU 时，设置各个容器能使用的 CPU 时间相对比例。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;以绝对的方式设置容器在每个调度周期内最多能使用的 CPU 时间。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;6.1 CPU限制相关参数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;执行docker run命令时能使用的和内存限制相关的所有选项如下。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;141&quot;/&gt;&lt;col width=&quot;392&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;7337-1534482104855-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;选项&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;7337-1534482104855-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--cpuset-cpus=&quot;&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-1-1&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;允许使用的 CPU 集，值可以为 0-3,0,1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;-c,--cpu-shares=0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;CPU 共享权值（相对权重）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;cpu-period=0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-3-1&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--cpu-quota=0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-4-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;限制 CPU CFS 配额，必须不小于1ms，即 &amp;gt;= 1000&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-5-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--cpuset-mems=&quot;&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;7337-1534482104855-cell-5-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;允许在上执行的内存节点（MEMs），只对 NUMA 系统有效&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中--cpuset-cpus用于设置容器可以使用的 vCPU 核。-c,--cpu-shares用于设置多个容器竞争 CPU 时，各个容器相对能分配到的 CPU 时间比例。--cpu-period和--cpu-quata用于绝对设置容器能使用 CPU 时间。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;6.2 CPU集&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_07 --cpuset-cpus=&quot;1,3&quot; ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;#表示容器中的进程可以在 cpu 1 和 cpu 3 上执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;6.3 CPU 资源的相对限制&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的容器得到同等比例的 CPU 周期。在有多个容器竞争 CPU 时可设置每个容器能使用的 CPU 时间比例。这个比例叫作共享权值，通过-c或--cpu-shares设置。Docker 默认每个容器的权值为 1024。不设置或将其设置为 0，都将使用这个默认值。系统会根据每个容器的共享权值和所有容器共享权值和比例来给容器分配 CPU 时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有三个正在运行的容器，这三个容器中的任务都是 CPU 密集型的。第一个容器的 cpu 共享权值是 1024，其它两个容器的 cpu 共享权值是 512。第一个容器将得到 50% 的 CPU 时间，而其它两个容器就只能各得到 25% 的 CPU 时间了。如果再添加第四个 cpu 共享值为 1024 的容器，每个容器得到的 CPU 时间将重新计算。第一个容器的CPU 时间变为 33%，其它容器分得的 CPU 时间分别为 16.5%、16.5%、33%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：这个比例只有在 CPU 密集型的任务执行时才有用。在四核的系统上，假设有四个单进程的容器，它们都能各自使用一个核的 100% CPU 时间，不管它们的 cpu 共享权值是多少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在多核系统上，CPU 时间权值是在所有 CPU 核上计算的。即使某个容器的 CPU 时间限制少于 100%，它也能使用各个 CPU 核的 100% 时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，假设有一个不止三核的系统。用-c=512的选项启动容器{C0}，并且该容器只有一个进程，用-c=1024的启动选项为启动容器C1，并且该容器有两个进程。CPU 权值的分布可能是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; PID    container    CPU CPU share
&lt;span&gt;  2&lt;/span&gt; 100    {C0}     0   100% of CPU0
&lt;span&gt;  3&lt;/span&gt; 101    {C1}     1   100% of CPU1
&lt;span&gt;  4&lt;/span&gt; 102    {C1}     2   100% of CPU2
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;6.4 CPU 资源的绝对限制&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Linux 通过 CFS（Completely Fair Scheduler，完全公平调度器）来调度各个进程对 CPU 的使用。CFS 默认的调度周期是 100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少 CPU 时间。使用--cpu-period即可设置调度周期，使用--cpu-quota即可设置在每个周期内容器能使用的 CPU 时间。两者一般配合使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root@docker:~# docker run -d --name ubuntu_08 --cpu-period=50000 --cpu-quota=25000 ubuntu:16.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#将 CFS 调度的周期设为 50000，将容器在每个周期内的 CPU 配额设置为 25000，表示该容器每 50ms 可以得到 50% 的 CPU 运行时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$ docker run -it --cpu-period=10000 --cpu-quota=20000 ubuntu:16.04 /bin/bash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;root@docker:~# docker run -d --name ubuntu_09 --cpu-period=10000 --cpu-quota=20000 ubuntu:16.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将容器的 CPU 配额设置为 CFS 周期的两倍，即容器分配两个 vCPU 就可以了。该配置表示容器可以在每个周期内使用两个 vCPU 的 100% 时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：CFS 周期的有效范围是 1ms~1s，对应的--cpu-period的数值范围是 1000~1000000。而容器的 CPU 配额必须不小于 1ms，即--cpu-quota的值必须 &amp;gt;= 1000。可以看出这两个选项的单位都是 us。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;七 Block IO限制&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;141&quot;/&gt;&lt;col width=&quot;461&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;6262-1534483165837-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;选项&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;6262-1534483165837-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--blkio-weight&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-1-1&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;设置的都是资源使用的权重&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示：该设置都是资源紧张的情况下才会起到权重的作用，正常情况下，都是平等的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--blkio-weight-device 针对特定的设备设置权重&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--device-read-bps&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;限制读某个设备的bps（数据量）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--device-write-bps&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-3-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;限制写入某个设备的bps（数据量）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--device-read-iops&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-4-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;限制读某个设备的iops（次数）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-5-0&quot;&gt;
&lt;p&gt;&lt;span&gt;--device-write-iops&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; data-cell-id=&quot;6262-1534483165837-cell-5-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;限制写入某个设备的iops（次数）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;7.1 block IO 权重&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_10 --blkio-weight 600 ubuntu:16.04
&lt;span&gt;  2&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_11 --blkio-weight 300 ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;#ubuntu_10容器的读写磁盘的带宽是ubuntu_11的两倍。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;7.2 限制 bps 和 iops&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;bps：byte per second，每秒读写的数据量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iops：io per second，每秒 IO 的次数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; root@docker:~# docker run -d --name ubuntu_12 --device-write-bps /dev/sda:30MB ubuntu:16.04
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;#ubuntu_12容器写 /dev/sda 的速率为 30 MB/s。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 28 Dec 2018 06:59:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 docer运行应用 1.1 常见容器运行 docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10190608.html</dc:identifier>
</item>
<item>
<title>游戏编程之命令模式 - 禹泽鹏鹏</title>
<link>http://www.cnblogs.com/IAMTOM/p/10190554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IAMTOM/p/10190554.html</guid>
<description>&lt;h2 id=&quot;7288-1545968780023&quot;&gt;1、什么是命令模式&lt;/h2&gt;
&lt;p&gt;最近看了《游戏编程模式》这本书，里面介绍了游戏开发时常用的设计模式，当然这些设计模式不只是在开发游戏时才管用，它们同样适用于其他软件开发，适用于各种语言。这里我记录一下自己的学习笔记以及结合unity的使用方法。命令模式是常用的设计模式之一，它的定义是这样：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。这个定义听起来似乎晦涩难懂，下面用unity游戏开发的例子来说明：&lt;/p&gt;

&lt;h2 id=&quot;8368-1545969179236&quot;&gt;2、对客户进行参数化&lt;/h2&gt;
&lt;p&gt;比如在游戏开发中，产品经理给你提了这样一个需求：按下按键A，控制角色攻击；按下按键B，控制角色奔跑；按下按键C，控制角色跳跃。面对这样一个简单的需求，我们或许会这样写：&lt;/p&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleInput()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.A))
    {
        Attack();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.B))
    {
        Run();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.C))
    {
        Jump();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，产品经理又提了需求，用户可以自定义按键功能，在很多游戏中都有做这样的功能，为了实现这样的功能，我们应该将这些对Attack()和Run()的调用转化成可以变换的东西，下面用命令模式来重写一下这个功能：&lt;/p&gt;
&lt;p&gt;先定义一个抽象类Command作为基类，再定义具体的子类来重写Excute();&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Command{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AttackCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;攻击逻辑&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;奔跑逻辑&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JumpCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳跃逻辑&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MonoBehaviour的Update函数中，每帧去监听用户输入，并返回对应的command&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameControl : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonA;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonB;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonC;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
    {
        buttonA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AttackCommand();
        buttonB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JumpCommand();
        buttonC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunCommand();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
    {
        Command cmd &lt;/span&gt;=&lt;span&gt; HandleInput();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmd != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            cmd.Excute(actor);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理用户输入&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command HandleInput()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.A))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonA;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.B))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonB;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.C))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonC;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;22&quot;&gt;这样，在按键触发和函数调用中间就加了一层Command，如果要自定义按键功能，直接修改Button对应的Command就行了。现在我们也可以修改一下上面的代码，让我们可以用这套机制去控制任意角色对象，只需将要控制的角色对象传进来即可：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameActor { }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Actor1 : GameActor { }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Actor2 : GameActor { }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Command{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AttackCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;攻击逻辑&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;奔跑逻辑&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JumpCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳跃逻辑&lt;/span&gt;
&lt;span&gt;    }
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameControl : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonA;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonB;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command buttonC;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GameActor actor;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
    {
        buttonA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AttackCommand();
        buttonB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JumpCommand();
        buttonC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunCommand();

        actor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actor1();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
    {
        Command cmd &lt;/span&gt;=&lt;span&gt; HandleInput();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmd != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            cmd.Excute(actor);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理用户输入&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command HandleInput()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.A))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonA;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.B))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonB;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.C))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buttonC;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;2281-1545976072968&quot;&gt;3、支持可撤销的操作&lt;/h2&gt;
&lt;p&gt;命令模式在需要支持可撤销操作的情况下也能轻松应对，假如我们需要给玩家提供撤销移动操作的功能时，我们可以先把玩家输入产生的command存入栈中（或者其他数据结构），在撤销时，从栈中取出栈顶的Command，再调用该Command的Undo()，就实现了撤销功能（Undo()为撤销方法，与Excute()相反），代码如下：&lt;/p&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameActor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Transform selfTra;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Move(Vector3 offset)
    {
        selfTra.Translate(offset);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Actor1 : GameActor { }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Actor2 : GameActor { }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Command{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Excute(GameActor actor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Undo(GameActor actor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MoveCommand : Command
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Vector3 moveOffset;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MoveCommand(Vector3 offset)
    {
        moveOffset &lt;/span&gt;=&lt;span&gt; offset;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Excute(GameActor actor)
    {
        actor.Move(moveOffset);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Undo(GameActor actor)
    {
        actor.Move(&lt;/span&gt;-&lt;span&gt;moveOffset);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandControl : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Command moveCommand;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GameActor actor;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Stack&amp;lt;Command&amp;gt;&lt;span&gt; commandStack;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
    {
        moveCommand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MoveCommand(Vector3.one);
        actor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actor1();
        commandStack &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;Command&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
    {
        Command cmd &lt;/span&gt;=&lt;span&gt; HandleInput();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmd != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            commandStack.Push(cmd);
            cmd.Excute(actor);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要撤销操作时调用这个函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PlayReverse()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (commandStack.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            commandStack.Pop().Undo(actor);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理用户输入&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Command HandleInput()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.A))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MoveCommand(&lt;span&gt;new&lt;/span&gt; Vector3(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Input.GetKeyDown(KeyCode.B))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MoveCommand(&lt;span&gt;new&lt;/span&gt; Vector3(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中， 每次产生一个command时就将它存到Stack中，当需要撤销操作时，就取出Stack顶部的command，并执行它的Undo()，按照这种方法，可以实现多重撤销。&lt;/p&gt;

&lt;h2 id=&quot;5025-1545979004059&quot;&gt;4、总结&lt;/h2&gt;
&lt;p&gt;通过上面的例子，我们再看命令模式的定义：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。现在我们差不多明白了命令模式的用法，它优点很明显，缺点也是有的：第一个优点是类间解耦，调用者和接收者之间没有任何依赖关系，调用者在实现功能时只需调用Command抽象类的Excute方法即可，不需要关注是哪个接收者执行；第二个优点是可扩展性，Command的子类可以很容易地扩展；缺点是如果有大量命令，那么Command的子类将会非常庞大。我们在实际开发中，应该发挥出命令模式的优点，并结合其他模式，减少Command子类庞大的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Fri, 28 Dec 2018 06:56:00 +0000</pubDate>
<dc:creator>禹泽鹏鹏</dc:creator>
<og:description>1、什么是命令模式 最近看了《游戏编程模式》这本书，里面介绍了游戏开发时常用的设计模式，当然这些设计模式不只是在开发游戏时才管用，它们同样适用于其他软件开发，适用于各种语言。这里我记录一下自己的学习笔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IAMTOM/p/10190554.html</dc:identifier>
</item>
<item>
<title>自动化测试如何准备测试数据 - 乙醇</title>
<link>http://www.cnblogs.com/nbkhic/p/10190582.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbkhic/p/10190582.html</guid>
<description>&lt;p&gt;其实大部分类型的测试都需要去准备测试数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;手工测试：一些基础数据，比如配置数据等等是需要去准备的；&lt;/li&gt;
&lt;li&gt;自动化测试：基础需要准备，现有数据，动态运行时产生的数据是需要准备的；&lt;/li&gt;
&lt;li&gt;性能测试：跟自动化测试差不多；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里就牵扯到了一些关于数据的概念了。&lt;/p&gt;
&lt;h3 id=&quot;测试数据的分类&quot;&gt;测试数据的分类&lt;/h3&gt;
&lt;p&gt;我们可以给测试数据分一些种类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础数据，比如一些内容管理系统会配置站点的标题，友情链接之类的基础配置数据&lt;/li&gt;
&lt;li&gt;存量数据，也就是现有数据。比如在测试一些电商站点的时候会提前插入一些商品信息，类目信息物流信息等&lt;/li&gt;
&lt;li&gt;动态数据，也可以叫做session数据。比如在测试电商站点的发布商品功能的时候，往往会去创建一些新的商品&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以想象到，基础数据其实可以比较容易的跟生产环境保持一致。测试环境的存量数据会比线上环境要少，测试环境的动态数据可能不会像线上环境那样真实。&lt;/p&gt;
&lt;p&gt;这里就需要讨论测试数据的量级和真实性的问题了。&lt;/p&gt;
&lt;h3 id=&quot;测试数据的量级&quot;&gt;测试数据的量级&lt;/h3&gt;
&lt;p&gt;大部分情况下，测试数据的量级是没有产生环境多的。所以测试数据可以是真实数据的子集。&lt;/p&gt;
&lt;p&gt;如果有类生产环境或预发布环境的话，可以尽量保持跟线上数据相当的量级。这样一些测试环境不好测出来的由于数据量导致的问题可以在预发布环境测出来。&lt;/p&gt;
&lt;h3 id=&quot;测试数据的真实性&quot;&gt;测试数据的真实性&lt;/h3&gt;
&lt;p&gt;我们测试环境的数据往往跟真实用户产生的数据是有差异的。比如测试论坛系统时，我们在帖子里的贴图可能往往就那么几张，尺寸也是恰到好处，而线上用户的贴图可能是五花八门，从而导致意想不到的问题。&lt;/p&gt;
&lt;h3 id=&quot;如何准备基础和存量数据&quot;&gt;如何准备基础和存量数据&lt;/h3&gt;
&lt;p&gt;基础和存量数据与线上环境越一致，测试中发现问题的概率可能就越高。一般来说，可以有下面的策略&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全量+脱敏策略。直接定期把线上的数据做脱敏，导入到测试环境。这里脱敏是必选，数据泄漏导致的问题严重程度往往比普通的线上bug要严重得多。&lt;/li&gt;
&lt;li&gt;定量+脱敏策略。只上一些线上数据，比如只在线上拉1000个商品，1000个用户信息，然后做脱敏。这里技术实现难度会比较高，毕竟要把关联表理顺。&lt;/li&gt;
&lt;li&gt;爬虫策略。如果是新项目/产品的话，线上没有存量数据可以导，那么可能要去友商那里爬一些数据，导到测环境做测试。比如做一个旅游站点，开始的时候是没有用户的游记的，这时候就要去类似站点爬一点来测试了。&lt;/li&gt;
&lt;li&gt;生成动态数据。如果线上没有数据，友商也没有的爬，那么就要人肉或者自动化的方式去产生一些数据了。系统简单的话可以用sql去跑，复杂点的话可能要调用接口或者用自动化的方式去生成。实在没辙的时候也可以手动去造一些数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于动态数据&quot;&gt;关于动态数据&lt;/h3&gt;
&lt;p&gt;大家在做自动化或者接口测试后往往会大量的去产生动态数据。那么问题就来了。&lt;/p&gt;
&lt;p&gt;这些数据存在哪里？什么意思呢？如果我们需要用自动化的方式去创建一个商品，那么商品的信息，图片地址该放在哪里呢？其实这是个持久化的问题了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;放文件里。文件格式有很多可以选的，比如xml/csv/json/yaml等。不过不推荐excel，毕竟是私有格式，没有太强的扩展性。而且excel一升级，你的解析代码和库也可能要跟着改一次，嗯，强烈不推荐了。&lt;/li&gt;
&lt;li&gt;放数据库里。爬一些商品的信息存到数据库里，然后读数据库也是很好的办法，还能熟悉一下sql的用法，面试经常问到，另外可以用数据库的事务机制来清理测试数据&lt;/li&gt;
&lt;li&gt;在代码里动态生成。比如动态随机生成用户的姓名啊性别和年龄之类的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据生成之后就面临着一个清理的问题。清理问题实际上数据生命周期的问题，测试数据应该有下面一些生命周期吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;短期数据。用例完了就删掉的数据，一般线上做性能测试的数据都是这样的短期数据&lt;/li&gt;
&lt;li&gt;长期数据。用例跑出来的数据放在那里也没事，可以一直存在。这种数据太多有时候会影响测试环境的性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自动化测试跑出的数据建议做短期数据，跑出来想办法清掉，因为自动化跑的频率其实可以很高，每次都产生一堆数据的话数据的量级可能会在短期变得很大，对测试环境的性能造成影响。&lt;/p&gt;
&lt;p&gt;以上的一些看法是个人的浅显的粗鄙的看法，肯定有很多不成熟的地方，欢迎大家斧正。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 06:56:00 +0000</pubDate>
<dc:creator>乙醇</dc:creator>
<og:description>其实大部分类型的测试都需要去准备测试数据。 手工测试：一些基础数据，比如配置数据等等是需要去准备的； 自动化测试：基础需要准备，现有数据，动态运行时产生的数据是需要准备的； 性能测试：跟自动化测试差不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nbkhic/p/10190582.html</dc:identifier>
</item>
<item>
<title>利用SQL Profile 追踪数据库操作 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10190444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10190444.html</guid>
<description>&lt;p&gt;&lt;span data-ttu-id=&quot;be58e-101&quot;&gt;SQL Server 事件探查器 &lt;span data-ttu-id=&quot;d4ab3-103&quot;&gt;是一个界面，用于创建和管理跟踪并分析和重播跟踪结果。 &lt;span data-ttu-id=&quot;d4ab3-104&quot;&gt;这些事件保存在一个跟踪文件中，稍后试图诊断问题时，可以对该文件进行分析或用它来重播一系列特定的步骤。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;sql-server-profiler-1&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;span data-ttu-id=&quot;d4ab3-122&quot;&gt;SQL Server 事件探查器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-122&quot;&gt;&lt;span data-ttu-id=&quot;d4ab3-123&quot;&gt;Microsoft &lt;span data-ttu-id=&quot;be58e-101&quot;&gt;SQL Server 事件探查器 是 SQL 跟踪的图形用户界面，用于监视 &lt;span data-ttu-id=&quot;4170a-101&quot;&gt;数据库引擎 或 Analysis Services 的实例。 &lt;span data-ttu-id=&quot;d4ab3-124&quot;&gt;您可以捕获有关每个事件的数据并将其保存到文件或表中供以后分析。 &lt;span data-ttu-id=&quot;d4ab3-125&quot;&gt;例如，可以对生产环境进行监视，了解哪些存储过程由于执行速度太慢影响了性能。 &lt;span data-ttu-id=&quot;be58e-101&quot;&gt;SQL Server 事件探查器 &lt;span data-ttu-id=&quot;d4ab3-126&quot;&gt;用于如下活动：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-127&quot;&gt;逐步分析有问题的查询以找到问题的原因。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-128&quot;&gt;查找并诊断运行慢的查询。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-129&quot;&gt;捕获导致某个问题的一系列 &lt;span data-ttu-id=&quot;8ccaf-101&quot;&gt;Transact-SQL 语句。 &lt;span data-ttu-id=&quot;d4ab3-130&quot;&gt;然后用所保存的跟踪在某台测试服务器上复制此问题，接着在该测试服务器上诊断问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-131&quot;&gt;监视 &lt;span data-ttu-id=&quot;4c299-101&quot;&gt;SQL Server 的性能以优化工作负荷。 &lt;span data-ttu-id=&quot;d4ab3-132&quot;&gt;有关为数据库工作负荷而优化物理数据库设计的信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-133&quot;&gt;使性能计数器与诊断问题关联。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-133&quot;&gt;注意：&lt;span data-ttu-id=&quot;be58e-101&quot;&gt;SQL Server 事件探查器 &lt;span data-ttu-id=&quot;d4ab3-134&quot;&gt;还支持对 &lt;span data-ttu-id=&quot;4c299-101&quot;&gt;SQL Server 实例上执行的操作进行审核。 &lt;span data-ttu-id=&quot;d4ab3-135&quot;&gt;审核将记录与安全相关的操作，供安全管理员以后复查。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; 事件&lt;/h3&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;d4ab3-141&quot;&gt;事件是在 &lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;SQL Server 数据库引擎实例中生成的操作。 &lt;span data-ttu-id=&quot;d4ab3-142&quot;&gt;示例包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-143&quot;&gt;登录连接、失败和断开。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;8ccaf-101&quot;&gt;Transact-SQL &lt;span data-ttu-id=&quot;d4ab3-144&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 语句。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-145&quot;&gt;远程过程调用 (RPC) 批处理状态。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-146&quot;&gt;存储过程的开始或结束。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-147&quot;&gt;存储过程中的语句的开始或结束。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-148&quot;&gt;SQL 批处理的开始或结束。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-149&quot;&gt;写入到 &lt;span data-ttu-id=&quot;4c299-101&quot;&gt;SQL Server 错误日志的错误。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-150&quot;&gt;在数据库对象上获取或释放的锁。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-151&quot;&gt;打开的游标。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;d4ab3-152&quot;&gt;安全权限检查。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;启动SQL Profiler工具&lt;/h2&gt;
&lt;p&gt;如果你在安装SqlServer的时候勾上了这个工具，那么就一定可以搜索的出来，我在win10的情况下直接进行搜索就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228120129069-808225672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如果你不是win10，也可以直接打开SQL server 然后点击工具就可以看到该工具了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228120217064-1430804439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们点击下之后会跳出来SQL server Profiler这个工具，需要我们进行连接到 &lt;span data-ttu-id=&quot;4c299-101&quot;&gt;SQL Server 实例的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228120346297-807392227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功连接之后会跳出一个弹框，那么在此其中去选择你要跟踪的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228120500921-1893435672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SQL profiler支持多连接跟踪，那么也就是可以分布式监控了，那么我们点击运行，就可以看到这样的可视化界面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228120731930-291307116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我用它我无非就是看下执行的什么SQL还有时间了，我执行了一条这样的sql，效果图如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
use EFCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228121000504-736368266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从刚才的15行直接变成了313，是不是挺可怕的，当你不限制，分布式监控的情况下一秒几千行。。。最好还是要做一做事件限制和数据列。&lt;/p&gt;
&lt;p&gt; 那么如何保存记录日志呢？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228122339716-2020830075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：关闭了这个可视化界面，只要你的服务没有关闭，那么这个是一直跑着呢，怎么停止呢？ （选中那么点那个）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228122719422-670468901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚才我上面说过，一下子出来了那么多记录，我们应该怎么办，网上很多底层的东西，类似CPU,进程号什么的，我是个渣渣，我只会TextData，大概就是这么做吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201812/1366751-20181228123859682-17632703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 利用SQL profile可以记录mssql的数据库操作，这无疑是微软技术的糖果。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 06:38:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>SQL Server 事件探查器 是一个界面，用于创建和管理跟踪并分析和重播跟踪结果。 这些事件保存在一个跟踪文件中，稍后试图诊断问题时，可以对该文件进行分析或用它来重播一系列特定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10190444.html</dc:identifier>
</item>
<item>
<title>了解 HTTPS，读这篇文章就够了 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/10190224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/10190224.html</guid>
<description>&lt;p&gt;今天接到个活儿，让我科普 HTTPS 。讲 HTTP 我都“方”，想要通俗易懂的说完 HTTPS， 我有点“圆”。在讲什么是 HTTPS 之前，我们先来看个漫画。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;708&quot; data-height=&quot;1600&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/80097-cd81eaa6ffbe4c00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/708/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/80097-cd81eaa6ffbe4c00.png&quot; data-original-width=&quot;708&quot; data-original-height=&quot;1600&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;419210&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;△ 图片来源于阮一峰的网络日志&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;漫画中其实就是 HTTPS 的握手过程，但是我相信大段的英文你看着也不怎么流畅，下面就由我简单讲解下吧。HTTPS 是在 HTTP 的基础上增加了 SSL 或 TLS 安全协议，这些协议有众多的套件，这些套件则是由加密算法和哈希算法组成，而这些算法最后则涉及到了数学。数学是我上学时期最头痛的学科，还记得上数学课时，我传纸条给坐在我后面的班花……咦，好像有点跑偏了，拉回来，坐好了，开始我们的 HTTPS 之旅。&lt;/p&gt;
&lt;h2&gt;HTTPS 是什么&lt;/h2&gt;
&lt;p&gt;HTTPS 是为了安全的使用 HTTP ，缩写展开：Hyper Text Transfer Protocol over Secure Socket Layer 。从英文释义可以看出，HTTPS 就是 HTTP + SSL 或者 HTTP + TLS 。&lt;/p&gt;
&lt;p&gt;“我读书少，你可不要骗我，上面的英文缩写不是 HTTP over SSL 吗？”呃...是这样的，HTTPS 最初使用的加密协议的确是 SSL，SSL 最近的三个版本是：SSL 1.0 、SSL 2.0 、SSL 3.0 ，不过随着加密算法的发展和人们对传输安全性要求的提高，截止目前已经长江后浪推前浪依次推出了 TLS 的四个版本，分别是：TLS 1.0 、TLS 1.1 、TLS 1.2 以及前不久刚推出的 TLS 1.3 。实际上，业内也有人把 TLS 1.0 叫做 SSL 3.1 ，事实上，TLS 是在 SSL 的基础上发展起来的更安全的加密协议。&lt;/p&gt;
&lt;h2&gt;为什么要使用 HTTPS&lt;/h2&gt;
&lt;p&gt;这个问题要从为什么逐渐的抛弃 HTTP 说起。HTTP 从 1991 年的 HTTP/0.9 一直发展到 1999 年的 HTTP/1.1 ，虽然功能不断增加，性能也不断提高，但是随着互联网技术和网络设备的迅速普及，导致信息大爆炸，众多的网民们对网络传输的速度和安全性有了越来越高的要求。2012 年，谷歌推出了 SPDY 方案，优化了 HTTP/1.x 的请求延迟和安全性问题，进一步普及了 HTTPS，截止到 2015 年，HTTP/2 已经成为标准，更是进一步推动了全网 HTTPS 的进程。&lt;/p&gt;
&lt;p&gt;全网 HTTPS 是大势所趋，那么为什么抛弃 HTTP 呢？最重要的原因就是安全问题，因为 HTTP 是明文传输的，这对于目前从娃娃就开始玩智能手机，学习 python 编程的新一代来说，抓个包估计是不在话下，更别提浸淫网络多年的“黑客”了。是时候跑步进入 HTTPS 加密时代的了。&lt;/p&gt;
&lt;h2&gt;HTTPS 为什么安全&lt;/h2&gt;
&lt;p&gt;上文已经有提到，HTTPS 就是 HTTP + SSL or TLS ，除了 HTTPS 传输标准严格和规范外，主要是 SSL 或者 TLS 对传输的信息有一整套的加解密和校验方案。这套方案主要从下面三个方面确保传输的安全。&lt;/p&gt;
&lt;p&gt;1. 身份认证&lt;/p&gt;
&lt;p&gt;传输之前首先通过数字证书来确认身份，各大 CA 厂商干的就是这个事情。这里涉及到一个名词：数字证书。数字证书分为公钥和私钥，CA 厂商会用自己的私钥来给证书申请者签发一套包含私钥和公钥的客户证书，客户的公钥证书谁都可以获取，里面包含了客户站点和证书的基本信息，用来确保访问者访问的就是他想要访问的站点。&lt;/p&gt;
&lt;p&gt;这个证书不可以伪造吗？答案是真的不可以。&lt;/p&gt;
&lt;p&gt;原因一：系统早已内置了各大 CA 厂商的公钥来校验证书是否是对应的站点的证书，如果不是，就会给出证书不匹配的提示，除非你给别人的设备强行植入假的 CA 公钥。&lt;/p&gt;
&lt;p&gt;原因二：这个证书是 CA 厂商通过哈希并加密得到的，基本无法逆向破解并伪造一个新的，除非是你黑进 CA 获取了 CA 的私钥，那这家 CA 也基本可以倒闭了。&lt;/p&gt;
&lt;p&gt;2. 数据保密&lt;/p&gt;
&lt;p&gt;数据保密包括对话秘钥传输时候的保密和数据的加密传送。&lt;/p&gt;
&lt;p&gt;对话秘钥：以 TLS 1.2 使用的套件之一 DHE-RSA-AES256-SHA256 为例：该套件是以 DHE 、RSA 作为秘钥交换算法，这两种秘钥交换算法都是使用的非对称加密，数学原理分别依赖于计算离散对数的难度和大数分解的难度。也就是在建立 HTTPS 链接的过程中，刚开始是有一些明文出现的，不过想要根据这些已知的明文推算出“对话秘钥”却非常困难。&lt;/p&gt;
&lt;p&gt;对话加密：客户端和和服务端协商并成功获取到对话秘钥后就开始用对话秘钥进行对称加密会话，上面的套件我们可以看到使用的是 AES256 加密算法。&lt;/p&gt;
&lt;p&gt;那么为什么“对话秘钥”的交换使用非对称加密，正式对话数据的传输使用对称加密？因为非对称加密虽然安全性比较高，但是它的效率比较低，速度比较慢，所以我们一般只使用它们来交换一下对话秘钥，后面的对话加密则使用速度更快，效率更高的对称加密。&lt;/p&gt;
&lt;p&gt;3. 数据完整&lt;/p&gt;
&lt;p&gt;身份认证成功后，到了数据加密传输的阶段，所有数据都以明文（HTTP）收发，只不过收发的是加密后的明文。这时候也遇到了一个问题，虽然中间人很难破解加密后的数据，但是如果他对数据进行了篡改，那该怎么办？此时加密套件验证数据一致性的哈希算法就派上用场了，哈希算法有多种，比如 MD5 ，SHA1 或者 SHA2 等，上面举例的加密套件使用的是 SHA2 中的 SHA256 来对数据进行哈希计算。这样就使得任何的数据更改都会导致通信双方在校验时发现问题，进而发出警报并采取相应的措施。&lt;/p&gt;
&lt;p&gt;以上主要从使用 HTTPS 的必要性及 HTTPS 能安全传输的原理进行了简单的阐述，HTTPS 的实现不仅仅是网络技术的集中应用，底层还涉及到了大量的算法以及密码学的众多知识，小编也无法一下子概述完整（笑哭）。另外，不论是 PFS，或是国际互联网组织正在推行的 HSTS 安全传输协议，他们的主要目的就是避免中间人攻击，使信息在传输过程中更安全，更快速。想要更详细的了解 HTTPS 相关知识，我们在推荐阅读里准备了大量的 HTTPS 干货，欢迎查阅。&lt;/p&gt;
&lt;p&gt;彩蛋：你是不是想吐槽一下标题说读这篇就够了，哈哈，你得允许我皮一下嘛~&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/338/%25E4%25B8%258D%25E6%2598%25AF%2520HTTPS%2520%25E6%258B%2596%25E6%2585%25A2%25E7%25BD%2591%25E7%25AB%2599%25E9%2580%259F%25E5%25BA%25A6%25EF%25BC%258C%25E8%2580%258C%25E6%2598%25AF%25E4%25BC%2598%25E5%258C%2596%25E5%2581%259A%25E7%259A%2584%25E4%25B8%258D%25E5%25A4%259F%25E4%25BC%2598%25E7%25A7%2580.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;不是 HTTPS 拖慢网站速度，而是优化做的不够优秀​&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/286/%25E7%25A7%2591%25E6%2599%25AE%2520TLS%25201.3%2520%25E2%2580%2594%2520%25E6%2596%25B0%25E7%2589%25B9%25E6%2580%25A7%25E4%25B8%258E%25E5%25BC%2580%25E5%2590%25AF%25E6%2596%25B9%25E5%25BC%258F.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;科普 TLS 1.3 — 新特性与开启方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/242/%25E4%25BB%258E%2520HTTP%2520%25E5%2588%25B0%2520HTTPS%2520%25E5%2586%258D%25E5%2588%25B0%2520HSTS.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;从 HTTP 到 HTTPS 再到 HSTS&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 06:06:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<og:description>今天接到个活儿，让我科普 HTTPS 。讲 HTTP 我都“方”，想要通俗易懂的说完 HTTPS， 我有点“圆”。在讲什么是 HTTPS 之前，我们先来看个漫画。 △ 图片来源于阮一峰的网络日志 △</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/10190224.html</dc:identifier>
</item>
<item>
<title>策略模式原来这么简单！ - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10190199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10190199.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾前面：&lt;/p&gt;
&lt;p&gt;无论是面试还是个人的提升，设计模式是必学的。今天来讲解&lt;strong&gt;策略&lt;/strong&gt;模式~&lt;/p&gt;

&lt;p&gt;我一次听到策略模式这个词，是在我初学JDBC的时候。不知道大家有没有用过DBUtils这个组件。当时初学跟着视频学习，方立勋老师首先是让我们先自己封装一下JDBC的一些常用的操作(实际上就是模仿DBUtils这个组件)。&lt;/p&gt;
&lt;p&gt;当时候的问题是这样的：我们打算封装一下&lt;code&gt;query()&lt;/code&gt;查询方法，传入的参数有&lt;code&gt;String sql , Object[] objects&lt;/code&gt;(指定SQL语句和对应的参数)。我们想根据&lt;strong&gt;不同的业务&lt;/strong&gt;返回不同的值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如说，有的时候我们返回的是一条数据，那我们想将这条数据封装成一个Bean对象&lt;/li&gt;
&lt;li&gt;比如说，有的时候我们返回的是多条数据，那我们想将这多条数据封装成一个&lt;code&gt;List&amp;lt;Bean&amp;gt;&lt;/code&gt; 集合&lt;/li&gt;
&lt;li&gt;比如说，有的时候我们返回的是xxxx数据，那我们想将这多条数据封装成一个&lt;code&gt;Map&amp;lt;Bean&amp;gt;&lt;/code&gt; 集合&lt;/li&gt;
&lt;li&gt;........等等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当时解决方案是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先定义一个接口：ResultSetHandler(&lt;strong&gt;调用者想要对结果集进行什么操作，只要实现这个接口即可&lt;/strong&gt;)
&lt;ul&gt;&lt;li&gt;这个接口定义了行为。&lt;code&gt;Object hanlder(ResultSet resultSet);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;然后实现上面的接口，比如我们要封装成一个Bean对象，就是&lt;code&gt;public class BeanHandler implements ResultSetHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用的时候，实际上就是&lt;code&gt;query()&lt;/code&gt;查询方法多一个参数&lt;code&gt;query(String sql, Object[] objects, ResultSetHandler rsh)&lt;/code&gt;。调用者想要返回什么类型，只要传入相对应的ResultSetHandler实现类就是了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    query方法：

    //这个方法的返回值是任意类型的，所以定义为Object。
    public static Object query(String sql, Object[] objects, ResultSetHandler rsh) {

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            connection = getConnection();
            preparedStatement = connection.prepareStatement(sql);

            //根据传递进来的参数，设置SQL占位符的值
            if (objects != null) {
                for (int i = 0; i &amp;lt; objects.length; i++) {
                    preparedStatement.setObject(i + 1, objects[i]);
                }
            }


            resultSet = preparedStatement.executeQuery();

            //调用调用者传递进来实现类的方法，对结果集进行操作
            return rsh.hanlder(resultSet);
    }

    接口：

    /*
    * 定义对结果集操作的接口，调用者想要对结果集进行什么操作，只要实现这个接口即可
    * */
    public interface ResultSetHandler {
         Object hanlder(ResultSet resultSet);
    
    }

    接口实现类(Example)：

    //接口实现类，对结果集封装成一个Bean对象
    public class BeanHandler implements ResultSetHandler {
    
    
        //要封装成一个Bean对象，首先要知道Bean是什么，这个也是调用者传递进来的。
        private Class clazz;
    
        public BeanHandler(Class clazz) {
            this.clazz = clazz;
        }
    
        @Override
        public Object hanlder(ResultSet resultSet) {
    
            try {
    
                //创建传进对象的实例化
                Object bean = clazz.newInstance();
    
                if (resultSet.next()) {
    
                    //拿到结果集元数据
                    ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
    
                    for (int i = 0; i &amp;lt; resultSetMetaData.getColumnCount(); i++) {
    
                        //获取到每列的列名
                        String columnName = resultSetMetaData.getColumnName(i+1);
    
                        //获取到每列的数据
                        String columnData = resultSet.getString(i+1);
    
                        //设置Bean属性
                        Field field = clazz.getDeclaredField(columnName);
                        field.setAccessible(true);
                        field.set(bean,columnData);
                    }
    
                    //返回Bean对象
                    return bean;
                }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是策略模式？？就这？？这不是多态的使用吗？？&lt;/p&gt;
&lt;h2 id=&quot;策略模式讲解&quot;&gt;1.1策略模式讲解&lt;/h2&gt;
&lt;p&gt;《设计模式之禅》：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定义一组算法，将每个算法都封装起来，并且使他们之间可以互换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;策略模式的类图是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/24/167df25af9f0cb8f?w=954&amp;amp;h=363&amp;amp;f=png&amp;amp;s=36480&quot; alt=&quot;策略模式通用类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;策略的接口和具体的实现应该很好理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;策略的接口相当于我们上面所讲的ResultSetHandler接口(定义了策略的行为)&lt;/li&gt;
&lt;li&gt;具体的实现相当于我们上面所讲的BeanHandler实现(接口的具体实现)
&lt;ul&gt;&lt;li&gt;具体的实现一般还会有几个，比如可能还有ListBeanHandler、MapBeanHandler等等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;令人想不明白的可能是：策略模式还有一个&lt;strong&gt;Context上下文对象&lt;/strong&gt;。这对象是用来干什么的呢？&lt;/p&gt;
&lt;p&gt;《设计模式之禅》：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Context叫做上下文角色，起承上启下封装作用，&lt;strong&gt;屏蔽高层模块对策略、算法的直接访问&lt;/strong&gt;，封装可能存在的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在知乎上也有类似的问题(为什么不直接调用，而要通过Person？)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/24/167df25afa0ba019?w=557&amp;amp;h=665&amp;amp;f=png&amp;amp;s=23285&quot; alt=&quot;知乎问题&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说白了，通过Person来调用&lt;strong&gt;更符合面向对象&lt;/strong&gt;(屏蔽了直接对具体实现的访问)。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;首先要明白一个道理，就是——到底是 “人” 旅游，还是火车、汽车、自行车、飞机这些交通工具旅游？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果没有上下文的话，客户端就必须直接和具体的策略实现进行交互了，尤其是需要提供一些公共功能或者是存储一些状态的时候，会大大增加客户端使用的难度；引入上下文之后，这部分工作可以由上下文来完成，客户端只需要和上下文进行交互就可以了。这样可以让策略模式更具有整体性，客户端也更加的简单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的链接：&lt;/p&gt;
&lt;p&gt;所以我们再说回上文的通用类图，我们就可以这样看了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/24/167df25afa50df46?w=1189&amp;amp;h=387&amp;amp;f=png&amp;amp;s=48635&quot; alt=&quot;DBUtils策略模式类图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;策略模式例子&quot;&gt;1.2策略模式例子&lt;/h2&gt;
&lt;p&gt;现在3y拥有一个公众号，名称叫做Java3y。3y想要这让更多的人认识到Java3y这个公众号。所以每天都在想怎么涨粉(hahah&lt;/p&gt;
&lt;p&gt;于是3y就开始想办法了(操碎了心)，同时3y在这一段时间下来发现&lt;strong&gt;涨粉的方式有很多&lt;/strong&gt;。为了方便，定义一个通用的接口方便来管理和使用呗。&lt;/p&gt;
&lt;p&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 增加粉丝策略的接口(Strategy)
 */
interface IncreaseFansStrategy {

    void action();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;涨粉的具体措施，比如说，请水军：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 请水军(ConcreteStrategy)
 */
public class WaterArmy implements IncreaseFansStrategy {
    
    @Override
    public void action() {
        System.out.println(&quot;3y牛逼，我要给你点赞、转发、加鸡腿！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;涨粉的具体措施，比如说，认真写原创：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 认真写原创(ConcreteStrategy)
 */
public class OriginalArticle implements IncreaseFansStrategy{

    @Override
    public void action() {
        System.out.println(&quot;3y认真写原创，最新一篇文章：《策略模式，就这？》&quot;);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3y还想到了很多涨粉的方法，比如说送书活动啊、商业互吹啊等等等...(这里就不细说了)&lt;/p&gt;
&lt;p&gt;说到底，无论是哪种涨粉方法，都是通过3y去执行的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 3y(Context)
 */
public class Java3y {

    private IncreaseFansStrategy strategy ;

    public Java3y(IncreaseFansStrategy strategy) {
        this.strategy = strategy;
    }

    // 3y要发文章了(买水军了、送书了、写知乎引流了...)。
    // 具体执行哪个，看3y选哪个
    public void exec() {
        strategy.action();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以啊，每当到了发推文的时候，3y就可以挑用哪种方式涨粉了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) {

        // 今天2018年12月24日
        Java3y java3y = new Java3y(new WaterArmy());
        java3y.exec();

        // 明天2018年12月25日
        Java3y java4y = new Java3y(new OriginalArticle());
        java4y.exec();
        
        // ......
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/24/167df25afa91fc29?w=1569&amp;amp;h=666&amp;amp;f=png&amp;amp;s=34853&quot; alt=&quot;执行结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;策略模式优缺点&quot;&gt;1.3策略模式优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算法可以自由切换
&lt;ul&gt;&lt;li&gt;改一下策略很方便&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;扩展性良好
&lt;ul&gt;&lt;li&gt;增加一个策略，就多增加一个类就好了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;策略类的数量增多
&lt;ul&gt;&lt;li&gt;每一个策略都是一个类，复用的可能性很小、类数量增多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;所有的策略类都需要对外暴露
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;上层模块必须知道有哪些策略&lt;/strong&gt;，然后才能决定使用哪一个策略&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/24/167df25afa723462?w=1136&amp;amp;h=202&amp;amp;f=png&amp;amp;s=9928&quot; alt=&quot;调用方必须要知道有哪些策略&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jdk的策略模式应用&quot;&gt;1.4JDK的策略模式应用&lt;/h2&gt;
&lt;p&gt;不知道大家还能不能想起ThreadPoolExecutor(线程池)：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=9b5c977e0f8329b2bf4c29d230c678fb&amp;amp;chksm=ebd74237dca0cb212f4505935f9905858b9166beddd4603c3d3b5386b5dd8cf240c460a8e7c4#rd&quot;&gt;线程池你真不来了解一下吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习ThreadPoolExecutor(线程池)就肯定要知道它的构造方法每个参数的意义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /**
     * Handler called when saturated or shutdown in execute.
     */
    private volatile RejectedExecutionHandler handler;

    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        //....
        this.handler = handler;
    }

    /**
     * Invokes the rejected execution handler for the given command.
     * Package-protected for use by ScheduledThreadPoolExecutor.
     */
    final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中我们可以找到RejectedExecutionHandler，这个参数代表的是拒绝策略(有四种具体的实现：直接抛出异常、使用调用者的线程来处理、直接丢掉这个任务、丢掉最老的任务)&lt;/p&gt;
&lt;p&gt;其实这就是策略模式的体现了。&lt;/p&gt;

&lt;p&gt;看完会不会觉得策略模式特别简单呀？就一个算法接口、多个算法实现、一个Context来包装一下，就完事了。&lt;/p&gt;
&lt;p&gt;推荐阅读和参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;乐于分享和输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/28/167f35999fff131f?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=21338&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章的&lt;strong&gt;目录导航&lt;/strong&gt;：&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 06:02:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>策略模式原来这么简单！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10190199.html</dc:identifier>
</item>
<item>
<title>一个好的程序员 - 周见智</title>
<link>http://www.cnblogs.com/xiaozhi_5638/p/10186940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozhi_5638/p/10186940.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227193809431-1067659698.jpg&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;p&gt;撤离一线城市工作已经接近一年时间，工作环境发生变化，让我印象深刻的应该是公司周围同事的工作状态。身处环境氛围的改变让我略感恐慌，总结一篇文章我认为好的程序员应该是什么样的，写出来提醒自己。(图片来自网络见水印)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227193910285-2089630910.jpg&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;342&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;技术是一个程序员吃饭的本钱，你可以什么都不擅长，不擅长沟通、也不擅长表达更不擅长管理，但是作为一个以技术名义拿工资的人，具备对应职位应有的技术能力这个是一定不能改变。初级工程师能按照设计文档很好的完成工作，中高级工程师能提出自己的设计思路、实现想法并且高质量完成工作等等。那种平时不太活跃但是能凭借自身能力把自己工作做好的人给我的感觉其实也非常不错。&lt;/span&gt;&lt;span&gt;对一个人能力的要求是会随着职位、时间的变化而更加严格，所以一个人在同一个公司干满1年、3年或者5年，公司对他的期望肯定会不一样。我觉得某些公司淘汰部分年龄大而能力没跟上的员工完全合符情理。因此，后面提到的持续学习、提升自己也是我认为一个好的程序员应该具备的素质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的技术能力是技术综合素质的描述，并不限制于你必须掌握多少门编程语言、会用多少框架解决多少业务、又或者精通多少设计模式、手撸什么什么算法之类的。它体现在多个方面，写代码能力、思考能力、抽象能力、设计能力等等诸如此类的我认为都算。抛开先天因素，这些能力都可以通过后天训练得到相应的提升。单从写代码来说，不管什么级别，我以为一个好的程序员应该适当保持码代码的频率。我现在的职位是技术经理，但是实质上我估算我半年的代码量（包括实际工作中和工作之外）比项目组中其它任何一个人都多。编程这个东西，长时间不摸键盘，真的会生疏。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;能接受新事物，持续学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227194005570-1044182462.jpg&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;408&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个好的程序员应该能接受新的事物，这里不限于技术，还包括其它思想、观点、现象等等。对未知事物保持好奇心，促使自己去探索、学习，从而提升自己。程序员的经验都是靠慢慢学习积累而成，我们身上大部分技能都是在离开学校之后才掌握，如果自己的工作内容本来就相对固定，再加上缺乏学习进步的意识，那么一年两年之后的你跟现在的你几乎没有什么区别，唯一不同的就是年龄又大了一两岁，竞争力又下降了几个百分点，再想想5年、10年之后会如何？而一直保持学习习惯的人，从内到外都能得到提升，自身技能不仅能够突破日常工作的要求，又由于有源源不断新的知识输入，平时在沟通、交谈之时也会更加自信。再或者实在哪天干得不爽了，拍屁股走人也是相当有底气。仔细想想，有多少人想跳槽但又对自己无论能力还是经验都缺乏信心，始终忍声吞气地呆在同一个公司，既不涨薪也不升职的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的人就会说了，我年龄大了，除了工作之外还有非常多的事情要做，哪来时间精力去学习新的东西？说这种话的人大多数可能都没从内心认识到保持学习的重要性，我认为一个好的程序员应该把持续学习当作生活中的一部分，就像你每天要睡觉、刷牙洗脸一样，为什么你每天刷牙洗脸有时间？因为你觉得不刷牙洗脸出门会很难堪，那么学习也应该是一样的道理。不管是中国古人说的“活到老学到老”还是我们敬爱的乔帮主说的“stay foolish, stay hungry”，我觉得都是非常适合各行各业每个人，当然也包括一个好的程序员。一些公司招聘满30岁的简历直接不看，这并不是歧视，从概率上讲，它能够提高合格人才招聘命中率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;勤于总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227194053107-1218448775.jpg&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;410&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面说到的两点我认为是成为一个好的程序员的基础条件，那么这里说到的“勤于总结”其实是对“持续学习”的一个补充，算作是如何学习的一个方法。无论是自己通过某种渠道学习到的新知识，还是工作中碰到过的疑难杂症，我觉得都有必要进行适当的总结，总结的过程就是梳理、反思的过程，帮助我们加深认识，增强记忆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结的方式有很多，个人觉得最好、最靠谱的应该是写博客（文章）发表出来让大家能看到，有人看到就有可能提出质疑，有质疑就会出现辩论，有辩论就会有新的认识，而不管最初的质疑正确与否。如果质疑是对的，那么我们会改正自己的错误；相反如果质疑是错的，那么通过辩论我们会更加相信自己最初的观点。所以我认为这个过程是永赚不亏的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;博客总结另外一个好处就是能够训练自己的书面表述能力，将脑子中的一个问题、方案能够正确详细地转换成有条理、图文并茂的文章，我认为这也是一个好的程序员应该具备的能力。很多东西看似懂了、会了其实大多数时候并不是真的懂了真的会了，非常有可能是你想当然。书写博客是一个表达的过程，就像你将一个事情从头到尾讲给一个陌生人听一样，如何让人快速听懂是门技术活，将脑子中的东西写出来，你很可能会发现有些地方之前想的是错的，而有些地方还可以改进。俗话说“好脑子不如烂笔头”，说的是再好的记忆力都不如将东西写在纸上，因为记忆力再好时间长了可能还是会忘记。而我认为“写出来”还有另外一个好处，那就是反思自己的想法是否真是对的。大部分人并不是天才，习惯性总结能帮我们缩小与天才之间的差距。&lt;/span&gt;&lt;span&gt;一个好的个人博客能给自己带来非常多的潜在价值，对自己的职业发展也会有相当大的帮助。一般应聘时如果简历上注“***优秀博主”，我觉得面试分数会增加一大截，比起那些简历上大段大段的项目经验更加有效果，这个道理其实跟你有一个贡献、活跃度很高的github一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为好的程序员应该有一个活跃度很高的博客，或许你的技术方向比较小众，博客关注人数并不高，但是没有关系，只要你长期保持“写”的这个过程就是有效果的，能坚持1年、5年、10年甚至20年。勤于总结这个东西大部分时候是需要靠自己主动有这个意识，如果想让某个人的行为去影响周边的人也去做这件事情，我觉得成功的概率其实并不高，而发自内心认识到它的重要性更能起到作用。所以，如果有看到这篇文章的朋友，主动抓紧时间行动起来吧！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;沟通、表达也很重要&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227194142630-1446891715.jpg&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;408&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序员一般给人埋头干活、不善交流的印象，大部分时候确实如此，但我认为一个好的程序员应该具备相对较好的沟通、表达能力。这其中又分两种，一种是口头表述能力、一种是书面表述能力。面对面口头沟通能力的重要性自然不必说了，如何在上级面前将自己的想法完整清晰地表达出来、如何在会上给大家传输自己的思路让每个在座的人都能听懂等等。那么什么是书面表述能力呢？工作中其实大部分时候并不具备面对面沟通的机会，更多时候是通过类似邮件、文档、即时通讯工具等等进行交流，如何将一个抽象的问题转换成书面文字（图表）又能让别人轻易看懂同样也是一门技术活。参加工作7年，自认为有一个还算靠谱的经验，就是能从一个从未见面的人写的文档材料中看出这个人是个什么水平，哪怕他写的内容我不是很擅长甚至完全看不懂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面对面沟通能力是我目前比较欠缺的，我也在尽力寻找场合来锻炼自己，希望借此来弥补自己相对较弱的方面。我认为改变自己需要两方面的因素，一个是外部环境一个是内在意识，其中个人更相信后者占更大比重。所以，这里说到的认识到自己缺点并寻求解决方法和前面提到的习惯性总结都应该是出于自我意识。有一些文章作者抱怨公司、领导或者同事的，如果换作是我，我更愿意第一步从自身找原因，当然了，不排除确实是外部问题，如果真是这样，我会如何面对后面我也会说到。另一方面，提高书面表述能力的一种有效途径除了前面说到的多写之外，还应该多看别人写的东西，模仿是最常见的学习手段，同样适合书写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一点我觉得适当推销自己也算是沟通表达能力的一种，好的程序员千万不要迷信“酒香不怕巷子深”这句话，当然推销自己也是在做好本职工作的前提下，适量、适度地向别人展示你有这个能力，其实并不会让人反感。沟通表达能力能让程序员在职业发展道路上走得更好，一个好的程序员当然不会甘愿一直呆在团队底层。尽早合理地训练自己沟通表达能力，保证自己在程序员这条“不归路”上走得更远。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;正确看待自己的付出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227194232582-1958028565.jpg&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;407&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人的地方就是江湖，程序员呆的地方也一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为一个好的程序员应该可以正确看待自己的付出、合理维护自己的利益。程序员也是人，好的程序员同样是人，辛勤付出必然是期待相应的回报，但是这个前提必须是客观看待自己工作产生的价值。“客观看待工作产生的价值”这本身就是一个很困难的事情，因为你和公司的标准太容易不一样了，如果这个标准差得太远，那么跳槽无疑是最好的选择，要让公司改变那是相当困难，委屈自己那也是煎熬。我认为公司和员工是一个相互依赖的关系，只有公司发展和员工当时职业发展刚好匹配上了，这种关系才是最牢靠的，各取所需。之后各自互相成长，谁淘汰谁都有可能，所以坦然面对，不必恐慌。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是之前当小弟还是现在团队leader的角色，我一贯的做法是先把事情做好。把工作做好做完美这个是前提，其它事情都好说。在我个人意识中，把能决定我职位、薪资的人都看成赞同这个观点的人，如果TA确实是这样的人，那么正合我意；相反如果TA不是，那么离开也不是什么坏事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个可能遇到的情况是公司政治斗争，这个东西真的避免不了，你不想主动涉及也有可能被动参与。我个人觉得即使处于这种环境也应该做好自己的本质工作，适当表明自己的态度，该争取时就争取。如果一个好的程序员死于内部政治斗争，我觉得也挺可惜。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于梦想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/104032/201812/104032-20181227194323645-1026005235.jpg&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;457&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写这段话的时候感觉有些犹豫，毕竟这跟是不是好程序员没什么关系，而且像我这种29的大叔还写这种关于梦想的鸡汤文字，很多人可能看不下去。但是思索再三我觉得还是有必要写一写，就当作是自我激励。梦想一直是让人保持清醒、不随波逐流的东西，我觉得人生任何阶段谈梦想都不可笑，儿时有长大后成为科学家的梦想，青年时有找到自己另一半终结单身狗幸福终老的愿望，中年时照样可以有那种一想起就会让你振奋不已的东西。“年少一切未定，随时会变，大喜大悲，从工作到爱情，都不知道第二天会是什么样子。分手吃碗面，天崩地裂，精神饱满哭一夜。所以充斥了背井离乡、颠沛流离这样的字眼，一回头满城灯火，每个路口丢了一具自己的尸体，不管你愿不愿意，都波澜壮阔。年纪大了，日成明朗，好像几年也做不了一件事，因为每件事都是人生最重要的决定，动不动一锤定音，不想再伤筋动骨”。可是啊人生看似数十年，但在人类历史长河中不足一提，三十岁、四十岁更不算什么。愿你三十四十仍像二十岁一样，虽不再大喜大悲，但仍能笑看人生。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Dec 2018 05:56:00 +0000</pubDate>
<dc:creator>周见智</dc:creator>
<og:description>撤离一线城市工作已经接近一年时间，工作环境发生变化，让我印象深刻的应该是公司周围同事的工作状态。身处环境氛围的改变让我略感恐慌，总结一篇文章我认为好的程序员应该是什么样的，写出来提醒自己。(图片来自网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaozhi_5638/p/10186940.html</dc:identifier>
</item>
</channel>
</rss>