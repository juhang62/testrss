<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Design Patterns | 02 什么样的代码是好代码 - 瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/12386383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/12386383.html</guid>
<description>&lt;p&gt;作为一个开发者，要想写出好代码，就要知道什么是好代码，以及评判代码好坏的常见标准。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;122.76902654867&quot;&gt;


&lt;p&gt;对开发人员来说，辨别代码的“好”和“烂”，是个非常重要的能力，这也是我们写出好代码的前提。&lt;/p&gt;
&lt;p&gt;那什么是好的代码，我们应该从哪些维度评判代码质量的高低呢？&lt;/p&gt;
&lt;p&gt;答案是：&lt;strong&gt;很难通过某（几）个词汇来全面地评价代码质量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“评价”这个词本身就有很强的主观性，每个人的标准都不尽一致。但不可否认的是，越有经验的工程师，给出的评价也就越准确。&lt;/p&gt;

&lt;h2 id=&quot;可维护性maintainability&quot;&gt;2.1 可维护性（maintainability）&lt;/h2&gt;
&lt;p&gt;“维护”，就是修改 bug、修改老代码、添加新代码之类的工作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“代码易维护”，就是在不破坏原有代码设计、不引入新 bug 的情况下，能够快速修改或者添加代码。&lt;/li&gt;
&lt;li&gt;“代码不易维护”，就是修改或者添加代码时很可能引入新的 bug，并且需要花费很长的时间才能完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;大多数项目中，维护代码的时间要远多于编写代码的时间，所以代码的可维护性非常重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;影响代码的可维护性的因素有很多，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码的分层是否清晰，模块化是否良好，模块间耦合性是否足够低（要高内聚、低耦合）；&lt;/li&gt;
&lt;li&gt;项目代码量的多少，业务的复杂程度，使用到的技术的复杂程度；&lt;/li&gt;
&lt;li&gt;另外，各类过程文档的编写、团队成员的开发水平等因素也会影响代码的可维护性。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;可读性readability&quot;&gt;2.2 可读性（readability）&lt;/h2&gt;
&lt;p&gt;首先，&lt;strong&gt;代码被阅读的次数要远远超过被编写、修改的次数&lt;/strong&gt;，读不懂代码，就很难安全地添加新功能、修复旧 bug。&lt;/p&gt;
&lt;p&gt;代码的可读性，与代码是否符合编码规范、代码的命名（包括类、函数、变量等）是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰等因素有关。&lt;/p&gt;
&lt;p&gt;影响代码的可维护性的因素有很多，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Code Review（代码审查）是个很好的测验代码可读性的方法。&lt;/li&gt;
&lt;li&gt;如果你的同事可以轻松读懂你写的代码，说明你的代码可读性很好；&lt;/li&gt;
&lt;li&gt;如果其他人在读你的代码时，有很多疑问，说明你的代码可读性并不高。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;可扩展性extensibility&quot;&gt;2.3 可扩展性（extensibility）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可扩展性表示代码应对未来需求变化的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果原有的代码已经预留好了扩展点（比如原代码中抽象了很多底层可以复用的模块），我们在修改很少代码的情况下，添加新的功能。&lt;/p&gt;
&lt;p&gt;这个时候，就可以说代码的可扩展性好，也可以说成代码的灵活性（flexibility）好。&lt;/p&gt;
&lt;p&gt;影响代码的可维护性的因素有很多，比如：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;代码的可读性和可扩展性，在很大程度上决定了代码是否有良好的维护性。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简洁性simplicity&quot;&gt;2.4 简洁性（simplicity）&lt;/h2&gt;
&lt;p&gt;用最简单的方法解决最复杂的问题，能做到这一点的，都是真正的大牛。&lt;/p&gt;
&lt;p&gt;程序开发中有个很有名的 KISS 原则：“Keep It Simple, Stupid”，就是说要尽量保持代码简单，甚至于傻瓜化，这其实也意味着代码易读、易维护。&lt;/p&gt;
&lt;h2 id=&quot;可复用性reusability&quot;&gt;2.5 可复用性（reusability）&lt;/h2&gt;
&lt;p&gt;开发过程中，要多复用已有的代码，尽力避免堆砌重复（相似）的代码。&lt;/p&gt;
&lt;p&gt;与可复用性相关的设计原则和实践经验有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;与 KISS 原则齐名的 DRY（Don’t Repeat Yourself）原则，强调的就是要提高代码的可复用性；&lt;/li&gt;
&lt;li&gt;有面向对象编程基础的同学，应该都知道继承、多态存在的目的之一，就是提高代码的可复用性；&lt;/li&gt;
&lt;li&gt;单一职责原则、解耦、高内聚、模块化等实践经验都能提高代码的可复用性。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;可测试性testability&quot;&gt;2.6 可测试性（testability）&lt;/h2&gt;
&lt;p&gt;这个评判维度比较少提及，但却是非常重要的代码质量评价标准。&lt;/p&gt;
&lt;p&gt;为了降低线上的故障率，我们的代码需要通过测试环节的检验。可测试性良好的代码有利于编写单元测试，有利于我们在测试环节更全面地发现问题、更快地定位到是哪些代码产生了这些问题。&lt;/p&gt;
&lt;p&gt;可测试性高的代码大多有这些特征：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;职责单一；&lt;br/&gt;输入明确（可控制）；&lt;br/&gt;输出清晰（可预测）；&lt;br/&gt;运算状态（一般是错误状态）可见；……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;设计问题没有标准答案，关键是我们要有自己的思考：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为什么有这种设计原则、思想或模式？&lt;br/&gt;它能解决什么问题？有哪些应用场景？&lt;br/&gt;该如何权衡、恰当地在项目中应用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时要认识到，上述评价维度 &lt;strong&gt;不是完全独立&lt;/strong&gt; 的，有些具有包含关系，也有的会互相影响。比如：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代码的可读性好、可扩展性好，就意味着代码的可维护性好；&lt;br/&gt;有些代码的可扩展性和可复用性好，抽象出了很多接口、类和方法，但却又导致代码的可读性和简洁性下降。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，我们摸清了好代码的样子，也知道了好代码的常见评判标准，接下来我们就要学习各类设计原则和设计思想了哦。&lt;/p&gt;
&lt;p&gt;开始期待吧 :-)&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;极客时间-王争《设计模式之美》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13.719298245614&quot;&gt;
&lt;h2 id=&quot;版权声明&quot;&gt;版权声明&lt;/h2&gt;
&lt;p&gt;作者: &lt;a href=&quot;https://healchow.com&quot;&gt;瘦风(https://healchow.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;瘦风的博客(https://www.cnblogs.com/shoufeng)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢阅读, 右侧导航栏有「瘦风的南墙」公众号二维码，输出更及时、更体系，欢迎扫码关注🤝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但 &lt;strong&gt;[必须在页面明显位置标明原文链接]&lt;/strong&gt;, 否则博主保留追究相关人士法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 15 Mar 2020 00:48:00 +0000</pubDate>
<dc:creator>瘦风</dc:creator>
<og:description>作为一个开发者，要想写出好代码，就要知道什么是好代码，以及评判代码好坏的常见标准。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shoufeng/p/12386383.html</dc:identifier>
</item>
<item>
<title>30岁码农的一次面试经历：不委屈自己 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12495854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12495854.html</guid>
<description>&lt;p&gt;记得五个月前，我去和前公司的一位领导交流，探讨“吃回头草”的可能性。因为前公司是做培训的，而我有一种强烈的预感就是，未来几年，培训行业会比之前更火。现在看起来，我当时挺有先见之明。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/03/mianshi-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;前公司一直做的是线下培训，我当时建议他们线上线下一起做。不确定他们是否采纳了我的建议，恐怕是情非得已。我在朋友圈看到几个资历老的前同事纷纷开启了线上教学的模式，甚至我还被邀请作为大牛参与到课程的体验当中。这说明线下培训的业务急需改革，线上培训的业务急需拓展了。&lt;/p&gt;
&lt;p&gt;那次谈话谈崩了。&lt;/p&gt;
&lt;p&gt;谈崩的原因很简单，薪水不符合我的预期，像我这种在互联网上混出了些小名气的，显然对薪水是有一定要求的，尽管面试的时候心态摆的很低。&lt;/p&gt;
&lt;p&gt;和我谈话的那位领导是前公司的二把手，红人一个，做事雷厉风行，取得了不少成绩，我是打心眼的佩服。我们俩畅谈了两个多小时，真可谓“英雄相惜”——不知不觉多喝了三四杯水。&lt;/p&gt;
&lt;p&gt;拿他来说吧，到这家公司之前在一家国企单位，日子过得很不错，福利待遇都好，还有自己的小酒厂。但总觉得国企束缚了自己的灵魂，就来到了这家培训公司，打算干一番事业。他的确是从基层做起，一步步拼到现在这个位置上，我当时离职的时候他还不起眼。&lt;/p&gt;
&lt;p&gt;要不是我被现在的老板骗出去创业，没准我俩现在是铁哥们。&lt;/p&gt;
&lt;p&gt;拿我来说吧，出版了一本书，名字叫做《Web全栈开发进阶之路》，博客的阅读量也非常可观，最近获得了 CSDN 的博客之星，这点成绩放眼整个互联网的话，是不足一提的。但对于洛阳这座三线城市来说，显然是首屈一指的——我是有这个自信心的。&lt;/p&gt;
&lt;p&gt;假如我去做线上培训或者线下培训，那肯定是有一定的群众基础的，这也正是他们邀请我的原因。这里需要说明一点的是，之前我做的不是讲师，而是在软件开发部任职。不管怎么说，和公司的几位高管交往得非常愉快，毕竟凭实力嘛。&lt;/p&gt;
&lt;p&gt;领导的打算是让我先到基层去锻炼锻炼，虽然他相信我的能力，但怕其他一些老同事不服气。&lt;/p&gt;
&lt;p&gt;这话不管是不是套路，我是不喜欢听的。到基层锻炼去，那我之前取得的这些成绩不都成了摆设嘛。人换了一个地方工作，之前的成绩就要一笔勾销，显然是个扯淡的想法。&lt;/p&gt;
&lt;p&gt;就好比说，人家徐庶从刘备那跳槽到曹操那，还要重新干出点业绩才叫人家任职。那折腾人家徐庶和人家妈干啥？换句话说，要我从基层干起，那就没必要邀请我去谈话嘛。&lt;/p&gt;
&lt;p&gt;所谓人往高处走水往低处流，咱不能逆转了人性啊。人都希望越过越好，没有人希望过山车。但我们的文化中似乎有这种偏见，就是你到了一个新地方，就不要谈之前的辉煌，你要从头做起，要重新证明自己，毕竟“是金子到哪都发光啊”！&lt;/p&gt;
&lt;p&gt;换句话说，到基层去锻炼就好像是要试试你的水平。还记得三国里面的庞统吧，人家是和诸葛亮齐名的啊，刘备竟然因为相貌的原因让人家到一个小小的地方历练历练，要不是张飞同学粗中有细，这块金子可就要被埋没了。刘备入蜀的可能性就大大降低了，毕竟入蜀是庞统的主意，替庞统报仇是进攻巴蜀的好幌子。&lt;/p&gt;
&lt;p&gt;话说回来，我的长相还是过得去的，算不上仪表堂堂，最起码也是玉树临风，对吧。要我去基层锻炼，意味着薪水就要大打折扣，我是万万不能同意的。&lt;/p&gt;
&lt;p&gt;再者说，没必要到基层嘛，就安排一个合适的岗位，适合我的岗位，那我也是能够证明自己的，毕竟基层的资源是有限的，既然有限，肯定会限制发展，难以释放身上四射的光芒啊。&lt;/p&gt;
&lt;p&gt;看篮球的读者前几天可能会刷到这样一条新闻，勇士队把斯蒂芬库里下放到了发展联盟，我当时在想，管理层不会脑子抽了吧？新闻后面的评论刚刷完，又一条新闻扑面而来，勇士队宣布斯蒂芬库里从发展联盟召回。嗯，管理层的脑子真的抽了。&lt;/p&gt;
&lt;p&gt;金三银四，最近是面试的高潮期，毕竟复工在即。但我奉劝各位面试官，不要心怀鬼胎，能力摆在那就是摆在那，不要总想着锻炼锻炼才能检出真金白银。如果需要锻炼后才知道水平，那要面试官干啥？&lt;/p&gt;
&lt;p&gt;肩负着伯乐的声誉，总得有点自己的方法才行，别整那些歪理。&lt;/p&gt;
&lt;p&gt;同样的，对于求职者来说，不盲目自信，也不要“忍辱负重”。自己过往的经验、荣誉是要拿出来写到简历上，摆到台面上讲出来的。信不信是面试官的事，讲不讲出来可就是我们自己的事了。&lt;/p&gt;
&lt;p&gt;当然了，前公司的领导对我不信任是可以理解的，毕竟那是人家的权力，我之前也没做过讲师。我当时的想法，除了看重培训的未来，没准自己那天就做直播了，讲师可是一个大好的锻炼机会。另外，也是想测试一下自己的影响力是否拉满——事实证明还没有，否则应该是公司一把手来面试我，而不是二把手。&lt;/p&gt;
&lt;p&gt;嗯，我当时并没有明确地拒绝，因为关系还是要维护的，领导的面子还是要给足的。到基层锻炼去是人家的行事准则，他就是那么干过来的，我虽然不喜欢他把这条准则强加到我身上，但也没必要当面纠正人家。&lt;/p&gt;
&lt;p&gt;聊完的第二天，领导主动打电话问我去不去，我只说“走不开身，想再发展发展副业”，后来就没有后来了。严格意义上说，后来有了这篇文章。&lt;/p&gt;
&lt;p&gt;我把这事写出来，就是为了劝你，该亮成绩就亮，假如面试官非要抹掉你之前的成绩，降低你的薪水，减少你的福利待遇 ，也没必要和面试官纠缠，去下一家面试就行了。&lt;/p&gt;
&lt;p&gt;千万不要委屈了自己。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了，我亲爱的读者朋友，以上就是本文的全部内容了，能看到这里的就是最优秀的程序员。&lt;strong&gt;原创不易，莫要白票，请你为本文点赞吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;666&lt;/strong&gt;】【&lt;strong&gt;1024&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类，细分到每一个视频），以及大厂技术牛人整理的面经一份，帮助了无数读者。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 15 Mar 2020 00:14:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>记得五个月前，我去和前公司的一位领导交流，探讨“吃回头草”的可能性。因为前公司是做培训的，而我有一种强烈的预感就是，未来几年，培训行业会比之前更火。现在看起来，我当时挺有先见之明。 前公司一直做的是线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12495854.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（四）之基于scikit-lean实现决策树 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12495539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12495539.html</guid>
<description>&lt;p&gt;
&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot; id=&quot;e695b0e68daee68c96e68e98e585a5e997a8e7b3bbe58897e69599e7a88befbc88e59b9befbc89e4b98be59fbae4ba8escikit-leane586b3e7ad96e6a091e5a484e79086iris_1&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;数据挖掘入门系列教程（四）之基于scikit-lean决策树处理Iris&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12490064.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，我们介绍了决策树的一些知识。如果对决策树还不是很了解的话，建议先阅读上一篇博客，在来学习这一篇。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;本次实验基于scikit-learn中的Iris数据。说了好久的Iris，从OneR到决策树，那么Iris到底长啥样呢？&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005402832-1402675181.jpg&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/iris-cycloglossa-1211.jpg&quot; data-src=&quot;imgs/iris-cycloglossa-1211.jpg&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e58aa0e8bdbde695b0e68daee99b86_2&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;加载数据集&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先我们还是需要先加载数据集，数据集来自scikit自带的iris数据集，数据集的内容可以参考以前的&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12446058.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，这里就不在赘述。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先让我们从scikit-learn中加载数据集。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sklearn.datasets &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; load_iris
dataset = load_iris()
data = dataset.data
target = dataset.target&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后我们再使用pandas将数据进行格式化以下，添加Iris的属性到数据集中。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd
data = pd.DataFrame(data,columns=[&lt;span class=&quot;hljs-string&quot;&gt;&quot;sepal_length&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;sepal_width&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;petal_length&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;petal_width&quot;&lt;/span&gt;])
data[&lt;span class=&quot;hljs-string&quot;&gt;&quot;class&quot;&lt;/span&gt;] = target&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;data的数据如下所示：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005403175-713019092.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584156903115.png&quot; data-src=&quot;imgs/1584156903115.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;class代表类别。其他的就是Iris的属性了。&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e695b0e68daee789b9e5be81_3&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;数据特征&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里我们主要是用画图来看一看Iris数据集的特征。本来以为画图就matpotlib就行了，但是没想到有seaborn这个好使用的库，来自&lt;a href=&quot;https://www.bilibili.com/video/av26086646&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;B站&lt;/a&gt;up主的提示。使用的库如下：&lt;/p&gt;
&lt;ul class=&quot;markdown_ul&quot;&gt;&lt;li&gt;matplotlib&lt;/li&gt;
&lt;li&gt;seaborn&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先我们画散点图：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; plt
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; seaborn &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; sb

sb.pairplot(data.dropna(),hue=&lt;span class=&quot;hljs-string&quot;&gt;&quot;class&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;图像如下所示：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005403411-2109142161.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/散点图.png&quot; data-src=&quot;imgs/%E6%95%A3%E7%82%B9%E5%9B%BE.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;上面的这幅图展示了在四个属性中的类别的分别情况。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;同时我们还可以画小提琴图：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;plt.figure(figsize=(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;))
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; column_index, column &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; enumerate(data.columns):
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; column == &lt;span class=&quot;hljs-string&quot;&gt;'class'&lt;/span&gt;:
        &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;
    plt.subplot(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, column_index + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    sb.violinplot(x=&lt;span class=&quot;hljs-string&quot;&gt;'class'&lt;/span&gt;, y=column, data=data)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;画出的图如下：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005403621-1565219480.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/小提琴图.png&quot; data-src=&quot;imgs/%E5%B0%8F%E6%8F%90%E7%90%B4%E5%9B%BE.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过上面的这幅图我们可以直观的比较出哪一个变量更具有代表性。比如说petal_width 对类别0更加的友好。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;接下来就是进行训练了。&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e8aeade7bb83_4&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;训练&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先的首先，我们还是需要从数据集中抽出训练集和测试集。这个内容在前面讲过了，就不多讲了。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sklearn.model_selection &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; train_test_split

input_data = data[[&lt;span class=&quot;hljs-string&quot;&gt;&quot;sepal_length&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;sepal_width&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;petal_length&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;petal_width&quot;&lt;/span&gt;]]
input_class =  data[&lt;span class=&quot;hljs-string&quot;&gt;&quot;class&quot;&lt;/span&gt;]

train_data,test_data,train_class,test_class = train_test_split(input_data,input_class,random_state = &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;then，让我们来开始进行训练吧，在scikit-learn中实现了决策树，和前面的&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12463757.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;K近邻算法&lt;/a&gt;一样我们直接引用就行，调用fit（训练）和predict（预测）函数。使用如下所示：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sklearn.tree &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; DecisionTreeClassifier

decision_tree = DecisionTreeClassifier(random_state=&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;)
decision_tree.fit(train_data,train_class)
predict_class = decision_tree.predict(test_data)
predict_score = np.mean(predict_class == test_class)
print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;预测的准确度为{}&quot;&lt;/span&gt;.format(predict_score))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;DecisionTreeClassifier其他的参数在后面说，这里主要说一下&lt;code&gt;random_state&lt;/code&gt;参数。为什么决策树还需要random_state这个参数，以下&lt;a href=&quot;https://www.zhihu.com/question/358180075/answer/941301081&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;知乎&lt;/a&gt;上面的两位博主的说法。&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005403876-1740940668.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584194821168.png&quot; data-src=&quot;imgs/1584194821168.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005404118-122994198.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584194846839.png&quot; data-src=&quot;imgs/1584194846839.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;至于哪个说法是正确的，我暂时也不知道，如果有知道的，可以在评论区留言哦！&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;最后得到的预测结果如下所示：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005404300-49711409.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584191158982.png&quot; data-src=&quot;imgs/1584191158982.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里值得注意的是&lt;code&gt;DecisionTreeClassifier()&lt;/code&gt;函数，里面可以添加很多参数。官方文档在这里： &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html&lt;/a&gt; 。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里还是稍微的说一下参数。&lt;/p&gt;

&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;更多的可以去看官网细节。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后我们可以将这个树的结构可视化，将文件保存在“tree.dot”中：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sklearn.tree &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; export_graphviz
&lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tree.dot&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'w'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; f:
    export_graphviz(decision_tree, feature_names =[&lt;span class=&quot;hljs-string&quot;&gt;'sepal_length'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'sepal_width'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'petal_length'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'petal_width'&lt;/span&gt;], out_file = f)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这个是决策树的图：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005404503-1146974895.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584190276067.png&quot; data-src=&quot;imgs/1584190276067.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;同样，我们还可以使用交叉验证，具体的使用可以参考别人的博客，或者看我的这一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12463757.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; sklearn.model_selection &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; cross_val_score
decision_tree = DecisionTreeClassifier()
scores = cross_val_score(decision_tree,input_data,input_class,scoring=&lt;span class=&quot;hljs-string&quot;&gt;'accuracy'&lt;/span&gt;)
print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;交叉验证结果: {0:.2f}%&quot;&lt;/span&gt;.format(np.mean(scores) * &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;通过交叉验证得到的准确度如下：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005404670-2036818986.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584191426643.png&quot; data-src=&quot;imgs/1584191426643.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;比上面的结果略低，不过这个是正常的。&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e99a8fe69cbae6a3aee69e97_5&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;随机森林&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;前面的博客介绍了随机树，这里不多做介绍，直接看使用吧。我们通过导入&lt;code&gt;RandomForestClassifier&lt;/code&gt;模块，并指令森林中树的个数为30，具体的参数看&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;  sklearn.ensemble &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; RandomForestClassifier
rft = RandomForestClassifier(n_estimators=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,random_state=&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;)
rft.fit(train_data,train_class)
predict_class = rft.predict(test_data)
predict_score = np.mean(predict_class == test_class)
print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;随机森林预测的准确度为{}&quot;&lt;/span&gt;.format(predict_score))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;最后的结果如下图&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005404863-1322432417.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584191633520.png&quot; data-src=&quot;imgs/1584191633520.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后进行交叉验证：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot;python&quot;&gt;scores = cross_val_score(rft,input_data,input_class,scoring=&lt;span class=&quot;hljs-string&quot;&gt;'accuracy'&lt;/span&gt;)
print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Accuracy: {0:.2f}%&quot;&lt;/span&gt;.format(np.mean(scores) * &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;结果如下：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005405031-1407502324.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584195483648.png&quot; data-src=&quot;imgs/1584195483648.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;emm，好像和上面的结果一样，因为这个数据集很小，可能会有这种情况。&lt;/p&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e8b083e58f82e5b7a5e7a88be5b888_6&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;调参工程师&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先，我们可以对决策树的max_feature和max_depth进行调参，改变其值，最终的结果如下：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005405194-1005736674.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584201176756.png&quot; data-src=&quot;imgs/1584201176756.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在随机森林中，我们可以对树的个数进行调参，结果如下图：&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202003/1439869-20200315005405394-1630298382.png&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/1584201234760.png&quot; data-src=&quot;imgs/1584201234760.png&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot; id=&quot;e7bb93e5b0be_7&quot;&gt; &lt;span class=&quot;xsj_heading_content&quot;&gt;结尾&lt;/span&gt;&lt;/h3&gt;
&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这次并没有使用《 Python数据挖掘入门与实践 》书上的例子，实在是它打篮球的数据找不到，emm。相比较与oneR算法的70%左右的正确率，决策树95%正确率已经算足够优秀了。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;尽管代码写起来很简单，也很容易实现得到结果，但是我们真正应该了解的是里面的内涵：决策树是什么？里面是怎样工作的？以及所蕴含的含义……&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/data_mining/tree/master/%E5%86%B3%E7%AD%96%E6%A0%91&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Mar 2020 16:54:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>数据挖掘入门系列教程（四）之基于scikit-lean决策树处理Iris加载数据集数据特征训练随机森林调参工程师结尾 数据挖掘入门系列教程（四）之基于scikit-lean决策树处理Iris 在上一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12495539.html</dc:identifier>
</item>
<item>
<title>SQL之开窗函数详解--可代替聚合函数使用 - 樱木007</title>
<link>http://www.cnblogs.com/hobelee/p/12495333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hobelee/p/12495333.html</guid>
<description>&lt;p&gt;       在没学习开窗函数之前，我们都知道，用了分组之后，查询字段就只能是分组字段和聚合的字段，这带来了极大的不方便，有时我们查询时需要分组，又需要查询不分组的字段，每次都要又到子查询，这样显得sql语句复杂难懂，给维护代码的人带来很大的痛苦，然而开窗函数出现了，曙光也来临了。如果要想更具体了解开窗函数，请看书《程序员的SQL金典》，开窗函数在mysql不能使用。&lt;/p&gt;
&lt;p&gt;       开窗函数与聚合函数一样，都是对行的集合组进行聚合计算。它用于为行定义一个窗口（这里的窗口是指运算将要操作的行的集合），它对一组值进行操作，不需要使用group by语句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列。定义看不懂不要紧，会用就行。&lt;/p&gt;
&lt;p&gt;       举个简单例子 查询每个工资小于5000的员工信息（姓名，城市 年龄 薪水），并且显示小于5000的员工个数，尝试使用下面语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName, FCITY, FAGE, FSalary, &lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;FROM&lt;/span&gt; T_Person &lt;span&gt;WHERE&lt;/span&gt; FSALARY&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
消息 &lt;span&gt;8120&lt;/span&gt;，级别 &lt;span&gt;16&lt;/span&gt;，状态 &lt;span&gt;1&lt;/span&gt;，第 &lt;span&gt;1&lt;/span&gt;&lt;span&gt; 行
选择列表中的列 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T_Person.FName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 无效，因为该列没有包含在聚合函数或 &lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; 子句中。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         可以使用子查询实现，语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName, FCITY, FAGE, FSalary, ( &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;FROM&lt;/span&gt; T_Person &lt;span&gt;WHERE&lt;/span&gt; FSALARY&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt; ) PersonNum &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; T_Person 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; FSALARY&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314220306983-1491875421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     使用开窗函数实现，查询结果一模一样，就不粘贴了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName, FCITY, FAGE, FSalary, &lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;OVER&lt;/span&gt;() &lt;span&gt;as&lt;/span&gt; PersonNum &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; T_Person 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; FSALARY&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1.开窗函数格式：函数名(列) OVER(选项)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.聚合开窗函数格式：聚合函数(列) OVER(PARTITION BY 字段)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      over关键字把聚合函数当成聚合开窗函数而不是聚合函数，SQL标准允许将所有的聚合函数用做聚合开窗函数。OVER关键字后的括号中还经常添加选项用以改变进行聚合运算的窗口范围。如果OVER关键字后的括号为空，则开窗函数会对结果集合的所有行进行聚合运算。&lt;/p&gt;
&lt;p&gt;      PARTITION BY来定义行的分区来进行聚合运算，与group by 不同，partition by 字句创建的分区是独立于结果集的，创建的分区只是用于进行聚合运算，而且不同的开窗函数所创建的分区不互相影响，例如：查询所有人员的信息，并查询所属城市的人员数以及同年龄的人员数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName,FCITY, FAGE, FSalary, &lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;OVER&lt;/span&gt;(PARTITION &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; FCITY) CityNum, 
&lt;/span&gt;&lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;OVER&lt;/span&gt;(PARTITION &lt;span&gt;BY&lt;/span&gt; FAGE) AgeNum &lt;span&gt;FROM&lt;/span&gt; T_Person &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; FCITY
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314223116221-1565790080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 查询所有人员的信息，并查询所属城市的人员数，每个城市的人按照年龄排序语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName,FCITY, FAGE, FSalary, &lt;span&gt;COUNT&lt;/span&gt;(FName) &lt;span&gt;OVER&lt;/span&gt;(PARTITION &lt;span&gt;BY&lt;/span&gt; FCITY &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; FAGE) CityNum &lt;span&gt;FROM&lt;/span&gt; T_Person &lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314223948990-662939797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 3.排序开窗函数格式：排序函数() OVER(ORDER BY 字段)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  (1)主要函数有ROW_NUMBER()、RANK()、DENSE_RANK()、NTILE()&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   ROW_NUMBER() 加行号，一般可以用于分页查询（现在被offset  fetch取代 ），对于没有主键列的表加行号作用很明显，删除重复数据等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  按照薪水高低给所有人员排序，同样薪水的排名不一样，可以用row_number(),&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;with&lt;/span&gt; a &lt;span&gt;as&lt;/span&gt;&lt;span&gt; 
(
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; FName, FSalary, FCity, FAge, ROW_NUMBER() &lt;span&gt;over&lt;/span&gt;(&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; FSalary) &lt;span&gt;as&lt;/span&gt; RowNum &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; T_Person 
)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; a 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314233159314-1607359307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用rank()将每个城市的薪水排行，值一样的同一个排名，出现两个第一名的时候，排在两个第一名后的排名将是第三名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; FName, FSalary, FCity, FAge, RANK() &lt;span&gt;over&lt;/span&gt;(PARTITION &lt;span&gt;BY&lt;/span&gt; FCITY &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; FSalary) &lt;span&gt;as&lt;/span&gt; RankNum &lt;span&gt;FROM&lt;/span&gt; T_Person 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314234511289-1616693166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  使用dense_rank()将每个城市的薪水排行，值一样的同一个排名，出现两个第一名的时候，排在两个第一名后的排名将是第三名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200314234629818-638703670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ntile(数字) over(order by 字段):数字表示一组多少个数，并根据数量得出分组的数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;,NTILE(&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;OVER&lt;/span&gt;(&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; FSalary) &lt;span&gt;AS&lt;/span&gt; NileNum &lt;span&gt;FROM&lt;/span&gt; T_Person
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/712869/202003/712869-20200315011343196-910430307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Mar 2020 16:00:00 +0000</pubDate>
<dc:creator>樱木007</dc:creator>
<og:description>在没学习开窗函数之前，我们都知道，用了分组之后，查询字段就只能是分组字段和聚合的字段，这带来了极大的不方便，有时我们查询时需要分组，又需要查询不分组的字段，每次都要又到子查询，这样显得sql语句复杂难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hobelee/p/12495333.html</dc:identifier>
</item>
<item>
<title>【原创】（五）Linux进程调度-CFS调度器 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/12495319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/12495319.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Completely Fair Scheduler&lt;/code&gt;，完全公平调度器，用于Linux系统中普通进程的调度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CFS&lt;/code&gt;采用了红黑树算法来管理所有的调度实体&lt;code&gt;sched_entity&lt;/code&gt;，算法效率为&lt;code&gt;O(log(n))&lt;/code&gt;。&lt;code&gt;CFS&lt;/code&gt;跟踪调度实体&lt;code&gt;sched_entity&lt;/code&gt;的虚拟运行时间&lt;code&gt;vruntime&lt;/code&gt;，平等对待运行队列中的调度实体&lt;code&gt;sched_entity&lt;/code&gt;，将执行时间少的调度实体&lt;code&gt;sched_entity&lt;/code&gt;排列到红黑树的左边。&lt;/li&gt;
&lt;li&gt;调度实体&lt;code&gt;sched_entity&lt;/code&gt;通过&lt;code&gt;enqueue_entity()&lt;/code&gt;和&lt;code&gt;dequeue_entity()&lt;/code&gt;来进行红黑树的出队入队。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;老规矩，先上张图片来直观了解一下原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235145194-204116226.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个&lt;code&gt;sched_latency&lt;/code&gt;周期内，根据各个任务的权重值，可以计算出运行时间&lt;code&gt;runtime&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;运行时间&lt;code&gt;runtime&lt;/code&gt;可以转换成虚拟运行时间&lt;code&gt;vruntime&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;根据虚拟运行时间的大小，插入到CFS红黑树中，虚拟运行时间少的调度实体放置到左边；&lt;/li&gt;
&lt;li&gt;在下一次任务调度的时候，选择虚拟运行时间少的调度实体来运行；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开始本文之前，建议先阅读下&lt;code&gt;（一）Linux进程调度器-基础&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;开始探索之旅！&lt;/p&gt;

&lt;h2 id=&quot;调度类&quot;&gt;2.1 调度类&lt;/h2&gt;
&lt;p&gt;Linux内核抽象了一个调度类&lt;code&gt;struct sched_class&lt;/code&gt;，这是一种典型的面向对象的设计思想，将共性的特征抽象出来封装成类，在实例化各个调度器的时候，可以根据具体的调度算法来实现。这种方式做到了高内聚低耦合，同时又很容易扩展新的调度器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235232449-1386087933.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调度核心代码&lt;code&gt;kernel/sched/core.c&lt;/code&gt;中，使用的方式是&lt;code&gt;task-&amp;gt;sched_class-&amp;gt;xxx_func&lt;/code&gt;，其中&lt;code&gt;task&lt;/code&gt;表示的是描述任务的结构体&lt;code&gt;struct task_struck&lt;/code&gt;，在该结构体中包含了任务所使用的调度器，进而能找到对应的函数指针来完成调用执行，有点类似于C++中的多态机制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;rqcfs_rqtask_structtask_groupsched_entity&quot;&gt;2.2 rq/cfs_rq/task_struct/task_group/sched_entity&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct rq&lt;/code&gt;：每个CPU都有一个对应的运行队列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct cfs_rq&lt;/code&gt;：CFS运行队列，该结构中包含了&lt;code&gt;struct rb_root_cached&lt;/code&gt;红黑树，用于链接调度实体&lt;code&gt;struct sched_entity&lt;/code&gt;。&lt;code&gt;rq&lt;/code&gt;运行队列中对应了一个CFS运行队列，此外，在&lt;code&gt;task_group&lt;/code&gt;结构中也会为每个CPU再维护一个CFS运行队列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct task_struct&lt;/code&gt;：任务的描述符，包含了进程的所有信息，该结构中的&lt;code&gt;struct sched_entity&lt;/code&gt;，用于参与CFS的调度；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct task_group&lt;/code&gt;：组调度（参考前文），Linux支持将任务分组来对CPU资源进行分配管理，该结构中为系统中的每个CPU都分配了&lt;code&gt;struct sched_entity&lt;/code&gt;调度实体和&lt;code&gt;struct cfs_rq&lt;/code&gt;运行队列，其中&lt;code&gt;struct sched_entity&lt;/code&gt;用于参与CFS的调度；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct sched_entity&lt;/code&gt;：调度实体，这个也是CFS调度管理的对象了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来一张图看看它们之间的组织关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235249852-1440735803.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct sched_entity&lt;/code&gt;结构体字段注释如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct sched_entity {
    /* For load-balancing: */
    struct load_weight      load;                   //调度实体的负载权重值
    struct rb_node          run_node;             //用于连接到CFS运行队列的红黑树中的节点
    struct list_head        group_node;          //用于连接到CFS运行队列的cfs_tasks链表中的节点
    unsigned int            on_rq;              //用于表示是否在运行队列中

    u64             exec_start;             //当前调度实体的开始执行时间
    u64             sum_exec_runtime;   //调度实体执行的总时间
    u64             vruntime;           //虚拟运行时间，这个时间用于在CFS运行队列中排队
    u64             prev_sum_exec_runtime;  //上一个调度实体运行的总时间

    u64             nr_migrations;      //负载均衡

    struct sched_statistics     statistics;     //统计信息

#ifdef CONFIG_FAIR_GROUP_SCHED
    int             depth;      //任务组的深度，其中根任务组的深度为0，逐级往下增加
    struct sched_entity     *parent;        //指向调度实体的父对象
    /* rq on which this entity is (to be) queued: */
    struct cfs_rq           *cfs_rq;        //指向调度实体归属的CFS队列，也就是需要入列的CFS队列
    /* rq &quot;owned&quot; by this entity/group: */
    struct cfs_rq           *my_q;      //指向归属于当前调度实体的CFS队列，用于包含子任务或子的任务组
#endif

#ifdef CONFIG_SMP
    /*
     * Per entity load average tracking.
     *
     * Put into separate cache line so it does not
     * collide with read-mostly values above.
     */
    struct sched_avg        avg ____cacheline_aligned_in_smp;   //用于调度实体的负载计算（`PELT`）
#endif
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;struct cfs_rq结构体的关键字段注释如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/* CFS-related fields in a runqueue */
struct cfs_rq {
    struct load_weight load;        //CFS运行队列的负载权重值
    unsigned int nr_running, h_nr_running;  //nr_running：运行的调度实体数（参与时间片计算）

    u64 exec_clock;     //运行时间
    u64 min_vruntime;   //最少的虚拟运行时间，调度实体入队出队时需要进行增减处理
#ifndef CONFIG_64BIT
    u64 min_vruntime_copy;
#endif

    struct rb_root_cached tasks_timeline;   //红黑树，用于存放调度实体

    /*
     * 'curr' points to currently running entity on this cfs_rq.
     * It is set to NULL otherwise (i.e when none are currently running).
     */
    struct sched_entity *curr, *next, *last, *skip; //分别指向当前运行的调度实体、下一个调度的调度实体、CFS运行队列中排最后的调度实体、跳过运行的调度实体

#ifdef  CONFIG_SCHED_DEBUG
    unsigned int nr_spread_over;
#endif

#ifdef CONFIG_SMP
    /*
     * CFS load tracking
     */
    struct sched_avg avg;       //计算负载相关
    u64 runnable_load_sum;
    unsigned long runnable_load_avg;        //基于PELT的可运行平均负载
#ifdef CONFIG_FAIR_GROUP_SCHED
    unsigned long tg_load_avg_contrib;      //任务组的负载贡献
    unsigned long propagate_avg;
#endif
    atomic_long_t removed_load_avg, removed_util_avg;
#ifndef CONFIG_64BIT
    u64 load_last_update_time_copy;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    /*
     *   h_load = weight * f(tg)
     *
     * Where f(tg) is the recursive weight fraction assigned to
     * this group.
     */
    unsigned long h_load;
    u64 last_h_load_update;
    struct sched_entity *h_load_next;
#endif /* CONFIG_FAIR_GROUP_SCHED */
#endif /* CONFIG_SMP */

#ifdef CONFIG_FAIR_GROUP_SCHED
    struct rq *rq;  /* cpu runqueue to which this cfs_rq is attached */     //指向CFS运行队列所属的CPU RQ运行队列

    /*
     * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in
     * a hierarchy). Non-leaf lrqs hold other higher schedulable entities
     * (like users, containers etc.)
     *
     * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a cpu. This
     * list is used during load balance.
     */
    int on_list;
    struct list_head leaf_cfs_rq_list;
    struct task_group *tg;  /* group that &quot;owns&quot; this runqueue */       //CFS运行队列所属的任务组

#ifdef CONFIG_CFS_BANDWIDTH
    int runtime_enabled;    //CFS运行队列中使用CFS带宽控制
    u64 runtime_expires;    //到期的运行时间
    s64 runtime_remaining;      //剩余的运行时间

    u64 throttled_clock, throttled_clock_task;  //限流时间相关
    u64 throttled_clock_task_time;
    int throttled, throttle_count;      //throttled：限流，throttle_count：CFS运行队列限流次数
    struct list_head throttled_list;    //运行队列限流链表节点，用于添加到cfs_bandwidth结构中的cfttle_cfs_rq链表中
#endif /* CONFIG_CFS_BANDWIDTH */
#endif /* CONFIG_FAIR_GROUP_SCHED */
};&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;整个流程分析，围绕着&lt;code&gt;CFS调度类实体：fair_sched_class&lt;/code&gt;中的关键函数来展开。&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;fair_sched_class&lt;/code&gt;都包含了哪些函数：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
 * All the scheduling class methods:
 */
const struct sched_class fair_sched_class = {
    .next           = &amp;amp;idle_sched_class,
    .enqueue_task       = enqueue_task_fair,
    .dequeue_task       = dequeue_task_fair,
    .yield_task     = yield_task_fair,
    .yield_to_task      = yield_to_task_fair,

    .check_preempt_curr = check_preempt_wakeup,

    .pick_next_task     = pick_next_task_fair,
    .put_prev_task      = put_prev_task_fair,

#ifdef CONFIG_SMP
    .select_task_rq     = select_task_rq_fair,
    .migrate_task_rq    = migrate_task_rq_fair,

    .rq_online      = rq_online_fair,
    .rq_offline     = rq_offline_fair,

    .task_dead      = task_dead_fair,
    .set_cpus_allowed   = set_cpus_allowed_common,
#endif

    .set_curr_task          = set_curr_task_fair,
    .task_tick      = task_tick_fair,
    .task_fork      = task_fork_fair,

    .prio_changed       = prio_changed_fair,
    .switched_from      = switched_from_fair,
    .switched_to        = switched_to_fair,

    .get_rr_interval    = get_rr_interval_fair,

    .update_curr        = update_curr_fair,

#ifdef CONFIG_FAIR_GROUP_SCHED
    .task_change_group  = task_change_group_fair,
#endif
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;runtime与vruntime&quot;&gt;3.1 runtime与vruntime&lt;/h2&gt;
&lt;p&gt;CFS调度器没有时间片的概念了，而是根据实际的运行时间和虚拟运行时间来对任务进行排序，从而选择调度。&lt;br/&gt;那么，运行时间和虚拟运行时间是怎么计算的呢？看一下流程调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235336124-91846660.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Linux内核默认的&lt;code&gt;sysctl_sched_latency&lt;/code&gt;是6ms，这个值用户态可设。&lt;code&gt;sched_period&lt;/code&gt;用于保证可运行任务都能至少运行一次的时间间隔；&lt;/li&gt;
&lt;li&gt;当可运行任务大于8个的时候，&lt;code&gt;sched_period&lt;/code&gt;的计算则需要根据任务个数乘以最小调度颗粒值，这个值系统默认为0.75ms；&lt;/li&gt;
&lt;li&gt;每个任务的运行时间计算，是用&lt;code&gt;sched_period&lt;/code&gt;值，去乘以该任务在整个CFS运行队列中的权重占比；&lt;/li&gt;
&lt;li&gt;虚拟运行的时间 = 实际运行时间 * NICE_0_LOAD / 该任务的权重；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是来看一个实例吧，以5个Task为例，其中每个Task的&lt;code&gt;nice&lt;/code&gt;值不一样（优先级不同），对应到的权重值在内核中提供了一个转换数组：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;const int sched_prio_to_weight[40] = {
 /* -20 */     88761,     71755,     56483,     46273,     36291,
 /* -15 */     29154,     23254,     18705,     14949,     11916,
 /* -10 */      9548,      7620,      6100,      4904,      3906,
 /*  -5 */      3121,      2501,      1991,      1586,      1277,
 /*   0 */      1024,       820,       655,       526,       423,
 /*   5 */       335,       272,       215,       172,       137,
 /*  10 */       110,        87,        70,        56,        45,
 /*  15 */        36,        29,        23,        18,        15,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图来了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235404514-1080589364.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cfs调度tick&quot;&gt;3.2 CFS调度tick&lt;/h2&gt;
&lt;p&gt;CFS调度器中的tick函数为&lt;code&gt;task_tick_fair&lt;/code&gt;，系统中每个调度tick都会调用到，此外如果使用了&lt;code&gt;hrtimer&lt;/code&gt;，也会调用到这个函数。&lt;br/&gt;流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235418624-1811691775.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要的工作包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更新运行时的各类统计信息，比如&lt;code&gt;vruntime&lt;/code&gt;， 运行时间、负载值、权重值等；&lt;/li&gt;
&lt;li&gt;检查是否需要抢占，主要是比较运行时间是否耗尽，以及&lt;code&gt;vruntime&lt;/code&gt;的差值是否大于运行时间等；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来一张图，感受一下&lt;code&gt;update_curr&lt;/code&gt;函数的相关信息更新吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235436775-1536215062.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务出队入队&quot;&gt;3.3 任务出队入队&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当任务进入可运行状态时，需要将调度实体放入到红黑树中，完成入队操作；&lt;/li&gt;
&lt;li&gt;当任务退出可运行状态时，需要将调度实体从红黑树中移除，完成出队操作；&lt;/li&gt;
&lt;li&gt;CFS调度器，使用&lt;code&gt;enqueue_task_fair&lt;/code&gt;函数将任务入队到CFS队列，使用&lt;code&gt;dequeue_task_fair&lt;/code&gt;函数将任务从CFS队列中出队操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235453309-1613887161.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;出队与入队的操作中，核心的逻辑可以分成两部分：1）更新运行时的数据，比如负载、权重、组调度的占比等等；2）将sched_entity插入红黑树，或者从红黑树移除；&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;dequeue_task_fair&lt;/code&gt;大体的逻辑类似，不再深入分析；&lt;/li&gt;
&lt;li&gt;这个过程中，涉及到了&lt;code&gt;CPU负载计算&lt;/code&gt;、&lt;code&gt;task_group组调度&lt;/code&gt;、&lt;code&gt;CFS Bandwidth带宽控制&lt;/code&gt;等，这些都在前边的文章中分析过，可以结合进行理解；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;任务创建&quot;&gt;3.3 任务创建&lt;/h2&gt;
&lt;p&gt;在父进程通过&lt;code&gt;fork&lt;/code&gt;创建子进程的时候，&lt;code&gt;task_fork_fair&lt;/code&gt;函数会被调用，这个函数的传入参数是子进程的&lt;code&gt;task_struct&lt;/code&gt;。该函数的主要作用，就是确定子任务的&lt;code&gt;vruntime&lt;/code&gt;，因此也能确定子任务的调度实体在红黑树RB中的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;task_fork_fair&lt;/code&gt;本身比较简单，流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235512671-756343968.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务选择&quot;&gt;3.4 任务选择&lt;/h2&gt;
&lt;p&gt;每当进程任务切换的时候，也就是&lt;code&gt;schedule&lt;/code&gt;函数执行时，调度器都需要选择下一个将要执行的任务。&lt;br/&gt;在CFS调度器中，是通过&lt;code&gt;pick_next_task_fair&lt;/code&gt;函数完成的，流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235527658-222083399.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当需要进程任务切换的时候，&lt;code&gt;pick_next_task_fair&lt;/code&gt;函数的传入参数中包含了需要被切换出去的任务，也就是&lt;code&gt;pre_task&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;pre_task&lt;/code&gt;不是普通进程时，也就是调度类不是CFS，那么它就不使用&lt;code&gt;sched_entity&lt;/code&gt;的调度实体来参与调度，因此会执行&lt;code&gt;simple&lt;/code&gt;分支，通过&lt;code&gt;put_pre_task&lt;/code&gt;函数来通知系统当前的任务需要被切换，而不是通过&lt;code&gt;put_prev_entity&lt;/code&gt;函数来完成；&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;pre_task&lt;/code&gt;是普通进程时，调用&lt;code&gt;pick_next_entity&lt;/code&gt;来选择下一个执行的任务，这个选择过程实际是有两种情况：当调度实体对应task时，&lt;code&gt;do while()&lt;/code&gt;遍历一次，当调度实体对应&lt;code&gt;task_group&lt;/code&gt;是，则需要遍历任务组来选择下一个执行的任务了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put_prev_entity&lt;/code&gt;，用于切换任务前的准备工作，更新运行时的统计数据，并不进行&lt;code&gt;dequeue&lt;/code&gt;的操作，其中需要将CFS队列的&lt;code&gt;curr&lt;/code&gt;指针置位成NULL；&lt;/li&gt;
&lt;li&gt;set_next_entity，用于设置下一个要运行的调度实体，设置CFS队列的&lt;code&gt;curr&lt;/code&gt;指针；&lt;/li&gt;
&lt;li&gt;如果使能了&lt;code&gt;hrtimer&lt;/code&gt;，则将&lt;code&gt;hrtimer&lt;/code&gt;的到期时间设置为调度实体的剩余运行时间；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;暂且分析到这吧，CFS调度器涵盖的内容还是挺多的，&lt;code&gt;fair.c&lt;/code&gt;一个文件就有将近一万行代码，相关内容的分析也分散在前边的文章中了，感兴趣的可以去看看。&lt;/p&gt;
&lt;p&gt;打完收工，洗洗睡了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202003/1771657-20200314235543748-58494634.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Mar 2020 15:57:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 By 鲁迅 By 高尔基 说明： 1. Kernel版本：4.14 2. ARM64处理器，Contex A53，双核 3. 使用工具：Source Insight 3.5， Visio 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/12495319.html</dc:identifier>
</item>
<item>
<title>OpenCV3入门（十三）图像运动模糊 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12495168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12495168.html</guid>
<description>&lt;h2&gt;1、原理&lt;/h2&gt;
&lt;p&gt;运动模糊产生： 由于相机传感器或物体相对运动， 按快门瞬间造成图像产生运动模糊。&lt;/p&gt;
&lt;p&gt;在用摄像机获取景物图像时，如果在相机曝光期间景物和摄像机之间存在相对运动，例如用照相机拍摄快速运动的物体，或者从行驶中的汽车上拍摄外面静止不动的景物时，拍得的照片都可能存在模糊的现象，这种由于相对运动造成图像模糊现象就是运动模糊。运动模糊是一种图片“退化”现象，无法反应真实的场景。&lt;/p&gt;
&lt;p&gt;假设图像f(x,y)进行平面运动，x(t0)和y(t0)分别是在x和y方向上随时间变化的量。那么介质上（如胶片或数字存储器）上任意点的曝光总数是通过对时间间隔内瞬间曝光量的积分得到的， 图像系统的快门在该段时间是开着的。假设快门开关所用的时间很短，因此光学成像过程不会受到图像运动干扰。运动模糊产生式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/743748/202003/743748-20200314232103290-165256569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; g(x,y)： 代表运动模糊后在坐标(x,y)的结果&lt;/p&gt;
&lt;p&gt;T：代表曝光时间&lt;/p&gt;
&lt;h2&gt;2、实现过程&lt;/h2&gt;
&lt;p&gt;1）对图像方向分解为x和y方向；&lt;/p&gt;
&lt;p&gt;2）因为图像Mat坐标对应图像的正下，所以翻转Y轴；&lt;/p&gt;
&lt;p&gt;3）分别计算图像位移；&lt;/p&gt;
&lt;p&gt;4）合并多个像素，防止溢出求平均值。&lt;/p&gt;
&lt;h2&gt;3、代码实例&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;实验代码如下。只是简单的实现了模糊原理，没有考虑加性噪声n(x)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; MotionBlur(Mat&amp;amp; img, Mat&amp;amp; dst, &lt;span&gt;int&lt;/span&gt; angle, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; distance)
{
    angle &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;*angle % &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; radian = ((&lt;span&gt;double&lt;/span&gt;)angle + &lt;span&gt;180.0&lt;/span&gt;) / &lt;span&gt;180.0&lt;/span&gt;*&lt;span&gt;3.1415926&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dx = (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;double&lt;/span&gt;)distance* cos(radian) + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dy = (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;double&lt;/span&gt;)distance* sin(radian) + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sign = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; img.rows;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; img.cols;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; chns =&lt;span&gt; img.channels();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dst.empty())    dst.create(height, width, img.type());
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, k；
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i0=&lt;span&gt;0&lt;/span&gt;, j0=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, p, sum, count;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;)
    {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* dstData = (unsigned &lt;span&gt;char&lt;/span&gt;*)dst.data + dst.step*&lt;span&gt;i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; chns; k++&lt;span&gt;)
            {
                sum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                sign &lt;/span&gt;= (dx &amp;gt; &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (p = &lt;span&gt;0&lt;/span&gt;; p &amp;lt; abs(dx); p++&lt;span&gt;)
                {
                    i0 &lt;/span&gt;=&lt;span&gt; i; 
                    j0 &lt;/span&gt;= j+p *&lt;span&gt; sign;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i0 &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; i0 &amp;lt; height &amp;amp;&amp;amp; j0 &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j0 &amp;lt;&lt;span&gt; width)
                    {
                        count&lt;/span&gt;++&lt;span&gt;;
                        sum &lt;/span&gt;+= img.at&amp;lt;Vec3b&amp;gt;&lt;span&gt;(i0, j0)[k];
                    }
                }
                sign &lt;/span&gt;= (dy &amp;gt; &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (p = &lt;span&gt;0&lt;/span&gt;; p &amp;lt; abs(dy); p++&lt;span&gt;)
                {
                    i0 &lt;/span&gt;= i + p *&lt;span&gt; sign;
                    j0 &lt;/span&gt;=&lt;span&gt; j; 
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i0 &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; i0 &amp;lt; height &amp;amp;&amp;amp; j0 &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j0 &amp;lt;&lt;span&gt; width)
                    {
                        count&lt;/span&gt;++&lt;span&gt;;
                        sum &lt;/span&gt;+= img.at&amp;lt;Vec3b&amp;gt;&lt;span&gt;(i0, j0)[k];
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    dstData[j&lt;/span&gt;*chns + k] = img.at&amp;lt;Vec3b&amp;gt;&lt;span&gt;(i0, j0)[k];
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    dstData[j&lt;/span&gt;*chns + k] = saturate_cast&amp;lt;uchar&amp;gt;(sum / (&lt;span&gt;double&lt;/span&gt;)count + &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);
                }

            }            
        }
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; test_motion()
{
    Mat src_img &lt;/span&gt;= imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic14.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, src_img);

    Mat dst_img;
    MotionBlur(src_img, dst_img, &lt;/span&gt;&lt;span&gt;180&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;motion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dst_img);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、测试&lt;/h2&gt;
&lt;p&gt;测试1：验证模糊的方向，输入棋盘格图，输出为不同方向的模糊效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/743748/202003/743748-20200314232254614-1063047975.png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出效果图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/743748/202003/743748-20200314232351514-2095193027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试2：模糊效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/743748/202003/743748-20200314232431986-1640023585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试3：模糊效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/743748/202003/743748-20200314233240285-1501053900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、参考文献&lt;/h2&gt;
&lt;p&gt;1、Motion Deblur Filter&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/3.4/d1/dfd/tutorial_motion_deblur_filter.html&quot;&gt;https://docs.opencv.org/3.4/d1/dfd/tutorial_motion_deblur_filter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、图像复原与重建篇——运动模糊&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jmu201521121021/article/details/80634361&quot;&gt;https://blog.csdn.net/jmu201521121021/article/details/80634361&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、PhotoShop算法实现进阶-模糊滤镜-运动模糊（二十四）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kezunhai/article/details/41757681&quot;&gt;https://blog.csdn.net/kezunhai/article/details/41757681&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、《OpenCV3 编程入门》，电子工业出版社，毛星雨著&lt;/p&gt;
&lt;p&gt;5、《学习OpenCV》，清华大学出版社，Gary Bradski， Adrian kaehler著&lt;/p&gt;
&lt;blockquote readability=&quot;2.9382716049383&quot;&gt;
&lt;p&gt;技术博客，转载请注明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12495168.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12495168.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 14 Mar 2020 15:28:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>OpenCV3入门（十三）图像运动模糊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12495168.html</dc:identifier>
</item>
<item>
<title>Dubbo监控中心 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12495119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12495119.html</guid>
<description>&lt;p&gt;Dubbo-admin管理控制台目前还没有正式发布,但是源码已托管在github上,我们可以自行下载使用;&lt;/p&gt;
&lt;p&gt;目前的管理控制台已经发布0.1版本，结构上采取了前后端分离的方式，前端使用Vue和Vuetify分别作为Javascript框架和UI框架，后端采用Spring Boot框架。既可以按照标准的Maven方式进行打包，部署，也可以采用前后端分离的部署方式，方便开发，功能上，目前具备了服务查询，服务治理(包括Dubbo2.7中新增的治理规则)以及服务测试三部分内容。&lt;/p&gt;
&lt;p&gt;因为是源码,所以我们如果是开发过程的话可以直接使用ide运行,部署则需要先进行打包&lt;/p&gt;

&lt;h5 id=&quot;下载源码&quot;&gt;下载源码&lt;/h5&gt;
&lt;p&gt;使用git命令,或是其他任何git工具从仓库克隆获取源码&lt;/p&gt;
&lt;p&gt;地址: &lt;a href=&quot;https://github.com/apache/dubbo-admin.git&quot; class=&quot;uri&quot;&gt;https://github.com/apache/dubbo-admin.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;克隆:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git clone https://github.com/apache/dubbo-admin.git&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;根据部署需求修改配置文件&quot;&gt;根据部署需求修改配置文件&lt;/h5&gt;
&lt;p&gt;文件位置:&lt;code&gt;dubbo-admin-server/src/main/resources/application.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#配置中心  统一管理公共配置
admin.config-center=zookeeper://127.0.0.1:2181
#注册中心  
admin.registry.address=zookeeper://127.0.0.1:2181
#元数据中心  将元数据信息保存到独立的key-value的存储中,降低注册中心网络开销
#包括 provide和consumer中独有的信息不需要被共享
#(元数据)provider的接口信息,方法信息等   可以放在zookeeper或是redis
admin.metadata-report.address=zookeeper://127.0.0.1:2181
# 默认端口8080 如需修改则添加配置
server.port=8080&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打包项目&quot;&gt;打包项目&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#进入源码根目录下
cd dubbo-admin
#打包
mvn clean package
#若无法通过测试 如注册中心未启动啥的 可用下面的命令跳过测试
mvn install -DskipTests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是第一次打包需要下载大量的依赖包,&lt;/p&gt;
&lt;h5 id=&quot;问题解决&quot;&gt;问题解决&lt;/h5&gt;
&lt;p&gt;1.默认会下载node9.1.1到maven仓库,下载速度非常慢,如果下载不超过也会导致无法继续打包,我们可以手动从镜像下载后放入maven仓库&lt;/p&gt;
&lt;p&gt;镜像地址:&lt;a href=&quot;https://mirrors.sjtug.sjtu.edu.cn/nodejs-release/v9.11.1/node-v9.11.1-darwin-x64.tar.gz&quot; class=&quot;uri&quot;&gt;https://mirrors.sjtug.sjtu.edu.cn/nodejs-release/v9.11.1/node-v9.11.1-darwin-x64.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231705230-1348871187.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完成后将压缩包放置上图中的本地仓库路径下,然后重新执行打包&lt;/p&gt;
&lt;p&gt;2.根据每台机器配置不同某些路径可能没有执行权限,根据错误信息授权即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231730417-1093488522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加执行权限:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chmod + x /Users/jerry/git/dubbo-admin/dubbo-admin-ui/node/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若打包成功则会看见maven标志性的build success&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231259523-888163401.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;部署分为两种方式&lt;/p&gt;
&lt;h5 id=&quot;前后端不分离&quot;&gt;前后端不分离:&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#jar文件位置: dubbo-admin/dubbo-admin-distribution/target/dubbo-admin-0.1.jar
java -jar dubbo-admin-0.1.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于zookeeper使用了netty来实现网络服务,netty会占用8080端口,导致dubbo-admin中的tomcat无法启动,有两种方式指定端口&lt;/p&gt;
&lt;p&gt;1.修改配置文件,需要重新打包部署&lt;/p&gt;
&lt;p&gt;2.启动时添加参数指定端口&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;java -jar dubbo-admin-0.1.jar --server.port=8081&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;前后端分离&quot;&gt;前后端分离:&lt;/h5&gt;
&lt;p&gt;前后端分离可以更方便的修改前端页面,使用nodejs作为前端服务器&lt;/p&gt;
&lt;p&gt;安装nodejs:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;wget https://npm.taobao.org/mirrors/node/v9.9.0/node-v9.9.0-linux-x64.tar.gz
ln -s ~/node-v9.9.0-linux-x64/bin/node /usr/bin/node
ln -s ~/node-v9.9.0-linux-x64/bin/npm /usr/bin/npx
ln -s ~/node-v9.9.0-linux-x64/bin/npm /usr/bin/npm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改node配置文件:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim ~/dubbo-admin/dubbo-admin-ui/config/index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231327939-779619171.png&quot; alt=&quot;image-20200312121025515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署成功后可以通过配置文件中dubbo-admin配置文件中指定的用户名和密码登录到监控中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们启动测试工程发布一个服务就可以在监控中心看见服务信息;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231347614-1010110303.png&quot; alt=&quot;image-20200312121025515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别注意:在监控中心添加的配置会覆盖provide以及consumer中的配置,优先级是最高的;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用Dubbo将前期练习项目CRM重构为分布式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231412127-1809437863.png&quot; alt=&quot;image-20200312121025515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构后构架:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231433956-1395386755.png&quot; alt=&quot;image-20200312121025515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工程结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231455149-734668941.png&quot; alt=&quot;image-20200312121025515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后必须要强调的一点,若某个非内置类型的对象需要在dubbo协议中传递时(例如User,Customer)则必须保证该类型实现了Serializable接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;错误:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440878/202003/1440878-20200314231509511-1915695421.png&quot;/&gt;&lt;br/&gt;curator-framework版本太低&lt;/p&gt;
&lt;p&gt;若需源码请私信&lt;/p&gt;
</description>
<pubDate>Sat, 14 Mar 2020 15:16:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>Dubbo admin管理控制台目前还没有正式发布,但是源码已托管在github上,我们可以自行下载使用; 目前的管理控制台已经发布0.1版本，结构上采取了前后端分离的方式，前端使用Vue和Vueti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12495119.html</dc:identifier>
</item>
<item>
<title>React-redux: React.js 和 Redux 架构的结合 - 阿林十一</title>
<link>http://www.cnblogs.com/alsy/p/12469323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alsy/p/12469323.html</guid>
<description>&lt;p&gt;通过&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/alsy/p/12469317.html&quot;&gt;Redux 架构理解&lt;/a&gt;我们了解到 Redux 架构的 store、action、reducers 这些基本概念和工作流程。我们也知道了 Redux 这种架构模式可以和其他的前端库组合使用，而 React-redux 正是把 Redux 这种架构模式和 React.js 结合起来的一个库。&lt;/p&gt;
&lt;h2&gt;Context&lt;/h2&gt;
&lt;p&gt;在 React 应用中，数据是通过 props 属性自上而下进行传递的。如果我们应用中的有很多组件需要共用同一个数据状态，可以通过状态提升的思路，将共同状态提升到它们的公共父组件上面。但是我们知道这样做是非常繁琐的，而且代码也是难以维护的。这时会考虑使用 Context，Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。也就是说在一个组件如果设置了 context，那么它的子组件都可以直接访问到里面的内容，而不用通过中间组件逐级传递，就像一个全局变量一样。&lt;/p&gt;
&lt;p&gt;在 App -&amp;gt; Toolbar -&amp;gt; ThemedButton 使用 props 属性传递 theme，Toolbar 作为中间组件将 theme 从 App 组件 传递给 ThemedButton 组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Toolbar theme=&quot;dark&quot; /&amp;gt;;
&lt;span&gt;  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Toolbar(props) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为必须将这个值层层传递所有组件。&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;div&amp;gt;
      &amp;lt;ThemedButton theme={props.theme} /&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  );
}

class ThemedButton extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Button theme={&lt;span&gt;this&lt;/span&gt;.props.theme} /&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 context，就可以避免通过中间元素传递 props 了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 为当前的 theme 创建一个 context（“light”为默认值）。&lt;/span&gt;
const ThemeContext = React.createContext('light'&lt;span&gt;);

class App extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无论多深，任何组件都能读取这个值。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个例子中，我们将 “dark” 作为当前的值传递下去。&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;ThemeContext.Provider value=&quot;dark&quot;&amp;gt;
        &amp;lt;Toolbar /&amp;gt;
      &amp;lt;/ThemeContext.Provider&amp;gt;
&lt;span&gt;    );
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中间的组件再也不必指明往下传递 theme 了。&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Toolbar(props) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;div&amp;gt;
      &amp;lt;ThemedButton /&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  );
}

class ThemedButton extends React.Component {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定 contextType 读取当前的 theme context。&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; React 会往上找到最近的 theme Provider，然后使用它的值。&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个例子中，当前的 theme 值为 “dark”。&lt;/span&gt;
  static contextType =&lt;span&gt; ThemeContext;
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Button theme={&lt;span&gt;this&lt;/span&gt;.context} /&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然解决了状态传递的问题却引入了 2 个新的问题。&lt;/p&gt;
&lt;p&gt;1. 我们引入的 context 就像全局变量一样，里面的数据可以被子组件随意更改，可能会导致程序不可预测的运行。&lt;/p&gt;
&lt;p&gt;2. context 极大地增强了组件之间的耦合性，使得组件的复用性变差，比如 ThemedButton 组件因为依赖了 context 的数据导致复用性变差。&lt;/p&gt;
&lt;p&gt;我们知道，redux 不正是提供了管理共享状态的能力嘛，我们只要通过 redux 来管理 context 就可以啦，第一个问题就可以解决了。&lt;/p&gt;

&lt;h2&gt;Provider 组件&lt;/h2&gt;
&lt;p&gt;React-Redux 提供 &lt;code&gt;Provider &lt;/code&gt;组件，利用了 react 的 context 特性，将 store 放在了 context 里面，使得该组件下面的所有组件都能直接访问到 store。大致实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Provider extends Component {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getChildContext 这个方法就是设置 context 的过程，它返回的对象就是 context，所有的子组件都可以访问到这个对象&lt;/span&gt;
&lt;span&gt;  getChildContext() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      store: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.store
    };
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.children;
  }
}

Provider.childContextTypes &lt;/span&gt;=&lt;span&gt; {
  store: React.PropTypes.object
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么我们可以这么使用，将 Provider 组件作为根组件将我们的应用包裹起来，那么整个应用的组件都可以访问到里面的数据了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import React, { Component } &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;'react';&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import ReactDOM &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-string&quot;&gt;'react-dom';&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;import { Provider } from 'react-redux';&lt;span&gt;
import { createStore } from &lt;/span&gt;'redux';&lt;span&gt;
import todoApp from &lt;/span&gt;'./reducers';&lt;span&gt;
import App from &lt;/span&gt;'./components/App';&lt;span&gt;

const store &lt;/span&gt;=&lt;span&gt; createStore(todoApp);

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById('root'&lt;span&gt;)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;展示（Dumb Components）组件和容器（Smart Components）组件&lt;/h2&gt;
&lt;p&gt;还记得我们的第二个问题吗？组件因为 context 的侵入而变得不可复用。React-Redux 为了解决这个问题，将所有组件分成两大类：展示组件和容器组件。&lt;/p&gt;
&lt;h3&gt;展示组件&lt;/h3&gt;
&lt;p&gt;展示组件有几个特征&lt;/p&gt;
&lt;p&gt;1. 组件只负责 UI 的展示，没有任何业务逻辑&lt;/p&gt;
&lt;p&gt;2. 组件没有状态，即不使用 this.state&lt;/p&gt;
&lt;p&gt;3. 组件的数据只由 props 决定&lt;/p&gt;
&lt;p&gt;4. 组件不使用任何 Redux 的 API&lt;/p&gt;

&lt;p&gt;展示组件就和纯函数一样，返回结果只依赖于它的参数，并且在执行过程里面没有副作用，让人觉得非常的靠谱，可以放心的使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import PropTypes from &lt;/span&gt;'prop-types'&lt;span&gt;;

class Title extends Component {
  static propTypes &lt;/span&gt;=&lt;span&gt; {
    title: PropTypes.string
  }

  render () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;h1&amp;gt;{ &lt;span&gt;this&lt;/span&gt;.props.title }&amp;lt;/h1&amp;gt;
&lt;span&gt;    )
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像这个 Title 组件就是一个展示组件，组件的结果完全由外部传入的 title 属性决定。&lt;/p&gt;
&lt;h3&gt;容器组件&lt;/h3&gt;
&lt;p&gt;容器组件的特征则相反&lt;/p&gt;
&lt;p&gt;1. 组件负责管理数据和业务逻辑，不负责 UI 展示&lt;/p&gt;
&lt;p&gt;2. 组件带有内部状态&lt;/p&gt;
&lt;p&gt;3. 组件的数据从 Redux state 获取&lt;/p&gt;
&lt;p&gt;4. 使用 Redux 的 API&lt;/p&gt;

&lt;p&gt;你可以直接使用 &lt;code&gt;store.subscribe()&lt;/code&gt; 来手写容器组件，但是不建议这么做,因为这样无法使用 React-redux 带来的性能优化。&lt;/p&gt;
&lt;p&gt;React-redux 规定，所有的展示组件都由用户提供，容器组件则是由 React-Redux 的 &lt;code&gt;connect()&lt;/code&gt; 自动生成。&lt;/p&gt;

&lt;h2&gt;高阶组件 Connect &lt;/h2&gt;
&lt;p&gt;React-redux 提供 &lt;code&gt;connect &lt;/code&gt;方法，可以将我们定义的展示组件生成容器组件。connect 函数接受一个展示组件参数，最后会返回另一个容器组件回来。所以 connect 其实是一个高阶组件（高阶组件就是一个函数，传给它一个组件，它返回一个新的组件）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import { connect } from 'react-redux'&lt;span&gt;;
import Header from &lt;/span&gt;'../components/Header'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect()(Header);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，Header 就是一个展示组件，经过 connect 处理后变成了容器组件，最后把它导出成模块。这个容器组件没有定义任何的业务逻辑，所有不能做任何事情。我们可以通过 &lt;code&gt;mapStateToProps &lt;/code&gt;和 &lt;code&gt;mapDispatchToProps 来定义我们的业务逻辑。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import { connect } from 'react-redux'&lt;span&gt;;
import Title from &lt;/span&gt;'../components/Title'&lt;span&gt;;

const mapStateToProps &lt;/span&gt;= (state) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    title: state.title
  }
}

const mapDispatchToProps &lt;/span&gt;= (dispatch) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    onChangeColor: (color) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      dispatch({ type: &lt;/span&gt;'CHANGE_COLOR'&lt;span&gt;, color });
    }
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(Title);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mapStateToProps 告诉 connect 我们要取 state 里的 title 数据，最终 title 数据会以 props 的方式传入 Title 这个展示组件。&lt;/p&gt;
&lt;p&gt;mapStateToProps &lt;code&gt;还&lt;/code&gt;会订阅 Store，每当 state 更新的时候，就会自动执行，重新计算展示组件的参数，从而触发展示组件的重新渲染。&lt;/p&gt;
&lt;p&gt;mapDispatchToProps 告诉 connect 我们需要 dispatch action，最终 onChangeColor 会以 props 回调函数的方式传入 Title 这个展示组件。&lt;/p&gt;

&lt;p&gt;Connect 组件大概的实现如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
export const connect = (mapStateToProps, mapDispatchToProps) =&amp;gt; (WrappedComponent) =&amp;gt;&lt;span&gt; {
  class Connect extends Component {
    static contextTypes &lt;/span&gt;=&lt;span&gt; {
      store: PropTypes.object
    }

    constructor () {
      super()
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
        allProps: {}
      }
    }

    componentWillMount () {
      const { store } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._updateProps()
      store.subscribe(() &lt;/span&gt;=&amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._updateProps())
    }

    _updateProps () {
      const { store } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context
      let stateProps &lt;/span&gt;=&lt;span&gt; mapStateToProps
        &lt;/span&gt;? mapStateToProps(store.getState(), &lt;span&gt;this&lt;/span&gt;.props) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 Store 的 state 和容器组件的 state 传入 mapStateToProps&lt;/span&gt;
        : {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 mapStateToProps 是否传入&lt;/span&gt;
      let dispatchProps =&lt;span&gt; mapDispatchToProps
        &lt;/span&gt;? mapDispatchToProps(store.dispatch, &lt;span&gt;this&lt;/span&gt;.props) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 dispatch 方法和容器组件的 state 传入 mapDispatchToProps&lt;/span&gt;
        : {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断 mapDispatchToProps 是否传入&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
        allProps: {
          ...stateProps,
          ...dispatchProps,
          ...&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props
        }
      })
    }

    render () {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 state.allProps 展开以容器组件的 props 传入&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &amp;lt;WrappedComponent {...&lt;span&gt;this&lt;/span&gt;.state.allProps} /&amp;gt;
&lt;span&gt;    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Connect
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，我们就很清楚了，原来 React-redux 就是通过 Context 结合 Redux 来实现 React 应用的状态管理，通过 Connect 这个高阶组件来实现展示组件和容器组件的连接的。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Mar 2020 14:39:00 +0000</pubDate>
<dc:creator>阿林十一</dc:creator>
<og:description>通过Redux 架构理解我们了解到 Redux 架构的 store、action、reducers 这些基本概念和工作流程。我们也知道了 Redux 这种架构模式可以和其他的前端库组合使用，而 Rea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/alsy/p/12469323.html</dc:identifier>
</item>
<item>
<title>何为内存重排序？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12485743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12485743.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;我们知道对于我们所编写的代码通过计算机如何顺序执行以源代码编写的指令，程序只是处理器自上而下执行的文本文件中列出的操作列表，其实这是错误的理解，计算机能够根据需要更改某些低级操作的顺序，尤其是在读取和写入内存时，出于性能原因，会进行内存重排序，内存重排序是一种利用指令来进行对应操作，通过这种操作极大地提高了程序的速度，但是，另一方面，它可能对无锁多线程造成严重破坏性，本节我们来分析何为重排序。&lt;/p&gt;
&lt;h2&gt;何为重排序&lt;/h2&gt;
&lt;p&gt;程序被加载到主内存中以便执行，CPU的任务是运行存储在其中的指令，并在必要时读取和写入数据，那么具体CPU具体是如何操作的呢？获取指令、解码从主存储器中加载所有所需数据的指令、执行指令、将生成的结果写回并存储到主内存中。现代CPU能够每纳秒执行十条指令，但是需要数十纳秒才能从主内存中获取一些数据，与处理器相比，这种类型的内存变得非常慢，为了减少加载和存储操作中的延迟，因此操作系统为CPU配备了一个很小但又非常快的特殊内存块，称为缓存，所以CPU将使用寄存器-缓存，高速缓存是处理器存储其最常使用的数据的地方，以避免与主内存的缓慢交互，当处理器需要读取或写入主内存时，它首先检查该数据的副本在其自己的缓存中是否可用，如果是这样，则处理器直接读取或写入高速缓存，而不必等待较慢的主内存响应，现代的CPU由多个内核组成—执行实际计算的组件，每个内核都有自己的缓存块，该缓存块又连接到主内存，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200314173104985-2138748289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体地说，解码模块可以具有一个派遣队列，在该队列中，提取的指令将保留，直到其请求的数据从主内存加载到缓存中或它们的从属指令完成为止，当一些指令正在等待（或停顿）时，就绪的指令会同时解码并下推到管道中，如果旧数据尚未在高速缓存中，则回写模块会将存储请求放入存储缓冲区中（高速缓存控制器按高速缓存行存储和加载数据，每条高速缓存行通常大于单个内存访问），并开始处理下一条独立指令。在将旧数据放入缓存后，或者如果它已经在缓存中，指令将使用新结果覆盖缓存，最终，新数据将最终根据不同的策略异步刷新到主内存（例如，当必须从高速缓存中为新的高速缓存行或与其他数据一起以批处理方式处理数据时），总而言之，通过加入缓存使计算机运行速度更快， 或者说它可以使处理器始终保持忙碌和高效的状态，从而帮助处理器因等待主内存响应避免浪费不必要的时间。 &lt;/p&gt;

&lt;div class=&quot;tlid-results-container results-container&quot;&gt;
&lt;div class=&quot;tlid-result result-dict-wrapper&quot;&gt;
&lt;div class=&quot;result tlid-copy-target&quot;&gt;
&lt;div class=&quot;text-wrap tlid-copy-target&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;result-shield-container tlid-copy-target&quot; readability=&quot;32&quot;&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;很显然，这种缓存机制会增加多核操作系统复杂性，有了缓存我们将需要详细的规则来确定数据如何在不同的缓存之间流动，也就是使得各个缓存副本中的数据一致性以此确保每个内核都具有最新的版本，它们被称为缓存一致性协议（高速缓存一致性是最重要的问题，它由于增加了芯片多处理器上的内核数量以及将在这些处理器上运行的共享内存程序而迅速影响了多核处理器的性能。 “窥探协议”和“基于目录的协议”是用于实现缓存之间一致性的两种协议，这些协议的主要目的是实现多核处理器的高速缓存中数据值的一致性和验证，以便通过任何高速缓存读取存储器地址都将返回写入该地址的最新数据），可能会导致巨大的性能损失，因此，操作系统则使用内存重排序技巧，以充分利用每个内核，内存重新排序可能有几个原因，例如，考虑两个被指令访问主内存中相同数据块的内核，内核A从内存中读取，内核B对其进行写入，可能会迫使内核A等待，而内核B将其本地缓存的数据写回到主内存中，以便内核A可以读取到最新信息，等待中的内核可能会选择提前运行其他内存指令，而不是浪费宝贵的时间而不做任何事情，启用某些优化后，编译器和虚拟机也可以自由地重新排序指令，这些更改在编译时发生，可以通过查看汇编代码或字节码知道，软件内存重排序以利用基础硬件可能提供的任何功能，只是为了使代码运行更快。我们来看如下代码：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadWriteDemo {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; A = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; B = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CPU1 (thread1) runs this method&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer() {
        A &lt;/span&gt;= 10&lt;span&gt;;  
        B &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CPU2 (thread2) runs this method&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;B)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        System.out.println(A &lt;/span&gt;== 10&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编写上述代码后，我们会假设write方法将在reader方法执行之前完成，在理想情况下这种假设正确无疑，但是，如果使用CPU寄存器的缓存和缓冲，这种假设将可能是错误的，例如，如果字段B已经在高速缓存中，而A不在，则B可以早于A存入主内存，即使A和B都在高速缓存中，B仍有可能早于A存入主内存或者A从主内存中先加载到B之前或者A在B存储前加载之前等类似多种可能性结果，简而言之，&lt;span&gt;将语句在原始代码中的排序方式称为程序顺序，单个内存引用（加载或存储）完成的顺序称为执行顺序，由于CPU高速缓存，缓冲区和推测性执行在指令完成时间上增加了太多的异步性，因此执行顺序不一定与其程序顺序相同，这就是CPU中执行重排序的方式。&lt;/span&gt;如果程序是单线程或者方法writer中的字段A和B仅由一个线程访问，我们实际上并不用关心重排序，因为方法writer中的两个存储区是独立的，即使两个存储被重排序。但是，如果程序为多线程，那么可能需要考虑执行顺序，例如，CPU1执行方法writer，而CPU2执行方法reader，&lt;span&gt;由于线程使用共享的主内存进行通信，并且由于CPU缓存一致性协议，缓存对访问是透明的&lt;/span&gt;，因此当从内存中加载数据时，如果从未从任何CPU加载过数据，则从主内存中获取，如果该CPU拥有数据，则为来自另一个CPU的高速缓存，如果拥有数据，则为来自其自身的高速缓存，如果CPU1无序执行方法writer，则上述打印出false，即使CPU1按照程序顺序执行了方法writer，打印结果仍有可能为false，因为CPU2可以在执行while语句时之前执行打印结果，因为从逻辑上讲，在完成while语句之后才应该打印结果（这称为控制依赖），但是，CPU2可以自由地先推测性地执行打印结果，一般来讲，当CPU看到诸如if或while语句之类的分支时，直到该分支指令完成之前，它才知道在哪里获取下一条指令，但是，如果它等待分支指令而又找不到足够的独立指令，则会降低CPU性能，因此，CPU1可以根据其预测推测性地执行打印结果，稍后可以批准其预测路径正确时，它将提交执行，在reader方法情况下，这意味着在打印结果之后，CPU1在while语句中找到了B == true，由于CPU并不知道我们关心A和B的执行顺序，因此必须使用所谓的内存屏障来告知它们顺序必须使用同步构造以强制执行的排序语义。如果两个CPU都引用相同的内存位置，说明它们具有数据依赖性，则没有一个CPU将对存储的给定操作进行重排序，否则将违反程序语义，基于以上分析，我们得出结论：&lt;span&gt;单线程程序在顺序化语义as-if-serial下运行，重排序的效果仅对多线程程序可见（或者一个线程中的重新排序仅对其他线程可见/对其他线程很重要），当CPU本质上执行给不了我们实际想要的排序语义时，程序必须使用同步机制。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;指令调度说明 &lt;/h3&gt;
&lt;p&gt;只要编译器不违反程序语义（这里的编译指代的是JIT编译器）就可以自由地根据其优化对代码进行物理或逻辑重新排序，现代编译器具有许多强大的代码转换，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; A = 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; B = A + 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; C = 20&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设编译器通过复杂的分析发现A不在缓存中，而C在缓存中，因此，A=10将触发多周期的数据加载，而C=20则可以在单个周期内完成，编译器可以直接跳过对A=10和B=A+10进行赋值操作而执行C=20，以将停顿减少1，如果编译器可以找到更多独立的指令，则可以通过减少更多的停顿来进行相同的重排序。由上述我们知道在单核计算机上，硬件内存的重排序并不是问题，线程是操作系统控制的软件结构，CPU仅接收连续的存储指令流，它们仍然可以重排序，但是要遵循一个基本规则：给定内核的内存访问在该内核中似乎是在程序中编写的，因此，可能会发生内存重排序，但前提是它不会破坏最终结果。接下来我们再来看一个例子（源于java并发实战）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnsafeLazyInitialization {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Resource resource;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Resource getInstance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resource == &lt;span&gt;null&lt;/span&gt;)
            resource = &lt;span&gt;new&lt;/span&gt; Resource();
        &lt;span&gt;return&lt;/span&gt; resource;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上使用先检查后操作模式实例化Resource，不用多讲，很有可能两个线程可以在该方法中同时到达，都将resource视为null并初始化变量。这里还涉及到我们上一节所讲解的部分初始化对象问题，导致对象无法正确安全发布，当我们初始化一个对象具体会进行5步操作：分配内存、创建对象、使用默认值初始化字段（比如int、boolean等）、运行构造函数、将对象的引用分配给变量，但是这里在进行第4步操作之前就运行第5步操作，所以getInstance方法将返回一个非空但不一致的对象（具有未初始化字段）的引用。但是上述方法也很有可能返回null，因为JMM对此允许， 要了解为什么这样做是可行的，我们需要详细分析读写，并评估它们之间是否存在事先发生联系（happens-before），我们将上述代码进行如下重写，以清楚地显示读取和写入：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200314192527584-331849409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;tlid-results-container results-container&quot;&gt;
&lt;div class=&quot;tlid-result result-dict-wrapper&quot;&gt;
&lt;div class=&quot;result tlid-copy-target&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;text-wrap tlid-copy-target&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;在此示例中，允许21和24都遵守10或13，并且合法执行了该程序，假设线程1看到resource为空并对其进行了初始化，线程2看到x不为空，应该会实例化Resource，但是结果可能返回null的resource，这是为何呢？前面我们讲解过CPU缓存一致性协议，当线程1执行实例化Resource时，此时需要写入到主内存，同时线程2刚好要获取resource将进行等待，为了解决缓存一致性引起的等待问题，JIT通过指令进行重排序，接下来将跳过实例化resource并写入，直接返回resource，此时结果就为null。我们将重排序操作改造成如下，相信能更好理解一点&lt;/p&gt;
&lt;div class=&quot;result-shield-container tlid-copy-target&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnsafeLazyInitialization {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Resource resource;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Resource getInstance() {
        Resource temp &lt;/span&gt;=&lt;span&gt; resource;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resource == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
            resource &lt;/span&gt;= temp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Resource(); 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp; 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过声明一个Resource的临时变量temp，此时在线程1和线程2都为null，接下来将在线程1中为null，而在线程2中不为null，因为它已由线程1初始化，最终线程1返回实例，而线程2返回null。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们详细讲解了重排序的概念以及引入重排序的原因，下一节我们进入到内存模型，感谢您的阅读，我们下节见。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 14 Mar 2020 14:22:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 我们知道对于我们所编写的代码通过计算机如何顺序执行以源代码编写的指令，程序只是处理器自上而下执行的文本文件中列出的操作列表，其实这是错误的理解，计算机能够根据需要更改某些低级操作的顺序，尤其是在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12485743.html</dc:identifier>
</item>
<item>
<title>Spring源码阅读笔记05：自定义xml标签解析 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/12384863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/12384863.html</guid>
<description>&lt;p&gt;本文主要集中在分析从如何将自定义xml标签解析成BeanDefinition到将其注册到容器中这一过程，Spring中的AOP配置就是基于这个来读取配置的。通过学习Spring对自定义标签的支持，更好的体会其可扩展的设计思路。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;233.34850778547&quot;&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/12244967.html&quot; target=&quot;_blank&quot;&gt;上篇文章&lt;/a&gt;中，提到了在Spring中存在默认标签与自定义标签两种，并且详细分析了默认标签的解析，本文就来分析自定义标签的解析，像Spring中的AOP就是通过自定义标签来进行配置的，这里也是为后面学习AOP原理打下基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里先回顾一下，当Spring完成了从配置文件到Document的转换并提取对应的root后，将开始所有元素的解析，而在这一过程中便会区分默认标签与自定义标签两种格式，并分别解析，可以再看一下这部分的源码加深理解：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(root)) {
        NodeList nl &lt;/span&gt;=&lt;span&gt; root.getChildNodes();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; nl.getLength(); i++&lt;span&gt;) {
            Node node &lt;/span&gt;=&lt;span&gt; nl.item(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Element) {
                Element ele &lt;/span&gt;=&lt;span&gt; (Element) node;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        delegate.parseCustomElement(root);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;26&quot;&gt;&lt;span&gt;　　从上面的函数中也可以看出，当Spring拿到一个元素时首先要做的是根据命名空间进行解析，如果是默认的命名空间，则使用parseDefaultElement()方法进行元素解析，否则使用parseCustomElement()方法进行解析。在本文中，所有的功能解析都是围绕其中的那句代码delegate.parseCustomElement(root)开展的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;28&quot;&gt;&lt;span&gt;  在分析自定义标签的解析过程之前，我们先了解一下自定义标签的使用过程，这里参考spring文档中的例子。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-自定义标签使用&quot; data-source-line=&quot;29&quot;&gt;1. 自定义标签使用&lt;/h2&gt;
&lt;p data-source-line=&quot;30&quot;&gt;&lt;span&gt;  扩展Spring自定义标签配置大致需要以下几个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;32&quot;&gt;&lt;li&gt;&lt;span&gt;定义一个XML文件来描述你的自定义标签元素&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建一个Handler，扩展自NamespaceHandlerSupport&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建若干个BeanDefinitionParser的实现，用来解析XML文件中的定义&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将上述文件注册到Spring中，这里其实是做一下配置&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;37&quot;&gt;&lt;span&gt;  接下来我们将创建一个自定义XML元素，便于通过一个更容易的方式配置SimpleDateFormat类型的bean。配置好之后我们可以通过下面的方式来定义一个SimpleDateFormat类型的bean：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;myns:dateformat id = &quot;dateFormat&quot; pattern = &quot;yyyy-MM-dd HH:mm&quot; lenient = &quot;true&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;11-编写schema&quot; data-source-line=&quot;41&quot;&gt;1.1 编写schema&lt;/h3&gt;
&lt;p data-source-line=&quot;42&quot;&gt;&lt;span&gt;  给Spring IoC容器创建XML扩展标签的第一步是创建一个新的XML模式来描述对应的标签(下面是我们将要用来配置SimpleDateFormat对象的schema)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;xsd:schema xmlns=&quot;http://www.mycompany.com/schema/myns&quot;&lt;span&gt;
    xmlns:xsd&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;span&gt;
    xmlns:beans&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    targetNamespace&lt;/span&gt;=&quot;http://www.mycompany.com/schema/myns&quot;&lt;span&gt;
    elementFormDefault&lt;/span&gt;=&quot;qualified&quot;&lt;span&gt;
    attributeFormDefault&lt;/span&gt;=&quot;unqualified&quot;&amp;gt;

    &amp;lt;xsd:&lt;span&gt;import&lt;/span&gt; namespace=&quot;http://www.springframework.org/schema/beans&quot;/&amp;gt;

    &amp;lt;xsd:element name=&quot;dateformat&quot;&amp;gt;
        &amp;lt;xsd:complexType&amp;gt;
            &amp;lt;xsd:complexContent&amp;gt;
                &amp;lt;xsd:extension base=&quot;beans:identifiedType&quot;&amp;gt;
                    &amp;lt;xsd:attribute name=&quot;lenient&quot; type=&quot;xsd:boolean&quot;/&amp;gt;
                    &amp;lt;xsd:attribute name=&quot;pattern&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&amp;gt;
                &amp;lt;/xsd:extension&amp;gt;
            &amp;lt;/xsd:complexContent&amp;gt;
        &amp;lt;/xsd:complexType&amp;gt;
    &amp;lt;/xsd:element&amp;gt;
&amp;lt;/xsd:schema&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　定义了上面的schema之后，我们就可以直接使用元素&amp;lt;myns:dateformat/&amp;gt;来配置SimpleDateFormat类型的对象了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;myns:dateformat id=&quot;dateFormat&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; lenient=&quot;true&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果没有做上面的工作，我们可能就需要通过下面的方式来配置SimpleDateFormat类型的对象了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;dateFormat&quot; &lt;span&gt;class&lt;/span&gt;=&quot;java.text.SimpleDateFormat&quot;&amp;gt;
    &amp;lt;constructor-arg value=&quot;yyyy-HH-dd HH:mm&quot;/&amp;gt;
    &amp;lt;property name=&quot;lenient&quot; value=&quot;true&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;12-编写一个beandefinitionparser&quot; data-source-line=&quot;80&quot;&gt;1.2 编写一个BeanDefinitionParser&lt;/h3&gt;
&lt;p data-source-line=&quot;81&quot;&gt;&lt;span&gt;  这个是继承自AbstractSingleBeanDefinitionParser，主要是用来将自定义标签解析成BeanDefinition。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SimpleDateFormatBeanDefinitionParser &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractSingleBeanDefinitionParser{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Class getBeanClass(Element element) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SimpleDateFormat.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doParse(Element element, BeanDefinitionBuilder bean) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this will never be null since the schema explicitly requires that a value be supplied&lt;/span&gt;
        String pattern = element.getAttribute(&quot;pattern&quot;&lt;span&gt;);
        bean.addConstructorArg(pattern);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this however is an optional property&lt;/span&gt;
        String lenient = element.getAttribute(&quot;lenient&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(lenient)) {
            bean.addPropertyValue(&lt;/span&gt;&quot;lenient&quot;&lt;span&gt;, Boolean.valueOf(lenient));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;13-编写一个namespacehandler&quot; data-source-line=&quot;99&quot;&gt;1.3 编写一个NamespaceHandler&lt;/h3&gt;
&lt;p data-source-line=&quot;101&quot;&gt;&lt;span&gt;  这个是继承自NamespaceHandlerSupport，主要是将上面的BeanDefinitionParser注册到Spring容器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyNamespaceHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; NamespaceHandlerSupport{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        registerBeanDefinitionParser(&lt;/span&gt;&quot;dateformat&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormatBeanDefinitionParser());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;14-编写springhandlers和springschemas文件&quot; data-source-line=&quot;111&quot;&gt;1.4 编写Spring.handlers和Spring.schemas文件&lt;/h3&gt;
&lt;p data-source-line=&quot;113&quot;&gt;&lt;span&gt;　　这两个文件默认位置是在工程资源目录的/META-INF/文件夹下，内容如下(注意要改成自己的包名)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
META-INF/&lt;span&gt;spring.handlers
http\:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.mycompany.com/schema/myns=spring.customElement.MyNamespaceHandler&lt;/span&gt;
&lt;span&gt;
META&lt;/span&gt;-INF/&lt;span&gt;spring.schemas
http\:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.mycompany.com/schema/myns/myns.xsd=spring/customElement/myns.xsd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;15-自定义标签使用示例&quot; data-source-line=&quot;122&quot;&gt;1.5 自定义标签使用示例&lt;/h3&gt;
&lt;p data-source-line=&quot;123&quot;&gt;&lt;span&gt;  使用自定义的扩展标签和使用Spring提供的默认标签是类似的，可以按照如下配置一个SimpleDateFormat类型的bean：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:myns&lt;/span&gt;=&quot;http://www.mycompany.com/schema/myns&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.mycompany.com/schema/myns &lt;/span&gt;&lt;span&gt;http://www.mycompany.com/schema/myns/myns.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;

    &amp;lt;!-- as a top-level bean --&amp;gt;
    &amp;lt;myns:dateformat id=&quot;defaultDateFormat&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; lenient=&quot;true&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　配置好之后可以测试一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    XmlBeanFactory xmlBeanFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; XmlBeanFactory(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;customElement.xml&quot;&lt;span&gt;));
    SimpleDateFormat myTestBean &lt;/span&gt;= (SimpleDateFormat)xmlBeanFactory.getBean(&quot;defaultDateFormat&quot;&lt;span&gt;);
    System.out.println( &lt;/span&gt;&quot;now time --- &quot;+ myTestBean.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出结果：&lt;/span&gt;
now time --- 2020-03-07 20:37
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;2-自定义标签解析&quot; data-source-line=&quot;149&quot;&gt;2. 自定义标签解析&lt;/h2&gt;
&lt;p data-source-line=&quot;150&quot;&gt;&lt;span&gt;  了解了自定义标签的使用之后，我们来探究一下自定义标签的解析过程。接着文章开头提到的，我们要从BeanDefinitionParserDelegate的parseCustomElement()方法开始：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parseCustomElement(Element ele) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; parseCustomElement(ele, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取对应的名称空间&lt;/span&gt;
    String namespaceUri =&lt;span&gt; getNamespaceURI(ele);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据命名空间找到对应的NamespaceHandler&lt;/span&gt;
    NamespaceHandler handler = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        error(&lt;/span&gt;&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;&lt;span&gt;, ele);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用自定义的NamespaceHandler进行解析&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; handler.parse(ele, &lt;span&gt;new&lt;/span&gt; ParserContext(&lt;span&gt;this&lt;/span&gt;.readerContext, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, containingBd));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;169&quot;&gt;&lt;span&gt;  这里可以看出对自定义标签进行解析的思路是根据Element获取对应的名称空间，然后根据名称空间获取对应的处理器，最后根据用户自定义的处理器进行解析，可是看起来简单，实现起来就不是这么简单了，先来看一下名称空间的获取吧。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;21-获取标签的名称空间&quot; data-source-line=&quot;171&quot;&gt;2.1 获取标签的名称空间&lt;/h2&gt;
&lt;p data-source-line=&quot;173&quot;&gt;&lt;span&gt;  自定义标签的解析是从名称空间的提取开始的，无论是区分默认标签和自定义标签，还是区分自定义标签对应的不同处理器，都是以标签所提供的名称空间为基础的。至于如何提取对应元素的名称空间，已经有现成的实现可供使用，spring中是直接调用org.w3c.dom.Node提供的相应方法来完成名称空间的提取：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getNamespaceURI(Node node) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.getNamespaceURI();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;22-获取自定义标签处理器&quot; data-source-line=&quot;179&quot;&gt;2.2 获取自定义标签处理器&lt;/h3&gt;
&lt;p data-source-line=&quot;181&quot;&gt;&lt;span&gt;  有了名称空间，就可以此来提取对应的NamespaceHandler了，这项工作是由下面这句代码来完成的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
NamespaceHandler handler = &lt;span&gt;this&lt;/span&gt;.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里readerContext的getNamespaceHandlerResolver()方法返回的其实是DefaultNamespaceHandlerResolver，所以我们直接进入其resolve()方法中往下看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NamespaceHandler resolve(String namespaceUri) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有已经配置的handler映射&lt;/span&gt;
    Map&amp;lt;String, Object&amp;gt; handlerMappings =&lt;span&gt; getHandlerMappings();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称空间找到对应的处理器信息&lt;/span&gt;
    Object handlerOrClassName =&lt;span&gt; handlerMappings.get(namespaceUri);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handlerOrClassName == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (handlerOrClassName &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; NamespaceHandler) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经做过解析，直接从缓存读取&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (NamespaceHandler) handlerOrClassName;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未做过解析，则返回的是类路径，需要从新加载&lt;/span&gt;
        String className =&lt;span&gt; (String) handlerOrClassName;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用反射加载类&lt;/span&gt;
            Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.classLoader);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!NamespaceHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(handlerClass)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri +
                        &quot;] does not implement the [&quot; + NamespaceHandler.&lt;span&gt;class&lt;/span&gt;.getName() + &quot;] interface&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化类&lt;/span&gt;
            NamespaceHandler namespaceHandler =&lt;span&gt; (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用自定义的初始化方法&lt;/span&gt;
&lt;span&gt;            namespaceHandler.init();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录在缓存&lt;/span&gt;
&lt;span&gt;            handlerMappings.put(namespaceUri, namespaceHandler);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; namespaceHandler;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; +&lt;span&gt;
                    namespaceUri &lt;/span&gt;+ &quot;] not found&quot;&lt;span&gt;, ex);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (LinkageError err) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FatalBeanException(&quot;Invalid NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; +&lt;span&gt;
                    namespaceUri &lt;/span&gt;+ &quot;]: problem with handler class file or dependent class&quot;&lt;span&gt;, err);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;228&quot;&gt;&lt;span&gt;　　上面函数中的流程还是比较清晰的，在前面的自定义标签使用示例中有说到，如果要使用自定义标签，需要在Spring.handlers文件中配置名称空间与名称空间处理器的映射关系。只有这样，Spring才能根据映射关系找到匹配的处理器。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;230&quot;&gt;&lt;span&gt;  而寻找匹配的处理器就是在上面函数中实现的，当获取到自定义的NamespaceHandler之后就可以进行处理器初始化并解析了。这里我们再回忆一下前面自定义标签示例中，对于名称空间处理器的内容(我们在其init()方法中注册了一个解析器)。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;232&quot;&gt;&lt;span&gt;  在上面的代码中，获取到自定义名称空间处理器后会马上执行其init()方法来进行自定义BeanDefinitionParser的注册。当然在init()中可以注册多个标签解析器，如&amp;lt;myns:A、&amp;lt;myns:B等，使得myns的名称空间中可以支持多种标签解析。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;234&quot;&gt;&lt;span&gt;  注册好之后，名称空间处理器就可以根据标签的不同来调用不同的解析器进行解析。根据上面的函数和之前的例子，我们基本可以判断getHandlerMappings()的主要功能就是读取Spring.handlers配置文件并将配置文件缓存在map中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt;&lt;span&gt; getHandlerMappings() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有被缓存则开始进行缓存&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.handlerMappings == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.handlerMappings == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this.handlerMappingsLocation在构造函数中已经被初始化为：META-INF/Spring.handlers&lt;/span&gt;
                    Properties mappings =&lt;span&gt;
                            PropertiesLoaderUtils.loadAllProperties(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlerMappingsLocation, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.classLoader);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Loaded NamespaceHandler mappings: &quot; +&lt;span&gt; mappings);
                    }
                    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; handlerMappings = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;(mappings.size());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将Properties格式文件合并到Map格式的handlerMappings中&lt;/span&gt;
&lt;span&gt;                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlerMappings =&lt;span&gt; handlerMappings;
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                            &lt;/span&gt;&quot;Unable to load NamespaceHandler mappings from location [&quot; + &lt;span&gt;this&lt;/span&gt;.handlerMappingsLocation + &quot;]&quot;&lt;span&gt;, ex);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlerMappings;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;263&quot;&gt;&lt;span&gt;  这里是借助工具类PropertiesLoaderUtils对Spring.handlers配置文件进行了读取，然后将读取的内容放到缓存中并返回。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-标签解析&quot; data-source-line=&quot;264&quot;&gt;2.3 标签解析&lt;/h3&gt;
&lt;p data-source-line=&quot;265&quot;&gt;&lt;span&gt;  获取到解析器以及要解析的元素后，Spring将解析工作委托给自定义解析器来解析，即下面代码所完成的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; handler.parse(ele, &lt;span&gt;new&lt;/span&gt; ParserContext(&lt;span&gt;this&lt;/span&gt;.readerContext, &lt;span&gt;this&lt;/span&gt;, containingBd));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　此时我们拿到的handler其实是我们自定义的MyNamespaceHandler了，但是我们前面并没有实现parse()方法，所以这里这个应该是调用的父类中的parse()方法，看一下NamespaceHandlerSupport中的parse()方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找解析器并进行解析操作&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; findParserForElement(element, parserContext).parse(element, parserContext);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取元素名称，也就是&amp;lt;myns:dateformat中的dateformat，在上面示例中，localName为dateformat&lt;/span&gt;
    String localName =&lt;span&gt; parserContext.getDelegate().getLocalName(element);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据dateformat找到对应的解析器，也就是在registerBeanDefinitionParser(&quot;dateformat&quot;, new SimpleDateFormatBeanDefinitionParser());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册的解析器&lt;/span&gt;
    BeanDefinitionParser parser = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parsers.get(localName);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parser == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        parserContext.getReaderContext().fatal(
            &lt;/span&gt;&quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;&lt;span&gt;, element);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parser;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　首先是寻找元素对应的解析器，然后调用其parse()方法。结合我们前面的示例，其实就是首先获取在MyNamespaceHandler类中的init()方法中注册对应的SimpleDateFormatBeanDefinitionParser实例，并调用其parse()方法进行进一步解析，同样这里parse()方法我们前面是没有实现的，我们也试着从其父类找一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; BeanDefinition parse(Element element, ParserContext parserContext) {
    AbstractBeanDefinition definition &lt;/span&gt;=&lt;span&gt; parseInternal(element, parserContext);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (definition != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;parserContext.isNested()) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            String id &lt;/span&gt;=&lt;span&gt; resolveId(element, definition, parserContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.hasText(id)) {
                parserContext.getReaderContext().error(
                        &lt;/span&gt;&quot;Id is required for element '&quot; +&lt;span&gt; parserContext.getDelegate().getLocalName(element)
                                &lt;/span&gt;+ &quot;' when used as a top-level tag&quot;&lt;span&gt;, element);
            }
            String[] aliases &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;];
            String name &lt;/span&gt;=&lt;span&gt; element.getAttribute(NAME_ATTRIBUTE);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasLength(name)) {
                aliases &lt;/span&gt;=&lt;span&gt; StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将AbstractBeanDefinition转换为BeanDefinitionHolder并注册&lt;/span&gt;
            BeanDefinitionHolder holder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder(definition, id, aliases);
            registerBeanDefinition(holder, parserContext.getRegistry());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (shouldFireEvents()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要通知监听器则进行处理&lt;/span&gt;
                BeanComponentDefinition componentDefinition = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanComponentDefinition(holder);
                postProcessComponentDefinition(componentDefinition);
                parserContext.registerComponent(componentDefinition);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanDefinitionStoreException ex) {
            parserContext.getReaderContext().error(ex.getMessage(), element);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; definition;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里虽是对自定义配置进行解析，但是可以看到大部分的代码是用来将解析后的AbstractBeanDefinition转化为BeanDefinitionHolder并将其注册，这点与解析默认标签是类似的，真正去做解析的事情其实是委托给了parseInternal()函数。而在parseInternal()中也并不是直接调用自定义的doParse()函数，而是先进行一系列的数据准备，包括对beanClass、scope、lazyInit等属性的准备：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
    BeanDefinitionBuilder builder &lt;/span&gt;=&lt;span&gt; BeanDefinitionBuilder.genericBeanDefinition();
    String parentName &lt;/span&gt;=&lt;span&gt; getParentName(element);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parentName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.getRawBeanDefinition().setParentName(parentName);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取自定义标签中的class，此时会调用自定义解析器中的getBeanClass()方法&lt;/span&gt;
    Class&amp;lt;?&amp;gt; beanClass =&lt;span&gt; getBeanClass(element);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanClass != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        builder.getRawBeanDefinition().setBeanClass(beanClass);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若子类没有重写getBeanClass方法则会尝试检查子类是否重写getBeanClassName()方法&lt;/span&gt;
        String beanClassName =&lt;span&gt; getBeanClassName(element);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanClassName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            builder.getRawBeanDefinition().setBeanClassName(beanClassName);
        }
    }
    builder.getRawBeanDefinition().setSource(parserContext.extractSource(element));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parserContext.isNested()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若存在父类则使用父类的scope属性&lt;/span&gt;
&lt;span&gt;        builder.setScope(parserContext.getContainingBeanDefinition().getScope());
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (parserContext.isDefaultLazyInit()) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置延迟加载&lt;/span&gt;
        builder.setLazyInit(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用子类重写的doParse方法进行解析&lt;/span&gt;
&lt;span&gt;    doParse(element, parserContext, builder);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.getBeanDefinition();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就是调用前面示例中我们自己写的doParse()方法&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
    doParse(element, builder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;365&quot;&gt;&lt;span&gt;　　到这里就完成了对自定义标签转换成BeanDefinition的整个过程了，回顾一下整个过程，在我们定义的SimpleDateFormatBeanDefinitionParser中我们只是做了与自己业务逻辑相关的部分，剩下的包括创建BeanDefinition以及进行相应默认属性的设置，Spring都帮我们默认实现了，我们当然也可以自己来完成这一过程，比如AOP就是这样做的，但是本文还是用最简单的方式来做一个说明。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-总结&quot; data-source-line=&quot;367&quot;&gt;3. 总结&lt;/h2&gt;
&lt;p data-source-line=&quot;368&quot;&gt;&lt;span&gt;  其实从Spring对自定义标签的解析中也可以体会到Spring的可扩展式设计思路，通过暴露一些接口，我们就能够方便地实现自己的个性化业务，不仅如此，Spring自己便是这项功能的践行者，像AOP、事务都是通过这种方式来定制对应的标签来完成配置需求的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;370&quot;&gt;&lt;span&gt;  到这里我们已经完成了Spring中全部的解析工作的学习，也就是说到这里我们已经学习了Spring将bean从配置文件加载到内存的完整过程，接下来的任务便是如果使用这些bean，这才是IoC容器的重头戏，后面会详细学习的。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 14 Mar 2020 14:20:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>本文主要集中在分析从如何将自定义xml标签解析成BeanDefinition到将其注册到容器中这一过程，Spring中的AOP配置就是基于这个来读取配置的。通过学习Spring对自定义标签的支持，更好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/volcano-liu/p/12384863.html</dc:identifier>
</item>
</channel>
</rss>