<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring之AOP流程解析(ProxyFactory) - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10660488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10660488.html</guid>
<description>&lt;p&gt;　　本节我们从ProxyFactory开始分析。该类有几个比较重要的方法——addAdvice、addAdvisor、getProxy，其中最后一个方法是我们本节的重点。前两个方法都是向ProxyFactory中成员变量advisors中加入成员，以便后面调用方法时实现拦截。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　这里，我们首先来了解前两个方法。在addAdvice中会调用到addAdvisor，而内部封装的advisor实际类型是DefaultPointcutAdvisor。如下图所示，这里将advice封装到DefaultPointcutAdvisor。这里我们默认只传入advice参数，在DefaultPointcutAdvisor中的成员变量pointcut默认为Pointcut.TRUE，也就是TruePointcut.INSTANCE，他比较特殊的是通过方法getClassFilter返回的是ClassFilter.TRUE，也就是TrueClassFilter.INSTANCE，通过方法getMethodMatcher返回的是MethodMatcher.TRUE，也就是TrueMethodMatcher.INSTANCE。通过他们的matches方法返回值都是true。接着，在addAdvisor方法中调用了addAdvisorInternal，该方法将入参advisor加入成员变量advisors中，然后将其中的值转换为数组赋给成员变量advisorArray(该变量用于后来在方法DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice中构建interceptorList列表)，然后调用adviceChanged方法将成员变量methodCache中的值清空。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201904/1365945-20190405233244552-1779405921.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　下面，我们来到本节的重点ProxyFactory.getProxy，该方法并不复杂，只是返回一个代理对象，该代理对象除了实现了ProxyFactory.targetSource.getTargetClass所实现接口，另外实现了SpringProxy、Advised、DecoratingProxy这三个接口。&lt;/p&gt;
&lt;p&gt;　　在ProxyFactory.getProxy方法中调用了ProxyCreatorSupport.createAopProxy，该方法首先调用了方法activate，然后通过方法getAopProxyFactory获得成员变量aopProxyFactory，该成员变量在通过ProxyFactory调用时是DefaultAopProxyFactory的实例。关于ProxyCreatorSupport的另一个构造方法，入参为aopProxyFactory，调用是在ProxyFactoryBean.newPrototypeInstance中，我将放在以后来讲解。接下来调用了DefaultAopProxyFactory.createAopProxy，这里的入参就是我们的ProxyFactory，这点需要紧记，因为在后来的代理对象调用方法时会用到，这里的入参接着会传入到接下来构建的AopProxy实现类型中。在DefaultAopProxyFactory.createAopProxy方法中根据情况构造了ObjenesisCglibAopProxy或者JdkDynamicAopProxy。其中JdkDynamicAopProxy是AopProxy基于JDK的实现，而ObjenesisCglibAopProxy是基于Cglib的实现，他直接继承自CglibAopProxy。这里我只分析JdkDynamicAopProxy，大家有兴趣可以看一下ObjenesisCglibAopProxy，二者只是实现方式不同，大体流程是一致的。我们这里然后就调用了JdkDynamicAopProxy.getProxy，这里有一个参数是ClassUtils.getDefaultClassLoader()，该方法获取的是当前线程的ClassLoader，也就是默认的AppLauncher。然后通过方法AopProxyUtils.completeProxiedInterfaces填充了SpringProxy、Advised、DecoratingProxy这三个接口。而后通过Proxy.newProxyInstance方法构建了代理对象，注意，这里的最后一个入参就是我们这里的JdkDynamicAopProxy。&lt;/p&gt;
&lt;p&gt;　　下面，假设我们调用了返回的代理对象的某个方法，也就是说，我们将来到JdkDynamicAopProxy.invoke。不知道大家是否还记得，在JdkDynamicAopProxy.advised就是在DefaultAopProxyFactory.createAopProxy方法中的入参，也就是我们的ProxyFactory。让我们再回到JdkDynamicAopProxy.invoke方法。这里首先获得了advised.targetSource，也就是ProxyFactory.targetSource。这里的targetSource是在ProxyFactory的构造函数中将入参Object封装后的TargetSource，默认实现是SingletonTargetSource。接着调用了targetSource.getTarget，也就是获取到了我们这里的目标对象，也就是构造ProxyFactory时的入参Object。然后，获取到target的实际类型，调用了advised.getInterceptorsAndDynamicInterceptionAdvice，也就是方法AdvisedSupport.getInterceptorsAndDynamicInterceptionAdvice。该方法根据之前传入的advisor构建调用链。由于我们之前并没有调用该方法，因此，在AdvisedSupport.methodCache中并没有该方法的缓存值，然后调用了DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice来构造cached并将其将入到成员变量methodCache中。&lt;/p&gt;
&lt;p&gt;　　接下来，让我们来到DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice，该方法实现了将入参config中的Advisors转换为通过匹配后的MethodInterceptor列表，也就是真实方法调用前的拦截链。如下图所示，这里是getInterceptorsAndDynamicInterceptionAdvice的完整方法。&lt;/p&gt;
&lt;p&gt;　　1.首先调用GlobalAdvisorAdapterRegistry.getInstance获得DefaultAdvisorAdapterRegistry。这里我们需要注意的是在DefaultAdvisorAdapterRegistry的构造方法中已经调用registerAdvisorAdapter方法为其成员变量adapters加入了MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter这三个AdvisorAdapter。&lt;/p&gt;
&lt;p&gt;　　2.调用入参config.getAdvisors获取在ProxyFactory中配置的advisors。&lt;/p&gt;
&lt;p&gt;　　3.遍历ProxyFactory.advisors，一般来说，在ProxyFactory中加入的advisor是DefaultPointcutAdvisor，实现了接口PointcutAdvisor。因此，这里将advisor强转为PointcutAdvisor，获取其pointcut，紧接着调用Pointcut.getClassFilter，并调用ClassFilter.matches，判断目标类型是否与当前pointcut的ClassFilter相匹配，如果返回值为true，则继续调用PointcutAdvisor.getPointcut.getMethodMatcher获得MethodMatcher，接着判断其是否与目标类型的调用方法相匹配。如果当前调用方法确实是拦截点，就会调用DefaultAdvisorAdapterRegistry.getInterceptors将当前advisor转换为MethodInterceptor列表。&lt;/p&gt;
&lt;p&gt;　　这里我简单说一下PointcutAdvisor与Advisor。PointcutAdvisor实现接口Advisor，并且增加了方法getPointcut，返回的Pointcut就是用来判断当前执行的方法是否与当前PointcutAdvisor相匹配。而advisor的作用就是用来封装advice，其有一个方法是getAdvice。这里的DefaultAdvisorAdapterRegistry.getInterceptors方法我放到后面来讲解。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　4.将返回的MethodInterceptor数组加入到interceptorList中然后返回。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201904/1365945-20190405233325527-132455531.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们首先来到DefaultAdvisorAdapterRegistry.getInterceptors。&lt;/p&gt;
&lt;p&gt;　　1.如果通过advisor.getAdvice获取的advice实现了接口MethodInterceptor，则直接将其加入到interceptors列表中。&lt;/p&gt;
&lt;p&gt;　　2.这里的成员变量adapters就是在DefaultAdvisorAdapterRegistry构造时就填充了MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter。接着遍历adapters并将满足条件的advice封装后加入到interceptors列表中。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　这里我们以MethodBeforeAdviceAdapter为例。在MethodBeforeAdviceAdapter.supportsAdvice方法中仅仅是判断入参advice是否实现了MethodBeforeAdvice接口，如果满足条件，则调用MethodBeforeAdviceAdapter.getInterceptor将advice强转为MethodBeforeAdvice并将其封装到MethodBeforeAdviceInterceptor中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201904/1365945-20190405233408635-1553345077.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到此为止，我们就构造好了AdviceChain，接下来，来到本节的最后一个重点——构造ReflectiveMethodInvocation，并调用其proceed方法。在构造ReflectiveMethodInvocation时，其最后一个入参就是我们刚刚构造好的chain。接下来，我们来到ReflectiveMethodInvocation.proceed。这里的链式调用很类似web应用中的过滤器，可能spirng团队也是经常写web架构的。&lt;/p&gt;
&lt;p&gt;　　1.这里首先判断当前调用是否已经将所有的调用链完成，如果已经完成，则调用invokeJoinpoint，触发真实要执行的方法。大家可能比较疑惑，这里为什么是interceptorsAndDynamicMethodMatchers.size() - 1，因为这里的currentInterceptorIndex是从-1开始的，如果从0开始的话，那么，显然就没有后面的 - 1。&lt;/p&gt;
&lt;p&gt;　　2.从interceptorsAndDynamicMethodMatchers列表中获取值，然后调用其invoke方法。这里我把MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor都讲解一下。&lt;/p&gt;
&lt;p&gt;　　如果这里的MethodInterceptor实际类型是MethodInterceptor，那么调用了MethodBeforeAdviceInterceptor.invoke，注意，这里的入参是ReflectiveMethodInvocation，也就是说，这里在调用了advice.before后，接着调用了ReflectiveMethodInvocation.proceed，接着来到ReflectiveMethodInvocation.proceed。&lt;/p&gt;
&lt;p&gt;　　然后假设这里的MethodInterceptor实际类型是AfterReturningAdviceInterceptor，这里直接就调用了ReflectiveMethodInvocation.proceed，在其调用完成后，调用了advice.afterReturning。&lt;/p&gt;
&lt;p&gt;　　接着，我们假设这里的MethodInterceptor实际类型是ThrowsAdviceInterceptor，这里直接调用了ReflectiveMethodInvocation.proceed，不过，这里添加了异常捕获如果获取到对应的Method，则通过invokeHandlerMethod调用捕获异常的方法。然后继续将异常抛出。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　可以说，这里很好的使用的递归的思路，实现了拦截器的链式调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201904/1365945-20190405233505195-1646791867.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，本节的内容就结束了。尽管内容洋洋洒洒，但是当你调试代码的时候，会发现其实并没有多少东西。希望大家在看本文的时候尽量结合源码调试，以加深理解。如果有疑问或有相关问题探讨，欢迎大家留言。&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>本节我们从ProxyFactory开始分析。该类有几个比较重要的方法——addAdvice、addAdvisor、getProxy，其中最后一个方法是我们本节的重点。前两个方法都是向ProxyFact</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10660488.html</dc:identifier>
</item>
<item>
<title>盘点ip地址冲突解决方法 - 新爵</title>
<link>http://www.cnblogs.com/sucy/p/10660491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sucy/p/10660491.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;日常生活中常会遇到主机报IP冲突的情形，那么出现该问题该如何排查：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.源头追溯，查日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行——&amp;gt; cmd——&amp;gt; eventvwr.msc  打开系统日志，依次进入Windows日志-系统，进入查看。找到类别为错误，来源为Tcpip的日志并打开，我们就能找到冲突主机的物理地址：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1296096/201904/1296096-20190405230656629-317397087.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上说明，检测到240e:fa:c1b4:5300:3479:168b:88f5:2 和 0C-84-DC-90-D9-38 两块网卡存在冲突，这就是冲突来源！（对比发现，该地址实际并不是本机网卡，当然如果是本机，可能右下角网卡图标处直接有异常提示出现，而且不能正常上网的哟，这也是区别的地方。）注意这里日志记录并不一定是针对本机，它记录的是该局域网内的冲突事件的哦。&lt;/p&gt;
&lt;p&gt;2.顺藤摸瓜，查找mac事件主机&lt;/p&gt;
&lt;p&gt;根据日志记录的两个mac去查找到对应的主机。本事例经查发现一小伙伴自己笔记本电脑外接了一块无线网卡........冲突自此而来！&lt;/p&gt;
&lt;p&gt;3.解决方法&lt;/p&gt;
&lt;p&gt;禁用其一无线网卡即可解决。 &lt;/p&gt;
&lt;p&gt;这里要说一下，其实这就是个双网卡入同一个局域网的问题，有的时候有线+无线网卡同时入网也会出现这种问题，需要注意。&lt;/p&gt;

&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;当然网上也给出了各种处理这类故障的方法，常见的有：&lt;/p&gt;
&lt;p&gt;（1）运行ipconfig /release ——&amp;gt; ipconfig /renew   终端重获ip&lt;/p&gt;
&lt;p&gt;（2）重启路由器（DHCP服务）&lt;/p&gt;
&lt;p&gt;（3）指定静态IP&lt;/p&gt;
&lt;p&gt;......对于上面的案例，以上3种方法是无济于事的！对于专业人士，掌握方法，才是根本哦。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 15:36:00 +0000</pubDate>
<dc:creator>新爵</dc:creator>
<og:description>日常生活中常会遇到主机报IP冲突的情形，那么出现该问题该如何排查： 1.源头追溯，查日志 运行——&gt; cmd——&gt; eventvwr.msc 打开系统日志，依次进入Windows日志-系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sucy/p/10660491.html</dc:identifier>
</item>
<item>
<title>Java 集合系列（四）—— ListIterator 源码分析 - 那一叶随风</title>
<link>http://www.cnblogs.com/phpstudy2015-6/p/10660457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/phpstudy2015-6/p/10660457.html</guid>
<description>&lt;p&gt;以脑图的形式来展示Java集合知识，让零碎知识点形成体系&lt;/p&gt;
&lt;h4&gt;Iterator 对比&lt;/h4&gt;
&lt;p&gt;  Iterator（迭代器）是一种设计模式，是一个对象，用于遍历集合中的所有元素。&lt;br/&gt;  Iterator 包含四个方法，分别是：next()、hasNext()、remove()、forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action)&lt;/p&gt;
&lt;p&gt;  Collection 接口继承 java.lang.Iterable，因此所有 Collection 实现类都拥有 Iterator 迭代能力。&lt;br/&gt;  逆向思考，Iterable 面向众多的 Collection 类型实现类，定义的方法就不可能太定制化，因此 Iterator 定义的功能比较简单。&lt;br/&gt;  仅有如上所列出来的四种方法，并且该迭代器只能够单向移动。&lt;/p&gt;
&lt;p&gt;  由于 List 类型的 Collection 是一个有序集合，对于拥有双向迭代是很有意义的。&lt;br/&gt;  ListIterator 接口则在继承 Iterator 接口的基础上定义了：add(E newElement)、set(E newElement)、hasPrevious()、previous()、nextIndex()、previousIndex() 等方法，使得 ListIterator 迭代能力增强，能够进行双向迭代、迭代过程中可以进行增删改操作。&lt;/p&gt;
&lt;h4&gt;现象与问题&lt;/h4&gt;

&lt;ol&gt;&lt;li&gt;add() 方法在迭代器位置前面添加一个新元素&lt;/li&gt;
&lt;li&gt;next() 与 previous() 返回越过的对象&lt;/li&gt;
&lt;li&gt;set() 方法替换的是 next() 和 previous() 方法返回的上一个元素&lt;/li&gt;
&lt;li&gt;next() 后，再 remove() 则删除前面的元素；previous() 则会删除后面的元素&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         list.add(&quot;aaa&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         list.add(&quot;bbb&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         list.add(&quot;ccc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         ListIterator&amp;lt;String&amp;gt; listIterator =&lt;span&gt; list.listIterator();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;迭代器位置： add-1 | aaa bbb ccc&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         listIterator.add(&quot;add-1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 | aaa bbb ccc&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         listIterator.add(&quot;add-2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回： aaa
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 aaa | bbb ccc&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        listIterator.next();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 aaa-set | bbb ccc&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         listIterator.set(&quot;aaa-set&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bbb
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 aaa-set bbb | ccc&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        listIterator.next();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回： bbb
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 aaa-set | bbb ccc&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        listIterator.previous();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add-1 add-1 aaa-set | bbb-set ccc&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         listIterator.set(&quot;bbb-set&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除 bbb-set&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        listIterator.remove();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        listIterator.remove();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         System.out.println(list);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;很多书本都有给出这样子的结论：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;链表有 n 个元素，则有 n+1 个位置可以添加新元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;add() 方法只依赖迭代器的+位置；remove() 和 set() 方法依赖于迭代器的状态（此时迭代的方向）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;连续两个 remove() 会出错，remove() 前应先执行 next() 或 previous()。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;迭代同时修改问题：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;  一个迭代器指向另一个迭代器刚刚删除的元素，则现在这个迭代器就变成无效的了（节点删除被回收；即使没被回收，该节点的前后引用也被重置为null）。&lt;br/&gt;链表迭代器有能够检测到这种修改的功能，当发现集合被修改了，将会抛出一个 ConcurrentModificationException 异常&lt;/p&gt;
&lt;p&gt;  为什么出现上面的这些现象与问题呢，我们还是从源码中寻找答案吧&lt;/p&gt;

&lt;h4&gt;源码分析&lt;/h4&gt;
&lt;p&gt;  有多个集合类根据自己的特点实现了 ListIterator 接口，其实现都大同小异，这里我们主要分析 LinkedList 中所实现的 ListIterator。&lt;/p&gt;
&lt;p&gt;  首先我们来分析 LinkedList 的 listIterator() 和 listIterator(int index) 方法获取 ListIterator 迭代器过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; AbstractList.java
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; listIterator() 方法 LinkedList 类本身并没有重写，需要追溯到 AbstractList 抽象类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 ListIterator 迭代器&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; listIterator() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; listIterator(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         rangeCheckForAdd(index);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查 index 范围是否超出&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ListItr(index);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该抽象类也有实现 ListItr 类&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheckForAdd(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index &amp;lt; 0 || index &amp;gt;&lt;span&gt; size())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkedList.java
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkedList 类重写了 listIterator(int index) 方法&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         checkPositionIndex(index);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理 检查 index 范围；相关代码就不贴了&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(index);
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt; lastReturned;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上一次处理的节点&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt; next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即将要处理的节点&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nextIndex;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即将要处理的节点的 index
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; modCount 表示集合和迭代器修改的次数；expectedModCount 表示当前迭代器对集合修改的次数&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;         ListItr(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isPositionIndex(index);&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;             next = (index == size) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : node(index);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             nextIndex =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        * 处理对象：迭代器当前的 next 节点
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        * 将处理目标储到 lastReturned 变量中
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        * 然后将当前的 next.next 节点保存起来，用于下一次迭代处理
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        * nextIndex 同时 +1
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        * 返回 lastReturned.item 元素
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        * 执行后：lastReturned 指向该次处理的节点；next、nextIndex 指向该次处理节点的后一个节点
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查 modCount 与 expectedModCount 是否相等
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际检查该链表是否被其他迭代器或者集合本身修改&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            checkForComodification();
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否存在 next 节点&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNext())
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             
&lt;span&gt; 43&lt;/span&gt;             lastReturned = next;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将这次返回的 node 节点更新到迭代器中的 lastReturned 变量&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;             next = next.next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将下一次需要处理 node 节点更新会 next 变量&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;             nextIndex++;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量 nextIndex +1&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; lastReturned.item;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回元素&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextIndex &amp;gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        * 处理对象：迭代器当前的 next.prev 节点
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        * 将处理目标储到 lastReturned 变量中
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;        * 然后将当前的 next.prev 节点保存起来，用于下一次迭代处理
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        * nextIndex 同时 -1
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        * 返回当前的 next.item 元素
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        * 执行后：next、lastReturned、nextIndex 指向该次处理节点的前一个节点
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E previous() {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            checkForComodification();
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否存在 prev 节点&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasPrevious())
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理当前 next 的 prev 节点
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 特殊情况：next = null 时，则它的 prev 节点为 last 节点  &lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             lastReturned = next = (next == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; last : next.prev;    
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             nextIndex--;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nextIndex -1&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex() {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextIndex;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; previousIndex() {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextIndex - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        * 处理对象：lastReturned
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        * 删除 lastReturned 指向的节点，并置为 null
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        * 同时保证 next 和 nextIndex 指向同一个节点
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             checkForComodification();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理， 检查 modCount 与 expectedModCount 是否相等&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;             Node&amp;lt;E&amp;gt; lastNext = lastReturned.next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 暂存 lastReturned 的 next 节点，用于恢复迭代状态&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             unlink(lastReturned);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除最后返回的节点    modCount++;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             
&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分迭代方向处理（因为删除一个节点后，需要恢复迭代状态：next 和 nextIndex 指向同一个节点）&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (next == lastReturned)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; next 与 lastReturned 节点相同则表明最近一次迭代操作是 previous()&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;                 next = lastNext;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除了原有 next 指向的节点，因此 nextIndex 相对指向的节点变为 next.next，需要更新 next 变量的指向&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;                 nextIndex--;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; next() 迭代方向；删除了next前面的节点，因此next的相对位置发生变化，需要 nextIndex -1&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;             lastReturned = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             expectedModCount++;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时 expectedModCount++&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;        * 处理对象：lastReturned
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(E e) {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;            checkForComodification();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             lastReturned.item =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        * 分位置进行添加
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            checkForComodification();
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;             lastReturned = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                linkLast(e);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                linkBefore(e, next);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             nextIndex++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             expectedModCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            Objects.requireNonNull(action);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (modCount == expectedModCount &amp;amp;&amp;amp; nextIndex &amp;lt;&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;                action.accept(next.item);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 lastReturned =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 next =&lt;span&gt; next.next;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 nextIndex++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            checkForComodification();
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;        * 检查 modCount 与 expectedModCount 是否相等，否则抛出错误
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        * ListIterator 迭代器进行增删操作时，都会同时对这两个变量 +1
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;        * 目的：
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        * 使用 ListIterator 迭代器期间，LinkedList 对象有且只能当前这一个迭代器可以进行修改
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;        * 避免 LinkedList 对象本身以及其他迭代器进行修改导致链表混乱
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;小结&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;  总的来说 ListIterator 是记录 List 位置的一个对象，它主要的成员变量是 lastReturned、next、nextIndex 以及 expectedModCount。&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;next() 处理的是 next 节点，返回 next.item&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;previous() 处理的是 next.prev 节点 返回 next.prev.item&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;remove() 处理的是 lastReturned 节点，并置为null，但要注意的是，删除节点后的 next 与 nextIndex 需分情况处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;set() 处理的是 lastReturned 节点，lastReturned.item = e&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;add() 添加，并将 lastReturned 置为null&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  这就很好地解释上面所提到的一些现象与问题了。&lt;br/&gt;  典型的就是连续两个 remove() 会报错，那是因为第一个 reomve() 之后 lastReturned 被置为null；第二个 remove() 处理的对象是null，因此炮锤 IllegalStateException&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;知识脑图&lt;/h4&gt;
&lt;p&gt;From &lt;a href=&quot;https://github.com/suifeng412/JCKTree&quot; target=&quot;_blank&quot;&gt;Java Core Knowledge Tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/789055/201904/789055-20190405232355497-282276452.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;749&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在 github 上建了一个 repository ，&lt;a href=&quot;https://github.com/suifeng412/JCKTree&quot; target=&quot;_blank&quot;&gt;Java Core Knowledge Tree&lt;/a&gt;，各位看官若是喜欢请给个star，以示鼓励，谢谢。&lt;br/&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsuifeng412%2FJCKTree&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/suifeng412/JCKTree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（以上是自己的一些见解，若有不足或者错误的地方请各位指出）&lt;/p&gt;
&lt;p&gt; 作者：&lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;那一叶随风&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/phpstudy2015-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 原文地址： &lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/10660457.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/phpstudy2015-6/p/10660457.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/%20https://www.cnblogs.com/phpstudy2015-6/p/6732784.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 声明：本博客文章为原创，只代表本人在工作学习中某一时间内总结的观点或结论。转载时请在文章页面明显位置给出原文链接&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>那一叶随风</dc:creator>
<og:description>以脑图的形式来展示Java集合知识，让零碎知识点形成体系 Iterator 对比 Iterator（迭代器）是一种设计模式，是一个对象，用于遍历集合中的所有元素。 Iterator 包含四个方法，分别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/phpstudy2015-6/p/10660457.html</dc:identifier>
</item>
<item>
<title>[java初探05]__数组的简单认识及Arrays类的常用方法 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10660450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10660450.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;数组是具有相同数据类型的一组数据的集合.在程序设计中,这样的集合称之为数组.数组的每个元素都具有相同的数据类型,在Java中数组也被看为一个对象.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在里,了解了数组的定义之后, 我们知道了,数组并不是简单的由一组数组成的.而是由一组具有相同数据类型的数据组成的,可以是一组整型的数据,也可以是一组字符型的数组,这里的数可以来理解为代表的是数据,而不是数字的意思.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果一维数组中的每一个元素任然是一个数组的话,那么它就构成了一个二维数组了.二维数组常用于表示表,表中的信息以行和列的形式组织.第一个代表元素的所在列,第二个下标是代表元素所在的列.&lt;/p&gt;
&lt;p&gt;在理解上,一维二维,就是线与面的关系,或者说一条数据和一个数据表的关系.面由线组成,表由一条条数据组成.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;创建一维数组,我们可以将代表数组的符号[]加在变量或者数据类型关键字后面,在通常情况下,数组的创建,都是使用第二种,及将[]加在数据类型关键字后面,这样在使用上,和在意义表达上也都要更加契合一些.&lt;/p&gt;
&lt;p&gt;而数组的创建,不仅要new一个数组出来,我们还的为它分配内存.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int a[]; // 声明int型数组
int[] b=new int[4]; // 声明的同时直接分配内存大小
a = new int [4]; //为其分配内存大小&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-a5528f0d9390cb3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-5-02.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;一维数组的初始化&lt;br/&gt;在前面我们知道了,数组的每个元素的表示,都是以数组的下标来表示的.那么我们想要对数组中的元素进行操作的化,必然要从数组的下标入手.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;静态初始化&lt;br/&gt;我们可以直接在创建数组的时候使用{}直接为数组初始化赋值,实现一步直接创建并初始化数组赋初值.这样就省略了分配内存的步骤.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;int[] b={1,2,3,4};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;动态初始化&lt;br/&gt;我们也可以直接通过数组的下标来直接对数组中的某个元素赋值初始化,称作动态初始化,动态初始化前,我们需要先为数组分配内存空间.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  int[] a;
        a =new int[4];
        a[0]=1;
        a[1]=2;
        a[3]=3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态初始化给数组赋值时,可以不对数组中的某些元素赋初始值,其将会输出为默认值0.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;二维数组的创建与初始化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二位数组前面我们说过了,就是在一维的基础上,再加一维.由线变面.&lt;br/&gt;所以二位数组的创建与初始化与一维数组的大同小异.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
int arr[][];
int[][] arr2;
arr2 = new int[2][4];

   int[][] c={{2,3},{12,13},{22,23}};
        System.out.println(c[0][1]);
        int[][] d=new int[3][4];
        d[0][0]=1;
        d[0][1]=2;
        d[0][2]=3;
        d[0][3]=4;
        d[1][0]=11;
        d[1][1]=12;
        d[1][2]=13;
        d[1][3]=14;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-37d1ff99457f51ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-5-03.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组操作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;遍历数组&lt;br/&gt;通过for循环遍历数组,将数组内容全部输出.一维数组的遍历十分简单:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;int[] a={1,2,3,4,5};
        for(int i=0;i&amp;lt;a.length;i++){
            System.out.print(a[i]+&quot;,&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;二维数组的遍历&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相对的,二维数组的遍历就要稍微复杂一些,我们观察一维数组的遍历,了解到实现原理是通过for循环,来循环输出对应下标的数组元素,每循环一次下标就加1,然后使条件小于数组的长度.&lt;/p&gt;
&lt;p&gt;那么二维数组的遍历应当可以使用一样的原理,不过二维数组有两个下标,怎么办呢,想来也是因该使用两个for循环来控制.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 二维数组的遍历
        int[][] b={{2,3,4,5},{12,13,14,15},{22,23,24,25}};
        for(int i=0;i&amp;lt;b.length;i++){ // 通过两个for循环遍历二维数组,外层循环遍历列的下标,
            for (int j=0;j&amp;lt;b[i].length;j++){  // 内存循环循环遍历行的下标.
                System.out.print(b[i][j]+&quot;,&quot;); //循环输出对应下标的元素.遍历出整个二维数组.
            }
            System.out.println(); // 输出换行(每行数据输出红后换行.)
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-fb420d26869df257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-5-04.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;替换数组元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Arrays类中给我们提供了fill方法用来填充后替换数组中的元素.其重载有多种方法提供不同形式的替换方式.fill(int[],int)方法可以将指定值替换(填充)到指定数组的所有元素中.fill(int[],int ,int,int)方法将指定值替换到指定范围的元素中,前两个int参数指定数组下标范围.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  //填充数组
        Arrays.fill(c,6);
        System.out.println(Arrays.toString(c));
        Arrays.fill(c,3,7,10);
        System.out.println(Arrays.toString(c));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;数组排序&lt;br/&gt;Arrays类中还提供了排序方法sort()其也重载有多个方法.最简单的排序方法sort(object)参数及需要排序的数组.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; Arrays.sort(c);
        System.out.println(Arrays.toString(c));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;复制数组&lt;br/&gt;Arrays类也提供有copyOf()方法和copyOfRange()方法用来将一个数组复制到另一个新数组中.copyOfrange()方法可以指定copy范围.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//copy数组
        int[] d=Arrays.copyOf(c,12);
        int[] e=Arrays.copyOfRange(c,3,7);
        System.out.println(Arrays.toString(d));
        System.out.println(Arrays.toString(e));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;数组查询&lt;br/&gt;Arrays类的binarySearch()方法,可使用二分法来搜索指定数组.其也提供有多种重载方式,可以在指定范围搜索数组.返回值为数组所在位置(不是返回其下标).&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//数组查询
          //数组查询
        System.out.println(Arrays.binarySearch(c,10));
        System.out.println(Arrays.binarySearch(c,5,7,10));
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;关于Arrays(数组)类的其他方法,我们可以打开Arrays类进行查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-0680a1d4f6d78ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-5-05.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于数组的学习笔记就暂且记录到这里,关于数组的排序,又涉及到排序算法,而排序算法的种类又有很多,之后会专门单独总结一篇文章来系统的学习排序算法.这里就不涉及数组的排序了.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.sql.SQLOutput;
import java.util.Arrays;

/**
 * @outhor xiaoshe
 * @date 2019/4/5  - @time 20:40
 * 数组
 */
public class Sty_Array {

    public static void main(String[] args) {
        Sty_Array sty_array = new Sty_Array();
        sty_array.create_array();
        sty_array.TraverArrays();

    }

    // 两种数组的创建,我们可以将代表数组的符号[]加给变量或者数据类型关键字.

    public void create_array(){
        // 一维数组
        int[] a;
        a =new int[4];
        a[0]=1;
        a[3]=3;
        System.out.println(a[3]);
        System.out.println(Arrays.toString(a));
        System.out.println(a.length);
        char[] b ={'a','b','c','d'};
        System.out.println(Arrays.toString(b));
        // 二维数组
        int[][] c={{2,3},{12,13},{22,23}};
        System.out.println(c[0][1]);
        int[][] d=new int[3][4];
        d[0][0]=1;
        d[0][3]=4;
        d[1][0]=11;
    }

    // 数组操作
    public void TraverArrays(){
        //一维数组的遍历
        int[] a={1,2,3,4,5};
        int[] c={3,6,2,4,1,7,9,8,0};
        for(int i=0;i&amp;lt;a.length;i++){
            System.out.print(a[i]+&quot;,&quot;);
        }
        System.out.println(&quot;\n----分界线-----&quot;);
        // 二维数组的遍历
        int[][] b={{2,3,4,5},{12,13,14,15},{22,23,24,25}};
        for(int i=0;i&amp;lt;b.length;i++){ // 通过两个for循环遍历二维数组,外层循环遍历列的下标,
            for (int j=0;j&amp;lt;b[i].length;j++){  // 内存循环循环遍历行的下标.
                System.out.print(b[i][j]+&quot;,&quot;); //循环输出对应下标的元素.遍历出整个二维数组.
            }
            System.out.println(); // 输出换行(每行数据输出红后换行.)
        }
        //数组排序
        Arrays.sort(c);
        System.out.println(Arrays.toString(c));
        //copy数组
        int[] d=Arrays.copyOf(c,12);
        int[] e=Arrays.copyOfRange(c,3,7);
        System.out.println(Arrays.toString(d));
        System.out.println(Arrays.toString(e));
        //填充数组
        Arrays.fill(c,6);
        System.out.println(Arrays.toString(c));
        Arrays.fill(c,3,7,10);
        System.out.println(Arrays.toString(c));
        //数组查询
        System.out.println(Arrays.binarySearch(c,10));
        System.out.println(Arrays.binarySearch(c,5,7,10));
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;更新时间:&lt;br/&gt;2019-4-5&lt;br/&gt;23:14&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 15:22:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>数组是具有相同数据类型的一组数据的集合.在程序设计中,这样的集合称之为数组.数组的每个元素都具有相同的数据类型,在Java中数组也被看为一个对象. 在里,了解了数组的定义之后, 我们知道了,数组并不是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10660450.html</dc:identifier>
</item>
<item>
<title>锁住余额，为何还会更新异常？ - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10660434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10660434.html</guid>
<description>&lt;p&gt;现有一个交易系统，每次交易都会更新余额。出账扣减余额，入账增加余额。为了保证资金安全，余额发生扣减时，需要比较现有余额与扣减金额大小，若扣减金额大于现有余额，扣减余额不足，扣减失败。&lt;/p&gt;
&lt;p&gt;余额表（&lt;em&gt;省去其他字段&lt;/em&gt;）结构如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;
CREATE TABLE `account`
(
  `id`      bigint(20) NOT NULL,
  `balance` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_bin;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新余额方法语序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553521924155-31cf0b6d-7bc9-43bb-92d7-bae39ed062e9.png&quot; alt=&quot;更新余额 sql 语序&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于存在并发更新余额的情况，在 t3 时刻，使用写锁锁住该行记录。这样就能保证事务执行期间不会有其他事务提交变更。&lt;/p&gt;
&lt;p&gt;现在我们假设有两个事务正在发执行该语序，执行顺序如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553603883962-58e72fd5-e659-4eb9-8813-bfcd3d669383.png&quot; alt=&quot;并发语序&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设 id=1 记录 balance=1000，事务隔离等级为 RR。小伙伴们可以根据这个执行时序可以先思考下 t3,t5,t6,t7 结果。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注： 以上时序，顺序执行。但是事务 1 执行到 t3 时刻，t4 时刻，事务 2 执行时将会被阻塞，后续无法执行。&lt;br/&gt;t4 时刻之后，只能先将 事务 1 语序执行，事务提交完成后，才能执行 事务 2 剩余语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面放出问题的答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;t3 (1,1000)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;t5 (1,1000)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;t4 (1,900)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;t6 (1,1000)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有没有跟你结果的不太一样？&lt;/p&gt;
&lt;p&gt;事务 1 查询结果基本没什么问题，事务 2 同一个事务内查询结果却不同。&lt;/p&gt;
&lt;p&gt;现在我们先带着疑问，看完下面 MySQL 的相关原理，你就会明白一切。&lt;/p&gt;
&lt;h2 id=&quot;相关原理&quot;&gt;相关原理&lt;/h2&gt;
&lt;h3 id=&quot;mvcc&quot;&gt;MVCC&lt;/h3&gt;
&lt;p&gt;假设在 RR 下，下图 &lt;em&gt;id=1 balance=1000&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1554298213401-c149ef82-05b7-4249-9ab4-8009be7ee56b.png&quot; alt=&quot;更新时序&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上图时序顺序可以执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务 1 将 id=1 记录 balance 更新为 900。然后 t5 查询结果肯定还是 &lt;em&gt;id=1 balance=1000&lt;/em&gt;，不然就读取到&lt;strong&gt;脏数据&lt;/strong&gt;，不符合当前事务隔离级别。&lt;/p&gt;
&lt;p&gt;从上面例子可以看到 id=1 的记录存在两个版本，一个为 &lt;em&gt;balance=1000&lt;/em&gt; ，一个为 &lt;em&gt;balance=900&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;MySQL 使用 MVCC 实现该功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVCC：Multiversion concurrency control&lt;/strong&gt;，多版本并发控制。摘录一段淘宝数据库月报的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到 MVCC 主要用来提高并发，还可以用来读取老版本数据。下面介绍 MVCC 实现的原理。&lt;/p&gt;
&lt;p&gt;首先我们先看下 MySQL 记录结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553605546873-d59eb925-39f5-4c8d-bea2-472a7d7084a4.png&quot; alt=&quot;行记录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 MySQL 行记录除了真实数据以外，还会存在三个隐藏字段，用来记录额外信息。&lt;/p&gt;
&lt;p&gt;DB_TRX_ID:事务id。&lt;br/&gt;DB_ROLL_PTR: 回滚指针，指向 undolog。&lt;br/&gt;ROW_ID：行 id,与此次无关。&lt;/p&gt;
&lt;blockquote readability=&quot;4.2209302325581&quot;&gt;
&lt;p&gt;具体行记录结构，可以参考掘金的小册『 &lt;a href=&quot;https://juejin.im/book/5bffcbc9f265da614b11b731&quot;&gt;MySQL 是怎样运行的：从根儿上理解 MySQL&lt;/a&gt;』，说实话小册写的真的很好，收益颇丰。哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL 通过 DB_ROLL_PTR 找到 undolog，而 undolog 记录数据的变更。这样 MySQL 就能推导出变更之前记录内容。&lt;/p&gt;
&lt;p&gt;查找过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553605512647-dd50a0ec-d8e2-4d71-81fb-55c26dda64ed.png&quot; alt=&quot;查找过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若需要知道 V1 版本记录，首先根据当前版本 V3 的 &lt;strong&gt;DB_ROLL_PTR&lt;/strong&gt; 找到 &lt;strong&gt;undolog&lt;/strong&gt;，然后根据 &lt;strong&gt;undolog&lt;/strong&gt; 内容，计算出上一个版本 V2。以此类推，最终找到 V1 这个版本记录。&lt;/p&gt;
&lt;p&gt;V1，V2 并不是物理记录，没有真实存在，仅仅具有逻辑意义。&lt;/p&gt;
&lt;p&gt;一行数据记录可能同时存在多个版本，但并不是所有记录都能对当前事务可见。不然上面 t5 就可能查询到最新的数据。所以查找数据版本时候 MySQL 必须判断数据版本是否对当前事务可见。&lt;/p&gt;
&lt;h3 id=&quot;一致性视图&quot;&gt;一致性视图&lt;/h3&gt;
&lt;p&gt;MySQL 会在事务开始后建立一个一致性视图（&lt;em&gt;并不是立刻建立&lt;/em&gt;），在这个视图中，会保存所有活跃的事务(&lt;em&gt;还未提交的事务&lt;/em&gt;)。&lt;/p&gt;
&lt;p&gt;假设当前事务创建活跃事务数组为如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553693518940-96ad3291-e932-49cb-9619-c04144e21ebd.png&quot; alt=&quot;视图数组&quot;/&gt;&lt;/p&gt;
&lt;p&gt;判断记录版本对于当前事务是否可见时，基于以下规则判断：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若记录版本事务 id 小于当前活跃事务 id 数组最小值,如 id 为 40，小于 45,代表当前记录版本的事务已提交，当前记录对于当前事务可见。&lt;/li&gt;
&lt;li&gt;若记录版本事务 id 大于当前活跃事务数组的最大值，如记录版本事务 id 为 100， 大于数组最大事务 id 90。说明了这个记录版本是当前事务创建之后生成，所以记录对于当前事务不可见。&lt;/li&gt;
&lt;li&gt;若记录版本事务 id 是当前活跃数组事务之一，如记录数据版本事务 id 为 56。代表记录版本所属事务还未提交，所以记录对于当前事务不可见。&lt;/li&gt;
&lt;li&gt;若记录版本事务 id 不是当前活跃数组事务之一，但是事务 id 位于数组最小值与最大值之一。如记录事务 ID 57。代表当前记录事务已提交，所以记录对于当前事务可见。&lt;/li&gt;
&lt;li&gt;若记录版本事务 id 为当前事务 id，代表该行数据是当前事务变更的，当然得可见。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4 这个规则可能比较绕，结合上面图片比较好理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上判断规则可能比较抽象，我们将其总结下面几句话。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;未提交事务生成的记录版本，不可见。&lt;/li&gt;
&lt;li&gt;视图生成前，提交事务生成记录版本可见。&lt;/li&gt;
&lt;li&gt;视图生成后，提交事务生成记录版本不可见。&lt;/li&gt;
&lt;li&gt;自身事务更新永远可见。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一致性视图只会在 RR 与 RC 下才会生成，对于 RR 来说，一致性视图会在&lt;strong&gt;第一个查询语句&lt;/strong&gt;的时候生成。而对于 RC 来说，每个查询语句都会重新生成视图。&lt;/p&gt;
&lt;h3 id=&quot;当前读与快照读&quot;&gt;当前读与快照读&lt;/h3&gt;
&lt;p&gt;MySQL 使用 MVCC 机制，可以 读取之前版本数据。这些旧版本记录不会且也无法再去修改，就像快照一样。所以我们将这种查询称为快照读。&lt;/p&gt;
&lt;p&gt;当然并不是所有查询都是快照读，select .... for update/ in share mode 这类加锁查询只会查询当前记录最新版本数据。我们将这种查询称为当前读。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;讲完原理之后，我们回过头分析一下上面查询结果的原因。&lt;/p&gt;
&lt;p&gt;这里我们将上面答案再贴过来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553695040133-00e840bd-99ce-4f46-8c7a-b717b4cc5bab.png&quot; alt=&quot;答案&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事务隔离级别为 RR，t1，t2 时刻两个事务由于查询语句，分别建立了一致性视图。&lt;/p&gt;
&lt;p&gt;t3 时刻，由于事务 1 使用 &lt;code&gt;select.. for update&lt;/code&gt; 为 id=1 这一行上了一把写锁，然后获取到最新结果。而 t4 时刻，由于该行已被上锁，事务 2 必须等待事务 1 释放锁才能继续。&lt;/p&gt;
&lt;p&gt;t5 时刻根据一致性视图，不能读取到其他事务提交的版本，所以数据没变。t7 时刻余额扣减 100，t8 时刻提交事务。&lt;/p&gt;
&lt;p&gt;此时最新版本记录为 &lt;strong&gt;id=1 balance=900&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于事务 1 事务提交，行锁被释放，t4 获取到写锁。由于 t4 是当前读，所以查询的结果为最新版本数据（1,900）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点来了&lt;/strong&gt;。t6 查询时，id=1 这条记录最新版本数据为 &lt;strong&gt;（1,900）&lt;/strong&gt;。但是最新版本事务 id，属于事务 2创建之后未提交的事务，位于活跃事务数组中。所以最新记录版本对于事务2 是不可见的。没办法只能根据 undolog 去读取上一版本记录 &lt;strong&gt;(1,1000)&lt;/strong&gt; 。这个版本记录刚好对于事务 2 可见。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;若当前事务隔离级别修改成 RC,那么结果就与 RR 不同。各位读者自行分析一下。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面贴一下 RC 答案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1553695417855-dde81b63-6f58-4b3b-a979-b4007d1ca2c0.png&quot; alt=&quot;RC 下结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;帮助文档&quot;&gt;帮助文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html&quot;&gt;&lt;strong&gt;mysql mvcc&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mysql.taobao.org/monthly/2017/12/01/&quot;&gt;&lt;strong&gt;淘宝月报&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mysql.taobao.org/monthly/2018/11/04/&quot;&gt;&lt;strong&gt;innodb 相关实现&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html&quot;&gt;&lt;strong&gt;consistent-read&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;极客时间- MySQL 专栏--事务到底是隔离的还是不隔离的&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>一次余额更新异常问题分析！！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10660434.html</dc:identifier>
</item>
<item>
<title>Python 学习 第十三篇：数据的读写-文件、DataFrame、json和pymssql - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/10572063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/10572063.html</guid>
<description>&lt;p&gt;Python的文件是一个重要的对象，使用open()函数来打开文件，创建文件对象，进行文件的读写操作。当数据用于交换信息时，通常需要把数据保存为有格式的文本数据，可以保存为有特定的行分隔符和列分隔符的数据，这可以使用pandas模块中的函数来读写；也可以保存为json结构的数据，这可以使用json模块中的函数来实现；对于大型的数据交互，通常使用数据库。&lt;/p&gt;
&lt;h2&gt;一，Python的open函数&lt;/h2&gt;
&lt;p&gt;open()函数用于打开文件，创建文件对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
open(name, mode, encoding=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;p&gt;name是文件名，包括路径&lt;/p&gt;
&lt;p&gt;encoding 是编码方式，常用的编码方式是utf-8&lt;/p&gt;
&lt;p&gt;mode是打开文件的模式，最常用的模式是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;r：只读模式，表示打开文件是为了从文件的开头读取文件中的数据；&lt;/li&gt;
&lt;li&gt;w：只写模式，表示打开文件是为了向文件写入数据。如果该文件已存在，那么打开该文件，删除原有的内容，从文件开头开始写入；如果该文件不存在，那么创建新的文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;open()函数创建一个file 对象，文件对象的主要方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;file.read([size])：size 未指定则返回整个文件，如果文件大小 &amp;gt;2 倍内存则有问题，f.read()读到文件尾时返回&quot;&quot;(空字串)。&lt;/li&gt;
&lt;li&gt;file.readline()：只读取一行。&lt;/li&gt;
&lt;li&gt;file.readlines([size]) ：返回包含size行的列表, size 未指定则返回全部行。&lt;/li&gt;
&lt;li&gt;for line in f: print( line )：通过迭代器访问。&lt;/li&gt;
&lt;li&gt;f.write(&quot;hello\n&quot;)：如果要写入字符串以外的数据,先将他转换为字符串。&lt;/li&gt;
&lt;li&gt;f.close() 关闭文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1，读取文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用open()函数打开一个文件，设置mode='r'，表示打开文件是为了读取文件中的数据，调用文件对象的函数或迭代器来逐行读取数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
file = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;',encoding='utf-8'&lt;/span&gt;&lt;span&gt;)
lines &lt;/span&gt;= [line.strip() &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file] 
file.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：打开文件之后，完成文件的读写之后，必须调用文件对象的close()方法，最终关闭文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，写入文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用open()函数打开一个文件，如果设置mode='w'，那么表示打开文件是为了向文件中写入数据，调用文档对象的write('content')函数向文档中写入内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
file = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
file.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;write content to file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
file.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：打开文件之后，完成文件的读写之后，必须调用文件对象的close()方法，最终关闭文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，文件的关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用open()函数打开一个文件，是把文件读取到内存中的，如果不及时关闭文件，文件对象就会一直占用系统资源，除了调用文件对象的close()方法关闭文件之外，还可以使用 with open()，由系统自动关闭文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;',encoding='utf-8'&lt;/span&gt;&lt;span&gt;) as file:
    lines &lt;/span&gt;= [line.strip() &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; file] 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二，pandas模块&lt;/h2&gt;
&lt;p&gt;pandas模块提供了一些用于把表格型数据读取为DataFrame对象的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，格式化数据的读取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;read_csv：从文件、URL、文件型对象中加载带分隔符的数据，默认的分隔符是逗号。&lt;/p&gt;
&lt;p&gt;read_table：从文件、URL、文件型对象中加载带分隔符的数据，默认的分隔符是制表符(\t)。&lt;/p&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;path：要读取的文件的位置&lt;/li&gt;
&lt;li&gt;sep：用于对行中各字段进行拆分的字符序列或正则表达式&lt;/li&gt;
&lt;li&gt;header：用作列名的行号，默认值是0，如果没有header行，设置为None&lt;/li&gt;
&lt;li&gt;index_col：用于行索引的列编号&lt;/li&gt;
&lt;li&gt;names：用于自定义列名列表，结合header=None&lt;/li&gt;
&lt;li&gt;na_values：一组用于替换NA的值&lt;/li&gt;
&lt;li&gt;iterator：返回一个TextParser以便逐块读取文件&lt;/li&gt;
&lt;li&gt;chunksize：文件的大小，用于迭代&lt;/li&gt;
&lt;li&gt;nrows：需要读取的行数，从文件开始处计算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; 2，输出数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用DataFrame的to_csv方法，可以把数据写到一个以逗号分隔的文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
DataFrame.to_csv(path_or_buf=None, sep=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, na_rep=&lt;span&gt;''&lt;/span&gt;, float_format=None, columns=&lt;span&gt;None, 
header&lt;/span&gt;=True, index=True, index_label=None, mode=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=None, compression=&lt;span&gt;None, 
quoting&lt;/span&gt;=None, quotechar=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, line_terminator=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, chunksize=None, tupleize_cols=&lt;span&gt;None, 
date_format&lt;/span&gt;=None, doublequote=True, escapechar=None, decimal=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;path_or_bu：输出文件的路径，或者设置sys.stdout&lt;/li&gt;
&lt;li&gt;sep：行中个字段的分隔符，默认是逗号&lt;/li&gt;
&lt;li&gt;na_rep：替换缺失数据的字符&lt;/li&gt;
&lt;li&gt;columns：列名列表&lt;/li&gt;
&lt;li&gt;header：是否输出header，默认值是True&lt;/li&gt;
&lt;li&gt;index：是否输出索引，默认是True&lt;/li&gt;
&lt;li&gt;line_terminator：列分隔符&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;三，json&lt;/h2&gt;
&lt;p&gt;Python中的json对象实际是一个字典结构，用于存储和交换信息，导入json模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，把字符串转换为json&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;json的load()方法用于把josn格式的字符串转换为json对象，这实际上是一个字典结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
json_string=  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{ &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:30, &quot;city&quot;:&quot;New York&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; parse string to json&lt;/span&gt;
json_obj = json.loads(json_string)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，把字典转换为json字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;json的dumps()函数用于把字典结构转换为json格式的字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
x =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 30&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New York&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert dict into JSON string:&lt;/span&gt;
json_string = json.dumps(x)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四，关系型数据库&lt;/h2&gt;
&lt;p&gt;使用pymssql连接SQL Server数据库，首先创建连接和游标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymssql

conn &lt;/span&gt;= pymssql.connect(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,database=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
cursor &lt;/span&gt;= conn.cursor() &lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行select语句获得数据时，返回的数据集有两种格式：元组和字典，这需要在创建游标时设置，as_dict的默认值是False。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cursor = conn.cursor(as_dict=True) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，执行数据更新和删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过游标的execute()函数来执行TSQL语句，调用 commit() 来提交事务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cursor.execute(&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
sql statement
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)　　

conn.commit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，执行数据的多行插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用游标的executemany()函数来插入多行数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cursor.executemany(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO persons VALUES (%d, %s, %s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    [(&lt;/span&gt;1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;John Smith&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;John Doe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
     (&lt;/span&gt;2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jane Doe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Joe Dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
     (&lt;/span&gt;3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mike T.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sarah H.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
conn.commit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，遍历数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当从SQL Server数据库中获取数据时，使用游标的fetchone()函数，以迭代方式返回结果集的一行数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT * FROM persons WHERE salesrep=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;John Doe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历数据（存放到元组中） 方式1&lt;/span&gt;
row =&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; row:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID=%d, Name=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[0], row[1&lt;span&gt;]))
    row &lt;/span&gt;=&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历数据（存放到元组中） 方式2&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cursor:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;row = %r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (row,))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历数据（存放到字典中）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; cursor = conn.cursor(as_dict=True)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; cursor.execute('SELECT * FROM persons WHERE salesrep=%s', 'John Doe')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for row in cursor:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(&quot;ID=%d, Name=%s&quot; % (row['id'], row['name']))&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4，关闭连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当查询完成之后，一定要关闭连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用with来自动关闭连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymssql 

server &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;187.32.43.13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
user &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;　　

with pymssql.connect(server, user, password, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as conn:
    with conn.cursor(as_dict&lt;/span&gt;=True) as cursor:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据存放到字典中&lt;/span&gt;
        cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT * FROM persons WHERE salesrep=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;John Doe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cursor:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID=%d, Name=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], row[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yyds/p/6186621.html&quot; target=&quot;_blank&quot;&gt;Python之文件读写&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010801439/article/details/80033341&quot; target=&quot;_blank&quot;&gt;pandas系列 read_csv 与 to_csv 方法各参数详解（全，中文版）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3schools.com/python/python_json.asp&quot; target=&quot;_blank&quot;&gt;Python JSON&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/malcolmfeng/p/6909293.html&quot; target=&quot;_blank&quot;&gt;python连接sql server数据库实现增删改查&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Apr 2019 15:03:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>Python的文件是一个重要的对象，使用open()函数来打开文件，创建文件对象，进行文件的读写操作。当数据用于交换信息时，通常需要把数据保存为有格式的文本数据，可以保存为有特定的行分隔符和列分隔符的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/10572063.html</dc:identifier>
</item>
<item>
<title>linux进程管理总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10660355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10660355.html</guid>
<description>&lt;h2 id=&quot;一进程相关的概念&quot;&gt;一、进程相关的概念&lt;/h2&gt;
&lt;p&gt;进程需要了解 进程，父进程，进程组,会话和控制终端的相关概念。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;进程和父进程：每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;进程组：每个进程都会属于一个进程组(process group)，每个进程组中可以包含多个进程。进程组会有一个进程组领导进程 (process group leader)，领导进程的PID成为进程组的ID (process group ID, PGID)，以识别进程组。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;kill给组发送信号进程组号前加负号如：kill -9 -2189&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;会话：一个或是多个进程组集合。 进程可以通过调用 pid_t setsid(); 来建立一个新会话，如果调用此函数的进程不是进程组长，就会创建一个新的会话，那么此时会：
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;该进程称为会话首进程 (session leader)&lt;/li&gt;
&lt;li&gt;该进程称为进程组组长&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;该进程没有控制终端，即使之前有控制终端这种联系也会断掉&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以使用第三个特性来创建 daemon 进程。 调用 getsid 可以获得会话首进程进程组 pid，也就是会话首进程进程 id。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;控制终端：
&lt;ol&gt;&lt;li&gt;一个会话持有一个控制终端 (controlling terminal)，可以是终端设备也可以是伪终端&lt;/li&gt;
&lt;li&gt;建立与控制终端连接的会话首进程被称为控制进程 (controlling process)&lt;/li&gt;
&lt;li&gt;一个会话有多个进程组，允许存在多个后台进程组 (backgroup process group) 和一个前台进程组 (foregroup process group)&lt;/li&gt;
&lt;li&gt;键入终端的中断键 (Ctrl+C) 会发送中断信号给前台进程组所有进程&lt;/li&gt;
&lt;li&gt;键入终端的退出键 (Ctrl+) 会发送退出信号给前台进程组所有进程&lt;/li&gt;
&lt;li&gt;终端或是网络断开会将挂断信号发送给会话首进程&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到执行ps -fj结果如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
UID         PID   PPID   PGID    SID  C STIME TTY          TIME CMD
chen      36829  36825  36829  36829  0 10:56 pts/0    00:00:00 -bash
chen      37247  36829  37247  36829  0 10:57 pts/0    00:00:00 vim
chen      90490  36829  90490  36829  0 11:57 pts/0    00:00:00 ps -fj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中PID就是进程id，PPID是父进程id，PGID为进程组id，SID为会话ID&lt;/p&gt;
&lt;h2 id=&quot;二关闭会话时子进程进程被杀死&quot;&gt;二、关闭会话时子进程进程被杀死&lt;/h2&gt;
&lt;p&gt;终端在关闭时会发送SIGHUP信号给session leader，此处就是bash进程，bash收到后向session内的所有进程发送SIGHUP然后退出。&lt;br/&gt;SIGHUP信号如果为注册处理函数默认行为就是退出。所以会话退出时子进程都被杀死。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册SIGHUP信号处理函数：可以在代码中处理或者使用nohup命令&lt;/li&gt;
&lt;li&gt;重新设置setsid：可以在代码中处理或者使用setsid命令&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三nohup的原理&quot;&gt;三、nohup的原理&lt;/h2&gt;
&lt;p&gt;其实很简单就是注册了SIGHUP的一个处理函数，忽略这个信号，然后去执行实际的命令。&lt;br/&gt;源码地址：&lt;a href=&quot;https://github.com/MaiZure/coreutils-8.3/blob/master/src/nohup.c&quot; class=&quot;uri&quot;&gt;https://github.com/MaiZure/coreutils-8.3/blob/master/src/nohup.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关键代码：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;   // 注册处理函数
  signal (SIGHUP, SIG_IGN);

  char **cmd = argv + optind;
  //执行实际的代码
  execvp (*cmd, cmd);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四setsid原理&quot;&gt;四、setsid原理&lt;/h2&gt;
&lt;p&gt;fork进程之后的子进程共享父进程的很多东西，并且会话组长就是父进程的会长组长，所以会收到来自父进程会话组长的信号。&lt;br/&gt;setsid用余新建一个会话，调用这个函数之后会当当前进程成为进程组组长和会话组组长，那么原来的会话产生的信号便不会发送到这个进程，从而不会受影响。&lt;/p&gt;
&lt;h2 id=&quot;五daemon-和守护进程的区别&quot;&gt;五、daemon &amp;amp;和守护进程的区别&lt;/h2&gt;
&lt;h2 id=&quot;六服务进程为什么要fork两次&quot;&gt;六、服务进程为什么要fork两次&lt;/h2&gt;
&lt;p&gt;首先说明两次不是必须的，有很多程序都采用了一次fork。&lt;/p&gt;
&lt;p&gt;第一次：为了调用setsid，这也解释了为什么调用setsid之前需要先fork的原因：&lt;br/&gt;linux规定调用这个函数之前,当前进程不允许是session leader。进程组leader是该进程组的第一个进程，fork出来的进程必定不是第一个，所以可以调用setsid。另外父进程一般直接退出，可以让shell收到进程结束的通知继续执行，而不是等待他结束。&lt;/p&gt;
&lt;p&gt;第二次：为了限制进程打开控制终端，只有会话组长能打开控制终端（非必须，相当于加了个限制条件Daemon不需要打开终端）&lt;/p&gt;
&lt;h2 id=&quot;七systemd管理daemon&quot;&gt;七、systemd管理daemon&lt;/h2&gt;
&lt;p&gt;现在很多的linux发行版都采用systemd来代替原来的init程序，systemd提供了很优秀的进程管理功能，我们需要注册服务时可以利用systemd功能，可以参看鸟哥的systemd介绍。&lt;/p&gt;
&lt;p&gt;另外补充点内核进程和Systemd进程：&lt;br/&gt;0号进程为内核进程，1号为Systemd进程，其他还有些内核进程在ps命令查看时以[]包裹。具体关系见：&lt;a href=&quot;https://coolshell.cn/articles/17998.html&quot;&gt;LINUX PID 1 和 SYSTEMD&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;八僵尸进程&quot;&gt;八、僵尸进程&lt;/h2&gt;
&lt;p&gt;这个定义摘抄自维基百科：在类UNIX系统中，僵尸进程是指完成执行（通过exit系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于&quot;终止状态&quot;的进程。这发生于子进程需要保留表项以允许其父进程读取子进程的exit status：一旦退出态通过wait系统调用读取，僵尸进程条目就从进程表中删除，称之为&quot;回收（reaped）&quot;。&lt;/p&gt;
&lt;h2 id=&quot;九进程名字和启动时指定进程名字&quot;&gt;九、进程名字和启动时指定进程名字&lt;/h2&gt;
&lt;p&gt;kill，ps，top，pstree这些命令都比较熟悉就不再提了。&lt;/p&gt;
&lt;p&gt;至于还有一组命令则不是通过进程号而是通过进程名字来操作进程，pkill和killall一样都是通过名字来杀死进程，而pgrep是通过名字来寻找进程。&lt;br/&gt;他们的原理都是通过查找/proc这个内存文件系统。&lt;/p&gt;
&lt;p&gt;在启动的时候可以通过exec命令重命名：&lt;br/&gt;&lt;code&gt;bash -c &quot;exec -a myname sleep 500 &amp;amp;&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你可以通过&lt;code&gt;ps -ef|grep myname&lt;/code&gt;来查看进程的详细信息&lt;/p&gt;
&lt;h2 id=&quot;十source-command和.command-和exec命令的区别&quot;&gt;十、source command和./command 和exec命令的区别&lt;/h2&gt;
&lt;p&gt;通常执行脚本有三种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;./command(同sh command)&lt;/li&gt;
&lt;li&gt;source command(同. command)&lt;/li&gt;
&lt;li&gt;exec command&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单说明下上面三种方式：&lt;/p&gt;
&lt;p&gt;第一种其实就是对应了linux的fork系统调用，在执行command时候，command是在子进程中执行的，当前shell等待直到子进程的command运行完毕在返回到当前shell。第二种则是直接在当前的进程中直接执行，执行完继续接受用户输入。第三种则对应了linux的exec系统调用，当前进程的执行流程会转向command，command是在当前进程直接执行，但是执行完之后便会直接退出。&lt;/p&gt;
&lt;p&gt;所以我们一般用的是第一和第二两种，这种的主要区别就是开不开新的进程（开进程是要一定开销的），另外因为第二种是在当前进程执行的，所以如果在command中设置了变量，那么相当于在当前进程中设置了变量，所以我们一般是用第一种去执行避免当前进程的变量被污染。&lt;/p&gt;
&lt;p&gt;思考：&lt;/p&gt;
&lt;p&gt;现在加入你在终端已经运行了一个非常耗时的任务，你按ctrl+z放入了后台，然后利用bg开始任务，因为终端断开就会收到SIGHUP信号，有没有办法忽略这个信号或者终端断开不收到这个信号？&lt;/p&gt;
&lt;p&gt;遗留：&lt;/p&gt;
&lt;p&gt;进程调试工具：ltrace strace ftrace&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://my.oschina.net/hosee/blog/507098&quot;&gt;Linux进程组和会话&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zdyi.com/books/apue/&quot;&gt;在线APUE译文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ybxuwei/article/details/77149575&quot;&gt;linux终端关闭时为什么会导致在其上启动的进程退出？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 05 Apr 2019 14:51:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 一、进程相关的概念 进程需要了解 进程，父进程，进程组,会话和控制终端的相关概念。 1. 进程和父进程：每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构 2. 进程组：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10660355.html</dc:identifier>
</item>
<item>
<title>大龄码农那些事——浅谈技术变现 - helloyaren</title>
<link>http://www.cnblogs.com/helloyaren/p/10660043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloyaren/p/10660043.html</guid>
<description>&lt;p&gt;       关于这个话题，其实园子里已经有不少园友发表自己的一些高见，我个人看到之后也深受启发的。对于变现这个词，在互联网时代，尤其对于码农来说应该是不陌生的，如经常听到“大数据变现”，“商业变现”等热门词语。其实往俗了说，变现就是赚钱。关于赚钱，我认为君子赚钱取之有道，只要不违法，我们大可不必避讳什么。在如今这个商业社会，没有钱，寸步难行。今天我就谈谈个人了解的几个技术变现的渠道或者方法，欢迎大家拍砖。&lt;/p&gt;
&lt;p&gt;       1、接私活&lt;/p&gt;
&lt;p&gt;       在程序员圈子，这个应该是我们最常见的程序变现方式。一般而言，只要你的技术还算凑合，然后朋友或者同事比较认可你，那么你大有机会获得接私活。我作为过来人，可以说在我的工作过程也接过不少私活。金额从几百到几万甚至几十万的都有。我这人其实平时也算比较懒，除了工作之外，也懒得自己去主动找些私活。不过平时在公司人缘还可以，技术上也被同事认可，所以他们一旦有机会接到项目，就会把一些技术上的事交给我办。为什么大家愿意把私活给我？我自己总结起来有这么几个原因：报价比较公道，另外有时也能以帮忙性质去接活，说到底就是让利给他们；认真负责，及时交付。也就是一旦接私活，就尽量按照规定时间内交付；最后我觉得还是相互信任，就是别人把活给你，最看重的应该是信任你，相信你能把这事做好。否则你即时其它再好，估计别人也不会考虑你。这个也是社会上常见的熟人生意。&lt;/p&gt;
&lt;p&gt;      关于接私活，我个人认为，码农虽然我这么说，但是我们不能妄自菲薄，我们跟画家一样，也属于创作型的工作，凭自己的手艺吃饭，无可厚非。不过前提是尽量不要影响自己的正常工作，另外最值得注意的是上班的时候别做私活，这个是职业道德问题。&lt;/p&gt;
&lt;p&gt;      其实关于接私活还有一些常见的来源可以跟大家说说，但是我个人并不推荐这么做。据我所知，有一些码农，尤其处于有一些权力岗位的码农，可能会利用公司的一些漏洞，把一些原本属于自己的工作的活，以私活的形式承接下来。虽然短期收益不菲，但是一旦被公司发现，将会导致严重后果。大家请三思。&lt;/p&gt;
&lt;p&gt;     2、做自媒体、写技术博客&lt;/p&gt;
&lt;p&gt;     现在自媒体已经很是发达了，很多程序员也纷纷试水自媒体，尤其在今日头条上看到不少中年码农、女码农以vlog的形式运营，本质还是靠吸引更多流量然后通过广告分成。能做自媒体或者写技术博客的，一般都是技术上比较厉害的人，对于技术一般的人，很难坚持下来。另外园子出现一些关于变现的博文，本质来说也是为了流量，当然我也不例外。不过这个不失为一种途径，而且很容易看到收益。&lt;/p&gt;
&lt;p&gt;     3、出书、做培训&lt;/p&gt;
&lt;p&gt;     这两种方式都是常见的，很多技术牛人都出书了，园子里就有很多。另外还有一些人通过给别人培训来实现变现。出书需要花费个人很大的精力和时间去做，这种方式一般人可能做不了。做培训除了需要口才之外还需要一定的技术，不过培训这种感觉比出书要相对容易，毕竟是技能，可以通过后期的训练来获得的，虽然有难度，但是我觉得这个不失为大龄码农的一种技术变现的重要途径。&lt;/p&gt;
&lt;p&gt;     4、做适合市场的软件&lt;/p&gt;
&lt;p&gt;      这种方式其实对于一般技术不是特别牛的人来说，是很好的。比如做小程序、H5游戏、定制类软件等。通过研究市场的需求，开发出适合市场需求软件，这是我个人比较推荐的方式，风险很小，不过需要你善于去寻找和发现商机。这个也是我们码农需要加强的地方，不能只顾埋头搬砖，不抬头看看外面的市场。说到底，技术离开市场一文不值。&lt;/p&gt;
&lt;p&gt;     5、技术创业&lt;/p&gt;
&lt;p&gt;      这个大家估计熟悉如今日头条的张一鸣就属于此类了，当然中国还有很多通过技术创业最终获得成功的码农，这个也是我们每个人追求的。技术创业风险很高，收益也相对较高。&lt;/p&gt;
&lt;p&gt;    以上5点就是我个人了解的技术变现的方式，最后给大家留几个问题供讨论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你还了解其它技术变现途径吗？&lt;/li&gt;
&lt;li&gt;你尝试技术变现了吗？你通过何种方式进行的呢？&lt;/li&gt;
&lt;li&gt;你认为知识变现前景如何？你现在购买过付费的技术课程了吗？&lt;/li&gt;
&lt;li&gt;你认为码农知识变现都有哪些优势和劣势呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1644550/201904/1644550-20190405215421714-832599598.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 13:36:00 +0000</pubDate>
<dc:creator>helloyaren</dc:creator>
<og:description>关于这个话题，其实园子里已经有不少园友发表自己的一些高见，我个人看到之后也深受启发的。对于变现这个词，在互联网时代，尤其对于码农来说应该是不陌生的，如经常听到“大数据变现”，“商业变现”等热门词语。其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloyaren/p/10660043.html</dc:identifier>
</item>
<item>
<title>新公司的第一个任务-重构系统(一) - 工藤-新一</title>
<link>http://www.cnblogs.com/gt-xy/p/10660028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gt-xy/p/10660028.html</guid>
<description>&lt;p&gt;     &lt;span&gt;辞职后想了一段时间，最终还是换了个城市工作，最近刚上班，陌生的城市还是有一股孤独感，麻将一缺三。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上班后的第一个任务领导就让我重构一下系统，我下意识就回答重构坑很深，想建议小步定期重构追求慢而稳，后面了解了下原因后也只能上手开始搞了。这套系统代码量只有不到3W行代码，不过这套系统的代码是我见过最糟糕的代码，十分脆弱，一个UI的类把所有的组件都耦合在一起了，业务逻辑的许多行为都在UI类中，存在几千行的函数里面功能不单一，没有注释命名也不清楚，具名变量没有几个都是魔数，等等等等，确实可以说是一份会让人奔溃的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 因为重构的任务确实难得，所以想记录一下自己重构过程的一些心得以及即将要踩的坑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 下面说一下目前自己重构的思路：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、解耦&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 重构之前领导要我搞个架构设计给它，其实我认为重构这套系统很多架构设计需要考虑的东西都不需要，最重要的还是水平层次的UI、业务逻辑、数据库以及设备控制解耦以及垂直层次的业务间解耦。这套系统耦合太高，开发成本真的是高，因为都是项目型开发只会修改几行代码适应不同项目还没有什么深刻认识，前几天我问一个准备在系统增加功能的同事，是不是加个功能就寸步难行了？他回答是。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 花了点时间把系统的解耦划分好，大致方向就确认好，也定制了一些重构过程中的机制。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、测试保证&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 重构还是要追求慢而稳，改的越多坑越深，很慌。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 部门内部质量保证的机制太少了，没有静态代码检查工具也没有单元测试工具，所以重构前就先把单元测试框架给搭建起来，当然关于测试我只打算测试重要的部分，粒度太细的话整个过程成本高效果也不高，测试的目的只保证重构没出错。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、重构工具&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 想看看有什么可以用得上的重构工具，后面查了下没什么合适的就不打算用了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 前两天就已经开始重构了，真的不容易，这份代码太折磨我了，不过重构完一小部分后，代码一下子就让人舒服多了，现在我只期望我运气能比较好，坑肯定在所难免只求坑不要太深。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 13:35:00 +0000</pubDate>
<dc:creator>工藤-新一</dc:creator>
<og:description>辞职后想了一段时间，最终还是换了个城市工作，最近刚上班，陌生的城市还是有一股孤独感，麻将一缺三。 上班后的第一个任务领导就让我重构一下系统，我下意识就回答重构坑很深，想建议小步定期重构追求慢而稳，后面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gt-xy/p/10660028.html</dc:identifier>
</item>
<item>
<title>婴儿的出生为你解惑构造函数和构造代码块 - 泰斗贤若如</title>
<link>http://www.cnblogs.com/zyx110/p/10659889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyx110/p/10659889.html</guid>
<description>&lt;p&gt;          &lt;span&gt;     &lt;strong&gt;今天回想这几天走过的Java路程，发现漏了一个点，就是构造代码块，我绞尽脑汁，也没想起来它的作用，我骗不了我自己，就搜相关资料，重新学习，在学习的过程中发现构造代码块和构造函数有一定的联系，为了捕捉这种联系，我总结了一个案例，这个案例能加深你对构造函数和构造代码块的理解。我写这个博客一是为了避免下次再被构造代码块这块石头绊倒，二是为了能给需要解惑的人提供一些帮助，还是那句话：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;span&gt;   越懂得与人分享，你的价值增值越大！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt;&lt;span&gt;看代码前要先明白一个需求：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                         使用Java类描述一个婴儿，假设现在两种婴儿，一种婴儿是一出生就有了名字，我们把这种婴儿叫&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;白户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，另一种婴儿是出生后才有了名字，我们把这种婴儿叫&lt;span&gt;&lt;strong&gt;&lt;span&gt;黑户&lt;span&gt;。（为了方便理解，我把刚出生就已经有名字的叫白户，把出生后才起名的叫黑户）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//婴儿类&lt;br/&gt;public class Baby {
    int id;//身份证
    String name;//名字

    //哭
    public void cry(){
        System.out.println(name+&quot;哇哇的哭。。。。&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        //创建一个baby对象
        Baby baby = new Baby();//婴儿出生
        baby.id=111;
        baby.name=&quot;小娃娃&quot;;&lt;strong&gt;&lt;span&gt;//黑户&lt;/span&gt;&lt;/strong&gt;
        baby.cry();
    }
}&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

小娃娃哇哇的哭。。。。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;由于小娃娃是出生之后才赋的值，所以小娃娃是黑户，我们现在要让婴儿一出生就有名字，就要用构造函数。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造函数的作用：    给对应的对象进行初始化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造函数定义的格式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
修饰符     函数名（形式参数）{

          函数体。。。
}
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造函数要注意的细节：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1.构造函数没有返回值类型&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.构造函数的函数名必须要与类名一致&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.构造函数并不是由我们手动调用的，而是在创建对应的对象时，jvm就会主动调用到对应的构造函数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4.如果一个类没有显式的写上一个构造方法时，Java编译器会为该类添加一个无参的构造方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;5.如果一个类已经显示的写上一个构造方法时，Java编译器不会再为该类添加无参的构造方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;6.构造函数是可以在一个类中以函数重载的形式存在多个的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//婴儿类
public class Baby {
    int id;//身份证
    String name;//名字

    //无参构造函数
    public  Baby(){

    }
    //有参构造函数
    public Baby(int id, String name) {
        this.id = id;
        this.name = name;
        System.out.println(&quot;Baby的属性初始化完毕！！！&quot;);
    }

    //哭
    public void cry(){
        System.out.println(this.name+&quot;哇哇的哭。。。。&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        //创建一个baby对象
        Baby baby = new Baby(222,&quot;小可爱&quot;);//婴儿出生   &lt;strong&gt;&lt;span&gt; 白户&lt;/span&gt;&lt;/strong&gt;
        baby.cry();
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

Baby的属性初始化完毕！！！
小可爱哇哇的哭。。。。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过上面的黑户和白户，我们能对构造函数有个深刻的理解，下面我再引申出构造代码块，依旧是这个例子，但是需求变了，现在的需求是婴儿一出生就必须哭，可能说到这，要是有人理解了上面的代码，肯定马上就能想到，这还不简单，把哭的方法写到构造函数中不就行了，对，这样确实也可以，但是有弊端，Java要求代码简练，能少写的就不多写，你先看下面的代码就知道了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//婴儿类
public class Baby {
    int id;//身份证
    String name;//名字

    //无参构造函数
    public  Baby(){
        cry();
    }
    //有参构造函数
    public Baby(int id, String name) {
        this.id = id;
        this.name = name;
      
        cry();
    }

    //哭
    public void cry(){
        System.out.println(&quot;哇哇的哭。。。。&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        //创建一个白户baby对象
        Baby baby = new Baby(222,&quot;小可爱&quot;);//白户
        //创建一个黑户baby对象
        Baby baby1 = new Baby();//黑户
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

哇哇的哭。。。。
哇哇的哭。。。。
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;虽然白户黑户两种婴儿都在出生的时候哭了，但是在两个构造函数中出现了重复代码，cry()方法重复了两次，为了解决重复代码这个问题，下面就让构造代码块出场吧！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造函数的作用：给对应的对象进行初始化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造代码块的作用：  给对象进行统一的初始化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;构造代码块的格式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
{
    构造代码块
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：构造代码块的大括号必须位于成员位置上&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码块的类别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.构造代码块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.局部代码块       &lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;大括号位于方法之内       作用：缩短局部变量的生命周期，节省一点点内存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.静态代码块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
static{
     静态代码块
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;构造代码块要注意的事项：&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.Java编译器编译一个Java源文件的时候，会把成员变量的声明语句提前至一个类的最前端&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.成员变量的初始化工作其实都是在构造函数中进行的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.一旦经过Java编译器编译后，构造代码块的代码就会被移动到构造函数中执行，是在构造函数之前执行的，构造函数中的代码是最后执行的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.成员变量的显式初始化与构造代码块的代码是按照当前代码的顺序执行的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//婴儿类
public class Baby {
    int id;//身份证
    String name;//名字

   &lt;span&gt;&lt;strong&gt;&lt;span&gt; //构造代码块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
    {
        cry();
    }
    //无参构造函数
    public  Baby(){

    }
    //有参构造函数
    public Baby(int id, String name) {
        this.id = id;
        this.name = name;

    }

    //哭
    public void cry(){
        System.out.println(&quot;哇哇的哭。。。。&quot;);
    }
}

class Test{
    public static void main(String[] args) {
        //创建一个白户baby对象
        Baby baby = new Baby(222,&quot;小可爱&quot;);//白户
        //创建一个黑户baby对象
        Baby baby1 = new Baby();//黑户
        //匿名对象
        new Baby();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
运行结果：

哇哇的哭。。。。
哇哇的哭。。。。
哇哇的哭。。。。
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//婴儿类
public class Baby {
    int id;//身份证
    String name;//名字

    //构造代码块
    {
        cry();
    }
    //无参构造函数
    public  Baby(){

    }
    //有参构造函数
    public Baby(int id, String name) {
        this.id = id;
        this.name = name;

    }

    //哭
    public void cry(){
        System.out.println(&quot;哇哇的哭。。。。&quot;);
    }
}

class Test{
    public static void main(String[] args) {
       &lt;span&gt;&lt;strong&gt;&lt;span&gt; //局部代码块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
        {
            //创建一个白户baby对象
            Baby baby = new Baby(222,&quot;小可爱&quot;);//白户
            //创建一个黑户baby对象
            Baby baby1 = new Baby();//黑户
            //匿名对象
            new Baby();
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;全部写完了，如果你觉得对你有用，记得推荐，如果觉得哪不对，欢迎指正！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 05 Apr 2019 12:57:00 +0000</pubDate>
<dc:creator>泰斗贤若如</dc:creator>
<og:description>序言： 今天回想这几天走过的Java路程，发现漏了一个点，就是构造代码块，我绞尽脑汁，也没想起来它的作用，我骗不了我自己，就搜相关资料，重新学习，在学习的过程中发现构造代码块和构造函数有一定的联系，为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zyx110/p/10659889.html</dc:identifier>
</item>
</channel>
</rss>