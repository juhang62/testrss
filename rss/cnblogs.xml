<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>请问你知道分布式系统设计模式的分割日志思想么？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14397246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14397246.html</guid>
<description>&lt;p&gt;将大文件切分为更容易处理的多个更小的文件。&lt;/p&gt;
&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;单一的日志文件可能会增长到很大，并且在程序启动时读取从而成为性能瓶颈。老的日志需要定时清理，但是对于一个大文件进行清理操作很费劲。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;将单一日志切分为多个，日志在达到一定大小时，会切换到新文件继续写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//写入日志
public Long writeEntry(WALEntry entry) {
    //判断是否需要另起新文件
    maybeRoll();
    //写入文件
    return openSegment.writeEntry(entry);
}

private void maybeRoll() {
    //如果当前文件大小超过最大日志文件大小
    if (openSegment.
            size() &amp;gt;= config.getMaxLogSize()) {
        //强制刷盘
        openSegment.flush();
        //存入保存好的排序好的老日志文件列表
        sortedSavedSegments.add(openSegment);
        //获取文件最后一个日志id
        long lastId = openSegment.getLastLogEntryId();
        //根据日志id，另起一个新文件，打开
        openSegment = WALSegment.open(lastId, config.getWalDir());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果日志做了切分，那么需要快速以某个日志位置（或者日志序列号）定位到某个文件的机制。可以通过两种方式实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个日志切分文件的名称都是包含特定开头以及日志位置偏移量（或者日志序列号）&lt;/li&gt;
&lt;li&gt;每一个日志序列号包含文件名称以及 transaction 偏移。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//创建文件名称
public static String createFileName(Long startIndex) {
    //特定日志前缀_起始位置_日志后缀
    return logPrefix + &quot;_&quot; + startIndex + &quot;_&quot; + logSuffix;
}

//从文件名称中提取日志偏移量
public static Long getBaseOffsetFromFileName(String fileName) {
    String[] nameAndSuffix = fileName.split(logSuffix);
    String[] prefixAndOffset = nameAndSuffix[0].split(&quot;_&quot;);
    if (prefixAndOffset[0].equals(logPrefix))
        return Long.parseLong(prefixAndOffset[1]);

    return -1l;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件名包含这种信息之后，读操作就分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给定一个偏移（或者 transaction id），获取到大于这个偏移日志所在文件&lt;/li&gt;
&lt;li&gt;从文件中读取所有大于这个偏移的日志&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;//给定偏移量，读取所有日志
public List&amp;lt;WALEntry&amp;gt; readFrom(Long startIndex) {
    List&amp;lt;WALSegment&amp;gt; segments = getAllSegmentsContainingLogGreaterThan(startIndex);
    return readWalEntriesFrom(startIndex, segments);
}

//给定偏移量，获取所有包含大于这个偏移量的日志文件
private List&amp;lt;WALSegment&amp;gt; getAllSegmentsContainingLogGreaterThan(Long startIndex) {
    List&amp;lt;WALSegment&amp;gt; segments = new ArrayList&amp;lt;&amp;gt;();
    //Start from the last segment to the first segment with starting offset less than startIndex
    //This will get all the segments which have log entries more than the startIndex
    for (int i = sortedSavedSegments.size() - 1; i &amp;gt;= 0; i--) {
        WALSegment walSegment = sortedSavedSegments.get(i);
        segments.add(walSegment);

        if (walSegment.getBaseOffset() &amp;lt;= startIndex) {
            break; // break for the first segment with baseoffset less than startIndex
        }
    }

    if (openSegment.getBaseOffset() &amp;lt;= startIndex) {
        segments.add(openSegment);
    }

    return segments;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;举例&quot;&gt;举例&lt;/h2&gt;
&lt;p&gt;基本所有主流 MQ 的存储，例如 RocketMQ，Kafka 还有 Pulsar 的底层存储 BookKeeper，都运用了分段日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RocketMQ：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%86%E6%AE%B5%E6%97%A5%E5%BF%97/rocketmq-commitlog.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kafka：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%86%E6%AE%B5%E6%97%A5%E5%BF%97/kafka-logs.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pulsar存储实现BookKeeper：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%86%E6%AE%B5%E6%97%A5%E5%BF%97/bookkeeper-logs.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，基于一致性协议 Paxos 或者 Raft 的存储，一般会采用分段日志，例如 Zookeeper 以及 TiDB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 00:26:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>分割日志（Segmented Log） 将大文件切分为更容易处理的多个更小的文件。 问题背景 单一的日志文件可能会增长到很大，并且在程序启动时读取从而成为性能瓶颈。老的日志需要定时清理，但是对于一个大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14397246.html</dc:identifier>
</item>
<item>
<title>5.2 spring5源码--spring AOP源码分析三---切面源码分析 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/14397221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/14397221.html</guid>
<description>&lt;p&gt;源码分析分为三部分&lt;/p&gt;
&lt;h3&gt;1. 解析切面&lt;/h3&gt;
&lt;h3&gt;2. 创建动态代理&lt;/h3&gt;
&lt;h3&gt;3. 调用&lt;/h3&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;源码的入口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;源码分析的入口, 从注解开始:&lt;/strong&gt;&lt;/span&gt;
组件的入口是一个注解, 比如启用AOP的注解@EnableAspectJAutoProxy. 在注解的实现类里面, 会有一个@Import(&quot;&quot;). 这个@Import(&quot;&quot;)就是引入的源码实现类. 比如AOP的@Import(AspectJAutoProxyRegistrar.class)
&lt;/pre&gt;
&lt;pre&gt;
通常, Spring要开启某一个功能, 都会增加一个注解, 如果我们再想要看某一个功能的源码, 那么就可以从他的注解跟进去看,在找到@Import(&quot;&quot;)就找到源码的入口了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码分析的入口, AOP注解:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package com.lxl.www.aop;

import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configurable
&lt;span&gt;&lt;strong&gt;// 使用注解的方式引入AOP
&lt;/strong&gt;&lt;strong&gt;@EnableAspectJAutoProxy&lt;/strong&gt;&lt;/span&gt;
@ComponentScan(&quot;com.lxl.www.aop&quot;)
public class MainConfig {

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入AOP, 我们需要在配置文件中增加@EnableAspectJAutoProxy代理. 那么想要去掉AOP的引入, 只需要将这个注解注释掉就可以了.  这个注解解释整个AOP的入口. &lt;/p&gt;
&lt;p&gt;提示: 其他组件的引入也是类似的, 通常引入组件, 需要增加一个注解, 而整个功能的入口就在这个主机上面.&lt;/p&gt;
&lt;p&gt;接下来, 进入到注解类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package org.springframework.context.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;span&gt;&lt;strong&gt;@Import(AspectJAutoProxyRegistrar.&lt;/strong&gt;&lt;strong&gt;class)
&lt;/strong&gt;&lt;/span&gt;public&lt;span&gt; @interface &lt;strong&gt;EnableAspectJAutoProxy&lt;/strong&gt; {

    boolean proxyTargetClass() default false&lt;span&gt;;

    boolean exposeProxy() default false&lt;span&gt;;

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是, 我们看到EnableAspectJAutoProxy类增加了一个@Import注解类, 我们知道Import注解可以向IoC容器中增加一个bean.&lt;/p&gt;

&lt;p&gt;下面进入到&lt;strong&gt;AspectJAutoProxyRegistrar类&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package org.springframework.context.annotation;

import org.springframework.aop.config.AopConfigUtils;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.type.AnnotationMetadata;

class&lt;span&gt; AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

    /**
     * Register, escalate, and configure the AspectJ auto proxy creator based on the value
     * of the @{@link EnableAspectJAutoProxy#proxyTargetClass()} attribute on the importing
     * {@code @Configuration} class.
     */&lt;span&gt;
    @Override
    public void&lt;span&gt;&lt;strong&gt; registerBeanDefinitions&lt;/strong&gt;(
            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
　　　　
        &lt;span&gt;&lt;strong&gt;AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);&lt;/strong&gt;
&lt;/span&gt;
        AnnotationAttributes enableAspectJAutoProxy =&lt;span&gt;
                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class&lt;span&gt;);
        if (enableAspectJAutoProxy != null&lt;span&gt;) {
            if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;&lt;span&gt;)) {
                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
            }
            if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;&lt;span&gt;)) {
                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
            }
        }
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看到, 使用ImportBeanDefinitionRegistrar注册了一个BeanDefinition.&lt;/p&gt;
&lt;p&gt;需要记住的是, 通常使用ImportBeanDefinitionRegistrar结合@Import可以向容器中注册一个BeanDefinition.&lt;/p&gt;
&lt;p&gt;如何注册的呢? 看具体实现. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
AopConfigUtils.&lt;span&gt;&lt;strong&gt;registerAspectJAnnotationAutoProxyCreatorIfNecessary&lt;/strong&gt;&lt;/span&gt;(registry);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注册名字是internalAutoProxyCreator的AnnotationAwareAspectJAutoProxyCreator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Nullable
    public static&lt;span&gt; BeanDefinition &lt;strong&gt;registerAspectJAnnotationAutoProxyCreatorIfNecessary&lt;/strong&gt;(
            BeanDefinitionRegistry registry, @Nullable Object source) {

        /**
         * 注册一个AnnotationAwareAspectJAutoProxyCreator类型的bean定义
         */
        return &lt;strong&gt;registerOrEscalateApcAsRequired&lt;/strong&gt;(&lt;span&gt;&lt;strong&gt;AnnotationAwareAspectJAutoProxyCreator&lt;/strong&gt;&lt;/span&gt;.class&lt;span&gt;, registry, source);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上结构梳理如下: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202012/1187916-20201224103712141-2107879457.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们看到,  注册了类AnnotationAwareAspectJAutoProxyCreator类型的bean. 这是一个什么样的类呢? 我们来看一下类的结构. 这个类的继承结构很庞大, 我们只看和本次内容相关的继承结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202012/1187916-20201214054357872-1063843324.png&quot; width=&quot;500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析切面, 创建动态代理, 都是在bean的后置处理器中进行的, 下面对照着AOP的实现原理以及createBean(创建bean)的过程来看&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202012/1187916-20201222202729071-1606841709.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是bean加载过程中调用的9次后置处理器. 在创建bean之前调用了InstantiationAwareBeanPostProcessor后置处理器判断是否需要为这个类创建AOP, 也就是解析切面的过程. 所以在AnnotationAwareAspectJAutoProxyCreator里面实现了InstantiationAwareBeanPostProcessor后置处理器的接口. 重写了postProcessBeforeInstantiation方法. &lt;/p&gt;
&lt;p&gt;在createBean的第三阶段初始化之后, 要创建AOP的动态代理, 调用了BeanPostProcess后置处理器, AnnotationAwareAspectJAutoProxyCreator也实现了BeanPostProcess接口. 重写了postProcessAfterInitialization. &lt;/p&gt;
&lt;p&gt;同时也需要处理AOP的循环依赖的问题, 处理循环依赖是在属性赋值之前调用SmartInstantiationAwareBeanPostProcessor后置处理器, 然后重写getEarlyBeanReference方法. 我们看到AnnotationAwareAspectJAutoProxyCreator也实现了SmartInstantiationAwareBeanPostProcessor接口. 并重写getEarlyBeanReference方法.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) AOP解析切面 &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 通过上面的分析,我们知道了, 解析切面是在重写了InstantiationAwareBeanPostProcessor后置处理器的postProcessBeforeInstantiation方法. 所以,我们要找到AnnotationAwareAspectJAutoProxyCreator重写的postProcessBeforeInstantiation方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;小贴士&lt;/strong&gt;

如何找到呢? 在idea中使用快捷键ctrl + o, 找到当前类重写的所有方法. 在搜索postProcessBeforeInstantiation, 就可以找到了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 进入创建动态代理的bean的后置处理器, 这是解析切面的第一个入口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@Override
    public Object &lt;span&gt;&lt;strong&gt;postProcessBeforeInstantiation&lt;/strong&gt;&lt;/span&gt;(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
        ......
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在&lt;strong&gt;postProcessBeforeInstantiation方法的入口处打一个断点,  接下来&lt;/strong&gt;看一下这个接口的调用链&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202012/1187916-20201222205323882-1299592625.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;420&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如上图, 可以看出我们的入口是main方法, 然后调用了refresh()方法, 执行的是refresh()方法的finishBeanFactoryInitialization()方法, 然胡调用了doGetBean()下的createBean().然后调用的是resolveBeforeInstantiation的applyBeanPostProcessorsBeforeInstantiation方法,在这里获取到所有的bean的后置处理器, 判断这个bean的后置处理器是否是InstantiationAwareBeanPostProcessor的一个实例. 如果是, 那么就调用&lt;strong&gt;postProcessBeforeInstantiation()方法. &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Nullable
    protected Object &lt;strong&gt;applyBeanPostProcessorsBeforeInstantiation&lt;/strong&gt;(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
        /**
         * 获取容器中所有的后置处理器
         * 这之前有一个注册bean定义的方法, 已经注册过了. 所以在这里可以获取到列表
         *
         * 9次bean的后置处理器, 都是一个类实现InstantiationAwareBeanPostProcessor类, 重写postProcessBeforeInstantiation方法
         */
        for&lt;span&gt; (BeanPostProcessor bp : getBeanPostProcessors()) {
            if&lt;span&gt; (bp instanceof InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp =&lt;span&gt; (InstantiationAwareBeanPostProcessor) bp;
                Object result =&lt;span&gt; ibp.&lt;span&gt;&lt;strong&gt;postProcessBeforeInstantiation&lt;/strong&gt;&lt;/span&gt;(beanClass, beanName);
                if (result != null&lt;span&gt;) {
                    return&lt;span&gt; result;
                }
            }
        }
        return null&lt;span&gt;;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面就来分析&lt;strong&gt;postProcessBeforeInstantiation()&lt;/strong&gt;方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
        /**
         * 在第一个bean创建的时候, 就会去调用所有的bean的后置处理器, 并且解析所有的切面.
         * 这一步是非常消耗性能的. 所以, 会放到缓存当中
         */
        // 构建缓存的key
        Object cacheKey =&lt;span&gt; getCacheKey(beanClass, beanName);

        // 没有beanName或者不包含在targetSourcedBeans
        if (!StringUtils.hasLength(beanName) || !this&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
            // 判断是否已经被解析过?
            if (this&lt;span&gt;.advisedBeans.containsKey(cacheKey)) {
                // 解析过, 则直接返回
                return null&lt;span&gt;;
            }
            /*
             * 判断当前这个类是不是需要跳过的类.如果是基础类或者是应该跳过里的类, 则返回null, 表示这个类不需要被解析
             *
             * 判断是不是基础bean(是不是切面类, 通知, 切点). 因为如果类本身是一个通知, 切面, 那我们不需要解析它
             * 跳过的类: 默认是false. 在shouldSkip里面拿到所有的bean定义, 标记是不是@Aspect, 然后将每一个通知生成一个advisor
             */
            if (isInfrastructureClass(beanClass) ||&lt;span&gt; shouldSkip(beanClass, beanName)) {
                /**
                 * advisedBean是一个集合, 用来保存类是否是一个advise
                 */
                this&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
                return null&lt;span&gt;;
            }
        }

        // Create proxy here if we have a custom TargetSource.
        // Suppresses unnecessary default instantiation of the target bean:
        // The TargetSource will handle target instances in a custom fashion.
        TargetSource targetSource =&lt;span&gt; getCustomTargetSource(beanClass, beanName);
        if (targetSource != null&lt;span&gt;) {
            if&lt;span&gt; (StringUtils.hasLength(beanName)) {
                this&lt;span&gt;.targetSourcedBeans.add(beanName);
            }
            Object[] specificInterceptors =&lt;span&gt; getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);

            // 创建了代理
            Object proxy =&lt;span&gt; createProxy(beanClass, beanName, specificInterceptors, targetSource);
            this&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
            return&lt;span&gt; proxy;
        }

        return null&lt;span&gt;;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一步: 构建缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
构建缓存的key
Object cacheKey = getCacheKey(beanClass, beanName);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
在第一个bean创建的时候, 就会去调用所有的bean的后置处理器, 并且解析所有的切面.&lt;br/&gt;这一步是非常消耗性能的. 所以, 会放到缓存当中. 已经创建过的,后面将不再创建
&lt;/pre&gt;
&lt;p&gt;第二步: 校验bean是否被解析过. 如果已经解析过, 则不再解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
// 判断是否已经被解析过
if (this&lt;span&gt;.advisedBeans.containsKey(cacheKey)) {
    // 解析过, 则直接返回
    return null&lt;span&gt;;
}  &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步: 判断类是否是需要跳过的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
if (isInfrastructureClass(beanClass) ||&lt;span&gt; shouldSkip(beanClass, beanName)) {
    /**
     * advisedBean是一个集合, 用来保存类是否是一个advise
     */
    this&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
    return null&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果是基础类或者是应该跳过的类, 则返回null, 表示这个类不需要被解析.&lt;/p&gt;
&lt;p&gt; 这里有两个判断.&lt;/p&gt;
&lt;p&gt;isInfrastructureClass(beanClass) 判断当前这个类是不是基础类, 这里的基础类的含义如下: &lt;strong&gt;Advice、Pointcut、Advisor、AopInfrastructureBean。&lt;/strong&gt;如果本身就是基础类，那么不用在解析了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
protected boolean isInfrastructureClass(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass) {
        // 如果这个类是一个Advice类型的类, 或者 Pointcut类型的类, 或者Adivsor类型的类, 或者AOPInsfrastructureBean类型的类.
        boolean retVal = &lt;span&gt;&lt;strong&gt;Advice&lt;/strong&gt;&lt;/span&gt;.class.isAssignableFrom(beanClass) ||&lt;span&gt;&lt;span&gt;&lt;strong&gt;
                Pointcut&lt;/strong&gt;&lt;/span&gt;.class.isAssignableFrom(beanClass) ||&lt;span&gt;&lt;span&gt;&lt;strong&gt;
                Advisor&lt;/strong&gt;&lt;/span&gt;.class.isAssignableFrom(beanClass) ||&lt;span&gt;&lt;span&gt;&lt;strong&gt;
                AopInfrastructureBean&lt;/strong&gt;&lt;/span&gt;.class&lt;span&gt;.isAssignableFrom(beanClass);
        if (retVal &amp;amp;&amp;amp;&lt;span&gt; logger.isTraceEnabled()) {
            logger.trace(&quot;Did not attempt to auto-proxy infrastructure class [&quot; + beanClass.getName() + &quot;]&quot;&lt;span&gt;);
        }
        return&lt;span&gt; retVal;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;shouldSkip(beanClass, beanName)&lt;/strong&gt;判断当前是否是需要跳过的类 .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    protected boolean &lt;strong&gt;shouldSkip&lt;/strong&gt;(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
        // 找到候选的Advisors(前置通知, 后置通知等)
        List&amp;lt;Advisor&amp;gt; candidateAdvisors =&lt;span&gt; findCandidateAdvisors();
        for&lt;span&gt; (Advisor advisor : candidateAdvisors) {
            if (advisor instanceof AspectJPointcutAdvisor &amp;amp;&amp;amp;&lt;span&gt;
                    ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
                return true&lt;span&gt;;
            }
        }
        return&lt;span&gt; super.shouldSkip(beanClass, beanName);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;findCandidateAdvisors(); 找到候选的类, 然后将候选类构造成Advisor对象. 进到方法里看看是如何筛选出候选对象的. &lt;/p&gt;
&lt;p&gt;AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    protected List&amp;lt;Advisor&amp;gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; findCandidateAdvisors&lt;/strong&gt;&lt;/span&gt;() {
        // Add all the Spring advisors found according to superclass rules.
        // 找到xml方式配置的Advisor和原生接口的AOP的advisor 以及找到事务相关的advisor
        List&amp;lt;Advisor&amp;gt; advisors =&lt;span&gt; super.findCandidateAdvisors();
        // Build Advisors for all AspectJ aspects in the bean factory.
        // 将找到的aspect, 封装为一个Advisor
        if (this.aspectJAdvisorsBuilder != null&lt;span&gt;) {
            //buildAspectJAdvisors()方法就是用来解析切面类, 判断是否含有@Aspect注解, 然后将每一个通知生成一个advisor
            advisors.addAll(this&lt;span&gt;.aspectJAdvisorsBuilder.buildAspectJAdvisors());
        }
        // 返回所有的通知
        return&lt;span&gt; advisors;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里做了两件事&lt;/p&gt;
&lt;p&gt;第一步: 解析xml方式配置的Advisor (包括原生接口方式配置的advisor 以及找到事务相关的advisor)&lt;/p&gt;
&lt;p&gt;第二步: 解析注解方式的切面. buildAspectJAdvisors()方法是用来解析切面类的. 解析每一个切面类中的通知方法, 并为每个方法匹配切点表达式.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210108155031515-899371525.png&quot; width=&quot;1000&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
public List&amp;lt;Advisor&amp;gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; buildAspectJAdvisors&lt;/strong&gt;&lt;/span&gt;() {
    /*
     * aspectNames: 用于保存切面名称的集合
     * aspectNames是缓存的类级别的切面, 缓存的是已经解析出来的切面信息
     */&lt;span&gt;
    List&amp;lt;String&amp;gt; &lt;strong&gt;aspectNames = this&lt;span&gt;.aspectBeanNames;

    &lt;/span&gt;&lt;/strong&gt;// 如果aspectNames值为空, 那么就在第一个单例bean执行的时候调用后置处理器(AnnotationAwareAspectJAutoProxy)
    if (aspectNames == null&lt;span&gt;) {
      // 加锁, 防止多个线程, 同时加载 Aspect
      synchronized (this&lt;span&gt;) {
        aspectNames = this&lt;span&gt;.aspectBeanNames;
        // 双重检查
        if (aspectNames == null&lt;span&gt;) {
          // 保存所有从切面中解析出来的通知
          List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
          // 保存切面名称的集合
          aspectNames = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
          /*
           * 扫描Object的子类. 那就是扫描所有的类
           *
           * 这里传入要扫描的对象是Object.class. 也就是说去容器中扫描所有的类.
           * 循环遍历. 这个过程是非常耗性能的, 所以spring增加了缓存来保存切面
           *
           * 但事务功能除外, 事务模块是直接去容器中找到Advisor类型的类 选择范围小
           * spring 没有给事务模块加缓存
           */&lt;strong&gt;&lt;span&gt;
          String[] beanNames =&lt;span&gt; BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
              this.beanFactory, &lt;span&gt;Object.class&lt;/span&gt;, true, false&lt;span&gt;);

          &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;// 循环遍历beanNames
         &lt;strong&gt; for&lt;span&gt; (String beanName : beanNames) {
            &lt;/span&gt;&lt;/strong&gt;if (!&lt;span&gt;isEligibleBean(beanName)) {
              continue&lt;span&gt;;
            }
            // We must be careful not to instantiate beans eagerly as in this case they
            // would be cached by the Spring container but would not have been weaved.
            // 通过beanName去容器中获取到对应class对象
            Class&amp;lt;?&amp;gt; beanType = this&lt;span&gt;.beanFactory.getType(beanName);
            if (beanType == null&lt;span&gt;) {
              continue&lt;span&gt;;
            }
            // 判断bean是否是一个切面, 也就是脑袋上是否有@Aspect注解
            &lt;strong&gt;if (this&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;.advisorFactory.isAspect(beanType)) {&lt;/strong&gt;
              aspectNames.add(beanName);
              // 将beanName和class对象构建成一个AspectMetadata对象
              AspectMetadata amd = new&lt;span&gt; AspectMetadata(beanType, beanName);
              if (amd.getAjType().getPerClause().getKind() ==&lt;span&gt; PerClauseKind.SINGLETON) {
                MetadataAwareAspectInstanceFactory factory =
                    new BeanFactoryAspectInstanceFactory(this&lt;span&gt;.beanFactory, beanName);
                // 解析切面类中所有的通知--一个通知生成一个Advisor.
                List&amp;lt;Advisor&amp;gt; classAdvisors = &lt;span&gt;&lt;strong&gt;this.advisorFactory.getAdvisors(factory);

                &lt;/strong&gt;&lt;/span&gt;// 加入到缓存中
                if (this&lt;span&gt;.beanFactory.isSingleton(beanName)) {
                  this&lt;span&gt;.advisorsCache.put(beanName, classAdvisors);
                } else&lt;span&gt; {
                  this&lt;span&gt;.aspectFactoryCache.put(beanName, factory);
                }
                advisors.addAll(classAdvisors);
              } else&lt;span&gt; {
                // Per target or per this.
                if (this&lt;span&gt;.beanFactory.isSingleton(beanName)) {
                  throw new IllegalArgumentException(&quot;Bean with name '&quot; + beanName +
                      &quot;' is a singleton, but aspect instantiation model is not singleton&quot;&lt;span&gt;);
                }
                MetadataAwareAspectInstanceFactory factory =
                    new PrototypeAspectInstanceFactory(this&lt;span&gt;.beanFactory, beanName);
                this&lt;span&gt;.aspectFactoryCache.put(beanName, factory);
                advisors.addAll(this&lt;span&gt;.advisorFactory.getAdvisors(factory));
              }
            }
          }
          this.aspectBeanNames =&lt;span&gt; aspectNames;
          return&lt;span&gt; advisors;
        }
      }
    }

    if&lt;span&gt; (aspectNames.isEmpty()) {
      return&lt;span&gt; Collections.emptyList();
    }
    List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    for&lt;span&gt; (String aspectName : aspectNames) {
      List&amp;lt;Advisor&amp;gt; cachedAdvisors = this.advisorsCache.get&lt;span&gt;(aspectName);
      if (cachedAdvisors != null&lt;span&gt;) {
        advisors.addAll(cachedAdvisors);
      } else&lt;span&gt; {
        MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get&lt;span&gt;(aspectName);
        advisors.addAll(this&lt;span&gt;.advisorFactory.getAdvisors(factory));
      }
    }
    return&lt;span&gt; advisors;
  }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看看如何生成List&amp;lt;Advisor&amp;gt;的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
// 解析切面类中所有的通知--一个通知生成一个Advisor.
List&amp;lt;Advisor&amp;gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
public List&amp;lt;Advisor&amp;gt;&lt;span&gt;&lt;strong&gt; getAdvisors&lt;/strong&gt;(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
        // 获取标记了@Aspect的类
        Class&amp;lt;?&amp;gt; aspectClass =&lt;span&gt; aspectInstanceFactory.getAspectMetadata().getAspectClass();
        // 获取切面类的名称
        String aspectName =&lt;span&gt; aspectInstanceFactory.getAspectMetadata().getAspectName();
        // 验证切面类
&lt;span&gt;        validate(aspectClass);

        // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
        // so that it will only instantiate once.
        // 使用包装的模式来包装 aspectInstanceFactory, 构建成MetadataAwareAspectInstanceFactory类
        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
                new&lt;span&gt; LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

        // 通知的集合, 按照排序后
        List&amp;lt;Advisor&amp;gt; advisors = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        // 获取切面类中所有的通知方法, 除了带有@Pointcut注解的方法
        for&lt;span&gt; (Method method : &lt;strong&gt;&lt;span&gt;getAdvisorMethods&lt;/span&gt;(&lt;span&gt;aspectClass&lt;/span&gt;)&lt;/strong&gt;) {
            // 将候选方法解析为Advisor. Advisor中包含advise和pointcut. 注意: getAdvisor()方法中定义了切面解析的顺序
            Advisor advisor = &lt;span&gt;&lt;strong&gt;getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName);
            &lt;/strong&gt;&lt;/span&gt;if (advisor != null&lt;span&gt;) {
                advisors.add(advisor);
            }
        }

        // If it's a per target aspect, emit the dummy instantiating aspect.
        if (!advisors.isEmpty() &amp;amp;&amp;amp;&lt;span&gt; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
            Advisor instantiationAdvisor = new&lt;span&gt; SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
            advisors.add(0&lt;span&gt;, instantiationAdvisor);
        }

        // Find introduction fields.
        for&lt;span&gt; (Field field : aspectClass.getDeclaredFields()) {
            Advisor advisor =&lt;span&gt; getDeclareParentsAdvisor(field);
            if (advisor != null&lt;span&gt;) {
                advisors.add(advisor);
            }
        }

        return&lt;span&gt; advisors;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这里主要有两点, 第一个是getAdvisorMethods(aspectClass)&lt;/strong&gt;获取当前切面类的所有的AdvisorMethod , 第二个是封装成的Advisor对象&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;2.5&quot;&gt;第一步: 解析切面类中所有的通知方法.getAdvisorMethods(aspectClass)
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
/**
     * 获取切面类中所有的方法, 且方法中有@Pointcut注解
     * @param aspectClass
     * @return
     */
    private List&amp;lt;Method&amp;gt; &lt;span&gt;&lt;strong&gt;getAdvisorMethods&lt;/strong&gt;&lt;/span&gt;(Class&amp;lt;?&amp;gt;&lt;span&gt; aspectClass) {
        final List&amp;lt;Method&amp;gt; methods = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        // 调用doWithMethods. 第二个参数是一个匿名函数, 重写了doWith方法
        ReflectionUtils.&lt;strong&gt;doWithMethods&lt;/strong&gt;(aspectClass, method -&amp;gt;&lt;span&gt; {
            // 解析切面类中所有的方法, 除了Pointcut
            &lt;span&gt;&lt;strong&gt;if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;) {
                methods.add(method);
            }&lt;/strong&gt;&lt;/span&gt;
        }, ReflectionUtils.USER_DECLARED_METHODS);
        if (methods.size() &amp;gt; 1&lt;span&gt;) {
            &lt;span&gt;&lt;strong&gt;// 对方法进行排序
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;            methods.sort(METHOD_COMPARATOR);&lt;/strong&gt;&lt;/span&gt;
        }
        return&lt;span&gt; methods;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个方法是, 扫描切面类的所有方法, 将其添加到methods中, 除了Pointcut注解的方法&lt;/p&gt;
&lt;p&gt;然后对methods进行排序, 如何排序呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
private static final Comparator&amp;lt;Method&amp;gt;&lt;span&gt; METHOD_COMPARATOR;

    static&lt;span&gt; {
        Comparator&amp;lt;Method&amp;gt; adviceKindComparator = new ConvertingComparator&amp;lt;&amp;gt;&lt;span&gt;(
                new InstanceComparator&amp;lt;&amp;gt;&lt;span&gt;(
                       &lt;strong&gt; Around.&lt;/strong&gt;&lt;strong&gt;class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&lt;/strong&gt;&lt;span&gt;),
                (Converter&amp;lt;Method, Annotation&amp;gt;) method -&amp;gt;&lt;span&gt; {
                    AspectJAnnotation&amp;lt;?&amp;gt; ann =&lt;span&gt; AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);
                    return (ann != null ? ann.getAnnotation() : null&lt;span&gt;);
                });
        Comparator&amp;lt;Method&amp;gt; methodNameComparator = new ConvertingComparator&amp;lt;&amp;gt;&lt;span&gt;(Method::getName);
        METHOD_COMPARATOR =&lt;span&gt; adviceKindComparator.thenComparing(methodNameComparator);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照Aroud, Before, After, AferReturning, AfterThrowing的顺序对通知方法进行排序&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;4.5&quot;&gt;第二步: 将候选的方法解析为Advisor. 这里也是有两步.具体如下:
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
/**
     * 解析切面类中的方法
     * @param candidateAdviceMethod 候选的方法
     */&lt;span&gt;
    @Override
    @Nullable
    public&lt;span&gt; Advisor &lt;strong&gt;getAdvisor&lt;/strong&gt;(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
            int&lt;span&gt; declarationOrderInAspect, String aspectName) {

        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

        // 获取切面中候选方法的切点表达式
        &lt;strong&gt;AspectJExpressionPointcut expressionPointcut =&lt;span&gt; getPointcut(
                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
        &lt;/span&gt;&lt;/strong&gt;if (expressionPointcut == null&lt;span&gt;) {
            return null&lt;span&gt;;
        }

        // 将切点表达式和通知封装到InstantiationModelAwarePointcutAdvisorImpl对象中, 这是一个Advisor通知
        return new&lt;span&gt; InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
                this&lt;span&gt;, aspectInstanceFactory, declarationOrderInAspect, aspectName);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在getPointcut中解析了method,以及切点表达式pointcut&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
/**
     * 找到候选方法method属于哪一种类型的Aspectj通知
     * @param candidateAdviceMethod        候选的通知方法
     * @param candidateAspectClass        候选的切面类
     * @return
     */&lt;span&gt;
    @Nullable
    private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&amp;lt;?&amp;gt;&lt;span&gt; candidateAspectClass) {
        &lt;span&gt;//&lt;strong&gt; 第一步: 解析候选方法上的注解,类似@Before(value=&quot;pointcut()&quot;)
        &lt;/strong&gt;&lt;/span&gt;// 找到Aspectj注解:  @Pointcut, @Around, @Before, @After, @AfterReturning, @AfterThrowing
        AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =&lt;span&gt;
                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
        if (aspectJAnnotation == null&lt;span&gt;) {
            return null&lt;span&gt;;
        }

        &lt;span&gt;//&lt;strong&gt; 第二步: 解析aspect切面中的切点表达式&lt;/strong&gt;&lt;/span&gt;
        AspectJExpressionPointcut ajexp =
                new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&amp;lt;?&amp;gt;[0&lt;span&gt;]);
        // 解析切点表达式
&lt;span&gt;        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
        if (this.beanFactory != null&lt;span&gt;) {
            ajexp.setBeanFactory(this&lt;span&gt;.beanFactory);
        }
        return&lt;span&gt; ajexp;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码, 可知, 这里也是有两个操作. 分别是将method解析为Advise, 另一个是解析切面类中的pointcut切点表达式. 返回返回切点表达式.&lt;/p&gt;
&lt;p&gt;接下来, 就是将候选方法和切点表达式封装成Advisor. 在getAdvisor(...)方法中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
// 将切点表达式和通知封装到InstantiationModelAwarePointcutAdvisorImpl对象中, 这是一个Advisor通知
return new InstantiationModelAwarePointcutAdvisorImpl(&lt;strong&gt;&lt;span&gt;expressionPointcut&lt;/span&gt;, &lt;span&gt;candidateAdviceMethod&lt;/span&gt;&lt;/strong&gt;,
      this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;expressionPointcut: 即切点表达式; candidateAdviceMethod: 即候选方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
public&lt;span&gt; InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
            Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int&lt;span&gt; declarationOrder, String aspectName) {

        // 当前的切点
        this.declaredPointcut =&lt;span&gt; declaredPointcut;
        // 切面类
        this.declaringClass =&lt;span&gt; aspectJAdviceMethod.getDeclaringClass();
        // 切面方法名
        this.methodName =&lt;span&gt; aspectJAdviceMethod.getName();
        //切面方法参数的类型
        this.parameterTypes =&lt;span&gt; aspectJAdviceMethod.getParameterTypes();
        //切面方法对象
        this.aspectJAdviceMethod =&lt;span&gt; aspectJAdviceMethod;
        // aspectJ的通知工厂
        this.aspectJAdvisorFactory =&lt;span&gt; aspectJAdvisorFactory;
        // aspectJ的实例工厂
        this.aspectInstanceFactory =&lt;span&gt; aspectInstanceFactory;
        // advisor的顺序
        /**
         * 前面我们看到, Advisor会进行排序, Around, Before, After, AfterReturning, AfterThrowing, 按照这个顺序.
         * 那么order值是什么呢?是advisors的size. 如果size是0, 那么就是第一个方法. 这里第一个不一定是Around, 他可能没有Around通知, 也没有Before通知.
         */
        this.declarationOrder =&lt;span&gt; declarationOrder;
        // 切面名
        this.aspectName =&lt;span&gt; aspectName;

        if&lt;span&gt; (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
            // Static part of the pointcut is a lazy type.
            Pointcut preInstantiationPointcut =&lt;span&gt; Pointcuts.union(
                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this&lt;span&gt;.declaredPointcut);

            
            this.pointcut = new&lt;span&gt; PerTargetInstantiationModelPointcut(
                    this&lt;span&gt;.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
            this.lazy = true&lt;span&gt;;
        }
        else&lt;span&gt; {
            // A singleton aspect.
            this.pointcut = this&lt;span&gt;.declaredPointcut;
            this.lazy = false&lt;span&gt;;
            this.instantiatedAdvice = &lt;span&gt;&lt;strong&gt;instantiateAdvice(this&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;.declaredPointcut);&lt;/strong&gt;&lt;/span&gt;
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面已经得到了切入点表达式, 这里会进行初始化Advice, 初始化的时候, 根据通知的类型进行初始化.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环绕通知, 构建一个环绕通知的对象&lt;/li&gt;
&lt;li&gt;前置通知, 构建一个前置通知的对象&lt;/li&gt;
&lt;li&gt;后置通知, 构建一个后置通知的对象&lt;/li&gt;
&lt;li&gt;异常通知, 构建一个异常通知的对象&lt;/li&gt;
&lt;li&gt;返回通知, 构建一个返回通知的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    @Nullable
    public&lt;span&gt; Advice &lt;strong&gt;getAdvice&lt;/strong&gt;(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int&lt;span&gt; declarationOrder, String aspectName) {
        // 候选的切面类
        Class&amp;lt;?&amp;gt; candidateAspectClass =&lt;span&gt; aspectInstanceFactory.getAspectMetadata().getAspectClass();
        validate(candidateAspectClass);
        // 通知方法上的注解内容
        AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =&lt;span&gt;
                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
        if (aspectJAnnotation == null&lt;span&gt;) {
            return null&lt;span&gt;;
        }

        // If we get here, we know we have an AspectJ method.
        // Check that it's an AspectJ-annotated class
        if (!&lt;span&gt;isAspect(candidateAspectClass)) {
            throw new AopConfigException(&quot;Advice must be declared inside an aspect type: &quot; +
                    &quot;Offending method '&quot; + candidateAdviceMethod + &quot;' in class [&quot; +&lt;span&gt;
                    candidateAspectClass.getName() + &quot;]&quot;&lt;span&gt;);
        }

        if&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&quot;Found AspectJ method: &quot; +&lt;span&gt; candidateAdviceMethod);
        }

        AbstractAspectJAdvice springAdvice;

        switch&lt;span&gt; (aspectJAnnotation.getAnnotationType()) {
            &lt;strong&gt;case&lt;span&gt; AtPointcut:
                &lt;/span&gt;&lt;/strong&gt;if&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&quot;Processing pointcut '&quot; + candidateAdviceMethod.getName() + &quot;'&quot;&lt;span&gt;);
                }
                return null&lt;span&gt;;
            &lt;strong&gt;case&lt;span&gt; AtAround:
                &lt;/span&gt;&lt;/strong&gt;// 封装成环绕通知的对象
                springAdvice = new&lt;span&gt; AspectJAroundAdvice(
                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                break&lt;span&gt;;
            &lt;strong&gt;case&lt;span&gt; AtBefore:
                &lt;/span&gt;&lt;/strong&gt;// 封装成前置通知对象
                springAdvice = new&lt;span&gt; AspectJMethodBeforeAdvice(
                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                break&lt;span&gt;;
            &lt;strong&gt;case&lt;span&gt; AtAfter:
                &lt;/span&gt;&lt;/strong&gt;// 封装成后置通知对象
                springAdvice = new&lt;span&gt; AspectJAfterAdvice(
                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                break&lt;span&gt;;
            &lt;strong&gt;case&lt;span&gt; AtAfterReturning:
                &lt;/span&gt;&lt;/strong&gt;// 封装成返回通知对象
                springAdvice = new&lt;span&gt; AspectJAfterReturningAdvice(
                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                AfterReturning afterReturningAnnotation =&lt;span&gt; (AfterReturning) aspectJAnnotation.getAnnotation();
                if&lt;span&gt; (StringUtils.hasText(afterReturningAnnotation.returning())) {
                    springAdvice.setReturningName(afterReturningAnnotation.returning());
                }
                break&lt;span&gt;;
            &lt;strong&gt;case&lt;span&gt; AtAfterThrowing:
                &lt;/span&gt;&lt;/strong&gt;// 封装异常通知对象
                springAdvice = new&lt;span&gt; AspectJAfterThrowingAdvice(
                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                AfterThrowing afterThrowingAnnotation =&lt;span&gt; (AfterThrowing) aspectJAnnotation.getAnnotation();
                if&lt;span&gt; (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
                }
                break&lt;span&gt;;
            &lt;strong&gt;default&lt;span&gt;:
                &lt;/span&gt;&lt;/strong&gt;throw new&lt;span&gt; UnsupportedOperationException(
                        &quot;Unsupported advice type on method: &quot; +&lt;span&gt; candidateAdviceMethod);
        }

        // Now to configure the advice...
&lt;span&gt;        springAdvice.setAspectName(aspectName);
        springAdvice.setDeclarationOrder(declarationOrder);
        String[] argNames = this&lt;span&gt;.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
        if (argNames != null&lt;span&gt;) {
            springAdvice.setArgumentNamesFromStringArray(argNames);
        }
        springAdvice.calculateArgumentBindings();

        return&lt;span&gt; springAdvice;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这就是我们在之前的结构中说过的, 在解析切面的时候, 会解析切面中的每一个方法, 将其解析成一个Advisor, 而每一个Advisor都包含两个部分:Advise和pointcut.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210108112632750-1719222678.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后, 将所有的切面类都解析完, 将所有的Advisor放入到集合advisors中返回.&lt;/p&gt;

&lt;p&gt;这样就完成了切面的解析.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 调用动态代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在ioc解析的过程中, 是在什么时候创建动态代理的呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常是在创建bean初始化之后创建动态代理. 如果有循环依赖, 会在实例化之后创建动态代理, 再来感受一下创建bean过程中的操作.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210108192238112-1871293748.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面我们来看正常的流程, 在初始化之后创建AOP动态代理 .&lt;/p&gt;
&lt;p&gt;在创建bean的过程中,一共有三步, 来看看AbstractAutowireCpableBeanFactory.doCreateBean()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
protected&lt;span&gt; Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        BeanWrapper instanceWrapper = null&lt;span&gt;;
        if&lt;span&gt; (mbd.isSingleton()) {
            instanceWrapper = this&lt;span&gt;.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null&lt;span&gt;) {
            //第一步: 实例化
            instanceWrapper =&lt;span&gt; createBeanInstance(beanName, mbd, args);
        }
        // 这里使用了装饰器的设计模式
        final Object bean =&lt;span&gt; instanceWrapper.getWrappedInstance();
        Class&amp;lt;?&amp;gt; beanType =&lt;span&gt; instanceWrapper.getWrappedClass();
        ......
        try&lt;span&gt; {
            // 第二步:填充属性, 给属性赋值(调用set方法)  这里也是调用的后置处理器
&lt;span&gt;            populateBean(beanName, mbd, instanceWrapper);
            // 第三步: 初始化.
            exposedObject =&lt;span&gt; initializeBean(beanName, exposedObject, mbd);
        }
        ......
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在第三步初始化的时候, 要处理很多bean的后置处理器. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    public&lt;span&gt; Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result =&lt;span&gt; existingBean;
        &lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; (BeanPostProcessor processor : getBeanPostProcessors()) {&lt;/strong&gt;
            Object current =&lt;span&gt;&lt;strong&gt; processor.postProcessAfterInitialization(result, beanName);
            &lt;/strong&gt;&lt;/span&gt;if (current == null&lt;span&gt;) {
                return&lt;span&gt; result;
            }
            result =&lt;span&gt; current;
        }
        return&lt;span&gt; result;
    } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;postProcessAfterInitialization(result, beanName);就是处理初始化之后的后置处理器, 下面就从这个方法作为入口分析. &lt;/p&gt;
&lt;p&gt;AnnotationAwareAspectJAutoProxyCreator也实现了postProcessAfterInitialization(result, beanName);接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    public&lt;span&gt; Object  postProcessAfterInitialization(@Nullable Object bean, String beanName) {
        /**
         * 每一个bean在解析的时候都会解析一遍切面.
         * 为什么每次都要解析一遍呢? 因为还有另外一种方式-实现Advisor接口的方式实现AOP, 在加载过程中, 可能随时有新的bean被解析出来. 所以, 需要每次都重新解析一遍,.
         * 我们在第一次解析的Advisor都已经放入到缓存, 在这里会先从缓存中取, 也就是已经解析过的不会重复解析. 也就是不 消耗性能
         */
        if (bean != null&lt;span&gt;) {
            // 获取缓存key
            Object cacheKey =&lt;span&gt; getCacheKey(bean.getClass(), beanName);
            /**
             * 因为有可能在循环依赖处理的时候已经创建国一遍, 如果是那么现在就不再创建了,并且删除
             * 在这里, 我们要处理的是普通类的动态代理, 所以, 需要将循环以来创建的动态代理删掉
             */
           &lt;strong&gt; if (this.earlyProxyReferences.remove(cacheKey) !=&lt;span&gt; bean) {
                &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;// 该方法将返回动态代理的实例
                &lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; wrapIfNecessary(bean, beanName, cacheKey);&lt;/strong&gt;&lt;/span&gt;
           &lt;strong&gt; }&lt;/strong&gt;
        }
        return&lt;span&gt; bean;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里需要强调的一点是, 每一个bean在解析的时候都会解析一遍切面.为什么每次都要解析一遍呢?&lt;/p&gt;
&lt;p&gt;因为创建切面有两种方式, 一种是实现Advisor接口, 另一种是注解的方式. 实现Advisor接口的方式, 在加载过程中, 可能随时有新的bean被解析出来. 所以, 需要每次都重新解析一遍.&lt;/p&gt;
&lt;p&gt;我们在第一次解析的Advisor都已经放入到缓存, 在这里会先从缓存中取, 也就是已经解析过的不会重复解析. 也就是不 消耗性能&lt;/p&gt;

&lt;p&gt;接下来处理的流程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210114104057416-799154639.png&quot; width=&quot;250&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里,第三步:删除循环依赖创建的动态代理对象, 为什么要这样处理呢?&lt;/p&gt;
&lt;p&gt;因为有可能在循环依赖处理的时候已经创建了动态代理bean, 如果是,那么现在就不再创建了,并且将其删除. &lt;/p&gt;
&lt;p&gt;在这里, 我们要处理的是普通类的动态代理, 所以, 需要将循环依赖创建的动态代理删掉&lt;/p&gt;

&lt;p&gt;注: earlyProxyReferences对象使用来存储循环依赖过程中创建的动态代理bean. 如果循环依赖创建了这个代理bean, 那么直接返回, 如果没有创建过, 我们再创建.&lt;/p&gt;

&lt;div readability=&quot;19&quot;&gt;下面来看看是如何创建的?
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
protected&lt;span&gt; Object &lt;strong&gt;wrapIfNecessary&lt;/strong&gt;(Object bean, String beanName, Object cacheKey) {
        // 已经被处理过(解析切面的时候, targetSourcedBeans用来存储自己实现创建动态代理的逻辑)
        if (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; this&lt;span&gt;.targetSourcedBeans.contains(beanName)) {
            return&lt;span&gt; bean;
        }
        // 判断bean是否是需要增强的bean
        /**
         * 哪些类是不需要增强的呢?
         * 在解析切面的时候, 基础类和应该跳过的类是不需要增强的.
         */
        if (Boolean.FALSE.equals(this.advisedBeans.get&lt;span&gt;(cacheKey))) {
            return&lt;span&gt; bean;
        }
        // 判断是否是基础类, 或者是否是需要跳过的类
        &lt;strong&gt;if (isInfrastructureClass(bean.getClass()) ||&lt;span&gt; shouldSkip(bean.getClass(), beanName)) {
            &lt;/span&gt;&lt;/strong&gt;// 将其标记为不需要增强的类
            this&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
            return&lt;span&gt; bean;
        }

        // 匹配Advisor. 根据类匹配advisors, 至少匹配上一个, 才创建动态代理, 否则不创建动态代理
        Object[] specificInterceptors = &lt;strong&gt;&lt;span&gt;getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);

        &lt;/span&gt;&lt;/strong&gt;// 匹配了至少一个advisor, 创建动态代理
        if (specificInterceptors !=&lt;span&gt; DO_NOT_PROXY) {
            this&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.TRUE);
            Object proxy =&lt;strong&gt;&lt;span&gt; createProxy&lt;/span&gt;(
                    &lt;span&gt;bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
            &lt;/span&gt;&lt;/strong&gt;this&lt;span&gt;.proxyTypes.put(cacheKey, proxy.getClass());
            return&lt;span&gt; proxy;
        }

        this&lt;span&gt;.advisedBeans.put(cacheKey, Boolean.FALSE);
        return&lt;span&gt; bean;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;来看看创建流程&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210114104842725-1535201897.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;
&lt;p&gt; 首先判断是否是需要跳过的类. 哪些类是需要跳过的类呢?&lt;/p&gt;
&lt;p&gt;第一类:基础类. Advice, Pointcut, Advisor, AopInfrastructureBean. &lt;/p&gt;
&lt;p&gt;第二类: 原始的接口类, 以.ORIGINAL开头的类&lt;/p&gt;

&lt;p&gt; 接下来, 匹配Advisor. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
protected List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt;&lt;span&gt; beanClass, String beanName) {
        // 第一步: 拿到已经解析出来的advisors(这次是从缓存中获取)
        List&amp;lt;Advisor&amp;gt; candidateAdvisors =&lt;strong&gt; findCandidateAdvisors();
        &lt;/strong&gt;// 第二步:循环判断advisor能否作用于当前bean(原理: 切点是否命中bean)
        List&amp;lt;Advisor&amp;gt; eligibleAdvisors =&lt;strong&gt; findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
       &lt;/strong&gt;// 第三步: 对匹配bean的advisor进行增强&lt;strong&gt;
&lt;span&gt;        extendAdvisors(eligibleAdvisors);
        &lt;/span&gt;&lt;/strong&gt;// 第四步: 对匹配bean的advisor进行排序
        if (!&lt;span&gt;eligibleAdvisors.isEmpty()) {
            eligibleAdvisors =&lt;span&gt;&lt;strong&gt; sortAdvisors(eligibleAdvisors);&lt;/strong&gt;
        }
        // 返回匹配到的advisors
        return&lt;span&gt; eligibleAdvisors;
    } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里经过了四步, 具体详见上述代码及注释. &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步: 从缓存中拿到已经解析出来的advisors&lt;/li&gt;
&lt;li&gt;第二步:循环判断advisor能否作用于当前bean&lt;/li&gt;
&lt;li&gt;第三步: 对匹配bean的advisor进行增强&lt;/li&gt;
&lt;li&gt;第四步: 对匹配bean的advisor进行排序&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210114111235623-2123872543.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里面的第一步: 从缓存中取出了已经解析出来的advisors集合. 解析方式是从缓存中取出已经解析的advisors&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210114111929437-1597277906.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接下来,循环遍历获得到的advisors, 得到每一个advisor. 判断advisor是否是目标bean需要增强的通知.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210114112451716-1521352187.png&quot; width=&quot;700&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里在筛选的时候, 根据切点表达式进行了两次筛选. 第一次粗筛, 第二次是精筛. 整个目标类, 只要有一个类命中切点表达式, 那么这个类就是需要被创建动态代理的类, 返回true.&lt;/p&gt;
&lt;p&gt;接下来就是要创建动态代理了. 然后,返回创建的动态代理对象.&lt;/p&gt;
&lt;p&gt;下面来看看是如何创建动态代理的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210119094848876-1587897225.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;创建动态代理对象有两种方式: 一种是jdk代理, 一种是cglib代理. &lt;/p&gt;
&lt;p&gt;无论是使用xml配置的方式, 还是使用注解的方式, 都有一个参数proxy-target-class, 如果将这个参数设置为true, 表示强制使用cglib代理. 如下所示设置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
使用注解的方式
@EnableAspectJAutoProxy(&lt;span&gt;&lt;strong&gt;proxyTargetClass&lt;/strong&gt;&lt;strong&gt;=true&lt;/strong&gt;&lt;/span&gt;)

使用xml配置的方式
&amp;lt;aop: sapectj-autoproxy &lt;span&gt;&lt;strong&gt;proxy-target-class=&quot;true&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;lt;/aop:&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以在创建动态代理之前, 先解析注解或者配置, 看是否配置了proxy-target-class参数. 如果配置了这个参数,且其值为true, 那么就创建一个cglib代理对象. 否则创建一个JDK代理对象.通常, 我们使用的更多的是spring自己定义的JDK代理对象. 通过Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);创建动态代理&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在JDKDynamicAopProxy代理类中有一个invoke()方法. 这个invoke方法, 就是执行代理对象的方法时调用的方法.&lt;/p&gt;
&lt;p&gt; 该方法是通过反射的方法执行目标类中定义的方法的. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 

}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt; 3. 调用动态代理.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;调用这里有一个非常经典的调用逻辑--调用链.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210119112205401-1412729015.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图, 调用链的逻辑是, 调用动态代理方法,比如说div(arg1, arg2), 然后执行调用链中第一个通知advisor1, 然后第一个通知调用第二个通知, 在执行第二个, 以此类推, 当所有的通知执行完, 调用目标方法div(arg1, arg2), 然后返回执行结果. 我们来看看代码的逻辑实现.&lt;/p&gt;
&lt;p&gt;如下代码是调用动态代理的代码入口:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
public class LxlMainClass {
  public static void main(String[] args) {

    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MainConfig.class);

    &lt;span&gt;&lt;strong&gt;Calculate&lt;/strong&gt;&lt;/span&gt; calculate = (Calculate) ctx.getBean(&quot;lxlCalculate&quot;);
    /**
     * 上面的calculate, 就是返回的动态代理的类
     * 当调用下面的div方法时, 实际上调用的是JdkDynamicAopProxy.invoke(...)方法
     */
    calculate.div(2, 4);

    ProgramCalculate programCalculate = (ProgramCalculate) ctx.getBean(&quot;lxlCalculate&quot;);
    String s = programCalculate.toBinary(5);
    System.out.println(s);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在main方法中, 获取的Calculate对象, 其实是动态代理生成的对象. 当调用calculate.div(2, 4)方法时, 其实调用的是动态代理的invoke()方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    @Nullable
    public&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object oldProxy = null&lt;span&gt;;
        // 设置代理上下文
        boolean setProxyContext = false&lt;span&gt;;

        // 目标源: 也就是目标代理的目标类
        TargetSource targetSource = this&lt;span&gt;.advised.targetSource;
        Object target = null&lt;span&gt;;

        try&lt;span&gt; {

            if (!this.equalsDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isEqualsMethod(method)) {
                // The target does not implement the equals(Object) method itself.
                return equals(args[0&lt;span&gt;]);
            }
            else if (!this.hashCodeDefined &amp;amp;&amp;amp;&lt;span&gt; AopUtils.isHashCodeMethod(method)) {
                // The target does not implement the hashCode() method itself.
                return&lt;span&gt; hashCode();
            }
            else if (method.getDeclaringClass() == DecoratingProxy.class&lt;span&gt;) {
                // There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.
                return AopProxyUtils.ultimateTargetClass(this&lt;span&gt;.advised);
            }
            // 如果方法所在类是一个接口 &amp;amp;&amp;amp; 是可分配为Advised类型的方法
            else if (!this.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;&lt;span&gt;
                    method.getDeclaringClass().isAssignableFrom(Advised.class&lt;span&gt;)) {
                // Service invocations on ProxyConfig with the proxy config...
                return AopUtils.invokeJoinpointUsingReflection(this&lt;span&gt;.advised, method, args);
            }

            Object retVal;

            if (this&lt;span&gt;.advised.exposeProxy) {
                // 把代理对象暴露在线程变量中.
                oldProxy =&lt;span&gt; AopContext.setCurrentProxy(proxy);
                // 设置代理的上下文为true
                setProxyContext = true&lt;span&gt;;
            }

            // Get as late as possible to minimize the time we &quot;own&quot; the target,
            // in case it comes from a pool.
            // 获取目标对象
            target =&lt;span&gt; targetSource.getTarget();
            Class&amp;lt;?&amp;gt; targetClass = (target != null ? target.getClass() : null&lt;span&gt;);

            // 把aop的advisor全部转化为拦截器, 通过责任链模式依次调用
            &lt;strong&gt;/**
             * 将advisor对象转换为interceptor对象.
             *
             * 问题: 为什么要将advisor都转化为interceptor拦截器呢?
             * 主要还是因为要进行责任链调用. 之前说过, 要想进行责任链调用, 他们要有一个共同的方法.
             * 转化为interceptor以后, 这里共同的方法就是invoke().
             * beforeAdivsor, afterAdvisor, returningAdvisor, throwingAdvisor. 这几种类型. 只有returningAdvisor和throwingAdvisor会转化为Interceptor.
             * 因为beforeAdvisor和adgerAdvisor本身就实现了interceptor接口
             */&lt;/strong&gt;&lt;span&gt;
            List&amp;lt;Object&amp;gt; chain = &lt;span&gt;&lt;strong&gt;this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

            &lt;/strong&gt;&lt;/span&gt;// 拦截器链为空
            if&lt;span&gt; (chain.isEmpty()) {
                // 通过反射直接调用执行目标方法
                Object[] argsToUse =&lt;span&gt; AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal =&lt;span&gt; AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            }
            else&lt;span&gt; {
                // 创建一个 method invocation 拦截器
                MethodInvocation invocation =
                        new&lt;span&gt; ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
                // Proceed to the joinpoint through the interceptor chain.
                &lt;span&gt;&lt;strong&gt;// 通过拦截器链调用连接点
                retVal =&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; invocation.proceed();&lt;/strong&gt;&lt;/span&gt;
            }

            // Massage return value if necessary.
            Class&amp;lt;?&amp;gt; returnType =&lt;span&gt; method.getReturnType();
            if (retVal != null &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp;&lt;span&gt;
                    returnType != Object.class &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
                    !RawTargetAccess.class&lt;span&gt;.isAssignableFrom(method.getDeclaringClass())) {
                // Special case: it returned &quot;this&quot; and the return type of the method
                // is type-compatible. Note that we can't help if the target sets
                // a reference to itself in another returned object.
                retVal =&lt;span&gt; proxy;
            }
            else if (retVal == null &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp;&lt;span&gt; returnType.isPrimitive()) {
                throw new&lt;span&gt; AopInvocationException(
                        &quot;Null return value from advice does not match primitive return type for: &quot; +&lt;span&gt; method);
            }
            return&lt;span&gt; retVal;
        }
        finally&lt;span&gt; {
            if (target != null &amp;amp;&amp;amp; !&lt;span&gt;targetSource.isStatic()) {
                // Must have come from TargetSource.
&lt;span&gt;                targetSource.releaseTarget(target);
            }
            if&lt;span&gt; (setProxyContext) {
                // Restore old proxy.
&lt;span&gt;                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; 这里有两步很重要:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步: 将匹配的advisor转换为Interceptor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步: 调用责任链, 执行各类通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210120105441539-37525430.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;先看第一步: &lt;/strong&gt;&lt;strong&gt;将匹配的advisor对象转换为interceptor拦截器对象. 为什么要将advisor转换为interceptor拦截器呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为要进行责任链调用&lt;/strong&gt;. 前面说过, 要想进行责任链调用, 他们要有一个共同的方法. 转化为interceptor以后, 共同的方法就是invoke().&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    public List&amp;lt;Object&amp;gt;&lt;span&gt;&lt;strong&gt; getInterceptorsAndDynamicInterceptionAdvice&lt;/strong&gt;(
            Advised config, Method method, @Nullable Class&amp;lt;?&amp;gt;&lt;span&gt; targetClass) {

        // This is somewhat tricky... We have to process introductions first,
        // but we need to preserve order in the ultimate list.
        AdvisorAdapterRegistry registry =&lt;span&gt; GlobalAdvisorAdapterRegistry.getInstance();
        &lt;strong&gt;// 获取到匹配当前方法的所有advisor
        Advisor[] advisors =&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; config.getAdvisors();&lt;/strong&gt;
        List&amp;lt;Object&amp;gt; interceptorList = new ArrayList&amp;lt;&amp;gt;&lt;span&gt;(advisors.length);
        Class&amp;lt;?&amp;gt; actualClass = (targetClass != null ?&lt;span&gt; targetClass : method.getDeclaringClass());
        Boolean hasIntroductions = null&lt;span&gt;;

        for&lt;span&gt; (Advisor advisor : advisors) {
            /**
             * 如果advisor是PointcutAdvisor类型
             */
            &lt;strong&gt;if&lt;span&gt; (advisor instanceof PointcutAdvisor) {
                &lt;/span&gt;&lt;/strong&gt;// Add it conditionally.
                PointcutAdvisor pointcutAdvisor =&lt;span&gt; (PointcutAdvisor) advisor;
                // 注解配置信息是一个前置过滤器 或者 目标类匹配advisor的切点表达式
                if (config.isPreFiltered() ||&lt;span&gt; pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
                    MethodMatcher mm =&lt;span&gt; pointcutAdvisor.getPointcut().getMethodMatcher();
                    boolean match;
                    if&lt;span&gt; (mm instanceof IntroductionAwareMethodMatcher) {
                        if (hasIntroductions == null&lt;span&gt;) {
                            hasIntroductions =&lt;span&gt; hasMatchingIntroductions(advisors, actualClass);
                        }
                        match =&lt;span&gt; ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);
                    }
                    else&lt;span&gt; {
                        match =&lt;span&gt; mm.matches(method, actualClass);
                    }
                    if&lt;span&gt; (match) {
                        // 将advice转换为MethodInterceptor拦截器,
                        MethodInterceptor[] interceptors =&lt;span&gt;&lt;strong&gt; registry.getInterceptors(advisor);
                        &lt;/strong&gt;&lt;/span&gt;if&lt;span&gt; (mm.isRuntime()) {
                            // Creating a new object instance in the getInterceptors() method
                            // isn't a problem as we normally cache created chains.
                            for&lt;span&gt; (MethodInterceptor interceptor : interceptors) {
                                // 将MethodInterceptor拦截器和MethodMatcher组装为一个新的对象
                                interceptorList.add(new&lt;span&gt; InterceptorAndDynamicMethodMatcher(interceptor, mm));
                            }
                        }
                        else&lt;span&gt; {
                            /&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt; 将拦截器直接放到interceptorList中
&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;                            interceptorList.addAll(Arrays.asList(interceptors));&lt;/strong&gt;
                        }
                    }
                }
            }
            &lt;strong&gt;else if (advisor instanceof IntroductionAdvisor) {&lt;/strong&gt; // 如果advisor是IntroductionAdvisor类型
                IntroductionAdvisor ia =&lt;span&gt; (IntroductionAdvisor) advisor;
                if (config.isPreFiltered() ||&lt;span&gt; ia.getClassFilter().matches(actualClass)) {
                    Interceptor[] interceptors =&lt;span&gt;&lt;span&gt;&lt;strong&gt; registry.getInterceptors(advisor);&lt;/strong&gt;&lt;/span&gt;
                    interceptorList.addAll(Arrays.asList(interceptors));
                }
            }
            else { // 其他类型的advisor
                Interceptor[] interceptors =&lt;span&gt;&lt;span&gt;&lt;strong&gt; registry.getInterceptors(advisor);&lt;/strong&gt;&lt;/span&gt;
                interceptorList.addAll(Arrays.asList(interceptors));
            }
        }

        return&lt;span&gt;&lt;strong&gt; interceptorList&lt;/strong&gt;;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里最重要的方法就是&lt;strong&gt;registry.getInterceptors(advisor), 在getInterceptors(advisor)里面循环遍历了advisors, 然后将每一个advisor转换为Interceptor, &lt;/strong&gt;这是将advisor转换为interceptor的具体实现. &lt;/p&gt;
&lt;p&gt;我们来看看源码和逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    public&lt;span&gt; MethodInterceptor[] &lt;strong&gt;getInterceptors&lt;/strong&gt;(Advisor advisor) throws UnknownAdviceTypeException {
        List&amp;lt;MethodInterceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;(3&lt;span&gt;);
        Advice advice =&lt;span&gt; advisor.getAdvice();
        if&lt;span&gt; (advice instanceof MethodInterceptor) {
            // 如果advice已经实现了MethodInterceptor接口, 那么直接将其添加到interceptors集合中
&lt;span&gt;            interceptors.add((MethodInterceptor) advice);
        }
        for (AdvisorAdapter adapter : this&lt;span&gt;.adapters) {
            // 判断是否是指定类型的advice
            if&lt;span&gt; (&lt;span&gt;&lt;strong&gt;adapter.supportsAdvice(advice)&lt;/strong&gt;&lt;/span&gt;) {
                // 如果是就将其转换为对应类型的Interceptor
&lt;span&gt;                interceptors.add(&lt;span&gt;&lt;strong&gt;adapter.getInterceptor(advisor)&lt;/strong&gt;)&lt;/span&gt;;
            }
        }
        if&lt;span&gt; (interceptors.isEmpty()) {
            throw new&lt;span&gt; UnknownAdviceTypeException(advisor.getAdvice());
        }
        return interceptors.toArray(new MethodInterceptor[0&lt;span&gt;]);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;adapter.supportsAdvice(advice)&lt;/strong&gt;判断advice是否是指定类型的adapter. adapter有如下几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MethodBeforeAdviceAdapter : 前置通知adapter&lt;/li&gt;
&lt;li&gt;AfterReturningAdviceAdapter:后置|放回通知adapter&lt;/li&gt;
&lt;li&gt;SimpleBeforeAdviceAdapter: simpler前置通知adapter&lt;/li&gt;
&lt;li&gt;ThrowsAdviceAdapter:异常通知adapter&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里采用的是适配器模式, 通过适配器来匹配各种不同类型的通知. 然后再调用adapter.getInterceptor(advisor)将advisor构建成Interceptor.&lt;/p&gt;
&lt;p&gt;通常有beforeAdivsor, afterAdvisor, returningAdvisor, throwingAdvisor几种类型的通知. 只有returningAdvisor和throwingAdvisor会转化为Interceptor.&lt;br/&gt;因为beforeAdvisor和afterAdvisor本身就实现了interceptor接口.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210121111247155-1507088915.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将所有的advisor转换成Interceptor以后放入到interceptors集合中返回.&lt;/p&gt;

&lt;p&gt;接下来执行责任链调用.责任链调用的思想主要有两个&lt;/p&gt;
&lt;p&gt;1. 递归调用&lt;/p&gt;
&lt;p&gt;2. 所有的advisor最终都让其实现interceptor, 并重写invoke()方法.&lt;/p&gt;
&lt;p&gt;来看一下源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    @Nullable
    public&lt;span&gt; Object proceed() throws Throwable {
        // We start with an index of -1 and increment early.
        // 如果是最后一个拦截器, 则直接执行. invokeJoinpoint()方法
        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1&lt;span&gt;) {
            return&lt;span&gt; invokeJoinpoint();
        }

        // 取出interceptorsAndDynamicMethodMatchers对象
        Object interceptorOrInterceptionAdvice =
                this.interceptorsAndDynamicMethodMatchers.get(++this&lt;span&gt;.currentInterceptorIndex);
        // 如果是InterceptorAndDynamicMethodMatcher类型
        if&lt;span&gt; (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
            // Evaluate dynamic method matcher here: static part will already have
            // been evaluated and found to match.
            InterceptorAndDynamicMethodMatcher dm =&lt;span&gt;
                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            Class&amp;lt;?&amp;gt; targetClass = (this.targetClass != null ? this.targetClass : this&lt;span&gt;.method.getDeclaringClass());
            // 调用methodMather的matchs()方法
            if (dm.methodMatcher.matches(this.method, targetClass, this&lt;span&gt;.arguments)) {
                // 匹配成功, 则调用拦截器的invoke()方法
                return dm.interceptor.invoke(this&lt;span&gt;);
            }
            else&lt;span&gt; {
                // Dynamic matching failed.
                // Skip this interceptor and invoke the next in the chain.
                // 动态匹配失败, 跳过此拦截器, 调用拦截器链中的下一个拦截器
                return&lt;span&gt; proceed();
            }
        }
        else&lt;span&gt; {
            // It's an interceptor, so we just invoke it: The pointcut will have
            // been evaluated statically before this object was constructed.
            //它是一个拦截器，因此我们只需要调用它：切入点将在构造此对象之前进行静态评估。
            return &lt;strong&gt;((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);&lt;/strong&gt;
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里interceptorsAndDynamicMethodMatchers存放的就是所有匹配到的advisor. 按照顺序,取出advisor. 然后将其转换为MethodInterceptor以后, 调用他的invoke(this)方法,同时将传递当前对象, 在invoke(this)中在此调用proceed()方法. 循环调用. 从interceptorsAndDynamicMethodMatchers取advisor, 直到取出最后一个advisor. 再次调用proceed()则指定调用目标方法.&lt;/p&gt;
&lt;p&gt;interceptorsAndDynamicMethodMatchers里面一共有6个advisor&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210126181526861-2070455916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体调用如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202101/1187916-20210126182145746-1110851218.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以上就是调用aop的整个过程. 内容还是很多的,需要时间消化.&lt;/p&gt;
</description>
<pubDate>Wed, 10 Feb 2021 22:51:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>一. AOP切面源码分析 源码分析分为三部分 1. 解析切面 2. 创建动态代理 3. 调用 源码的入口 源码分析的入口, 从注解开始: 组件的入口是一个注解, 比如启用AOP的注解@EnableAs</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/14397221.html</dc:identifier>
</item>
<item>
<title>计算机网络的七层结构、五层结构和四层结构 - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/14397154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/14397154.html</guid>
<description>&lt;p&gt;计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;OSI体系结构&lt;/code&gt;: 概念清楚，理论也比较完整，但是它既复杂又不实用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TCP/IP体系结构&lt;/code&gt;:TCP/IP是一个四层体系结构，得到了广泛的运用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;五层体系结构&lt;/code&gt;:为了方便学习，折中&lt;code&gt;OSI体系结构&lt;/code&gt;和&lt;code&gt;TCP/IP体系结构&lt;/code&gt;，综合二者的优点，这样既简洁，又能将概念讲清楚。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/15902069933478110794342591257585-bfdfb80b.jpg&quot; alt=&quot;15902069933478110794342591257585.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际运行的网络协议。&lt;/p&gt;

&lt;p&gt;看一下五层网络体系结构各层的主要功能：&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;应用层&lt;/code&gt;：应用层是网络协议的最高层，主要任务&lt;strong&gt;通过进程间的交互完成特定网络应用&lt;/strong&gt;。应用层协议定义的是&lt;code&gt;应用程序（进程）间通信和交互的规则&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。应用层交互的数据单元称为&lt;code&gt;报文&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;运输层&lt;/code&gt;：有时也译为传输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；&lt;/li&gt;
&lt;li&gt;用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;网络层&lt;/code&gt;：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成&lt;code&gt;分组&lt;/code&gt;或 &lt;code&gt;包&lt;/code&gt;进行传送。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫&lt;code&gt;IP数据报&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;数据链路层&lt;/code&gt;：数据链路层通常简称为&lt;code&gt;链路层&lt;/code&gt;。数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报&lt;code&gt;组装成帧&lt;/code&gt;，在两个相邻节点之间的链路上传送&lt;code&gt;帧&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;物理层&lt;/code&gt;：保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是应用进程的数据在各层之间的传递过程中所经历的变化的简单示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211010417178.png&quot; alt=&quot;image-20210211010417178&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TCP/IP的体系结构比较简单，只有四层。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;层次名称&lt;/th&gt;
&lt;th&gt;单 位&lt;/th&gt;
&lt;th&gt;功 能&lt;/th&gt;
&lt;th&gt;协 议&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;网络接口&lt;/td&gt;
&lt;td&gt;帧&lt;/td&gt;
&lt;td&gt;负责实际数据的传输，对应OSI参考模型的下两层&lt;/td&gt;
&lt;td&gt;HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;数据报&lt;/td&gt;
&lt;td&gt;负责网络间的寻址数据传输，对应OSI参考模型的第三层&lt;/td&gt;
&lt;td&gt;IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;报文段&lt;/td&gt;
&lt;td&gt;负责提供可靠的传输服务，对应OSI参考模型的第四层&lt;/td&gt;
&lt;td&gt;TCP（控制传输协议） UDP（用户数据报协议）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;应用层&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层&lt;/td&gt;
&lt;td&gt;FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这种四层协议数据交换的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://b3logfile.com/file/2020/05/%E6%96%B0%E6%96%87%E6%A1%A30522202013.24.48-5563d486.jpg?imageView2/2/interlace/1/format/webp&quot; alt=&quot;新文档 0522202013.24.48.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://b3logfile.com/file/2020/05/%E6%96%B0%E5%BB%BAXLSX%E5%B7%A5%E4%BD%9C%E8%A1%A8-2601b9ae.png?imageView2/2/interlace/1/format/webp&quot; alt=&quot;新建 XLSX 工作表.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;【1】：谢希仁编著 《计算机网络》&lt;/p&gt;
&lt;p&gt;【2】：&lt;a href=&quot;https://segmentfault.com/a/1190000039202672&quot; target=&quot;_blank&quot;&gt;网络篇（一）：所谓的四层结构和七层结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【3】：&lt;a href=&quot;https://ld246.com/article/1590226877769&quot; target=&quot;_blank&quot;&gt;计算机网络模型（四层、五层、七层）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【4】：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32059190&quot; target=&quot;_blank&quot;&gt;OSI 7层模型和TCP/IP 4层模型&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Feb 2021 17:25:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>1、	计算机网络体系 计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。 OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。 TCP/IP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/14397154.html</dc:identifier>
</item>
<item>
<title>程序员必备的一些数学基础知识 - 柯广</title>
<link>http://www.cnblogs.com/data-magnifier/p/14397061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/data-magnifier/p/14397061.html</guid>
<description>&lt;p&gt;作为一个标准的程序员，应该有一些基本的数学素养，尤其现在很多人在学习人工智能相关知识，想抓住一波人工智能的机会。很多程序员可能连这样一些基础的数学问题都回答不上来。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;矩阵&lt;code&gt;A(m,n)&lt;/code&gt;与矩阵&lt;code&gt;B(n,k)&lt;/code&gt;乘积C维度是多少？&lt;/li&gt;
&lt;li&gt;抛一枚硬币，正面表示1，反面表示0，那么取值的数学期望E(x)是多少？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一个傲娇的程序员，应该要掌握这些数学基础知识，才更有可能码出一个伟大的产品。&lt;/p&gt;
&lt;h2 id=&quot;线性代数&quot;&gt;线性代数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;向量&lt;/strong&gt; 向量（vector）是由一组实数组成的有序数组，同时具有大小和方向。一个n维向量a是由n个有序实数组成，表示为 a = [a1, a2, · · · , an]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性映射&lt;/strong&gt; 矩阵通常表示一个n维线性空间v到m维线性空间w的一个映射f: v -&amp;gt; w &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：为了书写方便，&lt;code&gt;X.T&lt;/code&gt;，表示向量X的转置。 这里：&lt;code&gt;X(x1,x2,...,xn).T，y(y1,y2,...ym).T&lt;/code&gt;，都是列向量。分别表示v,w两个线性空间中的两个向量。A(m,n)是一个&lt;code&gt;m*n&lt;/code&gt;的矩阵，描述了从v到w的一个线性映射。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转置&lt;/strong&gt; 将矩阵行列互换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加法&lt;/strong&gt; 如果A和B 都为m × n的矩阵，则A和B 的加也是m × n的矩阵，其每个元素是A和B相应元素相加。 [A + B]ij = aij + bij .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乘法&lt;/strong&gt; 如A是k × m矩阵和B 是m × n矩阵，则乘积AB 是一个k × n的矩阵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对角矩阵&lt;/strong&gt; 对角矩阵是一个主对角线之外的元素皆为0的矩阵。对角线上的元素可以为0或其他值。一个n × n的对角矩阵A满足： [A]ij = 0 if i ̸= j ∀i, j ∈ {1, · · · , n}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征值与特征矢量&lt;/strong&gt; 如果一个标量λ和一个非零向量v满足 Av = λv, 则λ和v分别称为矩阵A的特征值和特征向量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;矩阵分解&lt;/strong&gt; 一个矩阵通常可以用一些比较“简单”的矩阵来表示，称为矩阵分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;奇异值分解&lt;/strong&gt; 一个m×n的矩阵A的奇异值分解 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;其中U 和V 分别为m × m和n×n 的正交矩阵，Σ为m × n的对角矩阵，其对角 线上的元素称为奇异值（singular value）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征分解&lt;/strong&gt; 一个n × n的方块矩阵A的特征分解（Eigendecomposition）定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;其中Q为n × n的方块矩阵，其每一列都为A的特征向量，^为对角阵，其每一 个对角元素为A的特征值。 如果A为对称矩阵，则A可以被分解为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中Q为正交阵。&lt;/p&gt;
&lt;h2 id=&quot;微积分&quot;&gt;微积分&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;导数&lt;/strong&gt; 对于定义域和值域都是实数域的函数&lt;code&gt;f : R → R&lt;/code&gt;，若f(x)在点x0 的某个邻域∆x内，极限 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;存在，则称函数f(x)在点x0 处可导，&lt;code&gt;f'(x0)&lt;/code&gt;称为其导数，或导函数。 若函数f(x)在其定义域包含的某区间内每一个点都可导，那么也可以说函数f(x)在这个区间内可导。连续函数不一定可导，可导函数一定连续。例如函数|x|为连续函数，但在点x = 0处不可导。&lt;/p&gt;
&lt;h3 id=&quot;导数法则&quot;&gt;导数法则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;加法法则&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;y = f(x),z = g(x)&lt;/code&gt;则&lt;br/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/10.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乘法法则&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/11.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链式法则&lt;/strong&gt; 求复合函数导数的一个法则，是在微积分中计算导数的一种常用方法。若&lt;code&gt;x ∈ R，y = g(x) ∈ R，z = f(y) ∈ R&lt;/code&gt;，则 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/12.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;logistic-函数&quot;&gt;Logistic 函数&lt;/h3&gt;
&lt;p&gt;Logistic函数是一种常用的S形函数，是比利时数学家 Pierre François Verhulst在&lt;code&gt;1844-1845&lt;/code&gt;年研究种群数量的增长模型时提出命名的，最初作为一种生 态学模型。 Logistic函数定义为： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/14.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;当参数为&lt;code&gt;(k = 1, x0 = 0, L = 1)&lt;/code&gt;时，logistic函数称为标准logistic函数，记 为&lt;code&gt;σ(x)&lt;/code&gt;。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/15.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;标准logistic函数在机器学习中使用得非常广泛，经常用来将一个实数空间的数映射到(0, 1)区间。标准&lt;code&gt;logistic&lt;/code&gt;函数的导数为： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/16.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;softmax-函数&quot;&gt;softmax 函数&lt;/h3&gt;
&lt;p&gt;softmax函数是将多个标量映射为一个概率分布。对于&lt;code&gt;K&lt;/code&gt;个标量&lt;code&gt;x1, · · · , xK&lt;/code&gt;，&lt;code&gt;softmax&lt;/code&gt; 函数定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/17.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;这样，我们可以将&lt;code&gt;K&lt;/code&gt;个变量&lt;code&gt;x1, · · · , xK&lt;/code&gt;转换为一个分布：&lt;code&gt;z1, · · · , zK&lt;/code&gt;，满足 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/18.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;当softmax 函数的输入为K 维向量x时， &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/19.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中，1K = [1, · · · , 1]K×1 是K 维的全1向量。其导数为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/20.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数学优化&quot;&gt;数学优化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;离散优化和连续优化&lt;/strong&gt;:根据输入变量x的值域是否为实数域，数学优化问题可以分为离散优化问题和连续优化问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无约束优化和约束优化&lt;/strong&gt;:在连续优化问题中，根据是否有变量的约束条件，可以将优化问题分为无约束优化问题和约束优化问题。 ### 优化算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局最优和局部最优&lt;/strong&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/21.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/22.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;海赛矩阵 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/23.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;《运筹学里面有讲》，前面一篇文章计算梯度步长的时候也用到了： 梯度下降算法 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/24.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/25.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;梯度&quot;&gt;梯度&lt;/h3&gt;
&lt;p&gt;梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度下降法&lt;/strong&gt;&lt;br/&gt;梯度下降法（Gradient Descent Method），也叫最速下降法（Steepest Descend Method），经常用来求解无约束优化的极小值问题。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/26.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;梯度下降法的过程如图所示。曲线是等高线（水平集），即函数f为不同常数的集合构成的曲线。红色的箭头指向该点梯度的反方向（梯度方向与通过该点的等高线垂直）。沿着梯度下降方向，将最终到达函数f 值的局部最优解。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/27.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度上升法&lt;/strong&gt;&lt;br/&gt;如果我们要求解一个最大值问题，就需要向梯度正方向迭代进行搜索，逐渐接近函数的局部极大值点，这个过程则被称为梯度上升法。&lt;/p&gt;
&lt;h2 id=&quot;概率论&quot;&gt;概率论&lt;/h2&gt;
&lt;p&gt;概率论主要研究大量随机现象中的数量规律，其应用十分广泛，几乎遍及各个领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散随机变量&lt;/strong&gt;如果随机变量X 所可能取的值为有限可列举的，有n个有限取值 {x1, · · · , xn}, 则称X 为离散随机变量。要了解X 的统计规律，就必须知道它取每种可能值xi 的概率，即 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/28.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;code&gt;p(x1), · · · , p(xn)&lt;/code&gt;称为离散型随机变量X 的概率分布或分布，并且满足 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/29.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;常见的离散随机概率分布有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伯努利分布&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/30.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二项分布&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/31.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续随机变量&lt;/strong&gt;&lt;br/&gt;与离散随机变量不同，一些随机变量X 的取值是不可列举的，由全部实数 或者由一部分区间组成，比如 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/32.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;则称X 为连续随机变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概率密度函数&lt;/strong&gt;&lt;br/&gt;连续随机变量X 的概率分布一般用概率密度函数&lt;code&gt;p(x)&lt;/code&gt;来描述。&lt;code&gt;p(x)&lt;/code&gt;为可积函数，并满足： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/33.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均匀分布&lt;/strong&gt; 若a, b为有限数，[a, b]上的均匀分布的概率密度函数定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/34.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正态分布&lt;/strong&gt; 又名高斯分布，是自然界最常见的一种分布，并且具有很多良好的性质，在很多领域都有非常重要的影响力，其概率密度函数为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/35.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中，&lt;code&gt;σ &amp;gt; 0，µ&lt;/code&gt;和&lt;code&gt;σ&lt;/code&gt; 均为常数。若随机变量X 服从一个参数为&lt;code&gt;µ&lt;/code&gt;和&lt;code&gt;σ&lt;/code&gt; 的概率分布，简记为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/36.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;当&lt;code&gt;µ = 0，σ = 1&lt;/code&gt;时，称为标准正态分布。 均匀分布和正态分布的概率密度函数图： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/37.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;累积分布函数&lt;/strong&gt;&lt;br/&gt;对于一个随机变量X，其累积分布函数是随机变量X 的取值小于等于x的概率。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/38.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;以连续随机变量X 为例，累积分布函数定义为： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/39.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中p(x)为概率密度函数，标准正态分布的累计分布函数: &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/40.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机向量&lt;/strong&gt;&lt;br/&gt;随机向量是指一组随机变量构成的向量。如果&lt;code&gt;X1, X2, · · · , Xn&lt;/code&gt; 为n个随机变量, 那么称 &lt;code&gt;[X1, X2, · · · , Xn]&lt;/code&gt; 为一个 n 维随机向量。一维随机向量称为随机变量。随机向量也分为离散随机向量和连续随机向量。 条件概率分布 对于离散随机向量&lt;code&gt;(X, Y)&lt;/code&gt;，已知X = x的条件下，随机变量&lt;code&gt;Y = y&lt;/code&gt;的条件概率为： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/41.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;对于二维连续随机向量(X, Y )，已知X = x的条件下，随机变量Y = y 的条件概率密度函数为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/42.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;期望和方差&quot;&gt;期望和方差&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;期望&lt;/strong&gt; 对于离散变量X，其概率分布为&lt;code&gt;p(x1), · · · , p(xn)&lt;/code&gt;，X 的期望（expectation）或均值定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/43.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;对于连续随机变量X，概率密度函数为p(x)，其期望定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/44.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方差&lt;/strong&gt; 随机变量X 的方差（variance）用来定义它的概率分布的离散程度，定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/45.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标准差&lt;/strong&gt; 随机变量 X 的方差也称为它的二阶矩。X 的根方差或标准差。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/46.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协方差&lt;/strong&gt; 两个连续随机变量X 和Y 的协方差（covariance）用来衡量两个随机变量的分布之间的总体变化性，定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/47.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;协方差经常也用来衡量两个随机变量之间的线性相关性。如果两个随机变量的协方差为0，那么称这两个随机变量是线性不相关。两个随机变量之间没有线性相关性，并非表示它们之间独立的，可能存在某种非线性的函数关系。反之，如果X 与Y 是统计独立的，那么它们之间的协方差一定为0。&lt;/p&gt;
&lt;h3 id=&quot;随机过程&quot;&gt;随机过程&lt;/h3&gt;
&lt;p&gt;随机过程（stochastic process）是一组随机变量Xt 的集合，其中t属于一个索引（index）集合T 。索引集合T 可以定义在时间域或者空间域，但一般为时间域，以实数或正数表示。当t为实数时，随机过程为连续随机过程；当t为整数时，为离散随机过程。日常生活中的很多例子包括股票的波动、语音信号、身高的变化等都可以看作是随机过程。常见的和时间相关的随机过程模型包括贝努力过程、随机游走、马尔可夫过程等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;马尔可夫过程&lt;/strong&gt; 指一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/48.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中X0:t 表示变量集合X0, X1, · · · , Xt，x0:t 为在状态空间中的状态序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;马尔可夫链&lt;/strong&gt; 离散时间的马尔可夫过程也称为马尔可夫链（Markov chain）。如果一个马尔可夫链的条件概率 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/49.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;马尔可夫的使用可以看前面一篇写的有意思的文章： &lt;a href=&quot;https://mp.weixin.qq.com/s/2fyjOSSKXxvrCawTWR_2ow&quot; target=&quot;_blank&quot;&gt;女朋友的心思你能猜得到吗？——马尔可夫链告诉你&lt;/a&gt;随机过程还有高斯过程，比较复杂，这里就不详细说明了。&lt;/p&gt;
&lt;h2 id=&quot;信息论&quot;&gt;信息论&lt;/h2&gt;
&lt;p&gt;信息论（information theory）是数学、物理、统计、计算机科学等多个学科的交叉领域。信息论是由 Claude Shannon最早提出的，主要研究信息的量化、存储和通信等方法。在机器学习相关领域，信息论也有着大量的应用。比如特征抽取、统计推断、自然语言处理等。&lt;/p&gt;
&lt;h3 id=&quot;自信息和熵&quot;&gt;自信息和熵&lt;/h3&gt;
&lt;p&gt;在信息论中，熵用来衡量一个随机事件的不确定性。假设对一个随机变量X（取值集合为C概率分布为&lt;code&gt;p(x), x ∈ C&lt;/code&gt;）进行编码，自信息I(x)是变量X = x时的信息量或编码长度，定义为 I(x) = − log(p(x)), 那么随机变量X 的平均编码长度，即熵定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;其中当p(x) = 0时，我们定义0log0 = 0 熵是一个随机变量的平均编码长度，即自信息的数学期望。熵越高，则随机变量的信息越多；熵越低，则信息越少。如果变量X 当且仅当在x时&lt;code&gt;p(x) = 1&lt;/code&gt;，则熵为0。也就是说，对于一个确定的信息，其熵为0，信息量也为0。如果其概率分布为一个均匀分布，则熵最大。假设一个随机变量X 有三种可能值x1, x2, x3，不同概率分布对应的熵如下： &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联合熵和条件熵&lt;/strong&gt; 对于两个离散随机变量X 和Y ，假设X 取值集合为X；Y 取值集合为Y，其联合概率分布满足为&lt;code&gt;p(x, y)&lt;/code&gt;，则X 和Y 的联合熵（Joint Entropy）为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/50.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;X 和Y 的条件熵为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互信息&lt;/strong&gt; 互信息（mutual information）是衡量已知一个变量时，另一个变量不确定性的减少程度。两个离散随机变量X 和Y 的互信息定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/52.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;交叉熵和散度 交叉熵 对应分布为p(x)的随机变量，熵H(p)表示其最优编码长度。交叉熵是按照概率分布q 的最优编码对真实分布为p的信息进行编码的长度，定义为 &lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/coder-math/53.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;在给定p的情况下，如果q 和p越接近，交叉熵越小；如果q 和p越远，交叉熵就越大。&lt;br/&gt;&lt;img src=&quot;http://qiniu.ikeguang.com/image/ikeguang.com/ikeguang2.jpg&quot; alt=&quot;微信扫码关注&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Feb 2021 15:53:00 +0000</pubDate>
<dc:creator>柯广</dc:creator>
<og:description>作为一个标准的程序员，应该有一些基本的数学素养，尤其现在很多人在学习人工智能相关知识，想抓住一波人工智能的机会。很多程序员可能连这样一些基础的数学问题都回答不上来。 矩阵A(m,n)与矩阵B(n,k)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/data-magnifier/p/14397061.html</dc:identifier>
</item>
<item>
<title>主动降噪，通话降噪及AI降噪之辨 - c6000</title>
<link>http://www.cnblogs.com/c6000/p/14397024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c6000/p/14397024.html</guid>
<description>&lt;p&gt;近日，三星发布的Buds Pro 耳机中，宣传有以下功能。其中涉及到噪声的，有主动降噪，通话降噪及智能降噪，很多人对他们的具体用途容易混淆，今天我们来辨析一下。&lt;/p&gt;

&lt;p&gt;                                   &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210210212750684-1466789692.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;266&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;主动降噪和通话降噪完全不是一个概念，无论从方法，目的，技术手段，应用场景都不一样。&lt;/p&gt;

&lt;p&gt;1. 主动降噪ANC（Active Noise Cancellation），简单来说，耳机中的主动降噪是为了减少佩戴者自己听到的环境噪声，它是通过佩戴者耳机的扬声器发出与环境噪声相反相的声波，在佩戴者耳朵内部这个小小的声场环境里抵消了通过耳机物理结构传播进来的环境噪声，通过一下三张图就可以明白其基本原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210210220850433-2059579942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210210221003352-2139361916.png&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;227&quot; loading=&quot;lazy&quot;/&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210210221253854-954494557.png&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;242&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;为了实现主动降噪，其技术手段有Feedforward ANC (前馈主动降噪)， Feedback ANC (反馈主动降噪) 以及 Hybrid ANC (混合主动降噪，其实就是前馈加上反馈)。&lt;/p&gt;
&lt;p&gt;当前常见的算法： Filtered-X Least-Mean-Square (FXLMS) 滤波器，所以这么看来，ANC 实际和互联网常说的音频三剑客 3A 中的AEC还是近亲呢。&lt;/p&gt;


&lt;p&gt;ANC的实现方法解释起来比较繁琐，这里推荐几篇帖子，欢迎有兴趣的同学深入研究：&lt;/p&gt;
&lt;p&gt;Active Noise Control: A Tutorial Review： http://www2.coe.pku.edu.cn/tpic/2010913102917710.pdf&lt;/p&gt;
&lt;p&gt;关于主动降噪耳机，你想知道的一切： https://zhuanlan.zhihu.com/p/133252284&lt;/p&gt;
&lt;p&gt;这里给出一个例子供大家学习: https://github.com/875441459/Basic-demonstraion-of-Fxlms-Algo&lt;/p&gt;

&lt;p&gt;2. 通话降噪是互联网常说的音频三剑客3A中的一员，严格来说3A是指：&lt;/p&gt;
&lt;p&gt;AEC（Acoustic Echo Canceller），ANS(Ambient Noise Suppression)， AGC（Automatic Gain Control）&lt;/p&gt;
&lt;p&gt;通话降噪指的是 ANS(Ambient Noise Suppression)，也就是常说的噪声抑制，也有叫做Automatic Noise Suppression，狭义上的语音增强和语音分离也是指噪声抑制，&lt;/p&gt;
&lt;p&gt;广义的语音增强和语音分离就包含各自更广泛地范围了，有机会再详述。有人把ANC列为3A之一，很显然是混淆了二者的概念。&lt;/p&gt;
&lt;p&gt;通话降噪，简单来说是要从已经混有噪声的语音信号中，把噪声给抑制掉，完全通过软件从信号处理层面实现的，不像ANC那样需要在声场层面解决问题。&lt;/p&gt;
&lt;p&gt;通话降噪是为了降低耳机佩戴者在通话时传输给对方的语音中的噪声，其目的是把带噪语音变为清晰语音，当然也不一定非得用于通话，只要有这个需求的场景都可以用到。&lt;/p&gt;
&lt;p&gt;噪声抑制作为研究了几十年的技术，有很多的方法，不过目前因为谷歌开源的实时通信引擎WebRTC中的噪声抑制效果很好，很多公司都借鉴了WebRTC的噪声抑制方案。&lt;/p&gt;
&lt;p&gt;对于通话链路，不仅仅有一个通话降噪，其实它包含有如下的很多模块：&lt;/p&gt;
&lt;p&gt;                               &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210210231915696-170746353.png&quot; alt=&quot;&quot; width=&quot;675&quot; height=&quot;166&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这篇文章介绍的比较全面，推荐大家：通话降噪超级简洁——简介 https://zhuanlan.zhihu.com/p/87340866&lt;/p&gt;
&lt;p&gt;在github上有多的源码，这里给出一个例子供大家学习：https://github.com/cpuimage/WebRTC_NS&lt;/p&gt;

&lt;p&gt;3. AI降噪&lt;/p&gt;
&lt;p&gt;所谓的AI降噪，也就是智能降噪，其实是指的具体实现方法，不管是主动降噪，还是通话降噪，只要使用了深度学习技术，就可以称为AI降噪。&lt;/p&gt;
&lt;p&gt;目前在通话降噪中，深度学习使用的比较多，近几年各大语音学术会议上的噪声抑制，基本是深度学习论文一统天下了，反而信号处理方案论文不多见了。&lt;/p&gt;
&lt;p&gt;这里是业界交口称赞的一套开源的深度学习噪声抑制的方案：https://github.com/xiph/rnnoise&lt;/p&gt;
&lt;p&gt;而目前在主动降噪领域，引入深度学习的确实不多，笔者猜测由于主动降噪本身就是自适应滤波器，带有一定的自我学习的特点了，所以引入深度学习的效果可能提升有限。&lt;/p&gt;

&lt;p&gt;希望读者读过这篇文章后，对主动降噪，通话降噪及AI降噪有了初步的了解。&lt;/p&gt;

</description>
<pubDate>Wed, 10 Feb 2021 15:36:00 +0000</pubDate>
<dc:creator>c6000</dc:creator>
<og:description>近日，三星发布的Buds Pro 耳机中，宣传有以下功能。其中涉及到噪声的，有主动降噪，通话降噪及智能降噪，很多人对他们的具体用途容易混淆，今天我们来辨析一下。 主动降噪和通话降噪完全不是一个概念，无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c6000/p/14397024.html</dc:identifier>
</item>
<item>
<title>ASP.Net Core 5.0   MVC中AOP思想的体现(五种过滤器)并结合项目案例说明过滤器的用法 - 明志德道</title>
<link>http://www.cnblogs.com/for-easy-fast/p/14396996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/for-easy-fast/p/14396996.html</guid>
<description>&lt;h2&gt;执行顺序&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210224948452-1203983234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用方法，首先实现各自的接口，override里面的方法， 然后在startup 类的 ConfigureServices 方法，注册它们。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            services.AddTransient(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyAction));
            services.AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyResult));
            services.AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyException));
            services.AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyAuthorize));
            services.AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MyResource));
            services.AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(CheckLogin));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我将代码贴出来，照着模仿就可以了&lt;/p&gt;
&lt;h2&gt;IActionFilter&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAction :Attribute,IActionFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuted(ActionExecutedContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;行为过滤器OnActionExecuted作用于{controllerName }控制器下的{actionName }方法运行之后&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Encoding.Default);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;行为过滤器OnActionExecuting作用于{controllerName }控制器下的{actionName }方法运行之前&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Encoding.UTF8);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;IResultFilter&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyResult : Attribute,IResultFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResultExecuted(ResultExecutedContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果过滤器ResultExecuted作用于{controllerName }控制器下的{actionName }方法运行之后&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Encoding.Unicode);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResultExecuting(ResultExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果过滤器OnResultExecuting作用于{controllerName }控制器下的{actionName }方法运行之前&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Encoding.ASCII);
           
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;IExceptionFilter&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyException : Attribute,IExceptionFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext context)
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/调用框架本身异常处理器的方法&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;base.OnException(filterContext);&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取异常信息(可以根据实际需要写到本地或数据库中)&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; errorMsg =&lt;span&gt; context.Exception.Message;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常过滤器OnException作用于{controllerName }控制器下的{actionName }方法发生了错误：      {errorMsg}&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转指定的错误页面&lt;/span&gt;
&lt;span&gt;
            context.ExceptionHandled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;IAuthorizationFilter&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAuthorize : Attribute,IAuthorizationFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationFilterContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;身份验证过滤器OnAuthorization作用于{controllerName }控制器下的{actionName }方法&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;IResourceFilter&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyResource : Attribute, IResourceFilter
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; CacheDictionary = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResourceExecuted(ResourceExecutedContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代码执行到这里，就表示一定完成了逻辑计算；就有结果；&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; key =&lt;span&gt; context.HttpContext.Request.Path;
            CacheDictionary[key] &lt;/span&gt;=&lt;span&gt; context.Result;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;资源过滤器OnResourceExecuted 在{controllerName }控制器下的{actionName }方法运行之后，将结果数据缓存起来&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

         
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnResourceExecuting(ResourceExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;1.先判断缓存中是否有数据
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;2.如果有数据，就直接拿着数据走了
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;3.没有就继续往后，就去实例化控制器，去执行Action做计算 &lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存：需要一个key;  只要是key不变，拿到的数据就不变；
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果做缓存，一般请求路径不变，数据一般不变； &lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; key =&lt;span&gt; context.HttpContext.Request.Path;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CacheDictionary.Any(item =&amp;gt; item.Key ==&lt;span&gt; key))
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;资源过滤器OnResultExecuting   在{controllerName }控制器下的{actionName }方法运行之前 判断有缓存数据,直接返回数据&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                context.Result &lt;/span&gt;= CacheDictionary[key] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IActionResult;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有缓存---就继续往后； &lt;/span&gt;
            Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;资源过滤器OnResultExecuting   在{controllerName }控制器下的{actionName }方法运行之前 判断没有缓存数据&amp;lt;/br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;效果验证&lt;/h2&gt;
&lt;h3&gt;执行顺序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210230406658-1523690048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210230717912-480843311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 发生异常时的顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210231141380-650402947.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210231341425-418489318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;IResourceFilter做数据缓存的效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210231927481-1059043107.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/539967/202102/539967-20210210231732161-156982738.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Feb 2021 15:22:00 +0000</pubDate>
<dc:creator>明志德道</dc:creator>
<og:description>执行顺序 使用方法，首先实现各自的接口，override里面的方法， 然后在startup 类的&amp;#160;ConfigureServices 方法，注册它们。 services.AddTransie</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/for-easy-fast/p/14396996.html</dc:identifier>
</item>
<item>
<title>Spring Cloud实战 | 第十一篇：Spring Cloud Gateway网关实现对RESTful接口权限和按钮权限细粒度控制 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/14396990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/14396990.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/u=2478810630,3144072215&amp;amp;fm=26&amp;amp;gp=0.png&quot; class=&quot;desc_img&quot;/&gt;本篇通过实战的方式讲述如何基于Spring Cloud Gateway + vue-element-admin技术设计一套符合RBAC规范的权限管理系统，通过网关就可以轻易实现RESTful接口方法细粒度的控制，无需将Spring Security模块引入各个微服务；以及使用Vue的自定义指令在组件中使用实现细粒度的按钮权限控制。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153.32273961581&quot;&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;一. 前言&lt;/h2&gt;
&lt;p&gt;hi，大家好，这应该是农历年前的关于开源项目&lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来商城&lt;/a&gt; 的最后一篇文章了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来商城&lt;/a&gt; 是基于 Spring Cloud OAuth2 + Spring Cloud Gateway + JWT实现的统一认证鉴权，Spring Cloud &amp;amp; Alibaba + vue-element-admin实现的微服务、前后端分离的全栈开源项目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来商城&lt;/a&gt; 的权限设计主要是为了实现以下几点目标：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现RBAC模式的权限管理设计&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现基于vue-element-admin后台菜单权限管理系统&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Spring Cloud Gateway网关针对RESTful接口权限控制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Vue自定义指令实现按钮级别权限控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二-项目介绍&quot;&gt;二. 项目介绍&lt;/h2&gt;
&lt;h3 id=&quot;1-项目简介&quot;&gt;1. 项目简介&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来商城&lt;/a&gt; 是基于Spring Boot 2.4、Spring Cloud 2020 &amp;amp; Alibaba、Vue、element-ui、uni-app快速构建的一套&lt;strong&gt;全栈&lt;/strong&gt;开源商城平台，包括微服务应用、管理平台、微信小程序及APP应用。&lt;/p&gt;
&lt;h3 id=&quot;2-项目地址&quot;&gt;2. 项目地址&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;项目预览地址:&lt;/strong&gt; &lt;a href=&quot;https://www.youlai.store/&quot; target=&quot;_blank&quot;&gt;http://www.youlai.store&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信小程序体验码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/%E4%B8%89%E7%A0%81%E5%90%88%E4%B8%80.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码地址：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-项目往期文章&quot;&gt;3. 项目往期文章&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;后台微服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13581881.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第一篇：Windows搭建Nacos服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13584204.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第二篇：Spring Cloud整合Nacos实现注册中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13585125.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第三篇：Spring Cloud整合Nacos实现配置中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13608650.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第四篇：Spring Cloud整合Gateway实现API网关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13615592.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第五篇：Spring Cloud整合OpenFeign实现微服务之间的调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13719356.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第六篇：Spring Cloud Gateway+Spring Security OAuth2+JWT实现微服务统一认证授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13740264.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最七篇：Spring Cloud Gateway+Spring Security OAuth2集成统一认证授权平台下实现注销使JWT失效方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14022632.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最八篇：Spring Cloud +Spring Security OAuth2+ Vue前后端分离模式下无感知刷新实现JWT续期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14028366.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最九篇：Spring Security OAuth2认证服务器统一认证自定义异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14280184.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第十篇 ：Spring Cloud + Nacos整合Seata 1.4.1最新版本实现微服务架构中的分布式事务，进阶之路必须要迈过的槛&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;后台管理前端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13624548.html&quot; target=&quot;_blank&quot;&gt;vue-element-admin实战 | 第一篇： 移除mock接入微服务接口，搭建SpringCloud+Vue前后端分离管理平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13676619.html&quot; target=&quot;_blank&quot;&gt;vue-element-admin实战 | 第二篇： 最小改动接入后台实现根据权限动态加载菜单&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;微信小程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13882310.html&quot; target=&quot;_blank&quot;&gt;vue+uni-app商城实战 | 第一篇：从0到1快速开发一个商城微信小程序，无缝接入Spring Cloud OAuth2认证授权登录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;应用部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14067423.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第一篇：Linux 安装 Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14059009.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第二篇：Docker部署nacos-server:1.4.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14088400.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第三篇：IDEA集成Docker插件实现一键自动打包部署微服务项目，一劳永逸的技术手段值得一试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14091762.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第四篇：Docker安装Nginx，实现基于vue-element-admin框架构建的项目线上部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14095306.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第五篇：Docker启用TLS加密解决暴露2375端口引发的安全漏洞，被黑掉三台云主机的教训总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三-数据库设计&quot;&gt;三. 数据库设计&lt;/h2&gt;
&lt;p&gt;RBAC(Role-Based Access Control)&lt;strong&gt;基于角色访问控制&lt;/strong&gt;，目前使用最为广泛的权限模型。&lt;/p&gt;
&lt;p&gt;此模型有三个角色用户、角色和权限，在传统的权限模型用户直接关联加了角色层，解耦了用户和权限，使得权限系统有了更清晰的职责划分和更高的灵活度。&lt;/p&gt;
&lt;p&gt;以下是&lt;u&gt;&lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来系统&lt;/a&gt;&lt;/u&gt;关于RBAC权限模型的数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/08/kumn3iIZJ4zdcDe.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户和角色关系不用过多说明，这里重点说下权限，首先系统的权限分为3类，具体如下表:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;权限名称&lt;/th&gt;
&lt;th&gt;表名&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;权限标识&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;菜单权限&lt;/td&gt;
&lt;td&gt;sys_menu&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;接口权限&lt;/td&gt;
&lt;td&gt;sys_permission&lt;/td&gt;
&lt;td&gt;type=1&lt;/td&gt;
&lt;td&gt;PUT_/users/**&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;按钮权限&lt;/td&gt;
&lt;td&gt;sys_permission&lt;/td&gt;
&lt;td&gt;type=2&lt;/td&gt;
&lt;td&gt;system:user:add&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其实了解过目前主流开源系统的权限设计，大概率的把菜单和按钮放一块然后根据类别字段区分，以下就关于这种方式优劣发表下个人意见，仅供大家参考下不必较真：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;理论上合理，按钮肯定属于某个菜单之下&lt;/li&gt;
&lt;li&gt;省去了权限表(sys_permission)和关联中间表这两张表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;劣势：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;菜单模块变的复杂了，菜单表多了和菜单无关联的类型字段和权限标识字段&lt;/li&gt;
&lt;li&gt;菜单和按钮查询要区分类型，给代码开发带来复杂和影响查询性能&lt;/li&gt;
&lt;li&gt;不能同时满足按钮权限控制和网关根据请求路径Ant匹配鉴权（具体下文说）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四-权限管理系统&quot;&gt;四. 权限管理系统&lt;/h2&gt;
&lt;p&gt;先看下vue-element-admin下的RBAC模型下的后台权限管理界面，体验地址：&lt;a href=&quot;https://www.youlai.store/&quot; target=&quot;_blank&quot;&gt;http://www.youlai.store&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;菜单权限管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210206221810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;角色分配权限&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210206221757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五-restful接口权限控制&quot;&gt;五. RESTful接口权限控制&lt;/h2&gt;
&lt;h3 id=&quot;1-接口和按钮的权限标识的区别&quot;&gt;1. 接口和按钮的权限标识的区别&lt;/h3&gt;
&lt;p&gt;上文说到的关于权限表的拆分，菜单单独一张表，按钮权限和接口权限合为一张表根据类型type字段区分，之所以这样因为接口和按钮权限有些共性，都有一个权限标识字段。&lt;/p&gt;
&lt;p&gt;至于按钮和接口为什么要区分呢？都使用&lt;code&gt;system:user:add&lt;/code&gt;权限标识不可以吗？&lt;/p&gt;
&lt;p&gt;具体做法是接口方法加上Spring Security的注解@PreAuthorize(&quot;hasPermission('system:user:add')&quot;),在执行方法前判断用户时候拥有该权限。&lt;/p&gt;
&lt;p&gt;答案是一般场景这样设计绝对没问题。但这里使用网关作为统一鉴权的入口，肯定希望网关一次性把鉴权的活做的干脆利落，这样就不需要在各个微服务单独的把Spring Security权限模块引入鉴权，通过网关鉴权能把职责分工明确，减少开发工作量，无权限的请求直接被网关拦截返回，不会走到微服务那里再被告知无权访问，提高请求效率。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway网关使用请求路径Ant匹配请求标识进行权限判断的，例如&lt;code&gt;/users/1&lt;/code&gt;经过Ant匹配到权限标识&lt;code&gt;/users/**&lt;/code&gt;,而&lt;code&gt;/users/**&lt;/code&gt;是被用户所持有的权限标识，这就标识用户允许访问&lt;code&gt;/users/1&lt;/code&gt;的请求，所以和按钮的权限标识&lt;code&gt;system:user:add&lt;/code&gt;是有区别的。&lt;/p&gt;
&lt;p&gt;这样就完事了吗？当然还没，因为 &lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来系统&lt;/a&gt; 较于其他系统它是比较严格遵守&lt;code&gt;REST&lt;/code&gt;接口设计规范，所以如果仅仅是上面根据请求路径URL判断权限肯定是不合理的，&lt;code&gt;/users/1&lt;/code&gt;这个请求路径在RESTful接口下可能是&lt;code&gt;GET&lt;/code&gt;类型的请求也有可能是&lt;code&gt;PUT&lt;/code&gt;类型的请求,那该如何处理？&lt;/p&gt;
&lt;p&gt;所以在sys_permission表里还有一个method字段来标识请求方法类型,值可能会是&lt;em&gt;、GET、POST、PUT、PATCH、DELETE等HTTP请求方法类型，其中&lt;/em&gt;是不限请求方法类型的意思，然后将请求方法类型和请求路径组合得到接口的权限标识是这样的&lt;code&gt;PUT_users/1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来就通过对 &lt;a href=&quot;https://github.com/hxrui&quot; target=&quot;_blank&quot;&gt;有来系统&lt;/a&gt; 的实战操作来演示网关如何细粒度对RESTful接口的权限控制。&lt;/p&gt;
&lt;h3 id=&quot;2-添加权限&quot;&gt;2. 添加权限&lt;/h3&gt;
&lt;p&gt;新增用户管理的增删改查权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210103406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-角色授权&quot;&gt;3. 角色授权&lt;/h3&gt;
&lt;p&gt;赋予系统管理员(admin)&lt;code&gt;用户查询&lt;/code&gt;权限，无其他权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210124030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210124911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-加载角色权限规则数据至缓存&quot;&gt;4. 加载角色权限规则数据至缓存&lt;/h3&gt;
&lt;p&gt;项目启动查看Redis中的角色权限规则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210131406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到系统管理员这个角色是没有用户修改权限的。你可以给角色添加用户修改权限后尝试是否可以修改成功。&lt;/p&gt;
&lt;h3 id=&quot;5-接口权限控制演示&quot;&gt;5. 接口权限控制演示&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;admin&lt;/code&gt;系统管理员登录执行一个&lt;code&gt;用户修改&lt;/code&gt;的提交的请求，看一下网关鉴权的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210132454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果可想而知，系统管理员不具有修改用户&lt;code&gt;PUT_/youlai-admin/v1/users/2&lt;/code&gt;权限，从缓存查询只有超级管理员具有该接口请求方法访问权限。页面结果显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210132841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六-按钮权限控制&quot;&gt;六. 按钮权限控制&lt;/h2&gt;
&lt;h3 id=&quot;1-什么是vue自定义指令？&quot;&gt;1. 什么是Vue自定义指令？&lt;/h3&gt;
&lt;p&gt;Vue除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。&lt;/p&gt;
&lt;p&gt;这里主要使用&lt;code&gt;Vue.directive&lt;/code&gt;注册一个全局自定义指令&lt;code&gt;v-has- permission&lt;/code&gt;用于权限判断,然后在模板中的任何元素使用&lt;code&gt;v-has- permission&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/custom-directive.html&quot; target=&quot;_blank&quot;&gt;自定义指令学习传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-添加按钮权限&quot;&gt;2. 添加按钮权限&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210174833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-角色授权-1&quot;&gt;3. 角色授权&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210175343.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-加载角色按钮权限数据&quot;&gt;4. 加载角色按钮权限数据&lt;/h3&gt;
&lt;p&gt;完整代码：&lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin&quot; target=&quot;_blank&quot;&gt;youlai-mall-admin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录成功时获取用户信息，其中包含该用户拥有的权限字符串集合如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210184613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里将用户权限拥有的字符串集合缓存到vuex的perms属性中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210210607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-自定义和注册全局指令&quot;&gt;5. 自定义和注册全局指令&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin&quot; target=&quot;_blank&quot;&gt;有来管理前端&lt;/a&gt; 是基于&lt;code&gt;vue-element-admin&lt;/code&gt;后台前端解决方案，在&lt;code&gt;vue-element-admin&lt;/code&gt;项目我们可以看到自定义指令的应用。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210200834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后复制一份&lt;code&gt;permission.js&lt;/code&gt;重命名为&lt;code&gt;hasPermission.js&lt;/code&gt;,修改后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import store from '@/store'

// 校验用户是否拥有按钮权限

function hasPermission(el, binding) {
  const {value} = binding
  const perms = store.getters &amp;amp;&amp;amp; store.getters.perms
  if (value &amp;amp;&amp;amp; value instanceof Array) {
    if (value.length &amp;gt; 0) {
      const requiredPerms = value
      const hasPermission = perms.some(perm =&amp;gt; {
        return requiredPerms.includes(perm)
      })
      if (!hasPermission) {
        el.parentNode &amp;amp;&amp;amp; el.parentNode.removeChild(el)
      }
    }
  } else {
    throw new Error(`need perms! Like v-has-permission=&quot;['system:user:add','system:user:edit']&quot;`)
  }
}

export default {
  inserted(el, binding) {
    hasPermission(el,binding)
  },
  update(el, binding) {
    hasPermission(el,binding)
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册&lt;code&gt;hasPermission&lt;/code&gt;至全局指令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210204858.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210205054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;指令在组件上的应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210205246.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-按钮权限控制演示&quot;&gt;6. 按钮权限控制演示&lt;/h3&gt;
&lt;p&gt;系统管理员是没有&lt;code&gt;修改&lt;/code&gt;按钮的权限的，结果如下页面不显示修改按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210205546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那给系统管理员添加&lt;code&gt;修改&lt;/code&gt;按钮的权限，再看看用户页面的显示情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210205829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/haoxr/image/raw/master/default/20210210210002.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时用户页面的修改按钮已经显示出来了，至此完成了系统的按钮权限控制。&lt;/p&gt;
&lt;h2 id=&quot;七-结语&quot;&gt;七. 结语&lt;/h2&gt;
&lt;p&gt;本篇通过实战的方式讲述如何基于Spring Cloud Gateway + vue-element-admin技术设计一套符合RBAC规范的权限管理系统，通过网关就可以轻易实现RESTful接口方法细粒度的控制，无需将Spring Security模块引入各个微服务；以及使用Vue的自定义指令在组件中使用实现细粒度的按钮权限控制。&lt;/p&gt;
&lt;p&gt;如果你对此系统权限设计有更好的建议，欢迎留言给我，在此感谢！如果对项目感兴趣的话，欢迎加我微信和项目交流群。&lt;/p&gt;
&lt;p&gt;最后预祝大家新年愉快，有个完美充实的小假期。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 10 Feb 2021 15:19:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>一. 前言 hi，大家好，这应该是农历年前的关于开源项目有来商城 的最后一篇文章了。 有来商城 是基于 Spring Cloud OAuth2 + Spring Cloud Gateway + JWT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/14396990.html</dc:identifier>
</item>
<item>
<title>解析树状数组 - HinanawiTenshi</title>
<link>http://www.cnblogs.com/Tenshi/p/14396938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tenshi/p/14396938.html</guid>
<description>&lt;p&gt;已知一个数列，你需要进行下面两种操作：&lt;/p&gt;
&lt;p&gt;如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;如果直接使用数组来做，那么修改操作复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; ,查询复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt;.&lt;br/&gt;而如果使用前缀和数组来做，那么修改操作复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt; ,查询复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;上面两种方法的总复杂度都是 &lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么有没有更快的方法呢？有，树状数组便是一种解决方法，它的复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(logN)\)&lt;/span&gt; （在后面我们会说明为什么）&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;树状数组，是基于二进制的数位的特性的数据结构。所谓的特性指的是什么呢？简单地说就是可以逐位拆解出 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ,直到整个串被如此表示。&lt;/p&gt;
&lt;p&gt;举个例子：给出一个二进制串 &lt;span class=&quot;math inline&quot;&gt;\(100101\)&lt;/span&gt; ，它可以被分解为 &lt;span class=&quot;math inline&quot;&gt;\(100000+100+1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;这样便为求前缀和提供了一条道路：按照拆出来的数分块求前缀和。&lt;/p&gt;
&lt;p&gt;比如说要求数组前 &lt;span class=&quot;math inline&quot;&gt;\(12\)&lt;/span&gt; 个元素的和，利用 &lt;span class=&quot;math inline&quot;&gt;\(12_{(10)}=1100_{(2)}=1000_{(2)}+100_{(2)}=8_{(10)}+4_{(10)}\)&lt;/span&gt; 。&lt;br/&gt;先求出后 &lt;span class=&quot;math inline&quot;&gt;\(4\)&lt;/span&gt; 个元素的和（即 &lt;span class=&quot;math inline&quot;&gt;\(9-12\)&lt;/span&gt; ），再求出除了这 &lt;span class=&quot;math inline&quot;&gt;\(4\)&lt;/span&gt; 个元素之外后 &lt;span class=&quot;math inline&quot;&gt;\(8\)&lt;/span&gt; 个元素的和（即 &lt;span class=&quot;math inline&quot;&gt;\(1-8\)&lt;/span&gt; ）再把它们加起来即可。&lt;/p&gt;
&lt;p&gt;这样我们便解决了求前缀和（&lt;strong&gt;查询&lt;/strong&gt;）操作。&lt;/p&gt;
&lt;p&gt;讲到这里，我想引入这张图片帮助理解：（我们记 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 所对应的区间为 &lt;code&gt;c[x]&lt;/code&gt;）这张图完美地解释了 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 能够维护 &lt;span class=&quot;math inline&quot;&gt;\(lowbit(x)\)&lt;/span&gt; 个元素 （ &lt;span class=&quot;math inline&quot;&gt;\(lowbit(x)\)&lt;/span&gt; 指 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 在二进制下最后一个 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 以及它后面所有的 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 构成的二进制串所对应的数，比如说 &lt;span class=&quot;math inline&quot;&gt;\(lowbit(6)=lowbit(110_{(2)})=10_{(2)}=2\)&lt;/span&gt; ）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2185228/202102/2185228-20210210224717333-495868521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来讲讲&lt;strong&gt;更新&lt;/strong&gt;操作：&lt;/p&gt;
&lt;p&gt;核心问题便是：一个数改变了，需要改变什么相关的区间？&lt;br/&gt;答案是：改变&lt;strong&gt;维护的区间包括这个数&lt;/strong&gt;的区间，还是举例来说，如果 &lt;code&gt;a[9]&lt;/code&gt; 改变了，由上图可以看出，&lt;code&gt;c[9]&lt;/code&gt;,&lt;code&gt;c[10]&lt;/code&gt;,&lt;code&gt;c[12]&lt;/code&gt;（ &lt;span class=&quot;math inline&quot;&gt;\(12\)&lt;/span&gt; 之后的不考虑 ）均要改变。事实上，&lt;code&gt;c[x]&lt;/code&gt;上面的区间是&lt;code&gt;c[x+lowbit(x)]&lt;/code&gt; （比如 &lt;span class=&quot;math inline&quot;&gt;\(9_{(10)}=1001_{(2)}\)&lt;/span&gt; 于是 &lt;span class=&quot;math inline&quot;&gt;\(9\)&lt;/span&gt; 上面一层区间便是&lt;span class=&quot;math inline&quot;&gt;\(1001_{(2)}+lowbit(1001_{(2)})=1010_{(2)}=10_{(10)})\)&lt;/span&gt; 依次类推）。&lt;/p&gt;
&lt;p&gt;这样我们便知道如何&lt;strong&gt;更新&lt;/strong&gt;了。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//修改 p指的是当前位置，k指的是加上k（如果tree[p]=k则是修改为k）
void modify(int p,int k){
    for(;p&amp;lt;=n;p+=lowbit(p)) tree[p]+=k;
}

//查询
int query(int p){
    int res=0;
    for(;p;p-=lowbit(p)) res+=tree[p];
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h3&gt;
&lt;p&gt;结合代码，复杂度分析可以更便于理解：&lt;br/&gt;以&lt;strong&gt;查询&lt;/strong&gt;为例，复杂度无疑取决于那个&lt;code&gt;for&lt;/code&gt;循环会执行多少次。根据&lt;code&gt;lowbit&lt;/code&gt;的定义，&lt;br/&gt;即使&lt;code&gt;p&lt;/code&gt;所对应的&lt;code&gt;二进制串&lt;/code&gt;都是 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;,也不过是循环 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数次。&lt;br/&gt;具体地说，&lt;span class=&quot;math inline&quot;&gt;\(N=111...111_{(2)}\)&lt;/span&gt;（有 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 个 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; ），而 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 可以近似看成是 &lt;span class=&quot;math inline&quot;&gt;\(2^x\)&lt;/span&gt; ,故循环的次数为 &lt;span class=&quot;math inline&quot;&gt;\(x=logN\)&lt;/span&gt;,&lt;br/&gt;故对应的复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(logN)\)&lt;/span&gt; 。&lt;br/&gt;类似的，&lt;strong&gt;修改&lt;/strong&gt;的操作亦然。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Feb 2021 14:59:00 +0000</pubDate>
<dc:creator>HinanawiTenshi</dc:creator>
<og:description>引入 已知一个数列，你需要进行下面两种操作： 将某一个数加上 xx （修改） 求出某区间每一个数的和 （查询） 如何解决这个问题呢？ 如果直接使用数组来做，那么修改操作复杂度是 \(O(1)\) ,查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tenshi/p/14396938.html</dc:identifier>
</item>
<item>
<title>Java类加载机制 - 霍丙南</title>
<link>http://www.cnblogs.com/Huobn/p/14396901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Huobn/p/14396901.html</guid>
<description>&lt;h3 id=&quot;java类加载机制&quot;&gt;java类加载机制&lt;/h3&gt;
&lt;p&gt;类是java编程语言的基本单元。java的源代码经过编译后生成java的字节码文件（class文件），字节码文件是以二进制的形式存储。在运行时，这些类的字节码文件会加载进入JVM的内存的&lt;strong&gt;元空间&lt;/strong&gt;中，并且以&lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt;的形式对类进行描述。本文将详细讲解java的类加载机制。&lt;/p&gt;
&lt;h3 id=&quot;类加载流程&quot;&gt;类加载流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2217004/202102/2217004-20210210224646459-888955726.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;加载：通过&lt;code&gt;classloader&lt;/code&gt;将字节码文件以二进制字节流的形式读入到内存中，将字节流转换为方法区运行时的数据结构，在内存中生成一个&lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt;对象对类进行描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;链接：&lt;strong&gt;验证阶段&lt;/strong&gt;检查字节码文件是否符合JVM规范，&lt;strong&gt;准备阶段&lt;/strong&gt;为类中的静态字段分配内存并赋予初始值，解析阶段将虚拟机中常量池中的符号引用转化为直接引用。&lt;strong&gt;符号引用&lt;/strong&gt;存在于编译生成的字节码中，用来描述当前类对其他类的引用。&lt;strong&gt;直接引用&lt;/strong&gt;是可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。&lt;strong&gt;解析阶段&lt;/strong&gt;也可以在运行过程中发生，这个跟动态语言调用相关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2217004/202102/2217004-20210210224701765-651946254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化：初始化是类加载的最后一步，前面的类加载的过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的&lt;strong&gt;java程序代码&lt;/strong&gt;。它主要是负责：初始化阶段是执行类构造器（静态代码块）&lt;code&gt;&amp;lt; clinit &amp;gt;()&lt;/code&gt;方法的过程， &lt;code&gt;&amp;lt; clinit &amp;gt;()&lt;/code&gt;是编译器自动收集类中所有的类变量的赋值动作、静态代码块产生的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;classloader&quot;&gt;ClassLoader&lt;/h3&gt;
&lt;p&gt;ClassLoader顾名思义是类的加载器，类的加载要通过ClassLoader进行，ClassLoader的职责是将字节码文件从磁盘或者网络中加载进JVM内存。同时你也可以在java代码中操作ClassLoader定义一些自定义的行为。&lt;code&gt;ClassLoader&lt;/code&gt;是一个抽象基类，你可以继承它重写自己自定义的加载流程。一般我们的java类会通过几个常见的类加载器加载，它们分为&lt;code&gt;BootstrapClassLoader&lt;/code&gt;，&lt;code&gt;ExtensionClassLoader&lt;/code&gt;，&lt;code&gt;ApplicaitonClassLoader&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BootstrapClassLoader&lt;/code&gt;主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib&lt;/code&gt;路径下的核心类库或&lt;code&gt;-Xbootclasspath&lt;/code&gt;参数指定的路径下的jar包加载到内存中，注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为&lt;strong&gt;java&lt;/strong&gt;、&lt;strong&gt;javax&lt;/strong&gt;、&lt;strong&gt;sun&lt;/strong&gt;等开头的类)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExtensionClassLoader&lt;/code&gt;是指Sun公司(已被Oracle收购)实&lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt;类，由Java语言实现的，是Launcher的静态内部类，它负责加载&lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;/lib/ext&lt;/code&gt;目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationClassLoader&lt;/code&gt;也称应用程序加载器是指 Sun公司实现的&lt;code&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt;。它负责加载系统类路径&lt;code&gt;java -classpath&lt;/code&gt;或&lt;code&gt;-D java.class.path&lt;/code&gt; 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中&lt;strong&gt;默认的类加载器&lt;/strong&gt;，通过&lt;code&gt;ClassLoader#getSystemClassLoader()&lt;/code&gt;方法可以获取到该类加载器。&lt;/p&gt;
&lt;h3 id=&quot;双亲委派机制&quot;&gt;双亲委派机制&lt;/h3&gt;
&lt;p&gt;双亲委派机制是指，当一个&lt;code&gt;ClassLoader&lt;/code&gt;尝试加载一个类时，它并不会自己加载，而是将加载任务向上委托给父加载器加载。每个&lt;code&gt;ClassLoader&lt;/code&gt;中都有一个&lt;code&gt;parent&lt;/code&gt;属性，用来保存父加载器的引用。注意：父加载器并不是父类加载器，它们之间没有类之间的继承关系。双亲委派机制的加载流程为：在类加载器缓存中查询，此类是否已经加载，若已加载，则直接由此加载器加载，若没有则向上委托给父加载器加载。若最上层父加载器也未加载，则向下委托给子加载器加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
{
  synchronized (getClassLoadingLock(name)) {
    // 首先检查类是否已经加载过
    Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
    if (c == null) {
      // 没有加载过，则委托父加载器加载
      long t0 = System.nanoTime();
      try {
        if (parent != null) {
          // 若有父加载器，则委托父加载加载
          c = parent.loadClass(name, false);
        } else {
          // 若没有父加载器（最上层父加载器也未加载此类），则委托BootStrap加载器加载
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // ClassNotFoundException thrown if class not found
        // from the non-null parent class loader
      }

      if (c == null) {
        // If still not found, then invoke findClass in order
        // to find the class.
        // 这种情况代表Bootstrap加载器也未加载此类，则委托给本加载器加载。
        long t1 = System.nanoTime();
        c = findClass(name);
        // this is the defining class loader; record the stats
        PerfCounter.getParentDelegationTime().addTime(t1 - t0);
        PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
        PerfCounter.getFindClasses().increment();
      }
    }
    if (resolve) {
      resolveClass(c);
    }
    return c;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2217004/202102/2217004-20210210224722031-1848251279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试双亲委派机制&quot;&gt;测试双亲委派机制&lt;/h3&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;新建一个测试用的类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package misc;

public class Model
{
    static
    {
        System.out.println(&quot;类被加载了&quot;);
    }

    public static void sayHello()
    {
        System.out.println(&quot;hello&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;自己定义一个类加载器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyClassLoader extends ClassLoader
{
    private final String classPath;

    public MyClassLoader(String classPath)
    {
        this.classPath = classPath;
    }

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException
    {
        // 如果使用MyClassLoader加载，那么这句话将会输出至控制台
        System.out.println(&quot;使用MyClassLoader加载&quot;);
        var classFilePath = classPath + &quot;/&quot; + name.replace(&quot;.&quot;,&quot;/&quot;).concat(&quot;.class&quot;);
        var bao = new ByteArrayOutputStream();
        var readByte = 1;
        try
        {
            var fis = new FileInputStream(classFilePath);
            while ((readByte = fis.read()) != -1)
            {
                bao.write(readByte);
            }
            var bytesArray = bao.toByteArray();
            return defineClass(name, bytesArray, 0, bytesArray.length);
        } catch (IOException ex)
        {
            ex.printStackTrace();
            throw new ClassNotFoundException(ex.getMessage());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void loadClassViaMyClassLoader() throws Exception
{
    var classLoader = new MyClassLoader(&quot;/Users/huobingnan/code/java/misc/out/production/misc&quot;);
    var modelClass = classLoader.loadClass(&quot;misc.Model&quot;);
        System.out.println(&quot;Model的类加载器是：&quot; + modelClass.getClassLoader());
    var sayHelloMethod = modelClass.getDeclaredMethod(&quot;sayHello&quot;);
    sayHelloMethod.invoke(null);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;测试输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Model的类加载器是：jdk.internal.loader.ClassLoaders$AppClassLoader@7c53a9eb
类被加载了
hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出可以发现，Model类的加载并未使用我们自定义的&lt;code&gt;MyClassLoader&lt;/code&gt;，而是使用了JDK中的应用程序类加载器，这就是双亲委派机制的体现，你也可以对上述代码进行DEBUG运行，从中便可得知类加载的途径是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyClassLoader -&amp;gt; AppClassLoader -&amp;gt; PlatformClassLoader -&amp;gt; BootstrapClassLoader -&amp;gt; PlatformClassLoader -&amp;gt; AppClassLoader&lt;/code&gt; 。注意：不同的JDK可能加载器的名称会有所不同，笔者这里使用的是zulu-jdk-arm64。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;打破双亲委派机制&quot;&gt;打破双亲委派机制&lt;/h3&gt;
&lt;p&gt;通过上文的测试用例可以得知，尽管我们自定义了ClassLoader，但是由于双亲委派机制的存在，字节码文件没有使用我们自定义的ClassLoader加载。那么如何强制字节码文件使特定ClassLoader加载呢？我们可以通过重写&lt;code&gt;CLassLoader.loadClass(String name, boolean resovle)&lt;/code&gt;方法进行。例如下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyClassLoader extends ClassLoader
{
    private final String classPath;

    public MyClassLoader(String classPath)
    {
        this.classPath = classPath;
    }

    @Override
    protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException
    {
        if (name.startsWith(&quot;misc&quot;))
        {
                // 如果包名以misc开头，我们使用MyClassLoader加载
            return findClass(name); 
        }
        return super.loadClass(name, resolve);
    }

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException
    {
        System.out.println(&quot;使用MyClassLoader加载&quot;);
        var classFilePath = classPath + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;).concat(&quot;.class&quot;);
        var bao = new ByteArrayOutputStream();
        var readByte = 1;
        try
        {
            var fis = new FileInputStream(classFilePath);
            while ((readByte = fis.read()) != -1)
            {
                bao.write(readByte);
            }
            var bytesArray = bao.toByteArray();
            return defineClass(name, bytesArray, 0, bytesArray.length);
        } catch (IOException ex)
        {
            ex.printStackTrace();
            throw new ClassNotFoundException(ex.getMessage());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改之后，再次使用上文中的测试代码进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;使用MyClassLoader加载
Model的类加载器是：misc.MyClassLoader@d041cf
类被加载了
hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到，通过重写&lt;code&gt;loadClass&lt;/code&gt;方法，我们可以自定义类加载行为，打破双亲委派机制。&lt;/p&gt;
&lt;h3 id=&quot;打破双亲委派机制带来的问题&quot;&gt;打破双亲委派机制带来的问题&lt;/h3&gt;
&lt;p&gt;虽然我们自定义了类加载，并且打破了双亲委派机制，使得我们可以自定义类加载器加载类的行为。但是打破双亲委派机制后会带一个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public static void testClassLoaderCastBehavior() throws Exception
 {
   var classLoader = new MyClassLoader(&quot;/Users/huobingnan/code/java/misc/lib&quot;);
   var modelClass = classLoader.loadClass(&quot;misc.Model&quot;);
   var object = modelClass.getConstructor().newInstance();
   var model = (Model)object;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;使用MyClassLoader加载
类被加载了
Exception in thread &quot;main&quot; java.lang.ClassCastException: class misc.Model cannot be cast to class misc.Model (misc.Model is in unnamed module of loader misc.MyClassLoader @d041cf; misc.Model is in unnamed module of loader 'app')
        at misc.ClassLoaderTest.testClassLoaderCastBehavior(ClassLoaderTest.java:19)
        at misc.ClassLoaderTest.main(ClassLoaderTest.java:85)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用自定义类加载器，在文件系统中加载了一个类，这个类与我们项目类路径中的&lt;code&gt;Model&lt;/code&gt;类定义完全一致，但是他们之间并不能进行强制类型转换。这也就是说，虽然我们可以加载这个类，但是在使用的时候只能通过反射的方式进行。我们知道通过反射对一个类进行操作会带来隐患，而且对于用户来说，这样的调用操作并不直观。&lt;/p&gt;
&lt;p&gt;同时，这种行为也限制了我们在项目中保留接口定义的情况下，无法通过类加载器的加载实现类并强制转换使用。&lt;/p&gt;
&lt;p&gt;如果想要通过接口的形式进行上述操作需要借助java的SPI机制。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;张善香. 解析Java虚拟机开发：权衡优化，高效和安全的最优方案[M]. 北京: 清华大学出版社: 2013.&lt;/li&gt;
&lt;li&gt;java类加载机制（全套）&lt;a href=&quot;https://juejin.cn/post/6844903564804882445&quot; target=&quot;_blank&quot;&gt;https://juejin.cn/post/6844903564804882445&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java SPI机制 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28909673&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/28909673&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Feb 2021 14:48:00 +0000</pubDate>
<dc:creator>霍丙南</dc:creator>
<og:description>java类加载机制 类是java编程语言的基本单元。java的源代码经过编译后生成java的字节码文件（class文件），字节码文件是以二进制的形式存储。在运行时，这些类的字节码文件会加载进入JVM的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Huobn/p/14396901.html</dc:identifier>
</item>
<item>
<title>Java并发包源码学习系列：线程池ThreadPoolExecutor源码解析 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14396783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14396783.html</guid>
<description>&lt;p&gt;系列传送门：&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutor概述&quot;&gt;ThreadPoolExecutor概述&lt;/h2&gt;
&lt;h3 id=&quot;线程池解决的优点&quot;&gt;线程池解决的优点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;当执行大量异步任务时线程池能够提供较好的性能，因为线程池中的线程是可复用的，不需要每次执行异步任务时都创建和销毁线程。&lt;/li&gt;
&lt;li&gt;提供资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等等。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;线程池处理流程&quot;&gt;线程池处理流程&lt;/h3&gt;
&lt;p&gt;ThreadPoolExecutor执行execute时，流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202102/1771072-20210210220418824-1220801733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务，这里需要加全局锁。&lt;/li&gt;
&lt;li&gt;如果运行的线程数&amp;gt;=corePoolSize，则将任务加入BlockingQueue。&lt;/li&gt;
&lt;li&gt;如果此时BlockingQueue已满，则创建新的线程来处理任务，这里也需要加全局锁。&lt;/li&gt;
&lt;li&gt;如果创建新线程将使当前运行的线程超出maximumPoolSize，则按照拒绝策略拒绝任务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然啦，这篇文章意在从源码角度学习线程池这些核心步骤的具体实现啦，线程池概念性的东西，可以参考一些其他的博客：&lt;/p&gt;
&lt;h3 id=&quot;创建线程池&quot;&gt;创建线程池&lt;/h3&gt;
&lt;p&gt;创建线程池有几种方法，一种是使用Executors工具类快速创建内置的几种线程池，也可以自定义。&lt;/p&gt;
&lt;p&gt;一、通过Executor框架的工具类Executors可以创建三种类型的ThreadPoolExecutor。&lt;/p&gt;
&lt;p&gt;二、使用ThreadPoolExecutor的各种构造方法。&lt;/p&gt;
&lt;p&gt;《阿里巴巴 Java 开发手册》中：&lt;strong&gt;强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式&lt;/strong&gt;，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Executors 返回线程池对象的弊端如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;FixedThreadPool 和 SingleThreadExecutor&lt;/strong&gt; ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CachedThreadPool 和 ScheduledThreadPool&lt;/strong&gt; ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;本篇的重点就是这个ThreadPoolExecutor。&lt;/p&gt;
&lt;h2 id=&quot;重要常量及字段&quot;&gt;重要常量及字段&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {
        // 原子的Integer变量ctl，用于记录线程池状态【高3位】和线程池中线程个数【低29位】，这里假设Integer是32位的
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 其实并不是每个平台的Integer二进制都是32位的，实际上是，二进制位-3代表线程个数
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 线程最大个数【约5亿】 低COUNT_BITS都是1  000 11111111111111111111111111111
    private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    // 111 00000000000000000000000000000 高3位是 111
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
    // 000 00000000000000000000000000000 高3位是 000
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
    // 001 00000000000000000000000000000 高3位是 001
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
    // 010 00000000000000000000000000000 高3位是 110
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
    // 011 00000000000000000000000000000 高3位是 011
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;
    
    // Packing and unpacking ctl
    // 获取高3位的运行状态
    private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
    // 获取低29位的线程个数
    private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
    // 通过RunState和WorkCount计算ctl的值
    private static int ctlOf(int rs, int wc) { return rs | wc; }
    
    // 线程池状态变换是单调递增的
    private static boolean runStateLessThan(int c, int s) {
        return c &amp;lt; s;
    }

    private static boolean runStateAtLeast(int c, int s) {
        return c &amp;gt;= s;
    }
        // 只有RUNNING 是小于SHUTDOWN的
    private static boolean isRunning(int c) {
        return c &amp;lt; SHUTDOWN;
    }
    
    // ...
    
    // 阻塞队列
    private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
    // 独占锁 同步保证
    private final ReentrantLock mainLock = new ReentrantLock();
    // 存放 线程池中的工作线程
    private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();
    // 条件队列，线程调用awaitTermination时存放阻塞的线程
    private final Condition termination = mainLock.newCondition();

        // ...
    
    // 继承AQS和Runnable，任务线程
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    { /*.. */}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ThreadPoolExecutor通过AtomicInteger类的变量ctl记录&lt;strong&gt;线程池状态&lt;/strong&gt;和&lt;strong&gt;线程池中线程个数&lt;/strong&gt;，这里以Integer为32为例。&lt;/li&gt;
&lt;li&gt;高3位表示线程池的状态，低29位表示线程个数，分别通过&lt;code&gt;runStateOf&lt;/code&gt;和&lt;code&gt;workerCountOf&lt;/code&gt;计算。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程池的五种状态及转换&quot;&gt;线程池的五种状态及转换&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程池的状态&lt;/strong&gt;有五种，他们提供了线程池声明周期的控制：
&lt;ul&gt;&lt;li&gt;RUNNING：能够接收新任务，并且处理阻塞队列里的任务。&lt;/li&gt;
&lt;li&gt;SHUTDOWN：拒绝新任务，但会处理阻塞队列里的任务。&lt;/li&gt;
&lt;li&gt;STOP：拒绝新任务，并且抛弃阻塞队列里的任务，同时会中断正在处理的任务。&lt;/li&gt;
&lt;li&gt;TIDYING：所有任务都执行完后当前线程池workerCount为0，将调用terminated()这个钩子方法。&lt;/li&gt;
&lt;li&gt;TERMINATED：终止状态。terminated方法调用完成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;线程池的状态是有规律的，保证单调递增，但是不一定每个状态都会经历，比如有以下几种转换：
&lt;ul&gt;&lt;li&gt;RUNNING -&amp;gt; SHUTDOWN：可能是显式调用了&lt;code&gt;shutdown()&lt;/code&gt;方法，也可能在&lt;code&gt;finalize()&lt;/code&gt;里隐式调用。&lt;/li&gt;
&lt;li&gt;RUNNING或SHUTDOWN -&amp;gt; STOP：调用了&lt;code&gt;shutdownNow()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;SHUTDOWN -&amp;gt; TIDYING：队列和线程池都为空的时候。&lt;/li&gt;
&lt;li&gt;STOP -&amp;gt; TIDYING：线程池为空的时候。&lt;/li&gt;
&lt;li&gt;TIDYING -&amp;gt; TERMINATED：钩子方法&lt;code&gt;terminated()&lt;/code&gt;调用完成的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于awaitTermination()方法而阻塞在条件队列中的线程将会在线程池TERMINATED的时候返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202102/1771072-20210210220428421-1442941314.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutor构造参数及参数意义&quot;&gt;ThreadPoolExecutor构造参数及参数意义&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor方法的构造参数有很多，我们看看最长的那个就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize &amp;lt; 0 ||
            maximumPoolSize &amp;lt;= 0 ||
            maximumPoolSize &amp;lt; corePoolSize ||
            keepAliveTime &amp;lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt;：核心线程数定义了&lt;strong&gt;最小可以同时运行的线程数量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;：&lt;strong&gt;当队列中存放的任务达到队列容量的时候&lt;/strong&gt;，当前可以同时运行的线程数量变为&lt;strong&gt;最大线程数&lt;/strong&gt;。【如果使用的无界队列，这个参数就没啥效果】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt;: 阻塞队列，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，&lt;strong&gt;如果达到核心线程数的话，新任务就会被存放在队列中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;:当线程池中的线程数量大于 &lt;code&gt;corePoolSize&lt;/code&gt; 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 &lt;code&gt;keepAliveTime&lt;/code&gt;才会被回收销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unit&lt;/code&gt;：&lt;code&gt;keepAliveTime&lt;/code&gt; 的时间单位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threadFactory&lt;/code&gt;：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，默认使用Executors的静态内部类&lt;code&gt;DefaultThreadFactory&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt;：饱和策略，当前同时运行的线程数量达到最大线程数量【&lt;code&gt;maximumPoolSize&lt;/code&gt;】并且队列也已经被放满时，执行饱和策略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于各个参数的意义，强烈推荐这篇博客：&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/14368520.html&quot; target=&quot;_blank&quot;&gt;闪客sun : 图解 | 原来这就是线程池&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;work类&quot;&gt;Work类&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        private static final long serialVersionUID = 6138294804551838833L;

        /** 具体执行任务的线程 */
        final Thread thread;
        /** 执行的第一个任务 */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** 线程启动时，执行runWorker方法 */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }
                // 不可重入的，state = 1表示已获取
        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
                // state = 0 表示锁未被获取
        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        // 如果线程启动，则中断线程 state只有初始化的时候才是-1，其他的时间都是满足&amp;gt;=0的
        void interruptIfStarted() {
            Thread t;
            if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Worker继承了AQS和Runnable接口，是具体承载任务的对象。&lt;/p&gt;
&lt;p&gt;基于AQS，Worker实现了不可重入的独占锁，state == 0 表示锁未被获取，state == 1表示锁已经被获取， state == -1为初始状态。&lt;/p&gt;
&lt;p&gt;firstTask记录该工作线程执行的第一个任务，thread是执行任务的线程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interruptIfStarted()&lt;/code&gt;方法会在shutdownNow中调用，意在中断Worker线程，state初始化为-1，是不满足getState条件的。&lt;/p&gt;
&lt;h2 id=&quot;void-executerunnable-command&quot;&gt;void execute(Runnable command)&lt;/h2&gt;
&lt;p&gt;execute方法就是向线程池提交一个command任务进行执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void execute(Runnable command) {
        // 提交任务为null， 抛出空指针异常
        if (command == null)
            throw new NullPointerException();
                // 获取当前ctl的值 ： 线程池状态 + 线程个数
        int c = ctl.get();
        // 如果当前线程池中线程个数小于核心线程数corePoolSize
        if (workerCountOf(c) &amp;lt; corePoolSize) {
            // 通过addWorker新建一个线程，然后，启动该线程从而执行任务
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 如果线程池处于RUNNING状态，则添加任务到阻塞队列
        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
            // double-check
            int recheck = ctl.get();
            // 如果线程池不是处于RUNNING， 则从队列中移除任务
            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
                // 并执行拒绝策略
                reject(command);
            // 如果当前线程个数为0， 则添加一个线程
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 如果队列满，则新增线程，新增失败则执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果线程池当前线程数小于corePoolSize，则调用addWorker创建新线程执行任务，成功则直接返回。&lt;/li&gt;
&lt;li&gt;如果线程池处于RUNNING状态，则添加任务到阻塞队列，如果添加成功，进行double-check，检测出当前不是RUNNING，则进行移除操作，并执行拒绝策略。否则添加一个线程，确保有线程可以执行。&lt;/li&gt;
&lt;li&gt;如果线程池不是处于RUNNING或加入阻塞队列失败，并采取拒绝策略。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;boolean-addworkerfirsttask-core&quot;&gt;boolean addWorker(firstTask, core)&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 检测队列是否只在必要时为空
            
            // 等价为：下面几种情况返回false
            /* if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;     rs 为STOP TIDYING TERMINATED时返回false
                 (rs != SHUTDOWN ||      rs不为SHUTDOWN
                   firstTask != null ||  rs为SHUTDOWN 但 已经有了第一个任务
                   workQueue.isEmpty())) rs为SHUTDOWN 并且任务队列为空
                   */
    
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;  // 
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;  // 
                   firstTask == null &amp;amp;&amp;amp;
                   ! workQueue.isEmpty()))
                return false;
                        // 循环， 通过CAS操作来增加线程个数
            for (;;) {
                int wc = workerCountOf(c);
                // 线程个数如果超过限制，返回false
                if (wc &amp;gt;= CAPACITY ||
                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // CAS增加线程个数，操作成功跳出循环break
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                // CAS失败，检测线程状态是否发生了变化，如果发生变化，则跳到retry外层循环重新尝试
                // 否则在内层循环重新CAS
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
                // 走到这代表CAS操作已经成功
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            // 创建worker
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                // 独占锁保证同步
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // 重新检查线程池状态，以避免在获取锁前调用了shutdown接口
                    int rs = runStateOf(ctl.get());
                                        // 1. 线程池处于RUNNING
                    // 2. 线程池处于SHUTDOWN 并且firstTask为null
                    if (rs &amp;lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                        // 如果t已经启动
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // 添加任务
                        workers.add(w);
                        int s = workers.size();
                        if (s &amp;gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                // 添加任务成功后， 执行任务
                if (workerAdded) {
                    t.start(); // 执行
                    workerStarted = true;
                }
            }
        } finally {
            // 任务未执行成功
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;双重循环通过CAS操作增加线程数。&lt;/li&gt;
&lt;li&gt;使用全局的独占锁来控制：将并发安全的任务添加到works里，并启动。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;final-void-runworkerworker-w&quot;&gt;final void runWorker(Worker w)&lt;/h2&gt;
&lt;p&gt;用户线程提交任务到线程池后，由Worker执行，通过while循环不断地从工作队列里获取任务执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        // Worker启动执行runWorker
        public void run() {
            runWorker(this);
        }
        
    }

        final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // state设置为0， 允许中断
        boolean completedAbruptly = true;
        try {
            // 如果task不为null 或者 task为null 但是 getTask从任务队列获取的任务不为null
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                // 如果线程池当前STOP，则确保线程是中断状态
                // 如果不是STOP，确保线程没有被中断
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;amp;&amp;amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    // 任务执行之前的hook方法
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run(); // 执行任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        // 任务执行之后的hook方法
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    // 统计当前的Worker完成的任务数量
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            // 清理工作
            processWorkerExit(w, completedAbruptly);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;runnable-gettask&quot;&gt;Runnable getTask()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?
                // 循环
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 1. 线程池状态 &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; 工作队列为空
            // 2. 线程池状态 &amp;gt;= STOP
            // 两种情况，都直接数量 -1 ， 返回null
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }
                        // 工作线程的数量
            int wc = workerCountOf(c);

            // 需否需要超时控制
            boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

            //1. 工作线程的数量超过了maximumPoolSize 或者 需要超时控制，且poll出为null，就是没拿到
            //2. 工作线程数量 &amp;gt; 1 或者 工作队列为空
            // 两者都满足， 则数量 -1 ， 返回null
            if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
                &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                // 从工作队列里取出任务
                Runnable r = timed ?
                    // keepAliveTime时间内还没有获取到任务， 继续循环
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;void-processworkerexitw-completedabruptly&quot;&gt;void processWorkerExit(w, completedAbruptly)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        // completedAbruptly 为true表示用户线程运行异常，需要wc - 1
        // 否则是不需要处理的，在getTask中已经处理过了
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        // 统计线程池完成的任务个数， 从workers中移除当前worker
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }
                //如果当前线程池状态为SHUTDOWN且工作队列为空，
        //或者STOP状态但线程池里没有活动线程，则设置线程池状态为TERMINATED。
        tryTerminate();

        int c = ctl.get();
        // 如果线程池为 RUNNING 或SHUTDOWN 表示，tryTerminate()没有成功
        // 判断是否需要新增一个线程，如果workerCountOf(c) &amp;lt; min 新增一个线程
        if (runStateLessThan(c, STOP)) {
            // 表示正常退出
            if (!completedAbruptly) {
                // min 默认是corePoolSize
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &amp;gt;= min)
                    return; // replacement not needed
            }
            // 如果workerCountOf(c) &amp;lt; min 新增一个线程
            addWorker(null, false);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;void-shutdown&quot;&gt;void shutdown()&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SHUTDOWN : 拒绝新任务但是处理阻塞队列里的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用该方法之后，线程池不再接收新任务，但是工作队列里的任务还需要处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 检查权限，判断当前调用shutdown的线程是否拥有关闭线程的权限
            checkShutdownAccess();
            // 设置线程池状态为SHUTDOWN
            advanceRunState(SHUTDOWN);
            // 设置中断标志
            interruptIdleWorkers();
            // 钩子方法
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        // 尝试设置线程池状态为TERMINATED
        tryTerminate();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;void-advancerunstateint-targetstate&quot;&gt;void advanceRunState(int targetState)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       // 设置线程池状态为SHUTDOWN
    private void advanceRunState(int targetState) {
        for (;;) {
            int c = ctl.get();
            // 当前的状态已经是SHUTDOWN了就直接break返回，如果不是就CAS设置一下
            if (runStateAtLeast(c, targetState) ||
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;void-interruptidleworkers&quot;&gt;void interruptIdleWorkers()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       
    private void interruptIdleWorkers() {
        interruptIdleWorkers(false);
    }

        // onlyOne如果不传，默认为false
    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 遍历所有的Worker
            for (Worker w : workers) {
                Thread t = w.thread;
                // 如果工作线程没有被中断 且 获取Worker的锁成功，则设置中断标志
                // 这里：获取锁成功代表，设置的是没有在执行任务的线程，因为
                // 正在执行任务的线程是已经获取了锁的，你tryLock不会成功的
                if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                // 只用设置一个
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;final-void-tryterminate&quot;&gt;final void tryTerminate()&lt;/h3&gt;
&lt;p&gt;如果当前线程池状态为SHUTDOWN且工作队列为空，或者STOP状态但线程池里没有活动线程，则设置线程池状态为TERMINATED。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final void tryTerminate() {
        // 循环
        for (;;) {
            int c = ctl.get();
            // 如果RUNNING  TIDYING TERMINATED 
            // 如果SHUTDOWN 且任务队列不为空，还需要处理queue里的任务
            // 就不需要下面的操作了， 直接返回好了
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty()))
                return;
            
            // STOP 但 线程池里还有活动线程
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // CAS设置rs为TIDYING，且wc为0
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        // 钩子方法
                        terminated();
                    } finally {
                        // terminated() 完成之后， 就设置为TERMINATED
                        ctl.set(ctlOf(TERMINATED, 0));
                        // 激活所有因为await等待的线程
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;listrunnable-shutdownnow&quot;&gt;List(Runnable) shutdownNow()&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;STOP：拒绝新任务并且抛弃任务队列里的任务，同时会中断正在处理的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用该方法后，将线程池状态设置为STOP，拒绝新任务并且抛弃任务队列里的任务，同时会中断正在处理的任务，返回队列里被丢弃的任务列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public List&amp;lt;Runnable&amp;gt; shutdownNow() {
        List&amp;lt;Runnable&amp;gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 检查权限
            checkShutdownAccess();
            // 设置为STOP
            advanceRunState(STOP);
            // 设置中断标志
            interruptWorkers();
            // 将队列任务移到tasks中
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;void-interruptworkers&quot;&gt;void interruptWorkers()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void interruptWorkers() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers)
                // 如果线程启动，则中断线程【正在执行 + 空闲的所有线程都会被中断】
                w.interruptIfStarted();
        } finally {
            mainLock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;boolean-awaitterminationtimeout-unit&quot;&gt;boolean awaitTermination(timeout, unit)&lt;/h2&gt;
&lt;p&gt;当该方法被调用时，当前线程会被阻塞，直到超时时间到了，返回false。或者线程池状态为TERMINATED时，返回true。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (;;) {
                // 线程池状态为TERMINATED 返回true
                if (runStateAtLeast(ctl.get(), TERMINATED))
                    return true;
                // 超时了， 返回false
                if (nanos &amp;lt;= 0)
                    return false;
                nanos = termination.awaitNanos(nanos);
            }
        } finally {
            mainLock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Wed, 10 Feb 2021 14:05:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>系列传送门： Java并发包源码学习系列：AbstractQueuedSynchronizer Java并发包源码学习系列：CLH同步队列及同步资源获取与释放 Java并发包源码学习系列：AQS共享式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14396783.html</dc:identifier>
</item>
</channel>
</rss>