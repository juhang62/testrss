<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>pytorch实现MLP并在MNIST数据集上验证 - 王金翼</title>
<link>http://www.cnblogs.com/fyunaru/p/12791790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fyunaru/p/12791790.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;由于MLP的实现框架已经非常完善，网上搜到的代码大都大同小异，而且MLP的实现是deeplearning学习过程中较为基础的一个实验。因此完全可以找一份源码以参考，重点在于照着源码手敲一遍，以熟悉pytorch的基本操作。&lt;/p&gt;
&lt;h2 id=&quot;实验要求&quot;&gt;实验要求&lt;/h2&gt;
&lt;p&gt;熟悉pytorch的基本操作：用pytorch实现MLP，并在MNIST数据集上进行训练&lt;/p&gt;
&lt;h2 id=&quot;环境配置&quot;&gt;环境配置&lt;/h2&gt;
&lt;p&gt;实验环境如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Win10&lt;/li&gt;
&lt;li&gt;python3.8&lt;/li&gt;
&lt;li&gt;Anaconda3&lt;/li&gt;
&lt;li&gt;Cuda10.2 + cudnn v7&lt;/li&gt;
&lt;li&gt;GPU : NVIDIA GeForce MX250&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置环境的过程中遇到了一些问题，解决方案如下：&lt;/p&gt;
&lt;ol readability=&quot;1.8088495575221&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;anaconda下载过慢&lt;/p&gt;
&lt;p&gt;使用清华镜像源，直接百度搜索即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.4545454545455&quot;&gt;
&lt;p&gt;pytorch安装失败&lt;/p&gt;
&lt;p&gt;这里我首先使用的是pip的安装方法，失败多次后尝试了使用anaconda，然后配置了清华镜像源，最后成功。参考的教程如下：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34068584/article/details/90112484?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&amp;amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&quot;&gt;win10快速安装pytorch，清华镜像源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然也可以直接去pytorch官网下载所需版本的whl文件，然后手动pip安装。由于这种方式我已经学会了，为了学习anaconda，所以没有采用这种方式。具体方式可以百度如何使用whl。顺便贴下pytorch的whl的&lt;a href=&quot;https://download.pytorch.org/whl/torch_stable.html&quot;&gt;下载页面&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：pytorch的版本是要严格对应是否使用GPU、python版本、cuda版本的，如需手动下载pytorch的安装包，需搞懂其whl文件的命名格式&lt;/p&gt;
&lt;p&gt;另外还学习了anaconda的一些基本操作与原理，参考如下：&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/eaee1fadc1e9&quot;&gt;Anaconda完全入门指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验过程&quot;&gt;实验过程&lt;/h2&gt;
&lt;p&gt;最终代码见github：&lt;a href=&quot;https://github.com/FyuNaru/HIT-deep-learning/tree/master/HIT-deep-learning-1&quot;&gt;hit-deeplearning-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先设置一些全局变量，加载数据。batch_size决定了每次向网络中输入的样本数，epoch决定了整个数据集的迭代次数，具体作用与大小如何调整可参考附录中的博客。&lt;/p&gt;
&lt;p&gt;将数据读入，如果数据不存在于本地，则可以自动从网上下载，并保存在本地的data文件夹下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#一次取出的训练样本数
batch_size = 16
# epoch 的数目
n_epochs = 10

#读取数据
train_data = datasets.MNIST(root=&quot;./data&quot;, train=True, download=True,transform=transforms.ToTensor())
test_data = datasets.MNIST(root=&quot;./data&quot;, train=False, download=True, transform=transforms.ToTensor())
#创建数据加载器
train_loader = torch.utils.data.DataLoader(train_data, batch_size = batch_size, num_workers = 0)
test_loader = torch.utils.data.DataLoader(test_data, batch_size = batch_size, num_workers = 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是创建MLP模型，关于如何创建一个模型，可以参考附录中的博客，总之创建模型模板，训练模板都是固定的。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;Linear&lt;/code&gt;、&lt;code&gt;view&lt;/code&gt;、&lt;code&gt;CrossEntropyLoss&lt;/code&gt;、&lt;code&gt;SGD&lt;/code&gt;的用法需重点关注。查看官方文档或博客解决。&lt;/p&gt;
&lt;p&gt;这两条语句将数据放到了GPU上，同理测试的时候也要这样做。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = data.cuda()
target = target.cuda()
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class MLP(nn.Module):
    def __init__(self):
        #继承自父类
        super(MLP, self).__init__()
        #创建一个三层的网络
        #输入的28*28为图片大小，输出的10为数字的类别数
        hidden_first = 512
        hidden_second = 512
        self.first = nn.Linear(in_features=28*28, out_features=hidden_first)
        self.second = nn.Linear(in_features=hidden_first, out_features=hidden_second)
        self.third = nn.Linear(in_features=hidden_second, out_features=10)

    def forward(self, data):
        #先将图片数据转化为1*784的张量
        data = data.view(-1, 28*28)
        data = F.relu(self.first(data))
        data = F.relu((self.second(data)))
        data = F.log_softmax(self.third(data), dim = 1)

        return data

def train():
    # 定义损失函数和优化器
    lossfunc = torch.nn.CrossEntropyLoss().cuda()
    #lossfunc = torch.nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(params=model.parameters(), lr=0.01)
    # 开始训练
    for epoch in range(n_epochs):
        train_loss = 0.0
        for data, target in train_loader:
            optimizer.zero_grad()
            #将数据放至GPU并计算输出
            data = data.cuda()
            target = target.cuda()
            output = model(data)
            #计算误差
            loss = lossfunc(output, target)
            #反向传播
            loss.backward()
            #将参数更新至网络中
            optimizer.step()
            #计算误差
            train_loss += loss.item() * data.size(0)
        train_loss = train_loss / len(train_loader.dataset)
        print('Epoch:  {}  \tTraining Loss: {:.6f}'.format(epoch + 1, train_loss))
        # 每遍历一遍数据集，测试一下准确率
        test()
    #最后将模型保存
    path = &quot;model.pt&quot;
    torch.save(model, path)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test程序不再贴出，直接调用了一个很常用的test程序。&lt;/p&gt;
&lt;p&gt;最后是主程序，在这里将模型放到GPU上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;model = MLP()
#将模型放到GPU上
model = model.cuda()
train()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实验结果&quot;&gt;实验结果&lt;/h2&gt;
&lt;p&gt;实验结果如下，可以看到，当对数据迭代训练十次时，准确率已经可以达到97%&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1709487/202004/1709487-20200428084921275-1101821171.png&quot; alt=&quot;实验结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分别运行了两次，第一次没有使用cuda加速，第二次使用了cuda加速，任务管理器分别显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1709487/202004/1709487-20200428084943784-964020629.png&quot; alt=&quot;未使用cuda&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1709487/202004/1709487-20200428085004362-1787238055.png&quot; alt=&quot;使用cuda&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，未使用cuda加速时，cpu占用率达到了100%，而GPU的使用率为0；而使用cuda加速时，cpu占用率只有49%，而GPU使用率为1%。这里GPU使用率较低的原因很多，比如我程序中batch_size设置的较小，另外只将数据和模型放到了GPU上，cpu上仍有部分代码与数据。经简单测试，使用cuda的训练时间在2:30左右，不使用cuda的训练时间在3:40左右。&lt;/p&gt;
&lt;h2 id=&quot;参考博客&quot;&gt;参考博客&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/l1606468155/article/details/89818546?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2&amp;amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2&quot;&gt;使用Pytorch构建MLP模型实现MNIST手写数字识别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何创建自定义模型&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_27825451/article/details/90705328&quot;&gt;pytorch教程之nn.Module类详解——使用Module类来自定义网络层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;epoch和batch是什么&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/22c50ded4cf7&quot;&gt;深度学习 | 三个概念：Epoch, Batch, Iteration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如何用GPU加速&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/12145857.html&quot;&gt;从头学pytorch(十三):使用GPU做计算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaosongshine/article/details/89401522&quot;&gt;PyTorch如何使用GPU加速（CPU与GPU数据的相互转换）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;保存模型&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LXYTSOS/article/details/90639524&quot;&gt;PyTorch模型保存与加载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Apr 2020 00:53:00 +0000</pubDate>
<dc:creator>王金翼</dc:creator>
<og:description>写在前面 由于MLP的实现框架已经非常完善，网上搜到的代码大都大同小异，而且MLP的实现是deeplearning学习过程中较为基础的一个实验。因此完全可以找一份源码以参考，重点在于照着源码手敲一遍，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fyunaru/p/12791790.html</dc:identifier>
</item>
<item>
<title>一不小心实现了RPC - crossoverJie</title>
<link>http://www.cnblogs.com/crossoverJie/p/12791759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crossoverJie/p/12791759.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/mDN2XjShVI4TBLx.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/dMDreQw6JAk87Gs.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着最近关注 &lt;a href=&quot;https://github.com/crossoverJie/cim&quot;&gt;cim&lt;/a&gt; 项目的人越发增多，导致提的问题以及 Bug 也在增加，在修复问题的过程中难免代码洁癖又上来了。&lt;/p&gt;
&lt;p&gt;看着一两年前写的东西总是怀疑这真的是出自自己手里嘛？有些地方实在忍不住了便开始了漫漫重构之路。&lt;/p&gt;

&lt;p&gt;在开始之前先简单介绍一下 &lt;code&gt;cim&lt;/code&gt; 这个项目，下面是它的架构图：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/LfaP3sFtclEoVX5.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说就是一个 IM 即时通讯系统，主要有以下部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IM-server&lt;/code&gt; 自然就是服务端了，用于和客户端保持长连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IM-client&lt;/code&gt; 客户端，可以简单认为是类似于的 QQ 这样的客户端工具；当然功能肯定没那么丰富，只提供了一些简单消息发送、接收的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Route&lt;/code&gt; 路由服务，主要用于客户端鉴权、消息的转发等；提供一些 http 接口，可以用于查看系统状态、在线人数等功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然服务端、路由都可以水平扩展。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/eBumPJbrvyQsHTF.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个消息发送的流程图，假设现在部署了两个服务端 A、B 和一个路由服务；其中 &lt;code&gt;ClientA&lt;/code&gt; 和 &lt;code&gt;ClientB&lt;/code&gt; 分别和服务端 A、B 保持了长连接。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;ClientA&lt;/code&gt; 向 &lt;code&gt;ClientB&lt;/code&gt; 发送一个 &lt;code&gt;hello world&lt;/code&gt; 时，整个的消息流转如图所示：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先通过 &lt;code&gt;http&lt;/code&gt; 将消息发送到 &lt;code&gt;Route&lt;/code&gt; 服务。&lt;/li&gt;
&lt;li&gt;路由服务得知 &lt;code&gt;ClientB&lt;/code&gt; 是连接在 &lt;code&gt;ServerB&lt;/code&gt; 上；于是再通过 &lt;code&gt;http&lt;/code&gt; 将消息发送给 &lt;code&gt;ServerB&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最终 &lt;code&gt;ServerB&lt;/code&gt; 将消息通过与 &lt;code&gt;ClientB&lt;/code&gt; 的长连接通道 &lt;code&gt;push&lt;/code&gt; 下去，至此消息发送成功。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我截取了 &lt;code&gt;ClientA&lt;/code&gt; 向 &lt;code&gt;Route&lt;/code&gt; 发起请求的代码：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/7FRrUh1o4GPJCuI.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以看到这就是利用 &lt;code&gt;okhttp&lt;/code&gt; 发起了一个 &lt;code&gt;http&lt;/code&gt; 请求，这样虽然能实现功能，但其实并不优雅。&lt;/p&gt;
&lt;p&gt;举个例子：假设我们需要对接支付宝的接口，这里发送一个 http 请求自然是没问题；但对于支付宝内部各部门直接互相调用接口时那就不应该再使用原始的 http 请求了。&lt;/p&gt;
&lt;p&gt;应该是由服务提供方提供一个 &lt;code&gt;api&lt;/code&gt; 包，服务消费者只需要依赖这个包就可以实现接口调用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当然最终使用的是 http、还是自定义私有协议都可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也类似于我们在使用 &lt;code&gt;Dubbo&lt;/code&gt; 或者是 &lt;code&gt;SpringCloud&lt;/code&gt; 时，通常是直接依赖一个 &lt;code&gt;api&lt;/code&gt; 包，便可以像调用一个本地方法一样调用远程服务了，并且完全屏蔽了底层细节，不管是使用的 http 还是 其他私有协议都没关系，对于调用者来说完全不关心。&lt;/p&gt;
&lt;p&gt;这么一说是不是有内味了，这不就是 RPC 的官方解释嘛。&lt;/p&gt;
&lt;p&gt;对应到这里也是同样的道理，&lt;code&gt;Client&lt;/code&gt; 、&lt;code&gt;Route&lt;/code&gt;、&lt;code&gt;Server&lt;/code&gt; 本质上都是一个系统，他们互相的接口调用也应当是走 &lt;code&gt;RPC&lt;/code&gt; 才合理。&lt;/p&gt;
&lt;p&gt;所以我重构之后的变成这样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/R4sqwHxAMYmz7f9.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是代码也简洁了许多，就和调用本地方法一样了，而且这样也有几个好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完全屏蔽了底层细节，可以更好的实现业务及维护代码。&lt;/li&gt;
&lt;li&gt;即便是服务提供方修改了参数，在编译期间就能很快发现，而像之前那样调用是完全不知情的，所以也增加了风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面来聊聊具体是如何实现的。&lt;/p&gt;
&lt;p&gt;其实在上文&lt;a href=&quot;https://crossoverjie.top/2020/03/30/wheel/cicada9-proxy/&quot;&gt;《动态代理的实际应用》&lt;/a&gt; 中也有讲到，原理是类似的。&lt;/p&gt;
&lt;p&gt;要想做到对调用者无感知，就得创建一个接口的代理对象；在这个代理对象中实现编码、调用、解码的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/REoaJPXzOlmBjnK.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应到此处其实就是创建一个 &lt;code&gt;routeApi&lt;/code&gt; 的代理对象，关键就是这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;RouteApi routeApi = new ProxyManager&amp;lt;&amp;gt;(RouteApi.class, routeUrl, okHttpClient).getInstance();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整源码如下：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/Z3aJOxrDyeNqzo2.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;getInstance()&lt;/code&gt; 函数就是返回了需要被代理的接口对象；而其中的 &lt;code&gt;ProxyInvocation&lt;/code&gt; 则是一个实现了 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口的类，这套代码就是利用 &lt;code&gt;JDK&lt;/code&gt; 实现动态代理的三板斧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/28/N6CoDig2SHjb7lI.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 &lt;code&gt;ProxyInvocation&lt;/code&gt; 的源码会发现当我们调用被代理接口的任意一个方法时，都会执行这里的 &lt;code&gt;invoke()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;invoke()&lt;/code&gt; 方法自然就实现了上图中提到的：编码、远程调用、解码的过程；相信大家很容易看明白，由于不是本次探讨的重点就不过多介绍了。&lt;/p&gt;

&lt;p&gt;其实理解这些就也就很容易看懂 &lt;code&gt;Dubbo&lt;/code&gt; 这类 &lt;code&gt;RPC&lt;/code&gt; 框架的核心源码了，总体的思路也是类似的，只不过使用的私有协议，所以在编解码时会有所不同。&lt;/p&gt;
&lt;p&gt;所以大家要是想自己动手实现一个 &lt;code&gt;RPC&lt;/code&gt; 框架，不妨参考这个思路试试，当用自己写的代码跑通一个 &lt;code&gt;RPC&lt;/code&gt; 的 &lt;code&gt;helloworld&lt;/code&gt; 时的感觉是和自己整合了一个 &lt;code&gt;Dubbo&lt;/code&gt;、&lt;code&gt;SpringCloud&lt;/code&gt; 这样的第三方框架的感觉是完全不同的。&lt;/p&gt;
&lt;p&gt;本文的所有源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crossoverJie/cim&quot;&gt;https://github.com/crossoverJie/cim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的点赞与分享是对我最大的支持&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Apr 2020 00:41:00 +0000</pubDate>
<dc:creator>crossoverJie</dc:creator>
<og:description>前言 随着最近关注 &amp;quot;cim&amp;quot; 项目的人越发增多，导致提的问题以及 Bug 也在增加，在修复问题的过程中难免代码洁癖又上来了。 看着一两年前写的东西总是怀疑这真的是出自自己手里嘛？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/crossoverJie/p/12791759.html</dc:identifier>
</item>
<item>
<title>架构设计 | 分布式业务系统中，全局ID生成策略 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12791135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12791135.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在实际的开发中，几乎所有的业务场景产生的数据，都需要一个唯一ID作为核心标识，用来流程化管理。比如常见的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;订单：order-id,查订单详情，物流状态等；&lt;/li&gt;
&lt;li&gt;支付：pay-id,支付状态，基于ID事务管理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何生成唯一标识，在普通场景下，一般的方法就可以解决，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.UUID;
public class UuidUtil {
    public static String getUUid() {
        UUID uuid = UUID.randomUUID();
        return String.valueOf(uuid).replace(&quot;-&quot;,&quot;&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法可以解决绝大部分唯一ID需求的场景业务，但是网上各种UUID重复场景的描述帖，说的好像该API不好用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;絮叨一句&lt;/code&gt;&lt;/strong&gt;：说一个真实使用的业务场景，大概是半年近3000万的数据流水，用的就是UUID的API，暂时未捕捉到ID重复的问题，仅供参考。&lt;/p&gt;

&lt;h2 id=&quot;1、概念简介&quot;&gt;1、概念简介&lt;/h2&gt;
&lt;p&gt;Twitter公司开源的分布式ID生成算法策略，生成的ID遵循时间的顺序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202004/1691717-20200427233703623-1934852650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1为位标识，始终为0，不可用；&lt;/li&gt;
&lt;li&gt;41位时间截，存储时间截的差值（当前时间截-开始时间截)；&lt;/li&gt;
&lt;li&gt;10位的机器标识，10位的长度最多支持部署1024个节点；&lt;/li&gt;
&lt;li&gt;12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序号；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高。&lt;/p&gt;
&lt;h2 id=&quot;2、编码实现&quot;&gt;2、编码实现&lt;/h2&gt;
&lt;p&gt;工具类中很多可以自定义的，比如起始时间，机器ID配置等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 雪花算法ID生成
 */
public class SnowIdWorkerUtil {
    // 开始时间截 (2020-01-02)
    private final long timeToCut = 1577894400000L;
    // 机器ID所占的位数
    private final long workerIdBits = 2L;
    // 数据标识ID所占的位数
    private final long dataCenterIdBits = 8L;
    // 支持的最大机器ID，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)
    private final long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);
    // 支持的最大数据标识ID，结果是31
    private final long maxDataCenterId = -1L ^ (-1L &amp;lt;&amp;lt; dataCenterIdBits);
    // 序列在ID中占的位数
    private final long sequenceBits = 12L;
    // 机器ID向左移12位
    private final long workerIdShift = sequenceBits;
    // 数据标识ID向左移17位(12+5)
    private final long dataCenterIdShift = sequenceBits + workerIdBits;
    // 时间截向左移22位(5+5+12)
    private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;
    // 生成序列的掩码
    private final long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);
    // 工作机器ID(0~31)
    private long workerId;
    // 数据中心ID(0~31)
    private long dataCenterId;
    // 毫秒内序列(0~4095)
    private long sequence = 0L;
    // 上次生成ID的时间截
    private long lastTimestamp = -1L;
    /**
     * 构造函数
     * @param workerId 工作ID (0~31)
     * @param dataCenterId 数据中心ID (0~31)
     */
    public SnowIdWorkerUtil (long workerId, long dataCenterId) {
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;workerId 不符合条件&quot;);
        }
        if (dataCenterId &amp;gt; maxDataCenterId || dataCenterId &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;dataCenterId 不符合条件&quot;);
        }
        this.workerId = workerId;
        this.dataCenterId = dataCenterId;
    }

    public synchronized String nextIdVar(){
        return String.valueOf(nextId());
    }
    /**
     * 线程安全，获得下一个ID
     */
    private synchronized long nextId() {
        long timestamp = timeGen();
        // 如果当前时间小于上一次ID生成的时间戳，抛出异常
        if (timestamp &amp;lt; lastTimestamp) {
            throw new RuntimeException(String.format(
                                        &quot;时间顺序异常,时间差(上次时间-现在)=%d&quot;,
                                        lastTimestamp - timestamp));
        }
        // 如果是同一时间生成的，则进行毫秒内序列
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) &amp;amp; sequenceMask;
            //毫秒内序列溢出
            if (sequence == 0) {
                //阻塞到下一个毫秒,获得新的时间戳
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            // 时间戳改变，毫秒内序列重置
            sequence = 0L;
        }
        // 上次生成ID的时间截
        lastTimestamp = timestamp;
        // 移位并通过或运算拼到一起组成64位的ID
        return ((timestamp - timeToCut) &amp;lt;&amp;lt; timestampLeftShift)
                | (dataCenterId &amp;lt;&amp;lt; dataCenterIdShift)
                | (workerId &amp;lt;&amp;lt; workerIdShift) | sequence;
    }

    /**
     * 阻塞，获得新的时间戳
     */
    private long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &amp;lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }
    /**
     * 返回当前时间节点
     */
    private long timeGen() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        // 参数在实际业务下需要配置管理
        SnowIdWorkerUtil idWorker = new SnowIdWorkerUtil(1, 1);
        for (int i = 0; i &amp;lt; 100; i++) {
            String id = idWorker.nextIdVar();
            System.out.println(id+&quot;  &quot;+id.length()+&quot;位&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;还有一种常见的实现思路，基于数据库的自增主键ID，不过基于这个原理，却有各种不同的实现策略。&lt;/p&gt;
&lt;p&gt;简单表结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `du_temp_id` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='主键ID临时表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202004/1691717-20200427233646212-1496175347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、基于主键&quot;&gt;1、基于主键&lt;/h2&gt;
&lt;p&gt;这种模式的原理比较单调,向临时表写入一条记录，借助MySQL生成的唯一主键ID，然后拿出来稍微处理一下，作为各种业务场景的唯一ID使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class TempIdServiceImpl implements TempIdService {

    @Resource
    private TempIdMapper tempIdMapper ;

    @Override
    public List&amp;lt;String&amp;gt; getIdList() {
        List&amp;lt;String&amp;gt; idList = new ArrayList&amp;lt;&amp;gt;() ;
        TempIdEntity tempIdEntity = new TempIdEntity ();
        tempIdEntity.setCreateTime(new Date());
        for (int i = 0 ; i &amp;lt; 10 ; i++){
            tempIdMapper.insert(tempIdEntity);
            idList.add(UuidUtil.getNoId(8,Long.parseLong(tempIdEntity.getId().toString()))) ;
        }
        return idList ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题点：如果作为ID生成的临时表所在的MySQL服务宕掉，那可能会影响整个业务流程，造成雪崩效应。&lt;/p&gt;
&lt;h2 id=&quot;2、高可用集群&quot;&gt;2、高可用集群&lt;/h2&gt;
&lt;p&gt;单服务如果不能安稳的支撑业务需求，很自然集群模式就该上场了。提供多台MySQL服务[A,B,C],处理策略也不止一种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;库设置主键自增策略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如A库[1,4,7]，B库[2,5,8],C库[3,6,9],基于不同自增规则，生成统一的自增唯一标识。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成ID做分库标识&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种先把ID生成，然后不同的数据库生成的ID给一个不同的标识，例如UIDA，UIDB，UIDC。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class TempIdServiceImpl implements TempIdService {

    @Resource
    private TempIdMapper tempIdMapper ;

    @Override
    public List&amp;lt;String&amp;gt; getRouteIdList() {
        List&amp;lt;String&amp;gt; idList = new ArrayList&amp;lt;&amp;gt;() ;
        TempIdEntity tempIdEntity = new TempIdEntity ();
        tempIdEntity.setCreateTime(new Date());
        for (int i = 0 ; i &amp;lt; 2 ; i++){
            tempIdMapper.insertA(tempIdEntity);
            idList.add(UuidUtil.getRouteId(&quot;UID-A&quot;,10,
                       Long.parseLong(tempIdEntity.getId().toString()))) ;
            tempIdMapper.insertB(tempIdEntity);
            idList.add(UuidUtil.getRouteId(&quot;UID-B&quot;,10,
                    Long.parseLong(tempIdEntity.getId().toString()))) ;
            tempIdMapper.insertC(tempIdEntity);
            idList.add(UuidUtil.getRouteId(&quot;UID-C&quot;,10,
                    Long.parseLong(tempIdEntity.getId().toString()))) ;
        }
        return idList ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果样例：&lt;/p&gt;
&lt;p&gt;UID-A00001,UID-B00001,UID-C00001&lt;/p&gt;
&lt;p&gt;UID-A00002,UID-B00002,UID-C00002&lt;/p&gt;
&lt;h2 id=&quot;3、id样式优化&quot;&gt;3、ID样式优化&lt;/h2&gt;
&lt;p&gt;从数据获取的ID基本是一个自增的整数序列，可以提供一个格式美化工具方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UuidUtil {

    private static final String ZERO = &quot;00000000000&quot;;
    private static final String PREFIX = &quot;UID&quot;;
    
    public static String getNoId(int length,Long id){
        String idVar = String.valueOf(id) ;
        if (idVar.length()&amp;gt;length){
            return PREFIX+idVar ;
        } else {
            int gapLen = length-idVar.length()-PREFIX.length() ;
            return PREFIX+ZERO.substring(0,gapLen)+idVar ;
        }
    }

    public static String getRouteId(String route,Integer length,Long id){
        String idVar = String.valueOf(id) ;
        if (idVar.length()&amp;gt;length){
            return route+idVar ;
        } else {
            int gapLen = length-idVar.length()-route.length() ;
            return route+ZERO.substring(0,gapLen)+idVar ;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于不同的策略，把ID格式为统一的位数。&lt;/p&gt;
&lt;h2 id=&quot;4、性能问题&quot;&gt;4、性能问题&lt;/h2&gt;
&lt;p&gt;如果在高并发的业务场景下，实时基于MySQL去生成唯一ID容易产生性能瓶颈，当然其他方法也可能产生这个问题。可以在系统空闲时间批量生成一批，放入缓存中，在使用的时候直接从缓存层取出即可。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：数据和架构管理&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 23:53:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、全局ID简介 在实际的开发中，几乎所有的业务场景产生的数据，都需要一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12791135.html</dc:identifier>
</item>
<item>
<title>巧用Grafana和Arthas自动抓取K8S中异常Java进程的线程堆栈 - KAnts</title>
<link>http://www.cnblogs.com/ants/p/12790851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/12790851.html</guid>
<description>&lt;p&gt;近期发现业务高峰期时刻会出现CPU繁忙导致的timeout异常，通过监控来看是因为Node上面的一些Pod突发抢占了大量CPU导致的。&lt;/p&gt;
&lt;p&gt;问: 没有限制CPU吗？是不是限制的CPU使用值就可以解决了呢？&lt;br/&gt;解: 其实不能根本解决这个问题，因为使用的容器引擎是Docker，而Docker是使用了cgroups技术，这就引入了一个老大难的问题，cgroup的隔离性。当问题发生时并没有办法把异常CPU进程直接摁住，而会有短暂的高峰，现象为：限制了CPU为2核，突发时CPU可能是4、5、6等，然后容器会被kill掉，K8S会尝试重建容器。&lt;/p&gt;
&lt;h2 id=&quot;那么该如何解决？&quot;&gt;那么该如何解决？&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;使用隔离性更好的容器引擎，如 kata(VM级别)。&lt;/li&gt;
&lt;li&gt;优化程序&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;方案1&quot;&gt;方案1&lt;/h3&gt;
&lt;p&gt;我们可以知道方案1解决的比较彻底，而且只需要全局处理一次即可，但技术比较新颖，不知道会不会带来其它问题，我们之后准备拿出部分Node尝试kata container。&lt;/p&gt;
&lt;h3 id=&quot;方案2&quot;&gt;方案2&lt;/h3&gt;
&lt;p&gt;对应用开发者要求比较高，需要对应的开发者针对性介入，短期收益很高，我们先部署了这种。&lt;/p&gt;
&lt;h2 id=&quot;如何实施？&quot;&gt;如何实施？&lt;/h2&gt;
&lt;p&gt;我们知道程序在运行中，除非特别严重的BUG，CPU高峰一般非常短暂，这时候靠人肉抓包基本上是来不及的，也很耗费精力，我们就希望有一个程序能在CPU达到一定阈值的时候自动抓取线程堆栈来事后针对性优化，并且一定时间内只允许运行一次防止循环抓包导致程序不可用。&lt;/p&gt;
&lt;p&gt;根据要实现的最终效果我们发现与Grafana、Prometheus的告警机制十分接近，我们要做的就是接收告警的webhook，去对应的容器中获取线程堆栈就行。&lt;/p&gt;
&lt;p&gt;于是我们利用了 Grafana ，写了一个程序来完成这个功能。&lt;/p&gt;
&lt;h3 id=&quot;项目信息&quot;&gt;项目信息&lt;/h3&gt;
&lt;p&gt;开发语言: Go、Shell&lt;br/&gt;项目地址: &lt;a href=&quot;https://github.com/majian159/k8s-java-debug-daemon&quot;&gt;https://github.com/majian159/k8s-java-debug-daemon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利用了 Grafana 的告警机制，配合阿里的 arthas，来完成高CPU使用率线程的堆栈抓取。&lt;br/&gt;整体流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为 Grafana 添加 webhook 类型的告警通知渠道，地址为该程序的 url(默认的hooks路径为 /hooks)。&lt;/li&gt;
&lt;li&gt;配置Grafana图表，并设置告警阈值&lt;/li&gt;
&lt;li&gt;当 webhook 触发时，程序会自动将 &lt;code&gt;craw.sh&lt;/code&gt; 脚本拷贝到对应 Pod 的容器中并执行。&lt;/li&gt;
&lt;li&gt;程序将 stdout 保存到本地文件。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;效果预览&quot;&gt;效果预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_27_15_53_bH3y0o%20.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_27_15_54_XrXVpk%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;默认行为&quot;&gt;默认行为&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;每 node 同时运行执行数为10&lt;br/&gt;可以在 &lt;code&gt;./internal/defaultvalue.go&lt;/code&gt; 中更改
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var defaultNodeLockManager = nodelock.NewLockManager(10)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;默认使用集群内的Master配置&lt;br/&gt;可以在 &lt;code&gt;./internal/defaultvalue.go&lt;/code&gt; 中更改
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func DefaultKubernetesClient(){}

// default
func getConfigByInCluster(){}

func getConfigByOutOfCluster(){}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;默认使用并实现了一个基于本地文件的堆栈存储器, 路径位于工作路径下的 &lt;code&gt;stacks&lt;/code&gt;中&lt;br/&gt;可以在 &lt;code&gt;./internal/defaultvalue.go&lt;/code&gt; 中更改
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func GetDefaultNodeLockManager(){}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;默认取最繁忙的前50个线程的堆栈信息 (可在 &lt;code&gt;craw.sh&lt;/code&gt; 中修改)&lt;/li&gt;
&lt;li&gt;采集样本时间为2秒 (可在 &lt;code&gt;craw.sh&lt;/code&gt; 中修改)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;docker-image&quot;&gt;Docker Image&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/majian159/java-debug-daemon&quot;&gt;majian159/java-debug-daemon&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;为-grafana-新建一个通知频道&quot;&gt;为 Grafana 新建一个通知频道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_27_15_08_ID8XfL%20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意点&quot;&gt;注意点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;需要打开 Send reminders, 不然 Grafana 默认在触发告警后一直没有解决不会重复发送告警&lt;/li&gt;
&lt;li&gt;Send reminder every 可以控制最快多久告警一次&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为-grafana-新建一个告警图表&quot;&gt;为 Grafana 新建一个告警图表&lt;/h3&gt;
&lt;p&gt;如果嫌麻烦可以直接导入以下配置, 在自行更改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;datasource&quot;: &quot;prometheus&quot;,
  &quot;alert&quot;: {
    &quot;alertRuleTags&quot;: {},
    &quot;conditions&quot;: [
      {
        &quot;evaluator&quot;: {
          &quot;params&quot;: [
            1
          ],
          &quot;type&quot;: &quot;gt&quot;
        },
        &quot;operator&quot;: {
          &quot;type&quot;: &quot;and&quot;
        },
        &quot;query&quot;: {
          &quot;params&quot;: [
            &quot;A&quot;,
            &quot;5m&quot;,
            &quot;now&quot;
          ]
        },
        &quot;reducer&quot;: {
          &quot;params&quot;: [],
          &quot;type&quot;: &quot;last&quot;
        },
        &quot;type&quot;: &quot;query&quot;
      }
    ],
    &quot;executionErrorState&quot;: &quot;keep_state&quot;,
    &quot;for&quot;: &quot;10s&quot;,
    &quot;frequency&quot;: &quot;30s&quot;,
    &quot;handler&quot;: 1,
    &quot;name&quot;: &quot;Pod 高CPU堆栈抓取&quot;,
    &quot;noDataState&quot;: &quot;no_data&quot;,
    &quot;notifications&quot;: [
      {
        &quot;uid&quot;: &quot;AGOJRCqWz&quot;
      }
    ]
  },
  &quot;aliasColors&quot;: {},
  &quot;bars&quot;: false,
  &quot;dashLength&quot;: 10,
  &quot;dashes&quot;: false,
  &quot;fill&quot;: 1,
  &quot;fillGradient&quot;: 0,
  &quot;gridPos&quot;: {
    &quot;h&quot;: 9,
    &quot;w&quot;: 24,
    &quot;x&quot;: 0,
    &quot;y&quot;: 2
  },
  &quot;hiddenSeries&quot;: false,
  &quot;id&quot;: 14,
  &quot;legend&quot;: {
    &quot;alignAsTable&quot;: true,
    &quot;avg&quot;: true,
    &quot;current&quot;: true,
    &quot;max&quot;: true,
    &quot;min&quot;: false,
    &quot;rightSide&quot;: true,
    &quot;show&quot;: true,
    &quot;total&quot;: false,
    &quot;values&quot;: true
  },
  &quot;lines&quot;: true,
  &quot;linewidth&quot;: 1,
  &quot;nullPointMode&quot;: &quot;null&quot;,
  &quot;options&quot;: {
    &quot;dataLinks&quot;: []
  },
  &quot;percentage&quot;: false,
  &quot;pointradius&quot;: 2,
  &quot;points&quot;: false,
  &quot;renderer&quot;: &quot;flot&quot;,
  &quot;seriesOverrides&quot;: [],
  &quot;spaceLength&quot;: 10,
  &quot;stack&quot;: false,
  &quot;steppedLine&quot;: false,
  &quot;targets&quot;: [
    {
      &quot;expr&quot;: &quot;container_memory_working_set_bytes{job=\&quot;kubelet\&quot;, metrics_path=\&quot;/metrics/cadvisor\&quot;, image!=\&quot;\&quot;, container!=\&quot;POD\&quot;}* on (namespace, pod) group_left(node) max by(namespace, pod, node, container) (kube_pod_info)&quot;,
      &quot;legendFormat&quot;: &quot;{{node}} - {{namespace}} - {{pod}} - {{container}}&quot;,
      &quot;refId&quot;: &quot;A&quot;
    }
  ],
  &quot;thresholds&quot;: [
    {
      &quot;colorMode&quot;: &quot;critical&quot;,
      &quot;fill&quot;: true,
      &quot;line&quot;: true,
      &quot;op&quot;: &quot;gt&quot;,
      &quot;value&quot;: 1
    }
  ],
  &quot;timeFrom&quot;: null,
  &quot;timeRegions&quot;: [],
  &quot;timeShift&quot;: null,
  &quot;title&quot;: &quot;Pod CPU&quot;,
  &quot;tooltip&quot;: {
    &quot;shared&quot;: true,
    &quot;sort&quot;: 0,
    &quot;value_type&quot;: &quot;individual&quot;
  },
  &quot;type&quot;: &quot;graph&quot;,
  &quot;xaxis&quot;: {
    &quot;buckets&quot;: null,
    &quot;mode&quot;: &quot;time&quot;,
    &quot;name&quot;: null,
    &quot;show&quot;: true,
    &quot;values&quot;: []
  },
  &quot;yaxes&quot;: [
    {
      &quot;format&quot;: &quot;short&quot;,
      &quot;label&quot;: null,
      &quot;logBase&quot;: 1,
      &quot;max&quot;: null,
      &quot;min&quot;: null,
      &quot;show&quot;: true
    },
    {
      &quot;format&quot;: &quot;short&quot;,
      &quot;label&quot;: null,
      &quot;logBase&quot;: 1,
      &quot;max&quot;: null,
      &quot;min&quot;: null,
      &quot;show&quot;: true
    }
  ],
  &quot;yaxis&quot;: {
    &quot;align&quot;: false,
    &quot;alignLevel&quot;: null
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;queries配置&quot;&gt;Queries配置&lt;/h4&gt;
&lt;p&gt;Metrics 中填写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;container_memory_working_set_bytes{job=&quot;kubelet&quot;, metrics_path=&quot;/metrics/cadvisor&quot;, image!=&quot;&quot;, container!=&quot;POD&quot;} * on (namespace, pod) group_left(node) max by(namespace, pod, node, container) (kube_pod_info)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Legend 中填写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;{{node}} - {{namespace}} - {{pod}} - {{container}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完如下：&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_27_15_23_l95PjW%20.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;alert配置&quot;&gt;Alert配置&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;IS ABOVE&lt;/strong&gt;&lt;br/&gt;CPU使用值，这边配置的是超过1核CPU就报警, 可以根据需要自己调节&lt;br/&gt;&lt;strong&gt;Evaluate every&lt;/strong&gt;&lt;br/&gt;每多久计算一次&lt;br/&gt;&lt;strong&gt;For&lt;/strong&gt;&lt;br/&gt;Pedding时间&lt;/p&gt;
&lt;p&gt;配置完应该如下:&lt;br/&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/majian159/blogs@master/images/2020_04_27_15_26_xOjjLk%20.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;构建&quot;&gt;构建&lt;/h2&gt;
&lt;h3 id=&quot;二进制&quot;&gt;二进制&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;# 为当前系统平台构建
make

# 指定目标系统, GOOS: linux darwin window freebsd
make GOOS=linux

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;docker镜像&quot;&gt;Docker镜像&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;make docker

# 自定义镜像tag
make docker IMAGE=test
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 27 Apr 2020 23:42:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<og:description>前言 近期发现业务高峰期时刻会出现CPU繁忙导致的timeout异常，通过监控来看是因为Node上面的一些Pod突发抢占了大量CPU导致的。 问: 没有限制CPU吗？是不是限制的CPU使用值就可以解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ants/p/12790851.html</dc:identifier>
</item>
<item>
<title>2020年必须掌握的硬核技能k8s - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/12791071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/12791071.html</guid>
<description>&lt;p&gt;Kubernetes 是一个软件系统，使你在数以万计的电脑节点上运行软件时就像 所有节点是以单个大节点一样， 它将底层基础设施抽象，这样做同时简化了应用开发、部署，以及对开发和运维团队的管理。&lt;/p&gt;
&lt;h2 id=&quot;kubernetes集群架构&quot;&gt;Kubernetes集群架构&lt;/h2&gt;
&lt;p&gt;Kubernetes集群由很多节点组成，分为两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主节点 承载Kubernetes控制和管理整个集群系统的控制面板&lt;/li&gt;
&lt;li&gt;工作节点 运行实际部署的应用&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/403a6a96-e258-4dac-8d74-3a8fe63fbfcf.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;控制面板&quot;&gt;控制面板&lt;/h3&gt;
&lt;p&gt;控制集群并使它工作，包含多个组件（组件单节点或通过副本分别部署到多个主节点以确保高可用）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kubernetes Api Server： 客户端Kubectl、控制面板其他组件和worker节点都需要和它通信&lt;/li&gt;
&lt;li&gt;Scheduler: 调度应用&lt;/li&gt;
&lt;li&gt;Controller Manager: 执行集群级别功能，如复制组件、持续跟踪工作节点、处理节点失败等&lt;/li&gt;
&lt;li&gt;etcd：可靠的分布式数据库存储，能持久化集群配置&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;工作节点&quot;&gt;工作节点&lt;/h3&gt;
&lt;p&gt;运行容器化应用的机器，运行、监控、管理应用服务的任务由下组件完成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Docker、rtk或其他容器类型&lt;/li&gt;
&lt;li&gt;Kubelet与API Server通信，并管理它所在节点容器&lt;/li&gt;
&lt;li&gt;Kube-Proxy：负责组件之间负载均衡网络流量&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;minikube环境-核心概念&quot;&gt;MiniKube环境&amp;amp; 核心概念&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本处window10+Hyper-V搭建minikube本地集群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/8f5088de-2308-42f9-a97d-6daa20c997fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这台虚拟机既作为master，又作为worker，Kubectl从集群外部发起管理和控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 因国内极差的网络环境，建议使用阿里云的镜像地址：
minikube start --image-mirror-country=cn --image-repository=http://registry.aliyuncs.com/google_containers  --registry-mirror=https://aq32bn7a.mirror.aliyuncs.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以管理员权限执行CMD命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;kubectl: 发送Restful api 控制Kubernetes集群管理器&lt;/li&gt;
&lt;li&gt;Minikube是一个CLI工具，配置、管理(已针对开发流程优化)的单节点Kubernetes集群&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;列举4个核心概念&quot;&gt;列举4个核心概念&lt;/h3&gt;
&lt;h4 id=&quot;1-api&quot;&gt;1. API&lt;/h4&gt;
&lt;p&gt;Kubernetes API作为&lt;code&gt;声明式配置方案&lt;/code&gt;的基石，API文档中定义了API端点、资源，kubectl命令行工具可操作API对象，对象的序列化对象存储在etcd中，各组件也是通过API交互。&lt;/p&gt;
&lt;h4 id=&quot;2-k8s对象&quot;&gt;2. k8s对象&lt;/h4&gt;
&lt;p&gt;Kubernetes对象代表系统中持久化的实体，下面的实体都作为对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些容器化应用正在运行&lt;/li&gt;
&lt;li&gt;这些应用程序可用的资源&lt;/li&gt;
&lt;li&gt;与这些应用程序有关的行为&amp;amp;策略：重新启动策略、升级和容错&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kubernetes对象是&lt;code&gt;期望状态&lt;/code&gt;，创建对象之后，你就通知了K8s你希望集群这样运作。&lt;br/&gt;大多数K8s对象由spec和status组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spec：[由你]提供资源的特征描述&lt;/li&gt;
&lt;li&gt;status: [系统自行控制] 描述对象当前状态，由K8s系统组件设置和更新，K8s控制面板持续管理对象的实际状态去匹配你设定的期望状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当你创建k8s对象， 你需要提供对象spec来描述预期状态。 当使用k8s API(或者kubectl)，在API请求的body包含json信息；&lt;strong&gt;大多数时给kubectl提供.yaml文件来代替json&lt;/strong&gt;,kubectl会将yaml文件中信息转换为json再发起API请求。&lt;/p&gt;
&lt;p&gt;下面的&lt;code&gt;kubia-rs.yaml文件&lt;/code&gt;：ReplicaSet对象启动3个nodejs应用, [spec]定义了此次ReplicaSet的规格&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: apps/v1
kind: ReplicaSet
metadata: 
 name: kubia-rs
spec:
 replicas: 3
 selector: 
   matchLabels:
     app: kubia
 template:
   metadata: 
     labels: 
       app: kubia
   spec:
     containers:
     - name: kubia
       image: luksa/kubia
       ports:
       - containerPort: 8080
#  对于ReplicaSet啰嗦两句： 新一代的ReplicationController; 通常不会直接创建ReplicaSet，而是在创建更高级的Deployment资源时自动创建它们。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-pod&quot;&gt;3. Pod&lt;/h4&gt;
&lt;p&gt;Kubernetes Pod是创建/部署k8s对象中最小最简单的单元:&lt;br/&gt;由于不能将多个进程聚集在一个单独容器，需要另外一种高级结构将容器绑定在一起，作为一个单元管理，这就是Pod背后根本原理， 一个pod中容器共享相同ip和端口空间。&lt;/p&gt;
&lt;h4 id=&quot;4-controller&quot;&gt;4. Controller&lt;/h4&gt;
&lt;p&gt;k8s控制器是一个&lt;code&gt;control loop&lt;/code&gt;（监控集群状态，在被需要时或主动请求时更新集群），每个控制器都试图&lt;code&gt;将当前集群状态移动到期望状态&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在机器人和自动化，&lt;code&gt;control loop&lt;/code&gt;是一个非终止回路，用于调节系统状态，例如房间的空调。&lt;br/&gt;控制器自身可以执行操作，但一般情况下，控制器会将引起连锁反应的消息发往api server.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kubernetes内置了一些控制器: ReplicaSet、Deployment、StatefulSets、DaemonSet、Job...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# k8s deployment检查容器健康状态、保证容器数量、还具备部署相关的特性， deployment是管理和缩放容器的推荐控制器
kubectl  create  deployment  hello-kubia  --iamge=luksa/kubia
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这4个概念连起来就是：&lt;br/&gt;K8s已经定义了API元数据，Controller调度K8s系统到指定的 预期状态（这个预期状态以K8s对象提现），在落地形式上以创建/调度Pod来承载应用。 （此4个概念还不包含NetWork相关）&lt;/p&gt;
&lt;h2 id=&quot;开启kubernetes之旅&quot;&gt;开启Kubernetes之旅&lt;/h2&gt;
&lt;h4 id=&quot;创建3实例nodejs应用，&quot;&gt;创建3实例nodejs应用，&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;使用上面的K8s对象定义文件： kubia-rs.yaml文件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;\&amp;gt; kubectl  create  -f  kubia-rs.yaml

\&amp;gt; kubectl get pod --show-labels=true
NAME             READY   STATUS    RESTARTS   AGE     LABELS
kubia-rs-96ncq   1/1     Running   0          3m40s   app=kubia
kubia-rs-h5ppz   1/1     Running   0          3m41s   app=kubia
kubia-rs-x5578   1/1     Running   0          3m40s   app=kubia
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：Pod控制器中使用&lt;code&gt;标签选择器&lt;/code&gt;来指定哪些Pod属于同一组（服务也使用同样机制）。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;以上有多个Pod，创建服务对后端Pod形成负载均衡&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;[集群内访问]： ClusterIP&lt;br/&gt;[提供集群外访问]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nodeport： 把 service 的 port 映射到集群节点的一个端口上&lt;/li&gt;
&lt;li&gt;LoadBalancer：负载均衡器会单独分配一个ip地址并监听后端服务的指定端口，请求的流量会通过指定的端口转发到后端对应的服务。&lt;/li&gt;
&lt;li&gt;Ingress (minikube addons先启用ingress，智能路由)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4种网络方式的yaml代码如下：请通过kubectl create -f ...ymal命令生成对应的服务(ingress不是服务)&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/585db18d-efc6-42ec-84aa-3786cce481f7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;LoadBalancer是服务暴露到集群外或者公网上的标准方式；&lt;br/&gt;Ingress 这个服务类型跟我们前面的三种服务类型不一样，&lt;code&gt;它实际上不是一种服务类型&lt;/code&gt;，而是类似一种集群服务入口的存在，它可以基于你配置的不同路径或者子域名把流量路由到对应的后端服务，更像是一个“智能路由”服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/11ca8171-7a8a-43f9-8346-b3e24929c737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;访问3 Pod实例的nodejs应用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;ClusterIP 只能在集群内访问，minikube ssh 进入集群，或者Hyper-V进入VM： curl 10.100.166.197访问&lt;/li&gt;
&lt;li&gt;nodePort、Loadbalancer 需要使用minikube获取本地集群url&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ad7312b4-460b-48d2-98be-b0d39e46c2de.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ingress 是复杂网络应用的常规做法&lt;br/&gt;(1) hosts文件添加host到IP地址的映射&lt;br/&gt;(2) 通过ingress路由访问pod&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/249850b2-97a7-4834-9c77-73ea1c71aafa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面输出差异体现了随机Pod(即使连接来自同一个客户端)，SessionAffinity亲和力属性值(ClientIP)可让单子一客户端请求都指向一个Pod。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文从K8s全局架构讲起，力求先在你头脑中构筑宏观思维导图；&lt;br/&gt;提出核心概念帮助全流程理解；&lt;br/&gt;通过一个常见的多实例nodejs应用来实践k8s核心功能。&lt;br/&gt;本文的所有代码：&lt;a href=&quot;https://github.com/zaozaoniao/k8s-example.git&quot;&gt;https://github.com/zaozaoniao/k8s-example.git&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 23:37:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>最网最容易理解的k8s入门，可视野可运行，有图有真相。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/12791071.html</dc:identifier>
</item>
<item>
<title>编程中，有哪些好的习惯一开始就值得坚持？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12791643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12791643.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;86.947909024211&quot;&gt;
&lt;p&gt;嗨，小伙伴们大家好，我是沉默王二，就是那个吹自己既有颜值又有才华的家伙。今天这个话题我觉得还是值得和大家探讨的，因为好的编程习惯对程序员的职业生涯真的非常重要。&lt;/p&gt;
&lt;p&gt;记得我在学驾照的时候，遇到一哥们，之前开过车，属于无证驾驶的那种。但是，这哥们科目二竟然挂了四次，第五次有没有过我不知道，因为我科目三都考过了，那哥们还在练科目二。教练真气的不轻，天天扯着嗓门喊：“你那个脑袋瓜子特么能不能不要钻到车窗外面看，把车窗玻璃给我摇上去，里面难道看不到镜子吗？”&lt;/p&gt;
&lt;p&gt;我在排队等车期间真的观察过，尤其是侧方停车的时候，这哥们总是有意无意把脑袋伸出窗外看，玻璃摇上去的时候都能磕到车窗上，看得我都替他捉急。教练说这哥们之前开车的时候养成了这个坏习惯，现在想改就是改不过来；报了 VIP 也没用，最后一次看天意吧，实在是没招了。&lt;/p&gt;
&lt;p&gt;不是我吹牛，我科目二就考得挺顺利，一次性过，倒车入库的时候感觉都要压线了，但凭借着两周时间养成的好习惯硬是过了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/biancheng-xiguan-01.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;那接下来我就来分享三个好习惯，自我感觉良好地认为，值得所有的小伙伴们借鉴。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;&lt;span&gt;01、代码一定要规范&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;任何编程语言都有自己的一套规范，好的规范能让代码更易阅读，能让 bug 没有容身之处。你比如说，Java 类的命名应该遵守以下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;必须以大写字母开头&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最好是一个名词，比如说 System&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;尽量不要省略成单词的首字母&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Writer&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如说，方法的命名应该遵守以下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;必须以小写字母开头&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最好是一个动词，比如说 &lt;code&gt;print()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 &lt;code&gt;actionPerformed()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;writeBook&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遵守这些规则就像是在马路上遵守交通规则一样，否则后果不堪设想。之前给小伙伴们安利过两个 IDEA 插件，一个阿里巴巴的开发规约，一个 SonarLint，它们在提高代码质量上面的效果杠杠的，我自己一直在用。&lt;/p&gt;
&lt;p&gt;还有就是&lt;a href=&quot;https://mp.weixin.qq.com/s/tvO-4uah_c3PMELnoYNXXQ&quot;&gt;阿里出品的 Java 开发手册&lt;/a&gt;，一定要把上面罗列的条目刻到脑子里，至少放一份在桌面上吧，活学活用。&lt;/p&gt;
&lt;p&gt;我之前在日企的时候，公司内部就有一份编码规约，关于 ActionScript 方面的，详细程度可以和阿里的开发手册媲美，只不过没有对外开放。好多年过去了，虽然规约上面的内容忘得一干二净，但它给我的印象深刻——就像初恋女友一样，容颜早已忘却，背影却时不时涌上心头（逃。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/biancheng-xiguan-02.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h02&quot;&gt;&lt;span&gt;02、学会阅读源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;源码是香，但我不建议新手一上来就阅读源码，因为很容易劝退。就好像文章开头提到的学驾照一样，如果一开始就从科目三练起，那多半会在路上完蛋。&lt;/p&gt;
&lt;p&gt;阅读源码之前，技术储备一定要到位。也就是说科目三练习之前，科目一的理论知识要过关，科目二的基本技巧要掌握，如果说方向盘都不会打，油门刹车都不会踩，档位都不会挂，那教练不被吓出心脏病才怪。&lt;/p&gt;
&lt;p&gt;一旦你的技术功底达到一定程度后，想要更上一层楼，阅读源码就变得势在必行了。因为阅读源码有以下好处：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解决 bug。如果 Google、Stack Overflow 上搜不到答案，那么阅读源码几乎就是唯一可行的解决办法了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;知其所以然。比如说，你想知道为什么 String 类是不可变类，那就必须钻一钻源码才能明白。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;学习。为什么大牛们都会推荐 GitHub，就是因为它上面的项目都是开源的，源代码是可以直接阅读的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;改造。很多时候，我们已经拿到了一个轮子，但需要对它进行一些改造才能满足需求，那就必须在改之前阅读源码，否则，轮子可能会被改造成锤子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;知道阅读源码的好处了吧？那有小伙伴可能要问，怎么去阅读源码呢，有哪些技巧呢？我来分享一下自己经验：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先阅读文档。知道库是干嘛的，知道类是干嘛的，知道方法是干嘛的，知道变量是干嘛的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;打断点，进行调试。代码之间会有很多调用关系，如果只看不动手和源码干一架的话，很可能不知道代码之间是如何衔接的，通过调试就可以看清楚整个源码之间的脉络。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分享阅读源码后的心得。所谓好记性不如烂笔头，写下来可不只是为了分享自己阅读源码后的喜悦之情，更重要的是，当你忘的差不多时笔记可以唤醒你的记忆。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/biancheng-xiguan-03.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、独立思考并解决问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我的技术交流群里有过那么一个小伙伴，一年多时间过去了，几乎没什么成长，遇到问题就往群里群里扔，或者直接私信发给我。我发现，现在问的问题和一年前问的问题真差不多，无非就是形式上发生了一些变化。&lt;/p&gt;
&lt;p&gt;这说明什么呢？这名小伙伴没有学会独立思考，没有学会举一反三。人最珍贵的财产其实不是钱，而是思考的能力，对吧？脑子是越用越灵活的，不用呢，就真的会生锈。&lt;/p&gt;
&lt;p&gt;一旦你学会独立思考，那么你解决问题的能力真的是会提升一个很高的档次——从一名合格的程序员蜕变为一名优秀的程序员的关键节点。在我上大专的两年时间里，成长真的特别慢，因为遇到问题我就想着问同学啊，问老师啊，结果是同学和老师进步了，我还是原来的我。&lt;/p&gt;
&lt;p&gt;等到大三去实习后，一切就悄然改变了，领导忙得很，压根就没有工夫帮你解决一些鸡毛蒜皮的小问题。再者，真不好意思，不能把底裤漏给领导看啊，没办法，我就只能自己硬着头皮上。&lt;/p&gt;
&lt;p&gt;硬上的次数多了，真的发现，原来自己不通过别人的帮助也能够把问题解决掉。渐渐地，随着时间的推移，我在团队里面开始显山露水了。&lt;/p&gt;
&lt;p&gt;那怎么才能培养独立思考的能力呢？按照胡适先生所说的，就是质疑一切，然后提出假设，最后去求证。&lt;/p&gt;
&lt;p&gt;你比如说，Java 程序员都知道 String 类是不可变的，那假如说它是可变的呢？会是什么样子，研究完你就会明白，原来一个不可变类是这样设计的啊，自己也能搞个不可变类了！&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/biancheng-xiguan-04.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、最后&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5.6842105263158&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。本回答已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 27 Apr 2020 23:34:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>嗨，小伙伴们大家好，我是沉默王二，就是那个吹自己既有颜值又有才华的家伙。今天这个话题我觉得还是值得和大家探讨的，因为好的编程习惯对程序员的职业生涯真的非常重要。 记得我在学驾照的时候，遇到一哥们，之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12791643.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（7）——合成 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12534459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12534459.html</guid>
<description>&lt;p&gt;　　在图形编辑软件中，可以按特定地方式处理不同图层的合成，最新的CSS规范也引入了该功能，并提供了mix-blend-mode和background-blend-mode两个属性。混合模式（blending mode）是一种数学算法，可计算元素重叠部分的颜色值，目前已定义了十多种不同的混合模式。&lt;/p&gt;

&lt;p&gt;　　元素混合是指将元素和其背后内容（backdrop，也叫背着物）混合，由mix-blend-mode属性设置混合模式。元素背后既可以是另一个元素，也可以是父元素的背景，并且声明了mix-blend-mode属性的元素被称为前景。注意，不同层叠上下文中的元素不能混合。接下来会对已有的混合模式逐个讲解，并给出相应的计算公式，下面列出的是会用到的符号含义。&lt;/p&gt;
&lt;p&gt;　　（1）Cr：计算后的颜色值。&lt;/p&gt;
&lt;p&gt;　　（2）B：进行混合的公式。&lt;/p&gt;
&lt;p&gt;　　（3）Cs：前景中的颜色。&lt;/p&gt;
&lt;p&gt;　　（4）Cb：元素背后的颜色（backdrop color）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）darken&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　比较Cb和Cs的颜色分量（即R、G和B），选择较暗的颜色，即保留较小值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = min(Cb, Cs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面将img元素的mix-blend-mode属性定义为darken，父元素div声明了渐变背景。在下图中，左侧是img和div默认的混合效果，右侧是使用了darken混合后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; linear-gradient(to right, rgb(48,129,242) 10%, rgb(255,204,0) 66%, rgb(255,102,0))&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  img &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    mix-blend-mode&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; darken&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./avatar.png&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320195914649-55803229.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）lighten&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　与darken类似，但选择较亮的颜色，即保留较大值，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = max(Cb, Cs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200009621-1534489358.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）difference&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　取Cb和Cs颜色分量之差的绝对值，用较浅的颜色减去较深的颜色，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = | Cb - Cs |
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200058149-977988717.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）exclusion&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　与difference类似，但对比度更低，颜色更柔和，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = Cb + Cs - 2 x Cb x Cs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200209745-1134037138.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）multiply&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb和Cs中的颜色分量相乘，得到较暗的颜色，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = Cb x Cs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200317634-1567797783.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）screen&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb和Cs的颜色反转，然后相乘，最后再反转，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = 1 - [(1 - Cb) x (1 - Cs)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200409412-1061193829.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）overlay&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当Cb的颜色比Cs的颜色深时，执行multiply渲染；当Cb的颜色比Cs的颜色浅时，执行screen渲染，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = HardLight(Cs, Cb)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200507867-448678938.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8）hard-light&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　也是对multiply和screen的综合应用，但判断条件与overlay相反，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(Cs &amp;lt;= 0.5&lt;span&gt;)
    B(Cb, Cs) &lt;/span&gt;= Multiply(Cb, 2&lt;span&gt; x Cs)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    B(Cb, Cs) &lt;/span&gt;= Screen(Cb, 2 x Cs -1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200558608-1644547778.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9）soft-light&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　与hard-light类似，但颜色更加柔和，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt;(Cs &amp;lt;= 0.5&lt;span&gt;)
        B(Cb, Cs) &lt;/span&gt;= Cb - (1 - 2 x Cs) x Cb x (1 -&lt;span&gt; Cb)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        B(Cb, Cs) &lt;/span&gt;= Cb + (2 x Cs - 1) x (D(Cb) -&lt;span&gt; Cb)
&lt;/span&gt;&lt;span&gt;with&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(Cb &amp;lt;= 0.25&lt;span&gt;)
        D(Cb) &lt;/span&gt;= ((16 * Cb - 12) x Cb + 4&lt;span&gt;) x Cb
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        D(Cb) &lt;/span&gt;= sqrt(Cb)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200656047-298456491.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10）color-dodge&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　不改变颜色，但会将其调亮，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(Cb == 0&lt;span&gt;)
    B(Cb, Cs) &lt;/span&gt;= 0
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(Cs == 1&lt;span&gt;)
    B(Cb, Cs) &lt;/span&gt;= 1
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    B(Cb, Cs) &lt;/span&gt;= min(1, Cb / (1 - Cs))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200808775-1097181908.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11）color-burn&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　与color-dodge的作用相反，将颜色调暗，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(Cb == 1&lt;span&gt;)
    B(Cb, Cs) &lt;/span&gt;= 1
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(Cs == 0&lt;span&gt;)
    B(Cb, Cs) &lt;/span&gt;= 0
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    B(Cb, Cs) &lt;/span&gt;= 1 - min(1, (1 - Cb) / Cs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320200907986-1754063062.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来的四个混合模式不操作颜色分量，而是以不同的方式合并Cs和Cb的色相、饱和度、亮度和颜色，会用到几个辅助函数，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    Lum(C) = 0.3 x Cred + 0.59 x Cgreen + 0.11&lt;span&gt; x Cblue
    
    ClipColor(C)
        L &lt;/span&gt;=&lt;span&gt; Lum(C)
        n &lt;/span&gt;=&lt;span&gt; min(Cred, Cgreen, Cblue)
        x &lt;/span&gt;=&lt;span&gt; max(Cred, Cgreen, Cblue)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n &amp;lt; 0&lt;span&gt;)
            C &lt;/span&gt;= L + (((C - L) * L) / (L -&lt;span&gt; n))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x &amp;gt; 1&lt;span&gt;)
            C &lt;/span&gt;= L + (((C - L) * (1 - L)) / (x -&lt;span&gt; L))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; C
    
    SetLum(C, l)
        d &lt;/span&gt;= l -&lt;span&gt; Lum(C)
        Cred &lt;/span&gt;= Cred +&lt;span&gt; d
        Cgreen &lt;/span&gt;= Cgreen +&lt;span&gt; d
        Cblue &lt;/span&gt;= Cblue +&lt;span&gt; d
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ClipColor(C)
        
    Sat(C) &lt;/span&gt;= max(Cred, Cgreen, Cblue) -&lt;span&gt; min(Cred, Cgreen, Cblue)

    SetSat(C, s)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Cmax &amp;gt;&lt;span&gt; Cmin)
            Cmid &lt;/span&gt;= (((Cmid - Cmin) x s) / (Cmax -&lt;span&gt; Cmin))
            Cmax &lt;/span&gt;=&lt;span&gt; s
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            Cmid &lt;/span&gt;= Cmax = 0&lt;span&gt;
        Cmin &lt;/span&gt;= 0
        &lt;span&gt;return&lt;/span&gt; C;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;12）hue&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb的颜色的饱和度与亮度跟Cs中对应位置的色相合并，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201133966-1815427807.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;13）saturation&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb的颜色的色相与亮度跟Cs中对应位置的饱和度合并，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201221088-2069914353.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;14）color&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb的颜色的亮度跟Cs中对应位置的色相与饱和度合并，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = SetLum(Cs, Lum(Cb))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201314633-388666116.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;15）luminosity&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将Cb的颜色的色相与饱和度跟Cs中对应位置的亮度合并，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
B(Cb, Cs) = SetLum(Cb, Lum(Cs))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201409291-2019046507.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　背景混合适合一个元素包含多个背景的情况，由background-blend-mode属性设置混合模式。当混合多个背景时，会从后往前进行混合。如果包含背景色，那么首先由背景色与最下层的背景图混合，其结果再与次下层的背景图混合，以此类推。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，包含两个div元素，都使用lighten混合，其中第二个div元素包含背景色。两个元素的混合效果如下图所示，左侧无背景色，右侧有背景色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(./avatar.png) no-repeat center,
            url(./lake.png)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 40% 40%, cover&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background-blend-mode&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; lighten&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .color &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201512523-1130382678.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，background-blend-mode属性可接收多种混合模式，用逗号分隔，样式如下，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  background-blend-mode&lt;/span&gt;:&lt;span&gt; lighten, hard-light&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201601244-682197301.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　在合成的过程中，还可通过isolation属性隔离混合，即让那些元素自成一组。注意，isolation属性需要声明到某个容器元素中，并且不能和混合模式存在于同一个元素上。&lt;/p&gt;
&lt;p&gt;　　接下来用一个简单的例子来演示isolation属性的用法，首先创建HTML结构，section是img的祖先元素，div是img的父元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./avatar.png&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;blend&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;isolation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./avatar.png&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;blend&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后添加CSS样式，将混合模式声明在img元素上，第二个div元素定义了isolation属性。得到的效果如下图所示，左侧的祖先元素的背景会与图像混合，而右侧因为发生了隔离，所以就不会与背景混合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; linear-gradient(to right, #3081F2 10%, #FC0 66%, #F60)&lt;/span&gt;;
}&lt;span&gt;
.blend &lt;/span&gt;{&lt;span&gt;
  mix-blend-mode&lt;/span&gt;:&lt;span&gt; lighten&lt;/span&gt;;
}&lt;span&gt;
.isolation &lt;/span&gt;{&lt;span&gt;
  isolation&lt;/span&gt;:&lt;span&gt; isolate&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200320201758866-1384356154.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，建立层叠上下文的元素可自动独立，而不受isolation属性的影响，能发生层叠上下文的情形包括：&lt;/p&gt;
&lt;p&gt;　　（1）文档根元素，例如html元素。&lt;/p&gt;
&lt;p&gt;　　（2）相对或绝对定位且z-index属性值不为auto的元素。&lt;/p&gt;
&lt;p&gt;　　（3）固定或粘滞定位的元素。&lt;/p&gt;
&lt;p&gt;　　（4）弹性盒的子元素，且z-index属性值不为auto。&lt;/p&gt;
&lt;p&gt;　　（5）网格容器的子元素，且z-index属性值不为auto。&lt;/p&gt;
&lt;p&gt;　　（6）opacity属性值小于1的元素。&lt;/p&gt;
&lt;p&gt;　　（7）mix-blend-mode属性值不为normal的元素。&lt;/p&gt;
&lt;p&gt;　　（8）transform、filter、perspective、clip-path、mask、mask-image和mask-border属性值不为none的元素。&lt;/p&gt;
&lt;p&gt;　　（9）isolation属性值为isolate的元素。&lt;/p&gt;
&lt;p&gt;　　（10）-webkit-overflow-scrolling属性值为touch的元素。&lt;/p&gt;
&lt;p&gt;　　（11）contain属性值为layout、paint或包含它们其中之一的合成值（例如strict、content）的元素。&lt;/p&gt;
&lt;p&gt;　　（12）为will-change定义任一属性。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 23:20:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>在图形编辑软件中，可以按特定地方式处理不同图层的合成，最新的CSS规范也引入了该功能，并提供了mix-blend-mode和background-blend-mode两个属性。混合模式（blendin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12534459.html</dc:identifier>
</item>
<item>
<title>C# 基础知识系列-13 常见类库（三） - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12791614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12791614.html</guid>
<description>&lt;p&gt;在《C# 基础知识系列- 13 常见类库（二）》中，我们介绍了一下DateTime和TimeSpan这两个结构体的内容，也就是C#中日期时间的简单操作。本篇将介绍Guid和Nullable这两个内容。&lt;/p&gt;

&lt;p&gt;Guid(Globally Unique Identifier) 全局唯一标识，是一种由算法生成的二进制长度为128位的字符串，但字符串的长度是36其中32位16进制的数字和四个连接符。其作用是用来表示全局唯一标识，当多个系统或者数据量大的时候，用来做唯一标识，比如说数据库的主键。Guid并不是C#独有的，所以可以放心使用，不用担心跟其他系统交互时遇到对方无法识别的尴尬局面。&lt;/p&gt;
&lt;p&gt;Guid应用非常广泛，如果有查看过Windows系统注册表的同学应该见过如下类型的数据：&lt;code&gt;efa4bcc8-b293-48d5-9278-924b9c015b97&lt;/code&gt; ，这就是Guid。Guid甚至被Windows用作组件注册，网络接口标识等。&lt;/p&gt;
&lt;p&gt;简单来讲，Guid适合需要不重复标识的场景。&lt;/p&gt;
&lt;h2 id=&quot;11-创建一个guid&quot;&gt;1.1 创建一个Guid&lt;/h2&gt;
&lt;p&gt;Guid的创建非常简单直接通过&lt;code&gt;Guid.NewGuid()&lt;/code&gt;，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        Guid guid = Guid.NewGuid();
        Console.WriteLine(guid);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多次运行以上代码将会出现不同的结果，这是我的一次运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;66168bfa-8c3b-45ce-a340-da99c668fca8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，创建Guid就可以认为达到目的了，但是我们一起来看下Guid有哪些构造函数吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public Guid (byte[] b); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用长度为16的字节数组初始化一个Guid，其中Guid的值与字节数组相关。（根据定义来理解，C#会将字节数组b转换为128位的二进制数据，再转换为字符串格式）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var bytes = new byte[16]
        {
            12,23,59,29,93,22,22,19,45,37,53,38,54,46,33,11
        };
        Guid guid = new Guid(bytes);
        Console.WriteLine(guid);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多次运行，打印结果都是以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;1d3b170c-165d-1316-2d25-3526362e210b
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上可以得知，是通过一个字节数组创建一个Guid元素，这个元素的值就是这个字节数组的值。&lt;/p&gt;
&lt;p&gt;继续介绍第二个构造方法，通过格式化的字符串创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public Guid (string g);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;g表示Guid数据，有以下几种格式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dddddddddddddddddddddddddddddddd 表示32个连续数字&lt;/li&gt;
&lt;li&gt;dddddddd-dddd-dddd-dddd-dddddddddddd 表示 8、4、4、4 和 12 位数字的分组，可以用小括号和大括号包裹起来&lt;/li&gt;
&lt;li&gt;{0xdddddddd, 0xdddd, 0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}8、4 和 4 位数字的分组，和一个 8 组 2 位数字的子集，每组都带有前缀“0x”或“0X”，以逗号分隔&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该方法接受以上格式的Guid字符串，以下是示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;string[] guidStrings = { &quot;ca761232ed4211cebacd00aa0057b223&quot;,
                         &quot;CA761232-ED42-11CE-BACD-00AA0057B223&quot;, 
                         &quot;{CA761232-ED42-11CE-BACD-00AA0057B223}&quot;, 
                         &quot;(CA761232-ED42-11CE-BACD-00AA0057B223)&quot;, 
                         &quot;{0xCA761232, 0xED42, 0x11CE, {0xBA, 0xCD, 0x00, 0xAA, 0x00, 0x57, 0xB2, 0x23}}&quot; };
foreach (var guidString in guidStrings)
{
    var guid = new Guid(guidString);
    Console.WriteLine($&quot;Original string: {guidString}&quot;);
    Console.WriteLine($&quot;Guid:            {guid}&quot;);
    Console.WriteLine();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200428061649061-1891686106.png&quot; alt=&quot;image-20200427212857426&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过指定的整数和字节数组初始化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public Guid (int a, short b, short c, byte[] d);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中a 表示前四个字节，也就是第一个分隔符前面的八位，b表示之后两个字节，c表示b之后的两个字节，d表示其余八个字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Guid(1,2,3,new byte[]{0,1,2,3,4,5,6,7}) 创建对应于 &quot;00000001-0002-0003-0001-020304050607&quot; 的 Guid。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次指定各个位置的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public Guid (int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法与上一个类似，不过分的更细致了，其中int四个字节，byte一个字节，与类型的实际字节长度一致。&lt;/p&gt;
&lt;h2 id=&quot;12-一个空的guid&quot;&gt;1.2 一个空的Guid&lt;/h2&gt;
&lt;p&gt;C# 为Guid结构体提供了一个静态只读属性：&lt;code&gt;Empty&lt;/code&gt;，其值均为零，表示Guid的零值。很多接口或系统会为Guid类型的字段提供一个默认零值就是这个值，在一些业务场景中会遇到与零值的相等判断。&lt;/p&gt;
&lt;h2 id=&quot;13-guid与字符串之间一个转身&quot;&gt;1.3 Guid与字符串之间一个转身&lt;/h2&gt;
&lt;p&gt;根据Guid构造函数可以看到Guid的打印格式应该有三种，那么如何生成这三种呢？C#还有没有更多的格式支持呢？&lt;/p&gt;
&lt;p&gt;Guid的ToString方法有以下三个版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override string ToString ();
public string ToString (string format);
public string ToString (string format, IFormatProvider provider);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个是默认的转字符串的方法，格式在上文也有介绍。最后一个涉及到国际化，略过不提。第二个，则是用格式确定输出结果。C# 支持的format值和对应的意义如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;说明符&lt;/th&gt;
&lt;th&gt;返回值的格式&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32位数： 00000000000000000000000000000000&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32的数字，由连字符分隔： 00000000-0000-0000-0000-000000000000&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32位，用连字符隔开，括在大括号中： {00000000-0000-0000-0000-000000000000}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;32位，用连字符隔开，括在括号中： (00000000-0000-0000-0000-000000000000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;括在大括号中的四个十六进制值，其中第四个值是八个十六进制值的子集（也括在大括号中）： {0x00000000，0x0000，0x0000，{0x00，0x00，0x00，0x00，0x00，0x00，0x00，0x00}}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果fomat为NULL或者空字符串，则默认为D。&lt;/p&gt;
&lt;p&gt;这里介绍了Guid生成字符串的方法和对应的格式内容，而字符串转Guid除了使用构造函数以外还有两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static Guid Parse (string input);
public static Guid ParseExact (string input, string format);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个方法由C#自动解析字符串格式，第二种由调用方明确指出字符串的格式。格式仅支持N/D/B/P/X这五种。&lt;/p&gt;

&lt;p&gt;我们常用的基本数据类型，包括这两篇介绍的类型除了string是类，其他都是&lt;code&gt;struct&lt;/code&gt;类型。在C#中&lt;code&gt;struct&lt;/code&gt;无法置为NULL，一般情况下并不影响程序的运行。但是，如果涉及到交互，无论是与人还是与其他的系统交互，都会出现数据不可用的情况。举例来说，一场数学考试，对于每个学生来说都会有一个数字类型的试卷成绩。如果有同学因为生病了缺考了，我们直接给他试卷上标记零分显然是不可取的，所以需要标记为NULL，意思是缺考。这时候如果在系统中简单的使用 int或者double存成绩就会出现NULL无法存入系统。&lt;/p&gt;
&lt;p&gt;C#为了解决此类问题，添加了Nullable&amp;lt;T&amp;gt;，这是个结构体，C#为此添加了额外的支持。我们看下如何声明一个可空的int类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Nullable&amp;lt;int&amp;gt; score;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C# 除了以上的声明方式，还提供了一种特殊的语法，使用?：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;int? score;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是&lt;code&gt;类型?&lt;/code&gt; 表示&amp;lt;类型&amp;gt; 的可空类型。&lt;/p&gt;
&lt;h2 id=&quot;21-可空类型的使用&quot;&gt;2.1 可空类型的使用&lt;/h2&gt;
&lt;p&gt;可空类型可以跟其原类型一样正常使用，包括原类型支持的算术运算等。不过值得注意的一点是，如果可控类型的值为null，在和其他非null值进行计算后，最终结果只能是null。&lt;/p&gt;
&lt;p&gt;C# 为可空类型的值判断和读取提供了两个属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public bool HasValue { get; }
public T Value { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果HasValue为True，则表示Value可以正确读取到值，否则这个可控类型就是null。&lt;/p&gt;
&lt;p&gt;以上是Nullable的使用介绍，使用起来很简单，但是这是C#中一个很重要的地方。&lt;/p&gt;

&lt;p&gt;这是《C# 基础知识系列-常见类库》的最后一篇，但并不意味着C#的常见类只有这么多，后面还有很多内容。放心吧，都会在以后的篇幅中为大家一一介绍的。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://blogs.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200428061649564-515089269.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 22:17:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 在《C 基础知识系列 13 常见类库（二）》中，我们介绍了一下DateTime和TimeSpan这两个结构体的内容，也就是C 中日期时间的简单操作。本篇将介绍Guid和Nullable这两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12791614.html</dc:identifier>
</item>
<item>
<title>计算某天的下一天：黑盒测试之等价类划分+JUnit参数化测试 - 臭咸鱼</title>
<link>http://www.cnblogs.com/chouxianyu/p/12791558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chouxianyu/p/12791558.html</guid>
<description>&lt;p&gt;测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12、1≤day≤31和1900≤year≤2050)，分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。例如，输入为2004年11月30日，则该程序的输出为2004年12月1日。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;划分等价类，按照等价类划分法设计测试用例；&lt;/li&gt;
&lt;li&gt;编写getNextDate函数；&lt;/li&gt;
&lt;li&gt;掌握Junit4的用法，使用Junit4测试getNextDate函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设输入格式为year,month,day，且三个输入变量year、month和day均被输入，等价类划分如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190527%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E8%A1%A8.jpg&quot; alt=&quot;等价类划分表.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照题意则确实按上表这样划分等价类；按照实际情况则应考虑2月的特殊性。在本次实验中，我按照题意划分等价类；考虑到2月的特殊性，在根据有效等价类和无效等价类设计测试用例之外，我额外设计了4个测试用例&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;有效等价类测试用例&quot;&gt;有效等价类测试用例&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;期望结果&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;覆盖范围&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2004/11/30&lt;/td&gt;
&lt;td&gt;2004/12/1&lt;/td&gt;
&lt;td&gt;1,5,9&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;无效等价类测试用例&quot;&gt;无效等价类测试用例&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;期望结果&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;覆盖范围&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1899/6/1&lt;/td&gt;
&lt;td&gt;year非法&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2051/6/1&lt;/td&gt;
&lt;td&gt;year非法&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;a/6/1&lt;/td&gt;
&lt;td&gt;year非法&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/0/1&lt;/td&gt;
&lt;td&gt;month非法&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/13/1&lt;/td&gt;
&lt;td&gt;month非法&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/a/1&lt;/td&gt;
&lt;td&gt;month非法&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/1/0&lt;/td&gt;
&lt;td&gt;day非法&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/1/32&lt;/td&gt;
&lt;td&gt;day非法&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/1/a&lt;/td&gt;
&lt;td&gt;day非法&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;针对2月设计的等价类测试用例&quot;&gt;针对2月设计的等价类测试用例&lt;/h2&gt;
&lt;p&gt;因为闰年的2月有29天、非闰年的2月有28天，所以题目中对于year、month和day三个变量的要求不够严谨，所以再设计4个用例。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;期望结果&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;覆盖范围&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2000/2/30&lt;/td&gt;
&lt;td&gt;day非法&lt;/td&gt;
&lt;td&gt;闰年day非法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2000/2/29&lt;/td&gt;
&lt;td&gt;2000/3/1&lt;/td&gt;
&lt;td&gt;闰年day合法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/2/29&lt;/td&gt;
&lt;td&gt;day非法&lt;/td&gt;
&lt;td&gt;非闰年day非法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1999/2/28&lt;/td&gt;
&lt;td&gt;1999/3/1&lt;/td&gt;
&lt;td&gt;非闰年day合法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;其它测试用例&quot;&gt;其它测试用例&lt;/h2&gt;
&lt;p&gt;上文中的等价类测试用例其实只测试了输入是否合法，而并未关注程序的功能是否实现。因此可以从功能角度出发设计测试用例，举例如下。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;期望结果&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;覆盖范围&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2000/12/31&lt;/td&gt;
&lt;td&gt;2001/1/1&lt;/td&gt;
&lt;td&gt;31天的月份，month进位，day进位&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;​ 项目结构如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190552%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg&quot; alt=&quot;项目结构.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dateutiljava&quot;&gt;DateUtil.java&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.company;

public class DateUtil {
    // 有31天的月份
    private static int[] monthOfThirtyOne = new int[]{1,3,5,7,8,10,12};
    // 有30天的月份
    private static int[] monthOfThirty = new int[]{4,6,9,11};
    // 年月日
    private int year;
    private int month;
    private int day;

    // 最终实现的功能，输入是一个“年/月/日”格式的字符串；
    // 如果函数运行成功，输出则是相同格式的下一天，否则是错误信息
    public String getNextDate(String dateStr){
        String updateResult = this.updateDate(dateStr);
        // 如果输入合法
        if (updateResult.equals(&quot;success&quot;)){
            String checkResult = this.checkDate();
            // 如果输入合法
            if (checkResult.equals(&quot;valid&quot;)){
                // 计算明天的日期
                return this.calcNextDate();
            }
            return checkResult;
        }
        return updateResult;
    }

    // 根据输入字符串转换并更新年月日
    private String updateDate(String dateStr){
        // 获取年月日
        String[] numbers = dateStr.split(&quot;/&quot;);
        try{
            this.year = Integer.parseInt(numbers[0]);
        }catch (NumberFormatException e){
            return &quot;year非法&quot;;
        }
        try{
            this.month = Integer.parseInt(numbers[1]);
        }catch (NumberFormatException e){
            return &quot;month非法&quot;;
        }
        try{
            this.day = Integer.parseInt(numbers[2]);
        }catch (NumberFormatException e){
            return &quot;day非法&quot;;
        }
        return &quot;success&quot;;
    }

    // 检查日期是否合法
    private String checkDate(){
        String valid = &quot;valid&quot;;
        String yearInvalid = &quot;year非法&quot;;
        String monthInvalid = &quot;month非法&quot;;
        String dayInvalid = &quot;day非法&quot;;
        // year合法
        if (year&amp;gt;=1900&amp;amp;&amp;amp;year&amp;lt;=2050){
            // month合法
            if (month&amp;gt;=1&amp;amp;&amp;amp;month&amp;lt;=12){
                // day小于1
                if (day&amp;lt;=0){
                    return dayInvalid;
                }
                // 至此能保证day大于0

                // 是2月
                if (month==2){
                    // 闰年
                    if (yearIsLeap(year)){
                        // 1-29
                        if (day&amp;lt;=29){
                            return valid;
                        }else{
                            return dayInvalid;
                        }
                    }
                    // 平年2月
                    else{
                        // 1-28
                        if (day&amp;lt;=28){
                            return valid;
                        }else{
                            return dayInvalid;
                        }
                    }
                }

                // 至此能保证不是2月

                // 是否为31天的月
                for(int i=0;i&amp;lt;7;++i){
                    if (month==monthOfThirtyOne[i]){
                        // 1-31
                        if (day&amp;lt;=31){
                            return valid;
                        }else{
                            return dayInvalid;
                        }
                    }
                }

                // 至此能保证不是2月和31天的月

                // 是否为30天的月
                for(int i=0;i&amp;lt;4;++i){
                    if (month==monthOfThirty[i]){
                        // 1-30
                        if (day&amp;lt;=30){
                            return valid;
                        }else{
                            return dayInvalid;
                        }
                    }
                }
            }
            // month非法
            else{
                return monthInvalid;
            }
        }

        // year非法
        return yearInvalid;
    }

    // 计算下一天
    private String calcNextDate(){
        int yearNext;
        int monthNext;
        int dayNext=day+1;
        int dayCarry=0;
        int monthCarry=0;

        // 处理day
        // 是2月
        if (month==2){
            // 闰年
            if (yearIsLeap(year)){
                // 1-29
                if (day==29){
                    dayNext = 1;
                    dayCarry = 1;
                }
            }
            // 平年2月
            else{
                // 1-28
                if (day==28){
                    dayNext = 1;
                    dayCarry = 1;
                }
            }
        }
        // 不是2月
        else{
            boolean isThirtyOne= false;
            // 是否为31天的月
            for(int i=0;i&amp;lt;7;++i){
                if (month==monthOfThirtyOne[i]){
                    isThirtyOne = true;
                    // 1-31
                    if (day==31){
                        dayNext = 1;
                        dayCarry = 1;
                    }
                    break;
                }
            }

            // 至此能保证是30天的月
            if (!isThirtyOne){
                // 1-30
                if (day==30){
                    dayNext = 1;
                    dayCarry = 1;
                }
            }
        }

        // 处理月
        if (month+dayCarry&amp;gt;12){
            monthNext = 1;
            monthCarry = 1;
        }else{
            monthNext = month+dayCarry;
        }

        //  处理年
        yearNext = year+monthCarry;

        return yearNext +&quot;/&quot;+ monthNext +&quot;/&quot;+ dayNext;
    }

    // 判断某一年是否为闰年
    private boolean yearIsLeap(int year){
        // 普通闰年和世纪闰年
        if ((year%4==0&amp;amp;&amp;amp;year%100!=0)||(year%400==0)){
            return true;
        }

        // 平年
        return false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dateutiltestjava&quot;&gt;DateUtilTest.java&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.test;

import com.company.DateUtil;

import static org.junit.Assert.*;
import org.junit.Test;

//1、参数化测试：引入相关的包和类
import java.util.Collection;
import java.util.Arrays;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class) //2、参数化测试：更改测试运行器为RunWith(Parameterized.class)
public class DateUtilTest {
    //3、参数化测试：声明变量用来存放预期值与结果值
    private DateUtil util = new DateUtil();
    private String date;
    private String except;

    //4、参数化测试：声明一个返回值为 Collection 的公共静态方法，并使用@Parameters 进行修饰
    @Parameters
    public static Collection data(){
        return Arrays.asList(new Object[][]{
                {&quot;2004/11/30&quot;, &quot;2004/12/1&quot;},
                {&quot;1899/6/1&quot;, &quot;year非法&quot;},
                {&quot;2051/6/1&quot;, &quot;year非法&quot;},
                {&quot;a/6/1&quot;, &quot;year非法&quot;},
                {&quot;1999/0/1&quot;, &quot;month非法&quot;},
                {&quot;1999/13/1&quot;, &quot;month非法&quot;},
                {&quot;1999/a/1&quot;, &quot;month非法&quot;},
                {&quot;1999/1/0&quot;, &quot;day非法&quot;},
                {&quot;1999/1/32&quot;, &quot;day非法&quot;},
                {&quot;1999/1/a&quot;, &quot;day非法&quot;},
                {&quot;2000/2/30&quot;, &quot;day非法&quot;},
                {&quot;2000/2/29&quot;, &quot;2000/3/1&quot;},
                {&quot;1999/2/29&quot;, &quot;day非法&quot;},
                {&quot;1999/2/28&quot;, &quot;1999/3/1&quot;},
                {&quot;2000/12/31&quot;, &quot;2001/1/1&quot;},
        });
    }

    //5、参数化测试：为测试类声明一个带有参数的公共构造方法，并在其中为声明变量赋值
    public DateUtilTest(String date, String except){
        this.date = date;
        this.except = except;
    }

    @Test
    public void testGetNextDate(){
        assertEquals(except, util.getNextDate(date));
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;​ 如下图所示，15个测试用例均测试成功，程序实际输出与期望值相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190603%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg&quot; alt=&quot;测试结果.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本次实验的主要目的是巩固黑盒测试方法中的等价类划分法的知识，练习JUnit的参数化测试。在本次实验中，我认为我的getNextDate函数的实现并不是很优雅，比较过程化。写这个函数花了我很多时间，主要问题在于我没有抓住一些关键的、抽象的逻辑和子函数，比如天向月份进位和月份向年份完全可以参照加法器的循环、可以写一个函数根据年份和月份判断出天数的最大值等等。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：&lt;a href=&quot;https://github.com/chouxianyu&quot;&gt;@臭咸鱼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/chouxianyu/&quot;&gt;https://www.cnblogs.com/chouxianyu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎讨论和交流!&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Mon, 27 Apr 2020 19:14:00 +0000</pubDate>
<dc:creator>臭咸鱼</dc:creator>
<og:description>题目要求 测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12、1≤day≤31和1900≤year≤2050)，分别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chouxianyu/p/12791558.html</dc:identifier>
</item>
<item>
<title>23-Java-Spring框架(一) - 我只是一个码农</title>
<link>http://www.cnblogs.com/qinqin-me/p/12764934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinqin-me/p/12764934.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、Spring框架了解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Spring框架是一个开源的框架，为JavaEE应用提供多方面的解决方案，用于简化企业级应用的开发，相当于是一种容器，可以集成其他框架(结构图如下)。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200424004532941-152842277.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;上图反映了框架引包的依赖关系(例如：DAO的jar包依赖AOP的jar包，AOP的jar包依赖Core的jar包)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;上图也反映了Spring功能有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　IOC:控制反转，Spring的核心功能&lt;/p&gt;
&lt;p&gt;　　　　　　　　AOP:面向切面编程&lt;/p&gt;
&lt;p&gt;　　　　　　　　Web:MVC结构实现、与其他Web技术融合&lt;/p&gt;
&lt;p&gt;　　　　　　　　DAO:与JDBC整合和事务管理&lt;/p&gt;
&lt;p&gt;　　　　　　　　ORM:与ORM对象映射实现的框架整合&lt;/p&gt;
&lt;p&gt;　　　　　　　　JEE:与JavaEE服务整合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、SpringIOC（Inversion Of Control）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　       SpringIOC控制反转,是指程序中对象的获取方式发生反转，由最初的new方式创建，转为由框架创建注入，这样可以降低对象之间的耦合度。&lt;/p&gt;
&lt;p&gt;　　　　IOC的主要作用是管理程序的组件，创建组件对象和维护对象之间的关系。&lt;/p&gt;
&lt;p&gt;　　　　Spring容器：在Spring中，任何的Java类都被当成Bean组件，通过容器管理和使用，Spring容器实现了IOC和AOP机制，&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;Spring容器有ApplicationContext和BeanFactory两种类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　ApplicationContext继承自BeanFactory，提供了更多的方法，建议使用ApplicationContext。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200425223415498-1724208269.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200425223422716-1971409416.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;ApplicationContext实例化途径：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.从classpath下加载配置文件实例化:ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　2.从文件系统中加载配置文件实例化:ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;D:\\applicationContext.xml&quot;);&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;Bean对象的创建：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　   &lt;strong&gt;Spring容器创建Bean对象有三种方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　1.使用构造器来实例化&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　2.使用静态工厂方法来实例化&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　3.使用动态(实例)工厂方法来实例化&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;Spring容器创建Bean对象的步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第一步：&lt;/strong&gt;导入SpringIOC相关包到WebRoot/WBE-INF/lib下&lt;strong&gt;(想要相关包的网友请留言私聊)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　commons-logging-1.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　spring-beans-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　spring-context-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　spring-context-support-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　spring-core-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　spring-expression-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第二步：&lt;/strong&gt;编写实体类和实体工厂类&lt;/p&gt;
&lt;p&gt;实体类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;package&lt;span&gt; com.springioc.entity;
&lt;span&gt; 2 
&lt;span&gt; 3 &lt;span&gt;public &lt;span&gt;class&lt;span&gt; User {
&lt;span&gt; 4     &lt;span&gt;private&lt;span&gt; Integer id;
&lt;span&gt; 5     &lt;span&gt;private&lt;span&gt; String username;
&lt;span&gt; 6     &lt;span&gt;private&lt;span&gt; String password;
&lt;span&gt; 7     &lt;span&gt;public&lt;span&gt; User() {
&lt;span&gt; 8         &lt;span&gt;super&lt;span&gt;();
&lt;span&gt; 9         &lt;span&gt;//&lt;span&gt; TODO Auto-generated constructor stub
&lt;span&gt;10 &lt;span&gt;    }
&lt;span&gt;11     &lt;span&gt;public&lt;span&gt; User(Integer id, String username, String password) {
&lt;span&gt;12         &lt;span&gt;super&lt;span&gt;();
&lt;span&gt;13         &lt;span&gt;this.id =&lt;span&gt; id;
&lt;span&gt;14         &lt;span&gt;this.username =&lt;span&gt; username;
&lt;span&gt;15         &lt;span&gt;this.password =&lt;span&gt; password;
&lt;span&gt;16 &lt;span&gt;    }
&lt;span&gt;17     &lt;span&gt;public&lt;span&gt; Integer getId() {
&lt;span&gt;18         &lt;span&gt;return&lt;span&gt; id;
&lt;span&gt;19 &lt;span&gt;    }
&lt;span&gt;20     &lt;span&gt;public &lt;span&gt;void&lt;span&gt; setId(Integer id) {
&lt;span&gt;21         &lt;span&gt;this.id =&lt;span&gt; id;
&lt;span&gt;22 &lt;span&gt;    }
&lt;span&gt;23     &lt;span&gt;public&lt;span&gt; String getUsername() {
&lt;span&gt;24         &lt;span&gt;return&lt;span&gt; username;
&lt;span&gt;25 &lt;span&gt;    }
&lt;span&gt;26     &lt;span&gt;public &lt;span&gt;void&lt;span&gt; setUsername(String username) {
&lt;span&gt;27         &lt;span&gt;this.username =&lt;span&gt; username;
&lt;span&gt;28 &lt;span&gt;    }
&lt;span&gt;29     &lt;span&gt;public&lt;span&gt; String getPassword() {
&lt;span&gt;30         &lt;span&gt;return&lt;span&gt; password;
&lt;span&gt;31 &lt;span&gt;    }
&lt;span&gt;32     &lt;span&gt;public &lt;span&gt;void&lt;span&gt; setPassword(String password) {
&lt;span&gt;33         &lt;span&gt;this.password =&lt;span&gt; password;
&lt;span&gt;34 &lt;span&gt;    }
&lt;span&gt;35 &lt;span&gt;    @Override
&lt;span&gt;36     &lt;span&gt;public &lt;span&gt;int&lt;span&gt; hashCode() {
&lt;span&gt;37         &lt;span&gt;final &lt;span&gt;int prime = 31&lt;span&gt;;
&lt;span&gt;38         &lt;span&gt;int result = 1&lt;span&gt;;
&lt;span&gt;39         result = prime * result + ((id == &lt;span&gt;null) ? 0&lt;span&gt; : id.hashCode());
&lt;span&gt;40         result = prime *&lt;span&gt; result
&lt;span&gt;41                 + ((password == &lt;span&gt;null) ? 0&lt;span&gt; : password.hashCode());
&lt;span&gt;42         result = prime *&lt;span&gt; result
&lt;span&gt;43                 + ((username == &lt;span&gt;null) ? 0&lt;span&gt; : username.hashCode());
&lt;span&gt;44         &lt;span&gt;return&lt;span&gt; result;
&lt;span&gt;45 &lt;span&gt;    }
&lt;span&gt;46 &lt;span&gt;    @Override
&lt;span&gt;47     &lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; equals(Object obj) {
&lt;span&gt;48         &lt;span&gt;if (&lt;span&gt;this ==&lt;span&gt; obj)
&lt;span&gt;49             &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
&lt;span&gt;50         &lt;span&gt;if (obj == &lt;span&gt;null&lt;span&gt;)
&lt;span&gt;51             &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;52         &lt;span&gt;if (getClass() !=&lt;span&gt; obj.getClass())
&lt;span&gt;53             &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;54         User other =&lt;span&gt; (User) obj;
&lt;span&gt;55         &lt;span&gt;if (id == &lt;span&gt;null&lt;span&gt;) {
&lt;span&gt;56             &lt;span&gt;if (other.id != &lt;span&gt;null&lt;span&gt;)
&lt;span&gt;57                 &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;58         } &lt;span&gt;else &lt;span&gt;if (!&lt;span&gt;id.equals(other.id))
&lt;span&gt;59             &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;60         &lt;span&gt;if (password == &lt;span&gt;null&lt;span&gt;) {
&lt;span&gt;61             &lt;span&gt;if (other.password != &lt;span&gt;null&lt;span&gt;)
&lt;span&gt;62                 &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;63         } &lt;span&gt;else &lt;span&gt;if (!&lt;span&gt;password.equals(other.password))
&lt;span&gt;64             &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;65         &lt;span&gt;if (username == &lt;span&gt;null&lt;span&gt;) {
&lt;span&gt;66             &lt;span&gt;if (other.username != &lt;span&gt;null&lt;span&gt;)
&lt;span&gt;67                 &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;68         } &lt;span&gt;else &lt;span&gt;if (!&lt;span&gt;username.equals(other.username))
&lt;span&gt;69             &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
&lt;span&gt;70         &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
&lt;span&gt;71 &lt;span&gt;    }
&lt;span&gt;72 &lt;span&gt;    @Override
&lt;span&gt;73     &lt;span&gt;public&lt;span&gt; String toString() {
&lt;span&gt;74         &lt;span&gt;return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot;
&lt;span&gt;75                 + password + &quot;]&quot;&lt;span&gt;;
&lt;span&gt;76 &lt;span&gt;    }
&lt;span&gt;77     
&lt;span&gt;78 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实体工厂类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;package&lt;span&gt; com.springioc.entity;
&lt;span&gt; 2 
&lt;span&gt; 3 &lt;span&gt;public &lt;span&gt;class&lt;span&gt; UserFactory {
&lt;span&gt; 4     &lt;span&gt;public &lt;span&gt;static&lt;span&gt; User CreateUser(){
&lt;span&gt; 5         &lt;span&gt;return &lt;span&gt;new&lt;span&gt; User();
&lt;span&gt; 6 &lt;span&gt;    }
&lt;span&gt; 7     
&lt;span&gt; 8     &lt;span&gt;public&lt;span&gt; User DynamicCreateUser(){
&lt;span&gt; 9         &lt;span&gt;return &lt;span&gt;new&lt;span&gt; User();
&lt;span&gt;10 &lt;span&gt;    }
&lt;span&gt;11 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第三步：&lt;/strong&gt;编写实例化配置文件applicationContext.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;       xmlns:jdbc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jdbc&quot;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;       xmlns:jee&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;       xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;       xmlns:util&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/util&quot;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;             
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ************************************************************************************************************************ &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在容器配置文件applicationContext中添加bean的定义，等价于将Bean组件放入Spring容器，后续由Spring负责创建对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在容器中最基本的单位就是bean标签，一个bean标签代表一个对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 默认情况下，每一个bean都是单例的，在单例(singleton)情况下，随容器的创建而创建，随着容器的销毁而销毁 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Bean创建对象的三种方式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 1.构造器 
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            语法格式：    
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                     &amp;lt;bean id=&quot;对象标识符&quot; class=&quot;对象权限定名&quot;&amp;gt;&amp;lt;/bean&amp;gt; 
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            举例：
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;                    &amp;lt;bean id=&quot;user&quot; class=&quot;com.springioc.entity.User&quot;&amp;gt;&amp;lt;/bean&amp;gt;    
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 2.静态工厂 
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;            语法格式：    
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                     &amp;lt;bean id=&quot;静态工厂标识符&quot; class=&quot;工厂权限定名&quot; factory-method=&quot;静态方法名&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            举例：
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;                    &amp;lt;bean id=&quot;staticFactory&quot; class=&quot;com.springioc.entity.UserFactory&quot; factory-method=&quot;CreateUser&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 3.动态(实例)工厂 
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            语法格式:
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;                    &amp;lt;bean id=&quot;工厂标识符&quot; class=&quot;工厂权限定名&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                     &amp;lt;bean id=&quot;动态工厂标识符&quot; factory-bean=&quot;工厂标识符&quot; factory-method=&quot;动态方法名&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            举例：
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                    &amp;lt;bean id=&quot;userFactory&quot; class=&quot;com.springioc.entity.UserFactory&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                    &amp;lt;bean id=&quot;dynamicCreateUser&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;DynamicCreateUser&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userFactory&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.springioc.entity.UserFactory&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dynamicCreateUser&quot;&lt;/span&gt;&lt;span&gt; factory-bean&lt;/span&gt;&lt;span&gt;=&quot;userFactory&quot;&lt;/span&gt;&lt;span&gt; factory-method&lt;/span&gt;&lt;span&gt;=&quot;DynamicCreateUser&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ************************************************************************************************************* &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Bean便签常用属性:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                id:bean对象标识符
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                factory-bean:bean对象创建工厂标识符
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;                class:权限定名
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                factory-method:对象创建工厂函数
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;                init-method:bean对象初始化方法名
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                destory-method:bean对象销毁方法名
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                lazy-init:延迟bean对象实例化，当设置为true的时候，不管是不是单例(singleton)，当调用getBean()的时候才会创建对象
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;             Beans标签常用属性:(作用于beans标签中的所有bean标签)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                default-init-method:默认bean对象初始化方法名
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                default-destory-method:默认bean对象销毁方法名
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                default-lazy-init:默认延迟bean对象实例化
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;          &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ************************************************************************************************************** &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Bean对象的参数注入
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                注入类型可以为字符串、集合、Bean对象
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                1.setter注入
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                    name:实体类属性名
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;                    value:注入参数的值
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                    ref:注入bean对象的值
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                    举例：
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                        &amp;lt;bean id = &quot;user&quot; class = &quot;com.springioc.entity.User&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                            &amp;lt;property name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                            &amp;lt;property name=&quot;username&quot; value=&quot;admin&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                            &amp;lt;property name=&quot;password&quot; value=&quot;123&quot;&amp;gt;&amp;lt;/property&amp;gt;    
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                        &amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;                    相当于之前 User user = new User();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                              user.setId(1);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                              user.setUsername(&quot;admin&quot;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                              user.setPassword(&quot;123&quot;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                2.构造器注入 
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    index:实体类构造函数的形参顺序，0表示第一个参数，1表示第二参数，2表示第三个参数...
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                    value:注入参数的值
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    ref:注入bean对象的值
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                    举例：
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                        &amp;lt;bean id = &quot;user&quot; class = &quot;com.springioc.entity.User&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                            &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;2&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                            &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;username&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                            &amp;lt;constructor-arg index=&quot;2&quot; value=&quot;password&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                        &amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                注意：(以上两种注入方式都是以字符串的注入类型来举例的，下面是Bean对象注入和集合注入)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    Bean对象的注入:如果一个实体类中的属性是另一个实体类时，注入时需将property标签的value属性改为ref属性
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                    集合注入:(集合有set,list,map,props)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                        概述：假设一个实体类的属性中有集合，那么参数注入集合应该采用集合注入
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                        举例:
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                            &amp;lt;bean id = &quot;girl&quot; class = &quot;com.springioc.entity.Girl&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                                &amp;lt;property name=&quot;glist&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                                    &amp;lt;list&amp;gt;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                                        &amp;lt;value&amp;gt;范冰冰&amp;lt;/value&amp;gt;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                                        &amp;lt;value&amp;gt;杨幂&amp;lt;/value&amp;gt;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                                        &amp;lt;value&amp;gt;王祖贤&amp;lt;/value&amp;gt;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                                    &amp;lt;/list&amp;gt;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                                &amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                                &amp;lt;property name=&quot;gset&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                                    &amp;lt;set&amp;gt;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                                        &amp;lt;ref bean = &quot;user1&quot;/&amp;gt;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                                        &amp;lt;ref bean = &quot;user2&quot;/&amp;gt;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                                    &amp;lt;/set&amp;gt;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                                &amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                                &amp;lt;property name=&quot;gmap&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                                    &amp;lt;map&amp;gt;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                                        &amp;lt;entry key=&quot;美女&quot; value=&quot;杨幂&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                                        &amp;lt;entry key=&quot;美人&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                                            &amp;lt;value&amp;gt;范冰冰&amp;lt;/value&amp;gt;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                                        &amp;lt;/entry&amp;gt;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                                    &amp;lt;/map&amp;gt;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                                &amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                                &amp;lt;property name=&quot;gprops&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                                    &amp;lt;props&amp;gt;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;                                        &amp;lt;prop key=&quot;美女&quot;&amp;gt;杨幂&amp;lt;/prop&amp;gt;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                                        &amp;lt;prop key=&quot;美人&quot;&amp;gt;范冰冰&amp;lt;/prop&amp;gt;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                                    &amp;lt;/props&amp;gt;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                                &amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                            &amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; *************************************************************************************************************** &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一个Bean对象参数注入的实例:加载JDBC驱动&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 加载资源文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第一步：先建一个文件，文件名为jdbc.properties,放在src/下,文件中写 admin=root
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                                                                            password=root
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;                                                                            url=jdbc:mysql://localhost:3306/test
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                                                                            JDBCdriver=com.mysql.jdbc.Driver
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                  第二步:在applicationContext.xml中写
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                      &amp;lt;util:properties id=&quot;jdbc&quot; location=&quot;classpath:jdbc.properties&quot;&amp;gt;&amp;lt;/util:properties&amp;gt;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置数据源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring引入一种表达式语言，它和EL的语法相似，可以读取一个Bean对象/集合中的数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 第一步:编写一个和jdbc.properties文件相对应的实体类JDBCTest，属性名需要相等 
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;                  第二步:在applicationContext.xml中写
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                      &amp;lt;bean id=&quot;jdbc&quot; class=&quot;com.springioc.test.JDBCTest&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;                          &amp;lt;property name=&quot;admin&quot; value=&quot;#{db.admin}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;                        &amp;lt;property name=&quot;root&quot; value=&quot;#{db.password}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;                        &amp;lt;property name=&quot;url&quot; value=&quot;#{db.url}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;                        &amp;lt;property name=&quot;JDBCdriver&quot; value=&quot;#{db.JDBCdriver}&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;                      &amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ************************************************************************************************************** &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第四步：&lt;/strong&gt;编写实例化测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;package&lt;span&gt; com.springioc.test;
&lt;span&gt; 2 
&lt;span&gt; 3 &lt;span&gt;import org.springframework.context.ApplicationContext;&lt;span&gt;//&lt;span&gt;spring-context.jar包中的
&lt;span&gt; 4 &lt;span&gt;import org.springframework.context.support.ClassPathXmlApplicationContext;&lt;span&gt;//&lt;span&gt;spring-context-support.jar包中的
&lt;span&gt; 5 
&lt;span&gt; 6 &lt;span&gt;import&lt;span&gt; com.springioc.entity.User;
&lt;span&gt; 7 
&lt;span&gt; 8 &lt;span&gt;public &lt;span&gt;class&lt;span&gt; ApplicationContextBuildUserTest {
&lt;span&gt; 9     &lt;span&gt;public &lt;span&gt;static &lt;span&gt;void&lt;span&gt; main(String[] args) {
&lt;span&gt;10         &lt;span&gt;//&lt;span&gt;以前的方式创建对象
&lt;span&gt;11 &lt;span&gt;//&lt;span&gt;        User user = new User();
&lt;span&gt;12 &lt;span&gt;//&lt;span&gt;        System.out.println(user);
&lt;span&gt;13         
&lt;span&gt;14         &lt;span&gt;//&lt;span&gt;现在使用Spring框架的容器来创建对象
&lt;span&gt;15             &lt;span&gt;//&lt;span&gt;第一步:创建Spring容器
&lt;span&gt;16         ApplicationContext ac = &lt;span&gt;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;span&gt;17         
&lt;span&gt;18             &lt;span&gt;/*&lt;span&gt;第二步:从ApplicationContext容器获取Bean对象
&lt;span&gt;19 &lt;span&gt;             * 1.构造器获取对象
&lt;span&gt;20 &lt;span&gt;             *         语法格式：
&lt;span&gt;21 &lt;span&gt;             *             类型名 变量名 = 容器对象.getBean(&quot;对象标识符&quot;,组件类型);
&lt;span&gt;22 &lt;span&gt;             *         举例：
&lt;span&gt;23 &lt;span&gt;             *             User user = ac.getBean(&quot;user&quot;, User.class);
&lt;span&gt;24 &lt;span&gt;             * 2.静态工厂获取对象
&lt;span&gt;25 &lt;span&gt;             *         语法格式：
&lt;span&gt;26 &lt;span&gt;             *             类型名 变量名 = 容器对象.getBean(&quot;静态工厂标识符&quot;,组件类型);
&lt;span&gt;27 &lt;span&gt;             *         举例：
&lt;span&gt;28 &lt;span&gt;             *             User user = ac.getBean(&quot;staticFactory&quot;, User.class);
&lt;span&gt;29 &lt;span&gt;             * &lt;span&gt;*/
&lt;span&gt;30         User user = ac.getBean(&quot;dynamicCreateUser&quot;, User.&lt;span&gt;class&lt;span&gt;);
&lt;span&gt;31 &lt;span&gt;        System.out.println(user);
&lt;span&gt;32 &lt;span&gt;    }
&lt;span&gt;33 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第五步：&lt;/strong&gt;运行结果&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200426095738086-2138777419.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;Bean对象的作用域：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;指定Spring容器创建Bean对象的作用域：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200426131643758-1714828564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;注意：&lt;/strong&gt;singleton单例模式，通过getBean获取的对象HashCode是相同的，即user1 = user2返回true&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　prototype多例模式，通过getBean获取的对象HashCode是不同的，即user1 = user2返回false&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;Bean对象的参数注入：&lt;/span&gt;&lt;/strong&gt;(看上面的applicationContext.xml中注释写的知识点)&lt;/p&gt;
&lt;p&gt;　　　　　　　　容器可以建立Bean对象之间的关系，实现技术途径就是DI注入，Spring DI注入setter注入和构造器注入两种&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;组件扫描：&lt;/strong&gt;&lt;/span&gt;Spring提供了一套基于注解配置的的使用方法，&lt;strong&gt;使用该方法可以大大简化XML的配置信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　开启组件扫描，可以利用注解方式应用IOC，使用方法如下：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;strong&gt;第一步：&lt;/strong&gt;除了需要引入springIOC相关jar包之外还需要引入SpringAOP相关jar包&lt;strong&gt;(需要相关jar包的网友请留言私聊)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　aopalliance-1.0.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　aspectjweaver-1.5.3.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　spring-aop-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　spring-aspects-4.1.6.RELEASE.jar&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;strong&gt;第二步：&lt;/strong&gt;在applicationContext.xml中添加启用标记(用了组件扫描就可以不用bean标签了)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　&amp;lt;context:component-scan base-package=&quot;包路径(用最大的，例如:com.springioc)&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　&lt;strong&gt;第三步：&lt;/strong&gt;在组件类中追加以下标记&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427152808903-1385763929.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　&lt;strong&gt;　注意：&lt;/strong&gt;1.扫描组件后，默认id值为组件类名首字母小写，也可以自定义id。例如：@Component(&quot;stu&quot;)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　2.扫描组件后，默认scope为singleton单例，也可以进行指定。例如：@Scope(&quot;prototyppe&quot;)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　3.也可以指定初始化和销毁的方法，例如，在组件类的方法前追加@PostConstruct来指定初始化方法，追加@PreDestory来指定销毁方法&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　4.将所有bean组件扫描到Spring容器后，可以使用以下注解指定注入关系&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　@Autowired/@Qulifier:可以处理构造器注入和setter注入&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　@Resource：只能处理Setter注入，但大部分情况都是setter注入&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　5.@Value注解可以注入Spring表达式值&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　首先读取db.properties文件，封装成Properties对象，在applicationContext.xml中添加&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;&amp;lt;util:properties id=&quot;jdbc&quot; location=&quot;classpath:jdbc.properties&quot;&amp;gt;&amp;lt;/util:properties&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　然后在组件类属性变量或Setter方法前使用@Value注解&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;@Value(&quot;#{db.url}&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　private String url;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　&lt;strong&gt;追加标记举例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Component&lt;span&gt;//默认实体类id名称是实体类名称(首字母小写)&lt;br/&gt;2 &lt;span&gt;@Scope(&quot;prototype&quot;)&lt;span&gt;//默认为单例模式，此处修改为多例模式&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　 &lt;strong&gt;第四步：&lt;/strong&gt;测试获取bean对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springioc.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.springframework.context.ApplicationContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring-context.jar包中的&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring-context-support.jar包中的&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.springioc.entity.User;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApplicationContextBuildUserTest {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ApplicationContext ac = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         User user = ac.getBean(&quot;user&quot;, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);&lt;span&gt;//此处的id：user是从@Component默认实体类id中得出来的
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427161806307-1255653221.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;SpringIOC实现解耦(重点理解)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;strong&gt;解耦主题：&lt;/strong&gt;通过hibernate和JDBC两种技术实现一个用户的删除操作&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;strong&gt;1.XML配置文件版的解耦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第一步：&lt;/strong&gt;编写用户实体类和用户DAO接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户DAO实现接口&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.usedao;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDAO {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第二步：&lt;/strong&gt;编写Hibernate技术和JDBC技术分别实现删除操作的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDBC实现DAO删除操作&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.usedao;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JDBCDAO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDAO{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(&quot;通过JDBC实现User删除&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hibernate实现DAO删除操作&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.usedao;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HibernateDAO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDAO{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(&quot;通过Hibernate实现User删除&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第三步：&lt;/strong&gt;编写一个控制用户删除操作的控制类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制类，控制删除操作&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.entity.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.springioc_Decoupling.usedao.UserDAO;

@Controller&lt;span&gt;//用于Spring框架管理
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDAO dao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDAO getDao() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDao(UserDAO dao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dao =&lt;span&gt; dao;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
        dao.delete();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第四步：&lt;/strong&gt;配置applicationContext.xml信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       xmlns:jdbc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jdbc&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;       xmlns:jee&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;       xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       xmlns:util&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/util&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;= &quot;jdao&quot;&lt;/span&gt;&lt;span&gt; class &lt;/span&gt;&lt;span&gt;= &quot;com.springioc_Decoupling.usedao.JDBCDAO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;= &quot;hdao&quot;&lt;/span&gt;&lt;span&gt; class &lt;/span&gt;&lt;span&gt;= &quot;com.springioc_Decoupling.usedao.HibernateDAO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;= &quot;ucontroller&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.springiocDecoupling.entity.Controller.UserController&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;jdao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;span&gt;&lt;strong&gt;&amp;lt;!--解耦操作就体现在此处，要用jdbc，ref属性修改为jdao就行了，要用hibernate，ref属性修改为hdao就行了--&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第五步：&lt;/strong&gt;编写测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.entity.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.springframework.context.ApplicationContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring-context.jar包中的&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring-context-support.jar包中的&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.entity.Controller.UserController;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApplicationContextBuildUserTest {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ApplicationContext ac = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         UserController ucon = ac.getBean(&quot;ucontroller&quot;, UserController.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        ucon.delete();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　&lt;strong&gt;　测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427172330339-1855779047.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427172428627-6896297.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;2.通过注解的方式进行解耦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第一步：&lt;/strong&gt;编写用户实体类和用户DAO接口&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第二步：&lt;/strong&gt;第二步：编写Hibernate技术和JDBC技术分别实现删除操作的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springioc_Decoupling.usedao;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Repository;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; @Repository(&quot;jdao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JDBCDAO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDAO{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;通过JDBC实现User删除&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springioc_Decoupling.usedao;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Repository;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; @Repository(&quot;hdao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HibernateDAO &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDAO{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;通过Hibernate实现User删除&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }　　　　　　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第三步：&lt;/strong&gt;编写一个控制用户删除操作的控制类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.springiocDecoupling.entity.Controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.springioc_Decoupling.usedao.UserDAO;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Controller(&quot;ucontroller&quot;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//如果使用Autowired的话需要Qualifier搭配，例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11　　　//@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11　　　//@Qualifier(&quot;jdao&quot;)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     @Resource(name=&quot;jdao&quot;&lt;span&gt;)&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;解耦操作就体现在此处，要用jdbc修改为jdao就行了，要用hibernate修改为hdao就行了&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDAO dao;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDAO getDao() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDao(UserDAO dao) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.dao =&lt;span&gt; dao;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        dao.delete();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第四步：&lt;/strong&gt;配置applicationContext.xml信息，启动组件扫描&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       xmlns:jdbc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jdbc&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;       xmlns:jee&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;       xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       xmlns:util&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/util&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        &amp;lt;bean id = &quot;jdao&quot; class = &quot;com.springioc_Decoupling.usedao.JDBCDAO&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        &amp;lt;bean id = &quot;hdao&quot; class = &quot;com.springioc_Decoupling.usedao.HibernateDAO&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        &amp;lt;bean id = &quot;ucontroller&quot; class=&quot;com.springiocDecoupling.entity.Controller.UserController&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            &amp;lt;property name=&quot;dao&quot; ref=&quot;hdao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        &amp;lt;/bean&amp;gt; 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;          &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;          
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.springiocDecoupling&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:component-scan&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　&lt;strong&gt;第五步：&lt;/strong&gt;编写测试类&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　测试结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427172330339-1855779047.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1458243/202004/1458243-20200427172428627-6896297.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 27 Apr 2020 18:02:00 +0000</pubDate>
<dc:creator>我只是一个码农</dc:creator>
<og:description>一、Spring框架了解 Spring框架是一个开源的框架，为JavaEE应用提供多方面的解决方案，用于简化企业级应用的开发，相当于是一种容器，可以集成其他框架(结构图如下)。 上图反映了框架引包的依</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinqin-me/p/12764934.html</dc:identifier>
</item>
</channel>
</rss>