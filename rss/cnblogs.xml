<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IdentityServer4 之 Resource Owner Password Credentials 其实有点尴尬 - Code综艺圈</title>
<link>http://www.cnblogs.com/zoe-zyq/p/14260564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoe-zyq/p/14260564.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;接着IdentityServer4的授权模式继续聊，这篇来说说 Resource Owner Password Credentials授权模式，这种模式在实际应用场景中使用的并不多，只怪其太开放啦，直接在&lt;strong&gt;客户端&lt;/strong&gt;上拿着用户名和密码就去&lt;strong&gt;授权服务器&lt;/strong&gt;获取&lt;strong&gt;AccessToken&lt;/strong&gt;，这样容易被&lt;strong&gt;客户端&lt;/strong&gt;拿着用户名和密码搞坏事；接下来就详细说说。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Resource Owner Password Credentials&lt;/strong&gt;授权模式与上一节说到的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1MzYwMjQ5MQ==&amp;amp;mid=2247484451&amp;amp;idx=1&amp;amp;sn=52d10586571e43432e6a00f3f0877303&amp;amp;chksm=fbf118f7cc8691e1c9b7bf6207ccc07d26371a95c9f8faf4978625a89c5ece0c8c2e1a876af1&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;客户端凭据模式&lt;/a&gt;不同，这是有用户参与的，用户就是资源拥有者；通过允许在客户端使用用户名和密码的方式向授权服务器获取AccessToken，AccessToken和用户相关，即不同的用户获取到的AccessToken不一样。&lt;/p&gt;
&lt;h5 id=&quot;术语解释：&quot;&gt;术语解释：&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Resource Owner&lt;/strong&gt;：资源所有者，即拥有资源的用户； 绝大对数小伙伴都应该有自己的QQ，如果没特殊情况，相信每一个小伙伴的QQ空间中都有自己曾经觉得很酷或很有纪念意义的照片，这里的照片就是资源，而小伙伴就是资源所有者。 QQ服务器就是资源服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;resource-owner-password-credentials-流程&quot;&gt;Resource Owner Password Credentials 流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/Q4IRVwWxhdceiKO.png&quot; alt=&quot;image-20210106122921243&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程简要说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先用户和客户端需要提前在授权服务器上备案过的，用户没有备案，在资源服务器肯定就没有对应的资源，客户端没有备案就不能随意去授权服务器获取AccessToken；&lt;/li&gt;
&lt;li&gt;用户在客户端上输入用户名和密码，并带上备案过的客户端凭据一起请求授权服务器获取AccessToken;&lt;/li&gt;
&lt;li&gt;授权服务器验证用户凭据和客户端凭据，成功之后直接返回代表该用户的AccessToken；&lt;/li&gt;
&lt;li&gt;用户在操作时，带上AccessToken访问资源服务器；&lt;/li&gt;
&lt;li&gt;资源服务器正常返回结果，如果没有AccessToken是不能访问受保护资源的；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;结合流程，看看代码如何实现，步伐跟上哦；&lt;/p&gt;
&lt;p&gt;这里资源服务器和授权服务器就拷贝之前客户端模式的代码(这样每种模式的代码区分开，方便查看)，在原有基础上修改代码即可；&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/zyq025/IDS4Demo&quot; target=&quot;_blank&quot;&gt;https://github.com/zyq025/IDS4Demo&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;在原有的授权服务器上增加代码&quot;&gt;&amp;gt;&amp;gt;在原有的授权服务器上增加代码&lt;/h5&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;模拟在授权服务器中备案用户，方便测试效果，就在内存中模拟；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/zTZxgj7cEefRpHk.png&quot; alt=&quot;image-20210106132546239&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;备案新的客户端，指定其授权方式；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/c3DjWIGZ1qFlB8z.png&quot; alt=&quot;image-20210106133339652&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;好啦，到这授权服务器的修改就完成啦，用postman先测试一下；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/18H5sg3ZDVElBwG.png&quot; alt=&quot;image-20210106135112325&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;授权服务器修改完啦，资源服务器不用动，那就到客户端啦&quot;&gt;&amp;gt;&amp;gt;授权服务器修改完啦，资源服务器不用动，那就到客户端啦&lt;/h5&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建一个Winform窗体程序，简单布局安排上；并引入IdentityModel包；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/hwfogG4szn8UaFS.png&quot; alt=&quot;image-20210106142213334&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编写获取AccessToken逻辑，在&lt;strong&gt;GetAccessToken按钮&lt;/strong&gt;点击事件中增加代码，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/mThRJt8HzUAuIkP.png&quot; alt=&quot;image-20210106150232248&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先启动授权服务器，看看access_token运行效果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/j4zDhCUAMfydc71.png&quot; alt=&quot;image-20210106150619514&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获取到AccessToken之后就可以访问受保护的API啦，在&lt;strong&gt;调用API按钮&lt;/strong&gt;点击事件中进行逻辑编写，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/DquxUeBpwaskCv4.png&quot; alt=&quot;image-20210106151317975&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;授权服务器、资源服务器、客户端启动运行看效果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/ZPIo564OtxCUvQy.png&quot; alt=&quot;image-20210106151654463&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是Resource Owner Password Credentials的使用，流程是不是很简单。接下来聊聊这种模式的其他话题；&lt;/p&gt;
&lt;h4 id=&quot;resource-owner-password-credentials的尴尬之处&quot;&gt;Resource Owner Password Credentials的尴尬之处&lt;/h4&gt;
&lt;p&gt;在oauth2.0中如果使用这种模式，规定是不允许客户端存储资源所有者的用户名和密码的，但如果是第三方客户端想搞事情，就把用户信息先存一把，这样就导致间接泄露用户信息的风险很高(如果第三方客户端被攻击了)，这也是这种模式在实际应用场景使用比较少的原因，如果有其他模式选择，不建议使用此模式；&lt;/p&gt;
&lt;p&gt;通常以下情况，可以考虑使用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端是可高度信任的，且安全性要有保障；&lt;/li&gt;
&lt;li&gt;遗留应用，没有其他好的解决方案，可以使用；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;有用户参与获取的accesstoken和客户端凭据获取到的有什么区别&quot;&gt;有用户参与获取的accessToken和客户端凭据获取到的有什么区别&lt;/h4&gt;
&lt;p&gt;之前客户端凭据模式的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/6x4CgPKAfQEy1Gh.png&quot; alt=&quot;image-20201231154747613&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;资源所有者密码模式的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/06/RscLitSmA9jMy5z.png&quot; alt=&quot;image-20210106162450204&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小伙伴肯定看出来不止多一个，但其中比较重要的就是sub这个claim，如果sub存在，调用API的access_token就能区分是代表用户的，否则就是代表客户端的。即有用户参与获取的acess_token是代表用户的，每个用户的token都不一样。&lt;/p&gt;
&lt;h4 id=&quot;refresh_token得补上&quot;&gt;refresh_token得补上&lt;/h4&gt;
&lt;p&gt;refresh_token是为了给access_token进行延长有效期而存在的，为了安全和降低风险，access_token的有效期一般设置的比较短，通常会是两个小时(根据需要设置)，当access_token失效时，常规的做法就是让其跳转到登录页重新登录获取，这样频繁的跳转到登录页，用户体验及其不好，为避免这种情况，需对access_token进行在线续命，即延长有效期；实现的方案各种各样，比如有在前端定时检测的，也有在后端做有效判断的，但用的相对比较多还是使用refresh_token的形式，当access_token失效时，会采用refresh_token去请求新的access_token，保证用户正常操作。&lt;/p&gt;
&lt;p&gt;如果需要在获取access_token的时候同时返回refresh_token，需要在授权服务器上备案客户端时将&lt;strong&gt;AllowOfflineAccess&lt;/strong&gt;设置为true，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/07/JutC7pl9IkwVQNA.png&quot; alt=&quot;image-20210107100506699&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;refresh_token具体使用，在后续的案例单独说吧。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;关于Resource Owner Password Credentials 就简单说这么多，主要是看看如何使用，相信小伙伴在新的项目中应该会很少用到，毕竟拿着用户名和密码直接在第三方客户端搞事情，始终还是有风险；下一篇说说&lt;strong&gt;Implicit(简化模式)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，跟我一起学~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/07/l7e8dBOT4acFtvP.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 00:52:00 +0000</pubDate>
<dc:creator>Code综艺圈</dc:creator>
<og:description>前言 接着IdentityServer4的授权模式继续聊，这篇来说说 Resource Owner Password Credentials授权模式，这种模式在实际应用场景中使用的并不多，只怪其太开放</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zoe-zyq/p/14260564.html</dc:identifier>
</item>
<item>
<title>Promise入门到精通(初级篇)-附代码详细讲解 - l偏执l</title>
<link>http://www.cnblogs.com/xmjt/p/14260559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmjt/p/14260559.html</guid>
<description>&lt;p&gt;​     &lt;strong&gt;Promise&lt;/strong&gt;，中文翻译为&lt;code&gt;承诺,约定,契约&lt;/code&gt;，从字面意思来看，这应该是类似某种协议，规定了什么事件发生的条件和触发方法。&lt;/p&gt;
&lt;p&gt;​     Promise的诞生和一个词有关，就是&lt;mark&gt;异步&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;​     什么是&lt;code&gt;异步？？?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​     首先javascript是运行在浏览器端的语言，必须依赖javascript引擎来解析并执行代码，js引擎是&lt;code&gt;单线程&lt;/code&gt;，也就是一个任务接着一个任务来执行程序，这种单线程很容易因为一个任务发生延迟，造成整体的耗时变长，为了解决这个问题，所以就有了&lt;code&gt;异步&lt;/code&gt;这个概念。&lt;/p&gt;
&lt;p&gt;​ 异步就是当系统执行一个事件的时候，不会等待该事件结束，而是会去继续执行其他事件，当这个异步事件有了响应结果之后，系统会在空闲的时候继续执行该事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    简单来说就是js引擎会首先判断该事件是同步任务还是异步任务，如果是同步任务，将该事件压入宏任务队列中排队等待执行，如果是异步事件，则进入微任务队列中等待宏任务队列处于空闲状态时，再将微任务队列中的事件移入宏任务队列执行。这样我们就可以把不确定执行时间的一些事件用异步来执行。提高了程序运行的效率，&lt;/p&gt;
&lt;h3 id=&quot;promise的核心概念&quot;&gt;&lt;strong&gt;Promise的核心概念&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​     Promise中的核心概念是&lt;mark&gt;状态&lt;/mark&gt;，&lt;mark&gt;状态转换&lt;/mark&gt;就是Promise执行异步事件的&lt;code&gt;时机&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​     在Promise中有存在3种状态，分别对应的是:&lt;/p&gt;
&lt;p&gt;​     1、等待（&lt;mark&gt;padding&lt;/mark&gt;）&lt;/p&gt;
&lt;p&gt;​     2、承诺实现（&lt;mark&gt;fulfilled&lt;/mark&gt;）&lt;/p&gt;
&lt;p&gt;​     3、承诺失效（&lt;mark&gt;reject&lt;/mark&gt;）&lt;/p&gt;
&lt;p&gt;​     Promise初始状态只能为等待的padding状态，在适当的时机，我们可以选择改变padding的状态到fulfilled或者reject。&lt;/p&gt;
&lt;p&gt;​     ⚠️ &lt;strong&gt;Promise中的状态是不可逆转的&lt;/strong&gt;，且仅允许改变一次,所以无法从fulfilled或reject状态再次切换到其他状态。当初始的padding改变为fulfilled或reject后，该Promise就相当于完成了它的使命，后续的异步处理就会交由一个&lt;mark&gt;then( )&lt;/mark&gt;的方法来实现。&lt;/p&gt;
&lt;h3 id=&quot;promise的基本构成&quot;&gt;&lt;strong&gt;Promise的基本构成&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;​     在ES6语法中，Promise是一个&lt;code&gt;构造函数&lt;/code&gt;，使用时需要用&lt;code&gt;new&lt;/code&gt;关键词来创建实例对象。Promise构造函数中自带&lt;code&gt;excutor&lt;/code&gt;执行器，excutor执行器中有2个JavaScript中默认的函数参数&lt;mark&gt;resolve&lt;/mark&gt;，&lt;mark&gt;reject&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​     &lt;mark&gt;resolve&lt;/mark&gt;函数的作用是当Promise状态从padding转换到resolve时,可以把Promise中的对象或者变量当成参数传递出来供异步成功时调用，&lt;mark&gt;reject&lt;/mark&gt;函数的作用是当Promise状态从padding转换到reject时候可以把Promise中的对象或者变量，以及系统报错当成参数传递出来供异步失败时调用。&lt;/p&gt;
&lt;p&gt;​     &lt;mark&gt;then&lt;/mark&gt;是Promise原型上的一个方法，&lt;strong&gt;&lt;code&gt;Promise.prototype.then()&lt;/code&gt;&lt;/strong&gt; 所以通过构造函数创建的Promise实例对象也会自带then( )方法。then( )方法接受2个函数参数，作为Promise中异步成功和异步失败的2个回调函数。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Promise实例的基本代码结构：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//ES6 箭头函数写法
let promise = new Promise((resolve,reject)=&amp;gt;{
    if(/判断条件/){
        resolve()//承诺实现
    }else{
                                reject()//承诺实效
    }
})
promise.then(res=&amp;gt;{
                //处理承诺实现方法
},err=&amp;gt;{
    //处理承诺失效方法     
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    ❗️❗️❗️注意：Promise函数本身不是一个异步函数，在excutor执行器中运行的代码是同步的。执行异步的是then( )方法中的事件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;console.log('步骤1');
new Promise((resolve,reject)=&amp;gt;{
    console.log('步骤2');
})
console.log('步骤3')

//执行结果
### 步骤1
### 步骤2
### 步骤3

console.log('步骤1');
new Promise((resolve,reject)=&amp;gt;{
    console.log('步骤2');
    resolve()
}).then(res=&amp;gt;{
    console.log('步骤3');
})
console.log('步骤4')

//执行结果
### 步骤1
### 步骤2
### 步骤4
### 步骤3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     &lt;mark&gt;.catch&lt;/mark&gt;也是Promise原型上的一个方法，用来接收和处理Promise中的异步失败，乍一看怎么和then( )中第二个函数参数的功能是一样的嘞？没错滴，这2种方法都是用来处理异步失败的回调函数，但它们2个之间还是有一些小小的区别。🌟 then( )中第二个函数参数只能处理当前Promise异步失败的回调，而catch( )可以处理整个&lt;code&gt;Promise链&lt;/code&gt;上发生的异步失败的回调,便于异步失败和系统报错的整体处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise new Promise ((resolve,reject)=&amp;gt;{
  reject('发生错误了')
})
promise.catch(err=&amp;gt;{
  console.log(err)
})
//执行结果
### 发生错误了

let promise new Promise ((resolve,reject)=&amp;gt;{
  throw ('发生错误了')
})
promise.catch(err=&amp;gt;{
  console.log(err)
})
//执行结果
### 发生错误了
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    ⭕️ （&lt;strong&gt;推荐在Promise中使用catch来捕获处理异步失败方法和抛出错误&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&quot;promise链式调用&quot;&gt;Promise链式调用&lt;/h3&gt;
&lt;p&gt;​     链式调用是Promise中一个特别重要的属性。也是Promise能控制异步操作的关键,那么链式调用是什么？它的原理又是什么呢？&lt;/p&gt;
&lt;p&gt;​     链式调用最重要的作用就是能使&lt;code&gt;异步事件同步化&lt;/code&gt;，将多个异步事件变为同步，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise1 = new Promise((resolve,reject)=&amp;gt;{
    setTimeout(()=&amp;gt;{
        resolve()
    },100)
}).then(res=&amp;gt;{
    console.log('我成功了');
})


let promise2 = new Promise((resolve,reject)=&amp;gt;{
    resolve()
}).then(res=&amp;gt;{
    console.log('我也成功了');
})

//执行结果
### 我也成功了
### 我成功了
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     &lt;strong&gt;可以看出，这两个方法执行顺序并不按照代码结构上的顺序来执行，也就是所谓的异步事件&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;​     链式调用主要原理就是&lt;mark&gt;Promise.prototype.then&lt;/mark&gt;方法和&lt;mark&gt;Promise.prototype.catch&lt;/mark&gt;会返回一个新的Prmise对象，所以我们在Prmise后面可以一直使用&lt;mark&gt;then&lt;/mark&gt;方法来处理异步事件，这样每个异步事件都会等上一个异步事件的then( )方法触发后才会执行自身，从而达到同步的效果.&lt;/p&gt;
&lt;p&gt;​     当我们想让2个异步事件也遵循同步来执行就可以用Prmise的链式调用方法来重写代码结构:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise1 = new Promise((resolve,reject)=&amp;gt;{
    setTimeout(()=&amp;gt;{
        resolve()
    },100)
}).then(res=&amp;gt;{
    console.log('我成功了');
    return new Promise((resolve,reject)=&amp;gt;{
        resolve()
    })
}).then((res)=&amp;gt;{
    console.log('我也成功了');
})

//执行结果
### 我成功了
### 我也成功了
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;promise链式调用的规则&quot;&gt;Promise链式调用的规则&lt;/h3&gt;
&lt;p&gt;​     链式调用是Promise中一个重要的方法，能有效处理同步异步之间的逻辑关系，但是链式调用也有着自己一套使用规则，熟悉掌握它的规则才能更好的在开发中灵活的使用&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;规则1&lt;/strong&gt;：Promise对象会默认返回一个新的Promise，当我们不手动进行干预的时候，这个返回的Promise对象状态为&lt;mark&gt;fulfilled&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise = new Promise((resolve,reject)=&amp;gt;{
    resolve()
}).then(res=&amp;gt;{
    
}).then(res=&amp;gt;{
    console.log('规则1');
})

//上述的原理等价于下面的写法👇🏻

let promise = new Promise((resolve,reject)=&amp;gt;{
    resolve()
}).then(res=&amp;gt;{
    return new Promise((resolve,reject)=&amp;gt;{
        resolve()
    })
}).then(res=&amp;gt;{
    console.log('规则1');
})

//执行结果
### 规则1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;规则2&lt;/strong&gt;：Promise对象返回值类型是非Promise时，会自动转成状态是&lt;mark&gt;fulfilled&lt;/mark&gt;的Promise对象，这个返回值会被&lt;mark&gt;then( )&lt;/mark&gt;方法中的第一个参数所接收。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise = new Promise((resolve,reject)=&amp;gt;{
    resolve()
}).then(res=&amp;gt;{
    let str ='规则2'
    return str
}).then(res=&amp;gt;{
    console.log(res)
})

//上述的原理等价于下面的写法👇🏻

let promise = new Promise((resolve,reject)=&amp;gt;{
    resolve()
}).then(res=&amp;gt;{
    let str ='规则2'
    return new Promise((resolve,reject)=&amp;gt;{
        resolve(str)
    })
}).then(res=&amp;gt;{
    console.log(res)
})

//执行结果
### 规则2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​     &lt;strong&gt;规则3&lt;/strong&gt;：Promise对象可以手动返回一个新的Promise，这个新的Promise的状态类型可以由我们来决定在什么时间转变为&lt;mark&gt;fulfilled&lt;/mark&gt;或&lt;mark&gt;reject&lt;/mark&gt;，自由度较高，方便我们自由的来控制逻辑如何执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function init (params) {
    let promise = new Promise((resolve,reject)=&amp;gt;{
        let num=params
        resolve(num)
    }).then(res1=&amp;gt;{
        return new Promise((resolve,reject)=&amp;gt;{
           res1&amp;gt;=5?resolve('大于等于5'):reject('小于5')
        })
    }).then(res2=&amp;gt;{
        console.log(res2);
    }).catch(err=&amp;gt;{
        console.log(err);
    })
}

//执行
init(10)
//执行结果
### 大于等于5

//执行
init(1)
//执行结果
###小于5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     &lt;strong&gt;规则4&lt;/strong&gt;：Promise的回调函数中如果抛出错误&lt;code&gt;error&lt;/code&gt;,会返回一个状态为&lt;mark&gt;reject&lt;/mark&gt;的Promise对象，将这个错误作为参数传递给下一个Promise链中的&lt;code&gt;then( )&lt;/code&gt;方法的第二个函数参数或&lt;code&gt;catch()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise = new Promise((resolve, reject) =&amp;gt; {
    throw new Error('发生错误')
}).then(res=&amp;gt;{
    console.log(res);
}).catch(err=&amp;gt;{
    console.log(err);
})

//执行结果
### 发生错误
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     &lt;strong&gt;规则5&lt;/strong&gt;：Promise的值可以发生穿透现象,当中间的&lt;code&gt;then()&lt;/code&gt;方法没有定义回调参数时,上一个Promise链上的值会作为参数传递到下一个Promise对象的then( )方法的回调方法中,可以发生多层穿透。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let promise = new Promise((resolve, reject) =&amp;gt; {
    resolve('规则5')
}).then().then().then(res=&amp;gt;{
    console.log(res);
})

//执行结果
### 规则5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     &lt;strong&gt;规则6&lt;/strong&gt;： Promise的&lt;mark&gt;resolve&lt;/mark&gt;和&lt;mark&gt;reject&lt;/mark&gt;只能传递一个参数，如果传递多个参数必须用数组或对象进行封装，否则多余参数的值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; //用数组封装参数
let promise = new Promise((resolve,reject)=&amp;gt;{
            resolve([1,2])
        }).then(res=&amp;gt;{
            console.log(res);
        })
 //执行结果
 ### [1,2]
 
//直接传递多参数
  let promise = new Promise((resolve,reject)=&amp;gt;{
            resolve(1,2)
        }).then((num1,num2)=&amp;gt;{
            console.log(num1,num2);
        })
 //执行结果
 ### 1 undefined
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;promise解决的实际问题&quot;&gt;Promise解决的实际问题&lt;/h3&gt;
&lt;p&gt;​     通过上面的介绍，我们大致了解了Promise的用法，但是为什么我们要使用Promise，在什么地方去使用Promise呢？接下来就来告诉你&lt;/p&gt;
&lt;p&gt;​     在JavaScript中尤其是Node.js中，很多的Api方法都是异步方法，获取结果后通过回调函数来执行，当多个这样的异步方法嵌套在一起使用的时候就会出现臭名昭著的&lt;code&gt;回调地狱&lt;/code&gt;，我相信大部分开发者面对一个复杂的回调地狱时都免不了头皮发麻。下面用这段计数器功能的代码简单模拟一下回调地狱的形式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let num=0

let callback = function (value,fn) {
    console.log(value);
    fn()
}

callback(num,()=&amp;gt;{
    num++
    callback(num,()=&amp;gt;{
        num++
        callback(num,()=&amp;gt;{
            num++
            callback(num,()=&amp;gt;{
                num++
                callback(num,()=&amp;gt;{
                    console.log('结束');
                })
            })
        })
    })
})

//执行结果
###
0
1
2
3
4
结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     上面的代码只是简单的在每次回调的时候进行num+1的操作，但整体看上去就让人有点不太舒服了，更不要提在回调中执行其他异步操作，定时器，接口请求等，这种写法的代码层级嵌套太深不说，就代码长度来看也是越来越宽影响阅读体验。&lt;/p&gt;
&lt;p&gt;​     接来下我们就用上面学过的Promise方法来简单的改装一下这个计数器代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let num=0
let promise = new Promise((resolve,reject)=&amp;gt;{
    console.log(num);
    resolve(++num)
}).then(res=&amp;gt;{
    console.log(res);
    return ++res
}).then(res=&amp;gt;{
    console.log(res);
    return ++res
}).then(res=&amp;gt;{
    console.log(res);
    return ++res
}).then(res=&amp;gt;{
    console.log(res);
}).then(res=&amp;gt;{
    console.log('结束');
})

//执行结果
###
0
1
2
3
4
结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     两段代码进行对比，首先在样式上Promise方法书写的代码看起来更具有美感，在结构上Promise的代码比正常回调函数的写法更具结构性，每一个then方法里对应一个回调，这样写出的代码更容易被其他人所读懂。&lt;/p&gt;
&lt;p&gt;​     在普通回调函数中，我们不能保证每次回调的执行时间和次数和我们预设的一摸一样，当2个开发人员共同开发一个功能模块的时候可能由于沟通出现问题或另一个开发者的粗心，把传入的回调执行了多次&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function init(fn) {
        let num = 1;
        fn &amp;amp;&amp;amp; fn(num);
        /* 
            #### 其他业务代码
        */
        num += 1;
        fn &amp;amp;&amp;amp; fn(num);
        //这个方法可能被错误的调用了2次
      }

init((num) =&amp;gt; {
    console.log(&quot;我被调用了,输出&quot; + num);
 });

//期望得到的结果
### 我被调用了，输出1
//实际得到的结果
### 我被调用了，输出1
### 我被调用了，输出2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     如上面所见的模拟代码这就可能会造成系统运行上的报错或得到了一个错误的结果。这样的结果是大家都不想看到的。那我们如果用Promise改进一下呢&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function init(fn) {
        return new Promise((resolve,reject)=&amp;gt;{
            let num = 1;
            resolve(num)
            /*
             其他业务代码
            */
            num+=1
            resolve(num)
            resolve(num)
        }).then(res=&amp;gt;{
            fn &amp;amp;&amp;amp; fn(res);
        })
      }

init((num) =&amp;gt; {
   console.log(&quot;我被调用了,输出&quot; + num);
 });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​     这样用Promise修改的代码，无论后面调用了多少次&lt;code&gt;resolve（）&lt;/code&gt;方法，都不会再执行了，因为Promise的状态一旦被改变，就不能再更改了。一定程度上避免了回调被多次执行的问题。&lt;/p&gt;
&lt;h3 id=&quot;promise存在的一些问题&quot;&gt;Promise存在的一些问题&lt;/h3&gt;
&lt;p&gt;​     1、Promise一旦被生成就会立刻执行，中途是无法退出的&lt;/p&gt;
&lt;p&gt;​     2、Promise执行器内部的代码如果在&lt;mark&gt;resole&lt;/mark&gt;或&lt;mark&gt;reject&lt;/mark&gt;改变状态后出现报错，是无法通过&lt;code&gt;then&lt;/code&gt;方法第二个参数和&lt;code&gt;catch&lt;/code&gt;捕获到，必须通过内部回调或者用try catch的方式来抛出错误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//程序在resolve()被执行后出现报错
let promise = new Promise((resolve,reject)=&amp;gt;{
         resolve()
         throw new Error('错误')
     }).then(res=&amp;gt;{
        
     },err=&amp;gt;{
         console.log(err);
     }).catch(err=&amp;gt;{
         console.log(err);
     })
//期待执行结果
###  Error: 错误
//实际执行结果
### 没有任何输出

//用try catch捕获错误方式
let promise = new Promise((resolve, reject) =&amp;gt; {
        try {
          resolve();
          throw new Error(&quot;错误&quot;);
        } catch (error) {
          console.log(error);
        }
 });

//执行结果
### Error: 错误
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;​      &lt;code&gt;Promise&lt;/code&gt;是&lt;code&gt;ECMAscript ES6&lt;/code&gt;原生的对象，是解决javascript语言异步编程产生回调地狱的&lt;mark&gt;一种方法&lt;/mark&gt;。但它的本质也没有跳出回调问题，只是把嵌套关系优化成类似层级结构的写法来帮助开发者更容易处理异步中的逻辑代码。配合它的一些Api方法让我们更容易处理一些网络请求，但它也有自身的缺陷，在项目大量使用的话会降低一些性能，需要开发者在适时的时候去正确的使用它。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Promise入门到精通(中级篇)-附代码详细讲解&lt;br/&gt;（Promise Api在项目中对应用场景）&lt;strong&gt;正在码字中～&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Promise入门到精通(高级篇)-附代码详细讲解&lt;br/&gt;（深入了解Promise原理，并手动实现一个Promise）&lt;strong&gt;正在码字中～&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;    &lt;strong&gt;对Prmose后续知识点感兴趣对小伙伴可以先关注我噢&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;如果您觉得文章有错误需要修正，请联系我，采纳通过修改后，您的用户名会留在下面的感谢名单中&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      🏅&lt;em&gt;感谢名单&lt;/em&gt;🏅&lt;/p&gt;
&lt;p&gt;🏅&lt;em&gt;感谢对本篇文章的贡献&lt;/em&gt;🏅&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 00:51:00 +0000</pubDate>
<dc:creator>l偏执l</dc:creator>
<og:description>Promise入门到精通(初级篇)-附代码详细讲解 ​ Promise，中文翻译为承诺,约定,契约，从字面意思来看，这应该是类似某种协议，规定了什么事件发生的条件和触发方法。 ​ Promise的诞生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xmjt/p/14260559.html</dc:identifier>
</item>
<item>
<title>阿里面试：MySQL如何设计索引更高效？ - 敖丙</title>
<link>http://www.cnblogs.com/aobing/p/14260558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aobing/p/14260558.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.9406392694064&quot;&gt;
&lt;p&gt;有情怀，有干货，微信搜索【&lt;strong&gt;三太子敖丙&lt;/strong&gt;】关注这个不一样的程序员。&lt;/p&gt;
&lt;p&gt;本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/AobingJava/JavaFamily&quot;&gt;https://github.com/JavaFamily&lt;/a&gt; 已收录，有一线大厂面试完整考点、资料以及我的系列文章。&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库系列更新到现在我想大家对所有的概念都已有个大概认识了，这周我在看评论的时候我发现有个网友的提问我觉得很有意思：帅丙如何设计一个索引？你们都是怎么设计索引的？怎么设计更高效？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我一想索引我写过很多了呀，没道理读者还不会啊，但是我一回头看完，那确实，我就写了索引的概念，优劣势，没提到怎么设计，那这篇文章又这样应运而生了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文还是会有很多之前写过的重复概念，但是也是为了大家能更好的理解MySQL中几种索引设计的原理。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;正文&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，索引是一个基于链表实现的树状Tree结构，能够快速的检索数据，目前几乎所RDBMS数据库都实现了索引特性，比如MySQL的B+Tree索引，MongoDB的BTree索引等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务开发过程中，索引设计高效与否决定了接口对应SQL的执行效率，高效的索引可以降低接口的Response Time，同时还可以降低成本，我们要现实的目标是：索引设计-&amp;gt;降低接口响应时间-&amp;gt;降低服务器配置-&amp;gt;降低成本，最终要落实到成本上来，&lt;strong&gt;因为老板最关心的是成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就跟大家聊聊MySQL中的索引以及如何设计索引，使用索引才能提降低接口的RT，提高用户体检。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;MySQL中的索引&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL中的InnoDB引擎使用B+Tree结构来存储索引，可以尽量减少数据查询时磁盘IO次数，同时树的高度直接影响了查询的性能，一般树的高度维持在 3~4 层。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B+Tree由三部分组成：根root、枝branch以及Leaf叶子，其中root和branch不存储数据，只存储指针地址，数据全部存储在Leaf Node，同时Leaf Node之间用双向链表链接，结构如下：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gm98g5jp2sj31to0puad3.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看到，每个Leaf Node是三部分组成的，即前驱指针p_prev，数据data以及后继指针p_next，同时数据data是有序的，默认是升序ASC，分布在B+tree右边的键值总是大于左边的，同时从root到每个Leaf的距离是相等的，也就是访问任何一个Leaf Node需要的IO是一样的，即索引树的高度Level + 1次IO操作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将MySQL中的索引可以看成一张小表，占用磁盘空间，创建索引的过程其实就是按照索引列排序的过程，先在sort_buffer_size进行排序，如果排序的数据量大，sort_buffer_size容量不下，就需要通过临时文件来排序，最重要的是通过索引可以避免排序操作（distinct，group by，order by）。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;聚集索引&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL中的表是IOT（Index Organization Table，索引组织表)，数据按照主键id顺序存储（逻辑上是连续，物理上不连续），而且主键id是聚集索引（clustered index），存储着整行数据，如果没有显示的指定主键，MySQL会将所有的列组合起来构造一个row_id作为primary key，例如表users(id, user_id, user_name, phone, primary key(id))，id是聚集索引，存储了id, user_id, user_name, phone整行的数据。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;辅助索引&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gm9h2nblwbj31cm0m60ve.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;辅助索引也称为二级索引，索引中除了存储索引列外，还存储了主键id，对于user_name的索引idx_user_name(user_name)而言，其实等价于idx_user_name(user_name, id)，MySQL会自动在辅助索引的最后添加上主键id，熟悉Oracle数据库的都知道，索引里除了索引列还存储了row_id（代表数据的物理位置，由四部分组成：对象编号+数据文件号+数据块号+数据行号），我们在创建辅助索引也可以显示添加主键id。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_user_name &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;(user_name);&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_user_name_id &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;(user_name,&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;);&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; a.space &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; tbl_spaceid, a.table_id, a.name &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; table_name, row_format, space_type,  b.index_id , b.name &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; index_name, n_fields, page_no, b.type &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; index_type  &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; information_schema.INNODB_TABLES a &lt;span class=&quot;hljs-keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;join&lt;/span&gt; information_schema.INNODB_INDEXES b  &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; a.table_id =b.table_id &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a.name = &lt;span class=&quot;hljs-string&quot;&gt;'test/users'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| tbl_spaceid | table_id | table_name | row_format | space_type | index_id | index_name       | n_fields | page_no | index_type |&lt;br/&gt;+&lt;br/&gt;|         518 |     1586 | test/users | Dynamic    | Single     |     1254 | PRIMARY          |        9 |       4 |          3 |&lt;br/&gt;|         518 |     1586 | test/users | Dynamic    | Single     |     4003 | idx_user_name    |        2 |       5 |          0 |&lt;br/&gt;|         518 |     1586 | test/users | Dynamic    | Single     |     4004 | idx_user_name_id |        2 |      45 |          0 |&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; index_name, last_update, stat_name, stat_value, stat_description &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; mysql.innodb_index_stats &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; index_name &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;'idx_user_name'&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;'idx_user_name_id'&lt;/span&gt;);&lt;br/&gt;+&lt;br/&gt;| index_name       | last_update         | stat_name    | stat_value | stat_description                  |&lt;br/&gt;+&lt;br/&gt;| idx_user_name    | 2021-01-02 17:14:48 | n_leaf_pages |       1358 | Number of leaf pages in the index |&lt;br/&gt;| idx_user_name    | 2021-01-02 17:14:48 | size         |       1572 | Number of pages in the index      |&lt;br/&gt;| idx_user_name_id | 2021-01-02 17:14:48 | n_leaf_pages |       1358 | Number of leaf pages in the index |&lt;br/&gt;| idx_user_name_id | 2021-01-02 17:14:48 | size         |       1572 | Number of pages in the index      |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比一下两个索引的结果，n_fields表示索引中的列数，n_leaf_pages表示索引中的叶子页数，size表示索引中的总页数，通过数据比对就可以看到，辅助索引中确实包含了主键id，也说明了这两个索引时完全一致。&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Index_name&lt;/th&gt;
&lt;th&gt;n_fields&lt;/th&gt;
&lt;th&gt;n_leaf_pages&lt;/th&gt;
&lt;th&gt;size&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;idx_user_name&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1358&lt;/td&gt;
&lt;td&gt;1572&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;idx_user_name_id&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1358&lt;/td&gt;
&lt;td&gt;1572&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;索引回表&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面证明了辅助索引包含主键id，如果通过辅助索引列去过滤数据有可能需要回表，举个例子：业务需要通过用户名user_name去查询用户表users的信息，业务接口对应的SQL：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  user_id, user_name, phone &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; user_name = &lt;span class=&quot;hljs-string&quot;&gt;'Laaa'&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，对于索引idx_user_name而言，其实就是一个小表idx_user_name(user_name, id)，如果只查询索引中的列，只需要扫描索引就能获取到所需数据，是不需要回表的，如下SQL语句：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL 1: &lt;code&gt;select id, user_name from users where user_name = 'Laaa';&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SQL 2:&lt;/strong&gt; &lt;code&gt;select id from users where user_name = 'Laaa';&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;'Laaa'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | ref  | idx_user_name | idx_user_name | 82      | const |    1 |   100.00 | Using index |&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;'Laaa'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra       |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | ref  | idx_user_name | idx_user_name | 82      | const |    1 |   100.00 | Using index |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL 1和SQL 2的执行计划中的Extra=&lt;strong&gt;Using index&lt;/strong&gt; 表示使用覆盖索引扫描，不需要回表，再来看上面的业务SQL：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select user_id, user_name, phone from users where user_name = 'Laaa';&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到select后面的user_id，phone列不在索引idx_user_name中，就需要通过主键id进行回表查找，MySQL内部分如下两个阶段处理：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Section 1&lt;/strong&gt;： &lt;code&gt;select **id** from users where user_name = 'Laaa'&lt;/code&gt; //id = 100101&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Section 2:&lt;/strong&gt; &lt;code&gt;select user_id, user_name, phone from users where id&lt;/code&gt; = 100101;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将&lt;strong&gt;Section 2&lt;/strong&gt;的操作称为回表，即通过辅助索引中的主键id去原表中查找数据。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;索引高度&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的索引时B+tree结构，即使表里有上亿条数据，索引的高度都不会很高，通常维持在3-4层左右，我来计算下索引idx_name的高度，从上面知道索引信息：index_id = 4003， page_no = 5，它的偏移量offset就是page_no x innodo_page_size + 64 = 81984，通过hexdump进行查看&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;hexdump -s 81984 -n 10 /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/var/mysql/&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;/users.ibd&lt;/span&gt;&lt;br/&gt;0014040 00 02 00 00 00 00 00 00 0f a3                  &lt;br/&gt;001404a&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中索引的PAGE_LEVEL为00，即idx_user_name索引高度为1，0f a3 代表索引编号，转换为十进制是4003，正是index_id。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据扫描方式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全表扫描&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从左到右依次扫描整个B+Tree获取数据，扫描整个表数据，IO开销大，速度慢，锁等严重，影响MySQL的并发。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于OLAP的业务场景，需要扫描返回大量数据，这时候全表扫描的顺序IO效率更高。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;索引扫描&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来讲索引比表小，扫描的数据量小，消耗的IO少，执行速度块，几乎没有锁等，能够提高MySQL的并发。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于OLTP系统，希望所有的SQL都能命中合适的索引总是美好的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要区别就是扫描数据量大小以及IO的操作，全表扫描是顺序IO，索引扫描是随机IO，MySQL对此做了优化，增加了change buffer特性来提高IO性能。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;索引优化案例&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分页查询优化&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务要根据时间范围查询交易记录，接口原始的SQL如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; trade_info &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-07 23:59:59'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;102120&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表trade_info上有索引idx_status_create_time(status,create_time)，通过上面分析知道，等价于索引**（status,create_time,id)**，对于典型的分页limit m, n来说，越往后翻页越慢，也就是m越大会越慢，因为要定位m位置需要扫描的数据越来越多，导致IO开销比较大，这里可以利用辅助索引的覆盖扫描来进行优化，先获取id，这一步就是索引覆盖扫描，不需要回表，然后通过id跟原表trade_info进行关联，改写后的SQL如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; trade_info a ,&lt;p&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; trade_info &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-07 23:59:59'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;102120&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; b   //这一步走的是索引覆盖扫描，不需要回表&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; a.id = b.id;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多同学只知道这样写效率高，但是未必知道为什么要这样改写，理解索引特性对编写高质量的SQL尤为重要。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分而治之总是不错的&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;营销系统有一批过期的优惠卷要失效，核心SQL如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; coupons &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; =&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-07 23:59:59'&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Oracle里更新500w数据是很快，因为可以利用多个cpu core去执行，但是MySQL就需要注意了，一个SQL只能使用一个cpu core去处理，如果SQL很复杂或执行很慢，就会阻塞后面的SQL请求，造成活动连接数暴增，MySQL CPU 100%，相应的接口Timeout，同时对于主从复制架构，而且做了业务读写分离，更新500w数据需要5分钟，Master上执行了5分钟，binlog传到了slave也需要执行5分钟，那就是Slave延迟5分钟，在这期间会造成业务脏数据，比如重复下单等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化思路：先获取where条件中的最小id和最大id，然后分批次去更新，每个批次1000条，这样既能快速完成更新，又能保证主从复制不会出现延迟。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;先获取要更新的数据范围内的最小id和最大id（表没有物理delete，所以id是连续的）&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;min&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;) min_id, &lt;span class=&quot;hljs-keyword&quot;&gt;max&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;) max_id &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; coupons &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; =&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-07 23:59:59'&lt;/span&gt;; &lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type  | possible_keys          | key                    | key_len | ref  | rows   | filtered | Extra                    |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | range | idx_status_create_time | idx_status_create_time | 6       | NULL | 180300 |   100.00 | Using where; Using index |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​ Extra=Using where; Using index使用了索引idx_status_create_time，同时需要的数据都在索引中能找到，所以不需要回表查询数据。&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;以每次1000条commit一次进行循环update，主要代码如下：&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;current_id = min_id;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;  current_id &amp;lt; max_id &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;br/&gt;update coupons set status = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; where id &amp;gt;=current_id and id &amp;lt;= current_id + &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;  &lt;br/&gt;commit;&lt;br/&gt;current_id += &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;&lt;br/&gt;done&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个案例告诉我们，要充分利用辅助索引包含主键id的特性，先通过索引获取主键id走覆盖索引扫描，不需要回表，然后再通过id去关联操作是高效的，同时根据MySQL的特性使用分而治之的思想既能高效完成操作，又能避免主从复制延迟产生的业务数据混乱。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;MySQL索引设计&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉了索引的特性之后，就可以在业务开发过程中设计高质量的索引，降低接口的响应时间。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前缀索引&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于使用REDUNDANT或者COMPACT格式的InnoDB表，索引键前缀长度限制为767字节。如果TEXT或VARCHAR列的列前缀索引超过191个字符，则可能会达到此限制，假定为utf8mb4字符集，每个字符最多4个字节。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过设置参数innodb_large_prefix来开启或禁用索引前缀长度的限制，即是设置为OFF，索引虽然可以创建成功，也会有一个警告，主要是因为index size会很大，效率大量的IO的操作，即使MySQL优化器命中了该索引，效率也不会很高。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_nickname &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;(nickname);    // `nickname` varchar(255)&lt;br/&gt;Records: 0  Duplicates: 0  Warnings: 1&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;warnings&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| Level   | Code | Message                                                 |&lt;br/&gt;+&lt;br/&gt;| Warning | 1071 | Specified key was too long; max key length is 767 bytes |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务发展初期，为了快速实现功能，对一些数据表字段的长度定义都比较宽松，比如用户表users的昵称nickname定义为varchar(128)，而且有业务接口需要通过nickname查询，系统运行了一段时间之后，查询users表最大的nickname长度为30，这个时候就可以创建前缀索引来减小索引的长度提升性能。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; nickname = &lt;span class=&quot;hljs-string&quot;&gt;'Laaa'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | ref  | idx_nickname  | idx_nickname | 515     | const |    1 |   100.00 | NULL  |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key_len=515，由于表和列都是utf8mb4字符集，每个字符占4个字节，变长数据类型+2Bytes，允许NULL额外+1Bytes，即128 x 4 + 2 + 1 = 515Bytes。创建前缀索引，前缀长度也可以不是当前表的数据列最大值，应该是区分度最高的那部分长度，一般能达到90%以上即可，例如email字段存储都是类似这样的值xxxx@yyy.com，前缀索引的最大长度可以是xxxx这部分的最大长度即可。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_nickname_part &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt;(nickname(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;));&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; nickname = &lt;span class=&quot;hljs-string&quot;&gt;'Laaa'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type | possible_keys                  | key               | key_len | ref   | rows | filtered | Extra       |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | ref  | idx_nickname_part,idx_nickname | idx_nickname_part | 123     | const |    1 |   100.00 | Using where |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到优化器选择了前缀索引，索引长度为123，即30 x 4 + 2 + 1 = 123 Bytes，大小不到原来的四分之。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;前缀索引虽然可以减小索引的大小，但是不能消除排序。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; gender,&lt;span class=&quot;hljs-keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; nickname &lt;span class=&quot;hljs-keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'User100%'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; nickname &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type  | possible_keys                  | key          | key_len | ref  | rows | filtered | Extra                 |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | range | idx_nickname_part,idx_nickname | idx_nickname | 515     | NULL |  899 |   100.00 | Using index condition |&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; gender,&lt;span class=&quot;hljs-keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; nickname &lt;span class=&quot;hljs-keyword&quot;&gt;like&lt;/span&gt;  &lt;span class=&quot;hljs-string&quot;&gt;'User100%'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; nickname &lt;span class=&quot;hljs-keyword&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type  | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                        |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | range | idx_nickname_part | idx_nickname_part | 123     | NULL |  899 |   100.00 | Using where; Using temporary |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;复合索引&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单列索引不能很好的过滤数据的时候，可以结合where条件中其他字段来创建复合索引，更好的去过滤数据，减少IO的扫描次数，举个例子：业务需要按照时间段来查询交易记录，有如下的SQL：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;  * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; trade_info &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2020-10-07 23:59:59'&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发同学根据以往复合索引的设计的经验：&lt;strong&gt;唯一值多选择性好的列作为复合索引的前导列&lt;/strong&gt;，所以创建复合索idx_create_time_status是高效的，因为create_time是一秒一个值，唯一值很多，选择性很好，而status只有离散的6个值，所以认为这样创建是没问题的，&lt;strong&gt;但是这个经验只适合于等值条件过滤，不适合有范围条件过滤的情况&lt;/strong&gt;，例如idx_user_id_status(user_id，status)这个是没问题的，但是对于包含有create_time范围的复合索引来说，就不适应了，我们来看下这两种不同索引顺序的差异，即idx_status_create_time和idx_create_time_status。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_status_create_time &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; trade_info(&lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;, create_time);&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; idx_create_time_status &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; trade_info(create_time,&lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;);&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;=&lt;span class=&quot;hljs-string&quot;&gt;'2021-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2021-10-07 23:59:59'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type  | possible_keys                                 | key                    | key_len | ref  | rows  | filtered | Extra                 |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | trade_info | NULL       | range | idx_status_create_time,idx_create_time_status | idx_status_create_time | 6       | NULL | 98518 |   100.00 | Using index condition |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从执行计划可以看到，两种不同顺序的复合索引都存在的情况，MySQL优化器选择的是idx_status_create_time索引，那为什么不选择idx_create_time_status，我们通过optimizer_trace来跟踪优化器的选择。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt; optimizer_trace=&lt;span class=&quot;hljs-string&quot;&gt;&quot;enabled=on&quot;&lt;/span&gt;,end_markers_in_json=&lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;;&lt;br/&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; trade_info &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;gt;=&lt;span class=&quot;hljs-string&quot;&gt;'2021-10-01 00:00:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2021-10-07 23:59:59'&lt;/span&gt;;&lt;br/&gt;mysql&amp;gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; information_schema.OPTIMIZER_TRACE\G;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwgy1gm9phnowg0j30vw0u0n0o.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比下两个索引的统计数据，如下所示：&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;复合索引&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Rows&lt;/th&gt;
&lt;th&gt;参与过滤索引列&lt;/th&gt;
&lt;th&gt;Chosen&lt;/th&gt;
&lt;th&gt;Cause&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;idx_status_create_time&lt;/td&gt;
&lt;td&gt;Index Range Scan&lt;/td&gt;
&lt;td&gt;98518&lt;/td&gt;
&lt;td&gt;status &lt;strong&gt;AND&lt;/strong&gt; create_time&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;Cost低&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;idx_create_time_status&lt;/td&gt;
&lt;td&gt;Index Range Scan&lt;/td&gt;
&lt;td&gt;98518&lt;/td&gt;
&lt;td&gt;create_time&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;Cost高&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL优化器是基于Cost的，COST主要包括IO_COST和CPU_COST，MySQL的CBO（Cost-Based Optimizer基于成本的优化器）总是选择Cost最小的作为最终的执行计划去执行，从上面的分析，CBO选择的是复合索引idx_status_create_time，因为该索引中的status和create_time都能参与了数据过滤，成本较低；而idx_create_time_status只有create_time参数数据过滤，status被忽略了，其实CBO将其简化为单列索引idx_create_time，选择性没有复合索引idx_status_create_time好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;复合索引设计原则&lt;/strong&gt;&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;将范围查询的列放在复合索引的最后面，例如idx_status_create_time。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;列过滤的频繁越高，选择性越好，应该作为复合索引的前导列，适用于等值查找，例如idx_user_id_status。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个原则不是矛盾的，而是相辅相成的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;跳跃索引&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，如果表users有复合索引idx_status_create_time，我们都知道，单独用create_time去查询，MySQL优化器是不走索引，所以还需要再创建一个单列索引idx_create_time。用过Oracle的同学都知道，是可以走索引跳跃扫描（Index Skip Scan），在MySQL 8.0也实现Oracle类似的索引跳跃扫描，在优化器选项也可以看到skip_scan=on。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;| optimizer_switch             |use_invisible_indexes=off,skip_scan=on,hash_join=on |&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适合复合索引前导列唯一值少，后导列唯一值多的情况，如果前导列唯一值变多了，则MySQL CBO不会选择索引跳跃扫描，取决于索引列的数据分表情况。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;, user_id，&lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;, phone &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; create_time &amp;gt;=&lt;span class=&quot;hljs-string&quot;&gt;'2021-01-02 23:01:00'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; create_time &amp;lt;= &lt;span class=&quot;hljs-string&quot;&gt;'2021-01-03 23:01:00'&lt;/span&gt;;&lt;br/&gt;+&lt;br/&gt;| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |&lt;br/&gt;+&lt;br/&gt;|  1 | SIMPLE      | users | NULL       | range  | idx_status_create_time          | idx_status_create_time | NULL    | NULL | 15636 |    11.11 | Using where; Using index for skip scan|&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过optimizer_switch='skip_scan=off'来关闭索引跳跃扫描特性。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本位为大家介绍了MySQL中的索引，包括聚集索引和辅助索引，辅助索引包含了主键id用于回表操作，同时利用覆盖索引扫描可以更好的优化SQL。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也介绍了如何更好做MySQL索引设计，包括前缀索引，复合索引的顺序问题以及MySQL 8.0推出的索引跳跃扫描，我们都知道，索引可以加快数据的检索，减少IO开销，会占用磁盘空间，是一种用空间换时间的优化手段，同时更新操作会导致索引频繁的合并分裂，影响索引性能，在实际的业务开发中，如何根据业务场景去设计合适的索引是非常重要的，今天就聊这么多，希望对大家有所帮助。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是敖丙，你知道的越多，你不知道的越多，感谢各位的三连，我们下期见。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是敖丙，&lt;strong&gt;你知道的越多，你不知道的越多&lt;/strong&gt;，感谢各位人才的：&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;和&lt;strong&gt;评论&lt;/strong&gt;，我们下期见！&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.2281368821293&quot;&gt;
&lt;p&gt;文章持续更新，可以微信搜一搜「 &lt;strong&gt;三太子敖丙&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;资料&lt;/strong&gt;】有我准备的一线大厂面试资料和简历模板，本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/AobingJava/JavaFamily&quot;&gt;https://github.com/JavaFamily&lt;/a&gt; 已经收录，有大厂面试完整考点，欢迎Star。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 11 Jan 2021 00:49:00 +0000</pubDate>
<dc:creator>敖丙</dc:creator>
<og:description>有情怀，有干货，微信搜索【三太子敖丙】关注这个不一样的程序员。 本文 GitHub https://github.com/JavaFamily 已收录，有一线大厂面试完整考点、资料以及我的系列文章。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aobing/p/14260558.html</dc:identifier>
</item>
<item>
<title>Databricks 第四篇：分组统计和窗口 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/14090399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/14090399.html</guid>
<description>&lt;p&gt;对数据分析时，通常需要对数据进行分组，并对每个分组进行聚合运算。在一定意义上，窗口也是一种分组统计的方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;xref py py-func docutils literal notranslate&quot;&gt;&lt;span&gt;&lt;a class=&quot;reference internal&quot; title=&quot;pyspark.sql.DataFrame.groupBy&quot; href=&quot;https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#pyspark.sql.DataFrame.groupBy&quot;&gt;DataFrame.groupBy()&lt;/a&gt;&lt;span&gt;返&lt;/span&gt;&lt;/span&gt;&lt;span&gt;回的是GroupedData类，可以对分组数据应用聚合函数、apply()函数和pivot()函数。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;常用的聚合函数是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;count()：统计数量&lt;/li&gt;
&lt;li&gt;mean(*cols), avg(*cols)：计算均值&lt;/li&gt;
&lt;li&gt;max(*cols),min(*cols)：计算最大值和最小值&lt;/li&gt;
&lt;li&gt;sum(*cols)：计算累加和&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;举个例子，对DataFrame计算最大的age和height列的值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
df.groupBy().max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).collect() 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;一，聚合函数&lt;/h2&gt;
&lt;p&gt;对于聚合函数，还可以使用pandas中的函数，这需要使用GroupedData类的agg(*exprs)函数，该函数的作用是计算聚合值，并返回DataFrame对象。&lt;/p&gt;
&lt;p&gt;可以用于agg()函数中的聚合函数主要分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内置的聚合函数：avg, max, min, sum, count&lt;/li&gt;
&lt;li&gt;分组聚合的pandas UDF：pyspark.sql.functions.pandas_udf()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于内置的聚合函数，可以通过pyspark.sql.functions来导入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
gdf =&lt;span&gt; df.groupBy(df.name)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyspark.sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; functions as F
sorted(gdf.agg(F.min(df.age)).collect())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[Row(name='Alice', min(age)=2), Row(name='Bob', min(age)=5)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里重点介绍如何创建一个pandas UDF，Pandas UDF由Spark使用Arrow来传输数据，并通过Pandas对数据进行矢量化操作。在创建Pandas UDF时，需要通过pandas_udf作为修饰器或包装函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pyspark.sql.functions.pandas_udf(f=None, returnType=None, functionType=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;f：UDF&lt;/li&gt;
&lt;li&gt;returnType：UDF的返回值类型&lt;/li&gt;
&lt;li&gt;functionType：一个枚举值，它的枚举类型是：pyspark.sql.functions.PandasUDFType，默认值是SCALAR，返回标量值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，创建一个UDF，统计字符的个数。&lt;/p&gt;
&lt;p&gt;在修饰器中定义函数的返回值类型是int，参数的模式是接收一个序列，返回一个序列，序列中的元素的数据类型是由修饰器决定的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyspark.sql.functions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas_udf

@pandas_udf(IntegerType())
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; slen(s: pd.Series) -&amp;gt;&lt;span&gt; pd.Series:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s.str.len()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在定义函数时，显式指定输入参数的类型是MyType，函数返回值的类型是str：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入参数类型提示为MyType，函数返回类型提示为str&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; foo(name: MyType) -&amp;gt;&lt;span&gt; str: 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str(name)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;二，用户自定义的pandas函数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;pyspark共支持5种UDF的模式，分别表示从形参到返回值的模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式1：从DataFrame到DataFrame&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@pandas_udf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col1 string, col2 long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; func(s1: pd.Series, s2: pd.Series, s3: pd.DataFrame) -&amp;gt;&lt;span&gt; pd.DataFrame:
    s3[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;col2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = s1 +&lt;span&gt; s2.str.len()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模式2：从Series到Series&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@pandas_udf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; to_upper(s: pd.Series) -&amp;gt;&lt;span&gt; pd.Series:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s.str.upper()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模式3：从Series到Scalar，这种模式就是聚合函数，把多个值按照公式转换为标量值。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@pandas_udf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; mean_udf(v: pd.Series) -&amp;gt;&lt;span&gt; float:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; v.mean()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模式4：Iterator[pandas.Series] -&amp;gt; Iterator[pandas.Series]&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator
@pandas_udf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; plus_one(iterator: Iterator[pd.Series]) -&amp;gt;&lt;span&gt; Iterator[pd.Series]:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iterator:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; s + 1&lt;span&gt;

df &lt;/span&gt;= spark.createDataFrame(pd.DataFrame([1, 2, 3], columns=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
df.select(plus_one(df.v)).show()
&lt;/span&gt;+-----------+
|plus_one(v)|
+-----------+
|          2|
|          3|
|          4|
+-----------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;模式5：Iterator[Tuple[pandas.Series, …]] -&amp;gt; Iterator[pandas.Series]&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator, Tuple
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyspark.sql.functions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; struct, col
@pandas_udf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; multiply(iterator: Iterator[Tuple[pd.Series, pd.DataFrame]]) -&amp;gt;&lt;span&gt; Iterator[pd.Series]:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; s1, df &lt;span&gt;in&lt;/span&gt;&lt;span&gt; iterator:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; s1 *&lt;span&gt; df.v

df &lt;/span&gt;= spark.createDataFrame(pd.DataFrame([1, 2, 3], columns=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
df.withColumn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;output&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, multiply(col(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), struct(col(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))).show()
&lt;/span&gt;+---+------+
|  v|output|
+---+------+
|  1|     1|
|  2|     4|
|  3|     9|
+---+------+
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;三，apply(udf)函数和applyInPandas(func, schema)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;apply()和applyInPandas()函数的作用是：对每个分组应用函数，计算每个分组的聚合值。&lt;/p&gt;
&lt;p&gt;apply(udf)函数使用 pyspark.sql.functions.pandas_udf() 作为参数，applyInPandas(func, schema)函数使用python 原生函数作为参数。&lt;/p&gt;
&lt;p&gt;例如，apply()函数使用pandas_udf作为参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyspark.sql.functions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas_udf, PandasUDFType
df &lt;/span&gt;=&lt;span&gt; spark.createDataFrame(
    [(&lt;/span&gt;1, 1.0), (1, 2.0), (2, 3.0), (2, 5.0), (2, 10.0&lt;span&gt;)],
    (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
@pandas_udf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id long, v double&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PandasUDFType.GROUPED_MAP)  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize(pdf):
    v &lt;/span&gt;=&lt;span&gt; pdf.v
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pdf.assign(v=(v - v.mean()) /&lt;span&gt; v.std())
df.groupby(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).apply(normalize).show()  
&lt;/span&gt;+---+-------------------+
| id|                  v|
+---+-------------------+
|  1|-0.7071067811865475|
|  1| 0.7071067811865475|
|  2|-0.8320502943378437|
|  2|-0.2773500981126146|
|  2| 1.1094003924504583|
+---+-------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，applyInPandas()使用python 原生的函数作为参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd  
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pyspark.sql.functions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas_udf, ceil
df &lt;/span&gt;=&lt;span&gt; spark.createDataFrame(
    [(&lt;/span&gt;1, 1.0), (1, 2.0), (2, 3.0), (2, 5.0), (2, 10.0&lt;span&gt;)],
    (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize(pdf):
    v &lt;/span&gt;=&lt;span&gt; pdf.v
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pdf.assign(v=(v - v.mean()) /&lt;span&gt; v.std())
df.groupby(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).applyInPandas(
    normalize, schema&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id long, v double&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show()  
&lt;/span&gt;+---+-------------------+
| id|                  v|
+---+-------------------+
|  1|-0.7071067811865475|
|  1| 0.7071067811865475|
|  2|-0.8320502943378437|
|  2|-0.2773500981126146|
|  2| 1.1094003924504583|
+---+-------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四，&lt;strong&gt;pivot()函数&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从当前的DataFrame种透视一列，并执行指定的聚合操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pivot(pivot_col, values=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pivot_col：指定用于透视的列&lt;/li&gt;
&lt;li&gt;values：被旋转为列的值列表，该参数如果为None，表示旋转列的所有值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，按照year进行分组，把course列种的值透视为列，并计算earnings列的累加值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
df4.groupBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).pivot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;course&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotNET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]).sum(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;earnings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[Row(year=2012, dotNET=15000, Java=20000), Row(year=2013, dotNET=48000, Java=30000)]&lt;/span&gt;
&lt;span&gt;
df4.groupBy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).pivot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;course&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).sum(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;earnings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).collect()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;[Row(year=2012, Java=20000, dotNET=15000), Row(year=2013, Java=30000, dotNET=48000)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用于定义DataFrame的窗口，并对窗口进行计算。在进行窗口移动值，窗口的当前行（currentRow）的位置是0，如果position小于0，表示在当前行之前，如果position大于0，表示在当前行之后。&lt;/p&gt;
&lt;p&gt;Window的位置属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;Window.unboundedPreceding：窗口的第一行&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;Window.unboundedFollowing：窗口的最后一行&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;Window.currentRow：窗口的当前行&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;通过窗口函数来创建窗口：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;partitionBy(*cols)：分区&lt;/li&gt;
&lt;li&gt;orderBy(*cols)：排序&lt;/li&gt;
&lt;li&gt;rangeBetween(start, end)：start和end是相对于current row的位置，&lt;/li&gt;
&lt;li&gt;rowsBetween(start, end)：start和end是相对于current row的位置，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，利用这四个函数来创建窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW&lt;/span&gt;
window = Window.orderBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).rowsBetween(Window.unboundedPreceding, Window.currentRow)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; PARTITION BY country ORDER BY date RANGE BETWEEN 3 PRECEDING AND 3 FOLLOWING&lt;/span&gt;
window = Window.orderBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).partitionBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;country&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).rangeBetween(-3, 3)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/api/python/pyspark.sql.html#&quot; target=&quot;_blank&quot;&gt;pyspark.sql module&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 00:38:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>对数据分析时，通常需要对数据进行分组，并对每个分组进行聚合运算。在一定意义上，窗口也是一种分组统计的方法。 分组数据 DataFrame.groupBy()返回的是GroupedData类，可以对分组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljhdo/p/14090399.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之六：OpenAPI基本操作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14260523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14260523.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《Kubernetes官方java客户端》系列的第六篇，以下提到的&lt;span&gt;java客户端&lt;/span&gt;都是指&lt;span&gt;client-jar.jar&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107552722&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之五：proto基本操作 》&lt;/a&gt;已经提到，java客户端的基本功能由两个主要脉络组成，第一个是&lt;span&gt;proto&lt;/span&gt;，主要功能是使用&lt;span&gt;ProtoClient&lt;/span&gt;类提供的增删改查接口，这些接口用到的入参和返回对象所涉及到的java类，都是通过K8S的protobuf生成的；&lt;/li&gt;
&lt;li&gt;除了使用ProtoClient对K8S资源进行增删改查，还提供了另一种更强大的方式：OpenAPI，本章咱们就来一起学习OpenAPI相关的操作；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;k8s的openapi&quot;&gt;K8S的OpenAPI&lt;/h3&gt;
&lt;ol readability=&quot;5.9960707269155&quot;&gt;&lt;li readability=&quot;0.70142180094787&quot;&gt;
&lt;p&gt;先抛开java客户端不提，咱们来看看K8S本身的OpenAPI，地址是：&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/zh/docs/concepts/overview/kubernetes-api/&lt;/a&gt; ，关键信息如下图所示，可见K8S提供了OpenAPI规范：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083311889-685172755.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果您想查看当前K8S环境的OpenAPI规范，请打开K8S环境的/etc/kubernetes/manifests/kube-apiserver.yaml文件，增加下图红框中的内容：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083312368-299401381.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;修改完毕后请稍候，系统会根据文件的变化自动更新（&lt;span&gt;千万不要执行kubectl apply -f kube-apiserver.yaml&lt;/span&gt;，这会导致新建api-server的pod，由于端口占用而启动失败）;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;假设宿主机IP地址是192.168.50.135，那么在浏览器上访问：&lt;a href=&quot;http://192.168.50.135:8080/openapi/v2%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%BE%97%E5%88%B0%E6%89%80%E6%9C%89OpenAPI%E4%BF%A1%E6%81%AF%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A&quot; target=&quot;_blank&quot;&gt;http://192.168.50.135:8080/openapi/v2，就能得到所有OpenAPI信息如下图：&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083313690-174061389.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;上图的原始数据没有可读性，复制到在线JSON格式化网站，得到的内容如下图，例如查询pod列表的API信息已经非常详细了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083314311-2016592843.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以上就是对K8S的OpenAPI简介，接下来回到&lt;span&gt;java客户端&lt;/span&gt;本身，看看它提供了哪些OpenAPI相关的能力；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;java客户端的openapi&quot;&gt;java客户端的OpenAPI&lt;/h3&gt;
&lt;ol readability=&quot;7.2201066260472&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;打开java客户端工程的源码如下图，红框1就是和OpenAPI相关的子工程，提供服务的功能类都在红框2的package中，也就是说，依靠红框2中的API以及红框3中的数据结构，我们可以完成大部分K8S资源控制相关的操作：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083314798-876471326.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开常用的&lt;span&gt;CoreV1Api.java&lt;/span&gt;，如下图红框，顶部的注释已经说明了一切：这些代码都是工具生成的(至于如何生成就不在本文中讨论了):&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083315386-1969092453.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果您下载了java客户端源码，可以在client-java-api这个子工程中看到完整的OpenAPI接口文档：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083316092-416825930.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.6374269005848&quot;&gt;
&lt;p&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107552722&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之五：proto基本操作 》&lt;/a&gt;的代码中，咱们尝试过获取pod列表，但是ProtoClient的已有API不支持提交更详细的业务参数，此时选择OpenAPI接口即可输入详细的业务参数，接口详细信息可以在文档中查到，还带有完整的demo代码，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083316744-197966416.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.74015748031496&quot;&gt;
&lt;p&gt;上图中的&lt;span&gt;listNamespacedPod&lt;/span&gt;接口有两个重要参数：&lt;span&gt;fieldSelector&lt;/span&gt;和&lt;span&gt;labelSelector&lt;/span&gt;，这是过滤用的，详细的用法请参考K8S官方文档，地址是：&lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/working-with-objects/&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/concepts/overview/working-with-objects/&lt;/a&gt; ，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083317243-1173033579.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;弄清楚了K8S的OpenAPI规范，以及java客户端依据此规范生成的API服务，还有详细的接口文档在手，可以编码实战了；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083317453-391001256.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开始编码&quot;&gt;开始编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;a href=&quot;https://www.cnblogs.com/bolingcavalry/p/14260523.html&quot;&gt;《Kubernetes官方java客户端之一：准备 》&lt;/a&gt;中创建的&lt;span&gt;kubernetesclient&lt;/span&gt;工程，在里面新建子工程&lt;span&gt;openapi&lt;/span&gt;，其pom.xml内容如下，要注意的是spring-boot-starter-json已经被排除，因此序列化工具会变为Gson(原本默认是jackson)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;openapi&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;openapi&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for openapi client&amp;lt;/description&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-json&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;新增OpenAPIDemoApplication.java，这是新工程的引导类，也有两个web接口，一个创建namespace，另一个按照namespace查询pod列表，关键位置已添加了注释，就不多赘述了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.openapi;

import com.google.gson.GsonBuilder;
import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.ApiException;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.openapi.apis.CoreV1Api;
import io.kubernetes.client.openapi.models.V1Namespace;
import io.kubernetes.client.openapi.models.V1NamespaceBuilder;
import io.kubernetes.client.openapi.models.V1PodList;
import io.kubernetes.client.util.ClientBuilder;
import io.kubernetes.client.util.KubeConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.PostConstruct;
import java.io.FileReader;

@SpringBootApplication
@RestController
@Slf4j
public class OpenAPIDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(OpenAPIDemoApplication.class, args);
    }

    /**
     * 默认的全局设置
     * @return
     * @throws Exception
     */
    @PostConstruct
    private void setDefaultApiClient() throws Exception {
        // 存放K8S的config文件的全路径
        String kubeConfigPath = &quot;/Users/zhaoqin/temp/202007/05/config&quot;;
        // 以config作为入参创建的client对象，可以访问到K8S的API Server
        ApiClient client = ClientBuilder
                .kubeconfig(KubeConfig.loadKubeConfig(new FileReader(kubeConfigPath)))
                .build();

        // 创建操作类
        Configuration.setDefaultApiClient(client);
    }

    @RequestMapping(value = &quot;/openapi/createnamespace/{namespace}&quot;, method = RequestMethod.GET)
    public V1Namespace createnamespace(@PathVariable(&quot;namespace&quot;) String namespace) throws Exception {

        CoreV1Api coreV1Api = new CoreV1Api();

        V1Namespace v1Namespace = new V1NamespaceBuilder()
                .withNewMetadata()
                .withName(namespace)
                .endMetadata()
                .build();

        V1Namespace ns = coreV1Api.createNamespace(v1Namespace, null, null, null);

        // 使用Gson将集合对象序列化成JSON，在日志中打印出来
        log.info(&quot;ns info \n{}&quot;, new GsonBuilder().setPrettyPrinting().create().toJson(ns));

        return ns;
    }


    @RequestMapping(value = &quot;/openapi/pods/{namespace}&quot;, method = RequestMethod.GET)
    public V1PodList pods(@PathVariable(&quot;namespace&quot;) String namespace) throws ApiException {

        CoreV1Api apiInstance = new CoreV1Api();

        // String | If 'true', then the output is pretty printed.
        String pretty = null;

        // 订阅事件相关的参数，这里用不上
        Boolean allowWatchBookmarks = false;

        // 连续查找的标志，类似于翻页
        String _continue = null;

        //  字段选择器
        String fieldSelector = &quot;status.phase=Running&quot;;

        // 根据标签过滤
        // String labelSelector = &quot;component=kube-apiserver&quot;;
        String labelSelector = null;

        Integer limit = null;
        String resourceVersion = null;
        Integer timeoutSeconds = null;
        Boolean watch = false;

        V1PodList v1PodList = apiInstance.listNamespacedPod(namespace,
                pretty,
                allowWatchBookmarks,
                _continue,
                fieldSelector,
                labelSelector,
                limit,
                resourceVersion,
                timeoutSeconds,
                watch);

        // 使用Gson将集合对象序列化成JSON，在日志中打印出来
        log.info(&quot;pod info \n{}&quot;, new GsonBuilder().setPrettyPrinting().create().toJson(v1PodList));

        return v1PodList;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot; readability=&quot;-0.40178571428571&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将&lt;span&gt;OpenAPIDemoApplication&lt;/span&gt;运行起来，先测试创建&lt;span&gt;namespace&lt;/span&gt;的服务，在浏览器访问：&lt;a href=&quot;http://localhost:8080/openapi/createnamespace/dddeeefff&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/openapi/createnamespace/dddeeefff&lt;/a&gt; ，浏览器返回信息如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083317772-414857237.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SSH登录K8S主机，执行命令查看namespace，如下图红框，已经创建成功：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083318209-1449136896.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;再试试Pod列表，地址是 ：&lt;a href=&quot;http://localhost:8080/openapi/pods/kube-system&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/openapi/pods/kube-system&lt;/a&gt; ，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210111083318743-2114738124.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;至此，OpenAPI接口的实践就完成了，现在已将java客户端的最基本的功能都实践过了，接下来的文章咱们将开始学习精彩的高级功能；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 11 Jan 2021 00:33:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14260523.html</dc:identifier>
</item>
<item>
<title>如何在面试中介绍自己的项目经验（面向java改进版） - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/14247947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/14247947.html</guid>
<description>&lt;p&gt;    本人于3年前写的博文，&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/7586949.html&quot;&gt;如何在面试中介绍自己的项目经验&lt;/a&gt;，经过大家的捧场，陆续得到了将近7万个点击量，也得到了众多网站公众号的转载，不过自己感觉，这篇文章更多的是偏重于方法，没有具体给到Java方面相关的说辞。&lt;/p&gt;
&lt;p&gt;    三年过去了，随着本人面试官经验的积累，也随着技术的进步，本人就用适合当下2021年Java初级开发的面试场景，改写本文。请注意，这篇文章并不是简单的技术升级，也没有机械地教大家在介绍项目经验时背诵若干说辞，而是教大家如何结合项目经验更好地展示自己的技术亮点，这样就能最大程度地提升面试通过的可能性。&lt;/p&gt;
&lt;h2&gt;1  用简历争取到更多的面试机会&lt;/h2&gt;
&lt;p&gt;    本不想写这段，但最近我在帮一些同学准备简历时，发现他们虽然在当前公司里能胜任Java开发的工作，但凭简历恐怕无法得到面试机会，或者无法得到和自己相匹配的工资。而且准备简历的过程，也是准备项目说辞的过程，所以这里就一并把写简历的注意要点写上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    注意点1：阅读职位介绍上的技能要求年限，在简历上的醒目位置标明你有足量的相关技术项目经验。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    比如某职位需要有Spring boot 3年经验，又如某职位需要有2年大数据开发经验，而你恰好有了，就在简历第一页个人信息介绍下直接写明。&lt;/p&gt;
&lt;p&gt;    万一假设你缺乏一些，比如要求是有2年大数据，而你就只有一年，你就回想下，你在读书阶段，有没有在外面做过兼职，有没有帮老师一起做过项目，有的话别客气，把这部分的技术年限也加上。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;   注意点2：再仔细阅读职位介绍上要求的技术，也列在第一页的醒目位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    比如某职位需要有jave核心开发，多线程开发经验，分布式组件开发经验。其实对做开发的人来说，这些技术多少在项目里也用过，但如果你不写上，甚至你的简历没法过筛选，甚至你没有面试机会。 &lt;/p&gt;
&lt;p&gt; &lt;strong&gt;   注意点3：再多少写些你的亮点，怎么写看下面的范例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    也就是说，在简历第一页，你写好姓名性别年龄和手机邮箱等基本信息后，一般可以用如下概要的形式，向面试官展示你和职位的匹配度，如下是范例。&lt;/p&gt;
&lt;p&gt;    1 具有3年Java开发经验，2年Spring Boot开发经验，2年数据库开发经验。（这里的年限需要大于等于职位介绍上的要求，如果达不到，很多公司就不给面试机会）&lt;/p&gt;
&lt;p&gt;    如下再根据职位介绍上要求的技术，总纲性列出你掌握的技术，以此证明你很匹配&lt;/p&gt;
&lt;p&gt;    2 有Oracle，MySQL等数据库开发经验。&lt;/p&gt;
&lt;p&gt;    3 有多线程，集合等方面的开发经验&lt;/p&gt;
&lt;p&gt;    4 有大数据方面的xx技术和xx技术的开发经验。&lt;/p&gt;
&lt;p&gt;    这里你可以尽可能多地列出你掌握的JD上的技能，然后，你可以照着如下的范例列些你的亮点。&lt;/p&gt;
&lt;p&gt;    5 具有用索引，执行计划进行数据库调优的经验。（当前不会就自己查，这块资料太多）&lt;/p&gt;
&lt;p&gt;    6 熟悉Java JVM虚拟机结构，熟悉垃圾回收流程，有JVM性能调优的经验。（当前不会也自己查）&lt;/p&gt;
&lt;p&gt;    7 有在linux分析日志和排查问题的经验。（如果不会就去看些linux文件打开和搜索的相关命令）&lt;/p&gt;
&lt;p&gt;    8 熟悉面向对象思想，在项目里用过设计模式。（自己去看个单例或工厂模式，然后套到项目需求里）&lt;/p&gt;
&lt;p&gt;    9 有分布式组件的开发经验。（如果没有就别写，但对初级开发来说，这绝对是加分项）&lt;/p&gt;
&lt;p&gt;    10 熟悉Java集合等方面的底层代码。（自己去看HashMap，ConcurrrentHashMap，快速失效,ArrayList增删改查的底层代码，不难）&lt;/p&gt;
&lt;p&gt;    11 工作责任心强，具有一定的承压能力，肯加班。（写上去总不会错）&lt;/p&gt;
&lt;p&gt;    其实对大多数初级开发而言，应该都具备上述技能，哪怕当下不具备，用个把月绝对也能学会，所以大家完全可以写在简历上。&lt;/p&gt;
&lt;p&gt;    但我收到的很多Java开发的简历，只是简单地列出会的技术，没有任何润色性的文字，这样的简历或许就无法完全地展示候选人的能力，对应地，得到的面试机会可能就大大降低了。&lt;/p&gt;
&lt;p&gt;    相反，姑且先不论候选人是培训班出身还是科班出身，但就凭在简历第一页醒目地展示和该职位的匹配度，至少面试官就肯继续往下看项目经验了，这样得到面试的机会，乃至通过面试的机会，就大大增加了。&lt;/p&gt;
&lt;h2&gt;2  自我介绍时，立即全面抛出技术栈和亮点&lt;/h2&gt;
&lt;p&gt;    在面试的开始阶段，面试官大概率会让候选人自我介绍，这部分别的不用说，就直接根据上文给出的简历上列出的总纲性要点介绍自己，如下给出范例说辞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    先说技能和jd的匹配度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    我叫张三，今年25岁，18年从交大大学毕业，计算机系，目前有3年Java开发经验（这个是jd上的要求），有Oracle,MySQL的开发经验，有xx等技术经验（这些经验也是jd上的要求）&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;再说自己的亮点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在项目里，我用过用索引和执行计划等进行数据库调优经验，有JVM方面排查OOM的经验，大数据方面，用过Spark等框架，分布式组件方面，用过Redis和Dubbo等，有在linux上看日志然后排查线上问题的经验。&lt;/p&gt;
&lt;p&gt;    其实天地良心，上述提到的亮点，除了大数据spark以外，其它技能亮点初级开发应该都会，哪怕不会也能轻易学会。但就这样，很多候选人不会说，不过反过来，你说了就比别人强。&lt;strong&gt;然后立即引申出最近的项目，因为大多数公司会衡量jd技术是否在最近项目里用过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在最近的项目里，我用到了Spring Boot框架，具体用到了JPA组件，数据库用Oracle，最近的项目是xx系统，用到了敏捷开发模式，在这个项目里，我除了做coding外，还做过单元测试，讨论需求和详细设计等工作，并且最近的项目进度比较紧，我自己感觉还能主动加班，一起和同事们保质保量地完成项目。&lt;/p&gt;
&lt;p&gt;    在自我介绍阶段甚至也不必展开项目，因为后面你有机会详细说明，但你第一要以此进一步突出你最近的技能经验和职位介绍很匹配，第二还要以此说明你肯加班等特性(毕竟通过项目举例说明自己肯加班，比单纯说肯加班要可信得多)。&lt;/p&gt;
&lt;p&gt;     再强调下，在自我介绍阶段，只需要说明自己能胜任当前工作的要点，这些要点不需要展开，比如不必展开说明自己如何排查OOM异常的。而其它没和找工作没关系的，比如兴趣爱好，家庭成员，个人性格等一概不需要说。&lt;/p&gt;
&lt;p&gt;    大家在面试前，可以根据上述范例练习下说辞，不紧不慢地说这些话，估计也就需要2分钟，哪怕再腼腆再内向口才再不好的人，多练几遍也能说好，但如果因为没说好被面试官认为沟通能力差，就太冤枉了。&lt;/p&gt;
&lt;h2&gt;3  先介绍项目背景，打消面试官疑问&lt;/h2&gt;
&lt;p&gt;    由于你在自我介绍阶段已经涉及到最近项目了，所以面试官一定就会再问下去。不过不管怎么样，面试官总会问及你最近的项目，所以你总是有机会通过介绍项目经验来验证自己能胜任这份工作。&lt;/p&gt;
&lt;p&gt;    当面试官让你介绍下最近的项目时，你可以先大致先说下项目背景。因为有些候选人在简历上的项目经验看上去就像学习项目（其实我知道不少项目经验还真是），但你可以通过如下的说辞，证明这个项目是商业项目经验。&lt;/p&gt;
&lt;p&gt;    我最近是在xx公司（以此突出商业项目）里做了xx项目，这个项目的客户方是xx，已经上线（但如果是web项目面试官大概率会去核对）。这个项目用到了敏捷开发模式（提一下别展开，算抛出个提问点）， 这个项目组人员是xx人，做了n个月，我在里面做了xx和xx模块。 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;   &lt;/em&gt; 你这样一说，能通过项目所在公司和客户方等要素，说明这个项目不是你编的。有人会问了，如果项目真的是编的，该怎么说？这块我不管，你自己想办法说。&lt;/p&gt;
&lt;p&gt;    但你这样说之前，事先需要做好如下的功课。&lt;/p&gt;
&lt;p&gt;    1 了解敏捷开发模式，比如站会每个人该说什么，用jira管理进度，一年定好若干个发布日期，一个月发布一次等，因为你提到了，面试官大概率后继会问到。&lt;/p&gt;
&lt;p&gt;    2 如果你说的是xx财务系统xx图书馆系统等，一些资深的面试官可能会问，这块有现成的项目，为什么你们公司还要自己开发？所以说你在准备项目描述时，不能夸张，比如把一个数据收集模块的维护项目夸张成xx财务系统。不过我也遇到过一些候选人，他们就说这是公司接的项目，为什么人家还要下订单做此项目他们管不着。&lt;/p&gt;
&lt;p&gt;    3 你一旦说了这个项目，那么面试官就会认为你真实做过，所以其中每个业务需求，比如数据从哪里收集，客户从哪个前端发请求，客户请求处理的流程，以及数据表的规模等信息，你得知道并且事先准备好回答预案，我就经常用此来确认候选人的项目是真实项目还是编的项目。 &lt;/p&gt;
&lt;h2&gt;4 通过说项目管理工具，说明你不仅会写代码&lt;/h2&gt;
&lt;p&gt;     在介绍项目背景之后，你更可以说些项目管理的工具，以此证明你在项目里还做过其它事情，不仅是仅会写代码，具体的说辞范例如下。&lt;/p&gt;
&lt;p&gt;    在这个项目里，我们用到了maven，用git来管理代码，用jira来管理任务和bug，用jenkins工具来发布。我还用过junit编写过单元测试，我们还用sonar来统计代码的测试覆盖度，我们项目经理要求，只有当“行覆盖率高于80%”，代码才能提交。&lt;/p&gt;
&lt;p&gt;    上文提到maven，Git和junit这块不难，jira管理bug和task这个也没什么可问，但你要事先了解下sonar管理代码质量的基础知识以及行覆盖率等要点，至于jenkins发布脚本，这个无需一般开发操心，你说下就行了。在上文里你仅仅提到的是工具，但你更要通过这些工具，来进行自我表扬。&lt;/p&gt;
&lt;p&gt;    我在使用junit时，不会敷衍地编写案例，而会根据真实的业务数据来编写案例，并且我还会着重考虑各种边界情况（这些哪怕初级开发也有本事做到），而且在编写代码时，我会非常注意编码规范，比如定义变量时会让人一看就理解 ，在关键代码地方多写注释，在if等条件里不会写太复杂，一个方法不会写太长，或者你可以再说些其它好的编码规范。而且，一旦遇到我的bug，我会第一时间跟进，并会和相关对应的人一起解决掉。&lt;/p&gt;
&lt;p&gt;    上述文字，虽然说是自卖自夸，但由于你结合到了项目，所以面试官不会有违和感。而且你这样一说，面试官就会认为你除了写代码外，其它开发项目的综合能力也很强。&lt;/p&gt;
&lt;p&gt;    不过千万注意，介绍项目经验的目的主要是证明技能的匹配度，所以上文提到的“介绍项目背景”和“说明项目用到的工具”以及“自卖自夸”的说辞，你别说太多，可以通过练习把它们控制在1分钟以内。&lt;/p&gt;
&lt;h2&gt;5  用Spring Boot项目举例，说明你的技术基本面&lt;/h2&gt;
&lt;p&gt;    然后就需要介绍项目里用到的技术，哪怕你的亮点说辞再说，你也得保证技术的基本面说辞，这里就用当前Java项目的主流框架Spring Boot为例，告诉大家如何以此展示Java开发的基本功。&lt;/p&gt;
&lt;p&gt;    我们这个项目用到了Spring Boot框架，其中用JPA连接Oracle（或MySQL等）数据库，在控制层里用到了@RequestMapping注解来编写业务处理方法。在业务代码里，是用@Autowired注解来以IOC的方式引入类，还用到了@Service和@Component注解。当我们从数据库里拿到数据后，会用包含@Entity和@Table注解的模型类来映射数据。在这个项目里，我们还用到了@Transactional注解来定义事务，这个注解是作用在Service层上的，在这个项目里，我们还用到多个Java集合类和异常处理类。&lt;/p&gt;
&lt;p&gt;    通过上文的范例，大家应该可以很好地展示Spring Boot的基本技术面，其实对大多数Java初级开发而言，日常工作也就是用Spring Boot写一些增删改查的工作，所谓根据现有的业务再编写新的业务，所以上述说辞足够了。但是由于你提到了Spring Boot，所以在提问阶段，面试官大概率会问及如下的问题。&lt;/p&gt;
&lt;p&gt;    1 @Service和@Component注解的差别？ &lt;/p&gt;
&lt;p&gt;    2 各种Restful请求格式以及各种http请求返回码。&lt;/p&gt;
&lt;p&gt;    3 @Transactional事务里的事务隔离级别和事务传播机制概念。&lt;/p&gt;
&lt;p&gt;    4 Spring依赖注入概念和@Autowired的用法。&lt;/p&gt;
&lt;p&gt;    5  Spring Bean的生命周期。&lt;/p&gt;
&lt;p&gt;    6  甚至可能还会问Spring Boot启动流程以及底层源码。&lt;/p&gt;
&lt;p&gt;    对Java 0到3年的初级开发而言，其实能按本范例给出的说辞，并结合网上题目说好前4个问题，应该就足以应对大多数的面试了。 &lt;/p&gt;
&lt;h2&gt;6  用实例说明你在内存调优方面的经验&lt;/h2&gt;
&lt;p&gt;    当你介绍好基于Spring Boot的技术基本面以后，你还可以进一步说明诸多亮点，这里就先给出结合项目展示内存调优方面说辞的范例。&lt;/p&gt;
&lt;p&gt;    （之前是介绍项目技术基本面，比如Spring Boot）在本项目里，我会非常注意内存的使用性能，并在项目里有过排查分析OOM的项目经验，我在编码的时候，也会非常注意内存性能，同时我也了解过JVM内存结构以及GC算法。&lt;/p&gt;
&lt;p&gt;    不管怎么组织语言，这方面你需要突出四点：第一强调你有内存调优意识，第二说明你有排查OOM的经验，第三说明你写代码的时候也会注意内存性能，第四说明你还了解JVM结构和GC流程的知识。但这里依然要强调，你尚在项目介绍阶段，你说明要点即可，别展开，如果这里你展开说明内存调优的做法，面试官会认为你思路不清晰，不过既然你提到了，面试官可能立即就打断你介绍让你详细说明，或者你介绍完项目后会继续问，总之你是有机会详细展示内存调优亮点技能了。&lt;/p&gt;
&lt;p&gt;    这里不仅给出项目介绍阶段怎么说，还会给出你后继如何详细回答。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;如果面试官事后详细问你排查OOM经验细节时，你可以这样回答。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在测试环境，我们经常会收到内存使用率高于70%的告警，（至于怎么告警的相关设置，你可以看下new relic，如果你是初级开发，甚至不需要掌握相关经验），收到告警后，我第一通过dump命令观察当前内存镜像（你得熟悉下dump命令以及dump文件的打开方式和dump文件的内容），第二通过日志观察是哪个方法抛出的，最后发现是因为在订单模块（或其它模块）&lt;strong&gt;一个JDBC连接对象没关闭（或一个大的Hashmap对象用好没clear）&lt;/strong&gt;，所以导致了内存无法回收，发现问题后对应回收掉即可。   &lt;/p&gt;
&lt;p&gt;    这里你结合的业务（比如订单模块）来说明，然后面试官再问dump细节时，你再说下dump文件的结构，这就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    如果面试官再问你如何在代码里注意内存性能，你可以这样说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在写代码时，我会非常注意，在try...catch...finally从句里关闭或释放Connection和大的集合，一些大的对象用好以后，我会及时把它们设置成null，以此提升它们的回收时间，在for等循环里，我不会频繁地操作String对象，因为会产生大量内存碎片。同时，我会非常谨慎地使用finalize方法（事先看下），因为这可能会导致对象无法回收。&lt;/p&gt;
&lt;p&gt;    其实说上这四点就够了， 如果你自己感觉有本事，可以在了解强引用、弱引用和软引用的前提下在说如下的点，这很值钱。 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;   &lt;/em&gt; 在数据同步的业务场景里，我用到了弱引用（或软引用），以此提升数据对象的回收时间。&lt;/p&gt;
&lt;p&gt;    如果面试官问你JVM内存结构及GC（垃圾回收）流程，这其实是理论问题，网上资料太多，靠背就行了，所以这里就不再详细说了。但话说回来，GC流程以及JVM体系结构这方面的理论知识，这属于面试常用考点，你准备下不吃亏。 &lt;/p&gt;
&lt;h2&gt;7  展示你在数据库调优方面的经验&lt;/h2&gt;
&lt;p&gt;    很多候选人其实不会在面试中展示内存调优方面的经验，而你如果按照上述说辞，一方面在介绍项目经验时引出要点，另一方面在后继交流中很好地说明细节，那么可以这样说，你就超越了很多竞争者，甚至说句不该说的话，一些初级开发甚至还能以此充实自己的项目经验。&lt;/p&gt;
&lt;p&gt;    在介绍项目经验时，如果单纯展示内存调优方面的经验，可能说服力不强，这里再给出用实际说明数据库调优技能的范例。首先你可以在介绍项目时，适当地通过如下的说辞来引入要点。&lt;/p&gt;
&lt;p&gt;    在本项目里，我参与过数据表设计，所以会考虑用反范式来避免因大表关联而导致的性能损耗，同时我们会合理地设置索引以提升数据库的访问性能，并且我还有过用&lt;strong&gt;执行计划&lt;/strong&gt;优化语句的经验，同时在使用事务的时候，我会非常注意配置事务隔离级别和事务传播机制，以免造成锁表。&lt;/p&gt;
&lt;p&gt;    同样，在项目介绍阶段，数据库调优方面的说辞不需要展开，给出点即可，由于你提到了，所以面试官在后面大概率会问到。&lt;/p&gt;
&lt;p&gt;    不过你在面试前，需要准备如下的技能（其实这些技能属于数据库基本点，你不准备反而会有问题）。&lt;/p&gt;
&lt;p&gt;    1 你去看下索引的数据结构（比如B+树），建索引的语句，索引的种类，尤其是复合索引以及对应的回表和最左匹配原则。&lt;/p&gt;
&lt;p&gt;    2 事先看下索引的正确用法，以及哪些情况下用不到索引，比如where a != 'xx'可能就用不到。&lt;br/&gt;    3 索引的代价（会占硬盘，以及大批量读写时会重建索引，所以性能慢），以及在小表里，无需建索引。&lt;/p&gt;
&lt;p&gt;    4执行计划的概念，以及通过执行计划排查慢sql时该注意的点（避免全表扫描，设置合理的关联表方式等）。&lt;/p&gt;
&lt;p&gt;    5 三范式和反范式相关概念，因为你提到了。&lt;/p&gt;
&lt;p&gt;    6 事务隔离级别里的脏读等概念，以及事务传播机制，尤其地，你要具体说出你项目里用的是哪个。&lt;/p&gt;
&lt;p&gt;    其实上述点属于面试常考点，但根据我面试下来的结果，一些有3年java开发经验的候选人也未必能说好，不过再一次天地良心，这些技能点不难学，大多靠背就行，所以哪怕你刚毕业，或者只具备少量的开发经验，只要靠用功背下这些要点，一方面在介绍项目时就能很好地亮出要点，另一方面还能很好地应付后继的数据库问题，这样你的表现就足以超出大多数你的竞争者。   &lt;/p&gt;
&lt;h2&gt;8 总结前文说辞&lt;/h2&gt;
&lt;p&gt;    这里根据上文给出的要点，整理下介绍项目经验的说辞。&lt;/p&gt;
&lt;p&gt;    (介绍项目背景)我最近的项目是在xx公司做的xx社区爱心超市项目（项目别说太大），客户方是xx公司，项目组里是6个人，开发了八个月，最近还在开发，在其中我做了删除和更新订单模块的业务 （如果是在校阶段做的项目需要再加上如下的话），这个项目是我从大三开始，外面找xx公司做的兼职项目，做项目的时候我每月还能拿到钱。 &lt;/p&gt;
&lt;p&gt;    （介绍项目技术，JD上列的尽量说全）这个项目用到了Spring Boot框架，数据库是Oracle，用JPA连接Oracle（或MySQL等）数据库，在控制层里用到了@RequestMapping注解来编写业务处理方法。在业务代码里，是用@Autowired注解来以IOC的方式引入类，还用到了@Service和@Component注解。当我们从数据库里拿到数据后，会用包含@Entity和@Table注解的模型类来映射数据。在这个项目里，我们还用到了@Transactional注解来定义事务，这个注解是作用在Service层上的，在这个项目里，我们还用到多个Java集合类和异常处理类。&lt;/p&gt;
&lt;p&gt;    （介绍项目管理工具）这个项目用到了敏捷开发模式，用Maven框架，用sonar管理质量，用git管理项目版本，用jenkins发布，用logback打日志， 我在这个项目里，除了写代码外，还有用Junit进行单元测试的经验。我们还用sonar来统计代码的测试覆盖度，我们项目经理要求，只有当“行覆盖率高于80%”，代码才能提交。&lt;/p&gt;
&lt;p&gt;    （最后抛出亮点）在这个项目里，我用到了单例和工厂设计模式，在这个项目里，我做过JVM调优和数据库调优的的事情，在做项目时为了加深理解，我还看了ArrayList快速失效的底层代码，也看过HashMap关于HashCode以及put和get部分的底层源码。这个项目后期进度比较紧，我也能通过加班等手段保证项目能正常上线，而且一旦遇到线上问题，我也会尽量参与并解决。&lt;/p&gt;
&lt;p&gt;    大家在面试前，可以根据上述范例合理地准备说辞，次序和内容上可以做调整，但包含的几个要素尽量都说全。如果可以，事先要多练习几遍，确保能足量地抛出你的相关技能和亮点。&lt;/p&gt;
&lt;p&gt;    不过千万注意，在介绍项目时，对具体的点，比如内存调优，你点到为止，别展开，否则的话，面试官一定会认为里思路不清晰。总之在介绍项目时，需要遵循的要点是：第一要尽可能全面地说明你用过JD上的技能，第二要抛出亮点话题，等待面试官提问。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;9 准备项目说辞时，更可以准备后继面试官的问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    其实大多数面试官在面试前，有可能还在调试代码，或者还在开会，也就是他们事先是不会准备面试问题的。所以当你在自我介绍和介绍项目经验时抛出亮点后，他们往往会随口接着这个话题问下去，也就是说，只要实现准备好，你是知道面试官会问什么的。&lt;/p&gt;
&lt;p&gt;    根据上文给出的项目介绍说辞，你提到了敏捷开发，Spring Boot框架，数据库调优，内存调优，设计模式，junit以及项目管理软件，java集合以及底层源码等话题，在前文里也给出了一些面试官可能问到的问题以及对应的准备要点，除此之外，大家还可以做如下的准备。&lt;/p&gt;
&lt;p&gt;    1 理解单例模式，尤其是双重检查的单例模式，要会写代码，并给出一个项目使用场景，比如某工具类需要用单例的方式创建。同样地，对于工厂模式也准备一个使用场景，这更好办，比如xml解析器类，是用Factory模式创建的。&lt;/p&gt;
&lt;p&gt;    2 在理解的基础上，背诵并会默写ArrayList快速失效的底层代码，面试时，当面试官顺着你给出的言辞继续提问时，你可以边写边说，同时也可以准备HashMap以及Hashcode的底层源码。&lt;/p&gt;
&lt;p&gt;    3 去看下JVM内存调优和垃圾回收相关理论，最好再看下强引用，弱引用和软引用理论。&lt;/p&gt;
&lt;p&gt;    这里请注意，你在自我介绍和项目介绍时，可以通过抛出亮点来引导面试官提问，但同时，你更需要准备其它常见问题，因为有些面试官依然会问其它问题。对此大家可以在Spring Boot框架，数据库和Java核心开发这三个方面多刷些面试题，甚至可以多准备些笔试题。那么这样一说，你抛出亮点有什么好处呢？&lt;/p&gt;
&lt;p&gt;    第一，真有些面试官在顺着你言辞提问后，发现你回答很好（因为你事先准备过，想不好回答都难），然后他们就不再提问了。&lt;/p&gt;
&lt;p&gt;    第二，面试官多少会问及些你提到的亮点，这样你就能最大程度避免面试官问及你不熟悉的点。&lt;/p&gt;
&lt;p&gt;    第三，其实大多数初级开发在项目中只是做增删改查，但一方面你根据上文描述准备了若干常稳点，另一方面你能很好证明你熟悉设计模式，有JVM和数据库调优经验，那么你就有可能在面试中表现比其它人强。&lt;/p&gt;
&lt;p&gt;    总之，你在准备项目经验的前提下准备些基础和亮点技术点，准不会吃亏。 &lt;/p&gt;
&lt;h2&gt;10 总结：本文所含的说辞和方法足以应对初级面试官&lt;/h2&gt;
&lt;p&gt;     本人最近在帮上海一家知名培训学校的学员做面试辅导，在教他们用上述方法和说辞准备简历和准备项目介绍说辞后，他们均成功地找到工作。而且有好几位同学，有2到3年开发经验，本来期望工资是11到13k一个月（毕竟是培训班出身不敢要高）。我全程辅导让他们通过技术面试后，在谈薪资时，我好说歹说让他们至少要15k， 当他们硬着头皮咬着牙说出口后，均成功拿到这个价，而且一位胆子比较大的同学，还要到了16.5k。现在他们已经开始担心入职后怎么过试用期了，不过这是后话，如果我有时间还会写文章介绍此类经验。&lt;/p&gt;
&lt;p&gt;    这才是我敢在这篇博文里介绍相关方法和说辞的底气。除此之外，我敢写这篇博文的底气还在于我的多年技术面试官经验，以及我还出的两本面试书。对培训班毕业生尚且如此，如果大家最近还在软件公司里真刀真枪地干项目，那么我敢说这篇文章对大家的帮助更大。&lt;/p&gt;
&lt;p&gt;    也就是说，通过本文给出的技巧，大家足以能应对一些面试经验不足2年的初级面试官，当然，如果要去支应一些资深面试官（比如我），光凭此应该还不够，更需要在面试中展示多线程、分布式组件，微服务框架以及高并发等方面的技能，对此本人将在后继的文章里继续给出相关的技巧。&lt;/p&gt;
&lt;p&gt;    请大家关注我的公众号：一起进步，一起挣钱，在本公众号里，会有更多精彩文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226172/202101/1226172-20210109221844983-878996607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 11 Jan 2021 00:23:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>本人于3年前写的博文，如何在面试中介绍自己的项目经验，经过大家的捧场，陆续得到了将近7万个点击量，也得到了众多网站公众号的转载，不过自己感觉，这篇文章更多的是偏重于方法，没有具体给到Java方面相关的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaArchitect/p/14247947.html</dc:identifier>
</item>
<item>
<title>二进制小总结 - 伯乐钟情</title>
<link>http://www.cnblogs.com/lbole/p/14260496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbole/p/14260496.html</guid>
<description>&lt;p&gt;本文主要做计算机中的整数相关总结，包括机器值与真值、原码/反码/补码、java中的数据类型以及类型转换等，最后分享可变长整型的编码方式（varints+ZagZig）&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;312.5&quot;&gt;
&lt;h3 id=&quot;真值与机器值&quot;&gt;真值与机器值&lt;/h3&gt;
&lt;p&gt;  真值很好理解，就是十进制的数字前面再加上正负号，这是人类可以简单识别的数字，比如 0、±16、±1084、±10.34、±100.453 等，而正数前面的+符号可以省略。机器值从字面理解就是机器（计算机）识别的值，实际上也确实是这个意思。&lt;/p&gt;
&lt;p&gt;  计算机中通过高低电平表示1或者0，这样就可以表示一个二进制的数值。一个1或者0表示的数值位称为一个bit，而计算机中存储和传输数据的最小单位是一个字节（byte）也就是8个bit，所以说计算机所有计算本质上都是基于二进制。&lt;/p&gt;
&lt;p&gt;  在计算机中，我们可以使用1个或者多个字节存储一个数，但无论是多少个字节，其大小肯定是固定的，同时其所能表示的数值的范围也是固定的。比如说对使用1个字节存储的数进行计算或者传输，那么这个数所能表示的最小值为00000000最大值为11111111，转换为十进制为0 ~ 255。那么无论对这个数做了什么计算，无论计算之后的结果为多少都不能超出这个范围，同理使用2个字节存储的数范围为0 ~ 65535。&lt;/p&gt;
&lt;p&gt;  由于很多时候一个数据需要使用2个或者2个以上的字节表示，那么这种数据无论是存储还是传输的时候都会有一个顺序的问题，也就是大小端对齐（字节序）问题。在存储时高位字节在前为大端对齐，反之为小端对齐。在数据传输时先传输高位字节为大端字节序，反之为小端字节序。目前绝大多数平台内部都是小端对齐的方式存储数据，而大多数通信协议却都是用大端字节序传输数据，所以这一点值得注意一下。&lt;/p&gt;
&lt;h3 id=&quot;符号位与数值位&quot;&gt;符号位与数值位&lt;/h3&gt;
&lt;p&gt;  计算机中使用二进制存储传输和计算数值，但是不能只有数值，计算的时候还得有正负之分。在计算机中使用最高bit位的数值来表示正负号，这个bit位称作符号位。&lt;/p&gt;
&lt;p&gt;  计算机中符号位的值为0表示这个数为正数，符号位值为1表示这个树为负数。由于符号位表示符号所以其不表示具体的值，除开符号位剩余的bit位用来表示数值也就是数值位。比如1个字节的整数&lt;span&gt;0&lt;/span&gt;0000001，其中最高bit（最左边）位的0为符号位，表示这个数为正数，数值位为1，所以其真值为1。同理2个字节的整数&lt;span&gt;0&lt;/span&gt;0000000_0000001，其真值也是1。&lt;/p&gt;
&lt;h3 id=&quot;原码、反码和补码&quot;&gt;原码、反码和补码&lt;/h3&gt;
&lt;p&gt;  计算机只识别机器码，其实也就是二进制数，并且使用最高bit位表示符号位。那么两个真值为8和-8的8位整数，它们在计算机内部的机器值是否就分别是&lt;span&gt;0&lt;/span&gt;0001000和&lt;span&gt;1&lt;/span&gt;0001000？其实并不是，这只是8和-8的原码，而机器算计中的机器值是使用补码存储和计算的。&lt;/p&gt;
&lt;p&gt;  计算机中，正数的原码、反码和补码是一样的，所以上面那个例子中，真值为8的8位整数的机器值确实是&lt;span&gt;0&lt;/span&gt;0001000，但是-8就不是这么回事了。负数的首先将原码数值位按位取反得到反码，然后再将反码数值位加1之后则得到补码。我们来看一下-8这个例子，其原码为&lt;span&gt;1&lt;/span&gt;0001000，数值位按位取反之后的反码为&lt;span&gt;1&lt;/span&gt;1110111，然后数值位加1之后的补码为&lt;span&gt;1&lt;/span&gt;1111000。所以真值为-8的8位整数在计算机中的机器值为&lt;span&gt;1&lt;/span&gt;1111000，我们来看下面这张表&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;原码&lt;/th&gt;
&lt;th&gt;反码&lt;/th&gt;
&lt;th&gt;补码&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int8&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;0000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;1111110&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;1111111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int16&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;0000000_00000001&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;1111111_11111110&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;1111111_11111111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;em&gt;注：int8为8bit位整数占用1byte，int16为16bit位整数占用2byte。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;  刚说的是原码转补码的步骤，其实补码转原码的步骤是一样的。首先正数的原码补码是一样的不需要转换，我们看负数&lt;span&gt;1&lt;/span&gt;1111000，首先将数值位按位取反得到&lt;span&gt;1&lt;/span&gt;0000111，然后再将数值位加1得到&lt;span&gt;1&lt;/span&gt;0001000。我们再来看一个8位的整数&lt;span&gt;1&lt;/span&gt;0000000，是不是发现这个数原码和补码是一样的，那么这个看起来像是“-0”的数是怎么回事呢？其实可以将这个数看成是一个特殊值，它的真实含义就是最小值。8位的这种“-0”的真值为-128，16位的这种“-0”真值为-32768。所以只需要记住&lt;span&gt;1&lt;/span&gt;00...000这种补码就是最小值就行，我们看下面的这张表&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#EFF3F5&quot;/&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;二进制补码&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;十进制&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int8&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;0000000&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;-128&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;int16&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;0000000_00000000&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;-32768&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;int32&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;0000000_00000000_00000000_00000000&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;-2147483648&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;int64&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;0000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;-9223372036854775808&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  有两对8bit位的整数4、8和4、-8，我们分别看一下他们在计算机中是怎么做加法计算的。首先看4和8的补码分别为&lt;span&gt;0&lt;/span&gt;0000100和&lt;span&gt;0&lt;/span&gt;0001000，只需要将每个bit位相加就行，结果为&lt;span&gt;0&lt;/span&gt;0001100，其真值为12。我们再来4和-8的计算，它们补码分别为&lt;span&gt;0&lt;/span&gt;0000100和&lt;span&gt;1&lt;/span&gt;1111000，然后将它们按位相加（注意符号位也要做加法）得到&lt;span&gt;1&lt;/span&gt;1111100，其原码为&lt;span&gt;1&lt;/span&gt;0000100，真值为-4。&lt;/p&gt;
&lt;p&gt;  再来看一下减法计算，比如8bit位的整数-8减去4，首先可以将4处理一下可以变为(-8) + (-4)，这样是不是就又变为了加法了？-8和-4的补码分别为&lt;span&gt;1&lt;/span&gt;1111000和&lt;span&gt;1&lt;/span&gt;1111100，将它们按位相加得到补码&lt;span&gt;1&lt;/span&gt;1110100（注意这是8位的整数，超出部分发生了溢出），转换成原码为&lt;span&gt;1&lt;/span&gt;0001100，真值为-12。&lt;/p&gt;
&lt;p&gt;  再来看一下乘法，比如8bit位的整数-8乘以13，他们的补码分别为&lt;span&gt;1&lt;/span&gt;1111000和&lt;span&gt;0&lt;/span&gt;0001101。其中-8为被乘数，13为乘数，并且乘数有8个bit位，需要将被乘数按位与和位计算8次然后将结果相加，看如下分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、被乘数的第0个bit位值为1，将被乘数乘以1然后左移0位得到：11111000；&lt;/li&gt;
&lt;li&gt;2、被乘数的第1个bit位值为0，将被乘数乘以0然后左移1位得到：00000000；&lt;/li&gt;
&lt;li&gt;3、被乘数的第2个bit位值为1，将被乘数乘以1然后左移2位得到；11100000；&lt;/li&gt;
&lt;li&gt;4、被乘数的第3个bit位值为1，将被乘数乘以1然后左移3位得到；11000000；&lt;/li&gt;
&lt;li&gt;5、被乘数的第4个bit位值为0，将被乘数乘以0然后左移4位得到；00000000；&lt;/li&gt;
&lt;li&gt;6、被乘数的第5个bit位值为0，将被乘数乘以0然后左移5位得到；00000000；&lt;/li&gt;
&lt;li&gt;7、被乘数的第6个bit位值为0，将被乘数乘以0然后左移6位得到；00000000；&lt;/li&gt;
&lt;li&gt;8、被乘数的第7个bit位值为0，将被乘数乘以0然后左移7位得到；00000000；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由此可以得计算得到8组补码（注意上面做位移涉及到的整数溢出，只能是8个bit位），然后将它们做加法得到&lt;span&gt;1&lt;/span&gt;0011000（也存在整数溢出）转换为原码为&lt;span&gt;1&lt;/span&gt;1101000，真值为-104。&lt;/p&gt;
&lt;p&gt;  至于除法则是使用交替加减法的方式，本文只是对计算原理做一下扩展，这里不再继续深入做介绍，如果有想了解的可以自行上网查询。&lt;/p&gt;
&lt;p&gt;  通过上面的分析可以知道，使用补码可以将所有计算都转化为加法计算，这样可以让计算机底层对于整数（浮点数再此不做讲解，有时间会再单独写一篇文章作介绍）计算变得简单，反码属于历史遗留，因为其存在±0的问题。&lt;/p&gt;
&lt;h3 id=&quot;java中的基本数据类型&quot;&gt;Java中的基本数据类型&lt;/h3&gt;
&lt;p&gt;  在计算机编程语言中都会有数据类型的概念，数据类型是用来修饰变量的。不同数据类型所修饰的变量，其指代的数据在内存中占用空间的大小（基本类型变量使用的空间、指针或引用变量指向的地址空间等，后面简单称数据类型占用的内存空间）是固定的。即使在一些弱类型语言中，虽然变量可以不用显示地声明数据类型，但当第一次为变量赋值时，还是会隐式地为其附上数据类型属性。&lt;/p&gt;
&lt;p&gt;  对于java来说，由于其具有跨平台的特性，所以基本数据类型所占用的内存空间大小（字节数）是固定的。我们来看一下java中的几个基本数据类型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;byte&lt;/th&gt;
&lt;th&gt;char&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th&gt;float&lt;/th&gt;
&lt;th&gt;long&lt;/th&gt;
&lt;th&gt;double&lt;/th&gt;
&lt;th&gt;boolean&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;字节数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;8bit / 1byte&lt;/td&gt;
&lt;td&gt;16bit / 2byte&lt;/td&gt;
&lt;td&gt;16bit / 2byte&lt;/td&gt;
&lt;td&gt;32bit / 4byte&lt;/td&gt;
&lt;td&gt;32bit / 4byte&lt;/td&gt;
&lt;td&gt;64bit / 8byte&lt;/td&gt;
&lt;td&gt;64bit / 8byte&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;7&lt;/sup&gt; ~ 2&lt;sup&gt;7&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;0 ~ 2&lt;sup&gt;16&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;15&lt;/sup&gt; ~ 2&lt;sup&gt;15&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;31&lt;/sup&gt; ~ 2&lt;sup&gt;31&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;63&lt;/sup&gt; ~ 2&lt;sup&gt;63&lt;/sup&gt; - 1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;false | true&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;默认值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;后缀&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;f | F&lt;/td&gt;
&lt;td&gt;l | L&lt;/td&gt;
&lt;td&gt;d | D&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：jvm规范并没有指明boolean类型占用几个字节的空间，所以根据jvm产品的不同，实现的方式也可能不同。最广泛的说法是，jvm内部使用int代替boolean类型，也就是占用4个字节。另外这里没有列出浮点数的大小范围，由于本文只介绍整数，后面如果有时间则会单独出一篇介绍浮点数的博文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  我们来看下面几个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 案例1，下面的10进制真值的写法，但是当编译器编译完成之后，在内存中还是会以补码的形式存在
int value1 = 10;
int value2 = -10;
System.out.printf(&quot;value1=%d, value2=%d\n&quot;, value1, value2); // 结果为: value1=10, value2=-10

// 案例2，下面是2进制补码的写法，在数字前面加上'0b'或者'0B'，'_'只是一个分隔符
int value3 = 0b00000000_00000000_00000000_00001010; // 2进制int类型10的补码
int value4 = 0B11111111_11111111_11111111_11110110; // 2进制int类型-10的补码
System.out.printf(&quot;value3=%d, value4=%d\n&quot;, value3, value4); // 结果为: value3=10, value4=-10

// 案例3，下面是16进制补码的写法，在数字前面加上'0x'或者'0X'，大于9的数值使用a~f或A-F表示
int value5 = 0x0000000a; // 16进制int类型10的补码
int value6 = 0Xfffffff6; // 16进制int类型-10的补码
System.out.printf(&quot;value5=%d, value6=%d\n&quot;, value5, value6); // 结果为: value5=10, value6=-10

// 案例4，下面是8进制补码的写法，在数字前面加上'0'
int value7 = 012; // 8进制int类型10的补码
int value8 = 037777777766; // 8进制int类型-10的补码
System.out.printf(&quot;value7=%d, value8=%d\n&quot;, value7, value8); // 结果为: value7=10, value8=-10

/*
 * 注: 这里不论是10进制还是16进制等方式写的整数，在计算机内部都是以二进制补码的形式体现，
 *     也就是上面案例2的中2进制的形式体现。
 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  额外说明一下，这些基本数据类型只会出现在线程栈中，或者再详细一点，只会出现在线程栈的运行时栈帧（方法的工作空间）的局部变量表和操作数栈中。也就是说，只有在局部方法中才可以声明基本数据类型的局部变量。对象的成员变量或者类的静态变量即使是基本数据类型，最终也会被自动装箱为包装类型，然后在堆中开辟空间。 &lt;em&gt;但也有例外，在现在的高性能jvm中一般都会有jit（即时编译）系统，在逃逸分析时如果对象被判断为未逃逸（对象不是入参、不是返回值并且也没有被方法外部变量引用），则会做标量替换（拆分对象为基本数据类型）然后在线程栈或者CPU寄存器中分配空间，方法执行完成之后随着运行时栈帧出栈而被回收，可减少GC的工作负载。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;java中的整数类型转换&quot;&gt;Java中的整数类型转换&lt;/h3&gt;
&lt;p&gt;  整数的基本类型之间可以互相转换，甚至char类型都可以转换为byte、short、int、long等类型，反之亦然。但是不同的数据类型，其所占用的内存空间大小是不一样的，那么这里就涉及到补全和溢出的问题了。&lt;/p&gt;
&lt;p&gt;  整数类型按所占内存空间从小到大排序分别为byte、short、int、long，由占用空间小的转型为占用空间大的为&lt;em&gt;向上转型&lt;/em&gt;，反之为&lt;em&gt;向下转型&lt;/em&gt;。java中类型转换运算符为括号，括号中为转换的目标类型，例如&lt;code&gt;long value = (long) Integer.MAX_VALUE;&lt;/code&gt;。向上类型转换可以隐式地完成，也就是说不需要显示地编写出类型转换运算符例如&lt;code&gt;long value = Integer.MAX_VALUE;&lt;/code&gt;。但是向下类型转换时，可能会发生整数溢出（舍弃高字节位），所以必须显式的写出类型转换运算符，例如&lt;code&gt;short value = (short) Integer.MAX_VALUE;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  如果是向上转型时，使用符号位的值填充高字节位。向下转型时，直接舍掉高字节位。我们看下面两张表，从上往下看为向下转型，从下往上看则为向上转型：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;二进制正数补码&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;十进制正数&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000000_00000000_00000000_00000000_00000000_00000000_01111111&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000000_00000000_01111111&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;0000000_01111111&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;byte&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;1111111&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
  
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;二进制负数补码&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;十进制负数&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;1111111_11111111_11111111_11111111_11111111_11111111_11111111_10000000&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;1111111_11111111_11111111_10000000&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;1111111_10000000&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;byte&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;0000000&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  可以看到，不论转换成什么类型，最终的值还是不变的。我们看下面的案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 案例1
byte value = (byte) Short.MAX_VALUE; // Short.MAX_VALUE为short类型的最大值: 32767
// 案例2
short value = Byte.MIN_VALUE; // Byte.MIN_VALUE为byte类型的最小值: -128
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  案例1为一个向下类型转换，由于32767这个值超过了byte能表示的最大值，所以其必然会发生整数溢出。short类型的32767的二进制补码为&lt;span&gt;0&lt;/span&gt;1111111_11111111，向下转型为byte舍掉高位字节的二进制补码为&lt;span&gt;1&lt;/span&gt;1111111，其值变为了-1。&lt;/p&gt;
&lt;p&gt;  案例2为一个向上类型转换，byte类型的-128的二进制补码为&lt;span&gt;1&lt;/span&gt;0000000，将其转换为short类型之后的二进制补码为&lt;span&gt;1&lt;/span&gt;1111111_10000000。我们知道虽然其表示的值没有变还是-128，但是如果我们在向上类型转换之后，还想让原来的符号位表示数值，也就是得到byte类型-128这个值的无符号数，则可以做按位与计算&lt;code&gt;int value = Byte.MIN_VALUE &amp;amp; 0xff;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;java中的字面量&quot;&gt;Java中的字面量&lt;/h3&gt;
&lt;p&gt;  Java中可以可以定义两种类型的整数字面量，分别为int和long。例如&lt;code&gt;int value = 10;&lt;/code&gt;或者&lt;code&gt;long value = 10L;&lt;/code&gt;，可以看到其中long类型的字面量需要加上'L'类型的后缀，当然也可以是'l'。&lt;/p&gt;
&lt;p&gt;  Java中无法直接定义byte和short类型的字面量，但是如果这么写&lt;code&gt;byte value = 127;&lt;/code&gt;编译也没错，那么这里的127是不是就是byte类型的字面量呢？其实不是，这个127还是int类型的，只不过做了向下类型转换而已。但是前面说向下类型转换必须显式的写出类型转换运算符，这里没有那么是不是前面说错了呢？其实也不是，int类型127的二进制补码为&lt;span&gt;0&lt;/span&gt;0000000_00000000_00000000_01111111，向下转型为byte类型之后的二进制补码为&lt;span&gt;0&lt;/span&gt;1111111，那些被舍弃的0可以看做是填充位所以并没有发生整数溢出。由于字面量是静态不可变的值，编译器在编译的时候就知道其并不会发生整数溢出，所以就直接做了隐式类型转换。但是我们来看字面量为128的int类型整数，其二进制补码为&lt;span&gt;0&lt;/span&gt;0000000_00000000_00000000_10000000，转换为byte类型之后的补码为&lt;span&gt;1&lt;/span&gt;0000000，原本属于数值位的1变为了符号位，这里发生了整数溢出，所以需要显式的加上类型转换运算符&lt;code&gt;byte value = (byte) 128;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  我们来看下面这些关于字面量的隐式类型转换的案例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 案例1
byte value1 = 127;

// 案例2，-128在byte能够表示的数值范围内，编译器直接做了隐式类型转换。
byte value2 = -128; // 赋值给value1的二进制补码为: 10000000

// 案例3，Short.MAX_VALUE是一个常量，编译器编译的时候可以明确的知道其值为32767，所以编译器会先计算出32767 - 32640的值然后赋值给value3变量
byte value3 = Short.MAX_VALUE - 32640; // 赋值给value3的二进制补码为: 01111111

// 案例4，下面由于变量value4被final修饰，其值在编译期间是不可变的，编译器也能明确知道其值不会发生整数溢出
final byte int value4 = 127;
byte value5 = value4;

// 案例5
static final int value6 = 32767;
void func() {
        short value7 = value6;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们看这一行代码&lt;code&gt;long value = 2147483647&lt;/code&gt;，这是一个向上转型的例子，将int类型的字面量2147483647转换为long类型。但是如果字面量为2147483648就必须这么写&lt;code&gt;long value = 2147483648L;&lt;/code&gt;，因为2147483648这个值已经超过了int类型的最大值，必须使用long类型的字面量表示。&lt;/p&gt;
&lt;h3 id=&quot;内存对齐和有效位移&quot;&gt;内存对齐和有效位移&lt;/h3&gt;
&lt;p&gt;  不管是四则运算还是位运算，参与计算的整数有可能是不同的数据类型，也就意味着它们在内存中的占用的字节数不同，所以在计算的时候需要将转换为相同的类型，也就是内存对齐。&lt;/p&gt;
&lt;p&gt;  如果是byte、short、int等类型的数据做计算，默认会将byte和short了类型的数据先转换为int类型的数据然后在做计算。如果参与计算的数据中有long类型的数据，则会将非long类型的数据先转换为long类型，然后在做计算。&lt;/p&gt;
&lt;p&gt;  位移计算的时候数据类型要么是int类型要么是long类型，也就是说计算的说要么有32的bit位要么有64个bit为，那么我们做位移的时候是不是可以位移无限的bit位呢？当然不是，有效位移的位数为0到bit为数量（字宽）减去1，也就是说int的有效位移大小为0 ~ 31，long的有效位移数量为0 ~ 63。如果超出这个范围的话则会与31或者63做按位与计算，比如int数据位移36位则实际位移为&lt;code&gt;36 &amp;amp; 31 = 4&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;varints-128位可变长整型&quot;&gt;Varints 128位可变长整型&lt;/h3&gt;
&lt;p&gt;  通过前面的说明，大家应该对计算机中的整数有了清晰的理解。比如有一个int类型的整数，我们需要在网络传输传输它，那么发送方只需要传输4个字节的数据就行，接收方也只需要接收4个字节。比如我们传输一个值为10的int类型数据，大家可以知道其实只需要传输一个字节就行，但是谁也不能保证下一个传输的数据使用一个字节会不会溢出，所以这时候我们就需要设计一个可以变换字节数量的编解码方式，并且数据接收方也能够知道自己需要接受几个字节，Varints就是为了解决这个问题的。&lt;/p&gt;
&lt;p&gt;  Varints是按小端字节序排列，也就是低位字节在前高位字节在后。每个字节的第7个bit位不表示数值，只是用来标识是否为最后一个字节，如果第7个bit位值为1则代表不是最后一个字节，如果值为0则代表为最后一个字节，如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;真值&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;补码&lt;/strong&gt;&lt;/td&gt;
&lt;td bgcolor=&quot;#EFF3F5&quot;&gt;&lt;strong&gt;varints&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;1100100&lt;/td&gt;
&lt;td&gt;[&lt;span&gt;0&lt;/span&gt;1100100]&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;0000011_11101000&lt;/td&gt;
&lt;td&gt;[&lt;span&gt;1&lt;/span&gt;1101000, &lt;span&gt;0&lt;/span&gt;0000111]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;100000&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;&lt;span&gt;0&lt;/span&gt;0000000_00000001_10000110_10100000&lt;/td&gt;
&lt;td&gt;[&lt;span&gt;1&lt;/span&gt;0100000, &lt;span&gt;1&lt;/span&gt;0001101, &lt;span&gt;0&lt;/span&gt;0000010]&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  我们看上表中，红色部分为标识是否最后一个字节的bit位，那么这样是不是就可以表示一个无穷大的整数了，不过一般也没必要太大，就拿java来说，最大也就long类型的8个字节64个bit位大小。其实正真生产过程中应用所处理处理数据时，遇到小数值的概率要比遇到大数值的概率要大得多，所以varints可以在做网络传输或者数据存储时可以省不少流量和空间，而且可以便于扩展。不说别的，直接上代码了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class ByteUtil {

    private ByteUtil() {}
    
    public static byte[] enVarInt(int value) {
        int size = 0;
        byte[] temps = new byte[5];
        for (; (value &amp;amp; 0xffffff80) != 0; value &amp;gt;&amp;gt;&amp;gt;= 7, ++size) {
            temps[size] = (byte) (value &amp;amp; 0x7f | 0x80);
        }
        temps[size] = (byte) value;
        byte[] result = new byte[size + 1];
        System.arraycopy(temps, 0, result, 0, result.length);
        return result;
    }
    
    public static byte[] enVarInt(long value) {
        int size = 0;
        byte[] temps = new byte[10];
        for (; (value &amp;amp; 0xffffffffffffff80L) != 0; value &amp;gt;&amp;gt;&amp;gt;= 7, ++size) {
            temps[size] = (byte) (value &amp;amp; 0x7fL | 0x80L);
        }
        temps[size] = (byte) value;
        byte[] result = new byte[size + 1];
        System.arraycopy(temps, 0, result, 0, result.length);
        return result;
    }
    
    public static IntPair deVarInt(int offset, byte... buffer) {
        isLegalArg(offset &amp;gt;= 0 &amp;amp;&amp;amp; offset &amp;lt; buffer.length, String.format(&quot;offset=%d, bufferLen=%d, Must meet: offset &amp;gt;= 0 &amp;amp;&amp;amp; offset &amp;lt; %d&quot;, offset, buffer.length, buffer.length));
        int bitSize = 0, result = 0, length = 0;
        for (; offset &amp;lt; buffer.length &amp;amp;&amp;amp; bitSize &amp;lt; Integer.SIZE; ++offset) {
            int value = buffer[offset] &amp;amp; 0xff;
            result |= (value &amp;amp; 0x7f) &amp;lt;&amp;lt; bitSize;
            bitSize += 7;
            ++length;
            if (0 == (value &amp;amp; 0x80)) {
                break;
            }
        }
        return IntPair.of(length, result);
    }
    
    public static IntLPair deVarLong(int offset, byte... buffer) {
        isLegalArg(offset &amp;gt;= 0 &amp;amp;&amp;amp; offset &amp;lt; buffer.length, String.format(&quot;offset=%d, bufferLen=%d, Must meet: offset &amp;gt;= 0 &amp;amp;&amp;amp; offset &amp;lt; %d&quot;, offset, buffer.length, buffer.length));
        int bitSize = 0, length = 0;
        long result = 0;
        for (; offset &amp;lt; buffer.length &amp;amp;&amp;amp; bitSize &amp;lt; Long.SIZE; ++offset) {
            int value = buffer[offset] &amp;amp; 0xff;
            result |= (value &amp;amp; 0x7fL) &amp;lt;&amp;lt; bitSize;
            bitSize += 7;
            ++length;
            if (0 == (value &amp;amp; 0x80)) {
                break;
            }
        }
        return IntLPair.of(length, result);
    }

    private static void isLegalArg(boolean isLegalArg, String message) {
        if (!isLegalArg) {
            throw new IllegalArgumentException(message);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zigzag&quot;&gt;ZigZag&lt;/h3&gt;
&lt;p&gt;  前面我们讲解了varints可以省流量和空间，因为一般遇到小数值的概率要比遇到大数值的概率要大得多，同时我们也说了计算机内部是只是别补码的，如果处理一个数值很小但是却是负数的时候，单凭varints可就不能达到省流量和省空间的效果了。前面我们也讲到符号位为整数的最高bit位，那么即使一个负数的数值再小，整个整数看起来也不小，所以这时候就需要使用到ZigZag来吧符号位处理一下。&lt;/p&gt;
&lt;p&gt;  ZigZag编码时，正数不做任何处理。对于负数则将整体数值位按位取反再左移一位，然后将符号位放到第0个bit位上，这样处理之后就会得到一个与原来不一样的整数，然后再按varints进行编码。直接上ZigZag的代码了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class ByteUtil {

    private ByteUtil() {}

    public static int enZigZag(int value) {
        return (value &amp;lt;&amp;lt; 1) ^ (value &amp;gt;&amp;gt; 31);
    }
    
    public static long enZigZag(long value) {
        return (value &amp;lt;&amp;lt; 1) ^ (value &amp;gt;&amp;gt; 63);
    }
    
    public static int deZigZag(int value) {
        return (value &amp;gt;&amp;gt;&amp;gt; 1) ^ -(value &amp;amp; 1);
    }
    
    public static long deZigZag(long value) {
        return (value &amp;gt;&amp;gt;&amp;gt; 1) ^ -(value &amp;amp; 1);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;附加代码&quot;&gt;附加代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.Objects;

public class IntLPair {
    
    private int left;
    
    private long right;
    
    public IntLPair() {
    }
    
    private IntLPair(int left, long right) {
        this.left = left;
        this.right = right;
    }
    
    public static IntLPair of(int left, long right) {
        return new IntLPair(left, right);
    }
    
    public int getInt() {
        return left;
    }
    
    public void setInt(int left) {
        this.left = left;
    }
    
    public long getLong() {
        return right;
    }
    
    public void setLong(long right) {
        this.right = right;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        IntLPair intLPair = (IntLPair) o;
        return left == intLPair.left &amp;amp;&amp;amp;
                right == intLPair.right;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(left, right);
    }
    
    @Override
    public String toString() {
        return &quot;IntLPair{&quot; +
                &quot;left=&quot; + left +
                &quot;, right=&quot; + right +
                '}';
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.Objects;

public class IntLPair {
    
    private int left;
    
    private long right;
    
    public IntLPair() {
    }
    
    private IntLPair(int left, long right) {
        this.left = left;
        this.right = right;
    }
    
    public static IntLPair of(int left, long right) {
        return new IntLPair(left, right);
    }
    
    public int getInt() {
        return left;
    }
    
    public void setInt(int left) {
        this.left = left;
    }
    
    public long getLong() {
        return right;
    }
    
    public void setLong(long right) {
        this.right = right;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        IntLPair intLPair = (IntLPair) o;
        return left == intLPair.left &amp;amp;&amp;amp;
                right == intLPair.right;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(left, right);
    }
    
    @Override
    public String toString() {
        return &quot;IntLPair{&quot; +
                &quot;left=&quot; + left +
                &quot;, right=&quot; + right +
                '}';
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Mon, 11 Jan 2021 00:20:00 +0000</pubDate>
<dc:creator>伯乐钟情</dc:creator>
<og:description>本文主要做计算机中的整数相关总结，包括机器值与真值、原码/反码/补码、java中的数据类型以及类型转换等，最后分享可变长整型的编码方式（varints+ZagZig）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lbole/p/14260496.html</dc:identifier>
</item>
<item>
<title>数据仓库组件：HBase集群环境搭建和应用案例 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14260486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14260486.html</guid>
<description>&lt;p&gt;HBase是一种分布式、可扩展、支持海量结构化数据存储的NoSQL数据库。HBase在Hadoop之上提供了类似于Bigtable的能力，基于列存储模式的而不是基于行的模式。存储数据特点：非结构化或者松散的半结构化数据，存储大表自然是需要具备水平扩展的能力，基于服务集群处理海量庞大数据。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;220.37103111394&quot;&gt;
&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/big-data-parent&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/big-data-parent&quot; target=&quot;_blank&quot;&gt;GitEE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、基础描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hadoop原生的特点是解决大规模数据的离线批量处理场景，HDFS具备强大存储能力，但是并没有提供很强的数据查询机制。HBase组件则是基于HDFS文件系统之上提供类似于BigTable服务。&lt;/p&gt;
&lt;p&gt;HBase是一种分布式、可扩展、支持海量结构化数据存储的NoSQL数据库。HBase在Hadoop之上提供了类似于Bigtable的能力，基于列存储模式的而不是基于行的模式。存储数据特点：非结构化或者松散的半结构化数据，存储大表自然是需要具备水平扩展的能力，基于服务集群处理海量庞大数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、数据模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于Hbase的数据结构的基本描述；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表-Table：由行和列组成，列划分为若干个列族；&lt;/li&gt;
&lt;li&gt;行-Row：行键(Key)作标识，行代表数据对象；&lt;/li&gt;
&lt;li&gt;列族：列族支持动态扩展，以字符串形式存储；&lt;/li&gt;
&lt;li&gt;列标识：列族中的数据通过列标识符来定位；&lt;/li&gt;
&lt;li&gt;单元格：行键，列族，列标识符共同确定一个单元；&lt;/li&gt;
&lt;li&gt;单元数据：存储在单元里的数据称为单元数据；&lt;/li&gt;
&lt;li&gt;时间戳：默认基于时间戳来进行版本标识；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HBase的数据模型同关系型数据库很类似，数据存储在一张表中，有行有列。但从HBase的底层物理存储结构看更像是Map（K-V）集合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据管理是基于列存储的特点；&lt;/li&gt;
&lt;li&gt;简单的数据模型，内容存储为字符串；&lt;/li&gt;
&lt;li&gt;没有复杂的表关系，简单的增删查操作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从整体上看数据模型，HBase是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳每个值是一个未经解释的字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、解压文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf hbase-1.3.1-bin.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、配置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/profile

export HBASE_HOME=/opt/hbase-1.3.1
export PATH=$PATH:$HBASE_HOME/bin

source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、配置：hbase-env&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /opt/hbase-1.3.1/conf/hbase-env.sh

export JAVA_HOME=/opt/jdk1.8
export HBASE_MANAGES_ZK=false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、配置：hbase-site&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;vim /opt/hbase-1.3.1/conf/hbase-site.xml

&amp;lt;configuration&amp;gt;
    &amp;lt;!--HDFS存储--&amp;gt;
        &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;hbase.rootdir&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;hdfs://hop01:9000/HBase&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;!--开启集群--&amp;gt;
        &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;hbase.cluster.distributed&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 端口 --&amp;gt;
        &amp;lt;property&amp;gt;
                &amp;lt;name&amp;gt;hbase.master.port&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;16000&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;!--ZK集群--&amp;gt;
        &amp;lt;property&amp;gt;   
                &amp;lt;name&amp;gt;hbase.zookeeper.quorum&amp;lt;/name&amp;gt;
             &amp;lt;value&amp;gt;hop01,hop02,hop03&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;!--ZK数据--&amp;gt; 
        &amp;lt;property&amp;gt;   
                &amp;lt;name&amp;gt;hbase.zookeeper.property.dataDir&amp;lt;/name&amp;gt;
             &amp;lt;value&amp;gt;/data/zookeeper/data/&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5、配置：regionservers&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /opt/hbase-1.3.1/conf/regionservers

hop01
hop02
hop03
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6、配置：软连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软连接hadoop配置文件到HBase&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /opt/hadoop2.7/etc/hadoop/core-site.xml /opt/hbase-1.3.1/conf/core-site.xml
ln -s /opt/hadoop2.7/etc/hadoop/hdfs-site.xml /opt/hbase-1.3.1/conf/hdfs-site.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7、同步集群服务环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以手动配置集群，或者使用同步命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xsync hbase/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8、启动集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hop01节点启动即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/opt/hbase-1.3.1/bin/start-hbase.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hop03: starting regionserver, logging to /opt/hbase-1.3.1/bin/../logs/hbase-root-regionserver-hop03.out
hop02: starting regionserver, logging to /opt/hbase-1.3.1/bin/../logs/hbase-root-regionserver-hop02.out
hop01: starting regionserver, logging to /opt/hbase-1.3.1/bin/../logs/hbase-root-regionserver-hop01.out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;9、查看状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jps

HMaster：主节点
HRegionServer：分区节点
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10、停止集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hop01节点停止即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/opt/hbase-1.3.1/bin/stop-hbase.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;11、查看界面&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://hop01:16010
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210110223421815-888147579.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、切入客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/opt/hbase-1.3.1/bin/hbase shell
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、查看表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):002:0&amp;gt; list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、创建表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):003:0&amp;gt; create 'user','info'
0 row(s) in 2.7910 seconds
=&amp;gt; Hbase::Table - user
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、查看表结构&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):010:0&amp;gt; describe 'user'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5、添加数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;put 'user','id01','info:name','tom'
put 'user','id01','info:age','18'
put 'user','id01','info:sex','male'
put 'user','id02','info:name','jack'
put 'user','id02','info:age','20'
put 'user','id02','info:sex','female'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6、查看表数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):010:0&amp;gt; scan 'user'
ROW     COLUMN+CELL                                                                             
id01    column=info:age, timestamp=1594448524308, value=18                                      
id01    column=info:name, timestamp=1594448513534, value=tom                                    
id01    column=info:sex, timestamp=1594448530817, value=male                                    
id02    column=info:age, timestamp=1594448542631, value=20                                      
id02    column=info:name, timestamp=1594448536520, value=jack                                   
id02    column=info:sex, timestamp=1594448548005, value=female
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些表结构和数据会在集群之间自动同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、查询指定列&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):012:0&amp;gt; get 'user','id01'
COLUMN      CELL                                                                                    
info:age    timestamp=1594448524308, value=18                                                       
info:name   timestamp=1594448513534, value=tom                                                       
info:sex    timestamp=1594448530817, value=male
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;8、统计行数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):013:0&amp;gt; count 'user'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;9、删除行数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):014:0&amp;gt; deleteall 'user','id02'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10、清空表数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):016:0&amp;gt; truncate 'user'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;11、删除表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):018:0&amp;gt; disable 'user'
hbase(main):019:0&amp;gt; drop 'user'
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;1、核心依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.hbase&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hbase-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、基础配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里连接zookeeper集群地址即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zookeeper:
  address: 集群地址Url，逗号分隔
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写HBase配置和常用工具方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class HBaseConfig {

    private static String address;
    private static final Object lock=new Object();
    public static Configuration configuration = null;
    public static ExecutorService executor = null;
    public static Connection connection = null;

    /**
     * 获取连接
     */
    public static Connection getConnection(){
        if(null == connection){
            synchronized (lock) {
                if(null == connection){
                    configuration = new Configuration();
                    configuration.set(&quot;hbase.zookeeper.quorum&quot;, address);
                    try {
                        executor = Executors.newFixedThreadPool(10);
                        connection = ConnectionFactory.createConnection(configuration, executor);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        return connection;
    }

    /**
     * 获取 HBaseAdmin
     */
    public static HBaseAdmin getHBaseAdmin(){
        HBaseAdmin admin = null;
        try{
            admin = (HBaseAdmin)getConnection().getAdmin();
        }catch(Exception e){
            e.printStackTrace();
        }
        return admin;
    }
    /**
     * 获取 Table
     */
    public static Table getTable(TableName tableName) {
        Table table = null ;
        try{
            table = getConnection().getTable(tableName);
        }catch(Exception e){
            e.printStackTrace();
        }
        return table ;
    }
    /**
     * 关闭资源
     */
    public static void close(HBaseAdmin admin,Table table){
        try {
            if(admin!=null) {
                admin.close();
            }
            if(table!=null) {
                table.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Value(&quot;${zookeeper.address}&quot;)
    public void setAddress (String address) {
        HBaseConfig.address = address;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、查询案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询数据参考上述全表扫描结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class HBaseController {

    /**
     * 扫描全表
     */
    @GetMapping(&quot;/scanTable&quot;)
    public String scanTable () throws Exception {
        Table table = HBaseConfig.getTable(TableName.valueOf(&quot;user&quot;));
        try {
            ResultScanner resultScanner = table.getScanner(new Scan());
            for (Result result : resultScanner) {
                printResult(result);
            }
        } finally {
            HBaseConfig.close(null, table);
        }
        return &quot;success&quot;;
    }

    /**
     * 根据RowKey扫描
     */
    @GetMapping(&quot;/scanRowKey&quot;)
    public void scanRowKey() throws Exception {
        String rowKey = &quot;id02&quot;;
        Table table = HBaseConfig.getTable(TableName.valueOf(&quot;user&quot;));
        try {
            Result result = table.get(new Get(rowKey.getBytes()));
            printResult(result);
        } finally {
            HBaseConfig.close(null, table);
        }
    }

    /**
     * 输出 Result
     */
    private void printResult (Result result){
        NavigableMap&amp;lt;byte[], NavigableMap&amp;lt;byte[], NavigableMap&amp;lt;Long, byte[]&amp;gt;&amp;gt;&amp;gt; map = result.getMap();
        Set&amp;lt;Map.Entry&amp;lt;byte[], NavigableMap&amp;lt;byte[], NavigableMap&amp;lt;Long, byte[]&amp;gt;&amp;gt;&amp;gt;&amp;gt; set = map.entrySet();
        for (Map.Entry&amp;lt;byte[], NavigableMap&amp;lt;byte[], NavigableMap&amp;lt;Long, byte[]&amp;gt;&amp;gt;&amp;gt; entry : set) {
            Set&amp;lt;Map.Entry&amp;lt;byte[], NavigableMap&amp;lt;Long, byte[]&amp;gt;&amp;gt;&amp;gt; entrySet = entry.getValue().entrySet();
            for (Map.Entry&amp;lt;byte[], NavigableMap&amp;lt;Long, byte[]&amp;gt;&amp;gt; entry2 : entrySet) {
                System.out.print(new String(result.getRow()));
                System.out.print(&quot;\t&quot;);
                System.out.print(new String(entry.getKey()));
                System.out.print(&quot;:&quot;);
                System.out.print(new String(entry2.getKey()));
                System.out.print(&quot; value = &quot;);
                System.out.println(new String(entry2.getValue().firstEntry().getValue()));
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/big-data-parent
GitEE·地址
https://gitee.com/cicadasmile/big-data-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 11 Jan 2021 00:01:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>HBase是一种分布式、可扩展、支持海量结构化数据存储的NoSQL数据库。HBase在Hadoop之上提供了类似于Bigtable的能力，基于列存储模式的而不是基于行的模式。存储数据特点：非结构化或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14260486.html</dc:identifier>
</item>
<item>
<title>8. 格式化器大一统 -- Spring的Formatter抽象 - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/14260469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/14260469.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227153201605.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;你好，我是A哥(YourBatman)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw&quot; target=&quot;_blank&quot;&gt;上篇文章&lt;/a&gt; 介绍了&lt;code&gt;java.text.Format&lt;/code&gt;格式化体系，作为JDK 1.0就提供的格式化器，除了设计上存在一定缺陷，过于底层无法标准化对使用者不够友好，这都是对格式化器提出的更高要求。Spring作为Java开发的标准基建，本文就来看看它做了哪些补充。&lt;/p&gt;
&lt;h2 id=&quot;本文提纲&quot;&gt;本文提纲&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227191140521.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版本约定&quot;&gt;版本约定&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Spring Framework：5.3.x&lt;/li&gt;
&lt;li&gt;Spring Boot：2.4.x&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在应用中（特别是web应用），我们经常需要将前端/Client端传入的字符串转换成&lt;strong&gt;指定格式/指定数据类型&lt;/strong&gt;，同样的服务端也希望能把指定类型的数据按照&lt;strong&gt;指定格式&lt;/strong&gt; 返回给前端/Client端，这种情况下&lt;code&gt;Converter&lt;/code&gt;已经无法满足我们的需求了。为此，Spring提供了格式化模块专门用于解决此类问题。&lt;/p&gt;
&lt;p&gt;首先可以从宏观上先看看spring-context对format模块的目录结构安排：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201221054434297.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Formatter&amp;lt;T&amp;gt; extends Printer&amp;lt;T&amp;gt;, Parser&amp;lt;T&amp;gt; {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，该接口本身没有任何方法，而是聚合了另外两个接口Printer和Parser。&lt;/p&gt;
&lt;h2 id=&quot;printerparser&quot;&gt;Printer&amp;amp;Parser&lt;/h2&gt;
&lt;p&gt;这两个接口是相反功能的接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Printer&lt;/code&gt;：格式化显示（输出）接口。将T类型转为String形式，Locale用于控制国际化&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Printer&amp;lt;T&amp;gt; {
        // 将Object写为String类型
        String print(T object, Locale locale);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Parser&lt;/code&gt;：解析接口。将String类型转到T类型，Locale用于控制国际化。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface Parser&amp;lt;T&amp;gt; {
        T parse(String text, Locale locale) throws ParseException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;formatter&quot;&gt;Formatter&lt;/h2&gt;
&lt;p&gt;格式化器接口，它的继承树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201221062511589.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图可见，格式化动作只需关心到两个领域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间日期领域&lt;/li&gt;
&lt;li&gt;数字领域（其中包括货币）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;时间日期格式化&quot;&gt;时间日期格式化&lt;/h3&gt;
&lt;p&gt;Spring框架从4.0开始支持Java 8，针对&lt;code&gt;JSR 310&lt;/code&gt;日期时间类型的格式化专门有个包&lt;code&gt;org.springframework.format.datetime.standard&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201221060624967.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得一提的是&lt;/strong&gt;：在Java 8出来之前，Joda-Time是Java日期时间处理最好的解决方案，使用广泛，甚至得到了Spring内置的支持。现在Java 8已然成为主流，JSR 310日期时间API &lt;strong&gt;完全可以&lt;/strong&gt; 代替Joda-Time（JSR 310的贡献者其实就是Joda-Time的作者们）。因此joda库也逐渐告别历史舞台，后续代码中不再推荐使用，本文也会选择性忽略。&lt;/p&gt;
&lt;p&gt;除了Joda-Time外，Java中对时间日期的格式化还需分为这两大阵营来处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201222063045457.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;date类型&quot;&gt;Date类型&lt;/h4&gt;
&lt;p&gt;虽然已经2020年了（Java 8于2014年发布），但谈到时间日期那必然还是得有&lt;code&gt;java.util.Date&lt;/code&gt;，毕竟积重难返。所以呢，Spring提供了&lt;code&gt;DateFormatter&lt;/code&gt;用于支持它的格式化。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因为Date早就存在，所以DateFormatter是伴随着Formatter的出现而出现，@since 3.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// @since 3.0
public class DateFormatter implements Formatter&amp;lt;Date&amp;gt; {

        private static final TimeZone UTC = TimeZone.getTimeZone(&quot;UTC&quot;);
        private static final Map&amp;lt;ISO, String&amp;gt; ISO_PATTERNS;
        static {
                Map&amp;lt;ISO, String&amp;gt; formats = new EnumMap&amp;lt;&amp;gt;(ISO.class);
                formats.put(ISO.DATE, &quot;yyyy-MM-dd&quot;);
                formats.put(ISO.TIME, &quot;HH:mm:ss.SSSXXX&quot;);
                formats.put(ISO.DATE_TIME, &quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;);
                ISO_PATTERNS = Collections.unmodifiableMap(formats);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认使用的TimeZone是UTC标准时区，&lt;code&gt;ISO_PATTERNS&lt;/code&gt;代表ISO标准模版，这和&lt;code&gt;@DateTimeFormat&lt;/code&gt;注解的iso属性是&lt;strong&gt;一一对应&lt;/strong&gt;的。也就是说如果你不想指定pattern，可以快速通过指定ISO来实现。&lt;/p&gt;
&lt;p&gt;另外，对于格式化器来说有这些属性你都可以自由去定制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DateFormatter：

        @Nullable
        private String pattern;
        private int style = DateFormat.DEFAULT;
        @Nullable
        private String stylePattern;
        @Nullable
        private ISO iso;
        @Nullable
        private TimeZone timeZone;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它对Formatter接口方法的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DateFormatter：

        @Override
        public String print(Date date, Locale locale) {
                return getDateFormat(locale).format(date);
        }

        @Override
        public Date parse(String text, Locale locale) throws ParseException {
                return getDateFormat(locale).parse(text);
        }

        // 根据pattern、ISO等等得到一个DateFormat实例
        protected DateFormat getDateFormat(Locale locale) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到不管输入还是输出，底层依赖的都是JDK的&lt;code&gt;java.text.DateFormat&lt;/code&gt;（实际为SimpleDateFormat），现在知道为毛&lt;a href=&quot;https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw&quot; target=&quot;_blank&quot;&gt;上篇文章&lt;/a&gt;要先讲JDK的格式化体系做铺垫了吧，万变不离其宗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201226210109260.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此可以认为，Spring为此做的事情的核心，只不过是写了个根据Locale、pattern、IOS等参数生成&lt;code&gt;DateFormat&lt;/code&gt;实例的逻辑而已，属于应用层面的封装。也就是需要知晓&lt;code&gt;getDateFormat()&lt;/code&gt;方法的逻辑，此部分逻辑绘制成图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201222060840323.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此：pattern、iso、stylePattern它们的优先级谁先谁后，一看便知。&lt;/p&gt;
&lt;h5 id=&quot;代码示例&quot;&gt;代码示例&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1() {
    DateFormatter formatter = new DateFormatter();
    
    Date currDate = new Date();

    System.out.println(&quot;默认输出格式：&quot; + formatter.print(currDate, Locale.CHINA));
    formatter.setIso(DateTimeFormat.ISO.DATE_TIME);
    System.out.println(&quot;指定ISO输出格式：&quot; + formatter.print(currDate, Locale.CHINA));
    formatter.setPattern(&quot;yyyy-mm-dd HH:mm:ss&quot;);
    System.out.println(&quot;指定pattern输出格式：&quot; + formatter.print(currDate, Locale.CHINA));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;默认输出格式：2020-12-26
指定ISO输出格式：2020-12-26T13:06:52.921Z
指定pattern输出格式：2020-06-26 21:06:52
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：ISO格式输出的时间，是存在时差问题的，因为它使用的是UTC时间，请稍加注意。&lt;/p&gt;
&lt;p&gt;还记得本系列前面介绍的&lt;code&gt;CustomDateEditor&lt;/code&gt;这个属性编辑器吗？它也是用于对String -&amp;gt; Date的转化，底层依赖也是JDK的&lt;code&gt;DateFormat&lt;/code&gt;，但使用灵活度上没这个自由，已被抛弃/取代。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;java.util.Date&lt;/code&gt;类型的格式化，在此，语重心长的号召一句：如果你是&lt;strong&gt;新&lt;/strong&gt;项目，请全项目禁用Date类型吧；如果你是新代码，也请不要再使用Date类型，太拖后腿了。&lt;/p&gt;
&lt;h4 id=&quot;jsr-310类型&quot;&gt;JSR 310类型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201226212041456.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JSR 310日期时间类型是Java8引入的一套&lt;strong&gt;全新的&lt;/strong&gt;时间日期API。新的时间及日期API位于java.time中，此包中的是类是不可变且线程安全的。下面是一些关键类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Instant&lt;/strong&gt;——代表的是时间戳（另外可参考Clock类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LocalDate&lt;/strong&gt;——不包含具体时间的日期，如2020-12-12。它可以用来存储生日，周年纪念日，入职日期等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LocalTime&lt;/strong&gt;——代表的是不含日期的时间，如18:00:00&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LocalDateTime&lt;/strong&gt;——包含了日期及时间，不过没有偏移信息或者说时区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ZonedDateTime&lt;/strong&gt;——包含时区的&lt;strong&gt;完整的&lt;/strong&gt;日期时间还有时区，偏移量是以UTC/格林威治时间为基准的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timezone&lt;/strong&gt;——时区。在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时还有一些辅助类，如：Year、Month、YearMonth、MonthDay、Duration、Period等等。&lt;/p&gt;
&lt;p&gt;从上图&lt;code&gt;Formatter&lt;/code&gt;的继承树来看，Spring只提供了一些辅助类的格式化器实现，如MonthFormatter、PeriodFormatter、YearMonthFormatter等，且实现方式都是趋同的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class MonthFormatter implements Formatter&amp;lt;Month&amp;gt; {

        @Override
        public Month parse(String text, Locale locale) throws ParseException {
                return Month.valueOf(text.toUpperCase());
        }
        @Override
        public String print(Month object, Locale locale) {
                return object.toString();
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里以MonthFormatter为例，其它辅助类的格式化器实现其实基本一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201222064054953.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了：Spring为毛没有给&lt;code&gt;LocalDateTime、LocalDate、LocalTime&lt;/code&gt;这种更为常用的类型提供Formatter格式化器呢？&lt;/p&gt;
&lt;p&gt;其实是这样的：JDK 8提供的这套日期时间API是非常优秀的，自己就提供了非常好用的&lt;code&gt;java.time.format.DateTimeFormatter&lt;/code&gt;格式化器，并且设计、功能上都已经非常完善了。既然如此，Spring并不需要再重复造轮子，而是仅需考虑如何&lt;strong&gt;整合&lt;/strong&gt;此格式化器即可。&lt;/p&gt;
&lt;h5 id=&quot;整合datetimeformatter&quot;&gt;整合DateTimeFormatter&lt;/h5&gt;
&lt;p&gt;为了完成“整合”，把DateTimeFormatter融入到Spring自己的Formatter体系内，Spring准备了多个API用于衔接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DateTimeFormatterFactory&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;java.time.format.DateTimeFormatter&lt;/code&gt;的工厂。和DateFormatter一样，它支持如下属性方便你直接定制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DateTimeFormatterFactory：

        @Nullable
        private String pattern;
        @Nullable
        private ISO iso;
        @Nullable
        private FormatStyle dateStyle;
        @Nullable
        private FormatStyle timeStyle;
        @Nullable
        private TimeZone timeZone;


        // 根据定制的参数，生成一个DateTimeFormatter实例
        public DateTimeFormatter createDateTimeFormatter(DateTimeFormatter fallbackFormatter) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201223060640184.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优先级关系二者是一致的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern&lt;/li&gt;
&lt;li&gt;iso&lt;/li&gt;
&lt;li&gt;dateStyle/timeStyle&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：一致的设计，可以给与开发者近乎一致的&lt;strong&gt;编程体验&lt;/strong&gt;，毕竟JSR 310和Date表示的都是时间日期，尽量保持一致性是一种很人性化的设计考量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DateTimeFormatterFactoryBean&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;顾名思义，DateTimeFormatterFactory用于生成一个DateTimeFormatter实例，而本类用于把生成的Bean放进IoC容器内，完成和Spring容器的整合。客气的是，它直接继承自DateTimeFormatterFactory，从而自己同时就具备这两项能力：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成DateTimeFormatter实例&lt;/li&gt;
&lt;li&gt;将该实例放进IoC容器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;多说一句：虽然这个工厂Bean非常简单，但是它释放的信号可以作为&lt;strong&gt;编程指导&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个应用内，对日期、时间的格式化尽量只存在&lt;strong&gt;1种模版规范&lt;/strong&gt;。比如我们可以向IoC容器里扔进去一个模版，需要时注入进来使用即可
&lt;ol&gt;&lt;li&gt;注意：这里指的应用&lt;strong&gt;内&lt;/strong&gt;，一般不包含协议转换层使用的模版规范。如Http协议层可以使用自己单独的一套转换模版机制&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;日期时间模版不要在每次使用时去临时创建，而是集中统一创建好管理起来（比如放IoC容器内），这样维护起来方便很多&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：&lt;code&gt;DateTimeFormatterFactoryBean&lt;/code&gt;这个API在Spring内部并未使用，这是Spring专门给使用者用的，因为Spring也希望你这么去做从而把日期时间格式化模版管理起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;代码示例-1&quot;&gt;代码示例&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1() {
    // DateTimeFormatterFactory dateTimeFormatterFactory = new DateTimeFormatterFactory();
    // dateTimeFormatterFactory.setPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);

    // 执行格式化动作
    System.out.println(new DateTimeFormatterFactory(&quot;yyyy-MM-dd HH:mm:ss&quot;).createDateTimeFormatter().format(LocalDateTime.now()));
    System.out.println(new DateTimeFormatterFactory(&quot;yyyy-MM-dd&quot;).createDateTimeFormatter().format(LocalDate.now()));
    System.out.println(new DateTimeFormatterFactory(&quot;HH:mm:ss&quot;).createDateTimeFormatter().format(LocalTime.now()));
    System.out.println(new DateTimeFormatterFactory(&quot;yyyy-MM-dd HH:mm:ss&quot;).createDateTimeFormatter().format(ZonedDateTime.now()));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;2020-12-26 22:44:44
2020-12-26
22:44:44
2020-12-26 22:44:44
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：虽然你也可以直接使用&lt;code&gt;DateTimeFormatter#ofPattern()&lt;/code&gt;静态方法得到一个实例，&lt;strong&gt;但是&lt;/strong&gt; 若在Spring环境下使用它我还是建议使用Spring提供的工厂类来创建，这样能保证统一的编程体验，B格也稍微高点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用建议&lt;/strong&gt;：以后对日期时间类型（包括JSR310类型）就不要自己去写原生的&lt;code&gt;SimpleDateFormat/DateTimeFormatter&lt;/code&gt;了，建议可以用Spring包装过的&lt;code&gt;DateFormatter/DateTimeFormatterFactory&lt;/code&gt;，使用体验更佳。&lt;/p&gt;
&lt;h3 id=&quot;数字格式化&quot;&gt;数字格式化&lt;/h3&gt;
&lt;p&gt;通过了&lt;a href=&quot;https://mp.weixin.qq.com/s/ENKwVqPE1cuOgE51ODJnnw&quot; target=&quot;_blank&quot;&gt;上篇文章&lt;/a&gt;的学习之后，对数字的格式化就一点也不陌生了，什么数字、百分数、钱币等都属于数字的范畴。Spring提供了&lt;code&gt;AbstractNumberFormatter&lt;/code&gt;抽象来专门处理数字格式化议题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractNumberFormatter implements Formatter&amp;lt;Number&amp;gt; {
        ...
        @Override
        public String print(Number number, Locale locale) {
                return getNumberFormat(locale).format(number);
        }


        @Override
        public Number parse(String text, Locale locale) throws ParseException {
                // 伪代码，核心逻辑就这一句
                return getNumberFormat.parse(text, new ParsePosition(0));
        }

        // 得到一个NumberFormat实例
        protected abstract NumberFormat getNumberFormat(Locale locale);
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和&lt;code&gt;DateFormatter&lt;/code&gt;的实现模式何其相似，简直一模一样：底层实现依赖于（委托给）&lt;code&gt;java.text.NumberFormat&lt;/code&gt;去完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227054222168.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此抽象类共有三个具体实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NumberStyleFormatter：数字格式化，如小数，分组等&lt;/li&gt;
&lt;li&gt;PercentStyleFormatter：百分数格式化&lt;/li&gt;
&lt;li&gt;CurrencyStyleFormatter：钱币格式化&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数字格式化-1&quot;&gt;数字格式化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;NumberStyleFormatter&lt;/code&gt;使用NumberFormat的&lt;strong&gt;数字样式&lt;/strong&gt;的通用数字格式化程序。可定制化参数为：pattern。核心源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;NumberStyleFormatter：

        @Override
        public NumberFormat getNumberFormat(Locale locale) {
                NumberFormat format = NumberFormat.getInstance(locale);
                ...
                // 解析时，永远返回BigDecimal类型
                decimalFormat.setParseBigDecimal(true);
                // 使用格式化模版
                if (this.pattern != null) {
                        decimalFormat.applyPattern(this.pattern);
                }
                return decimalFormat;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test2() throws ParseException {
    NumberStyleFormatter formatter = new NumberStyleFormatter();

    double myNum = 1220.0455;
    System.out.println(formatter.print(myNum, Locale.getDefault()));

    formatter.setPattern(&quot;#.##&quot;);
    System.out.println(formatter.print(myNum, Locale.getDefault()));

    // 转换
    // Number parsedResult = formatter.parse(&quot;1,220.045&quot;, Locale.getDefault()); // java.text.ParseException: 1,220.045
    Number parsedResult = formatter.parse(&quot;1220.045&quot;, Locale.getDefault());
    System.out.println(parsedResult.getClass() + &quot;--&amp;gt;&quot; + parsedResult);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;1,220.045
1220.05

class java.math.BigDecimal--&amp;gt;1220.045
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;可通过setPattern()指定数字格式化的模版（一般建议显示指定）&lt;/li&gt;
&lt;li&gt;parse()方法返回的是&lt;code&gt;BigDecimal&lt;/code&gt;类型，从而保证了数字精度&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;百分数格式化&quot;&gt;百分数格式化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;PercentStyleFormatter&lt;/code&gt;表示使用百分比样式去格式化数字。核心源码（其实是全部源码）如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PercentStyleFormatter：

        @Override
        protected NumberFormat getNumberFormat(Locale locale) {
                NumberFormat format = NumberFormat.getPercentInstance(locale);
                if (format instanceof DecimalFormat) {
                        ((DecimalFormat) format).setParseBigDecimal(true);
                }
                return format;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个就更简单啦，pattern模版都不需要指定。代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test3() throws ParseException {
    PercentStyleFormatter formatter = new PercentStyleFormatter();

    double myNum = 1220.0455;
    System.out.println(formatter.print(myNum, Locale.getDefault()));

    // 转换
    // Number parsedResult = formatter.parse(&quot;1,220.045&quot;, Locale.getDefault()); // java.text.ParseException: 1,220.045
    Number parsedResult = formatter.parse(&quot;122,005%&quot;, Locale.getDefault());
    System.out.println(parsedResult.getClass() + &quot;--&amp;gt;&quot; + parsedResult);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;122,005%
class java.math.BigDecimal--&amp;gt;1220.05
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;百分数的格式化不能指定pattern，差评。&lt;/p&gt;
&lt;h4 id=&quot;钱币格式化&quot;&gt;钱币格式化&lt;/h4&gt;
&lt;p&gt;使用&lt;strong&gt;钱币样式&lt;/strong&gt;格式化数字，使用&lt;code&gt;java.util.Currency&lt;/code&gt;来描述货币。代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test3() throws ParseException {
    CurrencyStyleFormatter formatter = new CurrencyStyleFormatter();

    double myNum = 1220.0455;
    System.out.println(formatter.print(myNum, Locale.getDefault()));

    System.out.println(&quot;--------------定制化--------------&quot;);
    // 指定货币种类（如果你知道的话）
    // formatter.setCurrency(Currency.getInstance(Locale.getDefault()));
    // 指定所需的分数位数。默认是2
    formatter.setFractionDigits(1);
    // 舍入模式。默认是RoundingMode#UNNECESSARY
    formatter.setRoundingMode(RoundingMode.CEILING);
    // 格式化数字的模版
    formatter.setPattern(&quot;#.#¤¤&quot;);

    System.out.println(formatter.print(myNum, Locale.getDefault()));

    // 转换
    // Number parsedResult = formatter.parse(&quot;￥1220.05&quot;, Locale.getDefault());
    Number parsedResult = formatter.parse(&quot;1220.1CNY&quot;, Locale.getDefault());
    System.out.println(parsedResult.getClass() + &quot;--&amp;gt;&quot; + parsedResult);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;￥1,220.05
--------------定制化--------------
1220.1CNY
class java.math.BigDecimal--&amp;gt;1220.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得关注的是：这三个实现在Spring 4.2版本之前是“耦合”在一起。直到4.2才拆开，职责分离。&lt;/p&gt;

&lt;p&gt;本文介绍了Spring的Formatter抽象，让格式化器大一统。这就是Spring最强能力：API设计、抽象、大一统。&lt;/p&gt;
&lt;p&gt;Converter可以从任意源类型，转换为任意目标类型。而Formatter则是从String类型转换为任务目标类型，有点类似PropertyEditor。可以感觉出Converter是Formater的&lt;strong&gt;超集&lt;/strong&gt;，实际上在Spring中Formatter是被拆解成PrinterConverter和ParserConverter，然后再注册到ConverterRegistry，供后续使用。&lt;/p&gt;
&lt;p&gt;关于格式化器的注册中心、注册员，这就是下篇文章内容喽，欢迎保持持续关注。&lt;/p&gt;
&lt;h2 id=&quot;本文思考题&quot;&gt;♨本文思考题♨&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;看完了不一定懂，看懂了不一定记住，记住了不一定掌握&lt;/strong&gt;。来，文末3个思考题帮你复盘：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spring为何没有针对JSR310时间类型提供专用转换器实现？&lt;/li&gt;
&lt;li&gt;Spring内建众多Formatter实现，如何管理？&lt;/li&gt;
&lt;li&gt;格式化器Formatter和转换器Converter是如何整合到一起的？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;♚声明♚&quot;&gt;♚声明♚&lt;/h2&gt;
&lt;p&gt;本文所属专栏：&lt;strong&gt;Spring类型转换&lt;/strong&gt;，公号后台回复专栏名即可获取全部内容。&lt;/p&gt;
&lt;blockquote readability=&quot;6.2222222222222&quot;&gt;
&lt;p&gt;分享、成长，拒绝浅藏辄止。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】，回复关键字&lt;code&gt;专栏&lt;/code&gt;有Spring技术栈、中间件等小而美的&lt;strong&gt;原创专栏&lt;/strong&gt;供以免费学习。本文已被 &lt;a href=&quot;https://www.yourbatman.cn&quot; target=&quot;_blank&quot;&gt;https://www.yourbatman.cn&lt;/a&gt; 收录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是 &lt;strong&gt;A哥(YourBatman)&lt;/strong&gt; 原创文章，未经作者允许不得转载，谢谢合作。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;☀推荐阅读☀&lt;/h2&gt;
</description>
<pubDate>Sun, 10 Jan 2021 22:28:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>Date日期、JSR 310日期、数字、百分数、钱币格式化大一统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/14260469.html</dc:identifier>
</item>
<item>
<title>腾讯IOT之树莓派物联网设备 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/14260353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/14260353.html</guid>
<description>&lt;p&gt;本次实验的目的是将&lt;strong&gt;树莓派&lt;/strong&gt;设置为一个&lt;strong&gt;物联网终端&lt;/strong&gt;，通过微信小程序可以控制树莓派，实现蜂鸣器的开关。&lt;/p&gt;
&lt;p&gt;微信小程序界面如下所示，点击这个开关，就可以控制蜂鸣器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011309131-595911639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/IotForTecentBeep&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaohuiduan/IotForTecentBeep&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;硬件配置&quot;&gt;硬件配置&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;树莓派&lt;/li&gt;
&lt;li&gt;蜂鸣器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这里我将树莓派接的是&lt;code&gt;GPIO_00&lt;/code&gt;，使用的树莓派是树莓派4B版本。不同的树莓派的GPIO接口可能不同，可以根据自己的需要按情况考虑。&lt;/p&gt;
&lt;p&gt;实物图如下所示，VCC——3.3V ，GND ——GND，IO——GPIO_00（低电平触发）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011311955-476053761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;软件配置&quot;&gt;软件配置&lt;/h2&gt;
&lt;p&gt;编程语言使用的是Java，也就是说将使用Java实现腾讯云IOT平台的连接和树莓派GPIO口的控制。使用的IDE是&lt;code&gt;IntelliJ IDEA&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;tecent-iot-开发平台的使用&quot;&gt;Tecent IOT 开发平台的使用&lt;/h2&gt;
&lt;p&gt;Tecent IOT开发平台的官方参考文档网址：&lt;a href=&quot;https://cloud.tencent.com/document/product/1081&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/document/product/1081&lt;/a&gt;，不过个人觉得其文档对于Java SDK的描述不够详细，建议去看其 &lt;a href=&quot;https://github.com/tencentyun/iot-device-java/tree/master/explorer/explorer-device-android&quot; target=&quot;_blank&quot;&gt;Demo&lt;/a&gt; 源码才能明白其工作流程。&lt;/p&gt;
&lt;p&gt;腾讯云IOT开发平台的项目结构如下所示：分为两层——&lt;code&gt;项目&lt;/code&gt; 和 &lt;code&gt;产品&lt;/code&gt;。在使用其平台的时候，既需要创建project，也需要创建product。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011321114-1679874630.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;我们可以将&lt;strong&gt;项目&lt;/strong&gt;理解为智能家居整个系统，因此在项目中有很多&lt;strong&gt;产品&lt;/strong&gt;，比如说智能空调，智能报警器等等产品。而在空调中有温度、湿度等&lt;strong&gt;属性&lt;/strong&gt;，同时也有着开关等&lt;strong&gt;控制器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而在这篇博客中，项目名称是&lt;strong&gt;物联网实训&lt;/strong&gt;，产品名为&lt;strong&gt;树莓派&lt;/strong&gt;，但是树莓派只有一个&lt;strong&gt;功能&lt;/strong&gt;——控制蜂鸣器。也就是说，没有&lt;strong&gt;属性&lt;/strong&gt;，只有&lt;strong&gt;控制器&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新建项目&quot;&gt;新建项目&lt;/h3&gt;
&lt;p&gt;打开网址：&lt;a href=&quot;https://console.cloud.tencent.com/iotexplorer&quot; target=&quot;_blank&quot;&gt;https://console.cloud.tencent.com/iotexplorer&lt;/a&gt;新建项目，项目名称随意就行，创建好项目后，进入项目，然后创建产品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011321404-1560664340.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建产品&quot;&gt;新建产品&lt;/h3&gt;
&lt;p&gt;创建产品的选项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备：因为我们是准备将树莓派作为一台设备来使用的，因此，应该选择&lt;strong&gt;”设备“&lt;/strong&gt;，当然，如果是准备将它作为网关，则看着选就行了。&lt;/li&gt;
&lt;li&gt;认证方式：认证方式选择密钥认证，这样在代码中间直接写设备的密码就行，比证书稍微方便一点（不过实际上证书方便一点）。&lt;/li&gt;
&lt;li&gt;数据协议：使用数据模板即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011321711-92143623.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加自定义功能&quot;&gt;添加自定义功能&lt;/h3&gt;
&lt;p&gt;物联网设备，之所以叫物联网，是因为大家想把传感器获得的数据放在云端，或者通过云端去控制物联网设备。那么放什么数据，控制什么功能，则需要我们去定义。这里选择控制树莓派上面的蜂鸣器，因此只需要定义蜂鸣器即可。&lt;/p&gt;
&lt;p&gt;在腾讯IOT中，可以使用&lt;code&gt;新建功能&lt;/code&gt;定义这些功能。选择&lt;strong&gt;属性&lt;/strong&gt;，数据类型选择&lt;strong&gt;布尔型&lt;/strong&gt;（因为只有控制蜂鸣器的开/关）。请记住这个标识符&lt;code&gt;beep_switch&lt;/code&gt;，这个将在后面的代码中用到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011321970-692578450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于功能类型的不同，可以参考下面的表格。（不过在个人看来，在他的官方 Demo 中，无论是物联设备的数据（比如说温度湿度），还是物联网的控制（比如说灯的开关），它都定义成为了属性。也就是说，尽管 &lt;strong&gt;蜂鸣器的开关&lt;/strong&gt; 是人为下发的控制，但是还是定义为属性。至于事件和行为有什么作用，我也不清楚……)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下来自官方文档&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能元素&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;th&gt;功能标识符&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;用于描述设备的实时状态，支持读取和设置，如模式、亮度、开关等。&lt;/td&gt;
&lt;td&gt;PropertiesId&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;事件&lt;/td&gt;
&lt;td&gt;用于描述设备运行时的事件，包括告警、信息和故障等三种事件类型，可添加多个输出参数，如环境传感器检测到空气质量很差，空调异常告警等。&lt;/td&gt;
&lt;td&gt;EventId&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;行为&lt;/td&gt;
&lt;td&gt;用于描述复杂的业务逻辑,可添加多个调用参数和返回参数,用于让设备执行某项特定的任务，例如，开锁动作需要知道是哪个用户在什么时间开锁，锁的状态如何等。&lt;/td&gt;
&lt;td&gt;ActionId&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;p&gt;点击下一步，进入设备开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011322333-1611653495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设备开发&quot;&gt;设备开发&lt;/h3&gt;
&lt;p&gt;因为这里使用的是Java SDK进行开发，没有使用模组也没有基于OS开发，因此直接点击下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011322601-262907442.png&quot; alt=&quot;image-20210106165342612&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步就到了微信小程序配置。&lt;/p&gt;
&lt;h3 id=&quot;微信小程序配置&quot;&gt;微信小程序配置&lt;/h3&gt;
&lt;p&gt;腾讯IOT平台相比较于其他平台，有一个很大的特点就是可以很好的支持小程序。也就是说，在开发的阶段，就可以使用小程序去验证设备的功能。并且这个微信小程序不需要自己写样式代码，只需要进行简单的配置，就可以直接从小程序上面看到物联网设备的数据。&lt;/p&gt;
&lt;p&gt;因为这里我们使用的数据很简单，只有开关，所以随便配置一下面板即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011322904-1494654844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;面板配置&quot;&gt;面板配置&lt;/h4&gt;
&lt;p&gt;这里面板类型选择&lt;strong&gt;标准面板&lt;/strong&gt;，简单的配置一下开关即可，效果图如右图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011323188-1192830049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存退出之后，就进入到新建设备功能页面。&lt;/p&gt;
&lt;h3 id=&quot;新建设备&quot;&gt;新建设备&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;新建设备`的意义：创建一个设备代表启动了一个账号（这个设备会提供一个密钥），我们的设备使用这个密钥，就可以让我们的设备连接腾讯云IOT平台进行数据交互。&lt;/p&gt;
&lt;p&gt;从现实意义来说，就是我手中有一个树莓派，我需要让它连接腾讯云IOT平台，就需要账号密码，所以就需要创建一个设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建设备的步骤如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011323655-563197527.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用设备&quot;&gt;使用设备&lt;/h3&gt;
&lt;p&gt;点击 &lt;strong&gt;my_pi&lt;/strong&gt; ，进入设备管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011324109-1059251643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设备管理界面如下所示：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设备信息：这里面是设备的一些基本属性，其中通过设备&lt;code&gt;名称&lt;/code&gt;，&lt;code&gt;设备密钥&lt;/code&gt;，和&lt;code&gt;产品ID&lt;/code&gt;就可以唯一定位一个&lt;code&gt;设备&lt;/code&gt;，然后对其进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设备日志：设备日志里面保存着设备的上行和下行数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在线调试：通过在线调试，可以模拟设备的行为，或者对设备下发控制命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011324358-1247732115.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在线调试&quot;&gt;在线调试&lt;/h3&gt;
&lt;p&gt;可以使用在线的调试功能对物联网设备进行功能下发。（比如说下发开关数据，控制蜂鸣器的开关）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011324707-374385829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设备日志&quot;&gt;设备日志&lt;/h3&gt;
&lt;p&gt;可以在设备中看到物联网设备与云平台之间的上行和下行数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011325798-1121187172.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;🆗，以上的所有就是腾讯IOT平台的介绍，通过上面的操作，就可以创建一个设备，获得其name，key，id，然后对其进行开发。&lt;/p&gt;
&lt;h2 id=&quot;树莓派java开发&quot;&gt;树莓派Java开发&lt;/h2&gt;
&lt;p&gt;针对于树莓派开发，相信大家听过最多的都是Python开发，使用Python去控制树莓派的GPIO口，但是，因为腾讯提供的平台没有Python的SDK，因此，只能选择Java去控制树莓派的GPIO口。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pi4j.com/1.2/index.html&quot; target=&quot;_blank&quot;&gt;Pi4j&lt;/a&gt;是一个专门用来控制树莓派GPIO口的设备。关于使用安装可以去看&lt;a href=&quot;https://www.jianshu.com/p/0584f8b01725&quot; target=&quot;_blank&quot;&gt;树莓派---JAVA操作GPIO&lt;/a&gt;（不过基本上比较新的树莓派系统都不需要安装了）。&lt;/p&gt;
&lt;p&gt;因为我们是在Windows平台开发然后在树莓派上面运行Java程序（打包成jar运行），因此需要在树莓派上面安装Java环境（不过一般来说树莓派都自带了Java环境）。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;p&gt;使用IDEA创建maven项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011326177-2134228654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上述操作就创建一个Java maven项目。&lt;/p&gt;
&lt;h3 id=&quot;配置maven文件&quot;&gt;配置maven文件&lt;/h3&gt;
&lt;p&gt;然后配置maven文件，也就是&lt;code&gt;pom.xml&lt;/code&gt;，在其中导入依赖库，以及进行配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011326720-1108624365.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt;
                    &amp;lt;descriptorRefs&amp;gt;
                        &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;
                    &amp;lt;/descriptorRefs&amp;gt;
                    &amp;lt;archive&amp;gt;
                        &amp;lt;manifest&amp;gt;
                            &amp;lt;!--注意，此处必须是main()方法对应类的完整路径  --&amp;gt;
                            &amp;lt;mainClass&amp;gt;Main&amp;lt;/mainClass&amp;gt;
                        &amp;lt;/manifest&amp;gt;
                    &amp;lt;/archive&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;assembly&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
        
    &amp;lt;!--    生成的包名--&amp;gt;
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;IotForTecentBeep&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;!--    添加依赖库--&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--        腾讯IOT库--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.tencent.iot.explorer&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;explorer-device-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--        树莓派GPIO 库--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.pi4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pi4j-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;


    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;项目文件配置&quot;&gt;项目文件配置&lt;/h3&gt;
&lt;p&gt;在项目的目录下面添加data.json文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011327240-1610153568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;data.json需要存放一些数据。这个数据实际上就是&lt;strong&gt;自定义功能的json数据&lt;/strong&gt;，从页面复制之后粘贴到data.json文件中即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011327712-1690133047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;使用Java编写代码，具体的解释可以看代码中间的注释。不过要注意，需要根据自己的设备情况更改如下的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011328008-1715303757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，在这个地方需要根据自己的情况修改。（尽管在云平台中定义的是布尔型数据，但是实际上腾讯云发送过来的是int类型数据。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011328292-1928214930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在代码中要注意，&lt;strong&gt;必须&lt;/strong&gt;先订阅（也就是执行&lt;code&gt;subscribeTopic&lt;/code&gt;函数），才能够进行接收到平台发送过来的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.pi4j.io.gpio.*;
import com.tencent.iot.explorer.device.java.common.Status;
import com.tencent.iot.explorer.device.java.data_template.TXDataTemplateDownStreamCallBack;
import com.tencent.iot.explorer.device.java.mqtt.TXMqttActionCallBack;
import com.tencent.iot.explorer.device.java.server.samples.data_template.DataTemplateSample;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.json.JSONObject;

/**
 * @author XiaoHui
 */
public class Main {
    /**
     * IOT平台URL
     */
    public static String mBrokerURL = &quot;ssl://iotcloud-mqtt.gz.tencentdevices.com:8883&quot;;
    /**
     * 产品ID
     */
    public static String mProductID = &quot;64ONICJ3N8&quot;;
    /**
     * 设备名称
     */
    public static String mDevName = &quot;my_pi&quot;;
    /**
     * 设备密钥
     */
    public static String mDevPSK = &quot;1ktYq8uojYiuJgX7iZxAoQ==&quot;;
    /**
     * 储存属性的json文件名
     */
    public static String mJsonFileName = &quot;data.json&quot;;

    private static DataTemplateSample mDataTemplateSample;

    /**
     * 获得GPIO的控制器
     */
    public static final GpioController gpio = GpioFactory.getInstance();
    /**
     * GPIO输出，使用GPIO_00 ,默认输出为High
     */
    public static final GpioPinDigitalOutput beep = gpio.provisionDigitalOutputPin(RaspiPin.GPIO_00, &quot;beep&quot;, PinState.HIGH);


    public static void main(String[] args) {
        // CallBack 代表的是MQTT协议的回调函数，MyDownCallback代表的是IOT平台下发消息的回调
        mDataTemplateSample = new DataTemplateSample(mBrokerURL, mProductID, mDevName, mDevPSK,
                null, null, new CallBack(), mJsonFileName, new MyDownCallback());
        // 进行连接
        mDataTemplateSample.connect();
        // 进行订阅，只有订阅后，消息才能下发。
        mDataTemplateSample.subscribeTopic();
        mDataTemplateSample.propertyClearControl();
    }

    /**
     * MQTT的回调函数，可以不用管
     */
    public static class CallBack extends TXMqttActionCallBack {

        @Override
        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {

        }

        @Override
        public void onConnectionLost(Throwable cause) {

        }

        @Override
        public void onDisconnectCompleted(Status status, Object userContext, String msg) {
        }

        @Override
        public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
        }

        @Override
        public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {
        }

        @Override
        public void onMessageReceived(final String topic, final MqttMessage message) {

        }

    }

    /**
     * 实现下行消息处理的回调接口
     */
    private static class MyDownCallback extends TXDataTemplateDownStreamCallBack {

        @Override
        public void onReplyCallBack(String msg) {

        }

        @Override
        public void onGetStatusReplyCallBack(JSONObject data) {


        }

        /**
         * 在微信小程序点击关闭按钮后，IOT平台会向树莓派发送命令消息，此命令消息会在这这里进行回调
         * beep是低电平触发！！！！！！！！！！！！
         *
         * @param msg 接收到的消息。
         * @return
         */
        @Override
        public JSONObject onControlCallBack(JSONObject msg) {

                        // 获得开关的数据，beep_switch是开关的标识符。尽管我们在云平台中定义的是布尔型数据，但是实际上腾讯云发送过来的是int类型数据。
            int power = msg.getInt(&quot;beep_switch&quot;);
            // 打开开关
            if (power == 1) {
                beep.low();
                System.out.println(&quot;打开&quot;);
            } else {
                // 关闭蜂鸣器
                beep.high();
                System.out.println(&quot;关闭&quot;);
            }
            // 返回消息
            JSONObject result = new JSONObject();
            result.put(&quot;code&quot;, 0);
            result.put(&quot;status&quot;, &quot;ok&quot;);
            return result;
        }

        @Override
        public JSONObject onActionCallBack(String actionId, JSONObject params) {
           return null;
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码打包&quot;&gt;代码打包&lt;/h3&gt;
&lt;p&gt;因为我们的代码是在windows上面编译的，因此需要将其编译成jar文件，这个也就是之前配置&lt;code&gt;pom.xml&lt;/code&gt;文件的原因。IDEA上面编译还是挺简单的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011328658-571995648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过如上的操作我们就将项目编译成了jar包，jar包在target目录下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011329007-2061138634.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;程序运行&quot;&gt;程序运行&lt;/h2&gt;
&lt;p&gt;将编译好的jar文件放到树莓派中，使用VNC或者XShell皆可。然后在jar包文件目录下使用如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;java -jar 包名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此次项目生成的包名为&lt;code&gt;IotForTecentBeep-1.0-SNAPSHOT.jar&lt;/code&gt;，因此命令如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011329941-792876919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当程序运行起来的时候，就可以在微信小程序或者在线调试工具中对蜂鸣器进行控制。&lt;/p&gt;
&lt;h3 id=&quot;微信小程序控制&quot;&gt;微信小程序控制&lt;/h3&gt;
&lt;p&gt;前面说了，可以是用微信小程序对开发的物联网设备进行开发调试，然后在如下的页面得到设备的二维码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011330198-2024736160.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开”腾讯连连“小程序，对二维码进行扫描，即可将设备加入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011330599-143745257.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击中间的按钮就可以实现对蜂鸣器的控制了！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210111011331379-1767376320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;相比较于上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/14244343.html&quot; target=&quot;_blank&quot;&gt;腾讯IOT安卓开发初探&lt;/a&gt;，这一次实现消息的下发接收控制。不过有一说一，官方文档是真的坑，连一个比较详细的说明文档都没有，还得自己一个一个Debug，查看为什么消息发送失败，查看为什么没有接收到下发的消息……&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/xiaohuiduan/IotForTecentBeep&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaohuiduan/IotForTecentBeep&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol readability=&quot;0.20851063829787&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/14244343.html&quot; target=&quot;_blank&quot;&gt;腾讯IOT安卓开发初探&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.36734693877551&quot;&gt;
&lt;p&gt;物联网开发平台使用文档：&lt;a href=&quot;https://cloud.tencent.com/document/product/1081&quot; target=&quot;_blank&quot;&gt;物联网开发平台 - 文档中心 - 腾讯云 (tencent.com)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/tencentyun/iot-device-java&quot; target=&quot;_blank&quot;&gt;iot-device-java&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.basemu.com/raspberry-pi-4-gpio-pinout.html&quot; target=&quot;_blank&quot;&gt;树莓派4的GPIO接口介绍 – 八色木 (basemu.com)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0584f8b01725&quot; target=&quot;_blank&quot;&gt;树莓派---JAVA操作GPIO&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 10 Jan 2021 17:14:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>腾讯IOT之树莓派物联网设备 本次实验的目的是将树莓派设置为一个物联网终端，通过微信小程序可以控制树莓派，实现蜂鸣器的开关。 微信小程序界面如下所示，点击这个开关，就可以控制蜂鸣器。 项目地址：htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/14260353.html</dc:identifier>
</item>
</channel>
</rss>