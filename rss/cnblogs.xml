<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一个平凡但不平庸的程序猿2018个人总结 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10211265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10211265.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;又到了一年一度的年终总结了，相信大家估计也开始写总结，本人也不例外。在公司中写完模板化的总结之后，自己还是写了一个给自己的总结。本篇总结主要是讲述去年所定下目标的完成情况和人生感悟以及明年的目标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;去年目标以及完成情况&quot;&gt;去年目标以及完成情况&lt;/h2&gt;
&lt;h3 id=&quot;去年目标&quot;&gt;去年目标&lt;/h3&gt;
&lt;p&gt;完整的链接在这里:&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/8158716.html&quot;&gt;一个两年java程序猿的2017个人总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里先列举一下去年定的目标:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;阅读2本以上的技术相关书籍，并作出相应的实践；&lt;/li&gt;
&lt;li&gt;阅读5本以上国内外有意思的书籍；&lt;/li&gt;
&lt;li&gt;阅读jdk常用类的源码，能够理解其中的涵义；&lt;/li&gt;
&lt;li&gt;能够熟练掌握3个常用的技术框架；&lt;/li&gt;
&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天；&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动；&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天；&lt;/li&gt;
&lt;li&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;。。。 现在看来，去年定的目标有点多并且完成的难度还不小 o(╥﹏╥)o&lt;/p&gt;
&lt;p&gt;既然要做总结，那么还是需要看看这些是否达成了。&lt;/p&gt;
&lt;h3 id=&quot;完成情况&quot;&gt;完成情况&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先第一条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读2本以上的技术相关书籍，并作出相应的实践；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先是技术书籍，今年主要看完并做出实践的有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《编写高质量代码：改善Java程序的151个建议》&lt;/li&gt;
&lt;li&gt;《Effective Java》&lt;/li&gt;
&lt;li&gt;《阿里巴巴Java开发手册》&lt;/li&gt;
&lt;li&gt;《大话设计模式》&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中1、2、3这三本书对我编写代码的帮助非常大，特别是第三本，很大的程度上提升了我代码的质量。以前的我写代码仅仅只是为了应付工作，功能实现了就行，基本不管代码格式是否规范，性能是否最优，代码注释是否完整。。。 看完这三本书之后，慢慢开始在写代码的时候注意这些了，先不说代码质量写不写得好，但是起码的代码规范、参数命名、方法使用、异常处理等等已经改善了很多了，比如集合参数获取或遍历的时候，习惯先进行空指针的判断，需要关闭流的时候必须在finally中进行，if中条件过多时会抽出来并使用一个final boolean变量进行判断等等。其中改变最大的这块应该是注释这块了，在类、类属性、类方法使用Javadoc注释，方法中复杂逻辑概述使用块注释，简单的使用行注释，后续可能恢复的代码使用 &lt;code&gt;///&lt;/code&gt;注释等等。第四本 《大话设计模式》中主要学习的是设计模式思想，理解了一些并写成了相应的&lt;a href=&quot;https://www.cnblogs.com/xuwujing/category/1249313.html&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从这几本书中得到的收获远远不止这些，但这里就不在细说了。&lt;/p&gt;
&lt;p&gt;看过的书并做了一些实践的有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《Java 编程思想》&lt;/li&gt;
&lt;li&gt;《Java 并发编程实战》&lt;/li&gt;
&lt;li&gt;《Spring Boot实战 》&lt;/li&gt;
&lt;li&gt;《SpringCloud参考指南》&lt;/li&gt;
&lt;li&gt;《分布式服务框架原理与实践》&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多书都是看过一些，也做过一些实践，比如学习的SpringBoot和SpringCloud技术知识就来源于这些书籍。 但是因为各种原因最后没有坚持下来-_-||，也比较可惜的，所以这里就只能简单的列举下了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读5本以上国内外有意思的书籍；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年阅读完的书籍有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《人性的弱点》&lt;/li&gt;
&lt;li&gt;《傲慢与偏见》&lt;/li&gt;
&lt;li&gt;《满愿》&lt;/li&gt;
&lt;li&gt;《冰菓》&lt;/li&gt;
&lt;li&gt;《愿你归来，仍是少年》&lt;/li&gt;
&lt;li&gt;《人间失格》&lt;/li&gt;
&lt;li&gt;《别输在不会表达上》&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;《傲慢与偏见》看完此书之后顺便也看了下该电影，总的来情结说在意料之中，有意思一点的是谁傲慢，谁偏见到后面才知晓 罒ω罒。&lt;/p&gt;
&lt;p&gt;《冰菓》 是以前看过的一部叫做《冰菓》的动漫，越看越好看的那种，已经看过很多次了，因此买了一整套小说在看一遍。《满愿》则是该作者写的另一本推理小说，还算比较有意思的一本小说。&lt;/p&gt;
&lt;p&gt;《人间失格》 这本书是大文豪太宰治的最后一本小说，这本书从某种方面来说过于阴暗了，可能会引起不适，因此不怎么推荐去看。从现在来说的话，这本书的主角应该是有重度抑郁症吧。。。&lt;/p&gt;
&lt;p&gt;《愿你归来，仍是少年》 这本书主要思想也就是常说的&lt;code&gt;勿忘初心&lt;/code&gt;，记载的是作者前半生的所见所闻和感想，看完之后略有感触。不过在生活中也发现了一点，越是把&lt;code&gt;勿忘初心&lt;/code&gt;挂在嘴边的，越是忘了初心。。。&lt;/p&gt;
&lt;p&gt;《人性的弱点》 这本书是同事推荐的，看完真的感触很大，可以说在这一年是对我影响最大的一本书了，里面的道理都简单容易理解，建议每个人看一看，或许发现人生又是另一种了。&lt;/p&gt;
&lt;p&gt;《别输在不会表达上》 这本书说得很对，很有道理，但是看完也就看完了，并没有留下什么。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读jdk常用类的源码，能够理解其中的涵义；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;emmmm，这个源码是看过一点，但是没有坚持看下去，现在也忘得差不多。&lt;br/&gt;总得来说，看过但是没啥印象了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;能够熟练掌握3个常用的技术框架；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年熟练掌握了springboot、netty、kafka、zookeeper这些相关的技术框架，基本都可以熟练使用了，也编写了相关博客进行记载，相关的项目进行实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五、六、七条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天；&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动；&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;上述这三条都可以作为保持身体指定的目标，因此放到一起说。&lt;br/&gt;首先是坚持每天一万步，大概就是每天步行7~8公里，这个到目前为止并没达到250天，实际接近200天，至于为什么没有达到，各种原因都有，这里就不找那些借口了。&lt;br/&gt;每月至少一次户外运动，这个也没有每个月都去户外运动，不过还是有一些的。&lt;br/&gt;保持良好的睡眠时间，这个基本达标，目前差不多有300天良好的睡眠了。睡眠真的很重要，良好的睡眠才能开心的工作、学习和娱乐！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八条:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个月坚持写4以上篇博客，这个有很多个月没有达到，不过今年所写的博客已达到40篇了。总得来说，对比去年写的博客，虽然数量要少了不少，但是今年写的博客无论是页面排版还是质量都提升了不少，这也是一个不小的进步了 (*￣︶￣) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181225163027848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于上述这些定制的目标，我做了一个简单的Excel表格进行记录。这个Excel顺便也上传了，有兴趣的话查看的话，地址在这里，&lt;a href=&quot;https://files.cnblogs.com/files/xuwujing/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92.rar&quot;&gt;2018个人计划&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;去年目标总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照去年所定的状态进行评估。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;阅读2本以上的技术相关书籍，并作出相应的实践； -- 超越&lt;/li&gt;
&lt;li&gt;阅读5本以上国内外有意思的书籍； -- 达标&lt;/li&gt;
&lt;li&gt;阅读jdk常用类的源码，能够理解其中的涵义； -- 未达标&lt;/li&gt;
&lt;li&gt;能够熟练掌握3个常用的技术框架； -- 达标&lt;/li&gt;
&lt;li&gt;继续坚持每天一万步，一年中最少要达到250天； -- 未达标&lt;/li&gt;
&lt;li&gt;每月至少一次户外运动； -- 未达标&lt;/li&gt;
&lt;li&gt;每天睡眠时间不低于7小时，不高于9小时，一年至少要达到300天； -- 达标&lt;/li&gt;
&lt;li&gt;每个月坚持写4以上篇博客，一年所写的博客不低于40篇；-- 达标&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;总的来说，达标的是属于刚刚达标的，未达标基本是接近完成目标，但是差一些而已，至于为什么差一些的原因，思前想后，除了加班、天气不好、身体不舒服、重要的事情等等之外，好像就没有其他的了，o(╥﹏╥)o，其实那些都是借口，总结就一个字 &lt;code&gt;懒&lt;/code&gt;而已 。 虽然有一些目标没有达标，但是好在都是是在进行，而不是都没启动，这点还算不错，起码做了。 至于哪一个唯一超越的，大概是因为比较容易达成一些吧。&lt;/p&gt;
&lt;h2 id=&quot;今年事件&quot;&gt;今年事件&lt;/h2&gt;
&lt;p&gt;今年底事件就分为几个模块来说吧。&lt;/p&gt;
&lt;h3 id=&quot;在社区&quot;&gt;在社区&lt;/h3&gt;
&lt;p&gt;主要是在博客园、CSDN、GitHub技术社区这块；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编写了&lt;a href=&quot;https://www.cnblogs.com/xuwujing/category/1145997.html&quot;&gt;SpringBoot&lt;/a&gt;整合系列的博客，并将这些项目放到&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;GitHub&lt;/a&gt;进行了开源；&lt;/li&gt;
&lt;li&gt;完成Java中的&lt;a href=&quot;https://www.cnblogs.com/xuwujing/category/1249313.html&quot;&gt;设计模式系列&lt;/a&gt;博客的编写；&lt;/li&gt;
&lt;li&gt;新建了一个&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;GitHub&lt;/a&gt;仓库，记录自己在学习java中学习到的知识点，也包括之前编写的博客相关代码；&lt;/li&gt;
&lt;li&gt;有不少的博文访问量破万，并且在CSDN取得了博客专家称号；&lt;/li&gt;
&lt;li&gt;在github终于有过百star的项目了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然上面的成绩对于很多大佬来说没什么，但是对于个人来说有很大的鼓励作用，起码写的博文，开源的项目不是没有用，而是能够确切的帮助到一些人的。&lt;/p&gt;
&lt;h3 id=&quot;在公司&quot;&gt;在公司&lt;/h3&gt;
&lt;p&gt;可能因为今年是本命年，所以过年后运气一直都不错 ~_~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运气不错在年会中了一等奖；&lt;/li&gt;
&lt;li&gt;成为了公司的核心员工；&lt;/li&gt;
&lt;li&gt;获得了技术分享奖；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在工作中，成长了许多，除了技术方面外，最大的收获就是人际之间的关系处理以及做事这方面的吧。技术方面因经常分享一些新技术框架、开源工具的使用，因此得到一个技术分享将；做事方面而言可能是因为态度比较好一些，沟通闭环执行比较到位， 做的小事情多一些，不过也可能是因为运气比较好，部门人数较少，所以成为了核心员工(实际貌似没有什么用)。。。&lt;/p&gt;
&lt;h3 id=&quot;个人&quot;&gt;个人&lt;/h3&gt;
&lt;p&gt;坚持做了一些事情，有新增了一些有益于身体的事项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学习了不少新知识，看了一些有趣的书籍；&lt;/li&gt;
&lt;li&gt;去参加计算机软考了，但是很可惜没过；&lt;/li&gt;
&lt;li&gt;因牙疼去拔智齿了，并坚持每年洗牙；&lt;/li&gt;
&lt;li&gt;因眼睛疼，开始佩戴防辐射眼镜(零度数)；&lt;/li&gt;
&lt;li&gt;因脖子和肩膀疼，开始去做推拿了；&lt;/li&gt;
&lt;li&gt;因手指疼，开始有意识锻炼手指了；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人方面，和去年相比，在技术方面提升了不少。但是身体却不如去年了，明明在锻炼，在注意身体，但是感觉身体的确是一年不如一年。去年基本没有上述问题，但是在今年下半年尤为明显，明显的感觉到身体素质下降了，各种身体问题接踵而出。因此需要加强身体的锻炼，多运动，少久坐，多吃蔬菜水果，少吃酸辣刺激食物 ，保持良好睡眠，少熬夜 。。。 当然最重要的是少加班，只要少加班或不加班，那么上述的身体问题或许不会存在吧！&lt;/p&gt;
&lt;h2 id=&quot;明年目标&quot;&gt;明年目标&lt;/h2&gt;
&lt;p&gt;回过神来，发现一年就这么过了。虽然在2018年中国甚至全世界都发生了很多重大的事件，但是对个人来说，并没有特别留下深刻印象的东西，可能因为圈子太窄，对外接触较少吧...&lt;/p&gt;
&lt;p&gt;明天的目标，应该算是今年的目标吧。如果按照去年的我制定目标的话，可能就是以下的这些了:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每几小时坚持远眺和活动手指;&lt;/li&gt;
&lt;li&gt;每天坚持运动锻炼身体;&lt;/li&gt;
&lt;li&gt;每周坚持去电影院看一场电影;&lt;/li&gt;
&lt;li&gt;每周坚持写一篇博客；&lt;/li&gt;
&lt;li&gt;每月坚持去做推拿保护颈椎和脖子;&lt;/li&gt;
&lt;li&gt;每月坚持户外运动；&lt;/li&gt;
&lt;li&gt;每年坚持一次洗牙保护牙齿;&lt;/li&gt;
&lt;li&gt;每年坚持写年度总结；&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是今年的我并不想这么做了，经历过一些事情之后，还是觉得活得简单开心就好。所以今年的我只想希望明年的自己完成这几个目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;活得开心，开心最重要；&lt;/li&gt;
&lt;li&gt;喜欢做某件事情；&lt;/li&gt;
&lt;li&gt;喜欢一个人；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现实是如此残酷，人生又如此短暂，何不活的开心一点呢？&lt;br/&gt;找到一个自己真正想做的事情，只要不触犯法律道德底线，那么就去做吧。&lt;br/&gt;找到一个喜欢的人，无论是现实的，还是非现实的。&lt;/p&gt;
&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2018年，真的算是比较有意思的一年。在这一年中学会了太多，同时也失去了太多，可能有所得就必有所失吧。在这一年中，学会了在社会中如何合群，学会了控制自己的情绪，学会了在公司如何做&lt;strong&gt;一个领导放心、同事舒心的好人&lt;/strong&gt;，学会了职业性的微笑，学会习惯性的谎言 。。。 总之就是学会了很多技巧。但是学会这些的同时，自己也失去了很多，失去了一部分的自律生活，失去了一些健康的生活，失去了内心感动，失去了发至内心的笑容，失去了一部分的真诚... 失去了不少东西，可能再也不会回来，但是我还是希望以后的自己能够把找回来 ^_^&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写到这里差不多该写的都写了， 本篇博文主要的目的还是让自己有个清晰的认识，并且好对未来做些规划。今年收获了很多的感悟，其中发现高中自己写的日记中的一条感悟非常有意思，也算做今年的感悟吧！&lt;br/&gt;今年的感悟如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;活着是为了更好的活着而活着！&lt;/li&gt;
&lt;li&gt;对生活的不满的原因无在乎是想得太多，做的太少。&lt;/li&gt;
&lt;li&gt;当你觉得迷茫困惑的时候，放下手中的一切，出门去走走，散散心，听听纯音乐，发下呆，或许就不在困惑了&lt;/li&gt;
&lt;li&gt;种一颗树最好的时间是过去，其次是现在，最次的是未来，所以有什么想做的事情最好立马去做。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;其实本篇文章在之前写过，但是感觉写的不太好，就删除进行重写了...&lt;/p&gt;
&lt;p&gt;本文的标题想法来自以前看到的一篇文章，该篇文章如下:&lt;/p&gt;
&lt;blockquote readability=&quot;85&quot;&gt;
&lt;p&gt;我们可以平凡,但绝不可以平庸.&lt;br/&gt;平凡与平庸,既有共性,也有不同.共性在于两者都含有平平常常、普普通通的意思,都没有轰轰烈烈、惊天动地的壮举,也没有卓著功勋、叱咤风云的伟业和气势.不同在于,平凡是中性概念,指人有一颗平常心,在普通岗位兢兢业业、任劳任怨地工作和生活.平庸则带有贬意,消极颓废、没有追求,无所事事、碌碌无为,随波逐流、自暴自弃,生活得没有个性、没有张力、没有特色.&lt;br/&gt;平凡是人生的常态.大千世界,芸芸众生,成就非凡、出类拔萃、彪柄史册的人是少数,大奸大恶、民怨沸腾、遗臭万年的人也是少数.绝大多数人岗位平凡,角色普通,生活平淡,每天开门面对柴米油盐酱醋茶几件事,考学、升职、买房、找工作……与左邻右舍的人一样,有着接踵而至的忧愁烦恼,每天要感受百姓人生的喜怒哀乐.&lt;br/&gt;平凡不等于平淡.平凡人不一定有惊涛骇浪的壮举,却完全可以在平凡的岗位上,凭着一颗平凡却不平淡的心,珍惜光阴,执着追求,矢志不渝,朝着理想的方向奔跑,&quot;秀&quot;出自己的精彩.全国劳动模范徐虎,没想成名成家,也没想出人头地,平时的工作就是钻下水道、通排粪管、修水龙头,一干就是30年,默默地为社会作奉献,看似平凡的人生,却蕴涵着熠熠光华.&lt;br/&gt;平凡更不是平庸.平凡的人,可以无过人之才,可以默默无闻,但不能不知道为什么而活,不能没有理想与追求,不能消极悲观、无所作为.生活平凡,成就一般,永远不能成为浑浑噩噩、碌碌无为的理由和借口.平凡的人应是一块铺路石,个头虽小却双肩负重；平凡的人还应是一颗螺丝钉,毫不起眼却时刻发挥作用.&lt;br/&gt;平凡不平庸,必须坚定理想与追求.人生有了理想与追求,就有前进方向和力量.如果没有理想,精神空虚,人生会得过且过；如果有理想而不去追求,到头来仍是一无所获.人生十分短暂,只有目标明确、珍惜光阴,才能有所收获,赢得主动；只有执着上进、不懈求索,才能扬起前行的风帆,缩短现实与理想的距离.&lt;br/&gt;平凡不平庸,必须脚踏实地,尽力而为.远离平庸,不是喊在嘴上、贴在墙上的口号.人生平凡,并不妨碍自己在平凡的岗位上,对别人、对企业、对国家有所帮助、有所裨益、有所贡献.如果人生一无是处、毫无价值,不仅在平庸的泥淖中越陷越深,最终会成为社会、企业和别人的包袱.惟有脚踏实地,积极进取,做出实实在在的成绩,有所建树,方能平凡之中升华修养、彰显品格、实现价值.&lt;br/&gt;平凡不平庸,必须拒绝懒惰与懈怠、拒绝浅薄与浮躁,培养积极平和健康的心态.没有人注定平凡,也没有人一生卓越,不同的只是面对生活的态度.积极的态度,就要拥抱勤劳和坚韧,拒绝懒惰与懈怠；就要拥抱敦厚和务实,拒绝浅薄与浮燥；就要拥抱本色自我和独立人格,拒绝朝三暮四与随波逐流.心态积极平和健康,真诚对待每一个人,努力做好每一件事,就能身处平凡而超越平凡,让生活洒满灿烂阳光.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;这首音乐是以前看过的一部动漫，也可能是我感触最深的一部动漫。&lt;/p&gt;
&lt;p&gt;写作CLANNAD，译作经典，读作人生。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 又到了一年一度的年终总结了，相信大家估计也开始写总结，本人也不例外。在公司中写完模板化的总结之后，自己还是写了一个给自己的总结。本篇总结主要是讲述去年所定下目标的完成情况和人生感悟以及明年的目标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10211265.html</dc:identifier>
</item>
<item>
<title>python爬虫之反爬虫（随机user-agent，获取代理ip，检测代理ip可用性） - -零</title>
<link>http://www.cnblogs.com/-wenli/p/10211942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-wenli/p/10211942.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
随机User-Agent

获取代理ip

检测代理ip可用性
&lt;/pre&gt;&lt;/div&gt;






&lt;p&gt;&lt;strong&gt;&lt;strong&gt;fake_useragent库，伪装请求头&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
from fake_useragent import UserAgent

ua = UserAgent()
# ie浏览器的user agent
print(ua.ie)

# opera浏览器
print(ua.opera)

# chrome浏览器
print(ua.chrome)

# firefox浏览器
print(ua.firefox)

# safri浏览器
print(ua.safari)

# 最常用的方式
# 写爬虫最实用的是可以随意变换headers，一定要有随机性。支持随机生成请求头
print(ua.random)
print(ua.random)
print(ua.random)
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;strong&gt;在免费的代理网站爬取代理ip，免费代理的采集也很简单，无非就是：访问页面页面 —&amp;gt; 正则/xpath提取 —&amp;gt; 保存&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
代理ip网站
有代理：https://www.youdaili.net/Daili/guonei/
66代理：http://www.66ip.cn/6.html
西刺代理：https://www.xicidaili.com/
快代理：https://www.kuaidaili.com/free/
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#根据网页结果，适用正则表达式匹配
#这种方法适合翻页的网页
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
import re
import requests
import  time

def get_ip():
    url='https://www.kuaidaili.com/free/inha/'
    url_list=[url+str(i+1) for i in range(5)] #生成url列表，5代表只爬取5页
    print(url_list)
    ip_list = []
    for i in range(len(url_list)):
        url =url_list[i]
        html = requests.get(url=url,).text
        regip = '&amp;lt;td.*?&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})&amp;lt;/td&amp;gt;.*?&amp;lt;td.*?&amp;gt;(\d{1,5})&amp;lt;/td&amp;gt;'
        matcher = re.compile(regip,re.S)
        ipstr = re.findall(matcher, html)
        time.sleep(1)

        for j in ipstr:
            ip_list.append(j[0]+':'+j[1])  #ip+port
    print(ip_list)
    print('共收集到%d个代理ip' % len(ip_list))
    return ip_list
if __name__=='__main__':
    get_ip()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201901/1477786-20190102225909321-1927544505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
#先获取特定标签
#解析
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
import requests
from bs4 import BeautifulSoup
def get_ip_list(obj):
    ip_text = obj.findAll('tr', {'class': 'odd'})   # 获取带有IP地址的表格的所有行
    ip_list = []
    for i in range(len(ip_text)):
        ip_tag = ip_text[i].findAll('td')   
        ip_port = ip_tag[1].get_text() + ':' + ip_tag[2].get_text() # 提取出IP地址和端口号
        ip_list.append(ip_port)
    print(&quot;共收集到了{}个代理IP&quot;.format(len(ip_list)))
    print(ip_list)
    return ip_list
url = 'http://www.xicidaili.com/'
headers = {
    'User-Agent': 'User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36'}
request = requests.get(url, headers=headers)
response =request.text
bsObj = BeautifulSoup(response, 'lxml')     # 解析获取到的html
lists=get_ip_list(bsObj)
&lt;/pre&gt;&lt;/div&gt;






&lt;p&gt;第一种方法：通过返回的状态码判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
import requests
import random
import re
import time



def get_ip():
    url='https://www.kuaidaili.com/free/inha/'
    url_list=[url+str(i+1) for i in range(1)]
    print(url_list)
    ip_list = []
    for i in range(len(url_list)):
        url =url_list[i]
        html = requests.get(url=url,).text
        regip = '&amp;lt;td.*?&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})&amp;lt;/td&amp;gt;.*?&amp;lt;td.*?&amp;gt;(\d{1,5})&amp;lt;/td&amp;gt;'
        matcher = re.compile(regip,re.S)
        ipstr = re.findall(matcher, html)
        time.sleep(1)

        for j in ipstr:
            ip_list.append(j[0]+':'+j[1])
    print('共收集到%d个代理ip' % len(ip_list))
    print(ip_list)
    return ip_list
def valVer(proxys):
    badNum = 0
    goodNum = 0
    good=[]
    for proxy in proxys:
        try:
            proxy_host = proxy
            protocol = 'https' if 'https' in proxy_host else 'http'
            proxies = {protocol: proxy_host}
            print('现在正在测试的IP：',proxies)
            response = requests.get('http://www.baidu.com', proxies=proxies, timeout=2)
            if response.status_code != 200:
                badNum += 1
                print (proxy_host, 'bad proxy')
            else:
                goodNum += 1
                good.append(proxies)
                print (proxy_host, 'success proxy')
        except Exception as e:
            print( e)
            # print proxy_host, 'bad proxy'
            badNum += 1
            continue
    print ('success proxy num : ', goodNum)
    print( 'bad proxy num : ', badNum)
    print(good)

if __name__ == '__main__':
    ip_list=get_ip()
    valVer(ip_list)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201901/1477786-20190102233401134-1461738707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;第二种方法：使用requests包来进行验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
import requests
import random
import re
import time



def get_ip():
    url='https://www.kuaidaili.com/free/inha/'
    url_list=[url+str(i+1) for i in range(1)]
    print(url_list)
    ip_list = []
    for i in range(len(url_list)):
        url =url_list[i]
        html = requests.get(url=url,).text
        regip = '&amp;lt;td.*?&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})&amp;lt;/td&amp;gt;.*?&amp;lt;td.*?&amp;gt;(\d{1,5})&amp;lt;/td&amp;gt;'
        matcher = re.compile(regip,re.S)
        ipstr = re.findall(matcher, html)
        time.sleep(1)

        for j in ipstr:
            ip_list.append(j[0]+':'+j[1])
    print(ip_list)
    print('共收集到%d个代理ip' % len(ip_list))
    return ip_list
def valVer(proxys):
    badNum = 0
    goodNum = 0
    good=[]
    for proxy in proxys:
        print(&quot;现在正在检测ip&quot;,proxy)
        try:
            requests.get('http://wenshu.court.gov.cn/', proxies={&quot;http&quot;:&quot;http://&quot;+str(proxy)}, timeout=2)
        except:
            badNum+=1
            print('connect failed')
        else:
            goodNum=1
            good.append(proxy)
            print('success')

    print ('success proxy num : ', goodNum)
    print( 'bad proxy num : ', badNum)
    print(good)

if __name__ == '__main__':
    ip_list=get_ip()
    valVer(ip_list)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477786/201901/1477786-20190102232557215-741843662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;第三种方法：使用telnet&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
import telnetlib


try:

    telnetlib.Telnet('127.0.0.1', port='80', timeout=20)

except:

    print 'connect failed'

else:
    
    print 'success'
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 02 Jan 2019 15:36:00 +0000</pubDate>
<dc:creator>-零</dc:creator>
<og:description>python爬虫之反爬虫（随机user-agent，获取代理ip，检测代理ip可用性） 目录 随机User-Agent fake_useragent库，伪装请求头 获取代理ip 在免费的代理网站爬取代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-wenli/p/10211942.html</dc:identifier>
</item>
<item>
<title>2018年终总结——越过山丘 - 吕大豹</title>
<link>http://www.cnblogs.com/lvdabao/p/10211898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvdabao/p/10211898.html</guid>
<description>&lt;p&gt;又到了年终总结的时候了，每年花一点时间好好回顾下，看看收获与不足，然后在下一年里继续马不停蹄，人总要前进的嘛。&lt;/p&gt;
&lt;p&gt;今年也是并不轻松的一年啊，整个互联网行业都过得不容易。到年底了还传出各家裁员的消息，码农的处境真是前途堪忧。从宏观上看，是全球经济进入一个下行周期，哪个行业都会受影响，覆巢之下焉有完卵。&lt;/p&gt;
&lt;p&gt;这也促使我们进行更多的思考，今年我毕业满五年了，也已经是老码农队伍的一员。在未来的职业生涯中，要靠什么核心竞争力来维持自己的薪资呢？这是一个很现实的问题，毕竟跟年轻力壮的年轻人比起来，自己的精力明显不够了。据说有大厂招人已经不看五年以上工作经验的简历了，这就是形势，覆巢之下的形势。这种颓势应该会持续几年，所以我们必须得想明白这个问题了。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;工作&lt;/h3&gt;
&lt;p&gt;今年我换工作了，入了美团。自己都有点意外，从有想法到辞职、面试、入职，前后也就一个月吧。&lt;/p&gt;
&lt;p&gt;之前在创业型公司，呆了将近三年，今年也走到E轮了。我一直会觉得自己会跟公司走到最后。但命运就是这么奇怪，今年年初的时候我突然感觉自己处于比较危险的状态，技术深度上没有提升，工作上带着几个组员做没有挑战的业务。有点安逸的等待公司上市那一天。&lt;/p&gt;
&lt;p&gt;一位前辈敲醒了我，他问我，你们公司上市后你就不敲代码了吗？不工作了吗？想想自己想要的是什么。我遂下决心逃离舒适区。去向也没想太多，还是去大厂深化一下自己的技术实力吧，感觉这两年有点脱节。&lt;/p&gt;
&lt;p&gt;年初美团打车是很风光的，媒体各种报道，我也就抱着很向往的态度过去了。面试的过程还是有点曲折的，毕竟自己也两三年没再被面试过了，最大的感受就是，行业对工作五年的工程师要求是比较高的。工作两三年的码农是最好找工作的，性价比高，公司爱要。五年的就要精挑细选了，毕竟要的薪资高，干活也不那么麻利了。这也给各位老码农提个醒，技术的道路上不能停下学习的脚步。&lt;/p&gt;
&lt;p&gt;到了新团队还是有一段时间的适应期的。自己也切实感受到了压力，真的有一帮优秀的年轻人，技术好，干劲强。自己一点不敢怠慢，该学学，该加班加班，确实是逃离舒适区的感觉，心理和身体上都有一定程度的压力。现在入职半年多了，我也不敢松口气，强迫自己多研究东西，提高执行力，提高工作效率。虽然累一些，但感觉自己的内心是接受的，是无愧的。&lt;/p&gt;
&lt;h3 id=&quot;生活&quot;&gt;生活&lt;/h3&gt;
&lt;p&gt;今年在生活上也发生了一件大事，在北京买房了。对于一个北漂来讲这可能是终极梦想了。对于买房这件事，我和媳妇意见很统一，要干就一口气干到彻底的，不要犹犹豫豫。&lt;/p&gt;
&lt;p&gt;于是从四月份开始，陆陆续续看房。然后马不停蹄的走流程、交房、装修、搬家。花光了所有积蓄，终于在一个月前搬进了新家。总算是在北京安家了。&lt;/p&gt;
&lt;p&gt;买房真是个苦力活，前后六个多月，几乎每个周末都在外面跑，各种细碎的事情太多了。导致这半年上班都很疲惫，业余时间也不能再搞点别的输出了，所以今年微信公众号算是正式停笔了，博客也没写，文章产出为零。生活的其他方面也没什么可总结的，都被买房装修挤占了。&lt;/p&gt;
&lt;p&gt;好在生活终于恢复平静，我可以好好筹划下个阶段的事情了。嘚瑟一下晒晒房子吧~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/520134/201901/520134-20190102231632370-1112932341.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读书写作&quot;&gt;读书写作&lt;/h3&gt;
&lt;p&gt;到这里我真是惭愧的不知写什么了。&lt;/p&gt;
&lt;p&gt;上面也提到了，今年的业余时间基本为零，再加上整个人处于比较浮躁的状态，读书写作基本都是负向的总结。&lt;/p&gt;
&lt;p&gt;往年基本能读个十本左右的书，相比之下今年就太少了。东野圭吾的读了两本：《拉普拉斯的魔女》、《新参者》。看完对东野的膜拜也降温了一些些，看来大师的作品也还是经典的好看。&lt;/p&gt;
&lt;p&gt;经济学相关：《牛奶可乐经济学》读了一半，技术类：《JavaScript设计模式与开发实践》读了一半。浮躁啊浮躁，一本书都读不完了。&lt;/p&gt;
&lt;p&gt;前几天朋友送了本《高效能人士的七个习惯》，经典中的经典，感觉很适合现在的我。刚刚开始看，决定深入阅读和实践。&lt;/p&gt;
&lt;p&gt;关于写作上面也提到了，零，没有。&lt;/p&gt;
&lt;p&gt;今年基本都在知识星球进行碎碎谈了，各种零碎的技术生活相关内容，一点点积累。前些天看了下生成的年度总结，我发表了46000多字，自己都有点吃惊。因为感觉今年输出的内容太少了，看来积累了力量真是不容忽视啊！&lt;/p&gt;
&lt;h3 id=&quot;技术认知&quot;&gt;技术认知&lt;/h3&gt;
&lt;p&gt;技术人的年终总结，总得谈谈技术。我用“技术认知”这个小标题，也代表了今年在技术领域的成长。&lt;/p&gt;
&lt;p&gt;翻去年的年终总结，提到今年要学react，要玩一些新技术新框架。但其实都没实现。今年在技术上确实没什么实质提升，作为技术人还是有点慌的。&lt;/p&gt;
&lt;p&gt;但我现在也不是太慌，因为我对技术的认知有了一次提升，这在我看来是十分珍贵的。&lt;/p&gt;
&lt;p&gt;第一个认知是：不要着眼于使用技术，而是着眼于完成某项任务。听起来像是一句没用的废话，认知提升这件事情，自己内心悟到了就感觉特别深刻，而在别人看来往往是没用的鸡汤。这个感悟可以认为是对全栈的一些诠释，我个人觉得它包含的内容比全栈还丰富一些。你首先是一个工程师，其次才是前端工程师，编程不应自我划限。&lt;/p&gt;
&lt;p&gt;第二个认知是：一切都是代码。这是从我的leader身上学到的。具体来讲，我们现在用的最多的webpack、vue、react这些框架，不要认为它就是固定不变的框架，也不要不敢去修改它。要有一种敢于解剖所有框架的勇气，乃至自己实现一个的勇气。&lt;/p&gt;
&lt;p&gt;我个人觉得，这两条认知加起来，足以给我指明下一个前进方向了。&lt;/p&gt;
&lt;p&gt;最后再发一下今年比较流行的这张图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/520134/201901/520134-20190102231653078-980885286.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我认真反思了现在的状态，得出的结论是：自己处于绝望之谷附近。这真不是谦虚，在我看来今年最大的成长就是认识到了自己的无知，当然，具备客观评判自我的能力也是十分重要的。再说一个感受，认识到自己处于绝望之谷后，我竟然特别渴望鸡汤，不论是公司的所谓洗脑价值观，还是某大V的心灵鸡汤，只要是自己评判为有价值的内容，通通输入。告别对鸡汤的蔑视，或许是从愚昧山峰开始往下走的开始。&lt;/p&gt;
&lt;h3 id=&quot;新年计划&quot;&gt;新年计划&lt;/h3&gt;
&lt;p&gt;2019年工作和生活又进入一个恒纪元，可以做些计划了。&lt;/p&gt;
&lt;p&gt;首先是工作，技术深度和技术产出上加大投入，搞几个能拿得出手的作品。就以得到晋升为目标吧。&lt;/p&gt;
&lt;p&gt;读书和写作是可以好好规划了，新的一年做到踏实+勤奋，多读书，写作方面的话，还是聚焦技术吧，不在微信公众号写鸡汤了，聚焦技术博客吧。&lt;/p&gt;
&lt;p&gt;生活的话，至少得有一次旅行吧。另外家里催着要孩子了，尽管对于这事我还未做好准备。。。&lt;/p&gt;
&lt;p&gt;大概就这些吧，回首一下今年，的变动还是挺大的，对于自己的人生也是一个关键节点，越过这个山丘，还有无数山丘，加油2019！&lt;/p&gt;
</description>
<pubDate>Wed, 02 Jan 2019 15:19:00 +0000</pubDate>
<dc:creator>吕大豹</dc:creator>
<og:description>又到了年终总结的时候了，每年花一点时间好好回顾下，看看收获与不足，然后在下一年里继续马不停蹄，人总要前进的嘛。 今年也是并不轻松的一年啊，整个互联网行业都过得不容易。到年底了还传出各家裁员的消息，码农</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvdabao/p/10211898.html</dc:identifier>
</item>
<item>
<title>机器学习笔记  多项式回归 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10196767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10196767.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/10186516.html&quot; target=&quot;_blank&quot;&gt;上一篇机器学习笔记&lt;/a&gt;里,我们讲了线性回归.线性回归有一个前提：即我们假设数据是存在线性关系的. 然而,理想很丰满,现实很骨感,现实世界里的真实数据往往是非线性的.&lt;/p&gt;
&lt;p&gt;比如你的数据分布,是符合y=0.5$x^2$ + x + 2的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181229160049252-1236980305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那你用y=ax+b去拟合,无论如何都没法取的很好的效果.&lt;/p&gt;
&lt;p&gt;这时候,我们又想继续用上一篇笔记描述的线性回归来解决这个问题,我们要怎么办呢？一个很直观的想法就是,我们想造出一个新的特征$x^2$。那么现在我们拥有了2个特征x,$x^2$，我们就可以把问题转换为求解y=a$x^2$ + bx +c，从而把问题转换成我们熟悉的线性回归问题.&lt;/p&gt;

&lt;p&gt;通过上面的分析,我们可以看出,我们想做的事情是对样本做升维(即增加样本的特征数目),sklean中完成这一功能的类叫做&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html#sklearn.preprocessing.PolynomialFeatures&quot; target=&quot;_blank&quot;&gt;PolynomialFeatures&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;em class=&quot;property&quot;&gt;class &lt;/em&gt;&lt;code class=&quot;descclassname&quot;&gt;sklearn.preprocessing.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;PolynomialFeatures&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;degree=2&lt;/em&gt;, &lt;em&gt;interaction_only=False&lt;/em&gt;, &lt;em&gt;include_bias=True&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;degree&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;integer&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;The degree of the polynomial features. Default = 2.&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;&lt;strong&gt;interaction_only&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;boolean, default = False&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;If true, only interaction features are produced: features that are products of at most &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;degree&lt;/span&gt;&lt;/code&gt;&lt;em&gt;distinct&lt;/em&gt; input features (so not &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;x[1] &lt;span class=&quot;pre&quot;&gt;** &lt;span class=&quot;pre&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;x[0] &lt;span class=&quot;pre&quot;&gt;* &lt;span class=&quot;pre&quot;&gt;x[2] &lt;span class=&quot;pre&quot;&gt;** &lt;span class=&quot;pre&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;&lt;strong&gt;include_bias&lt;/strong&gt; &lt;span class=&quot;classifier-delimiter&quot;&gt;: &lt;span class=&quot;classifier&quot;&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;first last&quot;&gt;If True (default), then include a bias column, the feature in which all polynomial powers are zero (i.e. a column of ones - acts as an intercept term in a linear model).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设你的样本,原本有两个特征[a,b],那么当你进行一次degree=2的升维之后,你将得到5个特征[1,a,b,$a^2$,ab,$b^2$]，其中1又可以看做是$a^0或者b^0$。&lt;/p&gt;
&lt;p&gt;关于degree的理解你可以参考一下下面这个例子.&lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt; &lt;span&gt;PolynomialFeatures&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;x&lt;/span&gt;=pd.DataFrame({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;col1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [2], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;col2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [3],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;col3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[4&lt;span&gt;]})
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
poly2 &lt;/span&gt;= PolynomialFeatures(degree=2&lt;span&gt;)
poly2.fit_transform(x)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; array([[ 1.,  2.,  3.,  4.,  4.,  6.,  8.,  9., 12., 16&lt;span&gt;.]])

poly3 &lt;/span&gt;= PolynomialFeatures(degree=3&lt;span&gt;)
poly3.fit_transform(x)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; array([[ 1.,  2.,  3.,  4.,  4.,  6.,  8.,  9., 12., 16.,  8., 12., 16&lt;span&gt;.,
        &lt;/span&gt;18., 24., 32., 27., 36., 48., 64.]])
&lt;/pre&gt;
&lt;p&gt;  poly4 = PolynomialFeatures(degree=3,interaction_only=True)&lt;br/&gt;  poly4.fit_transform(x)&lt;/p&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;em id=&quot;__mceDel&quot;&gt;array([[ 1.,  2.,  3.,  4.,  6.,  8., 12., 24.]])&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的样本有3个特征,值分别为2,3,4,degree=2时,可能的取值有$2^0$,$3^0$,$4^0$(均为1),$2^1,2^2,3^1,3^2,4^1,4^2$,$2*3,2*4,3*4$共10个值.&lt;/p&gt;
&lt;p&gt;degree为3时,又新增了$2^3,3^3,4^3$，$2^2*3,2^2*4,3^2*2,3^2*4,4^2*2,4^2*3,2*3*4$共10个.总计20个.&lt;/p&gt;
&lt;p&gt;interaction_only=true时,表示新增的特征存在交互性,不存在自己*自己,比如[2,3,4]的交互式输出是[2*3,2*4,3*4,2*3*4].&lt;/p&gt;
&lt;p&gt;从上面的分析可以看出来,&lt;span&gt;随着degree的增加,PolynomialFeatures新生成的特征数目是呈指数级别增加的.这将带来模型训练速度的严重下降和模型的过拟合&lt;/span&gt;,所以实际上一般很少用多项式回归.&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;来个具体的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np  
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PolynomialFeatures

x &lt;/span&gt;= np.random.uniform(-3, 3, size=100&lt;span&gt;)
X &lt;/span&gt;= x.reshape(-1, 1&lt;span&gt;)
y &lt;/span&gt;= 0.5 * x**2 + x + 2 + np.random.normal(0, 1, 100&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;升维,为样本生成新的特征&lt;/span&gt;
poly = PolynomialFeatures(degree=2&lt;span&gt;)
poly.fit(X)
X2 &lt;/span&gt;=&lt;span&gt; poly.transform(X)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对新样本做训练&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LinearRegression
lin_reg2 &lt;/span&gt;=&lt;span&gt; LinearRegression()
lin_reg2.fit(X2, y)
y_predict2 &lt;/span&gt;=&lt;span&gt; lin_reg2.predict(X2)

plt.scatter(x, y)
plt.plot(np.sort(x), y_predict2[np.argsort(x)], color&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201812/583030-20181229163409926-333388435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 02 Jan 2019 15:09:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>上一篇机器学习笔记里,我们讲了线性回归.线性回归有一个前提：即我们假设数据是存在线性关系的. 然而,理想很丰满,现实很骨感,现实世界里的真实数据往往是非线性的. 比如你的数据分布,是符合y=0.5$x</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdu20112013/p/10196767.html</dc:identifier>
</item>
<item>
<title>asp.net core mcroservices 架构之 分布式日志（三）：集成kafka - 无为有道</title>
<link>http://www.cnblogs.com/ck0074451665/p/10211725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10211725.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;一 kafka介绍                               &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &lt;span&gt;kafka是基于zookeeper的一个分布式流平台，既然是流，那么大家都能猜到它的存储结构基本上就是线性的了。硬盘大家都知道读写非常的慢，那是因为在随机情况下，线性下，硬盘的读写非常快。kafka官方文档，一直拿传统的消息队列来和kafka对比，这样大家会触类旁通更快了解kafka的特性。最熟悉的消息队列框架有&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;ActiveMQ&lt;/a&gt; 和 &lt;a href=&quot;https://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt;.熟悉消息队列的，最熟悉的特性就是队列和发布订阅功能，因为这是大家最常用的，kafka实现了一些特有的机制，去规避传统的消息队列的一些瓶颈，比如并发，rabbitMQ在多个处理程序下，并不能保证执行顺序，还是必须自己去处理独占，而kafka使用consumer group的方式，实现了可以多个处理程序处理一个topic下的记录。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222905748-958399901.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222906453-1910197267.png&quot; alt=&quot;image&quot; width=&quot;505&quot; height=&quot;242&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个分区的记录保证能被每个组接受，这样可以并发去处理一个topic的记录，而且扩展组，则可以随意根据应用需求去扩展你的应用程序，但是每个组的消费者不能超过分区的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kafka &lt;a href=&quot;http://kafka.apache.org/documentation/#intro_distribution&quot;&gt;Distribution&lt;/a&gt; 提供了容错的功能，每一个partition都有一个服务器叫leader，还有零个或者一个以上的服务器叫follower，当这些follower都在同步数据的时候，leader扛起所有的写和读，当leader挂掉，follower会随机选取一个服务器当leader，当然必须有几个follower同步时 in-sync的。还有kafka虽然的那个记录具有原子性，但是并不支持事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为这一篇并不是专门讲解kafka，所以点到为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;&lt;span&gt;二&lt;/span&gt; &lt;span&gt;    扩展服务 开发                          &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     以前讲过，netcore的一个很重要的特性就是支持依赖注入，在这里一切皆服务。那么如果需要kafka作为日志服务的终端，就首先需要kafka服务，下面咱们就开发一个kafka服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，服务就是需要构建,这是netcore开发服务的第一步,我们首先建立一个IKafkaBuilder.cs接口类，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;homusing&lt;/span&gt; Microsoft.Extensions.DependencyInjection;

&lt;span&gt;namespace&lt;/span&gt; Walt.Freamwork.Service
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IKafkaBuilder
    {
         &lt;span&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;/// Gets the &amp;lt;see cref=&quot;IServiceCollection&quot;/&amp;gt; where Logging services are configured.&lt;/span&gt;
        &lt;span&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
        IServiceCollection Services { &lt;span&gt;get&lt;/span&gt;; }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再实现它,KafkaBuilder.cs&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; Microsoft.Extensions.DependencyInjection;

&lt;span&gt;namespace&lt;/span&gt; Walt.Freamwork.Service
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; KafkaBuilder : IKafkaBuilder
    {
        &lt;span&gt;public&lt;/span&gt; IServiceCollection Services {&lt;span&gt;get&lt;/span&gt;;}

        &lt;span&gt;public&lt;/span&gt; KafkaBuilder(IServiceCollection services)
        {
            Services=services;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再利用扩展方法为serviceCollection类加上扩展方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Service.Kafka;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.Framework.Service
{
  
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceCollectionExtensions
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Adds logging services to the specified &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt; to add services to.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IServiceCollection&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; so that additional calls can be chained.&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddKafka(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; AddKafka(services, builder =&amp;gt;&lt;span&gt; { });
        }
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddKafka(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services
        , Action&lt;/span&gt;&amp;lt;IKafkaBuilder&amp;gt;&lt;span&gt; configure)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
            }

            services.AddOptions(); 
            configure(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaBuilder(services));
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IKafkaService,KafkaService&amp;gt;&lt;span&gt;();  &lt;span&gt;//kafka的服务类
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;            return&lt;/span&gt;&lt;span&gt; services;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
KafkaService的实现：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Confluent.Kafka;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  Walt.Framework.Service.Kafka
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KafkaService : IKafkaService
    {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; KafkaOptions _kafkaOptions;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Producer _producer;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; KafkaService(IOptionsMonitor&amp;lt;KafkaOptions&amp;gt;&lt;span&gt;  kafkaOptions)
        {
            _kafkaOptions&lt;/span&gt;=&lt;span&gt;kafkaOptions.CurrentValue; 
            kafkaOptions.OnChange((kafkaOpt,s)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
                _kafkaOptions&lt;/span&gt;=&lt;span&gt;kafkaOpt; 
                    System.Diagnostics.Debug
                    .WriteLine(Newtonsoft.Json.JsonConvert.SerializeObject(kafkaOpt)&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;s);
                    
            });
             _producer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(_kafkaOptions.Properties);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ConvertToByte(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.Text.Encoding.Default.GetBytes(str);
        }
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Message&amp;gt; Producer(&lt;span&gt;string&lt;/span&gt; topic,&lt;span&gt;string&lt;/span&gt; key,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(topic)
            &lt;/span&gt;||&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(value))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topic或者value不能为null.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
      
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task=  &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _producer.ProduceAsync(topic,ConvertToByte(key),ConvertToByte(value)); 
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; task;
        }
 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;那么咱们是不是忘记什么了，看上面的代码，是不是那个配置类KafkaOptions 还没有说明&lt;span&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222907427-914024122.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222908135-841502752.png&quot; alt=&quot;image&quot; width=&quot;241&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;这个位置添加kafka的配置类KafkaConfigurationOptions&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; Microsoft.Extensions.Configuration;
&lt;span&gt;using&lt;/span&gt; Microsoft.Extensions.Options;
&lt;span&gt;using&lt;/span&gt; Walt.Freamwork.Service;

&lt;span&gt;namespace&lt;/span&gt; Walt.Freamwork.Configuration
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; KafkaConfigurationOptions : IConfigureOptions&amp;lt;KafkaOptions&amp;gt;
    {

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IConfiguration _configuration;


        &lt;span&gt;public&lt;/span&gt; KafkaConfigurationOptions(IConfiguration configuration)
        {
           _configuration=configuration;
        }


        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(KafkaOptions options)
        {
                //这里仅仅自定义一些你自己的代码，使用上面configuration配置中的配置节，处理程序没法自动绑定的
&lt;/pre&gt;
&lt;pre&gt;
                  一些事情。
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，将配置类添加进服务:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection.Extensions;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Service;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.Framework.Configuration
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KafkaConfigurationExtensioncs
    {
          &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IKafkaBuilder AddConfiguration(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IKafkaBuilder builder
          ,IConfiguration configuration)
          {
               
                InitService( builder,configuration); 
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
          }


          &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitService(IKafkaBuilder builder,IConfiguration configuration)
          {
            builder.Services.TryAddSingleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;KafkaOptions&amp;gt;&amp;gt;&lt;span&gt;(
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaConfigurationOptions(configuration));  /&lt;span&gt;/配置类和配置内容
&lt;/span&gt;
            builder.Services.TryAddSingleton
            (ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;KafkaOptions&amp;gt;&amp;gt;&lt;span&gt;(
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ConfigurationChangeTokenSource&amp;lt;KafkaOptions&amp;gt;&lt;span&gt;(configuration)) );&lt;span&gt;//这个是观察类，如果更改，会激发onchange方法&lt;/span&gt;

            builder.Services
            .TryAddEnumerable(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;KafkaOptions&amp;gt;&amp;gt;&lt;span&gt;
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ConfigureFromConfigurationOptions&amp;lt;KafkaOptions&amp;gt;&lt;span&gt;(configuration))); &lt;span&gt;//这个是option类，没这个，配置无法将类绑定&lt;/span&gt;
            
             builder.Services.AddSingleton(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaConfiguration(configuration));
          }
    }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;ok,推送nuget，业务部分调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;&lt;span&gt;三&lt;/span&gt; &lt;span&gt;    kafka服务调用                          &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在project中引用然后restore：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222907427-914024122.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222908689-1318314100.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;135&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;引入命名空间：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222909316-1529246311.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222909818-220283207.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;127&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;调用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging; 
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Log;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Service;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.TestMcroServoces.Webapi
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    { 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        { 
             
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
            .ConfigureAppConfiguration((hostingContext, configContext) &lt;/span&gt;=&amp;gt;&lt;span&gt;{
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; en=&lt;span&gt;hostingContext.HostingEnvironment;
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(en.IsDevelopment())
                 {
                     configContext.AddJsonFile($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{en.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                 }
                 &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                 {
                     configContext.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                 }
                   configContext.AddCommandLine(args)
             .AddEnvironmentVariables()
             .SetBasePath(Directory.GetCurrentDirectory()).Build(); 
              
            })&lt;span&gt;.ConfigureServices((context,configureServices)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;{
                   configureServices.AddKafka(KafkaBuilder=&amp;gt;{
                    KafkaBuilder.AddConfiguration(context.Configuration.GetSection(&quot;KafkaService&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;));
                   });
            })   //kafka的调用。&lt;/span&gt;
            .ConfigureLogging((hostingContext, logging) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
 
                logging.AddConfiguration(hostingContext.Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .AddCustomizationLogger();

            }).UseKestrel(KestrelServerOption&lt;/span&gt;=&amp;gt;&lt;span&gt;{
                KestrelServerOption.ListenAnyIP(&lt;/span&gt;&lt;span&gt;801&lt;/span&gt;&lt;span&gt;);
            })
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;().Build(); 
            host.Run(); 
            Console.ReadKey();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后提交git，让jenkins构建docker发布运行：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;jenkin是是非常牛的一款构建工具，不仅仅根据插件可以扩展不同环境，还支持分布式构建.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222912141-668790612.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222912733-1329843471.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;149&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这是我们用jenikins构建的的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222913465-736696841.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222914089-793100891.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;70&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;span&gt;然&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;让它跑起来：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222914772-684175380.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222915307-1708515639.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;32&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;调用看看：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222915764-1787452457.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222916256-846178493.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;138&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个方法是输出Properties数组的，这个配置结构只是演示，后面的结构要变，因为要放kafka的配置，比如连接服务ip等，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;改动也很简单，在配置好configuration和service后，改动这个类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;KafkaOptions和配置文件中kafka节点中的json结构就行。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222916679-1033612302.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222917056-205066570.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;72&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;&lt;span&gt;四 集成kafka&lt;/span&gt;&lt;span&gt;                         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;kafka的接口不多，看看都有那些：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.Producer.html&quot; href=&quot;https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.Producer.html&quot;&gt;&lt;span&gt;https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.Producer.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222917566-1441987015.png&quot; alt=&quot;image&quot; width=&quot;144&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.Consumer.html&quot;&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/a&gt;&lt;span&gt;和&lt;a href=&quot;https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/Confluent.Kafka.Producer.html&quot;&gt;Producer&lt;/a&gt;是咱们发布消息和消费消息的两个主类,代码在上文已经实现的service&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;客户端代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用my-replicated-topic-morepart这儿topic，还是希望多分区，因为后面consumer使用分布式计算读取。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222917976-24421712.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222918758-1161843946.png&quot; alt=&quot;image&quot; width=&quot;722&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;consumer先在客户端监听：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222919293-955987829.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222919812-1123172761.png&quot; alt=&quot;image&quot; width=&quot;838&quot; height=&quot;42&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;product端的调用代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222920459-174172336.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222921114-2114610743.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;156&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;执行这个接口后，再看consumer接收到的消息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222921744-1611143846.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222922267-1507885320.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;53&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最后一步，将咱们kafka日志部分替换为真实的kafka环境,看结果：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222923203-1640110819.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190102222924331-1690488257.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;459&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么最后的配置是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Prix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自定义日志提供程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;KafkaService&quot;:{
    &quot;Properties&quot;:{
      &quot;bootstrap.servers&quot;:&quot;192.168.249.106:9092&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;log使用这个kafka服务就很简单了，在前面文章中实现的log扩展类中，直接构造函数注入这个kafkaService，就可以以使用了。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分布式日志到这里结束，可能大家觉得后面还有日志索引和日志展现，因为这个读kafka需要分布式去处理，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我下面刚好要写分布式计算的文章，所以到时可以拿这个当例子，承前继后。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 02 Jan 2019 14:29:00 +0000</pubDate>
<dc:creator>无为有道</dc:creator>
<og:description>一 kafka介绍 kafka是基于zookeeper的一个分布式流平台，既然是流，那么大家都能猜到它的存储结构基本上就是线性的了。硬盘大家都知道读写非常的慢，那是因为在随机情况下，线性下，硬盘的读写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10211725.html</dc:identifier>
</item>
<item>
<title>.Net Core ORM选择之路，哪个才适合你 - fly-小文子</title>
<link>http://www.cnblogs.com/kuangliwen/p/10210638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kuangliwen/p/10210638.html</guid>
<description>&lt;p&gt;因为老板的一句话公司项目需要迁移到.Net Core ，但是以前同事用的ORM不支持.Net Core 开发过程也遇到了各种坑，插入条数多了也特别的慢，导致系统体验比较差好多都改写Sql实现。&lt;/p&gt;
&lt;p&gt;所以我打算找一款&lt;/p&gt;
&lt;p&gt;                           性能比较好 &lt;/p&gt;
&lt;p&gt;                           功能比较完善&lt;/p&gt;
&lt;p&gt;                           方便以后可以切换数据库（经过我对老板的了解这个功能非常重要）&lt;/p&gt;
&lt;p&gt;                           并且要有一定用户基础的ORM &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参赛ORM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够参赛的ORM必须要有以下个条件&lt;/p&gt;
&lt;p&gt;第一、功能方面要比较完善&lt;/p&gt;
&lt;p&gt;第二、Github需要有一定人气并且最近有更新&lt;/p&gt;
&lt;p&gt;第三、支持多种数据库少写Sql，方便以后&lt;/p&gt;

&lt;p&gt;筛选结果：&lt;/p&gt;
&lt;p&gt;1、EF Core&lt;/p&gt;
&lt;p&gt;2、Dapper+扩展&lt;/p&gt;
&lt;p&gt;3、SqlSugar Core&lt;/p&gt;
&lt;p&gt;4、Nhibernate Core&lt;/p&gt;
&lt;p&gt;5、PetaPoco&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一轮淘汰赛  我们比 人气&amp;amp;功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过对这几个ORM的初步了解，对功能方面和人气方面进行了初步评分&lt;/p&gt;
&lt;p&gt;1、EF Core     人气10，功能10&lt;/p&gt;
&lt;p&gt;2、Dapper+扩展  人气10，功能9&lt;/p&gt;
&lt;p&gt;3、SqlSugar Core  人气7，功能10&lt;/p&gt;
&lt;p&gt;4、Nhibernate Core 人气7，功能10 &lt;/p&gt;
&lt;p&gt;5、PetaPoco 人气6，功能6&lt;/p&gt;
&lt;p&gt;经过第一轮帅选，我淘态了PetaPoco ORM&lt;/p&gt;
&lt;p&gt; 最重要的是这个ORM定位比较尴尬 ，功能一般并且扩展插件也比较稀少。现有功能以拼Sql为主满足不了我以后切换数据库的需求，第一轮淘态。&lt;/p&gt;

&lt;p&gt;第一轮得分排名&lt;/p&gt;
&lt;p&gt;1、EF Core &lt;span&gt;胜出&lt;/span&gt;     &lt;/p&gt;
&lt;p&gt;2、Dapper+扩展  &lt;span&gt; 胜出 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、SqlSugar Core  ，Nhibernate Core &lt;span&gt;胜出 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、PetaPoco &lt;span&gt;淘态&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二轮淘汰赛 我们比易用性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写太牛逼的功能并不是我们所考虑的，需要上手快好用，于是我针对项目中几个需求点进行了上手测试，并给出了评分&lt;/p&gt;
&lt;p&gt;1、EF Core  10   轻松满足&lt;/p&gt;
&lt;p&gt;2、Dapper+扩展   8  需要找插件比较费时间&lt;/p&gt;
&lt;p&gt;3、SqlSugar Core 10   轻松满足&lt;/p&gt;
&lt;p&gt;4、Nhibernate Core &lt;span&gt;&lt;span&gt; 1&lt;/span&gt; 完全不会用&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第二轮得分排名&lt;/p&gt;
&lt;p&gt;1、EF Core，SqlSugar Core &lt;span&gt;  胜出     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、Dapper+扩展  &lt;span&gt; 胜出&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;3、Nhibernate Core  &lt;span&gt;淘态 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;能够通过精心挑选并且进入前3名，相信这3个ORM都有他们独自的魅力&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三轮淘汰赛 我们比性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过对 批量插入、单条插入、批量更新、单条更新、条件查询、多选删除等几种常用场景的并发测试&lt;/p&gt;
&lt;p&gt;我意外的发现SqlSugar性能比Dapper更加的优秀，EF垫底&lt;/p&gt;
&lt;p&gt;第三轮得分排名&lt;/p&gt;
&lt;p&gt;1、SqlSugar Core   &lt;span&gt;胜出&lt;/span&gt;     &lt;/p&gt;
&lt;p&gt;2、Dapper+扩展   &lt;span&gt;胜出&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;3、EF  &lt;span&gt;淘态&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;通过上面各种环节我们可以发现，我都会淘汰每场比赛表现最差者，因为我想找一个比较平衡的ORM用于项目，不想有短腿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;决赛 我们比大家的建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前Dapper+扩展和SqlSugar Core  这2个ORM是最适合我们的团队的，同事之间也各有说词,暂且平手吧。明天我们公司会在进行讨论。写个博文让大家给给建议，进行最终定夺。&lt;/p&gt;
&lt;p&gt;下面是这2款ORM地址：&lt;/p&gt;
&lt;p&gt;Dapper&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot; target=&quot;_blank&quot;&gt;https://github.com/StackExchange/Dapper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tmsmith/Dapper-Extensions&quot; target=&quot;_blank&quot;&gt;https://github.com/tmsmith/Dapper-Extensions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SqlSugar&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunkaixuan/SqlSugar&quot; target=&quot;_blank&quot;&gt;https://github.com/sunkaixuan/SqlSugar&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Jan 2019 14:23:00 +0000</pubDate>
<dc:creator>fly-小文子</dc:creator>
<og:description>因为老板的一句话公司项目需要迁移到.Net Core ，但是以前同事用的ORM不支持.Net Core 开发过程也遇到了各种坑，插入条数多了也特别的慢，导致系统体验比较差好多都改写Sql实现。 所以我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kuangliwen/p/10210638.html</dc:identifier>
</item>
<item>
<title>.net core+Spring Cloud学习之路 一 - 请叫我小冯哥哥</title>
<link>http://www.cnblogs.com/f-z-h/p/10211651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-z-h/p/10211651.html</guid>
<description>&lt;p&gt;&lt;br/&gt;  文章开头唠叨两句。&lt;/p&gt;
&lt;p&gt;  2019年了，而自己参加工作也两年有余了，用一个词来概括这两年多的生活，就是：“碌碌无为”。&lt;/p&gt;
&lt;p&gt;  也不能说一点收获都没有，但是很少。2019来了，我立志要打破现状，改变自己，突破自我。现在明白了只有不断的学习才能不被淘汰，只有不断的学习才能拿到更高的工资。&lt;/p&gt;
&lt;p&gt;  言归正传，在今早发现张队在元旦前的博客“&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shanyou/p/10198757.html&quot;&gt;年末展望：Oracle 对 JDK收费和.NET Core 给我们的机遇&lt;/a&gt;&lt;/span&gt;”，说明了以后.net core会越来越好，而我本人在2017年的时候开始接触过.net core的时候，就没有放弃过对.net core的学习，现在觉得微服务是个不错的方向，而自己也在学习这块的东西，所以写个博客记录一下自己的学习的笔记。&lt;/p&gt;
&lt;p&gt;  我采用的是java的Spring cloud + .net core。&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;先打开idea创建一个Spring boot项目，在pom文件中添加如下maven依赖：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Dalston.SR3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载eureka需要的jar包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;新建一个《&lt;span&gt;&lt;span&gt;application.properties》配置文件，添加如下几行配置：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server.port=8888  #客户端默认情况下会将自己注册到一个8761的端口，我们修改端口为8888
eureka.client.register-with-eureka=false  #默认会把自己当作一个客户端注册到eureka服务，把他设置为false。
eureka.client.fetch-registry=false  #默认去抓取注册信息，自己本身是一个eureka服务器，没必要去抓取，应该是客户端去抓取，所以把这个配置设置为false。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;添加一个启动类。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.builder.SpringApplicationBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerApp {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SpringApplicationBuilder(ServerApp.&lt;span&gt;class&lt;/span&gt;).web(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).run(args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动这个启动类，然后浏览器里输入：http://localhost:8888(8888是我spring boot的端口)，然后看到如下页面，这个时候说明Spring boot eureka服务启动成功。&lt;img src=&quot;https://img2018.cnblogs.com/blog/797816/201901/797816-20190102212700201-1662634253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;打开vs，创建一个.net core web api项目 ，使用nuget添加Pivotal.Discovery.Client库。&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;Startup.cs 中添加
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; services.AddDiscoveryClient(Configuration);&lt;/span&gt;
&lt;span&gt;            services.AddDiscoveryClient(Configuration);
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env,ILoggerFactory loggerFactory)
        {
            loggerFactory.AddConsole(Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            loggerFactory.AddDebug();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }
            app.UseDiscoveryClient();
            app.UseHttpsRedirection();
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要&lt;span&gt;using Pivotal.Discovery.Client;&lt;/span&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;修改端口，
&lt;ol&gt;&lt;li&gt;打开launchSettings.json&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;修改端口为5000
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;Demo&quot;: {
      &quot;commandName&quot;: &quot;Project&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;launchUrl&quot;: &quot;api/values&quot;,
      &quot;applicationUrl&quot;: &quot;http://localhost:5000&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;打开appsettings.json 添加eureka服务配置
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;spring&quot;:{
    &quot;application&quot;:{
      &quot;name&quot;:&quot;serviceone&quot;
    }
  },
  &quot;eureka&quot;:{
    &quot;client&quot;:{
      &quot;serviceUrl&quot;:&quot;http://localhost:8888/eureka&quot;,
      &quot;shouldFetchRegistry&quot;:false,
      &quot;shouldRegisterWithEureka&quot;:true
    },
    &quot;instance&quot;:{
      &quot;port&quot;:5000
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;到此为止我们算是配置完成了一个简单的注册服务的小demo，我们先启动eureka服务，再启动.net core服务。这个时候在eureka服务的页面中发现名字为serviceone的客户端成功注册到了eureka服务中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/797816/201901/797816-20190102215828514-1310760.png&quot; alt=&quot;&quot; width=&quot;1992&quot; height=&quot;348&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Spring Cloud&quot; href=&quot;https://github.com/SpringCloud/spring-cloud-docs&quot; target=&quot;_blank&quot;&gt;Spring Cloud&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;备注：最近先更新Spring Cloud知识，之后会使用完整的Spring Cloud + .net core完成一个完整的项目。&lt;/p&gt;
&lt;p&gt;下周更新：搭建eureka群集。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Jan 2019 14:13:00 +0000</pubDate>
<dc:creator>请叫我小冯哥哥</dc:creator>
<og:description>文章开头唠叨两句。 2019年了，而自己参加工作也两年有余了，用一个词来概括这两年多的生活，就是：“碌碌无为”。 也不能说一点收获都没有，但是很少。2019来了，我立志要打破现状，改变自己，突破自我。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-z-h/p/10211651.html</dc:identifier>
</item>
<item>
<title>漫谈“采样”（sampling） - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10206454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10206454.html</guid>
<description>&lt;p&gt;  越学越懵了，计算机中是怎么进行采样的，用了这么久的 rand() 函数，到现在才知道是怎么做的。&lt;/p&gt;
&lt;h2 id=&quot;从均匀分布中采样&quot;&gt;从均匀分布中采样&lt;/h2&gt;
&lt;p&gt;  计算机中通过 &lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%91%E7%94%9F%E5%99%A8/22674963?fr=aladdin&quot; target=&quot;blank&quot;&gt;线性同余发生器（linear congruential generator，LCG）&lt;/a&gt;很容易从一个 $ x \sim Uniform[0, 1)$ 的均匀分布中进行采样。如果要从 &lt;span class=&quot;math inline&quot;&gt;\(y \sim Uniform[a, b)\)&lt;/span&gt; 的均匀分布中采样，只需要 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的基础上做个变换 &lt;span class=&quot;math inline&quot;&gt;\(y = (b-a)x + a\)&lt;/span&gt; 即可。&lt;/p&gt;
&lt;p&gt;  当然除了 LCG 外，还有其它均匀分布随机数生成方法，这里不一一列举，可以参考博客&lt;a href=&quot;https://blog.csdn.net/JackyTintin/article/details/7798157&quot; target=&quot;_blank&quot;&gt;随机数生成（一）：均匀分布&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;  单独把均匀分布采样摘出来是因为它很基础，很多其它采样方法都是在该基础上进行操作。&lt;/p&gt;
&lt;h2 id=&quot;对离散型变量采样&quot;&gt;对离散型变量采样&lt;/h2&gt;
&lt;p&gt;  我们现在通过某种方法（比如 LCG）可以生成均匀分布的随机数，这个时候我们就完全可以对某个含有有限个离散取值的变量 &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 进行采样，方法就是采用轮盘赌选择法。&lt;/p&gt;
&lt;p&gt;  假设离散型变量 &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 有 3 个取值，&lt;span class=&quot;math inline&quot;&gt;\(a_1, a_2, a_3\)&lt;/span&gt;，概率分布如下图所示：&lt;br/&gt;&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201901/1351564-20190102164541922-1258334767.png&quot; width=&quot;350px&quot;/&gt;&lt;p&gt;图 1 离散型变量 &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 概率分布&lt;/p&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;  所有取值概率之和为 1。此时我们可以从 &lt;span class=&quot;math inline&quot;&gt;\(Uniform[0, 1)\)&lt;/span&gt; 生成一个随机数 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;，若 &lt;span class=&quot;math inline&quot;&gt;\(0 \le b &amp;lt; 0.6\)&lt;/span&gt;，则选择出 &lt;span class=&quot;math inline&quot;&gt;\(a_1\)&lt;/span&gt;；若 &lt;span class=&quot;math inline&quot;&gt;\(0.6 \le b &amp;lt; 0.7\)&lt;/span&gt;，则选择出 &lt;span class=&quot;math inline&quot;&gt;\(a_2\)&lt;/span&gt;；若 &lt;span class=&quot;math inline&quot;&gt;\(0.7 \le b &amp;lt; 1\)&lt;/span&gt;，则选择出 &lt;span class=&quot;math inline&quot;&gt;\(a_3\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;对连续型变量采样&quot;&gt;对连续型变量采样&lt;/h2&gt;
&lt;p&gt;  上面我们已经讨论了从均匀分布 &lt;span class=&quot;math inline&quot;&gt;\(U[a,b)\)&lt;/span&gt; 中采样，对于其余分布，如高斯分布、gamma 分布、指数分布、t 分布、F 分布、Beta 分布、Dirichlet 分布等等，都可以基于 &lt;span class=&quot;math inline&quot;&gt;\(U[0,1)\)&lt;/span&gt; 的样本生成。例如高斯分布可以通过 Box-Muller 变换得到：&lt;/p&gt;
&lt;p&gt;【Box-Muller 变换】如果随机变量 &lt;span class=&quot;math inline&quot;&gt;\(U_1,U_2\)&lt;/span&gt; 独立且 &lt;span class=&quot;math inline&quot;&gt;\(U_1,U_2 \sim Uniform[0, 1]\)&lt;/span&gt;，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} Z_0 = \sqrt{-2\ln U_1} \cos (2 \pi U_2) \\ Z_1 = \sqrt{-2\ln U_1} \sin (2 \pi U_2) \end{aligned} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则 &lt;span class=&quot;math inline&quot;&gt;\(Z_0, Z_1\)&lt;/span&gt; 独立且服从标准正态分布。&lt;/p&gt;
&lt;p&gt;  想要得到服从 &lt;span class=&quot;math inline&quot;&gt;\(Z_2 \sim N(\mu, \sigma^2)\)&lt;/span&gt; 的高斯分布，则只需对 &lt;span class=&quot;math inline&quot;&gt;\(Z_0 \sim N(0, 1)\)&lt;/span&gt; 做如下变换：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Z_2 = \sigma Z_0 + \mu \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  对于更加一般分布 &lt;span class=&quot;math inline&quot;&gt;\(p(x)\)&lt;/span&gt;，如下图所示，我们该如何对其进行采样呢？&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201901/1351564-20190102203714178-310005359.png&quot; width=&quot;350px&quot;/&gt;&lt;p&gt;图 2 分布 &lt;span class=&quot;math inline&quot;&gt;\(p(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;  这个时候我们可以使用 rejection sampling。&lt;/p&gt;
&lt;p&gt;  Rejection sampling 首先寻找一个简单的分布 &lt;span class=&quot;math inline&quot;&gt;\(q(x)\)&lt;/span&gt;，然后乘以一个常数 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，使其满足 &lt;span class=&quot;math inline&quot;&gt;\(p(x) \le M \cdot q(x)\)&lt;/span&gt;，如下图所示，&lt;span class=&quot;math inline&quot;&gt;\(q(x)\)&lt;/span&gt; 是一个高斯分布，&lt;span class=&quot;math inline&quot;&gt;\(M = 2\)&lt;/span&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201901/1351564-20190102204408830-1527750059.png&quot; width=&quot;450px&quot;/&gt;&lt;p&gt;图 2 分布 &lt;span class=&quot;math inline&quot;&gt;\(p(x)\)&lt;/span&gt; 和 分布 2q(x)&lt;/p&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;  在找到一个分布 &lt;span class=&quot;math inline&quot;&gt;\(2q(x)\)&lt;/span&gt; 能完全“覆盖”分布 &lt;span class=&quot;math inline&quot;&gt;\(p(x)\)&lt;/span&gt; 后，我们任意 sample 一个样本点 &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;，但此时，我们将以 &lt;span class=&quot;math inline&quot;&gt;\(\frac{p(x_i)}{2q(x_i)}\)&lt;/span&gt; 的概率选择去接收这个样本，以 &lt;span class=&quot;math inline&quot;&gt;\((1 - \frac{p(x_i)}{2q(x_i)})\)&lt;/span&gt; 的概率选择去拒绝该样本。rejection sampling 平均会接收 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{M}\)&lt;/span&gt; 个样本点。&lt;/p&gt;
&lt;p&gt;  rejection sampling 优点：使用 rejection sampling 可以对大多数分布进行采样，即使这些“分布”没有进行归一化。&lt;/p&gt;
&lt;p&gt;  rejection sampling 缺点：当 &lt;span class=&quot;math inline&quot;&gt;\(p(x)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(2q(x)\)&lt;/span&gt; 相差太多时，rejection sampling 将拒绝大多数样本点；其次，对于高维数据，常数 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 会很大，简单使用 rejection sampling 所需要的样本量随空间维数增加而指数增长，即高维情况下不适合用 rejection sampling，此时 MCMC（Markov Chains Monte Carlo）和 Gibbs sampling 才是主流。（当然 MCMC 等既能处理离散情况也能处理连续情况。）&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%91%E7%94%9F%E5%99%A8/22674963?fr=aladdin&quot; target=&quot;_blank&quot;&gt;线性同余发生器 -- 百度百科&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/JackyTintin/article/details/7798157&quot; target=&quot;_blank&quot;&gt;随机数生成（一）：均匀分布 -- MoussaTintin&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cosx.org/2013/01/lda-math-mcmc-and-gibbs-sampling&quot; target=&quot;_blank&quot;&gt;LDA-math-MCMC 和 Gibbs Sampling -- 靳志辉&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/pinard/p/6625739.html&quot; target=&quot;_blank&quot;&gt;MCMC(一)蒙特卡罗方法 -- 刘建平Pinard&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.coursera.org/learn/bayesian-methods-in-machine-learning/lecture/XYaYu/sampling-from-1-d-distributions&quot; target=&quot;_blank&quot;&gt;Bayesian Methods for Machine Learning: Sampling from 1-d distributions&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Jan 2019 13:59:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>给定一个分布 $p(x)$，计算机中如何进行采样？本文大致介绍了计算机中如何对均匀分布进行采样，并对离散分布和连续分布采样进行了简单介绍。本文不涉及 MCMC 和 Gibbs 采样。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10206454.html</dc:identifier>
</item>
<item>
<title>ReactJs 的各个版本生命周期、API变化 汇总（一、V16.0.0） - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/10211495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/10211495.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;由于 React 的版本更新频繁，各类的新特性也是让人眼花缭乱的，为了方便自己查询最新的以及过往的 各个 React 版本 api、生命周期函数。 这里就用 caniuse 的方式做一个 方便查询的小功能。&lt;/p&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;那么要实现这个小功能之前，我们必须要对 React 的各种版本进行仔细的解读。
最快捷的方式就是 直接 通过官方文档来获取最真实的信息。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一react-各个版本之间的纵向对比&quot;&gt;一、React 各个版本之间的纵向对比&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;V 16.0.0&lt;/td&gt;
&lt;td&gt;constructor()&lt;br/&gt;componentWillMount()&lt;br/&gt;render()&lt;br/&gt;componentDidMount()&lt;/td&gt;
&lt;td&gt;componentWillReceiveProps()&lt;br/&gt;shouldComponentUpdate()&lt;br/&gt;componentWillUpdate()&lt;br/&gt;render()&lt;br/&gt;componentDidUpdate()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;V 16.3.2&lt;/td&gt;
&lt;td&gt;constructor()&lt;br/&gt;static&amp;amp;nbspgetDerivedStateFromProps()&lt;br/&gt;componentWillMount() / UNSAFE_componentWillMount()&lt;br/&gt;render()&lt;br/&gt;componentDidMount()&lt;/td&gt;
&lt;td&gt;componentWillReceiveProps() / UNSAFE_componentWillReceiveProps()&lt;br/&gt;static getDerivedStateFromProps()&lt;br/&gt;shouldComponentUpdate()&lt;br/&gt;componentWillUpdate() /UNSAFE_componentWillUpdate()&lt;br/&gt;render()&lt;br/&gt;getSnapshotBeforeUpdate()&lt;br/&gt;componentDidUpdate()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;V 16.5.2&lt;/td&gt;
&lt;td&gt;constructor()&lt;br/&gt;static getDerivedStateFromProps()&lt;br/&gt;render()&lt;br/&gt;componentDidMount()&lt;/td&gt;
&lt;td&gt;static getDerivedStateFromProps()&lt;br/&gt;shouldComponentUpdate()&lt;br/&gt;render()&lt;br/&gt;getSnapshotBeforeUpdate()&lt;br/&gt;componentDidUpdate()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;V 16.7.0(最新)&lt;/td&gt;
&lt;td&gt;constructor()&lt;br/&gt;static getDerivedStateFromProps()&lt;br/&gt;render()&lt;br/&gt;componentDidMount()&lt;/td&gt;
&lt;td&gt;static getDerivedStateFromProps()&lt;br/&gt;shouldComponentUpdate()&lt;br/&gt;render()&lt;br/&gt;getSnapshotBeforeUpdate()&lt;br/&gt;componentDidUpdate()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;二react-的基础&quot;&gt;二、React 的基础&lt;/h2&gt;
&lt;h3 id=&quot;components-and-props&quot;&gt;1、Components and Props&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1-1、About &lt;code&gt;Components&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;1、Components let you split the UI into independent, reusable pieces, and think about each piece in isolation 

组件允许您将UI拆分为独立的、可重用的部分，并独立地考虑每个部分&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;2、Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.

从概念上讲，组件类似于JavaScript函数。它们接受任意输入(称为“props”)，并返回描述屏幕上应该出现的内容的React元素。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1-2、Component's presentation (展现形式)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The simplest way to define a component is to write a JavaScript function:&lt;br/&gt;（最简单的方式）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Welcome(props) {
  return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You can also use an ES6 class to define a component:&lt;br/&gt;（你也可以使用 ES2015 中 类 的方式）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Welcome extends React.Component {
  render() {
    return &amp;lt;h1&amp;gt;Hello, {this.props.name}&amp;lt;/h1&amp;gt;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的二种写法，目前来看是&lt;code&gt;等价的&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;任何都 React 版本，关于 Lifecycle 我们都可以找到对应的几个状态，来进行不同的 api 的差异的对比。这样也是方便，我们进行记忆的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三react-v-16.0.0&quot;&gt;三、React V 16.0.0&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;官方文档传送门：&lt;/code&gt; &lt;a href=&quot;https://5a046bf5a6188f4b8fa4938a--reactjs.netlify.com/docs/hello-world.html&quot;&gt;React V 16.0.0 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-component-lifecycle-v16.0.0&quot;&gt;1、 The Component Lifecycle ( v16.0.0 )&lt;/h3&gt;
&lt;h4 id=&quot;mounting-绑定阶段&quot;&gt;1-1 Mounting （绑定阶段）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;constructor()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;React.Component 的 constructor 会在组件被 mounted 之前被调用&lt;/li&gt;
&lt;li&gt;当作为 React.Component 的子类的时候，必须要有 super(props) 被调用，否则会有 bug&lt;/li&gt;
&lt;li&gt;constructor 是正确的初始化 state 的地方。并且在 constructor 中不能调用 setState() 方法&lt;/li&gt;
&lt;li&gt;如果没有初始化的方法或者 state 的话，就不需要 constructor&lt;/li&gt;
&lt;li&gt;state 也可以 基于 props 的值，但是 state 不会随着 props 带改变而改变。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;例如:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;constructor(props) {
  super(props);
  this.state = {
    color: props.initialColor
  };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果你想监听 props 的变化，再这个版本中你可以使用 componentWillReceiveProps(nextProps) 方法。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentWillMount()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;componentWillMount()在挂载发生之前立即被调用&lt;/li&gt;
&lt;li&gt;在 render() 之前 被调用&lt;/li&gt;
&lt;li&gt;所以在 这个方法中使用 setState() 不会 触发 render 方法&lt;/li&gt;
&lt;li&gt;避免在此方法中引入任何副作用&lt;/li&gt;
&lt;li&gt;这是在服务器呈现时调用的惟一生命周期钩子&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;render() 方法是必要的&lt;/li&gt;
&lt;li&gt;render 方法当被调用时，会检查当前的 props 和 state 并返回 一种具体的类型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;以下类型：&lt;/code&gt;&lt;br/&gt;&lt;code&gt;React elements&lt;/code&gt;、&lt;code&gt;String and numbers&lt;/code&gt; 、 &lt;code&gt;Portals&lt;/code&gt; 、&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当 render  null、 false、ReactDOM.findDOMNode(this) 的时候会返回 null&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;render 函数中不应该修改 state 的值，它不会马上和浏览器交互。&lt;/li&gt;
&lt;li&gt;如果想改变 state 的值，并马上能在浏览器上看到，那就在 componentDidMount() 中调用。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentDidMount()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;componentDidMount() 方法在 component is mounted 之后马上被调用&lt;/li&gt;
&lt;li&gt;在这一步可以初始化需要的 Dom 节点&lt;/li&gt;
&lt;li&gt;而且这里也是很好的进行 ajax 请求的地方。&lt;/li&gt;
&lt;li&gt;这里也是进行 订阅 的地方。并记得在 componentWillUnmount() 方法中 退订。&lt;/li&gt;
&lt;li&gt;在这里调用 setState() 会触发一个 额外的 rendering。如果同时触发2次也只会执行一次。&lt;/li&gt;
&lt;li&gt;不要频繁使用 setState() 因为会带来 性能问题。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;updating-数据更新阶段&quot;&gt;1-2 Updating （数据更新阶段）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;componentWillReceiveProps()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;componentWillReceiveProps(nextProps)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;componentWillReceiveProps() 方法 在已经被 mounted 的组件在接受一个新的props 的时候被调用。&lt;/li&gt;
&lt;li&gt;在这个方法中，你可以对比 this.props 和 nextProps 然后 使用 this.setState() 改变 props 的值&lt;/li&gt;
&lt;li&gt;当父组件 re-render 当前组件的时候，用于 props 并未发生改变，但是 也会执行 componentWillReceiveProps 这个方法。 所以这里就需要你进行 当前值 和 nextProps 对比 来进行下一步的操作。&lt;/li&gt;
&lt;li&gt;此方法不会在 初始化 对时候就执行的。&lt;/li&gt;
&lt;li&gt;唯一会执行这个方法对就是 props 更新发生变化的时候。这也是正确的使用当前 api 的场景。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;shouldComponentUpdate(nextProps, nextState)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;让React知道组件的输出是否不受当前状态或道具更改的影响&lt;/li&gt;
&lt;li&gt;是在每个状态更改时重新呈现 时候的默认行为。&lt;/li&gt;
&lt;li&gt;当有新的 props 和 state 被接受的 之前 就会 调用此方法&lt;/li&gt;
&lt;li&gt;在 初始化 render 和 forceUpdate方法被调用的时候，这个方法不会被调用。&lt;/li&gt;
&lt;li&gt;返回 fasle 的时候不会 防止 他们的组件组 进行 重新渲染。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentWillUpdate()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;componentWillUpdate(nextProps, nextState)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;此方法 比 shouldComponentUpdate 多了一个 immediately&lt;/li&gt;
&lt;li&gt;此方方法是为了 执行一些准备，在 updata 之前。&lt;/li&gt;
&lt;li&gt;在此方法中不能 执行 setState() ，也不能做任何事情，除了 dispatch a Redux action 等。&lt;/li&gt;
&lt;li&gt;如果你需要 更新 state 或者 props 的结果，你可以 使用 componentWillReceiveProps()&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentDidUpdate()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;componentDidUpdate(prevProps, prevState)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 updating 发生之后立即执行 componentDidUpdate&lt;/li&gt;
&lt;li&gt;在此方法 是一个机会来 处理 Dom 当 组件 update 之后。&lt;/li&gt;
&lt;li&gt;这也是一个好的地方来处理网络请求，当 props 发生改变的时候。&lt;/li&gt;
&lt;li&gt;如果 props 没发生改变，则不需要发送 ajax 请求。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;unmounting-解除绑定阶段&quot;&gt;1-3 Unmounting （解除绑定阶段）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentWillUnmount()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;当组件被卸载和销毁的时候此方法马上被调用。&lt;/li&gt;
&lt;li&gt;同时 也可以 清理 一些方法。例如 无效的 timers 、取消ajax请求、一些订阅&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;error-handling-错误处理阶段&quot;&gt;1-4 Error Handling （错误处理阶段）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;componentDidCatch()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;componentDidCatch(error, info)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;错误边界是响应组件，这些组件捕捉子组件树中的任何位置的JavaScript错误，记录这些错误，并显示一个回退UI，而不是崩溃的组件树。错误边界在呈现、生命周期方法和下面整个树的构造函数中捕获错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果类组件定义了这个生命周期方法，它就会成为一个错误边界。在其中调用setState()允许您在下面的树中捕获未处理的JavaScript错误并显示回退UI。只使用错误边界从意外异常中恢复;不要试图用它们来控制流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;other-apis&quot;&gt;2、 Other APIs&lt;/h3&gt;
&lt;h4 id=&quot;setstate-数据变更&quot;&gt;2-1 setState() （数据变更）&lt;/h4&gt;
&lt;h4 id=&quot;forceupdate-强制数据变更&quot;&gt;2-2 forceUpdate() （强制数据变更）&lt;/h4&gt;
&lt;h3 id=&quot;class-properties-类的属性&quot;&gt;3、 Class Properties （类的属性）&lt;/h3&gt;
&lt;h4 id=&quot;defaultprops默认的-props&quot;&gt;3-1 defaultProps（默认的 props）&lt;/h4&gt;
&lt;h4 id=&quot;displayname展示名称&quot;&gt;3-2 displayName（展示名称）&lt;/h4&gt;
&lt;h3 id=&quot;instance-properties-实例属性&quot;&gt;4、Instance Properties （实例属性）&lt;/h3&gt;
&lt;h4 id=&quot;props父组件传递进来的数据&quot;&gt;4-1 props（父组件传递进来的数据）&lt;/h4&gt;
&lt;h4 id=&quot;state本地组件的数据&quot;&gt;4-2 state（本地组件的数据）&lt;/h4&gt;
&lt;h3 id=&quot;回顾&quot;&gt;3、 回顾&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;可能就会有同学问了，为啥 第二部分的内容不讲了？&lt;br/&gt;答： 这真的没什么好讲的。&lt;br/&gt;以上则是 React V16.0.0 的全部内容，欢迎大家一起讨论～后面还有 关于剩下版本的 apis 变化的介绍，&lt;br/&gt;主要是以 为什么 react 开发组要 干掉这些 api 以及 新的 api 能解决什么问题为出发点。介绍 ReactJS 这些年的进化&lt;br/&gt;帮助大家一起来走进这个框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.4&quot;&gt;
&lt;p&gt;&lt;code&gt;GitHub&lt;/code&gt; 地址：（欢迎 star 、欢迎推荐 : )&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%20-%20%E7%AC%AC%E4%B8%89%E7%AB%A0%20-%20React/react-16.0.0.md&quot;&gt;ReactJs 的各个版本生命周期、API变化 汇总&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 02 Jan 2019 13:44:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>由于 React 的版本更新频繁，各类的新特性也是让人眼花缭乱的，为了方便自己查询最新的以及过往的 各个 React 版本 api、生命周期函数。 这里就用 caniuse 的方式做一个 方便查询的小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/10211495.html</dc:identifier>
</item>
<item>
<title>SSM的配置，及其中的MVC结构分析，SSM框架的响应流程 - 小徐同学是个coder</title>
<link>http://www.cnblogs.com/zjxu97/p/10211203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjxu97/p/10211203.html</guid>
<description>&lt;p&gt;今天头一次配置成功一个SSM框架，兴奋之余，还应该从使用的角度，将整个ssm配置的方法，配置的原因，认真的分析一下。在结束了对SSM框架简单的分析之后，就要开始回归基础，全面的认真复习。所以这个文档，要尽量的完整，目标就是，这个文档是是对SSM框架的学习，也是一个将来复习的资料。&lt;/p&gt;&lt;p&gt;　　这个版本中的代码貌似无法复制，我将可以也可复制版也发布了，在我的博客中，但是没有很好的样式。&lt;/p&gt;&lt;div id=&quot;write&quot; readability=&quot;293&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491355/201901/1491355-20190102204656510-815571989.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;h2&gt;1.1 配置文件简介&lt;/h2&gt;
&lt;p&gt;这个部分用来解读在resources文件夹下的配置信息。这一部分是整个ssm框架中，最难的一部分，也是最复杂的一部分。在配置这个部分的时候，尽管是不停的肤质粘贴，偶尔改一改路径。但是这样的一个 过程要比写业务逻辑代码麻烦的多。&lt;/p&gt;
&lt;h3&gt;1.1.1 jdbc.properties&lt;/h3&gt;
&lt;p&gt;这个文件是用来保存和数据库连击的相关的信息，比如JDBC驱动器、数据库户名、数据库密码等等，和数据库相关的静态信息，都会以KV的形式，保存在这个文件中。这样在需要对数据库的信息进行改变时，只需要打开这个文件，就可以对数据库的配置进行改变。与之前传统数据库连接方式相比，在修改时，不用改变多处的信息。&lt;/p&gt;
&lt;h3&gt;1.1.2 spring-mvc.xml&lt;/h3&gt;
&lt;p&gt;和名字显示的显示的一样，这是一个对MVC配置的一个文件。简单来讲有下面的几点功能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 设定用来存放controller的包的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 以文件前缀、后缀的方式，设定存放JSP文件的路径。&lt;/p&gt;
&lt;p&gt;我对这个文件的理解为，从controller获取执行哪一个文件的信息，在将这个信息，通过前缀和后缀的包装，传递给下一级。&lt;/p&gt;
&lt;h3&gt;1.1.3 spring-mybatis.xml&lt;/h3&gt;
&lt;p&gt;这个配置也常常叫做：applicationContext.xml，但是其实是一个东西，都是用来配置mybatis。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 将标注Spring注解的类自动转化成Bean，并且完成Bean的注入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 配置数据库相关的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3&lt;/code&gt; 配置数据库的sessionFactory&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4&lt;/code&gt; 配置需要被扫描的用来存放DAO接口的接口包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5&lt;/code&gt; 配置事务管理器。&lt;/p&gt;
&lt;h3&gt;1.1.4 UserDAO.xml&lt;/h3&gt;
&lt;p&gt;mapper.xml稍微好理解一些。就是使用DAO接口的全限定地址，和DAO中的操作数据库的sql方法，封装起来，那么调用DAO接口的某个方法的时候，就可以使用mapper.xml中封装的sql语句操作数据库。&lt;/p&gt;
&lt;p&gt;通常在这个文件也叫做mapper.xml文件.&lt;/p&gt;
&lt;h3&gt;1.1.5 web.xml&lt;/h3&gt;



&lt;h3&gt;1.1.6 其他&lt;/h3&gt;
&lt;p&gt;Logback是一个关于log日志的配置文件，并没有使用sql文件夹。还有就是pom.xml文件,看起来很多，其实也就是添加了几个依赖罢了。&lt;/p&gt;


&lt;h2&gt;1.2 jdbc.properties&lt;/h2&gt;
&lt;h3&gt;1.2.1 代码&lt;/h3&gt;

&lt;h3&gt;1.2.2 代码解析&lt;/h3&gt;
&lt;p&gt;前面四行是我们在操作JDBC的时候，常常操作的四项，分别是：驱动器、地址、用户名、密码。&lt;/p&gt;
&lt;p&gt;第7行设定最大连接数为30。最大连接数是连接池能申请的最大连接数。如果数据连接请求超过此数，后面的数据连接请求将被加入到等待队列中，这会影响之后的数据库操作。&lt;/p&gt;
&lt;p&gt;第8行设定最小连接数为10。最小连接数是连接池一直保持的数据连接。如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费掉。&lt;/p&gt;
&lt;p&gt;第9行设定在关闭之后，不会自动执行commit。如果设置为true，那么在数据库的连接状态关闭的时候，会将没有commit的数据库操作，执行commit。&lt;/p&gt;
&lt;p&gt;第10行设定连接超时时间。&lt;/p&gt;
&lt;p&gt;第11行设定失败后尝试的次数。&lt;/p&gt;
&lt;p&gt;这一个文件的设置十分明确。并且在它被读取的时候，也是以键值对的形式被读取的。&lt;/p&gt;
&lt;h2&gt;1.2 spring-mvc.xml&lt;/h2&gt;
&lt;h3&gt;1.2.1 代码&lt;/h3&gt;

&lt;h3&gt;1.2.2 代码解析&lt;/h3&gt;
&lt;p&gt;在这样的一个文件中，第1～11行都是环境。&lt;/p&gt;
&lt;p&gt;第14行设置存放controller的目录，在这个目录下的类都会被扫描。&lt;/p&gt;
&lt;p&gt;第17行将设定模式为注解模式，解析base-package目录下面带有@Controller注解的类。&lt;/p&gt;
&lt;p&gt;第23～27行设定这个解析的前缀和后缀，前缀设定这个文件的目录，后缀设定这个文件的拓展名。&lt;/p&gt;
&lt;h3&gt;1.2.3 功能简析&lt;/h3&gt;
&lt;p&gt;SpringMVC是View层的一部分，来自于页面的信息由SpringMVC控制的Controller将请求发送到Model层中的Service中，然后再Model中处理业务逻辑。从Model返回的model，添加上前缀和后缀，传递到View层中。&lt;/p&gt;
&lt;p&gt;所以，具体的细分的话，这是一个介于页面和Model层之间的模块：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 将来自页面的请求，传递到合适的controller。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 将从controller返回的一个jsp文件名的字符串，在这里包装之后，的到下一个jsp文件的全限定路径，然后显示出来。当然并不是所有的controller都有返回值，如果没有，那就是在当前的页面修改。&lt;/p&gt;

&lt;h2&gt;1.3 spring-mybatis.xml&lt;/h2&gt;
&lt;h3&gt;1.3.1 代码&lt;/h3&gt;

&lt;h3&gt;1.3.2 代码解析&lt;/h3&gt;
&lt;p&gt;第14行：加上这一行以后，将自动扫描路径下面的包，如果一个类带了@Service注解，将自动注册到Spring容器，不需要在spring-mybatis.xml文件定义bean了。类似的注解还有Component、Repository、Controller。&lt;/p&gt;
&lt;p&gt;例如：有下面一个类位于com.xzj.service或其子目录中：&lt;/p&gt;

&lt;p&gt;那么就相当于在spring-mybatis.xml添加了一段这样的。&lt;/p&gt;

&lt;p&gt;简而言之，这是一个将带有注解的类添加到Spring容器的语句。&lt;/p&gt;
&lt;p&gt;第20～30行，创建数据库连接池，读取jdbc.properties文件中的有关于数据库的设置，按照这样的设置，设定数据库连接池的属性。&lt;/p&gt;
&lt;h3&gt;1.3.3 功能简析&lt;/h3&gt;
&lt;p&gt;纵观整个项目，就是这一块是最复杂的，在上面的代码中：&lt;/p&gt;
&lt;p&gt;第50行和第38行的bean将DAO接口和mapper连接起来。这样的配置，使得在使用DAO接口的时候，直接调用接口方法，就可以直接调用DAO.xml中的sql语句。&lt;/p&gt;
&lt;p&gt;另外的一点就是注册了service的目录，将service的内容注册到了Spring的容器中。也就是说，这个这个文件配置了两个方面的内容：一个是以service代表的业务逻辑，一个是以DAO及其映射mapper代表的数据访问，这两者共同组成了Model层。&lt;/p&gt;
&lt;h2&gt;1.4 web.xml&lt;/h2&gt;
&lt;h3&gt;1.4.1 web.xml的代码&lt;/h3&gt;

&lt;h3&gt;1.4.2 代码解析&lt;/h3&gt;
&lt;p&gt;配置编码过滤器。&lt;/p&gt;
&lt;p&gt;配置分发器，并且这里的分发器中，注入了两个xml文件。&lt;/p&gt;
&lt;p&gt;配置welcome页面。&lt;/p&gt;



&lt;h2&gt;2.1 MVC的构成&lt;/h2&gt;

&lt;h3&gt;2.1.1 M层&lt;/h3&gt;
&lt;p&gt;M层表示Model层，模型层。用来实现业务逻辑、对数据进行访问。&lt;/p&gt;
&lt;p&gt;这一层大概分为三个部分，Model、Service、DAO这样的三块，以我创建的这个工程来讲三个部分分别是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; User类，这个类中有三个属性，分别有他们的get、set方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; Service接口及其实现类。在spring-mybatis.xml中配置，从而被扫描。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3&lt;/code&gt; UserDAO接口，在spring-mybatis.xml中配置，与UserDAO.xml配对，被动态实现。&lt;/p&gt;
&lt;p&gt;即:这层的三个模块都是在spring-mybatis.xml中被配置的。&lt;/p&gt;
&lt;h3&gt;2.1.2 V层&lt;/h3&gt;
&lt;p&gt;V层表示View层，显示层。是用来和用户交互的可视化界面，如html和jsp文件在浏览器中的显示。同样，在这些显示页面中，可以设定不同的请求，根据不同的前端动作，提交给分发器。那么这样的到的响应也不同。&lt;/p&gt;
&lt;h3&gt;2.1.3 C层&lt;/h3&gt;
&lt;p&gt;C层表示Controller控制器。C层大致上有两种功能：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 根据不同的请求，调用M层中不同业务逻辑处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 得到了来自M层处理结果的返回，给予V层的显示结果也不相同。&lt;/p&gt;
&lt;p&gt;这一块是在spring-mvc.xml配置的。&lt;/p&gt;
&lt;h2&gt;2.2 M层的具体构成&lt;/h2&gt;
&lt;h3&gt;2.2.1 简述&lt;/h3&gt;
&lt;p&gt;M层是Model层，负责业务逻辑和数据访问。以这个项目为例子，除了controller 以外的Java类和接口都是属于Model层的的，除此之外还有UserDAO.xml也是属于Model层的。&lt;/p&gt;
&lt;h3&gt;2.2.2 User类&lt;/h3&gt;
&lt;p&gt;User的代码如下：&lt;/p&gt;


&lt;p&gt;言简意赅，这一段代码就是定义一个User类，并且定义了几个域。id、name、password、comments。设定了它们的getter和setter。&lt;/p&gt;
&lt;h3&gt;2.2.3 UserService接口&lt;/h3&gt;

&lt;p&gt;申明一个接口，这个接口是Model层中的service的接口。它的实现类，必须实现在这个类中定义的方法。其实这个接口并不是必须的，在spring-mybatis.xml中，配置的com.xzj.service目录中直接写UserServiceImple类，即可将这个类配置进spring中。但是有这个过接口可以将Model层中的service服务的结构更加清晰。所以在这个工程中，就使用了UserService接口。&lt;/p&gt;

&lt;h3&gt;2.2.4 UserServiceImple 类&lt;/h3&gt;

&lt;p&gt;UserService的实现类，其中两个很重要的是两个注解11和14行的两个注解。 ​第11行的注解@Service(&quot;userService”)，表示是为userService服务的，这个userService是controller的userService类。&lt;/p&gt;
&lt;h3&gt;2.2.5 UserDAO 接口&lt;/h3&gt;



&lt;h3&gt;2.2.5 UserDAO.xml&lt;/h3&gt;

&lt;h2&gt;2.3 C层的具体构成&lt;/h2&gt;
&lt;h3&gt;2.3.1 简述&lt;/h3&gt;
&lt;p&gt;C层就是 controller，位于Model层和View层之间的一层。&lt;/p&gt;
&lt;h3&gt;2.3.2 Controller 类&lt;/h3&gt;


&lt;h3&gt;2.3.3 Controller层注解的详细分析&lt;/h3&gt;
&lt;p&gt;在controller中，重要的地方在于这几个注解。controller、Resource、RequestMapping这单个注解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 注解@Controller。&lt;/p&gt;
&lt;p&gt;表明这是一个Controller类，spring-mvc.xml文件设定的扫描目录下被扫描。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 注解@Resource。&lt;/p&gt;
&lt;p&gt;这个注解放在UserService的申明的前一行。它声明一个名为userService的对象，并且这个对象的类型为UserService接口的实现类。&lt;/p&gt;
&lt;p&gt;通过@Resource注解，可以在service目录下UserServiceImple类中找到带有一个@Service(&quot;userService”)的注解，找到的注解中的变量名和这个注解下一行声明的对象的变量名是一致的。&lt;/p&gt;
&lt;p&gt;在service目录下找到的那个类前面的注解表明在controller中的申明的对象的具体类型的UserServiceImple，它实现了UserService这个接口。&lt;/p&gt;
&lt;p&gt;也就是说，@Service(“userService”)注解的类，为@Resource下一行的名为userService的对象服务。而它们一个位于service目录下，一个位于controller目录下。这两个目录都被添加到了spring-*.xml中。这样的对应关系，是属于两个层的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3&lt;/code&gt; 注解@RequestMapping&lt;/p&gt;
&lt;p&gt;参数类型为一个字符串。这个参数的意义是从controller来的除了项目以外的三级及以下的URL地址。比如：&lt;/p&gt;

&lt;p&gt;这样的一个地址，经过分发器，来到了controller，controller会根据除了localhost/ssm/之外的地址，调用不同的方法。在controller这端，就会将后面的这段url地址通过注解，标记在方法上，或者是类上面。以这个url来看，它就会调用UserController.test(request,response)方法。&lt;/p&gt;
&lt;p&gt;注解的位置的区别在于：&lt;/p&gt;
&lt;p&gt;&amp;lt;1&amp;gt; 类的上方没有注解的时候，这个类的下面所有的方法的注解都需要添加参数。当然，也不是所有的方法都需要有注解。&lt;/p&gt;
&lt;p&gt;但是只要是存在的注解都需要有参数。否则这样写的controller方法，作出的效果将会是“localhost:8080/ssm”的结果，这样welcome页面将会失效。&lt;/p&gt;
&lt;p&gt;&amp;lt;2&amp;gt; 类的上方存在注解，那么这个注解会成为这个一个上级字符串加在类中的方法上的字符串上。就如同java的package的目录一样。com.xzj.test这样子，只不过在这里是用’/’来连接。&lt;/p&gt;

&lt;h2&gt;2.4 V层的具体构成&lt;/h2&gt;
&lt;p&gt;V层是直接面对用户的页面。所以在V层中，写的代码都是面向用户的操作的，尽管有一部分和请求相关，但是绝大部分还是于页面的展示相关的。&lt;/p&gt;
&lt;h3&gt;2.4.1 index.html文件&lt;/h3&gt;

&lt;p&gt;这段html代码，其中的重点在于javascript代码中的Ajax掌握。&lt;/p&gt;
&lt;p&gt;这段短短的javascript，发起请求，获得响应，设定显示，完成这三个工作。&lt;/p&gt;
&lt;p&gt;按钮-响应，这一块非常基础的前端应用，主要的问题来自于响应方法中的Http请求。关于javascript的代码逻辑，虽然一眼就能明了，但是，还是要仔细研究一下ajax如何在html文件中，更加精巧的应用。&lt;/p&gt;
&lt;p&gt;对于这个连接，就是在点击之后，会跳转到显示/WEB-INF/views/test.jsp相当于一个请求controller，并通过controller的到一个“test”的字符串，将其包装成为了一个完整的路径，在View层显示。&lt;/p&gt;

&lt;h3&gt;2.4.2 jsp目录及其下的test.jsp文件&lt;/h3&gt;

&lt;p&gt;这个jsp的路径是/WEB-INF/views/test.jsp，在从controller中返回一个字符串，比如一个“test”串，或者是modelAndView.setViewName(&quot;test”),并将其返回。&lt;/p&gt;
&lt;p&gt;就会通过spring-mvc.xml中的下两行，将其包装成/WEB-INF/views/test.jsp。并将其显示到页面中。&lt;/p&gt;

&lt;p&gt;在这样一个jsp页面中，${name}这个变量，是通过controller类中以返回modealAndView的方式，在modelAndView对象：&lt;/p&gt;

&lt;p&gt;那么在jsp页面中，将会读取这个KV，将name显示为成“SpringMVC”。这样就完成了一个从后台向前台的传输的过程。&lt;/p&gt;


&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 用户在浏览器窗口输入一个URL地址，以localhost:8080/ssm/为例子，由于这个URL是直接localhost/ssm/后面并没有接更多的信息，就会直接显示在web.xml中设定的welcome页面index.html。​&lt;strong&gt;这个过程发生在View层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 于是在浏览器页面上就会显示index.html的内容。用户按下显示onclick test的按钮，通过javascript的ajax发送一个包含一个字符串“showUser.do”和一个KV对“id = 1”的一个请求到controller，controller再根据请求中的“showUser.do”调用对应的controller方法。​&lt;strong&gt;这个过程从View层到Controller层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3&lt;/code&gt; 请求来到Cotroller，通过扫描在Spring-MVC.xml中配置的目录下的所有的Java类。找到这个目录下所有带有@Controller的类。在这些类中寻找“showUser.do”对应的方法。在Controller类的第24行找到了一个selectUser方法。那么就会执行这个方法，对来自View层的请求进行响应。&lt;strong&gt;这个过程发生在Controller层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4&lt;/code&gt; 找到这个方法了，开始执行。这个方法的核心在于，使用了userService这个对象以及它的的方法。关于如何使用的，在2.3.3中有详细的解释。在在这个类中，使用这个对象以及它的seclectUser方法，就是&lt;strong&gt;工作从Controller层到Model层的转移。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5&lt;/code&gt; 来到Model层，映入眼帘的就是Service接口的实现类ServiceImple。我们不关注Service接口，经过我的测试，去掉这个接口对程序的运行也没有影响。但是这个接口的存在，可以使Service方法更加规范化。在大型工程中，有一个这样的接口可以更加规范。在这个ServiceImple类中，申明了一个UserDAO的对象，这个对象并没有实体。通过注解，将UserDAO.xml作为这个接口的实体，使用定义在UserDAO.xml中的sql语句操作数据库。&lt;/p&gt;
&lt;p&gt;sql语句和UserDAO的对应，通过在spring-mybatis.xml中，将mapper的目录和DAO接口的目录配置进去。这样在mapper的xml中，声明是对哪一个DAO接口的实现，并且在每一个sql方法的标签内，设置id为对应的DAO接口中的方法名，就可以视作将DAO的方法在mapper的xml中实现了。&lt;/p&gt;
&lt;p&gt;通过目录、接口名、方法名的一系列配置，在调用UserDAO接口的方法的时候，就可以直接使用对应的sql语句。以：&lt;/p&gt;

&lt;p&gt;然后在UserServiceImple中，调用UserDAO的方法：&lt;/p&gt;

&lt;p&gt;在通过DAO的配置，使用UserDAO.xml中的sql语句操作数据库。&lt;/p&gt;
&lt;p&gt;这个部分的操作&lt;strong&gt;都是在Model层&lt;/strong&gt;。但是将Model层分为两个模块：service和DAO的话，那么这个部分是&lt;strong&gt;在Model层中是从service到DAO的转移&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;6&lt;/code&gt; 我们忽略mapper的xml文件中具体执行了什么。只考虑对数据库操作之后有没有数据的返回。&lt;/p&gt;
&lt;p&gt;如果没有，那么一个从前到后的SSM请求到响应就已经结束了。&lt;/p&gt;
&lt;p&gt;大多数时候是有返回的。通过mapper的xml文件中的result设定的返回值类型，将从数据库中获取的数值，包装成一个返回类型，返回给UserServiceImple的对象。&lt;/p&gt;
&lt;p&gt;在这个例子中是从数据库中获取指定id处的，一个User对象的所有信息，将其包装成一个User对象，返回给UserServiceImple。&lt;/p&gt;
&lt;p&gt;这个部分的操作&lt;strong&gt;都是在Model层，细分的话那么这个部分是在Model层中是从DAO到service的转移&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;7&lt;/code&gt; UserServiceImple对象将从DAO获得了一个User对象的返回值，返回给Controller层。&lt;/p&gt;
&lt;p&gt;这一个操作是从&lt;strong&gt;Model层返回到Controller层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;8&lt;/code&gt; 这样的一个User对象从DAO、Service传递了Controller层中由“showUser.do”对应的那个方法中继续着下一步的操作。&lt;/p&gt;
&lt;p&gt;通过下面两行语句，将获取的User对象转换成一个字符串，然后传送到javascript代码中请求所对应的响应码responseText中。&lt;/p&gt;

&lt;p&gt;然后通过DOM操作，将html中的某个字段修改成User对象的字符串形式。完成了获取内容在页面上的显示。这一步是&lt;strong&gt;从Controller层到View层的传递&lt;/strong&gt;。&lt;/p&gt;









&lt;/div&gt;</description>
<pubDate>Wed, 02 Jan 2019 12:48:00 +0000</pubDate>
<dc:creator>小徐同学是个coder</dc:creator>
<og:description>今天头一次配置成功一个SSM框架，兴奋之余，还应该从使用的角度，将整个ssm配置的方法，配置的原因，认真的分析一下。在结束了对SSM框架简单的分析之后，就要开始回归基础，全面的认真复习。所以这个文档，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjxu97/p/10211203.html</dc:identifier>
</item>
</channel>
</rss>