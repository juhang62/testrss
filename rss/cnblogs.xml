<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深度学习在推荐系统的应用(二) - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/DL4REC2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/DL4REC2.html</guid>
<description>&lt;h3 id=&quot;afm模型attentional-factorization-machine&quot;&gt;AFM模型(Attentional Factorization Machine)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ ŷ_{AFM}(x)=ω_0+∑_{i=1}^{n}ω_{i}x_{i}+p^T∑^{n}_{i=1}∑^{n}_{j=i+1}a_{ij}(v_i⊙v_j)x_ix_j \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;fwfm模型field-weighted-factorization-machines&quot;&gt;FwFM模型(Field-weighted Factorization Machines)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Φ_{FwFMs}((w,v), x) = w_{0} +∑_{i=1}^{m}x_iw_i +∑_{i=1}^{m}∑_{j=i+1}^{m}x_ix_j⟨v_i,v_j⟩r_{F (i),F (j)} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;fwfm模型field-weighted-factorization-machines-1&quot;&gt;FwFM模型(Field-weighted Factorization Machines)&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ Φ_{FwFMs}((w,v), x) = w_{0} +∑_{i=1}^{m}x_iw_i +∑_{i=1}^{m}∑_{j=i+1}^{m}x_ix_j⟨v_i,v_j⟩r_{F (i),F (j)} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.4017632241814&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;模型特点&lt;br/&gt;FwFM是在WWW'18上由Oath公司提出的点击率预估模型，针对FFM参数量大的不足提出了改进并在著名的公开数据集Criteo上验证有效。从模型形式上可以看出FwFM与FM区别仅在于FwFM给每个二阶交叉项引入了一个实数weight:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ r_{F (i),F (j)} \]&lt;/span&gt;&lt;br/&gt;总计多出m*(m-1)/2个参数,m是field个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.31578947368421&quot;&gt;
&lt;p&gt;模型案例&lt;br/&gt;&lt;a href=&quot;https://github.com/Tongzhenguo/Python-Project/blob/master/ctr_model/FwFM.py&quot;&gt;Tongzhenguo/Python-Project&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;xdeepfm极深因子分解机模型&quot;&gt;xDeepFM(极深因子分解机模型)&lt;/h3&gt;
&lt;p&gt;1.CIN结构:&lt;br/&gt;&lt;img src=&quot;https://yangxudong.github.io/xdeepfm/CIN.png&quot; alt=&quot;CIN结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.矩阵&lt;span class=&quot;math display&quot;&gt;\[𝑋^𝑘\]&lt;/span&gt;中的第ℎ行的计算公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ X_{h,*}^k = \sum_{i=1}^{H_{k-1}}\sum_{j=1}^m{W_{ij}^{k,h}(X_{i,*}^{k-1} \circ X_{j,*}^0)} \]&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>### AFM模型(Attentional Factorization Machine) ### FwFM模型(Field-weighted Factorization Machines) #</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arachis/p/DL4REC2.html</dc:identifier>
</item>
<item>
<title>线程池优化之充分利用线程池资源 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/10660479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10660479.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　最近做了电子发票的需求，分省开票接口和发票下载接口都有一定的延迟。为了完成开票后自动将发票插入用户微信卡包，目前的解决方案是利用线程池，将开票后插入卡包的任务（轮询分省发票接口，直到获取到发票相关信息或者轮询次数用完，如果获取到发票信息，执行发票插入微信卡包，结束任务）放入线程池异步执行。仔细想一想，这种实现方案存在一个问题，线程池没有充分的利用。为什么没有充分的利用？下面详细的分析。&lt;/p&gt;
&lt;h2&gt;二、异步线程池和异步任务包装&lt;/h2&gt;
&lt;p&gt;　　AsyncConfigurerSupport可以帮我们指定异步任务（注有@Async注解）对应的线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyAsyncConfigurer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AsyncConfigurerSupport {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(MyAsyncConfigurer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor taskExecutor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(&lt;/span&gt;2&lt;span&gt;);
        taskExecutor.setMaxPoolSize(&lt;/span&gt;4&lt;span&gt;);
        taskExecutor.setQueueCapacity(&lt;/span&gt;10&lt;span&gt;);
        taskExecutor.setRejectedExecutionHandler((runnable, executor) &lt;/span&gt;-&amp;gt; LOGGER.error(&quot;异步线程池拒绝任务...&quot; +&lt;span&gt; runnable));
        taskExecutor.setThreadFactory(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyAsyncThreadFactory());
        taskExecutor.initialize();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskExecutor;
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyAsyncThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

        MyAsyncThreadFactory() {
            SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
            group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() :
                    Thread.currentThread().getThreadGroup();
            namePrefix &lt;/span&gt;= &quot;myasync-pool-&quot; +&lt;span&gt;
                    poolNumber.getAndIncrement() &lt;/span&gt;+
                    &quot;-thread-&quot;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(group, r,
                    namePrefix &lt;/span&gt;+&lt;span&gt; threadNumber.getAndIncrement(),
                    &lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon())
                t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　异步任务包装，除了异步，还加入了retry功能，实现指定次数的接口轮询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncWrapped {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(AsyncWrapped.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Async
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; asyncProcess(Runnable runnable, Callback callback, Retry retry) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (retry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                retry &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Retry(1&lt;span&gt;);
            }
            retry.execute(ctx &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                runnable.run();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }, ctx &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    callback.call();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            });
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;异步调用异常...&quot;&lt;span&gt;, e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务代码大致逻辑如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
asyncWrapped.asyncProcess(() -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用分省接口获取发票信息
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发票信息异常，抛出异常（进入下次重试）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，插入用户微信卡包&lt;/span&gt;
    }, () -&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮询次数用尽，用户插入卡包失败&lt;/span&gt;
&lt;span&gt;    }
    , &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Retry(2, 1000&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里说一下为什么线程池没有充分的利用。异步任务中包含轮询操作，轮询有一定的时间间隔，导致在这段时间间隔内，线程一直处于被闲置的状态。所以为了能更好的利用线程池资源，我们得想办法解决时间间隔的问题。假如有个延迟队列，队列里放着我们的异步任务（不包含重试机制），然后延迟（轮询的时间间隔）一定时间之后，将任务放入线程池中执行，任务执行完毕之后根据是否需要再次执行决定是否再次放入到延迟队列去，这样每个线程池中的线程都不会闲着，达到了充分利用的目的。&lt;/p&gt;
&lt;h2&gt;三、定时任务线程池和实现轮询机制&lt;/h2&gt;
&lt;p&gt;　　@EnableScheduling 帮助开启@Scheduled注解解析。注册一个名字是ScheduledAnnotationBeanPostProcessor.DEFAULT_TASK_SCHEDULER_BEAN_NAME的定时任务线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableScheduling
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskConfiguration {

    @Bean(name &lt;/span&gt;=&lt;span&gt; ScheduledAnnotationBeanPostProcessor.DEFAULT_TASK_SCHEDULER_BEAN_NAME)
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ScheduledExecutorService scheduledAnnotationProcessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Executors.newScheduledThreadPool(5, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultThreadFactory());
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
            group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() :
                    Thread.currentThread().getThreadGroup();
            namePrefix &lt;/span&gt;= &quot;pool-&quot; +&lt;span&gt;
                    poolNumber.getAndIncrement() &lt;/span&gt;+
                    &quot;-schedule-&quot;&lt;span&gt;;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(group, r,
                    namePrefix &lt;/span&gt;+&lt;span&gt; threadNumber.getAndIncrement(),
                    &lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon()) {
                t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY) {
                t.setPriority(Thread.NORM_PRIORITY);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　实现轮询任务，实现接口SchedulingConfigurer，获取ScheduledTaskRegistrar 并指定定时任务线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureTasks(ScheduledTaskRegistrar registrar) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.registrar =&lt;span&gt; registrar;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.registrar.setScheduler(&lt;span&gt;this&lt;/span&gt;.applicationContext.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, ScheduledExecutorService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    scheduledTaskRegistrarHelper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScheduledTaskRegistrarHelper();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　scheduledFutures提交定时任务时返回结果集，periodTasks 定时任务结果集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentHashMap&amp;lt;String, TimingTask&amp;gt; periodTasks = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定时任务包装类，包含任务的执行次数（重试次数）、重试间隔、具体任务、重试次数用尽之后的回调等，以及自动结束定时任务、重试计数重置功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimingTask {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer retry;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务标识&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String taskId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试间隔&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long period;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ScheduledRunnable task;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束回调&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ScheduledCallback callback;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试计数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父线程MDC&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; curContext;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimingTask(Integer retry, String taskId, Long period, ScheduledRunnable task, ScheduledCallback callback) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.retry =&lt;span&gt; retry;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId =&lt;span&gt; taskId;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.period =&lt;span&gt; period;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.task =&lt;span&gt; task;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.callback =&lt;span&gt; callback;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.curContext =&lt;span&gt; MDC.getCopyOfContextMap();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getPeriod() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; period;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPeriod(Long period) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.period =&lt;span&gt; period;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTaskId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTaskId(String taskId) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId =&lt;span&gt; taskId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getRetry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retry;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRetry(Integer retry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.retry =&lt;span&gt; retry;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicInteger getCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; reset() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;this&lt;/span&gt;.count.intValue(); cnt &amp;lt; &lt;span&gt;this&lt;/span&gt;.retry; cnt = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count.intValue()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count.compareAndSet(cnt, 0&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process() {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; preContext =&lt;span&gt; MDC.getCopyOfContextMap();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.curContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                MDC.clear();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将父线程的MDC内容传给子线程&lt;/span&gt;
                MDC.setContextMap(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.curContext);
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.task.run();
            exitTask(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;定时任务异常...&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count.incrementAndGet() &amp;gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retry) {
                exitTask(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                MDC.clear();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                MDC.setContextMap(preContext);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时任务退出&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exitTask(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; execCallback) {
        scheduledFutures.get(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskId).cancel(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        scheduledFutures.remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTaskId());
        periodTasks.remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTaskId());
        LOGGER.info(&lt;/span&gt;&quot;结束定时任务: &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (execCallback &amp;amp;&amp;amp; callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            callback.call();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                , ToStringStyle.JSON_STYLE
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , TimingTask.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意上面定时任务是如何退出的，是在某一次任务执行成功之后（没有异常抛出）或者定时任务执行次数用尽才退出的。直接调用ScheduledFuture的cancel方法可以退出定时任务。还有就是定时任务中的日志需要父线程中的日志变量，所以需要对MDC进行一下处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Scope(&quot;prototype&quot;&lt;span&gt;)
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AspectTimingTask aspectTimingTask() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AspectTimingTask();
}

@Aspect
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScheduledAspect {
    @Around(&lt;/span&gt;&quot;target(AspectTimingTask)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object executeScheduledWrapped(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proceedingJoinPoint &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MethodInvocationProceedingJoinPoint) {
            MethodInvocationProceedingJoinPoint methodJoinPoint &lt;/span&gt;=&lt;span&gt; (MethodInvocationProceedingJoinPoint) proceedingJoinPoint;
            Method method &lt;/span&gt;=&lt;span&gt; ((MethodSignature) methodJoinPoint.getSignature()).getMethod();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AnnotatedElementUtils.isAnnotated(method, ScheduledTask.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                LOGGER.info(&lt;/span&gt;&quot;电子发票定时任务日志同步...&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他处理&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proceedingJoinPoint.proceed();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AspectTimingTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TimingTask timingTask;

    @Override
    @ScheduledTask
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        timingTask.process();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTimingTask(TimingTask timingTask) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.timingTask =&lt;span&gt; timingTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　AspectTimingTask 是对TimingTask 的包装类，实现了Runnable接口。主要是为了对run接口做一层切面，获取ProceedingJoinPoint 实例（公司中的日志调用链系统需要这个参数）。AspectTimingTask 的bean实例的scope是prototype，这个注意下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; register(Integer retry
        , Long period
        , String taskId
        , ScheduledRunnable task
        , ScheduledCallback callback) {
    scheduledTaskRegistrarHelper.register(retry, taskId, period, task, callback);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScheduledTaskRegistrarHelper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; register(Integer retry
            , String taskId
            , Long period
            , ScheduledRunnable task
            , ScheduledCallback callback) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否可以重置定时任务&lt;/span&gt;
        TimingTask preTask =&lt;span&gt; periodTasks.get(taskId);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; preTask
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; preTask.reset()
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; existTask(taskId)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        TimingTask curTask &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimingTask(retry, taskId, period, task, callback);
        AspectTimingTask aspectTimingTask &lt;/span&gt;= applicationContext.getBean(AspectTimingTask.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        aspectTimingTask.setTimingTask(curTask);
        ScheduledFuture&lt;/span&gt;&amp;lt;?&amp;gt; scheduledFuture =&lt;span&gt; registrar.getScheduler().scheduleAtFixedRate(aspectTimingTask, period);
        scheduledFutures.put(taskId, scheduledFuture);
        periodTasks.put(taskId, curTask);
        LOGGER.info(&lt;/span&gt;&quot;注册定时任务: &quot; +&lt;span&gt; curTask);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; existTask(String taskId) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; scheduledFutures.containsKey(taskId) &amp;amp;&amp;amp;&lt;span&gt; periodTasks.containsKey(taskId);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果taskId的定时任务已经存在则重置定时任务，否则注册新的定时任务。AspectTimingTask 实例通过ApplicationContext获取，每次获取都是一个新的实例。&lt;/p&gt;
&lt;p&gt;　　由 异步轮询任务 优化成 定时任务，充分利用了线程池。修改之后的业务代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
ScheduledTaskRegistrarHelper.register(10&lt;span&gt;
    , 5*&lt;/span&gt;1000L&lt;span&gt;
    , &lt;/span&gt;&quot;taskId&quot;&lt;span&gt;
    , () &lt;/span&gt;-&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用分省接口获取发票信息
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果发票信息异常，抛出异常（进入下次重试）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则，插入用户微信卡包&lt;/span&gt;
&lt;span&gt;    }
    () &lt;/span&gt;-&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮询次数用尽，用户插入卡包失败&lt;/span&gt;
&lt;span&gt;    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　针对电子发票插入微信卡包定时任务，重试执行次数10次，每隔5秒执行一次。任务完成之后结束定时任务，执行次数用尽之后触发插入卡包失败动作。&lt;/p&gt;
&lt;h2&gt;四、参考　　&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;     &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hujunzheng/p/10549849.html&quot;&gt;Spring异步调用原理及SpringAop拦截器链原理&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hujunzheng/p/10353390.html&quot;&gt;Springboot定时任务原理及如何动态创建定时任务&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 15:08:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、前言 最近做了电子发票的需求，分省开票接口和发票下载接口都有一定的延迟。为了完成开票后自动将发票插入用户微信卡包，目前的解决方案是利用线程池，将开票后插入卡包的任务（轮询分省发票接口，直到获取到发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10660479.html</dc:identifier>
</item>
<item>
<title>SpringBoot中异步请求和异步调用（看这一篇就够了） - 会炼钢的小白龙</title>
<link>http://www.cnblogs.com/baixianlong/p/10661591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baixianlong/p/10661591.html</guid>
<description>&lt;h2 id=&quot;异步请求与同步请求&quot;&gt;1、异步请求与同步请求&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/xianlongbai/Static-Resources/blob/master/image/22906052.png?raw=true&quot; alt=&quot;同步请求&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://github.com/xianlongbai/Static-Resources/blob/master/image/71641059.png?raw=true&quot; alt=&quot;异步请求&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点：&lt;/h3&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;可以先释放容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其响应将被延后，可以在耗时处理完成（例如长时间的运算）时再对客户端进行响应。&lt;span&gt;一句话：增加了服务器对客户端请求的吞吐量&lt;/span&gt;（实际生产上我们用的比较少，如果并发请求量很大的情况下，我们会通过nginx把请求负载到集群服务的各个节点上来分摊请求压力，当然还可以通过消息队列来做请求的缓冲）。&lt;/p&gt;
&lt;h2 id=&quot;异步请求的实现&quot;&gt;2、异步请求的实现&lt;/h2&gt;
&lt;h3 id=&quot;方式一servlet方式实现异步请求&quot;&gt;方式一：Servlet方式实现异步请求&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  @RequestMapping(value = &quot;/email/servletReq&quot;, method = GET)
  public void servletReq (HttpServletRequest request, HttpServletResponse response) {
      AsyncContext asyncContext = request.startAsync();
      //设置监听器:可设置其开始、完成、异常、超时等事件的回调处理
      asyncContext.addListener(new AsyncListener() {
          @Override
          public void onTimeout(AsyncEvent event) throws IOException {
              System.out.println(&quot;超时了...&quot;);
              //做一些超时后的相关操作...
          }
          @Override
          public void onStartAsync(AsyncEvent event) throws IOException {
              System.out.println(&quot;线程开始&quot;);
          }
          @Override
          public void onError(AsyncEvent event) throws IOException {
              System.out.println(&quot;发生错误：&quot;+event.getThrowable());
          }
          @Override
          public void onComplete(AsyncEvent event) throws IOException {
              System.out.println(&quot;执行完成&quot;);
              //这里可以做一些清理资源的操作...
          }
      });
      //设置超时时间
      asyncContext.setTimeout(20000);
      asyncContext.start(new Runnable() {
          @Override
          public void run() {
              try {
                  Thread.sleep(10000);
                  System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
                  asyncContext.getResponse().setCharacterEncoding(&quot;utf-8&quot;);
                  asyncContext.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;);
                  asyncContext.getResponse().getWriter().println(&quot;这是异步的请求返回&quot;);
              } catch (Exception e) {
                  System.out.println(&quot;异常：&quot;+e);
              }
              //异步请求完成通知
              //此时整个请求才完成
              asyncContext.complete();
          }
      });
      //此时之类 request的线程连接已经释放了
      System.out.println(&quot;主线程：&quot; + Thread.currentThread().getName());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方式二使用很简单直接返回的参数包裹一层callable即可可以继承webmvcconfigureradapter类来设置默认线程池和超时处理&quot;&gt;方式二：使用很简单，直接返回的参数包裹一层callable即可，可以继承WebMvcConfigurerAdapter类来设置默认线程池和超时处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  @RequestMapping(value = &quot;/email/callableReq&quot;, method = GET)
  @ResponseBody
  public Callable&amp;lt;String&amp;gt; callableReq () {
      System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());

      return new Callable&amp;lt;String&amp;gt;() {

          @Override
          public String call() throws Exception {
              Thread.sleep(10000);
              System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
              return &quot;callable!&quot;;
          }
      };
  }

  @Configuration
  public class RequestAsyncPoolConfig extends WebMvcConfigurerAdapter {

  @Resource
  private ThreadPoolTaskExecutor myThreadPoolTaskExecutor;

  @Override
  public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {
      //处理 callable超时
      configurer.setDefaultTimeout(60*1000);
      configurer.setTaskExecutor(myThreadPoolTaskExecutor);
      configurer.registerCallableInterceptors(timeoutCallableProcessingInterceptor());
  }

  @Bean
  public TimeoutCallableProcessingInterceptor timeoutCallableProcessingInterceptor() {
      return new TimeoutCallableProcessingInterceptor();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方式三和方式二差不多在callable外包一层给webasynctask设置一个超时回调即可实现超时处理&quot;&gt;方式三：和方式二差不多，在Callable外包一层，给WebAsyncTask设置一个超时回调，即可实现超时处理&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    @RequestMapping(value = &quot;/email/webAsyncReq&quot;, method = GET)
    @ResponseBody
    public WebAsyncTask&amp;lt;String&amp;gt; webAsyncReq () {
        System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());
        Callable&amp;lt;String&amp;gt; result = () -&amp;gt; {
            System.out.println(&quot;内部线程开始：&quot; + Thread.currentThread().getName());
            try {
                TimeUnit.SECONDS.sleep(4);
            } catch (Exception e) {
                // TODO: handle exception
            }
            logger.info(&quot;副线程返回&quot;);
            System.out.println(&quot;内部线程返回：&quot; + Thread.currentThread().getName());
            return &quot;success&quot;;
        };
        WebAsyncTask&amp;lt;String&amp;gt; wat = new WebAsyncTask&amp;lt;String&amp;gt;(3000L, result);
        wat.onTimeout(new Callable&amp;lt;String&amp;gt;() {

            @Override
            public String call() throws Exception {
                // TODO Auto-generated method stub
                return &quot;超时&quot;;
            }
        });
        return wat;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方式四deferredresult可以处理一些相对复杂一些的业务逻辑最主要还是可以在另一个线程里面进行业务处理及返回即可在两个完全不相干的线程间的通信&quot;&gt;方式四：DeferredResult可以处理一些相对复杂一些的业务逻辑，最主要还是可以在另一个线程里面进行业务处理及返回，即可在两个完全不相干的线程间的通信。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@RequestMapping(value = &quot;/email/deferredResultReq&quot;, method = GET)
    @ResponseBody
    public DeferredResult&amp;lt;String&amp;gt; deferredResultReq () {
        System.out.println(&quot;外部线程：&quot; + Thread.currentThread().getName());
        //设置超时时间
        DeferredResult&amp;lt;String&amp;gt; result = new DeferredResult&amp;lt;String&amp;gt;(60*1000L);
        //处理超时事件 采用委托机制
        result.onTimeout(new Runnable() {

            @Override
            public void run() {
                System.out.println(&quot;DeferredResult超时&quot;);
                result.setResult(&quot;超时了!&quot;);
            }
        });
        result.onCompletion(new Runnable() {

            @Override
            public void run() {
                //完成后
                System.out.println(&quot;调用完成&quot;);
            }
        });
        myThreadPoolTaskExecutor.execute(new Runnable() {

            @Override
            public void run() {
                //处理业务逻辑
                System.out.println(&quot;内部线程：&quot; + Thread.currentThread().getName());
                //返回结果
                result.setResult(&quot;DeferredResult!!&quot;);
            }
        });
       return result;
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;介绍&quot;&gt;1、介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;5.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;异步请求的处理。除了异步请求，一般上我们用的比较多的应该是异步调用。通常在开发过程中，会遇到一个方法是和实际业务无关的，没有紧密性的。比如记录日志信息等业务。这个时候正常就是启一个新线程去做一些业务处理，让主线程异步的执行其他业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方式基于spring下&quot;&gt;2、使用方式（基于spring下）&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;需要在启动类加入@EnableAsync使异步调用@Async注解生效&lt;/li&gt;
&lt;li&gt;在需要异步执行的方法上加入此注解即可@Async(&quot;threadPool&quot;),threadPool为自定义线程池&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码略。。。就俩标签，自己试一把就可以了&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;3、注意事项&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;在默认情况下，未设置TaskExecutor时，默认是使用SimpleAsyncTaskExecutor这个线程池，但此线程不是真正意义上的线程池，因为线程不重用，每次调用都会创建一个新的线程。可通过控制台日志输出可以看出，每次输出线程名都是递增的。所以最好我们来自定义一个线程池。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;调用的异步方法，不能为同一个类的方法（包括同一个类的内部类），简单来说，因为Spring在启动扫描时会为其创建一个代理类，而同类调用时，还是调用本身的代理类的，所以和平常调用是一样的。其他的注解如@Cache等也是一样的道理，说白了，就是Spring的代理机制造成的。所以在开发中，最好把异步服务单独抽出一个类来管理。下面会重点讲述。。&lt;/p&gt;
&lt;h2 id=&quot;什么情况下会导致async异步方法会失效&quot;&gt;4、什么情况下会导致@Async异步方法会失效？&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;7.5&quot;&gt;&lt;li&gt;&lt;span&gt;调用同一个类下注有@Async异步方法&lt;/span&gt;：在spring中像@Async和@Transactional、cache等注解本质使用的是动态代理，其实Spring容器在初始化的时候Spring容器会将含有AOP注解的类对象“替换”为代理对象（简单这么理解），那么注解失效的原因就很明显了，就是因为调用方法的是对象本身而不是代理对象，因为没有经过Spring容器，那么解决方法也会沿着这个思路来解决。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用的是静态(static )方法&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;调用(private)私有化方法&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决4中问题1的方式其它23两个问题自己注意下就可以了&quot;&gt;5、解决4中问题1的方式（其它2,3两个问题自己注意下就可以了）&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将要异步执行的方法单独抽取成一个类&lt;/span&gt;，原理就是当你把执行异步的方法单独抽取成一个类的时候，这个类肯定是被Spring管理的，其他Spring组件需要调用的时候肯定会注入进去，这时候实际上注入进去的就是代理类了。&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;其实我们的注入对象都是从Spring容器中给当前Spring组件进行成员变量的赋值，由于某些类使用了AOP注解，那么实际上在Spring容器中实际存在的是它的代理对象。那么我们就可以&lt;span&gt;通过上下文获取自己的代理对象调用异步方法&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/app&quot;)
public class EmailController {

    //获取ApplicationContext对象方式有多种,这种最简单,其它的大家自行了解一下
    @Autowired
    private ApplicationContext applicationContext;

    @RequestMapping(value = &quot;/email/asyncCall&quot;, method = GET)
    @ResponseBody
    public Map&amp;lt;String, Object&amp;gt; asyncCall () {
        Map&amp;lt;String, Object&amp;gt; resMap = new HashMap&amp;lt;String, Object&amp;gt;();
        try{
            //这样调用同类下的异步方法是不起作用的
            //this.testAsyncTask();
            //通过上下文获取自己的代理对象调用异步方法
            EmailController emailController = (EmailController)applicationContext.getBean(EmailController.class);
            emailController.testAsyncTask();
            resMap.put(&quot;code&quot;,200);
        }catch (Exception e) {
            resMap.put(&quot;code&quot;,400);
            logger.error(&quot;error!&quot;,e);
        }
        return resMap;
    }

    //注意一定是public,且是非static方法
    @Async
    public void testAsyncTask() throws InterruptedException {
        Thread.sleep(10000);
        System.out.println(&quot;异步任务执行完成！&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开启cglib代理，手动获取Spring代理类&lt;/span&gt;,从而调用同类下的异步方法。
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;首先，在启动类上加上&lt;span&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/span&gt;注解。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;代码实现，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
@Transactional(value = &quot;transactionManager&quot;, readOnly = false, propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)
public class EmailService {

    @Autowired
    private ApplicationContext applicationContext;

    @Async
    public void testSyncTask() throws InterruptedException {
        Thread.sleep(10000);
        System.out.println(&quot;异步任务执行完成！&quot;);
    }


    public void asyncCallTwo() throws InterruptedException {
        //this.testSyncTask();
//        EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);
//        emailService.testSyncTask();
        boolean isAop = AopUtils.isAopProxy(EmailController.class);//是否是代理对象；
        boolean isCglib = AopUtils.isCglibProxy(EmailController.class);  //是否是CGLIB方式的代理对象；
        boolean isJdk = AopUtils.isJdkDynamicProxy(EmailController.class);  //是否是JDK动态代理方式的代理对象；
        //以下才是重点!!!
        EmailService emailService = (EmailService)applicationContext.getBean(EmailService.class);
        EmailService proxy = (EmailService) AopContext.currentProxy();
        System.out.println(emailService == proxy ? true : false);
        proxy.testSyncTask();
        System.out.println(&quot;end!!!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;两者的使用场景不同，异步请求用来解决并发请求对服务器造成的压力，从而提高对请求的吞吐量；而异步调用是用来做一些非主线流程且不需要实时计算和响应的任务，比如同步日志到kafka中做日志分析等。&lt;/li&gt;
&lt;li&gt;异步请求是会一直等待response相应的，需要返回结果给客户端的；而异步调用我们往往会马上返回给客户端响应，完成这次整个的请求，至于异步调用的任务后台自己慢慢跑就行，客户端不会关心。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;异步请求和异步调用的使用到这里基本就差不多了，有问题还希望大家多多指出。&lt;/li&gt;
&lt;li&gt;这边文章提到了动态代理，而spring中Aop的实现原理就是动态代理，后续会对动态代理做详细解读，还望多多支持哈~&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;2.0412371134021&quot;&gt;
&lt;p&gt;个人博客地址：&lt;/p&gt;
&lt;blockquote readability=&quot;2.3023255813953&quot;&gt;
&lt;p&gt;csdn:&lt;a href=&quot;https://blog.csdn.net/tiantuo6513&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/tiantuo6513&lt;/a&gt;&lt;br/&gt;cnblogs:&lt;a href=&quot;https://www.cnblogs.com/baixianlong&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/baixianlong&lt;/a&gt;&lt;br/&gt;segmentfault:&lt;a href=&quot;https://segmentfault.com/u/baixianlong&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/u/baixianlong&lt;/a&gt;&lt;br/&gt;github:https://github.com/xianlongbai&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 06 Apr 2019 14:33:00 +0000</pubDate>
<dc:creator>会炼钢的小白龙</dc:creator>
<og:description>一、SpringBoot中异步请求的使用 1、异步请求与同步请求 特点： 可以先释放容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其响应将被延后，可以在耗时处理完成（例如长</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baixianlong/p/10661591.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——88. 防御性地编写READOBJECT方法 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10663149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10663149.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：https://github.com/jbloch/effective-java-3e-source-code&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;条目 50 里有一个不可变的日期范围类，它包含一个可变的私有Date属性。 该类通过在其构造方法和访问器中防御性地拷贝Date对象，竭尽全力维持其不变性（invariants and immutability）。 代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Immutable class that uses defensive copying
public final class Period {

    private final Date start;
    private final Date end;

    /**
     * @param  start the beginning of the period
     * @param  end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end   = new Date(end.getTime());
        if (this.start.compareTo(this.end) &amp;gt; 0)
            throw new IllegalArgumentException(
                          start + &quot; after &quot; + end);
    }

    public Date start () { return new Date(start.getTime()); }

    public Date end () { return new Date(end.getTime()); }

    public String toString() { return start + &quot; - &quot; + end; }

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设要把这个类可序列化。由于&lt;code&gt;Period&lt;/code&gt;对象的物理表示精确地反映了它的逻辑数据内容，所以使用默认的序列化形式是合理的(条目 87)。因此，要使类可序列化，似乎只需将implements Serializable 添加到类声明中就可以了。但是，如果这样做，该类不再保证它的关键不变性了。&lt;/p&gt;
&lt;p&gt;问题是readObject方法实际上是另一个公共构造方法，它需要与任何其他构造方法一样的小心警惕。 正如构造方法必须检查其参数的有效性（条目 49）并在适当的地方对参数防御性拷贝（条目 50），readObject方法也要这样做。 如果readObject方法无法执行这两个操作中的任何一个，则攻击者违反类的不变性是相对简单的事情。&lt;/p&gt;
&lt;p&gt;简而言之，readObject是一个构造方法，它将字节流作为唯一参数。 在正常使用中，字节流是通过序列化正常构造的实例生成的。当readObject展现一个字节流时，问题就出现了，这个字节流是人为构造的，用来生成一个违反类不变性的对象。 这样的字节流可用于创建一个不可能的对象，该对象无法使用普通构造方法创建。&lt;/p&gt;
&lt;p&gt;假设我们只是将&lt;code&gt;implements Serializablet&lt;/code&gt;添加到&lt;code&gt;Period&lt;/code&gt;类声明中。 然后，这个丑陋的程序生成一个Period实例，其结束时间在其开始时间之前。 对byte类型的值进行强制转换，其高阶位被设置，这是由于Java缺乏byte字面量，并且错误地决定对byte类型进行签名:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BogusPeriod {
  // Byte stream couldn't have come from a real Period instance!
  private static final byte[] serializedForm = {
    (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,
    0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,
    0x2b, 0x4f, 0x46, (byte)0xc0, (byte)0xf4, 0x02, 0x00, 0x02,
    0x4c, 0x00, 0x03, 0x65, 0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c,
    0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f,
    0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c, 0x00, 0x05, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00, 0x01, 0x78, 0x70,
    0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75,
    0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68, 0x6a,
    (byte)0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00,
    0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte)0xdf,
    0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03,
    0x77, 0x08, 0x00, 0x00, 0x00, (byte)0xd5, 0x17, 0x69, 0x22,
    0x00, 0x78
  };

  public static void main(String[] args) {
    Period p = (Period) deserialize(serializedForm);
    System.out.println(p);
  }

  // Returns the object with the specified serialized form
  static Object deserialize(byte[] sf) {
    try {
      return new ObjectInputStream(
          new ByteArrayInputStream(sf)).readObject();
    } catch (IOException | ClassNotFoundException e) {
      throw new IllegalArgumentException(e);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于初始化serializedForm的字节数组字面量（literal）是通过序列化正常的Period实例，并手动编辑生成的字节流生成的。 流的细节对于该示例并不重要，但是如果好奇，则在《Java Object Serialization Specification》[序列化，6]中描述了序列化字节流格式。 如果运行此程序，它会打印&lt;code&gt;Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984&lt;/code&gt;。只需声明&lt;code&gt;Period&lt;/code&gt;类为可序列化，我们就可以创建一个违反其类不变性的对象。&lt;/p&gt;
&lt;p&gt;要解决此问题，请为Period提供一个readObject方法，该方法调用defaultReadObject，然后检查反序列化对象的有效性。如果有效性检查失败，readObject方法抛出InvalidObjectException异常，阻止反序列化完成:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// readObject method with validity checking - insufficient!
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // Check that our invariants are satisfied
    if (start.compareTo(end) &amp;gt; 0)
        throw new InvalidObjectException(start +&quot; after &quot;+ end);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这样可以防止攻击者创建无效的Period实例，但仍然存在潜在的更微妙的问题。 可以通过构造以有效Period实例开头的字节流来创建可变Period实例，然后将额外引用附加到Period实例内部的私有Date属性。 攻击者从ObjectInputStream中读取Period实例，然后读取附加到流的“恶意对象引用”。 这些引用使攻击者可以访问Period对象中私有Date属性引用的对象。 通过改变这些Date实例，攻击者可以改变Period实例。 以下类演示了这种攻击：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MutablePeriod {
    // A period instance
    public final Period period;

    // period's start field, to which we shouldn't have access
    public final Date start;

    // period's end field, to which we shouldn't have access
    public final Date end;

    public MutablePeriod() {
        try {
            ByteArrayOutputStream bos =
                new ByteArrayOutputStream();
            ObjectOutputStream out =
                new ObjectOutputStream(bos);
            // Serialize a valid Period instance
            out.writeObject(new Period(new Date(), new Date()));

            /*
             * Append rogue &quot;previous object refs&quot; for internal
             * Date fields in Period. For details, see &quot;Java
             * Object Serialization Specification,&quot; Section 6.4.
             */
            byte[] ref = { 0x71, 0, 0x7e, 0, 5 };  // Ref #5
            bos.write(ref); // The start field
            ref[4] = 4;     // Ref # 4
            bos.write(ref); // The end field

            // Deserialize Period and &quot;stolen&quot; Date references
            ObjectInputStream in = new ObjectInputStream(
                new ByteArrayInputStream(bos.toByteArray()));
            period = (Period) in.readObject();
            start  = (Date)   in.readObject();
            end    = (Date)   in.readObject();
        } catch (IOException | ClassNotFoundException e) {
            throw new AssertionError(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要查看正在进行的攻击，请运行以下程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    MutablePeriod mp = new MutablePeriod();
    Period p = mp.period;
    Date pEnd = mp.end;

    // Let's turn back the clock
    pEnd.setYear(78);
    System.out.println(p);

    // Bring back the 60s!
    pEnd.setYear(69);
    System.out.println(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我的语言环境中，运行此程序会产生以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978
Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然创建了Period实例且保持了其不变性，但可以随意修改其内部组件。 一旦拥有可变的Period实例，攻击者可能会通过将实例传递给依赖于Period的安全性不变性的类来造成巨大的伤害。 这并非如此牵强：有些类就是依赖于String的不变性来保证安全性的。&lt;/p&gt;
&lt;p&gt;问题的根源是Period类的readObject方法没有做足够的防御性拷贝。 &lt;strong&gt;对象反序列化时，防御性地拷贝包含客户端不能拥有的对象引用的属性，是至关重要的&lt;/strong&gt;。 因此，每个包含私有可变组件的可序列化不可变类，必须在其readObject方法中防御性地拷贝这些组件。 以下readObject方法足以确保Period的不变性并保持其不变性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// readObject method with defensive copying and validity checking
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // Defensively copy our mutable components
    start = new Date(start.getTime());
    end   = new Date(end.getTime());

    // Check that our invariants are satisfied
    if (start.compareTo(end) &amp;gt; 0)
        throw new InvalidObjectException(start +&quot; after &quot;+ end);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，防御性拷贝在有效性检查之前执行，并且我们没有使用Date的clone方法来执行防御性拷贝。 需要这两个细节来保护Period免受攻击（条目 50）。 另请注意，final属性无法进行防御性拷贝。 要使用readObject方法，我们必须使start和end属性不能是final类型的。 这是不幸的，但它是这两个中较好的一个做法。 使用新的readObject方法并从&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;属性中删除final修饰符后，&lt;code&gt;MutablePeriod&lt;/code&gt;类不再无效。 上面的攻击程序现在生成如下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017
Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个简单的石蕊测试(litmus test)，用于确定类的默认readObject方法是否可接受：你是否愿意添加一个公共构造方法，该构造方法把对象中每个非瞬时状态的属性值作为参数，并在没有任何验证的情况下，将值保存在属性中？如果没有，则必须提供readObject方法，并且它必须执行构造方法所需的所有有效性检查和防御性拷贝。或者，可以使用序列化代理模式（serialization proxy pattern））(条目 90)。强烈推荐使用这种模式，因为它在安全反序列化方面花费了大量精力。&lt;/p&gt;
&lt;p&gt;readObject方法和构造方法还有一个相似之处，它们适用于非final可序列化类。 与构造方法一样，readObject方法不能直接或间接调用可重写的方法（条目 19）。 如果违反此规则并且重写了相关方法，则重写方法会在子类状态被反序列化之前运行。 程序可能会导致失败[Bloch05，Puzzle 91]。&lt;/p&gt;
&lt;p&gt;总而言之，无论何时编写readObject方法，都要采用这样一种思维方式，即正在编写一个公共构造方法，该构造方法必须生成一个有效的实例，而不管给定的是什么字节流。不要假设字节流一定表示实际的序列化实例。虽然本条目中的示例涉及使用默认序列化形式的类，但是所引发的所有问题都同样适用于具有自定义序列化形式的类。下面是编写readObject方法的指导原则:&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于具有必须保持私有的对象引用属性的类，防御性地拷贝该属性中的每个对象。不可变类的可变组件属于这一类别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;检查任何不变性，如果检查失败，则抛出InvalidObjectException异常。 检查应再任何防御性拷贝之后。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果必须在反序列化后验证整个对象图（object graph），那么使用ObjectInputValidation接口(在本书中没有讨论)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不要直接或间接调用类中任何可重写的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 06 Apr 2019 14:16:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10663149.html</dc:identifier>
</item>
<item>
<title>服务端预渲染之Nuxt(介绍篇) - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10663069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10663069.html</guid>
<description>&lt;p&gt;现在前端开发一般都是前后端分离，&lt;code&gt;mvvm&lt;/code&gt;和&lt;code&gt;mvc&lt;/code&gt;的开发框架，如&lt;code&gt;Angular&lt;/code&gt;、&lt;code&gt;React&lt;/code&gt;和&lt;code&gt;Vue&lt;/code&gt;等，虽然写框架能够使我们快速的完成开发，但是由于前后台分离，给项目&lt;code&gt;SEO&lt;/code&gt;带来很大的不便，搜索引擎在检索的时候是在网页中爬取数据，由于单页面应用读取到的页面是几乎空白的，无法爬取到任何数据信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=utf-8&amp;gt;
        &amp;lt;meta name=viewport content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
        &amp;lt;title&amp;gt;authorization_web&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=app&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码，单页面应用查看源代码的时候如上所示，所以搜索引擎无法爬取到任何信息，搜索引擎会认为当前页面为一个空页面。为了解决&lt;code&gt;SEO&lt;/code&gt;问题，推出了&lt;code&gt;SSR&lt;/code&gt;服务端预渲染，以便提高对&lt;code&gt;SEO&lt;/code&gt;优化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是SSR&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在认识&lt;code&gt;SSR&lt;/code&gt;之前，首先对&lt;code&gt;CSR&lt;/code&gt;与&lt;code&gt;SSR&lt;/code&gt;之间做个对比。&lt;/p&gt;
&lt;p&gt;首先看一下传统的web开发，传统的web开发是，客户端向服务端发送请求，服务端查询数据库，拼接&lt;code&gt;HTML&lt;/code&gt;字符串（模板），通过一系列的数据处理之后，把整理好的&lt;code&gt;HTML&lt;/code&gt;返回给客户端,浏览器相当于打开了一个页面。这种比如我们经常听说过的&lt;code&gt;jsp&lt;/code&gt;,&lt;code&gt;PHP&lt;/code&gt;,&lt;code&gt;aspx&lt;/code&gt;也就是传统的&lt;code&gt;MVC&lt;/code&gt;的开发。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SPA&lt;/code&gt;应用，到了&lt;code&gt;Vue&lt;/code&gt;、&lt;code&gt;React&lt;/code&gt;，单页面应用优秀的用户体验，逐渐成为了主流，页面整体式&lt;code&gt;javaScript&lt;/code&gt;渲染出来的，称之为客户端渲染&lt;code&gt;CSR&lt;/code&gt;。&lt;code&gt;SPA&lt;/code&gt;渲染过程。由客户端访问&lt;code&gt;URL&lt;/code&gt;发送请求到服务端，返回&lt;code&gt;HTML&lt;/code&gt;结构（但是&lt;code&gt;SPA&lt;/code&gt;的返回的&lt;code&gt;HTML&lt;/code&gt;结构是非常的小的，只有一个基本的结构，如第一段代码所示）。客户端接收到返回结果之后，在客户端开始渲染&lt;code&gt;HTML&lt;/code&gt;，渲染时执行对应&lt;code&gt;javaScript&lt;/code&gt;，最后渲染&lt;code&gt;template&lt;/code&gt;，渲染完成之后，再次向服务端发送数据请求，注意这里时数据请求，服务端返回&lt;code&gt;json&lt;/code&gt;格式数据。客户端接收数据，然后完成最终渲染。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SPA&lt;/code&gt;虽然给服务器减轻了压力，但是也是有缺点的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首屏渲染时间比较长：必须等待&lt;code&gt;JavaScript&lt;/code&gt;加载完毕，并且执行完毕，才能渲染出首屏。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEO&lt;/code&gt;不友好：爬虫只能拿到一个&lt;code&gt;div&lt;/code&gt;元素，认为页面是空的，不利于&lt;code&gt;SEO&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了解决如上两个问题，出现了&lt;code&gt;SSR&lt;/code&gt;解决方案，后端渲染出首屏的&lt;code&gt;DOM&lt;/code&gt;结构返回，前端拿到内容带上首屏，后续的页面操作，再用单页面路由和渲染，称之为服务端渲染(&lt;code&gt;SSR&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SSR&lt;/code&gt;渲染流程是这样的，客户端发送&lt;code&gt;URL&lt;/code&gt;请求到服务端，服务端读取对应的&lt;code&gt;url&lt;/code&gt;的模板信息，在服务端做出&lt;code&gt;html&lt;/code&gt;和&lt;code&gt;数据&lt;/code&gt;的渲染，渲染完成之后返回&lt;code&gt;html&lt;/code&gt;结构，客户端这时拿到的之后首屏页面的&lt;code&gt;html&lt;/code&gt;结构。所以用户在浏览首屏的时候速度会很快，因为客户端不需要再次发送&lt;code&gt;ajax&lt;/code&gt;请求。并不是做了&lt;code&gt;SSR&lt;/code&gt;我们的页面就不属于&lt;code&gt;SPA&lt;/code&gt;应用了，它仍然是一个独立的&lt;code&gt;spa&lt;/code&gt;应用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SSR&lt;/code&gt;是处于&lt;code&gt;CSR&lt;/code&gt;与&lt;code&gt;SPA&lt;/code&gt;应用之间的一个折中的方案，在渲染首屏的时候在服务端做出了渲染，注意仅仅是首屏，其他页面还是需要在客户端渲染的，在&lt;code&gt;服务端&lt;/code&gt;接收到请求之后并且渲染出首屏页面，会携带着剩余的路由信息预留给&lt;code&gt;客户端&lt;/code&gt;去渲染其他路由的页面。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nuxt.js 介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Nuxt&lt;/code&gt;官方网站有一句这样的话：&lt;code&gt;Nuxt.js&lt;/code&gt;预设了使您开发&lt;code&gt;Vue.js&lt;/code&gt;应用程序所需的所有配置。&lt;code&gt;Nuxt&lt;/code&gt;是一个基于&lt;code&gt;Vue.js&lt;/code&gt;的通用应用框架。通过对&lt;code&gt;客户端/服务端&lt;/code&gt;基础框架的抽象组织，&lt;code&gt;Nuxt&lt;/code&gt;主要关注的是应用的&lt;code&gt;ui&lt;/code&gt;渲染。&lt;/p&gt;
&lt;p&gt;通过上面的这些介绍可以简单的得出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Nuxt&lt;/code&gt;不仅仅用于服务端渲染也可以用于&lt;code&gt;SPA&lt;/code&gt;应用的开发&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;Nuxt&lt;/code&gt;提供的项目结构、异步数据加载，中间件的支持，布局等特性可大幅提升开发效率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nuxt&lt;/code&gt;可用于网站静态化，可以使用命令将整个网页打包成静态页面，使&lt;code&gt;SEO&lt;/code&gt;更加友好&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;Nuxt.js 特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;基于&lt;code&gt;Vue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自动代码分层&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;li&gt;强大的路由功能，支持异步数据&lt;/li&gt;
&lt;li&gt;静态文件服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EcmaScript6&lt;/code&gt;和&lt;code&gt;EcmaScript7&lt;/code&gt;的语法支持&lt;/li&gt;
&lt;li&gt;打包和压缩&lt;code&gt;JavaScript&lt;/code&gt;和&lt;code&gt;Css&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;头部标签管理&lt;/li&gt;
&lt;li&gt;本地开发支持热加载&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;ESLint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持各种样式预编译器&lt;code&gt;SASS&lt;/code&gt;、&lt;code&gt;LESS&lt;/code&gt;等等&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;HTTP/2&lt;/code&gt;推送&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;Nuxt 渲染流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个完整的服务器请求到渲染的流程&lt;/p&gt;
&lt;img src=&quot;https://zh.nuxtjs.org/nuxt-schema.svg&quot;/&gt;&lt;p&gt;通过上面的流程图可以看出，当一个客户端请求进入的时候，服务端有通过&lt;code&gt;nuxtServerInit&lt;/code&gt;这个命令执行在&lt;code&gt;Store&lt;/code&gt;的&lt;code&gt;action&lt;/code&gt;中，在这里接收到客户端请求的时候，可以将一些客户端信息存储到&lt;code&gt;Store&lt;/code&gt;中，也就是说可以把在服务端存储的一些客户端的一些登录信息存储到&lt;code&gt;Store&lt;/code&gt;中。之后使用了&lt;code&gt;中间件&lt;/code&gt;机制，中间件其实就是一个函数，会在每个路由执行之前去执行，在这里可以做很多事情，或者说可以理解为是路由器的拦截器的作用。然后再&lt;code&gt;validate&lt;/code&gt;执行的时候对客户端携带的参数进行校验，在&lt;code&gt;asyncData&lt;/code&gt;与&lt;code&gt;fetch&lt;/code&gt;进入正式的渲染周期，&lt;code&gt;asyncData&lt;/code&gt;向服务端获取数据，把请求到的数据合并到&lt;code&gt;Vue&lt;/code&gt;中的&lt;code&gt;data&lt;/code&gt;中，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nuxt说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Nuxt&lt;/code&gt;安装：&lt;/p&gt;
&lt;p&gt;确保安装了npx（npx在NPM版本5.2.0默认安装了）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npx create-nuxt-app &amp;lt;项目名&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装向导：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Project name                                //  项目名称
Project description                         //  项目描述
Use a custom server framework               //  选择服务器框架
Choose features to install                  //  选择安装的特性
Use a custom UI framework                   //  选择UI框架
Use a custom test framework                 //  测试框架
Choose rendering mode                       //  渲染模式
    Universal                                   //  渲染所有连接页面
    Single Page App                             //  只渲染当前页面&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都是比较重要的其他的配置内容就不做介绍了，一路回车即可。&lt;/p&gt;
&lt;h5 id=&quot;目录结构介绍&quot;&gt;# 目录结构介绍&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;assets              //  存放素材(需要执行webpack预处理操作)
components          //  组件
layouts             //  布局文件
static              //  静态文件(不需要webpack预处理操作)
middleware          //  中间件
pages               //  所有页面
plugins             //  插件
server              //  服务端代码
store               //  vuex&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置文件&quot;&gt;# 配置文件&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const pkg = require('./package')
module.exports = {
  mode: 'universal',    //  当前渲染使用模式
  head: {       //  页面head配置信息
    title: pkg.name,        //  title
    meta: [         //  meat
      { charset: 'utf-8' },
      { name: 'viewport', content: 'width=device-width, initial-scale=1' },
      { hid: 'description', name: 'description', content: pkg.description }
    ],
    link: [     //  favicon，若引用css不会进行打包处理
      { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
    ]
  },
  loading: { color: '#fff' },   //  页面进度条
  css: [    //  全局css（会进行webpack打包处理）
    'element-ui/lib/theme-chalk/index.css'  
  ],
  plugins: [        //  插件
    '@/plugins/element-ui'
  ],
  modules: [        //  模块
    '@nuxtjs/axios',
  ],
  axios: {},
  build: {      //  打包
    transpile: [/^element-ui/],
    extend(config, ctx) {       //  webpack自定义配置
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;nuxt运行命令&quot;&gt;# Nuxt运行命令&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;scripts&quot;: {
    //  开发环境
    &quot;dev&quot;: &quot;cross-env NODE_ENV=development nodemon server/index.js --watch server&quot;,
    //  打包
    &quot;build&quot;: &quot;nuxt build&quot;,
    //  在服务端运行
    &quot;start&quot;: &quot;cross-env NODE_ENV=production node server/index.js&quot;,
    //  生成静态页面
    &quot;generate&quot;: &quot;nuxt generate&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;结语&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里简单的对&lt;code&gt;Nuxt&lt;/code&gt;做了一些介绍，会持续更新对&lt;code&gt;Nuxt&lt;/code&gt;的跟进，希望会对大家有所帮助，如果有什么问题，可以在下面留言。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 13:56:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>现在前端开发一般都是前后端分离， 和`mvc Angular React Vue SEO`带来很大的不便，搜索引擎在检索的时候是在网页中爬取数据，由于单页面应用读取到的页面是几乎空白的，无法爬取到任何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10663069.html</dc:identifier>
</item>
<item>
<title>Android之Realm详解 - 故事爱人</title>
<link>http://www.cnblogs.com/WUXIAOCHANG/p/10662998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WUXIAOCHANG/p/10662998.html</guid>
<description>&lt;h2&gt;文章大纲&lt;/h2&gt;
&lt;p&gt;一、Realm介绍&lt;br/&gt;二、Realm实战&lt;br/&gt;三、Realm官方文档&lt;br/&gt;四、项目源码下载&lt;br/&gt;五、参考文章&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;714&quot; data-height=&quot;551&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-96c8b3b63629a3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/714/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-96c8b3b63629a3bc.png&quot; data-original-width=&quot;714&quot; data-original-height=&quot;551&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;63963&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;一、Realm介绍&lt;/h2&gt;
&lt;h3&gt;1. 什么是Realm&lt;/h3&gt;
&lt;p&gt;  Realm 是一个手机数据库，是用来替代 SQlite 的解决方案，比 SQlite 更轻量级，速度更快，因为它有一套自己的数据库搜索引擎，并且还具有很多现代数据库的优点，支持 JSON，流式 API 调用，数据变更通知，自动数据同步，简单身份验证，访问控制，事件处理，最重要的是跨平台，目前已经支持 Java、Swift、Object - C、React - Native 等多种实现。&lt;/p&gt;
&lt;h3&gt;2. Realm优势&lt;/h3&gt;
&lt;p&gt;易用&lt;br/&gt;  Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。&lt;br/&gt;快速&lt;br/&gt;  由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。&lt;br/&gt;跨平台&lt;br/&gt;  Realm 支持 iOS &amp;amp; OS X (Objective‑C &amp;amp; Swift) &amp;amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。&lt;br/&gt;高级&lt;br/&gt;  Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性&lt;br/&gt;可视化&lt;br/&gt;  Realm 还提供了一个轻量级的数据库查看工具，在Mac Appstore 可以下载“Realm Browser”这个工具，开发者可以查看数据库当中的内容，执行简单的插入和删除数据的操作。（windows上还不清楚）&lt;/p&gt;
&lt;h4&gt;3. 使用要求&lt;/h4&gt;
&lt;p&gt;（1）目前不支持Android以外的Java&lt;br/&gt;（2）Android Studio &amp;gt;= 1.5.1（不支持Eclipse）&lt;br/&gt;（3）JDK version &amp;gt;=7.&lt;br/&gt;（4）支持API 9(Android 2.3)以及之后的版本&lt;/p&gt;
&lt;h2&gt;二、Realm实战&lt;/h2&gt;
&lt;h3&gt;1. 添加依赖&lt;/h3&gt;
&lt;p&gt;在project的build中加入依赖&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &lt;span class=&quot;hljs-string&quot;&gt;&quot;io.realm:realm-gradle-plugin:2.2.1&quot;
    }
}
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;682&quot; data-height=&quot;872&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1638147-efd0042285b22de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/682/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1638147-efd0042285b22de4.png&quot; data-original-width=&quot;682&quot; data-original-height=&quot;872&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;187617&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在module中加入&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;apply plugin: &lt;span class=&quot;hljs-string&quot;&gt;'realm-android'
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;638&quot; data-height=&quot;504&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1638147-75617c94f75a302f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/638/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1638147-75617c94f75a302f.png&quot; data-original-width=&quot;638&quot; data-original-height=&quot;504&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;142054&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. 创建model&lt;/h3&gt;
&lt;p&gt;  创建一个User类，需要继承RealmObject。支持public, protected和 private的类以及方法&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RealmObject {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;int age;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return name;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;span class=&quot;hljs-params&quot;&gt;(String name) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;getAge&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return age;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setAge&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int age) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.age = age;
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  除了直接继承于RealmObject来声明 Realm 数据模型之外，还可以通过实现 RealmModel接口并添加 @RealmClass修饰符来声明。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RealmClass
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;RealmModel {
    ...
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的属性&lt;br/&gt;boolean, byte, short,int,long,float, double,String, Date 和，byte[], RealmObject, RealmList&amp;lt;? extends RealmObject&amp;gt;&lt;br/&gt;还支持Boolean, Byte, Short, Integer, Long, Float 和 Double&lt;br/&gt;提示：整数类型 short、int 和 long 都被映射到 Realm 内的相同类型（实际上为 long ）&lt;br/&gt;（1）@PrimaryKey——表示该字段是主键&lt;br/&gt;  使用过数据库的同学应该看出来了，PrimaryKey就是主键。使用@PrimaryKey来标注，字段类型必须是字符串（String）或整数（byte，short，int或long）以及它们的包装类型（Byte,Short, Integer, 或 Long）。不可以存在多个主键，使用字符串字段作为主键意味着字段被索引（注释@PrimaryKey隐式地设置注释@Index）。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@PrimaryKey
&lt;span class=&quot;hljs-keyword&quot;&gt;private String id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）@Required——表示该字段非空&lt;br/&gt;  在某些情况下，有一些属性是不能为null的。使用@Required可用于用于强行要求其属性不能为空，只能用于Boolean, Byte, Short, Integer, Long, Float, Double, String, byte[] 和 Date。在其它类型属性上使用。&lt;/p&gt;
&lt;p&gt;（3）@Required修饰会导致编译失败。&lt;br/&gt;  提示：基本数据类型不需要使用注解 @Required，因为他们本身就不可为空。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Required
&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）@Ignore——表示忽略该字段&lt;br/&gt;  被添加@Ignore标签后，存储数据时会忽略该字段。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Ignore
&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）@Index——添加搜索索引&lt;br/&gt;  为字段添加搜索索引，这样会使得插入的速度变慢，数据量也变得更大。不过在查询速度将变得更快，建议只在优化读取性能的特定情况时添加索引。支持索引：String，byte，short，int，long，boolean和Date字段。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果你创建Model并运行过，然后修改了Model。那么就需要升级数据库，否则会抛异常。升级方式后面会提到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3. 初始化Realm&lt;/h3&gt;
&lt;p&gt;重写Application类&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApp &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();
}
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AndroidManifest.xml中配置MyApp&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;791&quot; data-height=&quot;296&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-debc38c55beb9688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/791/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-debc38c55beb9688.png&quot; data-original-width=&quot;791&quot; data-original-height=&quot;296&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;65913&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;创建方式1&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApp &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();

        Realm.init(&lt;span class=&quot;hljs-keyword&quot;&gt;this);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这时候会创建一个叫做 default.realm的Realm文件，一般来说，这个文件位于/data/data/包名/files/。通过realm.getPath()来获得该Realm的绝对路径。&lt;/p&gt;
&lt;p&gt;创建方式2&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApp &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();

        Realm.init(&lt;span class=&quot;hljs-keyword&quot;&gt;this);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建方式3&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApp &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();

        Realm.init(&lt;span class=&quot;hljs-keyword&quot;&gt;this);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建方式4&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyApp &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Application {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onCreate&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onCreate();

        Realm.init(&lt;span class=&quot;hljs-keyword&quot;&gt;this);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;br/&gt;RealmConfiguration支持的方法：&lt;br/&gt;Builder.name : 指定数据库的名称。如不指定默认名为default。&lt;br/&gt;Builder.schemaVersion : 指定数据库的版本号。&lt;br/&gt;Builder.encryptionKey : 指定数据库的密钥。&lt;br/&gt;Builder.migration : 指定迁移操作的迁移类。&lt;br/&gt;Builder.deleteRealmIfMigrationNeeded : 声明版本冲突时自动删除原数据库。&lt;br/&gt;Builder.inMemory : 声明数据库只在内存中持久化。&lt;br/&gt;build : 完成配置构建。&lt;/p&gt;
&lt;h3&gt;4. 关闭Realm&lt;/h3&gt;
&lt;p&gt;记得使用完后，在onDestroy中关闭Realm&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override 
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onDestroy&lt;span class=&quot;hljs-params&quot;&gt;() { 
    &lt;span class=&quot;hljs-keyword&quot;&gt;super.onDestroy();
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;5. 获取realm对象&lt;/h3&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;RealmHelper {
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final String DB_NAME = &lt;span class=&quot;hljs-string&quot;&gt;&quot;myRealm.realm&quot;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private Realm mRealm;


    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;RealmHelper&lt;span class=&quot;hljs-params&quot;&gt;(Context context) {

        mRealm = Realm.getDefaultInstance();
    }

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Realm &lt;span class=&quot;hljs-title&quot;&gt;getRealm&lt;span class=&quot;hljs-params&quot;&gt;(){

        &lt;span class=&quot;hljs-keyword&quot;&gt;return mRealm;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;6. 增加数据&lt;/h3&gt;
&lt;p&gt;  写入操作需要在事务中进行，可以使用executeTransaction方法来开启事务。&lt;br/&gt;（1）使用executeTransaction方法插入数据&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;mRealm.executeTransaction(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
                User user = realm.createObject(User.class);
                user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;);
                user.setAge(&lt;span class=&quot;hljs-number&quot;&gt;23);
            }
        });
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  注意：如果在UI线程中插入过多的数据，可能会导致主线程拥塞。&lt;/p&gt;
&lt;p&gt;（2）使用copyToRealmOrUpdate或copyToRealm方法插入数据&lt;br/&gt;当Model中存在主键的时候，推荐使用copyToRealmOrUpdate方法插入数据。如果对象存在，就更新该对象；反之，它会创建一个新的对象。若该Model没有主键，使用copyToRealm方法，否则将抛出异常。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final User user = &lt;span class=&quot;hljs-keyword&quot;&gt;new User();
        user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Jack&quot;);
        user.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;);
        mRealm.executeTransaction(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
                realm.copyToRealmOrUpdate(user);
            }
        });
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你用的是这样的modle&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User2 &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RealmObject {
      &lt;span class=&quot;hljs-keyword&quot;&gt;public String name;
      &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int age;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样写&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;mRealm.executeTransaction(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
                User2 user = realm.createObject(User2.class);
                user.name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Micheal&quot;;
                user.age = &lt;span class=&quot;hljs-number&quot;&gt;30;
            }
        });
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）上面都是用可executeTransaction方法插入数据，还有另一种方法可以用于插入数据——beginTransaction和commitTransaction&lt;/p&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
&lt;code class=&quot;ruby&quot;&gt;mRealm.beginTransaction();&lt;span class=&quot;hljs-regexp&quot;&gt;//开启事务
User user = mRealm.createObject(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class);
user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;);
user.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;);
mRealm.commitTransaction();&lt;span class=&quot;hljs-regexp&quot;&gt;//提交事务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在插入前，先调用beginTransaction()，完成后调用commitTransaction()即可。&lt;br/&gt;  注意：在UI和后台线程同时开启创建write的事务，可能会导致ANR错误。为了避免该问题，可以使用executeTransactionAsync来实现。&lt;/p&gt;
&lt;p&gt;（4）使用executeTransactionAsync&lt;br/&gt;该方法会开启一个子线程来执行事务，并且在执行完成后进行结果通知。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;RealmAsyncTask transaction = mRealm.executeTransactionAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
        User user = realm.createObject(User.class);
        user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Eric&quot;);
        user.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;4&quot;);
      }
});
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以加入监听&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;RealmAsyncTask transaction =  mRealm.executeTransactionAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
        User user = realm.createObject(User.class);
        user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Eric&quot;);
        user.setId(&lt;span class=&quot;hljs-string&quot;&gt;&quot;4&quot;);
      }
}, &lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction.OnSuccess() {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onSuccess&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  注意：如果当Acitivity或Fragment被销毁时，在OnSuccess或OnError中执行UI操作，将导致程序奔溃 。用RealmAsyncTask .cancel();可以取消事务在onStop中调用，避免crash&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onStop &lt;span class=&quot;hljs-params&quot;&gt;() {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (transaction != &lt;span class=&quot;hljs-keyword&quot;&gt;null &amp;amp;&amp;amp; !transaction.isCancelled()) {
        transaction.cancel();
      }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）Realm还是个很好的功能就是将Json字符串转化为对象&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;Realm 解析 JSON 时遵循如下规则：&lt;br/&gt;使用包含空值（null）的 JSON 创建对象：&lt;br/&gt;对于非必须（可为空值的属性），设置其值为 null；&lt;br/&gt;对于必须（不可为空值的属性），抛出异常；&lt;br/&gt;使用包含空值（null）的 JSON 更新对象：&lt;br/&gt;对于非必须（可为空值的属性），设置其值为 null；&lt;br/&gt;对于必须（不可为空值的属性），抛出异常；&lt;br/&gt;使用不包含对应属性的 JSON： * 该属性保持不变&lt;/p&gt;
&lt;h3&gt;7. 查询数据&lt;/h3&gt;
&lt;p&gt;查找操作就比插入方便多了，并不需在事务中操作，直接查询即可。&lt;br/&gt;（1）findAll ——查询&lt;br/&gt;例：查询所有的User&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class).findAll();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)findAllAsync——异步查询&lt;br/&gt;当数据量较大，可能会引起ANR的时候，就可以使用findAllAsync&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class)
                .equalTo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;)
                .findAllAsync();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)findFirst ——查询第一条数据&lt;br/&gt;例：查询User表中的第一条数据&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;User user2 = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class).findFirst();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4)equalTo ——根据条件查询&lt;br/&gt;例：得到name为Gavin的用户列表。&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class)
            .equalTo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;).findAll();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果User中还有Dog属性，希望根据Dog的条件来获取用户：&lt;br/&gt;例：查询dogs.name为二哈的User&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class)
             .equalTo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dogs.name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;二哈&quot;).findAll();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  得到有养有dogs.name为”二哈”的用户列表（这里的dogs是User表中的属性名）&lt;/p&gt;
&lt;p&gt;(5)equalTo ——多条件查询&lt;br/&gt;当然，我们还经常要用到多条件的查询的功能。&lt;br/&gt;例：找到用户名为“Gavin”，且dogs.name为“二哈”的User&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class)
            .equalTo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;).findAll();
RealmResults&amp;lt;User&amp;gt; userList = user5.where()
            .equalTo(&lt;span class=&quot;hljs-string&quot;&gt;&quot;dogs.name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;二哈&quot;).findAll();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）排序&lt;br/&gt;查询结束后，还可以进行排序，就像这样：&lt;/p&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
&lt;code class=&quot;ruby&quot;&gt;RealmResults&amp;lt;User&amp;gt; userList = mRealm.where(User.&lt;span class=&quot;hljs-keyword&quot;&gt;class) .findAll();
userList = result.sort(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;); &lt;span class=&quot;hljs-regexp&quot;&gt;//根据age，正序排列
userList = result.sort(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;, Sort.DESCENDING);&lt;span class=&quot;hljs-regexp&quot;&gt;//逆序排列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）聚合&lt;br/&gt;RealmResult自带一些聚合方法：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;RealmResults&amp;lt;User&amp;gt; results = realm.where(User.class).findAll();
&lt;span class=&quot;hljs-keyword&quot;&gt;long   sum     = results.sum(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;).longValue();
&lt;span class=&quot;hljs-keyword&quot;&gt;long   min     = results.min(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;).longValue();
&lt;span class=&quot;hljs-keyword&quot;&gt;long   max     = results.max(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;).longValue();
&lt;span class=&quot;hljs-keyword&quot;&gt;double average = results.average(&lt;span class=&quot;hljs-string&quot;&gt;&quot;age&quot;);
&lt;span class=&quot;hljs-keyword&quot;&gt;long   matches = results.size();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（8）更多查询条件&lt;br/&gt;  上面就展示了equalTo的用法。当然，查询还有更多的用法，我就不一一示例了。已知的方法如下：&lt;br/&gt;sum()：对指定字段求和。&lt;br/&gt;average()：对指定字段求平均值。&lt;br/&gt;min(): 对指定字段求最小值。&lt;br/&gt;max() : 对指定字段求最大值。count : 求结果集的记录数量。&lt;br/&gt;findAll(): 返回结果集所有字段，返回值为RealmResults队列&lt;br/&gt;findAllSorted() : 排序返回结果集所有字段，返回值为RealmResults队列&lt;br/&gt;between(), greaterThan(),lessThan(), greaterThanOrEqualTo() &amp;amp; lessThanOrEqualTo()&lt;br/&gt;equalTo() &amp;amp; notEqualTo()&lt;br/&gt;contains(), beginsWith() &amp;amp; endsWith()&lt;br/&gt;isNull() &amp;amp; isNotNull()&lt;br/&gt;isEmpty()&amp;amp; isNotEmpty()&lt;/p&gt;
&lt;h4&gt;8. 修改数据&lt;/h4&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;mRealm.executeTransaction(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改也是需要在事务中操作。使用查询语句得到数据，然后将内容改了即可。&lt;/p&gt;
&lt;h3&gt;9. 删除数据&lt;/h3&gt;
&lt;p&gt;(1)使用deleteFromRealm()&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;(2)使用deleteFromRealm(int index)&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;mRealm.executeTransaction(&lt;span class=&quot;hljs-keyword&quot;&gt;new Realm.Transaction() {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(Realm realm) {
        userList.deleteFromRealm(&lt;span class=&quot;hljs-number&quot;&gt;0);
    }
});
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)其他方法&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;userList.deleteFirstFromRealm(); &lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;10. 异步任务注意点&lt;/h3&gt;
&lt;p&gt;最后在销毁Activity或Fragment时，要取消掉异步任务&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;onDestroy&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;super.onDestroy();
       &lt;span class=&quot;hljs-keyword&quot;&gt;if (deleteTask!=&lt;span class=&quot;hljs-keyword&quot;&gt;null&amp;amp;&amp;amp;!addTask.isCancelled()){
            deleteTask.cancel();
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;11. 其他常见操作&lt;/h3&gt;
&lt;p&gt;API:RealmObjectSchema&lt;br/&gt;（1）取消id必填&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;personSchema.setNullable(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;, &lt;span class=&quot;hljs-literal&quot;&gt;true):
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）移除id字段&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;personSchema.removeField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;);
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）重命名&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;personSchema..renameField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;userId&quot;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;API:DynamicRealmObject&lt;br/&gt;（4）获取id&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;String id = obj.getString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）为字段设置值&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;obj.setString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;Gavin&quot;);
obj.setInt(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;, 1);
obj.setLong(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;, 1);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;12. 数据库版本升级&lt;/h3&gt;
&lt;p&gt;  当数据结构发生变化是，需要升级数据库。对于Realm来说，数据库升级就是迁移操作，把原来的数据库迁移到新结构的数据库&lt;/p&gt;
&lt;p&gt;  例1：User类发生变化，移除age，新增个@Required的id字段。&lt;br/&gt;User版本：version 0&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;String name;
&lt;span class=&quot;hljs-keyword&quot;&gt;int    age;
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;User版本：version 1&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;@Required
&lt;span class=&quot;hljs-built_in&quot;&gt;String    id;
&lt;span class=&quot;hljs-built_in&quot;&gt;String name;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建迁移类CustomMigration，需要实现RealmMigration接口。执行版本升级时的处理：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Builder.migration升级数据库，将版本号改为1（原版本号：0）。当Realm发现新旧版本号不一致时，会自动使用该迁移类完成迁移操作。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;RealmConfiguration config = &lt;span class=&quot;hljs-keyword&quot;&gt;new RealmConfiguration.Builder() 
            .name(&lt;span class=&quot;hljs-string&quot;&gt;&quot;myrealm.realm&quot;) &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例2：加入Dog类，User中加入Dog集合。&lt;br/&gt;User版本：version 1&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;@Required
&lt;span class=&quot;hljs-built_in&quot;&gt;String    id;
&lt;span class=&quot;hljs-built_in&quot;&gt;String name;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;User版本：version 2&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Required
&lt;span class=&quot;hljs-keyword&quot;&gt;private String id;
&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
&lt;span class=&quot;hljs-keyword&quot;&gt;private RealmList&amp;lt;Dog&amp;gt; dogs;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dog类&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Dog &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;RealmObject {
        &lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
        &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;int age;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在迁移类CustomMigration中，继续添加处理方法。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;(oldVersion == &lt;span class=&quot;hljs-number&quot;&gt;1 &amp;amp;&amp;amp; newVersion == &lt;span class=&quot;hljs-number&quot;&gt;2) {
                &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;三、Realm官方文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Frealm.io%2Fcn%2Fdocs%2Fjava%2Flatest%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://realm.io/cn/docs/java/latest/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;四、项目源码下载&lt;/h2&gt;
&lt;p&gt;链接:&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1wSoXuclZ-Nwntnw_79xkLA&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1wSoXuclZ-Nwntnw_79xkLA&lt;/a&gt;&lt;br/&gt;密码:oc95&lt;/p&gt;
&lt;h2&gt;五、参考文章&lt;/h2&gt;

</description>
<pubDate>Sat, 06 Apr 2019 13:37:00 +0000</pubDate>
<dc:creator>故事爱人</dc:creator>
<og:description>文章大纲 一、Realm介绍二、Realm实战三、Realm官方文档四、项目源码下载五、参考文章 一、Realm介绍 1. 什么是Realm Realm 是一个手机数据库，是用来替代 SQlite 的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WUXIAOCHANG/p/10662998.html</dc:identifier>
</item>
<item>
<title>容器化时代我们应当选择Kubernetes - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10662958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10662958.html</guid>
<description>&lt;p&gt;前天发的文章《&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/10658110.html&quot;&gt;基于Kubernetes 构建.NET Core 的技术体系&lt;/a&gt;》，有同学问.NET Core上有Spring Cloud类似的平台吗？ .NET Core出现这么久了，这个为云原生应用开发而准备的系统需要Spring cloud这样的全家桶吗？今天写下这篇文章的目的就是陈述一下容器化时代还需要Spring Cloud这样的基础设施吗？ 大家希望使用Spring Cloud的初衷都是为了实现应用的微服务化。然而对于微服务而言，有六个基本必须实现的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程通讯&lt;/li&gt;
&lt;li&gt;服务注册与发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;配置中心&lt;/li&gt;
&lt;li&gt;熔断器&lt;/li&gt;
&lt;li&gt;网关路由&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们已经进入到容器化时代，Kubernetes成为了市场上容器编排的事实标准，而且k8S 同样具备了微服务所需要的服务注册与发现、负载均衡、配置中心。Spring cloud 的核心是Netflix微服务框架，非常成熟，但是在netflix oss开发初期，那个时候还没有docker，我们现在所有的服务都是通过虚拟容器承载的。&lt;/p&gt;
&lt;p&gt;Netflix OSS的许多内容都是在一个已经过去的年代写出来的，那时所有东西都只能运行在AWS云上而没有其它选择。关于那个年代的许多宝贵遗产和前提假设都已经被封装到了Netflix的库里面，对于现在你运行的环境（比如Linux容器）已经不适用了。在Linux容器、Docker、容器管理系统等等出现之后，我们越来越看到把我们的微服务运行在Linux容器（公有云、私有云，或者都要等等）里的巨大价值。另外，因为这些容器都是直接把这些服务打包起来，所以我们倾向于不要过多关心在容器里面运行的到底是什么技术（是Java？还是Node.js？或者Go？或者.NET Core?）&lt;/p&gt;
&lt;p&gt;Kubernetes是多语言的，不仅仅针对Java平台，而是以通用的方式为所有语言解决分布式计算问题。Kubernetes提供了配置管理、服务发现、负载均衡、跟踪、统计、单实例、平台级和应用栈之外的调度工作。该应用不需要任何客户端逻辑的库或代理程序，可以用任何语言编写。这意味着一个平台可以被多个团队（包括使用&lt;code&gt;Spring&lt;/code&gt;的&lt;code&gt;Java&lt;/code&gt;开发人员）使用，并提供多种用途：应​​用程序开发、测试环境、构建环境（源码运行、构建服务、依赖仓库）等。&lt;code&gt;Kubernetes&lt;/code&gt;解决了更广的微服务架构问题。除了提供运行时服务，&lt;code&gt;Kubernetes&lt;/code&gt;也可以让你制定环境、设置资源限制、RBAC、管理应用程序生命周期、允许自动扩容和自我修复（几乎表现得像一个抗脆弱平台）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在K8s集群中，没有必要拥有Eureka。K8s中的ETCD拥有所有必要的信息。&lt;/li&gt;
&lt;li&gt;您的应用程序将通过指定的K8s服务名称联系K8s API服务器以获取端点信息。&lt;/li&gt;
&lt;li&gt;Kubernetes 可以解决你所遇到的问题，可能可以取代netflix的整套技术&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.NET Core 就是为云原生应用的开发而准备的平台，.NET Core相较于他的哥哥.NET的优势也正是我们很容易的使用C# 语言去构建高内聚低耦合的云原生系统。借助于K8S，service fabric, 我们很容易构建一个.NET Core的微服务生态。结合.NET Core和k8s 容器服务在腾讯云上制作了一个教程 《.NET 微服务实战 — 微信公众号开发（ &lt;a href=&quot;https://cloud.tencent.com/developer/edu/major-100017&quot;&gt;https://cloud.tencent.com/developer/edu/major-100017&lt;/a&gt;）》，教程里例子-公众号开发虽然简单，我只是使用这个简单例子来阐述一个简单的问题，云时代的.NET 是怎么样的，我们要怎么样使用.NET Core。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 13:27:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>前天发的文章《基于Kubernetes 构建.NET Core 的技术体系》，有同学问.NET Core上有Spring Cloud类似的平台吗？ .NET Core出现这么久了，这个为云原生应用开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10662958.html</dc:identifier>
</item>
<item>
<title>Akka-CQRS（5）- CQRS Writer Actor 部署和测试 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/10662854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/10662854.html</guid>
<description>&lt;p&gt;&lt;span&gt;   上篇我们做了一个WriterActor的例子，主要目的是示范WriterActor如何作为集群分片用persistentActor特性及event-sourcing模式实现CQRS的写功能。既然是集群分片，那么我们就在这篇讲讲WriterActor的部署和测试，因为这个里面还是有些值得注意的地方。下面是一段WriteActor，即集群分片（cluster-sharding）的部署代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    ClusterSharding(system).start(
      typeName &lt;/span&gt;=&lt;span&gt; shardName,
      entityProps &lt;/span&gt;=&lt;span&gt; writerProps,
      settings &lt;/span&gt;=&lt;span&gt; cpsSettings,
      extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
      extractShardId &lt;/span&gt;=&lt;span&gt; getShopId,
      allocationStrategy &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).defaultShardAllocationStrategy(cpsSettings),
      handOffStopMessage &lt;/span&gt;=&lt;span&gt; PassivatePOS
    )&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意带handOffStopMessage参数的start函数必须同时提供allocationStrategy。这个参数提供了passivation消息类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个集群分片部署代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; POSRouter extends LogSupport {
  def main(args: Array[String]) {
    import WriterActor._
    import Commands._

    val argsPat &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(.*):(.*)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.r
    val (host, port) &lt;/span&gt;= args(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; argsPat(h, p) =&amp;gt;&lt;span&gt; (h, p)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2551&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

    val config &lt;/span&gt;= ConfigFactory.parseString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.port=\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + port + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      .withFallback(ConfigFactory.parseString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.hostname=\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + host + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;roles can be deployed on this node&lt;/span&gt;
      .withFallback(ConfigFactory.parseString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.cluster.roles = [poswriter]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      .withFallback(ConfigFactory.load())

    log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******* hostname = $host,  port = $port *******&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    val shardName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POSShard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSMessage(id: Long, cmd: POSCommand) {
      def shopId &lt;/span&gt;=&lt;span&gt; id.toString.head.toString

      def posId &lt;/span&gt;=&lt;span&gt; id.toString
    }

    val getPOSId: ShardRegion.ExtractEntityId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; (posCommand.posId, posCommand.cmd)
    }
    val getShopId: ShardRegion.ExtractShardId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; posCommand.shopId
    }


    val system &lt;/span&gt;= ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cloud-pos-server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config)
    val role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poswriter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;role of this shard&lt;/span&gt;
    val cpsSettings = ClusterShardingSettings(system).withRole(role) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.withPassivateIdleAfter(10 minutes)&lt;/span&gt;
&lt;span&gt;
    ClusterSharding(system).start(
      typeName &lt;/span&gt;=&lt;span&gt; shardName,
      entityProps &lt;/span&gt;=&lt;span&gt; writerProps,
      settings &lt;/span&gt;=&lt;span&gt; cpsSettings,
      extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
      extractShardId &lt;/span&gt;=&lt;span&gt; getShopId,
      allocationStrategy &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).defaultShardAllocationStrategy(cpsSettings),
      handOffStopMessage &lt;/span&gt;=&lt;span&gt; PassivatePOS
    )

    system.actorOf(ClusterMonitor.props, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cps-cluster-monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上有几个参数需要特别注意：host和port是从main的参数解析出来的如192.168.11.162:2551，代表本节点的host和port。akka.cluster.roles代表本节点支持的角色，这里poswriter是其中之一。而ClusterShardingSettings(system).withRole(&quot;poswriter&quot;)代表这个分片shard只能在支持poswriter角色的节点上部署。如果搞错了运行时你会发现Sharding无法启动。上面这段程序代表本节点支持poswriter角色。在本节点（输入的IP地址）部署了一个名称为“POSShard”的cluster-sharding，它具备poswriter角色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我在多部机器上运行这段代码，输入当前机器的IP+PORT就代表在这么多台机器上都部署了“POSShard”分片。上面的ClusterMonitor是个集群状态监控actor:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package sdp.cluster.monitor

import akka.actor._
import akka.cluster.ClusterEvent._
import akka.cluster._
import sdp.logging.LogSupport

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ClusterMonitor {
  def props &lt;/span&gt;= Props(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClusterMonitor)
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClusterMonitor extends Actor with LogSupport {
  val cluster &lt;/span&gt;=&lt;span&gt; Cluster(context.system)
  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def preStart(): Unit =&lt;span&gt; {
    cluster.subscribe(self,initialStateMode &lt;/span&gt;=&lt;span&gt; InitialStateAsEvents
      ,classOf[MemberEvent],classOf[UnreachableMember])  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅集群状态转换信息&lt;/span&gt;
&lt;span&gt;    super.preStart()
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def postStop(): Unit =&lt;span&gt; {
    cluster.unsubscribe(self)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消订阅&lt;/span&gt;
&lt;span&gt;    super.postStop()
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def receive: Receive =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberJoined(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Joining: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberUp(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Up: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberLeft(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Leaving: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberExited(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Exiting: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberRemoved(member, previousStatus) =&amp;gt;&lt;span&gt;
      log.info(
        s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Removed: {${member.address}} after {${previousStatus}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; UnreachableMember(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member detected as unreachable: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      cluster.down(member.address)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手工驱除，不用auto-down&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; _: MemberEvent =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore&lt;/span&gt;
&lt;span&gt;  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有了它我们可以监视集群节点连接状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，现在假设我们在几台机器组成的集群各节点上都部署了“POSShard”分片，那么就设计个客户端来向这个“POSShard”分片发送POSMessage：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSMessage(id: Long, cmd: POSCommand) {
      def shopId &lt;/span&gt;=&lt;span&gt; id.toString.head.toString

      def posId &lt;/span&gt;=&lt;span&gt; id.toString
    }

    val getPOSId: ShardRegion.ExtractEntityId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; (posCommand.posId, posCommand.cmd)
    }
    val getShopId: ShardRegion.ExtractShardId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; posCommand.shopId
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个客户端必须考虑以下几点：它必须在同一个集群，也就是它也是集群其中一个节点，否则无法和其它部署了“POSShard”分片的节点进行信息交流。但它又不能同处与部署了“POSShard”的节点，因为remote的hostname和port已经被占用。所以只能把客户端放在一个没有部署“POSShard”的节点上，然后用ClusterSharding(system).startProxy来启动一个分片中介：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;no shard deployed on this node  2558, use proxy&lt;/span&gt;
    val posHandler =&lt;span&gt; ClusterSharding(system).startProxy(
      typeName &lt;/span&gt;=&lt;span&gt; shardName,
      role &lt;/span&gt;= Some(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poswriter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
      extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
      extractShardId &lt;/span&gt;=&lt;span&gt; getShopId
    )

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;val posHandler = ClusterSharding(system).shardRegion(shardName)&lt;/span&gt;
&lt;span&gt;
    system.actorOf(POSClient.props(posHandler), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pos-client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意这个proxy的role必须是Some(&quot;poswriter&quot;)，只有这样才能调用其它节点上的”POSShard“，因为它们的角色都是“poswriter”。与WriterActor交互的必须是个actor，因为WriterActor会用sender()返回结果，这个sender()是个ActorRef：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; POSClient {
  def props(pos: ActorRef) &lt;/span&gt;= Props(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; POSClient(pos))
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSClient(posHandler: ActorRef)  extends Actor with LogSupport {

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def receive: Receive =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; msg @ POSMessage(_,_) =&amp;gt; posHandler !&lt;span&gt; msg
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; resp: POSResponse  =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;response from server: $resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可用下面的方式来指挥WriterActor:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    val posref = system.actorOf(POSClient.props(posHandler), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pos-client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;1021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, apple.code, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;2021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, pineapple.code, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;3021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, banana.code, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;4021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, grape.code, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;4021&lt;/span&gt;,Subtotal)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是服务端分片部署源代码：&lt;/p&gt;
&lt;p&gt;resources/application.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
akka.actor.warn-about-java-serializer-usage =&lt;span&gt; off
akka.log&lt;/span&gt;-dead-letters-during-shutdown =&lt;span&gt; off
akka.log&lt;/span&gt;-dead-letters =&lt;span&gt; off

akka {
  loglevel &lt;/span&gt;=&lt;span&gt; INFO
  actor {
    provider &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }

  remote {
    log&lt;/span&gt;-remote-lifecycle-events =&lt;span&gt; off
    netty.tcp {
      hostname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      port &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
  }

  cluster {
    seed&lt;/span&gt;-nodes =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.tcp://cloud-pos-server@192.168.11.162:2551&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    log&lt;/span&gt;-info =&lt;span&gt; off
    sharding {
      role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poswriter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      passivate&lt;/span&gt;-idle-entity-after = &lt;span&gt;5&lt;/span&gt;&lt;span&gt; m
    }
  }

  persistence {
    journal.plugin &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cassandra-journal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    snapshot&lt;/span&gt;-store.plugin = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cassandra-snapshot-store&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }

}

cassandra&lt;/span&gt;-&lt;span&gt;journal {
  contact&lt;/span&gt;-points = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.162&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}

cassandra&lt;/span&gt;-snapshot-&lt;span&gt;store {
  contact&lt;/span&gt;-points = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.162&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;POSRouter.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.server

import akka.actor._
import akka.cluster.sharding._
import akka.cluster.sharding.ClusterSharding
import com.typesafe.config.ConfigFactory
import sdp.cluster.monitor._
import sdp.logging._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; POSRouter extends LogSupport {
  def main(args: Array[String]) {
    import WriterActor._
    import Commands._

    val argsPat &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(.*):(.*)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.r
    val (host, port) &lt;/span&gt;= args(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; argsPat(h, p) =&amp;gt;&lt;span&gt; (h, p)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2551&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }


    val config &lt;/span&gt;= ConfigFactory.parseString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.port=\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + port + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      .withFallback(ConfigFactory.parseString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.remote.netty.tcp.hostname=\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + host + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;roles can be deployed on this node&lt;/span&gt;
      .withFallback(ConfigFactory.parseString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.cluster.roles = [poswriter]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      .withFallback(ConfigFactory.load())


    log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******* hostname = $host,  port = $port *******&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    val shardName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POSShard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSMessage(id: Long, cmd: POSCommand) {
      def shopId &lt;/span&gt;=&lt;span&gt; id.toString.head.toString

      def posId &lt;/span&gt;=&lt;span&gt; id.toString
    }

    val getPOSId: ShardRegion.ExtractEntityId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; (posCommand.posId, posCommand.cmd)
    }
    val getShopId: ShardRegion.ExtractShardId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; posCommand.shopId
    }


    val system &lt;/span&gt;= ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cloud-pos-server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config)
    val role &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poswriter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;role of this shard&lt;/span&gt;
    val cpsSettings = ClusterShardingSettings(system).withRole(role) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;.withPassivateIdleAfter(10 minutes)&lt;/span&gt;
&lt;span&gt;
    ClusterSharding(system).start(
      typeName &lt;/span&gt;=&lt;span&gt; shardName,
      entityProps &lt;/span&gt;=&lt;span&gt; writerProps,
      settings &lt;/span&gt;=&lt;span&gt; cpsSettings,
      extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
      extractShardId &lt;/span&gt;=&lt;span&gt; getShopId,
      allocationStrategy &lt;/span&gt;=&lt;span&gt; ClusterSharding(system).defaultShardAllocationStrategy(cpsSettings),
      handOffStopMessage &lt;/span&gt;=&lt;span&gt; PassivatePOS
    )

    system.actorOf(ClusterMonitor.props, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cps-cluster-monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是这个测试项目的源代码：&lt;/p&gt;
&lt;p&gt;build.sbt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
name := &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cloud-pos-client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

version :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

scalaVersion :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.12.8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

libraryDependencies :&lt;/span&gt;=&lt;span&gt; Seq(
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-cluster-sharding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.5.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.5.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence-cassandra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.93&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence-cassandra-launcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.93&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; Test,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ch.qos.logback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  %  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logback-classic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.2.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resources/application.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
akka.actor.warn-about-java-serializer-usage =&lt;span&gt; off
akka.log&lt;/span&gt;-dead-letters-during-shutdown =&lt;span&gt; off
akka.log&lt;/span&gt;-dead-letters =&lt;span&gt; off

akka {
  loglevel &lt;/span&gt;=&lt;span&gt; INFO
  actor {
    provider &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }

  remote {
    log&lt;/span&gt;-remote-lifecycle-events =&lt;span&gt; off
    netty.tcp {
      hostname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.162&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      port &lt;/span&gt;= &lt;span&gt;2558&lt;/span&gt;&lt;span&gt;
    }
  }

  cluster {
    seed&lt;/span&gt;-nodes =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.tcp://cloud-pos-server@192.168.11.162:2551&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    log&lt;/span&gt;-info =&lt;span&gt; off
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resources/logback.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;appender name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;STDOUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ch.qos.logback.core.ConsoleAppender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{&lt;span&gt;36&lt;/span&gt;} - %msg%&lt;span&gt;n
            &lt;/span&gt;&amp;lt;/Pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;appender-&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;STDOUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClientDemo.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client
import akka.actor._
import akka.cluster.sharding.ClusterSharding
import sdp.cluster.monitor._
import sdp.logging._
import Commands._
import States._
import Items._
import akka.cluster.sharding._


&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; POSClientDemo extends LogSupport {
  def main(args: Array[String]) {

    val system &lt;/span&gt;= ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cloud-pos-server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    val shardName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POSShard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

    val getPOSId: ShardRegion.ExtractEntityId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; (posCommand.posId, posCommand.cmd)
    }
    val getShopId: ShardRegion.ExtractShardId &lt;/span&gt;=&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; posCommand: POSMessage =&amp;gt;&lt;span&gt; posCommand.shopId
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;no shard deployed on this node  2558, use proxy&lt;/span&gt;
    val posHandler =&lt;span&gt; ClusterSharding(system).startProxy(
      typeName &lt;/span&gt;=&lt;span&gt; shardName,
      role &lt;/span&gt;= Some(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poswriter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
      extractEntityId &lt;/span&gt;=&lt;span&gt; getPOSId,
      extractShardId &lt;/span&gt;=&lt;span&gt; getShopId
    )

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;val posHandler = ClusterSharding(system).shardRegion(shardName)&lt;/span&gt;
&lt;span&gt;
    system.actorOf(ClusterMonitor.props, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cps-cluster-monitor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    val posref &lt;/span&gt;= system.actorOf(POSClient.props(posHandler), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pos-client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    posref &lt;/span&gt;! POSMessage(&lt;span&gt;1021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, apple.code, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;2021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, pineapple.code, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;3021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, banana.code, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;4021&lt;/span&gt;, LogSales(SALESTYPE.plu, &lt;span&gt;&quot;&quot;&lt;/span&gt;, grape.code, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    posref &lt;/span&gt;! POSMessage(&lt;span&gt;4021&lt;/span&gt;&lt;span&gt;,Subtotal)



    scala.io.StdIn.readLine()

    system.terminate()

  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client/Commands.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Commands {

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait POSCommand {}

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogOn(opr: String, passwd: String) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; LogOff extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SuperOn(su: String, passwd: String) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; SuperOff extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MemberOn(cardnum: String, passwd: String) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; MemberOff extends POSCommand   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;remove member status for the voucher&lt;/span&gt;
  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; RefundOn extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; RefundOff extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; VoidOn extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; VoidOff extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; VoidAll extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Suspend extends POSCommand

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VoucherNum(vnum: Int) extends POSCommand


  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogSales(salesType: Int, dpt: String, code: String, qty: Int, price: Int) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Subtotal extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Discount(code: String, percent: Int) extends POSCommand

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OfflinePay(acct: String, num: String, amount: Int) extends POSCommand          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;settlement   结算支付
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;read only command, no event process&lt;/span&gt;
  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VCBalance(acct: String, num: String, passwd: String) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VCPay(acct: String, num: String, passwd: String, amount: Int) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AliPay(acct: String, num: String, amount: Int) extends POSCommand
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WxPay(acct: String, num: String, amount: Int) extends POSCommand


  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; read only command, no update event&lt;/span&gt;
  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Plu(itemCode: String) extends POSCommand  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;read only&lt;/span&gt;

  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSMessage(id: Long, cmd: POSCommand) {
    def shopId &lt;/span&gt;=&lt;span&gt; id.toString.head.toString
    def posId &lt;/span&gt;=&lt;span&gt; id.toString
  }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client/States.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; States {

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; TXNTYPE {
    val sales: Int &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    val refund: Int &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    val &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;: Int = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    val voided: Int &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    val voidall: Int &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    val subtotal: Int &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
    val logon: Int &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
    val supon: Int &lt;/span&gt;= &lt;span&gt;7&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; super user on/off&lt;/span&gt;
    val suspend: Int = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;

  }

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SALESTYPE {
    val plu: Int &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    val dpt: Int &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    val cat: Int &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    val brd: Int &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    val ra:  Int &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    val sub: Int &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
    val ttl: Int &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
    val dsc: Int &lt;/span&gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;
    val crd: Int &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
  }


  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TxnItem(
                      txndate: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,txntime: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,opr: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工号&lt;/span&gt;
                      ,num: Int = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销售单号&lt;/span&gt;
                      ,seq: Int = &lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易序号&lt;/span&gt;
                      ,txntype: Int = TXNTYPE.sales&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易类型&lt;/span&gt;
                      ,salestype: Int = SALESTYPE.plu &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销售类型&lt;/span&gt;
                      ,qty: Int =  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易数量&lt;/span&gt;
                      ,price: Int = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单价（分）&lt;/span&gt;
                      ,amount: Int = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;码洋（分）&lt;/span&gt;
                      ,dscamt: Int = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;折扣：负值  net实洋 = amount + dscamt&lt;/span&gt;
                      ,member: String = &lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;会员卡号&lt;/span&gt;
                      ,code: String = &lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编号（商品、账号...）&lt;/span&gt;
                      ,desc: String = &lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;项目名称&lt;/span&gt;
                      ,dpt: String = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,department: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,cat: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,category: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,brd: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      ,brand: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                    )


  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VchStatus( &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作状态锁留给前端维护&lt;/span&gt;
                        qty: Int = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        refund: Boolean &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;: Boolean = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VchStates(
                        opr: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;收款员&lt;/span&gt;
                        jseq: BigInt = &lt;span&gt;0&lt;/span&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;begin journal sequence for read-side replay&lt;/span&gt;
                        num: Int = &lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前单号&lt;/span&gt;
                        seq: Int = &lt;span&gt;1&lt;/span&gt;,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前序号&lt;/span&gt;
                        &lt;span&gt;void&lt;/span&gt;: Boolean = &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消模式&lt;/span&gt;
                        refd: Boolean = &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;退款模式&lt;/span&gt;
                        due: Boolean = &lt;span&gt;true&lt;/span&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前余额&lt;/span&gt;
                        su: String = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                        mbr: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                      )


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client/POSClient.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client

import akka.actor._
import sdp.logging._
import Responses._
import Commands._

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; POSClient {
  def props(pos: ActorRef) &lt;/span&gt;= Props(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; POSClient(pos))
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSClient(posHandler: ActorRef)  extends Actor with LogSupport {

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def receive: Receive =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; msg @ POSMessage(_,_) =&amp;gt; posHandler !&lt;span&gt; msg
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; resp: POSResponse  =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;response from server: $resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client/Responses.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client

import States._
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Responses {

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; STATUS {
    val OK: Int &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    val FAIL: Int &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  }

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; POSResponse (sts: Int, msg: String, voucher: VchStates, txnItems: List[TxnItem])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;client/DataAccess.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package cloud.pos.client

import java.time.LocalDate
import java.time.format.DateTimeFormatter


&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Item(
                 brd: String
                 ,dpt: String
                 ,cat: String
                 ,code: String
                 ,name: String
                 ,price: Int

               )
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Items {
  val apple &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;green apple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;820&lt;/span&gt;&lt;span&gt;)
  val grape &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red grape&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1050&lt;/span&gt;&lt;span&gt;)
  val orage &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sunkist orage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;&lt;span&gt;)
  val banana &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demon banana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
  val pineapple &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hainan pineapple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1300&lt;/span&gt;&lt;span&gt;)
  val peach &lt;/span&gt;= Item(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;006&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xinjiang peach&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2390&lt;/span&gt;&lt;span&gt;)

  val tblItems &lt;/span&gt;=&lt;span&gt; List(apple, grape, orage, banana, pineapple, peach)

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait QueryItemsResult {}

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryItemsOK(items: List[Item]) extends QueryItemsResult

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryItemsFail(msg: String) extends QueryItemsResult

}


&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Codes {
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User(code: String, name: String, passwd: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Department(code: String, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Category(code: String, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Brand(code: String, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Ra(code: String, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account(code: String, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Disc(code: String, best: Boolean, aggr: Boolean, group: Boolean)

  val ras &lt;/span&gt;= List(Ra(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delivery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Ra(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cooking&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val dpts &lt;/span&gt;= List(Department(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fruit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Department(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Grocery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val cats &lt;/span&gt;= List(Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fresh Fruit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0201&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dry Grocery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val brds &lt;/span&gt;= List(Brand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sunkist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Brand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  val accts &lt;/span&gt;= List(Account(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Account(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value Card&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Account(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    ,Account(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alipay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),Account(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WXPay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

  val users &lt;/span&gt;= List(User(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tiger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),User(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),User(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Maria&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

  def getDpt(code: String) &lt;/span&gt;= dpts.find(d =&amp;gt; d.code ==&lt;span&gt; code)
  def getCat(code: String) &lt;/span&gt;= cats.find(d =&amp;gt; d.code ==&lt;span&gt; code)
  def getBrd(code: String) &lt;/span&gt;= brds.find(b =&amp;gt; b.code ==&lt;span&gt; code)
  def getAcct(code: String) &lt;/span&gt;= accts.find(a =&amp;gt; a.code ==&lt;span&gt; code)
  def getRa(code: String) &lt;/span&gt;= ras.find(a =&amp;gt; a.code ==&lt;span&gt; code)
}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; DAO {
  import Items._
  import Codes._

  def getItem(code: String): QueryItemsResult &lt;/span&gt;=&lt;span&gt; {
    val optItem &lt;/span&gt;= tblItems.find(it =&amp;gt; it.code ==&lt;span&gt; code)
    optItem match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(item) =&amp;gt;&lt;span&gt; QueryItemsOK(List(item))
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt; QueryItemsFail(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid item code!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
  }

  def validateDpt(code: String) &lt;/span&gt;= dpts.find(d =&amp;gt; d.code ==&lt;span&gt; code)
  def validateCat(code: String) &lt;/span&gt;= cats.find(d =&amp;gt; d.code ==&lt;span&gt; code)
  def validateBrd(code: String) &lt;/span&gt;= brds.find(b =&amp;gt; b.code ==&lt;span&gt; code)
  def validateRa(code: String) &lt;/span&gt;= ras.find(ac =&amp;gt; ac.code ==&lt;span&gt; code)
  def validateAcct(code: String) &lt;/span&gt;= accts.find(ac =&amp;gt; ac.code ==&lt;span&gt; code)

  def validateUser(userid: String, passwd: String) &lt;/span&gt;= users.find(u =&amp;gt; (u.code == userid &amp;amp;&amp;amp; u.passwd ==&lt;span&gt; passwd))

  def lastSecOfDateStr(ldate: LocalDate): String &lt;/span&gt;=&lt;span&gt; {
    ldate.format(DateTimeFormatter.ofPattern( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 23:59:59&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging/Log.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package sdp.logging

import org.slf4j.Logger

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * Logger which just wraps org.slf4j.Logger internally.
  *
  * @param logger logger
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Log(logger: Logger) {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use var consciously to enable squeezing later&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; isDebugEnabled: Boolean =&lt;span&gt; logger.isDebugEnabled
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isInfoEnabled: Boolean =&lt;span&gt; logger.isInfoEnabled
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isWarnEnabled: Boolean =&lt;span&gt; logger.isWarnEnabled
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isErrorEnabled: Boolean =&lt;span&gt; logger.isErrorEnabled

  def withLevel(level: Symbol)(msg: &lt;/span&gt;=&amp;gt; String, e: Throwable = &lt;span&gt;null&lt;/span&gt;): Unit =&lt;span&gt; {
    level match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;debug | &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;DEBUG =&amp;gt;&lt;span&gt; debug(msg)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;info | &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;INFO =&amp;gt;&lt;span&gt; info(msg)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;warn | &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;WARN =&amp;gt;&lt;span&gt; warn(msg)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;error | &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ERROR =&amp;gt;&lt;span&gt; error(msg)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nothing to do&lt;/span&gt;
&lt;span&gt;    }
  }

  def debug(msg: &lt;/span&gt;=&amp;gt; String): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDebugEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isDebugEnabled) {
      logger.debug(msg)
    }
  }

  def debug(msg: &lt;/span&gt;=&amp;gt; String, e: Throwable): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDebugEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isDebugEnabled) {
      logger.debug(msg, e)
    }
  }

  def info(msg: &lt;/span&gt;=&amp;gt; String): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isInfoEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isInfoEnabled) {
      logger.info(msg)
    }
  }

  def info(msg: &lt;/span&gt;=&amp;gt; String, e: Throwable): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isInfoEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isInfoEnabled) {
      logger.info(msg, e)
    }
  }

  def warn(msg: &lt;/span&gt;=&amp;gt; String): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isWarnEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isWarnEnabled) {
      logger.warn(msg)
    }
  }

  def warn(msg: &lt;/span&gt;=&amp;gt; String, e: Throwable): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isWarnEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isWarnEnabled) {
      logger.warn(msg, e)
    }
  }

  def error(msg: &lt;/span&gt;=&amp;gt; String): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isErrorEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isErrorEnabled) {
      logger.error(msg)
    }
  }

  def error(msg: &lt;/span&gt;=&amp;gt; String, e: Throwable): Unit =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isErrorEnabled &amp;amp;&amp;amp;&lt;span&gt; logger.isErrorEnabled) {
      logger.error(msg, e)
    }
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging/LogSupport.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package sdp.logging

import org.slf4j.LoggerFactory

trait LogSupport {

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
    * Logger
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;protected&lt;/span&gt; val log = &lt;span&gt;new&lt;/span&gt; Log(LoggerFactory.getLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass))

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging/ClusterMonitor.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package sdp.cluster.monitor

import akka.actor._
import akka.cluster.ClusterEvent._
import akka.cluster._
import sdp.logging.LogSupport

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ClusterMonitor {
  def props &lt;/span&gt;= Props(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClusterMonitor())
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClusterMonitor extends Actor with LogSupport {
  val cluster &lt;/span&gt;=&lt;span&gt; Cluster(context.system)
  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def preStart(): Unit =&lt;span&gt; {
    cluster.subscribe(self,initialStateMode &lt;/span&gt;=&lt;span&gt; InitialStateAsEvents
      ,classOf[MemberEvent],classOf[UnreachableMember])  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅集群状态转换信息&lt;/span&gt;
&lt;span&gt;    super.preStart()
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def postStop(): Unit =&lt;span&gt; {
    cluster.unsubscribe(self)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消订阅&lt;/span&gt;
&lt;span&gt;    super.postStop()
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def receive: Receive =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberJoined(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Joining: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberUp(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Up: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberLeft(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Leaving: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberExited(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Exiting: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MemberRemoved(member, previousStatus) =&amp;gt;&lt;span&gt;
      log.info(
        s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member is Removed: {${member.address}} after {${previousStatus}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; UnreachableMember(member) =&amp;gt;&lt;span&gt;
      log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member detected as unreachable: {${member.address}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      cluster.down(member.address)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手工驱除，不用auto-down&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; _: MemberEvent =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignore&lt;/span&gt;
&lt;span&gt;  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 06 Apr 2019 12:55:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>上篇我们做了一个WriterActor的例子，主要目的是示范WriterActor如何作为集群分片用persistentActor特性及event-sourcing模式实现CQRS的写功能。既然是集群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/10662854.html</dc:identifier>
</item>
<item>
<title>Spring Boot 项目实战（六）集成 Apollo - 枫本非凡</title>
<link>http://www.cnblogs.com/orzlin/p/10662492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/orzlin/p/10662492.html</guid>
<description>&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;上篇介绍了 Spring Boot 集成 Dubbo，使我们的系统打下了分布式的基础。随着程序功能的日益复杂，程序的配置日益增多：各种功能开关、参数配置、服务器地址等；对程序配置的期望值也越来越高：配置修改后实时生效，灰度发布，分环境、分集群管理配置，完善的权限、审核机制等；在这样的大环境下，传统的通过配置文件、数据库等方式已经越来越无法满足开发人员对配置管理的需求。分布式配置中心应运而生。本篇将主要介绍分布式配置中心 Apollo 的集成过程。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二部署-apollo&quot;&gt;二、部署 Apollo&lt;/h3&gt;
&lt;p&gt;① 部署教程见官方文档：&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97&quot; class=&quot;uri&quot;&gt;https://github.com/ctripcorp/apollo/wiki/分布式部署指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;② 架构剖析：&lt;a href=&quot;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_0.png&quot; alt=&quot;SpringBoot_6_0.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;三使用-apollo&quot;&gt;三、使用 Apollo&lt;/h3&gt;
&lt;p&gt;① 登录 Apollo 管理控制台后创建项目，其中应用 ID 全局唯一。&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_1.png&quot; alt=&quot;SpringBoot_6_1.png&quot;/&gt;&lt;br/&gt;② 创建成功后跳转到项目维护界面，左侧上方为环境列表，中间区域为项目信息，下方可操作集群及 namespace 。右侧为默认 namespace ：&lt;strong&gt;application&lt;/strong&gt; ，具体配置项在此区域维护。&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_2.png&quot; alt=&quot;SpringBoot_6_2.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;四spring-boot-集成-apollo&quot;&gt;四、Spring Boot 集成 Apollo&lt;/h3&gt;
&lt;h4 id=&quot;引入-apollo-依赖包&quot;&gt;4.1 引入 Apollo 依赖包&lt;/h4&gt;
&lt;p&gt;① 首先在项目父 pom 文件中声明 Apollo 依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        ...省略其余部分...
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.ctrip.framework.apollo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;apollo-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;② 其次在 demo-biz 层中的 pom 文件添加上述 Apollo 依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    ...省略其余部分...
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.ctrip.framework.apollo&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;apollo-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;添加-apollo-配置项&quot;&gt;4.2 添加 Apollo 配置项&lt;/h4&gt;
&lt;p&gt;① 在 application.properties 文件中的添加 Apollo 相关的配置项：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# 应用全局唯一的身份标识
app.id = 20000
# Apollo Meta Server 地址
apollo.meta = http://xxx.xxx.xxx.xxx:7881
# 自定义本地配置文件缓存路径
apollo.cacheDir = ./config
# 设置在应用启动阶段就加载 Apollo 配置
apollo.bootstrap.enabled = true
# 注入 application namespace
apollo.bootstrap.namespaces = application&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;② 将 application.properties 文件中的除了 Apollo 及 Logback 的其他配置项都转移到 Apollo 控制台中维护。&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_3.png&quot; alt=&quot;SpringBoot_6_3.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;验证-apollo&quot;&gt;4.3 验证 Apollo&lt;/h4&gt;
&lt;p&gt;① 启动日志中可以看到 Apollo 从 Meta Server 拉取配置项，并缓存到本地 config 目录。&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_4.png&quot; alt=&quot;SpringBoot_6_4.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_5.png&quot; alt=&quot;SpringBoot_6_5.png&quot;/&gt;&lt;br/&gt;② 访问 &lt;a href=&quot;http://localhost:8080/demo/test?id=1&quot; class=&quot;uri&quot;&gt;http://localhost:8080/demo/test?id=1&lt;/a&gt; 接口正常返回。&lt;/p&gt;
&lt;h4 id=&quot;托管-logback-配置项&quot;&gt;4.4 托管 Logback 配置项&lt;/h4&gt;
&lt;p&gt;① Apollo 1.2.0 版本后支持托管日志相关配置项，只需要在 application.properties 文件中增加以下 Apollo 配置项。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# 将 Apollo 配置加载提到初始化日志系统之前，需要托管日志配置时开启
apollo.bootstrap.eagerLoad.enabled = true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;② 将 Logback 配置项转移到 Apollo 控制台中维护。&lt;/p&gt;
&lt;h4 id=&quot;本地开发模式&quot;&gt;4.5 本地开发模式&lt;/h4&gt;
&lt;p&gt;某些情况下比如 Dubbo 接口本地联调，需要修改依赖方的接口版本，此时可以开启本地开发模式，在本地开发模式下，Apollo 只会从本地文件读取配置信息，不会从 Apollo 服务器读取配置。通过&lt;strong&gt;设置 JVM 参数&lt;/strong&gt;开启。&lt;br/&gt;&lt;img src=&quot;http://blog.shoegaze.com/SpringBoot_6_6.png&quot; alt=&quot;SpringBoot_6_6.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;dubbo-及-apollo-的兼容问题&quot;&gt;4.6 Dubbo 及 Apollo 的兼容问题&lt;/h4&gt;
&lt;p&gt;官方在集成 Dubbo 及 Apollo 时提供了两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 纯 Spring Boot 方式；即依赖 dubbo-spring-boot-starter 包。&lt;/li&gt;
&lt;li&gt;② 原生 Dubbo 方式；即依赖 dubbo 、zookeeper 、 zkclient 、curator-framework 包，然后通过 XML 方式配置，配置项用 ${} 占位符。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而我当时为了能清楚知道，对外提供了哪些 Dubbo 接口以及依赖了哪些外部 Dubbo 接口，使用 Spring XML 的形式配置 Dubbo，同时又依赖了 dubbo-spring-boot-starter 包，结果将 Dubbo 配置项托管至 Apollo 后，出现无法找到 Dubbo 配置项的情况。原因是&lt;strong&gt;通过 Spring XML 方式配置 Dubbo 时所依赖的 OverrideDubboConfigApplicationListener 执行时机太早了（远早于 Apollo 配置加载的时机）&lt;/strong&gt;。Apollo 1.2.0 版本支持「 apollo.bootstrap.eagerLoad.enabled 」配置项后虽然能解决这个问题，但还是不推荐 dubbo-spring-boot-starter + XML 这种形式的配置方式，推荐纯 Spring Boot 方式。&lt;/p&gt;
&lt;blockquote readability=&quot;1.0833333333333&quot;&gt;
&lt;p&gt;注：详见 &lt;a href=&quot;https://github.com/ctripcorp/apollo/issues/1600&quot; class=&quot;uri&quot;&gt;https://github.com/ctripcorp/apollo/issues/1600&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;五结语&quot;&gt;五、结语&lt;/h3&gt;
&lt;p&gt;至此 Spring Boot 集成 Apollo 的过程介绍完毕，相关代码已同步至 GitHub 。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Apr 2019 10:29:00 +0000</pubDate>
<dc:creator>枫本非凡</dc:creator>
<og:description>一、前言 上篇介绍了 Spring Boot 集成 Dubbo，使我们的系统打下了分布式的基础。随着程序功能的日益复杂，程序的配置日益增多：各种功能开关、参数配置、服务器地址等；对程序配置的期望值也越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/orzlin/p/10662492.html</dc:identifier>
</item>
<item>
<title>es6常用功能与异步详解（JS高级面试题） - 芙蓉0504</title>
<link>http://www.cnblogs.com/hibiscus-ben/p/10662245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hibiscus-ben/p/10662245.html</guid>
<description>&lt;p&gt;&lt;strong&gt;callback hell方法的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可读性不友好&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function loadImg(src,callback,fail){
    var img = document.createElement('img');
    img.onload = function(){
        callback(img);
    }
    img.onerror = function(){
        fail();
    }
    img.src = src;
}
var src = &quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot;;

loadImg(src,function(img){
    console.log('img width',img.width)
},function(){
    console.log('faild')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;用promise 去改造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用多个.then去分批处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function loadImg(src){
    return new Promise(function(resolve,reject){
        var img = document.createElement('img');
        img.onload = function(){
            resolve(img);
        }
        img.onerror = function(){
            reject();
        }
        img.src = src;
    })
}
var src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot;;
var result = loadImg(src);
result.then(function(img){
    console.log('img width',img.width)
},function(){
    console.log('faild')
})
result.then(function(img){
    console.log('img height',img.height)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题解答：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;new promise实例，而且要传入return&lt;/li&gt;
&lt;li&gt;new promise时要传入函数，函数有resolve reject函数&lt;/li&gt;
&lt;li&gt;成功时执行resolve()失败时执行reject()&lt;/li&gt;
&lt;li&gt;.then监听结果&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;es6常用功能&quot;&gt;ES6常用功能&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;let 定义变量，可以重新赋值&lt;/li&gt;
&lt;li&gt;const 定义常量，不可以重新赋值&lt;/li&gt;
&lt;li&gt;多行字符串/模板变量&lt;/li&gt;
&lt;li&gt;解构赋值（详情见es6）&lt;/li&gt;
&lt;li&gt;块级作用域（很大的改动）&lt;/li&gt;
&lt;li&gt;函数默认参数&lt;/li&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;块级作用域&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 在js里面 --&amp;gt;
var obj = {a:100,b:200}
for (var key in obj) {
    console.log(key,'for in')
}
console.log(key)  // 100,200

&amp;lt;!-- 在es6 --&amp;gt;
var obj = {a:100,b:200}
for (let key in obj) {
    console.log(key,'for in')
}
console.log(key); // undefine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;箭头函数改变this指向的问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 用箭头函数，指向本身函数对象 --&amp;gt;
function fn(){
    console.log('real',this); // {a:100}

    var arr = [1,2,3];
    arr.map(item=&amp;gt;{
        console.log(this); // {a:100}
    })
}
fn.call({a:100}); // call是强制让fn函数对象指向{a:100}

&amp;lt;!-- 不用箭头函数,this指向window --&amp;gt;
function fn(){
    console.log('real',this); // {a:100}

    var arr = [1,2,3];
    arr.map(function(item){
        console.log(this); // window;
    })
}
fn.call({a:100});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原型&quot;&gt;原型&lt;/h2&gt;
&lt;p&gt;描述一下zepto是如何使用原型&lt;br/&gt;描述一下jquery如何使用原型&lt;br/&gt;再结合自己的项目经验，说一个自己开发的列子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$p.css('color','red'); // css是原型方法
$p.html(); // html是原型方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原型如何体现他的扩展性&lt;/p&gt;
&lt;h2 id=&quot;异步&quot;&gt;异步&lt;/h2&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;h5 id=&quot;一.-什么是单线程和异步有什么关系&quot;&gt;一. 什么是单线程，和异步有什么关系&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;单线程只有一个线程，同一时间只能做一件事情&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;var i,sum = 0;
for(i=0;i&amp;lt;100000;i++){
    sum+=i;
}
console.log(sum);

&amp;lt;!-- alert不处理，js执行和dom渲染暂时卡顿 --&amp;gt;
console.log(1);
alert('hello');
console.log(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;用单线程的原因-避免DOM渲染的冲突&lt;br/&gt;A. 浏览器需要渲染DOM&lt;/p&gt;
&lt;p&gt;B. js可以修改DOM结构&lt;/p&gt;
&lt;p&gt;C. JS执行的时候，浏览器DOM渲染会暂停&lt;/p&gt;
&lt;p&gt;D. 两段JS也不能同时执行（都修改DOM就冲突了）&lt;/p&gt;
&lt;p&gt;E. webworder支持多线程，但是不能访问DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单线程的解决单线程方案-异步&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    console.log(100)
    setTimeout(function(){
        console.log(200);
    },1000)
    console.log(300);
    console.log(400);
    // 100
    // 300
    // 400
    // 200  一秒后执行&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;console.log(100)
$.ajax({
    url:'XXXX',
    success:function(res){
        console.log(res) // 最后执行
    }
});
console.log(300)
cobsole.log(400)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步的问题：&lt;/p&gt;
&lt;p&gt;问题一：没有按照书写的方式执行，可读性差&lt;/p&gt;
&lt;p&gt;问题二：callback中不容易模块化（setTimeout和ajax里面的函数）&lt;/p&gt;
&lt;h5 id=&quot;二.-什么是event-loop-异步的解决方案&quot;&gt;二. 什么是event-loop 异步的解决方案。&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;事件轮询，js实现异步的具体解决方案&lt;/li&gt;
&lt;li&gt;同步代码，直接执行&lt;/li&gt;
&lt;li&gt;异步函数先放在异步队列中；有setTimeout等待时间过后，才放入异步队列中。ajax执行完毕过后放入异步队列&lt;/li&gt;
&lt;li&gt;待同步函数执行完毕，轮询执行异步队列的函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回答点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么是异步队列，何时被放入异步队列&lt;/li&gt;
&lt;li&gt;轮询的过程。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;三.-是否用过jquery的deferred&quot;&gt;三. 是否用过jquery的deferred&lt;/h5&gt;
&lt;p&gt;问题解答：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 可以拿jquery1.5 对ajax的改变举例

2. 说明如何简单的封装、使用deferred，说出它的好处

3. 说明promise和deferred的区别&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jQuery1.5的变化——1.5之前&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ajax = $.ajax({
    url:'./data.json',
    success:function(){
        console.log('success 1');
        console.log('success 2');
        console.log('success 3');
    },
    error:function(){
        console.log('error');
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jQuery1.5的变化——1.5之后&lt;br/&gt;&lt;strong&gt;这样写的好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这样对修改封闭，对扩展开放，&lt;/li&gt;
&lt;li&gt;增加一个函数，不用再修改原来的函数&lt;/li&gt;
&lt;li&gt;多人开发，一人维护一个函数。&lt;/li&gt;
&lt;li&gt;测试也只测试新的函数。&lt;/li&gt;
&lt;li&gt;对代码管理和维护有好处的&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 每一个方法都会执行
var ajax = $.ajax('data.json');
ajax.done(function(){
    console.log('success 1');  
}).fail(function(){
  console.log('fail 1');  
}).done(function(){
    console.log('success 2');  
}).fail(function(){
  console.log('fail 2');  
}).done(function(){
    console.log('success 3');  
}).fail(function(){
  console.log('fail 3');  
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 与promise很相近了 --&amp;gt;
var ajax = $.ajax('data.json')
ajax.then(function(){
   console.log('success 1'); 
},function(){
    console.log('error 1');
}).then(function(){
   console.log('success 2'); 
},function(){
    console.log('error 2');
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;无法改变js异步和单线程的本质&lt;/li&gt;
&lt;li&gt;只能从写法上杜绝callback这种形式&lt;/li&gt;
&lt;li&gt;它是一种语法糖形式，但是解耦了代码&lt;/li&gt;
&lt;li&gt;很好的体现：开放封闭原则&lt;/li&gt;
&lt;li&gt;减少了回归测试的成本。多人开发方便。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用jquery deferred举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var wait = function(){
    var task = function(){
        console.log('执行完成');
    }
    setTimeout(task,20000)
}
wait();&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;function waitHandle(){
    // 定义 
    var dtd = $.Deferred();
    
    var wait = function(dtd){
    
        var task = function(){
            console.log('执行完毕');
            // 成功
            dtd.resolve()
            // 失败
            // dtd.reject()
        }
        setTimeout(task,2000);
        
        // wait返回
        return dtd;
    }
    
    // 最终返回
    return wait(dtd);
}

var w = waitHandle();
w.then(function(){
    console.log('ok 1');
},function(){
    console.log('err 1');
})
w.then(function(){
    console.log('ok 2');
},function(){
    console.log('err 2');
})
w.then(function(){
    console.log('ok 3');
},function(){
    console.log('err 3');
})

w.reject();  //  不会报错


// 开放封闭原则！！！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;br/&gt;dtd的API可分成两类，用意不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一类：dtd.reolve  dtd.reject  主动触发

第二类：dtd.then  dtd.done  dtd.fail  被动监听&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初步引入promise概念，是 jquery deferred 引入过来的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;promise和jquery deferred的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;promise对象只能被动监听，不能主动修改，所以在w.reject()会报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function waitHandle(){
    // 定义 
    var dtd = $.Deferred();
    
    var wait = function(dtd){
    
        var task = function(){
            console.log('执行完毕');
            // 成功
            dtd.resolve()
            // 失败
            // dtd.reject()
        }
        setTimeout(task,2000);
        
        // wait返回
        return dtd.promise(); // 这里返回的是promise对象
    }
    
    // 最终返回
    return wait(dtd);
}
var w = waitHandle();
$.when(w).then(function(){
    console.log('ok 1');
},function(){
    console.log('err 1');
}).then(function(){
    console.log('ok 2');
},function(){
    console.log('err 2');
})

w.reject();  // 这里就会直接报错。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;四.-promise的基本使用和原理&quot;&gt;四. promise的基本使用和原理&lt;/h5&gt;
&lt;p&gt;基本语法回顾&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 异常捕获&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function loadImg(src){
    return new Promise(resolve,reject){
        var img = document.createElement('img');
        img.onload = function(){
            resolve(img);
        }
        img.onerror = function(){
            reject('图片加载失败');
        }
        img.src=  src;
    }
}

var src=&quot;https://wwww.img.address&quot;;
var result = loadimg(src);
// 规定：then只接受一个成功的参数，最后统一用catch来捕获错误
result.then(function(img){
    console.log(1,img.width);
    return img;
}).then(function(img){
    console.log(2,img.width);
}).catch(function(ex){
    // 统一捕获异常，也会捕获到reject方法
    console.log(ex);
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 多个串联&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 场景：希望加载完第一个，再加载第二个
var src1 = 'img.address';
var result1 = loadImg(src1);
var src2 = 'img.address';
var result2 = loadImg(src2);

result1.then(function(img1){
    console.log('加载第一章图片',img1.width);
    return result2  // 重要！！！
}).then(function(img2){
    console.log('加载第二章图片',img2.width);  
}).catch(function(ex){
    console.log(ex);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. promise.all和promise.race&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Promise.all接收一个promise对象的数组
// 待全部完成之后，统一执行success
Promise.all([result1,result2]).then(datas=&amp;gt;{
    // 接收到的datas是一个数组，依次包含了多个promise返回的内容
    console.log(datas[0]);
    console.log(datas[1]);
})

// Promise.race 接收一个包含多个promise对象的数组
// 只要有一个完成，就执行success
Promise.race([result1,result2]).then(data=&amp;gt;{
    // data 是最先执行完成的 promise对象的返回值
    console.log(datas);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. promise标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于“标准”的闲谈，标准很重要&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    任何技术推广使用都需要一套标准来支撑
    如 html js css http等，无规则不成方圆
    任何不符合标准的东西，终将会被用户抛弃&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    三种状态：pending fulfilled rejected
    初始状态pending
    pending 变成fulfilled，或者pending变为rejected
    状态不可逆&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;promise 实例必须实现then这个方法
then()必须可以接收两个函数作参数
then()返回的必须是一个promise实例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题解答总结：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 基本语法复习
2. 如何异常捕获（error和reject都要考虑）
3. 多个串联-链式执行的好处
4. promise.all和promise.race
5. promise标准-状态变化，then函数&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;五.-介绍一下-asyncawait&quot;&gt;五. 介绍一下 async/await&lt;/h5&gt;
&lt;p&gt;是es7体验中的。&lt;/p&gt;
&lt;p&gt;then只是将callback拆分了&lt;/p&gt;
&lt;p&gt;async/await是最直接的同步写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const load = async function(){
    const result1 = await loadImg(src1);
    console.log(result1);
    const result2 = await loadImg(src1);
    console.log(result2);
}
load()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;语法（和promise的区别和联系）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 使用await，函数必须用async标识
2. await 后面跟的是一个promise实例
    使用了promise，并没有和promise冲突
    完全是同步的写法，再也没有回调函数
    但是：改变不了JS单线程、异步的本质
3. 需要安装babel-polyfill并，引入&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;六.-总结当前js异步解决方案&quot;&gt;六. 总结当前js异步解决方案&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;1. jQuery Deferred
2. Promise
3. async/await
4. generator（并不是解决异步的，原理比较复杂，忽略）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 06 Apr 2019 09:05:00 +0000</pubDate>
<dc:creator>芙蓉0504</dc:creator>
<og:description>callback hell方法的使用 可读性不友好 用promise 去改造 用多个.then去分批处理 问题解答： 1. new promise实例，而且要传入return 1. new promi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hibiscus-ben/p/10662245.html</dc:identifier>
</item>
</channel>
</rss>