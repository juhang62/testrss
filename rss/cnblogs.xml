<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解static关键字 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11939538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11939538.html</guid>
<description>&lt;p&gt;在开始讲static之前，我想让各位看一段有意思的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Test {
     
    static{
        System.out.println(&quot;test static 1&quot;);
    }
  
    static{
        System.out.println(&quot;test static 2&quot;);
    }
    
    public static void main(String[] args) {
         
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完程序，小白童鞋发话了：啥玩意？main方法中啥都没有，能运行啥？博主你个星星星...&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;运行结果：
test static 1
test static 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白童鞋:那啥...那啥...博主我说啥了，我啥都没说...&lt;/p&gt;
&lt;p&gt;其实，上面的代码懂的自然懂，不懂的自然就不懂了，因为上面的代码涉及到JVM的类加载了！当然不在本篇博客文章的范畴内，如果有兴趣理解上面的程序，这篇文章可能会对你有所帮助&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102983363&quot;&gt;别翻了，这篇文章绝对让你深刻理解java类的加载以及ClassLoader源码分析【JVM篇二】&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;static的主要意义是在于创建独立于具体对象的域变量或者方法。&lt;span&gt;&lt;strong&gt;以致于即使没有创建对象，也能使用属性和调用方法&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;static关键字还有一个比较关键的作用就是 &lt;span&gt;&lt;strong&gt;用来形成静态代码块以优化程序性能&lt;/strong&gt;&lt;/span&gt;。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。&lt;/p&gt;
&lt;p&gt;　　为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。&lt;/p&gt;

&lt;p&gt;1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法&lt;span&gt;&lt;strong&gt;不属于任何一个实例对象，而是被类的实例对象所共享&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】...我觉得我已经讲的很通俗了，你明白了咩？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。&lt;/p&gt;
&lt;p&gt;3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！&lt;/p&gt;
&lt;p&gt;4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。&lt;/p&gt;

&lt;p&gt;因为static是被类的实例对象所共享，因此如果&lt;span&gt;&lt;strong&gt;某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此比较常见的static应用场景有：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、修饰成员变量&lt;br/&gt;2、修饰成员方法&lt;br/&gt;3、静态代码块&lt;br/&gt;4、修饰类【只能修饰内部类也就是静态内部类】&lt;br/&gt;5、静态导包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的应用场景将会在下文陆续讲到...&lt;/p&gt;

&lt;p&gt;静态变量：&lt;br/&gt;static修饰的成员变量叫做静态变量【也叫做类变量】，静态变量是属于这个类，而不是属于是对象。&lt;/p&gt;
&lt;p&gt;实例变量：&lt;br/&gt;没有被static修饰的成员变量叫做实例变量，实例变量是属于这个类的实例对象。&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是：&lt;span&gt;&lt;strong&gt;static是不允许用来修饰局部变量&lt;/strong&gt;&lt;/span&gt;，不要问我问什么，因为java规定的！&lt;/p&gt;

&lt;p&gt;静态变量：&lt;br/&gt;静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。&lt;/p&gt;
&lt;p&gt;实例变量：&lt;br/&gt;每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我相信各位智商都比宜春智商要高，应该都能理解上面的话。下面举了例子完全出于娱乐，理解了大可不必看，下面的例子仅供参考，仅供娱乐一下下气氛，赶时间的熊dei大可略过！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怎么理解呢？打个比喻吧...就比方说程序员小王是一个比较温柔阳光的男孩子，这1024的这一天，老板闲的没事，非要拉着程序员小王来玩耍，怎么个玩法呢？老板和小王一人拿着一把菜刀，规则很简单，互相伤害，一人一刀，你一刀，我一刀....游戏一开始，老板二话不说，跳起来就是一刀，程序员小王二话也没说反手就是一菜刀回去，这个时候老板发飙了，双眼瞪得忒大，跳起来又是一刀，这个时候程序员小王不敢还手了，就没动手。没想到老板越来越生猛，左一刀右一刀全程下来差不多砍个半个时....程序员小王一直没有还过手，因为小王知道他是老板...&lt;/p&gt;
&lt;p&gt;这个程序员小王只会在老板第一次挥刀的时候，回老板一刀，之后就不还手了，这个时候我们把程序员小王看做是静态变量，把老板第一次向小王挥刀看做是类加载，把小王回老板一刀看出是分配内存空间，而一人一刀这个回合过程看成是类加载的过程，之后老板的每一刀都看成是创建一次对象。&lt;/p&gt;
&lt;p&gt;连贯起来就是static变量值在类第一次加载的时候分配空间，以后创建类对象的时候不会重新分配&lt;/p&gt;
&lt;p&gt;之后这个老板挨了一刀之后躺医院了一年，一出院回到公司第一件事就是拉程序员宜春出来玩耍，老板殊不知其然，这个博主程序员宜春性格异常暴躁，老板递给程序员宜春一把菜刀，博主宜春一接过菜刀，猝不及防的被老板跳起来就是一刀，程序员宜春痛的嗷了一声，暴躁的程序员宜春还没嗷完，在嗷的同时跳起来就是给老板一刀，接着老板跳起来又是一刀，程序员宜春嗷的一声又是回一刀，老板跳起来又一刀，程序员宜春嗷的一声又是回一刀，只要老板没停程序员宜春就没停，因为程序员宜春知道，就自己这曝脾气，暴躁起来si都敢摸，肯定有几个老铁知道....&lt;/p&gt;
&lt;p&gt;程序员宜春就类似实例变量，每次创建对象，都会为每个对象分配成员变量内存空间，就像老板来一刀，程序员宜春都会回一刀这样子的...&lt;/p&gt;

&lt;p&gt;我们都知道静态变量是属于这个类，而不是属于是对象，static独立于对象。&lt;/p&gt;
&lt;p&gt;但是各位有木有想过：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问【只要访问权限足够允许就行】，不理解没关系，来个代码就理解了&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class StaticDemo {

        static int value = 666;

        public static void main(String[] args) throws Exception{
            new StaticDemo().method();
        }

        private void method(){
            int value = 123;
            System.out.println(this.value);
        }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;猜想一下结果，我猜你的结果是123，哈哈是咩？其实&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;运行结果： 666&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回过头再去品味一下上面的那段话，你就能非常客观明了了，这个思想概念要有只是这种用法不推荐！&lt;/p&gt;
&lt;p&gt;因此小结一下访问静态变量和实例变量的两种方法：&lt;/p&gt;
&lt;p&gt;静态变量：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类名.静态变量&lt;/p&gt;
&lt;p&gt;对象.静态变量(不推荐)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态方法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类名.静态方法&lt;/p&gt;
&lt;p&gt;对象.静态方法(不推荐)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;static修饰的方法也叫做静态方法，不知道各位发现咩有，其实我们最熟悉的static静态方法就是main方法了~小白童鞋：喔好像真的是哦~。由于对于静态方法来说是不属于任何实例对象的，this指的是当前对象，因为static静态方法不属于任何对象，所以就谈不上this了。&lt;/p&gt;
&lt;p&gt;还有一点就是：&lt;span&gt;&lt;strong&gt;构造方法不是静态方法&lt;/strong&gt;！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;先看个程序吧，看看自个是否掌握了static代码块，下面程序代码继承关系为 &lt;strong&gt;BaseThree——&amp;gt; BaseTwo——&amp;gt; BaseOne&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BaseOne类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.initializationblock;

public class BaseOne {

    public BaseOne() {
        System.out.println(&quot;BaseOne构造器&quot;);
    }

    {
        System.out.println(&quot;BaseOne初始化块&quot;);
        System.out.println();
    }

    static {
        System.out.println(&quot;BaseOne静态初始化块&quot;);

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseTwo类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.initializationblock;

public class BaseTwo extends BaseOne {
    public BaseTwo() {
        System.out.println(&quot;BaseTwo构造器&quot;);
    }

    {
        System.out.println(&quot;BaseTwo初始化块&quot;);
    }

    static {
        System.out.println(&quot;BaseTwo静态初始化块&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BaseThree 类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.initializationblock;

public class BaseThree extends BaseTwo {
    public BaseThree() {
        System.out.println(&quot;BaseThree构造器&quot;);
    }

    {
        System.out.println(&quot;BaseThree初始化块&quot;);
    }

    static {
        System.out.println(&quot;BaseThree静态初始化块&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试demo2类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package com.gx.initializationblock;

/*
     注：这里的ABC对应BaseOne、BaseTwo、BaseThree 
 * 多个类的继承中初始化块、静态初始化块、构造器的执行顺序
     在继承中，先后执行父类A的静态块，父类B的静态块，最后子类的静态块，
     然后再执行父类A的非静态块和构造器，然后是B类的非静态块和构造器，最后执行子类的非静态块和构造器
 */
public class Demo2 {
    public static void main(String[] args) {
        BaseThree baseThree = new BaseThree();
        System.out.println(&quot;-----&quot;);
        BaseThree baseThree2 = new BaseThree();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;BaseOne静态初始化块
BaseTwo静态初始化块
BaseThree静态初始化块
BaseOne初始化块

BaseOne构造器
BaseTwo初始化块
BaseTwo构造器
BaseThree初始化块
BaseThree构造器
-----
BaseOne初始化块

BaseOne构造器
BaseTwo初始化块
BaseTwo构造器
BaseThree初始化块
BaseThree构造器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于static代码块运行结果不是很清晰的童鞋，详细讲解请看这篇&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102593419&quot;&gt;Static静态代码块以及各代码块之间的执行顺序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上仅仅是让各位明确代码块之间的运行顺序，显然还是不够的，静态代码块通常用来对静态变量进行一些初始化操作，比如定义枚举类，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public enum WeekDayEnum {
    MONDAY(1,&quot;周一&quot;),
    TUESDAY(2, &quot;周二&quot;),
    WEDNESDAY(3, &quot;周三&quot;),
    THURSDAY(4, &quot;周四&quot;),
    FRIDAY(5, &quot;周五&quot;),
    SATURDAY(6, &quot;周六&quot;),
    SUNDAY(7, &quot;周日&quot;);
 
    private int code;
    private String desc;
 
    WeekDayEnum(int code, String desc) {
        this.code = code;
        this.desc = desc;
    }
 
    private static final Map&amp;lt;Integer, WeekDayEnum&amp;gt; WEEK_ENUM_MAP = new HashMap&amp;lt;Integer, WeekDayEnum&amp;gt;();
 
    // 对map进行初始化
    static {
        for (WeekDayEnum weekDay : WeekDayEnum.values()) {
            WEEK_ENUM_MAP.put(weekDay.getCode(), weekDay);
        }
    }
 
    public static WeekDayEnum findByCode(int code) {
        return WEEK_ENUM_MAP.get(code);
    }
 
    public int getCode() {
        return code;
    }
 
    public void setCode(int code) {
        this.code = code;
    }
 
    public String getDesc() {
        return desc;
    }
 
    public void setDesc(String desc) {
        this.desc = desc;
    }
}　&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然不仅仅是枚举这一方面，还有我们熟悉的单例模式同样也用到了静态代码块，如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Singleton {
    private static Singleton instance;
 
    static {
        instance = new Singleton();
    }
 
    private Singleton() {}
 
    public static Singleton getInstance() {
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。&lt;/p&gt;
&lt;p&gt;还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。&lt;/p&gt;

&lt;p&gt;静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：&lt;/p&gt;
&lt;p&gt;1、它的创建是不需要依赖外围类的创建。&lt;br/&gt;2、它不能使用任何外围类的非static成员变量和方法。&lt;/p&gt;
&lt;p&gt;代码举例（静态内部类实现单例模式）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Singleton {
    
   // 声明为 private 避免调用默认构造方法创建对象
    private Singleton() {
    }
    
   // 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;Singleton&lt;/code&gt; 类加载时，静态内部类 &lt;code&gt;SingletonHolder&lt;/code&gt; 没有被加载进内存。只有当调用 &lt;code&gt;getUniqueInstance()&lt;/code&gt;方法从而触发 &lt;code&gt;SingletonHolder.INSTANCE&lt;/code&gt; 时 &lt;code&gt;SingletonHolder&lt;/code&gt; 才会被加载，此时初始化 &lt;code&gt;INSTANCE&lt;/code&gt; 实例，并且 JVM 能确保 &lt;code&gt;INSTANCE&lt;/code&gt; 只被实例化一次。&lt;/p&gt;
&lt;p&gt;这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。&lt;/p&gt;

&lt;p&gt;静态导包格式：&lt;code&gt;import static&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//  Math. --- 将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用
//  如果只想导入单一某个静态方法，只需要将换成对应的方法名即可
 
import static java.lang.Math.;
//  换成import static java.lang.Math.max;具有一样的效果
 
public class Demo {
    public static void main(String[] args) {
 
        int max = max(1,2);
        System.out.println(max);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态导包在书写代码的时候确实能省一点代码，可以直接调用里面的静态成员，但是会影响代码可读性，所以开发中一般情况下不建议这么使用。&lt;/p&gt;

&lt;p&gt;1、静态只能访问静态。&lt;br/&gt;2、非静态既可以访问非静态的，也可以访问静态的。&lt;/p&gt;

&lt;p&gt;到这里文章本该结束了的，但是static的使用始终离不开final字眼，二者可谓藕断丝连，常常繁见，我觉得还是很有必要讲讲，那么一起来看看下面这个程序吧。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Demo;

class FinalDemo {
    public final double i = Math.random();
    public static double t = Math.random();
}

public class DemoDemo {
    public static void main(String[] args) {

        FinalDemo demo1 = new FinalDemo();
        FinalDemo demo2 = new FinalDemo();
        System.out.println(&quot;final修饰的  i=&quot; + demo1.i);
        System.out.println(&quot;static修饰的 t=&quot; + demo1.t);
        System.out.println(&quot;final修饰的  i=&quot; + demo2.i);
        System.out.println(&quot;static修饰的 t=&quot; + demo2.t);

        System.out.println(&quot;t+1= &quot;+ ++demo2.t );
//      System.out.println( ++demo2.i );//编译失败
      }
}
运行结果：
    final修饰的  i=0.7282093281367935
    static修饰的 t=0.30720545678577604
    final修饰的  i=0.8106990945706758
    static修饰的 t=0.30720545678577604
    t+1= 1.307205456785776
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;static修饰的变量没有发生变化是因为&lt;span&gt;static作用于成员变量只是用来表示保存一份副本&lt;/span&gt;，其不会发生变化。怎么理解这个副本呢？其实static修饰的在类加载的时候就加载完成了（初始化），而且只会加载一次也就是说初始化一次，所以不会发生变化！&lt;/p&gt;
&lt;p&gt;至于final修饰的反而发生变化了？是不是巅覆你对final的看法？关于final详细讲解博主也准备好了一篇文章&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102720206&quot;&gt;程序员你真的理解final关键字吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ok,文章就先到这里了，希望这篇文章能够帮助到你对static的认识，若有不足或者不正之处，希望谅解并欢迎批评指正！&lt;/p&gt;
&lt;p&gt;如果本文章对你有帮助，哪怕是一点点，那就请点一个赞呗，谢谢~&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;《java编程思想》&lt;br/&gt;&lt;a href=&quot;http://baijiahao.baidu.com/s?id=1601254463089390982&amp;amp;wfr=spider&amp;amp;for=pc&quot; class=&quot;uri&quot;&gt;http://baijiahao.baidu.com/s?id=1601254463089390982&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34337272/article/details/82766943&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_34337272/article/details/82766943&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3799052.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dolphin0520/p/3799052.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 00:13:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>在开始讲static之前，我想让各位看一段有意思的代码： 看完程序，小白童鞋发话了：啥玩意？main方法中啥都没有，能运行啥？博主你个星星星... 小白童鞋:那啥...那啥...博主我说啥了，我啥都没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11939538.html</dc:identifier>
</item>
<item>
<title>我的程序员之路——2013年和2014年 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/10544572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/10544572.html</guid>
<description>&lt;p&gt;　　2012年的12月底跳槽到了新公司，新公司在人民广场北京东路那块，也是家小公司。但与前一家公司不同，新公司刚成立，没有稳定的收入来源，一切都是新的，从零开始。今年3月份，我和老同事还回去过一次，看了看这家公司的办公点，发现这幢楼里的很多公司都搬走了，基本是空掉了，物非人非。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317112057900-616269398.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/211606/201903/211606-20190317112113393-1628882386.jpg&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　前半年技术这块是由我那朋友负责的，他为了节约成本，招了好几个实习生，并且客户端只招了Android开发，测试也是后面招的，前期只有开发，没有产品经理，公司整体的技术团队还是比较薄弱的。公司的主营业务是做拼车，类似于现在的滴滴专车和顺风车。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）PHP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里的开发语言用的是PHP，也是从这里开始，我舍弃了C#，开始转用PHP开发。语言基本都是通的，看看语法，没几天就上手了，然后与同事开始开发业务逻辑。作为PHP新手，写出来的代码还是非常丑陋的，为了加快研发速度，选了个CI框架。负责PHP开发的人就两个，我和另外一个实习生，我们既要负责后台的开发，还要负责PC端的开发，以及客户端的接口。工作量是客户端的三倍，但人员配置却比客户端要少，这就导致客户端的接口经常来不及给到。后面又招了个PHP，才慢慢的开始改善。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）地图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　拼车业务就会用到地图，选择起始点和结束点，以及选取最优线路等。那时候选用的是百度地图，百度为第三方提供了开放的JavaScript脚本，我在那个时候开始学习使用第三方API。当时是个前端菜鸟，有些异步操作都没看出来，老用同步的写法，经常会取不到正确的数据，后面慢慢研究，发现了其中的门路。那时候工作充满热情，经常会熬到晚上十点多才走，一直在研究地图的使用。可惜没把当时的研究成果记录下来，很多都没用到的代码都没留下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）换血&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　后面又陆陆续续的进来新的同事，马上要到第一期交付的时候，但系统还没像样的雏形，只得加班加点的做。我离家比较远，有一段时间就直接住在附近的宾馆里，晚上加完班就回宾馆。交付的前一晚，我和另外两个同事通宵调试了一晚，第二天才勉强能演示。几位股东看了成品后，表示非常的不满意，离他们的预期相差甚远。他们想要的是和我们模仿的网站相同的功能，但我们给出的却是一个非常简陋的雏形。股东们把软件开发想的太简单了，以为人到了，产品就能出来了。我们是一个新组建的团队，什么都没有，全部从零开始，而且大家可以说都是新手，客户端的几个人原先也不是做Android的，后端也是PHP新手，项目也没有细致的规划，新团队还需要磨合期，总之有很多的问题。最后的结果是把我朋友下放，重新从外面找人来管团队。&lt;/p&gt;

&lt;p&gt;　　很快，替代的人就来了，他首先裁掉了几个客户端的人，然后又招了设计、iOS和运维，替换掉了原先的CI框架，改用ZF框架。新的负责人来了以后，明显的变化就是钱烧的快了。股东给他的要求是三个月时间，完成要模仿的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）日报&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　新负责人来了以后就要求我们每天写日报，然后发给他。每天还要开会，叙述今天遇到的问题，后面开会的成本太高，就取消了会议，日报继续发。大家没有受上半年的影响，热情依旧是非常高的，每天还是在努力工作着。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）项目管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　但是项目管理依旧还是有点混乱，后面用他的话讲就是他喜欢散养，不会约束每个人。但由于没有即时的反馈，项目做着做着就又出现了偏差，并且没有原型设计，需求只靠一张嘴，经常出现扯皮的情况，有些功能没有想象中的那么简单，深究一下就会发现很复杂。就比如要做个IM系统，需要能上传语音、图片和文字，客户端的同事花了点时间完成基本功能，后端的我们还要考虑如何保存这些数据。还有个钱包功能，股东们想让用户把钱存到账户中，公司就能有一个现金池，想法很好，但这种财务功能得非常严密，不能出现金额的差错，实现起来又是很费劲。三个月很快就到了，又到了演示的时候，中途开发的时候砍掉了好多复杂的需求，就只完成了拼车业务，股东们还不是非常满意。本来说好项目上线要去神农架自驾旅行，后面改到三清山和洞头岛。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）旅行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用负责人常说的一句话就是：“丑媳妇还是要见公婆的”。我们的产品最终还是上线了，虽然没有达到预期，但好歹能用了，上线后，还是有一点点的用户量。过了几天，公司同事一行人就开了三辆车出发去旅行了，公司解散前的唯一一次旅行。玩的还是蛮开心的，就是自驾坐在车上的时间有点长，有一天晚上九点才到目的地，然后吃顿晚饭，还是蛮辛苦的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）解散&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　大股东迟迟看不到成效，就取消了投资。撤资后，公司的另外几个股东想开辟新的业务，类似于美团外卖，不过就是送指定商品，但没有搞起来。最终还是在2013年的12月份，公司先后裁掉了两批员工后，彻底解散了，大家都拿到了相应的赔偿款，为期一年的创业以失败告终。&lt;/p&gt;
&lt;p&gt;　　这一年有很多收获，不仅仅是编程方面，还有项目管理、产品设计、团队协作等各方面都有新的感悟。&lt;/p&gt;

&lt;p&gt;　　这一年是比较昏暗的一年，我换了三家公司，这其实是一种很不好的情况，跳槽太频繁了，但也逼不得已而为之。&lt;/p&gt;
&lt;p&gt;　　这家就是我实习和兼职的那家公司，当时和老板一直有联系，他希望我过去帮忙，但我一直婉拒。后面公司解散了，把我们安排到另外一家公司去，我们都不想去，就全部自谋出路了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）面谈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　没有合适的去处，就去这家旅游公司了。当时的情况有所不同，我主动过去的，公司老板姿态就高了，开始压工资，换成现在的我肯定马上就走人了。不过那时候还是职场新人，资历不够，也没合适的地方去，就也没说啥了，工资很低，但承诺给我奖金。于是下周一就正式去上班了，去公司的时候发现又换了一波人，私企的常态，人员流动非常大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）接盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　公司招了一个开发，那老伙身体不好，工资自己开的也很低，能力一般，与其他同事相处有点困难，这让公司的同事对他意见越来越大，后面我来了以后，老板干脆就裁掉了他。他其实也没写多少代码，后面我都重构了。公司的设计也换了一波人，但配合起来还是没有问题。此时，又重拾了C#语言，开发又剩下我一个人了。这段时间渐渐形成了自己的一套页面开发模式，先写静态页面，带上数据请求，待到页面确认后，再改成动态页面。平时周末会兼职做做户外领队，带会员出去徒步旅行，这个还是挺有趣的，就是住宿条件有点差，而且出一身汗后还不能洗澡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）欠薪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　公司旅游的旺季是从9月份开始，其他月份就会没啥收入，这也直接导致现金流断裂。这段时间大概有三四个月没有发工资，非常难熬。这个时候我拼车公司的那个朋友来找我，说他那边缺人，让我过来帮忙。想到这边欠薪，后面就去和老板谈了下，老板当时说：“我把你当兄弟，你把我当老板，没钱就和我说，我给你。”，我蛮无语的，后面协商后，再次答应兼职维护网站。除了欠薪之外，还有一个重要原因是这边没有开发氛围，在这种环境下很难提升技术水平，上一年还有团队协作，今年却变成了单兵作战，有种倒退的感觉。不过业务水平倒是完善了许多，对户外徒步也有了很多了解，每次出去带队，别人还以为我是高手，其实我只是过来凑个人数的而已。&lt;/p&gt;

&lt;p&gt;　　我朋友那边是家创业型的金融公司，搞期权什么的，我到离职的时候都没搞懂这是啥玩意儿。这也是家创业公司，租了一套别墅作为办公地，员工有十几个人，请了个阿姨专门负责烧中饭和晚饭，不过吃饭要自己出钱的，公司不包饭。也是在这段时间，我开始写博客，并且平均每个月能写八九篇。&lt;/p&gt;
&lt;p&gt;　　平时午休的时候，我们一帮人就喜欢在别墅区里逛，都是豪车，隔壁屋子里还养了四条纯种的哈士奇，据说每一条要100W了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）团队配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这次的团队配置与以往不同，有设计、测试、后端和客户端，此处的客户端是用C++开发，针对电脑的，而不是手机。有一个人用C#开发了一套系统，由他来提供各个功能的接口，而我这边就是负责做个网站，管理用户的一些基础信息，而与金融相关的操作只能在客户端中运行。后面听说这套系统的所有权属于这个人，他卖这套系统赚了不少钱，而到这里来也是合作关系，不会把源码提供出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）加班&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　夏天的时候，有一段时间老板想加速开发，就缩短了工期，我住的比较远，没办法就直接住在公司了，大概有三周时间，周末有时候也会加会儿班。在指定时间顺利的完成了任务，不过我做的网站迟迟不上线。我那朋友和我说这块很有前途，老板也一直给大家画饼，把我说的一愣一愣的，但是离职的同事一个接一个，不像说的那么好。后面感觉这个老板不靠谱，而且团队的项目管理也有问题（参考我之前的一篇《&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/strick/p/3946475.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;最&lt;span&gt;近一个项目的反思&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》），就想着离职了。正好有个朋友那边在招人，就联系了我，于是在10月份我就又跳槽了。&lt;/p&gt;

</description>
<pubDate>Wed, 27 Nov 2019 00:10:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>2012年的12月底跳槽到了新公司，新公司在人民广场北京东路那块，也是家小公司。但与前一家公司不同，新公司刚成立，没有稳定的收入来源，一切都是新的，从零开始。今年3月份，我和老同事还回去过一次，看了看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/10544572.html</dc:identifier>
</item>
<item>
<title>五年老Android，我决定转后端开发了！ - 架构文摘</title>
<link>http://www.cnblogs.com/xwgblog/p/11939533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwgblog/p/11939533.html</guid>
<description>&lt;p&gt;今天给大家分享一些移动端（Android）开发学习后端开发（Java Web）的一些事儿，不知道从什么时候开始身边的同事都开始陆陆续续的在朋友圈发一些后端的文章如：Nginx、Docker、k8s类的知识，后来才发现大家都在学习一些后端的开发工作，可能是感觉移动端技术有些腻了了吧，需要有些突破了！&lt;/p&gt;
&lt;p&gt;甚至还有个iOS同事有在业余时间学习Java、Servlet、Spring等后端知识，这让我深有感触我在学校期间也学过Java Web的知识后来因为Android能够做一些界面元素好玩，容易带来成就感，再加上当时的Android真是火到天际。现在如果有人问我为什么要从事移动端开发，我一般都会回答：“误入歧途”，当然这也有些自嘲，开玩笑的成份。&lt;/p&gt;
&lt;p&gt;大概在16年的时候，我就有意无意的在开始自己学习后端知识了，那时候我的工作主要还是做App，偶尔学习下后端知识，可惜的是当时工作的单位后端是用的Python技术栈，由于当时我比较钟情于Java，所有没有学习Python~~。&lt;/p&gt;
&lt;p&gt;到了18年，我入职一家二线互联网公司还是做Android开发工作，当前公司正处于业务高速发展期扩张很快，当然变化也有多。当时就感觉移动端的开发人员在各种技术会议上时很低迷，基本很少发表意见，举个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一开始移动端时间类型使用的是int，后面一哥们改为long，再后来一技术专家要求改为字符串说是：便于后端阅读！这也可以理解关键是移动端还得兼容int、long、字符串型的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;改就改吧又没有做到统一标准，像这样的改动做为移动端开发，完全可以怼回去才是的啊！虽然改起来是小事，但也说明了一个问题：移动端开发话语权真的挺低的，怼又怼不过人家~~。&lt;/p&gt;
&lt;p&gt;再说另外一个故事，我们组来了位移动端技术专家，和我们聊了很久，其中有个问题让印象深刻：移动端为什么很少有架构师这个职业？当时我一听感觉确实是的，很少有公司会招移动端架构师，移动端开发并不像后端开发那样久远，它的发展也是由Android、iOS的出现才兴起的，也没有什么高并发、高可用之类的术语，移动端关注的更多的是界面、用户体验方面的问题。那一天聊了很久，从那一次我得出一个结论：作为移动端开发，很难做到技术大佬级别（相比较后端开发）。毕竟现在的互联网都是是数据、业务为主的，一个经验丰富移动端开发工程师，没写过业务，也没有大数据处理经验想要成为技术Leader、CTO、技术VP太难呢！&lt;/p&gt;
&lt;h3 id=&quot;为什么要学习后端呢&quot;&gt;为什么要学习后端呢？&lt;/h3&gt;
&lt;p&gt;现在大部分公司都是业务驱动型公司，就是业务为主，技术为辅。而且公司的业务都会放在后端，跟Web前端、移动端关系不大，移动端只做数据的收集与展示不会参与复杂业务逻辑流程，所以说：精华其实都在后端。&lt;/p&gt;
&lt;p&gt;举个例子，如果你们公司的App日活达到百万级别，说明App兼容性、适配、用户体验、各项关键指标优化的非常好，而支撑这日活百万的关键性技术还是在后端，所以要不要考虑学习下后端呢~~。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你说你要会点后端知识，再跟后端小哥来个结对编程，那效率高的不要不要的，一个眼神就懂（今晚跟你妈说学Java~~）！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;我是怎么学java后端的&quot;&gt;我是怎么学Java后端的？&lt;/h3&gt;
&lt;p&gt;可能我是比较幸运，在年初时和朋友合作了一个20w的外包项目，我主要负责后端的开发和架构。这个项目对我来说还是挺大的，之前的我都是负责一些App的设计和开发工作这次做后端的开发，多少有点生疏。&lt;/p&gt;
&lt;p&gt;当时搞这个项目，客户是说需要千万级的用户，那时的我也没有千万级的概念，只觉得用微服务应该是可以顶的住，一开始是使用的单服务、单数据库的形式，后面面临分布式问题改为多服务、单数据库的形式还缓了缓这个问题，这也算业界难题当时还考虑过2PC、seate、RabbitMQ那时候没时间、人力就没有继续弄了（好机智~~），后面也陆陆续续的解决了一些碰到的一些问题如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;微服务工程的组织（单服务单仓库 or 多服务单仓库）&lt;/li&gt;
&lt;li&gt;项目工程依赖管理（Maven parent工程）&lt;/li&gt;
&lt;li&gt;Docker本地调试（阿里云vpn）&lt;/li&gt;
&lt;li&gt;Dubbo服务接口仓库（Nexus仓库）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在只能想起来这么多了，实际碰到问题比这个更多！所幸是都一一解决掉了，历时2个月左右这个项目也正常上线了，不过后面也出现过一些问题如：机器cpu负载一直在90%以上，那一天我排查了很久，因为基础设施不全只能通过看日志来排查，最后发现是有在刷任务，一直在频繁访问某个接口，发现问题后就及时学习了限流方面的知识，在网关做了个限流，cpu才稳定下来。&lt;/p&gt;
&lt;p&gt;再有一次是因为技术方案的问题，这个项目有一个无限级的推广，当时选的方案是&lt;strong&gt;嵌套集&lt;/strong&gt;因为他查询起来很快，但是我们忽略了他修改代价实在是太高，导致系统用户到20w的时候推广关系插入变的超级慢，后来就不得不重新选一个方案用的：&lt;strong&gt;闭包表&lt;/strong&gt;插入、查询效率都可以，只是有些费空间。后面花了大概两天的时候才把数据修复过来（一口老血~~）。&lt;/p&gt;
&lt;p&gt;总的来说不会的就学习、问朋友，记忆比较深刻的是一次数据库一直95%以上，学的Java知识较多，对数据库算是了解还不多那时候，找了一天也没找出个问题，最后还是问朋友原来是没加索引查数据都是全表扫描，现在想想真是无语，后来朋友还开玩笑说后续咨询要收费了，哈哈。&lt;/p&gt;
&lt;p&gt;最后回顾下，我学过的一些Java后端知识：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet API&lt;/li&gt;
&lt;li&gt;Spring全家筒
&lt;ul&gt;&lt;li&gt;Spring Framework&lt;/li&gt;
&lt;li&gt;Spring Boot&lt;/li&gt;
&lt;li&gt;Spring Web&lt;/li&gt;
&lt;li&gt;Spring Security&lt;/li&gt;
&lt;li&gt;Spring Data JPA&lt;/li&gt;
&lt;li&gt;Spring Cloud&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;JWT Token&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;li&gt;Mybatis&lt;/li&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不能再多了，实际上好多技术我是学习过，但是没有实际使用过（难受~~）！！&lt;/p&gt;

&lt;p&gt;欢迎关注微信公众号《架构文摘》，精品技术文章第一时间推送。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/19/16e82d0b006032ac?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27413&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Nov 2019 00:07:00 +0000</pubDate>
<dc:creator>架构文摘</dc:creator>
<og:description>今天给大家分享一些移动端（Android）开发学习后端开发（Java Web）的一些事儿，不知道从什么时候开始身边的同事都开始陆陆续续的在朋友圈发一些后端的文章如：Nginx、Docker、k8s类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xwgblog/p/11939533.html</dc:identifier>
</item>
<item>
<title>大话设计，没有模式—通用权限设计与实现 - 李玉宝</title>
<link>http://www.cnblogs.com/yubaolee/p/DataPrivilege.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yubaolee/p/DataPrivilege.html</guid>
<description>&lt;p&gt;&lt;span&gt;当代码写多了，总有些是经验，但经验是什么呢？if…else用的次数比别人多？显然不是。有些超棒的设计可以谓之经验！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;网络上流行的经典的权限设计是【主体】- 【领域】 - 【权限】( who、what、how问题原型 ) 的设计思想，其中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【主体】可以是用户，可以是角色，也可以是一个部门&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【领域】可以是一个模块，可以是一个页面，也可以是页面上的按钮&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【权限】可以是“可见”，可以是“只读”，也可以是“可用”(如按钮可以点击)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了简化程序开发，在&lt;a href=&quot;https://gitee.com/yubaolee/OpenAuth.Core&quot; target=&quot;_blank&quot;&gt;OpenAuth.Core&lt;/a&gt;中去掉了权限的控制，简化为【主体】- 【领域】的模式，且【主体】限定为角色。&lt;span&gt;即只能给角色分配模块和按钮，不能直接分配给用户账号或部门。且一旦分配即表示该角色拥有操作该模块（按钮）的权限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191119225617440-1297104227.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;file-read-61&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191119225617919-670935057.png&quot; alt=&quot;file-read-61&quot; width=&quot;276&quot; height=&quot;344&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大道至简，标准的RBAC规范比这个还要简洁，所以它的生命力才最顽强。在此基础上，如果进行二次开发，进行更详细的功能权限控制，可以按照上面的思想进行改造。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数据权限是在功能权限的基础上面进一步的扩展，比如可以查看订单属于【功能权限】的范围，但是可以查看哪些订单就是【数据权限】的工作了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里面的几个概念：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【资源】：数据权限的控制对象，业务系统中的各种资源。比如订单单据、销售单等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【数据规则】：用于数据权限的条件规则 。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;应用场景&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;销售单，可以由本人查看&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;销售单，测试角色能看到自己的订单&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;销售单，测试角色能看到自己的订单，管理员角色可以看到所有订单&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;销售单，测试角色能看到自己的订单，管理员角色可以看到所有订单，账号test3可以看到应用名称为&quot;xxx管理系统&quot;的订单&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;我们能想到直接的方法，在访问数据的入口加入SQL Where条件来实现，以上4种情况对应的sql语句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; CreateUserID = {loginUser}
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; CreateUserID = {loginUser} &lt;span&gt;and&lt;/span&gt; {loginRole} &lt;span&gt;in&lt;/span&gt; (测试）
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; CreateUserID = ({loginUser} &lt;span&gt;and&lt;/span&gt; {loginRole} &lt;span&gt;in&lt;/span&gt; (测试)) &lt;span&gt;or&lt;/span&gt; {loginRole} &lt;span&gt;in&lt;/span&gt; (管理员)
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; CreateUserID = ({loginUser} &lt;span&gt;and&lt;/span&gt; {loginRole} &lt;span&gt;in&lt;/span&gt; (测试)) &lt;span&gt;or&lt;/span&gt; {loginRole} &lt;span&gt;in&lt;/span&gt; (管理员) &lt;span&gt;or&lt;/span&gt; ({loginUser}==test3 &lt;span&gt;and&lt;/span&gt; 应用名称==XXX管理系统)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这些一个一个的&quot;条件&quot;，简单理解为一个【数据规则】，通常会与原来我们前台的业务过滤条件合并再检索出数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个角色有不一样的【数据规则】，那么数据权限设计就变成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　【资源】 - 【数据规则】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在数据库记录中存放为资源ID+规则的形式，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126223800563-138720379.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191126223141&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126223801108-572329492.jpg&quot; alt=&quot;微信截图_20191126223141&quot; width=&quot;698&quot; height=&quot;134&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了简化程序开发，在开发过程中可以做出以下约定：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;所有需要进行数据权限控制功能的表，在设计时必须包含字段CreateUserId（创建用户Id)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;【资源】的名称限定为模块名称。如部门管理，用户管理，那么资源就是对应的部门列表，用户列表。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果【资源】没有设置数据规则，那么视为该资源允许被任何主体查看。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据规则中授权的对象限定为角色、用户。即不能设定为某个部门所有，如果想实现类似的功能，通过角色间接实现。例如：资源属于角色“开发组成员”，“开发组组长”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;权限控制总离不开一些条件的限制，如果没有完善的查询机制，那么在做权限条件过滤的时候你会觉得很别扭。马丁在&lt;strong&gt;《企业应用架构模式》第13章对象-关系元数据映射模式中提出查询对象模式(Query Object Pattern)&lt;/strong&gt;。该模式核心结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225537377-1591536417.png&quot;&gt;&lt;img title=&quot;下载&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225537871-692713107.png&quot; alt=&quot;下载&quot; width=&quot;532&quot; height=&quot;286&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该结构为【数据规则】的建立提供了理论基础。在设计数据权限的时候，可以照搬该思想。上面例子中的规则，数据规则展开如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; {
&lt;span&gt;  2&lt;/span&gt;        &quot;&lt;span&gt;Operation&lt;/span&gt;&quot;: &quot;&lt;span&gt;or&lt;/span&gt;&quot;,
&lt;span&gt;  3&lt;/span&gt;        &quot;&lt;span&gt;Filters&lt;/span&gt;&quot;: [{
&lt;span&gt;  4&lt;/span&gt;                &quot;&lt;span&gt;Key&lt;/span&gt;&quot;: &quot;&lt;span&gt;{loginRole}&lt;/span&gt;&quot;,
&lt;span&gt;  5&lt;/span&gt;                &quot;&lt;span&gt;Value&lt;/span&gt;&quot;: &quot;&lt;span&gt;09ee2ffa-7463-4938-ae0b-1cb4e80c7c13&lt;/span&gt;&quot;,
&lt;span&gt;  6&lt;/span&gt;                &quot;&lt;span&gt;Contrast&lt;/span&gt;&quot;: &quot;&lt;span&gt;contains&lt;/span&gt;&quot;,
&lt;span&gt;  7&lt;/span&gt;                &quot;&lt;span&gt;Text&lt;/span&gt;&quot;: &quot;&lt;span&gt;管理员&lt;/span&gt;&quot;
&lt;span&gt;  8&lt;/span&gt;        }],
&lt;span&gt;  9&lt;/span&gt;        &quot;&lt;span&gt;Children&lt;/span&gt;&quot;: [{
&lt;span&gt; 10&lt;/span&gt;                &quot;&lt;span&gt;Operation&lt;/span&gt;&quot;: &quot;&lt;span&gt;and&lt;/span&gt;&quot;,
&lt;span&gt; 11&lt;/span&gt;                &quot;&lt;span&gt;Filters&lt;/span&gt;&quot;: [{
&lt;span&gt; 12&lt;/span&gt;                        &quot;&lt;span&gt;Key&lt;/span&gt;&quot;: &quot;&lt;span&gt;{loginRole}&lt;/span&gt;&quot;,
&lt;span&gt; 13&lt;/span&gt;                        &quot;&lt;span&gt;Value&lt;/span&gt;&quot;: &quot;&lt;span&gt;0a7ebd0c-78d6-4fbc-8fbe-6fc25c3a932d&lt;/span&gt;&quot;,
&lt;span&gt; 14&lt;/span&gt;                        &quot;&lt;span&gt;Contrast&lt;/span&gt;&quot;: &quot;&lt;span&gt;contains&lt;/span&gt;&quot;,
&lt;span&gt; 15&lt;/span&gt;                        &quot;&lt;span&gt;Text&lt;/span&gt;&quot;: &quot;&lt;span&gt;测试&lt;/span&gt;&quot;
&lt;span&gt; 16&lt;/span&gt;                }, {
&lt;span&gt; 17&lt;/span&gt;                        &quot;&lt;span&gt;Key&lt;/span&gt;&quot;: &quot;&lt;span&gt;CreateUserId&lt;/span&gt;&quot;,
&lt;span&gt; 18&lt;/span&gt;                        &quot;&lt;span&gt;Value&lt;/span&gt;&quot;: &quot;&lt;span&gt;{loginUser}&lt;/span&gt;&quot;,
&lt;span&gt; 19&lt;/span&gt;                        &quot;&lt;span&gt;Contrast&lt;/span&gt;&quot;: &quot;&lt;span&gt;==&lt;/span&gt;&quot;,
&lt;span&gt; 20&lt;/span&gt;                        &quot;&lt;span&gt;Text&lt;/span&gt;&quot;: &quot;&quot;
&lt;span&gt; 21&lt;/span&gt;                }]
&lt;span&gt; 22&lt;/span&gt;        }, {
&lt;span&gt; 23&lt;/span&gt;                &quot;&lt;span&gt;Operation&lt;/span&gt;&quot;: &quot;&lt;span&gt;and&lt;/span&gt;&quot;,
&lt;span&gt; 24&lt;/span&gt;                &quot;&lt;span&gt;Filters&lt;/span&gt;&quot;: [{
&lt;span&gt; 25&lt;/span&gt;                        &quot;&lt;span&gt;Key&lt;/span&gt;&quot;: &quot;&lt;span&gt;AppName&lt;/span&gt;&quot;,
&lt;span&gt; 26&lt;/span&gt;                        &quot;&lt;span&gt;Value&lt;/span&gt;&quot;: &quot;&lt;span&gt;XXX管理平台&lt;/span&gt;&quot;,
&lt;span&gt; 27&lt;/span&gt;                        &quot;&lt;span&gt;Contrast&lt;/span&gt;&quot;: &quot;&lt;span&gt;==&lt;/span&gt;&quot;,
&lt;span&gt; 28&lt;/span&gt;                        &quot;&lt;span&gt;Text&lt;/span&gt;&quot;: &quot;&quot;
&lt;span&gt; 29&lt;/span&gt;                }, {
&lt;span&gt; 30&lt;/span&gt;                        &quot;&lt;span&gt;Key&lt;/span&gt;&quot;: &quot;&lt;span&gt;{loginUser}&lt;/span&gt;&quot;,
&lt;span&gt; 31&lt;/span&gt;                        &quot;&lt;span&gt;Value&lt;/span&gt;&quot;: &quot;&lt;span&gt;229f3a49-ab27-49ce-b383-9f10ca23a9d5,1df68dfd-3b6d-4491-872f-00a0fc6c5a64&lt;/span&gt;&quot;,
&lt;span&gt; 32&lt;/span&gt;                        &quot;&lt;span&gt;Contrast&lt;/span&gt;&quot;: &quot;&lt;span&gt;in&lt;/span&gt;&quot;,
&lt;span&gt; 33&lt;/span&gt;                        &quot;&lt;span&gt;Text&lt;/span&gt;&quot;: &quot;&lt;span&gt;test3,test4&lt;/span&gt;&quot;
&lt;span&gt; 34&lt;/span&gt;                }]
&lt;span&gt; 35&lt;/span&gt;        }]
&lt;span&gt; 36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;规则分为三个部分：【分组】(Children)、【规则】(Filter)、【操作符】(and or)，而规则自身就是一个分组。这种简单的结构就可以满足全部的情况。看不懂啥意思？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225538344-422936844.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191125234345&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225538840-796951656.jpg&quot; alt=&quot;微信截图_20191125234345&quot; width=&quot;713&quot; height=&quot;465&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样理解起来就比较简单了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191127003922116-775529443.jpg&quot;&gt;&lt;img title=&quot;48ddd81b9850d6b30edb8c2534b6713c&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191127003922556-1888307990.jpg&quot; alt=&quot;48ddd81b9850d6b30edb8c2534b6713c&quot; width=&quot;207&quot; height=&quot;224&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还不懂？？我们从简单的开始：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某一角色只能看到自己创建的信息。如：针对资源列表，我们设置了【测试】角色可以看到自己创建的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225539230-1866619351.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191125231835&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225539633-33525062.jpg&quot; alt=&quot;微信截图_20191125231835&quot; width=&quot;669&quot; height=&quot;234&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时如果用一个拥有测试角色的账号（test）登录，那么他只能看到自己创建的资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225540009-1545457216.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191125232012&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225540456-842213666.jpg&quot; alt=&quot;微信截图_20191125232012&quot; width=&quot;666&quot; height=&quot;343&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他角色的账号登录时，会出现无法看到任何信息。我们稍做调整：【管理员】角色可以看到所有资源，【测试】角色只能看到自己创建的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225540837-345533781.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191125233925&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225541265-440696140.jpg&quot; alt=&quot;微信截图_20191125233925&quot; width=&quot;668&quot; height=&quot;335&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时如果用一个拥有管理员角色的账号（admin）登录，那么他就可以看到全部资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225541660-462090983.jpg&quot;&gt;&lt;img title=&quot;微信截图_20191125233839&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201911/42655-20191126225542121-895968833.jpg&quot; alt=&quot;微信截图_20191125233839&quot; width=&quot;650&quot; height=&quot;448&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以此为基础，我们可以扩展非常复杂的数据权限控制。最终形成最后的复杂规则：【管理员】角色可以看到所有资源，【测试】角色只能看到自己创建的资源。账号test3/test4只能看到应用名称等于“XXX管理平台”的资源。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以在应用层基类BaseApp中，定义一个通用函数，根据当前即将访问的资源Id获取相应的访问【数据规则】，并把当前登录的用户信息注入到该规则中，最终转换成针对数据库的查询，如下：（不想看这个？直接跳过吧，看看如何使用也没有问题）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; GetDataPrivilege(&lt;span&gt;string&lt;/span&gt; parametername)
&lt;span&gt;  2&lt;/span&gt;         {
&lt;span&gt;  3&lt;/span&gt;             var loginUser = _auth.GetCurrentUser();
&lt;span&gt;  4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (loginUser.User.Account == Define.SYSTEM_USERNAME) &lt;span&gt;return&lt;/span&gt; UnitWork.Find&amp;lt;T&amp;gt;(&lt;span&gt;null&lt;/span&gt;);  &lt;span&gt;//超级管理员特权&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt;             var moduleName = &lt;span&gt;typeof&lt;/span&gt;(T).Name;
&lt;span&gt;  7&lt;/span&gt;             var rule = UnitWork.FindSingle&amp;lt;DataPrivilegeRule&amp;gt;(u =&amp;gt; u.SourceCode == moduleName);
&lt;span&gt;  8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (rule == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; UnitWork.Find&amp;lt;T&amp;gt;(&lt;span&gt;null&lt;/span&gt;); &lt;span&gt;//没有设置数据规则，那么视为该资源允许被任何主体查看&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (rule.PrivilegeRules.Contains(Define.DATAPRIVILEGE_LOGINUSER) ||
&lt;span&gt; 10&lt;/span&gt;                                              rule.PrivilegeRules.Contains(Define.DATAPRIVILEGE_LOGINROLE))
&lt;span&gt; 11&lt;/span&gt;             {
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;                 &lt;span&gt;//即把{loginUser} =='xxxxxxx'换为 loginUser.User.Id =='xxxxxxx'，从而把当前登录的用户名与当时设计规则时选定的用户id对比&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;                 rule.PrivilegeRules = rule.PrivilegeRules.Replace(Define.DATAPRIVILEGE_LOGINUSER, loginUser.User.Id);
&lt;span&gt; 15&lt;/span&gt;                 var roles = loginUser.Roles.Select(u =&amp;gt; u.Id).ToList();
&lt;span&gt; 16&lt;/span&gt;                 roles.Sort(); &lt;span&gt;//按字母排序,这样可以进行like操作&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;                 rule.PrivilegeRules = rule.PrivilegeRules.Replace(Define.DATAPRIVILEGE_LOGINROLE,
&lt;span&gt; 18&lt;/span&gt;                     &lt;span&gt;string&lt;/span&gt;.Join(',',roles));
&lt;span&gt; 19&lt;/span&gt;             }
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; UnitWork.Find&amp;lt;T&amp;gt;(&lt;span&gt;null&lt;/span&gt;).GenerateFilter(parametername,
&lt;span&gt; 21&lt;/span&gt;                 JsonHelper.Instance.Deserialize&amp;lt;FilterGroup&amp;gt;(rule.PrivilegeRules));
&lt;span&gt; 22&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样在我们自己的应用中，使用上面的函数创建一个基础查询，再加上自定义的查询条件即可轻松实现数据权限的控制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;             var result = &lt;span&gt;new&lt;/span&gt; TableData();
&lt;span&gt;  2&lt;/span&gt;             var objs = GetDataPrivilege(&quot;&lt;span&gt;u&lt;/span&gt;&quot;);
&lt;span&gt;  3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(request.key))
&lt;span&gt;  4&lt;/span&gt;             {
&lt;span&gt;  5&lt;/span&gt;                 objs = objs.Where(u =&amp;gt; u.Id.Contains(request.key));
&lt;span&gt;  6&lt;/span&gt;             }
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;             result.data = objs.OrderBy(u =&amp;gt; u.Id)
&lt;span&gt;  9&lt;/span&gt;                 .Skip((request.page - 1) * request.limit)
&lt;span&gt; 10&lt;/span&gt;                 .Take(request.limit);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;以上所有代码均已实现并开源（配置数据规则的界面可以自己画，layui的前端画起来实在太费力），&lt;/span&gt;&lt;a href=&quot;https://gitee.com/yubaolee/OpenAuth.Core&quot; target=&quot;_blank&quot;&gt;OpenAuth.Core&lt;/a&gt;&lt;span&gt;秉承代码之美，为.net core添砖加瓦，喜欢的star一下！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Nov 2019 23:42:00 +0000</pubDate>
<dc:creator>李玉宝</dc:creator>
<og:description>当代码写多了，总有些是经验，但经验是什么呢？if…else用的次数比别人多？显然不是。有些超棒的设计可以谓之经验！网络上流行的经典的权限设计是【主体】- 【领域】 - 【权限】( who、what、h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yubaolee/p/DataPrivilege.html</dc:identifier>
</item>
<item>
<title>SpringSecurity动态加载用户角色权限实现登录及鉴权 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11939522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11939522.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191127073923116-967508215.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很多人觉得Spring Security实现登录验证很难，我最开始学习的时候也这样觉得。因为我好久都没看懂我该怎么样将自己写的用于接收用户名密码的Controller与Spring Security结合使用，这是一个先入为主的误区。后来我搞懂了：根本不用你自己去写Controller。你只需要告诉Spring Security用户信息、角色信息、权限信息、登录页是什么？登陆成功页是什么？或者其他有关登录的一切信息。具体的登录验证逻辑它来帮你实现。&lt;/p&gt;
&lt;h2 id=&quot;一动态数据登录验证的基础知识&quot;&gt;一、动态数据登录验证的基础知识&lt;/h2&gt;
&lt;p&gt;在本号之前的文章中，已经介绍了Spring Security的formLogin登录认证模式，RBAC的权限控制管理模型，并且针对Spring Security的登录认证逻辑源码进行了解析等等。我们所有的用户、角色、权限信息都是在配置文件里面写死的，然而在实际的业务系统中，这些信息通常是存放在RBAC权限模型的数据库表中的。下面我们来回顾一下其中的核心概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RBAC的权限模型可以从用户获取为用户分配的一个或多个角色，从用户的角色又可以获取该角色的多种权限。通过关联查询可以获取某个用户的角色信息和权限信息。&lt;/li&gt;
&lt;li&gt;在源码解析的文章中，我们知道如果我们不希望用户、角色、权限信息写死在配置里面。我们应该实现UserDetails与UserDetailsService接口，从而从数据库或者其他的存储上动态的加载这些信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上是对一些核心的基础知识的总结，如果您对这些知识还不是很清晰，建议您先往下读本文。如果看完本文仍然理解困难，建议您翻看本号之前的文章。&lt;/p&gt;
&lt;h2 id=&quot;二userdetails与userdetailsservice接口&quot;&gt;二、UserDetails与UserDetailsService接口&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;UserDetailsService接口有一个方法叫做loadUserByUsername，我们实现动态加载用户、角色、权限信息就是通过实现该方法。函数见名知义：通过用户名加载用户。该方法的返回值就是UserDetails。&lt;/li&gt;
&lt;li&gt;UserDetails就是用户信息，即：用户名、密码、该用户所具有的权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来看一下UserDetails接口都有哪些方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserDetails extends Serializable {
    //获取用户的权限集合
    Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities();

    //获取密码
    String getPassword();

    //获取用户名
    String getUsername();

    //账号是否没过期
    boolean isAccountNonExpired();

    //账号是否没被锁定
    boolean isAccountNonLocked();

    //密码是否没过期
    boolean isCredentialsNonExpired();

    //账户是否可用
    boolean isEnabled();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们明白了，只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。&lt;/p&gt;
&lt;h2 id=&quot;三实现userdetails-接口&quot;&gt;三、实现UserDetails 接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class SysUser implements UserDetails{
    
    String password();  //密码
    String username();  //用户名
    boolean accountNonExpired;   //是否没过期
    boolean accountNonLocked;   //是否没被锁定
    boolean credentialsNonExpired;  //是否没过期
    boolean enabled;  //账号是否可用
    Collection&amp;lt;? extends GrantedAuthority&amp;gt; authorities;  //用户的权限集合

    //省略构造方法
    //省略set方法
    //省略get方法（即接口UserDetails的方法）
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们就是写了一个适应于UserDetails的java POJO类，所谓的 UserDetails接口实现就是一些get方法。get方法由Spring Security调用，我们通过set方法或构造函数为 Spring Security提供UserDetails数据。&lt;/p&gt;
&lt;h2 id=&quot;四实现userdetailsservice接口&quot;&gt;四、实现UserDetailsService接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyUserDetailsService implements UserDetailsService{

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            
       //这里从数据库sys_user表里面查询实体类对象。loadUser方法可使用Mybatis或JDBC或JPA自行实现。
       SysUser sysUser =  loadUser(username);   

        // 判断用户是否存在 
       if(user == null)  {  throw  new  UsernameNotFoundException(&quot;用户名不存在&quot;);  }

       //从数据库该用户所有的角色信息，所有的权限标志
       //遍历所有的ROLE角色及所有的Authority权限（菜单、按钮）。
       //用逗号分隔他们的唯一标志，具体过程自行实现。
       sysUser.setAuthorities(
               AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ROLE_AMIN , system:user:delete&quot;));
        
        //sysUser.setAccountNonLocked(true或false);
        return sysUser;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通常数据库表sys_user字段要和SysUser属性一一对应，比如username、password、enabled。但是比如accountNonLocked字段用于登录多次错误锁定，但我们一般不会在表里存是否锁定，而是存一个锁定时间字段。通过锁定时间是否大于当前时间判断账号是否锁定，所以实现过程中可以灵活做判断并用好set方法，不必拘泥于一一对应的形式。&lt;/li&gt;
&lt;li&gt;角色是一种特殊的权限，在Spring Security我们可以使用hasRole(角色标识)表达式判断用户是否具有某个角色，决定他是否可以做某个操作;通过hasAuthority(权限标识)表达式判断是否具有某个操作权限。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五最后说明&quot;&gt;五、最后说明&lt;/h2&gt;
&lt;p&gt;至此，我们将系统里面的所有的用户、角色、权限信息都通过UserDetailsService和UserDetails告知了Spring Security。但是多数朋友可能仍然不知道该怎样实现登录的功能，其实剩下的事情很简单了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写一个登录界面，写一个登录表单，表单使用post方法提交到默认的/login路径&lt;/li&gt;
&lt;li&gt;表单的用户名、密码字段名称默认是username、password。&lt;/li&gt;
&lt;li&gt;写一个登录成功之后的跳转页面，比如index.html&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后把这些信息通过配置方式告知Spring Security ，以上的配置信息名称都可以灵活修改。如果您不知道如何配置请参考本号之前的文章《formLogin登录认证模式》。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Tue, 26 Nov 2019 23:39:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>很多人觉得Spring Security实现登录验证很难，我最开始学习的时候也这样觉得。因为我好久都没看懂我该怎么样将自己写的用于接收用户名密码的Controller与Spring Security结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11939522.html</dc:identifier>
</item>
<item>
<title>带你涨姿势的认识一下 Kafka 消费者 - cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/11939490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/11939490.html</guid>
<description>&lt;p&gt;之前我们介绍过了 Kafka 整体架构，Kafka 生产者，Kafka 生产的消息最终流向哪里呢？当然是需要消费了，要不只产生一系列数据没有任何作用啊，如果把 Kafka 比作餐厅的话，那么生产者就是厨师的角色，消费者就是客人，只有厨师的话，那么炒出来的菜没有人吃也没有意义，如果只有客人没有厨师的话，谁会去这个店吃饭呢？！所以如果你看完前面的文章意犹未尽的话，可以继续让你爽一爽。如果你没看过前面的文章，那就从现在开始让你爽。&lt;/p&gt;
&lt;h2 id=&quot;kafka-消费者概念&quot;&gt;Kafka 消费者概念&lt;/h2&gt;
&lt;p&gt;应用程序使用 &lt;code&gt;KafkaConsumer&lt;/code&gt; 从 Kafka 中订阅主题并接收来自这些主题的消息，然后再把他们保存起来。应用程序首先需要创建一个 KafkaConsumer 对象，订阅主题并开始接受消息，验证消息并保存结果。一段时间后，生产者往主题写入的速度超过了应用程序验证数据的速度，这时候该如何处理？如果只使用单个消费者的话，应用程序会跟不上消息生成的速度，就像多个生产者像相同的主题写入消息一样，这时候就需要多个消费者共同参与消费主题中的消息，对消息进行分流处理。&lt;/p&gt;
&lt;p&gt;Kafka 消费者从属于&lt;code&gt;消费者群组&lt;/code&gt;。一个群组中的消费者订阅的都是&lt;code&gt;相同&lt;/code&gt;的主题，每个消费者接收主题一部分分区的消息。下面是一个 Kafka 分区消费示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065218309-1586911486.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的主题 T1 有四个分区，分别是分区0、分区1、分区2、分区3，我们创建一个消费者群组1，消费者群组中只有一个消费者，它订阅主题T1，接收到 T1 中的全部消息。由于一个消费者处理四个生产者发送到分区的消息，压力有些大，需要帮手来帮忙分担任务，于是就演变为下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065227017-998966175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，消费者的消费能力就大大提高了，但是在某些环境下比如用户产生消息特别多的时候，生产者产生的消息仍旧让消费者吃不消，那就继续增加消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065235656-542899910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，每个分区所产生的消息能够被每个消费者群组中的消费者消费，如果向消费者群组中增加更多的消费者，那么多余的消费者将会闲置，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065243485-733509114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;向群组中增加消费者是横向伸缩消费能力的主要方式。总而言之，我们可以通过增加消费组的消费者来进行&lt;code&gt;水平扩展提升消费能力&lt;/code&gt;。这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。&lt;/p&gt;
&lt;p&gt;Kafka 一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。换句话说，每个应用都可以读到全量的消息。为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组 G2，而这个消费组有两个消费者，那么就演变为下图这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065254409-1360395476.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个场景中，消费组 G1 和消费组 G2 都能收到 T1 主题的全量消息，在逻辑意义上来说它们属于不同的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结起来就是如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;消费者组和分区重平衡&quot;&gt;消费者组和分区重平衡&lt;/h2&gt;
&lt;h3 id=&quot;消费者组是什么&quot;&gt;消费者组是什么&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;消费者组（Consumer Group）&lt;/code&gt;是由一个或多个消费者实例（Consumer Instance）组成的群组，具有可扩展性和可容错性的一种机制。消费者组内的消费者&lt;code&gt;共享&lt;/code&gt;一个消费者组ID，这个ID 也叫做 &lt;code&gt;Group ID&lt;/code&gt;，组内的消费者共同对一个主题进行订阅和消费，同一个组中的消费者只能消费一个分区的消息，多余的消费者会闲置，派不上用场。&lt;/p&gt;
&lt;p&gt;我们在上面提到了两种消费方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个消费者群组消费一个主题中的消息，这种消费模式又称为&lt;code&gt;点对点&lt;/code&gt;的消费方式，点对点的消费方式又被称为消息队列&lt;/li&gt;
&lt;li&gt;一个主题中的消息被多个消费者群组共同消费，这种消费模式又称为&lt;code&gt;发布-订阅&lt;/code&gt;模式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消费者重平衡&quot;&gt;消费者重平衡&lt;/h3&gt;
&lt;p&gt;我们从上面的&lt;code&gt;消费者演变图&lt;/code&gt;中可以知道这么一个过程：最初是一个消费者订阅一个主题并消费其全部分区的消息，后来有一个消费者加入群组，随后又有更多的消费者加入群组，而新加入的消费者实例&lt;code&gt;分摊&lt;/code&gt;了最初消费者的部分消息，这种把分区的所有权通过一个消费者转到其他消费者的行为称为&lt;code&gt;重平衡&lt;/code&gt;，英文名也叫做 &lt;code&gt;Rebalance&lt;/code&gt; 。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065533626-702226493.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重平衡非常重要，它为消费者群组带来了&lt;code&gt;高可用性&lt;/code&gt; 和 &lt;code&gt;伸缩性&lt;/code&gt;，我们可以放心的添加消费者或移除消费者，不过在正常情况下我们并不希望发生这样的行为。在重平衡期间，消费者无法读取消息，造成整个消费者组在重平衡的期间都不可用。另外，当分区被重新分配给另一个消费者时，消息当前的读取状态会丢失，它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢应用程序。&lt;/p&gt;
&lt;p&gt;消费者通过向&lt;code&gt;组织协调者&lt;/code&gt;（Kafka Broker）发送心跳来维护自己是消费者组的一员并确认其拥有的分区。对于不同不的消费群体来说，其组织协调者可以是不同的。只要消费者定期发送心跳，就会认为消费者是存活的并处理其分区中的消息。当消费者检索记录或者提交它所消费的记录时就会发送心跳。&lt;/p&gt;
&lt;p&gt;如果过了一段时间 Kafka 停止发送心跳了，会话（Session）就会过期，组织协调者就会认为这个 Consumer 已经死亡，就会触发一次重平衡。如果消费者宕机并且停止发送消息，组织协调者会等待几秒钟，确认它死亡了才会触发重平衡。在这段时间里，&lt;strong&gt;死亡的消费者将不处理任何消息&lt;/strong&gt;。在清理消费者时，消费者将通知协调者它要离开群组，组织协调者会触发一次重平衡，尽量降低处理停顿。&lt;/p&gt;
&lt;p&gt;重平衡是一把双刃剑，它为消费者群组带来高可用性和伸缩性的同时，还有有一些明显的缺点(bug)，而这些 bug 到现在社区还无法修改。&lt;/p&gt;
&lt;p&gt;重平衡的过程对消费者组有极大的影响。因为每次重平衡过程中都会导致万物静止，参考 JVM 中的垃圾回收机制，也就是 Stop The World ，STW，(引用自《深入理解 Java 虚拟机》中 p76 关于 Serial 收集器的描述)：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程。直到它收集结束。&lt;code&gt;Stop The World&lt;/code&gt; 这个名字听起来很帅，但这项工作实际上是由虚拟机在后台自动发起并完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，在重平衡期间，消费者组中的消费者实例都会停止消费，等待重平衡的完成。而且重平衡这个过程很慢......&lt;/p&gt;
&lt;h2 id=&quot;创建消费者&quot;&gt;创建消费者&lt;/h2&gt;
&lt;p&gt;上面的理论说的有点多，下面就通过代码来讲解一下消费者是如何消费的&lt;/p&gt;
&lt;p&gt;在读取消息之前，需要先创建一个 &lt;code&gt;KafkaConsumer&lt;/code&gt; 对象。创建 KafkaConsumer 对象与创建 KafkaProducer 对象十分相似 --- 把需要传递给消费者的属性放在 &lt;code&gt;properties&lt;/code&gt; 对象中，后面我们会着重讨论 Kafka 的一些配置，这里我们先简单的创建一下，使用3个属性就足矣，分别是 &lt;code&gt;bootstrap.server&lt;/code&gt;，&lt;code&gt;key.deserializer&lt;/code&gt;，&lt;code&gt;value.deserializer&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这三个属性我们已经用过很多次了，如果你还不是很清楚的话，可以参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/Br0_DQ854n-Is0W88DbPOg&quot;&gt;带你涨姿势是认识一下Kafka Producer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一个属性是 &lt;code&gt;group.id&lt;/code&gt; 这个属性不是必须的，它指定了 KafkaConsumer 是属于哪个消费者群组。创建不属于任何一个群组的消费者也是可以的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Properties properties = new Properties();
        properties.put(&quot;bootstrap.server&quot;,&quot;192.168.1.9:9092&quot;);     properties.put(&quot;key.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);   properties.put(&quot;value.serializer&quot;,&quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
KafkaConsumer&amp;lt;String,String&amp;gt; consumer = new KafkaConsumer&amp;lt;&amp;gt;(properties);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主题订阅&quot;&gt;主题订阅&lt;/h3&gt;
&lt;p&gt;创建好消费者之后，下一步就开始订阅主题了。&lt;code&gt;subscribe()&lt;/code&gt; 方法接受一个主题列表作为参数，使用起来比较简单&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;consumer.subscribe(Collections.singletonList(&quot;customerTopic&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简单我们只订阅了一个主题 &lt;code&gt;customerTopic&lt;/code&gt;，参数传入的是一个正则表达式，正则表达式可以匹配多个主题，如果有人创建了新的主题，并且主题的名字与正则表达式相匹配，那么会立即触发一次重平衡，消费者就可以读取新的主题。&lt;/p&gt;
&lt;p&gt;要订阅所有与 test 相关的主题，可以这样做&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;consumer.subscribe(&quot;test.*&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;轮询&quot;&gt;轮询&lt;/h3&gt;
&lt;p&gt;我们知道，Kafka 是支持订阅/发布模式的，生产者发送数据给 Kafka Broker，那么消费者是如何知道生产者发送了数据呢？其实生产者产生的数据消费者是不知道的，KafkaConsumer 采用轮询的方式定期去 Kafka Broker 中进行数据的检索，如果有数据就用来消费，如果没有就再继续轮询等待，下面是轮询等待的具体实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
  while (true) {
    ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(Duration.ofSeconds(100));
    for (ConsumerRecord&amp;lt;String, String&amp;gt; record : records) {
      int updateCount = 1;
      if (map.containsKey(record.value())) {
        updateCount = (int) map.get(record.value() + 1);
      }
      map.put(record.value(), updateCount);
    }
  }
}finally {
  consumer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这是一个无限循环。消费者实际上是一个长期运行的应用程序，它通过轮询的方式向 Kafka 请求数据。&lt;/li&gt;
&lt;li&gt;第三行代码非常重要，Kafka 必须定期循环请求数据，否则就会认为该 Consumer 已经挂了，会触发重平衡，它的分区会移交给群组中的其它消费者。传给 &lt;code&gt;poll()&lt;/code&gt; 方法的是一个超市时间，用 &lt;code&gt;java.time.Duration&lt;/code&gt; 类来表示，如果该参数被设置为 0 ，poll() 方法会立刻返回，否则就会在指定的毫秒数内一直等待 broker 返回数据。&lt;/li&gt;
&lt;li&gt;poll() 方法会返回一个记录列表。每条记录都包含了记录所属主题的信息，记录所在分区的信息、记录在分区中的偏移量，以及记录的键值对。我们一般会遍历这个列表，逐条处理每条记录。&lt;/li&gt;
&lt;li&gt;在退出应用程序之前使用 &lt;code&gt;close()&lt;/code&gt; 方法关闭消费者。网络连接和 socket 也会随之关闭，并立即触发一次重平衡，而不是等待群组协调器发现它不再发送心跳并认定它已经死亡。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在同一个群组中，我们无法让一个线程运行多个消费者，也无法让多个线程安全的共享一个消费者。按照规则，一个消费者使用一个线程，如果一个消费者群组中多个消费者都想要运行的话，那么必须让每个消费者在自己的线程中运行，可以使用 Java 中的 &lt;code&gt;ExecutorService&lt;/code&gt; 启动多个消费者进行进行处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;消费者配置&quot;&gt;消费者配置&lt;/h2&gt;
&lt;p&gt;到目前为止，我们学习了如何使用消费者 API，不过只介绍了几个最基本的属性，Kafka 文档列出了所有与消费者相关的配置说明。大部分参数都有合理的默认值，一般不需要修改它们，下面我们就来介绍一下这些参数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fetch.min.bytes&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该属性指定了消费者从服务器获取记录的最小字节数。broker 在收到消费者的数据请求时，如果可用的数据量小于 &lt;code&gt;fetch.min.bytes&lt;/code&gt; 指定的大小，那么它会等到有足够的可用数据时才把它返回给消费者。这样可以降低消费者和 broker 的工作负载，因为它们在主题使用频率不是很高的时候就不用来回处理消息。如果没有很多可用数据，但消费者的 CPU 使用率很高，那么就需要把该属性的值设得比默认值大。如果消费者的数量比较多，把该属性的值调大可以降低 broker 的工作负载。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fetch.max.wait.ms&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过上面的 &lt;strong&gt;fetch.min.bytes&lt;/strong&gt; 告诉 Kafka，等到有足够的数据时才会把它返回给消费者。而 &lt;strong&gt;fetch.max.wait.ms&lt;/strong&gt; 则用于指定 broker 的等待时间，默认是 500 毫秒。如果没有足够的数据流入 kafka 的话，消费者获取的最小数据量要求就得不到满足，最终导致 500 毫秒的延迟。如果要降低潜在的延迟，就可以把参数值设置的小一些。如果 fetch.max.wait.ms 被设置为 100 毫秒的延迟，而 fetch.min.bytes 的值设置为 1MB，那么 Kafka 在收到消费者请求后，要么返回 1MB 的数据，要么在 100 ms 后返回所有可用的数据。就看哪个条件首先被满足。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;max.partition.fetch.bytes&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该属性指定了服务器从每个分区里返回给消费者的&lt;code&gt;最大字节数&lt;/code&gt;。它的默认值时 1MB，也就是说，&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt; 方法从每个分区里返回的记录最多不超过 max.partition.fetch.bytes 指定的字节。如果一个主题有20个分区和5个消费者，那么每个消费者需要&lt;code&gt;至少&lt;/code&gt;4 MB的可用内存来接收记录。在为消费者分配内存时，可以给它们多分配一些，因为如果群组里有消费者发生崩溃，剩下的消费者需要处理更多的分区。max.partition.fetch.bytes 的值必须比 broker 能够接收的最大消息的字节数(通过 max.message.size 属性配置大)，&lt;strong&gt;否则消费者可能无法读取这些消息，导致消费者一直挂起重试&lt;/strong&gt;。 在设置该属性时，另外一个考量的因素是消费者处理数据的时间。消费者需要频繁的调用 poll() 方法来避免会话过期和发生分区再平衡，如果单次调用poll() 返回的数据太多，消费者需要更多的时间进行处理，可能无法及时进行下一个轮询来避免会话过期。如果出现这种情况，可以把 max.partition.fetch.bytes 值改小，或者延长会话过期时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session.timeout.ms&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个属性指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s。如果消费者没有在 &lt;strong&gt;session.timeout.ms&lt;/strong&gt; 指定的时间内发送心跳给群组协调器，就会被认定为死亡，协调器就会触发重平衡。把它的分区分配给消费者群组中的其它消费者，此属性与 &lt;code&gt;heartbeat.interval.ms&lt;/code&gt; 紧密相关。heartbeat.interval.ms 指定了 poll() 方法向群组协调器发送心跳的频率，session.timeout.ms 则指定了消费者可以多久不发送心跳。所以，这两个属性一般需要同时修改，heartbeat.interval.ms 必须比 session.timeout.ms 小，一般是 session.timeout.ms 的三分之一。如果 session.timeout.ms 是 3s，那么 heartbeat.interval.ms 应该是 1s。把 session.timeout.ms 值设置的比默认值小，可以更快地检测和恢复崩愤的节点，不过长时间的轮询或垃圾收集可能导致非预期的重平衡。把该属性的值设置得大一些，可以减少意外的重平衡，不过检测节点崩溃需要更长的时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auto.offset.reset&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下的该如何处理。它的默认值是 &lt;code&gt;latest&lt;/code&gt;，意思指的是，在偏移量无效的情况下，消费者将从最新的记录开始读取数据。另一个值是 &lt;code&gt;earliest&lt;/code&gt;，意思指的是在偏移量无效的情况下，消费者将从起始位置处开始读取分区的记录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;enable.auto.commit&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们稍后将介绍几种不同的提交偏移量的方式。该属性指定了消费者是否自动提交偏移量，默认值是 true，为了尽量避免出现重复数据和数据丢失，可以把它设置为 false，由自己控制何时提交偏移量。如果把它设置为 true，还可以通过 &lt;strong&gt;auto.commit.interval.ms&lt;/strong&gt; 属性来控制提交的频率&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;partition.assignment.strategy&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们知道，分区会分配给群组中的消费者。&lt;code&gt;PartitionAssignor&lt;/code&gt; 会根据给定的消费者和主题，决定哪些分区应该被分配给哪个消费者，Kafka 有两个默认的分配策略&lt;code&gt;Range&lt;/code&gt; 和 &lt;code&gt;RoundRobin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该属性可以是任意字符串，broker 用他来标识从客户端发送过来的消息，通常被用在日志、度量指标和配额中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;max.poll.records&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该属性用于控制单次调用 call() 方法能够返回的记录数量，可以帮你控制在轮询中需要处理的数据量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;receive.buffer.bytes 和 send.buffer.bytes&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;socket 在读写数据时用到的 TCP 缓冲区也可以设置大小。如果它们被设置为 -1，就使用操作系统默认值。如果生产者或消费者与 broker 处于不同的数据中心内，可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。&lt;/p&gt;
&lt;h2 id=&quot;提交和偏移量的概念&quot;&gt;提交和偏移量的概念&lt;/h2&gt;
&lt;h3 id=&quot;特殊偏移&quot;&gt;特殊偏移&lt;/h3&gt;
&lt;p&gt;我们上面提到，消费者在每次调用&lt;code&gt;poll()&lt;/code&gt; 方法进行定时轮询的时候，会返回由生产者写入 Kafka 但是还没有被消费者消费的记录，因此我们可以追踪到哪些记录是被群组里的哪个消费者读取的。消费者可以使用 Kafka 来追踪消息在分区中的位置（偏移量）&lt;/p&gt;
&lt;p&gt;消费者会向一个叫做 &lt;code&gt;_consumer_offset&lt;/code&gt; 的特殊主题中发送消息，这个主题会保存每次所发送消息中的分区偏移量，这个主题的主要作用就是消费者触发重平衡后记录偏移使用的，消费者每次向这个主题发送消息，正常情况下不触发重平衡，这个主题是不起作用的，当触发重平衡后，消费者停止工作，每个消费者可能会分到对应的分区，这个主题就是让消费者能够继续处理消息所设置的。&lt;/p&gt;
&lt;p&gt;如果提交的偏移量小于客户端最后一次处理的偏移量，那么位于两个偏移量之间的消息就会被重复处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065351702-1264936069.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果提交的偏移量大于最后一次消费时的偏移量，那么处于两个偏移量中间的消息将会丢失&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065401872-1749460884.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然&lt;code&gt;_consumer_offset&lt;/code&gt; 如此重要，那么它的提交方式是怎样的呢？下面我们就来说一下&lt;/p&gt;
&lt;h3 id=&quot;提交方式&quot;&gt;提交方式&lt;/h3&gt;
&lt;p&gt;KafkaConsumer API 提供了多种方式来提交偏移量&lt;/p&gt;
&lt;h3 id=&quot;自动提交&quot;&gt;自动提交&lt;/h3&gt;
&lt;p&gt;最简单的方式就是让消费者自动提交偏移量。如果 &lt;code&gt;enable.auto.commit&lt;/code&gt; 被设置为true，那么每过 5s，消费者会自动把从 poll() 方法轮询到的最大偏移量提交上去。提交时间间隔由 &lt;code&gt;auto.commit.interval.ms&lt;/code&gt; 控制，默认是 5s。与消费者里的其他东西一样，自动提交也是在轮询中进行的。消费者在每次轮询中会检查是否提交该偏移量了，如果是，那么就会提交从上一次轮询中返回的偏移量。&lt;/p&gt;
&lt;h3 id=&quot;提交当前偏移量&quot;&gt;提交当前偏移量&lt;/h3&gt;
&lt;p&gt;把 &lt;code&gt;auto.commit.offset&lt;/code&gt; 设置为 false，可以让应用程序决定何时提交偏移量。使用 &lt;code&gt;commitSync()&lt;/code&gt; 提交偏移量。这个 API 会提交由 poll() 方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。&lt;/p&gt;
&lt;p&gt;commitSync() 将会提交由 poll() 返回的最新偏移量，如果处理完所有记录后要确保调用了 commitSync()，否则还是会有丢失消息的风险，如果发生了在均衡，从最近一批消息到发生在均衡之间的所有消息都将被重复处理。&lt;/p&gt;
&lt;h3 id=&quot;异步提交&quot;&gt;异步提交&lt;/h3&gt;
&lt;p&gt;异步提交 &lt;code&gt;commitAsync()&lt;/code&gt; 与同步提交 &lt;code&gt;commitSync()&lt;/code&gt; 最大的区别在于异步提交不会进行重试，同步提交会一致进行重试。&lt;/p&gt;
&lt;h3 id=&quot;同步和异步组合提交&quot;&gt;同步和异步组合提交&lt;/h3&gt;
&lt;p&gt;一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大的问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但是如果在关闭消费者或再均衡前的最后一次提交，就要确保提交成功。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;在消费者关闭之前一般会组合使用commitAsync和commitSync提交偏移量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;提交特定的偏移量&quot;&gt;提交特定的偏移量&lt;/h3&gt;
&lt;p&gt;消费者API允许调用 commitSync() 和 commitAsync() 方法时传入希望提交的 partition 和 offset 的 map，即提交特定的偏移量。&lt;/p&gt;
&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/14/kafka-consumer.html&quot;&gt;Kafka 消费者解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oreilly.com/library/view/kafka-the-definitive/9781491936153/ch04.html&quot;&gt;《Kafka-the-definitive》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《极客时间-Kafka核心技术与实战》&lt;/p&gt;
&lt;p&gt;《Kafka 权威指南》&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.confluent.io/current/clients/consumer.html&quot; class=&quot;uri&quot;&gt;https://docs.confluent.io/current/clients/consumer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html&quot; class=&quot;uri&quot;&gt;https://kafka.apache.org/23/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号获取更多优质电子书，关注一下你就知道资源是有多好了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201911/1515111-20191127065451417-1785146967.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Nov 2019 22:56:00 +0000</pubDate>
<dc:creator>cxuan</dc:creator>
<og:description>之前我们介绍过了 Kafka 整体架构，Kafka 生产者，Kafka 生产的消息最终流向哪里呢？当然是需要消费了，要不只产生一系列数据没有任何作用啊，如果把 Kafka 比作餐厅的话，那么生产者就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/11939490.html</dc:identifier>
</item>
<item>
<title>[UWP]用Win2D和CompositionAPI实现文字的发光效果，并制作动画 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/using_win2d_and_composition_API_to_implement_the_glow_effect_of_text_and_make_animation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/using_win2d_and_composition_API_to_implement_the_glow_effect_of_text_and_make_animation.html</guid>
<description>&lt;h2 id=&quot;成果&quot;&gt;1. 成果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200311469-1675549409.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;献祭了周末的晚上，成功召唤出了上面的番茄钟。正当我在感慨“不愧是Shadow大人，这难道就是传说中的五彩斑斓的黑？”&lt;/p&gt;
&lt;p&gt;“那才不是什么阴影效果，那是发光效果。”被路过的老婆吐槽了。&lt;/p&gt;
&lt;p&gt;系系系，老婆说的都系对的。我还以为我在做阴影动画，现在只好改博客标题了？&lt;/p&gt;
&lt;p&gt;要实现上面的动画效果，首先使用CompositionDrawingSurface，在它上面用DrawTextLayout画出文字，然后用GaussianBlurEffect模仿成阴影，然后用CanvasActiveLayer裁剪文字的轮廓，然后用这个CompositionDrawingSurface创建出CompositionSurfaceBrush，然后创建一个CompositionMaskBrush，将CompositionSurfaceBrush作为它的Mask，然后用CompositionLinearGradientBrush创建出渐变，再用BlendEffect将它变成四向渐变，再用ColorKeyFrameAnimation和ScalarKeyFrameAnimation在它上面做动画并把它作为CompositionMaskBrush的Source，然后创建SpriteVisual将CompositionMaskBrush应用上去，然后使用两个PointLight分别从左到右和从右到左照射这个SpriteVisual，再创建一个AmbientLight模仿呼吸灯。&lt;/p&gt;
&lt;p&gt;仔细想想……好吧，老婆说得对，我还真的没有用到任何Shadow的Api，这里和Shadow大人半毛钱关系都没有。&lt;/p&gt;
&lt;p&gt;这个番茄钟源码可以在这里查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DinoChan/OnePomodoro/blob/master/OnePomodoro/OnePomodoro/PomodoroViews/ShadowTextView.xaml&quot;&gt;OnePomodoro_ShadowTextView.xaml at master&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以安装我的番茄钟应用试玩一下，安装地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/zh-cn/p/onepomodoro/9nxpdp9gg880?activetab=pivot:overviewtab&quot;&gt;一个番茄钟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章将介绍其中几个关键技术。&lt;/p&gt;
&lt;h2 id=&quot;使用gaussianblureffect模仿阴影&quot;&gt;2. 使用GaussianBlurEffect模仿阴影&lt;/h2&gt;
&lt;p&gt;上一篇文章已经介绍过怎么在&lt;code&gt;CompositionDrawingSurface&lt;/code&gt;上写字，这里就不再重复。为了可以为文字添加阴影，需要用到&lt;code&gt;CanvasRenderTarget&lt;/code&gt;和&lt;code&gt;GaussianBlurEffect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;CanvasRenderTarget是一个可以用来画图的渲染目标。实现文字阴影的步骤如下：将文字画到CanvasRenderTarget，然后用它作为GaussianBlurEffect.Source产生一张高斯模糊的图片，这样看上去就和文字的阴影一样。然后再在这张模糊的图片的前面画上原本的文字。&lt;/p&gt;
&lt;p&gt;代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;using (var session = CanvasComposition.CreateDrawingSession(drawingSurface))
{
    session.Clear(Colors.Transparent);
    using (var textLayout = new CanvasTextLayout(session, Text, textFormat, width, height))
    {
        var bitmap = new CanvasRenderTarget(session, width, height);
        using (var bitmapSession = bitmap.CreateDrawingSession())
        {
            bitmapSession.DrawTextLayout(textLayout, 0, 0, FontColor);
        }
        var blur = new GaussianBlurEffect
        {
            BlurAmount = (float)BlurAmount,
            Source = bitmap,
            BorderMode = EffectBorderMode.Hard
        };

        session.DrawImage(blur, 0, 0);
        session.DrawTextLayout(textLayout, 0, 0, FontColor);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下（因为我用了白色字体，这时候已经不怎么像阴影了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200327837-1565709277.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.3207547169811&quot;&gt;
&lt;p&gt;关于CavasRenderTaget，死鱼的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37128817&quot;&gt;这篇文章&lt;/a&gt;有详细介绍。他的这个专栏的文章都很有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用canvasactivelayer裁剪文字&quot;&gt;3. 使用CanvasActiveLayer裁剪文字&lt;/h2&gt;
&lt;p&gt;关于裁剪文字，有几件事需要做。&lt;/p&gt;
&lt;p&gt;首先获取需要裁剪的文字的轮廓，这使用上一篇文章介绍过的&lt;code&gt;CanvasGeometry.CreateText&lt;/code&gt;就可以了，这个函数的返回值是一个&lt;a href=&quot;http://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_Geometry_CanvasGeometry.htm&quot;&gt;CanvasGeometry&lt;/a&gt;。然后使用&lt;code&gt;CanvasGeometry.CreateRectangle&lt;/code&gt;获取整个画布的CanvasGeometry，将他们用&lt;a href=&quot;http://microsoft.github.io/Win2D/html/M_Microsoft_Graphics_Canvas_Geometry_CanvasGeometry_CombineWith_1.htm&quot;&gt;CombineWith&lt;/a&gt;相减得出文字以外的部分，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var fullSizeGeometry = CanvasGeometry.CreateRectangle(session, 0, 0, width, height);
var textGeometry = CanvasGeometry.CreateText(textLayout);
var finalGeometry = fullSizeGeometry.CombineWith(textGeometry, Matrix3x2.Identity, CanvasGeometryCombine.Exclude);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里之所以不直接使用textGeometry，是因为我们并不是真的裁剪出文字的部分，而是像WPF的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.uielement.opacitymask?view=netframework-4.8&quot;&gt;OpacityMask&lt;/a&gt;那样用透明度控制显示的部分。&lt;a href=&quot;http://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_CanvasActiveLayer.htm&quot;&gt;CanvasActiveLayer&lt;/a&gt;就是用来实现这个功能。&lt;code&gt;CanvasDrawingSession.CreateLayer&lt;/code&gt;函数使用透明度和CanvasGeometry创建一个&lt;code&gt;CanvasActiveLayer&lt;/code&gt;，在创建Layer后&lt;code&gt;CanvasDrawingSession&lt;/code&gt;的操作都会应用这个透明度，直到Layer关闭。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;using (var layer = session.CreateLayer(1, finalGeometry))
{
    //DrawSth
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200345520-392662401.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.2405063291139&quot;&gt;
&lt;p&gt;关于CanvasActiveLayer的更多用法， 可以参考Lindexi的&lt;a href=&quot;https://blog.csdn.net/lindexi_gd/article/details/97624115&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;制作有复杂颜色的阴影&quot;&gt;4. 制作有复杂颜色的阴影&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200402190-349115024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，UWP中的DropShadow的Color只能有一种颜色，所以DropShadow不能使用复杂的颜色。这时候就要用到&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositionmaskbrush&quot;&gt;CompositionMaskBrush&lt;/a&gt;，CompositionMaskBrush有两个主要属性：Mask和Source。其中Mask是一个&lt;code&gt;CompositionBrush&lt;/code&gt;类型的属性，它指定不透明的蒙板源。简单来说，CompositionMaskBrush的形状就是它的Mask的形状。而Source属性则是它的颜色，这个属性可以是 CompositionColorBrush、CompositionLinearGradientBrush、CompositionSurfaceBrush、CompositionEffectBrush 或 CompositionNineGridBrush 类型的任何 CompositionBrush。可以使用前面创建的CompositionDrawingSurface创建出CompositionSurfaceBrush，最后创建一个CompositionMaskBrush，将CompositionSurfaceBrush作为它的Mask。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var maskBrush = Compositor.CreateMaskBrush();
maskBrush.Mask = Compositor.CreateSurfaceBrush(DrawingSurface);
maskBrush.Source = Compositor.CreateLinearGradientBrush();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来还想做到大紫大红的，但被吐槽和本来低调内敛的目的不符合，所以复用了以前&lt;a href=&quot;https://www.cnblogs.com/dino623/p/CompositionLinearGradientBrush-with-BlendEffect.html&quot;&gt;这篇文章&lt;/a&gt;的配色，CompositionLinearGradientBrush加BlendEffect做成了有些复杂的配色（但实际上太暗了看不出来）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200416898-401277615.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191126200427663-346983899.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用pointlight和ambientlight制作动画&quot;&gt;5. 使用PointLight和AmbientLight制作动画&lt;/h2&gt;
&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/dino623/p/using-PointLight-and-create-animation.html&quot;&gt;使用PointLight并实现动画效果&lt;/a&gt;这篇文章里介绍了PointLight的用法及基本动画，这次豪华些，同时有从左到右的红光以及从右到左的蓝光，这两个PointLight的动画效果大致是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201911/38937-20191123174634971-1633718128.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为PointLight最多只能叠加两个，所以再使用&lt;code&gt;AmbientLight&lt;/code&gt;并对它的&lt;code&gt;Intensity&lt;/code&gt;属性做动画，这样动画就会变得复杂些，最终实现了文章开头的动画。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var compositor = Window.Current.Compositor;
var ambientLight = compositor.CreateAmbientLight();
ambientLight.Intensity = 0;
ambientLight.Color = Colors.White;

var intensityAnimation = compositor.CreateScalarKeyFrameAnimation();
intensityAnimation.InsertKeyFrame(0.2f, 0, compositor.CreateLinearEasingFunction());
intensityAnimation.InsertKeyFrame(0.5f, 0.20f, compositor.CreateLinearEasingFunction());
intensityAnimation.InsertKeyFrame(0.8f, 0, compositor.CreateLinearEasingFunction());
intensityAnimation.Duration = TimeSpan.FromSeconds(10);
intensityAnimation.IterationBehavior = AnimationIterationBehavior.Forever;

ambientLight.StartAnimation(nameof(AmbientLight.Intensity), intensityAnimation);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_CanvasRenderTarget.htm&quot;&gt;CanvasRenderTarget Class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_Geometry_CanvasGeometry.htm&quot;&gt;CanvasGeometry Class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_CanvasActiveLayer.htm&quot;&gt;CanvasActiveLayer Class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositionmaskbrush&quot;&gt;CompositionMaskBrush Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/uwp/composition/composition-lighting&quot;&gt;组合照明 - Windows UWP applications Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/c_191585960&quot;&gt;Win2D - 知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Nov 2019 22:25:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<og:description>1. 成果 献祭了周末的晚上，成功召唤出了上面的番茄钟。正当我在感慨“不愧是Shadow大人，这难道就是传说中的五彩斑斓的黑？” “那才不是什么阴影效果，那是发光效果。”被路过的老婆吐槽了。 系系系，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dino623/p/using_win2d_and_composition_API_to_implement_the_glow_effect_of_text_and_make_animation.html</dc:identifier>
</item>
<item>
<title>串烧 JavaCAS相关知识 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11939124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11939124.html</guid>
<description>&lt;h3 id=&quot;jmm与问题引入&quot;&gt;JMM与问题引入&lt;/h3&gt;
&lt;p&gt;为啥先说JMM,因为CAS的实现类中维护的变量都被volatile修饰, 这个volatile 是遵循JMM规范(不是百分百遵循,下文会说)实现的保证多线程并发访问某个变量实现线程安全的手段&lt;/p&gt;
&lt;p&gt;一连串的知识点慢慢缕&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191126230551617-2110851234.png&quot; alt=&quot;jmm&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先说什么是JMM, JMM就是大家所说的java的内存模型, 它是人们在逻辑上做出的划分, 或者可以将JMM当成是一种规范, 有哪些规范呢? 如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可见性: 某一个线程对内存中的变量做出改动后,要求其他的线程在第一事件内马上马得到通知,在CAS的实现中, 可见性其实是通过不断的while循环读取而得到的通知, 而不是被动的得到通知&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性: 线程在执行某个操作的时,要么一起成功,要么就一起失败&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序性: 为了提高性能, 编译器处理器会进行指令的重排序, 源码-&amp;gt; 编译器优化重排 -&amp;gt; 处理器优化重排 -&amp;gt; 内存系统重排 -&amp;gt; 最终执行的命令&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;JVM运行的实体是线程, 每一个线程在创建之后JVM都会为其创建一个工作空间, 这个工作空间是每一个线程之间的私有空间, 并且任何两条线程之间的都不能直接访问到对方的工作空间, 线程之间的通信,必须通过共享空间来中转完成&lt;/p&gt;
&lt;p&gt;JMM规定所有的变量全部存在主内存中,主内存是一块共享空间,那么如果某个线程相对主内存中共享变量做出修改怎么办呢? 像下面这样:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将共享变量的副本拷贝到工作空间中&lt;/li&gt;
&lt;li&gt;对变量进行赋值修改&lt;/li&gt;
&lt;li&gt;将工作空间中的变量写回到内存中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;JMM还规定如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任何线程在解锁前必须将工作空间的共享变量立即刷新进内存中&lt;/li&gt;
&lt;li&gt;线程在加锁前必须读取主内存中的值更新到自己的工作空间中&lt;/li&gt;
&lt;li&gt;加锁和解锁是同一把锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;问题引入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时候如果多个线程并发按照上面的三步走去访问主内存中的共享变量的话就会出现线程安全性的问题, 比如说 现在主内存中的共享变量是c=1, 有AB两个线程去并发访问这个c变量, 都想进行c++, 现在A将c拷贝到自己的工作空间进行c++, 于是c=2 , 于此同时线程B也进行c++, c在B的工作空间中=2, AB线程将结果写回工作空间最终的结果就是2, 而不是我们预期的3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相信怎么解决大家都知道, 就是使用JUC,中的原子类就能规避这个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而原子类的底层实现使用的就是CAS技术&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;什么是cas&quot;&gt;什么是CAS&lt;/h3&gt;
&lt;p&gt;CAS(compare and swap) 顾名思义: 比较和交换,&lt;strong&gt;在JUC中原子类的底层使用的都是CAS无锁实现线程安全,是一门很炫的技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下面两行代码, 先比较再交换, 即: 如果从主内存中读取到的值为4就将它更新为2019&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        AtomicInteger atomicInteger = new AtomicInteger(4);
        atomicInteger.compareAndSet(4,2019);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进&lt;code&gt;AtomicInteger&lt;/code&gt;的源码如下, 底层维护着一个int 类型的 变量, (当然是因为我选择的原来类是AtomicInteger类型), 并且这个int类型的值被 &lt;strong&gt;volatile 修饰&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private volatile int value;

    /**
     * Creates a new AtomicInteger with the given initial value.
     *
     * @param initialValue the initial value
     */
    public AtomicInteger(int initialValue) {
        value = initialValue;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;什么是volatile&quot;&gt;什么是volatile&lt;/h3&gt;
&lt;p&gt;volatile是JVM提供的轻量的同步机制, 为什么是轻量界别呢? , 刚才在上面说了JMM规范中提到了三条特性, 而JVM提供的volatile仅仅满足上面的规范中的 2/3, 如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证可见性&lt;/li&gt;
&lt;li&gt;不保证原子性&lt;/li&gt;
&lt;li&gt;禁止指令重排序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;单独的volatile是不能满足原子性的,即如下代码在多线程并发访问的情况下依然会出现线程安全性问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile int value;
 
public void add(){
  value++;   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那么JUC的原子类是如何实现的 可以满足原子性呢? 于是就不得不说本片博文的主角, CAS&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;cas源码跟进&quot;&gt;CAS源码跟进&lt;/h3&gt;
&lt;p&gt;我们跟进&lt;code&gt;AtomicInteger&lt;/code&gt;中的先递增再获取的方法 &lt;code&gt;incrementAndGet()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过代码我们看到调用了Unsafe类来实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是Unsafe类?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入Unsafe类,可以看到他里面存在大量的 native方法,这些native方法全部是空方法,&lt;/p&gt;
&lt;p&gt;这个unsafe类其实相当于一个后门,他是java去访问调用系统上 C C++ 函数类库的方法 如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201911/1496926-20191126230551196-632541819.png&quot; alt=&quot;unsafe&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续跟进这个方法&lt;code&gt;incrementAndGet()&lt;/code&gt; 于是我们就来到了我们的主角方法, 关于这个方法倒是不难理解,主要是搞清楚方法中的var12345到底代表什么就行, 如下代码+注释&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;var1: 上一个方法传递进来的: this,即当前对象
var2: 上一个方法传递进来的valueOffset, 就是内存地址偏移量
      通过这个内存地址偏移量我能精确的找到要操作的变量在内存中的地址
      
var4: 上一个方法传递进来的1, 就是每次增长的值
var5: 通过this和内存地址偏移量读取出来的当前内存中的目标值
public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意它用的是while循环, 相对if(flag){} 这种写法会多一次判断, 整体的思路就是 在进行修改之前先进行一次比较,如果读取到的当前值和预期值是相同的,就自增,否则的话就继续轮询修改&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;小总结&quot;&gt;小总结&lt;/h3&gt;
&lt;p&gt;通过上面的过程, 其实就能总结出CAS的底层实现原理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;volatile&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;li&gt;unsafe类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补充: CAS通过Native方法的底层实现,本质上是操作系统层面上的CPU的并发原语,JVM会直接实现出汇编层面的指令,依赖于硬件去实现, 此外, 对于CPU的原语来说, 有两条特性1,必定连续, 2.不被中断&lt;/p&gt;
&lt;h3 id=&quot;cas的优缺点&quot;&gt;CAS的优缺点&lt;/h3&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;p&gt;它的底层我们看到了通过do-while 实现的自旋锁来实现, 就省去了在多个线程之间进行切换所带来的额外的上下文切换的开销&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过while循环不断的尝试获取, 省去了上下文切换的开销,但是占用cpu的资源&lt;/li&gt;
&lt;li&gt;CAS只能保证一个共享变量的原子性, 如果存在多个共享变量的话不得不加锁实现&lt;/li&gt;
&lt;li&gt;存在ABA问题&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;aba问题&quot;&gt;ABA问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是ABA问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们这样玩, 还是AB两个线程, 给&lt;code&gt;AtomicInteger&lt;/code&gt;赋初始值0&lt;/p&gt;
&lt;p&gt;A线程中的代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        Thread.sleep(3000);
        atomicInteger.compareAndSet(0,2019);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B线程中的代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        atomicInteger.compareAndSet(0,1);
        atomicInteger.compareAndSet(1,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AB线程同时启动, 虽然最终的结果A线程能成果的将值修改成2019,,但是它不能感知到在他睡眠过程中B线程对数据进行过改变, 换句话说就是A线程被B线程欺骗了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ABA问题的解决--- AtomicStampedRefernce.java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;带时间戳的原子引用, 实现的机制就是通过 原子引用+版本号来完成, 每次对指定值的修改相应的版本号会加1, 实例如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        // 0表示初始化, 1表示初始版本号
        AtomicStampedReference&amp;lt;Integer&amp;gt; reference = new AtomicStampedReference&amp;lt;&amp;gt;(0, 1);
        reference.getStamp(); // 获取版本号
        reference.attemptStamp(1,2); // 期待是1, 如果是1就更新为2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;原子引用&quot;&gt;原子引用&lt;/h3&gt;
&lt;p&gt;JUC中我们可以找到像&lt;code&gt;AtomicInteger&lt;/code&gt;这样已经定义好了实现类, 但是JUC没有给我们提供类似这样 &lt;code&gt;AtomicUser&lt;/code&gt;或者 &lt;code&gt;AtomicProduct&lt;/code&gt; 这样自定义类型的原子引用类型啊, 不过java仍然是提供了后门就是 原子引用类型&lt;/p&gt;
&lt;p&gt;使用实例:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        User user  = getUserById(1);
        AtomicReference&amp;lt;User&amp;gt; userAtomicReference = new AtomicReference&amp;lt;User&amp;gt;();
        user.setUsername(&quot;张三&quot;);
        userAtomicReference.compareAndSet(user,user);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;欢迎关注我, 会继续更新笔记&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 26 Nov 2019 15:08:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>JMM与问题引入 为啥先说JMM,因为CAS的实现类中维护的变量都被volatile修饰, 这个volatile 是遵循JMM规范(不是百分百遵循,下文会说)实现的保证多线程并发访问某个变量实现线程安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11939124.html</dc:identifier>
</item>
<item>
<title>ASP.NET Aries 高级开发教程：如何写WebAPI接口 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/11939069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/11939069.html</guid>
<description>&lt;p&gt;最近，有不少同学又问到，Aries里如何提供WebAPI接口？&lt;/p&gt;
&lt;p&gt;针对这个问题，今天给顺路写个教程，其实呢，很简单的。&lt;/p&gt;

&lt;p&gt;用这种方式，直接添加接口就可以了，Aries只是默认处理了.html后缀的请求。对于WS的asmx后缀是没有影响的，所以传统怎么添加就怎么添加。&lt;/p&gt;


&lt;p&gt;用这种方式，就是把接口独立成一个项目，然后通过IIS部署成子应用程序就可以了。&lt;/p&gt;
&lt;p&gt;只是部署成子应用程序的时候，需要注意一下子目录和根目录的web.config，出现重复的只能留根目录的那个。&lt;/p&gt;
&lt;p&gt;（一般都会建议用户用这种方式，好处是可以在IIS里学会一下怎么部署子应用程序。）&lt;/p&gt;

&lt;p&gt;这个方式，其实也很简单，下面介绍一下简单的部署：&lt;/p&gt;
&lt;h2&gt;1、引用Taurus.MVC用于写WebAPI：&lt;/h2&gt;
&lt;p&gt;在Web.UI项目添加引用Taurus.Core.dll（可以在Nuget上引用，也可以引用源码项目再引用项目）&lt;/p&gt;
&lt;h2&gt;2、配置Taurus.MVC的两个必备项：&lt;/h2&gt;
&lt;p&gt;A、在HttpModule中添加URL拦截。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是原来有的： &lt;/span&gt;
&amp;lt;add name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aries.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aries.Core.UrlRewrite,Aries.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是新添加的：&lt;/span&gt;
 &amp;lt;add name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taurus.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taurus.Core.UrlRewrite,Taurus.Core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B、在AppSetting中设置路径模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--&lt;span&gt;配置模式【值为0,1或2】[默认为1]
      值为0：匹配{Action}&lt;/span&gt;/&lt;span&gt;{Para}
      值为1：匹配{Controller}&lt;/span&gt;/{Action}/&lt;span&gt;{Para}
      值为2：匹配{Module}&lt;/span&gt;/{Controller}/{Action}/{Para}--&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taurus.RouteMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C、在AppSetting中设置接口代码所在的项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!--&lt;span&gt;指定控制器所在的项目（Dll）名称（可改，项目编绎的dll叫什么名就写什么）
    &lt;/span&gt;&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taurus.Controllers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taurus.Controllers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;--&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果是用Nuget上引用的，默认都会有上面的两个，其它默认生的，可以注释掉。&lt;/p&gt;
&lt;h2&gt;3、开始写应用接口代码：&lt;/h2&gt;
&lt;p&gt;接口代码写在哪里呢？放在哪个项目都可以，只要上面C点的配置指向就可以了，如果接口代码分散在多个项目中，配置的value可以用“逗号”分隔。&lt;/p&gt;
&lt;p&gt;按Taurus.MVC的方式写接口，继承自Taurus.Core.Controller即可：&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; API 接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; APIController : Taurus.Core.Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Hello()
        {
            Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello Controllers.API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口访问：http://.../api/hello&lt;/p&gt;

&lt;p&gt;Aries中默认处理的是.html后缀。&lt;/p&gt;
&lt;p&gt;Taurus默认处理的是无后缀。&lt;/p&gt;
&lt;p&gt;所以两者并无冲突，直接引用，加配置就可以了，没你想的复杂。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Nov 2019 14:59:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<og:description>最近，有不少同学又问到，Aries里如何提供WebAPI接口？  针对这个问题，今天给顺路写个教程，其实呢，很简单的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cyq1162/p/11939069.html</dc:identifier>
</item>
<item>
<title>【前端知识体系-JS相关】10分钟搞定JavaScript正则表达式高频考点 - Web前端社区</title>
<link>http://www.cnblogs.com/fecommunity/p/11922183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fecommunity/p/11922183.html</guid>
<description>&lt;h2 id=&quot;正则表达式基础&quot;&gt;1.正则表达式基础&lt;/h2&gt;
&lt;h3 id=&quot;创建正则表达式&quot;&gt;1.1 创建正则表达式&lt;/h3&gt;
&lt;h4 id=&quot;使用一个正则表达式字面量&quot;&gt;1.1.1 使用一个正则表达式字面量&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;调用regexp对象的构造函数&quot;&gt;1.1.2 调用RegExp对象的构造函数&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const regex = new RegExp(pattern, [, flags])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特殊字符&quot;&gt;1.1.3 特殊字符&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; - ^ 匹配输入的开始
 - $ 匹配输入的结束
 - \* 0次或多次  {0，}
 - \+ 1次或多次  {1，}
 - ?
   - 0次或者1次 {0,1}。
   - 用于先行断言
   - 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪
     - 对 &quot;123abc&quot; 用 /\d+/ 将会返回 &quot;123&quot;，
     - 用 /\d+?/,那么就只会匹配到 &quot;1&quot;。
 - . 匹配除换行符之外的任何单个字符
 - (x)  匹配 'x' 并且记住匹配项
 - (?:x)  匹配 'x' 但是不记住匹配项
 - x(?=y)  配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。
 - x(?!y)  匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。
 - x|y  匹配‘x’或者‘y’。
 - {n}  重复n次
 - {n, m}  匹配至少n次，最多m次
 - [xyz]   代表 x 或 y 或 z
 - [^xyz]  不是 x 或 y 或 z
 - \d  数字
 - \D  非数字
 - \s  空白字符，包括空格、制表符、换页符和换行符。
 - \S  非空白字符
 - \w  单词字符（字母、数字或者下划线）  [A-Za-z0-9_]
 - \W  非单字字符。[^A-Za-z0-9_]
 - \3  表示第三个分组
 - \b   词的边界
   - /\bm/匹配“moon”中得‘m’；
 - \B   非单词边界&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用正则表达式的方法&quot;&gt;1.2 使用正则表达式的方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。&lt;/li&gt;
&lt;li&gt;test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。&lt;/li&gt;
&lt;li&gt;match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。&lt;/li&gt;
&lt;li&gt;search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。&lt;/li&gt;
&lt;li&gt;replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。&lt;/li&gt;
&lt;li&gt;split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;正则对象的三个方法&quot;&gt;1.2.1 正则对象的三个方法&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;        //①test()判断字符串中是否出现某个字符串，返回布尔值
        var re = /abc/;
        var str = '00abc66';
        console.log(re.test(str));  // true
        //②exec()查找并返回字符串中指定的某个字符串，只匹配一次
        var re = /abc/;
        var str = 'a0bc88abc00abc';
        console.log(re.exec(str));  // [&quot;abc&quot;, index: 6, input: &quot;a0bc88abc00abc&quot;, groups: undefined]
        //③compile()方法用于改变正则匹配的内容
        var re = /ab/;
        var str = &quot;aabcdef&quot;;
        console.log(re.test(str));  //true
        re.compile(/bd/);
        console.log(re.test(str));  //false
        re.compile('66');
        console.log(re.test(str));  //false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;字符串中与正则相关的方法&quot;&gt;1.2.2 字符串中与正则相关的方法&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;        //①search()方法，返回符合条件的字符串首次出现的位置（下标）
        var re = /abc/;
        var str = '00abc66';
        console.log(str.search(re));        // 2
        //②match()方法，返回查找的结果，如果查询不到返回NULL
        console.log(str.match(re));         // [&quot;abc&quot;, index: 2, input: &quot;00abc66&quot;, groups: undefined]
        //③replace()方法，将匹配到的内容替换成指定内容
        console.log(str.replace(re, &quot;*&quot;));
        //④split()方法，将字符串分割成字符串数组
        console.log(str.split(re));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则表达式子表达式相关&quot;&gt;1.3 正则表达式子表达式相关&lt;/h3&gt;
&lt;h4 id=&quot;子表达式&quot;&gt;1.3.1 子表达式&lt;/h4&gt;
&lt;p&gt;在正则表达式中，通过一对圆括号括起来的内容，我们就称之为“子表达式”。如：var re = /\d(\d)\d/;&lt;/p&gt;
&lt;h4 id=&quot;捕获&quot;&gt;1.3.2 捕获&lt;/h4&gt;
&lt;p&gt;在正则表达式中，子表达式匹配到相应的内容时，系统会自动捕获这个行为，然后将子表达式匹配到的内容放入系统的缓存区中。我们把这个过程就称之为“捕获”。&lt;/p&gt;
&lt;h4 id=&quot;反向引用&quot;&gt;1.3.3 反向引用&lt;/h4&gt;
&lt;p&gt;在正则表达式中，我们可以使用\n（n&amp;gt;0，正整数，代表系统中的缓冲区编号）来获取缓冲区中的内容，我们把这个过程就称之为“反向引用”。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    var str = &quot;d1122jj7667h6868s9999&quot;;
    //查找AABB型的数字
    console.log(str.match(/(\d)\1(\d)\2/)); //1122
    //查找ABBA型的数字
    console.log(str.match(/(\d)(\d)\2\1/)); //7667
    //查找ABAB型的数字
    console.log(str.match(/(\d)(\d)\1\2/)); //6868
    //查找四个连续相同的数字
    console.log(str.match(/(\d)\1\1\1/));   //9999&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;限定符&quot;&gt;1.4 限定符&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;限定符可以指定正则表达式的一个给定字符必须要出现多少次才能满足匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;    *：匹配前面的子表达式零次或多次，0到多
    +：匹配前面的子表达式一次或多次，1到多
    ?：匹配前面的子表达式零次或一次，0或1
    {n}：匹配确定的 n 次 
    {n,}：至少匹配 n 次 
    {n,m}：最少匹配 n 次且最多匹配 m 次&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;[!WARNING]&lt;br/&gt;注意：针对于{n,m}，正则在匹配到一个符合多种次数的字符串时，优先匹配次数多的，即能匹配到m次就不会匹配n次，这就是贪婪模式（默认）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果在其后加?即{n,m}?则会更改为非贪婪模式（惰性模式），则此时正则优先匹配n次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    var str = &quot;aa1a22a333a6a8a&quot;;
    console.log(str.match(/a\d*/));      //a
    console.log(str.match(/a\d+/));      //a1
    console.log(str.match(/a\d?/));      //a
    console.log(str.match(/a\d{3}/));    //a333
    console.log(str.match(/a\d{2,}/));   //a22
    console.log(str.match(/a\d{1,3}/));  //a1
    console.log(str.match(/a\d{1,3}?/)); //a1

    //贪婪模式加深理解，案例如下：
    //贪婪模式下最开始的'a2就符合条件'，但是它会返回'a22'
    //注意：它是在遇到一个同时符合多个次数条件的字符串时，取符合次数多字符串
    var str = &quot;a22aa1a333a6a8a&quot;;
    console.log(str.match(/a\d{1,3}/));   //a22
    console.log(str.match(/a\d{1,3}/g));  //a22 a1 a333 a6 a8
    console.log(str.match(/a\d{1,3}?/));  //a2
    console.log(str.match(/a\d{1,3}?/g)); //a2 a1 a3 a6 a8&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定位符&quot;&gt;1.5 定位符&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;定位符可以将一个正则表达式固定在一行的开始或结束。也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;^ (脱字符)：匹配输入字符串的开始位置
$：匹配输入字符串的结束位置
\b：匹配一个单词边界
\B：匹配非单词边界&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则表达式的匹配模式修饰符&quot;&gt;1.6 正则表达式的匹配模式（修饰符）&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;表示正则匹配的附加规则，放在正则模式的最尾部。修饰符可以单个使用，也可以多个一起使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;①g全局匹配，找到所有匹配，而不是在第一个匹配后停止&lt;/li&gt;
&lt;li&gt;②i匹配全部大小写&lt;/li&gt;
&lt;li&gt;③m多行，将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由\n或\r分割），而不只是只匹配整个输入字符串的最开始和最末尾处。&lt;/li&gt;
&lt;li&gt;④s与m相反，单行匹配&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    var re = /^[a-z]/gim;   //可组合使用&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;转义字符&quot;&gt;1.7 转义字符&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;[!NOTE]&lt;br/&gt;因为在正则表达式中 . +  等属于表达式的一部分，但有时也需要匹配这些特殊字符，所以，需要使用反斜杠对特殊字符进行转义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  需要转义的字符：
  点号.
  小括号()
  中括号[]
  左斜杠/
  右斜杠\
  选择匹配符|
  
  * 
  ?
  {}
  + 
  $
  ^&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;正则练习题&quot;&gt;2. 正则练习题&lt;/h2&gt;
&lt;h3 id=&quot;匹配结尾的数字&quot;&gt;2.1 匹配结尾的数字&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/\d+$/g&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;统计空格个数&quot;&gt;2.2 统计空格个数&lt;/h3&gt;
&lt;p&gt;字符串内如有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let reg = /\s+/g
str.replace(reg, &quot; &quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;判断字符串是不是由数字组成&quot;&gt;2.3 判断字符串是不是由数字组成&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;str.test(/^\d+$/);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;电话号码正则&quot;&gt;2.4 电话号码正则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;区号必填为3-4位的数字&lt;/li&gt;
&lt;li&gt;区号之后用“-”与电话号码连接电话号码为7-8位的数字&lt;/li&gt;
&lt;li&gt;分机号码为3-4位的数字，非必填，但若填写则以“-”与电话号码相连接&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^\d{3,4}-\d{7,8}(-\d{3,4})?$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;手机号码正则表达式&quot;&gt;2.5 手机号码正则表达式&lt;/h3&gt;
&lt;p&gt;正则验证手机号，忽略前面的0，支持130-139，150-159。忽略前面0之后判断它是11位的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^0*1(3|5)\d{9}$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用正则表达式实现删除字符串中的空格&quot;&gt;2.6 使用正则表达式实现删除字符串中的空格&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;funtion trim(str) {
  let reg = /^\s+|\s+$/g
  return str.replace(reg, '');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;限制文本框只能输入数字和两位小数点等等&quot;&gt;2.7 限制文本框只能输入数字和两位小数点等等&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^\d*\.\d{0,2}$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;只能输入小写的英文字母和小数点和冒号正反斜杠.&quot;&gt;2.8 只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./)&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^[a-z\.:\/\\]*$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;替换小数点前内容为指定内容&quot;&gt;2.9 替换小数点前内容为指定内容&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例如：infomarket.php?id=197 替换为 test.php?id=197&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var reg = /^[^\.]+/;
var target = '---------';
str = str.replace(reg, target)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;只匹配中文的正则表达式&quot;&gt;2.10 只匹配中文的正则表达式&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/[\u4E00-\u9FA5\uf900-\ufa2d]/ig&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;返回字符串的中文字符个数&quot;&gt;2.11 返回字符串的中文字符个数&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先去掉非中文字符，再返回length属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function cLength(str){
  var reg = /[^\u4E00-\u9FA5\uf900-\ufa2d]/g;
  //匹配非中文的正则表达式
  var temp = str.replace(reg,'');
  return temp.length;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则表达式取得匹配ip地址前三段&quot;&gt;2.12 正则表达式取得匹配IP地址前三段&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只要匹配掉最后一段并且替换为空字符串就行了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function getPreThrstr(str) {
  let reg = /\.\d{1,3}$/;
  return str.replace(reg,'');
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匹配ul标签之间的内容&quot;&gt;2.13 匹配&lt;strong&gt;ul&lt;/strong&gt;标签之间的内容&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/&amp;lt;ul&amp;gt;[\s\S]+?&amp;lt;/ul&amp;gt;/i&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用正则表达式获得文件名&quot;&gt;2.14 用正则表达式获得文件名&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;c:\images\tupian\006.jpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能是直接在盘符根目录下，也可能在好几层目录下，要求替换到只剩文件名。&lt;br/&gt;首先匹配非左右斜线字符0或多个，然后是左右斜线一个或者多个。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function getFileName(str){
  var reg = /[^\\\/]*[\\\/]+/g;
  // xxx\ 或是 xxx/
  str = str.replace(reg,'');
  return str;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;绝对路径变相对路径&quot;&gt;2.15 绝对路径变相对路径&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&quot;http://23.123.22.12/image/somepic.gif&quot;转换为：&quot;/image/somepic.gif&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var reg = /http:\/\/[^\/]+/;
str = str.replace(reg,&quot;&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用户名正则&quot;&gt;2.16 用户名正则&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用于用户名注册，，用户名只 能用 中文、英文、数字、下划线、4-16个字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^[\u4E00-\u9FA5\uf900-\ufa2d\w]{4,16}$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匹配英文地址&quot;&gt;2.17 匹配英文地址&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;规则如下:&lt;br/&gt;包含 &quot;点&quot;, &quot;字母&quot;,&quot;空格&quot;,&quot;逗号&quot;,&quot;数字&quot;，但开头和结尾不能是除字母外任何字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^[a-zA-Z][\.a-zA-Z,0-9]*[a-zA-Z]$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则匹配价格&quot;&gt;2.18 正则匹配价格&lt;/h3&gt;
&lt;p&gt;开头数字若干位，可能有一个小数点，小数点后面可以有两位数字。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^\d+(\.\d{2})?$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;身份证号码的匹配&quot;&gt;2.19 身份证号码的匹配&lt;/h3&gt;
&lt;p&gt;身份证号码可以是15位或者是18位，其中最后一位可以是X。其它全是数字&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^(\d{14}|\d{17})(X|x)$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;单词首字母大写&quot;&gt;2.20 单词首字母大写&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每单词首字大写，其他小写。如blue idea转换为Blue Idea，BLUE IDEA也转换为Blue Idea&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function firstCharUpper(str) {
  str = str.toLowerCase();
  let reg = /\b(\w)/g;
  return str.replace(reg, m =&amp;gt; m.toUpperCase());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则验证日期格式&quot;&gt;2.21 正则验证日期格式&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;yyyy-mm-dd格式, 4位数字，横线，1或者2位数字，再横线，最后又是1或者2位数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^\d{4}-\d{1,2}-\d{1,2}$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;去掉文件的后缀名&quot;&gt;2.22 去掉文件的后缀名&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;www.abc.com/dc/fda.asp 变为 www.abc.com/dc/fda&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function removeExp(str) {
  return str.replace(/\.\w$/,'')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证邮箱的正则表达式&quot;&gt;2.23 验证邮箱的正则表达式&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;开始必须是一个或者多个单词字符或者是-，加上@，然后又是一个或者多个单词字符或者是-。然后是点“.”和单词字符和-的组合，可以有一个或者多个组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^[\w-]+@\w+\.\w+$/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则判断标签是否闭合&quot;&gt;2.24 正则判断标签是否闭合&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;标签可能有两种方式闭合，自闭和或者对称闭合的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/&amp;lt;([a-z]+)(\s*\w*?\s*=\s*&quot;.+?&quot;)*(\s*?&amp;gt;[\s\S]*?(&amp;lt;\/\1&amp;gt;)+|\s*\/&amp;gt;)/i&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;正则判断是否为数字与字母的混合&quot;&gt;2.25 正则判断是否为数字与字母的混合&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不能小于12位，且必须为字母和数字的混合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/^(([a-z]+[0-9]+)|([0-9]+[a-z]+))[a-z0-9]*$/i&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将阿拉伯数字替换为中文大写形式&quot;&gt;2.26 将阿拉伯数字替换为中文大写形式&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function replaceReg(reg,str){
  let arr=[&quot;零&quot;,&quot;壹&quot;,&quot;贰&quot;,&quot;叁&quot;,&quot;肆&quot;,&quot;伍&quot;,&quot;陆&quot;,&quot;柒&quot;,&quot;捌&quot;,&quot;玖&quot;];
  let reg = /\d/g;
  return str.replace(reg,function(m){return arr[m];})
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;去掉标签的所有属性&quot;&gt;2.27 去掉标签的所有属性&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;td style=&quot;width: 23px; height: 26px;&quot; align=&quot;left&quot;&amp;gt;***&amp;lt;/td&amp;gt;
变成没有任何属性的
&amp;lt;td&amp;gt;***&amp;lt;/td&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;思路：非捕获匹配属性，捕获匹配标签，使用捕获结果替换掉字符串。正则如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/(&amp;lt;td)\s(?:\s*\w*?\s*=\s*&quot;.+?&quot;)*?\s*?(&amp;gt;)/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;驼峰表示&quot;&gt;2.28 驼峰表示&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;String.prototype.camelCase = function () {
        // .*?是非贪婪的匹配，点可以匹配任意字符，星号是前边的字符有0-n个均匹配，问号是则是0-1；
        // (^\w{1}): 用于匹配第一个首字母
        // (.*)：用于匹配任意个的前面的字符，.表示的就是任意字符

        // - param 1: 匹配到的字符串
        // - param 2: 匹配的的子字符串
        // - param 3: 匹配的子字符串
        // - param的位置
        // - param 5: 原始字符串 4: 匹配到的字符串在字符串中

        return this.replace(/(^\w{1})(.*)/g, function (match, g1, g2) {
            return g1.toUpperCase() + g2.toLowerCase();
        });
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模板字符串&quot;&gt;2.29 模板字符串&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// str = 'name: @(name), age:@(age)'
       // data = {name : 'xiugang', age : 18}
       /**
        * 实现一个简单的数据绑定
        * @param str
        * @param data
        * @return {*}
        */
       String.prototype.formateString = function (data) {
           return this.replace(/@\((\w+)\)/g, function (match, key) {
               // 注意这里找到的值必须返回出去(如果是undefined，就是没有数据)
               // 注意：判断一个值的类型是不是undefined，可以通过typeof判断
               console.log(typeof data[key] === 'undefined');
               return data[key] === 'undefined' ? '' : data[key];
           });

       }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;去掉两边的空格&quot;&gt;2.30 去掉两边的空格&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
        * 去掉两边的空格
        * @param str
        * @return {*}
        */
       String.prototype.trim = function () {
           return this.replace(/(^\s*)|(\s*$)/g, '');
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取url参数-使用replace保存到一个数组里面然后从数组里面取出数据&quot;&gt;2.31 获取url参数: 使用replace保存到一个数组里面，然后从数组里面取出数据&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;'http://www.189dg.com/ajax/sms_query.ashx?undefined&amp;amp;undefined&amp;amp;undefined-06-27&amp;amp;undefined-06-27'
 url.replace(/(\w+)=(\w+)/g, function(a, b, c){
   console.log(a, b, c)
 })
action=smsdetail action smsdetail
sid=22 sid 22
stime=2014 stime 2014
etime=2014 etime 2014


// 封装为一个函数
var url = &quot;http://127.0.0.1/e/action/ShowInfo.php?classid=9&amp;amp;id=2&quot;;
function parse_url(_url){
 var pattern = /(\w+)=(\w+)/ig;
 var parames = {};
 url.replace(pattern, function(a, b, c){
   parames[b] = c;
 });
 return parames;
}
var parames = parse_url(url);
alert(parames['classid'] + &quot;, &quot; + parames['id']);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Nov 2019 14:56:00 +0000</pubDate>
<dc:creator>Web前端社区</dc:creator>
<og:description>1.正则表达式基础 1.1 创建正则表达式 1.1.1 使用一个正则表达式字面量 1.1.2 调用RegExp对象的构造函数 1.1.3 特殊字符 1.2 使用正则表达式的方法 exec	一个在字符串</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fecommunity/p/11922183.html</dc:identifier>
</item>
</channel>
</rss>