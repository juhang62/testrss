<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java多线程之消费生产模型 - wsilj</title>
<link>http://www.cnblogs.com/wsilj/p/13544274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wsilj/p/13544274.html</guid>
<description>&lt;h3 id=&quot;需求：要求仓库最大容量为4，且一共只生产20台电视机，下面的代码只适用于一个生产者一个消费者，有没有大佬提点建议怎么改成一对多或多对多不会出现死锁情况&quot;&gt;需求：要求仓库最大容量为4，且一共只生产20台电视机，下面的代码只适用于一个生产者一个消费者，有没有大佬提点建议怎么改成一对多或多对多不会出现死锁情况&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Warehouse {

    private int TVCount = 0;

    // 生产

    public synchronized void produce() {
        if (TVCount &amp;lt; 4) {
            TVCount++;
            System.out.println(Thread.currentThread().getName() + &quot;开始生产第 &quot; + TVCount + &quot; 台电视&quot;);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            super.notify();

        } else {
            try {
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // 消费

    public synchronized void consume() {

        if (TVCount &amp;gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot;开始消费第 &quot; + TVCount + &quot; 台电视&quot;);
            TVCount--;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            super.notify();
        } else {
            try {
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Productor extends Thread {

    private Warehouse warehouse;

    public Productor(Warehouse warehouse) {
        this.warehouse = warehouse;
    }

    @Override
    public void run() {
        System.out.println(&quot;开始生产电视机&quot;);
        for (int i = 0; i &amp;lt; 20; i++) {
            try {
                sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            warehouse.produce();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Consumer extends Thread {
    private Warehouse warehouse;

    public Consumer(Warehouse warehouse) {
        this.warehouse = warehouse;
    }

    @Override
    public void run() {
        System.out.println(&quot;开始消费新产品&quot;);
        for (int i = 0; i &amp;lt; 20; i++) {
            try {
                sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            warehouse.consume();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadExer5 {
    public static void main(String[] args) {
        Warehouse warehouse = new Warehouse();

        Productor t1 = new Productor(warehouse);
//        Productor t3 = new Productor(warehouse);
        Consumer t2 = new Consumer(warehouse);

        t1.setName(&quot;生产者1&quot;);
        t2.setName(&quot;消费者1&quot;);
//        t3.setName(&quot;生产者2&quot;);

        t1.start();
        t2.start();
//        t3.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Aug 2020 00:25:00 +0000</pubDate>
<dc:creator>wsilj</dc:creator>
<og:description>需求：要求仓库最大容量为4，且一共只生产20台电视机，下面的代码只适用于一个生产者一个消费者，有没有大佬提点建议怎么改成一对多或多对多不会出现死锁情况 class Warehouse { privat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wsilj/p/13544274.html</dc:identifier>
</item>
<item>
<title>【机器学习】算法原理详细推导与实现(七):决策树算法 - TTyb</title>
<link>http://www.cnblogs.com/TTyb/p/12686248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TTyb/p/12686248.html</guid>
<description>&lt;p&gt;在之前的文章中，对于介绍的分类算法有&lt;a href=&quot;https://www.cnblogs.com/TTyb/p/10976291.html&quot;&gt;逻辑回归算法&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/TTyb/p/10989082.html&quot;&gt;朴素贝叶斯算法&lt;/a&gt;，这类算法都是二分类的分类器，但是往往只实际问题中&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;不仅仅只有&lt;span class=&quot;math inline&quot;&gt;\(\{0,1\}\)&lt;/span&gt;，当出现一个新的类别&lt;span class=&quot;math inline&quot;&gt;\(y=2\)&lt;/span&gt;时，之前的分类器就不太适用，这里就要介绍一个叫做&lt;strong&gt;决策树&lt;/strong&gt;的新算法，该算法对于多个目标的离散特征往往有比较好的分类效果，用以解决&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;是离散型的数据，这是判别模型，也是一个生成学习算法。&lt;/p&gt;
&lt;h2 id=&quot;id3决策树&quot;&gt;ID3决策树&lt;/h2&gt;
&lt;h3 id=&quot;熵&quot;&gt;熵&lt;/h3&gt;
&lt;p&gt;假设当前网上有很多机器学习的教程，我想学机器学习，但是不知道哪一个教程比较好；又或者想买一个榴莲，不知道哪一只肉比较厚实，不知道该挑那一只，对于这种不确定性就叫做熵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个事情有多种可能情况时，这件事情对于观察人而言具体是哪种情况的不确定性叫做熵。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;信息&quot;&gt;信息&lt;/h3&gt;
&lt;p&gt;当你不知道选择哪一篇教程来学习机器学习时，有人和你说TTyb的机器学习教程很好，这个人对你提供的&lt;strong&gt;TTyb的机器学习教程很好&lt;/strong&gt;就是信息；又或者在买榴莲的时候，卖榴莲的人和你说这个榴莲的肉肯定很厚实，卖榴莲的人和你说的&lt;strong&gt;这个榴莲的肉肯定很厚实&lt;/strong&gt;就是信息。当某件事情存在不确定性，能够消除观察人对于某件事情的不确定性，也就是前面说的熵，能够消除不确定性的事物叫做信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息有很多种表现形式，能够调整不确定的概率的事物可以叫做信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如卖榴莲的老板说有很大概率这个榴莲的肉可能很厚实；能够排除干扰的事物可以叫做信息，例如卖榴莲的老板说这个榴莲壳厚，肉肯定小不要选择这个；能够确定情况的事物可以叫做信息，卖榴莲的老板说这个榴莲肉肯定很厚实，开了不厚实算我的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熵和信息数量相等，意义相反，获取信息意味着消除了不确定性熵。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;信息熵&quot;&gt;信息熵&lt;/h3&gt;
&lt;p&gt;假设有4个榴莲只有一个肉是厚实的，老板和你说榴莲A的肉不厚实，给你提供了&lt;span class=&quot;math inline&quot;&gt;\(0.4bit\)&lt;/span&gt;的信息，榴莲B的肉不厚实，给你提供了&lt;span class=&quot;math inline&quot;&gt;\(0.6bit\)&lt;/span&gt;的信息，榴莲C的肉不厚实，给你提供了&lt;span class=&quot;math inline&quot;&gt;\(1bit\)&lt;/span&gt;的信息，最后让你确定了榴莲D肉是厚实的。老板每次都给你提供了一次信息，为什么提供的信息量却是不一样的？信息是如何量化的？回想一下什么东西有单位，质量、温度等物理量，信息也是一个物理量，要测量这个物理量，不妨回想一下我们是怎样测量质量的，“千克”最初又是怎么被定义出来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614114725321-1531374339.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实我们最初并不知道千克的质量，而是选定了一个参照物，把这个物体的质量就称为&lt;em&gt;千克&lt;/em&gt;。当想要测量其他物体的质量时，就看这个物体的质量相当于多少个参照物体的质量，这里的“多少个”便是千克，如果参照物体换成“斤”，那么单位就会变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614115538292-1788524088.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测量信息也是一样，既然信息消除的是不确定性，那么就选择另外一个事件的不确定性作为参照事件，当想要测量其他事件的信息时，就看待测事件的不确定性相当于“多少个”参照事件的不确定性，这里的多少个便是信息量。即待测物体质量为&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;，参照物体个数(信息量)为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，参照物体质量(千克)为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，那么：&lt;/p&gt;
&lt;p&gt;\[m=n\times x \]&lt;/p&gt;
&lt;h4 id=&quot;均匀分布的信息熵&quot;&gt;均匀分布的信息熵&lt;/h4&gt;
&lt;p&gt;当选择的参照物事件是像抛硬币这样，只有两种等概率情况的事件时，测得的信息量的单位就被称为比特(bit)，然而测量参照物体个数(信息量)&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;时，我们是用待测物体质量&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;除以参照物体质量(千克)&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，即:&lt;/p&gt;
&lt;p&gt;\[n=\frac{m}{x} \]&lt;/p&gt;
&lt;p&gt;可是测量信息时却不能用除法，因为抛掷3个硬币能够产生的等可能结果并非&lt;span class=&quot;math inline&quot;&gt;\(3\times 2=6\)&lt;/span&gt;，而是&lt;span class=&quot;math inline&quot;&gt;\(2^3=8\)&lt;/span&gt;种，也就是说信息量不是线性关系，而是指数关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|正正正|反正正|
|正反正|正正反|
|反反正|反正反|
|正反反|反反反|
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以当知道可能情况的个数&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;，想求这些情况相当于多少个&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;参照事件&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;所产生的，用指数运算的反函数，即对数运算计算：&lt;/p&gt;
&lt;p&gt;\[n=log_xm \]&lt;/p&gt;
&lt;p&gt;而这里硬币只有正面和反面，那么这里的参照事件&lt;span class=&quot;math inline&quot;&gt;\(x=2\)&lt;/span&gt;，公式变换为：&lt;/p&gt;
&lt;p&gt;\[n=log_2m \]&lt;/p&gt;
&lt;p&gt;上面的式子代表，在抛硬币的实验中，假设8个不确定情况就相当于3个硬币抛出来结果&lt;span class=&quot;math inline&quot;&gt;\(3=log_28\)&lt;/span&gt;，即信息量为&lt;span class=&quot;math inline&quot;&gt;\(3bit\)&lt;/span&gt;;4个不确定情况就相当于2个硬币抛出来结果&lt;span class=&quot;math inline&quot;&gt;\(2=log_24\)&lt;/span&gt;，即信息量为&lt;span class=&quot;math inline&quot;&gt;\(2bit\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4 id=&quot;一般分布的信息熵&quot;&gt;一般分布的信息熵&lt;/h4&gt;
&lt;p&gt;而上面讲的时抛掷硬币，被测事件的所有可能情况都是等概率事件，但是如果存在如下假设，&lt;em&gt;这里有4个榴莲，只有一个榴莲的肉是厚实的，其他3个榴莲的肉是不厚实的&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614115233402-2070181743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么买到肉是厚实榴莲的不确定性(信息熵)为&lt;span class=&quot;math inline&quot;&gt;\(log_24=2bit\)&lt;/span&gt;，因为这里可能情况的个数&lt;span class=&quot;math inline&quot;&gt;\(m=4\)&lt;/span&gt;，所以不确定性是&lt;span class=&quot;math inline&quot;&gt;\(2bit\)&lt;/span&gt;。但是如果老板和你说最大的那个(最右边圆圈)榴莲有50%概率是肉厚的，那么从概率上来说买最大的那个(最右边圆圈)是肉厚的概率为&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt;，取出不是肉厚的概率是&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{3}\times \frac{1}{2}\)&lt;/span&gt;，这里代表剩下3个榴莲要瓜分剩下的&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt;概率，所以剩下3个榴莲每个的概率是&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{6}\)&lt;/span&gt;，这时候各个情况的概率不一样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614115313521-383182549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时该如何计算总信息量了呢？这时候就要分别测量每种可能情况的信息量后，乘以他们各自发生的概率再相加即可，即这时候买到肉厚的榴莲的不确定性(信息熵)为：&lt;/p&gt;
&lt;p&gt;\[\frac{1}{6}log_2m_1+\frac{1}{6}log_2m_2+\frac{1}{6}log_2m_3+\frac{1}{2}log_2m_4 \]&lt;/p&gt;
&lt;p&gt;不过怎么测量每种情况的信息量&lt;span class=&quot;math inline&quot;&gt;\(log_2m\)&lt;/span&gt;呢，怎么知道概率为&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{6}\)&lt;/span&gt;的情况的不确定性相当于抛掷多少个硬币所产生的不确定性呢？我们确实没有办法用&lt;span class=&quot;math inline&quot;&gt;\(log_2m\)&lt;/span&gt;这个公式了，但是我们知道&lt;span class=&quot;math inline&quot;&gt;\(1%\)&lt;/span&gt;会发生的情况，相当于从100个等概率情况中确定实际情况，即&lt;span class=&quot;math inline&quot;&gt;\(p=1%=frac{1}{100}\)&lt;/span&gt;，概率的倒数等于等概率情况的个数，即&lt;span class=&quot;math inline&quot;&gt;\(m=\frac{1}{100}=\frac{1}{p}\)&lt;/span&gt;，用概率的倒数&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{p}\)&lt;/span&gt;替换等概率情况的个数&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;后，我们就可以计算每种情况的信息量了：&lt;/p&gt;
&lt;p&gt;\[m_1=\frac{1}{\frac{1}{6}},m_2=\frac{1}{\frac{1}{6}},m_3=\frac{1}{\frac{1}{6}},m_4=\frac{1}{\frac{1}{2}} \]&lt;/p&gt;
&lt;p&gt;再用每个情况的信息量乘以对应事件发生的概率，再相加后就能算出总信息量了：&lt;/p&gt;
&lt;p&gt;\[\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{2}log_2\frac{1}{\frac{1}{2}}=1.79bit \]&lt;/p&gt;
&lt;p&gt;由此可得到，任何随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;信息熵为：&lt;/p&gt;
&lt;p&gt;\[H(X)=\sum_{i=1}^n p_ilog_2\frac{1}{p_i} \]&lt;/p&gt;
&lt;h3 id=&quot;信息增益&quot;&gt;信息增益&lt;/h3&gt;
&lt;p&gt;既然任何随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;信息熵为：&lt;/p&gt;
&lt;p&gt;\[H(X)=\sum_{i=1}^n p_ilog_2\frac{1}{p_i} \]&lt;/p&gt;
&lt;p&gt;那么假设&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;是随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;发生的概率，如果存在多个变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;，则他们的联合熵为：&lt;/p&gt;
&lt;p&gt;\[H(X,Y)=\sum_{i=1}^n p(x_i,y_i)log_2p(x_i,y_i) \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(p(x_i,y_i)\)&lt;/span&gt;代表事件&lt;span class=&quot;math inline&quot;&gt;\(X=x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(Y=y\)&lt;/span&gt;一起出现的联合概率。有了联合熵，又可以得到条件熵的表达式&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;，条件熵类似于条件概率,当事件&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;发生过后，事件&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;还剩下的不确定性(信息熵)：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X|Y)&amp;amp;=\sum_{y} p(y)H(X|Y=y) \\ &amp;amp;=-\sum_{y} p(y)\sum_{x}p(x|y)log(p(x|y)) \\ &amp;amp;=-\sum_{y}\sum_{x}p(x,y)log(p(x|y)) \\ &amp;amp;=-\sum_{x,y}p(x,y)log(p(x|y)) \end{split} \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)=H(X,Y)−H(Y)\)&lt;/span&gt;，信息熵和信息增益的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614113726048-6251161.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的椭圆代表随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X)\)&lt;/span&gt;,右边的椭圆代表随机变量&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(Y)\)&lt;/span&gt;,中间重合的部分就是信息增益&lt;span class=&quot;math inline&quot;&gt;\(I(X,Y)\)&lt;/span&gt;, 左边的椭圆去掉重合部分就是&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;,右边的椭圆去掉重合部分就是&lt;span class=&quot;math inline&quot;&gt;\(H(Y|X)\)&lt;/span&gt;，两个椭圆的并就是&lt;span class=&quot;math inline&quot;&gt;\(H(X,Y)\)&lt;/span&gt;，由此可以得到信息增益的公式为：&lt;/p&gt;
&lt;p&gt;\[I(X,Y)=H(X)−H(X|Y) \]&lt;/p&gt;
&lt;p&gt;回到最初的问题，当4个榴莲中不知道那个是肉厚的榴莲的时候，随机变量&lt;span class=&quot;math inline&quot;&gt;\(X=肉厚\)&lt;/span&gt;，不确定性(信息熵)的套用公式为:&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X)&amp;amp;=\sum_{i=1}^n p_ilog_2\frac{1}{p_i} \\ &amp;amp;=\frac{1}{4}log_2\frac{1}{\frac{1}{4}}+\frac{1}{4}log_2\frac{1}{\frac{1}{4}}+\frac{1}{4}log_2\frac{1}{\frac{1}{4}}+\frac{1}{4}log_2\frac{1}{\frac{1}{4}} \\ &amp;amp;=2 \end{split} \]&lt;/p&gt;
&lt;p&gt;假设每个榴莲从左到右记为随机变量&lt;span class=&quot;math inline&quot;&gt;\(X1\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(X2\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(X3\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(X4\)&lt;/span&gt;，老板告诉说最大的那个&lt;span class=&quot;math inline&quot;&gt;\(X4\)&lt;/span&gt;(最右边圆圈)榴莲有50%概率是肉厚的，即提供了信息&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;，求肉厚的信息熵。这时候先计算的信息熵为条件熵&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X|Y)&amp;amp;=H(X1)+H(X2)+H(X3)+H(X4|Y=y) \\ &amp;amp;=\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{6}log_2\frac{1}{\frac{1}{6}}+\frac{1}{2}log_2\frac{1}{\frac{1}{2}} \\ &amp;amp;=1.79bit \end{split} \]&lt;/p&gt;
&lt;p&gt;最后由总的不确定性(信息熵)减去后面的不确定性(信息熵)，得到老板说的话“最大的那个(最右边圆圈)榴莲有50%概率是肉厚的”提供的信息为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} I(X,Y)&amp;amp;=H(X)−H(X|Y) \\ &amp;amp;=2-1.79 \\ &amp;amp;=0.21bit \end{split} \]&lt;/p&gt;
&lt;p&gt;提供的信息&lt;span class=&quot;math inline&quot;&gt;\(0.21bit\)&lt;/span&gt;也叫做&lt;strong&gt;信息增益&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;id3决策树算法步骤&quot;&gt;ID3决策树算法步骤&lt;/h3&gt;
&lt;p&gt;输入的是&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个样本，样本输出集合为&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;，每个样本有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个离散特征，特征集合即为&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;，输出为决策树&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;。例如存在样本如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;天气&lt;/th&gt;
&lt;th&gt;气温&lt;/th&gt;
&lt;th&gt;湿度&lt;/th&gt;
&lt;th&gt;风力&lt;/th&gt;
&lt;th&gt;外出&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;则样本数量&lt;span class=&quot;math inline&quot;&gt;\(m=5\)&lt;/span&gt;；输出集合为&lt;code&gt;是&lt;/code&gt;或者&lt;code&gt;否&lt;/code&gt;，即&lt;span class=&quot;math inline&quot;&gt;\(X_1=是,X_2=否\)&lt;/span&gt;；每个样本的离散特征为&lt;span class=&quot;math inline&quot;&gt;\(n=4\)&lt;/span&gt;，即&lt;code&gt;天气&lt;/code&gt;、&lt;code&gt;气温&lt;/code&gt;、&lt;code&gt;湿度&lt;/code&gt;、&lt;code&gt;风力&lt;/code&gt;；特征集合为&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;，当离散特征&lt;span class=&quot;math inline&quot;&gt;\(Y'\)&lt;/span&gt;是&lt;code&gt;天气&lt;/code&gt;时，特征集合&lt;span class=&quot;math inline&quot;&gt;\(Y_i\)&lt;/span&gt;为&lt;code&gt;{晴朗,多云,下雨}&lt;/code&gt;。算法的过程为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;计算&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;中的各个特征（一共&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个）对输出&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的信息增益，选择信息增益最大的特征&lt;span class=&quot;math inline&quot;&gt;\(Y'\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(Y' \in Y\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;按特征&lt;span class=&quot;math inline&quot;&gt;\(Y'\)&lt;/span&gt;的不同取值&lt;span class=&quot;math inline&quot;&gt;\(Y_i\)&lt;/span&gt;将对应的样本输出&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;分成不同的类别&lt;span class=&quot;math inline&quot;&gt;\(X_i\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(i \in n\)&lt;/span&gt;。每个类别产生一个子节点。对应特征值为&lt;span class=&quot;math inline&quot;&gt;\(Y_i\)&lt;/span&gt;。返回增加了节点的数&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于所有的子节点，令&lt;span class=&quot;math inline&quot;&gt;\(X=X_i,m=m−\{Y'\}\)&lt;/span&gt;递归调用1-2步，得到子树&lt;span class=&quot;math inline&quot;&gt;\(T_j\)&lt;/span&gt;并返回。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;c45决策树&quot;&gt;C4.5决策树&lt;/h2&gt;
&lt;p&gt;ID3算法虽然提出了新思路，但是还是有如下4点需要改进的地方：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;ID3没有考虑连续特征，比如长度、密度都是连续值，无法在ID3运用，这大大限制了ID3的用途。--数据分箱即可解决&lt;/li&gt;
&lt;li&gt;ID3采用信息增益大的特征优先建立决策树的节点，但信息增益准则对可取值数目较多的属性有所偏好。&lt;/li&gt;
&lt;li&gt;算法对于缺失值的情况没有做考虑。--特征工程即可解决&lt;/li&gt;
&lt;li&gt;没有考虑过拟合的问题。--预剪枝和后剪枝&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;对于上面的第2点需要做一下解释。从上面可以知道，ID3信息增益的计算公式为：&lt;/p&gt;
&lt;p&gt;\[I(X,Y)=H(X)−H(X|Y) \]&lt;/p&gt;
&lt;p&gt;信息增益的大小取决于随机变量&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;信息熵的大小，&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;越小则信息增益越大，而什么情况下&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;会有极小的信息熵呢？举一个极端的例子，如果上面的例子中，变量天气的特征互不相同变成：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;天气&lt;/th&gt;
&lt;th&gt;气温&lt;/th&gt;
&lt;th&gt;湿度&lt;/th&gt;
&lt;th&gt;风力&lt;/th&gt;
&lt;th&gt;外出&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;大晴&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;小晴&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;小雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;那么天气的信息熵会等于0，计算如下，当天气为大晴时，&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{1}\)&lt;/span&gt;的概率不外出，&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;的概率外出，那么大晴的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=大晴)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出|Y=大晴)&amp;amp;=\frac{1}{1}log_2\frac{1}{\frac{1}{1}}+0log_20 \\ &amp;amp;=0 \end{split} \]&lt;/p&gt;
&lt;p&gt;同理天气条件下其他特征的信息熵都是&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，那么天气的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=天气)=0\)&lt;/span&gt;，得到天气的信息增益就最大了。也就是说决策树给天气这个属性下的离散特征都单独分成了一个子类，也就是说有多少种天气情况就有多少种取值，那么原数据集中有多少个离散特征，就会被划分为多少个子类。虽然这种划分毫无意义，但是从信息增益准则来讲，这就是最好的划分结果。&lt;/p&gt;
&lt;p&gt;对于这种结果看似完美划分了随机变量的特征，然而根据&lt;strong&gt;大数定律&lt;/strong&gt;，只有当样本数足够多的时候，频率才可以准确的近似概率。也就是说，&lt;strong&gt;样本数越少，对概率的估计结果的方差就会越大，结果也就越不准&lt;/strong&gt;。想象一下做抛硬币实验来近似正面向上的概率，如果只抛两次，那么得到的正面向上的概率可能会非常离谱。而如果抛1万次，不论何时何地几乎总能得到近似0.5的概率。&lt;/p&gt;
&lt;p&gt;而C4.5就是为了解决&lt;strong&gt;信息增益准则对可取值数目较多的属性有所偏好&lt;/strong&gt;这种问题，由此提出了&lt;strong&gt;信息增益比&lt;/strong&gt;，计算公式为：&lt;/p&gt;
&lt;p&gt;\[Ir=(X,Y)=\frac{I(X,Y)}{IV(Y)} \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(IV(Y)\)&lt;/span&gt;计算方式为：&lt;/p&gt;
&lt;p&gt;\[IV(Y)=\sum_yp_ylogp_y \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(p_y\)&lt;/span&gt;等于随机变量&lt;span class=&quot;math inline&quot;&gt;\(Y=y\)&lt;/span&gt;的概率。当信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X|Y)\)&lt;/span&gt;最小时，也就是分类各不相等的时候，&lt;span class=&quot;math inline&quot;&gt;\(IV(Y)\)&lt;/span&gt;也相对最小，这样就减轻了划分行为本身的影响。&lt;/p&gt;
&lt;h2 id=&quot;cart决策树&quot;&gt;cart决策树&lt;/h2&gt;
&lt;h3 id=&quot;基尼系数&quot;&gt;基尼系数&lt;/h3&gt;
&lt;p&gt;有一个盒子里面放着小球，如果小球的颜色都是绿色，那么代表绿色的概率是&lt;span class=&quot;math inline&quot;&gt;\(p_绿=1\)&lt;/span&gt;，我们可以称随机变量&lt;span class=&quot;math inline&quot;&gt;\(X=绿\)&lt;/span&gt;是纯正的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200627223715395-1254596934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果盒子里面的小球包含不同的颜色，不同颜色发生的概率为&lt;span class=&quot;math inline&quot;&gt;\(p_1,p_2,...\)&lt;/span&gt;，我们可以称随机变量&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;不纯正的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200627223706118-1091948704.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设某组样本存在多个随机变量&lt;span class=&quot;math inline&quot;&gt;\(X_1,X_2,...,X_n\)&lt;/span&gt;，他们各自发生的概率是&lt;span class=&quot;math inline&quot;&gt;\(\{p_1,p_2,...,p_n\}\)&lt;/span&gt;，那么这组样本的纯正程度可以使用基尼系数(Gini)衡量：&lt;/p&gt;
&lt;p&gt;\[Gini=1-p_1^2-p_2^2-...-p_n^2 \]&lt;/p&gt;
&lt;p&gt;假设一个盒子存在3种颜色的小球，他们的概率是：&lt;span class=&quot;math inline&quot;&gt;\(\{\frac{1}{3},\frac{1}{3},\frac{1}{3}\}\)&lt;/span&gt;，那么基尼系数为：&lt;span class=&quot;math inline&quot;&gt;\(Gini=1-(\frac{1}{3})^2-(\frac{1}{3})^2-(\frac{1}{3})^2=0.6666\)&lt;/span&gt;。其他情况的基尼系数计算：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\{\frac{1}{10},\frac{2}{10},\frac{7}{10}\}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\{1,0,0\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;计算的基尼系数为：&lt;/p&gt;
&lt;p&gt;\[Gini=1-(\frac{1}{10})^2-(\frac{2}{10})^2-(\frac{7}{10})^2=0.46 \]&lt;/p&gt;
&lt;p&gt;\[Gini=1-(1)^2-(0)^2-(0)^2=0 \]&lt;/p&gt;
&lt;p&gt;基尼系数越大，代表样本越不纯净;基尼系数越小，代表样本越纯净，最终会找出&lt;span class=&quot;math inline&quot;&gt;\(Gini\)&lt;/span&gt;指数最小的来作为最优的划分点&lt;/p&gt;
&lt;h3 id=&quot;剪枝&quot;&gt;剪枝&lt;/h3&gt;
&lt;p&gt;决策树算法为了避免过拟合和简化决策树模型，提出了剪枝的方法，剪枝分为预剪枝和后剪枝，剪枝的原理如下：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;预剪枝：在构造决策树的同时进行剪枝，也就是在节点划分前进行判断。所有决策树的构建方法，都是在无法进一步降低熵的情况下才会停止创建分支的过程，为了避免过拟合，可以设定一个阈值，熵减小的数量小于这个阈值，即使还可以继续降低熵，也停止继续创建分支。但是这种方法实际中的效果并不好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;后剪枝：在决策树生长完全构造好了过后，对树进行剪枝。剪枝的过程是对拥有同样父节点的一组节点进行检查，判断如果将其合并，熵的增加量是否小于某一阈值。如果确实小，则这一组节点可以合并一个节点。后剪枝是目前最普遍的做法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200802162704207-2012329332.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常见的剪枝有REP(Reduced Error Pruning)、PEP(Pessimistic Error Pruning)、CCP(Cost Complexity Pruning)和MEP(Minimum Error Pruning)算法，以下分别进行说明。&lt;/p&gt;
&lt;h4 id=&quot;reduced-error-pruningrep错误率降低剪枝）&quot;&gt;Reduced-Error Pruning(REP,错误率降低剪枝）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;REP&lt;/code&gt;是最简单粗暴的一种后剪枝方法，其目的减少误差样本数量。该算法是从下往上依次遍历所有的子树，直至没有任何子树可以替换使得在验证集上的表现得以改进时，算法就可以终止。&lt;/p&gt;
&lt;p&gt;假设树&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;存在很多结点&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(t \in T\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(e(t)\)&lt;/span&gt;表示节点&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;下训练样本误判的数量，则有训练样本误判总数量&lt;span class=&quot;math inline&quot;&gt;\(f(T)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[f(T)=-\sum_{t \in T}e(t) \]&lt;/p&gt;
&lt;p&gt;假设树&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;去掉某个节点&lt;span class=&quot;math inline&quot;&gt;\(t'\)&lt;/span&gt;变成树&lt;span class=&quot;math inline&quot;&gt;\(T'\)&lt;/span&gt;,则有训练样本误判总数量&lt;span class=&quot;math inline&quot;&gt;\(f(T')\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[f(T')=-\sum_{t \in T'}e(t) \]&lt;/p&gt;
&lt;p&gt;如果误判的数量降低，即剪枝之后使得误差降低:&lt;/p&gt;
&lt;p&gt;\[f(T) \leqslant f(T') \]&lt;/p&gt;
&lt;p&gt;那么代表剪枝后能使误差降低，剪枝成功。反复进行上面的操作，从底向上的处理结点，删除那些有害的结点，直到进一步修剪不能减低误差为止。例如：存在如下一棵树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200816144540811-1071982684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 1： 将节点4删掉替换成8和9，测试在验证集上的表现，若表现更好，则将节点4删掉并替换成8和9的并集，若表现不好则保留原树的形状&lt;br/&gt;Step 2： 将节点2删掉替换成8、9和5，测试在验证集上的表现&lt;br/&gt;Step 3： 将节点3删掉替换成6和7，测试在验证集上的表现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200816144830787-1498763199.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REP&lt;/code&gt;是最简单的后剪枝方法之一，不过由于使用独立的验证集，如果数据量较少(数据要分为训练集、验证集、测试集三份)，那么在使用验证集进行剪枝的时候，可能会在验证集出现的稀有实例，却在测试集中没有出现，那么就会存在过度剪枝的情况。&lt;strong&gt;如果数据集较小，通常不考虑采用REP算法&lt;/strong&gt;。尽管REP有这个缺点，但还是能够解决一定程度的过拟合问题。&lt;/p&gt;
&lt;h4 id=&quot;pesimistic-error-pruningpep悲观错误剪枝）&quot;&gt;Pesimistic-Error Pruning(PEP,悲观错误剪枝）&lt;/h4&gt;
&lt;p&gt;上文的&lt;code&gt;REP&lt;/code&gt;方法思想简单且易于使用，不过最大的问题在于它需要一个新的验证集来修正我们的决策树在，&lt;code&gt;PEP&lt;/code&gt;方法中不需要新的验证集，并且&lt;code&gt;PEP&lt;/code&gt;是自上而下剪枝的。&lt;code&gt;PEP&lt;/code&gt;的剪枝是把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200816162902887-182458164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来子树1可以分成(4,5,6,7)多个类，但是剪枝变成只能分成一个类(1)。同样的样本子集，如果用子树分类可以分成多个类，准确率肯定要高一些，而用单颗叶子节点来分的话只能分成一个类，准确肯定要低一些，所以&lt;span class=&quot;math inline&quot;&gt;\(PEP\)&lt;/span&gt;的误判率肯定是上升的。训练数据也带来错分误差偏向于训练集，为了解决这一问题，给每个子叶节点加入修正项&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt;。具有&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;个节点的树的错误率为：&lt;/p&gt;
&lt;p&gt;\[E(T) = \sum_{t \in T}\frac{e(t)+1/2}{N(t)} \]&lt;/p&gt;
&lt;p&gt;去掉节点&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;个子叶节点之后T′个节点的树的错误率为：&lt;/p&gt;
&lt;p&gt;\[E(T')=\sum_{t \in T, excep K}\frac{e(t)+1/2K}{N(t)} \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(e(t)\)&lt;/span&gt;表示节点&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;下训练样本误判的数量，&lt;span class=&quot;math inline&quot;&gt;\(N(t)\)&lt;/span&gt;表示节点&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;下训练样本的总数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PEP&lt;/code&gt;悲观错误剪枝剪枝法定义，&lt;strong&gt;如果 E(剪枝后误判数均值)−E(剪枝前误判数均值)&amp;lt;std(剪枝前误判数标准差)，则可以剪枝&lt;/strong&gt;，假设在子树中每一个样本的误判服从一个二项分布&lt;span class=&quot;math inline&quot;&gt;\(B(N,p)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;表示子树所包含的所有样本个数。&lt;/p&gt;
&lt;p&gt;所以，在剪枝前，其期望的误判数为：&lt;/p&gt;
&lt;p&gt;\[e(t)=N(t)∗E(t) \]&lt;/p&gt;
&lt;p&gt;其误判的标准差为：&lt;/p&gt;
&lt;p&gt;\[std(t)=\sqrt{N(t)∗E(T)*(1-E(T))} \]&lt;/p&gt;
&lt;p&gt;当剪枝后的误判数小于剪枝前的误判数一个标准差之后，就决定剪枝：&lt;/p&gt;
&lt;p&gt;\[e(t')-e(t)&amp;lt;std(t)=\sqrt{N(t)\times E(T)\times (1-E(T))} \]&lt;/p&gt;
&lt;p&gt;例如：存在如下一棵树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200816191052415-971487421.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于节点T4而言，剪枝前后的计算过程如下：&lt;/p&gt;
&lt;p&gt;已知&lt;span class=&quot;math inline&quot;&gt;\(E(T7)=0 ；E(T8)=2；E(T9)=1；E(T10)=1；E(T4)=7；N(t)=20\)&lt;/span&gt;，所以，剪枝前的误判概率为：&lt;/p&gt;
&lt;p&gt;\[E(T)=\frac{(0+2+1+1)+4∗0.5}{20}=0.3 \]&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;\[e(t)=20*0.3=6 \]&lt;/p&gt;
&lt;p&gt;\[std(t)=\sqrt{20*0.3*(1-0.3)}=2.05 \]&lt;/p&gt;
&lt;p&gt;在我们对T4进行剪枝后，即将T4直接作为叶节点，剪枝后的误判概率:&lt;/p&gt;
&lt;p&gt;\[E(T')=\frac{7+0.5}{20}=0.375 \]&lt;/p&gt;
&lt;p&gt;剪枝后的误判期望数为：&lt;/p&gt;
&lt;p&gt;\[e(t')=20*0.375=7.5 \]&lt;/p&gt;
&lt;p&gt;\[7.5-2.05&amp;lt;6 \]&lt;/p&gt;
&lt;p&gt;因此满足条件，所以我们将把T4节点剪枝&lt;/p&gt;
&lt;h4 id=&quot;cost-complexity-pruning（ccp，代价复杂度剪枝&quot;&gt;Cost-Complexity Pruning（CCP，代价复杂度剪枝)&lt;/h4&gt;
&lt;p&gt;该算法为子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;定义了代价（cost）和复杂度（complexity），以及一个可由用户设置的衡量代价与复杂度之间关系的参数&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，其中，代价指在剪枝过程中因子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;被叶节点替代而增加的错分样本，复杂度表示剪枝后子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;减少的叶结点数，&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;则表示剪枝后树的复杂度降低程度与代价间的关系，定义为:&lt;/p&gt;
&lt;p&gt;\[α= \frac{R(t)−R(T_t)}{∣N∣−1}​ \]&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|N|\)&lt;/span&gt;：子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;中的叶节点数;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(R(t)\)&lt;/span&gt;：结点&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;的错误代价，计算公式为&lt;span class=&quot;math inline&quot;&gt;\(R(t)=r(t)*p(t)\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(r(t)\)&lt;/span&gt;为结点t的错分样本率，&lt;span class=&quot;math inline&quot;&gt;\(p(t)\)&lt;/span&gt;为落入结点t的样本占所有样本的比例;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(R(T_t)\)&lt;/span&gt;：子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;错误代价，计算公式为&lt;span class=&quot;math inline&quot;&gt;\(R(T_t)=\sum R(i)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;为子树&lt;span class=&quot;math inline&quot;&gt;\(T_t\)&lt;/span&gt;的叶节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CCP算法可以分为两个步骤，&lt;br/&gt;Step 1： 按照上述公式从下到上计算每一个非叶节点的αα值，然后每一次都剪掉具有最小αα值的子树。从而得到一个集合&lt;span class=&quot;math inline&quot;&gt;\(\{T_0,T_1,T_2,...,T_M\}\)&lt;/span&gt;，其中，&lt;span class=&quot;math inline&quot;&gt;\(T_0\)&lt;/span&gt;表示完整的决策树，&lt;span class=&quot;math inline&quot;&gt;\(T_M\)&lt;/span&gt;表示根节点&lt;br/&gt;Step 2： 根据真实的错误率在集合&lt;span class=&quot;math inline&quot;&gt;\(\{T_0,T_1,T_2,...,T_M\}\)&lt;/span&gt;选出一个最好的决策树&lt;/p&gt;
&lt;p&gt;假设在下图中有数据100条，从下往上开始计算:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202008/996148-20200818163724784-1787102872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先以节点T4为例，那么可以得到:&lt;/p&gt;
&lt;p&gt;\[R(t)=r(t)*p(t)=\frac{7}{9+7}*\frac{9+7}{100}=\frac{7}{100} \]&lt;/p&gt;
&lt;p&gt;\[R(T_t)=\sum R(i)=R(7)+R(8)+R(6)=\frac{2}{3+2}*\frac{3+2}{100}+\frac{0}{0+2}*\frac{0+2}{100}+\frac{3}{6+3}*\frac{6+3}{100}=\frac{5}{100} \]&lt;/p&gt;
&lt;p&gt;\[α= \frac{R(t)−R(T_t)}{∣N∣−1}​=\frac{\frac{7}{100}-\frac{5}{100}}{3-1}=\frac{1}{100} \]&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;REP&lt;/th&gt;
&lt;th&gt;PEP&lt;/th&gt;
&lt;th&gt;CCP&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;剪枝方式&lt;/td&gt;
&lt;td&gt;自底向上&lt;/td&gt;
&lt;td&gt;自顶向下&lt;/td&gt;
&lt;td&gt;自底向上&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;计算复杂度&lt;/td&gt;
&lt;td&gt;0(n)&lt;/td&gt;
&lt;td&gt;0(n)&lt;/td&gt;
&lt;td&gt;o(n2)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;误差估计&lt;/td&gt;
&lt;td&gt;验证集上误差估计&lt;/td&gt;
&lt;td&gt;使用连续纠正&lt;/td&gt;
&lt;td&gt;标准误差&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对一般三种决策树进行总结，区分如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;支持模型&lt;/th&gt;
&lt;th&gt;特征选择&lt;/th&gt;
&lt;th&gt;连续值处理&lt;/th&gt;
&lt;th&gt;确实值处理&lt;/th&gt;
&lt;th&gt;剪枝&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ID3&lt;/td&gt;
&lt;td&gt;分类&lt;/td&gt;
&lt;td&gt;信息增益&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C4.5&lt;/td&gt;
&lt;td&gt;分类&lt;/td&gt;
&lt;td&gt;信息增益比&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CART&lt;/td&gt;
&lt;td&gt;分类、回归&lt;/td&gt;
&lt;td&gt;基尼系数&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
&lt;p&gt;假设观测到历史有如下一组信息：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;天气&lt;/th&gt;
&lt;th&gt;气温&lt;/th&gt;
&lt;th&gt;湿度&lt;/th&gt;
&lt;th&gt;风力&lt;/th&gt;
&lt;th&gt;外出&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;晴朗&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多云&lt;/td&gt;
&lt;td&gt;高温&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算逻辑&quot;&gt;计算逻辑&lt;/h3&gt;
&lt;p&gt;可以看到这个树的根节点是&lt;code&gt;外出&lt;/code&gt;，而根节点往下的一个节点，该怎么定义用哪一个条件呢？决策树构建树节点的条件在于：&lt;strong&gt;该节点能最大程度的提供有用的信息，使得不确定性(信息熵)减少得最快&lt;/strong&gt;。也就是说，天气、气温、湿度、风力这四个条件，哪一个条件为结果&lt;code&gt;外出&lt;/code&gt;提供更多的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202005/996148-20200510204054556-1708649387.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要计算哪一个条件能提供更多的信息，只要计算根节点和另一节点的信息熵差值，就是提供的信息增益了。由上面的表格可以知道，外出的概率为&lt;span class=&quot;math inline&quot;&gt;\(\frac{9}{14}\)&lt;/span&gt;，不外出的概率是&lt;span class=&quot;math inline&quot;&gt;\(\frac{5}{14}\)&lt;/span&gt;，很显然这是一个不均匀分布，要使用一般分布的信息熵计算：&lt;/p&gt;
&lt;p&gt;\[\sum p_ilog_2\frac{1}{p_i} \]&lt;/p&gt;
&lt;p&gt;则根节点外出的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出)&amp;amp;=\frac{9}{14}log_2\frac{1}{\frac{9}{14}}+\frac{5}{14}log_2\frac{1}{\frac{5}{14}} \\ &amp;amp;=0.940 \end{split} \]&lt;/p&gt;
&lt;p&gt;接着分别计算各个条件的信息熵，先计算天气各个情况的信息熵：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;天气为晴朗时，2/5的概率外出，3/5的概率不外出，晴朗的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=晴朗)\)&lt;/span&gt;为:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\begin{split} H(X=外出|Y=晴朗)&amp;amp;=\frac{2}{5}log_2\frac{1}{\frac{2}{5}}+\frac{3}{5}log_2\frac{1}{\frac{3}{5}} \\ &amp;amp;=0.971 \end{split} \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;天气为多云时，0的概率外出，0的概率不外出，信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=多云)\)&lt;/span&gt;为:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\begin{split} H(X=外出|Y=多云)&amp;amp;=0+0 \\ &amp;amp;=0 \end{split} \]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;天气为下雨时，3/5的概率外出，2/5的概率不外出，信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=下雨)\)&lt;/span&gt;为:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\begin{split} H(X=外出|Y=下雨)&amp;amp;=\frac{3}{5}log_2\frac{1}{\frac{3}{5}}+\frac{2}{5}log_2\frac{1}{\frac{2}{5}} \\ &amp;amp;=0.971 \end{split} \]&lt;/p&gt;
&lt;p&gt;而天气是 &lt;code&gt;晴朗&lt;/code&gt; 的概率为5/14，天气是 &lt;code&gt;多云&lt;/code&gt; 的概率为4/14，天气是 &lt;code&gt;下雨&lt;/code&gt; 的概率为5/14，所以 &lt;code&gt;天气&lt;/code&gt; 的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=天气)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出|Y=天气)&amp;amp;=\frac{5}{14} \times H(X=外出|Y=晴朗)+0 \times H(X=外出|Y=多云)+\frac{4}{14} \times H(X=外出|Y=下雨) \\ &amp;amp;=\frac{5}{14} \times 0.971+0 \times 0+\frac{4}{14} \times 0.971 \\ &amp;amp;=0.693 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;天气&lt;/code&gt;的信息增益&lt;span class=&quot;math inline&quot;&gt;\(I(X=外出,Y=天气)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} I(X=外出,Y=天气)&amp;amp;=H(X=外出)-H(X=外出|Y=天气) \\ &amp;amp;=0.940-0.693 \\ &amp;amp;=0.247 \end{split} \]&lt;/p&gt;
&lt;p&gt;同理计算得到，&lt;code&gt;气温&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=气温)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出|Y=气温)&amp;amp;=\frac{4}{14}H(X=外出|Y=高温)+\frac{6}{14}H(X=外出|Y=温暖)+\frac{4}{14}H(X=外出|Y=寒冷) \\ &amp;amp;=\frac{4}{14}(\frac{2}{4}log_2\frac{1}{\frac{2}{4}}+\frac{2}{4}log_2\frac{1}{\frac{2}{4}})+\frac{6}{14}(\frac{4}{6}log_2\frac{1}{\frac{4}{6}}+\frac{2}{6}log_2\frac{1}{\frac{2}{6}})+\frac{4}{14}(\frac{3}{4}log_2\frac{1}{\frac{3}{4}}+\frac{1}{4}log_2\frac{1}{\frac{1}{4}}) \\ &amp;amp;=\frac{4}{14}\times 1.0+\frac{6}{14}\times 0.918296+\frac{4}{14}\times 0.811278 \\ &amp;amp;=0.911 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;气温&lt;/code&gt;的信息增益&lt;span class=&quot;math inline&quot;&gt;\(I(X=外出,Y=气温)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} I(X=外出,Y=气温)&amp;amp;=H(X=外出)-H(X=外出|Y=气温) \\ &amp;amp;=0.940-0.911 \\ &amp;amp;=0.029 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;湿度&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=湿度)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出|Y=湿度)&amp;amp;=\frac{7}{14}H(X=外出|Y=高)+\frac{7}{14}H(X=外出|Y=正常) \\ &amp;amp;=\frac{7}{14}\times (\frac{6}{7}log_2\frac{1}{\frac{6}{7}}+\frac{1}{7}log_2\frac{1}{\frac{1}{7}})+\frac{7}{14}\times (\frac{3}{7}log_2\frac{1}{\frac{3}{7}}+\frac{4}{7}log_2\frac{1}{\frac{4}{7}}) \\ &amp;amp;=\frac{7}{14}\times 0.591673+\frac{7}{14}\times 1.159856 \\ &amp;amp;=0.788 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;湿度&lt;/code&gt;的信息增益&lt;span class=&quot;math inline&quot;&gt;\(I(X=外出,Y=湿度)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} I(X=外出,Y=湿度)&amp;amp;=H(X=外出)-H(X=外出|Y=湿度) \\ &amp;amp;=0.940-0.788 \\ &amp;amp;=0.152 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;风力&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出|Y=风力)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X=外出|Y=风力)&amp;amp;=\frac{6}{14}E_{有风}+\frac{8}{14}E_{无风} \\ &amp;amp;=\frac{6}{14}\times (\frac{3}{6}log_2\frac{1}{\frac{3}{6}}+\frac{3}{6}log_2\frac{1}{\frac{3}{6}})+\frac{8}{14}\times (\frac{6}{8}log_2\frac{1}{\frac{6}{8}}+\frac{2}{8}log_2\frac{1}{\frac{2}{8}}) \\ &amp;amp;=\frac{6}{14}\times 1.0+\frac{8}{14}\times 0.811278 \\ &amp;amp;=0.892 \end{split} \]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;风力&lt;/code&gt;的信息增益&lt;span class=&quot;math inline&quot;&gt;\(I(X=外出,Y=风力)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} I(X=外出,Y=风力)&amp;amp;=H(X=外出)-H(X=外出|Y=风力) \\ &amp;amp;=0.940-0.892 \\ &amp;amp;=0.048 \end{split} \]&lt;/p&gt;
&lt;p&gt;可以看到，信息增益：&lt;span class=&quot;math inline&quot;&gt;\(I(X=外出,Y=天气)&amp;gt;I(X=外出,Y=湿度)&amp;gt;I(X=外出,Y=风力)&amp;gt;I(X=外出,Y=气温)\)&lt;/span&gt;，所以对是否外出提供信息最多的条件是&lt;code&gt;天气&lt;/code&gt;。也就是说&lt;strong&gt;在决定是否外出的时候，天气是最重要的一个影响因素，天气的好坏很大程度决定了当天是否会外出，减少是否外出的不确定性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是天气分为多云、下雨、晴朗，由数据集可以知道多云的时候，无论气温、湿度和风力如何，都会外出；而下雨和晴朗的时候，会根据气温、湿度和风力的情况再来决定是否外出，因此决策树的构造变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202005/996148-20200516113123780-1705303611.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而下雨和晴朗的时候，会根据气温、湿度和风力的情况再来决定是否外出，这时就需要计算：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下雨时，选择信息增益最大的属性(气温、湿度或风力)来作为下一个节点&lt;br/&gt;晴朗时，选择信息增益最大的属性(气温、湿度或风力)来作为下一个节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;天气=下雨&lt;/code&gt;的情况下：&lt;/p&gt;
&lt;p&gt;由前面知道&lt;span class=&quot;math inline&quot;&gt;\(H(X=外出,Y=下雨)=0.971\)&lt;/span&gt;，在下雨时气温、湿度和风力外出情况如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;天气&lt;/th&gt;
&lt;th&gt;气温&lt;/th&gt;
&lt;th&gt;湿度&lt;/th&gt;
&lt;th&gt;风力&lt;/th&gt;
&lt;th&gt;外出&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;寒冷&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;无风&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;下雨&lt;/td&gt;
&lt;td&gt;温暖&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;有风&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;则&lt;code&gt;气温&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X_1=外出,X_2=下雨|Y=气温)\)&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;\[\begin{split} H(X_1=外出,X_2=下雨|Y=气温)&amp;amp;=H(X_1=外出,X_2=下雨|Y=温暖)+H(X_1=外出,X_2=下雨|Y=寒冷) \\ &amp;amp;=\frac{3}{5}\times (\frac{2}{3}log_2\frac{1}{\frac{2}{3}}+\frac{1}{3}log_2\frac{1}{\frac{1}{3}})+\frac{2}{5}\times (\frac{1}{2}log_2\frac{1}{\frac{1}{2}}+\frac{1}{2}log_2\frac{1}{\frac{1}{2}}) \\ &amp;amp;=0.951 \end{split} \]&lt;/p&gt;
&lt;p&gt;同理可得 &lt;code&gt;湿度&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X_1=外出,X_2=下雨|Y=湿度)=0.951\)&lt;/span&gt;，&lt;code&gt;风力&lt;/code&gt;的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X_1=外出,X_2=下雨|Y=风力)=0\)&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;天气=晴朗&lt;/code&gt;的情况下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(H(X_1=外出,X_2=晴朗|Y=湿度)\)&lt;/span&gt;最大，那么新得到的树形如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200614112453124-1727064273.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而上面却发现没有&lt;code&gt;气温&lt;/code&gt;选项？因为在其他三个的条件下就能决定是否外出了，气温对于外出没有直接影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算代码&quot;&gt;计算代码&lt;/h3&gt;
&lt;p&gt;将文本转化为数字：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;data[data == u'晴朗'] = 2
data[data == u'多云'] = 1
data[data == u'下雨'] = 0
data[data == u'高温'] = 2
data[data == u'温暖'] = 1
data[data == u'寒冷'] = 0
data[data == u'高'] = 1
data[data == u'正常'] = 0
data[data == u'有风'] = 1
data[data == u'无风'] = 0
data[data == u'是'] = 1
data[data == u'否'] = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于信息熵来计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 建立决策树模型，基于信息熵
dtc = DTC(criterion='entropy')
dtc.fit(x_train, y_train)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预测：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(dtc.predict(x_test))
print(dtc.score(x_test, y_test))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里样本比较小，所以得到的准确率分数为&lt;code&gt;1.0&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/996148/202006/996148-20200625162920065-553824155.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据和代码下载请关注公众号【 &lt;strong&gt;机器学习和大数据挖掘&lt;/strong&gt; 】，后台回复【 &lt;strong&gt;机器学习&lt;/strong&gt; 】即可获取&lt;/p&gt;
</description>
<pubDate>Sat, 22 Aug 2020 00:23:00 +0000</pubDate>
<dc:creator>TTyb</dc:creator>
<og:description>【机器学习】算法原理详细推导与实现(七):决策树算法 在之前的文章中，对于介绍的分类算法有逻辑回归算法和朴素贝叶斯算法，这类算法都是二分类的分类器，但是往往只实际问题中$y$不仅仅只有${0,1}$，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TTyb/p/12686248.html</dc:identifier>
</item>
<item>
<title>精讲响应式WebClient第3篇-POST、DELETE、PUT方法使用 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13544187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13544187.html</guid>
<description>&lt;p&gt;本文是精讲响应式WebClient第3篇，前篇的blog访问地址如下：&lt;/p&gt;
&lt;h2 id=&quot;一、restful风格与http-method&quot;&gt;一、RESTful风格与HTTP method&lt;/h2&gt;
&lt;p&gt;熟悉RESTful风格的朋友，应该了解RESTful风格API使用HTTP method表达对资源的操作。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用HTTP方法&lt;/th&gt;
&lt;th&gt;RESTful风格语义（操作）&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;查询、获取数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;新增、提交数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;删除数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;更新、修改数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在上一篇文章中我们已经为大家介绍了如何使用WebClient作为Http客户端发送GET请求与进行响应结果的接收。本节来为大家介绍POST、DELETE、PUT。&lt;/p&gt;
&lt;p&gt;POST等其他的方法在与GET方法在使用如下方法的时候是一致的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;block()阻塞获取响应结果的方法，subscribe()非阻塞异步结果订阅方法&lt;/li&gt;
&lt;li&gt;retrieve(）获取HTTP响应体，exchange()除了获取HTTP响应体，还可以获取HTTP 状态码、headers、cookies等HTTP报文信息。&lt;/li&gt;
&lt;li&gt;使用Mono接收单个对象的响应结果，使用Flux接收集合类对象的响应结果。&lt;/li&gt;
&lt;li&gt;占位符语法传参方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以想了解以上信息，请去参考： &lt;a href=&quot;http://www.zimug.com/java/spring/%e7%b2%be%e8%ae%b2%e5%93%8d%e5%ba%94%e5%bc%8fwebclient%e7%ac%ac2%e7%af%87-get%e8%af%b7%e6%b1%82%e9%98%bb%e5%a1%9e%e4%b8%8e%e9%9d%9e%e9%98%bb%e5%a1%9e%e8%b0%83%e7%94%a8%e6%96%b9%e6%b3%95%e8%af%a6/.html&quot;&gt;精讲响应式WebClient第2篇-GET请求阻塞与非阻塞调用方法详解&lt;/a&gt;。 本文只介绍POST、DELETE、PUT在使用过程中与GET不一样的地方。&lt;/p&gt;
&lt;blockquote readability=&quot;7.6214511041009&quot;&gt;
&lt;p&gt;为了方便后续开发测试，首先介绍一个网站给大家。&lt;a href=&quot;http://jsonplaceholder.typicode.com/&quot;&gt;JSONPlaceholder&lt;/a&gt;是一个提供免费的在线REST API的网站，我们在开发时可以使用它提供的url地址测试下网络请求以及请求参数。或者当我们程序需要获取一些模拟数据、模拟图片时也可以使用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、post请求发送json字符串、对象、表单数据&quot;&gt;二、Post请求发送JSON字符串、对象、表单数据&lt;/h2&gt;
&lt;h3 id=&quot;21使用post方法向服务端发送json字符串数据&quot;&gt;2.1.使用Post方法向服务端发送JSON字符串数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class OtherTest {

  //创建webClient
  private WebClient webClient = WebClient.builder()
          .baseUrl(&quot;http://jsonplaceholder.typicode.com&quot;)
          .build();


  @Test
  public void testPostJsonStr() {
    // 提交给服务端的JSON字符串
    String jsonStr = &quot;{\&quot;userId\&quot;: 1,\&quot;title\&quot;: \&quot;zimugtest\&quot;,\&quot;body\&quot;: \&quot;字母哥进行测试\&quot;}&quot;;

    // 发送请求
    Mono&amp;lt;String&amp;gt; mono = webClient
            .post() // POST 请求
            .uri(&quot;/posts&quot;)  // 请求路径
            .contentType(MediaType.APPLICATION_JSON)  //JSON数据类型
            .body(BodyInserters.fromValue(jsonStr))  //JSON字符串数据
            .retrieve() // 获取响应体
            .bodyToMono(String.class); //响应数据类型转换

    // 输出结果
    System.out.println(mono.block());
  }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应结果打印如下，&quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com/posts/1&quot;&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/a&gt;&quot; 服务的请求数据就是响应数据。响应结果同样是一个JSON字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200822060842130-1177698775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22将对象以json数据形式发送服务端&quot;&gt;2.2.将对象以JSON数据形式发送服务端&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  @Test
  public void testPostJson() {
    //构建请求发送对象
    PostDTO postDTO = new PostDTO();
    postDTO.setUserId(110);
    postDTO.setTitle(&quot;zimug-test&quot;);
    postDTO.setBody(&quot;字母哥进行Post测试&quot;);

    //发送请求
    Mono&amp;lt;PostDTO&amp;gt; mono = webClient
            .post() // 发送POST 请求
            .uri(&quot;/posts&quot;)  //服务请求路径，基于baseurl
            .contentType(MediaType.APPLICATION_JSON)  //以JSON数据格式
            .bodyValue(postDTO)   //发送请求体，对象形式
            .retrieve() // 获取响应体
            .bodyToMono(PostDTO.class); //响应数据类型转换

    // 输出结果
    System.out.println(&quot;=====&quot; + mono.block());
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;响应结果打印如下，使用PostDTO接收响应结果。因为 &quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com/posts/1&quot;&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/a&gt;&quot; 服务的请求数据就是响应数据。打印结果是PostDTO对象的toString()方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200822060842511-1285929638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;23post模拟表单数据提交&quot;&gt;2.3.POST模拟表单数据提交&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;  @Test
  public void testFormSubmit()  {
    //表单数据参数设置
    MultiValueMap&amp;lt;String, String&amp;gt; map = new LinkedMultiValueMap&amp;lt;&amp;gt;();
    map.add(&quot;title&quot;, &quot;zimug-test&quot;);
    map.add(&quot;body&quot;, &quot;字母哥进行测试&quot;);

    // 发送请求
    Mono&amp;lt;String&amp;gt; mono = webClient
            .post() // 发送POST 请求
            .uri(&quot;/posts&quot;)  // 请求路径
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)  //表单数据类型
            .body(BodyInserters.fromFormData(map))  //表单数据
            .retrieve() // 获取响应体
            .bodyToMono(String.class); //响应数据类型转换

    // 输出结果
    System.out.println(mono.block());
  }
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用字符串的方式接受响应结果，所以输出和《2.1.使用Post方法向服务端发送JSON字符串数据》输出结果是一样的。&lt;/p&gt;
&lt;h2 id=&quot;三、使用-delete方法去删除资源&quot;&gt;三、使用 DELETE方法去删除资源&lt;/h2&gt;
&lt;p&gt;删除一个已经存在的资源，使用webClient的delete()方法。该方法会向URL代表的资源发送一个HTTP DELETE方法请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testDelete()  {
  // 发送Delete请求
  webClient.delete().uri(&quot;/posts/1&quot;);  // 请求路径
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面章节测试类的基础上，写如上代码的测试用例。上面代码含义为删除posts列表里面的第1个帖子。&lt;/p&gt;
&lt;h2 id=&quot;四、使用put方法去修改资源&quot;&gt;四、使用PUT方法去修改资源&lt;/h2&gt;
&lt;p&gt;修改一个已经存在的资源，使用webClient的put()方法。该方法会向URL代表的资源发送一个HTTP PUT方法请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testPut()  {
  //要修改的数据对象
  PostDTO postDTO = new PostDTO();
  postDTO.setId(1);
  postDTO.setBody(&quot;字母哥进行Put测试&quot;);

  Mono&amp;lt;PostDTO&amp;gt; mono = webClient
          .put()
          .uri(&quot;/posts/1&quot;)  //服务请求路径，基于baseurl
          .contentType(MediaType.APPLICATION_JSON)
          .bodyValue(postDTO)   //发送请求体
          .retrieve() // 获取响应体
          .bodyToMono(PostDTO.class); //响应数据类型转换

  // 输出结果
  System.out.println(&quot;=====&quot; + mono.block());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码RESTful风格语义是：修改posts列表里面的第1个帖子。输出结果如下，是修改数据之后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200822060842719-751037755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 22:09:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文是精讲响应式WebClient第3篇，前篇的blog访问地址如下： 精讲响应式webclient第1篇-响应式非阻塞IO与基础用法 精讲响应式WebClient第2篇-GET请求阻塞与非阻塞调用方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13544187.html</dc:identifier>
</item>
<item>
<title>CSS图形基础：纯CSS绘制图形 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13544171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13544171.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;      为了在页面中利用CSS3绘制图形，在页面中定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div  class=&quot;container&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;       &amp;lt;div class=&quot;shape&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;    &lt;/p&gt;
&lt;p&gt;      其中，container作为显示图形的画布（容器），shape描述所绘制的图形。&lt;/p&gt;
&lt;p&gt;定义.container的样式规则如下：&lt;/p&gt;
&lt;p&gt;  .container&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    margin: 0 auto;&lt;/p&gt;
&lt;p&gt;    width: 300px;&lt;/p&gt;
&lt;p&gt;    height:300px;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    display:flex;&lt;/p&gt;
&lt;p&gt;    justify-content:center;&lt;/p&gt;
&lt;p&gt;    align-items:center;&lt;/p&gt;
&lt;p&gt;    background:#d8d8d8;&lt;/p&gt;
&lt;p&gt;    border: 4px solid rgba(255, 0, 0, 0.9);&lt;/p&gt;
&lt;p&gt;    border-radius: 10%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;对shape设置不同的样式规则，可以绘制不同的图形。&lt;/p&gt;
&lt;h3&gt;1．利用边框属性border绘制基本图形&lt;/h3&gt;
&lt;p&gt;      在CSS中，可以用width和height属性设置一个元素的宽度和高度，background属性设置元素的背景色。例如，设置.shape的样式规则如下：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:200px;&lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    background:#ff8c00;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      则可以在页面中绘制如图1所示的用深橙色填充的边长为200px的正方形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051015421-1498195046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1  用深橙色填充的正方形&lt;/p&gt;
&lt;p&gt;      图1中，外面的红色圆角方框由.container样式决定，里面的用深橙色填充的边长为200px的正方形由.shape样式决定。完整的HTML文件内容如下。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;CSS图形绘制&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;style&amp;gt;&lt;/p&gt;
&lt;p&gt;  .container&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    margin: 0 auto;&lt;/p&gt;
&lt;p&gt;    width: 300px;&lt;/p&gt;
&lt;p&gt;    height:300px;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    display:flex;&lt;/p&gt;
&lt;p&gt;    justify-content:center;&lt;/p&gt;
&lt;p&gt;    align-items:center;&lt;/p&gt;
&lt;p&gt;    background:#d8d8d8;&lt;/p&gt;
&lt;p&gt;    border: 4px solid rgba(255, 0, 0, 0.9);&lt;/p&gt;
&lt;p&gt;    border-radius: 10%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:200px;&lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    background:#ff8c00;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;&amp;lt;/style&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div  class=&quot;container&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;div class=&quot;shape&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;    &lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      下面各图形绘制时，除了特别说明，我们只给出图形所对应.shape样式的定义，其余部分保持不变。这样修改.shape样式，可以绘制不同的图形。&lt;/p&gt;
&lt;p&gt;      例如，要绘制一个边长为200px的正方形（只有外框线，没有内部填充），可以修改.shape如下：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:200px;&lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    border:4px solid #ff8c00;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      此时页面显示如图2所示，&lt;span&gt;“画布”&lt;/span&gt;中显示的图形为一个边长为200px的正方形。其中，用到了border属性进行边框样式的设置。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051119112-2031291377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  正方形&lt;/p&gt;
&lt;p&gt;      border属性是一个缩写的边框属性，用于设置元素所有的边框属性。可以设置的属性分别（按顺序）为：border-width（边框宽度）、border-style（边框样式）和border-color（边框颜色）。&lt;/p&gt;
&lt;p&gt;       本文中会用到包括border在内的许多CSS属性，这些属性的格式和功能我们不一一介绍，只是拿过来应用。需要了解这些属性功能和使用方法的读者可以参看《CSS参考手册》（&lt;a href=&quot;https://www.w3cschool.cn/cssref/3ps212do.html&quot; target=&quot;_blank&quot;&gt;https://www.w3cschool.cn/cssref/3ps212do.html&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;       （1）三角形。&lt;/p&gt;
&lt;p&gt;修改.shape如下：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:50px;&lt;/p&gt;
&lt;p&gt;    width:50px;&lt;/p&gt;
&lt;p&gt;    border-top: 100px solid orange;&lt;/p&gt;
&lt;p&gt;    border-left: 100px solid blue;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid green;&lt;/p&gt;
&lt;p&gt;    border-bottom: 100px solid red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图3所示的图形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051202653-942863657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  四个梯形围成正方形&lt;/p&gt;
&lt;p&gt;      在图3中，橙色梯形块代表是上边框宽度，蓝色梯形块代表左边框宽度，红色梯形块代表下边框宽度，绿色梯形块代表右边框宽度，对几个边距的宽度而言，它们之间的分界恰好是这个正方形的对角线所在的直线，如果里面的小正方形宽高无穷小（将shape样式定义中width和height的属性值均设为0），那么这个图形将是一个由四块不同颜色三角形拼接而成的图形，如图4所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051219589-171643173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  四个三角形拼成正方形&lt;/p&gt;
&lt;p&gt;修改.shape如下：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:0px;&lt;/p&gt;
&lt;p&gt;    width:0px;&lt;/p&gt;
&lt;p&gt;    border-left: 100px solid blue;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid green;&lt;/p&gt;
&lt;p&gt;    border-bottom: 200px solid red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图5所示的图形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051243630-63606401.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5  三个三角形拼成一个正方形&lt;/p&gt;
&lt;p&gt;      修改上面样式中左、右或下边框的填充色为背景色或transparent，相当于切掉了该边框，这样可以组合为不同的三角形。&lt;/p&gt;
&lt;p&gt;例如，修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:0px;&lt;/p&gt;
&lt;p&gt;    width:0px;&lt;/p&gt;
&lt;p&gt;    border-left: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 200px solid red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图6所示的等腰三角形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051309627-1098651184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图6  等腰三角形&lt;/p&gt;
&lt;p&gt;又如，修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt; .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:0px;&lt;/p&gt;
&lt;p&gt;    width:0px;&lt;/p&gt;
&lt;p&gt;    border-left: 100px solid blue;&lt;/p&gt;
&lt;p&gt;    border-bottom: 200px solid transparent;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图7所示的直角三角形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051331765-169104270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图7  直角三角形&lt;/p&gt;
&lt;p&gt;再如，修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:0px;&lt;/p&gt;
&lt;p&gt;    width:0px;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid green;&lt;/p&gt;
&lt;p&gt;    border-bottom: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图8所示的等腰直角三角形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051348512-1326907636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图8  等腰直角三角形&lt;/p&gt;
&lt;p&gt;      （2）平行四边形和梯形。&lt;/p&gt;
&lt;p&gt;      将一个矩形框进行倾斜，可以得到平行四边形。修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height:100px;&lt;/p&gt;
&lt;p&gt;    width:200px;&lt;/p&gt;
&lt;p&gt;    background:#ff8c00;&lt;/p&gt;
&lt;p&gt;    transform: skew(20deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图9所示的平行四边形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051412315-623882885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图9  平行四边形&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt; .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 70px solid #ff8c00;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    top:-50px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: '';&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 70px;&lt;/p&gt;
&lt;p&gt;    left:-50px;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 70px solid #ff8c00;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图10所示的菱形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051443069-1850530584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图10  菱形 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    width:100px;&lt;/p&gt;
&lt;p&gt;    border-bottom: 150px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图11所示的梯形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051512892-296260576.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图11  梯形&lt;/p&gt;
&lt;p&gt;      （3）圆、圆环和椭圆。&lt;/p&gt;
&lt;p&gt;      利用border-radius属性可以为元素设置圆角边框，这样可以绘制各种圆形。&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    width:150px;&lt;/p&gt;
&lt;p&gt;    height:150px;&lt;/p&gt;
&lt;p&gt;    background:#8A2BE2;&lt;/p&gt;
&lt;p&gt;    border-radius:50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图12所示的圆形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051540516-1120967498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图12  圆&lt;/p&gt;
&lt;p&gt;      将上面绘制圆的样式中的&lt;span&gt;“&lt;/span&gt;height:150px;&lt;span&gt;”&lt;/span&gt;改成&lt;span&gt;“&lt;/span&gt;height:50px;&lt;span&gt;”&lt;/span&gt;，其余保持不变，则得到如图13所示的椭圆。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051616839-241165274.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图13  椭圆&lt;/p&gt;
&lt;p&gt;      将两个椭圆旋转后交叉在一起，可以构成一个红叉叉。修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    width: 160px;&lt;/p&gt;
&lt;p&gt;    height: 24px;&lt;/p&gt;
&lt;p&gt;    background-color: #f00;&lt;/p&gt;
&lt;p&gt;    transform: rotate(45deg);&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    width: 160px;&lt;/p&gt;
&lt;p&gt;    height: 24px;&lt;/p&gt;
&lt;p&gt;    background-color: #f00;&lt;/p&gt;
&lt;p&gt;    transform: rotate(90deg);&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图14所示的红叉叉。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051640995-2022189230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图14  红叉叉&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 100px;&lt;/p&gt;
&lt;p&gt;    height: 50px;&lt;/p&gt;
&lt;p&gt;    background: #8A2BE2;&lt;/p&gt;
&lt;p&gt;    border-radius: 100px 100px 0 0;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图15所示的半圆。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051658945-816324525.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图15  半圆 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 100px;&lt;/p&gt;
&lt;p&gt;    height: 100px;&lt;/p&gt;
&lt;p&gt;    background: #8A2BE2;&lt;/p&gt;
&lt;p&gt;    border-radius: 100px 0 0 0;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图16所示的四分之一圆（扇形）。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051718845-853730975.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图16  扇形&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 0px;&lt;/p&gt;
&lt;p&gt;    height: 0px;&lt;/p&gt;
&lt;p&gt;    border-right: 60px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 60px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 60px solid red;&lt;/p&gt;
&lt;p&gt;    border-bottom: 60px solid red;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图17所示的图形，这个图形是游戏中的&lt;span&gt;“食人豆”&lt;/span&gt;。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051752761-392211266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图17  &lt;span&gt;“食人豆”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     width: 126px;&lt;/p&gt;
&lt;p&gt;     height: 180px;&lt;/p&gt;
&lt;p&gt;     background-color:#FFEFD5;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%  50%  50%  50%  / 60%   60%   40%  40%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图18所示的鸡蛋。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051813048-168774197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图18  鸡蛋&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     width: 100px;&lt;/p&gt;
&lt;p&gt;     height: 100px;&lt;/p&gt;
&lt;p&gt;     border: 15px solid red;&lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图19所示的圆环。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051851735-1340776304.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图19  圆环&lt;/p&gt;
&lt;p&gt;      为一个圆环加上一个倾斜的手柄，可以绘制出一个放大镜。修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     width: 64px;&lt;/p&gt;
&lt;p&gt;     height: 64px;&lt;/p&gt;
&lt;p&gt;     border: 10px solid black;&lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;     position: absolute;&lt;/p&gt;
&lt;p&gt;     right: -40px;&lt;/p&gt;
&lt;p&gt;     bottom: -16px;&lt;/p&gt;
&lt;p&gt;     border-width: 0;&lt;/p&gt;
&lt;p&gt;     background: black;&lt;/p&gt;
&lt;p&gt;     width: 56px;&lt;/p&gt;
&lt;p&gt;     height: 10px;&lt;/p&gt;
&lt;p&gt;     transform: rotate(45deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      可在页面中看到如图20所示的放大镜。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051917564-574405392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图20  放大镜&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     width: 100px;&lt;/p&gt;
&lt;p&gt;     height: 100px;&lt;/p&gt;
&lt;p&gt;     border: 15px solid white;&lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%;&lt;/p&gt;
&lt;p&gt;     border-top: 15px solid red;&lt;/p&gt;
&lt;p&gt;     border-left: 15px solid orange;&lt;/p&gt;
&lt;p&gt;     border-bottom: 15px solid green;&lt;/p&gt;
&lt;p&gt;     border-right: 15px solid blue;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图21四色圆环。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051937129-605843883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图21  四色圆环&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 120px;&lt;/p&gt;
&lt;p&gt;    height: 120px;&lt;/p&gt;
&lt;p&gt;    border-left: 60px solid green;&lt;/p&gt;
&lt;p&gt;    border-right: 60px solid blue;&lt;/p&gt;
&lt;p&gt;    border-top: 60px solid red;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图22所示的不规则圆环。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822051955705-1751993649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图22  不规则圆环&lt;/p&gt;
&lt;p&gt;      若保留图22中的红色，将另外两种颜色设为transparent，可在页面中看到如图23所示的扇面。若只保留蓝色，则可在页面中看到如图24所示的牛角。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052021542-869953719.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图23 扇面&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052036051-1265695691.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图24  牛角&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 0px;&lt;/p&gt;
&lt;p&gt;    height: 0px;&lt;/p&gt;
&lt;p&gt;    border-left: 60px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 60px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 120px solid red;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图25所示的圆锥形。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052112946-647147069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图 25  圆锥形&lt;/p&gt;
&lt;p&gt;（4）多边形。&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    width: 54px;&lt;/p&gt;
&lt;p&gt;    border-top: 50px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 18px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 18px solid transparent;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    top: -85px;&lt;/p&gt;
&lt;p&gt;    left: -18px;&lt;/p&gt;
&lt;p&gt;    border-bottom: 35px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 45px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 45px solid transparent;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;       可在页面中看到如图26所示的五边形。这个五边形由两个基本图形拼合而成：一个是下面部分使用.shape定义的梯形，另一个是上面部分使用.shape:before定义的上三角形。三角形和梯形层叠到一起，从而形成五边形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052149512-1128939248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图26  五边形 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 138.5px;&lt;/p&gt;
&lt;p&gt;    height: 80px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: -40px;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border-left: 69.25px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 69.25px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 40px solid red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    bottom: -40px;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border-left: 69.25px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 69.25px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 40px solid red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;     可在页面中看到如图27所示的六边形。这个六边形由三个基本图形拼合而成：一个是中间部分使用.shape定义的矩形，另一个是上面部分使用.shape:before定义的上三角形，还有一个是下面部分使用.shape:after定义的下三角形。三个基本图形层叠到一起，从而形成六边形。并且图中的六边形还是一个正六边形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052221215-1223694282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图27  六边形 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 120px;&lt;/p&gt;
&lt;p&gt;    height: 50px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: -35px;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    border-bottom: 35px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 35px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 35px solid transparent;&lt;/p&gt;
&lt;p&gt;    width: 50px;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 50px;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    border-top: 35px solid red;&lt;/p&gt;
&lt;p&gt;    border-left: 35px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 35px solid transparent;&lt;/p&gt;
&lt;p&gt;    width: 50px;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;        可在页面中看到如图28所示的八边形。这个八边形由三个基本图形拼合而成：一个是中间部分使用.shape定义的矩形，另一个是上面部分使用.shape:before定义的底边大于顶边的梯形，还有一个是下面部分使用.shape:after定义的底边小于顶边的梯形。三个基本图形层叠到一起，从而形成八边形。并且图中的八边形还是一个近似正八边形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052252920-330812199.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图28  八边形&lt;/p&gt;
&lt;p&gt;（5）多角星。&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;.shape&lt;/p&gt;
&lt;p&gt; {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    display: block;&lt;/p&gt;
&lt;p&gt;    width:0px;&lt;/p&gt;
&lt;p&gt;    height:0px;&lt;/p&gt;
&lt;p&gt;    border-left:  100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom:70px  solid red;&lt;/p&gt;
&lt;p&gt;    transform:rotate(35deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  { &lt;/p&gt;
&lt;p&gt;    content: '';&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    width: 0px; &lt;/p&gt;
&lt;p&gt;    height: 0px;&lt;/p&gt;
&lt;p&gt;    top: -45px;&lt;/p&gt;
&lt;p&gt;    left: -62.5px;&lt;/p&gt;
&lt;p&gt;    border-left:   30px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right:  30px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 80px solid green;&lt;/p&gt;
&lt;p&gt;    transform: rotate(-35deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  { &lt;/p&gt;
&lt;p&gt;    content: '';&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    width: 0px;&lt;/p&gt;
&lt;p&gt;    height: 0px;&lt;/p&gt;
&lt;p&gt;    top: 3px;&lt;/p&gt;
&lt;p&gt;    left: -105px;&lt;/p&gt;
&lt;p&gt;    border-left: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 100px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 70px solid blue;&lt;/p&gt;
&lt;p&gt;    transform:rotate(-70deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      可在页面中显示如图29所示的五角星。这个五角星是由三个三角形拼成的，由于文字描述不能精确，为了方便理解，将三个三角形设置成不同的颜色。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052319135-1993473587.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图29  五角星 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border-left: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-bottom: 100px solid red;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border-left: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-right: 50px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 100px solid red;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 30px;&lt;/p&gt;
&lt;p&gt;    left: -50px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      可在页面中看到如图30所示的六角星。这个六角星是由两个三角形拼合而成的，一个三角形是使用.shape定义的上三角形，另一个是使用.shape:after定义的下三角形。它们层叠到一起，从而形成六角星。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052351097-1859537670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图30  六角星 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    width: 150px;&lt;/p&gt;
&lt;p&gt;    height: 150px;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 0;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    height: 150px;&lt;/p&gt;
&lt;p&gt;    width: 150px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    transform: rotate(45deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      可在页面中看到如图31所示的八角星。这个八角星由两个正方形拼合而成：一个正方形是使用.shape定义的，另一个是使用.shape:after定义的，它旋转了45°。两个正方形层叠到一起，从而形成八角星。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052459038-424088012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图31  八角星 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    width: 150px;&lt;/p&gt;
&lt;p&gt;    height: 150px;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before, .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 0;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    height: 150px;&lt;/p&gt;
&lt;p&gt;    width: 150px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    transform: rotate(30deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    transform: rotate(60deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;      可在页面中看到如图32所示的十二角星。这个十二角星由三个正方形拼合而成：一个正方形是使用.shape定义的，另一个是使用.shape:before定义的，它旋转了30°，还有一个是使用.shape:after定义的，它 旋转了60°。三个正方形层叠到一起，从而形成十二角星。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052535557-976457821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图32  十二角星 &lt;/p&gt;
&lt;p&gt;（6）其他组合图形。&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    width: 20px;&lt;/p&gt;
&lt;p&gt;    height: 100px;   &lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    left: -40px;&lt;/p&gt;
&lt;p&gt;    top: 40px;&lt;/p&gt;
&lt;p&gt;    width: 100px; &lt;/p&gt;
&lt;p&gt;    height: 20px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图33所示的红十字。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052601204-1745621050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图33  红十字&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    width: 100px;&lt;/p&gt;
&lt;p&gt;    height: 90px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before, .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    left: 50px;&lt;/p&gt;
&lt;p&gt;    top: 0;&lt;/p&gt;
&lt;p&gt;    width: 50px;&lt;/p&gt;
&lt;p&gt;    height: 80px;&lt;/p&gt;
&lt;p&gt;    background: red;&lt;/p&gt;
&lt;p&gt;    border-radius: 50px 50px 0 0;&lt;/p&gt;
&lt;p&gt;    transform: rotate(-45deg);&lt;/p&gt;
&lt;p&gt;    transform-origin: 0 100%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    transform: rotate(45deg);&lt;/p&gt;
&lt;p&gt;    transform-origin :100% 100%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图34所示的心形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052623219-669678195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图34  心形 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    border-style: solid;&lt;/p&gt;
&lt;p&gt;    border-color: transparent transparent #FFFAFA transparent;&lt;/p&gt;
&lt;p&gt;    border-width: 0 25px 25px 25px;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    width: 50px;&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 25px;&lt;/p&gt;
&lt;p&gt;    left: -25px;&lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    height: 0;&lt;/p&gt;
&lt;p&gt;    border-style: solid;&lt;/p&gt;
&lt;p&gt;    border-color: #FFFAFA transparent transparent transparent;&lt;/p&gt;
&lt;p&gt;    border-width: 70px 50px 0 50px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图35所示的钻石。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052649756-1292312872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图35  钻石 &lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape &lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    position: relative;&lt;/p&gt;
&lt;p&gt;    width: 212px;&lt;/p&gt;
&lt;p&gt;    height: 100px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before, .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    content: &quot;&quot;;&lt;/p&gt;
&lt;p&gt;    position: absolute;&lt;/p&gt;
&lt;p&gt;    top: 0;&lt;/p&gt;
&lt;p&gt;    left: 0;&lt;/p&gt;
&lt;p&gt;    width: 60px;&lt;/p&gt;
&lt;p&gt;    height: 60px;&lt;/p&gt;
&lt;p&gt;    border: 20px solid red;&lt;/p&gt;
&lt;p&gt;    border-radius: 50px 50px 0 50px;&lt;/p&gt;
&lt;p&gt;    transform: rotate(-45deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    left: auto;&lt;/p&gt;
&lt;p&gt;    right: 0;&lt;/p&gt;
&lt;p&gt;    border-radius: 50px 50px 50px 0;&lt;/p&gt;
&lt;p&gt;    transform: rotate(45deg);&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图36所示的无穷大符号。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052719782-374484875.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图36  无穷大&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     width:80px;&lt;/p&gt;
&lt;p&gt;     height:80px;&lt;/p&gt;
&lt;p&gt;     border: 15px solid transparent;&lt;/p&gt;
&lt;p&gt;     border-top-color: red;&lt;/p&gt;
&lt;p&gt;     border-bottom-color: red;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:before, .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     content: '';&lt;/p&gt;
&lt;p&gt;     display: block;&lt;/p&gt;
&lt;p&gt;     width: 0;&lt;/p&gt;
&lt;p&gt;     height: 0;&lt;/p&gt;
&lt;p&gt;     position: absolute;&lt;/p&gt;
&lt;p&gt;     border: 15px solid transparent;&lt;/p&gt;
&lt;p&gt;     border-bottom-color: red;&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;  .shape:before&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     transform: rotate(135deg);&lt;/p&gt;
&lt;p&gt;     right: -15px;&lt;/p&gt;
&lt;p&gt;     top: -2.5px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  .shape:after&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;     transform: rotate(-45deg);&lt;/p&gt;
&lt;p&gt;     left: -15px;&lt;/p&gt;
&lt;p&gt;     bottom: -2.5px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图37所示的圆弧箭头。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052745182-1301741549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图37  圆弧箭头&lt;/p&gt;
&lt;h3&gt;2．利用box-shadow绘制图形&lt;/h3&gt;
&lt;p&gt;       在CSS中，属性box-shadow用于给对象实现图层阴影效果。利用box-shadow属性也可以绘制图形。&lt;/p&gt;
&lt;p&gt;      box-shadow的基本格式为：&lt;/p&gt;
&lt;p&gt;            box-shadow: h-shadow v-shadow blur spread color inset;&lt;/p&gt;
&lt;p&gt;       各参数的含义说明如下：&lt;/p&gt;
&lt;p&gt;       h-shadow必须设置，它表示阴影的水平偏移量，其值可以取正负值，如果值为正值，则阴影在对象的右边；若值为负值时，阴影在对象的左边。&lt;/p&gt;
&lt;p&gt;       v-shadow也必须设置，它表示阴影的垂直偏移量，其值也可以是正负值，如果为正值，阴影在对象的底部；其值为负值时，阴影在对象的顶部。&lt;/p&gt;
&lt;p&gt;       blur可选，表示阴影模糊半径，其值只能是为正值，如果值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊。&lt;/p&gt;
&lt;p&gt;       Spread可选，表示阴影扩展半径，其值可以是正负值，如果值为正，则整个阴影都延展扩大；若值为负值时，则缩小。&lt;/p&gt;
&lt;p&gt;       Color可选，表示阴影颜色。&lt;/p&gt;
&lt;p&gt;       Inset可选，表示阴影类型。其默认的投影方式是外阴影；如果取其唯一值“inset”，就是将外阴影变成内阴影。&lt;/p&gt;
&lt;p&gt;       另外，box-shadow可以使用一个或多个投影，如果使用多个投影时，必须用逗号&lt;span&gt;“&lt;/span&gt;，&lt;span&gt;”&lt;/span&gt;分开。&lt;/p&gt;
&lt;p&gt;       例如，若定义.shape样式规则如下：&lt;/p&gt;
&lt;p&gt;.shape&lt;/p&gt;
&lt;p&gt; {&lt;/p&gt;
&lt;p&gt;    width: 80px;&lt;/p&gt;
&lt;p&gt;    height: 60px;&lt;/p&gt;
&lt;p&gt;    background: #ff008c;&lt;/p&gt;
&lt;p&gt;    border: 6px solid blue;&lt;/p&gt;
&lt;p&gt;    box-shadow: 40px 30px green;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;则在页面中显示如图38所示的图形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052845285-1917662498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图38  绿色投影（outset）&lt;/p&gt;
&lt;p&gt;       若在box-shadow定义中加上inset，则显示的图形如图39所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052859512-1386201544.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图39  绿色投影（inset）&lt;/p&gt;
&lt;p&gt;      由此可知，对象阴影同box模型的层次一样，外阴影会在对象背景之下，内阴影会在边框之下背景之上。所以整个层级就是：边框&amp;gt;内阴影&amp;gt;背景图片&amp;gt;背景颜色&amp;gt;外阴影。&lt;/p&gt;
&lt;p&gt;      利用box-shadow属性，我们可以在页面中绘制图形。&lt;/p&gt;
&lt;p&gt;例如，修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;    width: 0;&lt;/p&gt;
&lt;p&gt;    color: #f00;&lt;/p&gt;
&lt;p&gt;    border: 15px solid transparent;&lt;/p&gt;
&lt;p&gt;    border-top: 25px solid;&lt;/p&gt;
&lt;p&gt;    box-shadow: 0 -32px 0 -6px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图40所示的下载箭头。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822052940336-1640420345.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图40  下载箭头&lt;/p&gt;
&lt;p&gt;      一般而言，一个div之类的元素通过设置border属性可以绘制一个基本图形，加上:before和:after两个伪类，最多可进行三个基本图形组合。若需要更多图形组合，border属性就有点无能为力了，增加div的定义个数是一种办法。有时，通过box-shadow属性设置多个投影来解决，可能更方便。这也是box-shadow属性的一大优势。&lt;/p&gt;
&lt;p&gt;       例如，修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;     width: 40px;&lt;/p&gt;
&lt;p&gt;     height: 0;&lt;/p&gt;
&lt;p&gt;     color: red;&lt;/p&gt;
&lt;p&gt;     box-shadow: 20px 20px 0 4px ,20px 0 0 4px ,20px 40px 0 4px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图41所示的图形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053008451-180147502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图41  三道杠&lt;/p&gt;
&lt;p&gt;再修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;     width: 40px;&lt;/p&gt;
&lt;p&gt;     height: 0;&lt;/p&gt;
&lt;p&gt;     color: red;&lt;/p&gt;
&lt;p&gt;     box-shadow: 20px 20px 0 3px ,20px 0 0 3px ,20px 40px 0 3px,&lt;/p&gt;
&lt;p&gt;                 20px 10px 0 3px ,20px 30px 0 3px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图42所示的五道杠。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053028056-897175451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图42  五道杠&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     width:80px;&lt;/p&gt;
&lt;p&gt;     height:80px;&lt;/p&gt;
&lt;p&gt;     box-shadow:-30px 0px 0px red,0px -30px 0px yellow,&lt;/p&gt;
&lt;p&gt;            30px 0px 0px green,0px 30px 0px blue;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图43所示的图形。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053046170-797532152.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图43  四色方框&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;     position: relative;&lt;/p&gt;
&lt;p&gt;     width: 40px;&lt;/p&gt;
&lt;p&gt;     height: 40px;&lt;/p&gt;
&lt;p&gt;     background-color: black;&lt;/p&gt;
&lt;p&gt;     border-radius: 50%;&lt;/p&gt;
&lt;p&gt;     box-shadow: 0 0 0 15px #fff,0 0 0 25px #000;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中显示如图44所示的单选按钮。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053106922-1448386573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图44 单选按钮&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    width: 80px;&lt;/p&gt;
&lt;p&gt;    height: 80px;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;    box-shadow: 15px 15px 0 0 white;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图45所示的弯月。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053127335-1563114087.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图45  弯弯的月亮&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;    width: 40px;&lt;/p&gt;
&lt;p&gt;    height: 40px;&lt;/p&gt;
&lt;p&gt;    background: #fff;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;    box-shadow: #fff 22px -15px 0 6px, #fff 57px -6px 0 2px, #fff 87px 4px 0 -4px,&lt;/p&gt;
&lt;p&gt;                #fff 33px 6px 0 6px, #fff 61px 6px 0 2px, #ccc 29px -23px 0 6px,&lt;/p&gt;
&lt;p&gt;                #ccc 64px -14px 0 2px, #ccc 94px -4px 0 -4px;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图46所示的云朵。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053148200-1080381012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图46  云朵&lt;/p&gt;
&lt;p&gt;修改.shape样式定义为：&lt;/p&gt;
&lt;p&gt;  .shape&lt;/p&gt;
&lt;p&gt;  {    &lt;/p&gt;
&lt;p&gt;    width:160px;&lt;/p&gt;
&lt;p&gt;    height:160px;&lt;/p&gt;
&lt;p&gt;    border-radius: 50%;&lt;/p&gt;
&lt;p&gt;    box-shadow: inset 0 0 0 16px  #fff,&lt;/p&gt;
&lt;p&gt;               -80px -80px 0 -64px #f00,&lt;/p&gt;
&lt;p&gt;               0 -112px 0 -64px #f0f,&lt;/p&gt;
&lt;p&gt;               80px -80px 0 -64px #ff0,&lt;/p&gt;
&lt;p&gt;               -80px 80px 0 -64px #0f0,&lt;/p&gt;
&lt;p&gt;               0 112px 0 -64px #0ff,&lt;/p&gt;
&lt;p&gt;               80px 80px 0 -64px #00f,&lt;/p&gt;
&lt;p&gt;               -112px 0 0 -64px #808,&lt;/p&gt;
&lt;p&gt;               112px 0 0 -64px #000; &lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;可在页面中看到如图47所示的图形，在一个圆环的周围围了8个小圆。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200822053208195-70539440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图47  圆环周围的小圆&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 21:33:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>为了在页面中利用CSS3绘制图形，在页面中定义 &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;shape&amp;quot;&amp;gt;&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13544171.html</dc:identifier>
</item>
<item>
<title>Redis高级项目实战，都0202年了，还不会Redis？ - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13506946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13506946.html</guid>
<description>&lt;p&gt;　　大家都听过&lt;span&gt;&lt;strong&gt;1万小时定律&lt;/strong&gt;&lt;/span&gt;，可事实真的是这样吗？做了&lt;span&gt;&lt;strong&gt;1万小时的CRUD&lt;/strong&gt;&lt;/span&gt;，不还只会CRUD吗，这年头&lt;span&gt;&lt;strong&gt;不&lt;/strong&gt;&lt;/span&gt;适当的&lt;strong&gt;&lt;span&gt;更新自身下技术栈&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;出门&lt;/strong&gt;&lt;/span&gt;和别人&lt;span&gt;&lt;strong&gt;聊天吹牛&lt;/strong&gt;&lt;/span&gt;的时候，都没拿不出手，(⊙o⊙)…&lt;span&gt;&lt;strong&gt;Redis没入门的童鞋不推荐往下看&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;先去脑补下Redis入门&lt;/strong&gt;&lt;/span&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12073107.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，&lt;span&gt;&lt;strong&gt;SpringBoot整合Redis的教程&lt;/strong&gt;&lt;/span&gt;(&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13515268.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;)，这篇不会讲浅的知识点！！！！&lt;/p&gt;
&lt;h2&gt;面试专题&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;什么是分布式锁？&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　首先，为了确保分布式锁可用，至少要满足以下三个条件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;互斥性&lt;/strong&gt;&lt;/span&gt;。在任意时刻，只有一个客户端能持有锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;不会发生死锁&lt;/span&gt;&lt;/strong&gt;。即便有一个客户端在持有锁的期间奔溃而没有主动解锁，也能保证后续其他客户端能加锁&lt;/li&gt;
&lt;li&gt;解铃还须系铃人。&lt;span&gt;&lt;strong&gt;加锁&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;解锁必须是同一个客户端&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/span&gt;自己&lt;span&gt;&lt;strong&gt;不能把别人加的锁给解了&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;实现分布式锁方式？&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　两种实现，下面都会有讲到&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;采用&lt;span&gt;&lt;strong&gt;lua脚本&lt;/strong&gt;&lt;/span&gt;操作分布式锁&lt;/li&gt;
&lt;li&gt;采用&lt;span&gt;&lt;strong&gt;setnx、setex命令连用&lt;/strong&gt;&lt;/span&gt;的方式实现分布式锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;什么是分布式锁？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;分布式锁&lt;/span&gt;&lt;/strong&gt;是&lt;span&gt;&lt;strong&gt;控制分布式系统&lt;/strong&gt;&lt;/span&gt;或&lt;span&gt;&lt;strong&gt;不同系统&lt;/strong&gt;&lt;/span&gt;之间&lt;span&gt;&lt;strong&gt;共同访问共享资源的&lt;/strong&gt;&lt;/span&gt;一种&lt;span&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/span&gt;实现&lt;/li&gt;
&lt;li&gt;如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往通过互斥来防止彼此干扰&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;为什么要有分布式锁？&lt;/h2&gt;
&lt;p&gt;　　可以&lt;span&gt;&lt;strong&gt;保证&lt;/strong&gt;&lt;/span&gt;在&lt;span&gt;&lt;strong&gt;分布式&lt;/strong&gt;&lt;/span&gt;部署的&lt;span&gt;&lt;strong&gt;应用集群&lt;/strong&gt;&lt;/span&gt;中，&lt;span&gt;&lt;strong&gt;同&lt;/strong&gt;&lt;/span&gt;一个&lt;span&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/span&gt;在同一&lt;span&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/span&gt;只能&lt;span&gt;&lt;strong&gt;被&lt;/strong&gt;&lt;strong&gt;一台机器&lt;/strong&gt;&lt;/span&gt;上的&lt;span&gt;&lt;strong&gt;一个线程执行&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;设计要求&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;可&lt;span&gt;&lt;strong&gt;重入&lt;/strong&gt;&lt;/span&gt;锁(避免死锁)&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/span&gt;锁和&lt;span&gt;&lt;strong&gt;释放&lt;/strong&gt;&lt;/span&gt;锁&lt;strong&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;锁和&lt;strong&gt;&lt;span&gt;释放&lt;/span&gt;&lt;/strong&gt;锁&lt;span&gt;&lt;strong&gt;高性能&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;实现方案&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;获取锁&lt;/strong&gt;&lt;/span&gt;，使用&lt;span&gt;&lt;strong&gt;setnx()&lt;/strong&gt;&lt;/span&gt;：SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;若&lt;span&gt;k&lt;/span&gt;ey存在，则什么都不做&lt;/strong&gt;&lt;/span&gt;，返回【0】加锁，锁的value值为当前占有锁服务器内网IP编号拼接任务标识&lt;/li&gt;
&lt;li&gt;在&lt;span&gt;&lt;strong&gt;释放锁&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;时&lt;/strong&gt;&lt;/span&gt;候进行判断。并&lt;span&gt;&lt;strong&gt;使用expire&lt;/strong&gt;&lt;/span&gt;命令&lt;span&gt;&lt;strong&gt;为锁添加一个超时时间&lt;/strong&gt;&lt;/span&gt;，超过该时间则&lt;span&gt;&lt;strong&gt;自动释放锁&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;返回1&lt;/strong&gt;&lt;/span&gt;则&lt;span&gt;&lt;strong&gt;成功获取锁&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;还设置&lt;/strong&gt;&lt;/span&gt;一个&lt;span&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;超时时间&lt;/strong&gt;&lt;/span&gt;，若&lt;span&gt;&lt;strong&gt;超过&lt;/strong&gt;&lt;/span&gt;这个&lt;span&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;/span&gt;则&lt;span&gt;&lt;strong&gt;放弃获取锁&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;setex&lt;/strong&gt;&lt;/span&gt;(key,value,expire)过期&lt;span&gt;&lt;strong&gt;以秒为单位&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;释放锁&lt;/strong&gt;&lt;/span&gt;的时候，&lt;span&gt;&lt;strong&gt;判断&lt;/strong&gt;&lt;/span&gt;是不是该&lt;span&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/span&gt;(即value为当前服务器内网IP编号拼接任务标识)，若是该锁，则&lt;strong&gt;&lt;span&gt;执行delete&lt;/span&gt;&lt;/strong&gt;进行&lt;span&gt;&lt;strong&gt;锁释放&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;创建一个SpringBoot工程&lt;/h2&gt;
&lt;p&gt;网址：https://start.spring.io/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200814222311751-1772794455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;p&gt;　　1、启动类上加上注解@EnableScheduling&lt;/p&gt;
&lt;p&gt;　　2、执行方法上加上注解@Scheduled&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200814230859253-524877502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;打包并上传至Linux服务器中启动&lt;/h2&gt;
&lt;p&gt;　　准备3台Linux服务器，并将打好的jar包，上传至3台服务器中，然后启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200814231810279-2069054679.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;nohub之持久化启动方式 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nohup java -jar jar名称 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;查看集群里面所有集群是否启动成功&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、先安装lsof：yum install lsof
2、验证：lsof -i:8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;查看本机TCP连接状态&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;为什么要三次握手？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;主要&lt;/strong&gt;&lt;/span&gt;是为了&lt;strong&gt;&lt;span&gt;防止已失效&lt;/span&gt;&lt;/strong&gt;的连接&lt;span&gt;&lt;strong&gt;请求报文段&lt;/strong&gt;&lt;/span&gt;突然&lt;strong&gt;&lt;span&gt;又传&lt;/span&gt;&lt;/strong&gt;到了&lt;strong&gt;&lt;span&gt;B&lt;/span&gt;&lt;/strong&gt;，因而报文错乱问题，假定A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已经失效的报文段。但B收到失效的连接请求报文段后，就误认为是A又发出一个新的连接请求，于是就向A发出确认报文段，同意建立连接。&lt;/p&gt;
&lt;p&gt;　　假定&lt;span&gt;&lt;strong&gt;不采用三次握手&lt;/strong&gt;&lt;/span&gt;，那么只要&lt;span&gt;&lt;strong&gt;B发出确认&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;新的连接就建立&lt;/strong&gt;&lt;/span&gt;，这样&lt;span&gt;&lt;strong&gt;一直等待A&lt;/strong&gt;&lt;/span&gt;发来数据，&lt;span&gt;&lt;strong&gt;B的许多资源&lt;/strong&gt;&lt;/span&gt;就这样&lt;span&gt;&lt;strong&gt;白白浪费&lt;/strong&gt;&lt;/span&gt;了。&lt;/p&gt;
&lt;h3&gt;图解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200815093340858-1369690611.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;有3次握手了，为啥还有4次挥手？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200816164445553-367496821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。&lt;br/&gt;第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。&lt;br/&gt;第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。&lt;br/&gt;第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。&lt;/p&gt;
&lt;h3&gt;作用&lt;/h3&gt;
&lt;p&gt;　　确保数据能够完整传输&lt;/p&gt;

&lt;h2&gt;图文讲解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200816170658270-1232710320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;分布式锁满足&lt;span&gt;&lt;strong&gt;两个条件&lt;/strong&gt;&lt;/span&gt;，一个是&lt;span&gt;&lt;strong&gt;加有效时间&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/span&gt;，一个是&lt;span&gt;&lt;strong&gt;高性能解锁&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;采用redis命令&lt;span&gt;&lt;strong&gt;setnx&lt;/strong&gt;&lt;/span&gt; (set if not exist)、&lt;span&gt;&lt;strong&gt;setex&lt;/strong&gt;&lt;/span&gt;（set expire value）实现&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;解锁流程不能遗漏&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;否则导致&lt;/strong&gt;&lt;/span&gt;任务执行一次就&lt;span&gt;&lt;strong&gt;永不过期&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;将&lt;span&gt;&lt;strong&gt;加锁代码&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;任务逻辑放到try catch代码块&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;解锁&lt;/strong&gt;&lt;/span&gt;流程&lt;span&gt;&lt;strong&gt;放&lt;/strong&gt;&lt;/span&gt;到&lt;span&gt;&lt;strong&gt;finally代码块&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;项目结构&lt;/h2&gt;
&lt;h3&gt;pom.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.3.3.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.cyb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yb-mobile-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yb-mobile-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo project for Spring Boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.junit.vintage&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit-vintage-engine&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;application.properties&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.redis.database=0
spring.redis.host=192.168.199.142
spring.redis.port=6379
spring.redis.password=12345678
server.port=9001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RedisService.java&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.redis.core.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：RedisService
 * @Description：TODO
 * @Author：chenyb
 * @Date：2020/8/16 5:39 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisService {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; size = Math.pow(2, 32&lt;span&gt;);


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; offset   位 8Bit=1Byte
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; setBit(String key, &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isShow) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            operations.setBit(key, offset, isShow);
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; offset
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; getBit(String key, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            result &lt;/span&gt;=&lt;span&gt; operations.getBit(key, offset);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; set(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key, Object value) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            operations.set(key, value);
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 写入缓存设置时效时间
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; set(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key, Object value, Long expireTime) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
            operations.set(key, value);
            redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);
            result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 批量删除对应的value
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; keys
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String... keys) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String key : keys) {
            remove(key);
        }
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除对应的value
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (exists(key)) {
            redisTemplate.delete(key);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断缓存中是否有对应的value
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; exists(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.hasKey(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读取缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Object get(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String key) {
        Object result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ValueOperations&lt;/span&gt;&amp;lt;Serializable, Object&amp;gt; operations =&lt;span&gt; redisTemplate.opsForValue();
        result &lt;/span&gt;=&lt;span&gt; operations.get(key);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 哈希 添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hashKey
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hmSet(String key, Object hashKey, Object value) {
        HashOperations&lt;/span&gt;&amp;lt;String, Object, Object&amp;gt; hash =&lt;span&gt; redisTemplate.opsForHash();
        hash.put(key, hashKey, value);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 哈希获取数据
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; hashKey
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object hmGet(String key, Object hashKey) {
        HashOperations&lt;/span&gt;&amp;lt;String, Object, Object&amp;gt; hash =&lt;span&gt; redisTemplate.opsForHash();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hash.get(key, hashKey);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 列表添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; k
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; v
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lPush(String k, Object v) {
        ListOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; list =&lt;span&gt; redisTemplate.opsForList();
        list.rightPush(k, v);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 列表获取
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; k
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; l
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; l1
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Object&amp;gt; lRange(String k, &lt;span&gt;long&lt;/span&gt; l, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; l1) {
        ListOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; list =&lt;span&gt; redisTemplate.opsForList();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.range(k, l, l1);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 集合添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(String key, Object value) {
        SetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; set =&lt;span&gt; redisTemplate.opsForSet();
        set.add(key, value);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 集合获取
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;Object&amp;gt;&lt;span&gt; setMembers(String key) {
        SetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; set =&lt;span&gt; redisTemplate.opsForSet();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set.members(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scoure
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; zAdd(String key, Object value, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; scoure) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        zset.add(key, value, scoure);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合获取
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scoure
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scoure1
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;Object&amp;gt; rangeByScore(String key, &lt;span&gt;double&lt;/span&gt; scoure, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; scoure1) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        redisTemplate.opsForValue();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zset.rangeByScore(key, scoure, scoure1);
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次加载的时候将数据加载到redis中&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveDataToRedis(String name) {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; index = Math.abs(name.hashCode() %&lt;span&gt; size);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; indexLong = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Double(index).longValue();
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; availableUsers = setBit(&quot;availableUsers&quot;, indexLong, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次加载的时候将数据加载到redis中&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getDataToRedis(String name) {

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; index = Math.abs(name.hashCode() %&lt;span&gt; size);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; indexLong = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Double(index).longValue();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getBit(&quot;availableUsers&quot;&lt;span&gt;, indexLong);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合获取排名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 集合名称
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long zRank(String key, Object value) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zset.rank(key,value);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合获取排名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; zRankWithScore(String key, &lt;span&gt;long&lt;/span&gt; start,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        Set&lt;/span&gt;&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; ret =&lt;span&gt; zset.rangeWithScores(key,start,end);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double zSetScore(String key, Object value) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zset.score(key,value);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合添加分数
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scoure
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; incrementScore(String key, Object value, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; scoure) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        zset.incrementScore(key, value, scoure);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合获取排名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; reverseZRankWithScore(String key, &lt;span&gt;long&lt;/span&gt; start,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        Set&lt;/span&gt;&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; ret =&lt;span&gt; zset.reverseRangeByScoreWithScores(key,start,end);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有序集合获取排名
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; reverseZRankWithRank(String key, &lt;span&gt;long&lt;/span&gt; start, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        ZSetOperations&lt;/span&gt;&amp;lt;String, Object&amp;gt; zset =&lt;span&gt; redisTemplate.opsForZSet();
        Set&lt;/span&gt;&amp;lt;ZSetOperations.TypedTuple&amp;lt;Object&amp;gt;&amp;gt; ret =&lt;span&gt; zset.reverseRangeWithScores(key, start, end);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;LockNxExJob.java&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.schedule;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.service.RedisService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Scheduled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Inet4Address;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.NetworkInterface;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Enumeration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：LockNxExJob
 * @Description：分布式获取锁和释放锁
 * @Author：chenyb
 * @Date：2020/8/16 5:44 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockNxExJob {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LockNxExJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisService redisService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String LOCK_PREFIX = &quot;prefix_&quot;&lt;span&gt;;
    @Scheduled(fixedRate &lt;/span&gt;= 8000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lockJob() {
        String lock &lt;/span&gt;= LOCK_PREFIX + &quot;LockNxExJob&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; nxRet=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作&lt;/span&gt;
            nxRet =&lt;span&gt; redisTemplate.opsForValue().setIfAbsent(lock,getHostIp());
            Object lockValue &lt;/span&gt;=&lt;span&gt; redisService.get(lock);
            System.out.println(lockValue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;nxRet){
                String value &lt;/span&gt;=&lt;span&gt; (String)redisService.get(lock);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP&lt;/span&gt;
                logger.info(System.currentTimeMillis()+&quot; get lock fail,lock belong to:{}&quot;&lt;span&gt;,value);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                redisTemplate.opsForValue().set(lock,getHostIp(),&lt;/span&gt;3600&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功&lt;/span&gt;
                logger.info(System.currentTimeMillis()+&quot; start lock lockNxExJob success&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            logger.error(&lt;/span&gt;&quot;lock error&quot;&lt;span&gt;,e);

        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nxRet){
                System.out.println(&lt;/span&gt;&quot;释放锁成功&quot;&lt;span&gt;);
                redisService.remove(lock);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取本机内网IP地址方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getHostIp(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Enumeration&lt;/span&gt;&amp;lt;NetworkInterface&amp;gt; allNetInterfaces =&lt;span&gt; NetworkInterface.getNetworkInterfaces();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allNetInterfaces.hasMoreElements()){
                NetworkInterface netInterface &lt;/span&gt;=&lt;span&gt; (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration&lt;/span&gt;&amp;lt;InetAddress&amp;gt; addresses =&lt;span&gt; netInterface.getInetAddresses();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (addresses.hasMoreElements()){
                    InetAddress ip &lt;/span&gt;=&lt;span&gt; (InetAddress) addresses.nextElement();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ip != &lt;span&gt;null&lt;/span&gt;
                            &amp;amp;&amp;amp; ip &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Inet4Address
                            &lt;/span&gt;&amp;amp;&amp;amp; !ip.isLoopbackAddress() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;loopback地址即本机地址，IPv4的loopback范围是127.0.0.0 ~ 127.255.255.255&lt;/span&gt;
                            &amp;amp;&amp;amp; ip.getHostAddress().indexOf(&quot;:&quot;)==-1&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ip.getHostAddress();
                    }
                }
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;　　打个jar运行在Linux上，一个在本地运行，&lt;span&gt;&lt;strong&gt;一个&lt;/strong&gt;&lt;/span&gt;获取锁&lt;span&gt;&lt;strong&gt;成功&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;一个&lt;/strong&gt;&lt;/span&gt;获取锁&lt;span&gt;&lt;strong&gt;失败&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200816223554492-1313888447.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200818223530355-1760608448.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;上面&lt;/strong&gt;&lt;/span&gt;我们已经使用&lt;span&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;了&lt;span&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;&lt;/span&gt;的功能，&lt;span&gt;&lt;strong&gt;同一时刻&lt;/strong&gt;&lt;strong&gt;只能一把锁获取成功&lt;/strong&gt;&lt;/span&gt;。从上图可以看出，&lt;span&gt;&lt;strong&gt;极端情况下&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;第一个Server获取锁成功&lt;/strong&gt;&lt;/span&gt;后，&lt;span&gt;&lt;strong&gt;服务或者Redis宕机&lt;/strong&gt;&lt;/span&gt;了，会&lt;span&gt;&lt;strong&gt;导致Redis锁无法释放&lt;/strong&gt;&lt;/span&gt;的问题，&lt;span&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/span&gt;就&lt;span&gt;&lt;strong&gt;一直获取锁失败&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;模拟server获取锁宕机&lt;/h2&gt;
&lt;p&gt;　　先把&lt;span&gt;&lt;strong&gt;项目跑起来&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;获取锁之后&lt;/strong&gt;&lt;/span&gt;，立马&lt;span&gt;&lt;strong&gt;kill -9 进程id&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;杀掉当前进程&lt;/strong&gt;&lt;/span&gt;，然后在运行项目，控制台就会一直提示，获取锁失败了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819000547581-1754769577.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819001314018-1165781808.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819001407749-2091216048.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;解决方案(&lt;span&gt;重点&lt;/span&gt;)&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;一次性执行一条命令就不会出现该情况发生，采用&lt;strong&gt;&lt;span&gt;Lua脚本&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Redis从2.6之后，支持&lt;span&gt;&lt;strong&gt;setnx、setex连用&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;lua脚本&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在redource目录下新增一个后缀名为.lua结尾的文件&lt;/li&gt;
&lt;li&gt;编写lua脚本&lt;/li&gt;
&lt;li&gt;传入lua脚本的key和arg&lt;/li&gt;
&lt;li&gt;调用redisTemplate.execute方法执行脚本&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;编写lua脚本&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819224859707-963451524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
local lockKey = KEYS[1&lt;span&gt;]
local lockValue &lt;/span&gt;= KEYS[2&lt;span&gt;]
&lt;/span&gt;--&lt;span&gt; setnx info
local result_1 &lt;/span&gt;= redis.call('SETNX'&lt;span&gt;,lockKey,lockValue)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; result_1 == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
then
local result_2 &lt;/span&gt;= redis.call('SETEX',lockKey,3600&lt;span&gt;,lockValue)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result_1
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result_1
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;封装调用lua脚本方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819225018239-205926746.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Boolean&amp;gt;&lt;span&gt; lockScript;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取lua结果
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean luaExpress(String key, String value) {
        lockScript &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;&lt;span&gt;();
        lockScript.setScriptSource(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;add.lua&quot;&lt;span&gt;))
        );
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置返回值&lt;/span&gt;
        lockScript.setResultType(Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装参数&lt;/span&gt;
        List&amp;lt;Object&amp;gt; keyList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        keyList.add(key);
        keyList.add(value);
        Boolean result &lt;/span&gt;=&lt;span&gt; (Boolean) redisTemplate.execute(lockScript, keyList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;改造之前的分布式锁方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819225150156-161111106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.schedule;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.service.RedisService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.io.ClassPathResource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.script.DefaultRedisScript;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Scheduled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scripting.support.ResourceScriptSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Inet4Address;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.NetworkInterface;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Enumeration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：LockNxExJob
 * @Description：分布式获取锁和释放锁
 * @Author：chenyb
 * @Date：2020/8/16 5:44 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockNxExJob {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LockNxExJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisService redisService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String LOCK_PREFIX = &quot;prefix_&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Boolean&amp;gt;&lt;span&gt; lockScript;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般分布式锁
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Scheduled(fixedRate = 8000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void lockJob() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String lock = LOCK_PREFIX + &quot;LockNxExJob&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean nxRet = false;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nxRet = redisTemplate.opsForValue().setIfAbsent(lock, getHostIp());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Object lockValue = redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(lockValue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (!nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                String value = (String) redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; get lock fail,lock belong to:{}&quot;, value);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } else {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisTemplate.opsForValue().set(lock, getHostIp(), 3600000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; start lock lockNxExJob success&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(4000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            logger.error(&quot;lock error&quot;, e);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } finally {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                System.out.println(&quot;释放锁成功&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisService.remove(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * lua脚本方式分布式锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(fixedRate &lt;/span&gt;= 8000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; luaLockJob() {
        String lock &lt;/span&gt;= LOCK_PREFIX + &quot;LockNxExJob&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; nxRet = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作&lt;/span&gt;
            nxRet =&lt;span&gt; luaExpress(lock,getHostIp());
            Object lockValue &lt;/span&gt;=&lt;span&gt; redisService.get(lock);
            System.out.println(lockValue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nxRet) {
                String value &lt;/span&gt;=&lt;span&gt; (String) redisService.get(lock);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; lua get lock fail,lock belong to:{}&quot;&lt;span&gt;, value);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                redisTemplate.opsForValue().set(lock, getHostIp(), &lt;/span&gt;3600000&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; lua start lock lockNxExJob success&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;lua lock error&quot;&lt;span&gt;, e);

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nxRet) {
                System.out.println(&lt;/span&gt;&quot;lua 释放锁成功&quot;&lt;span&gt;);
                redisService.remove(lock);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取lua结果
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean luaExpress(String key, String value) {
        lockScript &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;&lt;span&gt;();
        lockScript.setScriptSource(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;add.lua&quot;&lt;span&gt;))
        );
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置返回值&lt;/span&gt;
        lockScript.setResultType(Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装参数&lt;/span&gt;
        List&amp;lt;Object&amp;gt; keyList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        keyList.add(key);
        keyList.add(value);
        Boolean result &lt;/span&gt;=&lt;span&gt; (Boolean) redisTemplate.execute(lockScript, keyList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取本机内网IP地址方法
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getHostIp() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Enumeration&lt;/span&gt;&amp;lt;NetworkInterface&amp;gt; allNetInterfaces =&lt;span&gt; NetworkInterface.getNetworkInterfaces();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface &lt;/span&gt;=&lt;span&gt; (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration&lt;/span&gt;&amp;lt;InetAddress&amp;gt; addresses =&lt;span&gt; netInterface.getInetAddresses();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (addresses.hasMoreElements()) {
                    InetAddress ip &lt;/span&gt;=&lt;span&gt; (InetAddress) addresses.nextElement();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ip != &lt;span&gt;null&lt;/span&gt;
                            &amp;amp;&amp;amp; ip &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Inet4Address
                            &lt;/span&gt;&amp;amp;&amp;amp; !ip.isLoopbackAddress() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;loopback地址即本机地址，IPv4的loopback范围是127.0.0.0 ~ 127.255.255.255&lt;/span&gt;
                            &amp;amp;&amp;amp; ip.getHostAddress().indexOf(&quot;:&quot;) == -1&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ip.getHostAddress();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;验证&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819231306639-1947883497.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;补充解决Redis中的key乱码问题&lt;/h3&gt;
&lt;p&gt;　　只需要添加RedisConfig.java配置文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200819231856166-1949069750.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.RedisSerializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.StringRedisSerializer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：RedisConfig
 * @Description：Redis配置类
 * @Author：chenyb
 * @Date：2020/8/16 11:48 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前类为配置类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisConfig {
    @Bean &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisTemplate注入到Spring容器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String,String&amp;gt;&lt;span&gt; redisTemplate(RedisConnectionFactory factory){
        RedisTemplate&lt;/span&gt;&amp;lt;String,String&amp;gt; redisTemplate=&lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
        RedisSerializer&lt;/span&gt;&amp;lt;String&amp;gt; redisSerializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
        redisTemplate.setConnectionFactory(factory);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key序列化&lt;/span&gt;
&lt;span&gt;        redisTemplate.setKeySerializer(redisSerializer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;value序列化&lt;/span&gt;
&lt;span&gt;        redisTemplate.setValueSerializer(redisSerializer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;value hashmap序列化&lt;/span&gt;
&lt;span&gt;        redisTemplate.setHashKeySerializer(redisSerializer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key hashmap序列化&lt;/span&gt;
&lt;span&gt;        redisTemplate.setHashValueSerializer(redisSerializer);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RedisConnection实现分布式锁&lt;/h3&gt;
&lt;h4&gt;简介&lt;/h4&gt;
&lt;p&gt;　　RedisConnection实现分布式锁的方式，采用redisTemplate操作redisConnection实现setnx和setex两个命令连用&lt;/p&gt;
&lt;h4&gt;代码实现&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200820001936699-723207755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.schedule;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.service.RedisService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.io.ClassPathResource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.dao.DataAccessException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisStringCommands;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisCallback;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.script.DefaultRedisScript;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.types.Expiration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Scheduled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scripting.support.ResourceScriptSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Inet4Address;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.NetworkInterface;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Enumeration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：LockNxExJob
 * @Description：分布式获取锁和释放锁
 * @Author：chenyb
 * @Date：2020/8/16 5:44 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockNxExJob {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LockNxExJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisService redisService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String LOCK_PREFIX = &quot;prefix_&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Boolean&amp;gt;&lt;span&gt; lockScript;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般分布式锁
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Scheduled(fixedRate = 8000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void lockJob() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String lock = LOCK_PREFIX + &quot;LockNxExJob&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean nxRet = false;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nxRet = redisTemplate.opsForValue().setIfAbsent(lock, getHostIp());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Object lockValue = redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(lockValue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (!nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                String value = (String) redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; get lock fail,lock belong to:{}&quot;, value);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } else {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisTemplate.opsForValue().set(lock, getHostIp(), 3600000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; start lock lockNxExJob success&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(4000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            logger.error(&quot;lock error&quot;, e);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } finally {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                System.out.println(&quot;释放锁成功&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisService.remove(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * lua脚本方式分布式锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Scheduled(fixedRate = 8000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void luaLockJob() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String lock = LOCK_PREFIX + &quot;LockNxExJob&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean nxRet = false;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nxRet = luaExpress(lock,getHostIp());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nxRet = setLock(lock,600);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Object lockValue = redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(lockValue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (!nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                String value = (String) redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; lua get lock fail,lock belong to:{}&quot;, value);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } else {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisTemplate.opsForValue().set(lock, getHostIp(), 3600000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; lua start lock lockNxExJob success&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(4000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            logger.error(&quot;lua lock error&quot;, e);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } finally {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                System.out.println(&quot;lua 释放锁成功&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisService.remove(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * setnx和setex连用分布式锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(fixedRate &lt;/span&gt;= 8000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLockJob() {
        String lock &lt;/span&gt;= LOCK_PREFIX + &quot;LockNxExJob&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; nxRet = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nxRet = luaExpress(lock,getHostIp());&lt;/span&gt;
            nxRet = setLock(lock,getHostIp(),3&lt;span&gt;);
            Object lockValue &lt;/span&gt;=&lt;span&gt; redisService.get(lock);
            System.out.println(lockValue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nxRet) {
                String value &lt;/span&gt;=&lt;span&gt; (String) redisService.get(lock);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; setnx and setex get lock fail,lock belong to:{}&quot;&lt;span&gt;, value);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                redisTemplate.opsForValue().set(lock, getHostIp(), &lt;/span&gt;3600000&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; setnx and setex start lock lockNxExJob success&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot; setnx and setex lock error&quot;&lt;span&gt;, e);

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nxRet) {
                System.out.println(&lt;/span&gt;&quot; setnx and setex 释放锁成功&quot;&lt;span&gt;);
                redisService.remove(lock);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * setnx和setex连用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expire 超时时间
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; setLock(String key,String value,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; expire){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Boolean result&lt;/span&gt;=(&lt;span&gt;boolean&lt;/span&gt;)redisTemplate.execute(&lt;span&gt;new&lt;/span&gt; RedisCallback&amp;lt;Boolean&amp;gt;&lt;span&gt;() {

                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean doInRedis(RedisConnection connection) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection.set(key.getBytes(),value.getBytes(),Expiration.seconds(expire),RedisStringCommands.SetOption.ifAbsent());
                }
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            logger.error(&lt;/span&gt;&quot;set redis occured an exception&quot;&lt;span&gt;,e);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取lua结果
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean luaExpress(String key, String value) {
        lockScript &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;&lt;span&gt;();
        lockScript.setScriptSource(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;add.lua&quot;&lt;span&gt;))
        );
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置返回值&lt;/span&gt;
        lockScript.setResultType(Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装参数&lt;/span&gt;
        List&amp;lt;Object&amp;gt; keyList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        keyList.add(key);
        keyList.add(value);
        Boolean result &lt;/span&gt;=&lt;span&gt; (Boolean) redisTemplate.execute(lockScript, keyList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取本机内网IP地址方法
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getHostIp() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Enumeration&lt;/span&gt;&amp;lt;NetworkInterface&amp;gt; allNetInterfaces =&lt;span&gt; NetworkInterface.getNetworkInterfaces();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface &lt;/span&gt;=&lt;span&gt; (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration&lt;/span&gt;&amp;lt;InetAddress&amp;gt; addresses =&lt;span&gt; netInterface.getInetAddresses();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (addresses.hasMoreElements()) {
                    InetAddress ip &lt;/span&gt;=&lt;span&gt; (InetAddress) addresses.nextElement();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ip != &lt;span&gt;null&lt;/span&gt;
                            &amp;amp;&amp;amp; ip &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Inet4Address
                            &lt;/span&gt;&amp;amp;&amp;amp; !ip.isLoopbackAddress() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;loopback地址即本机地址，IPv4的loopback范围是127.0.0.0 ~ 127.255.255.255&lt;/span&gt;
                            &amp;amp;&amp;amp; ip.getHostAddress().indexOf(&quot;:&quot;) == -1&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ip.getHostAddress();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200820002558173-1162135335.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;分布式锁优化细节(&lt;span&gt;重点&lt;/span&gt;)&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;上面&lt;/strong&gt;&lt;/span&gt;几个&lt;span&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;/span&gt;，已经&lt;span&gt;&lt;strong&gt;实现了分布式锁&lt;/strong&gt;&lt;/span&gt;的功能，但是&lt;span&gt;&lt;strong&gt;极端情况下&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;ServerA&lt;/strong&gt;&lt;/span&gt;程序还&lt;span&gt;&lt;strong&gt;没执行完&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;ServerB程序执行完&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;把锁释放掉了&lt;/strong&gt;&lt;/span&gt;，就会造成A的锁释放掉了，这不是扯嘛，&lt;span&gt;&lt;strong&gt;ServerA还没执行完，锁就被其他人释放了&lt;/strong&gt;&lt;/span&gt;。解决方案：&lt;span&gt;&lt;strong&gt;释放的时候，使用lua，通过get方法获取value，判断value是否等于本机ip，是自己的才能释放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200821234232104-937570704.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.schedule;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cyb.ybmobileredis.service.RedisService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.io.ClassPathResource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.dao.DataAccessException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisStringCommands;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisCallback;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.script.DefaultRedisScript;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.types.Expiration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Scheduled;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scripting.support.ResourceScriptSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Inet4Address;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.NetworkInterface;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Enumeration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @ClassName：LockNxExJob
 * @Description：分布式获取锁和释放锁
 * @Author：chenyb
 * @Date：2020/8/16 5:44 下午
 * @Versiion：1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockNxExJob {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(LockNxExJob.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisService redisService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String LOCK_PREFIX = &quot;prefix_&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Boolean&amp;gt;&lt;span&gt; lockScript;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般分布式锁
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Scheduled(fixedRate = 8000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void lockJob() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String lock = LOCK_PREFIX + &quot;LockNxExJob&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean nxRet = false;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nxRet = redisTemplate.opsForValue().setIfAbsent(lock, getHostIp());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Object lockValue = redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(lockValue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (!nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                String value = (String) redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; get lock fail,lock belong to:{}&quot;, value);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } else {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisTemplate.opsForValue().set(lock, getHostIp(), 3600000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; start lock lockNxExJob success&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(4000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            logger.error(&quot;lock error&quot;, e);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } finally {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                System.out.println(&quot;释放锁成功&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisService.remove(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * lua脚本方式分布式锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Scheduled(fixedRate = 8000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void luaLockJob() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String lock = LOCK_PREFIX + &quot;LockNxExJob&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        boolean nxRet = false;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nxRet = luaExpress(lock,getHostIp());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nxRet = setLock(lock,600);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Object lockValue = redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(lockValue);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (!nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                String value = (String) redisService.get(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; lua get lock fail,lock belong to:{}&quot;, value);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            } else {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisTemplate.opsForValue().set(lock, getHostIp(), 3600000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                logger.info(System.currentTimeMillis() + &quot; lua start lock lockNxExJob success&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                Thread.sleep(4000);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } catch (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            logger.error(&quot;lua lock error&quot;, e);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        } finally {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if (nxRet) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                System.out.println(&quot;lua 释放锁成功&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                redisService.remove(lock);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * setnx和setex连用分布式锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(fixedRate &lt;/span&gt;= 8000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLockJob() {
        String lock &lt;/span&gt;= LOCK_PREFIX + &quot;LockNxExJob&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; nxRet = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redistemplate setnx操作
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nxRet = luaExpress(lock,getHostIp());&lt;/span&gt;
            System.out.println(&quot;hostIp1=&quot;+&lt;span&gt;getHostIp());
            nxRet &lt;/span&gt;= setLock(lock, getHostIp(), 30&lt;span&gt;);
            Object lockValue &lt;/span&gt;=&lt;span&gt; redisService.get(lock);
            System.out.println(lockValue);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nxRet) {
                String value &lt;/span&gt;=&lt;span&gt; (String) redisService.get(lock);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印当前占用锁的服务器IP&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; setnx and setex get lock fail,lock belong to:{}&quot;&lt;span&gt;, value);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁成功&lt;/span&gt;
                logger.info(System.currentTimeMillis() + &quot; setnx and setex start lock lockNxExJob success&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot; setnx and setex lock error&quot;&lt;span&gt;, e);

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (nxRet) {
                System.out.println(&lt;/span&gt;&quot; setnx and setex 释放锁成功&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisService.remove(lock);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用lua脚本释放锁&lt;/span&gt;
                System.out.println(&quot;hostIp2=&quot;+&lt;span&gt;getHostIp());
                Boolean result &lt;/span&gt;=&lt;span&gt; releaseLock(lock, getHostIp());
                System.out.println(&lt;/span&gt;&quot;状态:&quot;+&lt;span&gt;result);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放锁操作
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; releaseLock(String key, String value) {
        lockScript &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;Boolean&amp;gt;&lt;span&gt;();
        lockScript.setScriptSource(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;unlock.lua&quot;&lt;span&gt;)));
        lockScript.setResultType(Boolean.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装参数&lt;/span&gt;
        List&amp;lt;Object&amp;gt; keyList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        keyList.add(key);
        keyList.add(value);
        Boolean result &lt;/span&gt;=&lt;span&gt; (Boolean) redisTemplate.execute(lockScript, keyList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * setnx和setex连用
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key    键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value  值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expire 超时时间
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; setLock(String key, String value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; expire) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Boolean result &lt;/span&gt;= (&lt;span&gt;boolean&lt;/span&gt;) redisTemplate.execute(&lt;span&gt;new&lt;/span&gt; RedisCallback&amp;lt;Boolean&amp;gt;&lt;span&gt;() {

                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean doInRedis(RedisConnection connection) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection.set(key.getBytes(), value.getBytes(), Expiration.seconds(expire), RedisStringCommands.SetOption.ifAbsent());
                }
            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;set redis occured an exception&quot;&lt;span&gt;, e);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取lua结果
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   键
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean luaExpress(String key, String value) {
        lockScript &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;&lt;span&gt;();
        lockScript.setScriptSource(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;add.lua&quot;&lt;span&gt;))
        );
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置返回值&lt;/span&gt;
        lockScript.setResultType(Boolean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装参数&lt;/span&gt;
        List&amp;lt;Object&amp;gt; keyList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        keyList.add(key);
        keyList.add(value);
        Boolean result &lt;/span&gt;=&lt;span&gt; (Boolean) redisTemplate.execute(lockScript, keyList);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取本机内网IP地址方法
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getHostIp() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Enumeration&lt;/span&gt;&amp;lt;NetworkInterface&amp;gt; allNetInterfaces =&lt;span&gt; NetworkInterface.getNetworkInterfaces();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface &lt;/span&gt;=&lt;span&gt; (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration&lt;/span&gt;&amp;lt;InetAddress&amp;gt; addresses =&lt;span&gt; netInterface.getInetAddresses();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (addresses.hasMoreElements()) {
                    InetAddress ip &lt;/span&gt;=&lt;span&gt; (InetAddress) addresses.nextElement();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ip != &lt;span&gt;null&lt;/span&gt;
                            &amp;amp;&amp;amp; ip &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Inet4Address
                            &lt;/span&gt;&amp;amp;&amp;amp; !ip.isLoopbackAddress() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;loopback地址即本机地址，IPv4的loopback范围是127.0.0.0 ~ 127.255.255.255&lt;/span&gt;
                            &amp;amp;&amp;amp; ip.getHostAddress().indexOf(&quot;:&quot;) == -1&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ip.getHostAddress();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;unlock.lua脚本&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200821235129478-45459808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
local lockKey = KEYS[1&lt;span&gt;]
local lockValue &lt;/span&gt;= KEYS[2&lt;span&gt;]

&lt;/span&gt;--&lt;span&gt; get key
local result_1 &lt;/span&gt;= redis.call('get'&lt;span&gt;, lockKey)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; result_1 ==&lt;span&gt; lockValue
then
local result_2&lt;/span&gt;= redis.call('del'&lt;span&gt;, lockKey)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result_2
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;演示&lt;/h3&gt;
&lt;p&gt;　　为了演示方便，我把失效时间设置短一点，8秒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202008/1504448-20200822000116676-465132010.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;嫖都嫖完了，难道你忍心不点赞关注嘛&lt;/strong&gt;&lt;/span&gt;，O(∩_∩)O哈哈~~~~~今天，先到这，&lt;span&gt;&lt;strong&gt;后续&lt;/strong&gt;&lt;/span&gt;继续&lt;span&gt;&lt;strong&gt;写Redis秒杀系统的设计&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;案例源码下载&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/1uVoRQs8K3_zTfHXSTeP0uA  密码: k9sv
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 21 Aug 2020 16:46:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 大家都听过1万小时定律，可事实真的是这样吗？做了1万小时的CRUD，不还只会CRUD吗，这年头不适当的更新自身下技术栈，出门和别人聊天吹牛的时候，都没拿不出手，(⊙o⊙)…Redis没入门的童鞋</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/13506946.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列（四）：Spring Boot源码解析 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/13543780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/13543780.html</guid>
<description>&lt;h2&gt;一、自动装配原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821204803348-671894779.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　之前博文已经讲过，@SpringBootApplication继承了@EnableAutoConfiguration，该注解导入了AutoConfigurationImport Selector，这个类主要是扫描spring-boot-autoconfigure下面的META-INF\spring.factories中的EnableAutoConfiguration对应的全类名，其中XXXAutoConfiguration都是一个个自动配置类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821205933639-514863178.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　自动装配原理具体参考：&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/13521019.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Spring Boot系列（二）：Spring Boot自动装配原理解析&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、Spring Boot的jar启动&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　1、Spring Boot自动装配Tomcat组件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;① EmbeddedWebServerFactoryCustomizerAutoConfiguration内嵌的Web容器工厂定制器自动装配类，装配了TomcatWebServerFactoryCustomizer组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821211408828-1371075312.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　Tomcat工厂定制器TomcatWebServerFactoryCustomizer用来设置容器的属性，把ServerProperties中的属性设置到Tomcat容器的工厂中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821213451427-1185774617.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　ServerProperties服务的属性类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821213615131-1070847695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;② ServletWebServerFactoryAutoConfiguration，ServletWeb工厂自动装配类，装配了如下四个组件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ServletWebServerFactoryCustomizer：用来定制ServletWeb服务工厂&lt;/li&gt;
&lt;li&gt;TomcatServletWebServerFactoryCustomizer：用来定制TomcatServletWeb服务工厂&lt;/li&gt;
&lt;li&gt;ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar ：后置处理器&lt;/li&gt;
&lt;li&gt;ServletWebServerFactoryConfiguration：用来配置TomcatServletWeb服务工厂&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821214733248-1886470668.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　2、SpringApplication.run启动流程&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;① new SpringApplication(primarySources)，创建了一个SpringApplication&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;&lt;span&gt;... primarySources) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.resourceLoader =&lt;span&gt; resourceLoader;
        Assert.notNull(primarySources, &lt;/span&gt;&quot;PrimarySources must not be null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置主配置类 我们自己写的Spring Boot的启动类&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.primarySources = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(Arrays.asList(primarySources));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置web应用的类型&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.webApplicationType =&lt;span&gt; WebApplicationType.deduceFromClasspath();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置容器初始化器(ApplicationContextInitializer类型的)&lt;/span&gt;
        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把监听器设置到SpringApplication中[ApplicationListener]&lt;/span&gt;
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置主配置类&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.mainApplicationClass =&lt;span&gt; deduceMainApplicationClass();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;② SpringApplication的run方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;主要流程：&lt;/p&gt;
&lt;p&gt;　　第一：创建容器对象&lt;/p&gt;
&lt;p&gt;　　第二：去META-INFO/spring.factories中获取SpringApplicationRunListener监听器(事件发布监听器)&lt;/p&gt;
&lt;p&gt;　　第三：发布容器starting事件(通过spring的事件多播器)&lt;/p&gt;
&lt;p&gt;　　第四：封装命令行参数&lt;/p&gt;
&lt;p&gt;　　第五：准备容器环境&lt;/p&gt;
&lt;p&gt;　　第六：打印Springboot的图标&lt;/p&gt;
&lt;p&gt;　　第七：根据webApplicationType来创建容器&lt;/p&gt;
&lt;p&gt;　　第八：准备容器上下文&lt;/p&gt;
&lt;p&gt;　　第九：发布容器启动事件&lt;/p&gt;
&lt;p&gt;　　第十：发布容器运行事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();
        stopWatch.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器对象&lt;/span&gt;
        ConfigurableApplicationContext context = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Collection&lt;/span&gt;&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        configureHeadlessProperty();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去META-INFO/spring.factories中获取SpringApplicationRunListener监听器(事件发布监听器)&lt;/span&gt;
        SpringApplicationRunListeners listeners =&lt;span&gt; getRunListeners(args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布容器starting事件(通过spring的事件多播器)&lt;/span&gt;
&lt;span&gt;        listeners.starting();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装命令行参数&lt;/span&gt;
            ApplicationArguments applicationArguments = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultApplicationArguments(args);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 准备容器环境
             * 1: 获取或者创建环境
             * 2：把命令行参数设置到环境中
             * 3：通过监听器发布环境准备事件
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            ConfigurableEnvironment environment &lt;/span&gt;=&lt;span&gt; prepareEnvironment(listeners, applicationArguments);
            configureIgnoreBeanInfo(environment);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印Springboot的图标&lt;/span&gt;
            Banner printedBanner =&lt;span&gt; printBanner(environment);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建容器根据webApplicationType来创建容器(通过反射创建)&lt;/span&gt;
            context =&lt;span&gt; createApplicationContext();
            exceptionReporters &lt;/span&gt;= getSpringFactoriesInstances(SpringBootExceptionReporter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class[] { ConfigurableApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; }, context);
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * 准备上下文
             * 1：把环境设置到容器中
             * 2: 循环调用ApplicationContextInitializer进行容器初始化工作
             * 3: 发布容器上下文准备完成事件
             * 4: 注册关于Springboot特性的相关单例Bean
             * 5: 发布容器上下文加载完毕事件
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            prepareContext(context, environment, listeners, applicationArguments, printedBanner);
            refreshContext(context);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行ApplicationRunner和CommandLineRunner&lt;/span&gt;
&lt;span&gt;            afterRefresh(context, applicationArguments);
            stopWatch.stop();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StartupInfoLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布容器启动事件&lt;/span&gt;
&lt;span&gt;            listeners.started(context);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行ApplicationRunner和CommandLineRunner&lt;/span&gt;
&lt;span&gt;            callRunners(context, applicationArguments);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出现异常调用异常分析保护类进行分析&lt;/span&gt;
&lt;span&gt;            handleRunFailure(context, ex, exceptionReporters, listeners);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布容器运行事件&lt;/span&gt;
&lt;span&gt;            listeners.running(context);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;③ org.springframework.boot.SpringApplication#refreshContext&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　④ org.springframework.boot.SpringApplication#refresh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　⑤ org.springframework.context.support.AbstractApplicationContext#refresh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;到了AbstractApplicationContext#refresh方法，之前讲过Spring IoC源码解析讲过该方法的12大步，这里就不细说，详细可以参考：&lt;a href=&quot;https://www.cnblogs.com/toby-xu/p/11324776.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;Spring系列（三）：Spring IoC源码解析&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;，里面说过有一步就是onRefresh()，这个方法默认是空的，由子类根据自身需要去实现&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;⑥ org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;该onRefresh方法分2步&lt;/p&gt;
&lt;p&gt;　　第一：super.onRefresh(); 调用父类的onRefresh()&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第二：createWebServer()；创建Web服务，很重要，很重要，很重要！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;⑦ createWebServer()方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;第一：ServletContext servletContext = getServletContext(); 获取Servlet的上下文&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　第二：ServletWebServerFactory factory = getWebServerFactory();获取Tomcat的Web服务工厂&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　第三：this.webServer = factory.getWebServer(getSelfInitializer()); 创建一个Web服务器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821223437206-908479962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;⑧ TomcatServletWebServerFactory#getWebServer()方法，主要用于创建一个Tomcat Web容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821223651349-410976477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;到此我们知道Spring Boot的启动通过Spring IoC的refresh中的的onRefresh()带动了Tomcat的启动，跟我们之前我们学Spring Mvc的时候刚好相反，Spring Mvc的是Tomcat的启动带动了Spring容器的启动；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、普通Web工程启动&lt;/h2&gt;
&lt;h3&gt;　　1、普通的web工程，我们找到web.xml，会发现都配置了如下的加载Spring的配置。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821224058143-974325961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　2、Tomcat启动的时候会调用该上下文加载的的监听器的contextInitialized方法，我们进入到该方法：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821224337446-1521130556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 　　3、进入初始化Web应用上下文initWebApplicationContext方法中：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;this.context = createWebApplicationContext(servletContext);&lt;/li&gt;
&lt;li&gt;configureAndRefreshWebApplicationContext(cwac, servletContext);&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;　　4、进去到&lt;/strong&gt;configureAndRefreshWebApplicationContext(cwac, servletContext)方法中：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821224944942-7995248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; 　　5、进入到refresh方法实际就到了org.springframework.context.support.AbstractApplicationContext#refresh的方法&lt;/h3&gt;
&lt;p&gt;　　这个方法很熟悉了，Spring IoC的refresh的12大步；&lt;/p&gt;
&lt;h2&gt;四、Spring Boot启动流程图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1761778/202008/1761778-20200821234723342-154422864.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 15:51:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、自动装配原理 之前博文已经讲过，@SpringBootApplication继承了@EnableAutoConfiguration，该注解导入了AutoConfigurationImport Se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/13543780.html</dc:identifier>
</item>
<item>
<title>Python 为什么没有 void 关键字？ - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/13543884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/13543884.html</guid>
<description>&lt;p&gt;&lt;code&gt;void&lt;/code&gt; 是编程语言中最常见的关键字之一，从字面上理解，它是“空的、空集、空白”的意思，&lt;strong&gt;最常用于&lt;/strong&gt; 表示函数的一种返回值类型。&lt;/p&gt;
&lt;p&gt;维基百科上有一个定义：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;The void type, in several programming languages derived from C and Algol68, is the type for the result of a function that returns normally, but does not provide a result value to its caller.&lt;/p&gt;
&lt;p&gt;在 C、Algol68 及它们所派生的几种编程语言中，void 类型是函数正常返回的一种类型，但是不会给调用者返回一个值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单来说，void 是一种类型（type），但是没有具体的值（value）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这到底是什么意思呢？&lt;/p&gt;
&lt;p&gt;以 Python 的几种常见类型为例，我们可以从对比中看出规律：int 是一种表示整数的类型，它有无限个可能的整数值；bool 是一种布尔类型，它有两个可能的值（True 和 False）；NoneType 是一种表示 None 的类型，它只有一个值（None）。&lt;/p&gt;
&lt;p&gt;至于 void，它是一种更为抽象的特殊类型，但是不包含任何值。&lt;/p&gt;
&lt;p&gt;介绍完概念上的含义，我们就可以进入正题了。标题中的问题可以进一步分解成两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;其它语言为什么要使用 void 关键字？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 为什么不设计出 void 关键字？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于第一个问题，我们以 C/C++ 为例，先看看 void 的两种使用场景（PS：此处只考虑函数的用法，不考虑指针的用法，因为 Python 没有指针）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1ghxnocqx7uj20w0066mxe.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 void 用在函数的参数位置时，它表示该函数不需要传参。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初 C 语言的&lt;code&gt;f()&lt;/code&gt; 表示参数数量不确定，为了另外表达“不需要参数”的语义，所以引入&lt;code&gt;f(void)&lt;/code&gt; 作为限定。后来的语言（包括 Python）基本不在参数中使用 void，而是直接用&lt;code&gt;f()&lt;/code&gt; 表示不需传参。C++ 为了兼容 C，所以才同时支持这两种语法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 void 用在函数前作修饰时，它表示该函数没有返回值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 C 语言中，若不声明返回类型，则&lt;code&gt;f()&lt;/code&gt; 函数在编译后会返回整型的值。为了避免混乱，当不需要返回值时，就使用&lt;code&gt;void f()&lt;/code&gt; 来作限定。&lt;/p&gt;
&lt;p&gt;同时，更主要的是，它还起到了占位符的作用，表明一个函数的类型是已知的，这对代码可读性和编译都有所帮助。&lt;/p&gt;
&lt;p&gt;void 作为函数的空返回值类型，这种用法在 C++/Java 中也被继承了。另外，在 Javascript 中也有 void 的身影，只不过它成了一种操作符，起到了完全不同的作用，此处不表。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;Python 从头到尾都没有 void 关键字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么会这样？难道是因为在 Python 中不存在其它语言所面对的问题么？还是说，Python 中有自己的一套解决方案？&lt;/p&gt;
&lt;p&gt;仍以跟函数相关的两种用法为例作分析吧。&lt;/p&gt;
&lt;p&gt;在表示函数不需传参时，&lt;code&gt;f(void)&lt;/code&gt; 这种写法根本就是多余的，所以 Python 使用了最简单明了的无参式写法&lt;code&gt;f()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;至于返回值类型的用法，在我们定义出一个函数时，例如最简单的&lt;code&gt;def func():pass&lt;/code&gt; ，为了让它的调用结果&lt;code&gt;func()&lt;/code&gt; 是一个合法的对象，那它必须具有一个有效的类型（type）。&lt;/p&gt;
&lt;p&gt;这应该是以类型为基的编程语言都会遇到的共性问题，Python 也不例外。&lt;/p&gt;
&lt;p&gt;这个时候，如果函数本身没有显式地 return 出一个对象的话，就有两种可能的解决办法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方法一，即声明该函数为 void 类型，像 C 和其它语言所做的那样，只要能通过类型检查即可&lt;/li&gt;
&lt;li&gt;方法二，则是 Python 所用的方法，即令解释器隐式地返回一个 None 对象，也就是令函数默认得到一个 NoneType 类型，再用于类型检查（PS：Javascript 也类似，只不过它默认返回的是 undefined，它不是一个对象，而是一种表示“未定义”的类型，类似于 void）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;简单而言，Python 的设计思路是直接复用已有的 NoneType 类型，并让解释器来填补缺失掉的函数类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 Python 解释器的这个隐式填补过程，我已在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/e31XEz7z2Wl2jZaaYYGgbA&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;》文章详细分析过，感兴趣的同学可去查阅。&lt;/p&gt;
&lt;p&gt;这样做的好处至少有两点：&lt;strong&gt;一是没有引入新的 void 类型和关键字；二是不需要程序员在函数前声明返回类型，这就跟有显式返回值的写法保持了一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;试想一下，如果 Python 不让函数默认有返回值的话，就可能要写成 &lt;code&gt;void def func():...&lt;/code&gt; 这样的形式，那它就变成了函数定义时的一种特例。与另一种特例函数相比，即异步函数&lt;code&gt;asyc def func():...&lt;/code&gt; ，就可能引起混乱。&lt;/p&gt;
&lt;p&gt;总体而言，Python 似乎认为 void 空类型不是那么有存在的必要，似乎 NoneType 类型就足够了，而当缺少返回值时，让解释器统一注入是极为方便的，因此才出现了我们看到的现状。&lt;/p&gt;
&lt;p&gt;至此，文章标题的问题算是圆满回答了。&lt;/p&gt;
&lt;p&gt;最后，让我们开始进入 ending 吧：本文明面上是以“Python 为什么没有 void 关键字”为切入点，然而，它实际上瞄准的却是“Python 为什么需要返回 None”的问题。&lt;/p&gt;
&lt;p&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s/e31XEz7z2Wl2jZaaYYGgbA&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;》这篇文章中，我介绍了 Python 中函数默认返回 None 的机制，它是属于“how can”的内容。但是为什么要默认返回 None 呢？这则是属于“why need”或者“why should”的问题，而它需要从 void 关键字的缺失开始谈起……&lt;/p&gt;
&lt;p&gt;那么，为什么 Python 没有 void 关键字呢？请往上翻，重新阅读本文……&lt;/p&gt;
&lt;p&gt;本文属于“Python为什么”系列（Python猫出品），该系列主要关注 Python 的语法、设计和发展等话题，以一个个“为什么”式的问题为切入点，试着展现 Python 的迷人魅力。所有文章将会归档在 Github 上，项目地址：&lt;a href=&quot;https://github.com/chinesehuazhou/python-whydo&quot;&gt;https://github.com/chinesehuazhou/python-whydo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 15:35:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>void 是编程语言中最常见的关键字之一，从字面上理解，它是“空的、空集、空白”的意思，最常用于 表示函数的一种返回值类型。 维基百科上有一个定义： The void type, in several</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/13543884.html</dc:identifier>
</item>
<item>
<title>Dubbo直连方式 - 山丘i</title>
<link>http://www.cnblogs.com/mengd/p/13543836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengd/p/13543836.html</guid>
<description>&lt;h2 id=&quot;一、dubbo概述&quot;&gt;一、dubbo概述&lt;/h2&gt;
&lt;p&gt;Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向接口的远程方法调用，&lt;/li&gt;
&lt;li&gt;智能容错和负载均衡，&lt;/li&gt;
&lt;li&gt;服务自动注册和发现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案、 服务治理方案。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://dubbo.apache.org/zh-cn/&quot;&gt;http://dubbo.apache.org/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231332620-1627733466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;面向接口代理：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用接口的方法，在 A 服务器调用 B 服务器的方法，由 dubbo 实现对 B 的调用，无需关心实现的细节，就像 MyBatis 访问 Dao 的接口，可以操作数据库一样。不用关心 Dao 接口方法的实现&lt;/p&gt;
&lt;h3 id=&quot;1-基本架构&quot;&gt;1. 基本架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231338035-1761068831.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务提供者（Provider）&lt;/strong&gt;：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。&lt;br/&gt;&lt;strong&gt;服务消费者（Consumer ）&lt;/strong&gt;: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;br/&gt;&lt;strong&gt;注册中心（Registry）&lt;/strong&gt; ：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者&lt;br/&gt;&lt;strong&gt;监控中心（Monitor）&lt;/strong&gt; ：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心&lt;/p&gt;
&lt;p&gt;&lt;code&gt;调用关系说明&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务容器负责启动，加载，运行服务提供者&lt;/li&gt;
&lt;li&gt;服务提供者在启动时，向注册中心注册自己提供的服务&lt;/li&gt;
&lt;li&gt;服务消费者在启动时，向注册中心订阅自己所需的服务&lt;/li&gt;
&lt;li&gt;注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者&lt;/li&gt;
&lt;li&gt;服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用&lt;/li&gt;
&lt;li&gt;服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;2-dubbo-支持的协议&quot;&gt;2. dubbo 支持的协议&lt;/h3&gt;
&lt;p&gt;支持多种协议：dubbo , hessian , rmi , http, webservice , thrift , memcached , redis。dubbo 官方推荐使用 dubbo 协议。dubbo 协议默认端口 20880&lt;br/&gt;使用 dubbo 协议，spring 配置文件加入：&lt;br/&gt;&lt;code&gt;&amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、直连方法&quot;&gt;二、直连方法&lt;/h2&gt;
&lt;p&gt;点对点的直连项目：消费者直接访问服务提供者，没有注册中心。消费者必须指定服务提供者的访问地址（url）&lt;/p&gt;
&lt;p&gt;消费者直接通过 url 地址访问固定的服务提供者。这个 url 地址是不变的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231349482-1478822148.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、创建服务提供者&quot;&gt;三、创建服务提供者&lt;/h2&gt;
&lt;h3 id=&quot;1-思路&quot;&gt;1. 思路&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建一个maven web工程:服务的提供者&lt;/li&gt;
&lt;li&gt;创建一个实体bean查询的结果，实现Serializable接口&lt;/li&gt;
&lt;li&gt;提供一个服务接口:xxxx&lt;/li&gt;
&lt;li&gt;实现这个服务接口:xxxxImpl&lt;/li&gt;
&lt;li&gt;配置dubbo服务提供者的核心配置文件
&lt;ul&gt;&lt;li&gt;声明dubbo服务提供者的名称:保证唯一&lt;/li&gt;
&lt;li&gt;声明dubbo使用的协议和端口号&lt;/li&gt;
&lt;li&gt;暴露服务,使用直连方式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;添加监听器&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1-创建maven-web&quot;&gt;1. 创建maven web&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231359166-101954944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并添加对应的目录&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231405651-1047125032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-pomxml&quot;&gt;2. pom.xml&lt;/h3&gt;
&lt;p&gt;添加了dubbo依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;com.md&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;01-link-userservice-provider&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;



  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;


    &amp;lt;!--spring依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;


    &amp;lt;!--dubbo依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.6.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;&amp;lt;!--所在的目录--&amp;gt;
        &amp;lt;includes&amp;gt;&amp;lt;!--包括目录下的.properties,.xml 文件都会扫描到--&amp;gt;
          &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
          &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
        &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
      &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-创建实体&quot;&gt;3. 创建实体&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.md.dubbo.model;

import java.io.Serializable;

/**
 * @author MD
 * @create 2020-08-16 21:30
 */
// model实现序列化
public class User implements Serializable {

    private Integer id;

    private String username;

    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-创建服务接口并实现&quot;&gt;4. 创建服务接口并实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.md.dubbo.service;

import com.md.dubbo.model.User;

/**
 * @author MD
 * @create 2020-08-16 21:35
 */
public interface UserService {

    /**
     * 根据用户标识获取用户信息
     * @param id
     * @return
     */
    User queryUserById(Integer id);
}
//---------------------------------------
package com.md.dubbo.service.impl;

import com.md.dubbo.model.User;
import com.md.dubbo.service.UserService;

/**
 * @author MD
 * @create 2020-08-16 21:38
 */

public class UserServiceImpl implements UserService {
    @Override
    public User queryUserById(Integer id) {

        // 模拟
        User user = new User();
        user.setId(id);
        user.setUsername(&quot;pony&quot;);
        user.setAge(20);
        return user;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-配置服务提供者的核心配置文件&quot;&gt;5. 配置服务提供者的核心配置文件&lt;/h3&gt;
&lt;p&gt;在resources目录下建立dubbo-userservice-provider.xml文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231421055-751456521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里注意：选择apache的这个&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&amp;gt;

    &amp;lt;!--服务提供者声明名称：必须保证服务名称唯一，他的名称是dubbo内部使用的唯一标识,用项目名就行--&amp;gt;
    &amp;lt;dubbo:application name=&quot;01-link-userservice-provider&quot;/&amp;gt;

    &amp;lt;!--访问服务协议的名称及端口号
        name：指定协议名称
        port：指定协议端口号(默认20880)
    --&amp;gt;
    &amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&amp;gt;

    &amp;lt;!--
        暴露服务接口
        interface：暴露服务接口的全限定类名
        ref：接口引用的实现类在spring容器中的标识
        registry：如果不使用注册中心，则值为N/A，直连
    --&amp;gt;
    &amp;lt;dubbo:service interface=&quot;com.md.dubbo.service.UserService&quot; ref=&quot;userService&quot; registry=&quot;N/A&quot;/&amp;gt;

    &amp;lt;!--将接口的实现类加载到Spring容器中--&amp;gt;
    &amp;lt;bean id=&quot;userService&quot; class=&quot;com.md.dubbo.service.impl.UserServiceImpl&quot;/&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-添加监听器&quot;&gt;6. 添加监听器&lt;/h3&gt;
&lt;p&gt;在web.xml中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

&amp;lt;!--默认的版本低的话换成这个版本的，直接复制即可--&amp;gt;

  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;classpath:dubbo-userservice-provider.xml&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;

  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;

&amp;lt;/web-app&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7-配置tomcat&quot;&gt;7. 配置Tomcat&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;端口号注意修改一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP port ：8081&lt;/p&gt;
&lt;p&gt;JMX port：1098&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231432845-240837699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;8-安装本地jar到maven仓库&quot;&gt;8. 安装本地jar到maven仓库&lt;/h3&gt;
&lt;p&gt;服务接口中的方法要给消费者使用，消费者项目需要知道接口名称和接口中的方法名称、参数等。这些信息服务提供者才知道。需要把接口的 class 文件打包为 jar .&lt;br/&gt;服务接口项目的类文件打包为 jar， 安装到 maven 仓库，仓库中的提供者 jar 可以被消费者使用。&lt;br/&gt;&lt;code&gt;使用 idea 的 maven 窗口执行 install&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231439108-690020212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、创建服务消费者&quot;&gt;四、创建服务消费者&lt;/h2&gt;
&lt;h3 id=&quot;1-思路-2&quot;&gt;1. 思路&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建一个maven web工程:服务的消费者&lt;/li&gt;
&lt;li&gt;配置pom文件:添加需要的依赖(spring,dubbo)&lt;/li&gt;
&lt;li&gt;设置dubbo的核心配置文件&lt;/li&gt;
&lt;li&gt;编写controller&lt;/li&gt;
&lt;li&gt;配置中央调度器(就是一个servlet:DispatcherServlet)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基本和服务提供者一样，这里就说一些主要的&lt;/p&gt;
&lt;h3 id=&quot;1-pomxml&quot;&gt;1. pom.xml&lt;/h3&gt;
&lt;p&gt;还是maven web项目&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意：添加了服务提供者的依赖&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;com.md&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;02-link-consumer&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;



  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--spring依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.16.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--dubbo依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.6.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--依赖服务提供者--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.md&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;01-link-userservice-provider&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;


  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;&amp;lt;!--所在的目录--&amp;gt;
        &amp;lt;includes&amp;gt;&amp;lt;!--包括目录下的.properties,.xml 文件都会扫描到--&amp;gt;
          &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
          &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
        &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
      &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-配置服务消费者的核心配置文件&quot;&gt;2. 配置服务消费者的核心配置文件&lt;/h3&gt;
&lt;p&gt;在resources目录下建立dubbo-consumer.xml文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&amp;gt;

    &amp;lt;!--声明服务消费者名称：保证唯一性--&amp;gt;
    &amp;lt;dubbo:application name=&quot;02-link-consumer&quot;/&amp;gt;


    &amp;lt;!--
        引用远程服务接口:
        id:远程服务接口对象名称
        interface:调用远程接口的全限定类名
        url:访问服务接口的地址
        registry:不使用注册中心,值为:N/A
    --&amp;gt;
    &amp;lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.md.dubbo.service.UserService&quot;
                     url=&quot;dubbo://localhost:20880&quot; registry=&quot;N/A&quot;/&amp;gt;


&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-controller&quot;&gt;3. controller&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.md.dubbo.web;

import com.md.dubbo.model.User;
import com.md.dubbo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * @author MD
 * @create 2020-08-19 9:00
 */

@Controller
public class UserController {

    // 自动注入
    @Autowired
    private UserService userService;

    @RequestMapping(value = &quot;/user&quot;)
    public String userDetail(Model model , Integer id){
        User user = userService.queryUserById(id);
        model.addAttribute(&quot;user&quot;,user);
        return &quot;userDetail&quot;;

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-applicationcontextxml&quot;&gt;4. applicationContext.xml&lt;/h3&gt;
&lt;p&gt;在resources目录下创建spring配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&amp;gt;

    &amp;lt;!--扫描组件--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.md.dubbo.web&quot;/&amp;gt;

    &amp;lt;!--配置注解驱动--&amp;gt;
    &amp;lt;mvc:annotation-driven/&amp;gt;

    &amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
        &amp;lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&amp;gt;
        &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&amp;gt;

    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-配置中央调度器&quot;&gt;5. 配置中央调度器&lt;/h3&gt;
&lt;p&gt;在web.xml中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;
  &amp;lt;!--中央调度器--&amp;gt;


  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;

    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;classpath:applicationContext.xml,classpath:dubbo-consumer.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;

  &amp;lt;/servlet&amp;gt;


  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;


&amp;lt;/web-app&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-配置tomcat&quot;&gt;6. 配置Tomcat&lt;/h3&gt;
&lt;p&gt;和上面一样，只不过不用修改端口号了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231512594-77540775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-配置测试页面&quot;&gt;7. 配置测试页面&lt;/h3&gt;
&lt;p&gt;在webapp下 建立userDetail.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-jsp&quot;&gt;&amp;lt;%--
  Created by IntelliJ IDEA.
  User: MD
  Date: 2020/8/19
  Time: 9:06
  To change this template use File | Settings | File Templates.
--%&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;用户详情&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;用户详情&amp;lt;/h1&amp;gt;
&amp;lt;div&amp;gt;用户标识：${user.id}&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;用户名称：${user.username}&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;用户年龄：${user.age}&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;8-测试&quot;&gt;8. 测试&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先开服务提供者的Tomcat&lt;/li&gt;
&lt;li&gt;然后开服务消费者的Tomcat&lt;/li&gt;
&lt;li&gt;然后在地址栏输入，就可以看到了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1212924/202008/1212924-20200821231519260-136939772.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 15:16:00 +0000</pubDate>
<dc:creator>山丘i</dc:creator>
<og:description>一、dubbo概述 Apache Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力： 面向接口的远程方法调用， 智能容错和负载均衡， 服务自动注册和发现。 Dubb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengd/p/13543836.html</dc:identifier>
</item>
<item>
<title>Azure Kubernetes Service 入门 - Grant_Allen</title>
<link>http://www.cnblogs.com/AllenMaster/p/13541680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AllenMaster/p/13541680.html</guid>
<description>&lt;h2&gt;一，引言&lt;/h2&gt;
&lt;p&gt;　　上一节，我们使用Azure CLI 创建了Azure Resource Group 和 Azure Container Registry 资源，并且将本地的一个叫 “k8s.net.demo”的 images 推送到远端创建的私有的Docker Image Repo,今天接着上一篇我们学习一下Azure Kubernetes 服务，通过 Azure Portal 创建 Azure Kubernetes Service，并且希望将 Push 上去的Docker Image 部署到Azure Kubernetes 集群中&lt;/p&gt;
&lt;p&gt;　　Azure Kubernetes Service 简称AKS，它托管的Kubernetes 环境，可以使我们在Azure中很轻松的部署和管理容器话的应用程序。AKS环境启用了自动更新，自愈和自动缩放等功能。Kubernetes 的集群主机由Azure 免费管理，创建AKS服务的时候，我们可以将集群主机交由Aure进行托管，另外一种是我们在创建的时候，将我们自己创建好的VMSS挂载到AKS服务上。我们只需要为节点所在其上运行的VM付费即可。&lt;/p&gt;
&lt;p&gt;　　接下来，我们看看当前基础设施架构图&lt;/p&gt;
&lt;p&gt;--------------------我是分割线--------------------&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821162016094-1209751570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;--------------------我是分割线--------------------&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link-post-title&quot; href=&quot;https://www.cnblogs.com/AllenMaster/p/13518676.html&quot;&gt;Azure Command Line 创建 Azure Container Registry 服务&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二，正文&lt;/h2&gt;
&lt;h3&gt;1，创建Azure Kubernetes Service&lt;/h3&gt;
&lt;p&gt;Azure Portal 点击 “Create a resource”，在搜索框中输入 “Kubernetes Service”，进行搜索，点击 “Create”&lt;/p&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821162756487-841604574.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;Resource group 选择创建一个新的 “Web_Test_AKS_RG”&lt;/p&gt;
&lt;p&gt;Kubernetes cluster name：“cnbateblogwebCluster”&lt;/p&gt;
&lt;p&gt;Region 选择：“East Asia”&lt;/p&gt;
&lt;p&gt;Node count 改为 “1”&lt;/p&gt;
&lt;p&gt;点击 “Next：Node pools &amp;gt;”,进行设置节点池等信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821163432487-763274028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们如果想增加多个工作节点的话，可以选择 点击 “Add node pool”&lt;/p&gt;
&lt;p&gt;VM scale sets 选择：“Enabled”&lt;/p&gt;
&lt;p&gt;点击 “Next：Authentication &amp;gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821164257812-369153269.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 “Authentication method” 我们选择默认的 “Service principal”&lt;/p&gt;
&lt;p&gt;其他的都选择默认选项，点击 “Next：Networking &amp;gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821164719087-606608298.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 接下来我们进行配置网络信息，我们可以选择默认，也可以选择自定义的网络设计&lt;/p&gt;
&lt;p&gt;Network configuration 选择：“Advanced”&lt;/p&gt;
&lt;p&gt;Virtual network 选择创建新的，如下图所示&lt;/p&gt;
&lt;p&gt;Name：“CnBateBlogWeb_VNET”&lt;/p&gt;
&lt;p&gt;Address space：“10.0.0.0/8”&lt;/p&gt;
&lt;p&gt;Subnet name：“CnBateBlogWeb_AKS_SubNET”&lt;/p&gt;
&lt;p&gt;点击 “OK”，继续配置其他信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821165559902-475413807.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes service address range：“10.0.2.0/24”&lt;/p&gt;
&lt;p&gt;Kubernetes DNS service IP address：“10.0.2.10”&lt;/p&gt;
&lt;p&gt;其他的配置选择默认即可，点击“Next：Integrations &amp;gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821170003225-1958671796.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启容器监控，继续点击 “Review + create”，进行创建前的预校验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821170100612-904614268.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到 验证已通过，点击 “Create” 进行创建 AKS 服务&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821170253533-1816736347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功后，我们可以跳转到该资源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821172206241-225376523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821172209264-713468267.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2，为Azure Kubernetes Service 配置 Azure Container Registry 集成&lt;/h3&gt;
&lt;p&gt;找到上次创建好的叫 “cnbateblogwebACR” 的 Azure Container Registry&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821175435537-1922875946.png&quot; alt=&quot;&quot; width=&quot;1214&quot; height=&quot;456&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 “Access control（IAM）” ，选择 “Role assignments”，点击 “Add”,添加一个角色分配&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821175847553-1309809514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Role 选择：“AcrPull”&lt;/p&gt;
&lt;p&gt;Assign access to 选择：“Azure AD user,group,or service principal”&lt;/p&gt;
&lt;p&gt;Select 选择刚刚创建AKS 的时候,在AD中自动注册的App &lt;/p&gt;
&lt;p&gt;我们点击 ”Save“,进行保存操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821182204900-1683901078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821183354705-2079098338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;最后一步，我们使用kubectl连接到集群上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
az aks get-credentials --resource-group Web_Test_AKS_RG --name cnbateblogwebCluster
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821212519149-597388834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;3，Azure Portal 中创建pod&lt;/h3&gt;
&lt;p&gt;Azure Portal 中找到创建好的 aks 服务，选择 “Workloads（preview）” ，切换到 “Pods” 的Tab页，我们可以看到一些默认的pod，当然这些pod的命名空间都是kube-system，不是我们需要的default的命令空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821212824521-1056119998.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时，我们也可以通过kubectl 客户端命令进行查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821213415640-600155848.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们点击 “+Add ” 进行创建pod信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821213533842-922333169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;输入创建 pod 的描述文件，点击 “Add” 按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821214120511-543579652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完整yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod 
metadata:
  name: k8s-net-demo 
  labels: 
    app: k8s-net-demo
spec: 
  containers: 
    - name: k8s-net-demo
      image: cnbateblogwebacr.azurecr.io/k8s.net.demo:v1
      imagePullPolicy: IfNotPresent 
      ports:
        - containerPort: 80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回到Azure Portal 中，我们可以看到已经创建好的 k8s-net-demo 的pod 已经创建好了，状态也是 running&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821214714264-1745981179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821214819138-35963663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4，访问 pod 中的容器&lt;/h3&gt;
&lt;p&gt; 想要与pod 进行通信，可以通过 kubectl port-forward 配置端口转发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl port-forward k8s-net-demo &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821215331317-309349954.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 浏览器访问 http://127.0.0.1:8080，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821215554524-568669826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，我们成功的将 pod 跑起来了&lt;/p&gt;
&lt;h3&gt;5，使用service描述文件将 Pod 进行暴露&lt;/h3&gt;
&lt;p&gt;选择“Services and ingresses（preview）”,点击 “Add”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821221802103-124050812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们继续使用 service 藐视文件进行创建，这次 Kind（定义Kubernetes资源类型为Service)的类型为 “Service”，type 为 “LoadBalancer”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821222007317-1310812336.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821221557909-1388740799.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到 名字叫 “k8s-net-service1” 的 Type 为 LoadBalancer，External-ip 为 52.184.83.143  cluster-ip 为 10.0.2.134&lt;/p&gt;
&lt;p&gt;我们可以在集群内部使用 10.0.2.134:30000，如果是在集群外部，可以使用 52.184.83.143:80 进行访问&lt;/p&gt;
&lt;p&gt;浏览器访问 http://52.184.83.143:80，效果如下显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202008/1996262-20200821223517001-65770041.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;bingo，撒花，今天的分析到此完结。&lt;/p&gt;
&lt;h2&gt;三，结尾&lt;/h2&gt;
&lt;p&gt;　　本文，我们创建了AKS服务，并且使用在Azure Portal 上创建属于自己的 pod，并且使用配置端口转发供外界访问，到最后的到了 Service，基本上大家对K8s熟悉的话，上手AKS是非常快的，今天基本上演示了对AKS有了一个基本的认指，下一篇，我们具体讲解以下本篇中使用的一个YAML配置，以及暴露Service的时候，关于LoadBalancer的一些问题。&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/AllenMaster&quot; target=&quot;_blank&quot;&gt;Allen&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;版权：转载请在文章明显位置注明作者及出处。如发现错误，欢迎批评指正。&lt;/p&gt;

</description>
<pubDate>Fri, 21 Aug 2020 14:53:00 +0000</pubDate>
<dc:creator>Grant_Allen</dc:creator>
<og:description>一，引言 上一节，我们使用Azure CLI 创建了Azure Resource Group 和 Azure Container Registry 资源，并且将本地的一个叫 “k8s.net.demo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AllenMaster/p/13541680.html</dc:identifier>
</item>
<item>
<title>Vue管理系统前端系列四组件拆分封装 - Levy-伟</title>
<link>http://www.cnblogs.com/levywang/p/13543734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levywang/p/13543734.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;在上一篇记录中，首页中有太多的代码，为了避免代码的臃肿，需要对主要的功能模块拆分，来让代码看起来更简洁，且能进行复用。&lt;/p&gt;
&lt;p&gt;拆分后还加了些小功能，加入了修改 title 的代码，修改方式参考&lt;a href=&quot;https://www.cnblogs.com/levywang/vue/vue_title.md&quot;&gt;vue 动态修改 title&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;还增加了当前请求的页面缓存，使用状态管理器处理。监听路由，保存到 state 中，来处理的。 如何监听可参考&lt;a href=&quot;https://www.cnblogs.com/levywang/vue/vue_computed_watch.md&quot;&gt;vue 计算属性和监听属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;完整效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1750888/202008/1750888-20200821223530656-2052287661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;拆分后的，布局结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1750888/202008/1750888-20200821223547466-311483498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;布局最外层&lt;/strong&gt; index 代码，使用头部，侧边栏，主内容栏组成，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;!-- 布局的首页 --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;l-header&amp;gt;&amp;lt;/l-header&amp;gt;
        &amp;lt;l-aside&amp;gt;&amp;lt;/l-aside&amp;gt;
        &amp;lt;l-main&amp;gt;&amp;lt;/l-main&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import LHeader from './components/header'
import LAside from './components/aside'
import LMain from './components/main'
export default {
    data() {
        return {}
    },
    //引入组件
    components: {
        LHeader,
        LAside,
        LMain,
    },
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;头部&lt;/strong&gt; &lt;code&gt;index.vue&lt;/code&gt; 代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;!-- 头部文件 --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;header&quot;&amp;gt;
        &amp;lt;!-- logo --&amp;gt;
        &amp;lt;logo&amp;gt;&amp;lt;/logo&amp;gt;
        &amp;lt;!-- 折叠按钮 --&amp;gt;
        &amp;lt;hamburger&amp;gt;&amp;lt;/hamburger&amp;gt;
        &amp;lt;!-- 头部导航栏 --&amp;gt;
        &amp;lt;div class=&quot;heardNavBar&quot;&amp;gt;
            &amp;lt;el-menu default-active=&quot;1&quot; class=&quot;el-menu-demo&quot; background-color=&quot;#4b5f6e&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; mode=&quot;horizontal&quot;&amp;gt;
                &amp;lt;el-menu-item index=&quot;1&quot; @click=&quot;$router.push('/')&quot;&amp;gt;首页&amp;lt;/el-menu-item&amp;gt;
                &amp;lt;el-menu-item index=&quot;2&quot; @click=&quot;openUrl('#')&quot;&amp;gt;使用文档&amp;lt;/el-menu-item&amp;gt;
                &amp;lt;el-menu-item index=&quot;3&quot; @click=&quot;openUrl('https://github.com/levy-w-wang/lion-ui')&quot;&amp;gt;GitHub&amp;lt;/el-menu-item&amp;gt;
            &amp;lt;/el-menu&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;!-- 右侧信息 --&amp;gt;
        &amp;lt;div style=&quot;float:right&quot;&amp;gt;
            &amp;lt;!-- 全屏 --&amp;gt;
            &amp;lt;div style=&quot;float:left;line-height: 60px; padding: 0 10px;&quot;&amp;gt;
                &amp;lt;i class=&quot;el-icon-full-screen&quot; @click=&quot;toggleFull&quot;&amp;gt;&amp;lt;/i&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;!-- 个人信息 --&amp;gt;
            &amp;lt;div class=&quot;userinfo&quot;&amp;gt;
                &amp;lt;el-dropdown trigger=&quot;hover&quot;&amp;gt;
                    &amp;lt;span class=&quot;el-dropdown-link userinfo-inner&quot;&amp;gt;
                        &amp;lt;img src=&quot;@assets/img/user.jpg&quot; /&amp;gt;
                        {{ $store.getters.userInfo.username }}&amp;lt;i class=&quot;el-icon-caret-bottom&quot;&amp;gt;&amp;lt;/i&amp;gt;
                    &amp;lt;/span&amp;gt;
                    &amp;lt;el-dropdown-menu slot=&quot;dropdown&quot;&amp;gt;
                        &amp;lt;el-dropdown-item&amp;gt;
                            &amp;lt;router-link to=&quot;/&quot;&amp;gt;&amp;lt;i class=&quot;el-icon-s-home&quot;&amp;gt;&amp;lt;/i&amp;gt;首页&amp;lt;/router-link&amp;gt;
                        &amp;lt;/el-dropdown-item&amp;gt;
                        &amp;lt;el-dropdown-item&amp;gt;
                            &amp;lt;router-link to=&quot;/&quot;&amp;gt;&amp;lt;i class=&quot;el-icon-s-custom&quot;&amp;gt;&amp;lt;/i&amp;gt;我的主页&amp;lt;/router-link&amp;gt;
                        &amp;lt;/el-dropdown-item&amp;gt;
                        &amp;lt;el-dropdown-item divided&amp;gt;
                            &amp;lt;a @click=&quot;loginOut()&quot;&amp;gt;&amp;lt;i class=&quot;el-icon-switch-button&quot;&amp;gt;&amp;lt;/i&amp;gt;登出&amp;lt;/a&amp;gt;
                        &amp;lt;/el-dropdown-item&amp;gt;
                    &amp;lt;/el-dropdown-menu&amp;gt;
                &amp;lt;/el-dropdown&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import screenfull from 'screenfull'
import hamburger from './hamburger'
import logo from './logo'
// import { mapState } from 'vuex'
export default {
    data() {
        return {}
    },
    computed: {
        // ...mapState({
        //     isCollapse: (state) =&amp;gt; state.app.isCollapse,
        // }),
    },
    //引入组件
    components: {
        hamburger,
        logo,
    },
    // 方法
    methods: {
        openUrl(url) {
            window.open(url)
        },
        loginOut() {
            this.$confirm('确认退出吗?', '提示', {
                type: 'warning',
            })
                .then(() =&amp;gt; {
                    this.$store.commit('logout')
                })
                .catch(() =&amp;gt; {})
        },
        toggleFull() {
            if (!screenfull.isEnabled) {
                this.$message({
                    type: 'warning',
                    message: 'you browser can not work',
                })
                return false
            }
            screenfull.toggle()
        },
    },
    //未挂载DOM,不能访问ref为空数组
    //可在这结束loading，还做一些初始化，实现函数自执行,
    //可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。
    created() {},
    //可在这发起后端请求，拿回数据，配合路由钩子做一些事情；可对DOM 进行操作
    mounted() {},
}
&amp;lt;/script&amp;gt;

&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
.header {
    padding-left: 0px !important;
    height: 60px;
    line-height: 60px;
    width: 100%;
    background: #4b5f6e;
    color: #fff;

    .heardNavBar {
        float: left;
        background: #4b5f6e;
        padding: 0px 0px;
        height: 60px;
        line-height: 60px;
        font-size: 28px;
        cursor: pointer;
    }

    .userinfo {
        text-align: right;
        padding-right: 24px;
        float: right;
        padding: 0 10px;
        .userinfo-inner {
            font-size: 20px;
            cursor: pointer;
            color: #fff;
            img {
                width: 40px;
                height: 40px;
                border-radius: 10px;
                margin: 10px 0px 10px 10px;
                float: right;
            }
        }
    }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;头部中引用的相关组件代码如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;折叠导航栏&lt;/strong&gt; &lt;code&gt;hamburger&lt;/code&gt; 下的 &lt;code&gt;index.vue&lt;/code&gt; 代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;div @click=&quot;toggleCollapse&quot;&amp;gt;
        &amp;lt;svg :class=&quot;{ 'is-active': !isCollapse }&quot; class=&quot;hamburger&quot; viewBox=&quot;0 0 1024 1024&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;64&quot; height=&quot;64&quot;&amp;gt;
            &amp;lt;path d=&quot;M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 0 0 0-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0 0 14.4 7z&quot; /&amp;gt;
        &amp;lt;/svg&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { mapState } from 'vuex'
export default {
    name: 'Hamburger',
    computed: {
        ...mapState({
            isCollapse: (state) =&amp;gt; state.app.isCollapse,
        }),
    },
    methods: {
        //折叠导航栏
        toggleCollapse: function () {
            this.$store.commit('toggleCollapse')
        },
    },
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
.hamburger {
    padding-left: 13px;
    padding-right: 13px;
    text-align: center;
    width: 34px;
    height: 60px;
    line-height: 60px;
    float: left;
    cursor: pointer;
}

.is-active {
    transform: rotate(180deg);
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;折叠导航栏&lt;/strong&gt; &lt;code&gt;logo&lt;/code&gt; 下的 &lt;code&gt;index.vue&lt;/code&gt; 代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;!--  --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;logo&quot; :class=&quot;isCollapse ? 'logo-collapse-width' : 'logo-width'&quot;&amp;gt;
        &amp;lt;img v-if=&quot;isCollapse&quot; src=&quot;@assets/logo6065.png&quot; @click=&quot;$router.push('/')&quot; /&amp;gt;
        &amp;lt;img v-else src=&quot;@assets/logo.png&quot; @click=&quot;$router.push('/')&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { mapState } from 'vuex'
export default {
    data() {
        return {}
    },
    computed: {
        ...mapState({
            isCollapse: (state) =&amp;gt; state.app.isCollapse,
        }),
    },
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
.logo {
    float: left;
    height: 60px;
    padding: 0;
    margin: 0;
}
.logo-width {
    width: 230px;
}
.logo-collapse-width {
    width: 65px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;侧边栏&lt;/strong&gt;下的 &lt;code&gt;index.vue&lt;/code&gt;代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;!-- aside --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;aside-container&quot; :class=&quot;isCollapse ? 'aside-collapse-width' : 'aside-width'&quot;&amp;gt;
        &amp;lt;!--导航菜单  default-active=&quot;1-1&quot;--&amp;gt;
        &amp;lt;el-menu class=&quot;el-menu-vertical-demo&quot; :class=&quot;isCollapse ? 'aside-collapse-width' : 'aside-width'&quot; :collapse-transition=&quot;false&quot; :unique-opened=&quot;true&quot; :collapse=&quot;isCollapse&quot;&amp;gt;
            &amp;lt;el-submenu index=&quot;1&quot;&amp;gt;
                &amp;lt;template slot=&quot;title&quot;&amp;gt;
                    &amp;lt;i class=&quot;el-icon-setting&quot;&amp;gt;&amp;lt;/i&amp;gt;
                    &amp;lt;span slot=&quot;title&quot;&amp;gt;系统管理&amp;lt;/span&amp;gt;
                &amp;lt;/template&amp;gt;
                &amp;lt;el-menu-item index=&quot;1-1&quot; @click=&quot;$router.push('usermanage')&quot;&amp;gt;用户管理&amp;lt;/el-menu-item&amp;gt;
                &amp;lt;el-menu-item index=&quot;1-2&quot; @click=&quot;$router.push('menumanage')&quot;&amp;gt;菜单管理&amp;lt;/el-menu-item&amp;gt;
            &amp;lt;/el-submenu&amp;gt;
            &amp;lt;el-menu-item index=&quot;2&quot; disabled&amp;gt;
                &amp;lt;i class=&quot;el-icon-magic-stick&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;span slot=&quot;title&quot;&amp;gt;导航一&amp;lt;/span&amp;gt;
            &amp;lt;/el-menu-item&amp;gt;
            &amp;lt;el-menu-item index=&quot;3&quot; disabled&amp;gt;
                &amp;lt;i class=&quot;el-icon-reading&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;span slot=&quot;title&quot;&amp;gt;导航二&amp;lt;/span&amp;gt;
            &amp;lt;/el-menu-item&amp;gt;
        &amp;lt;/el-menu&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { mapState } from 'vuex'
export default {
    data() {
        return {}
    },
    //$store.getters.isCollapse
    computed: {
        ...mapState({
            isCollapse: (state) =&amp;gt; state.app.isCollapse,
        }),
        mainTabs: {
            get() {
                return this.$store.state.app.mainTabs
            },
            set(val) {
                this.$store.commit('updateMainTabs', val)
            },
        },
        mainTabsActiveName: {
            get() {
                return this.$store.state.app.mainTabsActiveName
            },
            set(val) {
                this.$store.commit('updateMainTabsActiveName', val)
            },
        },
    },
    watch: {
        $route: 'handleRoute',
    },
    created() {
        console.log(this.$route)
        this.handleRoute(this.$route)
    },
    methods: {
        // 路由操作处理
        handleRoute(route) {
            // tab标签页选中, 如果不存在则先添加
            var tab = this.mainTabs.filter((item) =&amp;gt; item.name === route.name)[0]
            if (!tab) {
                tab = {
                    name: route.name,
                    title: route.meta.title,
                    icon: route.meta.icon,
                }
                this.mainTabs = this.mainTabs.concat(tab)
            }
            this.mainTabsActiveName = tab.name
        },
    },
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
.aside-container {
    position: fixed;
    top: 0px;
    left: 0;
    bottom: 0;
    z-index: 1020;
    .el-menu {
        position: absolute;
        top: 60px;
        bottom: 0px;
        text-align: left;
    }
}
.aside-width {
    width: 230px;
}
.aside-collapse-width {
    width: 65px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;内容模块&lt;/strong&gt;下的 &lt;code&gt;index.vue&lt;/code&gt;代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;!--  --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;main-container clear&quot; :class=&quot;isCollapse ? 'position-collapse-left' : 'position-left'&quot;&amp;gt;
        &amp;lt;!-- 标签页 --&amp;gt;
        &amp;lt;el-tabs class=&quot;tabs&quot; :class=&quot;isCollapse ? 'position-collapse-left' : 'position-left'&quot; v-model=&quot;mainTabsActiveName&quot; :closable=&quot;true&quot; type=&quot;card&quot; @tab-click=&quot;selectedTabHandle&quot; @tab-remove=&quot;removeTabHandle&quot;&amp;gt;
            &amp;lt;el-dropdown class=&quot;tabs-tools&quot; :show-timeout=&quot;0&quot; trigger=&quot;hover&quot;&amp;gt;
                &amp;lt;div style=&quot;font-size:20px;width:50px;&quot;&amp;gt;
                    &amp;lt;i class=&quot;el-icon-arrow-down&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;el-dropdown-menu slot=&quot;dropdown&quot;&amp;gt;
                    &amp;lt;el-dropdown-item @click.native=&quot;tabsCloseCurrentHandle&quot;&amp;gt;关闭当前标签&amp;lt;/el-dropdown-item&amp;gt;
                    &amp;lt;el-dropdown-item @click.native=&quot;tabsCloseOtherHandle&quot;&amp;gt;关闭其它标签&amp;lt;/el-dropdown-item&amp;gt;
                    &amp;lt;el-dropdown-item @click.native=&quot;tabsCloseAllHandle&quot;&amp;gt;关闭全部标签&amp;lt;/el-dropdown-item&amp;gt;
                    &amp;lt;el-dropdown-item @click.native=&quot;tabsRefreshCurrentHandle&quot;&amp;gt;刷新当前标签&amp;lt;/el-dropdown-item&amp;gt;
                &amp;lt;/el-dropdown-menu&amp;gt;
            &amp;lt;/el-dropdown&amp;gt;
            &amp;lt;el-tab-pane v-for=&quot;item in mainTabs&quot; :key=&quot;item.name&quot; :label=&quot;item.title&quot; :name=&quot;item.name&quot;&amp;gt;
                &amp;lt;span slot=&quot;label&quot;&amp;gt; &amp;lt;i :class=&quot;item.icon&quot;&amp;gt;&amp;lt;/i&amp;gt; {{ item.title }} &amp;lt;/span&amp;gt;
            &amp;lt;/el-tab-pane&amp;gt;
        &amp;lt;/el-tabs&amp;gt;

        &amp;lt;!-- 主内容区域 --&amp;gt;
        &amp;lt;div class=&quot;main-content&quot;&amp;gt;
            &amp;lt;keep-alive&amp;gt;
                &amp;lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&amp;gt;
                    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
                &amp;lt;/transition&amp;gt;
            &amp;lt;/keep-alive&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { mapState } from 'vuex'
export default {
    data() {
        return {}
    },
    computed: {
        ...mapState({
            isCollapse: (state) =&amp;gt; state.app.isCollapse,
        }),
        mainTabs: {
            get() {
                return this.$store.state.app.mainTabs
            },
            set(val) {
                this.$store.commit('updateMainTabs', val)
            },
        },
        mainTabsActiveName: {
            get() {
                return this.$store.state.app.mainTabsActiveName
            },
            set(val) {
                this.$store.commit('updateMainTabsActiveName', val)
            },
        },
    },
    methods: {
        // tabs, 选中tab
        selectedTabHandle(tab) {
            tab = this.mainTabs.filter((item) =&amp;gt; item.name === tab.name)
            if (tab.length &amp;gt;= 1) {
                this.$router.push({ name: tab[0].name })
            }
        },
        // tabs, 删除tab
        removeTabHandle(tabName) {
            // 当只有首页时，不允许关掉。 若是其它页面可关掉后，push 首页进去
            if (this.mainTabs.length == 1 &amp;amp;&amp;amp; this.mainTabs[0].name == 'index') {
                return
            }
            this.mainTabs = this.mainTabs.filter((item) =&amp;gt; item.name !== tabName)
            if (this.mainTabs.length &amp;gt;= 1) {
                // 当前选中tab被删除
                if (tabName === this.mainTabsActiveName) {
                    this.$router.push({ name: this.mainTabs[this.mainTabs.length - 1].name }, () =&amp;gt; {
                        this.mainTabsActiveName = this.$route.name
                    })
                }
            } else {
                this.$router.push('/')
            }
        },
        // tabs, 关闭当前
        tabsCloseCurrentHandle() {
            this.removeTabHandle(this.mainTabsActiveName)
        },
        // tabs, 关闭其它
        tabsCloseOtherHandle() {
            this.mainTabs = this.mainTabs.filter((item) =&amp;gt; item.name === this.mainTabsActiveName)
        },
        // tabs, 关闭全部
        tabsCloseAllHandle() {
            this.mainTabs = []
            this.$router.push('/')
        },
        // tabs, 刷新当前
        tabsRefreshCurrentHandle() {
            var tempTabName = this.mainTabsActiveName
            this.removeTabHandle(tempTabName)
            this.$nextTick(() =&amp;gt; {
                this.$router.push({ name: tempTabName })
            })
        },
    },
}
&amp;lt;/script&amp;gt;
&amp;lt;style lang=&quot;scss&quot; scoped&amp;gt;
.main-container {
    padding: 0 5px 5px;
    position: absolute;
    top: 60px;
    left: 1px;
    right: 1px;
    bottom: 0px;
    .tabs {
        position: fixed;
        top: 60px;
        right: 50px;
        padding-left: 0px;
        padding-right: 2px;
        z-index: 1020;
        height: 40px;
        line-height: 40px;
        font-size: 14px;
        background: rgb(255, 253, 255);
        border-color: rgba(200, 206, 206, 0.5);
        // border-left-width: 1px;
        // border-left-style: solid;
        border-bottom-width: 1px;
        border-bottom-style: solid;
    }
    .tabs-tools {
        position: fixed;
        top: 60px;
        right: 0;
        z-index: 1020;
        height: 40px;
        // padding: 0 10px;
        font-size: 14px;
        line-height: 40px;
        cursor: pointer;
        border-color: rgba(200, 206, 206, 0.5);
        border-left-width: 1px;
        border-left-style: solid;
        border-bottom-width: 1px;
        border-bottom-style: solid;
        background: rgba(255, 255, 255, 1);
    }
    .tabs-tools:hover {
        background: rgba(200, 206, 206, 1);
    }
    .main-content {
        position: absolute;
        top: 45px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        padding: 5px;
        // background: rgba(209, 212, 212, 0.5);
    }
}
.position-left {
    left: 230px;
}
.position-collapse-left {
    left: 65px;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;export default {
    state: {
        // 是否折叠导航栏
        isCollapse: false,
        // 访问页集合
        mainTabs: [],
        // 当前访问页名
        mainTabsActiveName: '',
    },
    getters: {
        isCollapse: (state) =&amp;gt; {
            return state.isCollapse
        },
    },
    mutations: {
        toggleCollapse(state) {
            state.isCollapse = !state.isCollapse
        },
        updateMainTabs(state, tabs) {
            state.mainTabs = tabs
        },
        updateMainTabsActiveName(state, name) {
            state.mainTabsActiveName = name
        },
    },
    actions: {},
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;当然还有一些小的调整点，可参考 git 上的提交版本 &lt;strong&gt;首页组件拆分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://book.levy.net.cn/doc/frontend/uiframe/module_split.html&quot;&gt;http://book.levy.net.cn/doc/frontend/uiframe/module_split.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Aug 2020 14:39:00 +0000</pubDate>
<dc:creator>Levy-伟</dc:creator>
<og:description>组件封装 在上一篇记录中，首页中有太多的代码，为了避免代码的臃肿，需要对主要的功能模块拆分，来让代码看起来更简洁，且能进行复用。 拆分后还加了些小功能，加入了修改 title 的代码，修改方式参考vu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/levywang/p/13543734.html</dc:identifier>
</item>
</channel>
</rss>