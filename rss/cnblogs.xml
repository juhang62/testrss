<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>陪你解读Spring Batch（一）Spring Batch介绍 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10398535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10398535.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　整个章节由浅入深了解Spring Batch，让你掌握批处理利器。面对大批量数据毫无惧色。本章只做介绍，后面章节有代码示例。好了，接下来是我们的主角Spring Batch。&lt;/p&gt;

&lt;h2&gt;1.1 背景介绍&lt;/h2&gt;
&lt;h3&gt;1.1.1 诞生&lt;/h3&gt;
&lt;p&gt;　　开源社区一直把大部分注意力集中在web和SOA框架中，基于java的批处理框架确很少，因此一个标准的、可重用的批处理框架对我们来说很重要。先来说一下什么是批处理？在企业应用时，需要定期或者人工触发的读入大批量数据，然后完成相应的业务处理并进行归档。这类工作就成为批处理。&lt;/p&gt;
&lt;p&gt;　　SpringSource和Accenture致力于通过合作来解决这种状况，Accenture在实现批处理架构上有着丰富的产业实践经验，SpringSource则有深厚的技术开发经验，两者成为强大的合作伙伴，创造出高质量的、市场认可的企业级java解决方案。因此诞生了Spring Batch&lt;/p&gt;
&lt;h3&gt;1.1.2 为什么使用它？&lt;/h3&gt;
&lt;p&gt;　　Spring Batch作为Spring的子项目，是一款轻量级的综合批处理框架，通过它可以构建出壮健的企业级批处理应用，因为基于Spring，所以开发者十分容易上手使用。SpringBatch不仅提供了统一的读写接口、丰富的任务处理方式、可重用的功能，还包括了日志，事务管理，任务统计、弹性处理等功能。使开发人员可以更多的关注业务处理过程。&lt;/p&gt;
&lt;p&gt;　　Spring Batch不是一个调度框架，因为已经有非常好的企业级调度框架包括Quartz等，它只注重任务处理相关问题，如执行任务、事务、并发等，而不是提供调度功能。它是为了和调度程序一起完成任务而设计的。比如我们希望定期的执行大批量数据任务，那么可结合Quartz等来实现。&lt;/p&gt;
&lt;h3&gt;1.1.3 应用场景&lt;/h3&gt;
&lt;p&gt;　　大量文件处理是比较常见的企业级应用场景，比如你要做聚合支付，那么必定会有聚合账单，如果每天有百万甚至千万级别的交易数据。那么将如何处理呢？如何进行海量数据的对账成了难题。或者每天需要处理其他业务场景的大数据量的文件，最后将处理好的数据写入数据库中。&lt;/p&gt;
&lt;p&gt;　　其实可以先不用想Spring Batch，如果没有，我们如何开发？这里就需要一个框架需要以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持对多种数据源进行操作&lt;/li&gt;
&lt;li&gt;能够定义不同job之间的顺序关系&lt;/li&gt;
&lt;li&gt;能够定义每个job的输入和输出数据操作&lt;/li&gt;
&lt;li&gt;对异常输入数据有校验机制和弹性处理&lt;/li&gt;
&lt;li&gt;支持job重跑等处理机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这不就是一个批处理框架需要的基础功能吗？&lt;/p&gt;

&lt;h2&gt;1.2 Spring Batch架构&lt;/h2&gt;
&lt;h3&gt;1.2.1 框架层次&lt;/h3&gt;
&lt;p&gt;　　Spring Batch分三层，应用层，核心层和基础架构层。&lt;/p&gt;
&lt;p&gt;　　应用层：开发人员使用Spring Batch编写的所有批处理任务代码&lt;/p&gt;
&lt;p&gt;　　核心层：包含加载和控制批处理作业所需的核心类，Job，Step等类的实现&lt;/p&gt;
&lt;p&gt;　　基础架构层：包含通用的读写器和重试模块　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218231412276-527792233.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;510&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2.2 概念模型　　&lt;/h3&gt;
&lt;p&gt;　　下图显示了完整的概念模型，JobLauncher启动Job，Job可以有多个Step组合，每一个Step由开发者自己编写，可一把一个大Step分成多个小Step，完全看开发者意愿。每一个Step对应一个ItemReader、ItemProcessor和ItemWriter。所有的批处理框架都可以抽象成最简单的过程，读取数据，处理数据，写数据。所以Spring Batch提供了3个接口，ItemReader、ItemProcessor和ItemWriter。JobRepository则是记录Job、Step和发起Job的执行信息等。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218232049040-793474258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图为处理流程，reader读，processor处理校验数据，writer写数据（入参是list，减少io次数）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201902/1465200-20190218232355643-908833388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.3 处理原则&lt;/h2&gt;
&lt;p&gt;　　下面是一些处理原则，可参考&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量使用公用模块&lt;/li&gt;
&lt;li&gt;尽量简化操作，不要有复杂的业务逻辑。更不要处理一条数据还要调外部接口进行数据加工&lt;/li&gt;
&lt;li&gt;尽可能少的IO操作&lt;/li&gt;
&lt;li&gt;同一个批处理文件不要处理2次&lt;/li&gt;
&lt;li&gt;尽可能压力测试&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>前言 整个章节由浅入深了解Spring Batch，让你掌握批处理利器。面对大批量数据毫无惧色。本章只做介绍，后面章节有代码示例。好了，接下来是我们的主角Spring Batch。 1.1 背景介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10398535.html</dc:identifier>
</item>
<item>
<title>让ASP.NET Core支持GraphQL之-GraphQL的实现原理 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/10398505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/10398505.html</guid>
<description>&lt;p&gt;众所周知RESTful API是目前最流行的软件架构风格之一，它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。&lt;br/&gt;RESTful的优越性是毋庸置疑的，不过GraphQL也可以作为一种补充，让你的服务既支持RESTful的http调用，也容许客户端通过GraphQL支持的声明式语法调用服务。&lt;br/&gt;本篇文章并不想对比RESTful和GraphQL孰轻孰重，或者那种方式更好，相关比较可以参考&lt;a href=&quot;https://www.cnblogs.com/xiandnc/p/9162298.html&quot;&gt;GraphQL的前世今生&lt;/a&gt;。本文旨在介绍如何在ASP.NET Core应用中引入GraphQL，让你的应用既支持RESTFul，也能支持GraphQL。&lt;/p&gt;
&lt;h2 id=&quot;web应用程序是如何工作的&quot;&gt;Web应用程序是如何工作的&lt;/h2&gt;
&lt;p&gt;如果说一个Service能够提供一个功能，那么我们就可以给Service一个输入，从而得到一个输出。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/xiandnc/1232840/o_graphQL-service%20(1).png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果将若干个Service组合在一起形成一个应用程序，那么这个应用程序就可以提供若干个能力，当一个框架分别就输入和输出进行统一的约定和规范时，也就是人们常说的SOAP，RESTful等技术。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/xiandnc/1232840/o_graphQL-framework.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于RESTful来说，输入就是Http request，输出是一个json格式的字符串。而Web应用程序框架在做什么？根据某个输入(request)，找到对应的controller, 击中合适的action，同时将Request绑定为action方法的参数，最后将结果格式化为json字符串并输出。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/xiandnc/1232840/o_graphQL-restful.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GraphQL就是跟Web框架同一级别的技术，只不过输入（input)不再是Http request，而是GraphQL特有的语法结构，输出仍然为json字符串。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/xiandnc/1232840/o_graphQL-graphQL.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;graphql能够做些什么&quot;&gt;GraphQL能够做些什么&lt;/h2&gt;
&lt;p&gt;既然GraphQL是一种可以代替RESTful的技术，那么你一定很想知道他是怎么做到的。 如果能用一句话总结那就是: GraphQL是一种API资源的查询语言。GraphQL通过下面的三种类型来满足用户的需求：&lt;/p&gt;
&lt;h5 id=&quot;查询&quot;&gt;1. 查询&lt;/h5&gt;
&lt;p&gt;我们都知道用户的请求可以分为两类：Query和Command，Query用于查询资源，调用一次和多次都不会影响资源的状态，一个简单的查询如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;query {
  hero {
    id
    name
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的查询语言可以理解为：查询hero资源的&quot;id&quot;和&quot;name“属性&lt;/p&gt;
&lt;h5 id=&quot;mutation&quot;&gt;2. mutation&lt;/h5&gt;
&lt;p&gt;所谓mutation就是Command，意味着该用户请求能够改变服务端的状态，一个简单的mutation如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mutation ($human:HumanInput!) {
  createHuman(human: $human) {
    id
    name
  }
}
variables: {
    &quot;human&quot;: {
      &quot;name&quot;: &quot;Boba Fett&quot;,
      &quot;homePlanet&quot;: &quot;Kamino&quot;
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的mutation可以理解为创建一个humman对象，输入对象是一个$human变量，最后把创建对象的`”id&quot;和&quot;name&quot;属性查询出来。可以看出mutation一般都要配合一个变量使用，变量需要在&quot;variables&quot;中单独定义。&lt;/p&gt;
&lt;h5 id=&quot;subscriptions&quot;&gt;3. Subscriptions&lt;/h5&gt;
&lt;p&gt;Subscriptions用于提供类似websocket的功能，&lt;a href=&quot;https://github.com/graphql-dotnet/server/&quot;&gt;GraphQL Server&lt;/a&gt;是一个实现了Apollo GraphQL订阅协议的.NET Core服务器. 下面的例子需要同时打开两个浏览器窗口：&lt;br/&gt;Subscription用户订阅聊天消息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;subscription MessageAdded {
  messageAdded {
    from { id displayName }
    content
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mutation用户添加聊天内容:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mutation AddMessage($message: MessageInputType!) {
  addMessage(message: $message) {
    from {
      id
      displayName
    }
    content
  }
}

variables:
{
  &quot;message&quot;: {
    &quot;content&quot;: &quot;Message&quot;,
    &quot;fromId&quot;: &quot;1&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;graphql是如何实现的&quot;&gt;GraphQL是如何实现的&lt;/h2&gt;
&lt;p&gt;我在用每一个开源框架或者类库时都习惯于先浏览源码，了解整个源码的大概结构和实现。下面的过程以一个简单的查询为例，分析GraphQL的实现原理:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{
  query test {
    user{
        age
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;a href=&quot;https://github.com/graphql/graphiql&quot;&gt;graphQL browser IDE&lt;/a&gt;发送请求：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/xiandnc/1232840/o_Jietu20190218-224221@2x.png&quot;/&gt;&lt;br/&gt;GrpahQL处理的整个过程如下：&lt;/p&gt;
&lt;h5 id=&quot;客户端将上面的graphql-query通过http发送到服务端&quot;&gt;1.客户端将上面的GraphQL query通过http发送到服务端&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;curl 'http://localhost:5000/graphql' -H 'Accept-Encoding: gzip, deflate, br' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Connection: keep-alive' -H 'DNT: 1' -H 'Origin: http://localhost:5000' --data-binary '{&quot;query&quot;:&quot;# Write your query or mutation here\nquery test{\n  user{\n    age\n  }\n}\n&quot;}' --compressed&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;整个request以json的格式发送到了服务端服务端将request反序列化为graphqlrequest类型&quot;&gt;2. 整个Request以json的格式发送到了服务端，服务端将Request反序列化为GraphQLRequest类型：&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GraphQLRequest
{
    [JsonProperty(&quot;query&quot;)]
    public string Query { get; set; }
    
    [JsonProperty(&quot;variables&quot;)]
    public JObject Variables { get; set; }
    
    [JsonProperty(&quot;operationName&quot;)]
    public string OperationName { get; set; }
    
    public Inputs GetInputs()
    {
      return GraphQLRequest.GetInputs(this.Variables);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对上面的例子，实际上只有string Query属性被反序列化为”&quot;# Write your query or mutation here\nquery test{\n user{\n age\n }\n}\n&quot;“&lt;/p&gt;
&lt;h5 id=&quot;服务端解析query解析query的过程是一个语法分析的过程通过paser将query解析为ast&quot;&gt;3.服务端解析Query，解析Query的过程是一个语法分析的过程，通过&lt;a href=&quot;https://github.com/graphql-dotnet/parser&quot;&gt;Paser&lt;/a&gt;将Query解析为AST:&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    var source = new Source(body);
    var result = _parser.Parse(source);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Parse后的结果是一个Document类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public class Document : AbstractNode
{
    public string OriginalQuery { get; set; }
    public Operations Operations { get; }
    public Fragments Fragments { get; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本例的Query将会被解析为一个Operations，一个Operations将包含若干个有层次结构的Operation，解析Query的目的是为了知道客户端要查询user.Age这个属性。&lt;/p&gt;
&lt;h5 id=&quot;有了一个parse后的document接下来的工作将有documentexecuter来完成documentexecuter定义了整个调用服务端资源的流程&quot;&gt;4.有了一个Parse后的Document，接下来的工作将有DocumentExecuter来完成，DocumentExecuter定义了整个调用服务端资源的流程：&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public async Task&amp;lt;ExecutionResult&amp;gt; ExecuteAsync(ExecutionOptions options)
{
    //1. 打印开始时间
    //2. Parse Document
    //3. 验证Document是否是一个合法的GrapQL语法请求
    //4. 在流程的各个阶段执行Listener，用于在不同的时机切入代码，类似于ASP.NET Core中的Filter
    //5. 选择合适的执行策略
    //6. 执行服务端资源
    //7. 输出Response
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是GraphQL在.NET Core中的实现原理分析，下一篇将通过一个hello world级别的例子演示如何让你的ASP.NET应用程序支持GraphQL.&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 15:17:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>众所周知RESTful API是目前最流行的软件架构风格之一，它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 RESTful的优越性是毋庸置疑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/10398505.html</dc:identifier>
</item>
<item>
<title>数据分析三剑客之pandas - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10398490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10398490.html</guid>
<description>&lt;h2&gt;引入&lt;/h2&gt;
&lt;p&gt;前面一篇文章我们介绍了numpy，但numpy的特长并不是在于数据处理，而是在它能非常方便地实现科学计算，所以我们日常对数据进行处理时用的numpy情况并不是很多，我们需要处理的数据一般都是带有列标签和index索引的，而numpy并不支持这些，这时我们就需要pandas上场啦！ &lt;/p&gt;

&lt;h2&gt;WHAT?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Pandas&lt;/strong&gt;是基于&lt;strong&gt;Numpy&lt;/strong&gt;构建的库，在数据处理方面可以把它理解为numpy加强版，同时Pandas也是一项开源项目 。不同于numpy的是，pandas拥有种数据结构：&lt;strong&gt;Series&lt;/strong&gt;和&lt;strong&gt;DataFrame&lt;/strong&gt;： &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;fr-fic fr-dib medium-zoom-image&quot; src=&quot;https://image.jiqizhixin.com/uploads/editor/22da2bca-c579-4c81-8af4-902d19597f31/pandas-powerful-data-analysis-tools-for-python-13-638.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们就来生成一个简单的series对象来方便理解：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;from&lt;/span&gt; pandas &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Series,DataFrame
In [&lt;/span&gt;2]: &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
In [&lt;/span&gt;3]: data = Series([1,2,3,4],index = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
In [&lt;/span&gt;4&lt;span&gt;]: data
Out[&lt;/span&gt;4&lt;span&gt;]:
a    &lt;/span&gt;1&lt;span&gt;
b    &lt;/span&gt;2&lt;span&gt;
c    &lt;/span&gt;3&lt;span&gt;
d    &lt;/span&gt;4&lt;span&gt;
dtype: int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Series是一种类似一维数组的数据结构，由一组数据和与之相关的index组成，这个结构一看似乎与dict字典差不多，我们知道字典是一种&lt;strong&gt;无序&lt;/strong&gt;的数据结构，而pandas中的Series的数据结构不一样，它相当于&lt;strong&gt;定长有序&lt;/strong&gt;的字典，并且它的&lt;strong&gt;index和value&lt;/strong&gt;之间是&lt;strong&gt;独立&lt;/strong&gt;的，两者的索引还是有区别的，Series的&lt;strong&gt;index&lt;/strong&gt;是&lt;strong&gt;可&lt;/strong&gt;变的，而&lt;strong&gt;dict&lt;/strong&gt;字典的&lt;strong&gt;key&lt;/strong&gt;值是不可变的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;fr-fic fr-dib medium-zoom-image&quot; src=&quot;https://image.jiqizhixin.com/uploads/editor/3fe018dd-c064-4856-8b79-7ad4f34a61fc/pandas-powerful-data-analysis-tools-for-python-14-638.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面照例生成一个简单的DataFrame对象：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
In [8]: data = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[1,2,3],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;we&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;you&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;they&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;btc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ae&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}
In [&lt;/span&gt;9]: df =&lt;span&gt; DataFrame(data)
In [&lt;/span&gt;10&lt;span&gt;]: df
Out[&lt;/span&gt;10&lt;span&gt;]:
   a     b    c
0  &lt;/span&gt;1&lt;span&gt;    we  btc
&lt;/span&gt;1  2&lt;span&gt;   you  eos
&lt;/span&gt;2  3  they   ae
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DataFrame这种数据结构我们可以把它看作是一张二维表，DataFrame长得跟我们平时使用的Excel表格差不多，DataFrame的横行称为&lt;strong&gt;columns&lt;/strong&gt;，竖列和Series一样称为&lt;strong&gt;index&lt;/strong&gt;，DataFrame每一列可以是不同类型的值集合，所以DataFrame你也可以把它视为不同数据类型同一index的Series集合。&lt;/p&gt;

&lt;h2&gt;WHY?&lt;/h2&gt;

&lt;p&gt;科学计算方面numpy是优势，但在数据处理方面DataFrame就更胜一筹了，事实上DataFrame已经覆盖了一部分的数据操作了，对于数据挖掘来说，工作可大概分为读取数据-数据清洗-分析建模-结果展示：&lt;/p&gt;
&lt;p&gt;先说说读取数据，Pandas提供强大的IO读取工具，csv格式、Excel文件、数据库等都可以非常简便地读取，对于大数据，pandas也支持大文件的分块读取；&lt;/p&gt;
&lt;p&gt;接下来就是数据清洗，面对数据集，我们遇到最多的情况就是存在缺失值，Pandas把各种类型数据类型的缺失值统一称为NaN（这里要多说几句，None==None这个结果是true，但np.nan==np.nan这个结果是false，NaN在官方文档中定义的是float类型，有关于NaN和None的区别以及使用，有位博主已经做好整理：&lt;a href=&quot;https://junjiecai.github.io/posts/2016/Oct/20/none_vs_nan/&quot;&gt;None vs NaN&lt;/a&gt;）,Pandas提供许多方便快捷的方法来处理这些缺失值NaN。&lt;/p&gt;
&lt;p&gt;最重要的分析建模阶段，Pandas自动且明确的数据对齐特性，非常方便地使新的对象可以正确地与一组标签对齐，有了这个特性，Pandas就可以非常方便地将数据集进行拆分-重组操作。&lt;/p&gt;
&lt;p&gt;最后就是结果展示阶段了，我们都知道Matplotlib是个数据视图化的好工具，Pandas与Matplotlib搭配，不用复杂的代码，就可以生成多种多样的数据视图。&lt;/p&gt;

&lt;h2&gt;HOW？&lt;/h2&gt;
&lt;h3&gt;Series&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Series的两种生成方式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [19]: data = Series([222,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;btc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,234,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
In [&lt;/span&gt;20&lt;span&gt;]: data
Out[&lt;/span&gt;20&lt;span&gt;]:
0    &lt;/span&gt;222
1&lt;span&gt;    btc
&lt;/span&gt;2    234
3&lt;span&gt;    eos
dtype: object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然我们在生成的时候没有设置index值，但Series还是会自动帮我们生成index，这种方式生成的Series结构跟list列表差不多，可以把这种形式的Series理解为竖起来的list列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
In [21]: data = Series([1,2,3,4],index = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
In [&lt;/span&gt;22&lt;span&gt;]: data
Out[&lt;/span&gt;22&lt;span&gt;]:
a    &lt;/span&gt;1&lt;span&gt;
b    &lt;/span&gt;2&lt;span&gt;
c    &lt;/span&gt;3&lt;span&gt;
d    &lt;/span&gt;4&lt;span&gt;
dtype: int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种形式的Series可以理解为numpy的array外面披了一件index的马甲，所以array的相关操作，Series同样也是支持的。结构非常相似的&lt;strong&gt;dict字典同样也是可以转化为Series格式的：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [29]: dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
In [&lt;/span&gt;30]: dicSeries = Series(dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;查看Series的相关信息：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
In [32&lt;span&gt;]: data.index
Out[&lt;/span&gt;32]: Index([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;33&lt;span&gt;]: data.values
Out[&lt;/span&gt;33]: array([1, 2, 3, 4], dtype=&lt;span&gt;int64)

In [&lt;/span&gt;35]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; data    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;in方法默认判断的是index值&lt;/span&gt;
Out[35]: True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Series的NaN生成：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
In [46]: index1 = [ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
In [&lt;/span&gt;47]: dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;}
In [&lt;/span&gt;48]: data2 = Series(dic,index=&lt;span&gt;index1)
In [&lt;/span&gt;49&lt;span&gt;]: data2
Out[&lt;/span&gt;49&lt;span&gt;]:
a    NaN
b    &lt;/span&gt;1.0&lt;span&gt;
c    &lt;/span&gt;1.0&lt;span&gt;
d    &lt;/span&gt;1.0&lt;span&gt;
dtype: float64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这里我们可以看出Series的生成依据的是&lt;strong&gt;index值&lt;/strong&gt;，index‘a’在字典dic的key中并不存在，Series自然也找不到’a’的对应value值，这种情况下Pandas就会自动生成&lt;strong&gt;NaN(not a number)&lt;/strong&gt;来填补缺失值，这里还有个有趣的现象，原本dtype是int类型，生成NaN后就变成了float类型了，因为NaN的官方定义就是&lt;strong&gt;float类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NaN的相关查询：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [58&lt;span&gt;]: data2.isnull()
Out[&lt;/span&gt;58&lt;span&gt;]:
a     True
b    False
c    False
d    False
dtype: bool

In [&lt;/span&gt;59&lt;span&gt;]: data2.notnull()
Out[&lt;/span&gt;59&lt;span&gt;]:
a    False
b     True
c     True
d     True
dtype: bool

In [&lt;/span&gt;60]: data2[data2.isnull()==True]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;嵌套查询NaN&lt;/span&gt;
Out[60&lt;span&gt;]:
a   NaN
dtype: float64

In [&lt;/span&gt;64]: data2.count()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计非NaN个数&lt;/span&gt;
Out[64]: 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切记切记，查询NaN值切记不要使用np.nan==np.nan这种形式来作为判断条件，结果永远是False，==是用作&lt;strong&gt;值判断&lt;/strong&gt;的，而NaN并没有值，如果你不想使用上方的判断方法，你可以使用is作为判断方法，&lt;strong&gt;is&lt;/strong&gt;是&lt;strong&gt;对象引用判断，np.nan is np.nan&lt;/strong&gt;，结果就是你要的True。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Series自动对齐：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [72&lt;span&gt;]: data1
Out[&lt;/span&gt;72&lt;span&gt;]:
a      &lt;/span&gt;1&lt;span&gt;
asd    &lt;/span&gt;1&lt;span&gt;
b      &lt;/span&gt;1&lt;span&gt;
dtype: int64

In [&lt;/span&gt;73&lt;span&gt;]: data
Out[&lt;/span&gt;73&lt;span&gt;]:
a    &lt;/span&gt;1&lt;span&gt;
b    &lt;/span&gt;2&lt;span&gt;
c    &lt;/span&gt;3&lt;span&gt;
d    &lt;/span&gt;4&lt;span&gt;
dtype: int64

In [&lt;/span&gt;74]: data+&lt;span&gt;data1
Out[&lt;/span&gt;74&lt;span&gt;]:
a      &lt;/span&gt;2.0&lt;span&gt;
asd    NaN
b      &lt;/span&gt;3.0&lt;span&gt;
c      NaN
d      NaN
dtype: float64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面两个Series中不难看出各自的index所处位置并不完全相同，这时Series的&lt;strong&gt;自动对齐&lt;/strong&gt;特性就发挥作用了，在算术运算中，Series会自动寻找匹配的&lt;strong&gt;index值&lt;/strong&gt;进行运算，如果index不存在匹配则自动赋予NaN,值得注意的是，&lt;strong&gt;任何数+NaN=NaN&lt;/strong&gt;,你可以把NaN理解为吸收一切的黑洞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Series的name属性：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [84]: data.index.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
In [&lt;/span&gt;85]: data.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
In [&lt;/span&gt;86&lt;span&gt;]: data
Out[&lt;/span&gt;86&lt;span&gt;]:
abc
a    &lt;/span&gt;1&lt;span&gt;
b    &lt;/span&gt;2&lt;span&gt;
c    &lt;/span&gt;3&lt;span&gt;
d    &lt;/span&gt;4&lt;span&gt;
Name: test, dtype: int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Series&lt;strong&gt;对象本身&lt;/strong&gt;及其&lt;strong&gt;索引index&lt;/strong&gt;都有一个&lt;strong&gt;name属性&lt;/strong&gt;，name属性主要发挥作用是在&lt;strong&gt;DataFrame&lt;/strong&gt;中，当我们把一个Series对象放进DataFrame中，新的列将根据我们的name属性对该列进行命名，如果我们没有给Series命名，DataFrame则会自动帮我们命名为&lt;strong&gt;0&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;DataFrame&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DataFrame的生成：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
In [87]:  data = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BTC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ETH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;EOS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[50000, 4000, 150&lt;span&gt;]}
In [&lt;/span&gt;88]: data =&lt;span&gt; DataFrame(data)
In [&lt;/span&gt;89&lt;span&gt;]: data
Out[&lt;/span&gt;89&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
2  EOS    150
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DataFrame的生成与Series差不多，你可以自己指定index，也可不指定，DataFrame会自动帮你补上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看DataFrame的相关信息：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
In [95&lt;span&gt;]: data.index
Out[&lt;/span&gt;95]: RangeIndex(start=0, stop=3, step=1&lt;span&gt;)

In [&lt;/span&gt;96&lt;span&gt;]: data.values
Out[&lt;/span&gt;96&lt;span&gt;]:
array([[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BTC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 50000&lt;span&gt;],
       [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ETH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 4000&lt;span&gt;],
       [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EOS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 150]], dtype=&lt;span&gt;object)

In [&lt;/span&gt;97]: data.columns    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;DataFrame的列标签&lt;/span&gt;
Out[97]: Index([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;DataFrame的索引：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
In [92&lt;span&gt;]: data.name
Out[&lt;/span&gt;92&lt;span&gt;]:
0    BTC
&lt;/span&gt;1&lt;span&gt;    ETH
&lt;/span&gt;2&lt;span&gt;    EOS
Name: name, dtype: object

In [&lt;/span&gt;93]: data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
Out[&lt;/span&gt;93&lt;span&gt;]:
0    BTC
&lt;/span&gt;1&lt;span&gt;    ETH
&lt;/span&gt;2&lt;span&gt;    EOS
Name: name, dtype: object

In [&lt;/span&gt;94]: data.iloc[1]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;loc['name']查询的是行标签&lt;/span&gt;
Out[94&lt;span&gt;]:
name      ETH
price    &lt;/span&gt;4000&lt;span&gt;
Name: &lt;/span&gt;1, dtype: object
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实行索引，除了iloc，loc还有个&lt;strong&gt;ix&lt;/strong&gt;，&lt;strong&gt;ix&lt;/strong&gt;既可以进行&lt;strong&gt;行标签索引&lt;/strong&gt;，也可以进行&lt;strong&gt;行号索引&lt;/strong&gt;，但这也大大增加了它的不确定性，有时会出现一些奇怪的问题，所以pandas在0.20.0版本的时候就把ix给弃用了。&lt;/p&gt;
&lt;h2&gt;DataFrame的常用操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单地增加行、列：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [105]: data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;增加列&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;106&lt;span&gt;]: data
Out[&lt;/span&gt;106&lt;span&gt;]:
  name  price   type
0  BTC  &lt;/span&gt;50000&lt;span&gt;  token
&lt;/span&gt;1  ETH   4000&lt;span&gt;  token
&lt;/span&gt;2  EOS    150&lt;span&gt;  token
In [&lt;/span&gt;109]: data.loc[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ae&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,200,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;增加行&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;110&lt;span&gt;]: data
Out[&lt;/span&gt;110&lt;span&gt;]:
  name  price   type
0  BTC  &lt;/span&gt;50000&lt;span&gt;  token
&lt;/span&gt;1  ETH   4000&lt;span&gt;  token
&lt;/span&gt;2  EOS    150&lt;span&gt;  token
&lt;/span&gt;3   ae    200  token
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除行、列操作：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [117]: &lt;span&gt;del&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除列&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;118&lt;span&gt;]: data
Out[&lt;/span&gt;118&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
2  EOS    150
3   ae    200&lt;span&gt;
In [&lt;/span&gt;120]: data.drop([2])    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除行&lt;/span&gt;
Out[120&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
3   ae    200&lt;span&gt;

In [&lt;/span&gt;121&lt;span&gt;]: data
Out[&lt;/span&gt;121&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
2  EOS    150
3   ae    200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是，使用&lt;strong&gt;drop（）方法&lt;/strong&gt;返回的是&lt;strong&gt;Copy&lt;/strong&gt;而不是&lt;strong&gt;视图&lt;/strong&gt;，要想真正在原数据里删除行，就要设置&lt;em&gt;&lt;strong&gt;inplace=True&lt;/strong&gt;&lt;/em&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [125]: data.drop([2],inplace=&lt;span&gt;True)

In [&lt;/span&gt;126&lt;span&gt;]: data
Out[&lt;/span&gt;126&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
3   ae    200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;设置某一列为index:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [131]: data.set_index([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],inplace=&lt;span&gt;True)

In [&lt;/span&gt;132&lt;span&gt;]: data
Out[&lt;/span&gt;132&lt;span&gt;]:
      price
name
BTC   &lt;/span&gt;50000&lt;span&gt;
ETH    &lt;/span&gt;4000&lt;span&gt;
ae      &lt;/span&gt;200&lt;span&gt;

In [&lt;/span&gt;133]: data.reset_index(inplace=True)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将index返回回dataframe中&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;134&lt;span&gt;]: data
Out[&lt;/span&gt;134&lt;span&gt;]:
  name  price
0  BTC  &lt;/span&gt;50000
1  ETH   4000
2   ae    200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;处理缺失值:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [149&lt;span&gt;]: data
Out[&lt;/span&gt;149&lt;span&gt;]:
  name    price
0  BTC  &lt;/span&gt;50000.0
1  ETH   4000.0
2   ae    200.0
3&lt;span&gt;  eos      NaN

In [&lt;/span&gt;150]: data.dropna()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;丢弃含有缺失值的行&lt;/span&gt;
Out[150&lt;span&gt;]:
  name    price
0  BTC  &lt;/span&gt;50000.0
1  ETH   4000.0
2   ae    200.0&lt;span&gt;

In [&lt;/span&gt;151]: data.fillna(0)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;填充缺失值数据为0&lt;/span&gt;
Out[151&lt;span&gt;]:
  name    price
0  BTC  &lt;/span&gt;50000.0
1  ETH   4000.0
2   ae    200.0
3  eos      0.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是需要注意：&lt;strong&gt;这些方法返回的是copy而不是视图，如果想在原数据上改变，别忘了&lt;em&gt;inplace=True&lt;/em&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据合并：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
In [160&lt;span&gt;]: data
Out[&lt;/span&gt;160&lt;span&gt;]:
  name    price
0  BTC  &lt;/span&gt;50000.0
1  ETH   4000.0
2   ae    200.0
3&lt;span&gt;  eos      NaN

In [&lt;/span&gt;161&lt;span&gt;]: data1
Out[&lt;/span&gt;161&lt;span&gt;]:
  name  other
0  BTC  &lt;/span&gt;50000
1  BTC   4000
2  EOS    150&lt;span&gt;

In [&lt;/span&gt;162]: pd.merge(data,data1,on=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,how=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以name为key进行左连接&lt;/span&gt;
Out[162&lt;span&gt;]:
  name    price    other
0  BTC  &lt;/span&gt;50000.0  50000.0
1  BTC  50000.0   4000.0
2  ETH   4000.0&lt;span&gt;      NaN
&lt;/span&gt;3   ae    200.0&lt;span&gt;      NaN
&lt;/span&gt;4  eos      NaN      NaN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;平时进行数据合并操作，更多的会出一种情况，那就是出现&lt;strong&gt;重复值&lt;/strong&gt;，DataFrame也为我们提供了简便的方法：&lt;/p&gt;
&lt;p&gt;data.drop_duplicates(inplace=True)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据的简单保存与读取：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [165]: data.to_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;166]: pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[&lt;/span&gt;166&lt;span&gt;]:
   Unnamed: 0 name    price
0           0  BTC  &lt;/span&gt;50000.0
1           1  ETH   4000.0
2           2   ae    200.0
3           3  eos      NaN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么会出现这种情况呢，从头看到尾的同学可能就看出来了，增加第三行时，我用的是&lt;strong&gt;loc[‘3’]行标签&lt;/strong&gt;来增加的，而&lt;strong&gt;read_csv方法是默认index是从0开始增长的&lt;/strong&gt;，此时只需要我们设置下index参数就ok了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [167]: data.to_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=None)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不保存行索引&lt;/span&gt;
In [168]: pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[&lt;/span&gt;168&lt;span&gt;]:
  name    price
0  BTC  &lt;/span&gt;50000.0
1  ETH   4000.0
2   ae    200.0
3  eos      NaN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他的还有&lt;strong&gt;header&lt;/strong&gt;参数, 这些参数都是我们在保存数据时需要注意的。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Feb 2019 15:03:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>Pandas 引入 前面一篇文章我们介绍了numpy，但numpy的特长并不是在于数据处理，而是在它能非常方便地实现科学计算，所以我们日常对数据进行处理时用的numpy情况并不是很多，我们需要处理的数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10398490.html</dc:identifier>
</item>
<item>
<title>ES6之Promise用法详解 - 半指温柔乐</title>
<link>http://www.cnblogs.com/le220/p/10381920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/le220/p/10381920.html</guid>
<description>&lt;p&gt;本文主要对ES6的&lt;code&gt;Promise&lt;/code&gt;进行一些入门级的介绍。要想学习一个知识点，肯定是从三个方面出发，what、why、how。下面就跟着我一步步学习吧~&lt;/p&gt;

&lt;p&gt;首先是what。那么什么是&lt;code&gt;Promise&lt;/code&gt;呢？ &lt;br/&gt;以下是MDN对&lt;code&gt;Promise&lt;/code&gt;的定义&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future.&lt;/p&gt;
&lt;p&gt;译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么什么是异步操作？在学习promise之前需要把这个概念搞明白，下面将抽离一章专门介绍。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader2&quot;&gt;2.1 同步与异步&lt;/h2&gt;
&lt;p&gt;我们知道，JavaScript的执行环境是「单线程」。 &lt;br/&gt;所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。 &lt;br/&gt;但实际上还有其他线程，如事件触发线程、ajax请求线程等。&lt;/p&gt;
&lt;p&gt;这也就引发了同步和异步的问题。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader3&quot;&gt;2.1.1 同步&lt;/h3&gt;
&lt;p&gt;同步模式，即上述所说的单线程模式，&lt;strong&gt;一次&lt;/strong&gt;只能执行&lt;strong&gt;一个&lt;/strong&gt;任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「&lt;strong&gt;线程阻塞&lt;/strong&gt;」。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(x);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(&quot;don't carry out&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不会执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。 &lt;br/&gt;同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader4&quot;&gt;2.1.2 异步&lt;/h3&gt;
&lt;p&gt;下面就来看看异步模式。 &lt;br/&gt;异步模式，即与同步模式相反，可以一起执行&lt;strong&gt;多个任务&lt;/strong&gt;，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。 &lt;br/&gt;最常见的异步模式就数定时器了，我们来看看以下的例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     console.log('taskA, asynchronous'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; }, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; console.log('taskB, synchronize'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;while(true);&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; -------ouput-------
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;taskB, synchronize
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; taskA, asynchronous
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，&lt;strong&gt;异步任务会在当前脚本的所有同步任务执行完才会执行&lt;/strong&gt;。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader5&quot;&gt;2.1.3 回调函数&lt;/h3&gt;
&lt;p&gt;提起异步，就不得不谈谈回调函数了。上例中，&lt;code&gt;setTimeout&lt;/code&gt;里的&lt;code&gt;function&lt;/code&gt;便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。&lt;br/&gt;以下是WikiPedia对于&lt;code&gt;callback&lt;/code&gt;的定义。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。&lt;/p&gt;
&lt;p&gt;WikiPedia同时提到&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****************同步回调*****************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fun1 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(callback) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     console.log(&quot;before callback&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     (callback &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt;(callback) === 'function') &amp;amp;&amp;amp;&lt;span&gt; callback();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     console.log(&quot;after callback&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fun2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(param) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; start = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;((&lt;span&gt;new&lt;/span&gt; Date() - start) &amp;lt; 3000) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;delay 3s&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     console.log(&quot;I'm callback&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;fun1(fun2);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; -------output--------
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;before callback
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;after 3s&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;I’m callback
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; after callback
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。&lt;/p&gt;
&lt;p&gt;上一小节中&lt;code&gt;setTimeout&lt;/code&gt;就是常见的异步回调，另外常见的异步回调即ajax请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.4 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*****************异步回调*****************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; request(url, param, successFun, errorFun) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    $.ajax({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         type: 'GET'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        url: url,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        param: param,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         async: &lt;span&gt;true&lt;/span&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为true,即异步请求；false为同步请求&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        success: successFun,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        error: errorFun
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; request('test.html', '', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求成功后的回调函数，通常是对请求回来的数据进行处理&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     console.log('请求成功啦, 这是返回的数据:'&lt;span&gt;, data);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; },&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     console.log('sorry, 请求失败了, 这是失败信息:'&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader6&quot;&gt;2.2 为什么使用Promise&lt;/h2&gt;
&lt;p&gt;说完了以上基本概念，我们就可以继续学习&lt;code&gt;Promise&lt;/code&gt;了。&lt;br/&gt;上面提到，&lt;code&gt;Promise&lt;/code&gt;对象是用于异步操作的。既然我们可以使用异步回调来进行异步操作，为什么还要引入一个&lt;code&gt;Promise&lt;/code&gt;新概念，还要花时间学习它呢？不要着急，下面就来谈谈&lt;code&gt;Promise&lt;/code&gt;的过人之处。&lt;br/&gt;我们先看看下面的demo，利用&lt;code&gt;Promise&lt;/code&gt;改写例2.4的异步回调。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.5 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendRequest(url, param) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        request(url, param, resolve, reject);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; sendRequest('test.html', '').then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步操作成功后的回调&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     console.log('请求成功啦, 这是返回的数据:'&lt;span&gt;, data);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步操作失败后的回调&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     console.log('sorry, 请求失败了, 这是失败信息:'&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么一看，并没有什么区别，还比上面的异步回调复杂，得先新建Promise再定义其回调。其实，&lt;code&gt;Promise&lt;/code&gt;的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.6 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; request('test1.html', '', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data1) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     console.log('第一次请求成功, 这是返回的数据:'&lt;span&gt;, data1);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     request('test2.html', data1, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data2) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         console.log('第二次请求成功, 这是返回的数据:'&lt;span&gt;, data2);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         request('test3.html', data2, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data3) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             console.log('第三次请求成功, 这是返回的数据:'&lt;span&gt;, data3);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;request... 继续请求&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error3) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             console.log('第三次请求失败, 这是失败信息:'&lt;span&gt;, error3);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error2) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         console.log('第二次请求失败, 这是失败信息:'&lt;span&gt;, error2);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error1) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     console.log('第一次请求失败, 这是失败信息:'&lt;span&gt;, error1);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用&lt;code&gt;Promise&lt;/code&gt;，我们就可以利用&lt;code&gt;then&lt;/code&gt;进行「链式回调」，将异步操作以同步操作的流程表示出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例2.7 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; sendRequest('test1.html', '').then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data1) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     console.log('第一次请求成功, 这是返回的数据:'&lt;span&gt;, data1);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data2) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     console.log('第二次请求成功, 这是返回的数据:'&lt;span&gt;, data2);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data3) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     console.log('第三次请求成功, 这是返回的数据:'&lt;span&gt;, data3);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; }).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用catch捕捉前面的错误&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     console.log('sorry, 请求失败了, 这是失败信息:'&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是明显清晰很多？孰优孰略也无需多说了吧~下面就让我们真正进入&lt;code&gt;Promise&lt;/code&gt;的学习。&lt;/p&gt;

&lt;h2 id=&quot;articleHeader8&quot;&gt;3.1 基本用法&lt;/h2&gt;
&lt;p&gt;上一小节我们认识了&lt;code&gt;promise&lt;/code&gt;长什么样，但对它用到的&lt;code&gt;resolve&lt;/code&gt;、&lt;code&gt;reject&lt;/code&gt;、&lt;code&gt;then&lt;/code&gt;、&lt;code&gt;catch&lt;/code&gt;想必还不理解。下面我们一步步学习。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象代表一个未完成、但预计将来会完成的操作。&lt;br/&gt;它有以下三种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pending&lt;/code&gt;：初始值，不是fulfilled，也不是rejected&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fulfilled&lt;/code&gt;：代表操作成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rejected&lt;/code&gt;：代表操作失败&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;有两种状态改变的方式，既可以从&lt;code&gt;pending&lt;/code&gt;转变为&lt;code&gt;fulfilled&lt;/code&gt;，也可以从&lt;code&gt;pending&lt;/code&gt;转变为&lt;code&gt;rejected&lt;/code&gt;。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，&lt;code&gt;promise.then&lt;/code&gt;绑定的函数就会被调用。&lt;br/&gt;注意：&lt;code&gt;Promise&lt;/code&gt;一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。&lt;br/&gt;下面就通过例子进一步讲解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建Promise&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 异步操作成功 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        resolve(data);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 异步操作失败 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        reject(error);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似构建对象，我们使用&lt;code&gt;new&lt;/code&gt;来构建一个&lt;code&gt;Promise&lt;/code&gt;。&lt;code&gt;Promise&lt;/code&gt;接受一个「函数」作为参数，该函数的两个参数分别是&lt;code&gt;resolve&lt;/code&gt;和&lt;code&gt;reject&lt;/code&gt;。这两个函数就是就是「回调函数」，由JavaScript引擎提供。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolve&lt;/code&gt;函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； &lt;br/&gt;&lt;code&gt;reject&lt;/code&gt;函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。&lt;/p&gt;
&lt;p&gt;Promise实例生成以后，可以用&lt;code&gt;then&lt;/code&gt;方法指定&lt;code&gt;resolved&lt;/code&gt;状态和&lt;code&gt;reject&lt;/code&gt;状态的回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接例3.1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;promise.then(onFulfilled, onRejected);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something when success&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something when failure&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;then&lt;/code&gt;方法会返回一个Promise。它有两个参数，分别为Promise从&lt;code&gt;pending&lt;/code&gt;变为&lt;code&gt;fulfilled&lt;/code&gt;和&lt;code&gt;rejected&lt;/code&gt;时的回调函数（第二个参数非必选）。这两个函数都&lt;strong&gt;接受Promise对象传出的值作为参数&lt;/strong&gt;。&lt;br/&gt;简单来说，&lt;code&gt;then&lt;/code&gt;就是定义&lt;code&gt;resolve&lt;/code&gt;和&lt;code&gt;reject&lt;/code&gt;函数的，其&lt;code&gt;resolve&lt;/code&gt;参数相当于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolveFun(data) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;data为promise传出的值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而新建Promise中的'resolve(data)'，则相当于执行resolveFun函数。&lt;br/&gt;Promise新建后就会立即执行。而&lt;code&gt;then&lt;/code&gt;方法中指定的回调函数，将&lt;strong&gt;在当前脚本所有同步任务执行完才会执行&lt;/strong&gt;。如下例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   console.log('before resolved'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  resolve();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   console.log('after resolved'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   console.log('resolved'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; console.log('outer'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; -------output-------
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;before resolved
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;after resolved
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;outer
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; resolved
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于&lt;code&gt;resolve&lt;/code&gt;指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印'resolved'，这个和例2.2是一样的道理。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader9&quot;&gt;3.2 基本API&lt;/h2&gt;
&lt;h3 id=&quot;articleHeader10&quot;&gt;.then()&lt;/h3&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code&gt;语法：&lt;span class=&quot;hljs-selector-tag&quot;&gt;Promise&lt;span class=&quot;hljs-selector-class&quot;&gt;.prototype&lt;span class=&quot;hljs-selector-class&quot;&gt;.then(&lt;span class=&quot;hljs-selector-tag&quot;&gt;onFulfilled, &lt;span class=&quot;hljs-selector-tag&quot;&gt;onRejected)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对promise添加&lt;code&gt;onFulfilled&lt;/code&gt;和&lt;code&gt;onRejected&lt;/code&gt;回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的&lt;code&gt;resolve&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;因此，我们可以使用链式写法，如上文的例2.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的&lt;strong&gt;状态发生变化&lt;/strong&gt;，才会被调用。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader11&quot;&gt;.catch()&lt;/h3&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code&gt;语法：&lt;span class=&quot;hljs-selector-tag&quot;&gt;Promise&lt;span class=&quot;hljs-selector-class&quot;&gt;.prototype&lt;span class=&quot;hljs-selector-class&quot;&gt;.catch(&lt;span class=&quot;hljs-selector-tag&quot;&gt;onRejected)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法是&lt;code&gt;.then(undefined, onRejected)&lt;/code&gt;的别名，用于指定发生错误时的回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     console.log('success'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; }).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     console.log('error'&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******等同于******&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     console.log('success'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }).then(undefined, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     console.log('error'&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.4 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('test'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******等同于******&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     reject(&lt;span&gt;new&lt;/span&gt; Error('test'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用catch捕获&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; promise.&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    console.log(error);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; -------output-------
&lt;span&gt;15&lt;/span&gt; Error: test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上例可以看出，&lt;code&gt;reject&lt;/code&gt;方法的作用，等同于抛错。&lt;/p&gt;
&lt;p&gt;promise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个&lt;code&gt;catch&lt;/code&gt;所捕获。&lt;code&gt;then&lt;/code&gt;方法指定的回调函数，若抛出错误，也会被下一个&lt;code&gt;catch&lt;/code&gt;捕获。&lt;code&gt;catch&lt;/code&gt;中也能抛错，则需要后面的&lt;code&gt;catch&lt;/code&gt;来捕获。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.5 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; sendRequest('test.html').then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data1) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data2) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理前面三个Promise产生的错误&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦&lt;code&gt;fulfilled&lt;/code&gt;了，再抛错，也不会变为&lt;code&gt;rejected&lt;/code&gt;，就不会被&lt;code&gt;catch&lt;/code&gt;了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.6 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  resolve();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;throw&lt;/span&gt; 'error'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; promise.&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;    console.log(e);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;This is never called&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有使用&lt;code&gt;catch&lt;/code&gt;方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.7 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    resolve(x);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    console.log(data);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1217233/201902/1217233-20190215100118203-588860492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217233/201902/1217233-20190215100125864-1377040233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217233/201902/1217233-20190215100133872-2027653419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;如图所示，只有Chrome会抛错，且promise状态变为&lt;code&gt;rejected&lt;/code&gt;，Firefox和Safari中错误不会被捕获，也不会传递到外层代码，最后没有任何输出，promise状态也变为&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader12&quot;&gt;.all()&lt;/h3&gt;
&lt;pre class=&quot;hljs typescript&quot;&gt;
&lt;code&gt;语法：&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.all(iterable)
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法用于将多个Promise实例，包装成一个新的Promise实例。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var p = &lt;span class=&quot;hljs-built_in&quot;&gt;Promise.all([p1, p2, p3]);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.all&lt;/code&gt;方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用&lt;code&gt;Promise.resolve&lt;/code&gt;转换为一个promise)。它的状态由这三个promise实例决定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当p1, p2, p3状态都变为&lt;code&gt;fulfilled&lt;/code&gt;，p的状态才会变为&lt;code&gt;fulfilled&lt;/code&gt;，并将三个promise返回的结果，按参数的顺序（而不是 &lt;code&gt;resolved&lt;/code&gt;的顺序）存入数组，传给p的回调函数，如例3.8。&lt;/li&gt;
&lt;li&gt;当p1, p2, p3其中之一状态变为&lt;code&gt;rejected&lt;/code&gt;，p的状态也会变为&lt;code&gt;rejected&lt;/code&gt;，并把第一个被&lt;code&gt;reject&lt;/code&gt;的promise的返回值，传给p的回调函数，如例3.9。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.8 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     setTimeout(resolve, 3000, &quot;first&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     resolve('second'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p3 = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   setTimeout(resolve, 1000, &quot;third&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}); 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; Promise.all([p1, p2, p3]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(values) { 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  console.log(values); 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; -------output-------
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;约 3s 后&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;] 
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.9 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   setTimeout(resolve, 1000, &quot;one&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}); 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   setTimeout(reject, 2000, &quot;two&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p3 = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   reject(&quot;three&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; Promise.all([p1, p2, p3]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log('resolve'&lt;span&gt;, value);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     console.log('reject', error);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; reject three&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; -------output-------
&lt;span&gt;19&lt;/span&gt; reject three
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.10 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; timerPromisefy(delay) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            resolve(delay);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }, delay);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; startDate =&lt;span&gt; Date.now();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;Promise.all([
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     timerPromisefy(1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     timerPromisefy(32&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     timerPromisefy(64&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     timerPromisefy(128&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; ]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (values) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     console.log(Date.now() - startDate + 'ms'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    console.log(values);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; -------output-------
&lt;span&gt;21&lt;/span&gt; 133ms       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不一定，但大于128ms&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; [1,32,64,128]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;articleHeader13&quot;&gt;.race()&lt;/h3&gt;
&lt;pre class=&quot;hljs typescript&quot;&gt;
&lt;code&gt;语法：&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.race(iterable)
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法同样是将多个Promise实例，包装成一个新的Promise实例。&lt;/p&gt;
&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var p = &lt;span class=&quot;hljs-built_in&quot;&gt;Promise.race([p1, p2, p3]);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Promise.race&lt;/code&gt;方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为&lt;code&gt;fulfilled&lt;/code&gt;或&lt;code&gt;rejected&lt;/code&gt;），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.11 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) { 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     setTimeout(reject, 500, &quot;one&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) { 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     setTimeout(resolve, 100, &quot;two&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; Promise.race([p1, p2]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     console.log('resolve'&lt;span&gt;, value); 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     console.log('reject'&lt;span&gt;, error); 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; -------output-------
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;resolve two
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p3 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) { 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     setTimeout(resolve, 500, &quot;three&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p4 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) { 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     setTimeout(reject, 100, &quot;four&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; Promise.race([p3, p4]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     console.log('resolve'&lt;span&gt;, value);              
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     console.log('reject'&lt;span&gt;, error); 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; -------output-------
&lt;span&gt;32&lt;/span&gt; reject four
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一个promise对象变为resolve后，并不会取消其他promise对象的执行，如下例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.12 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fastPromise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         console.log('fastPromise'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         resolve('resolve fastPromise'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     }, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; slowPromise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         console.log('slowPromise'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         resolve('resolve slowPromise'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }, 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个promise变为resolve后程序停止&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Promise.race([fastPromise, slowPromise]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     console.log(value);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; resolve fastPromise&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; -------output-------
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;fastPromise
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;resolve fastPromise
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; slowPromise     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;仍会执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;articleHeader14&quot;&gt;.resolve()&lt;/h3&gt;
&lt;p&gt;语法：&lt;/p&gt;

&lt;pre class=&quot;javascript hljs&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.resolve(value);
&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.resolve(promise);
&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.resolve(thenable);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它可以看做&lt;code&gt;new Promise()&lt;/code&gt;的快捷方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Promise.resolve('Success'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******等同于******&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     resolve('Success'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码会让这个Promise对象立即进入&lt;code&gt;resolved&lt;/code&gt;状态，并将结果&lt;code&gt;success&lt;/code&gt;传递给&lt;code&gt;then&lt;/code&gt;指定的&lt;code&gt;onFulfilled&lt;/code&gt;回调函数。由于&lt;code&gt;Promise.resolve()&lt;/code&gt;也是返回Promise对象，因此可以用&lt;code&gt;.then()&lt;/code&gt;处理其返回值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.13 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Promise.resolve(&lt;/span&gt;'success').then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
    console.log(value);
});
&lt;/span&gt;-------output-------&lt;span&gt;
Success&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.14 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Resolving an array&lt;/span&gt;
Promise.resolve([1,2,3]).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
  console.log(value[&lt;/span&gt;0]);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 1&lt;/span&gt;
&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Resolving a Promise&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; p1 = Promise.resolve('this is p1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p2 =&lt;span&gt; Promise.resolve(p1);
p2.then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
    console.log(value);     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; this is p1&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve()&lt;/code&gt;的另一个作用就是将&lt;code&gt;thenable&lt;/code&gt;对象（即带有&lt;code&gt;then&lt;/code&gt;方法的对象）转换为promise对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.15 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 =&lt;span&gt; Promise.resolve({ 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     then: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) { 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         resolve(&quot;this is an thenable object!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; console.log(p1 &lt;span&gt;instanceof&lt;/span&gt; Promise);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; p1.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     console.log(value);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; this is an thenable object!&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成&lt;code&gt;resolved&lt;/code&gt;或&lt;code&gt;rejected&lt;/code&gt;，状态不会再改变，这和新建promise是一样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例3.16 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在回调函数前抛异常&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 =&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     then: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;error&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       resolve(&quot;Resolved&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 =&lt;span&gt; Promise.resolve(p1);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; p2.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     console.log(error);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; Error: error&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在回调函数后抛异常&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p3 =&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     then: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         resolve(&quot;Resolved&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;error&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p4 =&lt;span&gt; Promise.resolve(p3);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; p4.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     console.log(value);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; Resolved&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;articleHeader15&quot;&gt;.reject()&lt;/h3&gt;
&lt;pre class=&quot;hljs typescript&quot;&gt;
&lt;code&gt;语法：&lt;span class=&quot;hljs-built_in&quot;&gt;Promise.reject(reason)
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法和上述的&lt;code&gt;Promise.resolve()&lt;/code&gt;类似，它也是&lt;code&gt;new Promise()&lt;/code&gt;的快捷方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Promise.reject(&lt;span&gt;new&lt;/span&gt; Error('error'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******等同于******&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     reject(&lt;span&gt;new&lt;/span&gt; Error('error'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码会让这个Promise对象立即进入&lt;code&gt;rejected&lt;/code&gt;状态，并将错误对象传递给&lt;code&gt;then&lt;/code&gt;指定的&lt;code&gt;onRejected&lt;/code&gt;回调函数。&lt;/p&gt;

&lt;p&gt;经过上一章的学习，相信大家已经学会使用&lt;code&gt;Promise&lt;/code&gt;。&lt;br/&gt;总结一下创建promise的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;new Promise(fn)&lt;/code&gt;或者它的快捷方式&lt;code&gt;Promise.resolve()&lt;/code&gt;、&lt;code&gt;Promise.reject()&lt;/code&gt;，返回一个promise对象&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;fn&lt;/code&gt;中指定异步的处理&lt;br/&gt;处理结果正常，调用&lt;code&gt;resolve&lt;/code&gt;&lt;br/&gt;处理结果错误，调用&lt;code&gt;reject&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果使用ES6的箭头函数，将会使写法更加简单清晰。&lt;/p&gt;
&lt;p&gt;这一章节，将会用例子的形式，以说明promise使用过程中的注意点及容易犯的错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情景1：&lt;/strong&gt;reject 和 catch 的区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;promise.then(onFulfilled, onRejected)&lt;br/&gt;在&lt;code&gt;onFulfilled&lt;/code&gt;中发生异常的话，在&lt;code&gt;onRejected&lt;/code&gt;中是捕获不到这个异常的。&lt;/li&gt;
&lt;li&gt;promise.then(onFulfilled).catch(onRejected)&lt;br/&gt;&lt;code&gt;.then&lt;/code&gt;中产生的异常能在&lt;code&gt;.catch&lt;/code&gt;中捕获&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况，还是建议使用第二种，因为能捕获之前的所有异常。当然了，第二种的&lt;code&gt;.catch()&lt;/code&gt;也可以使用&lt;code&gt;.then()&lt;/code&gt;表示，它们本质上是没有区别的，&lt;code&gt;.catch === .then(null, onRejected)&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;情景2：&lt;/strong&gt;如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例4.1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; taskA() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    console.log(x);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     console.log(&quot;Task A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; taskB() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     console.log(&quot;Task B&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; onRejected(error) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     console.log(&quot;Catch Error: A or B&quot;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; finalTask() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log(&quot;Final Task&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise =&lt;span&gt; Promise.resolve();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;promise
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    .then(taskA)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    .then(taskB)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     .&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(onRejected)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    .then(finalTask);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; -------output-------
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;Catch Error: A or B,ReferenceError: x is not defined
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; Final Task
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217233/201902/1217233-20190215100039202-1985905723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据例4.1的输出结果及流程图，可以看出，A抛错时，会按照 taskA → onRejected → finalTask这个流程来处理。A抛错后，若没有对它进行处理，如例3.7，状态就会维持&lt;code&gt;rejected&lt;/code&gt;，taskB不会执行，直到&lt;code&gt;catch&lt;/code&gt;了错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例4.2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; taskA() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    console.log(x);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     console.log(&quot;Task A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; taskB() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     console.log(&quot;Task B&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; onRejectedA(error) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     console.log(&quot;Catch Error: A&quot;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; onRejectedB(error) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log(&quot;Catch Error: B&quot;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; finalTask() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     console.log(&quot;Final Task&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise =&lt;span&gt; Promise.resolve();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;promise
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    .then(taskA)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     .&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(onRejectedA)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    .then(taskB)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     .&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(onRejectedB)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    .then(finalTask);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt; -------output-------
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;Catch Error: A ReferenceError: x is not defined
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;Task B
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; Final Task
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将例4.2与4.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;情景3：&lt;/strong&gt;每次调用&lt;code&gt;then&lt;/code&gt;都会返回一个新创建的promise对象，而&lt;code&gt;then&lt;/code&gt;内部只是返回的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例4.3 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法1：对同一个promise对象同时调用 then 方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p1 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     resolve(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; p1.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; value * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; p1.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; value * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; p1.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log(&quot;finally: &quot; +&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; -------output-------
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;: 100
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法2：对 then 进行 promise chain 方式进行调用&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; p2 = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     resolve(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; p2.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; value * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; value * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     console.log(&quot;finally: &quot; +&lt;span&gt; value);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; -------output-------
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;: 400
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一种方法中，&lt;code&gt;then&lt;/code&gt;的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。&lt;br/&gt;因此容易出现下面的错误写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 例4.4 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; badAsyncCall(data) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; promise =&lt;span&gt; Promise.resolve(data);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; value + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; badAsyncCall(10).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    console.log(value);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;想要得到11，实际输出10&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; -------output-------
&lt;span&gt;14&lt;/span&gt; 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确的写法应该是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 改写例4.4 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; goodAsyncCall(data) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; promise =&lt;span&gt; Promise.resolve(data);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; promise.then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; value + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; goodAsyncCall(10).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   console.log(value);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; -------output-------
&lt;span&gt;13&lt;/span&gt; 11
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;情景4：&lt;/strong&gt;在异步回调中抛错，不会被&lt;code&gt;catch&lt;/code&gt;到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Errors thrown inside asynchronous functions will act like uncaught errors&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; 'Uncaught Exception!'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   }, 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; promise.&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   console.log(e);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;This is never called&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;情景5：&lt;/strong&gt; promise状态变为&lt;code&gt;resove&lt;/code&gt;或&lt;code&gt;reject&lt;/code&gt;，就凝固了，不会再改变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
console.log(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve, reject){
    reject();
    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
        resolve();            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;not called&lt;/span&gt;
    }, 0&lt;span&gt;);
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;2&lt;span&gt;);
}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;3&lt;span&gt;);
});
console.log(&lt;/span&gt;4&lt;span&gt;);

&lt;/span&gt;-------output-------
1
4
3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于&lt;code&gt;promise&lt;/code&gt;就先介绍到这边了，比较基础，有不足的地方欢迎指出，有更好的也欢迎补充~&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 14:54:00 +0000</pubDate>
<dc:creator>半指温柔乐</dc:creator>
<og:description>一 前言 本文主要对ES6的Promise进行一些入门级的介绍。要想学习一个知识点，肯定是从三个方面出发，what、why、how。下面就跟着我一步步学习吧~ 二 什么是Promise 首先是what</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/le220/p/10381920.html</dc:identifier>
</item>
<item>
<title>行为型模式：中介者模式 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10398430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10398430.html</guid>
<description>&lt;p&gt;&lt;strong&gt;LieBrother公众号原文&lt;/strong&gt;：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/O3Puy9Rkg446-L12YeBzWw&quot;&gt;行为型模式：中介者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/5216aa7557944b89863934ebeeb20fac_0034_01.jpg&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;十一大行为型模式之二：中介者模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：中介者模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：Mediator Pattern&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价值观&lt;/strong&gt; ：让你体验中介是无所不能的存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.&lt;br/&gt;用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;br/&gt;（来自《设计模式之禅》）&lt;/p&gt;
&lt;h2 id=&quot;你要的故事&quot;&gt;你要的故事&lt;/h2&gt;
&lt;p&gt;看了这小伙子的名字，大家会很直观的想到那些拿了我们半个月租的租房中介同学。在这不讲讲房租中介同学，以后可没机会了。大家现在找房子，不管是买还是租，一登录什么安居客、58同城，是不是有 80% 是经纪人房源，说 80% 还是比较保守的，经历了 4 次找房，发现个人房源越来越少。每个网站都有个选项：经纪人房源。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/219aa8bbef794d12b6e00c704a09e533_0034_02.png&quot; alt=&quot;房源&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(图片截自：安居客网站)&lt;/p&gt;
&lt;p&gt;经纪人就扮演着中介的角色，和本文要讲的中介者模式完全吻合。我们在找房子的时候，经纪人扮演什么角色呢？我们通过个人房源和经纪人房源的租房案例来简单描述经纪人的角色。&lt;/p&gt;
&lt;h3 id=&quot;个人房源&quot;&gt;个人房源&lt;/h3&gt;
&lt;p&gt;我们通过个人房源找房子的方式是这样的：在网上找个人房源的房东，然后挨个联系，和房东约定好时间去看房，我们跟房东的关系是一对多的关系。小明就在网上看了个人房源，联系了房东，分别去看了农民房和小区房，用代码表示如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PersonalTest {

    public static void main(String[] args) {
        Tenant xiaoMing = new Tenant(&quot;小明&quot;);
        xiaoMing.lookAtHouse();
    }

}

class Tenant {
    private String name;
    private XiaoQuFangLandlord xiaoQuFangLandlord2 = new XiaoQuFangLandlord();
    private NongMinFangLandlord nongMinFangLandlord2 = new NongMinFangLandlord();

    public Tenant(String name) {
        this.name = name;
    }

    public void lookAtHouse() {
        System.out.println(this.name +&quot;想看农民房&quot;);
        nongMinFangLandlord2.supply();
        System.out.println(this.name + &quot;想看小区房&quot;);
        xiaoQuFangLandlord2.supply();
    }

}

/**
 * 房东
 */
abstract class Landlord {
    // 提供房子
    public abstract void supply();
}

class XiaoQuFangLandlord extends Landlord {

    @Override
    public void supply() {
        System.out.println(&quot;小区房的房东提供一间小区房&quot;);
    }
}

class NongMinFangLandlord extends Landlord {

    @Override
    public void supply() {
        System.out.println(&quot;农民房的房东提供一间小区房&quot;);
    }
}

打印结果如下：
小明想看农民房
农民房的房东提供一间小区房
小明想看小区房
小区房的房东提供一间小区房&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小明分别联系小区房的房东和农民房的房东，然后依次去看了农民房和小区房。这样子有个弊端就是小明和房东是强关联的关系，其实小明只是去看一下房，看完不想租就和房东没啥关系了。这个时候经纪人就派上用场了，经纪人的主要任务就是把房子租出去，所以他和房东应该是强关系，直到把房子成功租出去了，才和房东脱离关系，而小明也不用去挨个找房东看房子了，这个职责转给经纪人，小明只需要联系一个人，那就是经纪人，跟他说我要看小区房和农民房，经纪人就带他去看。下面就介绍经纪人房源的方式，也就是本文要讲的中介者模式。&lt;/p&gt;
&lt;h3 id=&quot;经纪人房源&quot;&gt;经纪人房源&lt;/h3&gt;
&lt;p&gt;用经纪人房源找房子，小明就省心很多了，小明就只联系了一个经纪人，跟他描述了自己要的房源：小区房和农民房都可以，经纪人里面和他约定了一个下午的时间，把小明所有想看的房让他看完，最终小明决定租了一间房。看代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MediatorTest {

    public static void main(String[] args) {
        System.out.println(&quot;小明想要看小区房和农民房&quot;);
        Tenant2 xiaoMing = new Tenant2(&quot;小明&quot;, Arrays.asList(&quot;XiaoQuFang&quot;, &quot;NongMinFang&quot;));
        xiaoMing.lookAtHouse();
    }


}

/**
 * 租客
 */
class Tenant2 {
    private String name;
    private List&amp;lt;String&amp;gt; wantTypes;

    private RentingMediator rentingMediator = new RentingMediator();

    public Tenant2(String name, List&amp;lt;String&amp;gt; wantTypes) {
        this.name = name;
        this.wantTypes = wantTypes;
    }

    public void lookAtHouse() {
        rentingMediator.supplyHouse(wantTypes);
    }

}

/**
 * 中介抽象类
 */
abstract class Mediator {
    // 看房
    public abstract void supplyHouse(List&amp;lt;String&amp;gt; types);
}

/**
 * 租房中介
 */
class RentingMediator extends Mediator {

    private XiaoQuFangLandlord xiaoQuFangLandlord;
    private NongMinFangLandlord nongMinFangLandlord;

    public RentingMediator() {
        xiaoQuFangLandlord = new XiaoQuFangLandlord();
        nongMinFangLandlord = new NongMinFangLandlord();
    }

    @Override
    public void supplyHouse(List&amp;lt;String&amp;gt; types) {
        System.out.println(&quot;经纪人提供了如下房源&quot;);
        if (types.contains(&quot;XiaoQuFang&quot;)) {
            xiaoQuFangLandlord.supply();
        }
        if (types.contains(&quot;NongMinFang&quot;)) {
            nongMinFangLandlord.supply();
        }
    }
}

打印结果：
小明想要看小区房和农民房
经纪人提供了如下房源
小区房的房东提供一间小区房
农民房的房东提供一间小区房&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中，我们可以看到小明和经纪人是一对一关系，经纪人和房东是一对多关系。小明找房经历也轻松多了，只花了一下午就把房子都看了并看中了。这也是中介者模式的优点，&lt;strong&gt;减少了不必要的依赖，降低了类间的耦合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/mediator/&quot;&gt;Mediator Pattern&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;中介者模式通过在互相依赖的对象中间加了一层，让原本强依赖的对象变成弱依赖&lt;/strong&gt;。在软件编程中，有一个中介者模式的典型的例子，就是 MVC 框架，也称三层架构，通过 Controller (控制层) 将 Model (业务逻辑层) 和 View (视图层) 的依赖给分离开，协调 Model 和 View 中的数据和界面交互工作。看看你工作中的代码，想想看有没有哪些对象之间的关系特紧密特混乱，考虑是不是可以通过中介者模式来把依赖关系剥离，让代码更清晰。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《设计模式之禅》&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3R81iasIH8d17pzWzHMuAg&quot;&gt;行为型模式：模板方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望文章对您有所帮助，设计模式系列会持续更新，感兴趣的同学可以关注公众号：&lt;strong&gt;LieBrother&lt;/strong&gt;，第一时间获取文章推送阅读，也可以一起交流，交个朋友。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 14:50:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>十一大行为型模式之二：中介者模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10398430.html</dc:identifier>
</item>
<item>
<title>在 asp.net core 中使用类似 Application 的服务 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/10398404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/10398404.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在 asp.net 中，我们可以借助 &lt;code&gt;Application&lt;/code&gt; 来保存一些服务器端全局变量，比如说服务器端同时在线的人数计数，比如一些网站的配置信息。&lt;/p&gt;
&lt;p&gt;在 ASP.NET 应用中，之前开发的活动室预约系统把网站的 keyword 以及 Title 等信息，在网站启动的时候会从数据库加载配置并保存到 &lt;code&gt;Application&lt;/code&gt; 中，在需要的地方直接使用 &lt;code&gt;Application&lt;/code&gt; 来获取，后台更新配置之后，更新 &lt;code&gt;Application&lt;/code&gt; 变量，这样就不需要重启网站就可以更新网站配置信息了，在 Razor 页面上使用&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/d3a99763f37f6b49bd9762dc27a62e2b2f4d814b/ActivityReservation/Views/Shared/_Layout.cshtml#L7&quot;&gt;示例&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;title&amp;gt;@ViewBag.Title - @HttpContext.Current.Application[&quot;SystemTitle&quot;]&amp;lt;/title&amp;gt;
&amp;lt;meta name=&quot;keywords&quot; content=&quot;@HttpContext.Current.Application[&quot;SystemKeywords&quot;]&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迁移到 asp.net core 后，就不能直接这样用了，于是自己实现了一个服务，去加载网站配置信息，比较简单简陋，权当是抛砖引玉，不喜勿喷&lt;/p&gt;
&lt;h2 id=&quot;自定义-application-服务-iapplicationsettingservice&quot;&gt;自定义 Application 服务 &lt;code&gt;IApplicationSettingService&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;服务接口定义：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation.Helper/Services/IApplicationSettingService.cs&quot;&gt;IApplicationSettingService&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public interface IApplicationSettingService
    {
        string GetSettingValue(string settingKey);

        string SetSettingValue(string settingKey, string settingValue);

        int AddSettings(Dictionary&amp;lt;string, string&amp;gt; dictionary);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于一个字典对象的简单实现：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation.Helper/Services/ApplicationSettingInMemoryService.cs&quot;&gt;ApplicationSettingInMemoryService&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class ApplicationSettingInMemoryService : IApplicationSettingService
    {
        private readonly Dictionary&amp;lt;string, string&amp;gt; _settingDictionary = new Dictionary&amp;lt;string, string&amp;gt;();

        public int AddSettings(Dictionary&amp;lt;string, string&amp;gt; dictionary)
        {
            if (dictionary != null &amp;amp;&amp;amp; dictionary.Count &amp;gt; 0)
            {
                foreach (var item in dictionary)
                {
                    _settingDictionary[item.Key] = item.Value;
                }
            }
            return _settingDictionary.Count;
        }

        public string GetSettingValue(string settingKey)
        {
            _settingDictionary.TryGetValue(settingKey, out var val);
            return val;
        }

        public string SetSettingValue(string settingKey, string settingValue)
        {
            _settingDictionary[settingKey] = settingValue;
            return settingValue;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以根据自己的需要写不同的实现，比如放在配置中或者自己的缓存中，这里应用暂时是单体应用，所以只是放在了内存对象中。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;ol readability=&quot;2.9657794676806&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在 Startup 中注册服务：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.TryAddSingleton&amp;lt;IApplicationSettingService, ApplicationSettingInMemoryService&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;从数据库中读取配置信息，初始化配置数据&lt;/li&gt;
&lt;li readability=&quot;3.9306358381503&quot;&gt;
&lt;p&gt;在 Razor 页面上使用，&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation/Views/Shared/_Layout.cshtml&quot;&gt;示例&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@using ActivityReservation.Services
@inject IApplicationSettingService applicationSettings
/*  此处省略 N 行代码 ... */
&amp;lt;title&amp;gt;@($&quot;{ViewBag.Title} -- {applicationSettings.GetSettingValue(&quot;SystemTitle&quot;)}&quot;) &amp;lt;/title&amp;gt;
&amp;lt;meta name=&quot;keywords&quot; content=&quot;@(applicationSettings.GetSettingValue(&quot;SystemKeywords&quot;))&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 18 Feb 2019 14:45:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>在 asp.net 中，我们可以借助 Application 来保存一些服务器端全局变量，比如说服务器端同时在线的人数计数，比如一些网站的配置信息。 在 ASP.NET 应用中，之前开发的活动室预约</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/10398404.html</dc:identifier>
</item>
<item>
<title>前端进击的巨人（七）：走进面向对象，原型与原型链，继承方式 - Kenz</title>
<link>http://www.cnblogs.com/kenz520/p/10398086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenz520/p/10398086.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7324444-d54e856f02d99949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;前端进击的巨人（七）：带你走进面向对象，原型，继承&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;面向对象&quot; 是以 &quot;对象&quot; 为中心的编程思想，它的思维方式是构造。&lt;/p&gt;
&lt;p&gt;&quot;面向对象&quot; 编程的三大特点：&lt;strong&gt;&quot;封装、继承、多态”&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;封装：属性方法的抽象&lt;/li&gt;
&lt;li&gt;继承：一个类继承（复制）另一个类的属性/方法&lt;/li&gt;
&lt;li&gt;多态：方法（接口）重写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&quot;面向对象&quot; 编程的核心，离不开 &quot;类&quot; 的概念。简单地理解下 &quot;类&quot;，它是一种抽象方法。通过 &quot;类&quot; 的方式，可以创建出多个具有相同属性和方法的对象。&lt;/p&gt;
&lt;p&gt;但是！但是！但是JavaScript中并没有 &quot;类&quot; 的概念，对的，没有。&lt;/p&gt;
&lt;p&gt;ES6 新增的 &lt;code&gt;class&lt;/code&gt; 语法，只是一种模拟 &quot;类&quot; 的语法糖，底层机制依旧不能算是标准 &quot;类&quot; 的实现方式。&lt;/p&gt;
&lt;p&gt;在理解JavaScript中如何实现 &quot;面向对象&quot; 编程之前，有必要对JavaScript中的对象先作进一步地了解。&lt;/p&gt;
&lt;h3 id=&quot;什么是对象&quot;&gt;什么是对象&lt;/h3&gt;
&lt;p&gt;对象是&lt;strong&gt;&quot;无序属性&quot;&lt;/strong&gt;的集合，表现为&lt;strong&gt;&quot;键/值对&quot;&lt;/strong&gt;的形式。属性值可包含任何类型值（基本类型、引用类型：对象/函数/数组）。&lt;/p&gt;
&lt;p&gt;有些文章指出&lt;strong&gt;&quot;JS中一切都是对象&quot;&lt;/strong&gt;，略有偏颇，修正为：&lt;strong&gt;&quot;JS中一切引用类型都是对象&quot;&lt;/strong&gt;更为稳妥些。&lt;/p&gt;
&lt;p&gt;函数 / 数组都属于对象，数组就是对象的一种子类型，不过函数稍微复杂点，它跟对象的关系，有点&quot;鸡生蛋，蛋生鸡&quot;的关系，可先记住：&lt;strong&gt;&quot;对象由函数创建&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;简单对象的创建&quot;&gt;简单对象的创建&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字面量声明（常用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 操作符调用 &lt;code&gt;Object&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 字面量
let person = {
  name: '以乐之名'
};

// new Object()
let person = new Object();
person.name = '以乐之名';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上两种创建对象的方式，并不具备创建多个具有相同属性的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS：&lt;code&gt;new&lt;/code&gt; 操作符会对所有函数进行劫持，将函数变成构造函数（对函数的构造调用）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象属性的访问方式&quot;&gt;对象属性的访问方式&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 操作符访问 (也称 &lt;strong&gt;&quot;键访问&quot;&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 操作符访问（也称 &lt;strong&gt;&quot;属性访问&quot;&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;操作符-vs-操作符&quot;&gt;&lt;code&gt;.&lt;/code&gt; 操作符 VS &lt;code&gt;[]&lt;/code&gt; 操作符：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 访问属性时，属性名需遵循标识符规范，兼容性比 &lt;code&gt;[]&lt;/code&gt; 略差；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 接受任意UTF-8/Unicode字符串作为属性名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 支持动态属性名（变量）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 支持表达式计算（字符串连接 / ES6的&lt;code&gt;Symbol&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;TIPS: 标识符命名规范 —— 数字/英文字母/下划线组成，开头不能是数字。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 任意UTF-8/Unicode字符串作为属性名
person['$my-name'];

// 动态属性名（变量）
let attrName = 'name';
person[attrName];  

// 表达式计算
let attrPrefix = 'my_';
person[attrPrefix + 'name'];  // person['my_name']
person[Symbol.name];          // Symbol在属性名的应用&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;属性描述符&quot;&gt;属性描述符&lt;/h3&gt;
&lt;p&gt;ES5新增 &quot;属性描述符&quot;，可针对对象属性的特性进行配置。&lt;/p&gt;
&lt;h4 id=&quot;属性特性的类型&quot;&gt;属性特性的类型&lt;/h4&gt;
&lt;h5 id=&quot;数据属性&quot;&gt;1. 数据属性&lt;/h5&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;&lt;code&gt;Configurable&lt;/code&gt; 可配置（可删除）？&lt;code&gt;[true|false]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enumerable&lt;/code&gt; 可枚举 &lt;code&gt;[true|false]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Writable&lt;/code&gt; 可写？ &lt;code&gt;[true|false]&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Value&lt;/code&gt; 值？默认&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;访问器属性&quot;&gt;2. 访问器属性&lt;/h5&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Get [[Getter]]&lt;/code&gt; 读取方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Set [[Setter]]&lt;/code&gt; 设置方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;访问器属性优先级高于数据属性&quot;&gt;访问器属性优先级高于数据属性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;访问器属性会优于 &lt;code&gt;writeable/value&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;获取属性值时，如果对象属性存在 &lt;code&gt;get()&lt;/code&gt;，会忽略其 &lt;code&gt;value&lt;/code&gt; 值，直接调用 &lt;code&gt;get()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;设置属性值时，如果对象属性存在 &lt;code&gt;set()&lt;/code&gt;，会忽略 &lt;code&gt;writable&lt;/code&gt; 的设置，直接调用 &lt;code&gt;set()&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;访问器属性日常应用：
&lt;ul&gt;&lt;li&gt;属性值联动修改（一个属性值修改，会触发另外属性值修改）；&lt;/li&gt;
&lt;li&gt;属性值保护（只能通过 &lt;code&gt;set()&lt;/code&gt; 制定逻辑修改属性值）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;定义属性特性&quot;&gt;定义属性特性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt; 定义单个属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.defineProperties()&lt;/code&gt; 定义多个属性&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let Person = {};
Object.defineProperty('Person', 'name', {
  writable: true,
  enumerable: true,
  configurable: true,
  value: '以乐之名'
});
Person.name;   // 以乐之名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TIPS：使用 &lt;code&gt;Object.defineProperty/defineProperties&lt;/code&gt; 定义属性时，属性特性 &lt;code&gt;configurable/enumerable/writable&lt;/code&gt; 值默认为 &lt;code&gt;false&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt; 默认为 &lt;code&gt;undefined&lt;/code&gt;。其它方式创建对象属性时，前三者值都为 &lt;code&gt;true&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可使用&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt; 来获取对象属性的特性描述。&lt;/p&gt;
&lt;h3 id=&quot;原型&quot;&gt;原型&lt;/h3&gt;
&lt;p&gt;JavaScript中模拟 &quot;面向对象&quot; 中 &quot;类&quot; 的实现方式，是利用了JavaScript中函数的一个特性（属性）——&lt;code&gt;prototype&lt;/code&gt;（本身是一个对象）。&lt;/p&gt;
&lt;p&gt;每个函数默认都有一个 &lt;code&gt;prototype&lt;/code&gt; 属性，它就是我们所说的 &lt;strong&gt;&quot;原型&quot;&lt;/strong&gt;，或称 &lt;strong&gt;&quot;原型对象&quot;&lt;/strong&gt;。每个实例化创建的对象都有一个 &lt;code&gt;__proto__&lt;/code&gt; 属性（&lt;strong&gt;隐式原型&lt;/strong&gt;），它指向创建它的构造函数的 &lt;code&gt;prototype&lt;/code&gt; 属性。&lt;/p&gt;
&lt;h4 id=&quot;new-函数实现原型关联&quot;&gt;new + 函数（实现&quot;原型关联&quot;）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;let Person = function(name, age) {
  this.name = name;
  this.age = age;
};
Person.prototype.say = function() {};

let father = new Person('David', 48);
let mother = new Person('Kelly', 46);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7324444-299deacb39f17a1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;原型例子&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;操作符的执行过程，会对实例对象进行 &lt;strong&gt;&quot;原型关联&quot;&lt;/strong&gt;，或称 &quot;原型链接&quot;。&lt;/p&gt;
&lt;h4 id=&quot;new的执行过程&quot;&gt;new的执行过程&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;创建（构造）一个全新的空对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“这个新对象会被执行&quot;原型&quot;链接（新对象的&lt;code&gt;__proto__&lt;/code&gt;会指向函数的&lt;code&gt;prototype&lt;/code&gt;)”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;构造函数的&lt;code&gt;this&lt;/code&gt;会指向这个新对象，并对&lt;code&gt;this&lt;/code&gt;属性进行赋值&lt;/li&gt;
&lt;li&gt;如果函数没有返回其他对象，则返回这个新对象（注意构造函数的&lt;code&gt;return&lt;/code&gt;，一般不会有&lt;code&gt;return&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;原型链&quot;&gt;原型链&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&quot;对象由函数创建&quot;&lt;/strong&gt;，既然 &lt;code&gt;prototype&lt;/code&gt; 也是对象，那么它的 &lt;code&gt;__proto__&lt;/code&gt; 原型链上应该还有属性。&lt;code&gt;Person.prototype.__proto__&lt;/code&gt; 指向 &lt;code&gt;Function.prototype&lt;/code&gt;，而&lt;code&gt;Function.prototype.__proto__&lt;/code&gt; 最终指向 &lt;code&gt;Object.prototype.__proto__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIPS：&lt;code&gt;Object.prototype.__proto__&lt;/code&gt; 指向 &lt;code&gt;null&lt;/code&gt;（特例）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日常调用对象的 &lt;code&gt;toString()/valueOf()&lt;/code&gt; 方法，虽然没有去定义它们，但却能正常使用。实际上这些方法来自 &lt;code&gt;Object.prototype&lt;/code&gt;，所有普通对象的原型链最终都会指向 &lt;code&gt;Object.prototype&lt;/code&gt;，而对象通过原型链关联（继承）的方式，使得实例对象可以调用 &lt;code&gt;Object.prototype&lt;/code&gt; 上的属性 / 方法。&lt;/p&gt;
&lt;p&gt;访问一个对象的属性时，会先在其基础属性上查找，找到则返回值；如果没有，会沿着其原型链上进行查找，整条原型链查找不到则返回 &lt;code&gt;undefined&lt;/code&gt;。这就是原型链查找。&lt;/p&gt;
&lt;h3 id=&quot;基础属性与原型属性&quot;&gt;基础属性与原型属性&lt;/h3&gt;
&lt;h4 id=&quot;hasownproperty&quot;&gt;hasOwnProperty()&lt;/h4&gt;
&lt;p&gt;判断对象基础属性中是否有该属性，基础属性返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;涉及-in-操作都是所有属性基础-原型&quot;&gt;涉及 in 操作都是所有属性（基础 + 原型）&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;for...in...&lt;/code&gt; 遍历对象所有可枚举属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt; 判断对象是否拥有该属性&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;object.keys...与object.getownpropertynames...&quot;&gt;Object.keys(...)与Object.getOwnPropertyNames(...)&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Object.keys(...)&lt;/code&gt; 返回所有可枚举属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames(...)&lt;/code&gt; 返回所有属性&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;屏蔽属性&quot;&gt;屏蔽属性&lt;/h3&gt;
&lt;p&gt;修改对象属性时，如果属性名与原型链上属性重名，则在实例对象上创建新的属性，屏蔽对象对原型属性的使用（发生屏蔽属性）。&lt;strong&gt;屏蔽属性的前提是，对象基础属性名与原型链上属性名存在重名&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;创建对象属性时属性特性对屏蔽属性的影响&quot;&gt;创建对象属性时，属性特性对屏蔽属性的影响&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;对象原型链上有同名属性，且可写，在对象上创建新属性（屏蔽原型属性）；&lt;/li&gt;
&lt;li&gt;对象原型链上有同名属性，且只读，忽略；&lt;/li&gt;
&lt;li&gt;对象原型链上有同名属性，存在访问器属性 &lt;code&gt;set()&lt;/code&gt;，调用 &lt;code&gt;set()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;批量创建对象的方式&quot;&gt;批量创建对象的方式&lt;/h3&gt;
&lt;p&gt;创建多个具有相同属性的对象&lt;/p&gt;
&lt;h4 id=&quot;工厂模式&quot;&gt;1. 工厂模式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function createPersonFactory(name, age) {
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  obj.say = function() {
    console.log(`My name is ${this.name}, i am ${this.age}`);
  }
}

var father = createPersonFactory('David', 48);
var mother = createPersonFactory('Kelly', 46);
father.say();  // 'My name is David, i am 48'
mother.say();  // 'My name is Kelly, i am 46'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无法解决对象识别问题&lt;/li&gt;
&lt;li&gt;属性值为函数时无法共用，不同实例对象的 &lt;code&gt;say&lt;/code&gt; 方法没有共用内存空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;obj.say = function(){...}&lt;/code&gt; 实例化一个对象时都会开辟新的内存空间，去存储&lt;code&gt;function(){...}&lt;/code&gt;，造成不必要的内存开销。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;father.say == mother.say;  // false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造函数new&quot;&gt;2. 构造函数（&lt;code&gt;new&lt;/code&gt;)&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function() {
    console.log(`My name is ${this.name}, i am ${this.age}`);
  }
}

let father = new Person('David', 48);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点：属性值为引用类型（&lt;code&gt;say&lt;/code&gt;方法）时无法共用，不同实例对象的 &lt;code&gt;say&lt;/code&gt; 方法没有共用内存空间（与工厂模式一样）。&lt;/p&gt;
&lt;h4 id=&quot;原型模式&quot;&gt;3. 原型模式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person() {}
Person.prototype.name = 'David';
Person.prototype.age = 48;
Person.prototype.say = function() {
  console.log(`My name is ${this.name}, i am ${this.age}`);
};

let father = new Person();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：解决公共方法内存占用问题（所有实例属性的 &lt;code&gt;say&lt;/code&gt; 方法共用内存）&lt;br/&gt;缺点：属性值为引用类型时，因内存共用，一个对象修改属性会造成其它对象使用属性发生改变。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Person.prototype.like = ['sing', 'dance'];
let father = new Person();
let mother = new Person();
father.like.push('travel');

// 引用类型共用内存，一个对象修改属性，会影响其它对象
father.like;  // ['sing', 'dance', 'travel']
mother.like;  // ['sing', 'dance', 'travel']&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造函数-原型经典组合&quot;&gt;4. 构造函数 + 原型（经典组合）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.say = function() {
  console.log(`My name is ${this.name}, i am ${this.age}`);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：结合构造函数和原型的优点，&lt;strong&gt;&quot;构造函数初始化属性，原型定义公共方法&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;动态原型&quot;&gt;5. 动态原型&lt;/h4&gt;
&lt;p&gt;构造函数 + 原型的组合方式，区别于其它 &quot;面向对象&quot; 语言的声明方式。属性方法的定义并没有统一在构造函数中。因此动态原型创建对象的方式，则是在 &quot;构造函数 + 原型组合&quot; 基础上，优化了定义方式（区域）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Person(name, age) {
  this.name = name;
  this.age = age;
 
  // 判断原型是否有方法，没有则添加；
  // 原型上的属性在构造函数内定义，仅执行一次 
  if (!Person.prototype.say) {
    Person.prototype.say = function() {
      console.log(`My name is ${this.name}, i am ${this.age}`);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：属性方法统一在构造函数中定义。&lt;/p&gt;
&lt;p&gt;除了以上介绍的几种对象创建方式，此外还有&quot;寄生构造函数模式&quot;、&quot;稳妥构造函数模式&quot;。日常开发较少使用，感兴趣的伙伴们可自行了解。&lt;/p&gt;
&lt;h3 id=&quot;类-的继承&quot;&gt;&quot;类&quot; 的继承&lt;/h3&gt;
&lt;p&gt;传统的面向对象语言中，&quot;类&quot; 继承的原理是 &quot;类&quot; 的复制。但JavaScript模拟 &quot;类&quot; 继承则是通过 &lt;strong&gt;&quot;原型关联&quot;&lt;/strong&gt; 来实现，并不是 &quot;类&quot; 的复制。正如《你不知道的JavaScript》中提出的观点，这种模拟 &quot;类&quot; 继承的方式，更像是 &lt;strong&gt;&quot;委托&quot;&lt;/strong&gt;，而不是 &lt;strong&gt;&quot;继承&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下列举JavaScript中常用的继承方式，预先定义两个类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&quot;Person&quot; 父类（超类）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&quot;Student&quot; 子类（用来继承父类）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 父类统一定义
function Person(name, age) {
  // 构造函数定义初始化属性
  this.name = name;
  this.age = age;
}
// 原型定义公共方法
Person.prototype.eat = function() {};
Person.prototype.sleep = function() {};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;原型继承&quot;&gt;原型继承&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 原型继承
function Student(name, age, grade) {
  this.grade = grade;
};
Student.prototype = new Person();  // Student原型指向Person实例对象
Student.prototype.constructor = Student;  // 原型对象修改，需要修复constructor属性
let pupil = new Student(name, age, grade);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;原理&quot;&gt;原理：&lt;/h5&gt;
&lt;p&gt;子类的原型对象为父类的实例对象，因此子类原型对象中拥有父类的所有属性&lt;/p&gt;
&lt;h5 id=&quot;缺点&quot;&gt;缺点：&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;无法向父类构造函数传参，初始化属性值&lt;/li&gt;
&lt;li&gt;属性值是引用类型时，存在内存共用的情况&lt;/li&gt;
&lt;li&gt;无法实现多继承（只能为子类指定一个原型对象）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;构造函数继承&quot;&gt;构造函数继承&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 构造函数继承
function Student(name, age, grade) {
  Person.call(this, name, age);
  this.grade = grade;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;原理-1&quot;&gt;原理：&lt;/h5&gt;
&lt;p&gt;调用父类构造函数，传入子类的上下文对象，实现子类参数初始化赋值。仅实现部分继承，无法继承父类原型上的属性。可 &lt;code&gt;call&lt;/code&gt; 多个父类构造函数，实现多继承。&lt;/p&gt;
&lt;h5 id=&quot;缺点-1&quot;&gt;缺点：&lt;/h5&gt;
&lt;p&gt;属性值为引用类型时，需开辟多个内存空间，多个实例对象无法共享公共方法的存储，造成不必要的内存占用。&lt;/p&gt;
&lt;h4 id=&quot;原型-构造函数继承经典&quot;&gt;原型 + 构造函数继承（经典）&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 原型 + 构造函数继承
function Student(name, age, grade) {
  Person.call(this, name, age);  // 第一次调用父类构造函数
  this.grade = grade;
}
Student.prototype = new Person();  // 第二次调用父类构造函数
Student.prototype.constructor = Student;  // 修复constructor属性&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;原理-2&quot;&gt;原理：&lt;/h5&gt;
&lt;p&gt;结合原型继承 + 构造函数继承两者的优点，&lt;strong&gt;&quot;构造函数继承并初始化属性，原型继承公共方法&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;缺点-2&quot;&gt;缺点：&lt;/h5&gt;
&lt;p&gt;父类构造函数被调用了两次。&lt;/p&gt;
&lt;p&gt;待优化：父类构造函数第一次调用时，已经完成父类构造函数中** &quot;属性的继承和初始化&quot;&lt;strong&gt;，第二次调用时只需要&lt;/strong&gt; &quot;继承父类原型属性&quot;** 即可，无须再执行父类构造函数。&lt;/p&gt;
&lt;h4 id=&quot;寄生组合式继承理想&quot;&gt;寄生组合式继承（理想）&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 寄生组合式继承
function Student(name, age, grade) {
  Person.call(this, name, age);
  this.grade = grade;
}
Student.prototype = Object.create(Person.prototype);  
// Object.create() 会创建一个新对象，该对象的__proto__指向Person.prototype
Student.prototype.constructor = Student;

let pupil = new  Student('小明', 10, '二年级');&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;原理-3&quot;&gt;原理：&lt;/h5&gt;
&lt;p&gt;创建一个新对象，将该对象原型关联至父类的原型对象，子类 &lt;code&gt;Student&lt;/code&gt; 已使用 &lt;code&gt;call&lt;/code&gt; 来调用父类构造函数完成初始化，所以只需再继承父类原型属性即可，避免了经典组合继承调用两次父类构造函数。（较完美的继承方案）&lt;/p&gt;
&lt;h4 id=&quot;es6的class语法&quot;&gt;ES6的class语法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class Person {
  constructor(name, age) {
    this.name = name;
    this.grade = grade;
  }
  
  eat () {  //...  }
  sleep () {  //...  }
}

class Student extends Person {
  constructor (name, age, grade) {
    super(name, age);
    this.grade = grade;
  }

  play () {  //...  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：ES6提供的 &lt;code&gt;class&lt;/code&gt; 语法使得类继承代码语法更加简洁。&lt;/p&gt;
&lt;h3 id=&quot;object.create...&quot;&gt;Object.create(...)&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Object.create()&lt;/code&gt;方法会创建一个新对象，使用现有对象来提供新创建的对象的&lt;code&gt;__proto__&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Object.create&lt;/code&gt; 实现的其实是&quot;对象关联&quot;，直接上代码更有助于理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let person = {
  eat: function() {};
  sleep: function() {};
}

let father = Object.create(person); 
// father.__proto__ -&amp;gt; person, 因此father上有eat/sleep/talk等属性

father.eat();
father.sleep();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，我们并没有使用构造函数 / 类继承的方式，但 &lt;code&gt;father&lt;/code&gt; 却可以使用来自 &lt;code&gt;person&lt;/code&gt; 对象的属性方法，底层原理依赖于原型和原型链的魔力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Object.create实现原理/模拟
Object.create = function(o) {
  function F() {}
  F.prototype = o;
  return new F();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.create(...)&lt;/code&gt; 实现的 &quot;对象关联&quot; 的设计模式与 &quot;面向对象&quot; 模式不同，它并没有父类，子类的概念，甚至没有 &quot;类&quot; 的概念，只有对象。它倡导的是 &lt;strong&gt;&quot;委托&quot;&lt;/strong&gt; 的设计模式，是基于 &lt;strong&gt;&quot;面向委托&quot;&lt;/strong&gt; 的一种编程模式。&lt;/p&gt;
&lt;p&gt;文章篇幅有限，仅作浅显了解，后续可另开一章讲讲 &quot;面向对象&quot; VS &quot;面向委托&quot;，孰优孰劣，说一道二。&lt;/p&gt;
&lt;h3 id=&quot;对象识别检查-类-关系&quot;&gt;对象识别（检查 &quot;类&quot; 关系）&lt;/h3&gt;
&lt;h4 id=&quot;instanceof&quot;&gt;instanceof&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 只能处理对象与函数的关系判断。&lt;code&gt;instanceof&lt;/code&gt; 左边是对象，右边是函数。判断规则：沿着对象的 &lt;code&gt;__proto__&lt;/code&gt; 进行查找，沿着函数的 &lt;code&gt;prototype&lt;/code&gt; 进行查找，如果有关联引用则返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let pupil = new Student();
pupil instanceof Student;  // true
pupil instanceof Person;   // true Student继承了Person&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;object.prototype.isprototypeof...&quot;&gt;Object.prototype.isPrototypeOf(...)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Object.prototype.isPrototyepOf(...)&lt;/code&gt; 可以识别对象与对象，也可以是对象与函数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let pupil = new Student();
Student.prototype.isPrototypeOf(pupil); // true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断规则：在对象 &lt;code&gt;pupil&lt;/code&gt; 原型链上是否出现过 &lt;code&gt;Student.prototype&lt;/code&gt; , 如果有则返回 &lt;code&gt;true&lt;/code&gt;， 否则返回 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES6新增修改对象原型的方法：&lt;code&gt;Object.setPrototypeOf(obj, prototype)&lt;/code&gt;，存在有性能问题，仅作了解，更推荐使用 &lt;code&gt;Object.create(...)&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Student.prototype = Object.create(Person.prototype);
// setPrototypeOf改写上行代码
Object.setPrototypeOf(Student.prototype, Person.prototype);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;后语&quot;&gt;后语&lt;/h3&gt;
&lt;p&gt;&quot;面向对象&quot; 是程序编程的一种设计模式，具备 &lt;strong&gt;&quot;封装，继承，多态&quot;&lt;/strong&gt; 的特点，在ES6的 &lt;code&gt;class&lt;/code&gt; 语法未出来之前，原型继承确实是JavaScript入门的一个难点，特别是对新入门的朋友，理解起来并不友好，模拟继承的代码写的冗余又难懂。好在ES6有了 &lt;code&gt;class&lt;/code&gt; 语法糖，不必写冗余的类继承代码，代码写少了，眼镜片都亮堂了。&lt;/p&gt;
&lt;p&gt;老话说的好，“会者不难”。深入理解面向对象，原型，继承，对日后代码能力的提升及编码方式优化都有益处。好的方案不只有一种，明白个中缘由，带你走进新世界大门。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;本文首发Github，期待Star！&lt;br/&gt;&lt;a href=&quot;https://github.com/ZengLingYong/blog&quot; class=&quot;uri&quot;&gt;https://github.com/ZengLingYong/blog&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：以乐之名&lt;br/&gt;本文原创，有不当的地方欢迎指出。转载请指明出处。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 Feb 2019 13:41:00 +0000</pubDate>
<dc:creator>Kenz</dc:creator>
<og:description>'面向对象' 是以 '对象' 为中心的编程思想，它的思维方式是构造。 '面向对象' 编程的三大特点： '封装、继承、多态” ： 1. 封装：属性方法的抽象 2. 继承：一个类继承（复制）另一个类的属性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenz520/p/10398086.html</dc:identifier>
</item>
<item>
<title>跳槽找工作避坑指南（2019版） - 民工哥</title>
<link>http://www.cnblogs.com/youkanyouxiao/p/10398041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youkanyouxiao/p/10398041.html</guid>
<description>&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;amp;mid=2247488383&amp;amp;idx=1&amp;amp;sn=ce2a2273cd62d35a697ab43719d6c5af&amp;amp;chksm=e91b7663de6cff75f7fc9cc0e45e27f118a5f4d3545f0b16f657b19ef27bdae5cb1fcd62a4f3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icbyzk9reVWDUfNsNvibbOmPumOWpJticY7iadvaPpI7ht0lkTYNDANWHVg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPrcDyQicbvy0jBBQlqtSV2mf3BKyjvR7DhF8QibHYpp9L6dxAA6vq0y800pNjtWGyLf7IkUNW3QRliaA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;32.37410071942446&quot; data-cropy2=&quot;383.63309352517985&quot; data-ratio=&quot;0.39&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icbyzk9reVWDUfNsNvibbOmPumOWpJticY7iadvaPpI7ht0lkTYNDANWHVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号：&lt;/strong&gt;民工哥技术之路&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文/作者：&lt;/strong&gt;民工哥&lt;/p&gt;
&lt;p&gt;虽说年前就有很多人在修改简历、刷新简历，但是为了大家心中所谓的年终奖，99.9999%的人都会选择沉默，有一种「明修栈道，暗度陈仓」意味。&lt;/p&gt;
&lt;p&gt;拿完了年终奖，过完了春节，老子早TMD的不想干了，终于不用在你「对象是种扣嗖的老板或领导」这里受你这等鸟气了。于是乎，吭哧吭哧的埋头苦写简历，狂撒网，做梦都想有朝一日能出任CEO，迎娶白富美，走上人生的巅峰。&lt;/p&gt;
&lt;p&gt;理想是丰满的，现实是残酷的，搞不好，美梦没有做完，就会吃上一记当头一棒，将你打入「绝情谷」谷底。所以，跳槽找工作一定要慎重，慎重，再慎重。&lt;/p&gt;
&lt;p&gt;之前也写过类似的一篇文章「&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;amp;mid=2247488286&amp;amp;idx=1&amp;amp;sn=8b582d3425123591a1c9ffe8686d0d12&amp;amp;chksm=e91b7602de6cff146062cfcd805a04aa092e46ece221d72c2cbdb119cc1ffb7858221fd4ca28&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;与努力同样重要的是，学会做好这 6 点！&lt;/a&gt;」，混职场的读者可以参考参考。但今天，我不们不讲混职场，只讨论求职找工作中如何避坑，否则，又像网友调侃那样：这是跳出一坑，又入一坑啊，总之坑不完啊。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5909090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icvZicCTE64syTRxeYw0mTjdByE2LKPK0QSa432SITJLVYXxNlyd2cANw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;创业公司的坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里并不是讲创业公司不好，不喜者请绕道。&lt;/p&gt;
&lt;p&gt;创业公司其实要看公司的发展前景与创始人的战略眼光、思维方式、处事等一些因素，好的创业公司它的发展是飞速的，当然初期活肯定也会累一点，身兼多职的情况也会存在，但报酬薪水是成正比的，这类创业公司其实适合有一定工作经验，但寻求好的平台施展的读者们加入，抓住机遇，说不定就改变了你一生的命运。&lt;/p&gt;
&lt;p&gt;但，坑的公司也有，比如说：创业初期，待遇比你原来的还低，甚至80%不到，老板会讲初始员工有股权、期权，但是这些是如何兑现？什么时候能兑现？或者说凭公司目前的发展速度大概到什么样一个阶段能将你那20%的待遇持平？无从知晓。这类创业公司不是小坑，那就是个大坑，员工不能光干活，不吃饭哪。这无益于「坑蒙拐骗」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;外包公司的坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样，好的外包公司有，但按理说不多。&lt;/p&gt;
&lt;p&gt;现在的行情，外包公司招人很难。因为一方面，客户方要求越来越高，另一方面求职者的要求也会越来越高，两方面的压力与需求，一般的外包企业很难从中平衡，终究是要得罪一方才能求得生存。&lt;/p&gt;
&lt;p&gt;大多数外包企业的坑是：比如应聘时说直接与客户方签定合同，享受客户同等待遇，唯一区别是不是客户方的制内的员工而已。但是，实际是还是与外包企业签定合同，然后以外派的形式去客户方干活，工资与社保由外包公司发放，干过的读者都知道这里面的道道，就不一一说明了。其实，这个事实反差还不算比较坑。&lt;/p&gt;
&lt;p&gt;最比较坑的是什么呢，客户方驻场的活不好干，而且拿的薪水被外包压榨后不及三分之一的原来薪水，而且，动不动被罚，动不动被回退至原公司，这其中很大一部分原因，都是外包企业与客户方的人际关系处理不得当造成的。其实，客户方并不愿意这么干，用人都是有成本的。这个就等同于领导们犯的错，员工来背锅，一个道理。&lt;/p&gt;
&lt;p&gt;这也就是，为什么现在越来越多的求职者不愿意进外包公司的原因。并不是外包公司不好，而且，存在一定的问题。有时候是让求职者不敢去，去了怕做不好两头受气，还得离职找工作，再或者还有可能由于各种奇葩的理由被开。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;3、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;试用期过长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;试用期过长，在很多企业很常见，最常见的就是6个月试用期。&lt;/p&gt;
&lt;p&gt;在某此企业中是存的，比如，驻场技术支持的岗位，这类岗位一般工作可替代性较强，现成的文档与手册，不用太高深的技术水平，按正常流程与规则操作即可完成指定的工作内容。这种坑对找实习工作的读者们来讲，千万要注意，很多企业打着招实习生的旗号，其实就是在找苦力工，让你干上几个月的试用期，然后以各种理由让你打包卷铺盖滚蛋的大有人在。&lt;/p&gt;
&lt;p&gt;还有一些企业，可能比较小，人数也不多，但是呢，试用考核期也很长，这类企业在求职时也得慎重，注意了，别干着干着试用期还没到期，企业倒闭了。&lt;/p&gt;
&lt;p&gt;这里提一点，还有一些很鸡贼的企业，发明了一个名词：试岗期，很有意思的一个玩意。说白了就是你来公司试岗一周或多少天，原则上是没有报酬的，试岗期通过进入试用期，再然后正式期之后这钱可以给你，否则咱俩两清没有关系，而且还是与你签定所谓的试岗协议[协议一般内容为员工自愿进入试岗期，自原无薪]，去规避法律风险。其实，如果你遇到这种企业，个人建议与之说再见，本身的做法就是违法的。&lt;/p&gt;
&lt;p&gt;还有一点也得注意的是，如果你真遇上好的企业并且试用期在6个月的，那么你一定要事前与HR确认是否劳动合同期限为三年或以上，否则，你们这个用人关系是违法的，不太了解的可以看下《劳动法》。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;4、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;不交社保，工资私下转账&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这类现像在一、二线城市应该来讲比较少见，不交社保是严重违法行为，这是要受到处罚的。&lt;/p&gt;
&lt;p&gt;在三、四线城市，我想应该绝对存在的，有些企业，甚至不是正式注册的企业，三五个人的小公司（真不是看不上小公司），蜗居在小区民房里办公。然后呢，同员工讲如果你同意不交社保公司每月给你补贴多少多少钱。很多人一想社保交的也没什么卵用，每个月还少拿钱，不交社保这样一来，每个月还多拿钱了，何乐而不为？&lt;/p&gt;
&lt;p&gt;工资私下转账的，民工哥还真遇上到过。小伙伴讲老板每个月不是支付宝、就是微信转账给我，第一不用交税，第二也还方便（不用办卡）。可是，他尽然不知道，公司N个月后倒闭了，怎么办？维权？是有必要的，但是如何认定你与老板之间既定的雇佣关系是有难度的（这是针对上面说的一些小企业，3 5个人的）。老板完全可以将上述的转账行为设定成朋友间或买卖间的私人行为。但是如果说人数众多，比如20 30人的企业，而且你们可以证明存在你们所认为的雇佣关系，应该来说这类维权的成功性较大。总之，与其想着后面维权，不如避坑跳过，你说呢？&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;5、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;借招聘忽悠入伙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种公司，民工哥回霸都找工作真遇上过：&lt;/p&gt;
&lt;p&gt;详细请点击&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UYhfOp924bYQUqYCVgoT9tY9zibIyUB4m4udOibRHibe4ZiboyZXLGXa16A/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UYhfOp924bYQUqYCVgoT9tY9zibIyUB4m4udOibRHibe4ZiboyZXLGXa16A/640&quot; data-w=&quot;64&quot; data-fail=&quot;0&quot;/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;amp;mid=2247485171&amp;amp;idx=1&amp;amp;sn=d3feb169dd4c99536039c201cef510f1&amp;amp;chksm=e91b63efde6ceaf997285ffda605350a0abf81344073b9a6a00e874cfca6016516a93aa9aea7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;“金三银四”的折腾之聊一聊面试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如让你拿钱入伙，这是最坑。再比如谈什么技术入伙，说白了就没有工资，只干活不给钱，成功了你就是联合创始人之一，劳苦功高。总这类借招聘忽悠入伙的套路是一套接一套，很多，如果有读者遇到这类套路，欢迎留言爆光。&lt;/p&gt;
&lt;p&gt;如今，经济下行，大环境不好。但想着一夜爆富的人还不在少数，很容易被这种入伙发大财的前景所诱惑，面着面着就上了贼船。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;6、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;待遇还行、制度压榨&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;估计大多数读者没有遇到过，大概也不太明白什么情况，这类坑不小心很容易掉进去。&lt;/p&gt;
&lt;p&gt;待遇还行算是企业老板还有点良心，这个制度压榨是个啥情况呢？比如：合同期内离职，需要支付公司违约金「这里说的离职是正常流程离职」，违约金从何而来呢，就是讲你同公司签定合同了，公司可能会在你的任职期间做了某些技能培训（非外部）花了大量人力物力，但是你没有期满离职就是违约，而且鸡贼是并没有写进劳动合同里而是写在企业制度里，其中的道道你应该懂的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;画外音：公司把你养肥了，还给你钱，现在你翅膀硬了，要飞是吧，要飞可以，支付饲料费，放你飞。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如：制度写明离职提前60天提出，并且这两个月是工作交接期，公司只支付一定的基本薪资，因为在这两个月里你并没有实制性工作，没有给公司创造价值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;画外音：TMD都要走，不宰你一刀宰谁？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如：强制加班，没事你也给呆到XX点才能走，或者每周固定某天几点才能下班，到底干啥呢，不清楚。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;画外音：我的地盘，听我的，不听的滚蛋。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;肯定有人问：还有这种企业？明确告诉你有，我遇到过。还好我也鸡贼，第一天就把企业制度仔细研究了一遍并没有签字确认，哈哈......。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;7、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;天天喊口号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种坑也只能入职后才能知道，或者你可以多种打听能知道一点。&lt;/p&gt;
&lt;p&gt;为什么说天天喊口号这类公司也是个坑呢？打个最简单的比方，公司100人，早上站队喊个口号5分钟（有的甚至不够）500分钟去了，500分钟=8.3333小时，一个工作日最长8小时，TMD喊个口号去掉一个工作日，如果是200人、500人的企业呢，这口号是得有多金贵？&lt;/p&gt;
&lt;p&gt;知道的还好，是让员工学习企业文化，不知道还以为搞啥传销活动呢？但是，话又说回来，企业文化也不是靠喊几句口号、唱个什么鸟司歌就能贯彻下去的，企业文化是需要员工理解与认同的。再说了，你有见到BAT这些企业，闲着没事蛋痛的天天喊口号吗？或者，蛋痛的去背企业文化吗？肯定没有。&lt;/p&gt;
&lt;p&gt;公司发展还好的情况下，估摸着口号喊的还能硬气点，真正不太好的时候，估摸着口号喊的和鬼哭狼嚎一般吧。&lt;/p&gt;
&lt;p&gt;而且，这类企业有一个共同的特点：大多数高管都是传统企业或国有制改革退居二线的人，再或者是传统转互联网企业。都什么年代了，还拿着那50 60年代的企业管理思维来管理现代化的企业，不死才怪。&lt;/p&gt;
&lt;p&gt;口号喊的再响，司歌唱的再牛掰，都创造不出KPI，也干不出RMB。同样，也留不住企业需要的人才。只有钱给足了，你再来搞这些套路，企业员工才会拼命给你干，就算早上没吃饭，口号照样给你喊的杠杠滴。&lt;/p&gt;
&lt;p&gt;常喊口号的企业，离倒闭不远。真的，民工哥见到过两家，一家老板已成追逃对象（警方赏10万），一家已经千疮百孔、风雨飘摇，苦苦强撑着。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;8、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;高薪海外就业&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个不得不说是时下最火的招聘，国内经济形式不好，就业压力大。很多海个中介机构早已张开口袋，坐等求职者上钩了，海外就业不管是高薪还是高薪，都存在一定的风险因素（非常合规建全的角度）。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一：不在国内，存在维权难的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二：国家与国家之间的制度，企业制度，工作环境等问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第三：劳务关系认定问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第四：安全是个大问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种坑，千万不要去碰，不碰则已，一碰即雷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icFNstbHuT3xiaQo0uiamES4ZIErujiaiaw5oH2Zx9IsaYtCHHlwNQAdibtBg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5744047619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icFNstbHuT3xiaQo0uiamES4ZIErujiaiaw5oH2Zx9IsaYtCHHlwNQAdibtBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;672&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icPNxMianvlQX1ChGYjGWZqFaNHbbvUceKWoXbkmzbd01JoVj5KJNMwBQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.99&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPqhd7S1eJDbDZlbt6ibYgO5icPNxMianvlQX1ChGYjGWZqFaNHbbvUceKWoXbkmzbd01JoVj5KJNMwBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个海外求职，还需要注意一点的就是，千万不要随便将个人信息透露给招聘人员，不排除有诈骗团伙借机盗取信息之用。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;9、&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;招聘幌子，实则培训&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打着招聘的幌子，其实，是家培训机构。什么情况呢？情况就是：以招聘为名，忽悠前来应聘的人入职参加培训，这里的培训可是要付费的，并且承诺培训之后拿到多少多少的高薪。&lt;/p&gt;
&lt;p&gt;这时肯定有读者有疑问了，现在还有这么傻二的人吗？我告诉你，有，真人真事。一伙伴就是这样被忽悠进了，而且，而且，培训费还是贷款分期的，最TMD坑的是这个贷款分期合同是同另一家公司签定的。稀里糊涂的就这样被套路了，大几万块钱得慢慢吭哧吭哧的还。&lt;/p&gt;
&lt;p&gt;啥情况呢？也就是说，你就算发现不对了，也是晚了，因为合同是你签字的，并且与这家培训机构半毛钱关系没有。就是不参加培训，这钱你得照给，一句话，忽悠你没商量，不旦忽悠你，你还得付钱让他忽悠。&lt;/p&gt;
&lt;p&gt;目前，这类情况不少，大家在求职的时候千万要擦亮眼睛，这类坑可真的是防不慎防！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;找个工作尽然有这么多的坑，那么如何应对呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量选择正规网站投递简历。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以的话利用人脉内推为上策。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;应聘前、或投简历前多种渠道了解企业相关的信息，再进行选择&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;面试前多与HR或相关负责人沟通岗位情况、公司情况，以免浪费时间，多跑冤枉路。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;必要的劳动法知识学习，保护自己的合法权益。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;面试时多提专业问题，可以侧面了解公司现有的技术线与展示自己的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提高防坑意识，尤其那些还没入职就要交钱入伙的，或者入职交钱入伙的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;确定入职前，多向HR或负责人确认你所需要的信息，比如：薪资构成、福利待遇、公司相关的制度等，防止入坑容易，出坑难。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果不慎入坑，那就不要再犹豫了，抓紧时间跳吧，别等「骑驴找马」了，别到时候驴死马没找着。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;祝民工哥技术之路的所有读者们：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2019年都能斩获自己如意的Offer！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日话题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你的求职中遇到哪些坑？或者你有哪些避坑的经验，欢迎留言分享！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 13:29:00 +0000</pubDate>
<dc:creator>民工哥</dc:creator>
<og:description>公众号：民工哥技术之路 文/作者：民工哥 虽说年前就有很多人在修改简历、刷新简历，但是为了大家心中所谓的年终奖，99.9999%的人都会选择沉默，有一种「明修栈道，暗度陈仓」意味。 拿完了年终奖，过完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youkanyouxiao/p/10398041.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 打造一个简单的图书馆管理系统 (修正版)（七） 学生信息增删 - NanaseRuri</title>
<link>http://www.cnblogs.com/gokoururi/p/10398023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gokoururi/p/10398023.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本系列文章主要为我之前所学知识的一次微小的实践，以我学校图书馆管理系统为雏形所作。&lt;/p&gt;
&lt;p&gt;本系列文章主要参考资料：&lt;/p&gt;
&lt;p&gt;微软文档：https://docs.microsoft.com/zh-cn/aspnet/core/getting-started/?view=aspnetcore-2.1&amp;amp;tabs=windows&lt;/p&gt;
&lt;p&gt;《Pro ASP.NET MVC 5》、《锋利的 jQuery》&lt;/p&gt;


&lt;p&gt;此系列皆使用 VS2017+C# 作为开发环境。如果有什么问题或者意见欢迎在留言区进行留言。 &lt;/p&gt;
&lt;p&gt;项目 github 地址：&lt;a href=&quot;https://github.com/NanaseRuri/LibraryDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/NanaseRuri/LibraryDemo&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;本章内容&lt;/strong&gt;：Ajax 提交自定义对象、Ajax 提交数组&lt;/p&gt;



&lt;p&gt;此处全部都在 /AdminAccount/Index 页面完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、学生信息编辑首页&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 创建一个 Admin 控制器用于编辑学生信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Authorize(Roles = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminAccountController : Controller
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; UserManager&amp;lt;Student&amp;gt;&lt;span&gt; _userManager;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; AdminAccountController(UserManager&amp;lt;Student&amp;gt;&lt;span&gt; userManager)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             _userManager =&lt;span&gt; userManager;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             ICollection&amp;lt;Student&amp;gt; students =&lt;span&gt; _userManager.Users.ToList();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(students);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using LibraryDemo.Models.DomainModels
@model IEnumerable&lt;/span&gt;&amp;lt;LibraryDemo.Models.DomainModels.Student&amp;gt;&lt;span&gt;
@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AccountInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    Student stu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
}
&lt;/span&gt;&amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/css/BookInfo.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;h2&amp;gt;学生信息&amp;lt;/h2&amp;gt;

&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;buttonGroup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return addStudent()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;添加学生&amp;lt;/button&amp;gt;
    &amp;lt;button &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;return confirmDelete()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;删除学生&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;br /&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.UserName)&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.Name)&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.Degree)&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.PhoneNumber)&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.Email)&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;@Html.LabelFor(m =&amp;gt; stu.MaxBooksNumber)&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

        @if (&lt;/span&gt;!&lt;span&gt;@Model.Any())
        {
            &lt;/span&gt;&amp;lt;tr&amp;gt;&amp;lt;td colspan=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;未有学生信息&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; student &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Model)
            {
                &lt;/span&gt;&amp;lt;tr&amp;gt;
                    &amp;lt;td&amp;gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@student.UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@student.UserName&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@student.Name&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@Html.DisplayFor(m =&amp;gt; student.Degree)&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@student.PhoneNumber&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@student.Email&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@student.MaxBooksNumber&amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;&lt;span&gt;
            }
        }
    &lt;/span&gt;&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209231807159-173848514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、增加新学生&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此处打算使用 Ajax 来实现无刷新页面更新，因此动作方法返回类型为 Json 。&lt;/p&gt;
&lt;p&gt;动作方法：&lt;/p&gt;
&lt;p&gt;此处需注意在参数处添加 [FromBody] 修饰，否则无法读取来自页面的数据。&lt;/p&gt;
&lt;p&gt;为节省带宽，此处仅返回添加的学生的 JSON 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        [HttpPost]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;JsonResult&amp;gt;&lt;span&gt; AddStudent([FromBody]Student student)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {            
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_userManager.CreateAsync(student,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result.Succeeded)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; AddedStudent(student.UserName);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;JsonResult&amp;gt; AddedStudent(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; userName)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Student student=&lt;span&gt;await&lt;/span&gt; _userManager.Users.FirstOrDefaultAsync(s =&amp;gt; s.UserName ==&lt;span&gt; userName);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 userName =&lt;span&gt; student.UserName,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 name =&lt;span&gt; student.Name,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 degree = student.Degree == Degrees.CollegeStudent ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本科生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : (student.Degree == Degrees.Postgraduate ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;研究生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;博士生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 phoneNumber =&lt;span&gt; student.PhoneNumber,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 email =&lt;span&gt; student.Email,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 maxBooksNumber =&lt;span&gt; student.MaxBooksNumber
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在视图中添加 JS 代码：&lt;/p&gt;
&lt;p&gt;此处 JS 代码先是点击 添加书籍 按钮插入一行用于编辑的区域，然后通过插入区域的提交按钮提交信息，在信息成功返回后删除原来进行编辑的行，通过返回的信息添加新的行。&lt;/p&gt;
&lt;p&gt;27-33 中由于 ASP.NET Core 后台返回 JSON 数据时会对数据的键的首字母进行小写处理，因此此处读取属性也是使用首字母小写，在后台的键也是使用首字母小写加以强调。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    function postAddStudent() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        $.ajax({
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Url.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;AddStudent&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             contentType: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             method: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            data: JSON.stringify({
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 UserName: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Name: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 Degree:$(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#Degree&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 PhoneNumber: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#PhoneNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Email: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 MaxBooksNumber: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#MaxBooksNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            success: function (student) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                addStudentToTable(student);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    function addStudentToTable(student) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; studentList = document.getElementById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; studentInfo = document.getElementById(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;studentInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        studentList.removeChild(studentInfo);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#studentList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).append(`&amp;lt;tr&amp;gt;` +
&lt;span&gt;27&lt;/span&gt;             `&amp;lt;td&amp;gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${student.userName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;/td&amp;gt;` +
&lt;span&gt;28&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.userName}&amp;lt;/td&amp;gt;` +
&lt;span&gt;29&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.name}&amp;lt;/td&amp;gt;`+
&lt;span&gt;30&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.degree}&amp;lt;/td&amp;gt;` +
&lt;span&gt;31&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.phoneNumber}&amp;lt;/td&amp;gt;` +
&lt;span&gt;32&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.email}&amp;lt;/td&amp;gt;` +
&lt;span&gt;33&lt;/span&gt;             `&amp;lt;td&amp;gt;${student.maxBooksNumber}&amp;lt;/td &amp;gt;` +
&lt;span&gt;34&lt;/span&gt;             `&amp;lt;/tr&amp;gt;&lt;span&gt;`);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209233002720-1523789141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209233014704-1440037547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、 批量移除学生&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此处亦可以只返回更新过的元素，但为了演示 ASP.NET Core 使用 Ajax 对数组进行处理，故返回新的 Student 列表：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        [HttpPost]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;JsonResult&amp;gt; RemoveStudent([FromBody]IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; userNames)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            Student removedStudent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; userName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; userNames)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 removedStudent =&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.FindByNameAsync(userName);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (removedStudent!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.DeleteAsync(removedStudent);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }                
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetStudentData();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonResult GetStudentData()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; students = _userManager.Users.Select(s =&amp;gt;&lt;span&gt;new&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 userName=&lt;span&gt;s.UserName,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 name=&lt;span&gt;s.Name,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 degree=s.Degree==Degrees.CollegeStudent?&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本科生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:(s.Degree==Degrees.Postgraduate?&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;研究生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;博士生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 phoneNumber =&lt;span&gt; s.PhoneNumber,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 email =&lt;span&gt; s.Email,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 maxBooksNumber =&lt;span&gt; s.MaxBooksNumber                
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            });            
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(students);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;视图添加 JS 函数：&lt;/p&gt;
&lt;p&gt;18 行为数组元素的提交方式，不需像之前一样—— {values:values}，否则无法进行数据绑定而导致后台接收到空数据。&lt;/p&gt;
&lt;p&gt;为了对表格进行更新，先是通过 jQuery 获取了 tbody 的部分，清空后添加来自后台的新信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    function confirmDelete() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; userNames = document.getElementsByName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确认删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; values =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; userNames) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (userNames[i].&lt;span&gt;checked&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 message = message + userNames[i].value+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                values.push(userNames[i].value);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         message = message + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (confirm(message)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            $.ajax({
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Url.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;RemoveStudent&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 contentType: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 method: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                data: JSON.stringify(values),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                success: function(students) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    updateTable(students);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    function updateTable(data) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; body = $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#studentList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        body.empty();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; data[i];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             body.append(`&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userNames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${person.userName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;/td&amp;gt;
&lt;span&gt;32&lt;/span&gt;             &amp;lt;td&amp;gt;${person.userName}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${person.name}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${person.degree}&amp;lt;/td&amp;gt;
&lt;span&gt;33&lt;/span&gt;             &amp;lt;td&amp;gt;${person.phoneNumber}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${person.email}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${person.maxBooksNumber}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;span&gt;`);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209233937007-1858457207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209233945966-1003184617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408470/201902/1408470-20190209233952005-2083028014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Feb 2019 13:25:00 +0000</pubDate>
<dc:creator>NanaseRuri</dc:creator>
<og:description>ASP.NET Core 打造一个简单的图书馆管理系统（九） 学生信息增删， ASP.NET Core ajax</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gokoururi/p/10398023.html</dc:identifier>
</item>
<item>
<title>BFC是什么 - .智子</title>
<link>http://www.cnblogs.com/mlw1814011067/p/10397999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlw1814011067/p/10397999.html</guid>
<description>&lt;p&gt;BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，但当别人问我 BFC 是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec 和许多文章来全面地理解BFC。&lt;/p&gt;

&lt;p&gt;在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。&lt;/p&gt;
&lt;h4 id=&quot;box-css-&quot;&gt;　　Box: CSS布局的基本单位&lt;/h4&gt;
&lt;p&gt;　　Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；&lt;/li&gt;
&lt;li&gt;inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；&lt;/li&gt;
&lt;li&gt;run-in box: css3 中才有， 这儿先不讲了。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　Formatting context&lt;/h4&gt;
&lt;p&gt;　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。&lt;/p&gt;
&lt;p&gt;　　CSS2.1 中只有 &lt;code&gt;BFC &lt;/code&gt;和 &lt;code&gt;IFC&lt;/code&gt;, &lt;a href=&quot;http://www.cnblogs.com/lhb25/category/146075.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;CSS3&lt;/a&gt; 中还增加了 &lt;code&gt;GFC &lt;/code&gt;和 &lt;code&gt;FFC。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;bfc-&quot;&gt;　　BFC 定义&lt;/h4&gt;
&lt;p&gt;　　BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。&lt;/p&gt;
&lt;h4 id=&quot;bfc-&quot;&gt;　　BFC布局规则：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;内部的Box会在垂直方向，一个接一个地放置。&lt;/li&gt;
&lt;li&gt;Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠&lt;/li&gt;
&lt;li&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/li&gt;
&lt;li&gt;BFC的区域不会与float box重叠。&lt;/li&gt;
&lt;li&gt;BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/li&gt;
&lt;li&gt;计算BFC的高度时，浮动元素也参与计算&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;third_title&quot;&gt;二、哪些元素会生成BFC?&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;根元素&lt;/li&gt;
&lt;li&gt;float属性不为none&lt;/li&gt;
&lt;li&gt;position为absolute或fixed&lt;/li&gt;
&lt;li&gt;display为inline-block, table-cell, table-caption, flex, inline-flex&lt;/li&gt;
&lt;li&gt;overflow不为visible&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;third_title&quot;&gt;三、BFC的作用及原理&lt;/h3&gt;
&lt;h4 id=&quot;1-&quot;&gt;　　1. 自适应两栏布局&lt;/h4&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    body {
        width: 300px;
        position: relative;
    }
 
    .aside {
        width: 100px;
        height: 150px;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;: left;
        background: #f66;
    }
 
    .main {
        height: 200px;
        background: #fcc;
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aside&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1404918/201902/1404918-20190218211437869-913579055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第3条：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。&lt;/p&gt;
&lt;p&gt;　　根据&lt;code&gt;BFC&lt;/code&gt;布局规则第四条：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;的区域不会与&lt;code&gt;float box&lt;/code&gt;重叠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　我们可以通过通过触发main生成&lt;code&gt;BFC&lt;/code&gt;， 来实现自适应两栏布局。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.main {
    overflow: hidden;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当触发main生成&lt;code&gt;BFC&lt;/code&gt;后，这个新的&lt;code&gt;BFC&lt;/code&gt;不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1404918/201902/1404918-20190218211513608-1838168697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-&quot;&gt;2. 清除内部浮动&lt;/h4&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    .par {
        border: 5px solid #fcc;
        width: 300px;
    }
 
    .child {
        border: 5px solid #f66;
        width:100px;
        height: 100px;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;: left;
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;par&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;child&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面：&lt;br/&gt;　　&lt;img src=&quot;http://p1.qhimg.com/t016035b58195e7909a.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据&lt;code&gt;BFC&lt;/code&gt;布局规则第六条：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;计算&lt;code&gt;BFC&lt;/code&gt;的高度时，浮动元素也参与计算&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　为达到清除内部浮动，我们可以触发par生成&lt;code&gt;BFC&lt;/code&gt;，那么par在计算高度时，par内部的浮动元素child也会参与计算。&lt;/p&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.par {
    overflow: hidden;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;br/&gt;　　&lt;img src=&quot;http://p2.qhimg.com/t016bbbe5236ef1ffd5.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt; ￼&lt;/p&gt;
&lt;h4 id=&quot;3-margin-&quot;&gt;　　3. 防止垂直 margin 重叠&lt;/h4&gt;
&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    p {
        color: #f55;
        background: #fcc;
        width: 200px;
        line&lt;/span&gt;-&lt;span&gt;height: 100px;
        text&lt;/span&gt;-&lt;span&gt;align:center;
        margin: 100px;
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Haha&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;Hehe&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;页面：&lt;br/&gt;　　&lt;img src=&quot;http://p5.qhimg.com/t01b47b8b7d153c07cc.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　两个p之间的距离为100px，发送了margin重叠。&lt;br/&gt;　　根据BFC布局规则第二条：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Box&lt;/code&gt;垂直方向的距离由margin决定。属于同一个&lt;code&gt;BFC&lt;/code&gt;的两个相邻&lt;code&gt;Box&lt;/code&gt;的margin会发生重叠&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　我们可以在p外面包裹一层容器，并触发该容器生成一个&lt;code&gt;BFC&lt;/code&gt;。那么两个P便不属于同一个&lt;code&gt;BFC&lt;/code&gt;，就不会发生margin重叠了。&lt;br/&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    .wrap {
        overflow: hidden;
    }
    p {
        color: #f55;
        background: #fcc;
        width: 200px;
        line&lt;/span&gt;-&lt;span&gt;height: 100px;
        text&lt;/span&gt;-&lt;span&gt;align:center;
        margin: 100px;
    }
&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Haha&amp;lt;/p&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;p&amp;gt;Hehe&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下:&lt;br/&gt;　　&lt;img src=&quot;http://p3.qhimg.com/t0118d1d2badbb00521.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;third_title&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;　　其实以上的几个例子都体现了&lt;code&gt;BFC&lt;/code&gt;布局规则第五条：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;BFC&lt;/code&gt;就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　因为&lt;code&gt;BFC&lt;/code&gt;内部的元素和外部的元素绝对不会互相影响，因此， 当&lt;code&gt;BFC&lt;/code&gt;外部存在浮动时，它不应该影响&lt;code&gt;BFC&lt;/code&gt;内部Box的布局，&lt;code&gt;BFC&lt;/code&gt;会通过变窄，而不与浮动有重叠。同样的，当&lt;code&gt;BFC&lt;/code&gt;内部有浮动时，为了不影响外部元素的布局，&lt;code&gt;BFC&lt;/code&gt;计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 13:18:00 +0000</pubDate>
<dc:creator>.智子</dc:creator>
<og:description>BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlw1814011067/p/10397999.html</dc:identifier>
</item>
</channel>
</rss>