<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《ASP.NET Core In Action》读书笔记系列五 ASP.NET Core  解决方案结构解析1 - china_fucan</title>
<link>http://www.cnblogs.com/VolcanoCloud/p/10338342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/VolcanoCloud/p/10338342.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;创建好项目后，解决方案资源管理器窗口里我们看到，增加了不少文件夹及文件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190128172503622-343730648.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在解决方案文件夹中，找到项目文件夹，该文件夹又包含五个子文件夹 -Models、Controllers、Views、Properties、及wwwroot；Models、Controllers、Views对应MVC模型，控制器和视图。 Properties文件夹包含一个文件（launchSettings.json），它控制Visual Studio如何运行和调试应用程序。 wwwroot文件夹很特别，因为它是应用程序中浏览器可以直接访问的唯一的文件夹，你可以在这里面存放应用需要用到的CSS，JavaScript，图片或静态HTML文件。 浏览器无法访问wwwroot之外的文件。&lt;/span&gt;&lt;span&gt;虽然磁盘上存在wwwroot和Properties文件夹，但您可以看到解决方案资源管理器将它们显示为特殊节点，不按字母顺序排列，位于项目的顶部区域。 在项目中还有两个特殊的节点，Dependencies和Connected Services，它们在磁盘上没有相应的文件夹。 它们显示项目所有依赖项的集合，例如NuGet包、客户端依赖项和项目所依赖的远程服务。&lt;/span&gt;&lt;span&gt;在目根目录中，还有几个JSON文件-appsettings.json、bundleconfig.json和bower.json。 它们提供了各种配置设置，其中一些在运行时使用，另一些在编译时用于构建应用程序。（&lt;/span&gt;&lt;span&gt;Bower是一个客户端资产管理系统，用于获取CSS和JavaScript库。 由于Bower被放弃维护，ASP.NET团队正在探索替代方案。 bower.json文件很可能会在后面的版本中从默认模板中删除并替换）。&lt;/span&gt;&lt;span&gt;项目中最重要的文件是WebApplication2.csproj，因为它描述了如何构建你的项目。 Visual Studio未在解决方案中显式列出csproj文件，但可以在项目名称右键并选择“编辑”菜单对其进行编辑。&lt;/span&gt;&lt;span&gt;Visual Studio还在项目文件夹中列出了两个C#文件-Program.cs和Startup.cs。 在后面的章节，将介绍这两个类是如何实现配置和运行您的应用程序的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;csproj项目文件：定义依赖项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;csproj文件是.NET应用程序的项目文件，包含.NET工具构建项目所需的详细信息。 它定义了正项目的类型（Web应用程序、控制台应用程序、类库），项目的目标平台（.NET Core、.NET Framework 4.5、Mono等），以及项目所依赖的NuGet包。&lt;/span&gt;&lt;span&gt;项目文件一直是.NET应用程序的核心，ASP.NET Core对其进行了调整，使其更易于阅读和编辑。 这些调整如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、没有GUID  - 以前，全局唯一标识符（GUID）大量用于项目文件中；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、隐式文件包括 （Implicit file includes—）- 以前，项目中的每个文件都必须列在csproj文件中，项目才能编译； 现在，文件会被自动编译；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、没有NuGet包dll的路径 - 以前，csproj必须包含dll的路径，以及在packages.xml文件中列出依赖项。 现在，您可以直接在csproj中引用NuGet包，不需要指定磁盘上路径；&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;这些变化使项目文件更加简洁，下图显示了整个csproj文件：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190129155651389-1536744329.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　上图中Project元素的Sdk属性设定编译项目的默认设置，TargetFramework元素设定应用程序的运行框架，对于.NET Core 2.0项目，值为netcoreapp2.0; 对于完整的.NET Framework 4.6.1项目，值为net461。对于简单的应用程序，我们不需要更改项目文件，如果你想编辑csproj文件，不用像之前的版本那样先关闭项目，直接用前面提到的方法编辑即可。对项目文件最常见的更改是添加项目引用（PackageReference元素下NuGet包），.NET Core项目默认情况下，只引用一个NuGet包-Microsoft.AspNetCore.All，它是一个元数据包（元数据包是一个不包含代码的NuGet包，它引用一个或多个其他NuGet包，通过将元数据包添加到应用程序，可以方便地和隐式地添加它的所有包引用），包含了ASP.NET Core 2.0相关的所有软件包，但这不意味着，应用将使用所有的ASP.NET Core包。在ASP.NET Core 2.1中，Microsoft.AspNetCore.App元数据包引用默认已经安装上。 您可以在https://github.com/aspnet/Announcements/issues/287 查看Microsoft.AspNetCore.App和所有元数据包的区别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　简化后的项目文件更易手工编辑，这有利于开发跨平台应用。如果仍然使用Visual Studio，你依然可以像以前一样添加项目引用，管理NuGet包等。有关csproj格式更改的更多详细信息，可参阅https://docs.microsoft.com/en-us/dotnet/core/tools/csproj。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;Program类：构建Web主机&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　&lt;span&gt;　所有ASP.NET Core应用程序的启动方式与.NET控制台应用程序相同 - 使用Program.cs文件。 此文件包含静态 Main函数（这是控制台应用程序的标准特性）。 应用中必须包含这个方法，它在启动Web应用程序时调用。 在ASP.NET Core应用程序中，它用于构建和运行一个IWebHost实例，如下图所示，它显示了默认的Program.cs文件。 IWebHost是ASP.NET Core应用程序的核心，包含应用程序配置和侦听请求的Kestrel服务器,并返回客户端请求回应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190130133053817-2098637531.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Main函数包含创建Web服务器并开始侦听请求所需的基本初始化代码，在&lt;/span&gt;&lt;span&gt;实例化IWebHost之前，通过CreateDefaultBuilder方法定义IWebHost的配置。&lt;/span&gt;&lt;span&gt;应用程序的大部分配置都发生在CreateDefaultBuilder方法中，它还将一些职责委托给一个单独的类Startup。 这个类通过泛型方法UseStartup&amp;lt;&amp;gt; 引用，在这里可以配置应用程序的服务和中间件间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里有不少人提出这样的疑问，为什么要把配置分拆到两个类中？一般来说，Program类负责应用的基础结构，例如：Http服务器、与IIS集成、配置源；Startup定义应用将使用哪些功能、组件以及中间件。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190130144639463-2094913288.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt; &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　两个不同的ASP.NET Core 应用程序的Program类通常是相似的，但Startup类通常会有很大不同（尽管它们通常遵循类似的模式）。 随着应用程序的增长，很少会修改Program，但是，会经常修改Startup。 例如，向项目中添加新的NuGet依赖项，通常需要在Startup添加相应的代码才能使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Startup类：配置应用程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;span&gt;Startup类主要负责应用的两个方面的配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、&lt;/span&gt;&lt;span&gt;服务注册 - 您的应用程序所依赖的任何类 ，无论是框架使用的类还是应用程序自身需要使用的类都必须注册，只有这样，这些类才能在运行时被正常构建；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、中间件和MVC  - 应用程序如何处理和响应请求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在不同的方法中配置这两个方面的功能，服务注册在方法ConfigureServices中，中间件和MVC 在方法Configure中。这两个方法大致的样子如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190130150804572-1552858013.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;span&gt;Program中创建的WebHostBuilder先调用 ConfigureServices 然后调用Configuare，如下图所示：每个调用都会配置应用程序的不同部分。由于这样的调用顺序，Configuare方法中可以使用在ConfigureServices方法中注册的任何服务。调用完成后，WebHostBuilder通过调用Build()方法，创建IWebHost. 有一个地方需要注意，Startup类自身没有实现相应的接口，WebHostBuilder通过反射来调用预义的方法Configure和ConfigureServices，这样的设计使这个类更加灵活，我们可以修改签名，添加额外的参数。更详细的细节将在后面章节介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/69583/201901/69583-20190130153133040-1738151365.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;谢谢你的阅读，下节见！如果期待本系列，请点一下推荐！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 07:35:00 +0000</pubDate>
<dc:creator>china_fucan</dc:creator>
<og:description>创建好项目后，解决方案资源管理器窗口里我们看到，增加了不少文件夹及文件，如下图所示： 在解决方案文件夹中，找到项目文件夹，该文件夹又包含五个子文件夹 -Models、Controllers、Views</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/VolcanoCloud/p/10338342.html</dc:identifier>
</item>
<item>
<title>linux学习笔记-软件包的相关知识 - 仁人</title>
<link>http://www.cnblogs.com/renren-study-notes/p/10337552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renren-study-notes/p/10337552.html</guid>
<description>&lt;h3&gt;一.软件包种类&lt;/h3&gt;
&lt;p&gt;1.源码包&lt;/p&gt;
&lt;p&gt;源码包即提供源代码的发行包&lt;/p&gt;
&lt;p&gt;2.二进制包&lt;/p&gt;
&lt;p&gt;二进制包即提供二进制文件的发行包&lt;/p&gt;
&lt;p&gt;安装方法查找二进制包官网，复制到对应的系统目录&lt;/p&gt;
&lt;p&gt;2.deb包&lt;/p&gt;
&lt;p&gt;debian系列使用的软件包&lt;/p&gt;
&lt;p&gt;3.rpm包&lt;/p&gt;
&lt;p&gt;red-hat所开发的软件包类型&lt;/p&gt;
&lt;p&gt;4.可执行包&lt;/p&gt;
&lt;p&gt;这类软件包和windows的软件包类似，提供安装界面。&lt;/p&gt;
&lt;p&gt;安装方法终端运行下载的包，会弹出类似于windows的软件的安装界面&lt;/p&gt;
&lt;p&gt;卸载方法在软件的安装目录运行卸载的脚本，会弹出卸载界面&lt;/p&gt;
&lt;h3&gt;二.软件包的说明性文件&lt;/h3&gt;
&lt;p&gt;1.源码包和二进制包的说明文件种类&lt;/p&gt;
&lt;p&gt;（1）安装说明&lt;/p&gt;
&lt;p&gt;（2）依赖说明&lt;/p&gt;
&lt;p&gt;（3）测试说明&lt;/p&gt;
&lt;p&gt;（4）使用说明&lt;/p&gt;
&lt;p&gt;（5）版权说明&lt;/p&gt;
&lt;p&gt;（6）软件设计说明&lt;/p&gt;
&lt;p&gt;2.源码包和二进制包的说明文件的具体内容&lt;/p&gt;
&lt;p&gt;依赖，安装和测试说明：软件包的依赖情况，编译方法，安装方法，测试方法，卸载方法&lt;/p&gt;
&lt;p&gt;使用说明：软件包的功能，安装位置，使用与配置方法&lt;/p&gt;
&lt;p&gt;版权和软件设计说明：软件包所使用的版权内容，作者的联系方式，包的设计思路，包的网站，代码库的位置，提交代码的方式&lt;/p&gt;
&lt;p&gt;3.源码包和二进制包的说明文件位置&lt;/p&gt;
&lt;p&gt;常见位置&lt;/p&gt;
&lt;p&gt;（1）INSTALL文件&lt;/p&gt;
&lt;p&gt;（2）LICENSE文件&lt;/p&gt;
&lt;p&gt;（3）PACKAGE-MAINTAINER文件&lt;/p&gt;
&lt;p&gt;（3）RELEASE文件&lt;/p&gt;
&lt;p&gt;（4）docs或doc目录下的html网页&lt;/p&gt;
&lt;p&gt;（5）其它包内的大写字母名字的文件&lt;/p&gt;
&lt;h3&gt;三.软件包的依赖&lt;/h3&gt;
&lt;p&gt;1.软件包的依赖的分类&lt;/p&gt;
&lt;p&gt;（1）构建安装所需要的依赖&lt;/p&gt;
&lt;p&gt;（2）测试包所需要的依赖&lt;/p&gt;
&lt;p&gt;（3）构建包文档所需要的依赖&lt;/p&gt;
&lt;p&gt;（4）软件运行时的依赖&lt;/p&gt;
&lt;p&gt;2.软件包依赖的解决办法&lt;/p&gt;
&lt;p&gt;（1）源码包，二进制包和可执行包的依赖的解决办法&lt;/p&gt;
&lt;p&gt;查找包内的依赖文档或官网的安装说明，找出所需要的依赖软件包的名字，在对应软件包官网下载对应的源码包&lt;/p&gt;
&lt;p&gt;（2）deb包和rpm包解决依赖的思路&lt;/p&gt;
&lt;p&gt;1.软件包官网查找依赖，下载对应的deb或rpm依赖包&lt;/p&gt;
&lt;p&gt;2.使用deb或rpm包的不同的发行版本会自带包管理工具，可以使用这些工具在安装卸载deb或rpm包的同时解决依赖包&lt;/p&gt;
&lt;h3&gt;四.软件包的下载源&lt;/h3&gt;
&lt;p&gt;1.源码和二进制包的下载源为包的官网或代码库的地址&lt;/p&gt;
&lt;p&gt;2.deb包和rpm包下载源为debian包或redhat包官网或软件官网提供的deb或rpm包&lt;/p&gt;
&lt;p&gt;3.可执行包的下载源为软件官网&lt;/p&gt;
&lt;h3&gt;五.软件包的安装&lt;/h3&gt;
&lt;p&gt;一.源码包的安装思路：&lt;/p&gt;
&lt;p&gt;（1）配置：配置软件的安装位置等信息，有的包没有配置脚本&lt;/p&gt;
&lt;p&gt;（2）编译：源码文件编译为二进制文件&lt;/p&gt;
&lt;p&gt;（3）测试 ：测试生成的二进制文件的完整性，有的包没有测试脚本&lt;/p&gt;
&lt;p&gt;（4）安装：使用安装脚本将二进制文件复制到系统的对应目录&lt;/p&gt;
&lt;p&gt;（5）清理 ：清理生成的二进制文件及配置文件，也可以直接删除解压完的包目录&lt;/p&gt;
&lt;p&gt;2.源码包的分类：&lt;/p&gt;
&lt;p&gt;（1）使用makefile文件的包&lt;/p&gt;
&lt;p&gt;（2）使用setup.py的包&lt;/p&gt;
&lt;p&gt;（3）使用build的包&lt;/p&gt;
&lt;p&gt;3.源码包的配置方式：&lt;/p&gt;
&lt;p&gt;（1）使用makefile文件的包中有configure文件的包&lt;/p&gt;
&lt;p&gt;configure：配置文件用于配置源码包生成makefile文件，常用执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./configure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用参数：&lt;/p&gt;
&lt;p&gt;--prefix=      （安装软件到某个目录，一般情况下为/usr目录）&lt;/p&gt;
&lt;p&gt;注释：有的包不提供配置文件&lt;/p&gt;
&lt;p&gt;4.源码包的编译方法&lt;/p&gt;
&lt;p&gt;（1）使用makefile文件的包&lt;/p&gt;
&lt;p&gt;有的源码包不直接提供这个文件需要使用configure生成，或没有configure文件直接提供makefile文件&lt;/p&gt;
&lt;p&gt;编译方法及常用参数注释&lt;/p&gt;

&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;-j(n) :n为同时执行的任务数量，不设置则为尽可能同时执行多的任务，通常设置为cpu核数的二倍&lt;/p&gt;
&lt;p&gt; （2）使用setup.py的包&lt;/p&gt;
&lt;p&gt;编译方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python setup.py build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）使用build的包&lt;/p&gt;
&lt;p&gt;编译方法&lt;/p&gt;
&lt;p&gt;执行build.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./build.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.源码包的测试方法&lt;/p&gt;
&lt;p&gt;常见的测试命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;make&lt;/span&gt;&lt;span&gt; check

&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt; test

&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt; tests

ninja test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用参数&lt;/p&gt;
&lt;p&gt;-j（n）n为同时执行的任务数量，不设置则为尽可能同时执行多的任务，通常设置为cpu核数的二倍&lt;/p&gt;
&lt;p&gt;使用方法&lt;/p&gt;
&lt;p&gt;测试工具是源码包自带的脚本，需要参照软件包的测试说明，具体选择测试工具。&lt;/p&gt;
&lt;p&gt;6.源码包的安装方法&lt;/p&gt;
&lt;p&gt;（1）使用makefile的源码包安装方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# make&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用参数&lt;/p&gt;
&lt;p&gt;-j（n）n为同时执行的任务数量，不设置则为尽可能同时执行多的任务，通常设置为cpu核数的二倍&lt;/p&gt;
&lt;p&gt;（2）使用seup.py的源码包安装方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# python setup.py &lt;span&gt;install&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）使用build的源码包的安装方法&lt;/p&gt;
&lt;p&gt;使用build的源码包，基本是java的包，没有安装命令，参照包内的安装说明将编译生成的扩展名为.jar的二进制文件复制到对应目录&lt;/p&gt;
&lt;p&gt;二.deb包的安装方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# dpkg -i &amp;lt;package.deb&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三.rpm包的安装方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# rpm -i &amp;lt;package.rpm&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六.软件包的卸载&lt;/h3&gt;
&lt;p&gt;1.源码包的卸载思路&lt;/p&gt;
&lt;p&gt;（1）makefile源码包的卸载方法&lt;/p&gt;
&lt;p&gt;makefile文件可以使用卸载命令的执行卸载命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;make&lt;/span&gt; uninstall
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）setup.py源码包的卸载方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# python setup.py uninstall 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;makefile文件中没有卸载命令和.build的源码包卸载思路如下&lt;/p&gt;
&lt;p&gt;查找安装文件，手动删除&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.deb包的卸载方法&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dpkg -r &amp;lt;package.rpm&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.rpm包的卸载方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rpm -e &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&amp;lt;package.rpm&amp;gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 30 Jan 2019 07:30:00 +0000</pubDate>
<dc:creator>仁人</dc:creator>
<og:description>一.软件包种类 1.源码包 源码包即提供源代码的发行包 2.二进制包 二进制包即提供二进制文件的发行包 安装方法查找二进制包官网，复制到对应的系统目录 2.deb包 debian系列使用的软件包 3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renren-study-notes/p/10337552.html</dc:identifier>
</item>
<item>
<title>记一次优雅测试CORS - Julian89757</title>
<link>http://www.cnblogs.com/mi12205599/p/10337980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mi12205599/p/10337980.html</guid>
<description>&lt;p&gt;&lt;span&gt;------------------- ~。。~  想看优雅调试CORS请求：请下拉到文末---------------&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;跨域请求&lt;/h2&gt;
&lt;p&gt;站点A 请求站点B的数据，都可以认为是跨域请求；&lt;/p&gt;
&lt;p&gt;由于安全原因，浏览器严格限制&lt;strong&gt;通过脚本的跨域请求&lt;/strong&gt;，阻止某域名下的web应用尝试发送AJAX请求到其他域（http、protocol、port），这个限制被称为&lt;strong&gt;同源策略&lt;/strong&gt;，&lt;strong&gt;阻止恶意站点A尝试通过脚本的形式访问站点B的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;       一句话：减轻互联网上跨域请求实践中站点B的潜在风险。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;你已经登录并正在访问电商B站点， 这是邮件收到一份钓鱼网站的链接，点开该链接，进入该钓鱼A站点，该钓鱼A站点内部有Ajax请求代码，该请求现在可以无声的发起到电商站点B的请求，偷取数据。&lt;/p&gt;

&lt;p&gt;实际架构设计中需要站点A能够发起跨域请求到站点B， 基于客观需要，提出了跨域共享资源Cross-Origin Resource Sharing的技术机制。&lt;/p&gt;
&lt;p&gt;该机制通过增加站点B的响应HTTP头，告知浏览器允许特定域名下的web应用能够跨域访问B站点。&lt;/p&gt;
&lt;p&gt;举个橘子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201901/587720-20190130142703399-1588865034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对以上Http请求观察 浏览器发送和服务端响应的行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[XML Data]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;div id=&quot;3399-1547264560744&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;哪些请求要使用CORS？&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;3736-1547261980390&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;由XMlHttpRequest和FetchAPI发起的跨域行为&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&quot;6894-1547262163218&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;WebGL textures&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;1220-1547262172365&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Image/video frames drawn to a canvas using drawImage()&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2&gt;跨域请求方案&lt;/h2&gt;
&lt;p&gt;CORS是一个服务器允许放松同源策略的W3C标准，服务器可以显式允许同源请求并且拒绝其他的非同源访问，CORS更安全而且相比早期的JSONP技术更灵活。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;JSONP是一种服务端发送Json数据（不需要担心跨域问题）的方法，JSONP不使用XMLHttpRequest对象，而是使用script标签。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;在完成CORS时：很大程度上体现的是&lt;/strong&gt;服务端的资源保护策略&lt;/h4&gt;
&lt;p&gt;CORS协议规定在浏览器和服务端在完成跨域资源共享时的行为：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器： 客户端使用XmlHttpRequest发起Ajax请求，浏览器会自动携带Origin请求头（表示请求来自站点A）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;服务端： 服务端有一套完整的CORS策略，针对Origin服务端会在响应头Access-Control-Allow-Origin设定跨域策略，3种结果：&lt;/p&gt;
&lt;p&gt;        Access-Control-Allow-Origin: *                           // 允许任意Origin跨域请求&lt;/p&gt;
&lt;p&gt;        Access-Control-Allow-Origin: &amp;lt;origin&amp;gt;               // 这里只能指定一个Origin，一般情况下是请求携带的Origin&lt;/p&gt;
&lt;p&gt;        Access-Control-Allow-Origin: null                      // 不允许该Origin跨域请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt; 浏览器会查看Access-Control-Allow-Origin响应头，根据header value判断是否&lt;strong&gt;让脚本访问响应体&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;预检：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;“简单请求”（GET，HEAD，POST）不会触发预检（preflight）， “简单请求”必须同时满足以下条件：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;The only allowed methods are： GET HEAD POST&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;除浏览器自动添加的request header以外，允许某些手动添加的 header：Accept，Content-langugae等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;request 中的Content-Type只允许以下值：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不满足以上任意一个条件的基本上都有预检，预检是由浏览器自动检测并发起的。&lt;/p&gt;
&lt;p&gt;预检请求首先需要向站点B的资源发送一个 HTTP OPTIONS 请求头，其目的就是为了B站点能判断实际发送的请求是否是安全的（是否是自己允许的请求域名）。&lt;/p&gt;
&lt;p&gt;举个大梨子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/post-here/';
const body = '&lt;/span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Arun&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;';
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open('POST', url, true);
      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');
      invocation.setRequestHeader('Content-Type', 'application/xml');
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}

......
// 以上使用POST发送了一个xml，同时自定义了一个request header： X-PINGOTHER， 该跨域请求必定会预检。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201901/587720-20190130143816172-1571742832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 观察完整的预检流程：&lt;/p&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 一旦预检成功，真实的POST就会发起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: http://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: http://foo.example
Pragma: no-cache
Cache-Control: no-cache

&lt;/span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Arun&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;person&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some GZIP'd payload]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;携带凭据跨域&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认情况下，浏览器在XMLHttpRequest请求中不会发送凭据 （凭据包括HTTP cookies 和 Http认证信息比如 Authorization头），可以指定某标记以允许在XMLHttpRequest中发送凭据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const invocation = new XMLHttpRequest();
const url = 'http://bar.other/resources/credentialed-content/';
    
function callOtherDomain(){
  if(invocation) {
    invocation.open('GET', url, true);
    invocation.withCredentials = true;
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
// 以上是一个简单请求，并不会触发预检，浏览器会拒绝不包含Access-Control-Allow-Credentials: true跨域响应头的响应，并不让web内容访问到响应数据。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GET /resources/access-control-with-credentials/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/credential.html
Origin: http://foo.example
Cookie: pageAccess=2


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:34:52 GMT
Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2
X-Powered-By: PHP/5.2.6
Access-Control-Allow-Origin: http://foo.example    &lt;span&gt;// 当响应的是一个携带凭据的请求，服务端必须为Access-Control-Allow-Origin响应头指定一个Origin，而不能再用 * 通配符。&lt;/span&gt;
Access-Control-Allow-Credentials: true
Cache-Control: no-cache
Pragma: no-cache
Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT  &lt;span&gt;// 设置新的Cookie&lt;/span&gt;
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 106
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain


[text/plain payload]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;30.064516129032&quot;&gt;
&lt;ul&gt;&lt;li&gt;浏览器会取得Response，但是浏览器会阻止你的代码访问Response内容。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The browser itself runs into no error in getting the response. But your code runs into an error because it’s trying to access a response that’s not there — because the browser isn’t exposing the response to your code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; Asp.Net Core 2.1-&amp;gt;2.2 迁移指南中也提到这个问题： 如果服务端允许携带凭据跨域，就不允许再设置这种 Access-Control-Allow-Origin：* 响应头，必须明确指定Origin;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 app.UseCors(p =&amp;gt;&lt;span&gt;
                p.SetIsOriginAllowed(_ &lt;/span&gt;=&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                 .AllowCredentials()
                 .WithMethods(HttpMethods.Get, HttpMethods.Post, HttpMethods.Put, HttpMethods.Delete)
                 .WithHeaders(HeaderNames.ContentType)
                 .SetPreflightMaxAge(TimeSpan.FromHours(&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;)));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  _()=&amp;gt;true 为任意一个Origin生成对应的Access-Control-Allow-Origin响应头&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;附：一种优雅的跨域请求调试方法&lt;/h3&gt;
&lt;p&gt;同源策略针对 脚本跨域请求（HTTP直接跨域请求例如：src外链不存在这样的说法），本次着重探讨脚本跨域请求的验证方式。&lt;/p&gt;
&lt;p&gt;直观上：需要在某个服务器域名下构造Ajax请求，过程太繁琐， 需要搭建服务器、构建AJAX脚本请求。&lt;/p&gt;
&lt;p&gt;用一种极客的方法测试CORS请求：&lt;/p&gt;
&lt;div id=&quot;9823-1547275217252&quot; class=&quot;block-view code-view yne-code-theme-default&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot;&gt;
&lt;div class=&quot;para-text&quot; readability=&quot;32&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;yne-plain&quot;&gt;curl &lt;span class=&quot;yne-token yne-operator&quot;&gt;-&lt;span class=&quot;yne-token yne-constant&quot;&gt;H&lt;span class=&quot;yne-plain&quot;&gt; &lt;span class=&quot;yne-token yne-string&quot;&gt;&quot;Origin: http://example.com&quot;&lt;span class=&quot;yne-plain&quot;&gt; &lt;span class=&quot;yne-token yne-operator&quot;&gt;--&lt;span class=&quot;yne-plain&quot;&gt;verbose \&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;yne-plain&quot;&gt;  https&lt;span class=&quot;yne-token yne-punctuation&quot;&gt;:&lt;span class=&quot;yne-token yne-operator&quot;&gt;/&lt;span class=&quot;yne-token yne-operator&quot;&gt;/&lt;span class=&quot;yne-plain&quot;&gt;www&lt;span class=&quot;yne-token yne-punctuation&quot;&gt;.&lt;span class=&quot;yne-plain&quot;&gt;googleapis&lt;span class=&quot;yne-token yne-punctuation&quot;&gt;.&lt;span class=&quot;yne-plain&quot;&gt;com&lt;span class=&quot;yne-token yne-operator&quot;&gt;/&lt;span class=&quot;yne-plain&quot;&gt;discovery&lt;span class=&quot;yne-token yne-operator&quot;&gt;/&lt;span class=&quot;yne-plain&quot;&gt;v1&lt;span class=&quot;yne-token yne-operator&quot;&gt;/&lt;span class=&quot;yne-plain&quot;&gt;apis&lt;span class=&quot;yne-token yne-operator&quot;&gt;?&lt;span class=&quot;yne-plain&quot;&gt;fields&lt;span class=&quot;yne-token yne-operator&quot;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;  -H    标记请求的Header，上例指出了当前发起跨域请求的站点Origin； 你也可以在此指定User-Agent&lt;/p&gt;
&lt;p&gt; --verbose   打印整个响应体&lt;/p&gt;
&lt;p&gt; -X      指定请求动词&lt;/p&gt;



&lt;p&gt;本文部分内容取自：https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 30 Jan 2019 07:17:00 +0000</pubDate>
<dc:creator>Julian89757</dc:creator>
<og:description>~。。~ 想看优雅调试CORS请求：请下拉到文末 跨域请求 站点A 请求站点B的数据，都可以认为是跨域请求； 由于安全原因，浏览器严格限制通过脚本的跨域请求，阻止某域名下的web应用尝试发送AJAX请</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mi12205599/p/10337980.html</dc:identifier>
</item>
<item>
<title>自己写一个java的mvc框架吧（一） - 何白白</title>
<link>http://www.cnblogs.com/hebaibai/p/10338082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hebaibai/p/10338082.html</guid>
<description>&lt;h2 id=&quot;写之前的一些废话&quot;&gt;写之前的一些废话&lt;/h2&gt;
&lt;h3 id=&quot;废话-1-总是要先随便说点啥&quot;&gt;废话 1 （总是要先随便说点啥）&lt;/h3&gt;
&lt;p&gt;写了好几年的&lt;strong&gt;java&lt;/strong&gt;程序，基本上每个项目都有用到&lt;strong&gt;mvc&lt;/strong&gt;的框架，可能是&lt;strong&gt;spring mvc&lt;/strong&gt;也可能是&lt;strong&gt;struts&lt;/strong&gt;。这些框架怎么用相信大家也都很熟悉了，但是有没有想过自己写一个&lt;strong&gt;属于自己的mvc的框架&lt;/strong&gt;呢？有没有想过为啥你请求一个&lt;strong&gt;http&lt;/strong&gt;的地址，你的一个&lt;strong&gt;class&lt;/strong&gt;里的方法就能被执行了呢？现在咱们开始写一个&lt;strong&gt;mvc&lt;/strong&gt;框架吧。&lt;/p&gt;
&lt;p&gt;因为2年前自己写过一个mvc的框架，比较烂，但是也能用。所以大致需要的知识点我写在下面，再写一个应该也还是这些东西。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;反射&lt;/p&gt;
&lt;p&gt;基本上要写点框架性质的代码就都需要用到反射的知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;json，xml之类的配置文件的解析&lt;/p&gt;
&lt;p&gt;或多或少都可能需要一点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注解方面的&lt;/p&gt;
&lt;p&gt;如果不想使用配置文件的话，自定义注解是肯定要有的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;servlet&lt;/p&gt;
&lt;p&gt;因为http的入口就是这一个，肯定要用到。如果你要是要用&lt;strong&gt;filter&lt;/strong&gt;，那你就要比较熟悉filter。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;asm&lt;/p&gt;
&lt;p&gt;这个是因为要获取方法上的参数名称，使用反射取参数名称一般都是arg0，arg1这样的，除非有特别的配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;别的应该没了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;废话-2-大致的一个步骤&quot;&gt;废话 2 （大致的一个步骤）&lt;/h3&gt;
&lt;p&gt;大致说一下要写一个&lt;strong&gt;mvc&lt;/strong&gt;咱们都需要干点啥。&lt;/p&gt;
&lt;h4 id=&quot;第一步-创建一个映射关系&quot;&gt;第一步 创建一个映射关系&lt;/h4&gt;
&lt;p&gt;你需要一个 &lt;strong&gt;地址和一个方法的映射&lt;/strong&gt;（这个地址可是一个http的地址，也可以单纯的就是一个随意的字符串或者别的东西，因为这里写的是mvc框架，所以就确定它是一个http的请求地址）。&lt;/p&gt;
&lt;p&gt;这个映射关系可以先用一个java对象保存起来，之后我们可以根据不同的形式来获取到这些数据并填充这个对象。这些数据或许是通过注解，或许是xml文件，也可能是json文件来得到，只需要根据不同的形式来写不同的实现代码就好了，最终只要获取到这个映射关系就好。&lt;/p&gt;
&lt;h4 id=&quot;第二步-获取方法的详细信息&quot;&gt;第二步 获取方法的详细信息&lt;/h4&gt;
&lt;p&gt;请求地址与方法的映射创建完成之后，我们需要知道这个&lt;strong&gt;方法里面都有那些参数&lt;/strong&gt;，每个&lt;strong&gt;参数的名称和参数类型&lt;/strong&gt;是什么。&lt;/p&gt;
&lt;p&gt;这是使用了&lt;strong&gt;asm&lt;/strong&gt;框架。不了解的的同学可以搜一下，他是一个处理java字节码的工具，各大知名框架里都有用到，非常强大。我在这里用这个的主要原因是使用它获取方法的参数名称，因为反射的话没有特殊配置是取不到正确的名称的，但是我又不想有特殊配置～～～&lt;/p&gt;
&lt;h4 id=&quot;第三步-获取并转换请求参数&quot;&gt;第三步 获取并转换请求参数&lt;/h4&gt;
&lt;p&gt;因为我们是&lt;strong&gt;通过http请求来调用java的方法&lt;/strong&gt;，所以我们要把http请求中的参数取出来并&lt;strong&gt;转换成为对应方法中实际的参数类型&lt;/strong&gt;。比如一个方法的入参是 两个&lt;strong&gt;int&lt;/strong&gt;类型的数据，我们就要将http请求中的String类型的数据转换成为int类型。&lt;/p&gt;
&lt;p&gt;这一步我们不需要先直接处理http的请求，先用一些String类型的数据做一些测试即可。处理http请求的地方可以在后面再写。&lt;/p&gt;
&lt;h4 id=&quot;第四步-使用反射执行方法&quot;&gt;第四步 使用反射执行方法&lt;/h4&gt;
&lt;p&gt;这里没什么好说的，反射中的知识点。&lt;/p&gt;
&lt;h4 id=&quot;第五步-写一个http请求的入口并加一些配置&quot;&gt;第五步 写一个http请求的入口，并加一些配置&lt;/h4&gt;
&lt;p&gt;这里开始写一个请求的入口了，&lt;strong&gt;spring&lt;/strong&gt;使用的入口是一个 &lt;strong&gt;servlet&lt;/strong&gt;，&lt;strong&gt;struts&lt;/strong&gt;用的是一个&lt;strong&gt;filter&lt;/strong&gt;，我在这里也用一个&lt;strong&gt;servlet&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里我们需要定义一个配置文件，用来描述上面的映射关系。如果要使用注解的形式，还要自定义一些注解，并写一个包扫描的来处理这些注解。总之就是要吧上面定义的 &lt;strong&gt;请求地址与方法映射&lt;/strong&gt; 的这个对象数据填充起来。&lt;/p&gt;
&lt;p&gt;然后将每次请求过来之后，根据不同的请求路径，获取其映射的方法。之后执行这个方法。&lt;/p&gt;
&lt;h4 id=&quot;第六步-处理执行后的结果&quot;&gt;第六步 处理执行后的结果。&lt;/h4&gt;
&lt;p&gt;这里可能有点麻烦，因为要能适应到不同的视图解析之类的，可能是jsp，freemarker，或者别的啥的。需要好好设计一下代码。&lt;/p&gt;
&lt;p&gt;因为我自己还没有写到，所以先打算以字符串形式直接返回。&lt;/p&gt;
&lt;h3 id=&quot;废话-3-再说点啥&quot;&gt;废话 3 （再说点啥）&lt;/h3&gt;
&lt;p&gt;这个东西我刚开始写，代码在：&lt;a href=&quot;https://github.com/hjx601496320/aMvc&quot; class=&quot;uri&quot;&gt;https://github.com/hjx601496320/aMvc&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;至于什么时候写完？这个就要看公司里忙不忙了，但是基本上能保证这个是能写完的。&lt;/p&gt;
&lt;p&gt;博客的话一般我是自己先写一部分代码，然后在根据写代码的思路写一点博客，可能写着写着就和之前的不太一样了。不过我尽量吧我自己的思路说清楚。&lt;/p&gt;
&lt;h2 id=&quot;废话说完了&quot;&gt;废话说完了&lt;/h2&gt;
&lt;p&gt;现在就开始写吧～&lt;/p&gt;
&lt;p&gt;嗯。下一篇开始具体更新每一步怎么写。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 06:52:00 +0000</pubDate>
<dc:creator>何白白</dc:creator>
<og:description>自己写一个mvc框架吧（一） 写之前的一些废话 废话 1 （总是要先随便说点啥） 写了好几年的 java 程序，基本上每个项目都有用到 mvc 的框架，可能是 spring mvc 也可能是 stru</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hebaibai/p/10338082.html</dc:identifier>
</item>
<item>
<title>004.MySQL双主+Keepalived高可用 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10338088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10338088.html</guid>
<description>
&lt;h2 align=&quot;left&quot;&gt;一 基础环境&lt;/h2&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;99&quot;/&gt;&lt;col width=&quot;163&quot;/&gt;&lt;col width=&quot;166&quot;/&gt;&lt;col width=&quot;153&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;主机名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;系统版本&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;MySQL版本&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-0-3&quot;&gt;
&lt;p&gt;&lt;span&gt;主机IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;Master01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;CentOS 6.8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;MySQL 5.6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-1-3&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.10&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;Master02&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;CentOS 6.8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;MySQL 5.6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-2-3&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;VIP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td rowspan=&quot;1&quot; colspan=&quot;3&quot; align=&quot;center&quot; data-cell-id=&quot;74jhoe1505398821966-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.8.12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二 实际部署&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 安装MySQL&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# yum list installed | grep mysql        #查看是否存在其他MySQL组件
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# yum -y remove mysql-libs.x86_64     #为避免冲突引发报错，卸载已存在的组件
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120731408-1763578721.png&quot;&gt;&lt;img title=&quot;25&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120731676-457176832.png&quot; alt=&quot;25&quot; width=&quot;704&quot; height=&quot;114&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 study]#  yum localinstall mysql-commu* -y
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# chkconfig --list | grep mysqld              #查看MySQL是否加入启动项
&lt;span&gt;  3&lt;/span&gt; [root@Master01 ~]# chkconfig mysqld on
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;2.2 初始化MySQL&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# service mysqld start
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# mysql_secure_installation
&lt;span&gt;  3&lt;/span&gt; [root@Master01 ~]# service iptables stop
&lt;span&gt;  4&lt;/span&gt; [root@Master01 ~]# chkconfig iptables off
&lt;span&gt;  5&lt;/span&gt; [root@Master01 ~]# vi /etc/sysconfig/selinux
&lt;span&gt;  6&lt;/span&gt; SELINUX=disabled
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：以上操作在Master02主机上也需要执行。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装参考：http://www.cnblogs.com/007sx/p/7083143.html&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.3 master01 my.cf配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# vi /etc/my.cnf
&lt;span&gt;  2&lt;/span&gt; [mysqld]
&lt;span&gt;  3&lt;/span&gt; ……
&lt;span&gt;  4&lt;/span&gt; server-id=1                            #设置主服务器master的id
&lt;span&gt;  5&lt;/span&gt; log-bin=mysql-bin                      #配置二进制变更日志命名格式
&lt;span&gt;  6&lt;/span&gt; replicate-wild-ignore-table=mysql.%
&lt;span&gt;  7&lt;/span&gt; replicate-wild-ignore-table=test.%
&lt;span&gt;  8&lt;/span&gt; replicate-wild-ignore-table=information_schema.%
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; # 不同步哪些数据库
&lt;span&gt;  2&lt;/span&gt; binlog-ignore-db = mysql
&lt;span&gt;  3&lt;/span&gt; binlog-ignore-db = test
&lt;span&gt;  4&lt;/span&gt; binlog-ignore-db = information_schema
&lt;span&gt;  5&lt;/span&gt; # 只同步哪些数据库，除此之外，其他不同步
&lt;span&gt;  6&lt;/span&gt; binlog-&lt;span&gt;do&lt;/span&gt;-db = mysqltest
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;方法二：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议采用以下方式配置过滤：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; replicate-wild-ignore-table=mysql.%       #从库配置不同步表
&lt;span&gt;  2&lt;/span&gt; replicate-wild-&lt;span&gt;do&lt;/span&gt;-table=test.%            #从库配置需要同步的表
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：不要在主库使用binlog-ignore-db和binlog-do-db，也不要在从库使用replicate-wild-ignore和replicate-wild-do-table。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.4 创建账号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# mysql -uroot -p
&lt;span&gt;  2&lt;/span&gt; Enter password:
&lt;span&gt;  3&lt;/span&gt; mysql&amp;gt; grant replication slave on *.* to 'repl_user'@'172.24.8.11' identified by 'x12345678';
&lt;span&gt;  4&lt;/span&gt; mysql&amp;gt; grant all privileges on *.* to 'root'@'172.24.8.%'  identified by 'x120952576' with grant option;
&lt;span&gt;  5&lt;/span&gt; mysql&amp;gt; flush privileges;
&lt;span&gt;  6&lt;/span&gt; [root@Master01 ~]# service mysqld restart
&lt;span&gt;  7&lt;/span&gt; [root@Master01 ~]# mysql -uroot -p
&lt;span&gt;  8&lt;/span&gt; Enter password:
&lt;span&gt;  9&lt;/span&gt; mysql&amp;gt; show master status;
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120731872-1781431811.png&quot;&gt;&lt;img title=&quot;26&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120732061-250818197.png&quot; alt=&quot;26&quot; width=&quot;689&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;master01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;file：mysql-bin.000001&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;position：120&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.5 smaster02 my.cf配置配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master02 ~]# vi /etc/my.cnf
&lt;span&gt;  2&lt;/span&gt; [mysqld]
&lt;span&gt;  3&lt;/span&gt; server-id=2                            #设置主服务器master的id
&lt;span&gt;  4&lt;/span&gt; log-bin=mysql-bin                      #配置二进制变更日志命名格式
&lt;span&gt;  5&lt;/span&gt; replicate-wild-ignore-table=mysql.%
&lt;span&gt;  6&lt;/span&gt; replicate-wild-ignore-table=test.%
&lt;span&gt;  7&lt;/span&gt; replicate-wild-ignore-table=information_schema.%
&lt;span&gt;  8&lt;/span&gt; read_only=1
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;2.6 创建账号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master02 ~]# mysql -uroot -p
&lt;span&gt;  2&lt;/span&gt; Enter password:
&lt;span&gt;  3&lt;/span&gt; mysql&amp;gt; grant replication slave on *.* to 'repl_user'@'172.24.8.10' identified by 'x12345678';
&lt;span&gt;  4&lt;/span&gt; mysql&amp;gt; grant all privileges on *.* to 'root'@'172.24.8.%'  identified by 'x120952576' with grant option;
&lt;span&gt;  5&lt;/span&gt; mysql&amp;gt; flush privileges;
&lt;span&gt;  6&lt;/span&gt; [root@Master02 ~]# service mysqld restart
&lt;span&gt;  7&lt;/span&gt; [root@Master02 ~]# mysql -uroot -p
&lt;span&gt;  8&lt;/span&gt; Enter password:
&lt;span&gt;  9&lt;/span&gt; mysql&amp;gt; show master status;
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120732241-471034574.png&quot;&gt;&lt;img title=&quot;27&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120732437-1926552647.png&quot; alt=&quot;27&quot; width=&quot;690&quot; height=&quot;111&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;master02：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;file：mysql-bin.000001&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;position：120&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;三 启动主从&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 手动同步&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果Master01和Master02已经存在数据，则在开启主备复制之前，需要将Master01和Master02手动同步一次（/var/lib/mysql整个目录打包tar.gz），具体方法略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：本实验都是重新安装的MySQL，可直接启动同步。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.2 启动Master01的slave功能&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# service mysqld restart
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# mysql -uroot -p
&lt;span&gt;  3&lt;/span&gt; Enter password:
&lt;span&gt;  4&lt;/span&gt; mysql&amp;gt; change master to master_host='172.24.8.11',
&lt;span&gt;  5&lt;/span&gt; master_user='repl_user',
&lt;span&gt;  6&lt;/span&gt; master_password='x12345678',
&lt;span&gt;  7&lt;/span&gt; master_log_file='mysql-bin.000001',
&lt;span&gt;  8&lt;/span&gt; master_port=3306,
&lt;span&gt;  9&lt;/span&gt; master_log_pos=120;
&lt;span&gt; 10&lt;/span&gt; mysql&amp;gt; start slave;
&lt;span&gt; 11&lt;/span&gt; mysql&amp;gt; show slave status\G                  #查看slave状态
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120732889-229441711.png&quot;&gt;&lt;img title=&quot;28&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120733284-1639119024.png&quot; alt=&quot;28&quot; width=&quot;855&quot; height=&quot;898&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;3.3 启动Master02的slave功能&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master02 ~]# service mysqld restart
&lt;span&gt;  2&lt;/span&gt; [root@Master02 ~]# mysql -uroot -p
&lt;span&gt;  3&lt;/span&gt; Enter password:
&lt;span&gt;  4&lt;/span&gt; mysql&amp;gt; change master to master_host='172.24.8.10',
&lt;span&gt;  5&lt;/span&gt; master_user='repl_user',
&lt;span&gt;  6&lt;/span&gt; master_password='x12345678',
&lt;span&gt;  7&lt;/span&gt; master_log_file='mysql-bin.000001',
&lt;span&gt;  8&lt;/span&gt; master_log_pos=120;
&lt;span&gt;  9&lt;/span&gt; mysql&amp;gt; start slave;
&lt;span&gt; 10&lt;/span&gt; mysql&amp;gt; show slave status\G                  #查看slave状态
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120733568-1955760283.png&quot;&gt;&lt;img title=&quot;29&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120733880-551542435.png&quot; alt=&quot;29&quot; width=&quot;856&quot; height=&quot;896&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;slave的I/O和SQL线程都已经开始运行，而且Seconds_Behind_Master不再是NULL。日志的位置增加了，意味着一些事件被获取并执行了。如果你在master上进行修改，你可以在slave上看到各种日志文件的位置的变化，同样，你也可以看到数据库中数据的变化。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;四 安装Keepalived&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1 下载&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# wget http:&lt;span&gt;//www.keepalived.org/software/keepalived-1.3.6.tar.gz&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# tar -zvxf keepalived-1.3.6.tar.gz -C /tmp/
&lt;span&gt;  3&lt;/span&gt; [root@Master01 ~]# cd /tmp/keepalived-1.3.6
&lt;span&gt;  4&lt;/span&gt; [root@Master01 keepalived-1.3.6]# ./configure --prefix=/usr/local/keepalived/ --sysconf=/etc --with-init=SYSV
&lt;span&gt;  5&lt;/span&gt; #注：(upstart|systemd|SYSV|SUSE|openrc) #根据你的系统选择对应的启动方式
&lt;span&gt;  6&lt;/span&gt; [root@Master01 keepalived-1.3.6]# make &amp;amp;&amp;amp; make install
&lt;span&gt;  7&lt;/span&gt; [root@Master01 ~]# ln -s /usr/local/keepalived/sbin/keepalived /sbin
&lt;span&gt;  8&lt;/span&gt; [root@Master01 ~]# chmod u+x /etc/init.d/keepalived
&lt;span&gt;  9&lt;/span&gt; [root@Master01 ~]# chkconfig --add keepalived
&lt;span&gt; 10&lt;/span&gt; [root@Master01 ~]# chkconfig --level 35 keepalived on
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：Master02上也需要如上操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;若出现以下提示，需要执行：yum -y install openssl-devel。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120734111-1538599097.png&quot;&gt;&lt;img title=&quot;30&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120734326-927708711.png&quot; alt=&quot;30&quot; width=&quot;480&quot; height=&quot;49&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：也可采用yum install -y keepalived安装（个人不建议）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2 Master01配置Keepalived&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;默认情况下keepalived启动时会去/etc/keepalived目录下找配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# vim /etc/keepalived/keepalived.conf
&lt;span&gt;  2&lt;/span&gt; ! Configuration File &lt;span&gt;for&lt;/span&gt; keepalived
&lt;span&gt;  3&lt;/span&gt; global_defs {
&lt;span&gt;  4&lt;/span&gt;    notification_email {
&lt;span&gt;  5&lt;/span&gt;     x120952576@126.com
&lt;span&gt;  6&lt;/span&gt; #表示keepalived在发生诸如切换操作时发送Email给哪些地址，邮件地址可以多个，每行一个。
&lt;span&gt;  7&lt;/span&gt;    }
&lt;span&gt;  8&lt;/span&gt;    notification_email_from Alexandre.Cassen@firewall.loc
&lt;span&gt;  9&lt;/span&gt;    smtp_server 172.24.8.10
&lt;span&gt; 10&lt;/span&gt;    smtp_connect_timeout 30
&lt;span&gt; 11&lt;/span&gt;    router_id LVS_DEVEL
&lt;span&gt; 12&lt;/span&gt; }
&lt;span&gt; 13&lt;/span&gt; vrrp_instance VI_1 {
&lt;span&gt; 14&lt;/span&gt;     state BACKUP
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt; eth0
&lt;span&gt; 16&lt;/span&gt;     virtual_router_id 51
&lt;span&gt; 17&lt;/span&gt; #这里设置VRID，这里非常重要，相同的VRID为一个组，他将决定多播的MAC地址
&lt;span&gt; 18&lt;/span&gt;     priority 100
&lt;span&gt; 19&lt;/span&gt;     advert_int 1
&lt;span&gt; 20&lt;/span&gt;     nopreempt
&lt;span&gt; 21&lt;/span&gt; #不抢占，只在优先级高的机器上设置即可，优先级低的机器不设置
&lt;span&gt; 22&lt;/span&gt;     authentication {
&lt;span&gt; 23&lt;/span&gt;         auth_type PASS
&lt;span&gt; 24&lt;/span&gt;         auth_pass 1111
&lt;span&gt; 25&lt;/span&gt;     }
&lt;span&gt; 26&lt;/span&gt; track_script {
&lt;span&gt; 27&lt;/span&gt;     check_mysqld               #执行定义的监控脚本
&lt;span&gt; 28&lt;/span&gt; }
&lt;span&gt; 29&lt;/span&gt;     virtual_ipaddress {
&lt;span&gt; 30&lt;/span&gt;         172.24.8.12
&lt;span&gt; 31&lt;/span&gt;     }
&lt;span&gt; 32&lt;/span&gt; }
&lt;span&gt; 33&lt;/span&gt; vrrp_script check_mysqld {
&lt;span&gt; 34&lt;/span&gt;     script&quot;&lt;span&gt;/etc/keepalived/mysqlcheck/keepalived_check_mysql.sh &lt;/span&gt;&quot;
&lt;span&gt; 35&lt;/span&gt;     interval 2
&lt;span&gt; 36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;4.3 创建检测脚本&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# mkdir -p /etc/keepalived/mysqlcheck/
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# vi /etc/keepalived/mysqlcheck/keepalived_check_mysql.sh
&lt;span&gt;  3&lt;/span&gt; #!/bin/bash
&lt;span&gt;  4&lt;/span&gt; MYSQL=/usr/bin/mysql
&lt;span&gt;  5&lt;/span&gt; MYSQL_HOST=localhost
&lt;span&gt;  6&lt;/span&gt; MYSQL_USER=root
&lt;span&gt;  7&lt;/span&gt; MYSQL_PASSWORD=x120952576
&lt;span&gt;  8&lt;/span&gt; CHECK_TIME=3
&lt;span&gt;  9&lt;/span&gt; #mysql  &lt;span&gt;is&lt;/span&gt; workingMYSQL_OK &lt;span&gt;is&lt;/span&gt; 1 , mysql down MYSQL_OK &lt;span&gt;is&lt;/span&gt; 0
&lt;span&gt; 10&lt;/span&gt; MYSQL_OK=1
&lt;span&gt; 11&lt;/span&gt; function check_mysql_helth (){
&lt;span&gt; 12&lt;/span&gt; $MYSQL -h $MYSQL_HOST -u $MYSQL_USER -p${MYSQL_PASSWORD} -e &quot;&lt;span&gt;show status;&lt;/span&gt;&quot; &amp;gt;/dev/&lt;span&gt;null&lt;/span&gt; 2&amp;gt;&amp;amp;1
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $? = 0 ] ;then
&lt;span&gt; 14&lt;/span&gt;         MYSQL_OK=1
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;         MYSQL_OK=0
&lt;span&gt; 17&lt;/span&gt; fi
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; $MYSQL_OK
&lt;span&gt; 19&lt;/span&gt; }
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; [ $CHECK_TIME -ne 0 ]
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         let &quot;&lt;span&gt;CHECK_TIME -= 1&lt;/span&gt;&quot;
&lt;span&gt; 23&lt;/span&gt;         check_mysql_helth
&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ $MYSQL_OK = 1 ] ; then
&lt;span&gt; 25&lt;/span&gt;                 CHECK_TIME=0
&lt;span&gt; 26&lt;/span&gt;                 exit 0
&lt;span&gt; 27&lt;/span&gt;         fi
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ $MYSQL_OK -eq 0 ] &amp;amp;&amp;amp;  [ $CHECK_TIME -eq 0 ]
&lt;span&gt; 29&lt;/span&gt;         then
&lt;span&gt; 30&lt;/span&gt;                 /etc/init.d/keepalived stop
&lt;span&gt; 31&lt;/span&gt;                 exit 1
&lt;span&gt; 32&lt;/span&gt;         fi
&lt;span&gt; 33&lt;/span&gt;         sleep 1
&lt;span&gt; 34&lt;/span&gt; done
&lt;span&gt; 35&lt;/span&gt; [root@Master01 ~]# chmod u+x /etc/keepalived/mysqlcheck/keepalived_check_mysql.sh
&lt;span&gt; 36&lt;/span&gt; [root@Master01 ~]# service keepalived start
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;4.4 Master02配置Keepalived&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# scp /etc/keepalived/keepalived.conf root@127.24.8.11:/etc/keepalived/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参考Master01配置，去掉nopreempt选项，priority设置比Master01低即可。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.5 创建检测脚本&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master02 ~]# mkdir -p /etc/keepalived/mysqlcheck/
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# scp /etc/keepalived/mysqlcheck/keepalived_check_mysql.sh root@172.24.8.11:/etc/keepalived/mysqlcheck/
&lt;span&gt;  3&lt;/span&gt; [root@Master02 ~]# chmod u+x /etc/keepalived/mysqlcheck/keepalived_check_mysql.sh
&lt;span&gt;  4&lt;/span&gt; [root@Master02 ~]# service keepalived start
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt;五 功能测试&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;5.1 测试vip&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@test ~]# mysql -uroot -h172.24.8.12 -p
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120734554-1089392504.png&quot;&gt;&lt;img title=&quot;31&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120734782-383867660.png&quot; alt=&quot;31&quot; width=&quot;632&quot; height=&quot;245&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; mysql&amp;gt; show variables like &quot;&lt;span&gt;%hostname%&lt;/span&gt;&quot;;
&lt;span&gt;  2&lt;/span&gt; mysql&amp;gt; show variables like &quot;&lt;span&gt;%server_id%&lt;/span&gt;&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120735040-776355403.png&quot;&gt;&lt;img title=&quot;31&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120735232-166030599.png&quot; alt=&quot;31&quot; width=&quot;632&quot; height=&quot;245&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;5.2 同步测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@test ~]# mysql -uroot -p
&lt;span&gt;  2&lt;/span&gt; Enter password:
&lt;span&gt;  3&lt;/span&gt; mysql&amp;gt; create database mysqltest;
&lt;span&gt;  4&lt;/span&gt; mysql&amp;gt; use mysqltest;
&lt;span&gt;  5&lt;/span&gt; mysql&amp;gt; create table user(id &lt;span&gt;int&lt;/span&gt;(5),name &lt;span&gt;char&lt;/span&gt;(10));
&lt;span&gt;  6&lt;/span&gt; mysql&amp;gt; insert into user values (00001,'zhangsan');
&lt;span&gt;  7&lt;/span&gt; 在Slave从服务器上进行验证：
&lt;span&gt;  8&lt;/span&gt; [root@Master02 ~]# mysql -uroot -p
&lt;span&gt;  9&lt;/span&gt; Enter password:
&lt;span&gt; 10&lt;/span&gt; mysql&amp;gt; show databases;
&lt;span&gt; 11&lt;/span&gt; mysql&amp;gt; select * from mysqltest.user;
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120735450-2042405759.png&quot;&gt;&lt;img title=&quot;33&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120735694-980314131.png&quot; alt=&quot;33&quot; width=&quot;626&quot; height=&quot;514&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;5.3 测试Keepalived切换&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master01 ~]# service mysqld stop                            #停止Master01的MySQL
&lt;span&gt;  2&lt;/span&gt; [root@Master01 ~]# tail -f /var/log/messages                   #观察Master01的日志
&lt;/pre&gt;&lt;/div&gt;

&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120735977-858929187.png&quot;&gt;&lt;img title=&quot;34&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120736348-444750459.png&quot; alt=&quot;34&quot; width=&quot;1505&quot; height=&quot;402&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Master02 ~]# tail -f /var/log/messages                      #观察Master02的日志
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120736753-180668464.png&quot;&gt;&lt;img title=&quot;35&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120737209-1947766101.png&quot; alt=&quot;35&quot; width=&quot;1228&quot; height=&quot;431&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@Client ~]# mysql -uroot -h172.24.8.12 -px120952576  #客户端连接VIP
&lt;/pre&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120737503-1049514197.png&quot;&gt;&lt;img title=&quot;36&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201811/680719-20181105120737775-712006715.png&quot; alt=&quot;36&quot; width=&quot;521&quot; height=&quot;371&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：已经成功切换，在切换过程中可能中断几秒。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 30 Jan 2019 06:52:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 基础环境 主机名 系统版本 MySQL版本 主机IP Master01 CentOS 6.8 MySQL 5.6 172.24.8.10 Master02 CentOS 6.8 MySQL 5.6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10338088.html</dc:identifier>
</item>
<item>
<title>代理模式 - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/10324902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/10324902.html</guid>
<description>&lt;h2 id=&quot;一概念&quot;&gt;一、概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;代理模式：为另一个对象提供一个替身或占位符已控制对这个对象的访问，管理访问的方式有许多种。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;角色：&lt;br/&gt; 1、Subject：主题接口，为 RealSubject 和 Proxy 提供了接口。通过实现同一接口，Proxy 在 RealSubject 出现的地方的取代它。&lt;br/&gt; 2、RealSubject：具体主题，是真正做事的地方，它是被 proxy 代理和控制访问的对象。&lt;br/&gt; 3、Proxy：代理对象，持有 RealSubject 的引用，客户和 RealSubject 的交互都必须通过 Proxy。 在某些场景，Proxy 还会负责 RealSubject 对象的创建和销毁。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1153954/201901/1153954-20190126212111349-1347202242.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二代理模式的几种变体&quot;&gt;二、代理模式的几种变体&lt;/h2&gt;
&lt;h3 id=&quot;远程代理&quot;&gt;1、远程代理&lt;/h3&gt;
&lt;p&gt; 之前在看《Spring 实战》的时候，接触到了&lt;a href=&quot;https://www.cnblogs.com/jmcui/p/9044212.html&quot;&gt;&lt;span&gt;RPC机制&lt;/span&gt;&lt;/a&gt;。现在在读设计模式的时候，才发现 RPC 在设计模式中还有另外一个名字 —— 远程代理。所以这里就不展开讲了，详细了解可参考之前的文章。&lt;/p&gt;
&lt;h3 id=&quot;虚拟代理&quot;&gt;2、虚拟代理&lt;/h3&gt;
&lt;p&gt; 虚拟代理作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中的时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。&lt;/p&gt;
&lt;p&gt; 我们来看一个简单Demo，对于虚拟代理和普通代理的区别就一目了然了~~&lt;/p&gt;
&lt;h4 id=&quot;subject.java&quot;&gt;Subject.java&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description: 主题接口
 */
public interface Subject {

    void request();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;realsubject.java&quot;&gt;RealSubject.java&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description:具体主题 — 真正做事的地方
 */
public class RealSubject implements Subject {

    @Override
    public void request() {
        System.out.println(&quot;this is real subject.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;proxy.java---普通代理&quot;&gt;Proxy.java - 普通代理&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description: 普通代理
 */
public class Proxy implements Subject {

    private Subject subject;

    public Proxy(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void request() {
        subject.request();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;virtualproxy.java---虚拟代理&quot;&gt;VirtualProxy.java - 虚拟代理&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description: 虚拟代理
 */
public class VirtualProxy implements Subject {

    private Subject subject;

    @Override
    public void request() {
        // 在真正使用的时候才创建对象
        if (subject == null) {
            subject = new RealSubject();
        }
        subject.request();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {

    public static void main(String[] args) {
        //1、普通代理
        Subject subject = new RealSubject();
        Proxy proxy = new Proxy(subject);
        proxy.request();

        //2、虚拟代理
        Subject virtualProxy = new VirtualProxy();
        virtualProxy.request();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;保护代理&quot;&gt;3、保护代理&lt;/h3&gt;
&lt;p&gt; Java 在java.lang.reflect包中有自己的代理支持，利用这个包你可以在运行时动态的创建一个代理类，并将方法的调用转发到你说指定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为：动态代理。&lt;/p&gt;
&lt;p&gt; 我们要利用 Java 的动态代理创建一个保护代理实现。所谓保护代理，有点像权限控制系统，代理会拦截所有的请求并判断该次请求是否有权限访问对应的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1153954/201901/1153954-20190130093636175-1635059208.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们用保护代理简单的做一个权限控制，具体表现为：顾客可以查看商品的名字、详情、价格，而卖家可以看到商品的所有信息，包括利润等。&lt;/p&gt;
&lt;h4 id=&quot;商品-goods.java&quot;&gt;商品 — Goods.java&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public interface Goods {
    
    /**
     * @Description 商品的名字、详情、价格 —— 顾客可以查看
     */
    String getName(Long id);

    String getDetail(Long id);

    BigDecimal getPrice(Long id);

    /**
     * @Description 商品的利润 —— 只有卖家可以看到
     */
    BigDecimal getProfit(Long id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;invocationhandler&quot;&gt;InvocationHandler&lt;/h4&gt;
&lt;p&gt; InvocationHandler 的工作是响应代理的任何调用。你可以把 InvocationHandler 想成是代理收到方法调用后，请求做实际工作的对象。就是在 InvocationHandler 中，我们对请求进行筛选，判断是否有权限访问相应的资源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description: 顾客InvocationHandler — 看不到商品利润信息
 */
public class CustomerInvocationHandler implements InvocationHandler {

    private Goods goods;

    public CustomerInvocationHandler(Goods goods) {
        this.goods = goods;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (&quot;getName&quot;.equals(method.getName())
                || &quot;getDetail&quot;.equals(method.getName())
                || &quot;getPrice&quot;.equals(method.getName())) {
            return method.invoke(goods, args);
        }
        if (&quot;getProfit&quot;.equals(method.getName())) {
            throw new IllegalAccessException();
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @Description: 商家InvocationHandler — 可以看到所有信息
 */
public class SellerInvocationHandler implements InvocationHandler {

    private Goods goods;

    public SellerInvocationHandler(Goods goods) {
        this.goods = goods;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(goods, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试-1&quot;&gt;测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    
    public static void main(String[] args) {
        Goods goods = new Clothes();
        // 创建顾客代理
        Goods customer = (Goods) Proxy.newProxyInstance(goods.getClass().getClassLoader(),
                goods.getClass().getInterfaces(),
                new CustomerInvocationHandler(goods));
        // 创建卖家代理
        Goods seller = (Goods) Proxy.newProxyInstance(goods.getClass().getClassLoader(),
                goods.getClass().getInterfaces(),
                new SellerInvocationHandler(goods));
        // 判断某个类是不是代理类
        System.out.println(Proxy.isProxyClass(customer.getClass()));
        
        // 卖家代理调用
        System.out.println(&quot;-------卖家代理调用开始--------&quot;);
        System.out.println(seller.getName(800001L));
        System.out.println(seller.getDetail(800001L));
        System.out.println(seller.getPrice(800001L).doubleValue());
        System.out.println(seller.getProfit(800001L).doubleValue());
        System.out.println(&quot;-------卖家代理调用结束--------&quot;);

        // 顾客代理调用
        System.out.println(&quot;-------顾客代理调用开始--------&quot;);
        System.out.println(customer.getName(800001L));
        System.out.println(customer.getDetail(800001L));
        System.out.println(customer.getPrice(800001L).doubleValue());
        System.out.println(customer.getProfit(800001L).doubleValue());
        System.out.println(&quot;-------顾客代理调用结束--------&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在真实的世界中，代理模式有许多变体，这些变体都有共通点：都会将客户对主题（Subject）施加的方法调用拦截下来。这种间接的级别让我们可以做很多事，包括将请求分发到远程主题 — 远程代理；给创建开销大的对象提供代表 — 虚拟代理；或者提供某些级别的保护 — 保护代理。&lt;/li&gt;
&lt;li&gt;除了上面看到的代理模式的变体，代理模式还有很多应用场景：&lt;br/&gt; 1、防火墙代理（Firewall Proxy）：控制网络资源的访问，保护主题免于“坏客户”的侵害。&lt;br/&gt; 2、智能引用代理（Smart Reference Proxy）：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。&lt;br/&gt; 3、缓存代理（Caching Proxy）：为开销大的运算结果提供暂时的存储：它为允许多个客户共享结果，以减少计算和网络延迟。&lt;br/&gt; 4、同步代理（Synchronization Proxy）：在多线程的情况下为主题提供安全的访问。&lt;br/&gt; 5、复杂隐藏代理（Complexity Hiding Proxy）：用来隐藏一个类的复杂集合的复杂度，并进行访问控制，有时候也被称为外观代理（Facade Proxy）。看起来有点像外观模式，区别在于外观模式只提供了另一组接口，而外观代理控制访问。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如何让客户使用代理，而不是真正的对象？一个常用的技巧是提供一个工厂，实例化并返回主题 — 代理工厂。因为这是在工厂方法内发生的，我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;装饰者模式为对象增加行为，而代理模式是控制对象的访问。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;适配器模式会改变对象适配的接口，而代理模式则实现相同的接口。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;优点：&lt;br/&gt; 1、代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。&lt;br/&gt; 2、代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了保护目标对象的作用。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;缺点：&lt;br/&gt; 1、由于在客户端和真实对象之间增加了代理对象，请求的链路变长，可能会导致请求速度变慢。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;演示源代码：&lt;/strong&gt;&lt;a href=&quot;https://github.com/JMCuixy/design-patterns/tree/master/src/main/java/com/example/proxy&quot;&gt;&lt;span&gt;https://github.com/JMCuixy/design-patterns&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;tips&lt;/span&gt;&lt;/strong&gt;：transient 关键字，告诉 jvm 不要序列化这个字段。&lt;/p&gt;
&lt;h2 id=&quot;四寄语&quot;&gt;四、寄语&lt;/h2&gt;
&lt;p&gt; 年前的最后一篇文章了，祝愿大家新年快乐。愿大家早日实现财务自由！愿大家此生想得到的都拥有，得不到的都释怀！&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 06:35:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>一、概念 代理模式：为另一个对象提供一个替身或占位符已控制对这个对象的访问，管理访问的方式有许多种。 角色：  1、Subject：主题接口，为 RealSubject 和 Proxy 提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/10324902.html</dc:identifier>
</item>
<item>
<title>记录一次有意思的XSS过滤绕过2 - 飘渺__红尘</title>
<link>http://www.cnblogs.com/piaomiaohongchen/p/10337924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/piaomiaohongchen/p/10337924.html</guid>
<description>&lt;p&gt;　　前几天在漏洞挖掘中遇到个xss，感觉绕过过程蛮有意思的，写篇文章记录下。&lt;/p&gt;
&lt;p&gt;　　接下里是我对这个xss详细的分析和绕过&lt;/p&gt;
&lt;p&gt;　　存在问题站点http://******/index/appInfo?appId=784&amp;amp;url=xss&lt;/p&gt;
&lt;p&gt;　　当我查看源代码搜索xss：&lt;/p&gt;
&lt;p&gt;　　一处输出点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130131847555-1202455004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　继续搜索第二处输出点：&lt;/p&gt;
&lt;p&gt;　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130132028451-2076120374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;两次输出，第一次输出是在input标签中，第二次是在js中，这里不考虑input中利用了。因为input的type为hidden，即使能够利用成功xss也非常的鸡肋：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130132226325-50699015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以不考虑input标签了，我们转战到js下构造代码让其弹窗。&lt;/p&gt;
&lt;p&gt;　　最简单的，我们先闭合引号，先输入：';alert(1);//&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130132441349-1243395473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;页面直接变成空白页。。是不是程序判断中过滤了 alert？&lt;/p&gt;
&lt;p&gt;　　我们尝试删除 alert：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130132557228-100888850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还是 空白页，说明()被过滤了。&lt;/p&gt;
&lt;p&gt;我们尝试删除()看看alert有没有被过滤:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130132712672-84303372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;页面显示依旧是空白，接着我尝试把alert替换成prompt和confirm等常用弹窗遇见 ，依旧是空白页，很明显这里对弹窗函数和过滤了()，我们再次尝试双引号(&quot;&quot;)有没有被过滤:&lt;/p&gt;

&lt;p&gt;输入：http://******/index/appInfo?appId=784&amp;amp;url=xss';&quot;xss&quot;;//&lt;/p&gt;
&lt;p&gt;页面显示内容，然后再次查看源代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130133056608-43595134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;双引号没有被过滤。过滤了括号，一些弹窗函数。&lt;/p&gt;
&lt;p&gt;　　现在我们不抱着弹窗的目的看看能否执行一些简单的js操作，尝试用js代码跳转到百度:&lt;/p&gt;
&lt;p&gt;　　代码window.location.href=&quot;http://baidu.com&quot;&lt;/p&gt;
&lt;p&gt;　　我们闭合然后构造：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130133350675-1750799987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;发现还是显示空白页，说明过滤了，我猜测过滤window，我删除其他内容 保留window关键字:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130133517746-1550590690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;只要有 window他就显示空白页面。说明对window做了过滤。&lt;/p&gt;
&lt;p&gt;　　window表示打开的当前窗口，表示当前的还有this关键字，这里过滤了window我们可以尝试使用this代替window:&lt;/p&gt;
&lt;p&gt;　　我们再次构造地址:http://******/index/appInfo?appId=784&amp;amp;url=xss';this.location.href=&quot;http://baidu.com&quot;;//&lt;/p&gt;
&lt;p&gt;　　这次他没有拦截，让我们跳转到了百度:&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130133817503-936869475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在我们可以使用他进行url的跳转，现在我开始想着尝试弹窗，但是这貌似很难，因为他过滤的东西有点多。&lt;/p&gt;
&lt;p&gt;　　我尝试能不能使用dom节点写入:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130134046802-1571019227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;又是空白页面，我保留document删除其他部分 ：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130134152577-470775766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我发现程序只要 有document他就会拦截你到空白页，对于dom来说，没有document是没有灵魂的。虽然过滤document但是我们还是有办法绕过的。&lt;/p&gt;
&lt;p&gt;本地调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130134314855-1372896082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;发现self['doc'+'ument']就是document&lt;/p&gt;
&lt;p&gt;我们构造地址：http://******/index/appInfo?appId=784&amp;amp;url=xss';self['doc'%2b'ument'].body.innerHTML=111//&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130134536165-774335750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实写到这里，我们回顾发现我们现在已经可以做很多我们想做的事情了，我们可以通过js修改一个 界面内容，通过js实现一个任意跳转等。&lt;/p&gt;
&lt;p&gt;　　但是我们本能的觉得xss必须得弹个框框，这是我们普遍对xss的认知，现在我就只想弹窗？我该怎么做？&lt;/p&gt;
&lt;p&gt;　　在过滤了括号，一些弹窗的函数后，我发现我已经很难让他弹窗了。。我思考了很久都无法做到弹窗。。后来请教大佬得到了一种弹窗的方法，为我xss学习又一次打开新的世界：&lt;/p&gt;
&lt;p&gt;　　思路1:通过函数劫持弹窗 ：&lt;/p&gt;
&lt;p&gt;　　查看源码我们发现在下面一行调用了jq的attr属性操作函数，这里我们能否进行函数的劫持？对attr函数进行劫持，劫持他变成alert呢？&lt;/p&gt;
&lt;p&gt;　　这样不就能弹窗了？&lt;/p&gt;
&lt;p&gt;　　因为alert被过滤了，所以我们要用self['al'+'ert']替代绕过：&lt;/p&gt;
&lt;p&gt;　　我们尝试构造这样一个地址：http://******/index/appInfo?appId=784&amp;amp;url=xss';jQuery['attr']=this['al'%2b'ert']//&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130135658254-1698376186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们查看 源代码：&lt;/p&gt;


&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130135121867-987357089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面是我对函数劫持的分析:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130140225979-477355960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　弹窗思路2：&lt;/p&gt;
&lt;p&gt;　　使用#xss payload的方法　　&lt;/p&gt;
&lt;p&gt;　　使用window.location.hash然后外部定位就不会造成任何拦截了 ：&lt;/p&gt;
&lt;p&gt;　　因为过滤很多关键字，我们构造如下地址:&lt;/p&gt;
&lt;p&gt;　　http://******/index/appInfo?appId=784&amp;amp;url=xss%27;location=this.location.hash.slice%601%60;//#javascript:alert('xss')&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130141255970-1080747060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就可以造成弹窗，这里过滤了()我尝试%28%29一样是空白页，尝试把括号改成``还是空白页，当我编码``为%60的时候发现没有拦截，程序自动decode了。故导致xss:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090320/201901/1090320-20190130141657987-812930068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;先写到这里，这次xss的绕过让我收获了很多，为我以后xss研究打开了新的大门，总结 了一些宝贵的经验，从前辈师傅那里学到了更深层的东西&lt;/p&gt;
&lt;p&gt;比如说想玩好xss，一定要学好javascript基础！马上要过年了，特此 写这篇文章 留念下。新的一年有更多的困难和挑战等着我，更多的基础知识需要掌握！加油！　　　　&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 06:20:00 +0000</pubDate>
<dc:creator>飘渺__红尘</dc:creator>
<og:description>前几天在漏洞挖掘中遇到个xss，感觉绕过过程蛮有意思的，写篇文章记录下。 接下里是我对这个xss详细的分析和绕过 存在问题站点http://******/index/appInfo?appId=784</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/piaomiaohongchen/p/10337924.html</dc:identifier>
</item>
<item>
<title>Maven Archetype简介以及搭建 - Kevin_zheng</title>
<link>http://www.cnblogs.com/zhenghengbin/p/10337829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/10337829.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为什么会写这篇文章，因为公司先在构建项目骨架都是用的 &lt;code&gt;maven archetype&lt;/code&gt; ，身为一个上进的渣渣猿，自己还是有必要了解下这个东西的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;archetype介绍&quot;&gt;Archetype介绍&lt;/h2&gt;
&lt;p&gt;Archetype 是一个 Maven 项目模板工具包。原型被定义为原始模式或模型，从中创建所有其他相同类型的东西。这些名称适合我们尝试提供一个系统，该系统提供生成Maven项目的一致方法。Archetype 将帮助作者为用户创建 Maven 项目模板，并为用户提供生成这些项目模板的参数化版本的方法。-- &lt;a href=&quot;https://maven.apache.org/archetype/index.html&quot;&gt;摘自官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;archetype创建&quot;&gt;Archetype创建&lt;/h2&gt;
&lt;p&gt;接下来，我们创建一个我们自己的 &lt;code&gt;archetype&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;创建一个maven项目&quot;&gt;1.创建一个maven项目&lt;/h3&gt;
&lt;p&gt;这里需要引入 &lt;code&gt;maven-archetype-plugin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;完整pom文件如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;groupId&amp;gt;com.kevin&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kevin-test-demo&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;organization&amp;gt;
        &amp;lt;name&amp;gt;kevin-养码青年&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;https://www.cnblogs.com/zhenghengbin/&amp;lt;/url&amp;gt;
    &amp;lt;/organization&amp;gt;


    &amp;lt;properties&amp;gt;
        &amp;lt;jdk.version&amp;gt;1.8&amp;lt;/jdk.version&amp;gt;
        &amp;lt;maven.archetype.version&amp;gt;3.0.1&amp;lt;/maven.archetype.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;maven-archetype-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${maven.archetype.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;



    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;${jdk.version}&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;${jdk.version}&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成archetype&quot;&gt;2、生成archetype&lt;/h3&gt;
&lt;p&gt;打开cmd窗口，在刚才的maven项目的根目录中运行maven命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn archetype:create-from-project&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布&quot;&gt;3、发布&lt;/h3&gt;
&lt;p&gt;进入 &lt;code&gt;target/generated-sources/archetype&lt;/code&gt; 目录。执行 &lt;code&gt;mvn install&lt;/code&gt;,当然也可以发布到私服，这里我没有私服，就只安装到本地&lt;/p&gt;
&lt;p&gt;到此，我们自己的archetype 模板已经创建成功&lt;/p&gt;
&lt;h2 id=&quot;archetype-使用&quot;&gt;Archetype 使用&lt;/h2&gt;
&lt;p&gt;使用很简单，我们要指定我们archetype信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn archetype:generate -DarchetypeGroupId=com.kevin -DarchetypeArtifactId=kevin-test-demo-archetype -DarchetypeVersion=1.0-SNAPSHOT -DgroupId=com.kevin.productName -DartifactId=projectName -Dpackage=com.kevin.productName.projectName -Dversion=1.0.0 -DappName=projectName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;** 注意事项 **&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上面语句是一条完整语句，不能有空格&lt;/li&gt;
&lt;li&gt;-D 前面都有个空格&lt;/li&gt;
&lt;li&gt;-DarchetypeArtifactId 注意后面有archetype&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中最后的5个参数根据实际的情况进行修改，基本规范如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;groupId&lt;/code&gt;：项目工程的groupId；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;artifactId&lt;/code&gt;：项目工程的artifactId；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt;：项目工程的顶级package；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;version&lt;/code&gt;：项目工程的版本号；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;appName&lt;/code&gt;：项目工程打成包时的名字，当基于tomcat插件进行调试时，此名称也作为ContextPath名称。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;archetype&lt;/code&gt; 构建项目，不用让我们在添加各种 &lt;code&gt;pom&lt;/code&gt; 文件或者 &lt;code&gt;copy&lt;/code&gt; 代码。构建项目骨架简单迅速。&lt;br/&gt;玩的开心！&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 05:59:00 +0000</pubDate>
<dc:creator>Kevin_zheng</dc:creator>
<og:description>Maven Archetype简介以及搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/10337829.html</dc:identifier>
</item>
<item>
<title>JAVA-大白话探索JVM-运行时内存（三） - 不会代码的小白</title>
<link>http://www.cnblogs.com/xswz/p/10337815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xswz/p/10337815.html</guid>
<description>&lt;h2 id=&quot;前面章节&quot;&gt;前面章节&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xswz/p/10269508.html&quot;&gt;JAVA-大白话探索JVM-类加载器（一）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xswz/p/10305950.html&quot;&gt;JAVA-大白话探索JVM-类加载过程（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1548743782054&amp;amp;di=6bd526c91a25b3bd5bb09c3abb03f0b7&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.gifhome.com%2Fgif%2Femoji%2F2018%2F145f6cca3ac0406189da57a187901078.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jvm运行时内存&quot;&gt;JVM运行时内存&lt;/h2&gt;
&lt;h4 id=&quot;通过之前的章节我们知道.class类如何加载到内存中如图红框&quot;&gt;通过之前的章节，我们知道.class类如何加载到内存中，如图红框&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://img.ccode.live/imgs/2019/1/29/sWShP_gNl_1L03VzNj1hf..png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1548738600070&amp;amp;di=cedce9f2e5114000e129560cf005bc61&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.gifhome.com%2Fgif%2Femoji%2F2018%2Fc0965b34ece64514b81b7cd36aa9dcc2.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始讲讲内存空间&quot;&gt;开始讲讲内存空间&lt;/h2&gt;
&lt;h3 id=&quot;先了解jvm的周期&quot;&gt;先了解JVM的周期&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JVM在java程序执行时运行，结束时停止。&lt;/li&gt;
&lt;li&gt;一个java程序对应开启一个JVM进程&lt;/li&gt;
&lt;li&gt;JVM的线程分为两种：守护线程和普通线程
&lt;ul&gt;&lt;li&gt;守护线程属于JVM自己使用的线程，如GC&lt;/li&gt;
&lt;li&gt;普通线程是java程序的线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1548743185906&amp;amp;di=8da305ab35543a880fc7a6aae0f93ed2&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.mp.sohu.com%2Fupload%2F20170606%2F1410e92b7e7943cea86f97221e84d547.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程私有数据区&quot;&gt;线程私有数据区&lt;/h3&gt;
&lt;p&gt;你会发现，这都是些什么？？？？？。。。。。。呃&lt;/p&gt;
&lt;p&gt;不着急，一步一步来&lt;/p&gt;
&lt;h3 id=&quot;首先就是你了方法区method-area线程共享&quot;&gt;首先，就是你了，方法区(Method Area,线程共享)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;类的结构信息和类静态变量都保存在方法区(这样说会不会很抽象，举个例，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。)&lt;/li&gt;
&lt;li&gt;程序中的所有线程共享一个方法区，简称全局共享&lt;/li&gt;
&lt;li&gt;对于HotSpot虚拟机，方法区对应为永久代(Permanent Generation)，但本质上，两者并不等价，仅仅是因为HotSpot虚拟机的设计团队是用永久代来实现方法区而已，对于其他的虚拟机(JRockit、J9)来说，是不存在永久代这一概念的。&lt;/li&gt;
&lt;li&gt;使用永久代来实现方法区并不是一个好注意，由于方法区会存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，在某些场景下非常容易出现永久代内存溢出。如Spring、Hibernate等框架在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。在JSP页面较多的情况下，也会出现同样的问题。&lt;/li&gt;
&lt;li&gt;在JDK1.8下并没有出现我们期望的永久代内存溢出错误，而是Metaspace内存溢出错误。这是因为Java团队从JDK1.7开始就逐渐移除了永久代，到JDK1.8时，永久代已经被Metaspace取代，因此在JDK1.8并没有出现我们期望的永久代内存溢出错误。在JDK1.8中，JVM参数-XX:PermSize和-XX:MaxPermSize已经失效，取而代之的是-XX:MetaspaceSize和XX:MaxMetaspaceSize。注意：Metaspace已经不再使用堆空间，转而使用Native Memory&lt;/li&gt;
&lt;li&gt;还有一点需要说明的是，在JDK1.6中，方法区虽然被称为永久代，但并不意味着这些对象真的能够永久存在了，JVM的内存回收机制，仍然会对这一块区域进行扫描，即使回收这部分内存的条件相当苛刻。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;呃。。。。。。。有点多，慢慢吸收，这方法区也需要好好琢磨琢磨，一不小心溢出就麻烦了。&lt;/p&gt;
&lt;h3 id=&quot;其次java堆heap线程共享&quot;&gt;其次，Java堆(Heap,线程共享)&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;Java堆是JVM所管理的最大一块内存，所有线程共享这块内存区域，几乎所有的对象实例都在这里分配内存，因此，它也是垃圾收集器管理的主要区域。&lt;/li&gt;
&lt;li&gt;从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆又可以细分成：新生代和老年代，新生代里面有分为：Eden空间、From Survivor空间、To Survivor空间。&lt;/li&gt;
&lt;li&gt;有一点需要注意：Java堆空间只是在逻辑上是连续的，在物理上并不一定是连续的内存空间。&lt;/li&gt;
&lt;li&gt;默认情况下，新生代中Eden空间与Survivor空间的比例是8:1，可以使用参数-XX:SurvivorRatio对其进行配置。大多数情况下，新生对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，则触发一次Minor GC，将对象Copy到Survivor区，如果Survivor区没有足够的空间来容纳，则会通过分配担保机制提前转移到老年代去。&lt;/li&gt;
&lt;li&gt;何为分配担保机制？在发送Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果是，那么可以确保Minor GC是安全的，如果不是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，直接进行Full GC，如果大于，将尝试着进行一次Minor GC，Minor GC失败才会触发Full GC。注：不同版本的JDK，流程略有不同。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Survivor区作为Eden区和老年代的缓冲区域，常规情况下，在Survivor区的对象经过若干次垃圾回收仍然存活的话，才会被转移到老年代。JVM通过这种方式，将大部分命短的对象放在一起，将少数命长的对象放在一起，分别采取不同的回收策略。&lt;/p&gt;
&lt;h3 id=&quot;java栈stack线程私有本地方法栈&quot;&gt;Java栈(Stack，线程私有)、本地方法栈&lt;/h3&gt;
&lt;h4 id=&quot;java栈&quot;&gt;Java栈&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;java栈中只保存基础数据类型(四类八种)和自定义对象引用&lt;/li&gt;
&lt;li&gt;存取类型：先进后出&lt;/li&gt;
&lt;li&gt;栈内数据在超出其作用域将自动释放&lt;/li&gt;
&lt;li&gt;每个栈是线程私有，它们的生命周期与线程相同。&lt;/li&gt;
&lt;li&gt;每个线程建立一个操作栈，每个栈又包含若干个栈帧，每个栈帧对应每个方法调用&lt;/li&gt;
&lt;li&gt;栈帧：
&lt;/li&gt;
&lt;li&gt;与JAVA栈类似&lt;/li&gt;
&lt;li&gt;本地方法栈是在程序调用或JVM调用本地方法接口(Native)时候启用&lt;/li&gt;
&lt;li&gt;本地方法非java语言编写，不受JVM管理&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HotSpot VM将本地方法栈和JVM栈合并了。&lt;/p&gt;
&lt;h3 id=&quot;程序计数器线程私有&quot;&gt;程序计数器（线程私有）&lt;/h3&gt;
概念：在JVM概念模型里，字节码解释器工作时就说通过改变这个计算器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&lt;/li&gt;
&lt;li&gt;Java虚拟机可以支持多条线程同时执行，多线程是通过线程轮流切换来获得CPU执行时间的,每条线程都会有独立的程序计数器&lt;/li&gt;
&lt;li&gt;如果执行java方法，程序计数器记录JVM字节码指令的地址，如果执行 native，计数器为空(Underfined)&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;程序计数器这个内存区域在JVM规范中是唯一没有规定任何OutOfMemoryError的区域&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;运行时常量池runtime-constant-pool&quot;&gt;运行时常量池(Runtime Constant Pool)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;方法区的一部分，用于存放编译期间生成的各种字面量(int,short等等)和符号引用(对象符号引用Integer,String)&lt;/li&gt;
&lt;li&gt;除了编译产生能存入，运行期间也能将新的常量放入池中(String.intern())&lt;/li&gt;
&lt;li&gt;节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。&lt;/li&gt;
&lt;li&gt;节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，==判断引用是否相等，也就可以判断实际值是否相等&lt;/li&gt;
&lt;li&gt;Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。当对这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。&lt;/li&gt;
&lt;li&gt;Oracle对Java 7中的常量池做了一个非常重要的改变 — 常量池被重新定位到堆中。这意味着你不再受限于单独的固定大小内存区域。所有字符串现在都位于堆中，与大多数其他普通对象一样，这使你可以在调整应用程序时仅管理堆大小。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1548753069140&amp;amp;di=83b5400fe7534f3de368333fbddf8183&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fwww.pig66.com%2Fuploadfile%2F2017%2F0508%2F20170508022904572.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;完了&quot;&gt;完了······&lt;/h3&gt;
&lt;h4 id=&quot;先暂时这么多吧以上是我个人针对jvm的总结也方便大家快速理解跟巩固有错误的地方望告知下谢谢&quot;&gt;先暂时这么多吧，以上是我个人针对JVM的总结，也方便大家快速理解跟巩固，有错误的地方望告知下，谢谢。&lt;/h4&gt;

</description>
<pubDate>Wed, 30 Jan 2019 05:55:00 +0000</pubDate>
<dc:creator>不会代码的小白</dc:creator>
<og:description>前面章节 'JAVA 大白话探索JVM 类加载器（一）' 'JAVA 大白话探索JVM 类加载过程（二）' JVM运行时内存 通过之前的章节，我们知道.class类如何加载到内存中，如图红框 开始讲讲</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xswz/p/10337815.html</dc:identifier>
</item>
<item>
<title>【源码分析】HashMap源码再读-基于Java8 - 端木轩</title>
<link>http://www.cnblogs.com/f-zhao/p/10337803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-zhao/p/10337803.html</guid>
<description>&lt;p&gt;最近工作不是太忙，准备再读读一些源码，想来想去，还是先从JDK的源码读起吧，毕竟很久不去读了，很多东西都生疏了。当然，还是先从炙手可热的&lt;strong&gt;HashMap&lt;/strong&gt;，每次读都会有一些收获。当然，JDK8对HashMap有一次优化&lt;/p&gt;

&lt;p&gt;我们首先看到的，应该是它的一些基本参数，这对于我们了解HashMap有一定的作用。他们分别是：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;capacity&lt;/td&gt;
&lt;td&gt;容量，默认为16，最大为2^30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;loadFactor&lt;/td&gt;
&lt;td&gt;加载因子，默认0.75&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;threshold&lt;/td&gt;
&lt;td&gt;resize的阈值，capacity * loadFactor，元素数量达到这个值后就必须扩容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;treeify_threshold&lt;/td&gt;
&lt;td&gt;红黑树的阈值，数组中的某个节点下挂的节点数大于这个值之后，节点的数据结构就会从链表变为红黑树&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们知道，HashMap底层是通过数组+链表来实现的。具体的图网上有很多，我们主要看看几个重要的方法。&lt;/p&gt;
&lt;h2 id=&quot;构造方法&quot;&gt;2.1 构造方法&lt;/h2&gt;
&lt;p&gt;他的构造方法，最本质的构造方法是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面几行就是做一些基本的检查，我们看到，HashMap的最大容量是&lt;u&gt;MAXIMUM_CAPACITY&lt;/u&gt;，也就是2^30，我们日常使用时可能达不到这样的容量，但是如果真的需要在Map存储这么多的数据，还是建议存在其他的地方吧。当然，最后一行中时为了计算下一次resize的容量阈值，也就是计算出下一次resize的threshold。&lt;/p&gt;
&lt;h2 id=&quot;计算容量&quot;&gt;2.2 计算容量&lt;/h2&gt;
&lt;p&gt;这个方法较简单，直接返回的是一个size的值，这个参数的含义就是当前Map中存储的KV对的数量，而不是整个Map的容量。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int size() {
    return size;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;putkv&quot;&gt;2.3 put(K,V)&lt;/h2&gt;
&lt;p&gt;这个方法是HashMap中比较重要的一个方法，我们仔细分析一下。&lt;/p&gt;
&lt;h3 id=&quot;主入口&quot;&gt;2.3.1 主入口&lt;/h3&gt;
&lt;p&gt;首先，方法的入口是这个，也就是我们经常使用的就是这个方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们主要看的，就是put的整个过程。&lt;/p&gt;
&lt;h3 id=&quot;hashkey&quot;&gt;2.3.2 hash(key)&lt;/h3&gt;
&lt;p&gt;首先就是对我们传入的key，进行hash计算。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个方法，我们可以看到，HashMap的key是可以为null的，如果是null的话，那么我们的hash方法返回的hash值是0。&lt;/p&gt;
&lt;p&gt;如果key不是null，那么调用的是HashMap本身的hashCode方法，也就是我们的bean中自定义的hashCode()。不要以为这样就结束了。我们一般来说，一个key的hash值的范围也就是int的范围（从-2147483648到2147483648），但是HashMap的容量是有限的，必须把hash值能够分散到HashMap的数组中去。HashMap为了key在数组中更加分散，还会进行一次计算，也就是我们看到的第二行的方法。具体这块是如何分配均匀的，可以参考&lt;a href=&quot;http://ibat.xyz/2017/02/16/%E6%B5%85%E8%81%8AHashMap%E4%B8%AD%E7%9A%84hash%E7%AE%97%E6%B3%95/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;putval&quot;&gt;2.3.3 putVal()&lt;/h3&gt;
&lt;p&gt;这个方法就是将KV放到对应的桶中。这个方法的过程，比较清晰。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        //如果之前的数组为空，那么新建一个默认的数组
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        //如果hash值计算出来在数组中的位置上，没有元素，那么直接插入到数组中
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            //如果算出的hash存在，而且kv完全一致的话，那么目前什么也不做
            e = p;
        else if (p instanceof TreeNode)
            //如果数组中的元素是红黑树，那么将kv插入到红黑树中
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    //如果hash的桶中，已经存在了一个链表，那么新增一个节点，放到链表的尾部
                    p.next = newNode(hash, key, value, null);
                    //如果链表的长度大于树化的阈值，那么将链表转为红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //如果当前数组中存在相同的kv，那么根据是否替换来判断，如果不替换，那么就不替换
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        //如果空间需要进行扩容，那么进行resize操作
        resize();
    afterNodeInsertion(evict);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，putVal的方法过程基本上清楚了，但是里面有个非常重要的方法，就是resize，我们下面就进入resize方法，看看到底是如何扩容的。&lt;/p&gt;
&lt;h2 id=&quot;resize&quot;&gt;2.4 resize()&lt;/h2&gt;
&lt;p&gt;这个过程是HashMap扩容的过程，也是需要重点理解的一块。&lt;br/&gt;我们首先看下第一部分。&lt;/p&gt;
&lt;h3 id=&quot;确定容量和扩容阈值&quot;&gt;2.4.1 确定容量和扩容阈值&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Node&amp;lt;K,V&amp;gt;[] oldTab = table;
int oldCap = (oldTab == null) ? 0 : oldTab.length;
int oldThr = threshold;
int newCap, newThr = 0;
if (oldCap &amp;gt; 0) {
    //如果目前容量已经是最大容量，那么扩容阈值为int的最大值，所有的节点都不需要移动
    if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return oldTab;
    }
    //如果oldCap*2小于最大容量，并且oldCap&amp;gt;=16，扩容为2倍，扩容阈值也*2
    else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
        newThr = oldThr &amp;lt;&amp;lt; 1;
}
else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
    newCap = oldThr;
else {// 默认值
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
if (newThr == 0) {//计算新的扩容阈值
    float ft = (float)newCap * loadFactor;
    newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
              (int)ft : Integer.MAX_VALUE);
}
threshold = newThr;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个过程，主要是确定新的容量和扩容阈值。&lt;/p&gt;
&lt;h3 id=&quot;节点移动&quot;&gt;2.4.2 节点移动&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (oldTab != null) {
    for (int j = 0; j &amp;lt; oldCap; ++j) {//遍历老的数组
        Node&amp;lt;K,V&amp;gt; e;
        if ((e = oldTab[j]) != null) {
            oldTab[j] = null;
            if (e.next == null)//如果老的链表，只有一个KV，直接将这个KV放到新的数组链表中
                newTab[e.hash &amp;amp; (newCap - 1)] = e;
            else if (e instanceof TreeNode)//如果老的是红黑树，需要将红黑树中的每个元素都拆分到新的数组和链表/红黑树中
                ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
            else { // 如果节点是链表，而且不止一个KV的情况下，需要对链表进行处理，处理的过程，光看代码理解起来较困难，需要通过例子来理解
                Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                Node&amp;lt;K,V&amp;gt; next;
                do {
                    next = e.next;
                    if ((e.hash &amp;amp; oldCap) == 0) {
                        if (loTail == null)
                            loHead = e;
                        else
                            loTail.next = e;
                        loTail = e;
                    }
                    else {
                        if (hiTail == null)
                            hiHead = e;
                        else
                            hiTail.next = e;
                        hiTail = e;
                    }
                } while ((e = next) != null);
                if (loTail != null) {
                    loTail.next = null;
                    newTab[j] = loHead;
                }
                if (hiTail != null) {
                    hiTail.next = null;
                    newTab[j + oldCap] = hiHead;
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要知道，坐标点的计算方法是&lt;strong&gt;e.hash &amp;amp; (cap-1)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;没有进行扩容时，假设原来的cap=16，也就是默认值，扩容后容量为32。对于hash值为5（二进制为0000 0101）和21（二进制为0001 0101）的元素来讲，计算坐标，也就是和15（二进制为0000 1111）计算后的坐标点都是5，会落到同一个链表中。&lt;/p&gt;
&lt;p&gt;但是扩容后，需要求与的变成了31（二进制为0001 1111），算出来的坐标点分别为5和21，第二个坐标点增加了oldCap的长度。&lt;/p&gt;
&lt;p&gt;此时再看&lt;em&gt;e.hash &amp;amp; oldCap&lt;/em&gt;的计算结果，也就是将5和21和16（二进制为0001 0000）求与，得到的结果分别是0和16（!=0）。可以看到，当&lt;em&gt;e.hash &amp;amp; oldCap&lt;/em&gt;得到0时，坐标不需要进行变动，也就是不需要在数组中的位置不需要移动。如果结果不为0，需要在原来坐标的位置，增加oldCap。&lt;/p&gt;
&lt;p&gt;这里的lo和hi也就是两个链表，表示的是低位和高位的两条链表。&lt;/p&gt;

&lt;p&gt;我们都知道，HashMap不是线程安全的。这块主要体现在两块：&lt;/p&gt;
&lt;h2 id=&quot;get和put&quot;&gt;3.1 get和put&lt;/h2&gt;
&lt;p&gt;这两块都没有加锁，所以可能会导致多线程执行时，出现数据被覆盖的问题。&lt;/p&gt;
&lt;h2 id=&quot;死循环的问题&quot;&gt;3.2 死循环的问题&lt;/h2&gt;
&lt;p&gt;这个问题主要出现在resize的过程中，多线程都探测到需要resize时，将链表元素rehash过程中，可能会导致死循环。这个问题参考&lt;a href=&quot;https://coolshell.cn/articles/9606.html&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;至此，源码分析基本结束，我们还可以思考，为什么cap必须是2的幂次，我们应该如何正确的初始化HashMap等。&lt;/p&gt;
&lt;p&gt;欢迎大家关注我的公众号，有各种一线分享。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1541350-9a89b125eda3671d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;qrcode_for_gh_2e415bdf9b4e_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Jan 2019 05:52:00 +0000</pubDate>
<dc:creator>端木轩</dc:creator>
<og:description>最近工作不是太忙，准备再读读一些源码，想来想去，还是先从JDK的源码读起吧，毕竟很久不去读了，很多东西都生疏了。当然，还是先从炙手可热的 HashMap ，每次读都会有一些收获。当然，JDK8对Has</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-zhao/p/10337803.html</dc:identifier>
</item>
</channel>
</rss>