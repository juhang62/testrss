<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot(二十七)整合Redis之分布式锁 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_lock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_lock.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;29.924050632911&quot;&gt;
&lt;blockquote readability=&quot;7.780534351145&quot;&gt;
&lt;p&gt;在之前的一篇文章(&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/java_lock.html&quot; target=&quot;_blank&quot;&gt;《Java分布式锁,搞懂分布式锁实现看这篇文章就对了》&lt;/a&gt;)，已经介绍过几种java分布式锁，今天来个Redis分布式锁的demo。redis 现在已经成为系统缓存的必备组件，针对缓存读取更新操作，通常我们希望当缓存过期之后能够只有一个请求去更新缓存，其它请求依然使用旧的数据。这就需要用到锁，因为应用服务多数以集群方式部署，因此这里的锁就必需要是分布式锁才能符合需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习本章节之前，建议依次阅读以下文章，更好的串联全文内容，如已掌握以下列出知识点，请跳过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190125152405899-1222483389.png&quot; alt=&quot;请叫我头头哥_SpringBoot(二十七)整合Redis之分布式锁&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;简单实现&lt;/h2&gt;
&lt;p&gt;锁是针对某个资源的状态，保证其访问的互斥性，在实际使用当中，这个状态一般是一个字符串。使用 Redis 实现锁，主要是将状态放到 Redis 当中，利用其原子性，当其他线程访问时，如果 Redis 中已经存在这个状态，就不允许之后的一些操作。spring boot使用Redis的操作主要是通过RedisTemplate(或StringRedisTemplate )来实现。&lt;/p&gt;
&lt;p&gt;1.1 将锁状态放入 Redis：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.opsForValue().setIfAbsent(&quot;lockkey&quot;, &quot;value&quot;); // setIfAbsent如果键不存在则新增,存在则不改变已经有的值。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.2 设置锁的过期时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.expire(&quot;lockkey&quot;, 30000, TimeUnit.MILLISECONDS);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.3 删除/解锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.opsForValue().get(&quot;lockkey&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这么就是简单实现，但是1.1和1.2这么做，这两步违背了原子性，也就是一旦锁被创建，而没有设置过期时间，则锁会一直存在。&lt;/p&gt;
&lt;p&gt;1.4 获取锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.delete(&quot;lockkey&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.5 解决方案&lt;/p&gt;
&lt;p&gt;spring data的 RedisTemplate 当中并没有这样的方法。但是在jedis当中是有这种原子操作的方法的，需要通过 RedisTemplate 的 execute 方法获取到jedis里操作命令的对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
String result = template.execute(&lt;span&gt;new&lt;/span&gt; RedisCallback&amp;lt;String&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String doInRedis(RedisConnection connection) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
                JedisCommands commands &lt;/span&gt;=&lt;span&gt; (JedisCommands) connection.getNativeConnection();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; commands.set(key, &quot;锁定的资源&quot;, &quot;NX&quot;, &quot;PX&quot;, 3000&lt;span&gt;);
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意： Redis 从2.6.12版本开始 set 命令支持 NX 、 PX 这些参数来达到 setnx 、 setex 、 psetex 命令的效果，文档参见： &lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://doc.redisfans.com/string/set.html&quot; target=&quot;_blank&quot;&gt;SET — Redis 命令参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NX： 表示只有当锁定资源不存在的时候才能 SET 成功。利用 Redis 的原子性，保证了只有第一个请求的线程才能获得锁，而之后的所有线程在锁定资源被释放之前都不能获得锁。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;锁的进阶&lt;/h2&gt;
&lt;p&gt;模拟一个比较常见的秒杀场景，这时候就需要用到锁。&lt;/p&gt;
&lt;p&gt;2.1 创建RedisLockHelper&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.base.Strings;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisLockHelper {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringRedisTemplate stringRedisTemplate;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetId   targetId - 商品的唯一标志
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; timeStamp  当前时间+超时时间 也就是时间戳
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; lock(String targetId,String timeStamp){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(stringRedisTemplate.opsForValue().setIfAbsent(targetId,timeStamp)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应setnx命令，可以成功设置,也就是key不存在&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断锁超时 - 防止原来的操作异常，没有运行解锁操作  防止死锁&lt;/span&gt;
        String currentLock =&lt;span&gt; stringRedisTemplate.opsForValue().get(targetId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁过期 currentLock不为空且小于当前时间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(currentLock) &amp;amp;&amp;amp; Long.parseLong(currentLock) &amp;lt;&lt;span&gt; System.currentTimeMillis()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上一个锁的时间value 对应getset，如果lock存在&lt;/span&gt;
            String preLock =&lt;span&gt;stringRedisTemplate.opsForValue().getAndSet(targetId,timeStamp);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设两个线程同时进来这里，因为key被占用了，而且锁过期了。获取的值currentLock=A(get取的旧的值肯定是一样的),两个线程的timeStamp都是B,key都是K.锁时间已经过期了。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而这里面的getAndSet一次只会一个执行，也就是一个执行之后，上一个的timeStamp已经变成了B。只有一个线程获取的上一个值会是A，另一个线程拿到的值是B。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(preLock) &amp;amp;&amp;amp;&lt;span&gt; preLock.equals(currentLock) ){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; preLock不为空且preLock等于currentLock，也就是校验是不是上个对应的商品时间戳，也是防止并发&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 解锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; timeStamp
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock(String target,String timeStamp){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            String currentValue &lt;/span&gt;=&lt;span&gt; stringRedisTemplate.opsForValue().get(target);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(currentValue) &amp;amp;&amp;amp;&lt;span&gt; currentValue.equals(timeStamp) ){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除锁状态&lt;/span&gt;
&lt;span&gt;                stringRedisTemplate.opsForValue().getOperations().delete(target);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            log.error(&lt;/span&gt;&quot;警报！警报！警报！解锁异常{}&quot;&lt;span&gt;,e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是Redis加锁和解锁的工具类，里面使用的主要是两个命令，SETNX和GETSET。&lt;/p&gt;
&lt;p&gt;SETNX命令 将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做&lt;/p&gt;
&lt;p&gt;GETSET命令 先查询出原来的值，值不存在就返回nil。然后再设置值 对应的Java方法在代码中提示了。 注意一点的是，Redis是单线程的！所以在执行GETSET和SETNX不会存在并发的情况。&lt;/p&gt;
&lt;p&gt;2.2 创建Controller模拟秒杀场景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.common.RedisLockHelper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisController {

    @Autowired
    RedisLockHelper redisLockHelper;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 超时时间 5s
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIMEOUT = 5*1000&lt;span&gt;;

    @RequestMapping(value &lt;/span&gt;= &quot;/seckilling&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String Seckilling(String targetId){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; time = System.currentTimeMillis() +&lt;span&gt; TIMEOUT;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;redisLockHelper.lock(targetId,String.valueOf(time))){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;排队人数太多，请稍后再试.&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; surplusCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询该商品库存，为0则活动结束 e.g. getStockByTargetId&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(surplusCount==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;活动结束.&quot;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下单 e.g. buyStockByTargetId

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减库存 不做处理的话，高并发下会出现超卖的情况，下单数，大于减库存的情况。虽然这里减了，但由于并发，减的库存还没存到map中去。新的并发拿到的是原来的库存&lt;/span&gt;
            surplusCount =surplusCount-1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                Thread.sleep(&lt;/span&gt;100);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟减库存的处理时间&lt;/span&gt;
            }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减库存操作数据库 e.g. updateStockByTargetId

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; buyStockByTargetId 和 updateStockByTargetId 可以同步完成(或者事物)，保证原子性。&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解锁&lt;/span&gt;
&lt;span&gt;        redisLockHelper.unlock(targetId,String.valueOf(time));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;恭喜您，秒杀成功。&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其他参考资料：&lt;/p&gt;
&lt;p&gt;注：本文中很多内容来自以上链接的学习心得，感谢以上人员分享，也请转载本文的各站保持以上链接。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademo/tree/master/hellospringboot&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademo/tree/master/hellospringboot&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 11 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>在之前的一篇文章(《Java分布式锁,搞懂分布式锁实现看这篇文章就对了》)，已经介绍过几种java分布式锁，今天来个Redis分布式锁的demo。redis 现在已经成为系统缓存的必备组件，针对缓存读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/redis_lock.html</dc:identifier>
</item>
<item>
<title>浅析MySQL 8忘记密码处理方式 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10363357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10363357.html</guid>
<description>&lt;p&gt;        对MySQL有研究的读者，可能会发现MySQL更新很快，在安装方式上，MySQL提供了两种经典安装方式：解压式和一键式，虽然是两种安装方式，但我更提倡选择解压式安装，不仅快，还干净。在操作系统上，MySQL也支持多类型操作系统，如linux,windows等，如下为MySQL几个重大变化的操作系统。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211231436032-746928616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      通过研究分析，不难发现：MySQL从低版本向高版本迭代变化的过程，越来越严谨的安全性是其一大特点之一，我们举个例子，在版本6前，当忘记密码，重置密码，非常方面，只需使用执行如下两步即可：&lt;/p&gt;
&lt;p&gt;      步骤一：跳过权限表&lt;/p&gt;
&lt;p&gt;           mysqld –skip-grant-tables&lt;/p&gt;
&lt;p&gt;      步骤二：将密码置空&lt;/p&gt;
&lt;p&gt;          UPDATE user SET authentication_string='' WHERE user='root';&lt;/p&gt;
&lt;p&gt;    然而，这个方案，却在MySQL8不适用。&lt;/p&gt;
&lt;p&gt;     本篇文章将来解决MySQL 8忘记密码重置密码问题。主要包括三方面类容&lt;/p&gt;
&lt;p&gt;      内容一：简述解压式安装MySQL 8&lt;/p&gt;
&lt;p&gt;      内容二：忘记密码重置密码解决方案一&lt;/p&gt;
&lt;p&gt;      内容三：忘记密码重置密码解决方案二&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一   安装&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 1.在官网下载安装包(官网提供两种安装方式:可视化安装方式和解压式)，本示例以基于解压式。官网下载地址https://dev.mysql.com/downloads/mysql/&lt;/p&gt;
&lt;p&gt;2.将安装包解压，放在 C:\MySQL 目录下面&lt;/p&gt;
&lt;p&gt;3.配置环境变量&lt;/p&gt;
&lt;p&gt;MySQL_HOME=&quot;C:\MySQL\mysql-8.0.15-winx64&quot;&lt;/p&gt;
&lt;p&gt;PATH=&quot;%MySQL_HOME%\bin&quot;&lt;/p&gt;
&lt;p&gt;4.以管理员身份打开dos&lt;/p&gt;
&lt;p&gt;（1）启动服务&lt;/p&gt;
&lt;p&gt;mysqld --install&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215426116-925107746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)初始化并产生初始化密码(MySQL7+没有data目录，初始话安装data目录)&lt;/p&gt;
&lt;p&gt;mysqld --initialize --user=mysql --console&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215515693-176435662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）启动服务&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdnimg.cn/20190211202952332.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）登录&lt;/p&gt;
&lt;p&gt;账号root,密码为初始话产生的临时密码A*v)(Ivw7xjQ，登录后，需要改变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215648891-474992733.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）更改root密码&lt;/p&gt;
&lt;p&gt;格式：alter user '用户名'@'登录主机' identified by '密码(自定义)';&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdnimg.cn/20190211203625804.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）新密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215751930-663054808.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）扩展命令&lt;/p&gt;
&lt;p&gt;移除服务：mysql --remove&lt;/p&gt;
&lt;p&gt;停止mysql服务：mysql stop mysql&lt;/p&gt;
&lt;p&gt;退出mysql:exit&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二   解决忘记密码问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; （一）方案一&lt;/p&gt;
&lt;p&gt;1.管理员身份进入dos&lt;/p&gt;
&lt;p&gt;2.停止mysql服务&lt;/p&gt;
&lt;p&gt;net stop mysql&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215851020-500173490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.无密码启动&lt;/p&gt;
&lt;p&gt;mysqld --console --skip-grant-tables --shared-memory&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220047323-446829084.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.另启一个dos窗口，无密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220216790-1402446041.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;553&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.清空密码&lt;/p&gt;
&lt;p&gt;注意：authentication_string采用的是plugin加密方式，故设置为空，不要设置为其他值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220917601-723959755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.启动服务&lt;/p&gt;
&lt;p&gt;关闭打开的两个dos窗口，然后以管理员身份重新打开一个dos窗口，启动服务&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220447894-1840845109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.无密码登录&lt;/p&gt;
&lt;p&gt;mysql -u root&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220517407-672999190.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.重新设置密码&lt;/p&gt;
&lt;p&gt;修改后，就可以用新密码登录了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220550893-959459183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.新密码登录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220757099-1329595512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（二）方案二：利用参数 --init-file参数&lt;/p&gt;
&lt;p&gt;1.停止服务&lt;/p&gt;
&lt;p&gt;net stop mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230205266-1530696167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在c:\MySQL 目录下创建ResetPWD.txt文件，文件内容为&lt;/p&gt;
&lt;p&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230335449-2035767987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.执行ResetPWD.txt文件&lt;/p&gt;
&lt;p&gt;mysqld --init-file=c:\mysql\ResetPWD.txt --console，执行完毕后，关闭dos窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230533360-1379416166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.启动mysql&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230703644-1094292926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.用新密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230744258-1919296969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三  版权区&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/li&gt;
&lt;li&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/li&gt;
&lt;li&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/li&gt;
&lt;li&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/li&gt;
&lt;li&gt;可以转载该博客，但必须著名博客来源。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; &lt;/h2&gt;

</description>
<pubDate>Mon, 11 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>对MySQL有研究的读者，可能会发现MySQL更新很快，在安装方式上，MySQL提供了两种经典安装方式：解压式和一键式，虽然是两种安装方式，但我更提倡选择解压式安装，不仅快，还干净。在操作系统上，My</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10363357.html</dc:identifier>
</item>
<item>
<title>如何优雅的在Java应用中实现全局枚举处理 - 史亚健</title>
<link>http://www.cnblogs.com/shiyajian/p/10363554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiyajian/p/10363554.html</guid>
<description>&lt;h2 id=&quot;背景描述&quot;&gt;背景描述&lt;/h2&gt;
&lt;p&gt;为了表达某一个属性，具备一组可选的范围，我们一般会采用两种方式。枚举类和数据字典，两者具有各自的优点。枚举类写在Java代码中，方便编写相应的判断逻辑，代码可读性高，枚举类中的属性是可提前预估和确定的。数据字典，一般保存在数据库，不便于编写判断和分支逻辑，因为数据如果有所变动，那么对应的代码逻辑很有可能失效，强依赖数据库数据的正确性，数据字典中对应的属性对业务影响并不大，日常开发中常用做分类，打标签使用，属性的多少无法估计。&lt;/p&gt;
&lt;p&gt;目前基本上没有一个很好的全局处理枚举类的方案，所以我就自己综合各方面资料写了一个。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;架构还在不断完善中，代码不一定可以跑起来，不过关于枚举的配置已经完成，大家可以阅读并参考借鉴：&lt;a href=&quot;https://github.com/Shiyajian/pretty-demo.git&quot;&gt;pretty-demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大多数公司处理枚举的时候，会自定义一个枚举转换工具类，或者在枚举类中编写一个静态方法实现Integer转换枚举的方式。比如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 静态方法方式
public enum GenderEnum {

     // 代码略
    
     public static GenderEnum get(int value) {
         for (GenderEnum item : GenderEnum.values()) {
            if (value == item.getValue()) {
                 return item;
             }
         }
         return null;
     }
}
// 工具类方式
public class EnumUtil {

    public static &amp;lt;E extends Enumerable&amp;gt; E of(@Nonnull Class&amp;lt;E&amp;gt; classType, int value) {
        for (E enumConstant : classType.getEnumConstants()) {
            if (value == enumConstant.getValue()) {
                return enumConstant;
            }
        }
        return null;
    }

}

GenderEnum gender = EnumUtil.of(GenderEnum.class,1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式很麻烦，或者需要手动编写对应的静态方法，或者需要手动调用工具类进行转换。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;为了方便起见，我做了一个全局枚举值转换的方案，这个方案可以实现前端通过传递int到服务端，服务端自动转换成枚举类，进行相应的业务判断之后，再以数字的形式存到数据库；我们在查数据的时候，又能将数据库的数字转换成java枚举类，在处理完对应的业务逻辑之后，将枚举和枚举类对应的展示信息一起传递到前台，前台不需要维护这个枚举类和展示信息的对应关系，同时展示信息支持国际化处理，具体的方案如下：&lt;/p&gt;
&lt;p&gt;1、基于约定大于配置的原则，制定统一的枚举类的编写规则。大概规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个枚举类有两个字段: int value（存数据库），String key（通过key找对应的i18n文本信息）。这块需要细细讨论下，枚举值通常存数据库有存int值，也有存String值，各有利弊。存int的好处就是体积小，如果枚举的值是包含规律的，比如-1是删除，0是预处理，1是处理，2是处理完成，那么我们所有非删除数据，我们可以不使用 status in ( 0,1,2)这种方式，而转换为 status &amp;gt;= 0 ; 存String的话，好处就是可读性高，直接能从数据库的值中明白对应的状态，劣势就是占的体积大点。当然这些都是相对的，存int的时候，我们可以完善好注释，也具备好的可读性。如果int换成String，占的体积多的那一点，其实也可以忽略不计的。&lt;/li&gt;
&lt;li&gt;枚举枚举类需要继承统一接口，提供相应的方法供通用处理枚举时候使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是枚举接口和一个枚举示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Enumerable&amp;lt;E extends Enumerable&amp;gt; {

    /**
     * 获取在i18n文件中对应的 key
     * @return key
     */
    @Nonnull
    String getKey();

    /**
     * 获取最终保存到数据库的值
     * @return 值
     */
    @Nonnull
    int getValue();

    /**
     * 获取 key 对应的文本信息
     * @return 文本信息
     */
    @Nonnull
    default String getText() {
        return I18nMessageUtil.getMessage(this.getKey(), null);
    }
}
public enum GenderEnum implements Enumerable {

    /** 男 */
    MALE(1, &quot;male&quot;),

    /** 女 */
    FEMALE(2, &quot;female&quot;);

    private int value;

    private String key;

    GenderEnum(int value, String key) {
        this.value = value;
        this.key = key;
    }

    @Override
    public String getKey() {
        return this.key;
    }

    @Override
    public int getValue() {
        return this.value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们要做的就是，每个我们编写的枚举类，都需要按这样的方式进行编写，按照规范定义的枚举类方便下面统一编写。&lt;/p&gt;
&lt;p&gt;2、我们分析下controller层面的数据进和出，从而处理好枚举类和int值的转换，在Spring MVC中，框架帮我们做了数据类型的转换，所以我们以 Spring MVC作为切入点。前台发送到服务端的请求，一般有参数在url中和body中两种方式为主，分别以get请求和post请求配合@RequestBody为代表。&lt;/p&gt;
&lt;p&gt;【入参】get方法为代表，请求的MediaType为&quot;application/x-www-form-urlencoded&quot;，此时将 int 转换成枚举，我们注册一个新的Converter，如果spring MVC判断到一个值要转换成我们定义的枚举类对象时，调用我们设定的这个转换器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class MvcConfiguration implements WebMvcConfigurer, WebBindingInitializer {

    /**
     * [get]请求中，将int值转换成枚举类
     * @param registry
     */
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverterFactory(new EnumConverterFactory());
    }
}

public class EnumConverterFactory implements ConverterFactory&amp;lt;String, Enumerable&amp;gt; {

    private final Map&amp;lt;Class, Converter&amp;gt; converterCache = new WeakHashMap&amp;lt;&amp;gt;();

    @Override
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public &amp;lt;T extends Enumerable&amp;gt; Converter&amp;lt;String, T&amp;gt; getConverter(@Nonnull Class&amp;lt;T&amp;gt; targetType) {
        return converterCache.computeIfAbsent(targetType,
                k -&amp;gt; converterCache.put(k, new EnumConverter(k))
        );
    }

    protected class EnumConverter&amp;lt;T extends Enumerable&amp;gt; implements Converter&amp;lt;Integer, T&amp;gt; {

        private final Class&amp;lt;T&amp;gt; enumType;

        public EnumConverter(@Nonnull Class&amp;lt;T&amp;gt; enumType) {
            this.enumType = enumType;
        }

        @Override
        public T convert(@Nonnull Integer value) {
            return EnumUtil.of(this.enumType, value);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【入参】post为代表，将 int 转换成枚举。这块我们和前台达成一个约定（ Ajax中applicationType），所有在body中的数据必须为json格式。同样后台@RequestBody对应的参数的请求的MediaType为&quot;application/json&quot;，spring MVC中对于Json格式的数据，默认使用 Jackson2HttpMessageConverter。在Jackson转换成实体时候，有@JsonCreator和@JsonValue两个注解可以用，但是感觉还是有点麻烦。为了统一处理，我们需要修改Jackson对枚举类的序列化和反序列的支持。配置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@Slf4j
public class JacksonConfiguration {

    /**
     * Jackson的转换器
     * @return
     */
    @Bean
    @Primary
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public MappingJackson2HttpMessageConverter mappingJacksonHttpMessageConverter() {
        final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = converter.getObjectMapper();
        // Include.NON_EMPTY 属性为 空（&quot;&quot;） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        // 反序列化时候，遇到多余的字段不失败，忽略
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 允许出现特殊字符和转义符
        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);
        // 允许出现单引号
        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
        SimpleModule customerModule = new SimpleModule();
        customerModule.addDeserializer(String.class, new StringTrimDeserializer(String.class));
        customerModule.addDeserializer(Enumerable.class, new EnumDeserializer(Enumerable.class));
        customerModule.addSerializer(Enumerable.class, new EnumSerializer(Enumerable.class));
        objectMapper.registerModule(customerModule);
        converter.setSupportedMediaTypes(ImmutableList.of(MediaType.TEXT_HTML, MediaType.APPLICATION_JSON));
        return converter;
    }

}
public class EnumDeserializer&amp;lt;E extends Enumerable&amp;gt; extends StdDeserializer&amp;lt;E&amp;gt; {

    private Class&amp;lt;E&amp;gt; enumType;

    public EnumDeserializer(@Nonnull Class&amp;lt;E&amp;gt; enumType) {
        super(enumType);
        this.enumType = enumType;
    }

    @Override
    public E deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
        return EnumUtil.of(this.enumType, jsonParser.getIntValue());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【出参】当我们查询出结果，要展示给前台的时候，我们会对结果集增加@ResponseBody注解，这时候会调用Jackson的序列化方法，所以我们增加了枚举类的序列配置。如果我们只简单的将枚举转换成 int 给前台，那么前台需要维护这个枚举类的 int 和对应展示信息的关系。所以这块我们将值和展示信息一同返给前台，减轻前台的工作压力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 注册枚举类序列化处理类
customerModule.addSerializer(Enumerable.class, new EnumSerializer(Enumerable.class));

public class EnumSerializer extends StdSerializer&amp;lt;Enumerable&amp;gt; {

    public EnumSerializer(@Nonnull Class&amp;lt;Enumerable&amp;gt; type) {
        super(type);
    }

    @Override
    public void serialize(Enumerable enumerable, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();
        jsonGenerator.writeNumberField(&quot;value&quot;, enumerable.getValue());
        jsonGenerator.writeStringField(&quot;text&quot;, enumerable.getText());
        jsonGenerator.writeEndObject();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样关于入参和出参的配置都完成了，我们可以保证，所有前台传递到后台的 int 都会自动转换成枚举类。如果返回的数据有枚举类，枚举类也会包含值和展示文本，方便简单。&lt;/p&gt;
&lt;p&gt;3、存储层关于枚举类的转换。这里选的 ORM 框架为 Mybatis ，但是你如果翻看&lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/configuration.html&quot;&gt;官网&lt;/a&gt;，官网的资料只提供了两个方案，就是通过枚举隐藏字段name和ordinal的转换，没有一个通用枚举的解决方案。但是通过翻看 github 中的 &lt;a href=&quot;https://github.com/mybatis/mybatis-3/issues/970&quot;&gt;issue&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/mybatis/mybatis-3/releases/tag/mybatis-3.4.5&quot;&gt;release&lt;/a&gt; 记录，发现在 3.4.5版本中就提供了对应的自定义枚举处理配置，这块不需要我们做过多的配置，我们直接增加 mybatis-spring-boot-starter 的依赖，直接配置对应的Yaml 文件就实现了功能。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;application.yml
--
mybatis:
  configuration:
    default-enum-type-handler: github.shiyajian.pretty.config.enums.EnumTypeHandler&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EnumTypeHandler&amp;lt;E extends Enumerable&amp;gt; extends BaseTypeHandler&amp;lt;E&amp;gt; {

    private Class&amp;lt;E&amp;gt; enumType;

    public EnumTypeHandler() { /* instance */ }


    public EnumTypeHandler(@Nonnull Class&amp;lt;E&amp;gt; enumType) {
        this.enumType = enumType;
    }

    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, E e, JdbcType jdbcType) throws SQLException {
        preparedStatement.setInt(i, e.getValue());
    }

    @Override
    public E getNullableResult(ResultSet rs, String columnName) throws SQLException {
        int value = rs.getInt(columnName);
        return rs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

    @Override
    public E getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        int value = rs.getInt(columnIndex);
        return rs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

    @Override
    public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        int value = cs.getInt(columnIndex);
        return cs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就完成了从前台页面到业务代码到数据库的存储，从数据库查询到业务代码再到页面的枚举类转换。整个项目中完全不需要再手动去处理枚举类了。我们的开发流程简单了很多。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;一个好的方案并不需要多么高大上的技术，比如各种反射，各种设计模式，只要设计合理，就是简单易用，类似中国古代的榫卯。&lt;/p&gt;
&lt;p&gt;ps: 打算3月中旬辞职去杭州，3年多点，有需要招人的可以先交流交流：微信（q408859832），个人吹牛扯淡技术探讨qq群（757696438）&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 15:05:00 +0000</pubDate>
<dc:creator>史亚健</dc:creator>
<og:description>背景描述 为了表达某一个属性，具备一组可选的范围，我们一般会采用两种方式。枚举类和数据字典，两者具有各自的优点。枚举类写在Java代码中，方便编写相应的判断逻辑，代码可读性高，枚举类中的属性是可提前预</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiyajian/p/10363554.html</dc:identifier>
</item>
<item>
<title>多媒体文件格式（四）：TS 格式 - 灰色飘零</title>
<link>http://www.cnblogs.com/renhui/p/10362640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renhui/p/10362640.html</guid>
<description>&lt;p&gt;TS是一种音视频封装格式，全称为MPEG2-TS。其中TS即&quot;Transport Stream&quot;的缩写。&lt;/p&gt;
&lt;p&gt;先简要介绍一下什么是MPEG2-TS：&lt;/p&gt;
&lt;p&gt;DVD的音视频格式为MPEG2-PS，全称是Program Stream。而TS的全称则是Transport Stream。MPEG2-PS主要应用于存储的具有固定时长的节目，如DVD电影，而MPEG-TS则主要应用于实时传送的节目，比如实时广播的电视节目。这两种格式的主要区别是什么呢？简单地打个比喻说，你将DVD上的VOB文件的前面一截cut掉（或者干脆就是数据损坏），那么就会导致整个文件无法解码了，而电视节目是你任何时候打开电视机都能解码（收看）的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出，TS格式是主要用于直播的码流结构，具有很好的容错能力。通常TS流的后缀是.ts、.mpg或者.mpeg，多数播放器直接支持这种格式的播放。TS流中不包含快速seek的机制，只能通过协议层实现seek。HLS协议基于TS流实现的。&lt;/p&gt;
&lt;p&gt;TS格式分析工具：&lt;a href=&quot;https://pan.baidu.com/s/1wh1Ajxwv8T0vHwAYjI6PJA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1wh1Ajxwv8T0vHwAYjI6PJA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TS文件（流）可以分为三层：TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）。&lt;/p&gt;
&lt;p&gt;ES层就是音视频数据，PES层是在音视频数据上加了时间戳等对数据帧的说明信息，TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。&lt;/p&gt;
&lt;p&gt;下图是TS文件（码流）的分层结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682616/201902/682616-20190211204923332-1306467199.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原图可以在：&lt;a href=&quot;https://github.com/renhui/Thinking-in-AV/blob/master/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/TS/1.TS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg&quot; target=&quot;_blank&quot;&gt;https://github.com/renhui/Thinking-in-AV/blob/master/多媒体格式/TS/1.TS分层结构.jpg&lt;/a&gt; 查看。&lt;/p&gt;

&lt;p&gt;TS包大小固定为188字节，TS层分为三个部分：TS Header、Adaptation Field、Payload。&lt;/p&gt;
&lt;p&gt;TS Header固定4个字节；Adaptation Field可能存在也可能不存在，主要作用是给不足188字节的数据做填充；Payload是PES数据。&lt;/p&gt;
&lt;h3&gt;1. TS Header&lt;/h3&gt;
&lt;p&gt;TS包的包头提供关于传输方面的信息。&lt;/p&gt;
&lt;p&gt;TS包的包头长度不固定，前4个字节是固定的，后面可能跟有自适应字段（适配域）。4个字节是最小包头。&lt;/p&gt;
&lt;p&gt;包头的结构体字段如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sync_byte（同步字节）：固定为0x47;该字节由解码器识别，使包头和有效负载可相互分离。&lt;/li&gt;
&lt;li&gt;transport_error_indicator（传输错误标志）：‘1’表示在相关的传输包中至少有一个不可纠正的错误位。当被置1后，在错误被纠正之前不能重置为0。&lt;/li&gt;
&lt;li&gt;payload_unit_start_indicator（负载起始标志）：为1时，表示当前TS包的有效载荷中包含PES或者PSI的起始位置；在前4个字节之后会有一个调整字节，其的数值为后面调整字段的长度length。因此有效载荷开始的位置应再偏移1+[length]个字节。&lt;/li&gt;
&lt;li&gt;transport_priority（传输优先级标志）：‘1’表明当前TS包的优先级比其他具有相同PID， 但此位没有被置‘1’的TS包高。&lt;/li&gt;
&lt;li&gt;PID：指示存储与分组有效负载中数据的类型。&lt;/li&gt;
&lt;li&gt;transport_scrambling_control（加扰控制标志）：表示TS流分组有效负载的加密模式。空包为‘00’，如果传输包包头中包括调整字段，不应被加密。其他取值含义是用户自定义的。&lt;/li&gt;
&lt;li&gt;adaptation_field_control（适配域控制标志）：表示包头是否有调整字段或有效负载。‘00’为ISO/IEC未来使用保留；‘01’仅含有效载荷，无调整字段；‘10’ 无有效载荷，仅含调整字段；‘11’ 调整字段后为有效载荷，调整字段中的前一个字节表示调整字段的长度length，有效载荷开始的位置应再偏移[length]个字节。空包应为‘10’。&lt;/li&gt;
&lt;li&gt;continuity_counter（连续性计数器）：随着每一个具有相同PID的TS流分组而增加，当它达到最大值后又回复到0。范围为0~15。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. TS Adaptation Field&lt;/h3&gt;
&lt;p&gt;Adaptation Field的长度要包含传输错误指示符标识的一个字节。&lt;/p&gt;
&lt;p&gt;PCR是节目时钟参考，PCR、DTS、PTS都是对同一个系统时钟的采样值，PCR是递增的，因此可以将其设置为DTS值，音频数据不需要PCR。&lt;/p&gt;
&lt;p&gt;打包TS流时PAT和PMT表是没有Adaptation Field的，不够的长度直接补0xff即可。&lt;/p&gt;
&lt;p&gt;视频流和音频流都需要加adaptation field，通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。&lt;/p&gt;
&lt;h3 id=&quot;ts包负载部分&quot;&gt;3. TS Payload&lt;/h3&gt;
&lt;p&gt;TS包中Payload所传输的信息包括两种类型：视频、音频的PES包以及辅助数据；节目专用信息PSI。&lt;/p&gt;
&lt;p&gt;TS包也可以是空包。空包用来填充TS流，可能在重新进行多路复用时被插入或删除。&lt;/p&gt;
&lt;p&gt;视频、音频的ES流需进行打包形成视频、音频的 PES流。辅助数据（如图文电视信息）不需要打成PES包。&lt;/p&gt;

&lt;h3&gt;1. PES层&lt;/h3&gt;
&lt;p&gt;PES结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682616/201902/682616-20190211214448146-501104692.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的结构图可以看出，PES层是在每一个视频/音频帧上加入了时间戳等信息，PES包内容很多，下面我们说明一下最常用的字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pes start code：开始码，固定为0x000001。&lt;/li&gt;
&lt;li&gt;stream id：音频取值（0xc0-0xdf），通常为0xc0；视频取值（0xe0-0xef），通常为0xe0。&lt;/li&gt;
&lt;li&gt;pes packet length：后面pes数据的长度，0表示长度不限制，只有视频数据长度会超过0xffff。&lt;/li&gt;
&lt;li&gt;pes data length：后面数据的长度，取值5或10。&lt;/li&gt;
&lt;li&gt;pts：33bit值&lt;/li&gt;
&lt;li&gt;dts：33bit值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于时间戳PTS和DTS的说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PTS是显示时间戳、DTS是解码时间戳。&lt;/li&gt;
&lt;li&gt;视频数据两种时间戳都需要，音频数据的PTS和DTS相同，所以只需要PTS。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有PTS和DTS两种时间戳是B帧引起的，I帧和P帧的PTS等于DTS。如果一个视频没有B帧，则PTS永远和DTS相同。&lt;/p&gt;
&lt;p&gt;从文件中顺序读取视频帧，取出的帧顺序和DTS顺序相同。DTS算法比较简单，初始值 + 增量即可，PTS计算比较复杂，需要在DTS的基础上加偏移量。&lt;/p&gt;
&lt;p&gt;音频的PES中只有PTS（同DTS），视频的I、P帧两种时间戳都要有，视频B帧只要PTS（同DTS）。&lt;/p&gt;
&lt;h3&gt;2. ES 层&lt;/h3&gt;
&lt;p&gt;ES层指的就是音视频数据。&lt;/p&gt;
&lt;p&gt;一般的，视频为H.264视频，音频为AAC音频。&lt;/p&gt;

&lt;h3&gt;1. TS 流生成流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。&lt;/li&gt;
&lt;li&gt;对ES（基本码流）进行打包形成PES。&lt;/li&gt;
&lt;li&gt;在PES包中加入时间戳信息(PTS/DTS)。&lt;/li&gt;
&lt;li&gt;将PES包内容分配到一系列固定长度的传输包（TS Packet）中。&lt;/li&gt;
&lt;li&gt;在传输包中加入定时信息(PCR)。&lt;/li&gt;
&lt;li&gt;在传输包中加入节目专用信息(PSI) 。&lt;/li&gt;
&lt;li&gt;连续输出传输包形成具有恒定比特率的MPEG-TS流。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. TS 流解析流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;复用的MPEG-TS流中解析出TS包；&lt;/li&gt;
&lt;li&gt;从TS包中获取PAT及对应的PMT；&lt;/li&gt;
&lt;li&gt;从而获取特定节目的音视频PID；&lt;/li&gt;
&lt;li&gt;通过PID筛选出特定音视频相关的TS包，并解析出PES；&lt;/li&gt;
&lt;li&gt;从PES中读取到PTS/DTS，并从PES中解析出基本码流ES；&lt;/li&gt;
&lt;li&gt;将ES交给解码器，获得压缩前的原始音视频数据。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 11 Feb 2019 14:59:00 +0000</pubDate>
<dc:creator>灰色飘零</dc:creator>
<og:description>一、TS 格式标准介绍 TS是一种音视频封装格式，全称为MPEG2-TS。其中TS即&quot;Transport Stream&quot;的缩写。 先简要介绍一下什么是MPEG2-TS： DVD的音</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renhui/p/10362640.html</dc:identifier>
</item>
<item>
<title>Python中的@property装饰器 - szjshuffle</title>
<link>http://www.cnblogs.com/szjshuffle/p/10363463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szjshuffle/p/10363463.html</guid>
<description>&lt;p&gt;要了解@property的用途，首先要了解如何创建一个属性。&lt;/p&gt;
&lt;p&gt;一般而言，属性都通过__init__方法创建，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,score):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         self.name=&lt;span&gt;name
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         self.score=score
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建实例，运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tim=Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,97&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tim.score=100
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;tim.score 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 100 
&lt;span&gt;5&lt;/span&gt; mary=Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,90&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;mary.score 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样子有2个坏处：&lt;/p&gt;
&lt;p&gt;1.__init__ 中定义的属性是可变的，如果一个系统的开发人员在知道属性名的情况下，就可以进行随意更改(尽管可能是在无意识的情况下)，如果一不小心篡改了，后台排查很难！&lt;/p&gt;
&lt;p&gt;2.不利于进行参数检查，比如：score属性范围本该是[0,100],但如果输成了1000也不会报错。&lt;/p&gt;
&lt;p&gt;因此，一个标准的创建属性流程如下:&lt;/p&gt;
&lt;p&gt;1.定义三个跟属性(本例中是score)相关的函数：&lt;/p&gt;
&lt;p&gt;get(用于返回score属性)&lt;/p&gt;
&lt;p&gt;set(用于设定score属性)&lt;/p&gt;
&lt;p&gt;del(用于删除score属性)&lt;/p&gt;
&lt;p&gt;在set函数中，可以添加一些取值范围，比如[0,100].此外，为了私有化属性，前面可以加上__。&lt;/p&gt;
&lt;p&gt;这样就做到了既能通过创建实例设定属性，又不让开发人员轻易修改score属性。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，一旦score取值不在设定范围内，就会报错！&lt;/p&gt;
&lt;p&gt;创建一个实例，能够正常运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Mary=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Mary.setScore(90&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Mary.getScore()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，通过方法getScore()查看分数似乎还是有点繁琐，能不能把它当作一个属性去调用呢?至少调用不需要输入()嘛！&lt;/p&gt;
&lt;p&gt;当然是可以的。&lt;/p&gt;
&lt;p&gt;办法就是通过装饰器：@property&lt;/p&gt;
&lt;p&gt;通过给getScore,setScore,delScore三个方法分别添加三个装饰器，就可以直接把这三个方法作为属性去调用了！&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @getScore.setter
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @getScore.deleter
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tim=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tim.setScore=90
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;tim.getScore
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常神奇！方法居然变成了属性，为什么呢？&lt;/p&gt;
&lt;p&gt;因为装饰器@property本质上是一个property()函数，property()函数也是一个装饰器。&lt;/p&gt;
&lt;p&gt;一般的装饰器是用在普通函数上，而@property是用在类内的方法上。&lt;/p&gt;
&lt;p&gt;property()函数包含了三个部分：getter,setter,deleter。&lt;/p&gt;
&lt;p&gt;因为setter和deleter是property()的第二和第三个参数，不能直接套用@语法。&lt;/p&gt;
&lt;p&gt;因此，本质上@property相当于getter部分，@setScore.setter相当于setter部分,@delScore.deleter相当于deleter部分。&lt;/p&gt;
&lt;p&gt;所以，上面的代码本质上等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     score=property(getScore,setScore,delScore,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，为了函数名美观，可以把函数名字改成Score():&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Score(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Score.setter
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Score(self,score):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Score.deleter
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; tim=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; tim.Score=90
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;tim.Score
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 几篇个人觉得写的比较清楚的文章：&lt;/p&gt;
&lt;p&gt;http://www.runoob.com/python/python-func-property.html&lt;/p&gt;
&lt;p&gt;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186781871161bc8d6497004764b398401a401d4cce000&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/cicaday/p/python-decorator.html&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:37:00 +0000</pubDate>
<dc:creator>szjshuffle</dc:creator>
<og:description>要了解@property的用途，首先要了解如何创建一个属性。 一般而言，属性都通过__init__方法创建，比如： 创建实例，运行结果： 但是这样子有2个坏处： 1.__init__ 中定义的属性是可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szjshuffle/p/10363463.html</dc:identifier>
</item>
<item>
<title>DirectX11--深入理解与使用缓冲区资源 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10359345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10359345.html</guid>
<description>&lt;p&gt;在Direct3D 11中，缓冲区属于其中一种资源类型，它在内存上的布局是一维线性的。根据HLSL支持的类型以及C++的使用情况，缓冲区可以分为下面这些类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶点缓冲区(Vertex Buffer)&lt;/li&gt;
&lt;li&gt;索引缓冲区(Index Buffer)&lt;/li&gt;
&lt;li&gt;常量缓冲区(Constant Buffer)&lt;/li&gt;
&lt;li&gt;有类型的缓冲区(Typed Buffer)&lt;/li&gt;
&lt;li&gt;结构化缓冲区(Structured Buffer)&lt;/li&gt;
&lt;li&gt;追加/消耗缓冲区(Append/Consume Buffer)&lt;/li&gt;
&lt;li&gt;字节地址缓冲区(Byte Address Buffer)(未完工)&lt;/li&gt;
&lt;li&gt;间接参数缓冲区(Indirect Argument Buffer)(未完工)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此这一章主要讲述上面这些资源的创建和使用方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;顾名思义，顶点缓冲区存放的是一连串的顶点数据，尽管缓冲区的数据实际上还是一堆二进制流，但在传递给输入装配阶段的时候，就会根据顶点输入布局将其装配成HLSL的顶点结构体数据。顶点缓冲区的数据可以用自定义的顶点结构体数组来初始化。顶点可以包含的成员有：顶点坐标(必须有)，顶点颜色，顶点法向量，纹理坐标，顶点切线向量等等。每个顶点的成员必须匹配合适的DXGI数据格式。&lt;/p&gt;
&lt;p&gt;当然，纯粹的顶点数组只是针对单个物体而言的。如果需要绘制大量相同的物体，需要同时用到多个顶点缓冲区。这允许你将顶点数据分开成多个顶点缓冲区来存放。&lt;/p&gt;
&lt;p&gt;这里还提供了顶点缓冲区的另一种形式：&lt;strong&gt;实例缓冲区&lt;/strong&gt;。我们可以提供一到多个的顶点缓冲区，然后再提供一个实例缓冲区。其中实例缓冲区存放的可以是物体的世界矩阵、世界矩阵的逆转置、材质等。这样做可以减少大量重复数据的产生，以及减少大量的CPU绘制调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215032093-2131246589.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createvertexbuffer函数--创建顶点缓冲区&quot;&gt;CreateVertexBuffer函数--创建顶点缓冲区&lt;/h2&gt;
&lt;p&gt;顶点缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶点数据是否需要动态更新&lt;/li&gt;
&lt;li&gt;是否需要绑定到流输出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果顶点缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果顶点缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果顶点缓冲区需要绑定到流输出，则说明顶点缓冲区需要允许GPU写入，可以使用&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;，并且需要提供绑定标签&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下图说明了顶点缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215043698-1412046354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顶点缓冲区不需要创建资源视图，它可以直接绑定到输入装配阶段或流输出阶段。&lt;/p&gt;
&lt;p&gt;创建顶点缓冲区和一般的创建缓冲区函数如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateBuffer函数
// ------------------------------
// 创建缓冲区
// [In]d3dDevice            D3D设备
// [In]data                 初始化结构化数据
// [In]byteWidth            缓冲区字节数
// [Out]structuredBuffer    输出的结构化缓冲区
// [In]usage                资源用途
// [In]bindFlags            资源绑定标签
// [In]cpuAccessFlags       资源CPU访问权限标签
// [In]structuredByteStride 每个结构体的字节数
// [In]miscFlags            资源杂项标签
HRESULT CreateBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** buffer,
    D3D11_USAGE usage,
    UINT bindFlags,
    UINT cpuAccessFlags,
    UINT structureByteStride,
    UINT miscFlags)
{
    D3D11_BUFFER_DESC bufferDesc;
    bufferDesc.Usage = usage;
    bufferDesc.ByteWidth = byteWidth;
    bufferDesc.BindFlags = bindFlags;
    bufferDesc.CPUAccessFlags = cpuAccessFlags;
    bufferDesc.StructureByteStride = structureByteStride;
    bufferDesc.MiscFlags = miscFlags;

    D3D11_SUBRESOURCE_DATA initData;
    ZeroMemory(&amp;amp;initData, sizeof(initData));
    initData.pSysMem = data;

    return d3dDevice-&amp;gt;CreateBuffer(&amp;amp;bufferDesc, &amp;amp;initData, buffer);
}


// ------------------------------
// CreateVertexBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]vertexBuffer        输出的顶点缓冲区
// [InOpt]dynamic           是否需要CPU经常更新
// [InOpt]streamOutput      是否还用于流输出阶段(不能与dynamic同时设为true)
HRESULT CreateVertexBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** vertexBuffer,
    bool dynamic,
    bool streamOutput)
{
    UINT bindFlags = D3D11_BIND_VERTEX_BUFFER;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (dynamic &amp;amp;&amp;amp; streamOutput)
    {
        return E_INVALIDARG;
    }
    else if (!dynamic &amp;amp;&amp;amp; !streamOutput)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (dynamic)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        bindFlags |= D3D11_BIND_STREAM_OUTPUT;
        usage = D3D11_USAGE_DEFAULT;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, vertexBuffer,
        usage, bindFlags, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;索引缓冲区通常需要与顶点缓冲区结合使用，它的作用就是以索引的形式来引用顶点缓冲区中的某一顶点，并按索引缓冲区的顺序和图元类型来组装图元。它可以有效地减少顶点缓冲区中重复的顶点数据，从而减小网格模型占用的数据大小。使用相同的索引值就可以多次引用同一个顶点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215108808-171970242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引缓冲区的使用不需要创建资源视图，它仅用于输入装配阶段，并且在装配的时候你需要指定每个索引所占的字节数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DXGI_FORMAT_R8_UINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0-255&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DXGI_FORMAT_R16_UINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0-65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DXGI_FORMAT_R32_UINT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0-2147483647&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将索引缓冲区绑定到输入装配阶段后，你就可以用带Indexed的Draw方法，指定起始索引偏移值和索引数目来进行绘制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215056328-435995086.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createindexbuffer函数--创建索引缓冲区&quot;&gt;CreateIndexBuffer函数--创建索引缓冲区&lt;/h2&gt;
&lt;p&gt;索引缓冲区的创建只考虑数据是否需要动态更新。&lt;/p&gt;
&lt;p&gt;如果索引缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果索引缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateIndexBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]indexBuffer         输出的索引缓冲区
// [InOpt]dynamic           是否需要CPU经常更新
HRESULT CreateIndexBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** indexBuffer,
    bool dynamic)
{
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (dynamic)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, indexBuffer,
        usage, D3D11_BIND_INDEX_BUFFER, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;常量缓冲区是我们接触到的第一个可以给所有可编程着色器程序使用的缓冲区。由于着色器函数的形参没法从C++端传入，我们只能通过类似全局变量的方式来让着色器函数访问，这些参数被打包在一个常量缓冲区中。而C++可以通过创建对应的常量缓冲区来绑定到HLSL对应的&lt;code&gt;cbuffer&lt;/code&gt;，以实现从C++到HLSL的数据的传递。C++的常量缓冲区是以字节流来对待；而HLSL的&lt;code&gt;cbuffer&lt;/code&gt;内部可以像结构体那样包含各种类型的参数，而且还需要注意它的打包规则。&lt;/p&gt;
&lt;p&gt;关于常量缓冲区，有太多值得需要注意的细节了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个着色器阶段最多允许15个常量缓冲区，并且每个缓冲区最多可以容纳4096个标量。HLSL的&lt;code&gt;cbuffer&lt;/code&gt;需要指定&lt;code&gt;register(b#)&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;的范围为0到14&lt;/li&gt;
&lt;li&gt;在C++创建常量缓冲区时大小必须为16字节的倍数，因为HLSL的常量缓冲区本身以及对它的读写操作需要严格按16字节对齐&lt;/li&gt;
&lt;li&gt;对常量缓冲区的成员使用&lt;code&gt;packoffset&lt;/code&gt;修饰符可以指定起始向量和分量位置&lt;/li&gt;
&lt;li&gt;在更新常量缓冲区时由于数据是提交完整的字节流数据到GPU，会导致HLSL中&lt;code&gt;cbuffer&lt;/code&gt;的所有成员都被更新。为了减少不必要的更新，可以根据这些参数的更新频率划分出多个常量缓冲区以节省带宽资源&lt;/li&gt;
&lt;li&gt;一个着色器在使用了多个常量缓冲区的情况下，这些常量缓冲区不能出现同名参数&lt;/li&gt;
&lt;li&gt;单个常量缓冲区可以同时绑定到不同的可编程着色器阶段，因为这些缓冲区都是只读的，不会导致内存访问冲突。一个包含常量缓冲区的&lt;code&gt;*.hlsli&lt;/code&gt;文件同时被多个着色器文件引用，只是说明这些着色器使用相同的常量缓冲区布局，如果该缓冲区需要在多个着色器阶段使用，你还需要在C++同时将相同的常量缓冲区绑定到各个着色器阶段上&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215144897-601823991.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个HLSL常量缓冲区的例子(注释部分可省略，效果等价)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;cbuffer CBChangesRarely : register(b2)
{
    matrix gView /* : packoffset(c0) */;
    float3 gSphereCenter /* : packoffset(c4.x) */;
    float gSphereRadius /* : packoffset(c4.w) */;
    float3 gEyePosW /* : packoffset(c5.x) */;
    float gPad /* : packoffset(c5.w) */;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;createconstantbuffer函数--创建常量缓冲区&quot;&gt;CreateConstantBuffer函数--创建常量缓冲区&lt;/h2&gt;
&lt;p&gt;常量缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否需要CPU经常更新&lt;/li&gt;
&lt;li&gt;是否需要GPU更新&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果常量缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果常量缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果常量缓冲区在较长的一段时间才需要更新一次，则可以考虑使用&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下图说明了常量缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215154372-1799058996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常量缓冲区的使用同样不需要创建资源视图。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateConstantBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数，必须是16的倍数
// [Out]indexBuffer         输出的索引缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许GPU更新
HRESULT CreateConstantBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** constantBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        return E_INVALIDARG;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, constantBuffer,
        usage, D3D11_BIND_CONSTANT_BUFFER, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这是一种创建和使用起来最简单的缓冲区，但实际使用频率远不如上面所讲的三种缓冲区。它的数据可以在HLSL被解释成基本HLSL类型的数组形式。&lt;/p&gt;
&lt;p&gt;在HLSL中，如果是只读的缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Buffer&amp;lt;float4&amp;gt; gBuffer : register(t0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要留意的是，当前缓冲区和纹理需要共用纹理寄存器，即t#，因此要注意和纹理避开使用同一个寄存器槽。&lt;/p&gt;
&lt;p&gt;如果是可读写的缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;RWBuffer&amp;lt;float4&amp;gt; gRWBuffer : register(u0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有类型的缓冲区具有下面的方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void GetDimensions(out uint)&lt;/td&gt;
&lt;td&gt;获取资源各个维度下的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Load(in int)&lt;/td&gt;
&lt;td&gt;按一维索引读取缓冲区数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Operator&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Buffer&lt;/code&gt;仅允许读取，&lt;code&gt;RWBuffer&lt;/code&gt;允许读写&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有类型的缓冲区需要创建着色器资源视图以绑定到对应的着色器阶段。由于HLSL的语法知识定义了有限的类型和元素数目，但在&lt;code&gt;DXGI_FORMAT&lt;/code&gt;中，有许多种成员都能够用于匹配一种HLSL类型。比如，HLSL的&lt;code&gt;float4&lt;/code&gt;你可以使用&lt;code&gt;DXGI_FORMAT_R32G32B32A32_FLOAT&lt;/code&gt;, &lt;code&gt;DXGI_FORMAT_R16G16B16A16_FLOAT&lt;/code&gt;或&lt;code&gt;DXGI_FORMAT_R8G8B8A8_UNORM&lt;/code&gt;。而HLSL的&lt;code&gt;int2&lt;/code&gt;你可以使用&lt;code&gt;DXGI_FORMAT_R32G32_SINT&lt;/code&gt;，&lt;code&gt;DXGI_FORMAT_R16G16_SINT&lt;/code&gt;或&lt;code&gt;DXGI_FORMAT_R8G8_SINT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215228991-1520906562.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createtypedbuffer函数--创建有类型的缓冲区&quot;&gt;CreateTypedBuffer函数--创建有类型的缓冲区&lt;/h2&gt;
&lt;p&gt;有类型的缓冲区通常需要绑定到着色器上作为资源使用，因此需要将&lt;code&gt;bindFlags&lt;/code&gt;设为&lt;code&gt;D3D11_BIND_SHADER_RESOURCE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，有类型的缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否允许CPU写入/读取&lt;/li&gt;
&lt;li&gt;是否允许GPU写入&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果缓冲区需要允许GPU写入，说明后面可能需要创建UAV绑定到&lt;code&gt;RWBuffer&amp;lt;T&amp;gt;&lt;/code&gt;，为此还需要给&lt;code&gt;bindFlags&lt;/code&gt;添加&lt;code&gt;D3D11_BIND_UNORDERED_ACCESS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果缓冲区的数据需要读出到内存，则可以使用&lt;code&gt;D3D11_USAGE_STAGING&lt;/code&gt;，并允许CPU读取(&lt;code&gt;D3D11_CPU_ACCESS_READ&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下图说明了有类型的(与结构化)缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215247062-280596029.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateTypedBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]typedBuffer         输出的有类型的缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许使用RWBuffer
HRESULT CreateTypedBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** typedBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        bindFlags = 0;
        usage = D3D11_USAGE_STAGING;
        cpuAccessFlags |= D3D11_CPU_ACCESS_READ;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
        bindFlags |= D3D11_BIND_UNORDERED_ACCESS;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, typedBuffer,
        usage, bindFlags, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于追加/消耗缓冲区，我们后面再讨论。&lt;/p&gt;
&lt;p&gt;如果我们希望它作为&lt;code&gt;Buffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建着色器资源视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
srvDesc.Buffer.FirstElement = 0;            // 起始元素的索引
srvDesc.Buffer.NumElements = numElements;   // 元素数目

HR(md3dDevice-&amp;gt;CreateShaderResourceView(mBuffer.Get(), &amp;amp;srvDesc, mBufferSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果我们希望它作为&lt;code&gt;RWBuffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建无序访问视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = 0;
uavDesc.Buffer.NumElements = numElements;   // 元素数目

md3dDevice-&amp;gt;CreateUnorderedAccessView(mBuffer.Get(), &amp;amp;uavDesc, mBufferUAV.GetAddressOf());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将缓冲区保存的结果拷贝到内存&quot;&gt;将缓冲区保存的结果拷贝到内存&lt;/h2&gt;
&lt;p&gt;由于这些缓冲区仅支持GPU读取，我们需要另外新建一个缓冲区以允许它CPU读取和GPU写入(STAGING)，然后将保存结果的缓冲区拷贝到该缓冲区，再映射出内存即可：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HR(CreateTypedBuffer(md3dDevice.Get(), nullptr, sizeof data,
    mBufferOutputCopy.GetAddressOf(), true, true));

md3dImmediateContext-&amp;gt;CopyResource(mVertexOutputCopy.Get(), mVertexOutput.Get());
D3D11_MAPPED_SUBRESOURCE mappedData;
HR(md3dImmediateContext-&amp;gt;Map(mVertexOutputCopy.Get(), 0, D3D11_MAP_READ, 0, &amp;amp;mappedData));
memcpy_s(data, sizeof data, mappedData.pData, sizeof data);
md3dImmediateContext-&amp;gt;Unmap(mVertexOutputCopy.Get(), 0);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;结构化缓冲区可以说是缓冲区的复合形式，它允许模板类型&lt;code&gt;T&lt;/code&gt;是用户自定义的类型，即缓冲区存放的内容可以被解释为结构体数组。&lt;/p&gt;
&lt;p&gt;现在HLSL有如下结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct Data
{
    float3 v1;
    float2 v2;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是只读的结构化缓冲区，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;StructuredBuffer&amp;lt;Data&amp;gt; gStructuredBuffer : register(t0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是可读写的结构化缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;RWStructuredBuffer&amp;lt;Data&amp;gt; gRWStructuredBuffer : register(u0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构化缓冲区也具有下面的方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void GetDimensions(out uint)&lt;/td&gt;
&lt;td&gt;获取资源各个维度下的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Load(in int)&lt;/td&gt;
&lt;td&gt;按一维索引读取结构化缓冲区数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Operator&lt;/td&gt;
&lt;td&gt;&lt;code&gt;StructuredBuffer&lt;/code&gt;仅允许读取，&lt;code&gt;RWStructuredBuffer&lt;/code&gt;允许读写&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215255507-154448541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createstructuredbuffer函数--创建结构化缓冲区&quot;&gt;CreateStructuredBuffer函数--创建结构化缓冲区&lt;/h2&gt;
&lt;p&gt;结构化缓冲区的创建和有类型的缓冲区创建比较相似，区别在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要在&lt;code&gt;MiscFlags&lt;/code&gt;指定&lt;code&gt;D3D11_RESOURCE_MISC_BUFFER_STRUCTURED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要额外提供&lt;code&gt;structureByteStride&lt;/code&gt;说明结构体的大小&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateStructuredBuffer函数
// ------------------------------
// 如果需要创建Append/Consume Buffer，需指定cpuUpdates为false, gpuUpdates为true
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [In]structuredByteStride 每个结构体的字节数
// [Out]structuredBuffer    输出的结构化缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许使用RWStructuredBuffer
HRESULT CreateStructuredBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    UINT structuredByteStride,
    ID3D11Buffer ** structuredBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        bindFlags = 0;
        usage = D3D11_USAGE_STAGING;
        cpuAccessFlags |= D3D11_CPU_ACCESS_READ;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
        bindFlags |= D3D11_BIND_UNORDERED_ACCESS;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, structuredBuffer,
        usage, bindFlags, cpuAccessFlags, structuredByteStride, 
        D3D11_RESOURCE_MISC_BUFFER_STRUCTURED);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是SRV还是UAV，在指定&lt;code&gt;Format&lt;/code&gt;时只能指定&lt;code&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们希望它作为&lt;code&gt;StructuredBuffer&amp;lt;Data&amp;gt;&lt;/code&gt;使用，则需要创建着色器资源视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_UNKNOWN;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
srvDesc.Buffer.FirstElement = 0;            // 起始元素的索引
srvDesc.Buffer.NumElements = numElements;   // 元素数目

HR(md3dDevice-&amp;gt;CreateShaderResourceView(mBuffer.Get(), &amp;amp;srvDesc, mBufferSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果我们希望它作为&lt;code&gt;RWStructuredBuffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建无序访问视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_UNKNOWN;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = 0;
uavDesc.Buffer.NumElements = numElements;   // 元素数目

md3dDevice-&amp;gt;CreateUnorderedAccessView(mBuffer.Get(), &amp;amp;uavDesc, mBufferUAV.GetAddressOf());&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;追加缓冲区和消耗缓冲区类型实际上是结构化缓冲区的特殊变体资源。因为涉及到修改操作，它们都只能以无序访问视图的方式来使用。如果你只是希望这些结构体数据经过着色器变换并且不需要考虑最终的输出顺序要一致，那么使用这两个缓冲区是一种不错的选择。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ConsumeStructuredBuffer&amp;lt;float3&amp;gt; gVertexIn : register(u0);
AppendStructuredBuffer&amp;lt;float3&amp;gt; gVertexOut : register(u1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HLSL中，&lt;code&gt;AppendStructuredBuffer&lt;/code&gt;仅提供了&lt;code&gt;Append&lt;/code&gt;方法用于尾端追加成员；而&lt;code&gt;ConsumeStructuredBuffer&lt;/code&gt;则仅提供了&lt;code&gt;Consume&lt;/code&gt;方法用于消耗尾端成员。这两种操作实际上可以看做是对栈的操作。此外，你也可以使用&lt;code&gt;GetDimensions&lt;/code&gt;方法来获取当前缓冲区还剩下多少元素。&lt;/p&gt;
&lt;p&gt;一旦某个线程消耗了一个数据元素，就不能再被另一个线程给消耗掉，并且一个线程将只消耗一个数据。需要注意的是，因为线程之间的执行顺序是不确定的，因此无法根据线程ID来确定当前消耗的是哪个索引的资源。&lt;/p&gt;
&lt;p&gt;此外，追加/消耗缓冲区实际上并不能动态增长，你必须在创建缓冲区的时候就要分配好足够大的空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215309027-307056265.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;追加消耗缓冲区的创建&quot;&gt;追加/消耗缓冲区的创建&lt;/h2&gt;
&lt;p&gt;追加/消耗缓冲区可以经由&lt;code&gt;CreateStructuredBuffer&lt;/code&gt;函数来创建，需要指定&lt;code&gt;cpuUpdates&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;gpuUpdates&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;比较关键的是UAV的创建，需要像结构化缓冲区一样指定&lt;code&gt;Format&lt;/code&gt;为&lt;code&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;。并且无论是追加缓冲区，还是消耗缓冲区，都需要在&lt;code&gt;Buffer.Flags&lt;/code&gt;中指定&lt;code&gt;D3D11_BUFFER_UAV_FLAG_APPEND&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_UNKNOWN;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_APPEND;
uavDesc.Buffer.NumElements = numElements;   // 元素数目
HR(md3dDevice-&amp;gt;CreateUnorderedAccessView(mVertexInput.Get(), &amp;amp;uavDesc, mVertexInputUAV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在将UAV绑定到着色器时，如果是追加缓冲区，通常需要指定初始元素数目为0，然后提供给&lt;code&gt;ID3D11DeviceContext::*SSetUnorderedAccessViews&lt;/code&gt;方法的最后一个参数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT initCounts[1] = { 0 };
md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mVertexInputUAV.GetAddressOf(), initCounts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果是消耗缓冲区，则需要指定初始元素数目：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT initCounts[1] = { numElements };
md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(1, 1, mVertexInputUAV.GetAddressOf(), initCounts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(未完待续)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:17:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 在Direct3D 11中，缓冲区属于其中一种资源类型，它在内存上的布局是一维线性的。根据HLSL支持的类型以及C++的使用情况，缓冲区可以分为下面这些类型： 1. 顶点缓冲区(Vertex B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10359345.html</dc:identifier>
</item>
<item>
<title>自定义npm包的创建、发布、更新和撤销 - 前端路上的小兵</title>
<link>http://www.cnblogs.com/shcrk/p/10363369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shcrk/p/10363369.html</guid>
<description>&lt;h3&gt;大纲&lt;/h3&gt;
&lt;p&gt;1、准备&lt;br/&gt;2、自定义npm包&lt;br/&gt;3、发布自定义npm包&lt;br/&gt;4、引用npm包&lt;br/&gt;5、更新npm包&lt;br/&gt;6、撤销发布的npm包&lt;/p&gt;
&lt;h3&gt;简书原文&lt;/h3&gt;
&lt;p&gt;https://www.jianshu.com/p/d737bc5df5b7&lt;/p&gt;
&lt;h3&gt;1、准备&lt;/h3&gt;
&lt;h4&gt;1.1、注册npm用户&lt;/h4&gt;
&lt;p&gt;npm官网(https://www.npmjs.com/)&lt;/p&gt;
&lt;h4&gt;1.2、安装nodeJs&lt;/h4&gt;
&lt;p&gt;Node.js官网(http://nodejs.cn/)&lt;/p&gt;
&lt;h4&gt;1.3、编辑器&lt;/h4&gt;
&lt;p&gt;我使用的是编辑器vscode进行操作的，读者也可以打开控制台进入到对应目录中进行操作&lt;/p&gt;
&lt;h3&gt;2、创建自己的npm包&lt;/h3&gt;
&lt;h4&gt;2.1、创建一个空的文件夹,进入&lt;/h4&gt;
&lt;h4&gt;2.2、创建一个默认的npm包&lt;/h4&gt;
&lt;p&gt;在当前文件夹中执行控制台命令：&lt;/p&gt;

&lt;p&gt;1、执行npm init之后需要一步一步的填写对应信息，这些信息也就是你的npm的信息,在生成的package.json中会自动填入(如下图)&lt;br/&gt;2、可以执行npm init -y, 这样就会帮你创建一个默认配置的package.json而不需要自己一步步配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//默认配置的package.json如下所示：
{
  &quot;name&quot;: &quot;npm-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215052925-1193238314.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.3、创建一个index.js文件作为包入口文件&lt;/h4&gt;
&lt;p&gt; 当然这是默认的入口文件,如果有其他想法的话，完全可以在package.json中进行修改。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215125180-123945023.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.4、index.js&lt;/h4&gt;
&lt;p&gt; index.js就是你这个包的入口文件,你可以在里面做你想要的操作&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215201844-1217736904.png&quot; alt=&quot;&quot; width=&quot;847&quot; height=&quot;449&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.5、node index.js&lt;/h4&gt;
&lt;p&gt; 最简单的内容就是打印一个日志,这时候你可以通过执行node index.js来执行index.js中的内容,可以看到控制台中打印出了你想要的信息&lt;/p&gt;
&lt;h4&gt; 2.6、改进index.js&lt;/h4&gt;
&lt;p&gt; 当然我们不可能就为了打印一个日志而创建一个npm包，我们需要可以引入这个npm包并调用这个包中的一些方法,因此我们队这个npm包中的index.js中的内容进行完善一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
exports.testDemo = function() {
  console.log(&quot;this is test demo!!!!!!&quot;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、发布npm包&lt;/h3&gt;
&lt;h4&gt;3.1、登录npm(添加用户)&lt;/h4&gt;
&lt;p&gt; 添加npm用户,或者说登录你的npm账号&lt;br/&gt;执行： npm adduser&lt;br/&gt;然后会提示你输入你的用户名和密码以及邮箱,如果输入正确会提示你成功登录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215326019-2138488470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2、npm publish&lt;/h4&gt;
&lt;p&gt;当你成功登录之后,就可以发布你的npm包了。&lt;br/&gt;执行： npm publish&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215353650-802627702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.3、注意：&lt;/h4&gt;
&lt;p&gt; 可能你在publish的时候会出现如下错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211220643633-86176425.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么可能性有两个：&lt;br/&gt;1、你没有执行npm adduser进行登录&lt;br/&gt;2、可能你的包名重复了。&lt;br/&gt;如这里的npm-demo可能重复了所以导致无法publish上,这时最简单的方法是改包名,加上一个特殊的标志即可,改包名只需要对package.json中的name进行修改即可。(此处我将npm-demo改成npm-demo-crk之后再次执行npm publish就成功了)&lt;/p&gt;
&lt;h3&gt; 4、引用npm包&lt;/h3&gt;
&lt;h4&gt; 4.1、创建一个案例&lt;/h4&gt;
&lt;p&gt;想要引用npm包首先你要有个基本的案例,创建这个案例的方法和创建npm包其实是差不多的:&lt;br/&gt;执行：npm init -y&lt;br/&gt;创建一个index.js的入口文件&lt;br/&gt;这样就创建了一个案例了.&lt;/p&gt;
&lt;h4&gt; 4.2、下载依赖包&lt;/h4&gt;
&lt;p&gt;创建完案例之后就是引入npm包了&lt;br/&gt;执行：npm install -save-dev crk-demo-crk&lt;br/&gt;(或者： npm install crk-demo-crk)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211220827536-782765104.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4.3、调用npm包中的文件&lt;/h4&gt;
&lt;p&gt; 通过require来调用文件从而引用npm包中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var test = require(&quot;npm-demo-crk&quot;);
test.testDemo();
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.4、运行&lt;/h4&gt;
&lt;p&gt; 执行命令即可运行案例,可以看到控制台成功调用了方法打印出了日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
node index.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221014445-1683869888.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、更新npm包&lt;/h3&gt;
&lt;h4&gt;5.1、更改版本号&lt;/h4&gt;
&lt;p&gt;最简单方式无非就是改package.json关于版本&lt;br/&gt;或者可以执行命令： npm version 1.0.1 同样可以起到作用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221049217-1384828274.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.2、更新版本——发布版本&lt;/h4&gt;
&lt;p&gt;更新npm包同样是执行npm publish即可，&lt;br/&gt;可以看到publish的包已经更新了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221118249-683811819.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.3、更新依赖包&lt;/h4&gt;
&lt;p&gt;同样是执行： npm install -save-dev crk-demo-crk&lt;br/&gt;这样会更新最新的包到node_module中&lt;br/&gt;当然可能由于各种原因导致你更新的包还没有在npm上更新或者说你更新下来的依旧是旧的包。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221146545-172039561.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、撤销发布的npm包&lt;/h3&gt;
&lt;p&gt;我们现在发布的这个npm包只是测试用的或者只是用作其他作用而不是要发布到网上真的使用的，最好还是撤销下来。&lt;br/&gt;执行命令： npm --force unpublish npm-demo-crk&lt;br/&gt;需要注意的是：&lt;br/&gt;1、撤销npm包需要加上 --force强制执行才可以实现;&lt;br/&gt;2、撤销的包不能立马再次发布&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221220741-129789008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;撤销的包不能立马再次发布&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221228106-2067920713.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;参考网址&lt;/h4&gt;
&lt;p&gt;https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages&lt;br/&gt;https://www.jianshu.com/p/9a9ed7eaf655&lt;br/&gt;https://www.cnblogs.com/marymei0107/p/6339710.html&lt;/p&gt;

</description>
<pubDate>Mon, 11 Feb 2019 14:15:00 +0000</pubDate>
<dc:creator>前端路上的小兵</dc:creator>
<og:description>大纲 1、准备2、自定义npm包3、发布自定义npm包4、引用npm包5、更新npm包6、撤销发布的npm包 简书原文 https://www.jianshu.com/p/d737bc5df5b7 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shcrk/p/10363369.html</dc:identifier>
</item>
<item>
<title>#20   Python文件 - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10363370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10363370.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前面几节枯燥的模块终于结束了，想要完全掌握前几节的模块需要不断的练习才行，毕竟眼过千遍不如手过一遍嘛。在一些项目需求里，要对文件进行IO操作，毕竟重要数据不可能打印到屏幕上而不去保存，Python对的文件IO操作并不是很复杂，相信你很快就能掌握它！&lt;/p&gt;
&lt;h3&gt;文件IO操作&lt;/h3&gt;
&lt;p&gt;对于一个文件的操作，无非不过创建、删除、读、写，创建和删除在OS模块里面已经说过，那只剩下读和写了，也就是IO（Input，Output）操作了。&lt;/p&gt;
&lt;p&gt;接下来，将以徐志摩的《再别康桥》为例子，深入解读Python中文件IO操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;轻轻的我走了，
正如我轻轻的来；
我轻轻的招手，
作别西天的云彩。
&lt;/span&gt;----&lt;span&gt;
那河畔的金柳，
是夕阳中的新娘；
波光里的艳影，
在我的心头荡漾。
&lt;/span&gt;----&lt;span&gt;
软泥上的青荇，
油油的在水底招摇；
在康河的柔波里，
我甘心做一条水草！
&lt;/span&gt;----&lt;span&gt;
那榆荫下的一潭，
不是清泉，是天上虹；
揉碎在浮藻间，
沉淀着彩虹似的梦。
&lt;/span&gt;----&lt;span&gt;
寻梦？撑一支长篙，
向青草更青处漫溯⑷；
满载一船星辉，
在星辉斑斓里放歌。
&lt;/span&gt;----&lt;span&gt;
但我不能放歌，
悄悄是别离的笙箫；
夏虫也为我沉默，
沉默是今晚的康桥！
&lt;/span&gt;----&lt;span&gt;
悄悄的我走了，
正如我悄悄的来；
我挥一挥衣袖，
不带走一片云彩。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1. 打开文件&lt;/h4&gt;
&lt;p&gt;Python获得文件句柄的方式与c及其类似，使用内置函数open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 「file表示文件名、mode表示打开方式（默认为读）、buffering表示寄存区缓冲大小（负值为系统默认，0为没有寄存区缓存，1为文件会寄存行，大于1的整数为寄存区缓存大小）、encoding表示文件编码、newline表示换行符（默认为\n）」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以默认读的方式打开再别康桥，注意：文件路径（此时程序和再别康桥在同一路径）&lt;/span&gt;
f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以写的方式打开文件，注意：如果此文件不存在，则创建这个文件；如果存在，则删除原文件所有内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于不同的文件，有不同的处理方式，常用的mode参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模式                                                描述
 r                                                  读
 w                                                  写
 r&lt;/span&gt;+&lt;span&gt;                                                读写
 w&lt;/span&gt;+&lt;span&gt;                                                写读
 a                                                 追加
 a&lt;/span&gt;+&lt;span&gt;                                               追加读
 rb                                              二进制读
 wb                                              二进制写
 rb&lt;/span&gt;+&lt;span&gt;                                            二进制读写
 wb&lt;/span&gt;+&lt;span&gt;                                            二进制写读
 ab                                             二进制追加
 ab&lt;/span&gt;+                                           二进制追加读
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些模式看似复杂，其实内部规律很清晰，接下来将用文件的读和写来充分了解这些模式&lt;/p&gt;
&lt;h4&gt;2. 文件的读&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;read()&lt;/strong&gt; 「读取文件指针之后的所有内容，并返回字符串」&lt;/p&gt;
&lt;p&gt;这里提到了一个新概念：文件指针，想象一下，你在读书，你的手指头指着你正在读的地方，你没读一个字，你的手指头就跟着向后动一下，你的手指头就是文件指针，以上模式中，除了a、a+、ab+文件指针在文件末尾之外，其他的都是在文件开头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [2]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认读的方式打开文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;3]: f.read()                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件指针之后的所有内容&lt;/span&gt;
Out[3]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;轻轻的我走了，\n正如我轻轻的来；\n我轻轻的招手，\n作别西天的云彩。\n----\n那河畔的金柳，\n是夕阳中的新娘；\n波光里的艳影，\n在我的心头荡漾。\n----\n软泥上的青荇，\n油油的在水底招摇；\n在康河的柔波里，\n我甘心做一条水草！\n----\n那榆荫下的一潭，\n不是清泉，是天上虹；\n揉碎在浮藻间，\n沉淀着彩虹似的梦。\n----\n寻梦？撑一支长篙，\n向青草更青处漫溯；\n满载一船星辉，\n在星辉斑斓里放歌。\n----\n但我不能放歌，\n悄悄是别离的笙箫；\n夏虫也为我沉默，\n沉默是今晚的康桥！\n----\n悄悄的我走了，\n正如我悄悄的来；\n我挥一挥衣袖，\n不带走一片云彩。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [9]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以写的模式打开文件，此时这个文件的内容已经被删除了😰&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;10]: f.read()                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到文件是不允许读的&lt;/span&gt;
---------------------------------------------------------------------------&lt;span&gt;
UnsupportedOperation                      Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-10-571e9fb02258&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1&lt;span&gt; f.read()

UnsupportedOperation: &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; readable
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [1]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以二进制方式打开文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;2&lt;span&gt;]: f.read()
Out[&lt;/span&gt;2]: b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xff\xdb\x00C\x00\x05\x04\x04\x05\x04\x03\x05\x05\x04\x05\x06\x06\...........&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有许多文件格式是以二进制保存的，最典型的就是图片和视频&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;readline()&lt;/strong&gt;  「读一行」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [1]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;2]: f.readline()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读一行&lt;/span&gt;
Out[2]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;轻轻的我走了，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;3]: f.readline()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再读一行&lt;/span&gt;
Out[3]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;正如我轻轻的来；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;4&lt;span&gt;]: f.readline()
Out[&lt;/span&gt;4]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我轻轻的招手，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;5&lt;span&gt;]: f.readline()
Out[&lt;/span&gt;5]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作别西天的云彩。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;readlines()&lt;/strong&gt;  「按行读取文件，将所有的行保存为一个列表」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
In [6]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;7&lt;span&gt;]: f.readlines()
Out[&lt;/span&gt;7&lt;span&gt;]:
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;轻轻的我走了，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;正如我轻轻的来；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我轻轻的招手，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作别西天的云彩。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;那河畔的金柳，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是夕阳中的新娘；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;波光里的艳影，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;在我的心头荡漾。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;软泥上的青荇，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;油油的在水底招摇；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;在康河的柔波里，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我甘心做一条水草！\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;那榆荫下的一潭，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;不是清泉，是天上虹；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;揉碎在浮藻间，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;沉淀着彩虹似的梦。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;寻梦？撑一支长篙，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;向青草更青处漫溯⑷；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;满载一船星辉，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;在星辉斑斓里放歌。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;但我不能放歌，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;悄悄是别离的笙箫；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;夏虫也为我沉默，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;沉默是今晚的康桥！\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;----\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;悄悄的我走了，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;正如我悄悄的来；\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我挥一挥衣袖，\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;不带走一片云彩。\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;文件迭代&lt;/strong&gt;  「open函数打开一个文件后，这个句柄本身是可迭代对象」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [8]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再别康桥.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;9]: &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; f:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接迭代文件&lt;/span&gt;
   ...:     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(line)
   ...:
轻轻的我走了，

正如我轻轻的来；

我轻轻的招手，

作别西天的云彩。

&lt;/span&gt;----&lt;span&gt;

那河畔的金柳，
（将后面的输出省略了）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 文件的写&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;write(text)&lt;/strong&gt;  「text表示要写入文件的内容，并返回写入的字符数」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [13]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以写的方式打开文件，如果文件不存在则创建，如果存在则删除原有内容&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;14]: f.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入hello&lt;/span&gt;
Out[14]: 5&lt;span&gt;

In [&lt;/span&gt;15]: f.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;word\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入word并换行&lt;/span&gt;
Out[15]: 5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：如果这时候去查看文件内容，发现里面还是空荡荡的，为什么呢？因为寄存区缓存的原因，默认是使用系统的寄存区缓存机制，想要立刻写入文件可以改变buffering的值，也可以使用close()方法关闭文件（关闭文件时所有内容都会写入文件）、再或者使用flush()方法立即将寄存区内容写入文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [23]: f.flush()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用flush()方法立即刷入&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;24]: ! cat new_file.txt   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用命令查看文件内容，文件内容有两行，一行字，一行空白（因为使用\n换行了），这个是Linux系统命令🤥&lt;/span&gt;
helloword&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [25]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以追加模式打开，如果文件存在则打开文件，如果不存在则新建文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;27]: f.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i am new\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[&lt;/span&gt;27]: 9&lt;span&gt;

In [&lt;/span&gt;28&lt;span&gt;]: f.flush()

In [&lt;/span&gt;30&lt;span&gt;]: ! cat new_file.txt
helloword
i am new&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [31]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;32]: f.read()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 追加方式是不允许读的，w、wb、ab也不允许读&lt;/span&gt;
---------------------------------------------------------------------------&lt;span&gt;
UnsupportedOperation                      Traceback (most recent call last)
&lt;/span&gt;&amp;lt;ipython-input-32-571e9fb02258&amp;gt; &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
----&amp;gt; 1&lt;span&gt; f.read()

UnsupportedOperation: &lt;/span&gt;&lt;span&gt;not&lt;/span&gt; readable
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [33]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用追加读的方式打开文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;34]: f.read()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以读，但为什么是空的？因为文件指针在末尾&lt;/span&gt;
Out[34]: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;36]: f.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;afd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以写&lt;/span&gt;
Out[36]: 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;writelines(lines)&lt;/strong&gt;  「将一个列表或元组序列写入文件，需要换行自己加」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
In [39]: f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_file.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

In [&lt;/span&gt;43]: f.writelines([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将列表序列写入文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;44]: f.writelines((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将元组序列写入文件&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;45]: f.flush()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 刷入&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;46]: ! cat new_file.txt   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看文件内容&lt;/span&gt;
helloworldhahahehe
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4. 关闭文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;close()&lt;/strong&gt;   「关闭文件，如果将寄存区有缓存则写入文件」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
In [48]: f.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5. 文件其他方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tell()&lt;/strong&gt;  「返回当前文件指针位置」&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;seek(offset, whence=0)&lt;/strong&gt; 「offset代表要设置的文件指针位置」&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt;  「返回当前文件名」&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:15:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录Python中文件的IO操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10363370.html</dc:identifier>
</item>
<item>
<title>Ocelot 资源汇总 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10363360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10363360.html</guid>
<description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;最近一两年.NET Core的关注度持续上升, 微服务及云原生应用开发上采用.NET Core也越来越多，Ocelot 作为.NET Core平台下一款开源的API 网关开发库越来越得到社区的认可，应用到生产中的案例也有好几百了。春节抽空整理了现有网上公开的Ocelot相关的资源，包括示例项目、扩展插件、博客文章、视频等, 供大家参考。&lt;/p&gt;
&lt;p&gt;我把整理好的资源放在github：&lt;a title=&quot;https://github.com/geffzhang/awesome-ocelot&quot; href=&quot;https://github.com/geffzhang/awesome-ocelot&quot;&gt;https://github.com/geffzhang/awesome-ocelot&lt;/a&gt;，欢迎大家一起来丰富这个资源，资源来自全世界，所以内容以世界语言英文方式组织。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;系列文章&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从系列文章中第一篇是Tom 当时所在的公司 的文章，你可以了解到Ocelot的诞生过程，这里面很多文章都是我们身边的同学写的，比如7篇文章虽是英文的，但是你知道他是NCC的项目&lt;a title=&quot;https://github.com/dotnetcore/EasyCaching&quot; href=&quot;https://github.com/dotnetcore/EasyCaching&quot;&gt;https://github.com/dotnetcore/EasyCaching&lt;/a&gt; 作者黄文清同学哦，后面的几篇中文的文章更是把Ocelot如何扩展写的很清楚了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前涉及到Ocelot的图书只有一本微软.NET团队写的《.NET 微服务：适用于容器化 .NET 应用程序的体系结构》引用的微服务应用程序 &lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot;&gt;eShopOnContainers&lt;/a&gt; 使用的是 &lt;a href=&quot;https://github.com/ThreeMammals/Ocelot&quot;&gt;Ocelot&lt;/a&gt;，这是一个简单的轻量级 API 网关，可与微服务/容器一起部署到任意位置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;会议演讲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然我在社区举办过多次活动介绍Ocelot， 录制有视频的是2017年我和徐玉涛在微软Summit 2017上的演讲，当时.NET Core 2.0 还是刚发布，我们当时线上跑的是1.1版本，其中也涉及到了定制Ocelot的内容都是上面的文章中有详细的文字阐述。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;社区项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ocelot 作为一款扩展性很强的开发库，社区中也涌现了很多非常有价值的项目，这些项目都是在生产环境应用过的，让有定制需求的同学少走很多弯路，这也体现了这个项目的活跃性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源贡献者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ocelot 现在一起参与贡献过代码的63位，我这里只列出了在项目中持续活跃的以及对项目有重要贡献，这个列表我还会持续更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相对于扩展组件，有很多同学在研究学习Ocelot，以及投入生产项目以示例的形式在github上开源，这些项目不仅仅是围绕Ocelot，同时围绕.NET Core的微服务的各个方面都会有涉及，也是大家打造微服务框架的一个参考项目，我这里节选了github上面的一部分项目，发现这些项目都是中文的，肯定都是我们身边的同学贡献的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视频&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有几个视频都需要借助梯子，老外做的几个视频很不错，最后一个视频是微软和我们一起拍摄的3分钟的宣传视频。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;欢迎大家 在这里提供你们使用Ocelot的信息 &lt;a href=&quot;https://github.com/geffzhang/awesome-ocelot/issues/1&quot;&gt;https://github.com/geffzhang/awesome-ocelot/issues/1&lt;/a&gt; ，据说所知目前Ocelot的用户案例是很多的，我创建了一个国内的Ocelot用户的微信群，当前只要列了两个大用户。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Ocelot项目的Star 增长图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201902/510-20190211221021348-1211554126.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;441&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201902/510-20190211221021864-1704508380.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;截至2019.2.11，Ocelot项目目前有Star 3076个，从上图可以看出从.NET Core 2.0发布以来，增长的曲线是一条笔直上升图，这也侧面反应了.NET Core的采用率也在直线上升。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:10:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>前言最近一两年.NET Core的关注度持续上升, 微服务及云原生应用开发上采用.NET Core也越来越多，Ocelot 作为.NET Core平台下一款开源的API 网关开发库越来越得到社区的认可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10363360.html</dc:identifier>
</item>
<item>
<title>Android通过DeepLink方式跳转其他App传递参数 - MoMask</title>
<link>http://www.cnblogs.com/lovelyYakir/p/10363007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovelyYakir/p/10363007.html</guid>
<description>&lt;p&gt;  网上对于安卓DeepLink方式跳转传递参数的例子较少，说的也不客观，实践之后发现还是有一些坑。其实为什么要用DeepLink方式跳转，有些是因为引流的原因，他们希望通过网页就能直接跳转到App的界面。还有其实就是某些业务的需要，需要统一跳转方式，方便维护代码。如果不知道DeepLink是什么，可以自行百度一下，下面介绍一下实际的用法：&lt;/p&gt;
&lt;p&gt;接收参数方：&lt;/p&gt;
&lt;p&gt;1.跳转的App需要在清单文件注册以下是例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
package=&quot;com.example.alex.deeplinkproject&quot;&amp;gt;

&amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&amp;lt;application
android:allowBackup=&quot;true&quot;
android:icon=&quot;@mipmap/ic_launcher&quot;
android:label=&quot;@string/app_name&quot;
android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
android:supportsRtl=&quot;true&quot;
android:theme=&quot;@style/AppTheme&quot;&amp;gt;
&amp;lt;activity android:name=&quot;.MainActivity&quot;&amp;gt;
&amp;lt;intent-filter&amp;gt;
&amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;

&amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
&amp;lt;/intent-filter&amp;gt;
&amp;lt;!--url跳转格式为：open://app.test.com/game--&amp;gt;
&amp;lt;intent-filter&amp;gt;
&amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt;
&amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt;
&amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;

&amp;lt;data
android:scheme=&quot;open&quot;
android:host=&quot;app.test.com&quot;
android:pathPrefix=&quot;/game&quot;
/&amp;gt;
&amp;lt;/intent-filter&amp;gt;

&amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;

&amp;lt;/manifest&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过三个字段生成一个URL：scheme：//host pathPrefix 如上：open://app.test.com/game&lt;/p&gt;
&lt;p&gt;2 需要接收的参数通过Uri获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
//通过Deeplink 跳转获取参数
String action =&lt;span&gt; getIntent().getAction();
if&lt;span&gt; (Intent.ACTION_VIEW.equals(action)) {
Uri data =&lt;span&gt; getIntent().getData();
if (data != null&lt;span&gt;) {
String appId = data.getQueryParameter(&quot;appId&quot;&lt;span&gt;);
String token = data.getQueryParameter(&quot;token&quot;&lt;span&gt;);
String extend = data.getQueryParameter(&quot;extend&quot;&lt;span&gt;);
String merchant = data.getQueryParameter(&quot;merchant&quot;&lt;span&gt;);
String agent = data.getQueryParameter(&quot;agent&quot;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发送参数方（以下代码比较简单使用Kotlin编写）：&lt;/p&gt;
&lt;p&gt;1.需要传递对应的参数而后拼接到Uri后面，以下是例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
class&lt;span&gt; MainActivity : AppCompatActivity() {

override fun onCreate(savedInstanceState: Bundle?&lt;span&gt;) {
super&lt;span&gt;.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
findViewById&amp;lt;Button&amp;gt;&lt;span&gt;(R.id.bt1).setOnClickListener {
val intent = Intent(Intent.ACTION_VIEW, Uri.parse(&quot;open://app.test.com/game?appId=com.game.sid21&amp;amp;token=21token&amp;amp;extend=21extend&amp;amp;merchant=21merchant&amp;amp;agent=21agent&quot;&lt;span&gt;))
intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
startActivity(intent)
}
}
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似GET请求已Key=Value的形式传递。注意，Uri.parse 中的参数不可用+号进行拼接会出现无法获取参数的情况。跳转到其他App采用开启新的栈方式，避免误认为是一个App。&lt;/p&gt;
&lt;p&gt;  以上就是一个完整的跳转流程代码，但是实际上，当被跳转的App已经启动的时候我们有时候会取不到数据，但是跳转是正常的跳转了。这边要注意我们使用的flag，当被启动的App已经启动，他会在onNewIntent()返回我们的正确的Intent而不是getIntent()了。你需要重写此方法获取最新的Intent。最好抽取一个方法出来，在onCreate()和onNewIntent()中都获取Intent()。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Override
    protected void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //通过Deeplink 跳转获取参数
&lt;span&gt;        getIntentData(getIntent());

    }

    @Override
    protected void&lt;span&gt; onNewIntent(Intent intent) {
        super&lt;span&gt;.onNewIntent(intent);
        getIntentData(intent);
    }
    
    private  void&lt;span&gt; getIntentData(Intent intent){
        String action =&lt;span&gt; intent.getAction();
        if&lt;span&gt; (Intent.ACTION_VIEW.equals(action)) {
            Uri data =&lt;span&gt; getIntent().getData();

            if (data != null&lt;span&gt;) {
                String appId = data.getQueryParameter(&quot;appId&quot;&lt;span&gt;);
                String token = data.getQueryParameter(&quot;token&quot;&lt;span&gt;);
                String extend = data.getQueryParameter(&quot;extend&quot;&lt;span&gt;);
                String merchant = data.getQueryParameter(&quot;merchant&quot;&lt;span&gt;);
                String agent = data.getQueryParameter(&quot;agent&quot;&lt;span&gt;);
            }
        }
        
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 11 Feb 2019 11:54:00 +0000</pubDate>
<dc:creator>MoMask</dc:creator>
<og:description>网上对于安卓DeepLink方式跳转传递参数的例子较少，说的也不客观，实践之后发现还是有一些坑。其实为什么要用DeepLink方式跳转，有些是因为引流的原因，他们希望通过网页就能直接跳转到App的界面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovelyYakir/p/10363007.html</dc:identifier>
</item>
</channel>
</rss>