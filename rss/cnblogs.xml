<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>不要再问我Java程序是怎么执行的了！ - 为何不是梦</title>
<link>http://www.cnblogs.com/ibigboy/p/11184133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ibigboy/p/11184133.html</guid>
<description>&lt;h2&gt;什么是Java虚拟机？&lt;/h2&gt;
&lt;p&gt;要弄明白Java程序的执行过程首先要了解一下Java虚拟机&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/p&gt;&lt;p&gt;Java虚拟机（Java Virtual Machine简称JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。--百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，Java虚拟机是在原有计算机的基础上虚拟出来的抽象计算机，提供Java程序的运行环境。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础，使Java程序能够做到 “Write Once, Run Anywhere”。&lt;/p&gt;
&lt;h2&gt;Java程序执行过程&lt;/h2&gt;
&lt;p&gt;那有了Java程序的运行环境等一些列支持后，Java程序是如何做到从一个只有代码的.java源文件变成计算机可执行的文件的呢？ 如下图，是Java程序的执行过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1205690/201907/1205690-20190714134902701-878145347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致过程就是，我们写好的.java文件（源文件）被编译器编译后变成.class文件（字节码），然后被JVM的类加载器加载到内存，通过字节码校验器去做一些校验，校验通过后交由解释器将字节码文件解释成计算机能够识别的机器指令。&lt;/p&gt;

&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;维基百科&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;字节码：&lt;/strong&gt;字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;Java字节码：&lt;/strong&gt;是Java虚拟机执行的一种指令格式。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;解释器：&lt;/strong&gt;是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过上图我们知道Java程序的执行会经过一下几个步骤：​编译--&amp;gt;装载字节码--&amp;gt;校验字节码--&amp;gt;解释字节码--&amp;gt;执行，然后我们看一下这几个步骤具体执行过程，以及Java程序的执行过程对应到我们的实际操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在windows环境中，打开命令窗口，切换到java文件的目录，使用 &lt;code&gt;javac &lt;/code&gt;命令，执行 &lt;code&gt;javac xxx.java &lt;/code&gt;把.java文件编译成.class文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、装载字节码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译好的.class文件交给 JVM 执行，即使用&lt;code&gt;java&lt;/code&gt;命令，执行&lt;code&gt;java xxx&lt;/code&gt;（.class文件的名称，不带后缀）。&lt;code&gt;java&lt;/code&gt;命令将会启动 JVM，并将后面的参数作为初始化类，通过 JVM 内的类加载器将字节码文件装载到内存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、校验字节码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类的加载是通过类加载器进行的，加载完后，先由字节码校验器负责检查那些无法执行的明显有破坏性的操作。除了系统类之外，其他类都要被校验。&lt;/p&gt;
&lt;p&gt;校验器执行的一些检查：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量要在使用前初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法调用与对象引用类型之间要匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问私有数据和方法的规则没有被违反&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对本地变量的访问都在运行的堆栈内&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行时堆栈没有溢出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果这些检查没有通过，类最终不会被加载完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、解释字节码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM 把每一条要执行的字节码交给解释器，翻译成对应的机器语言，最终由操作系统执行。&lt;/p&gt;
&lt;p&gt;JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;维基百科&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;机器语言：&lt;/strong&gt;机器语言（machine language）是一种指令集的体系。这种指令集称为机器代码（machine code），是计算机的CPU可直接解读的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;实际上JVM执行字节码文件远比这复杂，其中还包括即时编译器、指令重排等优化。这里只是对Java程序的执行过程做一个大致的介绍，让Java程序员能够明白自己写的程序在JVM里到底是如何执行的。如果要深入研究JVM的更多细节，建议大家去看书或其他资料。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jul 2019 00:44:00 +0000</pubDate>
<dc:creator>为何不是梦</dc:creator>
<og:description>什么是Java虚拟机？ 要弄明白Java程序的执行过程首先要了解一下Java虚拟机 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ibigboy/p/11184133.html</dc:identifier>
</item>
<item>
<title>JVM(八)：Java 对象模型 - iceWang丶</title>
<link>http://www.cnblogs.com/JRookie/p/11192748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JRookie/p/11192748.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文将学习对象是如何创建的，对象的内存布局，以及如何定位访问一个对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对象创建&quot;&gt;对象创建&lt;/h2&gt;
&lt;p&gt;当虚拟机碰到一个new指令时，首先检查指令参数能否在常量池中定位一个类的符号引用，并且检查该符号引用对应的类是否已经被加载，解析和初始化。当一切都确定完成后，JVM就会为其分配内存(需要分配的内存大小在现在就已经确定，在 &lt;strong&gt;下面&lt;/strong&gt; 中详细讲述)。&lt;/p&gt;
&lt;p&gt;对象的内存分配方式分为以下两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;指针碰撞&lt;/strong&gt;，这种分配方式建立在堆内已用空间和剩余空间是完整的，这样的话，在两者之间放置一个指针作为分界点的指示器即可，在分配空间时，只需要移到一下指针位置就好了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空闲列表&lt;/strong&gt;，如果 JVM 内的空间不是规整的，那么就只能采用此方案了。此时 JVM 会维护一个列表，记录了哪些内存块是可用的，在分配的时候划一个大小足够的区域给对象实例，并更新列表即可。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上两种方式采取哪种，取决于 Java 堆是否工整，而堆是否工整又取决于垃圾回收算法是否具有整理功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对象模型&quot;&gt;对象模型&lt;/h2&gt;
&lt;p&gt;前面说到对象在创建时就已经确定了内存大小，那么 JVM 是怎么确定对象的大小呢？对象在内存中又是如何存储的呢？&lt;/p&gt;
&lt;p&gt;在 JVM 中 Java 的对象模型分为以下3块，&lt;strong&gt;对象头&lt;/strong&gt;，&lt;strong&gt;实例数据&lt;/strong&gt;，&lt;strong&gt;对齐填充&lt;/strong&gt;，下面就让我们来分别介绍一下。&lt;/p&gt;
&lt;h3 id=&quot;对象头&quot;&gt;对象头&lt;/h3&gt;
&lt;p&gt;对象头的数据包括两部分。一部分是用于存储自身运行时数据，这部分数据被官方称为“Mark World”。其中存储数据包括&lt;strong&gt;Hashcode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对象头的另外一部分是 &lt;strong&gt;类型指针&lt;/strong&gt;，即对象指向其类元数据的指针。通过这个指针，我们就可以知道该实例属于哪个类。&lt;/p&gt;
&lt;h3 id=&quot;实例数据&quot;&gt;实例数据&lt;/h3&gt;
&lt;p&gt;实例数据就是对象真正存储的有效信息，也就是代码中定义的各种类型的字段内容，不论是父类的还是子类的，都需要记录下来。其存储顺序受到虚拟机分配策略和定义顺序影响。&lt;/p&gt;
&lt;h3 id=&quot;对齐填充&quot;&gt;对齐填充&lt;/h3&gt;
&lt;p&gt;对象填充不是必要数据。在模型中只是起到占位符的作用。因为 HotSpot 要求对象起始地址必须是8的整数倍，这样在实例数据达不到要求的时候，就需要通过对齐填充来补齐。&lt;/p&gt;
&lt;h2 id=&quot;对象访问&quot;&gt;对象访问&lt;/h2&gt;
&lt;p&gt;对象访问的方式是通过引用来定位、访问。但 JVM 规范并没有强制要求该通过何种方式使用引用，因此具体实现还是要依赖与具体虚拟机类型。&lt;/p&gt;
&lt;p&gt;不过目前的主流访问方式就是以下两种。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;使用引用&lt;/strong&gt;。其在 Java 堆中会独立创建一个句柄池，引用指向句柄，而句柄指向实例数据和类型数据。&lt;br/&gt;&lt;img src=&quot;https://markdown-1254037841.cos.ap-shanghai.myqcloud.com/JVM_image/reference_pool.jpg&quot; alt=&quot;使用句柄访问&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用这种方式来访问的优点是稳定，例如在 GC 后，实例数据需要移动，那么只需要修改句柄池中的内容即可，reference 指向的是稳定的位置，缺点是这种方式需要二次定位，速度较慢。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;直接指针访问&lt;/strong&gt;，引用直接堆中对象地址，堆中保存了实例数据和类型数据指针，指针直接指向另外存储的类型数据。&lt;br/&gt;&lt;img src=&quot;https://markdown-1254037841.cos.ap-shanghai.myqcloud.com/JVM_image/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png&quot; alt=&quot;通过直接指针访问对象&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用这种方式的优点是访问实例数据快，因为 reference 指向直接的对象，省去了一次内存定位开销。但缺点就是不够稳定，在对象移动后，reference 也需要修改值。&lt;/p&gt;
&lt;p&gt;具体采用何种，不同的虚拟机有不同的实现，因为两者各有千秋，并没有强烈的优缺点，因此不同情况不同处理即可。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在本文中介绍了对象的本质模型是什么，以及对象是如何创建和访问使用的，与上文的 JVM 内存模型结合来看，可以让我们了解内存泄露产生的原因，有助于高效地理解使用 Java 的自动内存管理机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://markdown-1254037841.cos.ap-shanghai.myqcloud.com/JVM_image/iceWang.jpg&quot; alt=&quot;iceWang公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章在公众号“iceWang”第一手更新，有兴趣的朋友可以关注公众号，第一时间看到笔者分享的各项知识点。谢谢！笔芯！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本系列文章主要借鉴自《深入分析 Java Web 技术内幕》和《深入理解 Java 虚拟机-JVM 高级特性与最佳实践》。&lt;br/&gt;​&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 16 Jul 2019 00:40:00 +0000</pubDate>
<dc:creator>iceWang丶</dc:creator>
<og:description>本文将学习对象是如何创建的，对象的内存布局，以及如何定位访问一个对象。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JRookie/p/11192748.html</dc:identifier>
</item>
<item>
<title>百亿级数据处理优化 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11186279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11186279.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近在做大数据处理时，遇到两个大表 join 导致数据处理太慢（甚至算不出来）的问题。我们的数仓基于阿里的 ODPS，它与 Hive 类似，所以这篇文章也适用于使用 Hive 优化。处理优化问题，一般是先指定一些常用的优化参数，但是当设置参数仍然不奏效的时候，我们就要结合具体的业务，在 SQL 上做优化了。为了不增加大家的阅读负担，我会简化这篇文章的业务描述&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这是一个离线数据处理的问题。在这个业务中有两张表，表结构及说明如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;user_article_tb 表：&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201907/1129006-20190715233528065-818089439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字段解释：&lt;/p&gt;
&lt;p&gt; uid: 用户标识，itemid：文章id，dur: 阅读文章时长，如果大于 0 代表阅读了文章，等于 0 代表没有点击文章 &lt;/p&gt;
&lt;p&gt; dt：天分区，每天 55 亿条记录&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;strong&gt;user_profile_tb 表：&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201907/1129006-20190715233648080-787262519.png&quot; alt=&quot;&quot;/&gt;&lt;pre&gt;
字段解释：&lt;br/&gt;uid：用户标识，gender：性别，F 代表女，M 代表男，age:年龄，city：城市&lt;br/&gt;dt：天分区字段，这是一张总表，每天存储全量用户画像属性，最新数据十亿级别
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需求是这样的：计算 7 天中，女性用户在每篇文章上的 ctr （最终会按照降序进行截断）。直接写 SQL 很容易，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; 
　　itemid
　　, &lt;/span&gt;&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;if&lt;/span&gt;(dur &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;)) &lt;span&gt;/&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) ctr
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;
　　(
    　　&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; uid, itemid, dur
    　　&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_article_tb
    　　&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; dt&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190701&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; dt&lt;span&gt;&amp;lt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190707&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
　　) data_tb
　　&lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;
　　(
　　　　&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
　　　　&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_profile_tb
　　　　&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; dt&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190707&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;最新的日期&lt;/span&gt;
   　　　　&lt;span&gt;and&lt;/span&gt; gender&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
　　) profile_tb
　　&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt; 
　　　　data_tb.uid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; profile_tb.uid
&lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; 
　　itemid
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; ctr &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;
limit &lt;/span&gt;&lt;span&gt;50000&lt;/span&gt;&lt;span&gt;
;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么问题来了：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于 user_article_tb 来说，7天的数据量将近 400 亿条记录，还需要 join 一张十亿级别的画像表。这个数据量基本上就跑不出来了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;像这种探索性质的需求，经常会变化。假设需求变成计算男性或者计算一二线城市用户的呢？可能又需要重跑整个数据，既要付出时间成本又要付出高昂的资源成本&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;解决&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们一一解决上面提到的两个问题。先考虑第一个，既然 join 的两张表太大了，我们能不能尝试把表变小呢。答案是肯定的，对于画像表来说显然是没办法缩小了，但是对于 user_artitle_tb 是可以的。我们可以按照表的分区字段 dt 用每天的数据分别 join 画像表，将结果再按天存储在一张临时表里面。这样每天就是十亿级别的数据 join，基本可以解决问题。但是每天的数据仍有多余的 join，比如：某天的数据中 uid = 00001 的用户，一天看了 1000 篇文章，那这个用户就需要多 join 999 次。在我们的业务中一个用户一天看文章的数量 &amp;gt; 10 是很普遍的，因此多余 join 的情况还是比较严重的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对上面提到的多余 join 的情况，最彻底的解决方法就是把 user_article_tb 表变成 uid 粒度的，跟画像表一样。我们将 7 天的数据转换成 uid 粒度的 SQL 如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; overwrite &lt;span&gt;table&lt;/span&gt; user_article_uid_tb &lt;span&gt;as&lt;/span&gt; 
&lt;span&gt;select&lt;/span&gt; uid, wm_concat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, concat_ws(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, itemid, dur)) item_infos
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; 
　　(
  　　　&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
　　　　&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_article_tb
  　　 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; dt &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190701&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; dt &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190707&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   
　　) tmp
&lt;/span&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; uid
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面 SQL 可以看到，我们首先将 7 天的数据按照 uid 做 group by 操作，构造 item_infos。因为我们的是计算 ctr，所以我们可以按照 uid 粒度对表做转换，并且 item_infos 字段包含什么是要根据业务需求做选择。每天不到 1 亿 uid，7天汇总的 uid 不到 10 亿，两张 uid 粒度的表进行 join 就会快很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，多余 join 的问题得到了解决， 再来看看第二个问题。这个问题其实就是我们维度建模理论中所说的宽表，为了避免统计不同维度时频繁 join 维表，我们可以在上游数据将常用的维度提前关联起来，形成一张大宽表。下游数据可以直接用从而减少 join。以我们的问题为例，SQL 如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; user_profile_article_uid_tb &lt;span&gt;as&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; 
    data_tb.uid
    , item_infos
    , gender
    , age
    , city
　　&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 其他维度字段&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt;
　　(
   　　 &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; uid, item_infos
    　　&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_article_uid_tb 
　　) data_tb
　　&lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;
　　(
    　　&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; uid, gender, age, city
　　　　&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_profile_tb
　　　　&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; dt&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;20190707&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;最新的日期&lt;/span&gt;
&lt;span&gt;　　) profile_tb
　　&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt; 
　　　　data_tb.uid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; profile_tb.uid&lt;br/&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样，上面提到的两个问题就都解决了。最终我们的需求：女性用户每篇文章的 ctr 计算如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; 
    itemid
    , &lt;/span&gt;&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;if&lt;/span&gt;(dur &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;)) &lt;span&gt;/&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) ctr
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; 
　　(
　　　　&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;br/&gt;　　　　　　split(item_info, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; itemid
    　 　　, split(item_info, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; dur
　　　　&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; user_profile_article_uid_tb 
　　　　lateral &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; explode(split(item_infos, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) item_tb &lt;span&gt;as&lt;/span&gt;&lt;span&gt; item_info
　　) tmp
&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt; itemid
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; ctr &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;
limit &lt;/span&gt;&lt;span&gt;50000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参数优化&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mapreduce.map.memory.mb
mapreduce.reduce.memory.mb
mapred.reduce.tasks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这些参数设置是比较通用的选项， 当这些选项不能够达到最优的效果时，需要从业务上进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这篇文章主要介绍了在 ODPS 或 Hive 上，百亿级数据规模的 join 优化。核心思想就是减少 join 的数据量，同时优化没有放之四海而皆准的方法，一定是结合业务进行的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;欢迎关注公众号&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201905/1129006-20190519220125818-12935098.png&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jul 2019 00:32:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>最近在做大数据处理时，遇到两个大表 join 导致数据处理太慢（甚至算不出来）的问题。我们的数仓基于阿里的 ODPS，它与 Hive 类似，所以这篇文章也适用于使用 Hive 优化。处理优化问题，一般</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11186279.html</dc:identifier>
</item>
<item>
<title>快速掌握mongoDB(一)——mongoDB安装部署和常用shell命令 - 捞月亮的猴子</title>
<link>http://www.cnblogs.com/wyy1234/p/10919567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyy1234/p/10919567.html</guid>
<description>&lt;h2&gt;1.mongoDB简介&lt;/h2&gt;
&lt;p&gt;　　mongoDB 是由C++语言编写的，是一种分布式的面向文档存储的开源nosql数据库。nosql是Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。&lt;/p&gt;
&lt;p&gt;　　mongoDB是无模式的文档数据库,在关系型数据库中，数据表的每一行都拥有一样的字段，字段的名字和数据类型在创建table的时候就基本确定了，如student表的每一行都有学生编号、学生姓名、年龄等字段；而在mongoDB中，存储数据的格式类似于Json(格式为&lt;a href=&quot;https://docs.mongodb.com/manual/reference/bson-types/&quot; target=&quot;_blank&quot;&gt;Bson&lt;/a&gt;)，每一个document的字段的名字和数据类型可以完全不同，如在一个collection下，第一个document可以存储学生信息(学生编号、姓名、年龄、性别等)，第二个document可以存储班级信息(班级编号，班级名等)。正是因为无模式的特点，让我们可以无需多余操作就能完成数据的横向扩展。下表是mongoDB和传统数据库术语的对应关系。&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr&gt;&lt;th&gt;SQL术语&lt;/th&gt;
&lt;th&gt;MongoDB&lt;/th&gt;
&lt;th&gt;解释/说明&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;td&gt;数据库表/集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;td&gt;数据记录行/文档&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;数据字段/域&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;join&lt;/td&gt;
&lt;td&gt; $lookup&lt;/td&gt;
&lt;td&gt;表连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;主键,MongoDB自动将_id字段设置为主键&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;2. mongoDB安装&lt;/span&gt; &lt;/h2&gt;
&lt;h3&gt;1.安装mongoDB&lt;/h3&gt;
&lt;p&gt;　　mongoDB的安装步骤十分简单，下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center#community&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.mongodb.com/download-center#community&lt;/a&gt;。如果我们想在Windows上安装mongoDB直接下载msi文件，双击安装即可。如果要将mongoDB安装在Linux系统上，步骤如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###第1步 下载解压mongdb&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;下载解压二进制包，解压即安装&lt;/span&gt;
　　cd /usr/local/src/&lt;span&gt;
　　curl &lt;/span&gt;-O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.9&lt;span&gt;.tgz
　　tar &lt;/span&gt;-zxvf mongodb-linux-x86_64-4.0.9&lt;span&gt;.tgz
　　mv mongodb&lt;/span&gt;-linux-x86_64-4.0.9 /usr/local/&lt;span&gt;mongodb

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###第2步 添加配置文件&lt;/span&gt;
　　vim /usr/local/mongodb/bin/&lt;span&gt;mongodb.conf
&lt;span&gt;&lt;strong&gt;配置文件内容如下：&lt;/strong&gt;&lt;/span&gt;
&lt;em&gt;&lt;span&gt;systemLog:
  destination: file
  logAppend: &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;true
  path:&lt;/em&gt; /usr/local/mongodb/logs/mongodb.log
storage:
  dbPath: /usr/local/mongodb/data
  journal:
    enabled: true
processManagement:
  fork: true
net:
  port: 27017
  bindIp: 0.0.0.0&lt;/span&gt;

 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;配置文件中指定的dbpath和log要自己添加，不然会报错，执行命令 &lt;/span&gt;
　　mkdir -p /usr/local/mongodb/data; mkdir -p /usr/local/mongodb/logs/;cd /usr/local/mongodb/logs/&lt;span&gt;; touch mongodb.log

 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###第3步 加载配置文件运行&lt;/span&gt;
　　/usr/local/mongodb/bin/mongod &lt;span&gt;-f&lt;/span&gt; /usr/local/mongodb/bin/&lt;span&gt;mongodb.conf 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###第4步 添加环境变量，用于可以在任意目录下执行mongo命令 &lt;/span&gt;
　　vim ~/.bash_profile &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改当前用户下的环境变量 PATH=$PATH:$HOME/bin:/usr/local/mongodb/bin  &lt;/span&gt;
　　source ~/.bash_profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　安装完成后，在任意目录下使用命令 &lt;span class=&quot;cnblogs_code&quot;&gt;mongo 192.168.70.133:27017&lt;/span&gt; (mongo命令会默认启动127.0.0.1:27017)启动mongodb，mongoDB使用的是javascript shell，我们简单测试一下，如果出现下边的界面表示安装成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190525151151628-164071995.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt; 　　这里简单使用一下mongoDB的shell来添加、删除数据库和collection:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201906/1007918-20190616150530057-737696353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.安装Robomongo并连接数据库&lt;/h3&gt;
&lt;p&gt;　　mongoDB的GUI有MongoDB Compass、studio 3T等，这里使用的是Robomongo，下载地址：&lt;a href=&quot;https://robomongo.org/&quot; target=&quot;_blank&quot;&gt;https://robomongo.org/&lt;/a&gt;，下载完成后一直Next安装即可，连接mongoDB效果如下，Robomongo是傻瓜式的用法，可以通过客户端添加collection,document，执行shell等，具体使用方法就不再详细介绍了。&lt;/p&gt;
&lt;p&gt;·　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190525153533351-367984082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们也可以通过shell脚本连接数据库，在Robomongo执行shell命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接远程数据库&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; mongo=&lt;span&gt;new&lt;/span&gt; Mongo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.70.133:27017&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到数据库&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; db=mongo.getDB(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到collecttion&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; collection=db.getCollection(&lt;span&gt;&quot;userinfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询colletion中所有数据&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; list=&lt;span&gt;collection.find().toArray();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;json形式打印结果&lt;/span&gt;
　　printjson(list);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3 mongoDB的shell&lt;/h2&gt;
&lt;p&gt;　　我们已经知道mongoDB是面向文档的nosql数据库，因为其无模式的特点，造成它的操作要比关系型数据库复杂一些，这里简单介绍一下mongoDB的CRUD操作。注意：从3.2版本开始，mongoDB添加了一些xxxOne()和xxxMany()方法，我们尽量使用这些新的方法。&lt;/p&gt;
&lt;h3&gt;1 添加(insert)&lt;/h3&gt;
&lt;p&gt;　　　添加数据的指令是insert，使用方法如下：&lt;/p&gt;

&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201906/1007918-20190613211708734-1714194013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　insert方法的参数也可以是数组，用于批量添加数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.userinfos.insert([
   {_id:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;23&lt;/span&gt;&lt;span&gt;},
   {_id:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;24&lt;/span&gt;&lt;span&gt;}
]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从3.2版本，mongoDB添加了insertOne和insertMany方法，分别用于单条插入和批量插入，用法很简单，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;insertOne用于单条添加&lt;/span&gt;&lt;/strong&gt;
　　&lt;span&gt;db.userinfos.insertOne(
   　　{_id:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;23&lt;/span&gt;&lt;span&gt;}
  　 );

&lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;insertMany用于批量添加&lt;/span&gt;&lt;/strong&gt;
　　&lt;span&gt; db.userinfos.insertMany([
  　　 {_id:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;23&lt;/span&gt;&lt;span&gt;},
  　　 {_id:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;24&lt;/span&gt;&lt;span&gt;}
　　]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2 查询(find)&lt;/h3&gt;
&lt;p&gt;　　mongoDB查询使用find函数，语法如下：&lt;/p&gt;
&lt;p&gt; 　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201906/1007918-20190613220902900-1323060044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　mongoDB使用find查询时，默认会返回主键_id，如果不想返回主键的话设置_id=0即可。mongoDB的查询语法是比较简单的，但是因为其无模式的特点，且field的值可以是对象和数组，造成mongoDB的运算符要比传统的关系型数据库多很多，如运算符$exists可用于查询field是否存在、$type用于判断filed的类型等等，这里汇总了一些常用的查询相关的运算符，有兴趣的小伙伴可以测试一下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;121.5&quot;&gt;&lt;tr readability=&quot;45&quot;&gt;&lt;td colspan=&quot;5&quot; readability=&quot;25.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;测试数据：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;db.userinfos.insertMany([
   {_id:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;23&lt;/span&gt;,level:&lt;span&gt;10&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;san&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;24&lt;/span&gt;,level:&lt;span&gt;20&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;si&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles:[ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;25&lt;/span&gt;,level:&lt;span&gt;30&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;赵六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;26&lt;/span&gt;,level:&lt;span&gt;40&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
   {_id:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;田七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;27&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, address:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
   {_id:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;周八&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;28&lt;/span&gt;,roles:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], address:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
]);&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; 类别&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt; 运算符&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt; 说明&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt; 实例&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt; 执行结果&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td rowspan=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;比较运算符   &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$gt($gte)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;大于(大于等于)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ age:{$gt:25}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查找age&amp;gt;25的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;赵六&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 { &quot;_id&quot; : 5, &quot;name&quot; : &quot;田七&quot; }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;&lt;span&gt; $lt($lte)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 小于(小于等于)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{ age:{$lt:25}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查找age&amp;lt;25的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;李四&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt; $eq&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 等于&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{ age:{$eq:25}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;查询age=25的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 3, &quot;name&quot; : &quot;王五&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td&gt;&lt;span&gt; $ne&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 不等于&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ age:{$ne:25}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt; 查询age!=25的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{&quot;_id&quot; : 1,&quot;name&quot; : &quot;张三&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 2,&quot;name&quot; : &quot;李四&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 4,&quot;name&quot; : &quot;赵六&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 5,&quot;name&quot; : &quot;田七&quot;}]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td&gt;&lt;span&gt; $in&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 包含&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{ age:{$in:[24,25]}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;查询age在[24,25]中的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 [ { &quot;_id&quot; : 2, &quot;name&quot; : &quot;李四&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;王五&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td&gt;&lt;span&gt; $nin&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 不包含&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{ age:{$nin:[24,25]}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;查询age不在[24,25]中的文档的name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{&quot;_id&quot; : 1,&quot;name&quot; : &quot;张三&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 4,&quot;name&quot; : &quot;赵六&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 5,&quot;name&quot; : &quot;田七&quot;}]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;&lt;strong&gt;&lt;span&gt;逻辑运算符&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$and&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 与&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{$and: [&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{name:{$eq:'张三'}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:{$eq:23}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　]},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;查询name='张三'且age=23的文档 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td&gt;&lt;span&gt;$not &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;非&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{age:{$not:{$in:[23,24,25]}}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;查询age不在[23,24,24]中的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 4, &quot;name&quot; : &quot;赵六&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{ &quot;_id&quot; : 5, &quot;name&quot; : &quot;田七&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td&gt;&lt;span&gt;$or &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 或&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{$or: [&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{name:{$eq:'张三'}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:{$eq:24}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　]},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;查询name='张三'或者age=24的文档 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;李四&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td&gt;&lt;span&gt;$nor &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;或的取反&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{$nor: [&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{name:{$eq:'张三'}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:{$eq:24}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　]},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt; 上边栗子的取反操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ {&quot;_id&quot; : 3,&quot;name&quot; : &quot;王五&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　 {&quot;_id&quot; : 4,&quot;name&quot; : &quot;赵六&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　 {&quot;_id&quot; : 5,&quot;name&quot; : &quot;田七&quot;} ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td rowspan=&quot;5&quot;&gt;&lt;strong&gt;&lt;span&gt; 评估运算符&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$mod&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;取余&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{age:{$mod:[10,3]}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;查询name%10=3的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;$regex&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;正则 &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:{$regex:/^张/i}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;查询name以张开头的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:{$in:[/^张/,/四$/]}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查询name以张开头或者以四结尾的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{ &quot;_id&quot; : 2, &quot;name&quot; : &quot;李四&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt;&lt;span&gt;$where&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;where过滤&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$where :function(){return this.name=='张三';}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查询名字为张三的记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：where可以实现所有的过滤，但是效率不高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是因为where采用逐行判断而不使用索引&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td&gt;&lt;span&gt; $expr&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 表达式过滤&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $expr:{$lt:[&quot;$age&quot;,&quot;$level&quot;]}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt; 查询age&amp;lt;level的记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 3, &quot;name&quot; : &quot;王五&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{ &quot;_id&quot; : 4, &quot;name&quot; : &quot;赵六&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;元素运算符 &lt;/strong&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$exists&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;field是否存在&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ address:{$exists:true}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ name:1 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查询存在address字段的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 5, &quot;name&quot; : &quot;田七&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{ &quot;_id&quot; : 6, &quot;name&quot; : &quot;周八&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt;&lt;span&gt;$type&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;field类型&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.find(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:{$type:'string'}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt; 查询name为string的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所有文档都匹配&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18.5&quot;&gt;&lt;td rowspan=&quot;3&quot;&gt;&lt;span&gt;&lt;strong&gt;数组运算符&lt;/strong&gt;   &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; $all&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 包含所有元素才匹配成功&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{roles:{$all:['vip','gen']}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;查询roles中包含vip和gen的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; [ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;王五&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td&gt;&lt;span&gt; $eleMatch&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 只要有一个元素符合就匹配成功&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{roles:{$elemMatch:{ $eq: 'vip', $ne: 'gen' }}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt; 查询roles中有元素等于vip，或有元素不等于gen的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{&quot;_id&quot; : 1,&quot;name&quot; : &quot;张三&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 2,&quot;name&quot; : &quot;李四&quot;},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{&quot;_id&quot; : 3,&quot;name&quot; : &quot;王五&quot;}]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.5&quot;&gt;&lt;td&gt;&lt;span&gt;$size&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 元素个数相同的匹配成功&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; db.userinfos.find(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{roles:{$size:2}},&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　{name:1}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt; 查询roles中有两个元素的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[ { &quot;_id&quot; : 1, &quot;name&quot; : &quot;张三&quot; },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{ &quot;_id&quot; : 3, &quot;name&quot; : &quot;王五&quot; } ]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;3 修改(update)&lt;/h3&gt;
&lt;p&gt;　　mongoDB修改documen使用的命令是update，语法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201906/1007918-20190616114751086-971432921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　mongoDB的update默认只修改一条document，如果想修改所有符合条件的documet的话，可以设置multi:true。upsert表示当没有符合过滤条件的文档时，就添加一条文档，并将修改的内容作为新增document的值。mongoDB的update功能比较丰富，如可以修改field的名字，删除field，以及对数组进行增删改。从3.2版本开始，mongoDB添加了updateOne()和updateMany()方法，用于修改单条或者多条数据，推荐使用新的方法，语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将age&amp;lt;25的记录的level修改为50，只修改一条。updateOne相当于update设置multi:false&lt;/span&gt;
&lt;span&gt;db.userinfos.updateOne(
   {age:{$lt:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;}},
   {$&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;:{level:&lt;span&gt;50&lt;/span&gt;&lt;span&gt;}}
   )
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将age&amp;lt;25的记录的level修改为50，所有符合条件的记录都修改。updateMany相当于update设置multi:true&lt;/span&gt;
&lt;span&gt;db.userinfos.updateMany(
   {age:{$lt:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;}},
   {$&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;:{level:&lt;span&gt;50&lt;/span&gt;&lt;span&gt;}}
   )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里汇总了mongoDB中关于update的相关运算符，有兴趣的小伙伴可以测试一下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;56.5&quot;&gt;&lt;tr readability=&quot;45&quot;&gt;&lt;td colspan=&quot;5&quot; readability=&quot;25.5&quot;&gt;
&lt;p&gt; &lt;strong&gt;测试数据：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;db.userinfos.insertMany([
   {_id:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;23&lt;/span&gt;,level:&lt;span&gt;10&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;san&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;24&lt;/span&gt;,level:&lt;span&gt;20&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;si&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles:[ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;25&lt;/span&gt;,level:&lt;span&gt;30&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]},
   {_id:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;赵六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;26&lt;/span&gt;,level:&lt;span&gt;40&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, roles: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] },
   {_id:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;田七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;27&lt;/span&gt;, ename: { firstname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lastname: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, address:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
   {_id:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;周八&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age: &lt;span&gt;28&lt;/span&gt;,roles:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], address:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
]);&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;21.5&quot;&gt;&lt;td rowspan=&quot;8&quot;&gt; &lt;strong&gt;值操作运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$currentDate&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;修改field值为当前时间,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果field不存在则添加field&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$currentDate:{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　createtime:{$type:'timestamp'}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;将张三的createtime字段值修改为当前时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　格式为时间戳(&quot;createtime&quot; : Timestamp(1560663270, 1))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;补充:如果不设置$type，默认的格式为date&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　格式为date(&quot;createtime&quot; : ISODate(&quot;2019-06-16T05:38:21.119Z&quot;))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;$set&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;修改值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$set:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{level:20}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 将张三的level修改为20。如果要修改的field不存在，不会添加新的field。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;$setOnInsert &lt;/span&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;只有在新增document时进行赋值，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一定要设置upsert:true&lt;/span&gt;&lt;/p&gt;
&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$setOnInsert:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{level:30}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{upsert:true}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 因为已经有name=张三的document，所以不做任何操作&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'吴九'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$setOnInsert:{level:30}},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{upsert:true}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 添加一个name=吴九的document，并设置level为30&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;$inc&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;自增&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$inc:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:10}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;张三的age自增10，age修改为23+10=33&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;$mul&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;自乘&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$mul:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:2}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;张三的age自乘2，age修改为23*2=46&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt;&lt;span&gt;$min&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;取小&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$min:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:13}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;张三的age取小值，因为23&amp;gt;13,所以修改age为13。如果修改的值比23大，那么不做操作。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt;&lt;span&gt;$max&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;取大&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;db.userinfos.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{name:'张三'},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$max:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:33}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;张三的age取大值，因为23&amp;lt;33,所以修改age为33。如果修改的值比23小，那么不做操作。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;字段操作运算符&lt;/strong&gt;  &lt;/td&gt;
&lt;td&gt;&lt;span&gt;$rename&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 修改filed的名字&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;&lt;span&gt; db.userinfos.update(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{name:'张三'},&lt;br/&gt;　　{$rename:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{age:'年龄'}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 将张三的age字段名改成年龄，值不变，年龄=23&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;$unset&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 删除field&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; db.userinfos.update(&lt;/span&gt;
&lt;p&gt;&lt;span&gt;　　{name:'张三'},&lt;br/&gt;　　{$unset:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{level:''}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;br/&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 将张三的level字段删除&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt; 　　数组相关的update运算符：&lt;/h4&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;109&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td colspan=&quot;5&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试数据：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;   db.students.insertMany(
        [{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grades&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;&lt;span&gt; ] },
　　      { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grades&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ &lt;span&gt;88&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;, &lt;span&gt;92&lt;/span&gt;&lt;span&gt; ] }]
   )&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;21.5&quot;&gt;&lt;td rowspan=&quot;8&quot;&gt;&lt;strong&gt;&lt;span&gt; 数组运算符&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;$&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;单个占位符&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 1, grades: 80 },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $set: { &quot;grades.$&quot; : 82 } }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;修改_id=1的文档graders中第一个值为80的元素，值改成82&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [ 85, 82, 80 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 90, 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td&gt;&lt;span&gt; $[]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 所有元素占位符&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 1},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $set: { &quot;grades.$[]&quot; : 100 } }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;修改_id=1的文档graders中所有元素，值改成100&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [ 100, 100, 100 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 90, 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;25.5&quot;&gt;&lt;td&gt;&lt;span&gt; $[&amp;lt;identifier&amp;gt;]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 符合arrayFilter过滤条件的元素占位符&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 2},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $set: { &quot;grades.$[element]&quot; : 100 } },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ arrayFilters: [ { &quot;element&quot;: { $gte: 90 } } ]}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;修改_id=2的文档graders中大于等于90的元素，值改成100&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 82, 80  ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 100, 100 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;22&quot;&gt;&lt;td&gt;&lt;span&gt; $push&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 添加元素&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 1 },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $push: { &quot;grades&quot; : 98 } }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;在_id=1的文档graders中添加元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80 ,98 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 90, 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;26&quot;&gt;&lt;td&gt;&lt;span&gt;$addToSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 添加不存在的元素，如果元素已经存在则无操作&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 1 },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $addToSet: { &quot;grades&quot; : 100 } }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;19&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;在_id=1的文档graders中添加元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80 ,98,100 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 90, 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;补充：如果添加的元素是85，因为85已经存在，所以不执行操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td&gt;&lt;span&gt; $pop&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 弹出(移除)元素&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.updateOne(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ _id: 1 },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ $pop: { &quot;grades&quot; : 1 } }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt; 移除最后一个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88, 90, 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;补充：如果{ $pop: { &quot;grades&quot; : -1 } }表示从前边弹出，移除第一个元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;22&quot;&gt;&lt;td&gt;&lt;span&gt;$pullAll&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;根据值移除数组中的元素&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:2},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$pullAll:{&quot;grades&quot;:[88,90]}}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;移除_id=2的文档的graders中值为88,90的所有元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80  ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 92 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20.5&quot;&gt;&lt;td&gt;&lt;span&gt; $pull&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 移除符合条件的元素&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:2},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$pull:{&quot;grades&quot;:{$gt:90}}}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;移除_id=2的文档的graders中大于90的所有元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80  ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88,90 ] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;32.5&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt; 数组批量添加&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关运算符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; $each&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 和$push,$addToSet配合使用，用于批量添加元素&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:1},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$push:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{grades:{$each:[99,100]}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;在_id=1的文档graders中添加元素[99,100]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80 ,99,100 ] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88,90 ,92] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;31.5&quot;&gt;&lt;td&gt;&lt;span&gt; $slice&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 和$push,$each配合使用，用于限制元素个数&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;&lt;span&gt; &lt;/span&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:1},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$push:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{grades:{$each:[99,100],$slice:4}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;&lt;span&gt; 在_id=1的文档graders中添加元素[99,100]&lt;/span&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [  85, 80, 80 ,99] },&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88,90 ,92] }]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用$slice:-4，则保留后4个元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;33&quot;&gt;&lt;td&gt;&lt;span&gt;$sort&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和$push,$each配合使用，在添加元素后进行排序&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:1},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$push:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{grades:{$each:[70,100],$sort:1}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;&lt;span&gt;在_id=1的文档graders中添加元素[99,100]，并排序&lt;/span&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [70,80,80,85,100]},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88,90 ,92] }]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用$sort:-1，则倒序排序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;32&quot;&gt;&lt;td&gt;&lt;span&gt;$position&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;和$push,$each配合使用，指定插入元素的位置&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;db.students.update(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{_id:1},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{$push:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　{grades:{$each:[70,100],$position:1}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;&lt;span&gt; 在_id=1的文档graders中,从索引1开始插入元素[99,100]&lt;/span&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[{ &quot;_id&quot; : 1, &quot;grades&quot; : [85,70,100,80,80]},&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　{ &quot;_id&quot; : 2, &quot;grades&quot; : [ 88,90 ,92] }]&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;4.删除(remove/delete)&lt;/h3&gt;
&lt;p&gt;　　在3.2以前的版本中，mongoDB使用remove方法来删除文档，用法如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201906/1007918-20190616143017259-1159581044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从3.2版本开始，提供了deleteOne()和deleteMany()方法，分别用于删除单条和多条document，语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除单条document，功能类似于remove设置justOne:true&lt;/span&gt;
　　db.userinfos.deleteOne({age:{$gt:&lt;span&gt;25&lt;/span&gt;&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除所有符合条件的document，功能类似于remove设置justOne:false&lt;/span&gt;
　　db.userinfos.deleteMany({age:{$gt:&lt;span&gt;25&lt;/span&gt;}})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本篇是mongoDB的第一篇，简单介绍了mongoDB的安装方法，通过js shell进行mongoDB的CRUD操作，后续会逐步介绍mongoDB的索引、数据聚合、GridFS和C#驱动，以及副本集和sharing集群搭建。如果本文由错误的地方，希望大家可以指出，我会及时修改，谢谢。&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jul 2019 00:32:00 +0000</pubDate>
<dc:creator>捞月亮的猴子</dc:creator>
<og:description>1.mongoDB简介 mongoDB 是由C++语言编写的，是一种分布式的面向文档存储的开源nosql数据库。nosql是Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyy1234/p/10919567.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web Api之JWT(一) - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11123023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11123023.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近沉寂了一段，主要是上半年相当于休息和调整了一段时间，接下来我将开始陆续学习一些新的技术，比如Docker、Jenkins等，都会以生活实例从零开始讲解起，到时一并和大家分享和交流。接下来几节课的内容将会讲解JWT，关于JWT的原理解析等等园子里大有文章，就不再叙述，这里我们讲解使用和一些注意的地方。&lt;/p&gt;
&lt;h2&gt;为什么要使用JWT&lt;/h2&gt;
&lt;p&gt;在.NET Core之前对于Web应用程序跟踪用户登录状态最普通的方式则是使用Cookie，当用户点击登录后将对其信息进行加密并响应写入到用户浏览器的Cookie里，当用户进行请求时，服务端将对Cookie进行解密，然后创建用户身份，整个过程都是那么顺其自然，但是这是客户端是基于浏览器的情况，如果是客户端是移动app或者桌面应用程序呢？关于JWT原理可以参考系列文章&lt;a title=&quot;ASP.NET Core 认证与授权[4]:JwtBearer认证&quot; href=&quot;https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html&quot;&gt;https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html&lt;/a&gt;，当然这只是其中一种限制还有其他。如果我们使用Json Web Token简称为JWT而不是使用Cookie，此时Token将代表用户，同时我们不再依赖浏览器的内置机制来处理Cookie，我们仅仅只需要请求一个Token就好。这个时候就涉及到Token认证，那么什么是Token认证呢？一言以蔽之：将令牌(我们有时称为AccessToken或者是Bearer Token)附加到HTTP请求中并对其进行身份认证的过程。Token认证被广泛应用于移动端或SPA。&lt;/p&gt;
&lt;h2&gt;Json Web Token基础&lt;/h2&gt;
&lt;p&gt;JWT由三部分构成，Base64编码的Header，Base64编码的Payload，签名，三部分通过点隔开。第一部分以Base64编码的Header主要包括Token的类型和所使用的算法，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HS265&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;typ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JWT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二部分以Base64编码的Payload主要包含的是声明(Claims)，例如，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;765032130654732&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三部分则是将Key通过对应的加密算法生成签名，最终三部分以点隔开，比如如下形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiSmVmZmNreSIsImVtYWlsIjoiMjc1MjE1NDg0NEBxcS5jb20iLCJleHAiOjE1NjU2MTUzOTgsIm5iZiI6MTU2MzE5NjE5OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAxIn0.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; OJjlGJOnCCbpok05gOIgu5bwY8QYKfE2pOArtaZJbyI
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里此时我们应该知道：JWT包含的信息并没有加密，比如为了获取Payload，我们大可通过比如谷歌控制台中的APi（atob）对其进行解码，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715211402620-1668824173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那如我所说既然JWT包含的信息并没有加密，只是进行了Base64编码，岂不是非常不安全呢？当然不是这样，还没说完，第三部分就是签名，虽然我们对Payload（姑且翻译为有效负载），未进行加密，但是若有蓄意更换Payload，此时签名将能充分保证Token无效，除非将签名的Key不小心暴露在光天化日之下，否则必须是安全的。好了，到了这里，我们稍稍讲解了下JWT构成，接下来我们进入如何在.NET Core中使用JWT。&lt;/p&gt;
&lt;h2&gt;.NET Core中使用JWT&lt;/h2&gt;
&lt;p&gt;在.NET Core中如何使用JWT，那么我们必须得知晓如何创建JWT，接下来我们首先创建一个端口号为5000的APi，创建JWT，然后我们需要安装 &lt;span class=&quot;cnblogs_code&quot;&gt;System.IdentityModel.Tokens.Jwt&lt;/span&gt; 包，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715212242263-1055895515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们直接给出代码来创建Token，然后一一对其进行详细解释，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(ClaimTypes.Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Email, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Sub, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D21D099B-B49B-4604-A247-71B0518A0B1C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                issuer: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                audience: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                claims: claims,
                notBefore: DateTime.Now,
                expires: DateTime.Now.AddHours(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                signingCredentials: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256)
            );

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jwtToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityTokenHandler().WriteToken(token);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上我们在声明集合中初始化声明时，我们使用了两种方式，一个是使用 &lt;span class=&quot;cnblogs_code&quot;&gt;ClaimTypes&lt;/span&gt; ，一个是 &lt;span class=&quot;cnblogs_code&quot;&gt;JwtRegisteredClaimNames&lt;/span&gt; ，那么这二者有什么区别？以及我们到底应该使用哪种方式更好？或者说两种方式都使用是否有问题呢？针对ClaimTypes则来自命名空间 &lt;span class=&quot;cnblogs_code&quot;&gt;System.Security.Claims&lt;/span&gt; ，而JwtRegisteredClaimNames则来自命名空间 &lt;span class=&quot;cnblogs_code&quot;&gt;System.IdentityModel.Tokens.Jwt&lt;/span&gt; ，二者在获取声明方式上是不同的，ClaimTypes是沿袭微软提供获取声明的方式，比如我们要在控制器Action方法上获取上述ClaimTypes.Name的值，此时我们需要F12查看Name的常量定义值是多少，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715221621470-972321835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来则是获取声明Name的值，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; sub = User.FindFirst(d =&amp;gt; d.Type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?.Value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715221909592-917098992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如果我们想要获取声明JwtRegisterClaimNames.Sub的值，我们是不是应该如上同样去获取呢？我们来试试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sub = User.FindFirst(d =&amp;gt; d.Type == JwtRegisteredClaimNames.Sub)?.Value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715222212011-1118333553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们发现为空没有获取到，这是为何呢？这是因为获取声明的方式默认是走微软定义的一套映射方式，如果我们想要走JWT映射声明，那么我们需要将默认映射方式给移除掉，在对应客户端Startup构造函数中，添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715222440355-1392368167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果用过并熟悉IdentityServer4的童鞋关于这点早已明了，因为在IdentityServer4中映射声明比如用户Id即（sub）是使用的JWT，也就是说使用的JwtRegisteredClaimNames，此时我们再来获取Sub看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715222739282-1956288627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以以上对于初始化声明两种方式的探讨并没有用哪个更好，因为对于使用ClaimTypes是沿袭以往声明映射的方式，如果要出于兼容性考虑，可以结合两种声明映射方式来使用。接下来我们来看生成签名代码，生成签名是如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上我们给出签名的Key是1234567890123456，是不是给定Key的任意长度皆可呢，显然不是，&lt;span&gt;关于Key的长度至少是16&lt;/span&gt;，否则会抛出如下错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715223328594-37341950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们再来看实例化Token的参数，即如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                issuer: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                audience: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                claims: claims,
                notBefore: DateTime.Now,
                expires: DateTime.Now.AddHours(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                signingCredentials: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256)
            );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;issuer代表颁发Token的Web应用程序，audience是Token的受理者，如果是依赖第三方来创建Token，这两个参数肯定必须要指定，因为第三方本就不受信任，如此设置这两个参数后，我们可验证这两个参数。要是我们完全不关心这两个参数，可直接使用JwtSecurityToken的构造函数来创建Token，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(ClaimTypes.Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Email, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Sub, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D21D099B-B49B-4604-A247-71B0518A0B1C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Exp, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now.AddMilliseconds(1)).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Nbf, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jwtToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityToken(&lt;span&gt;new&lt;/span&gt; JwtHeader(&lt;span&gt;new&lt;/span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256)), &lt;span&gt;new&lt;/span&gt; JwtPayload(claims));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是Exp和Nbf是基于Unix时间的字符串，所以上述通过实例化DateTimeOffset来创建基于Unix的时间。到了这里，我们已经清楚的知道如何创建Token，接下来我们来使用Token获取数据。我们新建一个端口号为5001的Web应用程序，同时安装包【 &lt;span class=&quot;cnblogs_code&quot;&gt;Microsoft.AspNetCore.Authentication.JwtBearer&lt;/span&gt; 】接下来在Startup中ConfigureServices添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    IssuerSigningKey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),

                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidIssuer &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                    ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidAudience &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                    ValidateLifetime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

                    ClockSkew &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
                };
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述若Token依赖于第三方而创建，此时必然会配置issuer和audience，同时在我方也如上必须验证issuer和audience，上述我们也验证了签名，我们通过设置 &lt;span class=&quot;cnblogs_code&quot;&gt;ValidateLifetime&lt;/span&gt;  为true，说明验证过期时间而并非Token中的值，最后设置 &lt;span class=&quot;cnblogs_code&quot;&gt;ClockSkew&lt;/span&gt;  有效期为5分钟。对于设置 &lt;span class=&quot;cnblogs_code&quot;&gt;ClockSkew&lt;/span&gt;  除了如上方式外，还可如下设置默认也是5分钟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 ClockSkew = TimeSpan.Zero
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上对于认证方案我们使用的是 &lt;span class=&quot;cnblogs_code&quot;&gt;JwtBearerDefaults.AuthenticationScheme&lt;/span&gt; 即Bearer，除此之外我们也可以自定义认证方案名称，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715231947071-1553777114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后别忘记添加认证中间件在Configure方法中，认证中间件必须放在使用MVC中间件之前，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            app.UseAuthentication();

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到了这里，我们通过端口为5000的Web Api创建了Token，并配置了端口号为5001的Web应用程序使用JWT认证，接下来最后一步则是调用端口号为5000的APi获取Token，并将Token设置到请求头中Authorization键的值，格式如下（注意Bearer后面有一个空格）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + token);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在页面上放置一个按钮点击获取端口号为5000的Token后，接下来请求端口号为5001的应用程序，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    $(function () {
        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click(function () {
            $.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).done(function (token) {
                $.ajax({
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    contentType: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5001/api/home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    beforeSend: function (xhr) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (token !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            xhr.setRequestHeader(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; token);
                        }
                    },
                    success: function (data) {
                        alert(data);
                    },
                    error: function (xhr) {
                        alert(xhr.status);
                    }
                });
            });
        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715230922215-2069769217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190715231248170-2118911205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们讲解了在.NET Core中使用JWT进行认证以及一点点注意事项，比较基础性的东西，下一节讲解完在JWT中使用刷新Token，开始正式进入Docker系列，感谢阅读，下节见。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 23:33:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 最近沉寂了一段，主要是上半年相当于休息和调整了一段时间，接下来我将开始陆续学习一些新的技术，比如Docker、Jenkins等，都会以生活实例从零开始讲解起，到时一并和大家分享和交流。接下来几节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11123023.html</dc:identifier>
</item>
<item>
<title>JAVA面试题 浅析Java中的static关键字 - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11192096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11192096.html</guid>
<description>&lt;p&gt;面试官Q1：请说说static关键字，你在项目中是怎么使用的？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;static 关键字可以用来修饰：属性、方法、内部类、代码块；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;static 修饰的资源属于&lt;strong&gt;类级别&lt;/strong&gt;，是全体对象实例共享的资源；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用 static 修饰的属性，静态属性是在类的加载期间初始化的，使用&lt;strong&gt;类名.属性&lt;/strong&gt;访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;案例说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;①修饰成员变量&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 package com.ant.param;
 public class StaticFieldDemo {
     public static void main(String[] args) {
         Foo f1 = new Foo();
         Foo f2 = new Foo();
         Foo f3 = new Foo();
         System.out.println(f1.id + &quot; &quot; + f2.id + &quot; &quot; + f3.id );
     }
 }
class Foo{
    int id;
}
运行结果如下：
0 0 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码我们很熟悉，根据Foo构造出的每一个对象都是独立存在的，保存有自己独立的成员变量，相互不会影响，他们在内存中的示意如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190715224620253-1036932637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看出，f1、f2和f3三个变量引用的对象分别存储在内存中堆区域的不同地址中，所以他们之间相互不会干扰。对象的成员属性都在这了，由每个对象自己保存。f1.id、f2.id、f3.id相当于“每个人一个水杯”。&lt;/p&gt;
&lt;p&gt;我们对上面的代码，做如下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.ant.param;
 public class StaticFieldDemo {
     public static void main(String[] args) {
         Foo f1 = new Foo();
         Foo f2 = new Foo();
         Foo f3 = new Foo();
         System.out.println(f1.id + &quot; &quot; + f2.id + &quot; &quot; +
         f3.id + &quot; &quot; + Foo.i);
     }
}
class Foo{
    int id;
    static int i=0;
    public Foo(){
        id = i++;
    }
}
运行结果如下：
0 1 2 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序执行过程内存图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 1 步：加载类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190715225119196-735156057.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static修饰的变量在类加载期间初始化，且在方法区中分配，属于线程共享区，所有的对象实例共享一份数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 2步：继续加载类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190715225133895-735467785.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;第 3步：继续加载类&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190715225148368-1541807548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终加载结果如上述三个步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②修饰成员方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static的另一个作用，就是修饰成员方法。相比于修饰成员属性，修饰成员方法对于数据的存储上面并没有多大的变化，因为我们从上面可以看出，方法本来就是存放在类的定义当中的(方法区)。static修饰成员方法最大的作用，就是可以使用&quot;&lt;strong&gt;类名.方法名&quot;&lt;/strong&gt;的方式操作方法，避免了先要new出对象的繁琐和资源消耗，我们可能会经常在帮助类中看到它的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 package com.ant.param;
 
 public class StaticFieldDemo {
     private static void print(){
         System.out.println(&quot;hello&quot;);
     }
     public static void main(String[] args) {
         StaticFieldDemo.print();
     }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;③修饰静态代码块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态代码块是在类加载期间运行的代码块，由于类只加载一次，所以静态代码块只执行一次！静态代码块用途很常见,一般用来在类加载以后初始化一些静态资源时候使用。如：加载配置文件等&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.ant.param;
 
 public class StaticBlockDemo {
     public static void main(String[] args) {
         Foo foo = new Foo();
     }
 }
 
 class Foo{
    //代码块，在创建对象的时候执行，使用很少，和构造器差不多
    {
        System.out.println(&quot;创建对象了！&quot;);
    }
    //静态代码块，在类加载期间执行，用于加载配置文件或者其他信息等
    static{
        System.out.println(&quot;类加载了！&quot;);
    }
    public Foo(){
        System.out.println(&quot;调用了构造器！&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态块用法：将多个类成员放在一起初始化，使得程序更加规整，对理解对象的初始化过程非常关键；&lt;/p&gt;
&lt;p&gt;在我的印象中，这些问题一般初中级Java工程师会被问到，都是很常规的面试题，您会了吗？&lt;/p&gt;

</description>
<pubDate>Mon, 15 Jul 2019 23:06:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官Q1：请说说static关键字，你在项目中是怎么使用的？ static 关键字可以用来修饰：属性、方法、内部类、代码块； static 修饰的资源属于类级别，是全体对象实例共享的资源； 使用 s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11192096.html</dc:identifier>
</item>
<item>
<title>使用Optional摆脱NPE的折磨 - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/11192604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/11192604.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-dfeb2d48d3779723.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;architectural-architectural-design-architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在目前的工作中，我对Java中的Stream和Lambda表达式都使用得很多，之前也写了两篇文章来总结对应的知识。&lt;/p&gt;
&lt;p&gt;不过对于Optional这个特性，一直没有很好地使用起来，所以最近又开始阅读《Java 8实战》这本书，本文是针对其中第10章的一个学习总结。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在Java中，如果你尝试对null做函数调用，就会引发NullPointerException（NPE），NPE是Java程序开发中的最典型的异常，对于Java开发者来说，无论你是初出茅庐的新人和还工作多年的老司机，NPE经常让他们翻车。为了避免NPE，他们会加很多if判断语句，使得代码的可读性变得很差。&lt;/p&gt;
&lt;p&gt;从软件设计的角度来看，null本身是没有意义的语义，这是一种对缺失变量值的错误的建模。&lt;/p&gt;
&lt;p&gt;从Java类型系统的角度看，null可以被赋值给任何类型的变量，并且不断被传递，知道最后谁也不知道它是从哪里引入的。&lt;/p&gt;
&lt;h2 id=&quot;optional的引入&quot;&gt;Optional的引入&lt;/h2&gt;
&lt;p&gt;Java设计者从Haskell和Scala中获取灵感，在Java 8中引入了一个新的类&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;。如果一个接口返回Optional，可以表示一个人可能有车也可能没有车，这个比简单的返回Car要更明确，阅读代码的人不需要提前准备业务知识。&lt;/p&gt;
&lt;p&gt;Optional的目的就在于此：通过类型系统让你的领域模型中隐藏的知识显式地体现在你的代码中。&lt;/p&gt;
&lt;h2 id=&quot;optional的使用&quot;&gt;Optional的使用&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;返回一个空的Optional实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;如果值存在并且满足提供的过滤条件，则返回包含该值的Optional对象；否则就返回一个空的Optional对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;如果值存在，就对该值执行提供的mapping函数调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;flatMap&lt;/td&gt;
&lt;td&gt;如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ifPresent&lt;/td&gt;
&lt;td&gt;如果值存在，就执行使用该值的方法调用，否则什么也不做&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;of&lt;/td&gt;
&lt;td&gt;将指定值用Optional封装之后返回，如果该值为null，则抛出一个NPE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ofNullable&lt;/td&gt;
&lt;td&gt;将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;orElse&lt;/td&gt;
&lt;td&gt;如果有值则返回，否则返回一个默认值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;orElseGet&lt;/td&gt;
&lt;td&gt;如果有值则返回，否则返回一个由指定的Supplier接口生成的值(如果默认值的生成代价比较高的话，则适合使用orElseGet方法)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;orElseThrow&lt;/td&gt;
&lt;td&gt;如果有值则返回，否则返回一个由指定的Supplier接口抛出的异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;如果值存在，则返回该值，否则抛出一个NoSuchElementException异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;isPresent&lt;/td&gt;
&lt;td&gt;如果值存在则返回true，否则返回false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面这张表里列举了Optional的基础API，我这里列举了一些使用的tips：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你可以用ofNullable将一个可能为null的对象封装为Optional对象，然后获取值的时候使用orElse方法提供默认值；可以使用empty方法创建一个空的Optional对象；of方法一般不用，不过如果你知道某个值不可能为null，则可以用Optional封装该值，这样它一旦为null就会抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//empty方法的使用
Optional&amp;lt;Car&amp;gt; optCar = Optional.empty();

//of方法的使用
Optional&amp;lt;Car&amp;gt; optCar = Optional.of(car);

//ofNullable方法的使用
Optional&amp;lt;Car&amp;gt; optCar = Optional.ofNullable(car);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;你可以使用map方法从Optional对象中它封装的值中的某个字段的值；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Optional&amp;lt;Insurance&amp;gt; optInsurance = Optional.ofNullable(insurance);
Optional&amp;lt;String&amp;gt; name = optInsurance.map(Insurance::getName); &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果需要连续、层层递进的从某个对象链的末端获取字段的值，则不能全部使用map方法，需要先使用flatMap，最后再使用map方法；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//转换之前
public String getCarInsuranceName(Person person) {
  return person.getCar().getInsurance().getName();
}

//转换后
public String getCarInsuranceName(Optional&amp;lt;Person&amp;gt; person) {
  return person.flatMap(Person::getCar)
               .flatMap(Car::Insurance)
               .map(Insurance::getName)
               .orElse(&quot;Unknown&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Optional中的map、flatMap和filter方法，在概念是与Stream中对应的方法都很类似，区别就在于Optional中的元素至多有一个，算是Stream的一种特殊情况——一种特殊的集合。&lt;/li&gt;
&lt;li&gt;不要使用ifPresent和get方法，它们本质上和不适用Optional对象之前的模式相同，都是臃肿的if-then-else判断语句；&lt;/li&gt;
&lt;li&gt;由于Optional无法序列化，所以在领域模型中，无法将某个字段定义为Optional的，原因是：Optional的设计初衷仅仅是要支持能返回Optional对象的语法，如果我们希望在域模型中引入Optional，则可以用下面这种替代的方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
  private Car car;
  public Optional&amp;lt;Car&amp;gt; getCarAsOptional() {
    return Optional.ofNullable(car);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不要使用基础类型的Optional对象，原因是：基础类型的Optional对象不支持map、flatMap和filter方法，而这些方法是Optional中非常强大的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实战案例&quot;&gt;实战案例&lt;/h2&gt;
&lt;h3 id=&quot;案例1使用工具类方法改良可能抛出异常的api&quot;&gt;案例1：使用工具类方法改良可能抛出异常的API&lt;/h3&gt;
&lt;p&gt;Java方法处理异常结果的方式有两种：返回null（或错误码）；抛出异常，例如：Integer.parseInt(String)这个方法——如果无法解析到对应的整型，该方法就抛出一个NumberFormationException，这种情况下我们一般会使用try/catch语句处理异常情况。&lt;/p&gt;
&lt;p&gt;一般我们建议将try/catch块单独提取到一个方法中，在这里使用Optional设计这个方法，代码如下。在开发中，可以尝试构建一个OptionalUtility工具类，将这些复杂的try/catch逻辑封装起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Optional&amp;lt;Integer&amp;gt; stringToInt(String a) {
  try{
    return Optional.of(Integer.parseInt(s));
  } catch  (NumberFormationException e) {
    return Optional.empty();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例2综合案例&quot;&gt;案例2：综合案例&lt;/h3&gt;
&lt;p&gt;现在有个方法，是尝试从一个属性映射中获取某个关键词对应的值，例子代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public static int readDuration(Properties properties, String name) {
        String value = properties.getProperty(name);
        if (value != null) {
            try {
                int i = Integer.parseInt(value);
                if (i &amp;gt; 0) {
                    return i;
                }
            } catch (NumberFormatException e) {

            }
        }
        return 0;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Optional的写法后，代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static int readDurationWithOptional(Properties properties, String name) {
        return Optional.ofNullable(properties.getProperty(name))
            .flatMap(OptionalUtility::stringToInt)
            .filter(integer -&amp;gt; integer &amp;gt; 0)
            .orElse(0);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要访问的属性值不存在，Properites.getProperty(String)方法的返回值就是一个null，使用noNullable工厂方法就可以将该值转换为Optional对象；接下来，可以使用flatMap将一个Optional转换为Optional对象；最后使用filter过滤掉负数，然后就可以使用orElse获取属性值，如果拿不到则返回默认值0。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用Optional的思路和Stream相同，都是链式思路，跟数据库查询似的，表达力很强，而且省去了哪些复杂的try/catch和if-then-else方法。在后面的开发中，可以使用Optional设计API，这样可以设计出更安全的接口和方法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-4e61421679e2d7b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 20:05:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>在目前的工作中，我对Java中的Stream和Lambda表达式都使用得很多，之前也写了两篇文章来总结对应的知识。 '024：Java流实现Shell：cat 1.log | grep a | sor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaadu/p/11192604.html</dc:identifier>
</item>
<item>
<title>排序--最大堆构造和堆排序（单步查看过程） - 努力爬呀爬</title>
<link>http://www.cnblogs.com/payapa/p/11192303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/payapa/p/11192303.html</guid>
<description>&lt;p&gt;这里先简单说下最大堆的基本性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大堆一定是完全二叉树&lt;/li&gt;
&lt;li&gt;当父节点为 n 时，左孩子为 n * 2 + 1，右孩子为 n * 2 + 2&lt;/li&gt;
&lt;li&gt;当孩子为 n 时，其父节点为： (n - 1) / 2 ----&amp;gt; 这一点很重要，在后面初始化的时候会用到&lt;/li&gt;
&lt;li&gt;父节点大于等于左孩子和右孩子，但左孩子不一定大于右孩子&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解以上基本性质之后，就可以先看一下如何对一个序列做最大堆的初始化。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;最大堆的构造&quot;&gt;最大堆的构造&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;思路：过程就像冒泡一样，从最序号最大的父节点开始，查看是否满足最大堆，如果不满足，则调整（调整之后，还要查看被调整的节点是否依然满足最大堆性质，如果不满足，则需要往下遍历调整，这部分在后面的举例中会有说明），如果满足，则继续查看前一个父节点是否满足，直接最终的0节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：这里有个数组：x[] = {2 5 3 9 7 1 6}，则对应树为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715231120194-2091559303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该序列长度为7，最大下标为6，则最大的父节点下标就是: (6 - 1)/ 2 是2（基本性质第三条），对应的数值是3，&lt;br/&gt;他的左孩子是1，右孩子是6，右孩子比父节点大，所以应该调整一下这两个节点，得到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715231558834-635685527.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该节点调整完之后，再查看前一个父节点，下标为1，对应的数值为5，&lt;br/&gt;他的左孩子是9，右孩子是7，不满足，所以父节点应该与左孩子进行交换，得到:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715232017796-1513191629.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续往前，再前面一个父节点下标为0，数值为2，左孩子是9，右孩子是6，不满足最大堆，父节点与左孩子交换，得到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715232244984-1250811455.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;交换之前，左孩子为9，现在左孩子为2，导致这个左孩子不满足最大堆性质，因为这个左孩子的左孩子大于左孩子，所以，这里就出现了上面括号中所说的：&lt;strong&gt;调整完之后，还要查看被调整的节点是否依然满足最大堆的性质。&lt;/strong&gt;&lt;br/&gt;这里还要对调整之后的节点继续调整：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715232842319-295266887.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，一个最大堆就初始化完成了！&lt;/p&gt;
&lt;h2 id=&quot;堆排序&quot;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;其实，明白了最大堆怎么构造出来的之后，堆排序就很容易了。&lt;br/&gt;想一想，最大堆构造出来之后，其实就直接得到了最大值：x[0]，&lt;br/&gt;&lt;strong&gt;如果把 x[0] 与最后一个数字交换一下，然后对剩下的数字重新按之前的方法构造一下，不就找到了第二大的数字了吗？&lt;/strong&gt;&lt;br/&gt;此时第二大的数字就是x[0]，把它与刚刚参加排序的最后的一个数字交换一下，然后再对剩下的数字排序一下，就可以得到第三大的数字，&lt;br/&gt;这么一直循环，就可以把当前数组排序完成了。&lt;br/&gt;接着刚刚的那个例题，先把9与参与排序的最后一个数字对换，得到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715234843451-381851014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时参与排序的，就只有：3，7，6，5，2，1。&lt;br/&gt;因为x[0]被调整了，所以要查看x[0]是否依然最大堆性质，显然是不满足的，所以继续调整x[0]，得到:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715235247913-765146602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;x[0]与x[1]互换之后，导致被调整的x[1]又不满足最大堆，那就再调整一下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715235519851-1682509439.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在整个树都满足最大堆了，也就得到了现在参与排序的最大值x[0]为7，&lt;br/&gt;所以，x[0]与当前参与排序的最后一位交换，得到：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715235716787-376532036.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时参与排序的，只有：1，5，6，3，2。&lt;br/&gt;按照上面步骤再次循环，这里就不写了，直接放图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190715235849931-1360084772.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001152811-1318401020.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001159930-298891304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001206716-639261214.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001214019-1831186322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001220885-926100406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1724559/201907/1724559-20190716001227314-454580188.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

// 打印数组
void print(int *array, int len)
{
    for (int i=0; i&amp;lt;len; i++)
    {
        printf(&quot;%d &quot;, array[i]);
    }
    printf(&quot;\n&quot;);
}

// 交换两个数值
void swap(int *array, int i, int j)
{
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return;
}

// 对当前父节点进行排序
// 查看该父节点是否满足最大堆，如果不满足则调整子节点
void sort (int *array, int father, int len)
{
    for (int lchild =father*2+1; lchild&amp;lt;len; lchild=father*2+1)
    {
        int k = lchild;  // 先用k指向左孩子
        int rchild = lchild + 1;
        if ((rchild &amp;lt; len) &amp;amp;&amp;amp; (array[rchild] &amp;gt; array[lchild])) 
        {
            k = rchild;   // 如果有右孩子，且右孩子比左孩子还大，则更新k
        }

        // 这里的k，指向了左右孩子中较大的那个
        if (array[k] &amp;gt; array[father])
        {
            swap(array, k, father); // 交换父亲和孩子的数值

            father = k;  // 这里就是查看被调整之后的节点k，是否依然满足最大堆
        }
        else
        {
            break;  // 当前节点不需要被调整
        }
    }
    return;
}

int main(void)
{
    int x[] = {2,5,3,9,7,1,6};
    int len = sizeof(x)/sizeof(int);

    print(x, len); // 先输出原始序列

    // 最大子节点下标为len-1，所以它的父节点是 (len-1-1) / 2
    for (int i = (len - 2)/2; i&amp;gt;=0; i--)
    {
        sort(x, i, len);
    }

    print(x, len); // 输出初始化之后的最大堆

    for (int i=(len-1); i&amp;gt;0; i--)
    {
        swap(x, 0, i);  // 把最大的一个值放到末尾，然后对剩余的数组进行排序
        sort(x, 0, i);
    }
    print(x, len); // 输出排序之后的序列
    return 0;
}

最终输出为：
2 5 3 9 7 1 6 
9 7 6 5 2 1 3 
1 2 3 5 6 7 9 &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 15 Jul 2019 16:26:00 +0000</pubDate>
<dc:creator>努力爬呀爬</dc:creator>
<og:description>这里先简单说下最大堆的基本性质： 最大堆一定是完全二叉树 当父节点为 n 时，左孩子为 n 2 + 1，右孩子为 n 2 + 2 当孩子为 n 时，其父节点为： (n 1) / 2 这一点很重要，在后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/payapa/p/11192303.html</dc:identifier>
</item>
<item>
<title>数据结构-双向链表（Python实现） - 浩然haoran</title>
<link>http://www.cnblogs.com/dongyangblog/p/11192419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongyangblog/p/11192419.html</guid>
<description>&lt;p&gt;数据结构在编程世界中一直是非常重要的一环，不管是开发还是算法，哪怕是单纯为了面试，数据结构都是必修课，今天我们介绍链表中的一种——双向链表的代码实现。&lt;/p&gt;
&lt;p&gt;好了，话不多说直接上代码。&lt;/p&gt;
&lt;h2 id=&quot;双向链表&quot;&gt;双向链表&lt;/h2&gt;
&lt;p&gt;首先，我们定义一个节点类：Node&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
    def getData(self):
        return self.data

    def setData(self, data):
        self.data = data

    def getNext(self):
        return self.next

    def getPrev(self):
        return self.prev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，我们定义了节点类，并实现了获取、修改节点数据、获取上一个/下一个节点的方法。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;node = Node(10)&lt;/code&gt;就可以实例化一个节点啦。&lt;/p&gt;
&lt;p&gt;接下来我们来定义链表类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TwoWayList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.length = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，我们定义了一个链表类，并设置三个属性，head表示头节点，tail表示尾节点，length表示链表长度，接下来，我们给链表类添加一些方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断链表是否为空：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def isEmpty(self):
        return self.head == None&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在链表尾部添加节点：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def append(self, item):
        if self.length == 0:
            node = Node(item)
            self.head = node
            self.tail = node
            self.length = 1
            return
        node = Node(item)
        tail = self.tail
        tail.next = node
        node.prev = tail
        self.tail = node
        self.length += 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加节点的时候，我们首先要判断链表是否为空，另外要注意给原本的尾节点设置next属性，新的尾节点设置prev属性，更新链表的tail和length属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链表中插入节点：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def insert(self, index, item):
        length = self.length
        if (index&amp;lt;0 and abs(index)&amp;gt;length) or (index&amp;gt;0 and index&amp;gt;=length):
            return False
        if index &amp;lt; 0:
            index = index + length
        if index == 0:
            node = Node(item)
            if self.head != None:
                self.head.prev = node
            else:
                self.tail = node
            node.next = self.head
            self.head = node
            self.length += 1
            return True
        if index == length - 1:
            return self.append(item)


        node1 = self.head
        for i in range(0, index):
            node1 = node1.next
        node2 = node1.next

        node = Node(item)
        node.prex = node1
        node.next = node2
        node1.next = node
        node2.prev = node

        self.length += 1
        return True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入节点时候，我们参数为下标index和数据item，我们默认在指定下标的后面插入新节点。&lt;/p&gt;
&lt;p&gt;在这里我们同样要特殊考虑头节点和尾结点的情况。&lt;/p&gt;
&lt;p&gt;在执行插入时先将新节点的next、prev属性指向相应节点，在将前后节点的next和prev指向新节点，同时注意更新链表的length属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据节点数据获取链表上的节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def get(self, data):
        node = self.head
        for i in range(self.length):
            if node.data == data:
                return node
            else:
                node = node.next
        else:
            return False&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;根据下标获取链表上的节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def getByIndex(self, index):
        if index &amp;gt;= self.length:
            return False
        if index == 0:
            return self.head

        now = self.head
        for i in range(self.length):
            if i == index:
                return now
            now = now.next&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新指定下标节点的数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def setData(self, index, data):
        if index &amp;gt;= self.length:
            return False
        if index == 0:
            self.head.data = data

        now = self.head
        for i in range(self.length):
            if i == index:
                now.data = data
                return True
            now = now.next&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除指定下标的节点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def remove(self, index):
        if index &amp;gt;= self.length:
            return False
        if index == 0:
            self.head = self.head.next
            if self.length != 1:
                self.head.prev = None
            self.length -= 1
            return True
        if index == self.length-1:
            self.tail = self.tail.prev
            self.tail.next = None
            self.length -= 1
            return True

        now = self.head
        for i in range(self.length):
            if i == index:
                now.next.prev = now.prev
                now.prev.next = now.next
                self.length -= 1
                return True
            now = now.next&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意要更新length属性，如果删除头节点还要更新head属性，如果删除尾结点要更新tail属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链表翻转&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def reverse(self):
        now = self.head
        last = None
        for i in range(self.length):
            last = now
            now = now.next
            tmp = last.prev
            last.prev = last.next
            last.next = tmp
        tmp = self.head
        self.head = self.tail
        self.tail = tmp
        return True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链表翻转我们不光要更新tail和head属性，还要将每一个节点上的next和prev属性调换。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;清空链表&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def clear(self):
        self.head = None
        self.tail = None
        self.length = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现链表类的__str__方法，定义print()函数打印链表的方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    def __str__(self):
        string = ''
        node = self.head
        for i in range(self.length):
            string += str(node.data) + '/'
            node = node.next
        return string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们让print()函数打印链表时，从头节点开始依次打印每个节点的数据，并用/符号分割。&lt;/p&gt;
&lt;p&gt;好啦，一个双向链表我们就定义好了，并实现了一些操作链表的方法，我们了来测试一下我们定义的链表吧~&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;li = TwoWayList()
li.isEmpty()
li.insert(0, 1)
li.getByIndex(0)
li.remove(0)

print(li)
li.append(1)

print(li)
li.append(2)
print(li)
li.append(4)
print(li)
li.insert(2,3)
print(li)
li.insert(3,4)

print(li)
li.remove(2)
print(li)
li.setData(2,10)
print(li)
li.reverse()
print(li)
print(li.get(2).data)
print(li.getByIndex(1).data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的操作，检查一下你的输出吧，如果你有任何建议欢迎留言告诉我&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jul 2019 15:58:00 +0000</pubDate>
<dc:creator>浩然haoran</dc:creator>
<og:description>数据结构在编程世界中一直是非常重要的一环，不管是开发还是算法，哪怕是单纯为了面试，数据结构都是必修课，今天我们介绍链表中的一种——双向链表的代码实现。 好了，话不多说直接上代码。 双向链表 首先，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongyangblog/p/11192419.html</dc:identifier>
</item>
<item>
<title>python数据库-MongoDB的安装(53) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/11179118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/11179118.html</guid>
<description>
&lt;h3&gt;一、NoSQL介绍&lt;/h3&gt;
&lt;h4&gt;1、什么是NoSQL&lt;/h4&gt;
&lt;p&gt;　　NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;。&lt;/p&gt;
&lt;p&gt;　　NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。&lt;/p&gt;
&lt;p&gt;　　NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。&lt;/p&gt;

&lt;p&gt;　　今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL 数据库的发展却能很好的处理这些大的数据。&lt;/p&gt;

&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;- 高可扩展性&lt;/li&gt;
&lt;li&gt;- 分布式计算&lt;/li&gt;
&lt;li&gt;- 低成本&lt;/li&gt;
&lt;li&gt;- 架构的灵活性，半结构化数据&lt;/li&gt;
&lt;li&gt;- 没有复杂的关系&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;- 没有标准化&lt;/li&gt;
&lt;li&gt;- 有限的查询功能（到目前为止）&lt;/li&gt;
&lt;li&gt;- 最终一致是不直观的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190712222647161-321346840.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二、MongoDB介绍&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。&lt;/li&gt;
&lt;li&gt;在高负载的情况下，添加更多的节点，可以保证服务器性能。&lt;/li&gt;
&lt;li&gt;MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。&lt;/li&gt;
&lt;li&gt;MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190712222849858-409665880.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;主要特点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。&lt;/li&gt;
&lt;li&gt;你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=&quot;Sameer&quot;,Address=&quot;8 Gandhi Road&quot;)来实现更快的排序。&lt;/li&gt;
&lt;li&gt;你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。&lt;/li&gt;
&lt;li&gt;如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。&lt;/li&gt;
&lt;li&gt;Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。&lt;/li&gt;
&lt;li&gt;MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。&lt;/li&gt;
&lt;li&gt;Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。&lt;/li&gt;
&lt;li&gt;Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。&lt;/li&gt;
&lt;li&gt;Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。&lt;/li&gt;
&lt;li&gt;GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。&lt;/li&gt;
&lt;li&gt;MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。&lt;/li&gt;
&lt;li&gt;MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。&lt;/li&gt;
&lt;li&gt;MongoDB安装简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;三、MongoDB下载安装（ubuntu系统）&lt;/h3&gt;
&lt;p&gt;MongoDB 官网地址：&lt;a href=&quot;https://www.mongodb.com/&quot; target=&quot;_blank&quot;&gt;https://www.mongodb.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 官方英文文档：&lt;a href=&quot;https://docs.mongodb.com/manual/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MongoDB 各平台下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center#community&quot; target=&quot;_blank&quot;&gt;https://www.mongodb.com/download-center#community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MongoDB的下载安装，分为windows/mac/linux不同的平台，但是操作大同小异，这里我已linux平台下给大家演示 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190712223451416-1410527645.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、下载好了之后，进入到下载的目录里面解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -zxvf mongodb-linux-x86_64-ubuntu1604-4.0.10.tgz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、在系统文件夹/usr/local里面新建一个文件夹mongodb，将解压好的MongoDB文件夹移动到系统的/usr/local/mongodb里面，也可以不用命令，直接拖拽一样，只不过usr是系统文件夹，需要root用户才能操作，所以使用sudo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:~/Downloads$ sudo mv mongodb-linux-x86_64-ubuntu1604-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt; /usr/local/mongodb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 &lt;strong&gt;PATH&lt;/strong&gt; 路径中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt; export PATH=/usr/local/mongodb/bin:$PATH&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、安装MongoDB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:/usr/local/mongodb/bin$ &lt;strong&gt;sudo apt install mongodb&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、MongoDB后台管理shell&lt;/h3&gt;
&lt;p&gt;如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo命令文件。&lt;/p&gt;
&lt;p&gt;MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。&lt;/p&gt;
&lt;p&gt;当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:&lt;strong&gt;/usr/local/mongodb/bin&lt;/strong&gt;$ &lt;strong&gt;./mongo&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201907/751754-20190712225802361-1090617546.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;做一个简单的插入和查询的测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt; db.hero.insert({h_name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李白&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})   # 插入
WriteResult({ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nInserted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&amp;gt;&lt;span&gt; db.hero.find()    # 查询
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : ObjectId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5d28a0aad9b981703296bede&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;h_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李白&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五、mongoDB创建用户和删除用户&lt;/h3&gt;
&lt;h4&gt;1、创建用户&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.createUser
(
    {
        user:&lt;/span&gt;&amp;lt;name_string&amp;gt;&lt;span&gt;,                      #字符串
    
        pwd:&lt;/span&gt;&amp;lt;password_string&amp;gt;&lt;span&gt;,                 #字符串

        roles:[{role:&lt;/span&gt;&amp;lt;role_name&amp;gt;,db:&amp;lt;db_name&amp;gt;}]     #数组+&lt;span&gt;对象

    }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;user文档字段介绍：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;user字段，为新用户的名字；&lt;/li&gt;
&lt;li&gt;pwd字段，用户的密码； &lt;/li&gt;
&lt;li&gt;cusomData字段，为任意内容，例如可以为用户全名介绍；&lt;/li&gt;
&lt;li&gt;roles字段，指定用户的角色，可以用一个空数组给新用户设定空角色；&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;在roles字段,可以指定内置角色和用户定义的角色。&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt; db.createUser({user:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,pwd:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,roles:[{role:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;readWrite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,db:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]})
Successfully added user: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;roles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;readWrite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    ]
}
&lt;/span&gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:~$ mongo Hero -u &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、删除用户&lt;/h4&gt;
&lt;p&gt;　　db.dropUser(&amp;lt;user_name&amp;gt;)    删除某个用户，接受字符串参数&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
db.dropUser(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　db.dropAllUser()             删除当前库的所有用户&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;六，基于角色的访问控制（Role-Based Access Control）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;角色是授予User在指定资源上执行指定操作的权限，MongoDB官方手册对角色的定义是：&lt;/p&gt;
&lt;p&gt;A role grants privileges to perform the specified actions on resource.&lt;/p&gt;
&lt;p&gt;MongoDB&lt;tt class=&quot;descname&quot;&gt;为了方便管理员管理权限，在DB级别上预先定义了内置角色；如果用户需要对权限进行更为细致的管理，MongoDB允许用户创建自定义的角色，能够在集合级别上控制User能够执行的操作。&lt;br/&gt;&lt;/tt&gt;MongoDB使用角色（Role）授予User访问资源的权限，Role决定User能够访问的数据库资源和执行的操作。一个User能够被授予一个或多个Role，如果User没有被授予Role，那么就没有访问MongoDB系统的权限。&lt;/p&gt;
&lt;p&gt;A user is granted one or more roles that determine the user’s access to database resources and operations. Outside of role assignments, the user has no access to the system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，内置角色（Built-In Roles）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内置角色是MongoDB预定义的角色，操作的资源是在DB级别上。MongoDB拥有一个SuperUser的角色：&lt;tt class=&quot;xref mongodb mongodb-authrole docutils literal&quot;&gt;&lt;strong&gt;root&lt;/strong&gt;，拥有最大权限，能够在系统的所有资源上执行任意操作。&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库用户角色（Database User Roles）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;read：&lt;/strong&gt;授予User只读数据的权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readWrite：&lt;/strong&gt;授予User读写数据的权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;数据库管理角色（Database Administration Roles）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;dbAdmin：&lt;/strong&gt;在当前dB中执行管理操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dbOwner：&lt;/strong&gt;在当前DB中执行任意操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;userAdmin：&lt;/strong&gt;在当前DB中管理User&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;备份和还原角色（Backup and Restoration Roles）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;backup&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;restore&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;跨库角色（All-Database Roles）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;readAnyDatabase：&lt;/strong&gt;授予在所有数据库上读取数据的权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;readWriteAnyDatabase：&lt;/strong&gt;授予在所有数据库上读写数据的权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;userAdminAnyDatabase：&lt;/strong&gt;授予在所有数据库上管理User的权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dbAdminAnyDatabase：&lt;/strong&gt;授予管理所有数据库的权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;集群管理角色（Cluster Administration Roles）：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;clusterAdmin&lt;/strong&gt;：授予管理集群的最高权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clusterManager&lt;/strong&gt;：授予管理和监控集群的权限，A user with this role can access the config and local databases, which are used in sharding and replication, respectively.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clusterMonitor&lt;/strong&gt;：授予监控集群的权限，对监控工具具有readonly的权限&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hostManager&lt;/strong&gt;：管理Server&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3&gt;七、mongoDB的删除&lt;/h3&gt;
&lt;h4&gt;1、ubuntu环境下下载mongoDB&lt;/h4&gt;
&lt;h5 id=&quot;ubuntu12.04上的mongodb卸载-一、卸载只是mongodb&quot;&gt;1.1、卸载只是 mongodb，这将删除只是 mongodb 包本身。&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get&lt;/span&gt; remove mongodb
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;ubuntu12.04上的mongodb卸载-二、卸载mongodb和它的依赖项。&quot;&gt;1.2、卸载 mongodb 和它的依赖项。这将删除 mongodb 软件包和不再需要的任何其依赖包&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get&lt;/span&gt; remove --auto-remove mongodb
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;1.3、清除您的配置数据&lt;/h5&gt;
&lt;p&gt;如果你还想要删除您的本地/config 文件为 mongodb，那么这将工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get&lt;/span&gt; purge mongodb
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;八、mongoDB安装及连接遇到的问题及解决方案&lt;/h3&gt;
&lt;p&gt;　　说明：不同平台下mongoDB同样的问题解决方案不一样，应为windows、linux、mac不同平台下的命令是有差异的，所以大家在网上搜索mongoDB安装和链接的问题的时候最好说明是什么平台下的问题，不然你使用的mac系统，解决搜索出来的是linux下的解决方案也不一样能解决问题。&lt;/p&gt;
&lt;h4 class=&quot;title-article&quot;&gt;1、Failed to start mongod.service: Unit mongod.service not found.（ubuntu）&lt;/h4&gt;
&lt;p&gt;　　1.1、也就是说mongod.service文件没有找到，需要我们手动创建一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]
Description&lt;/span&gt;=High-performance, schema-&lt;span&gt;free&lt;/span&gt; document-&lt;span&gt;oriented database
After&lt;/span&gt;=&lt;span&gt;network.target
Documentation&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;docs.mongodb.org/manual&lt;/span&gt;
&lt;span&gt; 
[Service]
User&lt;/span&gt;=&lt;span&gt;mongodb
Group&lt;/span&gt;=&lt;span&gt;mongodb
ExecStart&lt;/span&gt;=/usr/bin/mongod --quiet --config /etc/&lt;span&gt;mongod.conf
 
[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.2、然后执行 （激活mongod service）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo systemctl enable mongod
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.3、启动、重启和关闭命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo service mongod start
sudo service mongod restart
sudo service mongod stop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、Error: couldn't connect to server 127.0.0.1:27017 src/mongo/shell/mongo.js&lt;/h4&gt;
&lt;p&gt;　　2.1、先看服务启动没有，如果没有启动服务先启动服务：sudo service mongod start&lt;/p&gt;
&lt;p&gt;　　2.2如果服务已经启动了，那有可能是上次不正常关闭mongo,导致存放数据的文件被占用了，被锁住了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:~$ &lt;strong&gt;/usr/local/mongodb&lt;/strong&gt;/bin/mongod --repair  #/usr/local/mongodb是mongo的安装目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:~$ rm -f &lt;strong&gt;/usr/local/data/db&lt;/strong&gt;/mongod.&lt;span&gt;lock  #/usr/locak/data/db 是mongo的数据库文件路径&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.3、如果上一步解决不了，那么就是路径设置有问题，通过重新对路径的设置解决此问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houlei@ubuntu:~$ /usr/local/mongodb/bin/mongod --dbpath=/usr/local/data/db
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3、找不到mongod或者mong命令(mac系统)&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
houleideMacPro:~&lt;span&gt; Se7eN_HOU$ mongod

&lt;/span&gt;-bash: mongod: command not found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案：出现这个问题多数是应为，mongod或者mongo的路径不做PATH里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export MONGO_PATH=/usr/local/&lt;span&gt;mongodb
export PATH&lt;/span&gt;=$PATH:$MONGO_PATH/bin
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 15 Jul 2019 15:55:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、NoSQL介绍 1、什么是NoSQL NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;。 NoSQL，指的是非关系型的数据库。NoSQL有时也称</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/11179118.html</dc:identifier>
</item>
</channel>
</rss>