<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java秒杀系统优化的工程要点 - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11595633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11595633.html</guid>
<description>&lt;p&gt;这篇博客是笔者学习慕课网若鱼老师的《Java秒杀系统方案优化 高性能高并发实战》课程的学习笔记。若鱼老师授课循循善诱，讲解由浅入深，欢迎大家支持。&lt;/p&gt;
&lt;p&gt;本文记录课程中的注意点，方便以后code review。此外，本文将注意点相关的优质讲解链接在了一起，方便初学者系统学习。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文并非单纯介绍秒杀系统特有的技术点，不适合高手。进阶学习的话，极客时间有个不错的小专栏——如何设计一个秒杀系统，阿里高级技术专家讲解秒杀系统的设计要点，那个课程挺干货的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;登录的密码传输&quot;&gt;1. 登录的密码传输：&lt;/h2&gt;
&lt;p&gt;用户的数据库表设计，需要增加一字段保存密码的Salt值&lt;/p&gt;
&lt;p&gt;两次MD5操作(&lt;code&gt;敏感数据一定要使用https协议传输&lt;/code&gt;)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端：将明文password和客户端硬编码的Salt值进行拼接，然后进行MD5操作。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不用盐的话，MD5字符串有可能会被彩虹表或者社工库破解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;服务端：将客户端传过来的MD5字符串和数据库用户对应的Salt字段进行拼接。然后进行MD5操作。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这次加盐MD5，可以有效防止内部员工泄露或者数据库被拖库后，明文密码泄露&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;自定义jsr303的校验器&quot;&gt;2. 自定义JSR303的校验器&lt;/h2&gt;
&lt;p&gt;可以参照javax.validation.constraints.NotNull注解，自定义自己的校验器，将校验代码与业务代码分离。不过由于校验失败会输出BindException异常，所以最好配合全局捕获异常进行友好的输出。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自定义校验器很简单，只需要定义一个注解和对应的校验类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;自定义全局异常捕获&quot;&gt;3. 自定义全局异常捕获&lt;/h2&gt;
&lt;p&gt;使用@ControllerAdvice注解，定义全局的异常捕获，并从异常中获取异常信息解析出来，发送给前端&lt;br/&gt;可以自定义一个GlobalException异常，利用全局异常捕获，将所有服务器处理异常集中处理。（Service层处理异常后不设置状态码，而是直接抛GlobalException全局异常）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不返回状态码的好处是Controller层不需要再繁琐的判断Service层的返回值，代码更简洁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库表设计&quot;&gt;4. 数据库表设计&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过将订单建立唯一索引来保证用户只能创建一个秒杀订单&lt;/li&gt;
&lt;li&gt;商品金额最好以分为单位，比较安全&lt;/li&gt;
&lt;li&gt;商品ID最好不要使用自增，会暴露商品总数等信息。可以使用UUID，但范围查找时会有性能损耗。所以一般采用SnowFlake算法生成ID&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;另外，自增ID的缺点也就是无法在多个表中，或者多个数据库中保持ID主键唯一不重复，所以若是使用分布式数据库以及数据合并的情况下时不能使用自增ID的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码规范&quot;&gt;5. 代码规范&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;更新字段越多，产生的数据库Binlog就越多。所以只更新数据库部分字段的时候，最好新建一个对象，只赋值要更新的字段，然后调用mybatis的@Update，这样不做全量更新可以提高性能&lt;/li&gt;
&lt;li&gt;前端回包使用Result包装类封装，对报错信息使用CodeMsg包装类封装，保持代码风格统一&lt;/li&gt;
&lt;li&gt;Service只注入跟自己同名的dao，如果需要别的dao，请注入对应的Service&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Service的api相比dao会多一些防御代码（例如，直接修改了别的模块dao数据，但缓存未清理），更加安全&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事务&quot;&gt;6. 事务&lt;/h2&gt;
&lt;p&gt;秒杀有两个事务：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减库存-&amp;gt;创建秒杀订单&lt;/li&gt;
&lt;li&gt;创建秒杀订单&lt;br/&gt;秒杀中涉及到上述两个事务，为了保障数据安全，可以使用声明式事务（Spring的@Transactional）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PROPAGATION_REQUIRED是Spring默认的传播机制，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。本工程的场景使用默认事务传播机制即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有关Spring事务传播机制可以查看&lt;a href=&quot;https://www.jianshu.com/p/fab34943c03c&quot;&gt;这篇博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;压测&quot;&gt;7. 压测&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在生产环境中，秒杀系统要独立运行与其他业务系统，实现资源隔离，避免业务系统相互影响稳定性&lt;/li&gt;
&lt;li&gt;请求入口可以使用nginx，LVS，F5等不同的负载均衡器&lt;/li&gt;
&lt;li&gt;Jmeter 随机生成用户数据，然后使用Jmeter模拟用户压测。压测运行环境最好与被测服务器环境隔离。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接口测试可以还使用Postman和ApacheBench&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;页面优化技术&quot;&gt;8. 页面优化技术&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;页面/URL缓存。用于数据变化不频繁的页面或者热点网页。如果数据较多需要分页的数据，类似商品详情数据，一般可以考虑只缓存前两页（根据访问量作取舍）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;缓存方法：将渲染好的html文件存放到Redis。在访问Url时，首先检测Redis是否有html缓存。有缓存的话则直接返回缓存；没有缓存的话则渲染后存入Redis，并返回给前端。页面缓存过期时间具体根据业务场景判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.6315789473684&quot;&gt;
&lt;p&gt;如果需要采用JS/CSS压缩或者减少连接数等方法，可以&lt;a href=&quot;https://www.jianshu.com/p/e664fe534ef9&quot;&gt;使用HTTP2来提升性能&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;对象缓存。例如使用Redis保存Session对象。对象缓存涉及到一个双写一致性问题，有关双写一致性问可以查看&lt;a href=&quot;https://www.jianshu.com/p/a0d8a1dd9bc7&quot;&gt;这篇博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;秒杀的逻辑优化&quot;&gt;9. 秒杀的逻辑优化&lt;/h2&gt;
&lt;p&gt;顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统初始化，把商品库存数量加载到Redis&lt;/li&gt;
&lt;li&gt;收到请求，Redis原子操作预减库存，库存不足，直接返回，否则进入3&lt;/li&gt;
&lt;li&gt;请求入队，立即返回前端“排队中”&lt;/li&gt;
&lt;li&gt;请求出队，生成订单，减少库存（服务端）&lt;/li&gt;
&lt;li&gt;客户端轮询，是否秒杀成功（客户端）和4同步，得到结果刷新结果显示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在第二步预减库存时，可以在内存里加一个map，ID为商品ID，value为是否有库存，这样当库存没有之后，直接通过内存中的值判断是否还有库存，减少对Redis的访问。&lt;/li&gt;
&lt;li&gt;购买请求加入消息队列，异步下单（前端显示排队中），增强用户体验&lt;/li&gt;
&lt;li&gt;前端要尽量减少重复请求&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;安全优化&quot;&gt;10. 安全优化&lt;/h2&gt;
&lt;h3 id=&quot;秒杀接口地址隐藏&quot;&gt;10.1 秒杀接口地址隐藏&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;每次点击秒杀按钮，先从服务器获取动态拼接而成的秒杀地址。&lt;/li&gt;
&lt;li&gt;Redis以缓存用户ID和商品ID为Key，秒杀地址为Value缓存秒杀地址&lt;/li&gt;
&lt;li&gt;用户请求秒杀商品的时候，要带上秒杀地址进行校验&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;数学公式验证码&quot;&gt;10.2 数学公式验证码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;防止恶意脚本抢购&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使请求时间分散&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;接口限流防刷&quot;&gt;10.3 接口限流防刷&lt;/h3&gt;
&lt;p&gt;使用计数法，在拦截器做限制请求频率。利用Redis缓存的有效期（以用户ID拼接Url作为key，以访问次数为value），指定缓存有效期为1秒，访问接口每次将value+1，到达阈值跳转全局异常。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6381909547739&quot;&gt;
&lt;p&gt;优化：使用拦截器+自定义注解，减少对业务代码的侵入。有关拦截器可以查看&lt;a href=&quot;https://www.jianshu.com/p/d0719c1ebfd9&quot;&gt;这篇博客&lt;/a&gt;&lt;br/&gt;另外对于接口限流也可以考虑使用令牌桶，控制对mysql的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，限于笔者经验水平有限，欢迎读者就文中的观点提出宝贵的建议和意见。如果想获得更多的学习资源或者想和更多的技术爱好者一起交流，可以关注我的公众号『全菜工程师小辉』后台回复关键词领取学习资料、进入前后端技术交流群和程序员副业群。同时也可以加入程序员副业群Q群：735764906 一起交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190927085540403-2126635880.gif&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:56:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>这篇博客是笔者学习慕课网若鱼老师的《Java秒杀系统方案优化 高性能高并发实战》课程的学习笔记。若鱼老师授课循循善诱，讲解由浅入深，欢迎大家支持。 本文记录课程中的注意点，方便以后code revie</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11595633.html</dc:identifier>
</item>
<item>
<title>结对编程项目应用开发的收获与总结 - qkuns</title>
<link>http://www.cnblogs.com/qkuns/p/11595630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qkuns/p/11595630.html</guid>
<description>&lt;p&gt;本次结对编程项目是基于我的搭档的个人项目。我负责UI前端编写以及服务器后端，我的搭档负责题目的生成部分的代码。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/qkuns/ATPGS&quot;&gt;https://github.com/qkuns/ATPGS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;尽管结对项目花了一周的时间，事实上只有commit26次。&lt;/p&gt;
&lt;p&gt;一开始我们决定完成一个移动应用，于是使用React-Native作为开发的框架（前端），后端使用php。&lt;/p&gt;
&lt;p&gt;开发平台macOS，运行平台iOS。&lt;/p&gt;

&lt;p&gt;一开始我先列出了项目所有的需求，大概构想出每个需求实现的顺序。然后着手写代码。&lt;/p&gt;
&lt;p&gt;基于以前开发的经验，完成页面的速度很快。但是也有一些失误：&lt;/p&gt;
&lt;p&gt;一开始我认为这个应用的数据在组件中通信不是很多，于是决定开组件的props和页面之间路由进行数据传递。但是到了前端的开发后期，发现组件之间的通信写了很多难以理解的代码。&lt;/p&gt;
&lt;p&gt;如下图，首页这个页面里有一个卡片，卡片上的Tab栏负责输入小学初中高中，下面的四个按钮和一个文本负责输入数量，生成试卷时需要从Tab中获取年级数据，还要从文本中获取数量，文本框的数据还要和按钮绑定……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927083403954-422376792.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写到一半就觉得代码冗余，一开始就应该选用redux进行数据管理的。&lt;/p&gt;
&lt;p&gt;前端的基本没有其他问题了。&lt;/p&gt;

&lt;p&gt;于是开始着手后端和部署服务器了。&lt;/p&gt;
&lt;p&gt;先是简单的学习了一下运维知识，购买了阿里云服务器。熟悉了LAMP的服务器环境下，如何可以从外部访问，怎么部署一个网站。&lt;/p&gt;
&lt;p&gt;然后学习了一点php知识，基本语法以及如何通过php操作数据库。写好了注册功能的后端代码后其他的就不难了。&lt;/p&gt;

&lt;p&gt;后来在前后端对接的时候出现了一点问题。&lt;/p&gt;
&lt;p&gt;前端通过axios传给后端的数据，后端接收不到，无论输入密码是否正确，后端总是返回succeed。&lt;/p&gt;
&lt;p&gt;后来&lt;span&gt;&lt;strong&gt;通过某搜索引擎解决了&lt;/strong&gt;&lt;/span&gt;。axios传的数据类型是json，而php需要接收的是formData。&lt;/p&gt;

&lt;p&gt;完成了这些之后，短信注册功能的验证码难住我了。&lt;/p&gt;
&lt;p&gt;php的学习不够不会使用api以及后端存储session不知道怎么读取，最后也&lt;strong&gt;某搜索引擎&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/span&gt;了……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总的来说这次结对编程项目对我提升挺大的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目成果&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927084703346-1237502492.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;537&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927084947780-1776940424.png&quot; alt=&quot;&quot; width=&quot;268&quot; height=&quot;531&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927084737598-232694914.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;537&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927084812041-952395424.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;533&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927085023264-547057854.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;536&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1810488/201909/1810488-20190927085103661-167162673.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;533&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:54:00 +0000</pubDate>
<dc:creator>qkuns</dc:creator>
<og:description>本次结对编程项目是基于我的搭档的个人项目。我负责UI前端编写以及服务器后端，我的搭档负责题目的生成部分的代码。 项目地址：https://github.com/qkuns/ATPGS 尽管结对项目花了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qkuns/p/11595630.html</dc:identifier>
</item>
<item>
<title>Spring Boot （五）： Redis缓存使用姿势盘点 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11595609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11595609.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190927084830440-899890648.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-简介&quot;&gt;1. Redis 简介&lt;/h2&gt;
&lt;p&gt;Redis 是目前业界使用最广泛的内存数据存储。相比 Memcached，Redis 支持更丰富的数据结构，例如 hashes, lists, sets 等，同时支持数据持久化。除此之外，Redis 还提供一些类数据库的特性，比如事务，HA，主从库。可以说 Redis 兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍 Redis 在 Spring Boot 中两个典型的应用场景。&lt;/p&gt;
&lt;h2 id=&quot;lettuce-简介&quot;&gt;2. Lettuce 简介&lt;/h2&gt;
&lt;p&gt;如果在 Java 应用中使用过 Redis 缓存，那么对 &lt;code&gt;Jedis&lt;/code&gt; 一定不陌生， &lt;code&gt;Lettuce&lt;/code&gt; 和 &lt;code&gt;Jedis&lt;/code&gt; 一样，都是连接 &lt;code&gt;Redis Server&lt;/code&gt; 的客户端程序。&lt;code&gt;Jedis&lt;/code&gt; 在实现上是直连 &lt;code&gt;Redis Server&lt;/code&gt;，多线程环境下非线程安全，除非使用连接池，为每个 &lt;code&gt;Jedis&lt;/code&gt; 实例增加物理连接。 &lt;code&gt;Lettuce&lt;/code&gt; 基于 &lt;code&gt;Netty&lt;/code&gt; 的连接实例（StatefulRedisConnection），可以在多个线程间并发访问，且线程安全，满足多线程环境下的并发访问，同时它是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-应用中使用方式&quot;&gt;3. Spring Boot 应用中使用方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;直接通过 &lt;code&gt;RedisTemplate&lt;/code&gt; 来使用&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;Spring Cache&lt;/code&gt; 集成 &lt;code&gt;Redis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Spring Session&lt;/code&gt; 做 &lt;code&gt;Session&lt;/code&gt; 共享&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工程实战&quot;&gt;4. 工程实战&lt;/h2&gt;
&lt;h3 id=&quot;工程依赖-pom.xml-如下&quot;&gt;4.1 工程依赖 pom.xml 如下：&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-redis/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;spring-boot-starter-data-redis ：在 &lt;code&gt;Spring Boot 2.x&lt;/code&gt; 后底层不再是使用 &lt;code&gt;Jedis&lt;/code&gt; ，而是换成了 &lt;code&gt;Lettuce&lt;/code&gt; ，如图：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;commons-pool2 ： 用作 &lt;code&gt;redis&lt;/code&gt; 连接池，如不引入启动会报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;spring-session-data-redis ： &lt;code&gt;Spring Session&lt;/code&gt; 引入，用作共享 &lt;code&gt;Session&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190927084830596-856835935.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置文件-application.yml&quot;&gt;4.2 配置文件 application.yml&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080
  servlet:
    session:
      timeout: 30m
spring:
  application:
    name: spring-boot-redis
  cache:
    # 使用了Spring Cache后，能指定spring.cache.type就手动指定一下，虽然它会自动去适配已有Cache的依赖，但先后顺序会对Redis使用有影响（JCache -&amp;gt; EhCache -&amp;gt; Redis -&amp;gt; Guava）
    type: REDIS
  redis:
    host: 192.168.0.128
    port: 6379
    password: 123456
    # 连接超时时间（ms）
    timeout: 10000
    # Redis默认情况下有16个分片，这里配置具体使用的分片，默认是0
    database: 0
    lettuce:
      pool:
        # 连接池最大连接数（使用负值表示没有限制） 默认 8
        max-active: 100
        # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1
        max-wait: -1
        # 连接池中的最大空闲连接 默认 8
        max-idle: 8
        # 连接池中的最小空闲连接 默认 0
        min-idle: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的配置不多解释，需要解释的已经标注注释。&lt;/p&gt;
&lt;h3 id=&quot;redistemplate-使用方式&quot;&gt;4.3 RedisTemplate 使用方式&lt;/h3&gt;
&lt;h4 id=&quot;创建实体类-user.java&quot;&gt;4.3.1 创建实体类 User.java&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/model/User.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements Serializable {

    private static final long serialVersionUID = 662692455422902539L;
    private Long id;
    private String name;
    private int age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义-redistemplate&quot;&gt;4.3.2 自定义 RedisTemplate&lt;/h4&gt;
&lt;p&gt;默认情况下的模板只能支持 &lt;code&gt;RedisTemplate&amp;lt;String, String&amp;gt;&lt;/code&gt; ，也就是只能存入字符串，这在开发中是不友好的，所以自定义模板是很有必要的，当自定义了模板又想使用 &lt;code&gt;String&lt;/code&gt; 存储这时候就可以使用 &lt;code&gt;StringRedisTemplate&lt;/code&gt; 的方式，它们并不冲突，添加配置类 &lt;code&gt;RedisCacheConfig.java&lt;/code&gt; ，代码如下：&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/config/RedisCacheConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class RedisCacheConfig {

    @Bean
    public RedisTemplate&amp;lt;String, Serializable&amp;gt; redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String, Serializable&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试接口-usercontroller.java&quot;&gt;4.3.3 测试接口 UserController.java&lt;/h4&gt;
&lt;p&gt;代码清单：&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@Slf4j
public class UserController {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    RedisTemplate&amp;lt;String, Serializable&amp;gt; redisCacheTemplate;

    @Autowired
    UserService userService;

    @GetMapping(&quot;/test&quot;)
    public void test() {
        stringRedisTemplate.opsForValue().set(&quot;geekdigging&quot;, &quot;https://www.geekdigging.com/&quot;);

        log.info(&quot;当前获取对象：{}&quot;,stringRedisTemplate.opsForValue().get(&quot;geekdigging&quot;));

        redisCacheTemplate.opsForValue().set(&quot;geekdigging.com&quot;, new User(1L, &quot;geekdigging&quot;, 18));

        User user = (User) redisCacheTemplate.opsForValue().get(&quot;geekdigging.com&quot;);

        log.info(&quot;当前获取对象：{}&quot;, user);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;4.3.4 测试&lt;/h4&gt;
&lt;p&gt;启动服务，打开浏览器访问链接：http://localhost:8080/test ，查看控制台日志打印，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-09-24 23:49:30.191  INFO 19108 --- [nio-8080-exec-1] c.s.s.controller.UserController          : 当前获取对象：https://www.geekdigging.com/
2019-09-24 23:49:30.243  INFO 19108 --- [nio-8080-exec-1] c.s.s.controller.UserController          : 当前获取对象：User(id=1, name=geekdigging, age=18)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试成功。&lt;/p&gt;
&lt;h3 id=&quot;使用-spring-cache-集成-redis&quot;&gt;4.4 使用 Spring Cache 集成 Redis&lt;/h3&gt;
&lt;h4 id=&quot;spring-cache-特点&quot;&gt;4.4.1 Spring Cache 特点&lt;/h4&gt;
&lt;p&gt;Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 Redis），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。&lt;/p&gt;
&lt;p&gt;Spring Cache 具备相当的好的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache、Redis、Guava 的集成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 annotation 即可使得现有代码支持缓存&lt;/li&gt;
&lt;li&gt;开箱即用 Out-Of-The-Box，不用安装和部署额外第三方组件即可使用缓存&lt;/li&gt;
&lt;li&gt;支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition&lt;/li&gt;
&lt;li&gt;支持 AspectJ，并通过其实现任何方法的缓存支持&lt;/li&gt;
&lt;li&gt;支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定义接口-userservice.java&quot;&gt;4.4.2 定义接口 UserService.java&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/service/UserService.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserService {
    User save(User user);

    User get(Long id);

    void delete(Long id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接口实现-userserviceimpl.java&quot;&gt;4.4.3 接口实现 UserServiceImpl.java&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/service/impl/UserServiceImpl.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
@Slf4j
public class UserServiceImpl implements UserService {

    private static final Map&amp;lt;Long, User&amp;gt; USER_MAP = new HashMap&amp;lt;&amp;gt;();

    static {
        USER_MAP.put(1L, new User(1L, &quot;geekdigging.com&quot;, 18));
        USER_MAP.put(2L, new User(2L, &quot;geekdigging.com&quot;, 19));
        USER_MAP.put(3L, new User(3L, &quot;geekdigging.com&quot;, 20));
    }

    @CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;)
    @Override
    public User save(User user) {
        USER_MAP.put(user.getId(), user);
        log.info(&quot;进入 save 方法，当前存储对象：{}&quot;,  user);
        return user;
    }

    @Cacheable(value = &quot;user&quot;, key = &quot;#id&quot;)
    @Override
    public User get(Long id) {
        log.info(&quot;进入 get 方法，当前获取对象：{}&quot;,  USER_MAP.get(id));
        return USER_MAP.get(id);
    }

    @CacheEvict(value = &quot;user&quot;, key = &quot;#id&quot;)
    @Override
    public void delete(Long id) {
        USER_MAP.remove(id);
        log.info(&quot;进入 delete 方法，删除成功&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便演示数据库操作，直接定义了一个 &lt;code&gt;Map&amp;lt;Long, User&amp;gt; USER_MAP&lt;/code&gt; ，这里的核心就是三个注解 &lt;code&gt;@Cacheable&lt;/code&gt; 、 &lt;code&gt;@CachePut&lt;/code&gt; 、 &lt;code&gt;@CacheEvict&lt;/code&gt; 。&lt;/p&gt;
&lt;h5 id=&quot;cacheable&quot;&gt;4.4.3.1 @Cacheable&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;根据方法的请求参数对其结果进行缓存&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key： 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合（如：&lt;code&gt;@Cacheable(value=&quot;user&quot;,key=&quot;#userName&quot;)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;value： 缓存的名称，必须指定至少一个（如：&lt;code&gt;@Cacheable(value=&quot;user&quot;)&lt;/code&gt; 或者 &lt;code&gt;@Cacheable(value={&quot;user1&quot;,&quot;use2&quot;})&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;condition： 缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存（如：&lt;code&gt;@Cacheable(value = &quot;user&quot;, key = &quot;#id&quot;,condition = &quot;#id &amp;lt; 10&quot;)&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;cacheput&quot;&gt;4.4.3.2 @CachePut&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key： 同上&lt;/li&gt;
&lt;li&gt;value： 同上&lt;/li&gt;
&lt;li&gt;condition： 同上&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;cachevict&quot;&gt;4.4.3.3 @CachEvict&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;根据条件对缓存进行清空&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key： 同上&lt;/li&gt;
&lt;li&gt;value： 同上&lt;/li&gt;
&lt;li&gt;condition： 同上&lt;/li&gt;
&lt;li&gt;allEntries： 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存（如： &lt;code&gt;@CacheEvict(value = &quot;user&quot;, key = &quot;#id&quot;, allEntries = true)&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;beforeInvocation： 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存（如： &lt;code&gt;@CacheEvict(value = &quot;user&quot;, key = &quot;#id&quot;, beforeInvocation = true)&lt;/code&gt; ）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;启动主类&quot;&gt;4.4.4 启动主类&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/SpringBootRedisApplication.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableCaching
public class SpringBootRedisApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootRedisApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里需增加注解 &lt;code&gt;@EnableCaching&lt;/code&gt; 开启 Spring Session。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;增加测试接口&quot;&gt;4.4.5 增加测试接口&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/controller/UserController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(&quot;/test1&quot;)
public void test1() {
    User user = userService.save(new User(4L, &quot;geekdigging.com&quot;, 35));

    log.info(&quot;当前 save 对象：{}&quot;, user);

    user = userService.get(1L);

    log.info(&quot;当前 get 对象：{}&quot;, user);

    userService.delete(5L);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试-1&quot;&gt;4.4.6 测试&lt;/h4&gt;
&lt;p&gt;启动服务，打开浏览器访问链接：http://localhost:8080/test ，刷新页面，控制台日志打印如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-09-25 00:07:21.887  INFO 21484 --- [nio-8080-exec-1] c.s.s.service.impl.UserServiceImpl       : 进入 save 方法，当前存储对象：User(id=4, name=geekdigging.com, age=35)
2019-09-25 00:07:21.897  INFO 21484 --- [nio-8080-exec-1] c.s.s.controller.UserController          : 当前 save 对象：User(id=4, name=geekdigging.com, age=35)
2019-09-25 00:07:21.899  INFO 21484 --- [nio-8080-exec-1] c.s.s.service.impl.UserServiceImpl       : 进入 get 方法，当前获取对象：User(id=1, name=geekdigging.com, age=18)
2019-09-25 00:07:21.900  INFO 21484 --- [nio-8080-exec-1] c.s.s.controller.UserController          : 当前 get 对象：User(id=1, name=geekdigging.com, age=18)
2019-09-25 00:07:21.901  INFO 21484 --- [nio-8080-exec-1] c.s.s.service.impl.UserServiceImpl       : 进入 delete 方法，删除成功&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次刷新页面，查看控制台日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2019-09-25 00:08:54.076  INFO 21484 --- [nio-8080-exec-7] c.s.s.service.impl.UserServiceImpl       : 进入 save 方法，当前存储对象：User(id=4, name=geekdigging.com, age=35)
2019-09-25 00:08:54.077  INFO 21484 --- [nio-8080-exec-7] c.s.s.controller.UserController          : 当前 save 对象：User(id=4, name=geekdigging.com, age=35)
2019-09-25 00:08:54.079  INFO 21484 --- [nio-8080-exec-7] c.s.s.controller.UserController          : 当前 get 对象：User(id=1, name=geekdigging.com, age=18)
2019-09-25 00:08:54.079  INFO 21484 --- [nio-8080-exec-7] c.s.s.service.impl.UserServiceImpl       : 进入 delete 方法，删除成功&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果和我们期望的一致，可以看到增删改查中，查询是没有日志输出的，因为它直接从缓存中获取的数据，而添加、修改、删除都是会进入 &lt;code&gt;UserServiceImpl&lt;/code&gt; 的方法内执行具体的业务代码。&lt;/p&gt;
&lt;h3 id=&quot;session-共享&quot;&gt;4.5 Session 共享&lt;/h3&gt;
&lt;h4 id=&quot;spring-session-简介&quot;&gt;4.5.1 Spring Session 简介&lt;/h4&gt;
&lt;p&gt;Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案。Spring Session 提供了集群 Session（Clustered Sessions）功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。&lt;/p&gt;
&lt;h4 id=&quot;启动主类-springbootredisapplication.java&quot;&gt;4.5.2 启动主类 SpringBootRedisApplication.java&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/SpringBootRedisApplication.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableCaching
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)
public class SpringBootRedisApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootRedisApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;maxInactiveIntervalInSeconds: 设置 Session 失效时间，使用 Spring Session 之后，原 Spring Boot 配置文件 &lt;code&gt;application.yml&lt;/code&gt; 中的 &lt;code&gt;server.session.timeout&lt;/code&gt; 属性不再生效。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;增加测试接口-1&quot;&gt;4.5.3 增加测试接口&lt;/h4&gt;
&lt;p&gt;代码清单：spring-boot-redis/src/main/java/com/springboot/springbootredis/controller/UserController.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(&quot;/getBlogUrl&quot;)
public String getSessionId(HttpServletRequest request) {
    String url = (String) request.getSession().getAttribute(&quot;url&quot;);
    if (StringUtils.isEmpty(url)) {
        request.getSession().setAttribute(&quot;url&quot;, &quot;https://www.geekdigging.com/&quot;);
    }
    log.info(&quot;获取session内容为： {}&quot;, request.getSession().getAttribute(&quot;url&quot;));
    return request.getRequestedSessionId();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试-2&quot;&gt;4.5.4 测试&lt;/h4&gt;
&lt;p&gt;启动服务，打开浏览器访问链接：http://localhost:8080/getBlogUrl ，查看 Redis 当前存储内容，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201909/908359-20190927084830739-2136745678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 1569339180000 为失效时间，意思是这个时间后 Session 失效， b2522824-1094-478e-a435-554a551bc8bb 为 SessionId 。&lt;/p&gt;
&lt;h4 id=&quot;如何在多台服务中共享-session&quot;&gt;4.5.6 如何在多台服务中共享 Session&lt;/h4&gt;
&lt;p&gt;按照上面的步骤在另一个项目中再次配置一次，启动后自动就进行了 Session 共享。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;5. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/spring-boot-examples/tree/master/spring-boot-redis&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/spring-boot-examples/tree/master/spring-boot-redis&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;http://emacoo.cn/backend/spring-redis/&lt;br/&gt;https://blog.battcn.com/2018/05/11/springboot/v2-nosql-redis/&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:49:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. Redis 简介 Redis 是目前业界使用最广泛的内存数据存储。相比 Memcached，Redis 支持更丰富的数据结构，例如 hashes, lists, sets 等，同时支持数据持久化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11595609.html</dc:identifier>
</item>
<item>
<title>net core WebApi——定时任务Quartz - AprilBlank</title>
<link>http://www.cnblogs.com/AprilBlank/p/11595603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AprilBlank/p/11595603.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;本来打算昨天都开始写这篇，就因为要把小团队的博客整理汇总，一看二哈的博客那么多，一个个复制粘贴肯定麻烦（其实是我自己觉得复制麻烦），所以穿插着写了个小爬虫，后续写差不多了就拿出来晾晾吧（py菜鸡水平）。&lt;/p&gt;
&lt;p&gt;之前开发的时候，忽略了记录，等到想写点儿啥跟后台有关的东西的时候，还得一点点回忆，最近是因为同事给我说，&quot;哎，每个月把数据给我统计下做个界面展示啊&quot;。一想到每个月我要做次操作就头疼，咦，不对，这不就是写个&lt;strong&gt;定时任务&lt;/strong&gt;就搞定了嘛。&lt;/p&gt;
&lt;h3 id=&quot;quartz&quot;&gt;Quartz&lt;/h3&gt;
&lt;p&gt;其实在选这个定时器的类库的时候，我在&lt;strong&gt;Hangfire&lt;/strong&gt;两者间徘徊，后来是想到不管用什么方法什么工具都是次要的，主要看你怎么用，用到哪，图形界面是需要但不是必要，分秒级别的控制也都是看你自己业务需要，定时器就后台挂起运行就行了没必要让我看见，想操作了再说吧，就这样愉快的决定使用&lt;strong&gt;Quartz&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，依然是在我们Util的工程引入包。&lt;/p&gt;
&lt;p&gt;引入完成后，在我们的入口Startup中添加实例的注册声明。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public IServiceProvider ConfigureServices(IServiceCollection services)
        {
            ServiceInjection.ConfigureRepository(services);

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            //任务调度
            services.TryAddSingleton&amp;lt;ISchedulerFactory, StdSchedulerFactory&amp;gt;();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SchedulerFactory&lt;/strong&gt;任务调度就好比一个公司的老大，&lt;strong&gt;Trigger&lt;/strong&gt;就是一个项管，&lt;strong&gt;Job&lt;/strong&gt;就是苦逼的码农，老大想要一天搞个app，就跟项管说一句，我要一天后要东西，这时候项管心里就有数了，一天后的那个时间，找到码农，直接剥夺他的代码执行，好了app出来了，苦逼的结束并不意味着真的结束，这老大一看可以啊，好了，以后每天我要一个成品app，如此循环往复，项管不厌其烦，码农换了又换（当然job不会）。&lt;/p&gt;
&lt;p&gt;项管还会有多个，每个项管下面可不止一个码农。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;像这样的情况可能有些夸张，但是类似的情况却真实存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok，完了之后，我们来创建一个&lt;strong&gt;MyJob&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class MyJob : IJob
    {
        public Task Execute(IJobExecutionContext context)
        {
            return Task.Run(() =&amp;gt;
            {
                LogUtil.Debug(&quot;执行MyJob&quot;);
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后我们来写个简单的&lt;strong&gt;QuartzUtil&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    public class QuartzUtil
    {
        private static ISchedulerFactory _schedulerFactory;
        private static IScheduler _scheduler;

        /// &amp;lt;summary&amp;gt;
        /// 添加任务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;类&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;jobKey&quot;&amp;gt;键&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;trigger&quot;&amp;gt;触发器&amp;lt;/param&amp;gt;
        public static async void Add(Type type, JobKey jobKey, ITrigger trigger = null)
        {
            Init();
            _scheduler = await _schedulerFactory.GetScheduler();

            await _scheduler.Start();

            if (trigger == null)
            {
                trigger = TriggerBuilder.Create()
                    .WithIdentity(&quot;april.trigger&quot;)
                    .WithDescription(&quot;default&quot;)
                    .WithSimpleSchedule(x=&amp;gt;x.WithMisfireHandlingInstructionFireNow().WithRepeatCount(-1))
                    .Build();
            }
            var job = JobBuilder.Create(type)
                .WithIdentity(jobKey)
                .Build();

            await _scheduler.ScheduleJob(job, trigger);          
        }
        /// &amp;lt;summary&amp;gt;
        /// 恢复任务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;jobKey&quot;&amp;gt;键&amp;lt;/param&amp;gt;
        public static async void Resume(JobKey jobKey)
        {
            Init();
            _scheduler = await _schedulerFactory.GetScheduler();
            LogUtil.Debug($&quot;恢复任务{jobKey.Group},{jobKey.Name}&quot;);
            await _scheduler.ResumeJob(jobKey);
        }
        /// &amp;lt;summary&amp;gt;
        /// 停止任务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;jobKey&quot;&amp;gt;键&amp;lt;/param&amp;gt;
        public static async void Stop(JobKey jobKey)
        {
            Init();
            _scheduler = await _schedulerFactory.GetScheduler();
            LogUtil.Debug($&quot;暂停任务{jobKey.Group},{jobKey.Name}&quot;);
            await _scheduler.PauseJob(jobKey);
        }
        /// &amp;lt;summary&amp;gt;
        /// 初始化
        /// &amp;lt;/summary&amp;gt;
        private static void Init()
        {
            if (_schedulerFactory == null)
            {
                _schedulerFactory = AprilConfig.ServiceProvider.GetService&amp;lt;ISchedulerFactory&amp;gt;();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;触发器的使用，有很多种方式，可以使用简单的执行一次/多久执行一次/循环执行几次等等。&lt;/p&gt;
&lt;p&gt;还有可以使用&lt;strong&gt;Cron&lt;/strong&gt;表达式：&lt;/p&gt;
&lt;p&gt;简单来说，&lt;strong&gt;corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份&lt;/strong&gt;，举个例子，就像开头说的，让我每隔一个月执行一次统计，写法就是 0 0 0 1 * ?，当然这就有涉及到什么符号的问题了，这种不需要强记，需要的时候查下就行，推荐一个工具站吧，&lt;a href=&quot;http://www.bejson.com/othertools/cronvalidate/&quot;&gt;Cron校验工具&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;感觉我的博客内容好单调，内容框架就是开头，代码，测试，结尾，唉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过做啥东西，测试少不了，最起码你的东西能用，才说明可行。&lt;/p&gt;
&lt;p&gt;我们在&lt;strong&gt;Values&lt;/strong&gt;添加一个方法，这里我们5s一执行（懒得等）。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        [HttpGet]
        [Route(&quot;QuartzTest&quot;)]
        public void QuartzTest(int type)
        {
            JobKey jobKey = new JobKey(&quot;demo&quot;,&quot;group1&quot;);
            switch (type)
            {
                //添加任务
                case 1:
                    var trigger = TriggerBuilder.Create()
                            .WithDescription(&quot;触发器描述&quot;)
                            .WithIdentity(&quot;test&quot;)
                            //.WithSchedule(CronScheduleBuilder.CronSchedule(&quot;0 0/30 * * * ? *&quot;).WithMisfireHandlingInstructionDoNothing())
                            .WithSimpleSchedule(x=&amp;gt;x.WithIntervalInSeconds(5).RepeatForever().WithMisfireHandlingInstructionIgnoreMisfires())
                            .Build();
                    QuartzUtil.Add(typeof(MyJob), jobKey, trigger);
                    break;
                //暂停任务
                case 2:
                    QuartzUtil.Stop(jobKey);
                    break;
                //恢复任务
                case 3:
                    QuartzUtil.Resume(jobKey);
                    break;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们来愉快的运行吧，记得appsettings配置个路径访问白名单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1757809/201909/1757809-20190927084307665-34991371.png&quot; alt=&quot;测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一番1，2，3输入完之后，我们来看下日志。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1757809/201909/1757809-20190927084319660-1413258683.png&quot; alt=&quot;测试&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行任务--- ok&lt;/li&gt;
&lt;li&gt;暂停任务--- ok&lt;/li&gt;
&lt;li&gt;恢复任务--- ok&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;问题及解决方法&quot;&gt;问题及解决方法&lt;/h3&gt;
&lt;p&gt;但是问题出现了，暂停恢复后，连执行了多次（具体看你间隔时间以及你的频率），这个是有点儿怪异，当时我记得这个问题让我鼓捣了好半天，也是各种查资料查方法，但实际呢这个是Quartz的保护机制，为了防止你的操作是因为不可预知的问题导致的，所以有个重做错过的任务，另外我们的代码中触发器也有这个配置&lt;strong&gt;WithMisfireHandlingInstructionIgnoreMisfires&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来去掉这个重做机制并测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1757809/201909/1757809-20190927084330701-212130157.png&quot; alt=&quot;测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CronTrigger&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionDoNothing&lt;/td&gt;
&lt;td&gt;不触发立即执行; 等待下次Cron触发频率到达时刻开始按照Cron频率依次执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionIgnoreMisfires&lt;/td&gt;
&lt;td&gt;以错过的第一 个频率时间立刻开始执行; 重做错过的所有频率周期后; 当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionFireAndProceed&lt;/td&gt;
&lt;td&gt;以当前时间为触发频率立刻触发一次执行; 然后按照Cron频率依次执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;SimpleTrigger&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionFireNow&lt;/td&gt;
&lt;td&gt;以当前时间为触发频率立即触发执行; 执行至FinalTIme的剩余周期次数;以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到; 调整后的FinalTime会略大于根据starttime计算的到的FinalTime值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionIgnoreMisfires&lt;/td&gt;
&lt;td&gt;以错过的第一个频率时间立刻开始执行; 重做错过的所有频率周期;当下一次触发频率发生时间大于当前时间以后，按照Interval的依次执行剩下的频率; 共执行RepeatCount+1次&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionNextWithExistingCount&lt;/td&gt;
&lt;td&gt;不触发立即执行; 等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数; 以startTime为基准计算周期频率，并得到FinalTime; 即使中间出现pause，resume以后保持FinalTime时间不变&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionNowWithExistingCount&lt;/td&gt;
&lt;td&gt;以当前时间为触发频率立即触发执行; 执行至FinalTIme的剩余周期次数; 以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到; 调整后的FinalTime会略大于根据starttime计算的到的FinalTime值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionNextWithRemainingCount&lt;/td&gt;
&lt;td&gt;不触发立即执行; 等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数; 以startTime为基准计算周期频率，并得到FinalTime; 即使中间出现pause，resume以后保持FinalTime时间不变&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;withMisfireHandlingInstructionNowWithRemainingCount&lt;/td&gt;
&lt;td&gt;以当前时间为触发频率立即触发执行; 执行至FinalTIme的剩余周期次数; 以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到; 调整后的FinalTime会略大于根据starttime计算的到的FinalTime值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;配置规则介绍参考：&lt;a href=&quot;https://blog.csdn.net/yangshangwei/article/details/78539433&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/yangshangwei/article/details/78539433&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前在net framework遇到过一个问题，IIS回收问题，网站在20分钟无请求后就停了，任务也紧跟着停了，当时的解决方法是做个windows服务来定时请求网站保持活跃，当然也可以通过禁止回收来保持网站一直运行。&lt;/p&gt;
&lt;p&gt;net core中还没部署运行，如果有相关问题，后续也会补充上来一起交流解决。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;定时任务在一个后台系统中一般使用场景还算广泛，主要是sql数据统计，sql/文件备份，定时推送等，具体问题具体分析，&lt;strong&gt;net core 3.0&lt;/strong&gt;都已经问世了，学无止境啊。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:44:00 +0000</pubDate>
<dc:creator>AprilBlank</dc:creator>
<og:description>[toc] 前言 本来打算昨天都开始写这篇，就因为要把小团队的博客整理汇总，一看二哈的博客那么多，一个个复制粘贴肯定麻烦（其实是我自己觉得复制麻烦），所以穿插着写了个小爬虫，后续写差不多了就拿出来晾晾</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AprilBlank/p/11595603.html</dc:identifier>
</item>
<item>
<title>阿里巴巴 Sentinel  + InfluxDB + Chronograf 实现监控大屏 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/11595596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/11595596.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190927083839469-1144667076.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇推文中，我们使用时序数据库 &lt;code&gt;InfluxDb&lt;/code&gt; 做了流控数据存储，但是数据存储不是目的，分析监控预警才是最终目标，那么问题来了，如何更好的实现呢？用过阿里巴巴 Sentinel 控制台的小伙伴，是不是觉得它的控制台丑爆了，而且只有短短的五厘米，显然不能满足大部分人或者场景的使用。&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190927083849043-856646444.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;工具&quot;&gt;工具&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;sentinel-dashboard（控制台，收集数据）&lt;/li&gt;
&lt;li&gt;Influxdb（时序数据库，存储数据）&lt;/li&gt;
&lt;li&gt;Chronograf （展示控制台，显示数据并实现预警）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;Sentinel 控制台 和 时序数据库 Influxdb 的安装方式前面已经聊过，这里不再赘述，简单说下 Chronograf 展示控制台的安装方式，这里推荐使用 Docker 安装方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run -p 8888:8888 \
      -v $PWD:/var/lib/chronograf \
      chronograf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装成功以后，浏览器访问 &lt;code&gt;http://ip:8888&lt;/code&gt; 你应该看到一个欢迎页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190927083857055-474897022.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，自行配置数据源，根据业务场景组装监控大屏。&lt;/p&gt;
&lt;h2 id=&quot;大屏&quot;&gt;大屏&lt;/h2&gt;
&lt;p&gt;这里根据 Sentinel 限流组件采集的数据，组装了一个简单的监控大屏，可以监控历史访问总量、最近一小时的访问量、限流数以及最近几分钟或者几小时的访问曲线等等，相比于阿里演示版是不是瞬间高大上的些许。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201909/109211-20190927083904867-904956113.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总访问量&quot;&gt;总访问量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;successQps&quot;) AS &quot;总访问量&quot; FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最近一小时访问量&quot;&gt;最近一小时访问量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;successQps&quot;) AS &quot;访问量&quot;
FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;
WHERE TIME &amp;gt; NOW() - 1h&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最近一小时限流数&quot;&gt;最近一小时限流数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;blockQps&quot;) AS &quot;限流数&quot;
FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;
WHERE time &amp;gt; now() - 1h&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最近一小时异常数&quot;&gt;最近一小时异常数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;exceptionQps&quot;) AS &quot;异常数&quot;
FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;
WHERE time &amp;gt; now() - 1h&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最近一小时的访问趋势图秒级别&quot;&gt;最近一小时的访问趋势图(秒级别)&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;successQps&quot;) AS &quot;访问量&quot;
FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;
WHERE time &amp;gt; now() - 1h
GROUP BY time(1s)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;最近12小时资源访问排名&quot;&gt;最近12小时资源访问排名&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SUM(&quot;successQps&quot;) AS &quot;成功qps&quot;, SUM(&quot;blockQps&quot;) AS &quot;限流qps&quot;
FROM &quot;sentinel_log&quot;.&quot;autogen&quot;.&quot;sentinelInfo&quot;
WHERE time &amp;gt; now() - 12h
GROUP BY resource&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;预警&quot;&gt;预警&lt;/h2&gt;
&lt;p&gt;后期我们在 Chronograf 中接入 Kapacitor ，Chronograf会自动打开该Configure Alert Endpoints部分，Kapacitor支持多个警报端点/事件处理程序。有兴趣的小伙伴也可以在 Sentinel 控制台中根据流控数据进行更智能化的设置，比如根据限流失败数以及机器指标动态调整流控规则。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;有了她，小哥哥、小姐姐们再也不用担心凌晨一点的闹钟了，是不是很爽？以上只是冰山一角，目前我们上线的监控系统平台，通过各种第三方组件库（&lt;code&gt;Telegraf、InfluxDB、Chronograf、Kapacitor、Grafana、Prometheus、Consul、Elasticsearch、Kibana&lt;/code&gt;），接入了 1000 台服务器实时监控，200个监控大屏，上千个监控指标，每日处理成吨的数据。是不是很吊！？我唧唧都佩服我自己的想象力。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/52itstyle/sentinel-dashboard&quot; class=&quot;uri&quot; title=&quot;https://gitee.com/52itstyle/sentinel-dashboard&quot;&gt;https://gitee.com/52itstyle/sentinel-dashboard&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/chronograf&quot; class=&quot;uri&quot;&gt;https://hub.docker.com/_/chronograf&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:40:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<og:description>前言 在上一篇推文中，我们使用时序数据库 做了流控数据存储，但是数据存储不是目的，分析监控预警才是最终目标，那么问题来了，如何更好的实现呢？用过阿里巴巴 Sentinel 控制台的小伙伴，是不是觉得它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smallSevens/p/11595596.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 3.0 : 二十四. 配置的Options模式 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore_24.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore_24.html</guid>
<description>&lt;p&gt;上一章讲到了配置的用法及内部处理机制，对于配置，ASP.NET Core还提供了一种Options模式。(&lt;a href=&quot;https://www.cnblogs.com/FlyLolo/p/ASPNETCore2_0.html&quot;&gt;ASP.NET Core 系列目录&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;上一章有个配置的绑定的例子，可以将配置绑定到一个Theme实例中。也就是在使用对应配置的时候，需要进行一次绑定操作。而Options模式提供了更直接的方式，并且可以通过依赖注入的方式提供配置的读取。&lt;strong&gt;下文中称每一条Options配置为Option。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1.简单的不为Option命名的方式&lt;/h2&gt;
&lt;p&gt;依然采用这个例子，在appsettings.json中存在这样的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0921DC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改一下ValueController，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IOptions&amp;lt;Theme&amp;gt; _options = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValuesController(IOptions&amp;lt;Theme&amp;gt;&lt;span&gt; options)
    {
        _options &lt;/span&gt;=&lt;span&gt; options;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContentResult GetOptions()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ContentResult() { Content = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;options:{ _options.Value.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依然需要在Startup文件中做注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services.Configure&lt;/span&gt;&amp;lt;Theme&amp;gt;(Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Theme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

        services.AddControllersWithViews();  //3.0中启用的新方法
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;请求这个Action，获取到的结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
options:Blue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以在需要使用该配置的时候通过依赖注入的方式使用了。但有个疑问，这里将“Theme”类型绑定了这样的配置，但如果有多个这样的配置呢？就如同下面这样的配置的时候：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Themes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#0921DC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#FF4500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这样的情况下，存在多个Theme的配置，这样对于之前这种依赖注入的方式就不行了。这时系统提供了将注入的Options进行命名的方法。&lt;/p&gt;
&lt;h2&gt;2.为Option命名的方式&lt;/h2&gt;
&lt;p&gt;首先需要在Startup文件中注册的时候对其命名，添加如下两条注册代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.Configure&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeBlue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Themes:0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
services.Configure&lt;/span&gt;&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeRed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Themes:1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改ValueController代码，添加IOptionsMonitor&amp;lt;Theme&amp;gt;和IOptionsSnapshot&amp;lt;Theme&amp;gt;两种新的注入方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; IOptions&amp;lt;Theme&amp;gt; _options = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IOptionsMonitor&amp;lt;Theme&amp;gt; _optionsMonitor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IOptionsSnapshot&amp;lt;Theme&amp;gt; _optionsSnapshot = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValuesController(IOptions&amp;lt;Theme&amp;gt; options, IOptionsMonitor&amp;lt;Theme&amp;gt; optionsMonitor, IOptionsSnapshot&amp;lt;Theme&amp;gt;&lt;span&gt; optionsSnapshot)
        {
            _options &lt;/span&gt;=&lt;span&gt; options;
            _optionsMonitor &lt;/span&gt;=&lt;span&gt; optionsMonitor;
            _optionsSnapshot &lt;/span&gt;=&lt;span&gt; optionsSnapshot;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContentResult GetOptions()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ContentResult() { Content = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;options:{_options.Value.Name},&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsSnapshot:{ _optionsSnapshot.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeBlue&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Name },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsMonitor:{_optionsMonitor.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeRed&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求这个Action，获取到的结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
options:Blue,optionsSnapshot:Red,optionsMonitor:Gray
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新增的两种注入方式通过Options的名称获取到了对应的Options。为什么是两种呢？它们有什么区别？不知道有没有读者想到上一章配置的重新加载功能。在配置注册的时候，有个reloadOnChange选项，如果它被设置为true的，当对应的数据源发生改变的时候，会进行重新加载。而Options怎么能少了这样的特性呢。&lt;/p&gt;
&lt;h2&gt;3.Option的自动更新与生命周期&lt;/h2&gt;
&lt;p&gt;为了验证这三种Options的读取方式的特性，修改Theme类，添加一个Guid字段，并在构造方法中对其赋值，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Theme
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Theme()
    {
        Guid &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Guid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Color { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改上例中的名为GetOptions的Action的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContentResult GetOptions()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentResult()
    {
        Content &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;options:{_options.Value.Name}|{_options.Value.Guid},&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
        $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsSnapshot:{ _optionsSnapshot.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeBlue&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Name }|{_optionsSnapshot.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeBlue&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Guid},&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
        $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optionsMonitor:{_optionsMonitor.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeRed&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Name}|{_optionsMonitor.Get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;ThemeRed&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Guid}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求这个&lt;span lang=&quot;EN-US&quot;&gt;Action，返回结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
options:Blue|ad328f15-254f-&lt;span&gt;4505&lt;/span&gt;-a79f-4f27db4a393e,optionsSnapshot:Red|dba5f550-29ca-&lt;span&gt;4779&lt;/span&gt;-9a02-781dd17f595a,optionsMonitor:Gray|a799fa41-&lt;span&gt;9444&lt;/span&gt;-45dd-b51b-fcd15049f98f
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新页面，返回结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
options:Blue|ad328f15-254f-&lt;span&gt;4505&lt;/span&gt;-a79f-4f27db4a393e,optionsSnapshot:Red|a2350cb3-c156-4f71-bb2d-25890fe08bec,optionsMonitor:Gray|a799fa41-&lt;span&gt;9444&lt;/span&gt;-45dd-b51b-fcd15049f98f
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见IOptions和IOptionsMonitor两种方式获取到的Name值和Guid值均未改变，而通过IOptionsSnapshot方式获取到的Name值未改变，但Guid值发生了改变，每次刷新页面均会改变。这类似前面讲依赖注入时做测试的例子，现在猜测Guid未改变的IOptions和IOptionsMonitor两种方式是采用了Singleton模式，而Guid发生改变的IOptionsSnapshot方式是采用了Scoped或Transient模式。如果在这个Action中多次采用IOptionsSnapshot读取_optionsSnapshot.Get(&quot;ThemeBlue&quot;).Guid的值，会发现同一次请求的值是相同的，不同请求之间的值是不同的，也就是IOptionsSnapshot方式使采用了Scoped模式（此验证示例比较简单，请读者自行修改代码验证）。&lt;/p&gt;
&lt;p&gt;在这样的情况下，修改三种获取方式对应的配置项的Name值，例如分别修改为“Blue1”、“Red1”和“Gray1”，再次多次刷新页面查看返回值，会发现如下情况：&lt;/p&gt;
&lt;p&gt;IOptions方式：Name和Guid的值始终未变。Name值仍为Blue。&lt;/p&gt;
&lt;p&gt;IOptionsSnapshot方式：Name值变为Red1，Guid值单次请求内相同，每次刷新之间不同。&lt;/p&gt;
&lt;p&gt;IOptionsMonitor方式：只有修改配置值后第一次刷新的时候将Name值变为了Gray1，Guid未改变。之后多次刷新，这两个值均未做改变。&lt;/p&gt;
&lt;p&gt;总结：IOptions和IOptionsMonitor两种方式采用了Singleton模式，但区别在于IOptionsMonitor会监控对应数据源的变化，如果发生了变化则更新实例的配置值，但不会重新提供新的实例。IOptionsSnapshot方式采用了Scoped模式每次请求采用同一个实例，在下一次请求的时候获取到的是一个新的实例，所以如果数据源发生了改变，会读取到新的值。先大概记一下这一的情况，在下文剖析IOptions的内部处理机制的时候就会明白为什么会这样。&lt;/p&gt;
&lt;h2&gt;4.数据更新提醒&lt;/h2&gt;
&lt;p&gt;IOptionsMonitor方式还提供了一个OnChange方法，当数据源发生改变的时候会触发它，所以如果想在这时候做点什么，可以利用这个方法实现。示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_optionsMonitor.OnChange((theme,name)=&amp;gt; { Console.WriteLine(theme.Name +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ name); });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.不采用Configuration配置作为数据源的方式&lt;/h2&gt;
&lt;p&gt;上面的例子都是采用了读取配置的方式，实际上Options模式和上一章的Configuration配置方式使分开的，读取配置只不过是Options模式的一种实现方式，例如可以不使用Configuration中的数据，直接通过如下代码注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
services.Configure&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeBlack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, theme =&amp;gt;&lt;span&gt; {
    theme.Color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    theme.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.ConfigureAll方法&lt;/h2&gt;
&lt;p&gt;系统提供了一个ConfigureAll方法，可以将所有对应的实例统一设置。例如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
services.ConfigureAll&amp;lt;Theme&amp;gt;(theme =&amp;gt;&lt;span&gt; {
     theme.Color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     theme.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时无论通过什么名称去获取Theme的实例，包括不存在对应设置的名称，获取到的值都是本次通过ConfigureAll设置的值。&lt;/p&gt;
&lt;h2&gt;7.PostConfigure和PostConfigureAll方法&lt;/h2&gt;
&lt;p&gt;这两个方法和Configure、ConfigureAll方法类似，只是它们会在Configure、ConfigureAll之后执行。&lt;/p&gt;
&lt;h2&gt;8.多个Configure、ConfigureAll、PostConfigure和PostConfigureAll的执行顺序&lt;/h2&gt;
&lt;p&gt;可以这样理解，每个Configure都是去修改一个名为其设置的名称的变量，以如下代码为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
services.Configure&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeBlack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, theme =&amp;gt;&lt;span&gt; {
    theme.Color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    theme.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条设置就是去修改（注意是修改而不是替换）一个名为&quot;ThemeBlack&quot;的Theme类型的变量，如果该变量不存在，则创建一个Theme实例并赋值。这样就生成了一些变量名为“空字符串、“ThemeBlue”、“ThemeBlack”的变量（只是举例，忽略空字符串作为变量名不合法的顾虑）”。&lt;/p&gt;
&lt;p&gt;依次按照代码的顺序执行，这时候如果后面的代码中出现同名的Configure，则修改对应名称的变量的值。如果是ConfigureAll方法，则修改所有类型为Theme的变量的值。&lt;/p&gt;
&lt;p&gt;而PostConfigure和PostConfigureAll则在Configure和ConfigureAll之后执行，即使Configure的代码写在了PostConfigure之后也是一样。&lt;/p&gt;
&lt;p&gt;至于为什么会是这样的规则，下一节会详细介绍。&lt;/p&gt;

&lt;h2&gt;1. 系统启动阶段，依赖注入&lt;/h2&gt;
&lt;p&gt;上一节的例子中涉及到了三个接口IOptions、IOptionsSnapshot和IOptionsMonitor，那么就从这三个接口说起。既然Options模式是通过这三个接口的泛型方式注入提供服务的，那么在这之前系统就需要将它们对应的实现注入到依赖注入容器中。这发生在系统启动阶段创建IHost的时候，这时候HostBuilder的Build方法中调用了一个services.AddOptions()方法，这个方法定义在OptionsServiceCollectionExtensions中，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionsServiceCollectionExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddOptions(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
            }

            services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptions&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsManager&amp;lt;&amp;gt;&lt;span&gt;)));
            services.TryAdd(ServiceDescriptor.Scoped(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsSnapshot&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsManager&amp;lt;&amp;gt;&lt;span&gt;)));
            services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsMonitor&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsMonitor&amp;lt;&amp;gt;&lt;span&gt;)));
            services.TryAdd(ServiceDescriptor.Transient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsFactory&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsFactory&amp;lt;&amp;gt;&lt;span&gt;)));
            services.TryAdd(ServiceDescriptor.Singleton(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IOptionsMonitorCache&amp;lt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(OptionsCache&amp;lt;&amp;gt;&lt;span&gt;)));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
            =&amp;gt;&lt;span&gt; services.Configure(Options.Options.DefaultName, configureOptions);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; configureOptions)
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略非空验证代码&lt;/span&gt;
&lt;span&gt;
            services.AddOptions();
            services.AddSingleton&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, configureOptions));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection ConfigureAll&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;TOptions&amp;gt; configureOptions) &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;
            =&amp;gt; services.Configure(name: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, configureOptions: configureOptions);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见这个AddOptions方法的作用就是进行服务注入，IOptions&amp;lt;&amp;gt;、IOptionsSnapshot&amp;lt;&amp;gt;对应的实现是OptionsManager&amp;lt;&amp;gt;，只是分别采用了Singleton和Scoped两种生命周期模式，IOptionsMonitor&amp;lt;&amp;gt;对应的实现是OptionsMonitor&amp;lt;&amp;gt;，同样为Singleton模式，这也验证了上一节例子中的猜想。除了上面提到的三个接口外，还有IOptionsFactory&amp;lt;&amp;gt;和IOptionsMonitorCache&amp;lt;&amp;gt;两个接口，这也是Options模式中非常重要的两个组成部分，接下来的内容中会用到。&lt;/p&gt;
&lt;p&gt;另外的两个Configure方法就是上一节例子中用到的将具体的Theme注册到Options中的方法了。二者的区别就是是否为配置的option命名，而第一个Configure方法就未命名的方法，通过上面的代码可知它实际上是传入了一个默认的Options.Options.DefaultName作为名称，这个默认值是一个空字符串，也就是说，未命名的Option相当于是被命名为空字符串。最终都是按照已命名的方式也就是第二个Configure方法进行处理。还有一个ConfigureAll方法，它是传入了一个null作为Option的名称，也是交由第二个Configure处理。&lt;/p&gt;
&lt;p&gt;在第二个Configure方法中仍调用了一次AddOptions方法，然后才是将具体的类型进行注入。AddOptions方法中采用的都是TryAdd方法进行注入，已被注入的不会被再次注入。接下来注册了一个IConfigureOptions&amp;lt;TOptions&amp;gt;接口，对应的实现是ConfigureNamedOptions&amp;lt;TOptions&amp;gt;(name, configureOptions)，它的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigureNamedOptions&amp;lt;TOptions&amp;gt; : IConfigureNamedOptions&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConfigureNamedOptions(&lt;span&gt;string&lt;/span&gt; name, Action&amp;lt;TOptions&amp;gt;&lt;span&gt; action)
    {
        Name &lt;/span&gt;=&lt;span&gt; name;
        Action &lt;/span&gt;=&lt;span&gt; action;
}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;TOptions&amp;gt; Action { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, TOptions options)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (options == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(options));
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Null name is used to configure all named options.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (Name == &lt;span&gt;null&lt;/span&gt; || name ==&lt;span&gt; Name)
        {
            Action&lt;/span&gt;?&lt;span&gt;.Invoke(options);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(TOptions options) =&amp;gt;&lt;span&gt; Configure(Options.DefaultName, options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它在构造方法中存储了配置的名称（Name）和创建方法（Action），它的两个Configure方法用于在获取Options的值的时候执行对应的Action来创建实例（例如示例中的Theme）。在此时不会被执行。所以在此会出现3中类型的ConfigureNamedOptions，分别是Name值为具体值的、Name值为为空字符串的和Name值为null的。这分别对应了第一节的例子中的为Option命名的Configure方法、不为Option命名的Configure方法、以及ConfigureAll方法。&lt;/p&gt;
&lt;p&gt;此处用到的OptionsServiceCollectionExtensions和ConfigureNamedOptions对应的是通过代码直接注册Option的方式，例如第一节例子中的如下方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.Configure&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeBlack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, theme =&amp;gt; { &lt;span&gt;new&lt;/span&gt; Theme { Color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是以Configuration作为数据源的方式，例如如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.Configure&amp;lt;Theme&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThemeBlue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Themes:0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用到的是OptionsServiceCollectionExtensions和ConfigureNamedOptions这两个类的子类，分别为OptionsConfigurationServiceCollectionExtensions和NamedConfigureFromConfigurationOptions两个类，通过它们的名字也可以知道是专门用于采用Configuration作为数据源用的，代码类似，只是多了一条关于IOptionsChangeTokenSource的依赖注入，作用是将Configuration的关于数据源变化的监听和Options的关联起来，当数据源发生改变的时候可以及时更新Options中的值，主要的Configure方法代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection Configure&amp;lt;TOptions&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, &lt;span&gt;string&lt;/span&gt; name, IConfiguration config, Action&amp;lt;BinderOptions&amp;gt;&lt;span&gt; configureBinder)
    &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略验证代码&lt;/span&gt;
&lt;span&gt;
    services.AddOptions();
    services.AddSingleton&lt;/span&gt;&amp;lt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; ConfigurationChangeTokenSource&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, config));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; services.AddSingleton&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; NamedConfigureFromConfigurationOptions&amp;lt;TOptions&amp;gt;&lt;span&gt;(name, config, configureBinder));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样还有PostConfigure和PostConfigureAll方法，和Configure、ConfigureAll方法类似，只不过注入的类型为IPostConfigureOptions&amp;lt;TOptions&amp;gt;。&lt;/p&gt;
&lt;h2&gt;2. Options值的获取&lt;/h2&gt;
&lt;p&gt;Option值的获取也就是从依赖注入容器中获取相应实现的过程。通过依赖注入阶段，已经知道了IOptions&amp;lt;&amp;gt;和IOptionsSnapshot&amp;lt;&amp;gt;对应的实现是OptionsManager&amp;lt;&amp;gt;，就以OptionsManager&amp;lt;&amp;gt;为例看一下依赖注入后的服务提供过程。OptionsManager&amp;lt;&amp;gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsManager&amp;lt;TOptions&amp;gt; : IOptions&amp;lt;TOptions&amp;gt;, IOptionsSnapshot&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptionsFactory&amp;lt;TOptions&amp;gt;&lt;span&gt; _factory;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; OptionsCache&amp;lt;TOptions&amp;gt; _cache = &lt;span&gt;new&lt;/span&gt; OptionsCache&amp;lt;TOptions&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsManager(IOptionsFactory&amp;lt;TOptions&amp;gt;&lt;span&gt; factory)
    {
        _factory &lt;/span&gt;=&lt;span&gt; factory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TOptions Value
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Get(Options.DefaultName);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; TOptions Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        name &lt;/span&gt;= name ??&lt;span&gt; Options.DefaultName;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.GetOrAdd(name, () =&amp;gt;&lt;span&gt; _factory.Create(name));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它有IOptionsFactory&amp;lt;TOptions&amp;gt;和OptionsCache&amp;lt;TOptions&amp;gt;两个重要的成员。如果直接获取Value值，实际上是调用的另一个Get(string name)方法，传入了空字符串作为name值。所以最终值的获取还是在缓存中读取，这里的代码是_cache.GetOrAdd(name, () =&amp;gt; _factory.Create(name))，即如果缓存中存在对应的值，则返回，如果不存在，则由_factory去创建。OptionsFactory&amp;lt;TOptions&amp;gt;的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsFactory&amp;lt;TOptions&amp;gt; : IOptionsFactory&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _setups;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _postConfigures;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IValidateOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _validations;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsFactory(IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; setups, IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; postConfigures) : &lt;span&gt;this&lt;/span&gt;(setups, postConfigures, validations: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsFactory(IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; setups, IEnumerable&amp;lt;IPostConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt; postConfigures, IEnumerable&amp;lt;IValidateOptions&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; validations)
    {
        _setups &lt;/span&gt;=&lt;span&gt; setups;
        _postConfigures &lt;/span&gt;=&lt;span&gt; postConfigures;
        _validations &lt;/span&gt;=&lt;span&gt; validations;
}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TOptions Create(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TOptions();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; setup &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _setups)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setup &lt;span&gt;is&lt;/span&gt; IConfigureNamedOptions&amp;lt;TOptions&amp;gt;&lt;span&gt; namedSetup)
            {
                namedSetup.Configure(name, options);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (name ==&lt;span&gt; Options.DefaultName)
            {
                setup.Configure(options);
            }
        }
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; post &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _postConfigures)
        {
            post.PostConfigure(name, options);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_validations != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; failures = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; validate &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _validations)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; validate.Validate(name, options);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Failed)
                {
                    failures.AddRange(result.Failures);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (failures.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OptionsValidationException(name, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TOptions), failures);
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; options;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要看它的TOptions Create(string name)方法。这里会遍历它的_setups集合，这个集合类型为IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;&amp;gt;，在讲Options模式的依赖注入的时候已经知道，每一个Configure、ConfigureAll实际上就是向依赖注入容器中注册了一个IConfigureOptions&amp;lt;TOptions&amp;gt;，只是名称可能不同。而PostConfigure和PostConfigureAll方法注册的是IPostConfigureOptions&amp;lt;TOptions&amp;gt;类型，对应的就是_postConfigures集合。&lt;/p&gt;
&lt;p&gt;首先会遍历_setups集合，调用IConfigureOptions&amp;lt;TOptions&amp;gt;的Configure方法，这个方法的主要代码就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;if&lt;/span&gt; (Name == &lt;span&gt;null&lt;/span&gt; || name ==&lt;span&gt; Name)
 {
      Action&lt;/span&gt;?&lt;span&gt;.Invoke(options);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果Name值为null，即对应的是ConfigureAll方法，则执行该Action。或者Name值和需要读取的值相同，则执行该Action。&lt;/p&gt;
&lt;p&gt;_setups集合遍历之后，同样的机制遍历_postConfigures集合。这就是上一节关于Configure、ConfigureAll、PostConfigure和PostConfigureAll的执行顺序的验证。&lt;/p&gt;
&lt;p&gt;最终返回对应的实例并写入缓存。这就是IOptions和IOptionsSnapshot两种模式的处理机制，接下来看一下IOptionsMonitor模式，它对应的实现是OptionsMonitor。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptionsMonitor&amp;lt;TOptions&amp;gt; : IOptionsMonitor&amp;lt;TOptions&amp;gt; &lt;span&gt;where&lt;/span&gt; TOptions : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptionsMonitorCache&amp;lt;TOptions&amp;gt;&lt;span&gt; _cache;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IOptionsFactory&amp;lt;TOptions&amp;gt;&lt;span&gt; _factory;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IEnumerable&amp;lt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&amp;gt;&lt;span&gt; _sources;
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; Action&amp;lt;TOptions, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; _onChange;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OptionsMonitor(IOptionsFactory&amp;lt;TOptions&amp;gt; factory, IEnumerable&amp;lt;IOptionsChangeTokenSource&amp;lt;TOptions&amp;gt;&amp;gt; sources, IOptionsMonitorCache&amp;lt;TOptions&amp;gt;&lt;span&gt; cache)
    {
        _factory &lt;/span&gt;=&lt;span&gt; factory;
        _sources &lt;/span&gt;=&lt;span&gt; sources;
        _cache &lt;/span&gt;=&lt;span&gt; cache;

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; source &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _sources)
        {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; registration =&lt;span&gt; ChangeToken.OnChange(
                      () &lt;/span&gt;=&amp;gt;&lt;span&gt; source.GetChangeToken(),
                      (name) &lt;/span&gt;=&amp;gt;&lt;span&gt; InvokeChanged(name),
                      source.Name);

                _registrations.Add(registration);        
}
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InvokeChanged(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        name &lt;/span&gt;= name ??&lt;span&gt; Options.DefaultName;
        _cache.TryRemove(name);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; Get(name);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_onChange != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            _onChange.Invoke(options, name);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TOptions CurrentValue
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; Get(Options.DefaultName);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; TOptions Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        name &lt;/span&gt;= name ??&lt;span&gt; Options.DefaultName;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cache.GetOrAdd(name, () =&amp;gt;&lt;span&gt; _factory.Create(name));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDisposable OnChange(Action&amp;lt;TOptions, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; listener)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; disposable = &lt;span&gt;new&lt;/span&gt; ChangeTrackerDisposable(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, listener);
        _onChange &lt;/span&gt;+=&lt;span&gt; disposable.OnChange;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; disposable;
    }

    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChangeTrackerDisposable : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Action&amp;lt;TOptions, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; _listener;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; OptionsMonitor&amp;lt;TOptions&amp;gt;&lt;span&gt; _monitor;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChangeTrackerDisposable(OptionsMonitor&amp;lt;TOptions&amp;gt; monitor, Action&amp;lt;TOptions, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; listener)
        {
            _listener &lt;/span&gt;=&lt;span&gt; listener;
            _monitor &lt;/span&gt;=&lt;span&gt; monitor;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnChange(TOptions options, &lt;span&gt;string&lt;/span&gt; name) =&amp;gt;&lt;span&gt; _listener.Invoke(options, name);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; _monitor._onChange -=&lt;span&gt; OnChange;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分功能和OptionsManager类似，只是由于它是采用了Singleton模式，所以它是采用监听数据源改变并更新的模式。当通过Configuration作为数据源注册Option的时候，多了一条IOptionsChangeTokenSource的依赖注入。当数据源发生改变的时候更新数据并触发OnChange(Action&amp;lt;TOptions, string&amp;gt; listener)，在第一节的数据更新提醒中有相关的例子。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Sep 2019 00:38:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>上一章讲到了配置的用法及内部处理机制，对于配置，ASP.NET Core还提供了一种Options模式。(ASP.NET Core 系列目录) 一、Options的使用 上一章有个配置的绑定的例子，可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FlyLolo/p/ASPNETCore_24.html</dc:identifier>
</item>
<item>
<title>StackOverflow 第四周周报及19年就业情况分析 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11595248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11595248.html</guid>
<description>&lt;p&gt;&lt;span&gt;这是 Stack Overflow 第四周周报，两篇 Java、两篇 Python。公众号&lt;strong&gt;「渡码」&lt;/strong&gt;为日更，欢迎关注。另外，我搜集了今年的就业数据，对招聘情况和岗位情况做了简单总结，想了解的朋友点&lt;a href=&quot;https://www.cnblogs.com/duma/p/11577982.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;DAY1. 枚举对象 == 和 equals 区别&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们在比较枚举常量时可以使用 == 运算符或者 equals 方法，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnumEquals {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FRUITS  {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 苹果 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        APPLE,
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 橙子 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ORANGE
    }&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; equalApple(FRUITS fruit) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fruit ==&lt;span&gt; FRUITS.APPLE) {
            System.out.println(&lt;/span&gt;&quot;equals&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fruit.equals(FRUITS.APPLE)) {
            System.out.println(&lt;/span&gt;&quot;equals&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;先考虑第一个问题：为什么可以用 == 判断枚举常量相等？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道判断对象的相等应该用 equals 方法，== 只是判断对象的引用是否相等，枚举常量能够使用 == 判断相等是因为枚举常量除了定义时初始化的对象外，没有其他实例。例如：常量 APPLE 在定义时已经初始化，并且运行时不会再有其他的 APPLE 枚举常量。根据 JLS 文档，Java 通过以下四点保证枚举常量不存在定义之外的实例&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;试图显式实例化枚举类型是编译时错误，例如：new FRUITS()&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Enum 类中的 clone 方法确保永远不能克隆Enum常量，看看 clone 方法可以看到直接抛出 CloneNotSupportedException 异常&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;序列化机制的特殊处理确保不会因为反序列化而创建重复的实例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;禁止枚举类型的反射实例化&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因为枚举常量只有一个实例，因此可以直接用 == 判断枚举实例的相等。如果我们看下 equals 源码就可以发现它也是用 == 进行判断，所以我们考虑第二个问题：使用 == 和 equals 的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;== 不会抛出 NullPointerException 异常， 而 equals 会&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;== 的类型不匹配在编译时检查，而 equals 不检查&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnumEquals {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FRUITS  {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 苹果 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        APPLE,
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 橙子 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ORANGE
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; SIZE {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SMALL,
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        MIDDLE,
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 大 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        LARGE
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        FRUITS fruit &lt;/span&gt;=&lt;span&gt; FRUITS.APPLE;
        fruit &lt;/span&gt;==&lt;span&gt; SIZE.SMALL;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因此使用 == 相比 equals 有以下优势：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;更快&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运行时更安全&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编译时更安全&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/1750435/comparing-java-enum-members-or-equals&lt;/p&gt;
&lt;p&gt;https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.9&lt;/p&gt;
&lt;h2&gt;DAY2. 用 Python 复制文件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们都知道 Python 库非常强大，通常我们想实现一个功能基本都找到现成的库。今天我们就介绍 Python 标准库中的一个模块 —— shutil ，该模块中定义了文件复制的方法。如：复制一个文件，直接调一个函数即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
src = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
dst &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

shutil.copyfile(src, dst)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除了该函数， shutil 模块还定义了其他的函数提供文件复制的功能，但是细节略有不同，对比如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201909/1129006-20190919222600494-12166977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中 copy2 复制的比较全面，估计性能也是比较低的。下面简单举两个例子对比一下不同函数的区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 目的路径是否是目录，copyfile vs copy2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
src = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.rar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
dst &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

shutil.copyfile(src, dst)
shutil.copy2(src, dst)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 是否能复制 meta 数据，copyfile vs copy2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
src = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.rar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
dst &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test1.rar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

shutil.copyfile(src, dst)
shutil.copy2(src, dst)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看文件的 meta 信息，copyfile 复制的文件的更新时间是最新的， 而 copy2 复制的文件更新时间与源文件一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里只举这两个例子，如对其他函数感兴趣可自行尝试。另外，shutil 模块应该还有其他更方便的函数可以供我们使用。总之使用 Python 开发效率还是挺高的，掌握 Python 确实能提高工作效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/123198/how-do-i-copy-a-file-in-python&lt;/p&gt;
&lt;h2&gt;DAY3. 什么是 Java Bean&lt;/h2&gt;
&lt;div id=&quot;img-content&quot; readability=&quot;47.5&quot;&gt;
&lt;p&gt;&lt;span&gt;从学 Java web 开发起，我们就知道有 Java Bean 这个东西。但对于我来说，因为我毕业后一直做大数据，讲真我确实不知道 Java Bean 的正式定义。下面我们一起看看符合什么要求才叫 Java Bean ：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;rich_media_content&quot;&gt;&lt;span&gt;所有的属性是 private，提供 getter 和 setter 设置属性&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;rich_media_content&quot;&gt;&lt;span&gt;有一个 public 无参构造函数&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;rich_media_content&quot;&gt;&lt;span&gt;实现 Serializable 接口&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Java Bean 其实是一种规范。对于我们学知识来说，往往想问为什么 Java Bean 定义这样的规范。对照上面三点，我的思考是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;getter/setter 方法为了对外暴露属性的读写接口，方便框架调用。同时，属性用 private 修饰可以提高安全性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;之前的文章看过 Hadoop 框架反射的例子， public 无参构造可以很方便框架通过反射创建类实例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于 web 框架通常需要数据传输，因此需要对象具有序列化与反序列化的能力&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们今天这篇文章比较简短，只是简单介绍了一下 Java Bean 规范的定义，并且谈了谈我自己的一些思考。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;rich_media_content&quot; readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly&lt;/p&gt;
&lt;h2&gt;DAY3. Python 中实现 switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 我们都知道 Python 原生语法中不支持 switch 语句。当然 Python 这么灵活的语法，我们自己实现一个也比较容易。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt;,
  }[x]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样实现稍微有些不完备，没有默认值，且如果参数不在字典中会报错。我们更新一版如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt;
  }.get(x, &lt;/span&gt;9)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样实现看起来比较理想了，我们还可以用 Lambda 表达式实现复杂计算，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f3(x):
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;lambda&lt;/span&gt; x: x * 5&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;lambda&lt;/span&gt; x: x + 7&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;lambda&lt;/span&gt; x: x - 2&lt;span&gt;
  }.get(x, &lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x: x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用 Python 实现 switch 语句还是非常方便的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;猜测 Python 原生之所以不支持 switch 语法是因为 Python 语言本身已经很灵活了，不需要额外提供 switch 语句增加语言本身的臃肿。真是应了那句话，人生苦短，我用 Python&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 27 Sep 2019 00:34:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>这是 Stack Overflow 第四周周报，两篇 Java、两篇 Python。公众号「渡码」为日更，欢迎关注。另外，我搜集了今年的就业数据，对招聘情况和岗位情况做了简单总结，想了解的朋友点这里。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11595248.html</dc:identifier>
</item>
<item>
<title>单元测试框架Uinttest一文详解 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/11593345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/11593345.html</guid>
<description>&lt;p&gt;一谈及unittest，大家都知道，unittest是Python中自带的单元测试框架，它里面封装好了一些校验返回的结果方法和一些用例执行前的初始化操作。unittest单元测试框架不仅可以适用于单元测试，还可以适用web自动化测试用例的开发与执行，该测试框架可组织执行测试用例，并且提供了丰富的断言方法，判断测试用例是否通过，最终生成测试结果。&lt;/p&gt;
&lt;p&gt;在聊unittest时，需要先明白，最基础的四个概念：TestCase，TestSuite，TestRunner，TestFixture，看如下静态图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190926173248239-656207142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;unittest运行流程&lt;/h3&gt;
&lt;p&gt;先编写好TestCase，然后由TestLoader加载TestCase到TestSuite，其次由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。&lt;/p&gt;
&lt;h3&gt;unittest模块的各个属性说明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;unittest.TestCase&lt;/strong&gt;：TestCase类，所有测试用例类继承的基本类。&lt;/p&gt;
&lt;pre&gt;
class BaiduTest(unittest.TestCase):
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;unittest.main()&lt;/strong&gt;：使用它可以方便的将一个单元测试模块变为可直接运行的测试脚本，main()方法使用TestLoader类来搜索所有包含在该模块中以“test”命名开头的测试方法，并自动执行他们。执行方法的默认顺序是：根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。所以以A开头的测试用例方法会优先执行，以a开头会后执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unittest.TestSuite()&lt;/strong&gt;：unittest框架的TestSuite()类是用来创建测试套件的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unittest.TextTextRunner()&lt;/strong&gt;：unittest框架的TextTextRunner()类，通过该类下面的run()方法来运行suite所组装的测试用例，入参为suite测试套件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unittest.defaultTestLoader()&lt;/strong&gt;： defaultTestLoader()类，通过该类下面的discover()方法可自动更具测试目录start_dir匹配查找测试用例文件（test*.py），并将查找到的测试用例组装到测试套件，因此可以直接通过run()方法执行discover。用法如下：&lt;/p&gt;
&lt;pre&gt;
discover=unittest.defaultTestLoader.discover(test_dir, pattern='test_*.py')
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;unittest.skip()&lt;/strong&gt;：装饰器，当运行用例时，有些用例可能不想执行等，可用装饰器暂时屏蔽该条测试用例。一种常见的用法就是比如说想调试某一个测试用例，想先屏蔽其他用例就可以用装饰器屏蔽。&lt;/p&gt;
&lt;p&gt;@unittest.skip(reason)： skip(reason)装饰器：无条件跳过装饰的测试，并说明跳过测试的原因。&lt;/p&gt;
&lt;p&gt;@unittest.skipIf(reason)：skipIf(condition,reason)装饰器：条件为真时，跳过装饰的测试，并说明跳过测试的原因。&lt;/p&gt;
&lt;p&gt;@unittest.skipUnless(reason)：skipUnless(condition,reason)装饰器：条件为假时，跳过装饰的测试，并说明跳过测试的原因。&lt;/p&gt;
&lt;p&gt;@unittest.expectedFailure()：expectedFailure()测试标记为失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUp()&lt;/strong&gt;：setUp()方法用于每个测试用例执行前的初始化工作。如测试用例中需要访问数据库，可以在setUp中建立数据库连接并进行初始化。如测试用例需要登录web，可以先实例化浏览器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tearDown()&lt;/strong&gt;：tearDown()方法用于每个测试用例执行之后的善后工作。如关闭数据库连接、关闭浏览器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUpClass()&lt;/strong&gt;：setUpClass()方法用于所有测试用例前的设置工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tearDownClass()&lt;/strong&gt;：tearDownClass()方法用于所有测试用例执行后的清理工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;addTest()&lt;/strong&gt;：addTest()方法是将测试用例添加到测试套件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;run()&lt;/strong&gt;：run()方法是运行测试套件的测试用例，入参为suite测试套件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;assert*()&lt;/strong&gt;：在执行测试用例的过程中，最终用例是否执行通过，是通过判断测试得到的实际结果和预期结果是否相等决定的。&lt;/p&gt;
&lt;p&gt;断言方式如下：&lt;/p&gt;
&lt;p&gt;assertEqual(a,b，[msg='测试失败时打印的信息']):断言a和b是否相等，相等则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertNotEqual(a,b，[msg='测试失败时打印的信息']):断言a和b是否相等，不相等则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertTrue(x，[msg='测试失败时打印的信息'])：断言x是否True，是True则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertFalse(x，[msg='测试失败时打印的信息'])：断言x是否False，是False则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertIs(a,b，[msg='测试失败时打印的信息']):断言a是否是b，是则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertNotIs(a,b，[msg='测试失败时打印的信息']):断言a是否是b，不是则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertIsNone(x，[msg='测试失败时打印的信息'])：断言x是否None，是None则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertIsNotNone(x，[msg='测试失败时打印的信息'])：断言x是否None，不是None则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertIn(a,b，[msg='测试失败时打印的信息'])：断言a是否在b中，在b中则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertNotIn(a,b，[msg='测试失败时打印的信息'])：断言a是否在b中，不在b中则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertIsInstance(a,b，[msg='测试失败时打印的信息'])：断言a是是b的一个实例，是则测试用例通过。&lt;/p&gt;
&lt;p&gt;assertNotIsInstance(a,b，[msg='测试失败时打印的信息'])：断言a是是b的一个实例，不是则测试用例通过。&lt;/p&gt;
&lt;p&gt;说了这么多的属性，接下来用一段代码举例：&lt;/p&gt;
&lt;p&gt;unittest基本代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittestbasic1.unittest_operation &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_basic.py
@time: 2019-09-26 23:38
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMathFunc(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TestCase基类方法,所有case执行之前自动执行&lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUpClass(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*************这里是所有测试用例前的准备工作*************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TestCase基类方法,所有case执行之后自动执行&lt;/span&gt;
&lt;span&gt;    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDownClass(cls):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*************这里是所有测试用例后的清理工作*************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TestCase基类方法,每次执行case前自动执行&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------这里是一个测试用例前的准备工作-------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TestCase基类方法,每次执行case后自动执行&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------这里是一个测试用例后的清理工作-------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @unittest.skip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我想临时跳过这个测试用例.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_add(self):
        self.assertEqual(&lt;/span&gt;3, add(1, 2&lt;span&gt;))
        self.assertNotEqual(&lt;/span&gt;3, add(2, 2))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试业务方法add&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_minus(self):
        self.skipTest(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;跳过这个测试用例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.assertEqual(&lt;/span&gt;1, minus(3, 2))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试业务方法minus&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_multi(self):
        self.assertEqual(&lt;/span&gt;6, multi(2, 3))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试业务方法multi&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_divide(self):
        self.assertEqual(&lt;/span&gt;2, divide(6, 3))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试业务方法divide&lt;/span&gt;
        self.assertEqual(2.5, divide(5, 2&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main(verbosity&lt;/span&gt;=2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(a, b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; minus(a, b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a-&lt;span&gt;b


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; multi(a, b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a*&lt;span&gt;b


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; divide(a, b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a/b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行代码，结果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190926232015827-1058634962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;理论加实践，结合起来看，应该更容易明白些，切莫做纸上谈兵。&lt;/p&gt;
&lt;h3&gt;添加用例运行方式&lt;/h3&gt;
&lt;p&gt;弄明白了unittest的基本属性，接下来分享下添加用例运行的不同方式&lt;/p&gt;
&lt;h4&gt;方式一：使用addTests单个添加&lt;/h4&gt;
&lt;p&gt;用addTests方法单个添加用例，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittestbasic2.unittest_operation2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TestMathFunc

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite1.py
@time: 2019-09-26 23:38
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单个添加测试用例&lt;/span&gt;
    suite.addTest(TestMathFunc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_multi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suite.addTest(TestMathFunc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_divide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    runner &lt;/span&gt;= unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(suite)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;方式二：测试用例添加到用例集中&lt;/h4&gt;
&lt;p&gt;从方法一种看，单个添加用例比较麻烦，该方法可以将用例添加到一个用例集中，再通过suite统一运行，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittestbasic2.unittest_operation2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TestMathFunc

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite2.py
@time: 2019-09-26 23:38
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将测试用例添加到一个用例集中&lt;/span&gt;
    tests = [TestMathFunc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), TestMathFunc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_minus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    suite.addTests(tests)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将测试用例列表添加到测试组中&lt;/span&gt;
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(suite)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;方式三：TestLoader方法加载用例&lt;/h4&gt;
&lt;p&gt;使用TestLoader方法加载用例，就是无法对case进行排序，执行顺序是随机的。实现方法有如下三种，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittestbasic2.unittest_operation2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TestMathFunc

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite3.py
@time: 2019-09-26 23:44
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一种方法：传入'模块名.TestCase名'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用addTests + TestLoader。不过用TestLoader的方法是无法对case进行排序的&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; loadTestsFromName()，传入'模块名.TestCase名'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; suite.addTests(unittest.TestLoader().loadTestsFromName('unittest_operation2.TestMathFunc'))&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; suite.addTests(unittest.TestLoader().loadTestsFromName('unittest_operation1.TestMathFunc'))&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里还可以把'模块名.TestCase名'放到一个列表中&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ②&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; suite.addTests(unittest.TestLoader().loadTestsFromNames(['unittest_operation2.TestMathFunc', 'unittest_operation1.TestMathFunc']))&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二种方法：传入TestCase 需要导入对应模块&lt;/span&gt;
&lt;span&gt;    suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc))
    runner &lt;/span&gt;= unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(suite)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;方式四：通过discover()方法&lt;/h4&gt;
&lt;p&gt;看了前三种实现方式，都比较单一，实际运用中，case数量不仅仅只有一两个，一个一个去添加的话，那得多麻烦。故而引用discover()方法，匹配指定文件夹下以test开头的测试用例，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite4.py
@time: 2019-09-26 23:46
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./testcase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    all_cases &lt;/span&gt;= unittest.defaultTestLoader.discover(path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到某个目录下所有的以test开头的Python文件里面的测试用例&lt;/span&gt;
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(all_cases)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所述，就是常见的用例执行方式了，不过，运用最多的还是最后一种方式。&lt;/p&gt;
&lt;h3&gt;测试报告&lt;/h3&gt;
&lt;p&gt;在做测试时，自然是要生成测试报告的，一份好的测试报告，可以很直观的看出当前代码构建的系统状况，也可以帮助自己很快定位问题。&lt;/p&gt;
&lt;p&gt;前段时间，在github上搜索到一份带截图的测试报告模板，所以引用使用了一番，整体很不错，自己也略小有调整，将报告模板引用到代码中即可使用。&lt;/p&gt;
&lt;p&gt;说到测试报告，再使用之前的代码，就实现不了，需要引用HTMLTestRunner。我一般使用html格式的报告，还有一种是xml格式的，使用jenkins构建代码的话，那就需要生成xml格式的测试报告了。&lt;/p&gt;
&lt;h4&gt;html格式测试报告&lt;/h4&gt;
&lt;p&gt;先来看如何生成html格式的测试报告，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.HTMLTestRunner_cn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTMLTestRunner
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite5.py
@time: 2019-09-26 23:58
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./testcase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    report_file &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到某个目录下所有的以test开头的Python文件里面的测试用例&lt;/span&gt;
    all_cases = unittest.defaultTestLoader.discover(path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    report_time &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    report_file_path &lt;/span&gt;= report_file + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/report/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + report_time + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-result.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    file_result &lt;/span&gt;= open(report_file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    runner &lt;/span&gt;= HTMLTestRunner(stream=file_result, title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;简单运算demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, description=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;温一壶清酒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, verbosity=2, retry=2&lt;span&gt;,
                           save_last_try&lt;/span&gt;=&lt;span&gt;True)
    runner.run(all_cases)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后，查看测试报告，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190927000428379-840267134.png&quot; alt=&quot;&quot; width=&quot;842&quot; height=&quot;416&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以自己的产品做了个登录测试，生成的测试报告更全面，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.HTMLTestRunner_cn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTMLTestRunner

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittestlogin.py
@time: 2019-09-22 11:38
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; case_01(unittest.TestCase):
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUpClass(cls):
        cls.driver &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
        cls.driver.maximize_window()

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDownClass(cls):
        cls.driver.quit()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_img(self):
        self.imgs.append(self.driver.get_screenshot_as_base64())
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在是python3.x 中，如果在这里初始化driver ，因为3.x版本 unittestbasic1 运行机制不同，会导致用力失败时截图失败&lt;/span&gt;
        self.driver.get(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        self.driver.implicitly_wait(&lt;/span&gt;30&lt;span&gt;)
        self.imgs &lt;/span&gt;=&lt;span&gt; []
        self.addCleanup(self.cleanup)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cleanup(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case1(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 正常登录&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.add_img()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.add_img()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.add_img()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        self.add_img()
        user_name &lt;/span&gt;= self.driver.find_element_by_css_selector(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
        self.assertEqual(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一壶清酒stage1111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, user_name, msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[2]/div[1]/div[2]/div[5]/div[3]/ul/li[2]/span/i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;5&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case2(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 账号不存在&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.add_img()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case3(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 密码错误&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.add_img()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @unittest.skip(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;临时跳过这个测试用例&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case4(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 跳过该用例&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)

    @unittest.skipIf(&lt;/span&gt;3 &amp;gt; 2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;判断为真，此用例不执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case5(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; skipIf判断，为真则不执行&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)

    @unittest.skipUnless(&lt;/span&gt;3 &amp;lt; 2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;判断为假，此用例不执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case6(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; skipIf判断，为假则不执行&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text()
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_case7(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 断言失败&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[1]/div[1]/div[2]/div[1]/div/div[1]/div/div/div/div/div[3]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='text']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input[type='password']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button[type='button']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        user_name &lt;/span&gt;= self.driver.find_element_by_css_selector(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).text
        self.assertEqual(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一壶清酒stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, user_name, msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.driver.find_element_by_css_selector(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;3&lt;span&gt;)
        self.driver.find_element_by_xpath(
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@id='app']/div/div[2]/div[1]/div[2]/div[5]/div[3]/ul/li[2]/span/i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    suites &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suites.addTest(case_01(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_case7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    report_time &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    report_file &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    report_file_path &lt;/span&gt;= report_file + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/report/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + report_time + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-result.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    file_result &lt;/span&gt;= open(report_file_path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; retry重试次数&lt;/span&gt;
    runer = HTMLTestRunner(stream=file_result, title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;带截图的测试报告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, description=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;温一壶清酒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, verbosity=2, retry=&lt;span&gt;0,
                           save_last_try&lt;/span&gt;=&lt;span&gt;True)
    runer.run(suites)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看测试报告如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190927000826641-1997432355.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;xml格式测试报告&lt;/h4&gt;
&lt;p&gt;生成xml格式的测试报告，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xmlrunner

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
@author: wenyihuqingjiu
@project: unittestdemo
@file: unittest_demo_suite6.py
@time: 2019-09-27 00:11
@desc:
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./testcase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    report_file &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到某个目录下所有的以test开头的Python文件里面的测试用例&lt;/span&gt;
    all_cases = unittest.defaultTestLoader.discover(path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    report_time &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    report_file_path &lt;/span&gt;= report_file + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/report/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    runner &lt;/span&gt;= xmlrunner.XMLTestRunner(verbosity=2, output=report_file_path)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; output 报告存放路径&lt;/span&gt;
    runner.run(all_cases)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的报告如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190927001304312-1032135386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;生成的测试报告，发送到邮箱中，预览附件时，部分文字是乱码，样式按钮也不可点击，是因为样式文件被浏览器拦截了嘛？&lt;/p&gt;
&lt;p&gt;预览文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201909/1242227-20190927001718429-1755383086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:32:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<og:description>一谈及unittest，大家都知道，unittest是Python中自带的单元测试框架，它里面封装好了一些校验返回的结果方法和一些用例执行前的初始化操作。unittest单元测试框架不仅可以适用于单元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hong-fithing/p/11593345.html</dc:identifier>
</item>
<item>
<title>08.Django基础六之ORM中的锁和事务 - changxin7</title>
<link>http://www.cnblogs.com/changxin7/p/11595555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changxin7/p/11595555.html</guid>
<description>&lt;h2 id=&quot;一-锁&quot;&gt;一 锁&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;行级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　select_for_update(nowait=False, skip_locked=False) #注意必须用在事务里面，至于如何开启事务，我们看下面的事务一节。&lt;/p&gt;
&lt;p&gt;　　　　返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个 SELECT ... FOR UPDATE 语句。&lt;/p&gt;
&lt;p&gt;　　　　举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;entries = Entry.objects.select_for_update().filter(author=request.user)  #加互斥锁，由于mysql在查询时自动加的是共享锁，所以我们可以手动加上互斥锁。create、update、delete操作时，mysql自动加行级互斥锁&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。&lt;/p&gt;
&lt;p&gt;　　　　一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。 如果这不想要使查询阻塞的话，使用select_for_update(nowait=True)。 如果其它事务持有冲突的锁，互斥锁, 那么查询将引发 DatabaseError 异常。你也可以使用select_for_update(skip_locked=True)忽略锁定的行。 nowait和　　skip_locked是互斥的，同时设置会导致ValueError。&lt;/p&gt;
&lt;p&gt;　　　　目前，postgresql，oracle和mysql数据库后端支持select_for_update()。 但是，MySQL不支持nowait和skip_locked参数。&lt;/p&gt;
&lt;p&gt;　　　　使用不支持这些选项的数据库后端（如MySQL）将nowait=True或skip_locked=True转换为select_for_update()将导致抛出DatabaseError异常，这可以防止代码意外终止。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;表锁（了解）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class LockingManager(models.Manager):
    &quot;&quot;&quot; Add lock/unlock functionality to manager.

    Example::

        class Job(models.Model): #其实不用这么负载，直接在orm创建表的时候，给这个表定义一个lock和unlock方法，借助django提供的connection模块来发送锁表的原生sql语句和解锁的原生sql语句就可以了，不用外层的这个LckingManager(model.Manager)类

            manager = LockingManager()

            counter = models.IntegerField(null=True, default=0)

            @staticmethod
            def do_atomic_update(job_id)
                ''' Updates job integer, keeping it below 5 '''
                try:
                    # Ensure only one HTTP request can do this update at once.
                    Job.objects.lock()

                    job = Job.object.get(id=job_id)
                    # If we don't lock the tables two simultanous
                    # requests might both increase the counter
                    # going over 5
                    if job.counter &amp;lt; 5:
                        job.counter += 1                                        
                        job.save()

                finally:
                    Job.objects.unlock()


    &quot;&quot;&quot;    

    def lock(self):
        &quot;&quot;&quot; Lock table. 

        Locks the object model table so that atomic update is possible.
        Simulatenous database access request pend until the lock is unlock()'ed.

        Note: If you need to lock multiple tables, you need to do lock them
        all in one SQL clause and this function is not enough. To avoid
        dead lock, all tables must be locked in the same order.

        See http://dev.mysql.com/doc/refman/5.0/en/lock-tables.html
        &quot;&quot;&quot;
        cursor = connection.cursor()
        table = self.model._meta.db_table
        logger.debug(&quot;Locking table %s&quot; % table)
        cursor.execute(&quot;LOCK TABLES %s WRITE&quot; % table)
        row = cursor.fetchone()
        return row

    def unlock(self):
        &quot;&quot;&quot; Unlock the table. &quot;&quot;&quot;
        cursor = connection.cursor()
        table = self.model._meta.db_table
        cursor.execute(&quot;UNLOCK TABLES&quot;)
        row = cursor.fetchone()
        return row  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二-事务&quot;&gt;二 事务&lt;/h2&gt;

&lt;p&gt;　　关于MySQL的事务处理，我的mysql博客已经说的很清楚了，那么我们来看看Django是如果做事务处理的。django1.8版本之前是有很多种添加事务的方式的，中间件的形式（全局的）、函数装饰器的形式，上下文管理器的形式等，但是很多方法都在1.8版之后给更新了，下面我们只说最新的：&lt;/p&gt;
&lt;h3 id=&quot;全局开启&quot;&gt;1 全局开启&lt;/h3&gt;
&lt;p&gt;　　　　在Web应用中，常用的事务处理方式是将每个请求都包裹在一个事务中。这个功能使用起来非常简单，你只需要将它的配置项ATOMIC_REQUESTS设置为True。&lt;/p&gt;
&lt;p&gt;　　　　它是这样工作的：当有请求过来时，Django会在调用视图方法前开启一个事务。如果请求却正确处理并正确返回了结果，Django就会提交该事务。否则，Django会回滚该事务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mxshop',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        'USER': 'root',
        'PASSWORD': '123',
        'OPTIONS': {
            &quot;init_command&quot;: &quot;SET default_storage_engine='INNODB'&quot;,
　　　　　　　#'init_command': &quot;SET sql_mode='STRICT_TRANS_TABLES'&quot;, #配置开启严格sql模式


        }
        &quot;ATOMIC_REQUESTS&quot;: True, #全局开启事务，绑定的是http请求响应整个过程        &quot;AUTOCOMMIT&quot;:False, #全局取消自动提交，慎用
    }，　　'other':{　　　　'ENGINE': 'django.db.backends.mysql',             ......　　} #还可以配置其他数据库
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　上面这种方式是统一个http请求对应的所有sql都放在一个事务中执行（要么所有都成功，要么所有都失败）。是全局性的配置， 如果要对某个http请求放水（然后自定义事务），可以用non_atomic_requests修饰器，那么他就不受事务的管控了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import transaction

@transaction.non_atomic_requests
def my_view(request):
    do_stuff()

@transaction.non_atomic_requests(using='other')
def my_other_view(request):
    do_stuff_on_the_other_database()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　但是Django 文档中说，不推荐这么做。因为如果将事务跟 HTTP 请求绑定到一起的时，然而view 是依赖于应用程序对数据库的查询语句效率和数据库当前的锁竞争情况。当流量上来的时候，性能会有影响，知道一下就行了&lt;/p&gt;
&lt;p&gt;　　　　所以推荐用下面这种方式，通过 &lt;code&gt;transaction.atomic&lt;/code&gt; 来更加明确的控制事务。atomic允许我们在执行代码块时，在数据库层面提供原子性保证。 如果代码块成功完成， 相应的变化会被提交到数据库进行commit；如果执行期间遇到异常，则会将该段代码所涉及的所有更改回滚。&lt;/p&gt;
&lt;h3 id=&quot;局部使用事务&quot;&gt;2 局部使用事务&lt;/h3&gt;
&lt;p&gt;　　　　atomic(&lt;em&gt;using=None, savepoint=True&lt;/em&gt;)[source] ，参数：using='other',就是当你操作其他数据库的时候，这个事务才生效，看上面我们的数据库配置，除了default，还有一个other，默认的是default。savepoint的意思是开启事务保存点，推荐看一下我&lt;a href=&quot;https://www.cnblogs.com/clschao/articles/10065275.html&quot;&gt;数据库博客&lt;/a&gt;里面的事务部分关于保存点的解释。&lt;/p&gt;
&lt;p&gt;原子性是数据库事务的一个属性。使用atomic，我们就可以创建一个具备原子性的代码块。一旦代码块正常运行完毕，所有的修改会被提交到数据库。反之，如果有异常，更改会被回滚。&lt;/p&gt;
&lt;p&gt;　　　　被atomic管理起来的代码块还可以内嵌到方法中。这样的话，即便内部代码块正常运行，如果外部代码块抛出异常的话，它也没有办法把它的修改提交到数据库中。&lt;/p&gt;
&lt;p&gt;　　　　用法1：给函数做装饰器来使用　&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import transaction

@transaction.atomic
def viewfunc(request):
    # This code executes inside a transaction.
    do_stuff()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　用法2：作为上下文管理器来使用，其实就是设置事务的保存点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import transaction

def viewfunc(request):
    # This code executes in autocommit mode (Django's default).
    do_stuff()

    with transaction.atomic():   #保存点
        # This code executes inside a transaction.
        do_more_stuff()

    do_other_stuff()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　一旦把atomic代码块放到try/except中，完整性错误就会被自然的处理掉了，比如下面这个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import IntegrityError, transaction

@transaction.atomic
def viewfunc(request):
    create_parent()

    try:
        with transaction.atomic():
            generate_relationships()
    except IntegrityError:
        handle_exception()

    add_children()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　用法3：还可以嵌套使用，函数的事务嵌套上下文管理器的事务，上下文管理器的事务嵌套上下文管理器的事务等。下面的是函数嵌套上下文的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import IntegrityError, transaction

@transaction.atomic
def viewfunc(request):
    create_parent()

    try:
        with transaction.atomic():
            generate_relationships()　　　　　　　#other_task()  #还要注意一点，如果你在事务里面写了别的操作，只有这些操作全部完成之后，事务才会commit，也就是说，如果你这个任务是查询上面更改的数据表里面的数据，那么看到的还是事务提交之前的数据。
    except IntegrityError:
        handle_exception()

    add_children()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　这个例子中，即使generate_relationships()中的代码打破了数据完整性约束，你仍然可以在add_children()中执行数据库操作，并且create_parent()产生的更改也有效。需要注意的是，在调用handle_exception()之前，generate_relationships()中的修改就已经被安全的回滚了。因此，如果有需要，你照样可以在异常处理函数中操作数据库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;尽量不要在atomic代码块中捕获异常

  因为当atomic块中的代码执行完的时候，Django会根据代码正常运行来执行相应的提交或者回滚操作。如果在atomic代码块里面捕捉并处理了异常，就有可能隐盖代码本身的错误，从而可能会有一些意料之外的不愉快事情发生。

  担心主要集中在DatabaseError和它的子类（如IntegrityError）。如果这种异常真的发生了，事务就会被破坏掉，而Django会在代码运行完后执行回滚操作。如果你试图在回滚前执行一些数据库操作，Django会抛出TransactionManagementError。通常你会在一个ORM相关的信号处理器抛出异常时遇到这个行为。

捕获异常的正确方式正如上面atomic代码块所示。如果有必要，添加额外的atomic代码块来做这件事情，也就是事务嵌套。这么做的好处是：当异常发生时，它能明确地告诉你那些操作需要回滚，而那些是不需要的。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　为了保证原子性，atomic还禁止了一些API。像试图提交、回滚事务，以及改变数据库连接的自动提交状态这些操作，在atomic代码块中都是不予许的，否则就会抛出异常。&lt;/p&gt;
&lt;p&gt;　　下面是Django的事务管理代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入最外层atomic代码块时开启一个事务；&lt;/li&gt;
&lt;li&gt;进入内部atomic代码块时创建保存点；&lt;/li&gt;
&lt;li&gt;退出内部atomic时释放或回滚事务；注意如果有嵌套，内层的事务也是不会提交的，可以释放（正常结束）或者回滚&lt;/li&gt;
&lt;li&gt;退出最外层atomic代码块时提交或者回滚事务；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　你可以将保存点参数设置成False来禁止内部代码块创建保存点。如果发生了异常，Django在退出第一个父块的时候执行回滚，如果存在保存点，将回滚到这个保存点的位置，否则就是回滚到最外层的代码块。外层事务仍然能够保证原子性。然而，这个选项应该仅仅用于保存点开销较大的时候。毕竟它有个缺点：会破坏上文描述的错误处理机制。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;strong&gt;transaction只对数据库层的操作进行事务管理,不能理解为python操作的事务管理&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def example_view(request):
    tag = False
    with transaction.atomic():
        tag = True
        change_obj() # 修改对象变量
        obj.save()
        raise DataError
    print(&quot;tag = &quot;,tag) #结果是True，也就是说在事务中的python变量赋值，即便是事务回滚了，这个赋值也是成功的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;strong&gt;还要注意&lt;/strong&gt;：如果你配置了全局的事务，它和局部事务可能会产生冲突，你可能会发现你局部的事务完成之后，如果你的函数里面其他的sql除了问题，也就是没在这个上下文管理器的局部事务包裹范围内的函数里面的其他的sql出现了问题，你的局部事务也是提交不上的，因为全局会回滚这个请求和响应所涉及到的所有的sql，所以还是建议以后的项目尽量不要配置全局的事务，通过局部事务来搞定，当然了，看你们的业务场景。&lt;/p&gt;
&lt;h3 id=&quot;transaction的其他方法&quot;&gt;transaction的其他方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@transaction.atomic
def viewfunc(request):

  a.save()
  # open transaction now contains a.save()
  sid = transaction.savepoint()  #创建保存点

  b.save()
  # open transaction now contains a.save() and b.save()

  if want_to_keep_b:
      transaction.savepoint_commit(sid) #提交保存点
      # open transaction still contains a.save() and b.save()
  else:
      transaction.savepoint_rollback(sid)  #回滚保存点
      # open transaction now contains only a.save()

  transaction.commit() #手动提交事务，默认是自动提交的，也就是说如果你没有设置取消自动提交，那么这句话不用写，如果你配置了那个AUTOCOMMIT=False，那么就需要自己手动进行提交。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　为保证事务的隔离性，我们还可以结合上面的锁来实现，也就是说在事务里面的查询语句，咱们使用select_for_update显示的加锁方式来保证隔离性，事务结束后才会释放这个锁，例如：（了解）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@transaction.atomic ## 轻松开启事务
def handle(self):
    ## 测试是否存在此用户
    try:
        ## 锁定被查询行直到事务结束
        user = 
    User.objects.select_for_update().get(open_id=self.user.open_id)
        #other sql 语句
    except User.DoesNotExist:
        raise BaseError(-1, 'User does not exist.')
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　通过Django外部的python脚本来测试一下事务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os

if __name__ == '__main__':
    os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;BMS.settings&quot;)
    import django
    django.setup()

    import datetime
    from app01 import models

    try:
        from django.db import transaction
        with transaction.atomic():
            new_publisher = models.Publisher.objects.create(name=&quot;火星出版社&quot;)
            models.Book.objects.create(title=&quot;橘子物语&quot;, publish_date=datetime.date.today(), publisher_id=10)  # 指定一个不存在的出版社id
    except Exception as e:
        print(str(e))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　下面再说一些设置事务的小原则吧：&lt;/p&gt;
&lt;p&gt;　　　　1.保持事务短小&lt;br/&gt;　　　　2.尽量避免事务中rollback&lt;br/&gt;　　　　3.尽量避免savepoint&lt;br/&gt;　　　　4.默认情况下，依赖于悲观锁&lt;br/&gt;　　　　5.为吞吐量要求苛刻的事务考虑乐观锁&lt;br/&gt;　　　　6.显示声明打开事务&lt;br/&gt;　　　　7.锁的行越少越好，锁的时间越短越好&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:10:00 +0000</pubDate>
<dc:creator>changxin7</dc:creator>
<og:description>一 锁 行级锁 select_for_update(nowait=False, skip_locked=False) 注意必须用在事务里面，至于如何开启事务，我们看下面的事务一节。 返回一个锁住行直到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/changxin7/p/11595555.html</dc:identifier>
</item>
<item>
<title>品Spring：实现bean定义时采用的“先进生产力” - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/taste-spring-003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/taste-spring-003.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
前景回顾&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们把写好的业务代码交给Spring之后，Spring都会做些什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仔细想象一下，再稍微抽象一下，Spring所做的几乎全部都是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“bean的实例化，bean的依赖装配，bean的初始化，bean的方法调用，bean的销毁回收”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那问题来了，Spring为什么能够准确无误的完成这波对bean的操作呢？答案很简单，就是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“Spring掌握了有关bean的足够多的信息”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是本系列文章第一篇“帝国的基石”的核心思想。Spring通过bean定义的概念收集到了bean的全部信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这件事也说明，当我们拥有了一个事物的大量有效信息之后，就可以做出一些非常有价值的操作。如大数据分析，用户画像等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;紧接着就是第二个问题，Spring应该采用什么样的方式来收集bean的信息呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是本系列文章第二篇“bean定义上梁山”主要讲的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是统一了编程模型，只要是围绕Spring的开发，包括框架自身的开发，最后大都转化为bean定义的注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足不同的场景，Spring提供了两大类的bean定义注册方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现指定接口，采用写代码的方式来注册，这是非常灵活的动态注册，根据不同的条件注册不同的bean，主要用于第三方组件和Spring的整合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标上指定注解，采用注解扫描的方式来注册，这相当于一种静态的注册，非常不灵活，但特别简单易用，主要用于普通业务代码的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring设计的这一切，看起来确实完美，用起来也确实很爽，但实现起来呢，也确实的非常麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尤其是在全部采用注解和Java配置的时候，那才叫一个繁琐，看看源码便知一二。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以本篇及接下来的几篇都会写一些和实现细节相关的内容，俗称“干货”，哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最容易想到的实现方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个bean其实就是一个类，所以bean的信息就是类的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那一个类都有哪些信息呢，闭着眼睛都能说出来，共四大类信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类型信息，类名，父类，实现的接口，访问控制/修饰符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;字段信息，字段名，字段类型，访问控制/修饰符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法信息，方法名，返回类型，参数类型，访问控制/修饰符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注解信息，类上的注解，字段上的注解，方法上的注解/方法参数上的注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：还有内部类/外部类这些信息，也是非常重要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这里脑海中应该立马蹦出两个字，没错，就是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;反射&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，Spring并没有采用反射来获取这些信息，个人认为可能有以下两个大的原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能损耗问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想使用反射，JVM必须先加载类，然后生成对应的Class&amp;lt;?&amp;gt;对象，最后缓存起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际的工程可能会注册较多的bean，但是真正运行时不一定都会用得到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以JVM加载过多的类，不仅会耗费较多的时间，还会占用较多的内存，而且加载的类很多可能都不用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;信息完整度问题&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JDK在1.8版本中新增加了一些和反射相关的API，比如和方法参数名称相关的。此时才能使用反射获取相对完善的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但Spring很早就提供了对注解的支持，所以当时的反射并不完善，也可能是通过反射获取到的信息并不能完全符合要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，Spring没有选择反射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如何获取类的这些信息呢？答案应该只剩一种，就是&lt;/span&gt;&lt;span&gt;直接从字节码文件中获取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;采用先进的生产力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码经过编译变成字节码，所以源码中有的信息，在字节码中肯定都有。只不过换了一种存在的形式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java源码遵循Java语法规范，生成的字节码遵循JVM中的字节码规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;字节码文件的结构确实有些复杂，应用程序想要直接从字节码中读出需要的信息也确实有些困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小平同志曾说过，“科学技术是第一生产力”。所以要解决复杂的问题，必须要有比较可靠的技术才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于复杂的字节码来说，先进的生产力就是ASM了。&lt;/span&gt;&lt;span&gt;ASM是一个小巧快速的Java字节码操作框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它既可以读字节码文件，也可以写字节码文件。Spring框架主要用它来读取字节码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASM框架是采用访问者模式设计出来的，如果不熟悉这个设计模式的可以阅读本公众号上一篇文章“趣说访问者模式”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该模式的核心思想就是，访问者按照一定的规则顺序进行访问，期间会自动获取到相关信息，把有用的信息保存下来即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一下ASM的具体使用方式，可以看看作为了解，说不定以后会用到。哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASM定义了ClassVisitor来获取类型信息，AnnotationVisitor来获取注解信息，FieldVisitor来获取字段信息，MethodVisitor来获取方法信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先准备好产生字节码的素材，其实就是一个类啦，这个类仅作测试使用，不用考虑是否合理，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;17&quot;&gt;&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;18&quot;&gt;&lt;span class=&quot;&quot;&gt;@Configuration&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;ddd&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;@ComponentScan&lt;/span&gt;(basePackages = {&lt;span class=&quot;&quot;&gt;&quot;a.b.c&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;&quot;x.y.z&quot;&lt;/span&gt;},&lt;br/&gt;scopedProxy = ScopedProxyMode.DEFAULT,&lt;br/&gt;includeFilters = {&lt;span class=&quot;&quot;&gt;@Filter&lt;/span&gt;(classes = Integer.class)})&lt;br/&gt;&lt;span class=&quot;&quot;&gt;@Ann&lt;/span&gt;0(ann1 = &lt;span class=&quot;&quot;&gt;@Ann&lt;/span&gt;1(name = &lt;span class=&quot;&quot;&gt;&quot;ann1Name&quot;&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;D&lt;/span&gt;&amp;lt;@&lt;span class=&quot;&quot;&gt;Null&lt;/span&gt; &lt;span class=&quot;&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Number&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;C&lt;/span&gt;&amp;lt;@&lt;span class=&quot;&quot;&gt;Valid&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Long&lt;/span&gt;, @&lt;span class=&quot;&quot;&gt;NotNull&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Date&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;&quot;&gt;protected&lt;/span&gt; Long lon = Long.MAX_VALUE;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;private&lt;/span&gt; String str;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@Autowired&lt;/span&gt;(required = &lt;span class=&quot;&quot;&gt;false&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;private&lt;/span&gt; Date date;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@Resource&lt;/span&gt;(name = &lt;span class=&quot;&quot;&gt;&quot;aaa&quot;&lt;/span&gt;, lookup = &lt;span class=&quot;&quot;&gt;&quot;bbb&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;private&lt;/span&gt; Map&amp;lt;&lt;span class=&quot;&quot;&gt;@NotNull&lt;/span&gt; String, &lt;span class=&quot;&quot;&gt;@Null&lt;/span&gt; Object&amp;gt; map;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@Bean&lt;/span&gt;(name = {&lt;span class=&quot;&quot;&gt;&quot;cc&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;&quot;dd&quot;&lt;/span&gt;}, initMethod = &lt;span class=&quot;&quot;&gt;&quot;init&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;&quot;&gt;getStr&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(@NotNull String sssss, @Null &lt;span class=&quot;&quot;&gt;int&lt;/span&gt; iiiii, &lt;span class=&quot;&quot;&gt;double&lt;/span&gt; dddd, @Valid &lt;span class=&quot;&quot;&gt;long&lt;/span&gt; llll)&lt;/span&gt; &lt;span class=&quot;&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; sssss;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;&quot;&gt;getDouble&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(&lt;span class=&quot;&quot;&gt;double&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这个类里面包含了较为全面的信息，&lt;/span&gt;&lt;span&gt;泛型、父类、实现的接口、字段、方法、注解&lt;/span&gt;&lt;span&gt;等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照ASM规定的访问顺序，首先访问类型信息，使用ClassVisitor的visit方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;16&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; void visit(&lt;span class=&quot;&quot;&gt;int&lt;/span&gt; version, &lt;span class=&quot;&quot;&gt;int&lt;/span&gt; access, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt; name, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt; signature, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt; superName, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt;[] interfaces) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---ClassVisitor-visit---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;version&quot;&lt;/span&gt;, version);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;access&quot;&lt;/span&gt;, access);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;name&quot;&lt;/span&gt;, name);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;signature&quot;&lt;/span&gt;, signature);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;superName&quot;&lt;/span&gt;, superName);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;interfaces&quot;&lt;/span&gt;, Arrays.toString(interfaces));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这个方法会由ASM框架调用，方法参数的值是框架传进来的，我们要做的只是在方法内部把这些参数值保存下来就行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后可以按照自己的需求去解析和使用，我这里只是简单输出一下。如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;//版本信息，52表示的是JDK1.8&lt;/span&gt;&lt;br/&gt;version = &lt;span class=&quot;&quot;&gt;52&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//访问控制信息，表示的是public class&lt;/span&gt;&lt;br/&gt;access = &lt;span class=&quot;&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//类型的名称&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = org/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/D&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//类型的签名，依次为，本类的泛型、父类、父类的泛型、实现的接口&lt;/span&gt;&lt;br/&gt;signature = &amp;lt;T:Ljava/lang/Number;&amp;gt;Lorg/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/C&amp;lt;Ljava/lang/Long;Ljava/util/Date;&amp;gt;;Lorg/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/A;Lorg/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/B;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//父类型的名称&lt;/span&gt;&lt;br/&gt;superName = org/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/C&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//实现的接口&lt;/span&gt;&lt;br/&gt;interfaces = [org/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/A, org/cnt/ts/&lt;span class=&quot;&quot;&gt;asm&lt;/span&gt;/B]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;现在我们已经获取到了这些信息，虽然我们并不知道它是如何在字节码中存着的，这就是访问者模式的好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类型名称都是以斜线“/”分割，是因为斜线是路径分隔符，可以非常方便的拼出完整路径，从磁盘上读取.class文件的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有以大写“L”开头后跟一个类型名称的，这个大写L表示的是“对象”的意思，后跟的就是对象的类型名称，说白了就是类、接口、枚举、注解等这些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着访问的是类型上标的注解，使用ClassVisitor的visitAnnotation方法，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;7&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@&lt;span class=&quot;&quot;&gt;Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; AnnotationVisitor &lt;span class=&quot;&quot;&gt;visitAnnotation&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(String descriptor, boolean visible)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---ClassVisitor-visitAnnotation---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;descriptor&quot;&lt;/span&gt;, descriptor);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;visible&quot;&lt;/span&gt;, visible);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;&quot;&gt;new&lt;/span&gt; _AnnotationVisitor();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;需要说明的是，&lt;/span&gt;&lt;span&gt;这个方法只能访问到注解的类型信息，注解的属性信息需要使用AnnotationVisitor去访问&lt;/span&gt;&lt;span&gt;，也就是这个方法的返回类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类上标有@Configuration(&quot;ddd&quot;)，所以输出结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//类型描述/名称&lt;br/&gt;descriptor = Lorg/springframework/context/annotation/Configuration;&lt;br/&gt;//这个是可见性，表明在运行时可以获取到注解的信息&lt;br/&gt;visible = true&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后使用AnnotationVisitor去访问显式设置过的注解属性信息，&lt;/span&gt;&lt;span&gt;使用visit方法访问基本的信息&lt;/span&gt;&lt;span&gt;，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@&lt;span class=&quot;&quot;&gt;Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(String name, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---AnnotationVisitor-visit---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;name&quot;&lt;/span&gt;, name);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;value&quot;&lt;/span&gt;, value);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;实际上我们是把ddd设置给了注解的value属性，所以结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;//属性名称，是value&lt;/span&gt;&lt;br/&gt;name = &lt;span class=&quot;&quot;&gt;value&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;//属性值，是ddd&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = ddd&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;至此，@Configuration注解已经访问完毕。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再访问@ComponentScan注解，同样使用ClassVisitor的visitAnnotation方法，和上面的那个一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得到的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;descriptor&lt;/span&gt; = Lorg/springframework/context/annotation/ComponentScan;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;visible&lt;/span&gt; = &lt;span class=&quot;&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后使用AnnotationVisitor去访问设置过的注解属性信息，&lt;/span&gt;&lt;span&gt;使用visitArray方法访问数组类型的信息&lt;/span&gt;&lt;span&gt;，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@&lt;span class=&quot;&quot;&gt;Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; AnnotationVisitor &lt;span class=&quot;&quot;&gt;visitArray&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---AnnotationVisitor-visitArray---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;name&quot;&lt;/span&gt;, name);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;&quot;&gt;new&lt;/span&gt; _AnnotationVisitor();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这个方法&lt;/span&gt;&lt;span&gt;只能访问到数组类型属性的名称&lt;/span&gt;&lt;span&gt;，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = basePackages&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;属性的值还是使用基本的visit方法去访问，因为数组的值是多个，所以visit方法会多次调用，按顺序依次获取数组的每个元素值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因数组有两个值，所以方法调用两次&lt;/span&gt;&lt;span&gt;，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = null&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = a.b.c&lt;p&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = null&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = x.y.z&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;因为数组的值没有名称，所以name总是null。value的值就是数组的元素值，按先后顺序保存在一起即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后由于注解的下一个属性是枚举类型的，所以&lt;/span&gt;&lt;span&gt;使用visitEnum方法来访问&lt;/span&gt;&lt;span&gt;，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;8&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; void visitEnum(&lt;span class=&quot;&quot;&gt;String&lt;/span&gt; name, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt; descriptor, &lt;span class=&quot;&quot;&gt;String&lt;/span&gt; value) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---AnnotationVisitor-visitEnum---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;name&quot;&lt;/span&gt;, name);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;descriptor&quot;&lt;/span&gt;, descriptor);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;value&quot;&lt;/span&gt;, value);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//注解的属性名称，是scopedProxy&lt;br/&gt;name = scopedProxy&lt;br/&gt;//枚举类型，是ScopedProxyMode&lt;br/&gt;descriptor = Lorg/springframework/context/annotation/ScopedProxyMode;&lt;br/&gt;//属性的值，是我们设置的DEFAULT&lt;br/&gt;value = DEFAULT&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后继续访问数组类型的属性，使用visitArray方法访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得到的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = includeFilters&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;接下来该获取数组的元素了，&lt;/span&gt;&lt;span&gt;由于这个数组元素的类型也是一个注解，所有使用visitAnnotation方法访问&lt;/span&gt;&lt;span&gt;，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;7&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;@&lt;span class=&quot;&quot;&gt;Override&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; AnnotationVisitor &lt;span class=&quot;&quot;&gt;visitAnnotation&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(String name, String descriptor)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;---AnnotationVisitor-visitAnnotation---&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;name&quot;&lt;/span&gt;, name);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;descriptor&quot;&lt;/span&gt;, descriptor);&lt;br/&gt;&lt;span class=&quot;&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;&quot;&gt;new&lt;/span&gt; _AnnotationVisitor();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;得到的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;name = null&lt;br/&gt;//注解类型名称&lt;br/&gt;descriptor = Lorg/springframework/context/annotation/ComponentScan$Filter;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到这个注解是@ComponentScan内部的@Filter注解。&lt;/span&gt;&lt;span&gt;这个注解本身是作为数组元素的值，所以name是null，因为数组元素是没有名称的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再访问@Filter这个注解的属性，得到属性名称如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = classes&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;属性值是一个数组，它只有一个元素，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = null&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = Ljava/lang/Integer;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，代码较多，不再贴了，只给出结果的解析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是map类型的那个字段的结果，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//访问控制，&lt;span class=&quot;&quot;&gt;private&lt;/span&gt;&lt;br/&gt;access = 2&lt;br/&gt;//字段名称&lt;br/&gt;name = map&lt;br/&gt;//字段类型&lt;br/&gt;descriptor = Ljava/util/Map;&lt;br/&gt;//字段类型签名，包括泛型信息&lt;br/&gt;signature = Ljava/util/Map&amp;lt;Ljava/lang/String;Ljava/lang/Object;&amp;gt;;&lt;br/&gt;value = null&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;该字段上标了注解，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;descriptor&lt;/span&gt; = Ljavax/annotation/Resource;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;visible&lt;/span&gt; = &lt;span class=&quot;&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;并且设置了注解的两个属性，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = name&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = aaa&lt;p&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = lookup&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = bbb&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;由于编译器会生成默认的无参构造函数&lt;/span&gt;&lt;span&gt;，所以会有如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//访问控制，public&lt;br/&gt;access = 1&lt;br/&gt;//对应于构造函数名称&lt;br/&gt;name = &lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;br/&gt;//方法没有参数，返回类型是void&lt;br/&gt;descriptor = &lt;span&gt;()V&lt;/span&gt;&lt;br/&gt;signature = null&lt;br/&gt;exceptions = null&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;这有一个定义的方法结果，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//public&lt;br/&gt;access = 1&lt;br/&gt;//方法名称&lt;br/&gt;name = getStr&lt;br/&gt;//方法参数四个，分别是，String、int、double、long，返回类型是String&lt;br/&gt;descriptor = (&lt;span&gt;Ljava/lang/String&lt;/span&gt;;&lt;span&gt;IDJ&lt;/span&gt;)&lt;span&gt;Ljava/lang/String&lt;/span&gt;;&lt;br/&gt;signature = null&lt;br/&gt;//抛出Exception异常&lt;br/&gt;exceptions = [java/lang/Exception]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;参数里面的大写字母I表示int，D表示double，J表示long，都是基本数据类，要记住不是包装类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法的四个参数名称，依次分别是：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;//参数名称&lt;br/&gt;name = sssss&lt;br/&gt;//参数访问修饰，0表示没有修饰&lt;br/&gt;access = 0&lt;p&gt;name = iiiii&lt;br/&gt;access = 0&lt;/p&gt;&lt;p&gt;name = dddd&lt;br/&gt;access = 0&lt;/p&gt;&lt;p&gt;name = llll&lt;br/&gt;access = 0&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;由于方法上标有注解，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;descriptor&lt;/span&gt; = Lorg/springframework/context/annotation/Bean;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;visible&lt;/span&gt; = &lt;span class=&quot;&quot;&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;数组类型的属性名称，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = name&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;属性值有两个，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = null&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = cc&lt;p&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = null&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = dd&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;简单类型的属性值，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;name&lt;/span&gt; = initMethod&lt;br/&gt;&lt;span class=&quot;&quot;&gt;value&lt;/span&gt; = init&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;由于方法的其中三个参数上也标了注解，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;5&quot;&gt;&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;4&quot;&gt;//参数位置，第0个参数&lt;br/&gt;parameter = 0&lt;br/&gt;//注解类型名称，@NotNull&lt;br/&gt;descriptor = Ljavax/validation/constraints/NotNull;&lt;br/&gt;//可见性，运行时可见&lt;br/&gt;visible = true&lt;p&gt;parameter = 1&lt;br/&gt;descriptor = Ljavax/validation/constraints/Null;&lt;br/&gt;visible = true&lt;/p&gt;&lt;p&gt;parameter = 3&lt;br/&gt;descriptor = Ljavax/validation/Valid;&lt;br/&gt;visible = true&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;以上这些只是部分的输出结果。&lt;/span&gt;&lt;span&gt;完整示例代码参见文章末尾，可以自己运行一下仔细研究研究。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结尾总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在业务开发中直接使用ASM的情况肯定较少，一般在框架开发或组件开发时可能会用到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASM的使用并不是特别难，多做测试即可发现规律。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在测试时发现两个值得注意的事情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只能访问到显式设置注解属性的那些值，对于注解的默认属性值是访问不到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要想获取到注解的默认值，需要去访问注解自己的字节码文件，而不是使用注解的类的字节码文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只能访问到类型自己定义的信息，从父类型继承的信息也是访问不到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说，字节码中只包括在源码文件中出现的信息，字节码本身不处理继承问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，JVM在加载一个类型时，要加载它的父类型，并处理继承问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整示例代码&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://github.com/coding-new-talking/taste-spring.git&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;（END）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 00:07:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>前景回顾当我们把写好的业务代码交给Spring之后，Spring都会做些什么呢？仔细想象一下，再稍微抽象一下，Spring所做的几乎全部都是：“bean的实例化，bean的依赖装配，bean的初始化，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/taste-spring-003.html</dc:identifier>
</item>
</channel>
</rss>