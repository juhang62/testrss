<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>实现一个简单的WebSocket聊天室 - 超超不会飞</title>
<link>http://www.cnblogs.com/chaohangz/p/10745489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaohangz/p/10745489.html</guid>
<description>&lt;h2 id=&quot;websocket-简介&quot;&gt;WebSocket 简介&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。&lt;br/&gt;WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;br/&gt;在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;web&quot;&gt;Web&lt;/h2&gt;
&lt;p&gt;我们先用 &lt;code&gt;express&lt;/code&gt; 搭一个基础的服务端。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;index.js&lt;/code&gt; 文件&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var app = require('express')();
var http = require('http').createServer(app);

app.get('/', function(req, res){
  res.send('&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;');
});

http.listen(3000, function(){
  console.log('listening on *:3000');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run &lt;code&gt;node index.js&lt;/code&gt;，并在浏览器打开 &lt;code&gt;http://localhost:3000&lt;/code&gt;，访问成功即可看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/661386-88ce2063dfcfbd52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;
&lt;p&gt;设计我们的主页，实现一个简单的聊天窗口。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;app.get('/', function(req, res){
  res.sendFile(__dirname + '/index.html');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建 &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Socket.IO chat&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;ul id=&quot;messages&quot;&amp;gt;&amp;lt;/ul&amp;gt;
    &amp;lt;form action=&quot;&quot;&amp;gt;
      &amp;lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&amp;gt;&amp;lt;button&amp;gt;Send&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启应用并刷新页面你就可以看到一个如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/661386-a02082e7a995b6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;socket.io&quot;&gt;Socket.io&lt;/h2&gt;
&lt;p&gt;引入&lt;code&gt;socket.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install --save socket.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res){
  res.sendFile(__dirname + '/index.html');
});

io.on('connection', function(socket){
  console.log('an user connected');
});

http.listen(3000, function(){
  console.log('listening on *:3000');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;index.html&lt;/code&gt;，在&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;下添加如下代码&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;/socket.io/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  var socket = io();
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启应用并刷新页面，就可以看到命令行打印如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/661386-bae9ba92924db97c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;emitting-event&quot;&gt;Emitting event&lt;/h2&gt;
&lt;p&gt;当用户在聊天窗的输入框内输入，并提交时，触发 &lt;code&gt;emit&lt;/code&gt; 事件，服务端监听到该事件并做出相应的反应。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;/socket.io/socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;https://code.jquery.com/jquery-1.11.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  $(function () {
    var socket = io();
    $('form').submit(function(e){
      e.preventDefault(); // 防止页面重新加载
      socket.emit('chat message', $('#m').val());
      $('#m').val('');
      return false;
    });
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端监听该事件，在 &lt;code&gt;index.js&lt;/code&gt; 文件添加该代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;io.on('connection', function(socket){
  socket.on('chat message', function(msg){
    console.log('message: ' + msg);
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;展示消息&quot;&gt;展示消息&lt;/h2&gt;
&lt;p&gt;当服务端收到用户A发出的消息，服务端重新发出该消息，让客户端接收，客户端监听到该事件后展示该条消息，就可以实现用户 A, B, C 都接收到该消息。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;io.on('connection', function(socket){
  socket.on('chat message', function(msg){
    io.emit('chat message', msg);
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;index.html&lt;/code&gt;，实现消息的展示&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
  $(function () {
    var socket = io();
    $('form').submit(function(e){
      e.preventDefault(); // prevents page reloading
      socket.emit('chat message', $('#m').val());
      $('#m').val('');
      return false;
    });
    socket.on('chat message', function(msg){
      $('#messages').append($('&amp;lt;li&amp;gt;').text(msg));
    });
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启应用并刷新页面，可以打开多个浏览器页面同时访问 &lt;code&gt;localhost:3000&lt;/code&gt;，就可以体验简单聊天室的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/661386-bac5a0841aebdfec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置昵称&quot;&gt;设置昵称&lt;/h2&gt;
&lt;p&gt;在每个用户进入的时候，随机生成一个数字作为用户的昵称，并且向所有用户广播该用户进入聊天室。当用户发送消息时，拼接上用户的昵称。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;io.on('connection', (socket) =&amp;gt; {
  const nickname = 'user' + Math.ceil((Math.random() * 1000))
  socket.broadcast.emit('connection', nickname + ' connected')

  socket.on('chat message', (msg) =&amp;gt; {
    io.emit('chat message', nickname + ': ' + msg)
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;index.html&lt;/code&gt;，监听 &lt;code&gt;connection&lt;/code&gt; 事件&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
  $(() =&amp;gt; {
    const socket = io()
    $('form').submit((e) =&amp;gt; {
      e.preventDefault()
      socket.emit('chat message', $('#m').val())
      $('#m').val('')
      return false
    });
    socket.on('chat message', (msg) =&amp;gt; {
      $('#messages').append($('&amp;lt;li&amp;gt;').text(msg))
    })
    socket.on('connection', (msg) =&amp;gt; {
      $('#messages').append($('&amp;lt;li&amp;gt;').text(msg))
    })
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启应用并打开多个客户端，可以看到如下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/661386-7be66296b6bfbf8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;本文大部分案例出自 &lt;code&gt;socket.io&lt;/code&gt; 的入门文档 &lt;a href=&quot;https://socket.io/get-started/chat/&quot; class=&quot;uri&quot;&gt;https://socket.io/get-started/chat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/WebSocket&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001472780997905c8f293615c5a42eab058b6dc29936a5c000&quot;&gt;廖雪峰官网 WebSocket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/html/html5-websocket.html&quot;&gt;菜鸟教程 WebSocket&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 07:55:00 +0000</pubDate>
<dc:creator>超超不会飞</dc:creator>
<og:description>WebSocket 简介 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaohangz/p/10745489.html</dc:identifier>
</item>
<item>
<title>花马云10亿无作为，被同事骂的当众落泪，后为阿里创造4500亿价值 - LonelyKeyGuest</title>
<link>http://www.cnblogs.com/gdjk/p/10745476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdjk/p/10745476.html</guid>
<description>&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;阅读本文大概需要 5.6 分钟。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那个骗走马云10个亿，被阿里同事指着鼻子让他滚蛋的人，后来怎么样了？&lt;/p&gt;
&lt;p&gt;后来，他成为阿里巴巴集团首席技术官，而且被公认为，近10年来，中国最好的首席技术官。&lt;/p&gt;
&lt;p&gt;他叫王坚，被称为“阿里云之父”，阿里最受争议的领导，曾被骂了整整4年，在开会时委屈到流泪。&lt;/p&gt;
&lt;p&gt;王坚对马云有多重要？&lt;/p&gt;
&lt;p&gt;他让阿里拥有了自己的技术，帮阿里巴巴在全球拿下超过140万客户，为全球76.5万用户提供云计算和大数据的服务，年营收112亿，估值4500亿。&lt;/p&gt;
&lt;p&gt;目前在国内第一，全球第三。&lt;/p&gt;
&lt;p&gt;仅次于亚马逊和微软。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4de224757?w=620&amp;amp;h=411&amp;amp;f=jpeg&amp;amp;s=59295&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在所有人唾骂王坚时，马云站出来请求大家 “给王坚一点时间”，差一点把阿里搞分了家。&lt;/p&gt;
&lt;p&gt;马云为什么愿意毫无保留的相信王坚？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;1、真正决定人生胜负的，是从敢于放弃开始！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;王坚出生于1962年，比马云大两岁，在人生的前30年，一直在和心理学打交道。&lt;/p&gt;
&lt;p&gt;28岁杭州大学心理系博士，30岁的心理学教授，31岁的博导，32岁的系主任。&lt;/p&gt;
&lt;p&gt;他用了四年，完成了别人几乎要十年才能完成的跨越。&lt;/p&gt;
&lt;p&gt;当时他在杭大读研时，自己学校的知识还不能满足他，就跑去浙大，旁听了计算机研究生的课程。&lt;/p&gt;
&lt;p&gt;几年下来，王坚的水平居然不亚于计算机导师。&lt;/p&gt;
&lt;p&gt;硕士论文，他写的是《人机交互和多通道用户界面》，这是中国首部讨论人机交互的论文，后续航天工程上轨道对接的人机交互程序都受此影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4de7d42ca?w=296&amp;amp;h=316&amp;amp;f=jpeg&amp;amp;s=13419&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果按照这个节奏下去，他以后的人生，不需要太努力。&lt;/p&gt;
&lt;p&gt;结果，王坚辞职了。&lt;/p&gt;
&lt;p&gt;他是技术性人才，一心只想搞科研，做系主任他不顺心。&lt;/p&gt;
&lt;p&gt;1999年，李开复正在筹备微软亚洲研究院，主要研究方向就是人机领域，李开复三顾茅庐，终于说动了王坚。&lt;/p&gt;
&lt;p&gt;加入不久之后，王坚就给微软带来了新产品：“数字墨水”。&lt;/p&gt;
&lt;p&gt;这项技术在当时并没有火起来，但如今微软的强大绘画功能就是脱胎于“数字墨水”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4e4dba61a?w=400&amp;amp;h=224&amp;amp;f=gif&amp;amp;s=919775&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了李开复，王坚还深受比尔·盖茨信任。&lt;/p&gt;
&lt;p&gt;有人写邮件给王坚，描述了他在比尔·盖茨面前提到软件的数据分析，比尔·盖茨说你应该去找王坚。&lt;/p&gt;
&lt;p&gt;那一个大牛扎堆的世界，王坚也可以算其中最特别的一个。&lt;/p&gt;
&lt;p&gt;但即便如此，王坚在这个结点，再次选择离职。&lt;/p&gt;
&lt;p&gt;时间来到2007年，王坚第一次见到马云。&lt;/p&gt;
&lt;p&gt;那时的王坚，已经做到了微软亚洲研究院副院长，出席了阿里召开的“网侠大会”。&lt;/p&gt;
&lt;p&gt;那次碰面，王坚告诉马云：&lt;/p&gt;
&lt;p&gt;“如果阿里还不掌握技术，未来将不会有它的身影。”&lt;/p&gt;
&lt;p&gt;一句话，让马云对王坚一见钟情。&lt;/p&gt;
&lt;p&gt;两年之后，王坚被马云挖了过来，给予的职位是阿里的首席架构师，首要任务就是为阿里输出技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4e50bb78e?w=640&amp;amp;h=273&amp;amp;f=jpeg&amp;amp;s=29461&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;2、只要抗住压力，就还有翻身的机会&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;加入阿里以后，王坚提出了一个中国却从未有人做过的构想——“阿里云构想”。&lt;/p&gt;
&lt;p&gt;那个时候，在中国还没有人知道什么是云计算，同事们也不知道“阿里云”是用来做什么的。&lt;/p&gt;
&lt;p&gt;于是，马云找来他就是一个错误，因为他什么都不会，只是一个溜须拍马的。刀哥在知乎上找到了一条骂王坚最恨的帖子，让大家感受一下：&lt;/p&gt;
&lt;p&gt;马总找王坚挑大梁绝对是个错误，首先这丫根本不懂技术，其次他TM太虚了，天天给你画饼；再次，这个贱人就是一个拍马屁的高手，我到现在也没想通聪明如马总怎么会被哄到那么挺他。。。难道是后来发觉骑虎难下了么。。。&lt;/p&gt;

&lt;p&gt;甚至那时阿里正召开总裁大会，有一位员工直接对马云说：马总，你别听王坚的瞎扯！他就是一个骗子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4e4ff9a31?w=500&amp;amp;h=281&amp;amp;f=gif&amp;amp;s=1482457&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在马云任命王坚担任阿里CTO的内部帖子下面，很多人留言质疑王坚，浪费钱浪费资源却一事无成，凭什么升CTO?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf4e5b53045?w=640&amp;amp;h=218&amp;amp;f=jpeg&amp;amp;s=16041&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部门考核绩效连年压线，考核没有任何依据，为什么王坚部门还不解散？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf5063dd6fd?w=640&amp;amp;h=331&amp;amp;f=jpeg&amp;amp;s=25108&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面对这一条条质疑，马云都不得不去帖子下面回复：“请相信博士（王坚），给他一点时间。”，但这并没有多少帮助，后续的阿里巴巴就像要分家了一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf505d6d808?w=563&amp;amp;h=324&amp;amp;f=jpeg&amp;amp;s=15067&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种非议中，王坚团队里的成员扛不住了。有超过一半员工离职，辞职信中他们写道：“我觉得在干下去，也看不到任何希望。”&lt;/p&gt;
&lt;p&gt;最后这个一直咬牙坚持的瘦弱大叔在阿里云事业部年会上失声痛哭，但即便眼泪止不住的流，他还手拿话筒，哽咽地给自己鼓气：&lt;/p&gt;
&lt;p&gt;“这几年我挨的骂甚至比我一辈子挨得骂还多，但是我不后悔。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf5066e12b6?w=640&amp;amp;h=315&amp;amp;f=jpeg&amp;amp;s=23301&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;3、如果困难出现，你就战斗到底&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;王坚加入阿里之后做了哪些重要贡献？&lt;/p&gt;
&lt;p&gt;以现在的标准看，当时中国的云技术恐怕只能用“一片荒芜”来形容，没人知道云计算到底是做什么的，更不知道阿里云是做什么的。&lt;/p&gt;
&lt;p&gt;王坚加入后，带着技术工程师，没日没夜地加班开发。北京的夏天酷热难当，测试系统的服务器又架在没有空调的办公室里，简直像个大熔炉，实在热得撑不住了，王坚就每天从冰场叫来两个大冰块，人工降温。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf507054056?w=640&amp;amp;h=362&amp;amp;f=jpeg&amp;amp;s=29924&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;王坚肩上扛着阿里有史以来最艰巨的任务——突破云技术。&lt;/p&gt;
&lt;p&gt;他用云技术，帮助阿里开发出一套管理城市的城市大脑。&lt;/p&gt;
&lt;p&gt;简单来说，把城市大脑跟特种车辆连接在一起，比如救护车、救火车、警车，当特种车辆出现以后，大街上看似全部都正常的红绿灯，其实，都已经被“大脑”调整过了。&lt;/p&gt;
&lt;p&gt;最后的结果是：&lt;/p&gt;
&lt;p&gt;这些特种车辆到达现场的时间，被缩短了50%，缩短的时间都成为了救命的机会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf51c10242c?w=560&amp;amp;h=314&amp;amp;f=gif&amp;amp;s=1642048&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他用云技术，帮助天猫一次一次刷新着双十一的成交记录。&lt;/p&gt;
&lt;p&gt;2011双11给技术团队留下了午夜惊魂般难忘的回忆：系统性技术问题，使大量商家可能出现超卖。&lt;/p&gt;
&lt;p&gt;次年，天猫以云计算为“塔基”，为电商及电商服务商提供IT基础设施。&lt;/p&gt;
&lt;p&gt;2018年的双11期间，阿里云上新增调用的弹性计算能力累计超过1000万核，相当于10座大型数据中心，创造了“脉冲计算”的新纪录。&lt;/p&gt;
&lt;p&gt;2015年1月，12306把车票查询业务放到了阿里云上，春运高峰期间，阿里云承担了12306系统中75%的流量，以往抢票期间系统瘫痪的情况大为改观。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf525b32560?w=640&amp;amp;h=443&amp;amp;f=jpeg&amp;amp;s=32848&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最重要的是，他让阿里真正拥有了自己的技术。&lt;/p&gt;
&lt;p&gt;2016年，阿里云为37％的中国网站保障安全，为全球76.5万用户提供云计算和大数据的服务。&lt;/p&gt;
&lt;p&gt;现在的阿里云，是阿里巴巴的一张王牌。摩根士丹利分析师认为，五年后，阿里云营收规模将达到285.83亿美元，估值将突破670亿美元。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;juejin-editor-bold&quot;&gt;4、从”骗子“到 “阿里云之父”，王坚做对了什么？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2007年与马云的相遇，改变了阿里受制于人的命运，也改变了王坚博士的人生走向。&lt;/p&gt;
&lt;p&gt;之前刀哥讲了马云相信王坚的理由，最后我们再聊一聊，为什么经历两次辞职，王坚最终选择了阿里？&lt;/p&gt;
&lt;p&gt;从”骗子“到 “阿里云之父”王坚做对了什么？&lt;/p&gt;
&lt;p&gt;1. 做对事只能赢一场，跟对人可以赢一生。&lt;/p&gt;
&lt;p&gt;王坚加入阿里，看重的是马云的坚定。&lt;/p&gt;
&lt;p&gt;2010年初，阿里小贷的总裁觉得自己快要被当时阿里云无休止的故障拖垮了，央求马云，“马总，能不能放我一马？”&lt;/p&gt;
&lt;p&gt;马云很坚定，不可以，云计算是未来。&lt;/p&gt;
&lt;p&gt;马云说，王坚说他知道大数据的方向，我信任他。如果撞墙了，这钱打水漂了，我花得起，这是战略。&lt;/p&gt;
&lt;p&gt;2. 把认真当信仰，人生就会开挂。&lt;/p&gt;
&lt;p&gt;在开发阿里云的过程中，王坚遇到了无数棘手的问题：数据传输问题、计算稳定性问题、处理速度问题，各种错误层出不穷，各种Bug形式翻新。&lt;/p&gt;
&lt;p&gt;他手下的大批工程师因为看不到阿里云的前景，又被喷地体无完肤，纷纷选择投入其他部门，或者干脆离开阿里，几乎是众叛亲离。&lt;/p&gt;
&lt;p&gt;王坚一度崩溃，当着数千人落泪。&lt;/p&gt;
&lt;p&gt;他落泪的理由，不是因为自己的艰难，而是因为很多年轻人和正在跟曾经的自己一样，做着不被人理解的事情。&lt;/p&gt;
&lt;p&gt;寂寞和争议，是创新的必经之路。&lt;/p&gt;
&lt;p&gt;阿里云的技术，让阿里巴巴的底气越来越强。&lt;/p&gt;
&lt;p&gt;在阿里巴巴上市那天，作为当时最大股东的孙正义曾说：“阿里云的前途不可限量，它是互联网的未来”。&lt;/p&gt;
&lt;p&gt;最难的事情，不是知道，而是做到。&lt;/p&gt;
&lt;p&gt;不是人人都能成为王坚，但这个”骗子“告诉我们的道理，每个人其实都做得到。&lt;/p&gt;

&lt;p&gt;往期精彩回顾&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/21/16a3edf525da8cca?w=500&amp;amp;h=278&amp;amp;f=jpeg&amp;amp;s=27769&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Apr 2019 07:53:00 +0000</pubDate>
<dc:creator>LonelyKeyGuest</dc:creator>
<og:description>阅读本文大概需要 5.6 分钟。 阅读本文大概需要 5.6 分钟。 那个骗走马云10个亿，被阿里同事指着鼻子让他滚蛋的人，后来怎么样了？ 后来，他成为阿里巴巴集团首席技术官，而且被公认为，近10年来，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdjk/p/10745476.html</dc:identifier>
</item>
<item>
<title>Python 中包/模块的 `import` 操作 - byronXIE</title>
<link>http://www.cnblogs.com/byronxie/p/10745292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byronxie/p/10745292.html</guid>
<description>&lt;blockquote readability=&quot;3.8015267175573&quot;&gt;
&lt;p&gt;版权声明：博客为作者原创，允许转载，但必须注明原文地址: &lt;a href=&quot;https://www.cnblogs.com/byronxie/p/10745292.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/byronxie/p/10745292.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建以下包结构。一个文件夹 &lt;code&gt;cookFish/&lt;/code&gt;，下面包含两个文件， &lt;code&gt;__init__.py&lt;/code&gt;和&lt;code&gt;cookBook.py&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为什么取这几个名字呢？假设我想用 Python 去做和鱼相关的菜，这件事情很复杂，所以我给它创建了一个包，名叫&lt;code&gt;cookFish&lt;/code&gt;， 既然是包，在它下面必须得创建一个文件&lt;code&gt;__init__.py&lt;/code&gt;。烧鱼必备条件之一就是菜谱，所以接着创建了 &lt;code&gt;cookBook.py&lt;/code&gt;。这几个文件对我们这次来说就足够了，所以就没有再创建其他文件了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cookFish/
    __init__.py
    cookBook.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;cookFish/__init__.py&lt;/code&gt;中输入如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__version__ = '0.1'
__author__ = 'XIE Byron'


def cookFish_hello():
    print(&quot;cookFish_Hello() from cookFish/__init__.py&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;cookFish/cookBook.py&lt;/code&gt;中输入如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cookBook_hello():
    print(&quot;cookBook_hello() from cookBook.py&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;import-package-name-都做了什么&quot;&gt;&quot;import package-name&quot; 都做了什么？&lt;/h2&gt;
&lt;p&gt;导入包&lt;code&gt;cookFish&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import cookFish&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;import&lt;/code&gt;时出现错误&lt;code&gt;ModuleNotFoundError&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
&amp;lt;ipython-input-11-18f0abd953db&amp;gt; in &amp;lt;module&amp;gt;
----&amp;gt; 1 import cookFish

ModuleNotFoundError: No module named 'cookFish'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议先将 Python 的&lt;strong&gt;当前工作目录&lt;/strong&gt;设置为 &lt;code&gt;cookFish&lt;/code&gt; 的 &lt;strong&gt;父文件夹&lt;/strong&gt;（就是包含&lt;code&gt;cookFish&lt;/code&gt;文件夹的文件夹)。命令如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.chdir(r'path\to\parent\folder\of\cookFish')&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;用&lt;code&gt;dir&lt;/code&gt;操作查看&lt;strong&gt;当前命名空间&lt;/strong&gt;和&lt;strong&gt;&lt;code&gt;cookFish&lt;/code&gt;命名空间&lt;/strong&gt;下都有哪些内容。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir() # 查看当前命名空间下的对象。注意： cookFish 在当前命名空间下。
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'cookFish', 'os']

&amp;gt;&amp;gt;&amp;gt; dir(cookFish) # 查看 cookFish 命名空间下的对象。
['__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', 'cookFish_hello']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的的 &lt;code&gt;__author__&lt;/code&gt;, &lt;code&gt;__version__&lt;/code&gt;, &lt;code&gt;cookFish_hello&lt;/code&gt; 是我们定义的，都导入到了 &lt;code&gt;cookFish&lt;/code&gt; 的命名空间下。但是&lt;code&gt;cookFish&lt;/code&gt; 下的模块 &lt;code&gt;cookBook.py&lt;/code&gt; 没有被导入。这是因为直接 &lt;code&gt;import cookFish&lt;/code&gt; 只运行&lt;code&gt;cookFish&lt;/code&gt;文件夹下的 &lt;code&gt;__init__.py&lt;/code&gt; 文件，不会运行其他模块，所以&lt;code&gt;cookBook&lt;/code&gt;没有被导入。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：Python 中的&lt;code&gt;模块&lt;/code&gt;指后缀 &lt;code&gt;.py&lt;/code&gt;的文件，也叫&lt;code&gt;脚本&lt;/code&gt;。&lt;code&gt;包&lt;/code&gt; 指包含 &lt;code&gt;__init__.py&lt;/code&gt; 文件的一个文件夹，一般还会包含其他模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;包模块的命名空间&quot;&gt;包/模块的命名空间&lt;/h2&gt;
&lt;p&gt;这里讲一下我对概念&lt;strong&gt;“在&lt;code&gt;cookFish&lt;/code&gt;的命名空间下”&lt;/strong&gt;的理解。&lt;/p&gt;
&lt;p&gt;Python 的 &lt;code&gt;import A&lt;/code&gt; 会把 &lt;code&gt;A&lt;/code&gt; 的Python 代码运行一遍，并把运行结果放在一个叫&lt;code&gt;A&lt;/code&gt;的命名空间下。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 如果 &lt;code&gt;A&lt;/code&gt; 是包，&lt;code&gt;A&lt;/code&gt; 的 Python 代码就是 文件夹A下的 &lt;code&gt;__init__.py&lt;/code&gt; 中的代码。 如果 &lt;code&gt;A&lt;/code&gt; 是模块，那么就是文件 &lt;code&gt;A.py&lt;/code&gt; 中的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;import B&lt;/code&gt;会把 &lt;code&gt;B&lt;/code&gt; 的 Python 代码运行一遍，并把运行结果放在一个叫 &lt;code&gt;B&lt;/code&gt; 的命名空间下。假设&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;中都有一个叫&lt;code&gt;X&lt;/code&gt;的对象， &lt;code&gt;A&lt;/code&gt; 中的&lt;code&gt;X&lt;/code&gt;在当前命名空间下叫 &lt;code&gt;A.X&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt;中的&lt;code&gt;X&lt;/code&gt;在当前命名空间下叫 &lt;code&gt;B.X&lt;/code&gt;，两个&lt;code&gt;X&lt;/code&gt;在当前命名空间下不重名。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;: 这里的&lt;code&gt;对象&lt;/code&gt; 指 Python 中的变量/属性，函数，类，实例等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如&lt;code&gt;__version__&lt;/code&gt;属性（或者叫它变量）就在&lt;code&gt;cookFish&lt;/code&gt;的命名空间下，我们只能通过 &lt;code&gt;cookFish.__version__&lt;/code&gt; 才能访问到 &lt;code&gt;__version__&lt;/code&gt;，直接输入 &lt;code&gt;__version__&lt;/code&gt; 访问不到它，会报错。&lt;/p&gt;
&lt;p&gt;直接输入&lt;code&gt;__version__&lt;/code&gt; 运行会报如下错误：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&amp;lt;ipython-input-4-8d40cf051c04&amp;gt; in &amp;lt;module&amp;gt;
----&amp;gt; 1 __verison__

NameError: name '__verison__' is not defined
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他导入包模块的方式&quot;&gt;其他导入包/模块的方式&lt;/h2&gt;
&lt;p&gt;如果我们想导入 &lt;code&gt;cookFish&lt;/code&gt; 下的模块 &lt;code&gt;cookBook&lt;/code&gt;呢？可以用下面的语法：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import cookFish.cookBook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就能通过全名&lt;code&gt;cookFish.cookBook&lt;/code&gt;访问&lt;code&gt;cookBook.py&lt;/code&gt;中的对象了，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cookFish.cookBook.cookBook_hello()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好长的名字啊，能不能短一点啊？当然可以&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import cookFish.cookBook as cb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就能通过别名&lt;code&gt;cb&lt;/code&gt;来访问&lt;code&gt;cookBook.py&lt;/code&gt;中的对象了，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cb.cookBook_hello()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那我能不能只导入&lt;code&gt;cookBook_hello()&lt;/code&gt;到当前命名空间？当然可以&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from cookFish.cookBook import cookBook_hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就能直接访问 &lt;code&gt;cookBook_hello()&lt;/code&gt;了，不用任何前缀：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cookBook_hello()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;from-包模块名-import-是导入所有对象吗&quot;&gt;“from 包/模块名 import *” 是导入所有对象吗？&lt;/h2&gt;
&lt;p&gt;那我可以一次性导入 &lt;code&gt;cookFish&lt;/code&gt; 下的所有模块、所有包吗？可以也不可以。&lt;/p&gt;
&lt;p&gt;Python 有一个条指令&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from 包/模块名 import *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;code&gt;from cookFish import *&lt;/code&gt;，给我们的第一感觉是，这条指令是遍历了 &lt;code&gt;cookFish&lt;/code&gt; 下的所有文件，找到这个包下面的所有包和模块，把他们统统导入到当前命名空间。&lt;/p&gt;
&lt;p&gt;但不幸的是，这个操作在windows和Mac系统上不能很好地实现。因为它们的文件系统不能提供准确的文件名大小写信息。在这两个平台上，Python 不知道应该把&lt;code&gt;ECHO.py&lt;/code&gt;导入为模块&lt;code&gt;echo&lt;/code&gt;, &lt;code&gt;Echo&lt;/code&gt; 还是&lt;code&gt;ECHO&lt;/code&gt;，或者其他。（比如windows 95 上面，所有文件名的首字母都会显示为大写)。如果Python 把 &lt;code&gt;ECHO.py&lt;/code&gt;导入为 模块&lt;code&gt;Echo&lt;/code&gt;，但实际Python代码中有时按照 &lt;code&gt;echo&lt;/code&gt; 使用的，那肯定会报错。[1]&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Python 支持大小写，&lt;code&gt;Echo&lt;/code&gt;和&lt;code&gt;ECHO&lt;/code&gt;是两个不一样的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python 的唯一的解决办法是包的作者提供一个明确的包的索引，告诉 Python 在 Python 代码中如何命名这个模块。import 语句定义下面一个约定，如果在包的 &lt;code&gt;__init__.py&lt;/code&gt; 中定义了一个 &lt;code&gt;__all__&lt;/code&gt; 列表，在 &lt;code&gt;from xxx import *&lt;/code&gt; 时，Python 就会把 &lt;code&gt;__all__&lt;/code&gt; 列表中的对象导入。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;! 注意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__all__&lt;/code&gt; 只对 &lt;code&gt;from xxx import *&lt;/code&gt; 有影响，对其他 import 操作没有任何影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;cookFish/__init__.py&lt;/code&gt;中， 我们只把函数 &lt;code&gt;cookFish_hello&lt;/code&gt;加入&lt;code&gt;__all__&lt;/code&gt; 中，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;__all__ = ['cookFish_hello', ] # added to support `from xxx import *`

__version__ = '0.1'
__author__ = 'XIE Byron'

def cookFish_hello():
    print(&quot;cookFish_Hello() from cookFish/__init__.py&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启&lt;/strong&gt; Python 解释器，运行如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from cookFish import *&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;! 注意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Python 解释器为了提高运行效率，同一个模块只会导入一次。一个模块被导入后，再次运行导入命名不会重新导入。所以需要&lt;strong&gt;重启&lt;/strong&gt; Python 解释器（就是关闭 Python 解释器，然后重新进入)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后输入 &lt;code&gt;dir()&lt;/code&gt; 查看 &lt;code&gt;cookFish_Hello()&lt;/code&gt;是否被导入到了当前命名空间.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'cookFish_hello', 'os']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到只有在&lt;code&gt;__all__&lt;/code&gt;列表中的 &lt;code&gt;cookFish_hello&lt;/code&gt;被导入到当前命名空间。&lt;/p&gt;
&lt;p&gt;所以问题“可以一次性导入 &lt;code&gt;cookFish&lt;/code&gt; 下的所有模块、所有包吗？“ 的答案是：是否能一次导入，取决于包的作者有没有把所有子模块/子包都加入到 &lt;code&gt;__all__&lt;/code&gt;列表中。&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://www.python.org/doc/essays/packages/&quot;&gt;Built-in Package Support in Python 1.5&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 07:40:00 +0000</pubDate>
<dc:creator>byronXIE</dc:creator>
<og:description>Python 中包/模块的 操作 版权声明：博客为作者原创，允许转载，但必须注明原文地址: https://www.cnblogs.com/byronxie/p/10745292.html 创建以下包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/byronxie/p/10745292.html</dc:identifier>
</item>
<item>
<title>[区块链专栏|非对称加密] 对数字证书（CA认证）原理的回顾 - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/10745376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/10745376.html</guid>
<description>&lt;p&gt;&lt;span&gt;摘要：文中首先解释了加密解密的一些基础知识和概念，然后通过一个加密通信过程的例子说明了加密算法的作用，以及数字证书的出现所起的作用。接着对数字证书做一个详细的解释，并讨论一下windows中数字证书的管理，最后演示使用makecert生成数字证书。【注，转载自一篇2010年的技术文章，虽然时间有点久了，但是原理介绍的很清楚，可做为参考】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1、基础知识&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;      这部分内容主要解释一些概念和术语，最好是先理解这部分内容。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.1、公钥密码体制(public-key cryptography)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.2、对称加密算法(symmetric key algorithms)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; // 密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1.3、非对称加密算法(asymmetric key algorithms)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.4、RSA简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，&lt;strong&gt;RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.5、签名和加密&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。 比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里主要解释一下签名，签名就是在&lt;strong&gt;信息&lt;/strong&gt;的后面再加上一段内容，可以证明&lt;strong&gt;信息&lt;/strong&gt;没有被修改过，怎么样可以达到这个效果呢？一般是对&lt;strong&gt;信息&lt;/strong&gt;做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的&lt;strong&gt;信息&lt;/strong&gt;内容。在把&lt;strong&gt;信息&lt;/strong&gt;发送出去时，把这个hash值加密后做为一个签名和&lt;strong&gt;信息&lt;/strong&gt;一起发出去。 接收方在收到&lt;strong&gt;信息&lt;/strong&gt;后，会重新计算&lt;strong&gt;信息&lt;/strong&gt;的hash值，并和&lt;strong&gt;信息&lt;/strong&gt;所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据&lt;strong&gt;信息&lt;/strong&gt;内容计算的hash值就会变化。当然，不怀好意的人也可以修改&lt;strong&gt;信息&lt;/strong&gt;内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和&lt;strong&gt;信息&lt;/strong&gt;一起发送，以保证这个hash值不被修改。至于如何让别人可以解密这个签名，这个过程涉及到数字证书等概念，我们后面在说到数字证书时再详细说明，这里您先只需先理解签名的这个概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、一个加密通信过程的演化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.1 第一回合：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：？？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：你好&lt;/strong&gt;  &lt;/span&gt;      // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此通信过程可以改进为如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2 第二回合：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;// &lt;/strong&gt;注&lt;/span&gt;意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]&lt;strong&gt;  就表示用私钥对&lt;/strong&gt;“你好，我是服务器”&lt;strong&gt;进行加密后的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是男人}[私钥|RSA] 发给客户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由男人发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为用“服务器”用私钥加密后的内容，&lt;strong&gt;由并且只能由&lt;/strong&gt;公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设“黑客”想冒充“服务器”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]&lt;/strong&gt;  &lt;/span&gt;  //这里黑客无法冒充，因为他不知道&lt;strong&gt;私钥&lt;/strong&gt;，无法用&lt;strong&gt;私钥&lt;/strong&gt;加密某个字符串后发送给客户去验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“客户”-&amp;gt;“黑客”：？？？？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.3 第三回合：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。&lt;span&gt;所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。&lt;/span&gt;然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.4 第四回合：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：{我们后面的通信过程，用对称加密来进行，这里是&lt;span&gt;对称加密算法&lt;/span&gt;和&lt;span&gt;密钥&lt;/span&gt;}[公钥|RSA]   &lt;/span&gt;&lt;span&gt; //&lt;span&gt;蓝色字体&lt;/span&gt;的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{OK，收到！}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{你的余额是100元}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。&lt;span&gt;注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这个两个方法都有一定的问题，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“客户”-&amp;gt;“黑客”：你好&lt;/span&gt;           //黑客截获“客户”发给“服务器”的消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器，这个是我的公钥&lt;/span&gt;    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“黑客”：向我证明你就是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“黑客”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]  &lt;/span&gt;    //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。&lt;strong&gt;这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 &lt;/strong&gt;如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;证书的发布机构&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;证书的有效期&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;公钥&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;证书所有者（Subject）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;签名所使用的算法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指纹以及指纹算法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，&lt;strong&gt;数字证书可以保证&lt;/strong&gt;数字&lt;/span&gt;证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5 第五回合：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书&lt;/span&gt;        //这里用证书代替了公钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.6 完整过程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step1&lt;/strong&gt;： “客户”向服务端发送一个通信请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：你好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step2&lt;/strong&gt;： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：你好，我是服务器，这里是我的数字证书 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step3&lt;/strong&gt;： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：向我证明你就是服务器，这是一个随机字符串 &lt;/span&gt;    //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{一个随机字符串}[私钥|RSA]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step4&lt;/strong&gt;： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“客户”-&amp;gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“服务器”-&amp;gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;span&gt; //继续其它的通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.7 其它问题：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【问题1】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;〖解决方法〗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【问题2】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;〖解决方法〗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【问题3】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;〖解决方法〗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3. 证书的构成和原理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;3.1 证书的构成和原理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;之前已经大概说了一个证书由什么构成，但是没有仔细进行介绍，这里对证书的内容做一个详细的介绍。先看下一个证书到底是个什么东西，在windows下查看一个证书时，界面是这样的，我们主要关注一下Details Tab页，其中的内容比较长，我滚动内容后后抓了三个图，把完整的信息显示出来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/certificateDetails.png&quot;&gt;&lt;img title=&quot;certificateDetails&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/certificateDetails_thumb.png&quot; alt=&quot;certificateDetails&quot; width=&quot;1242&quot; height=&quot;481&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面的内容比较多——Version、Serial number、Signature algorithm 等等，挑几个重要的解释一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Issuer (证书的发布机构)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。对于上面的这个证书来说，就是指&quot;SecureTrust CA&quot;这个机构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Valid from , Valid to (证书的有效期)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是证书的有效时间，或者说证书的使用期限。 过了有效期限，证书就会作废，不能使用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Public key (公钥)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个我们在前面介绍公钥密码体制时介绍过，公钥是用来对消息进行加密的，第2章的例子中经常用到的。这个数字证书的公钥是2048位的，它的值可以在图的中间的那个对话框中看得到，是很长的一串数字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Subject (主题)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 对于这里的证书来说，证书的所有者是Trustwave这个公司。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Signature algorithm (签名所使用的算法)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名(第1.5节中解释过数字签名)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;◆Thumbprint, Thumbprint algorithm (指纹以及指纹算法)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个是用来保证证书的完整性的，也就是说确保证书没有被修改过，这东西的作用和2.7中说到的第3个问题类似。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。 注意，这个指纹会使用&quot;SecureTrust CA&quot;这个证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。这里问题又来了，证书的指纹和指纹算法用什么加密呢？他们是用证书发布机构的私钥进行加密的。可以用证书发布机构的公钥对指纹和指纹算法解密，&lt;strong&gt;也就是说证书发布机构除了给别人发布证书外，他自己本身也有自己的证书&lt;/strong&gt;。证书发布机构的证书是哪里来的呢？？？这个证书发布机构的数字证书(一般由他自己生成)在我们的操作系统刚安装好时(例如windows xp等操作系统)，这些证书发布机构的数字证书就已经被微软(或者其它操作系统的开发机构)安装在操作系统中了，微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认就安装在操作系统里面了，并且设置为操作系统信任的数字证书。这些证书发布机构自己持有与他自己的数字证书对应的私钥，他会用这个私钥加密所有他发布的证书的指纹作为数字签名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.2 如何向证书的发布机构去申请证书&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;举个例子方便大家理解，假设我们公司&quot;ABC Company&quot;花了1000块钱，向一个证书发布机构&quot;SecureTrust CA&quot;为我们自己的公司&quot;ABC Company&quot;申请了一张证书，注意，这个证书发布机构&quot;SecureTrust CA&quot;是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了&quot;SecureTrust CA&quot;的证书。&quot;SecureTrust CA&quot;在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时&quot;SecureTrust CA&quot;还会给一个我们公司&quot;ABC Company&quot;的私钥给到我们。我们花了1000块钱买的这个证书的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;×××××××××××××××证书内容开始×××××××××××××××××&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Issuer : SecureTrust CA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Subject : ABC Company&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Valid from ： 某个日期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Valid to： 某个日期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Public Key : 一串很长的数字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;…… 其它的一些证书内容……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{证书的指纹和计算指纹所使用的指纹算法}[SecureTrust CA的私钥|RSA]      //这个就是&quot;SecureTrust CA&quot;对这个证书的一个数字签名，表示这个证书确实是他发布的，有什么问题他会负责(收了我们1000块，出了问题肯定要负责任的)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;×××××××××××××××证书内容结束×××××××××××××××××&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;               // 记不记得我们前面的约定？{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们&quot;ABC Company&quot;申请到这个证书后，我们把证书投入使用，我们在通信过程开始时会把证书发给对方，对方如何检查这个证书的确是合法的并且是我们&quot;ABC Company&quot;公司的证书呢？首先应用程序(对方通信用的程序，例如IE、OUTLook等)读取证书中的Issuer(发布机构)为&quot;SecureTrust CA&quot; ，然后会在操作系统中受信任的发布机构的证书中去找&quot;SecureTrust CA&quot;的证书，如果找不到，那说明证书的发布机构是个水货发布机构，证书可能有问题，程序会给出一个错误信息。 如果在系统中找到了&quot;SecureTrust CA&quot;的证书，那么应用程序就会从证书中取出&quot;SecureTrust CA&quot;的公钥，然后对我们&quot;ABC Company&quot;公司的证书里面的指纹和指纹算法用这个公钥进行解密，然后使用这个指纹算法计算&quot;ABC Company&quot;证书的指纹，将这个计算的指纹与放在证书中的指纹对比，如果一致，说明&quot;ABC Company&quot;的证书肯定没有被修改过并且证书是&quot;SecureTrust CA&quot; 发布的，证书中的公钥肯定是&quot;ABC Company&quot;的。对方然后就可以放心的使用这个公钥和我们&quot;ABC Company&quot;进行通信了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;★这个部分非常重要，一定要理解，您可以重新回顾一下之前的两章“1、基础知识”和“ 2、一个加密通信过程的演化”，然后再来理解这部分的内容。后面在Https的配置演示中，我还会再举例子说明证书的构成和原理。如果您把这节的内容看了几遍还没有搞懂证书的工作原理，您可以留言指出我没有说清楚的内容，我好方便进行修正。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.3 证书的发布机构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;前面已经初步介绍了一下证书发布机构，这里再深入讨论一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实所有的公司都可以发布证书，我们自己也可以去注册一家公司来专门给别人发布证书。但是很明显，我们自己的专门发布证书的公司是不会被那些国际上的权威机构认可的，人家怎么知道你是不是个狗屁皮包公司？因此微软在它的操作系统中，并不会信任我们这个证书发布机构，当应用程序在检查证书的合法信的时候，一看证书的发布机构并不是操作系统所信任的发布机构，就会抛出错误信息。也就是说windows操作系统中不会预先安装好我们这个证书发布机构的证书，不信任我们这个发布机构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不受信任的证书发布机构的危害&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么一个证书发布机构受不受信任这么重要？我们举个例子。假设我们开了一个狗屁公司来为别人发布证书，并且我和微软有一腿，微软在他们的操作系统中把我设置为了受信任的证书发布机构。现在如果有个小公司叫Wicrosoft 花了10块钱让我为他们公司申请了一个证书，并且公司慢慢壮大，证书的应用范围也越来越广。然后有个奸商的公司JS Company想冒充Wicrosoft，于是给了我￥10000，让我为他们颁布一个证书，但是证书的名字(Subject)要写Wicrosoft，假如我为了这￥10000，真的把证书给了他们，那么他们以后就可以使用这个证书来冒充Wicrosoft了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是一个优秀的证书发布机构，比如你要向他申请一个名字叫Wicrosoft的证书，它会让你提供很多资料证明你确实可以代表Wicrosoft这个公司，也就是说他回去核实你的身份。证书发布机构是要为他发布出的证书负法律责任的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，你可能会想，TMD，那我们自己就不能发布证书吗？就一定要花钱去申请？当然不是，我们自己也可以成立证书发布机构，但是需要通过一些安全认证等等，只是有点麻烦。另外，如果数字证书只是要在公司内部使用，公司可以自己给自己生成一个证书，在公司的所有机器上把这个证书设置为操作系统信任的证书发布机构的证书(这句话仔细看清楚，有点绕口)，这样以后公司发布的证书在公司内部的所有机器上就可以通过验证了(在发布证书时，把这些证书的Issuer(发布机构)设置为我们自己的证书发布机构的证书的Subject(主题)就可以了)。但是这只限于内部应用，因为只有我们公司自己的机器上设置了信任我们自己这个所谓的证书发布机构，而其它机器上并没有事先信任我们这个证书发布机构，所以在其它机器上，我们发布的证书就无法通过安全验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4. 在windows中对数字证书进行管理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;4.1 查看、删除、安装 数字证书&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们在上一章中说到了，我们的操作系统中会预先安装好一些证书发布机构的证书，我们看下在windows中如何找到这些证书，步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)开始菜单-&amp;gt;运行，输入mmc，回车&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)在打开的窗口中选择 File-&amp;gt; Add/Remove Snap-in…&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)然后在弹出的对话框的 Standalone Tab页里面点击 Add… 按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4)在弹出的对对话框中选择 certificates 后点击 Add 按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的步骤如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://pic002.cnblogs.com/img/jeffery.sun/200912/2009121816032340.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的步骤结束后，会又弹出一个对话框，里面有三个单选按钮如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;My user account&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Service account&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Computer account&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以选择第一或者第三个选项，用来查看当前用户的证书或整个计算里面安装的证书。我们这里就默认选择第一个，平时一般安装证书的时候都会给所有用户安装，所以选择第一个和第三个选项看到的证书会差不多。我们在左边的导航树中选中受信任的证书发布机构(Trusted Root Certificate Authorities)，然后点击下面的证书(Certificates)，在右边的区域中就可以看到所有的受信任的证书发布机构的证书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/trustedcaAuth.png&quot;&gt;&lt;img title=&quot;trustedcaAuth&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/trustedcaAuth_thumb.png&quot; alt=&quot;trustedcaAuth&quot; width=&quot;773&quot; height=&quot;294&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意上面的图片中，右边我们选中的这个证书发布机构&quot;SecureTrust CA&quot;，我们前面在第3章3.2节中举例子的时候，就是去向这个证书发布机构申请的证书，由于我们申请的证书是这个机构发布的，所以应用程序在检查我们的证书的发布机构时(会检查我们证书的签名，确认是该机构发布的证书)，就会发现是可以信任的证书发布机构，从而就会相信我们证书的真实性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除数字证书很简单，直接在右边的列表中右键然后删除就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数字证书的安装也比较简单，直接双击数字证书文件，会打开数字证书，对话框下面会有一个Install Certificate按钮，点击后就可以根据向导进行安装，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/installCertificate_1.png&quot;&gt;&lt;img title=&quot;installCertificate&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/installCertificate_thumb_1.png&quot; alt=&quot;installCertificate&quot; width=&quot;919&quot; height=&quot;479&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个证书是我自己生成的测试证书，在证书的导入向导里面，它会让你选择导入到什么位置，如果是一个我们自己信任的证书发布机构自己的证书，只要导入到Certificate Authorities就可以了。Trusted Root Certificate Authorities, Intermediate Certification Authorities, Third-Party Root Certification Authorities 都是可以的，他们只是对证书的发布机构做了一个分类，还有一些其它的证书类型，例如Personal(个人证书)等等，具体就不介绍了。安装的时候一般来说可以用默认的选择项一直&quot;下一步&quot;到底。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.2 如何自己创建证书&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;每个证书发布机构都有自己的用来创建证书的工具，当然，具体他们怎么去创建一个证书的我也不太清楚。 微软为我们提供了一个用来创建证书的工具makecert.exe，在安装Visual Studio的时候会安装上。如果没有安装也无所谓，可以上网去下一个，搜索&lt;strong&gt;makecert&lt;/strong&gt;就可以了。如果对我放心的话，可以直接从我的博客下载，这是&lt;a href=&quot;http://files.cnblogs.com/JefferySun/makecert.zip&quot;&gt;链接&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向一些正规的证书发布机构申请证书一般是要收费的(因为别人要花时间检查你的身份，确认有没有同名的证书等等)，这里我们看下如何自己创建一个证书，为后面在IIS中配置Https做准备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用到的是&lt;strong&gt;makecert&lt;/strong&gt;这个工具，微软有很详细的使用帮助，我这里只做一个简单的解释，详细的各种参数和使用方法请查看&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/bfsktky3(VS.80).aspx&quot;&gt;MSDN的makecert的帮助&lt;/a&gt;。但是里面有些参数说得不够清楚，而且还有遗漏的，可以参看我后面的解释作为一个补充。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看下&lt;strong&gt;makecert&lt;/strong&gt;最简单的使用方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;makecert.exe test.cer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的命令会在makecert.exe所在的目录生成一个证书文件test.cer的数字证书文件。可以双击证书打开，看看证书的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/testCertificate1.png&quot;&gt;&lt;img title=&quot;testCertificate1&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/JefferySun/WindowsLiveWriter/aba748e7a228_8B56/testCertificate1_thumb.png&quot; alt=&quot;testCertificate1&quot; width=&quot;410&quot; height=&quot;274&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;证书的发布机构是&quot;Root Agency&quot;，证书的主题(证书发布给谁)是&quot;Joe’s-Software-Emporium&quot;，因为我们没有指定把证书发布给谁，makecert自己给我们随便生成了一个公司的名字。另外还指定了公钥、签名算法(用来解密签名)、指纹和指纹算法等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;，因为这个证书是由微软的工具生成的，严格来说它没什么发布机构，所以微软虚拟了一个叫做&quot;Root Agency&quot;的发布机构，默认情况下，windows里面安装了这个所谓的证书发布机构的证书，但是这证书默认情况下不是受信任的，原因很简单，这样做大家都可以用makecert来制作合法的数字证书了。如果我们自己硬是要，也可以把它设置为受信任的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们看下其它的参数，比如我们要给网站 www.jefferysun.com 生成一个证书MyCA.cer，假设我们把makecert.exe放在C：盘下，命令行如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;makecert -r -pe -n &quot;CN=10.30.146.206&quot; -b 01/01/2000 -e 01/01/2036 -eku 1.3.6.1.5.5.7.3.1 -ss my -sr localMachine -sky exchange -sp &quot;Microsoft RSA SChannel Cryptographic Provider&quot; -sy 12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C:/&amp;gt; makecert.exe –pe -r  –n  &quot;CN=www.jefferysun.com&quot; -ss my -sr LocalMachine -a sha1 -len 2048  MyCA.cer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释一下makecert的常用参数的意思：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;-n&lt;/strong&gt; 指定主题的名字，这个是有固定的格式的， CN=主题名字 ，CN应该是Certificate Name的缩写。我这里的主题的名字就是我们的IIS所在机器的IP。这里可以指定一些主题的其它附加信息，例如 O= *** 表示组织信息等等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-r&lt;/strong&gt; 创建自签署证书，意思就是说在生成证书时，将证书的发布机构设置为自己。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-pe&lt;/strong&gt; 将所生成的私钥标记为可导出。注意，服务器发送证书给客户端的时候，客户端只能从证书里面获取公钥，私钥是无法获取的。如果我们指定了这个参数，证书在安装在机器上后，我们还可以从证书中导出私钥，默认情况下是不能导出私钥的。正规的途径发布的证书，是不可能让你导出私钥的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-b –e&lt;/strong&gt; 证书的有效期&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-ss&lt;/strong&gt; 证书的存储名称，就是windows证书存储区的目录名，如果不存在在的话就创建一个。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-sr&lt;/strong&gt; 证书的存储位置，只有currentuser（默认值）或 localmachine两个值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-sv&lt;/strong&gt; 指定保存私钥的文件，文件里面除了包含私钥外，其实也包含了证书。这个文件是需要保密的，这个文件在服务端配置时是需要用到的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个CN=10.30.146.206要与自己的服务器相对应，要不然在配置HTTPS的时候会出现错误&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-a&lt;/strong&gt; 指定签名算法，必须是md5或rsa1。(还记得签名算法的作用不？可以看一下3章的第1节中关于签名算法的介绍)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-in&lt;/strong&gt; 指定证书发布机构的名称&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;-len&lt;/strong&gt; 这个参数在中文的帮助文档中好像没有提到，但是这个其实很重要，用于指定公钥的位数，越大越安全，默认值是1024，推荐2048。我试了下，这个不为1024的倍数也是可以的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/zhulinfeiba/article/details/5957028&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zhulinfeiba/article/details/5957028&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 07:36:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<og:description>摘要：文中首先解释了加密解密的一些基础知识和概念，然后通过一个加密通信过程的例子说明了加密算法的作用，以及数字证书的出现所起的作用。接着对数字证书做一个详细的解释，并讨论一下windows中数字证书的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/10745376.html</dc:identifier>
</item>
<item>
<title>百度面试两板斧：手写算法问基础 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/10745150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10745150.html</guid>
<description>&lt;p&gt;阅读本文大概需要 4 分钟。&lt;/p&gt;

&lt;p&gt;17年7月份，我参加了百度的实习生面试，随后在百度开始了半年的实习生活，18年7月份，我参加了百度的校招提前批面试，由于可以同时参加百度多个部门的提前批面试，结果我前前后后面试了10多次，也算是一段比较奇葩的经历了。&lt;/p&gt;

&lt;p&gt;当然，实习生面试是这里面最简单的一次了，三轮面试，前两轮都是在问基础，问的也不深入，第三轮面试则直接谈人生谈理想。其实百度的日常实习生面试难度确实比校招要来的容易，因为百度一年四季都在招实习生，反观阿里和腾讯，只有在春招期间招收实习生。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtZuP8ZeyB4FxABia27ibibb1kAiaf6KJwnvfZECgiaSL6MIickdvG2kc2rOww/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtZuP8ZeyB4FxABia27ibibb1kAiaf6KJwnvfZECgiaSL6MIickdvG2kc2rOww/640?wx_fmt=jpeg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtZuP8ZeyB4FxABia27ibibb1kAiaf6KJwnvfZECgiaSL6MIickdvG2kc2rOww/640?wx_fmt=jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;既然上面的面试难度不太具有代表性，那么我还是来说说秋招的百度面试经历吧。&lt;/p&gt;

&lt;p&gt;大家都知道，阿里内部用Java居多，腾讯内部用C++居多，而百度内部的语言则是五花八门，Java、C++、Python、PHP，都有一定数量的人在用，所以百度的面试题也会比较杂，什么都有可能考，但亦不会考的特别难。&lt;/p&gt;

&lt;p&gt;手写算法是百度秋招必考的一个环节，我那时候都是电话面试，所以直接是用在线写代码的网站来做题的（面试官可以实时看到你的代码情况）手写算法一般是压轴环节，也就是面试官问完基础题，就会开始让你写算法题。&lt;/p&gt;

&lt;p&gt;题目的难度也不尽相同，有的面试官让我写过二叉树相关的简单题，也有面试官让我写DFS、BFS的题目，当然，多数题目还是剑指offer上的题目，以及基础题：字符串问题、快排、二分查找、二分查找变式等。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewt6SjIxZSIWDCq1nLqERP4GSialYCNTXOy1WOAVbDuvFicn5ic8Kjqb5b1A/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewt6SjIxZSIWDCq1nLqERP4GSialYCNTXOy1WOAVbDuvFicn5ic8Kjqb5b1A/640?wx_fmt=jpeg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewt6SjIxZSIWDCq1nLqERP4GSialYCNTXOy1WOAVbDuvFicn5ic8Kjqb5b1A/640?wx_fmt=jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是，面试官会允许你在本地IDE进行调试，这样一来可以节省你的时间。&lt;/p&gt;

&lt;p&gt;在开始写代码前，面试官一般会先问你的思路，假如他没有问，那你也要主动告诉他，要知道，考察算法题的时候，和面试官的有效沟通也是一个很重要的考察点，否则你可能会漏掉关键信息，以至于无法完成后续答题。&lt;/p&gt;

&lt;p&gt;当然，打铁还需自身硬，最关键的一点是，你需要花大量时间刷题，积累经验，保持做题手感，剑指offer上的题目基本要掌握，LeetCode的经典题型必须重视，刷题是一件你需要不断坚持的事情，就和考研前需要不断做数学题一样，都是一个道理。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtWxJ8yNap6nbVlFgrVQQFicEyaMKQOd0lGGFkRhCWwVOV64t1nPW7m6Q/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtWxJ8yNap6nbVlFgrVQQFicEyaMKQOd0lGGFkRhCWwVOV64t1nPW7m6Q/640?wx_fmt=jpeg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_jpg/hbTNOSuicwltPXqKud06xicqyJqemnxewtWxJ8yNap6nbVlFgrVQQFicEyaMKQOd0lGGFkRhCWwVOV64t1nPW7m6Q/640?wx_fmt=jpeg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;讲了这么多关于手写算法方面的内容，可能你已经萌生退意了，那我们还是把话题移回到简单粗暴的基础问题吧，计算机网络、操作系统、数据结构这三门课程，百度一样喜欢考，不过难度适中，一般只会考比较基础的问题，比如TCP/IP三次握手、四次挥手，线程和进程的区别，内存管理方式等等。&lt;/p&gt;

&lt;p&gt;最后要说的是，百度最喜欢考察的一类题目，叫做海量数据问题，虽然现在越来越多公司都喜欢考这个，但是百度可以说是这类题目的创始人。&lt;/p&gt;

&lt;p&gt;所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。&lt;/p&gt;

&lt;p&gt;如果大家对这块内容感兴趣，那么我推荐一个大牛的博客，对这方面内容做了很全面的整理，可能很多人已经看过：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/v_july_v/article/details/7382693&lt;/p&gt;

&lt;p&gt;关于百度面试的内容，我就总结这么多了，当然，大部分是针对校招同学的面试题，至于社招的朋友，则更多地会和部门需求匹配，考察的重点也不再是上述这些基础知识和算法题了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果仍有疑问，也可以留言参与互动噢。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/1hReHaqafafJYoFH7OAhmUdTjo35vvJTy1lRVjG2CzFP3arfVRDqI7a8PSS6Sx5LialaFTE1HFu2N4OIhL8jP9g/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一介码农，尚能写作，我是黄小斜，不是黄老邪噢&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247485147&amp;amp;idx=1&amp;amp;sn=321b126865f14f902dd92eef988e61b8&amp;amp;chksm=fa59c11ccd2e480ab804e074a31fca61fd5753d00c85b909fe7a1d91d19df8661b4aa8f04356&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk5NDQwOA==&amp;amp;mid=2247485147&amp;amp;idx=1&amp;amp;sn=321b126865f14f902dd92eef988e61b8&amp;amp;chksm=fa59c11ccd2e480ab804e074a31fca61fd5753d00c85b909fe7a1d91d19df8661b4aa8f04356&amp;amp;scene=21#wechat_redirect&quot;&gt;记一次面试腾讯的奇葩经历&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sia0of2KNSKbtKL4fYPN64yxHoRLQ03zUoNb8keqpHj14Qpb9v9s5YuNKbYnJfwJMfrVTdA6m13vfk7LLXrO9NQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Sia0of2KNSKbtKL4fYPN64yxHoRLQ03zUoNb8keqpHj14Qpb9v9s5YuNKbYnJfwJMfrVTdA6m13vfk7LLXrO9NQ/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/Sia0of2KNSKbtKL4fYPN64yxHoRLQ03zUoNb8keqpHj14Qpb9v9s5YuNKbYnJfwJMfrVTdA6m13vfk7LLXrO9NQ/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你点的每个好看，我都认真当成了喜欢&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 06:54:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>阅读本文大概需要 4 分钟。 17年7月份，我参加了百度的实习生面试，随后在百度开始了半年的实习生活，18年7月份，我参加了百度的校招提前批面试，由于可以同时参加百度多个部门的提前批面试，结果我前前后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10745150.html</dc:identifier>
</item>
<item>
<title>软件构造 第二章 软件构建的过程和工具 - Boston丶o</title>
<link>http://www.cnblogs.com/boston-o/p/10745088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boston-o/p/10745088.html</guid>
<description>
&lt;p&gt;&lt;span&gt;第一部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、软件的生命周期&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.from zero to one&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计划、分析、设计、实现、测试、维护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.from 1 to  n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件的更新与老化、&lt;/span&gt;&lt;span&gt;不同软件之间相互取代演化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421093213146-1969740433.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;72&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421095126286-1905482394.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、经典软件模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个基础类型：线性、迭代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现有模型：瀑布模型、增量模型、V模型、原型法、螺旋模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑的关键因素：适应变化的能力、开发效率、项目管理复杂性、软件质量&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.瀑布模型：线性模型&lt;/p&gt;
&lt;p&gt;按步骤依次实现。利于使用，应对变化代价高&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421102426641-45014295.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.增量模型：非迭代&lt;/p&gt;
&lt;p&gt;将整个产品分成不同的增量，逐一完成。&lt;/p&gt;
&lt;p&gt;以增量的方式实施瀑布模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421103110351-1842431550.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.V模型：线性模型&lt;/p&gt;
&lt;p&gt;瀑布模型的扩展，强化测试&lt;/p&gt;
&lt;p&gt;强化测试：对代码、文件进行分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421103326913-2088657750.png&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.原型法：迭代模型&lt;/p&gt;
&lt;p&gt;实现系统的原型：原型模拟最终产品的几个方面，甚至完全不同&lt;/p&gt;
&lt;p&gt;过程：分析基础要求（细节可忽略）、开发初始模型、评论、修改和增强原型&lt;/p&gt;
&lt;p&gt;优点：在项目早期可以获得用户的反馈、用户判断软件是否符合规格说明、对软件进行估算&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421104426008-1825096245.png&quot; alt=&quot;&quot; width=&quot;272&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.螺旋模型：迭代模型&lt;/p&gt;
&lt;p&gt;一种风险驱动的过程模型，每做完一个层面进行评估&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421105247676-164586023.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、敏捷开发&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.开发宣言：提倡适应性规划、演化开发、 尽早交付和持续改进，并鼓励对变化作出快速和灵活的响应。&lt;/p&gt;
&lt;p&gt;人以及人与人的互动胜于过程和工具&lt;/p&gt;
&lt;p&gt;可运行的软件胜于面面俱到的文档&lt;/p&gt;
&lt;p&gt;客户合作胜于合同谈判&lt;/p&gt;
&lt;p&gt;响应变化生于遵循计划&lt;/p&gt;
&lt;p&gt;2.快速迭代&lt;/p&gt;
&lt;p&gt;用户参与、短期开发、大量测试、&lt;/p&gt;
&lt;p&gt;3.极限编程&lt;/p&gt;
&lt;p&gt;原型、持续发布、自动构建、结对编程、测试驱动的开发&lt;/p&gt;

&lt;p&gt; &lt;span&gt;四、协同软件开发&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开源软件构建模型：没有协同管理控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;细节：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421120823170-1568878010.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;439&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五、软件配置管理（SCM）和版本控制系统（VCS）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; SCM的任务是追踪与控制软件中的变化&lt;/p&gt;
&lt;p&gt;1)SCM实际任务是版本控制和建立基线&lt;/p&gt;

&lt;p&gt;软件配置项是软件配置管理的基本单位，任何需要管理 的要素都时软件配置项（源代码、数据、文档、软硬件、环境等）&lt;/p&gt;
&lt;p&gt;基线 是在某时间点上，通过评审和认可后的版本，作为后续变化的基点。&lt;/p&gt;

&lt;p&gt; 2)分支和进化图（属于SCI或一个系统）&lt;/p&gt;
&lt;p&gt; 在分支上进行并行开发，如测试新功能 &lt;/p&gt;
&lt;p&gt; 其他人员不想在新功能完成之前涉及新功能 &lt;/p&gt;
&lt;p&gt; 分支对单个开发人员也很有用 &lt;/p&gt;
&lt;p&gt; 通过正确的设置，任何程序员都可以 从任何位置拉出或推送到任何位置，从而在合作模式中创造出极大的灵 活性。&lt;/p&gt;

&lt;p&gt;版本控制系统（VCS）&lt;/p&gt;
&lt;p&gt;Local VCS 本地管理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421122449140-484192193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Centralized VCS 集中式管理，通过云端交互&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421122507055-1254809171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Distributed VCS（eg：git）分布式管理，用户直接交互或通过云端交互&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421122520068-1237860570.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;

&lt;p&gt;版本控制术语：&lt;/p&gt;
&lt;p&gt;▪存储库：我们项目中版本的本地或远程存储&lt;/p&gt;
&lt;p&gt;▪工作副本：我们可以处理的项目的本地可编辑副本&lt;/p&gt;
&lt;p&gt;▪文件：我们项目中的单个文件&lt;/p&gt;
&lt;p&gt;▪版本或修订版：内容的记录我们在某个时间点的项目&lt;/p&gt;
&lt;p&gt;▪改变或差异：两个版本之间的差异&lt;/p&gt;
&lt;p&gt;▪头部：当前版本&lt;/p&gt;

&lt;p&gt;版本控制系统的功能&lt;br/&gt;▪可靠：只要我们需要，就可以保留版本; 允许备份&lt;/p&gt;
&lt;p&gt;▪多个文件：跟踪项目的版本，而不是单个文件&lt;/p&gt;
&lt;p&gt;▪有意义的版本：变化是什么，为什么要制作？&lt;/p&gt;
&lt;p&gt;▪还原：全部或部分还原旧版本&lt;/p&gt;
&lt;p&gt;▪比较版本&lt;/p&gt;
&lt;p&gt;▪查看历史记录：整个项目或单个文件&lt;/p&gt;
&lt;p&gt;▪不仅仅是代码：散文，图片，...&lt;/p&gt;
&lt;p&gt;允许多个人一起工作&lt;/p&gt;

&lt;p&gt;&lt;span&gt;六、git&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）git存储库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.git目录：存储所有版本、控制数据&lt;/p&gt;
&lt;p&gt;缓存区：内存中&lt;/p&gt;
&lt;p&gt;工作目录：本地文件系统&lt;/p&gt;
&lt;p&gt;2）文件的三种状态&lt;/p&gt;
&lt;p&gt;修改：工作目录中的文件与git存储库中的文件不同，但不在临时区域中&lt;/p&gt;
&lt;p&gt;分阶段：文件已修改并已添加到暂存区&lt;/p&gt;
&lt;p&gt;提交：该文件在工作目录和git目录中保持相同&lt;/p&gt;
&lt;p&gt;3）Git中的对象图：&lt;/p&gt;
&lt;p&gt;Git上的所有操作都是在一个图数据库上进行&lt;/p&gt;
&lt;p&gt;从另一台机器/服务器复制git项目意味着复制 整个对象图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421130803018-929355117.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对象图中的代码：不重复保存个版本中没有发生变化的文件、每个文件的每个版本只保存依次，多个提交可共享版本&lt;/p&gt;
&lt;p&gt;4)分支：分支是在版本控制下对对象的复制，以便修 改可以沿两个分支平行进行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421134200621-704841671.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、软件构造的一般过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421135457772-742128461.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.编程&lt;/p&gt;
&lt;p&gt;1）开发语言：c++，python，java等等&lt;/p&gt;
&lt;p&gt;IDE：集成开发环境：方便编写代码和管理文件；能够编译、构建；结构清晰；有GUI界面；支持第三方扩展工具&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）建模语言：&lt;/span&gt;建模语言是一种人工语言，用于表达信息、知识或系统，以一套一致的 规则定义来可视化、推理、验证和交流系统的设计。&lt;/p&gt;
&lt;p&gt;3）配置语言&lt;/p&gt;
&lt;p&gt;配置程序的参数和初始设置 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用应提供工具支持配置文件的维护 &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;某些计算机程序只能在启动时读取其配置文件&lt;/p&gt;
&lt;p&gt;其他人定期检查配置文件的变化&lt;/p&gt;

&lt;p&gt;2.静态代码分析：在没有实际执行程序的情况下执行的计算机软件分析&lt;/p&gt;
&lt;p&gt;1）代码评审：&lt;/p&gt;
&lt;p&gt;正式代码评审：一种结构化的检查 代码和文档缺陷的过程&lt;/p&gt;
&lt;p&gt;轻量代码评审：电子邮件、结对编程、工具辅助&lt;/p&gt;
&lt;p&gt;2）该过程提供了对代码结构的理解，并有助于确保代码符合行业标准、自动化工具可以帮助程序员和开发人员进行静态分析。&lt;/p&gt;
&lt;p&gt;3.动态代码分析:运行程序以分析代码&lt;/p&gt;
&lt;p&gt;程序需要经过充分的测试 &lt;/p&gt;
&lt;p&gt;利用测试度量技术（如覆盖率）确保 代码的可能功能均被充分测试到&lt;/p&gt;
&lt;p&gt; 用来测量 程序的时空复杂度，特定指令或函数的调用频率或持续时间&lt;/p&gt;
&lt;p&gt;4.调试与测试&lt;/p&gt;
&lt;p&gt;测试为软件的利益相关者提供有关被测产品或服务 质量的信息 &lt;/p&gt;
&lt;p&gt;1）测试：程序能否正常运行，能否满足所有需求&lt;/p&gt;
&lt;p&gt;技巧：联想V字模型、测试需求文档&lt;/p&gt;
&lt;p&gt;2）调试：&lt;/p&gt;
&lt;p&gt;调试是识别错误的根本原因并对其进行纠正的过程 &lt;/p&gt;
&lt;p&gt;调试往往是成功测试的后续环节，成功测试不意味着没有发现错误， 反而相反&lt;/p&gt;
&lt;p&gt;测试和调试不会提升软 件质量，而是发现缺陷的主要手段 &lt;/p&gt;
&lt;p&gt;软件质量应通过认真的分析需求、良好 的设计、高质量的编码来确保。 &lt;/p&gt;
&lt;p&gt;调试是最后的手段&lt;/p&gt;
&lt;p&gt;5.重构&lt;/p&gt;
&lt;p&gt;重构是在不改变代码外部行为的前提下，改善其内部结 构。 &lt;/p&gt;
&lt;p&gt;（1）投入短期时间/工作成本，对系统的整体质量进行长期投资&lt;/p&gt;
&lt;p&gt;（2）保留语义使代码更易维护和修改、进行单元测试以证明代码正常工作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、狭义软件构造过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.构建系统：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译代码、打包和测试解释型语言、编译和打包web应用程序、执行单元测试、进行静态分析得到bug报告、输入不同格式的输入文件，得到人可读的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.编译语言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编译后得到目标文件， 后续被链接入类库或者可执行程序中 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终得到可部署到目标机器的发布包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;版本控制工具。&lt;/p&gt;
&lt;p&gt;源树和对象树：特定开发人员使用的源文件和编译对象文件集。&lt;/p&gt;
&lt;p&gt;编译工具：输入文件并生成输出文件的工具（例如，将源代码文件转换为目标代码和可执行程序）。编译工具的常见示例包括C或Java编译器，但它们还包括文档和单元测试发电机。&lt;/p&gt;
&lt;p&gt;构建机器：执行编译工具的计算设备。&lt;/p&gt;
&lt;p&gt;发布打包和目标机器：打包软件，分发给最终用户，然后安装到目标机器上的方法。&lt;/p&gt;

&lt;p&gt;·基于Web的应用程序的编译和打包。&lt;/p&gt;
&lt;p&gt;　　- 使用静态HTML页面&lt;/p&gt;
&lt;p&gt;　　- 使用Java或C# 编写的源代码&lt;/p&gt;
&lt;p&gt;　　- 使用JSP，ASP或PHP语法编写的混合文件以及多种类型的配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614222/201904/1614222-20190421142212348-87761966.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.构建系统的组件：&lt;/p&gt;
&lt;p&gt;1）源树：程序的源代码被存储为多个磁盘文件，将这些文件安排到不同的地方称为源树，其结构通常反映了软件的体系结构。&lt;/p&gt;
&lt;p&gt;2）对象树：一个单独的树层次结构，用于存储由构建过程构建的任何对象文件或可执行程序。&lt;/p&gt;
&lt;p&gt;3）编译工具：将可读的源文件转换为机器可读的可执行程序文件的程序。&lt;/p&gt;
&lt;p&gt;编译器：源文件 -&amp;gt; 对象文件&lt;/p&gt;
&lt;p&gt;链接器：多个相关的目标文件 -&amp;gt; 可执行的程序映像&lt;/p&gt;
&lt;p&gt;基于UML的代码生成器：模型 -&amp;gt; 源代码文件&lt;/p&gt;
&lt;p&gt;文件生成器：脚本 -&amp;gt; 文件&lt;/p&gt;
&lt;p&gt;4）包装类型：&lt;/p&gt;
&lt;p&gt;档案文件：zip和解压缩&lt;/p&gt;
&lt;p&gt;软件包管理工具：UNIX风格，例如.rpm和.deb&lt;/p&gt;
&lt;p&gt;定制的GUI安装工具：Windows风格&lt;/p&gt;

&lt;p&gt;3.构建过程和构建描述&lt;/p&gt;
&lt;p&gt;构建过程：构建工具调用每个编译工具来完成工作，这是一个端到端的事件序列。&lt;/p&gt;
&lt;p&gt;构建描述：构建工具需要构建描述信息，基于文本的格式编写 &lt;/p&gt;
&lt;p&gt;构建系统如何被使用：&lt;/p&gt;
&lt;p&gt;开发人员构建：开发人员已检出VCS的源代码并正在专用工作区中构建软件，结果发布包将用于开发人员的私人开发。&lt;/p&gt;
&lt;p&gt;发布版本：为测试组提供一个完整的软件包供验证，软件的质量足够高时为客户提供相同的软件包。用于发布版本的源代码树只编译一次，永不修改。&lt;/p&gt;
&lt;p&gt;健全性构建：与发布版本类似，但并非针对客户，可以每天发生多次，并且趋向于完全自动化。&lt;/p&gt;


&lt;p&gt;4.java编译工具&lt;/p&gt;
&lt;p&gt;（1）Java开发工具包（JDK）&lt;/p&gt;
&lt;p&gt;（2）GNU Java编译器&lt;/p&gt;
&lt;p&gt;（3）Eclipse Java编译器（ECJ）&lt;/p&gt;
&lt;p&gt;java中打开文件：与机器无关的字节代码，用于描述程序流，而不是直接编译为本 地机器代码&lt;/p&gt;
&lt;p&gt;java的可执行程序：Java 语言是动态进行类的加载，在运行时根据需要，类会被加载入内存。 &lt;/p&gt;
&lt;p&gt;java程序要求两点：必须为JVM提供包含main方法的类的名称。 这用作执行的起点。  - 还必须为JVM提供类路径，该路径用于标识其他类的位置。&lt;/p&gt;
&lt;p&gt;java中的库：.由于动态加载的特性，可以随 时替换和升级JAR文件（需要确保兼容性）。&lt;/p&gt;


&lt;p&gt;5.子目标和构建变体&lt;/p&gt;
&lt;p&gt;构建方法：可以存在任意数量的构建方式，每个方式都使用稍微 修改的构建过程并创建一个稍微不同的发布包&lt;/p&gt;
&lt;p&gt;1)三种不同的构建方法:&lt;/p&gt;
&lt;p&gt;构建子目标：仅重建开发人员正在处理的树的部分。&lt;/p&gt;
&lt;p&gt;构建不同版本的软件：定制输出以改变软件的行为。&lt;/p&gt;
&lt;p&gt;构建不同的目标体系结构：为各种不同的CPU类型和操作系统编译相同的源文件集，包括x86，MIPS和PowerPC等CPU以及Linux，Windows和Mac OS X等操作系统。&lt;/p&gt;
&lt;p&gt;2）构建子目标&lt;/p&gt;
&lt;p&gt;任何大型软件都可以分成许多子组件，通常采用静态或动态库的形式。&lt;/p&gt;
&lt;p&gt;避免耗费时间，最好限制构建子组件的数量。&lt;/p&gt;
&lt;p&gt;6. 构建工具：Make、Ant、Maven、Gradle、Eclipse&lt;/p&gt;

</description>
<pubDate>Sun, 21 Apr 2019 06:32:00 +0000</pubDate>
<dc:creator>Boston丶o</dc:creator>
<og:description>第一部分 一、软件的生命周期 1.from zero to one 计划、分析、设计、实现、测试、维护 2.from 1 to n 软件的更新与老化、不同软件之间相互取代演化 二、经典软件模型 两个基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boston-o/p/10745088.html</dc:identifier>
</item>
<item>
<title>在 DotNetCore 3.0 程序中使用通用协议方式启动文件关联应用 - hippieZhou</title>
<link>http://www.cnblogs.com/hippieZhou/p/10683191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hippieZhou/p/10683191.html</guid>
<description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在传统的基于 .NET Framework 的 WPF 程序中，我们可以使用如下代码段启动相关的默认应用：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;# 启动默认文本编辑器打开 helloworld.txt
Process.Start(&quot;helloworld.txt&quot;);

# 启动默认浏览器打开 https://hippiezhou.fun/
Process.Start(&quot;https://hippiezhou.fun/&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是上述协议方式在 .NET Core 中不再适用，当我们使用上述方式进行操作，程序会给我们爆如下的错误：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/749711/201904/749711-20190421130915451-880420000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们需要寻找新的协议方式来调取系统的相关类型文件的默认打开方式。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：使用如下方法的前提是需要我们的机器上安装 Windows 10 任一版本的 SDK，否则无法正常使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做过 UWP 开发的朋友应该对 &lt;strong&gt;Launcher&lt;/strong&gt; 族下的 API 有所了解，这个下面的相关方法能够启动系统默认应用。我们想在 &lt;strong&gt;.NET Core 3.0 WPF&lt;/strong&gt; 使用这个族的 API 需要进行一些配置才可以。&lt;/p&gt;
&lt;p&gt;首先，我们需要修改我们的 &lt;strong&gt;.csproj&lt;/strong&gt; 文件，使项目能够使用上述的 API，修改如下所示：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;WinExe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;UseWPF&amp;gt;true&amp;lt;/UseWPF&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;!--新增节点--&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;System.Runtime.WindowsRuntime&quot; Version=&quot;4.3.0&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
  
  &amp;lt;!--新增节点--&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;Reference Include=&quot;Windows&quot;&amp;gt;
      &amp;lt;HintPath&amp;gt;$(MSBuildProgramFiles32)\Windows Kits\10\UnionMetadata\10.0.17763.0\Windows.winmd&amp;lt;/HintPath&amp;gt;
      &amp;lt;IsWinMDFile&amp;gt;true&amp;lt;/IsWinMDFile&amp;gt;
      &amp;lt;Private&amp;gt;false&amp;lt;/Private&amp;gt;
    &amp;lt;/Reference&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，重新加载我们的项目，这个时候就可以使用 &lt;strong&gt;Launcher&lt;/strong&gt; 了。比如，我们可以使用如下方式调用默认浏览器打开目标网址：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;await Launcher.LaunchUriAsync(new Uri(&quot;https://hippiezhou.fun/&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于更多 &lt;strong&gt;Launcher&lt;/strong&gt; 的使用方法可参考 MSDN，文末有给出相应链接。&lt;/p&gt;
&lt;h2 id=&quot;相关参考&quot;&gt;相关参考&lt;/h2&gt;
</description>
<pubDate>Sun, 21 Apr 2019 05:11:00 +0000</pubDate>
<dc:creator>hippieZhou</dc:creator>
<og:description>问题描述 在传统的基于 .NET Framework 的 WPF 程序中，我们可以使用如下代码段启动相关的默认应用： 但是上述协议方式在 .NET Core 中不再适用，当我们使用上述方式进行操作，程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hippieZhou/p/10683191.html</dc:identifier>
</item>
<item>
<title>LinkedHashMap为什么是有序的(与put先后顺序一致) - 远方的风lyh</title>
<link>http://www.cnblogs.com/lyhc/p/10743550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyhc/p/10743550.html</guid>
<description>&lt;p&gt;　&lt;a href=&quot;http://www.cnblogs.com/lyhc/p/10278256.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文版权归 远方的风lyh和博客园共有，欢迎转载，但须保留此段声明，并给出原文链接，谢谢合作，如有错误之处忘不吝批评指正!&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;　　首先呢，明白一点 LinkedHashMap是HashMap的子类,也就是说它就是一个HashMap(所以还是要对HashMap源码有一定了解),至于它可以保证(有序)先后顺序，只能说儿子比老子优秀！虎父无犬子，儿子在父亲的基业上又有了独到之处！原因呢？下面一起看看源码((基于jdk1.8)就知晓了！(看源码一定要有耐心，第一次看可能看不懂，后面再看可能还是看不懂，但是别放弃治疗)。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedHashMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;　变量分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　 LinkedHashMap在HashMap基础上扩展的这两个成员变量要特别注意，这两个变量是保证有序的基础&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The head (eldest) of the doubly linked list.&lt;br/&gt;* 记录第一个 key—value 对象关于&lt;/span&gt;&lt;span&gt;LinkedHashMap.Entry&amp;lt;K,V&amp;gt;的结构接下来就会分析&lt;/span&gt;&lt;br/&gt;*/
&lt;/pre&gt;
&lt;pre&gt;
 　　&lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; head; &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; * The tail (youngest) of the doubly linked list.&lt;br/&gt;* 保存最后一个 key—value 对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;　LinkedHashMap.Entry&amp;lt;K,V&amp;gt;结构:&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　它继承了&lt;span&gt;HashMap.Node&amp;lt;K,V&amp;gt;&lt;/span&gt;,  添加了两个&lt;span&gt;LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;/span&gt; 用来记录它的前一个 和后一个put进入来的key-value对象(&lt;span&gt;LinkedHashMap.Entry&amp;lt;K,V&amp;gt;),在在结构设计上保证了LinkedHashMap有序的可实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Node&amp;lt;K,V&amp;gt;&lt;span&gt; {&lt;br/&gt;//它的前一个 和后一个put进入来的key-value对象
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　附上&lt;span&gt;HashMap.Node&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }
&lt;/span&gt;&lt;span&gt;        //省略。。。。。。。
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874807/201904/874807-20190421115550604-2091600391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　实现&lt;/h2&gt;
&lt;p&gt;　　 　　了解完结构我们再来看看它在代码中是如何实现的,LinkedHashMap是HashMap的子类 ，在放入key-value时,它复用了HashMap的put方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
            n &lt;/span&gt;= (tab =&lt;span&gt; resize()).length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要格外注意 LinkedHashMap复写了HashMap的 
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newNode(hash, key, value, null) 方法&lt;/span&gt;
            tab[i] =&lt;span&gt; &lt;strong&gt;newNode(hash, key, value, null);
           &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...... &lt;/span&gt;
    }            
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　LinkedHashMap复写了HashMap的newNode(hash, key, value, null) 方法,代码如下:
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  Node&amp;lt;K,V&amp;gt; newNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        linkNodeLast(p);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/***有序的实现核心***/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkNodeLast(LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     LinkedHashMap.Entry&amp;lt;K,V&amp;gt; last =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     tail =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         head =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         p.before =&lt;span&gt; last;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         last.after =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 举一个场景来说明上面的有序核心实现方法,比如说有这么一个场景:  一个班有 1号小明同学 2号张三 3号小红 4号李四同学，老师要知道学生进入教师的先后顺序。老师在黑板上写了 两个词  head，tail两个字段 规定:&lt;/p&gt;
&lt;p&gt;　　　　1.第一个来的在 head来的在head、tail写上自己的名字&lt;/p&gt;
&lt;p&gt;　　　　2.第二个及后续到的, 看到黑板上的tail字段后，找到这个同学(这个同学记住我之后到的 after) 通知自己到了(并记住在我之前的是这个同学before) 并修改tail字段为自己的名字&lt;/p&gt;
&lt;p&gt;　　例子:&lt;/p&gt;
&lt;p&gt;　　　　1.小明同学 第一个到  ,在黑板上 head，tail 都写下 小明&lt;/p&gt;
&lt;p&gt;　　　　2.张三到了之后看到 tail是小明 记住 自己上一个(before)是小明 ，并修改tail为张三 ，通知小明，小明记下来自己的后面（afte)r是张三&lt;/p&gt;
&lt;p&gt;　　　　3小红到了看到tail是张三 记住自己上一个(before)是张三 并修改tail为小红,通知张三，张三记下来自己的后面(after)是小红&lt;/p&gt;
&lt;p&gt;　　　　4李四到了。。。。。。。&lt;/p&gt;
&lt;p&gt;　　老师来了上课 看到head上写的是小明  并询问 小明 你后面是谁 ， 小明回:小红 再询问 小红 ....知道 询问到李四 结束&lt;/p&gt;
&lt;p&gt;　　老师就知道了学生进入教室的顺序 小明-&amp;gt;张三-&amp;gt;小红-&amp;gt;李四。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 05:06:00 +0000</pubDate>
<dc:creator>远方的风lyh</dc:creator>
<og:description>本文版权归 远方的风lyh和博客园共有，欢迎转载，但须保留此段声明，并给出原文链接，谢谢合作，如有错误之处忘不吝批评指正! 絮叨絮叨 首先呢，明白一点 LinkedHashMap是HashMap的子类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyhc/p/10743550.html</dc:identifier>
</item>
<item>
<title>一行命令更新所有 npm 依赖包 - Steve_Xu</title>
<link>http://www.cnblogs.com/stevexu/p/10744765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stevexu/p/10744765.html</guid>
<description>&lt;p&gt;&lt;strong&gt;npm&lt;/strong&gt; 包的更新速度很快，为了将项目或者全局依赖更新到最新版本。传统的做法是一个一个更新，比如更新 &lt;strong&gt;react&lt;/strong&gt; 到最新版本，命令如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# npm
npm i --save react@latest
# yarn
yarn add react@latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yarn&lt;/strong&gt; 是 facebook 发明的新一代 js 包管理器，支持离线使用。&lt;a href=&quot;https://yarnpkg.com/zh-Hans/docs/migrating-from-npm&quot;&gt;这是 npm 与 yarn 的 命令对照&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是，这种做法相当耗时。有没有更简单的方法呢？&lt;br/&gt;答案是使用 &lt;a href=&quot;https://github.com/dylang/npm-check&quot;&gt;npm-check&lt;/a&gt; 或者 &lt;a href=&quot;https://yarnpkg.com/zh-Hans/&quot;&gt;yarn&lt;/a&gt;。两者都需要全局安装。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm i -g yarn
npm i -g npm-check&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用-npm-check-更新项目依赖&quot;&gt;使用 npm-check 更新项目依赖&lt;/h2&gt;
&lt;p&gt;在项目根目录运行&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm-check -u&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;? Choose which packages to update. (Press &amp;lt;space&amp;gt; to select)

 Update package.json to match version installed.
❯◯ chalk     ^1.1.3   ❯  2.4.2   https://github.com/chalk/chalk#readme
 ◯ cheerio   ^0.22.0  ❯  0.22.0  https://github.com/cheeriojs/cheerio#readme
 ◯ debug     ^2.3.3   ❯  4.1.1   https://github.com/visionmedia/debug#readme
 ◯ log4js    ^1.0.1   ❯  4.1.0   https://log4js-node.github.io/log4js-node/
 ◯ mustache  ^2.3.0   ❯  3.0.1   https://github.com/janl/mustache.js
 ◯ request   2.79.0   ❯  2.88.0  https://github.com/request/request#readme
 ◯ unescape  ^0.2.0   ❯  1.0.1   https://github.com/jonschlinkert/unescape
 ◯ yargs     ^6.4.0   ❯  13.2.2  https://yargs.js.org/

 Space to select. Enter to start upgrading. Control-C to cancel.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;空格切换包是否更新，&lt;strong&gt;Control + C&lt;/strong&gt; 取消更新，回车就是执行更新。&lt;/p&gt;
&lt;h2 id=&quot;使用-yarn-更新项目依赖&quot;&gt;使用 yarn 更新项目依赖&lt;/h2&gt;
&lt;p&gt;在项目根目录运行&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn upgrade-interactive  --latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn upgrade-interactive v1.15.2
info Color legend :
 &quot;&amp;lt;red&amp;gt;&quot;    : Major Update backward-incompatible updates
 &quot;&amp;lt;yellow&amp;gt;&quot; : Minor Update backward-compatible features
 &quot;&amp;lt;green&amp;gt;&quot;  : Patch Update backward-compatible bug fixes
? Choose which packages to update. (Press &amp;lt;space&amp;gt; to select, &amp;lt;a&amp;gt; to toggle all,
&amp;lt;i&amp;gt; to invert selection)
 dependencies
   name      range   from       to          url
❯◯ chalk     latest  1.1.3   ❯  2.4.2       https://github.com/chalk/chalk#readm
e
 ◯ cheerio   latest  0.22.0  ❯  1.0.0-rc.3  https://github.com/cheeriojs/cheerio
#readme
 ◯ debug     latest  2.6.9   ❯  4.1.1       https://github.com/visionmedia/debug
#readme
 ◯ log4js    latest  1.1.1   ❯  4.1.0       https://log4js-node.github.io/log4js
-node/
 ◯ mustache  latest  2.3.2   ❯  3.0.1       https://github.com/janl/mustache.js
 ◯ request   latest  2.79.0  ❯  2.88.0      https://github.com/request/request#r
eadme
 ◯ unescape  latest  0.2.0   ❯  1.0.1       https://github.com/jonschlinkert/une
scape
 ◯ yargs     latest  6.6.0   ❯  13.2.2      https://yargs.js.org/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yarn&lt;/strong&gt; 提供了全选切换功能，就是按键 &lt;strong&gt;A&lt;/strong&gt;，空格切换包是否更新，&lt;strong&gt;Control + C&lt;/strong&gt; 取消更新，回车就是执行更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yarn&lt;/strong&gt; 的更新命令太长了，谁记得住，这种时候，请合理使用命令行工具的帮助，比如运行 &lt;strong&gt;yarn help&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;更新命令对照表&quot;&gt;更新命令对照表&lt;/h2&gt;
&lt;p&gt;更新全局依赖同上&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;更新项目依赖，没有交互&lt;/td&gt;
&lt;td&gt;yarn upgrade --latest&lt;/td&gt;
&lt;td&gt;npm-check -y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;更新项目依赖，有交互&lt;/td&gt;
&lt;td&gt;yarn upgrade-interactive --latest&lt;/td&gt;
&lt;td&gt;npm-check -u&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;更新全局依赖，没有交互&lt;/td&gt;
&lt;td&gt;yarn global upgrade --latest&lt;/td&gt;
&lt;td&gt;npm-check -g -y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;更新全局依赖，有交互&lt;/td&gt;
&lt;td&gt;yarn global upgrade-interactive --latest&lt;/td&gt;
&lt;td&gt;npm-check -g -u&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;检测原理&quot;&gt;检测原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;yarn&lt;/strong&gt; 是根据 &lt;strong&gt;yarn.lock&lt;/strong&gt; 文件来检测版本是否是最新的，所以项目是使用 &lt;strong&gt;npm&lt;/strong&gt; 安装依赖包，更新前要运行 &lt;code&gt;yarn install&lt;/code&gt; 一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm-check&lt;/strong&gt; 是检测 &lt;strong&gt;package.json&lt;/strong&gt; 文件，项目存在 &lt;strong&gt;node_modules&lt;/strong&gt; 文件夹即可更新。&lt;/p&gt;
&lt;h2 id=&quot;更新提醒&quot;&gt;更新提醒&lt;/h2&gt;
&lt;p&gt;没有交互就是将依赖包直接更新到最新版本，推荐使用交互式更新，会有更新的警告信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最新的依赖包，API 可能发生重大改变。为了顺利更新，更新前请 &lt;code&gt;git commit&lt;/code&gt; 一下，更新失败了也能顺利回退。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;不推荐使用-cnpm&quot;&gt;不推荐使用 cnpm&lt;/h2&gt;
&lt;p&gt;为了加快安装依赖的安装速度，可能被同事安利 &lt;strong&gt;cnpm&lt;/strong&gt;，但是这样会导致包的依赖安装不正常，项目无法运行。&lt;/p&gt;
&lt;p&gt;更好的做法是使用 &lt;a href=&quot;https://github.com/Pana/nrm&quot;&gt;nrm&lt;/a&gt; 切换下载源。&lt;/p&gt;
&lt;p&gt;平时使用 &lt;strong&gt;yarn&lt;/strong&gt; 装包，&lt;strong&gt;npm&lt;/strong&gt; 运行脚本。&lt;/p&gt;
&lt;h2 id=&quot;安装-nrm&quot;&gt;安装 nrm&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm i -g nrm &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看下载镜像源&quot;&gt;查看下载镜像源&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nrm ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  npm ---- https://registry.npmjs.org/
  cnpm --- http://r.cnpmjs.org/
* taobao - https://registry.npm.taobao.org/
  nj ----- https://registry.nodejitsu.com/
  npmMirror  https://skimdb.npmjs.com/registry/
  edunpm - http://registry.enpmjs.org/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;切换镜像源&quot;&gt;切换镜像源&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nrm use taobao&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;装包命令不变，比如安装 &lt;strong&gt;react&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# npm
npm i --save react
# yarn
yarn add react&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;体验飞一般的装包速度，再也不是装包一小时，码代码五分钟。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 04:55:00 +0000</pubDate>
<dc:creator>Steve_Xu</dc:creator>
<og:description>npm 包的更新速度很快，为了将项目或者全局依赖更新到最新版本。传统的做法是一个一个更新，比如更新 react 到最新版本，命令如下： yarn 是 facebook 发明的新一代 js 包管理器，支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stevexu/p/10744765.html</dc:identifier>
</item>
<item>
<title>聊一聊快速排序（Js） - siegaii</title>
<link>http://www.cnblogs.com/siegaii/p/10744645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siegaii/p/10744645.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基本思路&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;双指针+递归分治（本质是一个创建二叉树搜索树的过程）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我的理解&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上面的基本思路是参考网络上大佬的文章整理的出来的，我来说说我的理解。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在将要排序的数据中选取一个数作为基准数，将这些数据中比所选取的基准数小的数放在所选取基准数的左边为左数组，将比所选取基准数大的数组放在右边为右数组。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过递归的方式重复循环1中的过程达到排序的目的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;下面是我的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
let testArray = [3, 1, 2, 5, 6, 4&lt;span&gt;];
let quickSort &lt;/span&gt;= (array) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array.length &amp;lt; 2) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    let leftArray &lt;/span&gt;=&lt;span&gt; [];
    let rightArray &lt;/span&gt;=&lt;span&gt; [];
    let baseDigit &lt;/span&gt;= array[0&lt;span&gt;];
    array.forEach(element &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; baseDigit) {
            leftArray.push(element);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; baseDigit) {
            rightArray.push(element);
        }
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; quickSort(leftArray).concat(baseDigit, quickSort(rightArray))
};
quickSort(testArray);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;某乎上一篇文章的思路&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;基本思路跟我上述理解大同小异，主要来看看这篇文章具体的实现过程。下面借用原文的图来讲解（原文的图做的很好就不单独画图了，主要讲一讲原文没解释需要注意的地方，和对该篇文章做一个补充），底部附原文链接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.数组[2,3,1,5,6,4]，创建两指针，一个只想头一个指向尾，再确定一个基准数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;为了方便后面递归是能够确定基准数，这里基准数选取，第一个数或者最后一个数）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://pic4.zhimg.com/80/v2-2b65df4885fd0b2cab6a7292e9862983_hd.jpg&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-2b65df4885fd0b2cab6a7292e9862983_hd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.开始第一次的递归处理，尾指针先从右往左扫，扫到第一个小于（注意是小于，而不是小于等于哦）基准数的位置停住，这时候头指针再从左往右扫，扫到第一个大于基准数的位置停住，这时候是下面的图示状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;（&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这里如果基准数选区的第一个数，应该尾指针先往左侧扫，若基准数选取为最后一个属则，应是头指针向往右扫）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://pic3.zhimg.com/v2-b56c81009eb0d5bb88d78c6666540cde_r.jpg&quot;&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b56c81009eb0d5bb88d78c6666540cde_r.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;交换两个指针所指的数，成为了下面的状态：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://pic4.zhimg.com/80/v2-4b651cc92caf76a95d1d7f2c8a035503_hd.jpg&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-4b651cc92caf76a95d1d7f2c8a035503_hd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.两个数交换完毕，右指针此时指的是arr[2] = 3, 左指针指着arr[1] = 1；交换完毕后右指针继续从当前位置往左扫，扫到1的时候发现和左指针相遇了，那么这个时候就结束左右指针的扫描，左右指针同时指着arr[1] = 1，即：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://pic1.zhimg.com/80/v2-7559b7456d1daf923964b57930c4c888_hd.jpg&quot;&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-7559b7456d1daf923964b57930c4c888_hd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;此时退出循环扫描的过程，交换基准数与左右指针同时所指的数的位置，开头说了，基准数我选择的是arr[0] = 2, 指针指的是arr[1] = 1; 交换过后就变成了：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://pic4.zhimg.com/80/v2-d0add270d76696c048b35dabb58d0197_hd.jpg&quot;&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-d0add270d76696c048b35dabb58d0197_hd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这时候就发现基准数已经出现在了它排完序后应该在的位置（排完序后是[1,2,3,4,5,6]，2出现在了第2位）,比这个基准数小的数组出现在了它的左边（[1]出现在了2的左边），比基准数大的出现在了它的右边（[3,5,6,4]出现在了2的右边）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4.之后的过程就是对左右数组的分别递归处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; quickSort(arr, begin, end) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归出口&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(begin &amp;gt;=&lt;span&gt; end)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = begin; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左指针&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; r = end; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右指针&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; temp = arr[begin]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准数，这里取数组第一个数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右指针相遇的时候退出扫描循环&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(l &amp;lt;&lt;span&gt; r) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右指针从右向左扫描，碰到第一个小于基准数的时候停住&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(l &amp;lt; r &amp;amp;&amp;amp; arr[r] &amp;gt;=&lt;span&gt; temp)
            r &lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左指针从左向右扫描，碰到第一个大于基准数的时候停住&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(l &amp;lt; r &amp;amp;&amp;amp; arr[l] &amp;lt;=&lt;span&gt; temp)
            l &lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换左右指针所停位置的数&lt;/span&gt;
        [arr[l], arr[r]] =&lt;span&gt; [arr[r], arr[l]];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后交换基准数与指针相遇位置的数&lt;/span&gt;
    [arr[begin], arr[l]] =&lt;span&gt; [arr[l], arr[begin]];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归处理左右数组&lt;/span&gt;
    quickSort(arr, begin, l - 1&lt;span&gt;);
    quickSort(arr, l &lt;/span&gt;+ 1&lt;span&gt;, end);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [2,3,4,1,5,6&lt;span&gt;]
quickSort(arr, &lt;/span&gt;0, 5&lt;span&gt;);
console.log(arr)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;百科上的思路&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;百科上的思路跟上述某乎文章基本一致，不过再细节方面不同，这里主要讲已将它们不同的地方，详情请参考原文。（需注意之处也在和上文相同不在赘述）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;主要的不同之处在于再上述2，3步骤。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;百科上给的方式是：假设让右指针先扫，扫到了比基准数小的，就讲该数与基准数值交换位置，此时左指针指向基准数，再让左指针往右扫描，扫到比基准数大的交换左右指针数值，两指针相遇时直接退出这次递归，通过这样的的方式来达到第一次递归的目的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;上文中则是：假设让右指针先扫，扫到了比基准数小的，指针停住，再让左指针往右扫描扫到比基准数大的数再停住，然后交换两指针指向的值，反复调用，两指针相遇时与基准数的数值进行交换。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;相对于理解来说我认为是，百科的方式更容易理解（其实是我先理解了百科的方式让后想到了自己的思路，最后才理解了某乎的方式）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const quickSort = (array) =&amp;gt;&lt;span&gt; {
 const sort &lt;/span&gt;= (arr, left = 0, right = arr.length - 1) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (left &amp;gt;= right) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左边的索引大于等于右边的索引说明整理完毕&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
  }
 let i &lt;/span&gt;=&lt;span&gt; left
 let j &lt;/span&gt;=&lt;span&gt; right
 const baseVal &lt;/span&gt;= arr[j] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取无序数组最后一个数为基准值&lt;/span&gt;
 &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把所有比基准值小的数放在左边大的数放在右边&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; arr[i] &amp;lt;= baseVal) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到一个比基准值大的数交换&lt;/span&gt;
   i++&lt;span&gt;
  }
  arr[j] &lt;/span&gt;= arr[i] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt; (j &amp;gt; i &amp;amp;&amp;amp; arr[j] &amp;gt;= baseVal) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到一个比基准值小的数交换&lt;/span&gt;
   j--&lt;span&gt;
 }
  arr[i] &lt;/span&gt;= arr[j] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）&lt;/span&gt;
&lt;span&gt; }
 arr[j] &lt;/span&gt;= baseVal &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）&lt;/span&gt;
 sort(arr, left, j-1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将左边的无序数组重复上面的操作&lt;/span&gt;
 sort(arr, j+1, right) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将右边的无序数组重复上面的操作&lt;/span&gt;
&lt;span&gt; }
 const newArr &lt;/span&gt;= array.concat() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证这个函数是纯函数拷贝一次数组&lt;/span&gt;
&lt;span&gt; sort(newArr)
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newArr
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span class=&quot;cm-keyword&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;性能&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;既然这里给出了三种方式来实现快排，那我们就来测试一下性能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由于百科的方法有问题再5位数以上会报错10000后面不测试百科方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;第一个数我的方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;在1000个相同随机数的情况下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601343/201904/1601343-20190421121136634-1435128126.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5Cdjlia%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1555818922769.png&quot;&gt;&lt;img src=&quot;file://c/Users/djlia/AppData/Roaming/Typora/typora-user-images/1555818922769.png?lastModify=1555819569&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;在100000个相同随机数的情况下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1601343/201904/1601343-20190421121152902-1163499104.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5Cdjlia%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1555819220840.png&quot;&gt;&lt;img src=&quot;file://c/Users/djlia/AppData/Roaming/Typora/typora-user-images/1555819220840.png?lastModify=1555819569&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结论&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;从性能上讲是某乎的方法更高。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;附测试代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我的方法&lt;/span&gt;
let myQuickSort = (array) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array.length &amp;lt; 2) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    let leftArray &lt;/span&gt;=&lt;span&gt; [];
    let rightArray &lt;/span&gt;=&lt;span&gt; [];
    let baseDigit &lt;/span&gt;= array[0&lt;span&gt;];
    array.forEach(element &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; baseDigit) {
            leftArray.push(element);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; baseDigit) {
            rightArray.push(element);
        }
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myQuickSort(leftArray).concat(baseDigit, myQuickSort(rightArray))
};
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 某乎的方法&lt;/span&gt;
let moHu = (arr, begin, end) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归出口&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (begin &amp;gt;=&lt;span&gt; end)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = begin; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左指针&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; r = end; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右指针&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; temp = arr[begin]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准数，这里取数组第一个数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右指针相遇的时候退出扫描循环&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (l &amp;lt;&lt;span&gt; r) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右指针从右向左扫描，碰到第一个小于基准数的时候停住&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (l &amp;lt; r &amp;amp;&amp;amp; arr[r] &amp;gt;=&lt;span&gt; temp)
            r&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左指针从左向右扫描，碰到第一个大于基准数的时候停住&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (l &amp;lt; r &amp;amp;&amp;amp; arr[l] &amp;lt;=&lt;span&gt; temp)
            l&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换左右指针所停位置的数&lt;/span&gt;
        [arr[l], arr[r]] =&lt;span&gt; [arr[r], arr[l]];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后交换基准数与指针相遇位置的数&lt;/span&gt;
    [arr[begin], arr[l]] =&lt;span&gt; [arr[l], arr[begin]];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归处理左右数组&lt;/span&gt;
    moHu(arr, begin, l - 1&lt;span&gt;);
    moHu(arr, l &lt;/span&gt;+ 1&lt;span&gt;, end);
};
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;百科的方法&lt;/span&gt;
let baiKe = (array) =&amp;gt;&lt;span&gt; {
    let sort &lt;/span&gt;= (arr, left = 0, right = arr.length - 1) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (left &amp;gt;= right) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左边的索引大于等于右边的索引说明整理完毕&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
        let i &lt;/span&gt;=&lt;span&gt; left;
        let j &lt;/span&gt;=&lt;span&gt; right;
        const baseVal &lt;/span&gt;= arr[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取无序数组最后一个数为基准值&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把所有比基准值小的数放在左边大的数放在右边&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; arr[i] &amp;lt;= baseVal) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到一个比基准值大的数交换&lt;/span&gt;
                i++&lt;span&gt;
            }
            arr[j] &lt;/span&gt;= arr[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（i 等于 j）&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (j &amp;gt; i &amp;amp;&amp;amp; arr[j] &amp;gt;= baseVal) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到一个比基准值小的数交换&lt;/span&gt;
                j--&lt;span&gt;
            }
            arr[i] &lt;/span&gt;= arr[j] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 j）&lt;/span&gt;
&lt;span&gt;        }
        arr[j] &lt;/span&gt;= baseVal; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将基准值放至中央位置完成一次循环（这时候 j 等于 i ）&lt;/span&gt;
        sort(arr, left, j - 1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将左边的无序数组重复上面的操作&lt;/span&gt;
        sort(arr, j + 1, right) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将右边的无序数组重复上面的操作&lt;/span&gt;
&lt;span&gt;    };
    const newArr &lt;/span&gt;= array.concat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了保证这个函数是纯函数拷贝一次数组&lt;/span&gt;
&lt;span&gt;    sort(newArr);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newArr
};
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个1-count的随机数组&lt;/span&gt;
let createTestArray = (count) =&amp;gt;&lt;span&gt; {
    let temArray &lt;/span&gt;=&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count &amp;gt; 0&lt;span&gt;) {
        temArray.unshift(count);
        count&lt;/span&gt;--&lt;span&gt;;
    }
    let i &lt;/span&gt;=&lt;span&gt; temArray.length;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i) {
        let j &lt;/span&gt;= Math.floor(Math.random() * i--&lt;span&gt;);
        [temArray[j], temArray[i]] &lt;/span&gt;=&lt;span&gt; [temArray[i], temArray[j]];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temArray;
};
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;
let testQuickSort = (name, func, arr, moHu) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!!&lt;span&gt;moHu) {
        console.time(name);
        func(arr, moHu.begin, moHu.end);
        console.timeEnd(name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    console.time(name);
    func(arr);
    console.timeEnd(name);
};
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成1-100000的随机数组&lt;/span&gt;
const testArray = createTestArray(100000&lt;span&gt;);
testQuickSort(&lt;/span&gt;'myQuickSort'&lt;span&gt;, myQuickSort, testArray);
testQuickSort(&lt;/span&gt;'moHu', moHu, testArray, {begin: 0, end: 99999&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; testQuickSort('baiKe', baiKe, testArray);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;最后记一笔，快速排序是不稳定排序也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;文章连接：&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;某乎：&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59769969&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;微软前端社招笔试详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;百科：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;amp;fromid=2084344&amp;amp;fr=aladdin#3_7&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;百度百科&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Apr 2019 04:14:00 +0000</pubDate>
<dc:creator>siegaii</dc:creator>
<og:description>快速排序 基本思路 双指针+递归分治（本质是一个创建二叉树搜索树的过程） 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/siegaii/p/10744645.html</dc:identifier>
</item>
</channel>
</rss>