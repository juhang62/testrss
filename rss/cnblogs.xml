<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SSM Spring SpringMVC Mybatis框架整合Java配置完整版 - g歌德a</title>
<link>http://www.cnblogs.com/gede/p/11061859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gede/p/11061859.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　以前用着SSH都是老师给配好的，自己直接改就可以。但是公司主流还是SSM,就自己研究了一下Java版本的配置。网上大多是基于xnl的配置，但是越往后越新的项目都开始基于JavaConfig配置了，这也是写此文章的原因。&lt;/span&gt;&lt;span&gt;不论是eclipse还是myeclipse 都没有集成mybatis的相关组件，Spring也没有对其进行兼容，所以说我们会用到一些mybatis提供的核心jar包。下面先看一下我们的项目结构，我先自建了一个集成spring4.1的 ssm web项目（红色箭头指向注意删除web.xml配置，因为后期会和我们的java配置冲突而导致项目失败），结构如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190620212955780-1911362251.png&quot; alt=&quot;&quot; width=&quot;231&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　当你看到这里说明你并不是很了解mybatis，或者只是有其他框架的开发经验。所以建议你还是看下去。工欲善其事必先利其器，想要用mybatis必须先了解哦我们的mybatis。这里不说mybatis的起因来源，也不说他的深层机理。就简单谈一谈在ssm框架中的位置。以前用的ssh 我一直写的是HQL sq语句，web项目中的mvc框架一直占据了主流，几乎所以的CURD都是遵循这个框架来实现的，开发者通常会建立对应的service，dao，web层进行分层操作。为了代码的健壮性和可修改性，那些分层通常设计为接口类型，然后功能实现再通过相应的接口实现。而mybatis特殊的是，通过数据库逆向工程生成的XXXmapper.java全是接口文件，一个XXXmapper.java对应一个XXXmapper.xml 来实现持久层的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　刚刚说到的mybatis逆向工程，熟悉hibernate的知道，hibernate给不一样的ide都适配了逆向工程的专用插件。而mybatis没有，但是官方给出的方法更是简单，使用简单的xml配置搭上相应的java代码一运行，就可以实现数据库的逆向工程。生成我们所需要的l实体，和操作映射。这个时候我们就可以把逆向工程的对应文件路径进行设置，分别对应我们的model和dao层。说了这么多就是这一句分层的思想。下面简单看一下逆向工程代码：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;官方给出的java主文件，起名为GeneratorSqlmap：主要修改这一语句：&lt;/span&gt;File configFile = new File(&quot;.&lt;span&gt;/resources/generatorConfig.xml&lt;/span&gt;&quot;);这里我们的配置xml放在resources资源文件夹下面。&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.reversedb;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月18日 上午10:10:49
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.api.MyBatisGenerator;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.config.Configuration;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.config.xml.ConfigurationParser;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.internal.DefaultShellCallback;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeneratorSqlmap {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generator() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         List&amp;lt;String&amp;gt; warnings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; overwrite = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定配置文件&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         File configFile = &lt;span&gt;new&lt;/span&gt; File(&quot;./resources/generatorConfig.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         ConfigurationParser cp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationParser(warnings);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Configuration config =&lt;span&gt; cp.parseConfiguration(configFile);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         DefaultShellCallback callback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultShellCallback(overwrite);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         MyBatisGenerator myBatisGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyBatisGenerator(config, callback, warnings);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         myBatisGenerator.generate(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行main方法以生成代码&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             GeneratorSqlmap generatorSqlmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeneratorSqlmap();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            generatorSqlmap.generator();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;再看我们resources下的generatorConfig.xml 文件。主要填写这些信息：&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Mysql数据库连接的信息：驱动类、连接地址、用户名、密码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;生成POJO类的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;mapper映射文件生成的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;mapper接口生成的的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指定数据表&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &amp;lt;generatorConfiguration&amp;gt;
&lt;span&gt; 5&lt;/span&gt;   &amp;lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;commentGenerator&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;!-- 是否去除自动生成的注释 --&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;/commentGenerator&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;!-- Mysql数据库连接的信息：驱动类、连接地址、用户名、密码 --&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
&lt;span&gt;12&lt;/span&gt;         connectionURL=&quot;jdbc:mysql://localhost:3306/hotel&quot;
&lt;span&gt;13&lt;/span&gt;         userId=&quot;root&quot;
&lt;span&gt;14&lt;/span&gt;         password=&quot;112233&quot;&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;/jdbcConnection&amp;gt;
&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &amp;lt;!--&lt;span&gt; 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal --&amp;gt;
&lt;span&gt;19&lt;/span&gt;     &amp;lt;javaTypeResolver &amp;gt;
&lt;span&gt;20&lt;/span&gt;         &amp;lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&amp;gt;
&lt;span&gt;21&lt;/span&gt;     &amp;lt;/javaTypeResolver&amp;gt;
&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt;     &amp;lt;!-- targetProject：生成POJO类的位置 --&amp;gt;
&lt;span&gt;24&lt;/span&gt;     &amp;lt;javaModelGenerator targetPackage=&quot;com.gede.model&quot; targetProject=&quot;.\src&quot;&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
&lt;span&gt;26&lt;/span&gt;         &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&amp;gt;
&lt;span&gt;27&lt;/span&gt;         &amp;lt;!-- 从数据库返回的值被清理前后的空格 --&amp;gt;
&lt;span&gt;28&lt;/span&gt;         &amp;lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;/javaModelGenerator&amp;gt;
&lt;span&gt;30&lt;/span&gt;     
&lt;span&gt;31&lt;/span&gt;     &amp;lt;!-- targetProject：mapper映射文件生成的位置 --&amp;gt;
&lt;span&gt;32&lt;/span&gt;     &amp;lt;sqlMapGenerator targetPackage=&quot;com.gede.dao&quot;  targetProject=&quot;.\src&quot;&amp;gt;
&lt;span&gt;33&lt;/span&gt;         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
&lt;span&gt;34&lt;/span&gt;         &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&amp;gt;
&lt;span&gt;35&lt;/span&gt;     &amp;lt;/sqlMapGenerator&amp;gt;
&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     &amp;lt;!-- targetProject：mapper接口生成的的位置 --&amp;gt;
&lt;span&gt;38&lt;/span&gt;     &amp;lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.gede.dao&quot;  targetProject=&quot;.\src&quot;&amp;gt;
&lt;span&gt;39&lt;/span&gt;         &amp;lt;!-- enableSubPackages:是否让schema作为包的后缀 --&amp;gt;
&lt;span&gt;40&lt;/span&gt;         &amp;lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&amp;gt;
&lt;span&gt;41&lt;/span&gt;     &amp;lt;/javaClientGenerator&amp;gt;
&lt;span&gt;42&lt;/span&gt;     
&lt;span&gt;43&lt;/span&gt;     &amp;lt;!-- 指定数据表 --&amp;gt;
&lt;span&gt;44&lt;/span&gt;     &amp;lt;table schema=&quot;&quot; tableName=&quot;webuser&quot;&amp;gt;&amp;lt;/table&amp;gt;
&lt;span&gt;45&lt;/span&gt;     
&lt;span&gt;46&lt;/span&gt;     &amp;lt;!--&lt;span&gt; 有些表的字段需要指定java类型 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &amp;lt;table schema=&quot;DB2ADMIN&quot; tableName=&quot;ALLTYPES&quot; domainObjectName=&quot;Customer&quot; &amp;gt;
&lt;span&gt;48&lt;/span&gt;       &amp;lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&amp;gt;
&lt;span&gt;49&lt;/span&gt;       &amp;lt;generatedKey column=&quot;ID&quot; sqlStatement=&quot;DB2&quot; identity=&quot;true&quot; /&amp;gt;
&lt;span&gt;50&lt;/span&gt;       &amp;lt;columnOverride column=&quot;DATE_FIELD&quot; property=&quot;startDate&quot; /&amp;gt;
&lt;span&gt;51&lt;/span&gt;       &amp;lt;ignoreColumn column=&quot;FRED&quot; /&amp;gt;
&lt;span&gt;52&lt;/span&gt;       &amp;lt;columnOverride column=&quot;LONG_VARCHAR_FIELD&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
&lt;span&gt;53&lt;/span&gt;     &amp;lt;/table&amp;gt; --&amp;gt;
&lt;span&gt;54&lt;/span&gt;   &amp;lt;/context&amp;gt;
&lt;span&gt;55&lt;/span&gt; &amp;lt;/generatorConfiguration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置好以后运行我们的java文件，如果自己已经建好包直接打开就可以，如果之前没有包，记得刷新一下项目。这个时候再看我们的项目结构大致是这样的：你会发现model下面还多了一个xxxExampled的java文件。他的区别用途如下图：&lt;/p&gt;
&lt;p&gt;图片原文地址：&lt;a href=&quot;https://blog.csdn.net/qq_39056805/article/details/80585941&quot;&gt;https://blog.csdn.net/qq_39056805/article/details/80585941&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190620215953538-1885477040.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;357&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190620220230379-1398154446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　到这里我们的mybatis相应的文件已经应有具有，本来按常规思路来说应该是先搭建spring+springMVC然后再整合mybatis，但是这里还是先铺垫了mybatis。下面我们进行项目spring搭建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先设置Spring的启动，需要ConfigInit.java、WebConfig.java、RootConfig.java&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;ConfigInit.java&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.config;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:09:38
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;* @description ：充当web.xml的作用。
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigInit &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractAnnotationConfigDispatcherServletInitializer{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 加载RootConfig配置文件
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[] getRootConfigClasses() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {RootConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * 加载网站配置文件
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[] getServletConfigClasses() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {WebConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 设置项目起始目录路径为/
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String[] getServletMappings() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{&quot;/&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;WebConfig.java&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.config;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ViewResolver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.EnableWebMvc;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.view.InternalResourceViewResolver;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:09:49
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; @ComponentScan(&quot;com.gede.controller&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;@EnableWebMvc
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebMvcConfigurerAdapter{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 配置试图控制器
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 统一解析/WEB-INF/view/下的jsp文件
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewResolver viewResolver()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         InternalResourceViewResolver resolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalResourceViewResolver();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         resolver.setPrefix(&quot;/WEB-INF/view/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         resolver.setSuffix(&quot;.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolver;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * 允许静态资源解析
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        configurer.enable();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;RootConfig.java&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.config;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.EnableWebMvc;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:10:01
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@EnableWebMvc
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RootConfig {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到这一步我们已经把Spring以及SpringMVC启动配置类做完了，我们需要一个index.jsp和控制器IndexController.java来实现一个最简单mvc；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;IndexController.java&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod.GET;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:18:20
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     @RequestMapping(value=&quot;/&quot;,method=&lt;span&gt;GET)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190620222251763-2002610406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是我们需要导入的jar包：mybatis基础包，mybatis逆向工程的三个核心包，mybatis-spring的集成包和我们的mysql驱动jar包，下面开始整合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们采用数据库连接处的DataSource方式，在这里有两种选择，一可以选择新建DataConfig.java的配置文件，也可以直接配在我们的RootConfig.java 里面。在这里我们选择配在RootConfig中：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;配置数据源连接池：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; @Bean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BasicDataSource dataSource() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         BasicDataSource dataSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicDataSource();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/hotel?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         dataSource.setUsername(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         dataSource.setPassword(&quot;112233&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;创建sqlSessionFactoryBean工厂&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;  @Bean
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBean sqlSessionFactoryBean() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         PathMatchingResourcePatternResolver resolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathMatchingResourcePatternResolver();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         SqlSessionFactoryBean sqlSessionFactoryBean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBean();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        sqlSessionFactoryBean.setDataSource(dataSource());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             sqlSessionFactoryBean.setMapperLocations(resolver.getResources(&quot;classpath:com/gede/dao/*.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlSessionFactoryBean;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;设置mybatis基础扫描包和加载sql工厂&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;  @Bean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer mapperScannerConfigurer() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         MapperScannerConfigurer mapperScannerConfigurer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         mapperScannerConfigurer.setBasePackage(&quot;com.gede.dao&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactoryBean&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperScannerConfigurer;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的基础包扫描也可以使用@MapperScan()注释来实现，最后的RootConfig.java大致长这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.config;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbcp.BasicDataSource;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.SqlSessionFactoryBean;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.annotation.MapperScan;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.mapper.MapperScannerConfigurer;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.io.support.PathMatchingResourcePatternResolver;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.config.annotation.EnableWebMvc;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:10:01
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;@EnableWebMvc
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@MapperScan()&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RootConfig {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 数据资源配置
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BasicDataSource dataSource() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         BasicDataSource dataSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicDataSource();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/hotel?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         dataSource.setUsername(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         dataSource.setPassword(&quot;112233&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * mybatis配置
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBean sqlSessionFactoryBean() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         PathMatchingResourcePatternResolver resolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PathMatchingResourcePatternResolver();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         SqlSessionFactoryBean sqlSessionFactoryBean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBean();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        sqlSessionFactoryBean.setDataSource(dataSource());
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             sqlSessionFactoryBean.setMapperLocations(resolver.getResources(&quot;classpath:com/gede/dao/*.xml&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sqlSessionFactoryBean;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;     * mybatis配置
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer mapperScannerConfigurer() {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         MapperScannerConfigurer mapperScannerConfigurer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         mapperScannerConfigurer.setBasePackage(&quot;com.gede.dao&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactoryBean&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperScannerConfigurer;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     
&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个时候运行我们的项目发小项目报错了：&lt;/p&gt;
&lt;p&gt; org/springframework/dao/support/DaoSupport。。。。。。。。。。。。。&lt;/p&gt;
&lt;p&gt;查了一下缺少jar包，网上的都是关于maven的添加依赖，最后我这里添加了hibernate的框架解决了。启动成功，到这里我们的SSM框架就整合完成了。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;（四）测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　添加了hibernate的框架后，我们运行成功，开始写一些简单的测试。在这里我们写了一个user.jsp来显示从数据库中查到的用户信息，还有与其对应的SelectController 。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;user.jsp&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; import&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java.util.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://java.sun.com/jsp/jstl/core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;User&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.id}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;username:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;password:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sex:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.sex}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;tele:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.tele}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;qq:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.qq}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;enabled:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.enabled}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;authority:&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:out &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;${user.authority}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;SelectController 。通过调用相应的查询操作，然后我们让查询结果随model一起返回界面。这个时候我们的jsp上就可以用jstl来获取我们的值了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod.GET;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gede.model.Webuser;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gede.service.GetUserService;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:57:46
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SelectController {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; GetUserService getUserService;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SelectController(GetUserService getUserService) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.getUserService =&lt;span&gt; getUserService;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     @RequestMapping(value=&quot;/select&quot;,method=&lt;span&gt;GET)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(Model model){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         Webuser user=&lt;span&gt;getUserService.select();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         model.addAttribute(&quot;user&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;user&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GetUserServiceImpl这是我们的service层代码，负责调用mybatis逆向生成的mapper接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gede.service.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gede.dao.WebuserMapper;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gede.model.Webuser;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gede.service.GetUserService;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; gede
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; date：2019年6月20日 下午10:54:29
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;* @description ：
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GetUserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GetUserService {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  WebuserMapper webuserMapper;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GetUserServiceImpl(WebuserMapper webuserMapper) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.webuserMapper =&lt;span&gt; webuserMapper;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Webuser select() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         Webuser webuser=webuserMapper.selectByPrimaryKey(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; webuser;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里我们的项目大致如下，运行项目访问&lt;a href=&quot;http://localhost:8080/ssm//select&quot;&gt;http://localhost:8080/ssm//select&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190621080952270-415428888.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;709&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1565130/201906/1565130-20190621081101107-1155714434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢大家的观看，如有疑问请联系g376482a@163.com。附相关jar包：&lt;a href=&quot;https://www.lanzous.com/b792634/%20&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt; &lt;em id=&quot;__mceDel&quot;&gt;密码:i6s7&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Jun 2019 00:16:00 +0000</pubDate>
<dc:creator>g歌德a</dc:creator>
<og:description>以前用着SSH都是老师给配好的，自己直接改就可以。但是公司主流还是SSM,就自己研究了一下Java版本的配置。网上大多是基于xnl的配置，但是越往后越新的项目都开始基于JavaConfig配置了，这也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gede/p/11061859.html</dc:identifier>
</item>
<item>
<title>Solr 部署与使用踩坑全记录 - Charles Zhang</title>
<link>http://www.cnblogs.com/weisenz/p/11060952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weisenz/p/11060952.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;Solr 是一种可供企业使用的、基于 Lucene 的搜索服务器，它支持层面搜索、命中醒目显示和多种输出格式。在这篇文章中，将介绍 Solr 并展示如何轻松地将其表现优异的全文本搜索功能加入到 Web 应用程序中。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://lucene.apache.org/solr/downloads.html&quot; class=&quot;uri&quot;&gt;https://lucene.apache.org/solr/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文中使用的Solr 版本：7.7.2，因为我是用的是 Windows 系统，所以主要介绍的是 Windows 下的部署方法。&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;
&lt;p&gt;Solr 内置了 Jetty，所以不需要任何安装任何 Web 容器即可运行。直接通过命令行就可以启动。&lt;/p&gt;
&lt;p&gt;启动 Solr：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; .\solr.cmd start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停止 Solr：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; .\solr.cmd stop -all&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建-core&quot;&gt;创建 Core&lt;/h4&gt;
&lt;p&gt;首先在 &lt;code&gt;server\solr&lt;/code&gt; 文件夹中创建一个新的目录，然后将 &lt;code&gt;server\solr\configsets\_default&lt;/code&gt; 下的 &lt;code&gt;conf&lt;/code&gt; 目录复制到刚刚创建的文件夹。&lt;/p&gt;
&lt;p&gt;在浏览器中打开 &lt;code&gt;http://localhost:8983/solr/&lt;/code&gt; 点击左侧的 &lt;code&gt;Core Admin&lt;/code&gt; 添加 Core。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362228/201906/362228-20190620194859245-1178569105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;instanceDir&lt;/code&gt; 都改成刚刚创建的目录名称。&lt;/p&gt;
&lt;p&gt;创建好之后即可在左侧的 &lt;code&gt;Core Selector&lt;/code&gt; 中找到这个 Core。&lt;/p&gt;
&lt;p&gt;现在一个 Core 就创建好了，在 Core 的面板里可以对其进行一些基本操作。&lt;/p&gt;
&lt;p&gt;Solr 的 Api 是支持通过调用接口添加数据的，但是在实际使用中我们都是从数据库中同步数据，所以我们需要为 Solr 配置数据源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362228/201906/362228-20190620194917354-2094007271.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;solrconfig.xml&lt;/code&gt; 文件中找到如下内容：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;!-- Request Handlers
       http://wiki.apache.org/solr/SolrRequestHandler

       Incoming queries will be dispatched to a specific handler by name
       based on the path specified in the request.

       If a Request Handler is declared with startup=&quot;lazy&quot;, then it will
       not be initialized until the first request that uses it.
    --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加一个 &lt;code&gt;requestHandler&lt;/code&gt; 节点：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;requestHandler name=&quot;/dataimport&quot; class=&quot;solr.DataImportHandler&quot;&amp;gt;
    &amp;lt;lst name=&quot;defaults&quot;&amp;gt;
      &amp;lt;str name=&quot;config&quot;&amp;gt;data-config.xml&amp;lt;/str&amp;gt;
    &amp;lt;/lst&amp;gt;
  &amp;lt;/requestHandler&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;data-config.xml 文件的大致结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362228/201906/362228-20190620194928144-1300750743.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍后会对 data-config.xml 文件进行详细介绍。&lt;/p&gt;
&lt;h4 id=&quot;配置数据源&quot;&gt;配置数据源&lt;/h4&gt;
&lt;h5 id=&quot;使用-sql-server数据源&quot;&gt;使用 SQL Server 数据源&lt;/h5&gt;
&lt;p&gt;从&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server?view=sql-server-2017&quot;&gt;微软官网&lt;/a&gt;下载 SQL Server 的 Microsoft SQL Server JDBC 驱动程序 4.1 驱动，复制到 &lt;code&gt;server\solr-webapp\webapp\WEB-INF\lib&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;p&gt;这里需要注意的是把在下载的文件重命名为 &lt;code&gt;sqljdbc4.jar&lt;/code&gt;，我之前没有改名死活加载不上。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/code&gt; 驱动配置数据源：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dataSource name=&quot;postData&quot; driver=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; url=&quot;jdbc:sqlserver://127.0.0.1:1433;SelectMethod=Cursor;DatabaseName=post;useLOBs=false;loginTimeout=60&quot; user=&quot;charlestest&quot; password=&quot;12345678&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用-mysql数据源&quot;&gt;使用 MySQL 数据源&lt;/h5&gt;
&lt;p&gt;下载：mysql-connector-java-6.0.6.jar 复制到 &lt;code&gt;server\solr-webapp\webapp\WEB-INF\lib&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;dist&lt;/code&gt; 目录复制 &lt;code&gt;solr-dataimporthandler-7.7.2.jar&lt;/code&gt; 到 &lt;code&gt;server/solr-webapp/webapp/WEB-INF/lib&lt;/code&gt; 中。&lt;br/&gt;配置 &lt;code&gt;data-config.xml&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dataConfig&amp;gt;
    &amp;lt;dataSource name=&quot;postsData&quot;  type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/posts?useUnicode=true&amp;amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;amp;useLegacyDatetimeCode=false&amp;amp;amp;serverTimezone=UTC&quot; user=&quot;root&quot; password=&quot;12345678&quot; batchSize=&quot;-1&quot; /&amp;gt;
    &amp;lt;document name=&quot;posts&quot;&amp;gt;
        &amp;lt;entity name=&quot;Post&quot; dataSource=&quot;postData&quot; pk=&quot;Id&quot; transformer=&quot;DateFormatTransformer,HTMLStripTransformer&quot; rootEntity=&quot;true&quot; query=&quot;SELECT Id, post_author, post_date, post_date_gmt, post_content, post_title, post_excerpt, post_status, comment_status, ping_status, post_password, post_name, to_ping, pinged, post_modified, post_modified_gmt, post_content_filtered, post_parent, guid, menu_order, post_type, post_mime_type, comment_count
        FROM wp_posts&quot;
        deltaQuery=&quot;SELECT Id, post_author, post_date, post_date_gmt, post_content, post_title, post_excerpt, post_status, comment_status, ping_status, post_password, post_name, to_ping, pinged, post_modified, post_modified_gmt, post_content_filtered, post_parent, guid, menu_order, post_type, post_mime_type, comment_count
        FROM wp_posts post_modified &amp;amp;gt;'${dataimporter.last_index_time}' &quot; 
        &amp;gt;
            &amp;lt;field column=&quot;Id&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_author&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_date&quot; dateTimeFormat='yyyy-MM-dd HH:mm:ss'/&amp;gt;
            &amp;lt;field column=&quot;post_date_gmt&quot; dateTimeFormat='yyyy-MM-dd HH:mm:ss'/&amp;gt;
            &amp;lt;field column=&quot;post_content&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_title&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_excerpt&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_status&quot; /&amp;gt;
            &amp;lt;field column=&quot;comment_status&quot; /&amp;gt;
            &amp;lt;field column=&quot;ping_status&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_password&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_name&quot; /&amp;gt;
            &amp;lt;field column=&quot;to_ping&quot; /&amp;gt;
            &amp;lt;field column=&quot;pinged&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_modified&quot; dateTimeFormat='yyyy-MM-dd HH:mm:ss'/&amp;gt;
            &amp;lt;field column=&quot;post_modified_gmt&quot; dateTimeFormat='yyyy-MM-dd HH:mm:ss'/&amp;gt;
            &amp;lt;field column=&quot;post_content_filtered&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_parent&quot; /&amp;gt;
            &amp;lt;field column=&quot;guid&quot; /&amp;gt;
            &amp;lt;field column=&quot;menu_order&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_type&quot; /&amp;gt;
            &amp;lt;field column=&quot;post_mime_type&quot; /&amp;gt;
            &amp;lt;field column=&quot;comment_count&quot; /&amp;gt;
            &amp;lt;entity name=&quot;PostAuthor&quot; dataSource=&quot;authordata&quot; pk=&quot;Id&quot; query=&quot;SELECT Id, user_login, user_pass, user_nicename, user_email, user_url, user_registered, user_activation_key, user_status, display_name
            FROM wp_users where id=${Post.post_author}&quot;&amp;gt;
                &amp;lt;field column=&quot;Id&quot; /&amp;gt;
                &amp;lt;field column=&quot;user_login&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_pass&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_nicename&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_email&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_url&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_registered&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_activation_key&quot;/&amp;gt;
                &amp;lt;field column=&quot;user_status&quot;/&amp;gt;
                &amp;lt;field column=&quot;display_name&quot;/&amp;gt;
            &amp;lt;/entity&amp;gt;
        &amp;lt;/entity&amp;gt;
    &amp;lt;/document&amp;gt;
&amp;lt;/dataConfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;entity 中的一些常用属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;query：查询只对第一次全量导入有作用，对增量同步不起作用。&lt;/li&gt;
&lt;li&gt;deltaQuery：的意思是，查询出所有经过修改的记录的 Id 可能是修改操作，添加操作，删除操作产生的（此查询只对增量导入起作用，而且只能返回 Id 值）&lt;/li&gt;
&lt;li&gt;deletedPkQuery：此操作值查询那些数据库里伪删除的数据的 Id、solr 通过它来删除索引里面对应的数据（此查询只对增量导入起作用，而且只能返回 Id 值）。&lt;/li&gt;
&lt;li&gt;deltaImportQuery：是获取以上两步的 Id，然后把其全部数据获取，根据获取的数据对索引库进行更新操作，可能是删除，添加，修改（此查询只对增量导入起作用，可以返回多个字段的值，一般情况下，都是返回所有字段的列）。&lt;/li&gt;
&lt;li&gt;parentDeltaQuery：从本 entity 中的 deltaquery 中取得参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;dataSource 中 batchSize 属性的作用是可以在批量导入的时候限制连接数量。&lt;/p&gt;
&lt;p&gt;配置完成后重新加载一下 Core。&lt;/p&gt;
&lt;h4 id=&quot;中文分词&quot;&gt;中文分词&lt;/h4&gt;
&lt;p&gt;将 &lt;code&gt;contrib\analysis-extras\lucene-libs&lt;/code&gt; 目录中的 &lt;code&gt;lucene-analyzers-smartcn-7.7.2.jar&lt;/code&gt; 复制到 &lt;code&gt;server\solr-webapp\webapp\WEB-INF\lib&lt;/code&gt; 目录下，否则会报错。&lt;br/&gt;在 &lt;code&gt;managed-shchema&lt;/code&gt; 中添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;!-- 配置中文分词器 --&amp;gt;
  &amp;lt;fieldType name=&quot;text_cn&quot; class=&quot;solr.TextField&quot;&amp;gt;
    &amp;lt;analyzer type=&quot;index&quot;&amp;gt;
      &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot; /&amp;gt;
    &amp;lt;/analyzer&amp;gt;
    &amp;lt;analyzer type=&quot;query&quot;&amp;gt;
      &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot; /&amp;gt;
    &amp;lt;/analyzer&amp;gt;
  &amp;lt;/fieldType&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把需要使用中文分词的字段类型设置成 &lt;code&gt;text_cn&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;field name=&quot;Remark&quot; type=&quot;text_cn&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;主从部署&quot;&gt;主从部署&lt;/h4&gt;
&lt;p&gt;Solr 复制模式，是一种在分布式环境下用于同步主从服务器的一种实现方式，因之前提到的基于 rsync 的 SOLR 不同方式部署成本过高，被 Solr 1.4 版本所替换，取而代之的就是基于 HTTP 协议的索引文件传输机制，该方式部署简单，只需配置一个文件即可。Solr 索引同步的是 Core 对 Core，以 Core 为基本同步单元。&lt;/p&gt;
&lt;p&gt;主服务器 &lt;code&gt;solrconfig.xml&lt;/code&gt; 配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot;&amp;gt;
    &amp;lt;lst name=&quot;master&quot;&amp;gt;
        &amp;lt;!-- 执行 commit 操作后进行 replicate 操作同样的设置'startup', 'commit', 'optimize'--&amp;gt;
        &amp;lt;str name=&quot;replicateAfter&quot;&amp;gt;commit&amp;lt;/str&amp;gt;
        &amp;lt;!-- 执行 startup 操作后进行 replicate 操作 --&amp;gt;
        &amp;lt;str name=&quot;replicateAfter&quot;&amp;gt;startup&amp;lt;/str&amp;gt;
        &amp;lt;!-- 复制索引时也同步以下配置文件 --&amp;gt;
        &amp;lt;str name=&quot;confFiles&quot;&amp;gt;schema.xml,stopwords.txt&amp;lt;/str&amp;gt;
        &amp;lt;!-- 每次 commit 之后，保留增量索引的周期时间，这里设置为 5 分钟。 --&amp;gt;
        &amp;lt;str name=&quot;commitReserveDuration&quot;&amp;gt;00:05:00&amp;lt;/str&amp;gt;  
        &amp;lt;!-- 验证信息，由用户自定义用户名--&amp;gt;
        &amp;lt;!-- &amp;lt;str name=&quot;httpBasicAuthUser&quot;&amp;gt;root&amp;lt;/str&amp;gt; --&amp;gt;
        &amp;lt;!-- 验证信息，由用户自定义密码 --&amp;gt;
        &amp;lt;!-- &amp;lt;str name=&quot;httpBasicAuthPassword&quot;&amp;gt;password&amp;lt;/str&amp;gt; --&amp;gt;
    &amp;lt;/lst&amp;gt;
    &amp;lt;!--
       &amp;lt;lst name=&quot;slave&quot;&amp;gt;
         &amp;lt;str name=&quot;masterUrl&quot;&amp;gt;http://your-master-hostname:8983/solr&amp;lt;/str&amp;gt;
         &amp;lt;str name=&quot;pollInterval&quot;&amp;gt;00:00:60&amp;lt;/str&amp;gt;
       &amp;lt;/lst&amp;gt;
    --&amp;gt;
&amp;lt;/requestHandler&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从服务器 &lt;code&gt;solrconfig.xml&lt;/code&gt; 配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot;&amp;gt;
    &amp;lt;lst name=&quot;slave&quot;&amp;gt;
        &amp;lt;!-- 主服务器的同步地址 --&amp;gt;
        &amp;lt;str name=&quot;masterUrl&quot;&amp;gt;http://192.168.1.135/solr/posts&amp;lt;/str&amp;gt;
        &amp;lt;!-- 从服务器同步间隔，即每隔多长时间同步一次主服务器 --&amp;gt;
        &amp;lt;str name=&quot;pollInterval&quot;&amp;gt;00:00:60&amp;lt;/str&amp;gt;
        &amp;lt;!-- 压缩机制，来传输索引，可选 internal|external，internal：内网，external：外网 --&amp;gt;
        &amp;lt;str name=&quot;compression&quot;&amp;gt;internal&amp;lt;/str&amp;gt;
        &amp;lt;!-- 设置连接超时（单位：毫秒） --&amp;gt;
        &amp;lt;str name=&quot;httpConnTimeout&quot;&amp;gt;50000&amp;lt;/str&amp;gt;
        &amp;lt;!-- 如果设置同步索引文件过大，则应适当提高此值。（单位：毫秒） --&amp;gt;
        &amp;lt;str name=&quot;httpReadTimeout&quot;&amp;gt;500000&amp;lt;/str&amp;gt;
        &amp;lt;!-- 验证用户名，需要和 master 服务器一致 --&amp;gt;
        &amp;lt;!-- &amp;lt;str name=&quot;httpBasicAuthUser&quot;&amp;gt;root&amp;lt;/str&amp;gt; --&amp;gt;
        &amp;lt;!-- 验证密码，需要和 master 服务器一致 --&amp;gt;
        &amp;lt;!-- &amp;lt;str name=&quot;httpBasicAuthPassword&quot;&amp;gt;password&amp;lt;/str&amp;gt; --&amp;gt;
    &amp;lt;/lst&amp;gt;
&amp;lt;/requestHandler&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Solr 主从同步是通过 Slave 周期性轮询来检查 Master 的版本，如果 Master 有新版本的索引文件，Slave 就开始同步复制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、Slave 发出一个 filelist 命令来收集文件列表。这个命令将返回一系列元数据（size、lastmodified、alias 等信息）。&lt;/li&gt;
&lt;li&gt;2、Slave 查看它本地是否有这些文件，然后它会开始下载缺失的文件（使用命令 filecontent）。如果与 Master 连接失败，就会重新连接，如果重试 5 次还是没有成功，就会 Slave 停止同步。&lt;/li&gt;
&lt;li&gt;3、文件被同步到了一个临时目录（&lt;code&gt;index.时间戳&lt;/code&gt; 格式的文件夹名称，例如：index.20190614133600008）。旧的索引文件还存放在原来的文件夹中，同步过程中出错不会影响到 Slave，如果同步过程中有请求访问，Slave 会使用旧的索引。&lt;/li&gt;
&lt;li&gt;4、当同步结束后，Slave 就会删除旧的索引文件使用最新的索引。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们项目中 6.7G 的索引文件（279 万条记录），大概只用了 12 分钟左右就同步完成了，平均每秒的同步速度大约在 10M 左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362228/201906/362228-20190620194958419-333360003.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/362228/201906/362228-20190620195004572-2008608870.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt; 如果主从的数据源配置的不一致，很可能导致从服务器无法同步索引数据。&lt;/p&gt;
&lt;h4 id=&quot;在项目中使用-solr&quot;&gt;在项目中使用 Solr&lt;/h4&gt;
&lt;h5 id=&quot;在-java-项目中使用-solr&quot;&gt;在 Java 项目中使用 Solr&lt;/h5&gt;
&lt;p&gt;SolrJ 是 Solr 的官方客户端，文档地址：&lt;a href=&quot;https://lucene.apache.org/solr/7_7_2/solr-solrj/&quot; class=&quot;uri&quot;&gt;https://lucene.apache.org/solr/7_7_2/solr-solrj/&lt;/a&gt;。&lt;br/&gt;使用 maven 添加：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.apache.solr/solr-solrj --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.solr&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;solr-solrj&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;7.7.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询索引文档：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    String keyword = &quot;苹果&quot;;
    Map&amp;lt;String, String&amp;gt; queryParamMap = new HashMap&amp;lt;String, String&amp;gt;();
    queryParamMap.put(&quot;q&quot;, &quot;*:*&quot;);
    queryParamMap.put(&quot;fq&quot;, keyword);
    MapSolrParams queryParams = new MapSolrParams(queryParamMap);
    QueryResponse queryResponse = client.query(&quot;posts&quot;, queryParams);
    SolrDocumentList results = queryResponse.getResults();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加和更新索引文档：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 通过 属性 添加到索引中
    SolrInputDocument doc = new SolrInputDocument();
    doc.addField(&quot;id&quot;, &quot;10000&quot;);
    doc.addField(&quot;post_title&quot;, &quot;test-title&quot;);
    doc.addField(&quot;post_name&quot;, &quot;test-name&quot;);
    doc.addField(&quot;post_excerpt&quot;, &quot;test-excerpt&quot;);
    doc.addField(&quot;post_content&quot;, &quot;test-content&quot;);
    doc.addField(&quot;post_date&quot;, &quot;2019-06-18 14:56:55&quot;);
    client.add(&quot;posts&quot;, doc);

    // 通过 Bean 添加到索引中
    Post post = new Post();
    post.setId(10001);
    post.setPost_title(&quot;test-title-10001&quot;);
    post.setPost_name(&quot;test-name&quot;);
    post.setPost_excerpt(&quot;test-excerpt&quot;);
    post.setPost_content(&quot;test-content&quot;);
    post.setPost_date(new Date());
    client.addBean(&quot;posts&quot;, post);

    client.commit(&quot;posts&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体代码可以参考我 GitHub 中的示例，这里就不详细列出了。&lt;/p&gt;
&lt;h5 id=&quot;在-dotnet-项目中使用-solr&quot;&gt;在 DotNet 项目中使用 Solr&lt;/h5&gt;
&lt;p&gt;SolrNet：&lt;a href=&quot;https://github.com/mausch/SolrNet&quot; class=&quot;uri&quot;&gt;https://github.com/mausch/SolrNet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过 Nuget 添加 SolrNet：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Install-Package SolrNet&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定义一个索引对象 &lt;code&gt;PostDoc&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 文章 doc。
    /// &amp;lt;/summary&amp;gt;
    [Serializable]
    public class PostDoc
    {
        [SolrUniqueKey(&quot;id&quot;)]
        public int Id { get; set; }

        [SolrField(&quot;post_title&quot;)]
        public string Title { get; set; }

        [SolrField(&quot;post_name&quot;)]
        public string Name { get; set; }

        [SolrField(&quot;post_excerpt&quot;)]
        public string Excerpt { get; set; }

        [SolrField(&quot;post_content&quot;)]
        public string Content { get; set; }

        [SolrField(&quot;post_date&quot;)]
        public DateTime PostDate { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目的 &lt;code&gt;Startup&lt;/code&gt; 类中初始化 SolrNet：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;  SolrNet.Startup.Init&amp;lt;PostDoc&amp;gt;(&quot;http://localhost:8983/solr/posts&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加或更新文档操作：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    // 同步添加文档
    solr.Add(
        new PostDoc()
        {
            Id = 30001,
            Name = &quot;This SolrNet Name&quot;,
            Title = &quot;This SolrNet Title&quot;,
            Excerpt = &quot;This SolrNet Excerpt&quot;,
            Content = &quot;This SolrNet Content 30001&quot;,
            PostDate = DateTime.Now
        }
    );
    // 异步添加文档（更新）
    await solr.AddAsync(
        new PostDoc()
        {
            Id = 30001,
            Name = &quot;This SolrNet Name&quot;,
            Title = &quot;This SolrNet Title&quot;,
            Excerpt = &quot;This SolrNet Excerpt&quot;,
            Content = &quot;This SolrNet Content Updated 30001&quot;,
            PostDate = DateTime.Now
        }
    );
    // 提交
    ResponseHeader responseHeader = await solr.CommitAsync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除文档操作：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    // 使用文档 Id 删除
    await solr.DeleteAsync(&quot;300001&quot;);
    // 直接删除文档
    await solr.DeleteAsync(new PostDoc()
    {
        Id = 30002,
        Name = &quot;This SolrNet Name&quot;,
        Title = &quot;This SolrNet Title&quot;,
        Excerpt = &quot;This SolrNet Excerpt&quot;,
        Content = &quot;This SolrNet Content 30002&quot;,
        PostDate = DateTime.Now
    });
    // 提交
    ResponseHeader responseHeader = await solr.CommitAsync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搜索并对结果进行排序，在不传入分页参数的情况下 SolrNet 会返回所有满足条件的结果。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    // 排序
    ICollection&amp;lt;SortOrder&amp;gt; sortOrders = new List&amp;lt;SortOrder&amp;gt;() {
        new SortOrder(&quot;id&quot;, Order.DESC)
    };
    // 使用查询条件并排序
    SolrQueryResults&amp;lt;PostDoc&amp;gt; docs = await solr.QueryAsync(&quot;post_title:索尼&quot;, sortOrders);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用字段筛选的另一种方式：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    // 使用条件查询
    SolrQueryResults&amp;lt;PostDoc&amp;gt; posts = solr.Query(new SolrQueryByField(&quot;id&quot;, &quot;30000&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分页查询并对高亮关键字：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    SolrQuery solrQuery = new SolrQuery(&quot;苹果&quot;);
    QueryOptions queryOptions = new QueryOptions
    {
        // 高亮关键字
        Highlight = new HighlightingParameters
        {
            Fields = new List&amp;lt;string&amp;gt; { &quot;post_title&quot; },
            BeforeTerm = &quot;&amp;lt;font color='red'&amp;gt;&amp;lt;b&amp;gt;&quot;,
            AfterTerm = &quot;&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;&quot;
        },
        // 分页
        StartOrCursor = new StartOrCursor.Start(pageIndex * pageSize),
        Rows = pageSize
    };
    SolrQueryResults&amp;lt;PostDoc&amp;gt; docs = await solr.QueryAsync(solrQuery, queryOptions);
    var highlights = docs.Highlights;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;高亮关键字需要在返回结果中单独获取，&lt;code&gt;docs.Highlights&lt;/code&gt; 是一个 &lt;code&gt;IDictionary&amp;lt;string, HighlightedSnippets&amp;gt;&lt;/code&gt; 对象，每个 &lt;code&gt;key&lt;/code&gt; 对应文档的 &lt;code&gt;id&lt;/code&gt;，&lt;code&gt;HighlightedSnippets&lt;/code&gt; 中也是一个 &lt;code&gt;Dictionary&lt;/code&gt;，存储高亮处理后的字段和内容。&lt;/p&gt;
&lt;h5 id=&quot;在-python-项目中使用-solr&quot;&gt;在 Python 项目中使用 Solr&lt;/h5&gt;
&lt;p&gt;PySolr：&lt;a href=&quot;https://github.com/django-haystack/pysolr&quot; class=&quot;uri&quot;&gt;https://github.com/django-haystack/pysolr&lt;/a&gt;&lt;br/&gt;使用 &lt;code&gt;pip&lt;/code&gt; 安装 pysolr：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip install pysolr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的操作：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
import pysolr

SOLR_URL = 'http://localhost:8983/solr/posts'

def add():
    &quot;&quot;&quot;
    添加
    &quot;&quot;&quot;
    result = solr.add([
        {
            'id': '20000',
            'post_title': 'test-title-20000',
            'post_name': 'test-name-20000',
            'post_excerpt': 'test-excerpt-20000',
            'post_content': 'test-content-20000',
            'post_date': '2019-06-18 14:56:55',
        },
        {
            'id': '20001',
            'post_title': 'test-title-20001',
            'post_name': 'test-name-20001',
            'post_excerpt': 'test-excerpt-20001',
            'post_content': 'test-content-20001',
            'post_date': '2019-06-18 14:56:55',
        }
    ])
    solr.commit()
    results = solr.search(q='id: 20001')
    print(results.docs)

def delete():
    &quot;&quot;&quot;
    删除
    &quot;&quot;&quot;
    solr.delete(q='id: 20001')
    solr.commit()
    results = solr.search(q='id: 20001')
    print(results.docs)

def update():
    &quot;&quot;&quot;
    更新
    &quot;&quot;&quot;
    solr.add([
        {
            'id': '20000',
            'post_title': 'test-title-updated',
            'post_name': 'test-name-updated',
            'post_excerpt': 'test-excerpt-updated',
            'post_content': 'test-content-updated',
            'post_date': '2019-06-18 15:00:00',
        }
    ])
    solr.commit()   
    results = solr.search(q='id: 20000')
    print(results.docs)

def query():
    &quot;&quot;&quot;
    查询
    &quot;&quot;&quot;
    results = solr.search('苹果')
    print(results.docs)

if __name__ == &quot;__main__&quot;:
    solr = pysolr.Solr(SOLR_URL)
    add()
    delete()
    update()
    query()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是在使用 &lt;code&gt;solr.add()&lt;/code&gt; 和 &lt;code&gt;solr.delete&lt;/code&gt; 方法以后需要执行一下 &lt;code&gt;solr.commit()&lt;/code&gt; 方法，否则文档的变更不会提交。&lt;br/&gt;如果想获取添加或更新是否成功可以通过判断 &lt;code&gt;solr.commit()&lt;/code&gt; 方法返回结果，&lt;code&gt;solr.commit()&lt;/code&gt; 方法的返回结果是一个 xml 字符串：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    &amp;lt;response&amp;gt;
        &amp;lt;lst name=&quot;responseHeader&quot;&amp;gt;
        &amp;lt;int name=&quot;status&quot;&amp;gt;0&amp;lt;/int&amp;gt;
        &amp;lt;int name=&quot;QTime&quot;&amp;gt;44&amp;lt;/int&amp;gt;
    &amp;lt;/lst&amp;gt;
&amp;lt;/response&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;status&lt;/code&gt; 的值如果是 0 就表示提交成功了。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;通过简单使用和测试，就会发现搜索结果并不是很精准，比如搜索“微软”这个关键字，搜索出来的数据中有完全不包含这个关键字的内容，所以要想让搜索结果更加准确就必须对 Sorl 进行调优，Solr 中还有很多高级的用法，例如设置字段的权重、自定义中文分词词库等等，有机会我会专门写一篇这样的文章来介绍这些功能。&lt;br/&gt;我在 &lt;code&gt;sql&lt;/code&gt; 目录里提供了数据库脚本，方便大家创建测试数据，数据是以前做的一个小站从网上抓取过来的科技新闻。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Jun 2019 23:31:00 +0000</pubDate>
<dc:creator>Charles Zhang</dc:creator>
<og:description>Solr 是一种可供企业使用的、基于 Lucene 的搜索服务器，它支持层面搜索、命中醒目显示和多种输出格式。在这篇文章中，将介绍 Solr 并展示如何轻松地将其表现优异的全文本搜索功能加入到 Web</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weisenz/p/11060952.html</dc:identifier>
</item>
<item>
<title>Consul-template+nginx实现自动负载均衡 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11061145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11061145.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;consul-template 是 Consul 的一个守护程序，使用 consul-template 可以方便快速的实现对 Consul Key/Value 存储系统的访问，可以从 KV 系统中读取数据、监视变动、同步本地文件；还可以在执行模板更新的同时，执行本地系统命令，比如常见的就是在同步数据到本地模板文件后，生成 Nginx 配置文件，并执行 nginx -s reload 命令，使 Nginx 重新加载配置文件。&lt;/p&gt;
&lt;h5 id=&quot;consul-template-的特点&quot;&gt;consul-template 的特点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;智能发现：一旦开始运行 consul-template ，consul-template 将会自动的发现 Consul 中的 Key/Value 变更，并自动更新到本地模板文件&lt;/li&gt;
&lt;li&gt;重复过滤：consul-template 内部可以跨实例对数据进行重复筛选，多个 consul-template 实例进行选举，确定只有一个 consul-template 执行 KV 查询，然后将结果同步到其它 consul-template 实例，在命令行中使用 -dedup 标记或者在配置文件中配置“deduplicate” 来启用重复过滤功能&lt;/li&gt;
&lt;li&gt;快速使用：支持命令行和配置文件，有多种方法可以运行Consul Template，但最常见的模式是将Consul Template作为系统服务运行。&lt;/li&gt;
&lt;li&gt;Dry Mode：在Dry模式，Consul-Template会将结果呈现在STDOUT，操作员可以检查输出是否正常，以决定更换模板是否安全。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考文档：&lt;br/&gt;&lt;a href=&quot;https://www.google.com&quot; class=&quot;uri&quot;&gt;https://www.google.com&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/hashicorp/consul-template&quot; class=&quot;uri&quot;&gt;https://github.com/hashicorp/consul-template&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.consul.io&quot; class=&quot;uri&quot;&gt;https://www.consul.io&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.hi-linux.com/posts/36431.html&quot; class=&quot;uri&quot;&gt;https://www.hi-linux.com/posts/36431.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;centos7.0-安装-nginx&quot;&gt;Centos7.0 安装 nginx&lt;/h2&gt;
&lt;p&gt;执行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 添加源
rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm

// 执行安装
yum install -y nginx

// 修改 nginx 默认端口为 8010
vi /etc/nginx/conf.d/default.conf

// 加入开机启动
systemctl enable nginx.service

// 启动 nginx
systemctl start nginx.service&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;打开浏览器&quot;&gt;打开浏览器&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://172.16.1.218:8010&quot; class=&quot;uri&quot;&gt;http://172.16.1.218:8010&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202212830-1209575469.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;设置-consul-template-的生成-nginx-配置文件的目录&quot;&gt;设置 Consul-template 的生成 nginx 配置文件的目录&lt;/h2&gt;
&lt;h5 id=&quot;创建目录&quot;&gt;创建目录&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /etc/nginx/conf.d/consul&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;编辑-nginx.conf&quot;&gt;编辑 nginx.conf&lt;/h5&gt;
&lt;p&gt;编辑 nginx.conf 文件，将上面的目录 /etc/nginx/conf.d/consul 作为配置文件目录导入到 nginx 中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/nginx/nginx.conf

// 将下面这句代码加入到nginx倒数第二行

include /etc/nginx/consul/*.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;编辑好的-nginx.conf-文件&quot;&gt;编辑好的 nginx.conf 文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202221871-2019860317.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-consul-template&quot;&gt;安装 consul-template&lt;/h2&gt;
&lt;p&gt;因为 consul-template 只有一个二进制包，所以其安装过程非常的简单；首先是下载二进制包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://releases.hashicorp.com/consul-template/0.20.0/consul-template_0.20.0_linux_amd64.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压到当前目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxf consul-template_0.20.0_linux_amd64.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移动到 consul 相同目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /usr/local/bin/consul-template
mv consul-template /usr/local/bin/consul-template&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置环境变量，输入命令：vi /etc/profile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将这里的代码添加到 profile 文件末尾
export CONSUL_TEMPLATE_HOME=/usr/local/bin/consul-template
export PATH=$PATH:$CONSUL_HOME:$CONSUL_TEMPLATE_HOME

// 执行命令使环境变量生效
source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将模板文件存入-kv系统&quot;&gt;将模板文件存入 KV系统&lt;/h2&gt;
&lt;p&gt;为了获得变更自动通知，我们呢需要将 consul-template 模板文件添加到 Consul 的 Key/Value 存储系统中&lt;/p&gt;
&lt;h5 id=&quot;从控制台存入&quot;&gt;从控制台存入&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202232597-602644626.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码格式选择 HCL，会自动高亮喔。关于 consul-template 的语法，请参考：&lt;a href=&quot;https://github.com/hashicorp/consul-template%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%EF%BC%8C%E6%88%91%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E4%BA%86%E5%AE%98%E6%96%B9%E7%9A%84&quot; class=&quot;uri&quot;&gt;https://github.com/hashicorp/consul-template，为了方便，我直接复制了官方的&lt;/a&gt; examples/nginx.md 文件内容&lt;/p&gt;
&lt;h5 id=&quot;在-consul-template-本地建立-tpl-文件&quot;&gt;在 consul-template 本地建立 tpl 文件&lt;/h5&gt;
&lt;p&gt;回到 consul-template 服务器上的目录 /usr/local/bin/consul-template ，创建一个 find_adress.tpl 文件内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 创建文件
vi find_adress.tpl

// 输入以下内容
{{ key &quot;hashicorp/street_address&quot; }}

// 保存退出&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;根据-find_adress.tpl-获得模板内容&quot;&gt;根据 find_adress.tpl 获得模板内容&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;// 执行命令
consul-template --template &quot;find_address.tpl:hashicorp_address.tpl&quot; -once&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，准备工作进行到这里，已基本结束；经过这么长时间的命令执行，相信很多同学已经把网页关闭了，但是没办法，这这些事情还是得一步一步的来。&lt;/p&gt;
&lt;h2 id=&quot;启动-consul-template&quot;&gt;启动 consul-template&lt;/h2&gt;
&lt;p&gt;终于可以启动了 consul-template 了，激动人心哪，consul-template 提供两种启动方式，命令行参数/加载配置文件 方式启动，就便利性来说，还是推荐“加载配置文件”方式启动，一次配置，终身有效嘛。&lt;/p&gt;
&lt;h5 id=&quot;命令行参数启动方式&quot;&gt;命令行参数启动方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;consul-template --consul-addr 172.16.1.218:8500 --template &quot;hashicorp_address.tpl:/etc/nginx/consul/vhost.conf:/usr/sbin/nginx -s reload&quot; --log-level=info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码参数这里做简单的解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--consul-addr：指定 Consul 代理服务器的地址，默认 127.0.0.1:8500&lt;/li&gt;
&lt;li&gt;--template ：指定模板，这里有3个值，每个值以冒号（：）进行分隔，首先是利用 hashicorp_address.tpl 生成 /etc/nginx/consul/vhost.conf 配置文件，然后马上执行命令 /usr/sbin/nginx -s reload 重新加载 nginx 配置&lt;/li&gt;
&lt;li&gt;--log-level：日志输出级别&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;查看生成的-vhost.conf-文件&quot;&gt;查看生成的 vhost.conf 文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202257661-974438049.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;加载配置文件启动方式&quot;&gt;加载配置文件启动方式&lt;/h5&gt;
&lt;p&gt;编写 hashicorp 的 nginx 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wait {
    min = &quot;3s&quot;
    max = &quot;9s&quot;
}

syslog {
    enabled = true
    facility = &quot;LOCAL5&quot;
}

consul {
    address = &quot;172.16.1.218:8500&quot;
}

template {
    source = &quot;hashicorp_address.tpl&quot;
    destination = &quot;/etc/nginx/consul/vhost.conf&quot;
    command = &quot;service nginx reload&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行参数和配置文件中的参数名称是一致的，配置文件编写完成，以加载配置文件形式启动 consul-template&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;consul-template -config &quot;nginx.hcl&quot; --log-level=info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202304047-339844492.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图看到，consul-template 启动后即刻进入侦听状态，在侦听 Consul 服务变动，如果有服务注册进来，马上就会更新 nginx 文件；下面，我们尝试启动一个 Ron.Consul.dll:12008 的服务，该服务将会注册到 Consul，让我们来看看在不重新启动 consul-template 的情况下，是否会自动更新 vhost.conf 文件&lt;/p&gt;
&lt;h5 id=&quot;启动-12008-服务注册&quot;&gt;启动 12008 服务注册&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202309024-889287081.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12008注册为 home 节点的服务已经启动了，下面查看 /etc/nginx/consul/vhost.conf 配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202321391-255185079.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图红框处内容就是自动更新的配置文件&lt;/p&gt;
&lt;h5 id=&quot;通过访问-nginx-访问服务&quot;&gt;通过访问 nginx 访问服务&lt;/h5&gt;
&lt;p&gt;还记得最开始的时候，我们设置 nginx 的默认侦听端口为 8010 吗；现在，我们在浏览器中打开下面的地址&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://172.16.1.218:8010/home/add/10/20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190620202328872-149118874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到返回值：30，表示本次搭建 consul-template+nginx 成功！&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;写了这么长时间的博客，这篇文章应该是输入命令最多的一篇文章了，这也是和 Windows 下编程的最大的不同，很有快感，希望大家也乐在其中。&lt;/p&gt;
&lt;h2 id=&quot;netcore-集成-consul-导读&quot;&gt;.NETCore 集成 Consul 导读&lt;/h2&gt;
</description>
<pubDate>Thu, 20 Jun 2019 22:21:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>前言 consul template 是 Consul 的一个守护程序，使用 consul template 可以方便快速的实现对 Consul Key/Value 存储系统的访问，可以从 KV 系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11061145.html</dc:identifier>
</item>
<item>
<title>交换平台第二章：项目边界与架构设计（上） - 妖生</title>
<link>http://www.cnblogs.com/yaoshen/p/11062354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoshen/p/11062354.html</guid>
<description>&lt;h3 id=&quot;第二章项目边界与架构设计上&quot;&gt;第二章：项目边界与架构设计（上）&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;author 妖生&lt;br/&gt;date 2019-06-21&lt;br/&gt;slogan：本是江湖客，曾把青锋剑，不料入此坑，书下与或非。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;导读&quot;&gt;2.1 导读&lt;/h3&gt;
&lt;p&gt;上一章讲了&lt;a href=&quot;https://www.cnblogs.com/yaoshen/p/11037399.html&quot;&gt;数据交换平台的一些基本概念&lt;/a&gt;，也留下了一些疑问：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么把数据变成文件上传到前置机上去交换？怎么在目标端下载下来？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么保证大文件的传输完整呢？中途失败了怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么知道对面的主机收到了我发送的文件呢？网闸可不提供TCP的ACK功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么保证数据的安全性呢？中途被篡改了怎么办？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么保证数据的时序性呢？网闸可不按照时间顺序给你传递文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;怎么监控数据流转的情况呢？丢包了怎么办？有没有办法可以知道？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章我们来讲讲数据交换平台的项目边界与架构设计，并在我们的架构设计里回答部分上面的问题。&lt;/p&gt;
&lt;h3 id=&quot;平台边界与系统目标&quot;&gt;2.2 平台边界与系统目标&lt;/h3&gt;
&lt;p&gt;首先，让我们来问自己几个问题：&lt;/p&gt;
&lt;p&gt;1、我们做的平台，目的是什么？&lt;br/&gt;2、与业务系统的边界在哪里？&lt;/p&gt;
&lt;p&gt;首先，我们的目的是什么？&lt;/p&gt;
&lt;p&gt;我们之前在做数据交换的工作的时候，把这部分功能融合在了业务系统中，好处是：开发快，用一个工具类就完成了文件的上传、下载。&lt;/p&gt;
&lt;p&gt;坏处呢？在业务系统渐渐繁杂的时候，所有的业务功能都要去调用这个工具类，进行文件打包、上传的操作。与业务深度耦合，不能给其他系统服用。&lt;br/&gt;上传之后，也不知道目标节点到底有没有收到这个包。&lt;br/&gt;在接收到文件时，也不知道在传输的过程中，这个文件是否被篡改。&lt;/p&gt;
&lt;p&gt;随着国家对信息安全的要求越来越严格，网闸、文件加密都已经成为了防火防盗的其中一把安全锁。&lt;/p&gt;
&lt;p&gt;那么现在可以说，我们的目的是什么？&lt;/p&gt;
&lt;p&gt;1、是为了能在跨网闸（关于网闸的概念详见第一章&lt;a href=&quot;https://www.cnblogs.com/yaoshen/p/11037399.html&quot;&gt;数据交换平台的一些基本概念&lt;/a&gt;）的情况下传输文件，快速传输。&lt;br/&gt;在之前的系统中，数据经常会有延迟一两天的情况才到达目标节点的情况。&lt;/p&gt;
&lt;p&gt;2、可以监控文件流转情况。&lt;br/&gt;在无法监控的情况下，总是人工排查，经常耗费运维人员一整天的时间，也让客户对我们产生了不信任感。&lt;/p&gt;
&lt;p&gt;3、文件传输加密。&lt;br/&gt;满足国家的信息安全要求。&lt;/p&gt;
&lt;p&gt;4、保证文件入库的有序性。&lt;br/&gt;在业务的流转中，有时会更新同一条数据，或者先插入再更新，怎么保证这个先后顺序呢？&lt;/p&gt;
&lt;p&gt;5、与业务系统解耦。&lt;br/&gt;将新的交换平台从业务系统中剥离出来，为各个业务系统提供数据交换的需求实现。&lt;/p&gt;
&lt;h3 id=&quot;技术选型与目标实现&quot;&gt;2.3 技术选型与目标实现&lt;/h3&gt;
&lt;p&gt;那么，针对以上情况，我们要怎么做架构设计？怎么做技术选型呢？&lt;/p&gt;
&lt;h4 id=&quot;文件传输工具选型&quot;&gt;2.3.1 文件传输工具选型&lt;/h4&gt;
&lt;p&gt;1、首先是文件传输。怎么去做技术选型？&lt;/p&gt;
&lt;p&gt;先看看有什么能入我们的眼帘吧。我们的测试与生产的基础环境是什么？linux、java。&lt;/p&gt;
&lt;p&gt;先看看linux下有哪些文件传输工具：rcp,scp,rsync,ftp,sftp,lftp,wget,curl。&lt;/p&gt;
&lt;p&gt;再来看看我们的文件传输要求：&lt;br/&gt;1）GB级大文件传输；&lt;br/&gt;2）可上传、下载；&lt;br/&gt;3）可断点续传；&lt;br/&gt;4）防网络抖动；&lt;br/&gt;5）最重要的一点，JAVA的API支持。&lt;/p&gt;
&lt;p&gt;我们从以上工具中选几个常用的、有代表性的来看看吧：wget、scp、rsync、ftp、sftp。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;wget&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;wput上传&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;scp&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;rsync&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ftp&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;sftp&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;一般&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6.8963414634146&quot;&gt;
&lt;p&gt;以上这些工具的比较如果没有实际用过的同学可以参考这篇博文&lt;a href=&quot;https://blog.csdn.net/emili/article/details/6858818&quot;&gt;linux下不同服务器间数据传输(rcp,scp,rsync,ftp,sftp,lftp,wget,curl)&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里要说句，上述的wget、scp等工具其实是有办法用java来调用的，java里有个ProcessBuilder类，可以调用外部命令，linux的shell、window的exe都可以。&lt;/p&gt;
&lt;p&gt;一般的用法就是Runtime.getRuntime().exec()或ProcessBuilder(array).start()，感兴趣的可以自己百度,&lt;br/&gt;或参考这两篇博文：&lt;a href=&quot;https://www.cnblogs.com/aboutblank/p/4256461.html&quot;&gt;ProcessBuilder&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/sinat_34620530/article/details/54311876&quot;&gt;Runtime.getRuntime().exec()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，看到这里的小伙伴可能会发现我们的倾向已经很明确了，那就是FTP。&lt;br/&gt;毕竟，这是一个可以跟HTTP相媲美的历史悠久的工具对不对？并且还有很成熟的javaAPI，Apache的common类都已经将其收入囊中。&lt;/p&gt;
&lt;p&gt;说到这里，为什么不用简单的HTTP client来实现文件的传输管理呢？&lt;br/&gt;其实也是可以的，可以模拟rsync，来实现分段管理、分片下载，类似迅雷、电驴这样的P2P下载工具。&lt;/p&gt;
&lt;p&gt;还设想过，用socket来进行文件的传输，例如开通十个线程，每个线程对应一个socket长连接，轮询传输二进制流文件。&lt;/p&gt;
&lt;p&gt;嗯，不过，论稳定性与简单易用，还是用FTP吧，至于http还是等HTTP2.0的普及吧。&lt;/p&gt;
&lt;p&gt;还有个真实的想哭的原因，从项目启动到交付稳定版本，只给了一个月时间。呵呵，呵呵，呵呵……&lt;/p&gt;
&lt;p&gt;稳定、简单、易用，满足需求、API丰富，重要的是快，这些理由还不够吗？妙蛙种子，不，FTP，就决定是你了。&lt;/p&gt;
&lt;p&gt;当然，你以为选了FTP就结束了，后续会单独有一章说FTP的安装、调优及断点续传过程中遇到的坑的。&lt;/p&gt;
&lt;h4 id=&quot;文件流转的监控设计&quot;&gt;2.3.2 文件流转的监控设计&lt;/h4&gt;
&lt;p&gt;在物理隔离的情况下，无法直接用http、TCP访问，怎么通过文件交换实现文件流转的监控呢？&lt;/p&gt;
&lt;p&gt;在这里，我们可以稍微简单重温下http是怎么进行数据交互的：我发个请求，你给个回执。就这么简单对不对？&lt;/p&gt;
&lt;p&gt;http是基于TCP的，tcp是怎么连接的？三次握手的经典过程，我想大家应该是不会忘的。就算忘了，还是知道有握手这么个事情的（笑）。&lt;/p&gt;
&lt;p&gt;好吧，简单回顾下，客户端的请求是第一次握手；在TCP第二次握手的时候，服务端会进行相应，此时产生一个ACK包返回客户端；第三次握手，客户端收到回执，又发出ACK给服务端，确认收包。&lt;/p&gt;
&lt;p&gt;那么，这跟我们的文件流转监控有什么关系呢？聪明的你是不是已经想到了，对，没错，我们也可以在网闸那头收到包的时候返回一个ACK文件，证明我收到包了呀。&lt;/p&gt;
&lt;p&gt;嗯，我们发个快递就行了，不用客气得像http一样来个电话连线。&lt;/p&gt;
&lt;p&gt;给大家当场画个图吧，上菜&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1349401/201906/1349401-20190621011009834-896730218.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一看，感觉很棘手的流转监控是不是瞬间就easy了。&lt;/p&gt;
&lt;p&gt;可是，真的这么简单吗？&lt;br/&gt;在多目标的时候，怎么保证将你的数据包正确发送给目标？&lt;br/&gt;在到达网闸下一个节点，返回ACK的时候，又怎么知道原路返回呢？&lt;/p&gt;
&lt;p&gt;这些问题后续会也会单独列个章节说，暂且叫数据链路生成与文件流转监控。&lt;/p&gt;
&lt;h4 id=&quot;文件加密的选型待补充&quot;&gt;2.3.3 文件加密的选型（待补充）&lt;/h4&gt;
&lt;h4 id=&quot;文件时序的设计机制待补充&quot;&gt;2.3.4 文件时序的设计机制（待补充）&lt;/h4&gt;
&lt;h4 id=&quot;系统的解耦与深入待补充&quot;&gt;2.3.5 系统的解耦与深入（待补充）&lt;/h4&gt;
&lt;h3 id=&quot;架构设计与总结待补充&quot;&gt;2.4 架构设计与总结（待补充）&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的知识星球，星球目前免费哦。&lt;br/&gt;这里会有一些我在工作、生活的一些感悟与总结，当然，还有最新的一些技术分享（都是原创哦）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1349401/201906/1349401-20190605002828374-984038345.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Jun 2019 17:13:00 +0000</pubDate>
<dc:creator>妖生</dc:creator>
<og:description>第二章：项目边界与架构设计（上） author 妖生 date 2019 06 21 slogan：本是江湖客，曾把青锋剑，不料入此坑，书下与或非。 [TOC] 2.1 导读 上一章讲了 '数据交换平</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaoshen/p/11062354.html</dc:identifier>
</item>
<item>
<title>python如何以表格形式打印输出 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/11062308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/11062308.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;好久不见，风水轮流转，我竟然写写写python了 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;近日有个小需求，要求收集统计一些信息上报，并直接在后台控制台打印，写入日志&lt;/p&gt;
&lt;p&gt;为了美观，需要以表格形式展现数据，形如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201906/688270-20190621001323245-318216515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽说可以用 prettytable 实现这个效果，不过还得安装这个库，需求比较简单就不考虑安装第三方依赖了，所以得自己写&lt;/p&gt;

&lt;p&gt;照着这个图，可以发现&lt;strong&gt;几个关键的实现点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 由数据项的各个属性，整理出表头&lt;/p&gt;
&lt;p&gt;2. 计算每个属性对应的最大宽度，作为每列的宽度&lt;/p&gt;
&lt;p&gt;3. 每列左右留一些空&lt;/p&gt;
&lt;p&gt;4. 表头上下，以及数据项末尾添加一行 --+-- 外围&lt;/p&gt;
&lt;p&gt;5. 循环每项，各项左右使用 | 做外围&lt;/p&gt;
&lt;p&gt;6. 需支持居中显示或左对齐，这些可以通过计算列的总长度，再补空格来实现  利用 .center  .ljust 这些快捷方法&lt;/p&gt;

&lt;p&gt;最终效果呢，还是阔以的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/688270/201906/688270-20190621001941592-1798463338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据项&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; timingInfo =&lt;span&gt; [{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://aaa.bbb.net/ccc/article/details/11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;duration(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 121.12&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 222&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size(kb)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22.01
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}, {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/nd-element-in-list-to-another-list-of-strings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;duration(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 121.22&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3332&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size(kb)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22.01
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}, {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/path2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;duration(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;121.12434234 (1212312.12 + 121212)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3332&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size(kb)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22.01
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;}, {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/nd-element-in-list-to-another-list-of-strings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;duration(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 121.42323423423&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3332&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size(kb)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22.01
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}, {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;path2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;duration(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;121.11 (111.11 + 20)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start(ms)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3332&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;size(kb)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 22.01
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}]
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取表头&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; keyHeader =&lt;span&gt; timingInfo[0].keys()
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放每列的最大长度&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; keyMaxLen =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; timingInfo:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i,h &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(keyHeader):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每个属性对应的最大长度&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         maxLen =&lt;span&gt; max(len(h), len(str(item[h])))
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; keyMaxLen.get(h, None):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             maxLen =&lt;span&gt; max(maxLen, keyMaxLen[h])
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         keyMaxLen[h] =&lt;span&gt; maxLen
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; keyMaxLen
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; printGroup(group):
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; group:
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i,h &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(keyHeader):
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             itemLen = keyMaxLen.get(h, str(h)) + 4
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 补空位并居中&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;             s = str(item[h]).center(itemLen, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; item[h] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;             icon = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; item[h] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 icon = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;             s = (icon &lt;span&gt;if&lt;/span&gt; i == 0 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;) + s[1:len(s)] +&lt;span&gt; icon
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt; s,
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n[timing info]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 占位项&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; tag =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i,h &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(keyHeader):
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     tag[h] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 前后添上&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;timingInfo.insert(0, tag)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;timingInfo.append(tag)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一行需要先单独打印出来&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;printGroup([tag])
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再单独打印表头&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i,h &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(keyHeader):
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 留空位4&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt;     itemLen = keyMaxLen.get(h, str(h)) + 4
&lt;span&gt;90&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 快捷居中并补空位  左对齐可使用 ljust之类&lt;/span&gt;
&lt;span&gt;91&lt;/span&gt;     s =&lt;span&gt; h.center(itemLen)
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;     s = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; i == 0 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;) + s[1:len(s)] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;93&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; s,
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; 
&lt;span&gt;95&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印后面的数据项，包括两条 --+--占位&lt;/span&gt;
&lt;span&gt;96&lt;/span&gt; printGroup(timingInfo)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这个是直接打印出来的，print 默认一行打印，要做到按项拼接，就得在print后面加个逗号，&lt;/p&gt;
&lt;p&gt;另外，这样只能在控制台输出，而如果要打印到日志中，就得换种做法了&lt;/p&gt;
&lt;p&gt;使用字符串拼接，整个输出就是一个字符串，从头拼到末尾就ok了&lt;/p&gt;

&lt;p&gt;当然嫌麻烦的话，也可以直接装了prettytable 直接用也行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; prettytable as pt

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; tb = pt.PrettyTable( [&quot;City name&quot;, &quot;Area&quot;, &quot;Population&quot;, &quot;Annual Rainfall&quot;])&lt;/span&gt;
tb =&lt;span&gt; pt.PrettyTable()
tb.field_names &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;City name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Area&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Population&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Annual Rainfall&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
tb.add_row([&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adelaide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,1295, 1158259, 600.5&lt;span&gt;])
tb.add_row([&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Brifasdfae&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,5905, 1857594, 1146.4&lt;span&gt;])
tb.add_row([&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Darwin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 112, 120900, 171423423423423424.7&lt;span&gt;])
tb.add_row([&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hobart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1357, 205556,619.5&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tb)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 20 Jun 2019 16:34:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>好久不见，风水轮流转，我竟然写写写python了 近日有个小需求，要求收集统计一些信息上报，并直接在后台控制台打印，写入日志 为了美观，需要以表格形式展现数据，形如 虽说可以用 prettytable</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imwtr/p/11062308.html</dc:identifier>
</item>
<item>
<title>推荐系统的探索与利用问题综述 - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/RECE2E.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/RECE2E.html</guid>
<description>&lt;h2 id=&quot;问题引入&quot;&gt;问题引入&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;推荐系统冷启动问题常见的一种解决方案就是利用Bandit算法,Bandit算法通常用于解决探索与利用问题,其中解决探索与利用问题的经典案例是MAB问题；&lt;br/&gt;&lt;img src=&quot;https://yqfile.alicdn.com/img_f112fd1bf65f250b6d629c1c06408291.png&quot; alt=&quot;MAB&quot;/&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这里MAB问题有三个概念:臂,收益,遗憾
&lt;ul&gt;&lt;li&gt;1.臂:实际可以选择的对象,这里的臂可以是推荐系统中的策略或者内容分类,一般情况下臂的数量应该小于选择的次数,这样才能保证收敛。&lt;/li&gt;
&lt;li&gt;2.收益:选择了臂后对应的单次收益,在推荐系统中可以理解为点击或者购买某个物品&lt;/li&gt;
&lt;li&gt;3.遗憾:单次收益与最优收益的差&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;目标与建模:&lt;br/&gt;所以我们的目标就是在有限的N次选择中尽量使得累计遗憾最低&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{数学建模:} R_{T} = \sum_{i=1}^{T}(W_{opt}-W_{B(i)})\text{,其中}R_T\text{代表累计遗憾;T是总选择次数;} W_{opt}\text{是最优收益;}W_{B(i)}\text{是第i次选择获得的收益} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{特别地,当每次选择的收益是0或者1时,称为伯努利收益;上式可以化简为如下形式:} R_{T} = T - \sum_{i=1}^{T-N}0\text{,这里的N是取到收益1的次数} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;ucb算法介绍&quot;&gt;UCB算法介绍&lt;/h2&gt;
&lt;h3 id=&quot;计算公式&quot;&gt;计算公式&lt;/h3&gt;
&lt;p&gt;Upper Confidence Bound，即置信区间上界&lt;br/&gt;置信区间可以简单直观地理解为不确定性的程度，区间越宽，越不确定，反之就很确定。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ score(i) = \frac{N_i}{T} + \sqrt{\frac{2\ln_T}{N_i}} \text{,其中}N_i\text{代表第i个臂收益为1的次数;T是总选择次数。注：这里直接给出了结论,推导部分见附录} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;对公式的理解&quot;&gt;对公式的理解：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;公式有两部分，加号前面是这个候选臂到目前的平均收益，反应了它的效果，后面的叫做 Bonus，本质上是均值的标准差，反应了候选臂效果的不确定性，就是置信区间的上边界。&lt;/li&gt;
&lt;li&gt;如果一个臂的选择次数很少，即N很小，那么它的 Bonus 就会较大，在最后排序输出时有优势，这个 Bonus 反映了一个候选的收益置信区间宽度，Bonus 越大，候选的平均收益置信区间越宽，越不确定，越需要更多的选择机会。反之如果平均收益很大，就是说加号左边很大，也会在被选择时有优势。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

# T个用户/T次曝光
T = 1000
# N个电影/N个电影品类
N = 10

# 保证结果可复现
np.random.seed(888)
# 每部电影累积点击率(理论概率)
true_rewards = np.random.uniform(low=0, high=1, size=N)
# 每部电影当前点击率(实际频率)
estimated_rewards = np.zeros(N)
# 每部电影点击次数
chosen_count = np.zeros(N)
total_reward = 0


def calculate_delta(T, item):
    if chosen_count[item] == 0:
        return 1
    else:
        return np.sqrt(2 * np.log(T) / chosen_count[item])


def UCB(t, N):
    # UCB得分
    upper_bound_probs = [estimated_rewards[item] + calculate_delta(t, item) for item in range(N)]
    item = np.argmax(upper_bound_probs)
    # 模拟伯努利收益
    reward = np.random.binomial(n=1, p=true_rewards[item])
    return item, reward


# T个用户/T次曝光依次发生
for t in range(1, T):
    # 为第t个用户推荐一部电影，reward = 1 表示用户点击观看，reward = 0 表示用户未点击
    item, reward = UCB(t, N)
    # print(&quot;item, reward = %s,%s&quot; % (item, reward))
    # 一共有多少用户接受了推荐/N部电影的点击次数
    total_reward += reward

    # 更新电影的当前点击率
    estimated_rewards[item] = ((t - 1) * estimated_rewards[item] + reward) / t
    # print(estimated_rewards[item])
    chosen_count[item] += 1
    # 输出当前点击率
    # print(t,estimated_rewards)
    # 输出累积点击率
    # print(t,true_rewards)
    diff = np.subtract(true_rewards,estimated_rewards)
    print(diff[0])
    
0.8595606060609418
0.35956060606094176
0.19289393939427513
0.10956060606094176
0.2595606060609418
...
0.01640294418596766
0.016245471958934443
0.01709132465111296
0.01693347823970004
0.016775947837118665&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;其他bandit-算法&quot;&gt;其他Bandit 算法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1.汤普森采样算法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;2.Epsilon 贪婪算法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;3.效果对比&lt;br/&gt;完全随机：就是不顾用户反馈的做法。&lt;br/&gt;朴素选择：就是认准一个效果好的，一直推。&lt;br/&gt;Epsilon 贪婪算法：每次以小概率尝试新的，大概率选择效果好的。&lt;br/&gt;UCB：每次都会给予机会较少的候选一些倾向。&lt;br/&gt;汤普森采样：用贝塔分布管理每一个候选的效果。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他的臂&quot;&gt;其他的臂&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1.新用户:冷启动策略&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;2.新策略/新模型&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;方法扩展&quot;&gt;方法扩展&lt;/h2&gt;
&lt;p&gt;1.LinUCB(加入了特征的UCB)&lt;br/&gt;2.COFIBA算法(将Bandit算法与协同过滤结合使用)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cf.meitu.com/confluence/pages/viewpage.action?pageId=52905721&quot;&gt;17【MAB问题】简单却有效的Bandit算法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.iteye.com/news/32386&quot;&gt;Bandit算法与推荐系统&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/songyunli1111/article/details/83384738&quot;&gt;UCB公式的理解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21388070&quot;&gt;专治选择困难症——bandit算法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32356077&quot;&gt;Multi-Armed Bandit: UCB (Upper Bound Confidence)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1400274&quot;&gt;Bandit算法，A/B测试，孰优孰劣？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://cf.meitu.com/confluence/pages/viewpage.action?pageId=52905737&quot;&gt;【MAB问题】结合上下文信息的Bandit算法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Jun 2019 15:46:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>1.简述 2.实践 3.扩展 4.附录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/arachis/p/RECE2E.html</dc:identifier>
</item>
<item>
<title>安全优雅的RESTful API签名实现方案 - hjzgg</title>
<link>http://www.cnblogs.com/hjzgg/p/11062043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hjzgg/p/11062043.html</guid>
<description>&lt;h2 id=&quot;接口签名的必要性&quot;&gt;1、接口签名的必要性&lt;/h2&gt;
&lt;p&gt;在为第三方系统提供接口的时候，肯定要考虑接口数据的安全问题，比如数据是否被篡改，数据是否已经过时，数据是否可以重复提交等问题。其中我认为最终要的还是数据是否被篡改。在此分享一下我的关于接口签名的实践方案。&lt;/p&gt;
&lt;h2 id=&quot;项目中签名方案痛点&quot;&gt;2、项目中签名方案痛点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每个接口有各自的签名方案，不统一，维护成本较高。&lt;/li&gt;
&lt;li&gt;没有对消息实体进行签名，无法避免数据被篡改。&lt;/li&gt;
&lt;li&gt;无法避免数据重复提交。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;签名及验证流程&quot;&gt;3、签名及验证流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201906/640632-20190620215259099-35639341.png&quot; alt=&quot;签名流程说明&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;签名规则&quot;&gt;4、签名规则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;线下分配appid和appsecret，针对不同的调用方分配不同的appid和appsecret。&lt;/li&gt;
&lt;li&gt;加入timestamp（时间戳），10分钟内数据有效。&lt;/li&gt;
&lt;li&gt;加入流水号nonce（防止重复提交），至少为10位。针对查询接口，流水号只用于日志落地，便于后期日志核查。 针对办理类接口需校验流水号在有效期内的唯一性，以避免重复请求。&lt;/li&gt;
&lt;li&gt;加入signature，所有数据的签名信息。&lt;br/&gt;其中appid、timestamp、nonce、signature这四个字段放入请求头中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;签名生成&quot;&gt;5、签名生成&lt;/h2&gt;
&lt;h3 id=&quot;数据部分&quot;&gt;5.1、数据部分&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Path：按照path中的顺序将所有value进行拼接&lt;/li&gt;
&lt;li&gt;Query：按照key字典序排序，将所有key=value进行拼接&lt;/li&gt;
&lt;li&gt;Form：按照key字典序排序，将所有key=value进行拼接&lt;/li&gt;
&lt;li&gt;Body：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;Json: 按照key字典序排序，将所有key=value进行拼接（例如{&quot;a&quot;:&quot;a&quot;,&quot;c&quot;:&quot;c&quot;,&quot;b&quot;:{&quot;e&quot;:&quot;e&quot;}} =&amp;gt; a=a^_^b=e=e^_^c=c）
String: 整个字符串作为一个拼接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果存在多种数据形式，则按照path、query、form、body的顺序进行再拼接，得到所有数据的拼接值。&lt;br/&gt;上述拼接的值记作 Y。&lt;/p&gt;
&lt;h3 id=&quot;请求头部分&quot;&gt;5.2、请求头部分&lt;/h3&gt;
&lt;p&gt;X=&quot;appid=xxxnonce=xxxtimestamp=xxx&quot;&lt;/p&gt;
&lt;h3 id=&quot;生成签名&quot;&gt;5.3、生成签名&lt;/h3&gt;
&lt;p&gt;最终拼接值=XY&lt;br/&gt;最后将最终拼接值按照如下方法进行加密得到签名(signature)。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;signature=org.apache.commons.codec.digest.HmacUtils.hmacSha256Hex(app secret, 拼接的值);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;签名算法实现&quot;&gt;6、签名算法实现&lt;/h2&gt;
&lt;h3 id=&quot;指定哪些接口或者哪些实体需要签名&quot;&gt;6.1、指定哪些接口或者哪些实体需要签名&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({TYPE, METHOD})
@Retention(RUNTIME)
@Documented
public @interface Signature {
    String ORDER_SORT = &quot;ORDER_SORT&quot;;//按照order值排序
    String ALPHA_SORT = &quot;ALPHA_SORT&quot;;//字典序排序
    boolean resubmit() default true;//允许重复请求
    String sort() default Signature.ALPHA_SORT;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;指定哪些字段需要签名&quot;&gt;6.2、指定哪些字段需要签名&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({FIELD})
@Retention(RUNTIME)
@Documented
public @interface SignatureField {
    //签名顺序
    int order() default 0;
    //字段name自定义值
    String customName() default &quot;&quot;;
    //字段value自定义值
    String customValue() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;签名核心算法signatureutils&quot;&gt;6.3、签名核心算法（SignatureUtils）&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static String toSplice(Object object) {
    if (Objects.isNull(object)) {
        return StringUtils.EMPTY;
    }
    if (isAnnotated(object.getClass(), Signature.class)) {
        Signature sg = findAnnotation(object.getClass(), Signature.class);
        switch (sg.sort()) {
            case Signature.ALPHA_SORT:
                return alphaSignature(object);
            case Signature.ORDER_SORT:
                return orderSignature(object);
            default:
                return alphaSignature(object);
        }
    }
    return toString(object);
}

private static String alphaSignature(Object object) {
    StringBuilder result = new StringBuilder();
    Map&amp;lt;String, String&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
    for (Field field : getAllFields(object.getClass())) {
        if (field.isAnnotationPresent(SignatureField.class)) {
            field.setAccessible(true);
            try {
                if (isAnnotated(field.getType(), Signature.class)) {
                    if (!Objects.isNull(field.get(object))) {
                        map.put(field.getName(), toSplice(field.get(object)));
                    }
                } else {
                    SignatureField sgf = field.getAnnotation(SignatureField.class);
                    if (StringUtils.isNotEmpty(sgf.customValue()) || !Objects.isNull(field.get(object))) {
                        map.put(StringUtils.isNotBlank(sgf.customName()) ? sgf.customName() : field.getName()
                                , StringUtils.isNotEmpty(sgf.customValue()) ? sgf.customValue() : toString(field.get(object)));
                    }
                }
            } catch (Exception e) {
                LOGGER.error(&quot;签名拼接(alphaSignature)异常&quot;, e);
            }
        }
    }

    for (Iterator&amp;lt;Map.Entry&amp;lt;String, String&amp;gt;&amp;gt; iterator = map.entrySet().iterator(); iterator.hasNext(); ) {
        Map.Entry&amp;lt;String, String&amp;gt; entry = iterator.next();
        result.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue());
        if (iterator.hasNext()) {
            result.append(DELIMETER);
        }
    }
    return result.toString();
}

private static String toString(Object object) {
    Class&amp;lt;?&amp;gt; type = object.getClass();
    if (BeanUtils.isSimpleProperty(type)) {
        return object.toString();
    }
    if (type.isArray()) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; Array.getLength(object); ++i) {
            sb.append(toSplice(Array.get(object, i)));
        }
        return sb.toString();
    }
    if (ClassUtils.isAssignable(Collection.class, type)) {
        StringBuilder sb = new StringBuilder();
        for (Iterator&amp;lt;?&amp;gt; iterator = ((Collection&amp;lt;?&amp;gt;) object).iterator(); iterator.hasNext(); ) {
            sb.append(toSplice(iterator.next()));
            if (iterator.hasNext()) {
                sb.append(DELIMETER);
            }
        }
        return sb.toString();
    }
    if (ClassUtils.isAssignable(Map.class, type)) {
        StringBuilder sb = new StringBuilder();
        for (Iterator&amp;lt;? extends Map.Entry&amp;lt;String, ?&amp;gt;&amp;gt; iterator = ((Map&amp;lt;String, ?&amp;gt;) object).entrySet().iterator(); iterator.hasNext(); ) {
            Map.Entry&amp;lt;String, ?&amp;gt; entry = iterator.next();
            if (Objects.isNull(entry.getValue())) {
                continue;
            }
            sb.append(entry.getKey()).append(&quot;=&quot;).append(toSplice(entry.getValue()));
            if (iterator.hasNext()) {
                sb.append(DELIMETER);
            }
        }
        return sb.toString();
    }
    return NOT_FOUND;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;toSplice方法首先判断对象是否注有@Signature注解，如果有则获取签名的排序规则（key值字典序排序或者指定order的值进行排序），比如排序规则是Signature.ALPHA_SORT（字典序）会调用alphaSignature方法生成key=value的拼接串；如果对象没有@Signature注解，该对象类型可能是数组、者集合类等，则调用toString方法生成key=value的拼接串。&lt;/li&gt;
&lt;li&gt;alphaSignature方法通过反射获取到对象的所有Field属性，需要判断两种情况：（1）获取该Field属性对应的Class信息，如果Class信息含有@Signature注解，则调用toSplice方法生成key=value的拼接串；（2）该Field属性含有@SignatureField注解，调用toString方法生成key=value的拼接串。&lt;/li&gt;
&lt;li&gt;toString方法针对array, collection, simple property, map类型的数据做处理。其中如果对象是java的simple property类型，直接调用对象的toString方法返回value；如果是array、collection、map类型的数据，再调用toSplice方法生成key=value的拼接串。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;签名校验&quot;&gt;7、签名校验&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180929185732250-575762973.png&quot; alt=&quot;header中需要传递参数&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;wmhopenapi.validate&quot;, exceptionIfInvalid = false)
@Signature
public class SignatureHeaders {
    public static final String SIGNATURE_HEADERS_PREFIX = &quot;wmhopenapi-validate&quot;;
    public static final Set&amp;lt;String&amp;gt; HEADER_NAME_SET = Sets.newHashSet();
    private static final String HEADER_APPID = SIGNATURE_HEADERS_PREFIX + &quot;-appid&quot;;
    private static final String HEADER_TIMESTAMP = SIGNATURE_HEADERS_PREFIX + &quot;-timestamp&quot;;
    private static final String HEADER_NONCE = SIGNATURE_HEADERS_PREFIX + &quot;-nonce&quot;;
    private static final String HEADER_SIGNATURE = SIGNATURE_HEADERS_PREFIX + &quot;-signature&quot;;
    static {
        HEADER_NAME_SET.add(HEADER_APPID);
        HEADER_NAME_SET.add(HEADER_TIMESTAMP);
        HEADER_NAME_SET.add(HEADER_NONCE);
        HEADER_NAME_SET.add(HEADER_SIGNATURE);
    }
    /**
     * 线下分配的值
     * 客户端和服务端各自保存appId对应的appSecret
     */
    @NotBlank(message = &quot;Header中缺少&quot; + HEADER_APPID)
    @SignatureField
    private String appid;
    /**
     * 线下分配的值
     * 客户端和服务端各自保存，与appId对应
     */
    @SignatureField
    private String appsecret;
    /**
     * 时间戳，单位: ms
     */
    @NotBlank(message = &quot;Header中缺少&quot; + HEADER_TIMESTAMP)
    @SignatureField
    private String timestamp;
    /**
     * 流水号【防止重复提交】; (备注：针对查询接口，流水号只用于日志落地，便于后期日志核查； 针对办理类接口需校验流水号在有效期内的唯一性，以避免重复请求)
     */
    @NotBlank(message = &quot;Header中缺少&quot; + HEADER_NONCE)
    @SignatureField
    private String nonce;
    /**
     * 签名
     */
    @NotBlank(message = &quot;Header中缺少&quot; + HEADER_SIGNATURE)
    private String signature;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private SignatureHeaders generateSignatureHeaders(Signature signature, HttpServletRequest request) throws Exception {
    //处理header name
    Map&amp;lt;String, Object&amp;gt; headerMap = Collections.list(request.getHeaderNames())
            .stream()
            .filter(headerName -&amp;gt; SignatureHeaders.HEADER_NAME_SET.contains(headerName))
            .collect(Collectors.toMap(headerName -&amp;gt; headerName.replaceAll(&quot;-&quot;, &quot;.&quot;), headerName -&amp;gt; request.getHeader(headerName)));
    //将header信息：name=value转换成PropertySource
    PropertySource propertySource = new MapPropertySource(&quot;signatureHeaders&quot;, headerMap);
    //将header信息绑定到SignatureHeaders对象
    SignatureHeaders signatureHeaders = RelaxedConfigurationBinder.with(SignatureHeaders.class)
            .setPropertySources(propertySource)
            .doBind();
    Optional&amp;lt;String&amp;gt; result = ValidatorUtils.validateResultProcess(signatureHeaders);
    if (result.isPresent()) {
        throw new ServiceException(&quot;WMH5000&quot;, result.get());
    }
    //从配置中拿到appid对应的appsecret
    String appSecret = limitConstants.getSignatureLimit().get(signatureHeaders.getAppid());
    if (StringUtils.isBlank(appSecret)) {
        LOGGER.error(&quot;未找到appId对应的appSecret, appId=&quot; + signatureHeaders.getAppid());
        throw new ServiceException(&quot;WMH5002&quot;);
    }

    //其他合法性校验
    Long now = System.currentTimeMillis();
    Long requestTimestamp = Long.parseLong(signatureHeaders.getTimestamp());
    if ((now - requestTimestamp) &amp;gt; EXPIRE_TIME) {
        String errMsg = &quot;请求时间超过规定范围时间10分钟, signature=&quot; + signatureHeaders.getSignature();
        LOGGER.error(errMsg);
        throw new ServiceException(&quot;WMH5000&quot;, errMsg);
    }
    String nonce = signatureHeaders.getNonce();
    if (nonce.length() &amp;lt; 10) {
        String errMsg = &quot;随机串nonce长度最少为10位, nonce=&quot; + nonce;
        LOGGER.error(errMsg);
        throw new ServiceException(&quot;WMH5000&quot;, errMsg);
    }
    if (!signature.resubmit()) {
        String existNonce = redisCacheService.getString(nonce);
        if (StringUtils.isBlank(existNonce)) {
            redisCacheService.setex(nonce, nonce, (int) TimeUnit.MILLISECONDS.toSeconds(RESUBMIT_DURATION));
        } else {
            String errMsg = &quot;不允许重复请求, nonce=&quot; + nonce;
            LOGGER.error(errMsg);
            throw new ServiceException(&quot;WMH5000&quot;, errMsg);
        }
    }
　　 //设置appsecret
    signatureHeaders.setAppsecret(appSecret);
    return signatureHeaders;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成签名前需要如下几个校验步骤。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理header name，通过工具类将header信息绑定到签名实体SignatureHeaders对象上。&lt;/li&gt;
&lt;li&gt;验证appid是否合法。&lt;/li&gt;
&lt;li&gt;根据appid从配置中心中拿到appsecret。&lt;/li&gt;
&lt;li&gt;请求是否已经超时，默认10分钟。&lt;/li&gt;
&lt;li&gt;随机串是否合法。&lt;/li&gt;
&lt;li&gt;是否允许重复请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String headersToSplice = SignatureUtils.toSplice(signatureHeaders);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;切面拦截控制层方法生成method中参数的拼接&quot;&gt;7.5、切面拦截控制层方法，生成method中参数的拼接&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private List&amp;lt;String&amp;gt; generateAllSplice(Method method, Object[] args, String headersToSplice) {
    List&amp;lt;String&amp;gt; pathVariables = Lists.newArrayList(), requestParams = Lists.newArrayList();
    String beanParams = StringUtils.EMPTY;
    for (int i = 0; i &amp;lt; method.getParameterCount(); ++i) {
        MethodParameter mp = new MethodParameter(method, i);
        boolean findSignature = false;
        for (Annotation anno : mp.getParameterAnnotations()) {
            if (anno instanceof PathVariable) {
                if (!Objects.isNull(args[i])) {
                    pathVariables.add(args[i].toString());
                }
                findSignature = true;
            } else if (anno instanceof RequestParam) {
                RequestParam rp = (RequestParam) anno;
                String name = mp.getParameterName();
                if (StringUtils.isNotBlank(rp.name())) {
                    name = rp.name();
                }
                if (!Objects.isNull(args[i])) {
                    List&amp;lt;String&amp;gt; values = Lists.newArrayList();
                    if (args[i].getClass().isArray()) {
                        //数组
                        for (int j = 0; j &amp;lt; Array.getLength(args[i]); ++j) {
                            values.add(Array.get(args[i], j).toString());
                        }
                    } else if (ClassUtils.isAssignable(Collection.class, args[i].getClass())) {
                        //集合
                        for (Object o : (Collection&amp;lt;?&amp;gt;) args[i]) {
                            values.add(o.toString());
                        }
                    } else {
                        //单个值
                        values.add(args[i].toString());
                    }
                    values.sort(Comparator.naturalOrder());
                    requestParams.add(name + &quot;=&quot; + StringUtils.join(values));
                }
                findSignature = true;
            } else if (anno instanceof RequestBody || anno instanceof ModelAttribute) {
                beanParams = SignatureUtils.toSplice(args[i]);
                findSignature = true;
            }

            if (findSignature) {
                break;
            }
        }
        if (!findSignature) {
            LOGGER.info(String.format(&quot;签名未识别的注解, method=%s, parameter=%s, annotations=%s&quot;, method.getName(), mp.getParameterName(), StringUtils.join(mp.getMethodAnnotations())));
        }
    }
    List&amp;lt;String&amp;gt; toSplices = Lists.newArrayList();
    toSplices.add(headersToSplice);
    toSplices.addAll(pathVariables);
    requestParams.sort(Comparator.naturalOrder());
    toSplices.addAll(requestParams);
    toSplices.add(beanParams);
    return toSplices;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;generateAllSplice方法是在控制层切面内执行，可以在方法执行之前获取到已经绑定好的入参。分别对注有@PathVariable、@RequestParam、@RequestBody、@ModelAttribute注解的参数进行参数拼接的处理。其中注@RequestParam注解的参数需要特殊处理一下，分别考虑数组、集合、原始类型这三种情况。&lt;/p&gt;
&lt;h3 id=&quot;对最终的拼接结果重新生成签名信息&quot;&gt;7.6、对最终的拼接结果重新生成签名信息&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SignatureUtils.signature(allSplice.toArray(new String[]{}), signatureHeaders.getAppsecret());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端使用示例&quot;&gt;8、客户端使用示例&lt;/h2&gt;
&lt;h3 id=&quot;生成签名-1&quot;&gt;8.1、生成签名&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//初始化请求头信息
SignatureHeaders signatureHeaders = new SignatureHeaders();
signatureHeaders.setAppid(&quot;111&quot;);
signatureHeaders.setAppsecret(&quot;222&quot;);
signatureHeaders.setNonce(SignatureUtils.generateNonce());
signatureHeaders.setTimestamp(String.valueOf(System.currentTimeMillis()));
List&amp;lt;String&amp;gt; pathParams = new ArrayList&amp;lt;&amp;gt;();
//初始化path中的数据
pathParams.add(SignatureUtils.encode(&quot;18237172801&quot;, signatureHeaders.getAppsecret()));
//调用签名工具生成签名
signatureHeaders.setSignature(SignatureUtils.signature(signatureHeaders, pathParams, null, null));
System.out.println(&quot;签名数据: &quot; + signatureHeaders);
System.out.println(&quot;请求数据: &quot; + pathParams);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输出结果&quot;&gt;8.2、输出结果&lt;/h3&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;拼接结果: appid=111^_^appsecret=222^_^nonce=c9e778ba668c8f6fedf35634eb493af6304d54392d990262d9e7c1960b475b67^_^timestamp=1538207443910^_^w8rAwcXDxcDKwsM=^_^
签名数据: SignatureHeaders{appid=111, appsecret=222, timestamp=1538207443910, nonce=c9e778ba668c8f6fedf35634eb493af6304d54392d990262d9e7c1960b475b67, signature=0a7d0b5e802eb5e52ac0cfcd6311b0faba6e2503a9a8d1e2364b38617877574d}
请求数据: [w8rAwcXDxcDKwsM=]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;思考&quot;&gt;9、思考&lt;/h2&gt;
&lt;p&gt;上述的签名方案的实现校验逻辑是在控制层的切面内完成的。如果项目用的是springmvc框架，可以放在Filter或者拦截器里吗？很明显是不行的（因为ServletRequest的输入流InputStream 在默认情况只能读取一次）。上述方案需要获取绑定后的参数结果，然后执行签名校验逻辑。在执行控制层方法之前，springmvc已经帮我们完成了绑定的步骤，当然了，在绑定的过程中会解析ServletRequest中参数信息（例如path参数、parameter参数、body参数）。&lt;/p&gt;
&lt;p&gt;其实如果我们能在Filter或者拦截器中实现上述方案，那么复杂度将会大大的降低。首先考虑如何让ServletRequest的输入流InputStream可以多次读取，然后通过ServletRequest获取path variable（对应@PathVariable）、parameters（对应@RequestParam）、body（对应@RequestBody）参数，最后整体按照规则进行拼接并生成签名。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;优化方案参考：https://www.cnblogs.com/hujunzheng/p/10178584.html&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 20 Jun 2019 15:14:00 +0000</pubDate>
<dc:creator>hjzgg</dc:creator>
<og:description>安全优雅的RESTful API签名实现方案 1、接口签名的必要性 在为第三方系统提供接口的时候，肯定要考虑接口数据的安全问题，比如数据是否被篡改，数据是否已经过时，数据是否可以重复提交等问题。其中我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hjzgg/p/11062043.html</dc:identifier>
</item>
<item>
<title>在日志中记录Java异常信息的正确姿势 - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/11061929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/11061929.html</guid>
<description>&lt;h2 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;今天遇到一个线上的BUG，在执行表单提交时失败，但是从程序日志中看不到任何异常信息。&lt;br/&gt;在Review源代码时发现，当catch到异常时只是输出了&lt;code&gt;e.getMessage()&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;logger.error(&quot;error: {}, {}&quot;, params, e.getMessage());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在日志中看不到任何信息，说明&lt;code&gt;e.getMessage()&lt;/code&gt;返回值为空字符串。&lt;/p&gt;
&lt;h2 id=&quot;原因分析&quot;&gt;原因分析&lt;/h2&gt;
&lt;p&gt;先来看一下Java中的异常类图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190620224921877-1807978345.png&quot; alt=&quot;Java异常类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Throwable是Java中所有异常信息的顶级父类，其中的成员变量&lt;code&gt;detailMessage&lt;/code&gt;就是在调用&lt;code&gt;e.getMessage()&lt;/code&gt;返回的值。&lt;br/&gt;那么这个属性会在什么时候赋值呢，追溯源码发现，该属性只会在Throwable构造函数中赋值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Throwable() {
    // 在默认构造函数中不会给detailMessage属性赋值
    fillInStackTrace();
}

public Throwable(String message) {
    fillInStackTrace();
    // 直接将参数赋值给detailMessage
    detailMessage = message;
}

public Throwable(String message, Throwable cause) {
    fillInStackTrace();
    // 直接将参数赋值给detailMessage
    detailMessage = message;
    this.cause = cause;
}

public Throwable(Throwable cause) {
    fillInStackTrace();
    // 当传入的Throwable对象不为空时，为detailMessage赋值
    detailMessage = (cause==null ? null : cause.toString());
    this.cause = cause;
}

protected Throwable(String message, Throwable cause,
                        boolean enableSuppression,
                        boolean writableStackTrace) {
    if (writableStackTrace) {
        fillInStackTrace();
    } else {
        stackTrace = null;
    }
    // 直接将参数赋值给detailMessage
    detailMessage = message;
    this.cause = cause;
    if (!enableSuppression)
        suppressedExceptions = null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，从源码中可以看到在Throwable的默认构造函数中是不会给&lt;code&gt;detailMessage&lt;/code&gt;属性赋值的。&lt;br/&gt;也就是说，当异常对象是通过默认构造函数实例化的，或者实例化时传入的message为空字符串，那么调用&lt;code&gt;getMessage()&lt;/code&gt;方法时返回值就为空，也就是我遇到的情形。&lt;br/&gt;所以，在程序日志中不要单纯使用&lt;code&gt;getMessage()&lt;/code&gt;方法获取异常信息（返回值为空时，不利于问题排查）。&lt;/p&gt;
&lt;h2 id=&quot;正确的做法&quot;&gt;正确的做法&lt;/h2&gt;
&lt;p&gt;在Java开发中，常用的日志框架及组件通常是：slf4j，log4j和logback，他们的关系可以描述为：slf4j提供了统一的日志API，将具体的日志实现交给log4j与logback。&lt;br/&gt;也就是说，通常我们只需要在项目中使用slf4j作为日志API，再集成log4j或者logback即可。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190620225033819-2009959594.png&quot; alt=&quot;Java日志组件集成&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 使用slf4j作为日志API --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- 集成logback作为具体的日志实现 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述配置以集成slf4j和logback为例，添加对应的logback配置文件（logback.xml）：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration scan=&quot;false&quot; scanPeriod=&quot;30 seconds&quot; debug=&quot;false&quot; packagingData=&quot;true&quot;&amp;gt;
    &amp;lt;statusListener class=&quot;ch.qos.logback.core.status.OnConsoleStatusListener&quot;/&amp;gt;
    &amp;lt;!-- 输出到控制台 --&amp;gt;
    &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    　　
    &amp;lt;!-- 输出到文件 --&amp;gt;
    &amp;lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&amp;gt;
        &amp;lt;file&amp;gt;test.log&amp;lt;/file&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%date %level [%thread] %logger{10} [%file:%line] %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;root level=&quot;info&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Java中通过slf4j提供的日志API记录日志：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Test {
    private static final Logger logger = LoggerFactory.getLogger(Test.class);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们需要在程序日志中输出异常信息时，应该直接传入异常对象即可，而不要单纯通过异常对象的&lt;code&gt;getMessage()&lt;/code&gt;方法获取输出异常信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void test() {
    try {
        // 使用默认构造函数实实例化异常对象
        throw new NullPointerException();
    } catch (Exception e) {
        // 直接将异常对象传入日志接口，保存异常信息到日志文件中
        logger.error(&quot;error: {}&quot;, e.getMessage(), e);
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下是保存到日志文件中的异常信息片段：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;2019-06-20 20:04:25,290 ERROR [http-nio-8090-exec-1] o.c.s.f.c.TestExceptionController [TestExceptionController.java:26] error: null # 使用默认构造参数实例化异常对象时，getMessage()方法返回值为空对象
# 如下是具体的异常堆栈信息
java.lang.NullPointerException: null
    at org.chench.springboot.falsework.controller.TestExceptionController.test(TestExceptionController.java:24) ~[classes/:na]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_181]
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_181]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_181]
    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_181]
    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) [spring-web-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) [spring-web-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:877) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:783) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:866) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.31.jar:8.5.31]
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) [spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.31.jar:8.5.31]

......
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Jun 2019 14:51:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>遇到的问题 今天遇到一个线上的BUG，在执行表单提交时失败，但是从程序日志中看不到任何异常信息。 在Review源代码时发现，当catch到异常时只是输出了 ，如下所示： 在日志中看不到任何信息，说明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nuccch/p/11061929.html</dc:identifier>
</item>
<item>
<title>EM算法和高斯混合模型GMM介绍 - sunwq06</title>
<link>http://www.cnblogs.com/sunwq06/p/11052072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunwq06/p/11052072.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;EM算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;EM算法主要用于求概率密度函数参数的最大似然估计，将问题$\arg \max _{\theta_{1}} \sum_{i=1}^{n} \ln p\left(x_{i} | \theta_{1}\right)$转换为更加易于计算的$\sum_{i=1}^{n} \ln p\left(x_{i}, \theta_{2} | \theta_{1}\right)$，其中$\theta_2$可以取任意的先验分布$q(\theta_2)$。EM算法的推导过程如下：$$\begin{aligned} \ln p\left(x | \theta_{1}\right) &amp;amp;=\int q\left(\theta_{2}\right) \ln p\left(x | \theta_{1}\right) d \theta_{2}=\int q\left(\theta_{2}\right) \ln \frac{p\left(x, \theta_{2} | \theta_{1}\right)}{p\left(\theta_{2} | x, \theta_{1}\right)} d \theta_{2}=\int q\left(\theta_{2}\right) \ln \frac{p\left(x, \theta_{2} | \theta_{1}\right) q\left(\theta_{2}\right)}{p\left(\theta_{2} | x, \theta_{1}\right) q\left(\theta_{2}\right)} d \theta_{2}   \\ &amp;amp;=\underbrace{\int q\left(\theta_{2}\right) \ln \frac{p\left(x, \theta_{2} | \theta_{1}\right)}{q\left(\theta_{2}\right)} d \theta_{2}}_{\text { define this to }\mathcal{L}\left(x,\theta_1\right)}+\underbrace{\int q\left(\theta_{2}\right) \ln \frac{q\left(\theta_{2}\right)}{p\left(\theta_{2} | x, \theta_{1}\right)} d \theta_{2}}_{\text { Kullback-Leibler divergence }} \end{aligned}$$利用凸函数的性质，$\text{KL divergence}=E\left[-\ln \frac{p\left(\theta_{2} | x, \theta_{1}\right)}{q\left(\theta_{2}\right)}\right]\geq{-\ln{E\left[\frac{p\left(\theta_{2} | x, \theta_{1}\right)}{q\left(\theta_{2}\right)}\right]}}=-\ln{1}=0$，当且仅当$q\left(\theta_{2}\right)=p\left(\theta_{2} | x, \theta_{1}\right)$时$\text{KL divergence}$取值为0。&lt;/p&gt;
&lt;p&gt;基于以上推导，EM算法的计算流程如下：&lt;/p&gt;
&lt;p&gt;       给定初始值$\theta_1^{(0)}$，按以下步骤迭代至收敛（以第t+1步为例）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;E-step: 令$q_{t}\left(\theta_{2}\right)=p\left(\theta_{2} | x, \theta_{1}^{(t)}\right)$，则$\mathcal{L}_{t}\left(x, \theta_{1}\right)=\int q_{t}\left(\theta_{2}\right) \ln p\left(x, \theta_{2} | \theta_{1}\right) d \theta_{2}-\underbrace{\int q_{t}\left(\theta_{2}\right) \ln q_{t}\left(\theta_{2}\right) d \theta_{2}}_{\text { can ignore this term }}$&lt;/li&gt;
&lt;li&gt;M-step: 令$\theta_{1}^{(t+1)}=\arg \max _{\theta_{1}} \mathcal{L}_{t}\left(x, \theta_{1}\right)$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;算法解释：&lt;/p&gt;
&lt;p&gt;$$&lt;br/&gt;\begin{aligned} \ln p\left(x | \theta_{1}^{(t)}\right) &amp;amp;=\mathcal{L}_{t}\left(x, \theta_{1}^{(t)}\right)+\underbrace{K L\left(q_t\left(\theta_{2}\right) \| p\left(\theta_{2} | x_{1}, \theta_{1}^{(t)}\right)\right)}_{=0 \text { by setting } q=p}\quad \leftarrow \text { E-step } \\ &amp;amp; \leq \mathcal{L}_{t}\left(x, \theta_{1}^{(t+1)}\right) \quad \leftarrow \text { M-step } \\ &amp;amp; \leq \mathcal{L}_{t}\left(x, \theta_{1}^{(t+1)}\right)+\underbrace{K L\left(q_{t}\left(\theta_{2}\right) \| p\left(\theta_{2} | x_{1}, \theta_{1}^{(t+1)}\right)\right)}_{&amp;gt;0 \text { because } q \neq p} \\ &amp;amp;=\ln p\left(x | \theta_{1}^{(t+1)}\right)\end{aligned}&lt;br/&gt;$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183927/201906/1183927-20190620163225410-84550026.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;高斯混合模型GMM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高斯混合模型是一个用于聚类的概率模型，对于数据$\vec{x}_1,\vec{x}_2,\cdots,\vec{x}_n$中的任一数据$\vec{x}_i$，$c_i$表示$\vec{x}_i$被分配到了第$c_i$个簇中，并且$c_i\in\{1,2,\cdots,K\}$。模型定义如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Prior cluster assignment: $c_{i} \stackrel{\text { iid }}{\sim}$ Discrete $(\vec{\pi}) \Rightarrow \operatorname{Prob}\left(c_{i}=k | \vec{\pi}\right)=\pi_{k}$&lt;/li&gt;
&lt;li&gt;Generate observation: $\vec{x}_i \sim N\left(\vec{\mu}_{c_{i}}, \Sigma_{c_{i}}\right)$&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;模型需要求解的就是先验概率$\vec{\pi}=(\pi_1,\pi_2,\cdots,\pi_K)$，各簇高斯分布的均值$\{\vec{\mu}_1,\vec{\mu}_2,\cdots,\vec{\mu}_K\}$以及协方差矩阵$\{\Sigma_1,\Sigma_2,\cdots,\Sigma_K\}$这些量。为了求解这些量，使用最大似然估计，定义需最大化的目标函数为&lt;/p&gt;
&lt;p&gt;$$\sum_{i=1}^{n} \ln p\left(\vec{x}_{i} | \vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}\right)\text{, where }\boldsymbol{\mu}=\{\vec{\mu}_1,\vec{\mu}_2,\cdots,\vec{\mu}_K\}\text{ and }\boldsymbol{\Sigma}=\{\Sigma_1,\Sigma_2,\cdots,\Sigma_K\}$$&lt;/p&gt;
&lt;p&gt;利用EM算法求解上式的最大值，将上式写为$$\sum_{i=1}^{n} \ln p\left(\vec{x}_{i} | \vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}\right)=\sum_{i=1}^{n} \underbrace{\sum_{k=1}^{K} q\left(c_{i}=k\right) \ln \frac{p\left(\vec{x}_{i}, c_{i}=k | \vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}\right)}{q\left(c_{i}=k\right)}}_{\mathcal{L}}+\sum_{i=1}^n\underbrace{\sum_{k=1}^{K} q\left(c_{i}=k\right) \ln \frac{q\left(c_{i}=k\right)}{p\left(c_{i}=k | \vec{x}_{i}, \vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}\right)}}_{\text{KL divergence}}$$&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;E-step: 根据贝叶斯法则，令$q_t\left(c_{i}=k\right)=p\left(c_{i}=k | \vec{x}_{i}, \vec{\pi}^{(t)}, \mu^{(t)}, \Sigma^{(t)}\right)\propto p\left(c_{i}=k | \vec{\pi}^{(t)}\right) p\left(\vec{x}_{i} | c_{i}=k, \boldsymbol{\mu}^{(t)}, \boldsymbol{\Sigma}^{(t)}\right)$，容易看出$$q_t\left(c_{i}=k\right)=\frac{\pi_{k}^{(t)} N\left(\vec{x}_{i} | \vec{\mu}_{k}^{(t)}, \Sigma_{k}^{(t)}\right)}{\sum_{j} \pi_{j}^{(t)} N\left(\vec{x}_{i} | \vec{\mu}_{j}^{(t)}, \Sigma_{j}^{(t)}\right)}$$&lt;/li&gt;
&lt;li&gt;M-step: $$\arg\max_{\vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}}\sum_{i=1}^{n} \sum_{k=1}^{K}  q_t\left(c_{i}=k\right)\ln p\left(\vec{x}_{i}, c_{i}=k | \vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}\right)=\arg\max_{\vec{\pi}, \boldsymbol{\mu}, \boldsymbol{\Sigma}}\sum_{i=1}^{n} \sum_{k=1}^{K}  q_t\left(c_{i}=k\right)\left[\ln \pi_k+\ln N\left(\vec{x}_{i} | \vec{\mu}_{k}, \Sigma_{k}\right)\right]$$可以得出$\pi_{k}^{(t+1)}=\frac{\sum_{i=1}^{n}q_t\left(c_i=k\right)}{\sum_{j=1}^{K}\sum_{i=1}^{n}q_t\left(c_i=j\right)}, \quad\vec{\mu}_{k}^{(t+1)}=\frac{\sum_{i=1}^{n} q_t\left(c_i=k\right) \vec{x}_{i}}{\sum_{i=1}^{n}q_t\left(c_i=k\right)}, \quad  \Sigma_{k}^{(t+1)}=\frac{ \sum_{i=1}^{n} q_t\left(c_i=k\right)\left(\vec{x_{i}}-\vec{\mu}_{k}^{(t+1)}\right)\left(\vec{x}_{i}-\vec{\mu}_{k}^{(t+1)}\right)^{T}}{\sum_{i=1}^{n}q_t\left(c_i=k\right)}$&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 20 Jun 2019 14:41:00 +0000</pubDate>
<dc:creator>sunwq06</dc:creator>
<og:description>介绍EM算法的原理，并且介绍了如何使用EM算法对GMM这一概率聚类模型进行求解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunwq06/p/11052072.html</dc:identifier>
</item>
<item>
<title>Cocos-BCX开发入门之cli_wallet - 青锋之殇</title>
<link>http://www.cnblogs.com/hinousagi/p/11061869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hinousagi/p/11061869.html</guid>
<description>&lt;p&gt;区块链技术作为近几年来最具争议的技术，吸引了全世界的关注，尽管人们对它的评价却褒贬不一，有的人认为它就是一场骗局，亦或是一场投机者的狂欢，不过我却认为它真的能够对我们的生活带来一些改变，尤其是最近一年，区块链正在褪去只能炒币的形象，更多的结合到了我们的实际生活中给我们带来了便利，尤其是银行和票据的应用。&lt;br/&gt;而游戏作为自带金融属性的一种应用形式，本身就和区块链有着很多互相呼应的地方，随着近些年的公链技术的发展，越来越多的区块链游戏开始进入到我们的视野，Cocos-BCX是由Cocos2d引擎官方团队针对目前游戏的局限性，并结合区块链的去中心化属性而开发出的专门针对游戏而生的公链，它有着诸如确认速度、游戏世界观、道具穿越等特色，结合Cocos自家的Cocos Creater开发工具，可以很便捷的开发区块链游戏，十分适合区块链游戏的开发。&lt;/p&gt;

&lt;p&gt;官方文档已经对Cocos-BCX的开发做出了详尽的说明，本文只是对没有接触过区块链开发的小伙伴们的一个入门Cocos-BCX的指南，希望可以帮助到大家。&lt;/p&gt;
&lt;h2 id=&quot;准备工作-1&quot;&gt;1.准备工作&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git clone https://github.com/Cocos-BCX/cocos-bcx-node-bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将节点源码下载下来后，解压打开，进入&lt;em&gt;cocos-bcx-node-bin/cli/testnet/0.7.16&lt;/em&gt;目录&lt;br/&gt;解压cli_wallet.tar.gz,得到cli_wallet文件，将cli_wallet赋予可执行权限&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd cocos-bcx-node-bin/cli/testnet/0.7.16
chmod 755 cli_wallet&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;连接区块链网络&quot;&gt;连接区块链网络&lt;/h2&gt;
&lt;p&gt;然后去&lt;a href=&quot;http://cocos-terminal.com&quot;&gt;CocosTerminal&lt;/a&gt;注册一个账户，登录之后，点击右上角的小齿轮找到节点地址&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055749/201906/1055749-20190620221944387-1301389596.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055749/201906/1055749-20190620222040234-265529957.png&quot;/&gt;&lt;br/&gt;如图所示，即是节点地址，稍后我们会用到它，回到终端，输入命令（注意要将其中的ws://127.0.0.1:8070换成刚刚得到的节点地址，链ID可以也要替换，不过要先执行一次命令，他会返回正确的链ID，在替换一下执行一遍命令就可以了，并且退出cli_wallet想要再次连接节点时，链ID需要在第一次连接节点后生成的一个wallet.json文件里面找，所以建议第一次连接节点时就将正确的连接命令记录下来，便于以后连接。）&lt;br/&gt;命令格式&lt;br/&gt;./cli_wallet --chain-id [链 ID] -s [见证人节点 RPC 地址] -r [命令行钱包的 RPC 服务所监听的地址]&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./cli_wallet --chain-id 81003974d328ff17b64076928ab87b24d7dffbc87df3d4cde89d2fa1877e4f6a -s ws://127.0.0.1:8070 -r 127.0.0.1:8099&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以连接到Cocos-BCX的网络了&lt;/p&gt;
&lt;h2 id=&quot;与区块链网络进行交互&quot;&gt;与区块链网络进行交互&lt;/h2&gt;
&lt;p&gt;第一次登陆钱包需要设置钱包密码&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;set_password *****&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置钱包密码后，需要解锁钱包，之后再次登陆也需要解锁钱包&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;unlock *****&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时命令行编程unlock开头，代表解锁成功。&lt;br/&gt;之后的命令可以参考&lt;a href=&quot;https://cn-dev.cocosbcx.io/docs/22-cli_wallet&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Jun 2019 14:38:00 +0000</pubDate>
<dc:creator>青锋之殇</dc:creator>
<og:description>Cocos BCX简介 区块链技术作为近几年来最具争议的技术，吸引了全世界的关注，尽管人们对它的评价却褒贬不一，有的人认为它就是一场骗局，亦或是一场投机者的狂欢，不过我却认为它真的能够对我们的生活带来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hinousagi/p/11061869.html</dc:identifier>
</item>
</channel>
</rss>