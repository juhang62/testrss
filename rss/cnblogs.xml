<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET中并行开发优化 - lingfeng95</title>
<link>http://www.cnblogs.com/zhao123/p/11064107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhao123/p/11064107.html</guid>
<description>&lt;p&gt;让我们考虑一个简单的编程挑战：对大数组中的所有元素求和。现在可以通过使用并行性来轻松优化这一点，特别是对于具有数千或数百万个元素的巨大阵列，还有理由认为，并行处理时间应该与常规时间除以CPU核心数一样多。事实证明，这一壮举并不容易实现。我将向您展示几种并行执行此操作的方法，它们如何改善或降低性能以及以某种方式影响性能的所有细节。&lt;/p&gt;
&lt;h2&gt;简单的循环方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ITEMS = &lt;span&gt;500000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayC()
{
    arr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[ITEMS];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rnd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ITEMS; i++&lt;span&gt;)
    {
        arr[i] &lt;/span&gt;= rnd.Next(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ForLocalArr()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ITEMS; i++&lt;span&gt;)
    {
        total &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(arr[i].ToString());
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ForeachLocalArr()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arr)
    {
        total &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(item.ToString());
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要迭代循环就可以计算出结果，超级简单，这里没有用直接相加求出结果，原因是直接求出结果，发现每次基本的运行都比并行快，但是实际上，并行处理没有那么简单，所以这里的加法就简单的处理下total += int.Parse(arr[i].ToString())。现在，让我们尝试用并行性来打败数组迭代吧。&lt;/p&gt;
&lt;h2&gt;首次尝试&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _lock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ThreadPoolWithLock()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threads = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; partSize = ITEMS /&lt;span&gt; threads;
    Task[] tasks &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task[threads];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; iThread = &lt;span&gt;0&lt;/span&gt;; iThread &amp;lt; threads; iThread++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; localThread =&lt;span&gt; iThread;
        tasks[localThread] &lt;/span&gt;= Task.Run(() =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = localThread * partSize; j &amp;lt; (localThread + &lt;span&gt;1&lt;/span&gt;) * partSize; j++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lock)
                {
                    total &lt;/span&gt;+=&lt;span&gt; arr[j];
                }
            }
        });
    }

    Task.WaitAll(tasks);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，您必须使用localThread变量来“保存”该iThread时间点的值。否则，它将是一个随着for循环前进而变化的捕获变量。当数据最后打的时候并行已经比普通的快了，但是发现快的不多，说明还可以优化&lt;/p&gt;
&lt;h2&gt;再次优化&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ThreadPoolWithLock2()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threads = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; partSize = ITEMS /&lt;span&gt; threads;
    Task[] tasks &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task[threads];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; iThread = &lt;span&gt;0&lt;/span&gt;; iThread &amp;lt; threads; iThread++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; localThread =&lt;span&gt; iThread;
        tasks[localThread] &lt;/span&gt;= Task.Run(() =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = localThread * partSize; j &amp;lt; (localThread + &lt;span&gt;1&lt;/span&gt;) * partSize; j++&lt;span&gt;)
            {
                temp &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(arr[j].ToString());
            }

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lock)
            {
                total &lt;/span&gt;+=&lt;span&gt; temp;
            }
        });
    }

    Task.WaitAll(tasks);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;增加设置临时变量，减少lock次数，发现运行效果已经有质的提高，提高了几倍。忽然想起，有个Parallel.For的方法，研究性能是否可以更快。&lt;/p&gt;
&lt;h2&gt;Parallel.For优化&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ParallelForWithLock()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parts = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; partSize = ITEMS /&lt;span&gt; parts;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parallel = Parallel.For(&lt;span&gt;0&lt;/span&gt;, parts, &lt;span&gt;new&lt;/span&gt; ParallelOptions(), (iter) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = iter * partSize; j &amp;lt; (iter + &lt;span&gt;1&lt;/span&gt;) * partSize; j++&lt;span&gt;)
        {
            temp &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(arr[j].ToString());
        }

        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lock)
        {
            total &lt;/span&gt;+=&lt;span&gt; temp;
        }
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果比普通迭代快，但是没有ThreadPool快，但是觉得Parallel.For还可以继续优化，也许可以更快&lt;/p&gt;
&lt;h2&gt;Parallel.For继续优化&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ParallelForWithLock2()
{
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parts = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; partSize = ITEMS /&lt;span&gt; parts;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parallel = Parallel.For(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, parts,
        localInit: () &lt;/span&gt;=&amp;gt; &lt;span&gt;0L&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initializes the &quot;localTotal&quot;&lt;/span&gt;
        body: (iter, state, localTotal) =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = iter * partSize; j &amp;lt; (iter + &lt;span&gt;1&lt;/span&gt;) * partSize; j++&lt;span&gt;)
            {
                localTotal &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(arr[j].ToString());
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; localTotal;
        },
        localFinally: (localTotal) &lt;/span&gt;=&amp;gt; { total +=&lt;span&gt; localTotal; });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果已经很快，和ThreadPool优化过的差不多，有些时候更快&lt;/p&gt;
&lt;h2&gt;结论和总结&lt;/h2&gt;
&lt;p&gt;并行化优化肯定可以提高性能，但是这取决于很多因素，每个案例都应该进行测量和检查。&lt;br/&gt;当各种线程需要通过某种锁定机制相互依赖时，性能会显着降低。&lt;/p&gt;
&lt;h2&gt;50万数据运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/546912/201906/546912-20190621134409572-366854151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Jun 2019 00:15:00 +0000</pubDate>
<dc:creator>lingfeng95</dc:creator>
<og:description>让我们考虑一个简单的编程挑战：对大数组中的所有元素求和。现在可以通过使用并行性来轻松优化这一点，特别是对于具有数千或数百万个元素的巨大阵列，还有理由认为，并行处理时间应该与常规时间除以CPU核心数一样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhao123/p/11064107.html</dc:identifier>
</item>
<item>
<title>几行代码养只猫，心情瞬间好多了 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/11067627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/11067627.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;或枯燥或有趣的技术学习，都不妨碍一只憨态可掬的萌猫卧在你的网页上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;浏览博客的时候经常会看到一个二次元的小姐姐或轻轻摇头或眨巴眼睛似在与你互动甚是可爱，就像下边这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20190619.live2d.1.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;曾想了解是如何实现的，奈何本身不懂前端，且对二次元并不感冒，就放下了，直到遇到了这只猫，再也无法抵挡诱惑，决心将她抱进自己的博客，每天能看到她，就会有个好心情，我想也许会有读者跟我一样吧，能有这么一只萌宠呆在这里足以平添很多的乐趣了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20190619.live2d.2.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上这种效果都是使用Live2D技术实现的，Live2D是一种应用于电子游戏的绘图渲染技术，由日本Cybernoids公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，换句话说就是2D的素材实现一定程度的3D效果&lt;/p&gt;
&lt;p&gt;Live2D可以展示在很多平台上，例如浏览器，Android，IOS，Unity等，GitHub上有很多已经实现的Live2D项目，我所养的这只猫也来自于&lt;a href=&quot;https://github.com/QiShaoXuan/live2DModel&quot;&gt;&lt;code&gt;live2DModel&lt;/code&gt;&lt;/a&gt;这个仓库，这个仓库下还收集了其他一些Live2D模型&lt;/p&gt;
&lt;p&gt;在自己的网站上养猫非常的简单，只需要以下两步即可，其实&lt;a href=&quot;https://github.com/QiShaoXuan/live2DModel&quot;&gt;&lt;code&gt;live2DModel&lt;/code&gt;&lt;/a&gt;仓库里边有demo的，但是对于完全不懂前端的人来说看起来还是有点费劲，我这里仅仅是给整理成更容易理解和使用的版本，向原作者致敬：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载代码仓库到自己的项目下，仓库地址如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;https://github.com/ops-coffee/demo/tree/master/live2d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中index.hmtl为示例代码，将整个项目放在nginx下可以直接查看效果&lt;/p&gt;
&lt;p&gt;live2d文件夹存放了猫的模型以及需要用到的两个js文件&lt;/p&gt;
&lt;p&gt;你只需要把index.html同层的live2d文件夹拷贝到你的项目下，然后按照下边步骤添加js就可以将猫养在你的站点了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加如下JS代码到需要显示猫的页面上&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;/live2d/L2Dwidget.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  L2Dwidget.init({
    model: {
      jsonPath: '/live2d/tororo/assets/tororo.model.json',
    },
    display: {
      superSample: 2,
      width: 150,
      height: 150,
      position: 'right',
      hOffset: 0,
      vOffset: 0,
    },
    mobile: {
      show: true,
      scale: 1,
      motion: true,
    },
    react: {
      opacityDefault: 0.8,
      opacityOnHover: 0.2,
    }
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;model：&lt;/strong&gt; 指定&lt;code&gt;model.json&lt;/code&gt;位置，如果你不喜欢猫也可以在&lt;a href=&quot;https://github.com/QiShaoXuan/live2DModel&quot;&gt;&lt;code&gt;live2DModel&lt;/code&gt;&lt;/a&gt;这个仓库下查找自己喜欢的模型，然后将模型目录拷贝到live2d文件夹下，然后修改model路径参数以及display显示参数即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;display：&lt;/strong&gt; 控制live2d模型在页面上显示的位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mobile：&lt;/strong&gt; 控制手机上是否显示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;react：&lt;/strong&gt; 控制显示的透明度&lt;/p&gt;
&lt;p&gt;至此完成，再访问网页就会发现一只猫静静的卧在那里，看风云变幻，自云淡风轻~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.png&quot; alt=&quot;扫码关注公众号查看更多实用文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章推荐阅读：&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 23:22:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>或枯燥或有趣的技术学习，都不妨碍一只憨态可掬的萌猫卧在你的网页上 浏览博客的时候经常会看到一个二次元的小姐姐或轻轻摇头或眨巴眼睛似在与你互动甚是可爱，就像下边这样 曾想了解是如何实现的，奈何本身不懂前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/11067627.html</dc:identifier>
</item>
<item>
<title>c++性能测试工具：google benchmark入门（二） - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/11067594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/11067594.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/10348925.html&quot;&gt;上一篇&lt;/a&gt;中我们初步体验了google benchmark的使用，在本文中我们将更进一步深入了解google benchmark的常用方法。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;向测试用例传递参数&quot;&gt;向测试用例传递参数&lt;/h2&gt;
&lt;p&gt;之前我们的测试用例都只接受一个&lt;code&gt;benchmark::State&amp;amp;&lt;/code&gt;类型的参数，如果我们需要给测试用例传递额外的参数呢？&lt;/p&gt;
&lt;p&gt;举个例子，假如我们需要实现一个队列，现在有ring buffer和linked list两种实现可选，现在我们要测试两种方案在不同情况下的性能表现：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 必要的数据结构
#include &quot;ring.h&quot;
#include &quot;linked_ring.h&quot;

// ring buffer的测试
static void bench_array_ring_insert_int_10(benchmark::State&amp;amp; state)
{
    auto ring = ArrayRing&amp;lt;int&amp;gt;(10);
    for (auto _: state) {
        for (int i = 1; i &amp;lt;= 10; ++i) {
            ring.insert(i);
        }
        state.PauseTiming(); // 暂停计时
        ring.clear();
        state.ResumeTiming(); // 恢复计时
    }
}
BENCHMARK(bench_array_ring_insert_int_10);

// linked list的测试
static void bench_linked_queue_insert_int_10(benchmark::State &amp;amp;state)
{
    auto ring = LinkedRing&amp;lt;int&amp;gt;{};
    for (auto _:state) {
        for (int i = 0; i &amp;lt; 10; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_linked_queue_insert_int_10);

// 还有针对删除的测试，以及针对string的测试，都是高度重复的代码，这里不再罗列&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，上面的测试除了被测试类型和插入的数据量之外没有任何区别，如果可以通过传入参数进行控制的话就可以少写大量重复的代码。&lt;/p&gt;
&lt;p&gt;编写重复的代码是浪费时间，而且往往意味着你在做一件蠢事，google的工程师们当然早就注意到了这一点。虽然测试用例只能接受一个&lt;code&gt;benchmark::State&amp;amp;&lt;/code&gt;类型的参数，但我们可以将参数传递给state对象，然后在测试用例中获取：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static void bench_array_ring_insert_int(benchmark::State&amp;amp; state)
{
    auto length = state.range(0);
    auto ring = ArrayRing&amp;lt;int&amp;gt;(length);
    for (auto _: state) {
        for (int i = 1; i &amp;lt;= length; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Arg(10);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子展示了如何传递和获取参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传递参数使用&lt;code&gt;BENCHMARK&lt;/code&gt;宏生成的对象的&lt;code&gt;Arg&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;传递进来的参数会被放入state对象内部存储，通过&lt;code&gt;range&lt;/code&gt;方法获取，调用时的参数0是传入参数的需要，对应第一个参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;Arg&lt;/code&gt;方法一次只能传递一个参数，那如果一次想要传递多个参数呢？也很简单：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static void bench_array_ring_insert_int(benchmark::State&amp;amp; state)
{
    auto ring = ArrayRing&amp;lt;int&amp;gt;(state.range(0));
    for (auto _: state) {
        for (int i = 1; i &amp;lt;= state.range(1); ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Args({10, 10});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子没什么实际意义，只是为了展示如何传递多个参数，&lt;code&gt;Args&lt;/code&gt;方法接受一个vector对象，所以我们可以使用c++11提供的大括号初始化器简化代码，获取参数依然通过&lt;code&gt;state.range&lt;/code&gt;方法，1对应传递进来的第二个参数。&lt;/p&gt;
&lt;p&gt;有一点值得注意，参数传递只能接受整数，如果你希望使用其他类型的附加参数，就需要另外想些办法了。&lt;/p&gt;
&lt;h2 id=&quot;简化多个类似测试用例的生成&quot;&gt;简化多个类似测试用例的生成&lt;/h2&gt;
&lt;p&gt;向测试用例传递参数的最终目的是为了在不编写重复代码的情况下生成多个测试用例，在知道了如何传递参数后你可能会这么写：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static void bench_array_ring_insert_int(benchmark::State&amp;amp; state)
{
    auto length = state.range(0);
    auto ring = ArrayRing&amp;lt;int&amp;gt;(length);
    for (auto _: state) {
        for (int i = 1; i &amp;lt;= length; ++i) {
            ring.insert(i);
        }
        state.PauseTiming();
        ring.clear();
        state.ResumeTiming();
    }
}
// 下面我们生成测试插入10，100，1000次的测试用例
BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Arg(10);
BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Arg(100);
BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Arg(1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们生成了三个实例，会产生下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201906/1434464-20190622023217004-602810259.jpg&quot; alt=&quot;pass args&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来工作良好，是吗？&lt;/p&gt;
&lt;p&gt;没错，结果是正确的，但是记得我们前面说过的吗——&lt;em&gt;不要编写重复的代码&lt;/em&gt;！是的，上面我们手动编写了用例的生成，出现了可以避免的重复。&lt;/p&gt;
&lt;p&gt;幸好&lt;code&gt;Arg&lt;/code&gt;和&lt;code&gt;Args&lt;/code&gt;会将我们的测试用例使用的参数进行注册以便产生&lt;code&gt;用例名/参数&lt;/code&gt;的新测试用例，并且返回一个指向&lt;code&gt;BENCHMARK&lt;/code&gt;宏生成对象的指针，换句话说，如果我们想要生成仅仅是参数不同的多个测试的话，只需要链式调用&lt;code&gt;Arg&lt;/code&gt;和&lt;code&gt;Args&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Arg(10)-&amp;gt;Arg(100)-&amp;gt;Arg(1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果和上面一样。&lt;/p&gt;
&lt;p&gt;但这还不是最优解，我们仍然重复调用了Arg方法，如果我们需要更多用例时就不得不又要做重复劳动了。&lt;/p&gt;
&lt;p&gt;对此google benchmark也有解决办法：我们可以使用&lt;code&gt;Range&lt;/code&gt;方法来自动生成一定范围内的参数。&lt;/p&gt;
&lt;p&gt;先看看Range的原型：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMAEK(func)-&amp;gt;Range(int64_t start, int64_t limit);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;start表示参数范围起始的值，limit表示范围结束的值，Range所作用于的是一个_闭区间_。&lt;/p&gt;
&lt;p&gt;但是如果我们这样改写代码，是会得到一个错误的测试结果：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(bench_array_ring_insert_int)-&amp;gt;Range(10, 1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201906/1434464-20190622023150158-2094667392.jpg&quot; alt=&quot;error&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么会这样呢？那是因为Range默认除了start和limit，中间的其余参数都会是某一个基底（base）的幂，基地默认为8，所以我们会看到64和512，它们分别是8的平方和立方。&lt;/p&gt;
&lt;p&gt;想要改变这一行为也很简单，只要重新设置基底即可，通过使用&lt;code&gt;RangeMultiplier&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(bench_array_ring_insert_int)-&amp;gt;RangeMultiplier(10)-&amp;gt;Range(10, 1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在结果恢复如初了。&lt;/p&gt;
&lt;p&gt;使用Ranges可以处理多个参数的情况：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(func)-&amp;gt;RangeMultiplier(10)-&amp;gt;Ranges({{10, 1000}, {128， 256}});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个范围指定了测试用例的第一个传入参数的范围，而第二个范围指定了第二个传入参数可能的值（注意这里不是范围了）。&lt;/p&gt;
&lt;p&gt;与下面的代码等价：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(func)-&amp;gt;Args({10, 128})
               -&amp;gt;Args({100, 128})
               -&amp;gt;Args({1000, 128})
               -&amp;gt;Args({10, 256})
               -&amp;gt;Args({100, 256})
               -&amp;gt;Args({1000, 256})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上就是用生成的第一个参数的范围于后面指定内容的参数做了一个笛卡尔积。&lt;/p&gt;
&lt;h2 id=&quot;使用参数生成器&quot;&gt;使用参数生成器&lt;/h2&gt;
&lt;p&gt;如果我想定制没有规律的更复杂的参数呢？这时就需要实现自定义的参数生成器了。&lt;/p&gt;
&lt;p&gt;一个参数生成器的签名如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CustomArguments(benchmark::internal::Benchmark* b);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在生成器中计算处参数，然后调用&lt;code&gt;benchmark::internal::Benchmark&lt;/code&gt;对象的Arg或Args方法像上两节那样传入参数即可。&lt;/p&gt;
&lt;p&gt;随后我们使用&lt;code&gt;Apply&lt;/code&gt;方法把生成器应用到测试用例上：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;BENCHMARK(func)-&amp;gt;Apply(CustomArguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这一过程的原理并不复杂，我做个简单的解释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;BENCHMARK&lt;/code&gt;宏产生的就是一个&lt;code&gt;benchmark::internal::Benchmark&lt;/code&gt;对象然后返回了它的指针&lt;/li&gt;
&lt;li&gt;向&lt;code&gt;benchmark::internal::Benchmark&lt;/code&gt;对象传递参数需要使用Arg和Args等方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apply&lt;/code&gt;方法会将参数中的函数应用在自身&lt;/li&gt;
&lt;li&gt;我们在生成器里使用&lt;code&gt;benchmark::internal::Benchmark&lt;/code&gt;对象的指针b的Args等方法传递参数，这时的b其实指向我们的测试用例&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到此为止生成器是如何工作的已经一目了然了，当然从上面得出的结论，我们还可以让Apply做更多的事情。&lt;/p&gt;
&lt;p&gt;下面看下Apply的具体使用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 这次我们生成100，200，...，1000的测试用例，用range是无法生成这些参数的
static void custom_args(benchmark::internal::Benchmark* b)
{
    for (int i = 100; i &amp;lt;= 1000; i += 100) {
        b-&amp;gt;Arg(i);
    }
}

BENCHMARK(bench_array_ring_insert_int)-&amp;gt;RangeMultiplier(10)-&amp;gt;Apply(custom_args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义参数的测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201906/1434464-20190622023108640-364056091.jpg&quot; alt=&quot;custom_args&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此向测试用例传递参数的方法就全部介绍完了。&lt;/p&gt;
&lt;p&gt;下一篇中我会介绍如何将测试用例写成模板，传递参数只能解决一部分重复代码，对于拥有类似方法的不同待测试类型的测试用例，使用模板将会大大减少我们不必要的工作。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 18:34:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>'上一篇' 中我们初步体验了google benchmark的使用，在本文中我们将更进一步深入了解google benchmark的常用方法。 本文索引 向测试用例传递参数 简化多个类似测试用例的生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/apocelipes/p/11067594.html</dc:identifier>
</item>
<item>
<title>[译]Vulkan教程(03)开发环境 - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/Vulkan-Tutorial-03-Developmenet-Environment.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/Vulkan-Tutorial-03-Developmenet-Environment.html</guid>
<description>&lt;p&gt;&lt;span&gt;[译]Vulkan教程(03)开发环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是我翻译（&lt;a href=&quot;https://vulkan-tutorial.com/&quot;&gt;https://vulkan-tutorial.com&lt;/a&gt;）上的Vulkan教程的第3篇。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;In this chapter we'll set up your environment for developing Vulkan applications and install some useful libraries. All of the tools we'll use, with the exception of the compiler, are compatible with Windows, Linux and MacOS, but the steps for installing them differ a bit, which is why they're described separately here.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本章我们将配置Vulkan开发环境，安装一些有用的库。我们使用的所有工具（编译器除外）都是在Windows、Linux和MacOS上兼容的，但是安装它们的步骤有点不同，所以我们分别描述之。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;If you're developing for Windows, then I will assume that you are using Visual Studio 2017 to compile your code. You may also use Visual Studio 2013 or 2015, but the steps may be a bit different.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你在Windows上开发，那么我假设你在使用Visual studio 2017编译代码。你也可以用Visual Studio 2013或2015，只是步骤可能稍微有点不同。&lt;/p&gt;
&lt;h2&gt;Vulkan SDK&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开发Vulkan应用程序所需的最重要的组件是SDK。它包含头文件，标准验证层，调试工具和Vulkan函数的加载器。加载器在在运行时查询driver中的函数，这与OpenGL的GLEW类似——如果你熟悉它的话。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The SDK can be downloaded from &lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;&lt;span&gt;the LunarG website&lt;/span&gt;&lt;/a&gt; using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SDK可以从&lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;LunarG 网站&lt;/a&gt;下载，按钮就在页面下边。你不用创建账户，但有了账户你可以得到一些对你有用的额外文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234302665-556969439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Proceed through the installation and pay attention to the install location of the SDK. The first thing we'll do is verify that your graphics card and driver properly support Vulkan. Go to the directory where you installed the SDK, open the &lt;code&gt;Bin&lt;/code&gt; directory and run the &lt;code&gt;cube.exe&lt;/code&gt; demo. You should see the following:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装SDK，注意一下安装的位置。首先我们要验证你的图形卡和driver是否支持Vulkan。进入你安装SDK的文件夹，打开Bin 文件夹，运行cube.exe 示例。你应该会看到如下内容：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234822714-1918252617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the &lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;&lt;span&gt;introduction chapter&lt;/span&gt;&lt;/a&gt; for links to drivers from the major vendors.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你看到错误信息，那么确保你的driver已经更新到最新版本，有Vulkan运行时，且你的图形卡被Vulkan支持。在&lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;introduction chapter&lt;/a&gt;入门章节有链接，可以查看主要厂商的driver。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;There is another program in this directory that will be useful for development. The &lt;code&gt;glslangValidator.exe&lt;/code&gt;program will be used to compile shaders from the human-readable &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenGL_Shading_Language&quot;&gt;&lt;span&gt;GLSL&lt;/span&gt;&lt;/a&gt; to bytecode. We'll cover this in depth in the &lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules&quot;&gt;&lt;span&gt;shader modules&lt;/span&gt;&lt;/a&gt; chapter. The &lt;code&gt;Bin&lt;/code&gt; directory also contains the binaries of the Vulkan loader and the validation layers, while the &lt;code&gt;Lib&lt;/code&gt; directory contains the libraries.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个目录里还有一个有用的程序。程序&lt;code&gt;glslangValidator.exe&lt;/code&gt;会被用于编译shader，将人类可读的&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenGL_Shading_Language&quot;&gt;GLSL&lt;/a&gt; 转换为字节码。我们将在&lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules&quot;&gt;shader modules&lt;/a&gt; 章节细说。文件夹Bin 还有Vulkan加载器和验证层的二进制文件，而文件夹Lib 包含一些库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The &lt;code&gt;Doc&lt;/code&gt; directory contains useful information about the Vulkan SDK and an offline version of the entire Vulkan specification. Lastly, there's the &lt;code&gt;Include&lt;/code&gt; directory that contains the Vulkan headers. Feel free to explore the other files, but we won't need them for this tutorial.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;文件夹Doc 包含Vulkan SDK的有用信息，还有一个离线版本的Vulkan说明书。文件夹Include 包含Vulkan头文件。你可以自由探索这些文件，但是本教程中就不谈它们了。&lt;/p&gt;
&lt;h2&gt;GLFW&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creating a window to display the rendered results. To benefit from the cross-platform advantages of Vulkan and to avoid the horrors of Win32, we'll use the &lt;a href=&quot;http://www.glfw.org/&quot;&gt;&lt;span&gt;GLFW library&lt;/span&gt;&lt;/a&gt; to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like &lt;a href=&quot;https://www.libsdl.org/&quot;&gt;&lt;span&gt;SDL&lt;/span&gt;&lt;/a&gt;, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如前所述，Vulkan是个平台不可知论的API，它没有创建窗口的工具。为了享受Vulkan的好处，也为了避免Win32的恐怖，我们将使用&lt;a href=&quot;http://www.glfw.org/&quot;&gt;GLFW library&lt;/a&gt;来创建窗口，它支持Windows、Linux和MacOS。还有其他的库也能做到这一点，例如&lt;a href=&quot;https://www.libsdl.org/&quot;&gt;SDL&lt;/a&gt;，但是GLFW的优势是，它也抽象了Vulkan中一些除创建窗口外的其它跨平台的东西。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;You can find the latest release of GLFW on the &lt;a href=&quot;http://www.glfw.org/download.html&quot;&gt;&lt;span&gt;official website&lt;/span&gt;&lt;/a&gt;. In this tutorial we'll be using the 64-bit binaries, but you can of course also choose to build in 32 bit mode. In that case make sure to link with the Vulkan SDK binaries in the &lt;code&gt;Lib32&lt;/code&gt; directory instead of &lt;code&gt;Lib&lt;/code&gt;. After downloading it, extract the archive to a convenient location. I've chosen to create a &lt;code&gt;Libraries&lt;/code&gt; directory in the Visual Studio directory under documents. Don't worry about there not being a &lt;code&gt;libvc-2017&lt;/code&gt; folder, the &lt;code&gt;libvc-2015&lt;/code&gt; one is compatible.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你可以在官网&lt;a href=&quot;http://www.glfw.org/download.html&quot;&gt;official website&lt;/a&gt;上找到最新的GLFW。本教程中我们将使用64位二进制文件，但是你当然可以选择构建一个32位的。如果那样，确保链接到Vulkan SDK的文件夹Lib32 ，而不是Lib。下载之后，将其解压缩到一个合适的位置。我选择了在Visual Studio文件夹下创建一个Libraries 文件夹。如果没有文件夹libvc-2017 ，别担心，文件夹libvc-2015 也是与之兼容的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234355903-1768256606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;GLM&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Unlike DirectX 12, Vulkan does not include a library for linear algebra operations, so we'll have to download one. &lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;&lt;span&gt;GLM&lt;/span&gt;&lt;/a&gt; is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不像DirectX 12，Vulkan没有用于线性代数操作的库，所以我们不得不下载一个。&lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;GLM&lt;/a&gt; 是一个为图形API设计的库，广泛用于OpenGL中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GLM is a header-only library, so just download the &lt;a href=&quot;https://github.com/g-truc/glm/releases&quot;&gt;&lt;span&gt;latest version&lt;/span&gt;&lt;/a&gt; and store it in a convenient location. You should have a directory structure similar to the following now:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;GLM是个只有头文件的库，所以下载最新版保存到合适的位置上。你应该会看到类似这样的目录结构：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234404499-1461662726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Setting up Visual Studio 配置VS&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Now that you've installed all of the dependencies we can set up a basic Visual Studio project for Vulkan and write a little bit of code to make sure that everything works.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然你已经安装了所有的依赖库，我们可以为Vulkan配置Visual Studio项目了。我们还将写一点点代码来确保一切能正常工作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Start Visual Studio and create a new &lt;code&gt;Windows Desktop Wizard&lt;/code&gt; project by entering a name and pressing &lt;code&gt;OK&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;启动Visual Studio，创建新Windows Desktop Wizard 项目，输入项目名，点击OK。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234412180-815712697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Make sure that &lt;code&gt;Console Application (.exe)&lt;/code&gt; is selected as application type so that we have a place to print debug messages to, and check &lt;code&gt;Empty Project&lt;/code&gt; to prevent Visual Studio from adding boilerplate code.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;确保选中Console Application (.exe)为应用程序类型，这样我们就有一个地方可以打印调试信息，勾选Empty Project 以避免Visual Studio添加样板代码。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234427433-64995961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234439815-372864092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Press &lt;code&gt;OK&lt;/code&gt; to create the project and add a C++ source file. You should already know how to do that, but the steps are included here for completeness.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击OK ，创建项目和一个C++源代码文件。你应该已经知道如何做了，但这里为了完整起见，都陈列出来了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234434932-13670741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Now add the following code to the file. Don't worry about trying to understand it right now; we're just making sure that you can compile and run Vulkan applications. We'll start from scratch in the next chapter.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在在文件中添加下述代码。别担心，现在不理解代码也没关系，我们只是为了确保你能编译和运行Vulkan应用程序。下一章我们将从零开始（写代码）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLFW_INCLUDE_VULKAN
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;GLFW/glfw3.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_RADIANS
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_DEPTH_ZERO_TO_ONE
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;glm/vec4.hpp&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;glm/mat4x4.hpp&amp;gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    glfwInit();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GLFWwindow* window = glfwCreateWindow(&lt;span&gt;800&lt;/span&gt;, &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vulkan window&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nullptr, nullptr);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     uint32_t extensionCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vkEnumerateInstanceExtensionProperties(nullptr, &amp;amp;&lt;span&gt;extensionCount, nullptr);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     std::cout &amp;lt;&amp;lt; extensionCount &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; extensions supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    glm::mat4 matrix;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    glm::vec4 vec;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     auto test = matrix *&lt;span&gt; vec;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;glfwWindowShouldClose(window)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        glfwPollEvents();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    glfwDestroyWindow(window);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    glfwTerminate();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Let's now configure the project to get rid of the errors. Open the project properties dialog and ensure that &lt;code&gt;All Configurations&lt;/code&gt; is selected, because most of the settings apply to both &lt;code&gt;Debug&lt;/code&gt; and &lt;code&gt;Release&lt;/code&gt; mode.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在我们来配置项目，以搞定这些错误。打开项目属性对话框，确保选中All Configurations ，因为大部分配置都同时应用到Debug 和Release 模式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234452940-2044951543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234459425-365345724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Go to &lt;code&gt;C++ -&amp;gt; General -&amp;gt; Additional Include Directories&lt;/code&gt; and press &lt;code&gt;&amp;lt;Edit...&amp;gt;&lt;/code&gt; in the dropdown box.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择C++ -&amp;gt; General -&amp;gt; Additional Include Directories ，点击下拉框的&amp;lt;Edit...&amp;gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234505169-218138874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Add the header directories for Vulkan, GLFW and GLM:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;添加头文件夹（Vulkan、GLFW和GLM）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234515081-1307117133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Next, open the editor for library directories under &lt;code&gt;Linker -&amp;gt; General&lt;/code&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下一步，打开Linker -&amp;gt; General下的库文件夹编辑器：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234522570-1279406835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;And add the locations of the object files for Vulkan and GLFW:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;添加Vulkan和GLFW的对象文件的位置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234528993-1183084892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Go to &lt;code&gt;Linker -&amp;gt; Input&lt;/code&gt; and press &lt;code&gt;&amp;lt;Edit...&amp;gt;&lt;/code&gt; in the &lt;code&gt;Additional Dependencies&lt;/code&gt; dropdown box.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择Linker -&amp;gt; Input ，点击Additional Dependencies 下拉框的&amp;lt;Edit...&amp;gt;：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234534834-1620225374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Enter the names of the Vulkan and GLFW object files:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入Vulkan和GLFW对象文件的名字：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234546673-2044640633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;And finally change the compiler to support C++17 features:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后修改编译器以支持C++17特性：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234551547-1303767185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;You can now close the project properties dialog. If you did everything right then you should no longer see any more errors being highlighted in the code.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在你可以关闭项目属性对话框。如果你一切都做对了，那么你应该不会再看到代码中有高亮的错误。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Finally, ensure that you are actually compiling in 64 bit mode:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后，确保你在64位模式下编译：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234556746-1995727725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Press &lt;code&gt;F5&lt;/code&gt; to compile and run the project and you should see a command prompt and a window pop up like this:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击F5 来编译和运行项目，你应该会看到一个命令行和一个窗口弹出来：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234601934-873898030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The number of extensions should be non-zero. Congratulations, you're all set for &lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Base_code&quot;&gt;&lt;span&gt;playing with Vulkan&lt;/span&gt;&lt;/a&gt;!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;扩展数量应该为非零数字。恭喜，你已经准备好玩Vulkan了！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;These instructions will be aimed at Ubuntu users, but you may be able to follow along by compiling the LunarG SDK yourself and changing the &lt;code&gt;apt&lt;/code&gt; commands to the package manager commands that are appropriate for you. You should already have a version of GCC installed that supports modern C++ (4.8 or later). You also need both CMake and make.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下述教程是给Ubuntu用户的，但是你可以自己编译LunarG SDK，从apt命令跳转到适合你的包管理器命令，这样也可以使用下面的教程。你应该已经有一版支持C++（4.8或更高）的GCC安装好了。你还需要CMake和make。&lt;/p&gt;
&lt;h2&gt;Vulkan SDK&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开发Vulkan应用程序所需的最重要的组件是SDK。它包含头文件，标准验证层，调试工具和Vulkan函数的加载器。加载器在在运行时查询driver中的函数，这与OpenGL的GLEW类似——如果你熟悉它的话。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The SDK can be downloaded from &lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;&lt;span&gt;the LunarG website&lt;/span&gt;&lt;/a&gt; using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SDK可以从&lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;LunarG 网站&lt;/a&gt;下载，按钮就在页面下边。你不用创建账户，但有了账户你可以得到一些对你有用的额外文档。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234611985-964543087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Open a terminal in the directory where you've downloaded the &lt;code&gt;.tar.gz&lt;/code&gt; archive and extract it:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开终端，跳到你下载.tar.gz 压缩包的文件夹下，解压缩它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xzf vulkansdk-linux-x86_64-xxx.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;It will extract all of the files in the SDK to a subdirectory with the SDK version as name in the working directory. Move the directory to a convenient place and take note of its path. Open a terminal in the root directory of the SDK, which will contain files like &lt;code&gt;build_examples.sh&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;它会将SDK的所有文件解压到子文件夹下，以SDK版本为文件夹名。将这个文件夹移动到方便的地方，注意它的路径。打开终端，在SDK的根文件夹下，会包含文件build_examples.sh。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The samples in the SDK and one of the libraries that you will later use for your program depend on the XCB library. This is a C library that is used to interface with the X Window System. It can be installed in Ubuntu from the &lt;code&gt;libxcb1-dev&lt;/code&gt; package. You also need the generic X development files that come with the &lt;code&gt;xorg-dev&lt;/code&gt; package.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SDK中的示例，和你稍后会用到的一个库，依赖于XCB库。这是一个用于与X窗口系统交互的C库。在Ubuntu中它可以用libxcb1-dev 包下载。你还需要随xorg-dev 包的通用X开发文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt install libxcb1-dev xorg-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;You can now build the Vulkan examples in the SDK by running:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在你可以编译SDK中的Vulkan示例了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./build_examples.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;If compilation was successful, then you should now have a &lt;code&gt;./examples/build/vkcube&lt;/code&gt; executable. Run it from the &lt;code&gt;examples/build&lt;/code&gt; directory with &lt;code&gt;./vkcube&lt;/code&gt; and ensure that you see the following pop up in a window:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果编译成功，那么你现在应该有一个可执行的./examples/build/vkcube 文件。从examples/build 文件夹，用./vkcube运行它，确保你看到下述弹出窗口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234626817-372278573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the &lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;&lt;span&gt;introduction chapter&lt;/span&gt;&lt;/a&gt; for links to drivers from the major vendors.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你看到错误信息，那么确保你的driver已经更新到最新版本，有Vulkan运行时，且你的图形卡被Vulkan支持。在&lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;introduction chapter&lt;/a&gt;入门章节有链接，可以查看主要厂商的driver。&lt;/p&gt;
&lt;h2&gt;GLFW&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creation a window to display the rendered results. To benefit from the cross-platform advantages of Vulkan and to avoid the horrors of X11, we'll use the &lt;a href=&quot;http://www.glfw.org/&quot;&gt;&lt;span&gt;GLFW library&lt;/span&gt;&lt;/a&gt; to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like &lt;a href=&quot;https://www.libsdl.org/&quot;&gt;&lt;span&gt;SDL&lt;/span&gt;&lt;/a&gt;, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如前所述，Vulkan是个平台不可知论的API，它没有创建窗口的工具。为了享受Vulkan的好处，也为了避免X11的恐怖，我们将使用&lt;a href=&quot;http://www.glfw.org/&quot;&gt;GLFW library&lt;/a&gt;来创建窗口，它支持Windows、Linux和MacOS。还有其他的库也能做到这一点，例如&lt;a href=&quot;https://www.libsdl.org/&quot;&gt;SDL&lt;/a&gt;，但是GLFW的优势是，它也抽象了Vulkan中一些除创建窗口外的其它跨平台的东西。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;We'll be installing GLFW from source instead of using a package, because the Vulkan support requires a recent version. You can find the sources on the &lt;a href=&quot;http://www.glfw.org/&quot;&gt;&lt;span&gt;official website&lt;/span&gt;&lt;/a&gt;. Extract the source code to a convenient directory and open a terminal in the directory with files like &lt;code&gt;CMakeLists.txt&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们不用包来安装GLWF，而是从源代码安装它，因为Vulkan需要最近的版本。你可以在官网&lt;a href=&quot;http://www.glfw.org/&quot;&gt;official website&lt;/a&gt;上找到源代码。解压缩源代码到方便的文件夹，打开终端，找到有CMakeLists.txt的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Run the following commands to generate a makefile and compile GLFW:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;运行下述命令，生成makefile，编译GLFW：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;cmake .
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; make
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;You may see a warning stating &lt;code&gt;Could NOT find Vulkan&lt;/code&gt;, but you can safely ignore this message. If compilation was successful, then you can install GLFW into the system libraries by running:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你可能看到一个警告说“Could NOT find Vulkan”（无法找到Vulkan），但是你可以安全地忽略这个消息。如果编译成功，那么你可以安装GLFW到系统库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;GLM&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Unlike DirectX 12, Vulkan does not include a library for linear algebra operations, so we'll have to download one. &lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;&lt;span&gt;GLM&lt;/span&gt;&lt;/a&gt; is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不像DirectX 12，Vulkan没有用于线性代数操作的库，所以我们不得不下载一个。&lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;GLM&lt;/a&gt; 是一个为图形API设计的库，广泛用于OpenGL中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;It is a header-only library that can be installed from the &lt;code&gt;libglm-dev&lt;/code&gt; package:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;它是只有头文件的库，可以从libglm-dev 包安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo apt install libglm-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Setting up a makefile project 配置makefile项目&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Now that you have installed all of the dependencies, we can set up a basic makefile project for Vulkan and write a little bit of code to make sure that everything works.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然你已经安装了所有的依赖，我们可以设置一个基础的Vulkan的makefile项目，写一小点代码来确保一切能顺利工作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Create a new directory at a convenient location with a name like &lt;code&gt;VulkanTest&lt;/code&gt;. Create a source file called &lt;code&gt;main.cpp&lt;/code&gt;and insert the following code. Don't worry about trying to understand it right now; we're just making sure that you can compile and run Vulkan applications. We'll start from scratch in the next chapter.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在合适的位置创建一个新文件夹，起名VulkanTest之类的都可以。创建一个源代码文件，命名为main.cpp，插入下述代码。别担心，现在不用理解这些代码，我们只是要确保你能编译和运行Vulkan应用程序。下一章我们将从零开始（写代码）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLFW_INCLUDE_VULKAN
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;GLFW/glfw3.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_RADIANS
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_DEPTH_ZERO_TO_ONE
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;glm/vec4.hpp&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;glm/mat4x4.hpp&amp;gt;
&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    glfwInit();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GLFWwindow* window = glfwCreateWindow(&lt;span&gt;800&lt;/span&gt;, &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vulkan window&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nullptr, nullptr);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;     uint32_t extensionCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vkEnumerateInstanceExtensionProperties(nullptr, &amp;amp;&lt;span&gt;extensionCount, nullptr);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  
&lt;span&gt;20&lt;/span&gt;     std::cout &amp;lt;&amp;lt; extensionCount &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; extensions supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    glm::mat4 matrix;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    glm::vec4 vec;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     auto test = matrix *&lt;span&gt; vec;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;  
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;glfwWindowShouldClose(window)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        glfwPollEvents();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    glfwDestroyWindow(window);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;  
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    glfwTerminate();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;  
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Next, we'll write a makefile to compile and run this basic Vulkan code. Create a new empty file called &lt;code&gt;Makefile&lt;/code&gt;. I will assume that you already have some basic experience with makefiles, like how variables and rules work. If not, you can get up to speed very quickly with &lt;a href=&quot;https://makefiletutorial.com/&quot;&gt;&lt;span&gt;this tutorial&lt;/span&gt;&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下一步，我们将写一个makefile来编译和运行这个基础的Vulkan代码。创建一个新的空文件，命名为Makefile。我假设你已经对makefile有一些了解，例如变量和规则是如何工作的。如果没有，这个教程可以让你很快上手。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;We'll first define a couple of variables to simplify the remainder of the file. Define a &lt;code&gt;VULKAN_SDK_PATH&lt;/code&gt; variable that refers to the location of the &lt;code&gt;x86_64&lt;/code&gt; directory in the LunarG SDK, for example:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先来定义几个变量来简化文件。例如，定义VULKAN_SDK_PATH 变量，指向LunarG SDK的x86_64 文件夹的位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Make sure to replace &lt;code&gt;user&lt;/code&gt; with your own username and &lt;code&gt;x.x.x.x&lt;/code&gt; with the right version. Next, define a &lt;code&gt;CFLAGS&lt;/code&gt;variable that will specify the basic compiler flags:&lt;/p&gt;
&lt;p&gt;确保替换user 为你自己的用户名，替换x.x.x.x为正确的版本号。下一步，定义CFLAGS变量，标识基础编译器标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CFLAGS = -std=c++&lt;span&gt;17&lt;/span&gt; -I$(VULKAN_SDK_PATH)/include
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We're going to use modern C++ (&lt;code&gt;-std=c++17&lt;/code&gt;), and we need to be able to locate &lt;code&gt;vulkan.h&lt;/code&gt; in the LunarG SDK.&lt;/p&gt;
&lt;p&gt;我们计划使用现代C++（-std=c++17），我们需要能够定位LunarG SDK中的vulkan.h文件。&lt;/p&gt;
&lt;p&gt;Similarly, define the linker flags in a &lt;code&gt;LDFLAGS&lt;/code&gt; variable:&lt;/p&gt;
&lt;p&gt;相似的，定义LDFLAGS 变量，表示链接标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LDFLAGS = -L$(VULKAN_SDK_PATH)/lib `pkg-config --&lt;span&gt;static&lt;/span&gt; --libs glfw3` -lvulkan
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;The first flag specifies that we want to be able to find libraries like &lt;code&gt;libvulkan.so&lt;/code&gt; in the LunarG SDK's &lt;code&gt;x86_64/lib&lt;/code&gt;directory. The second component invokes &lt;code&gt;pkg-config&lt;/code&gt; to automatically retrieve all of the linker flags necessary to build an application with GLFW. Finally, &lt;code&gt;-lvulkan&lt;/code&gt; links with the Vulkan function loader that comes with the LunarG SDK.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一个标志说明，我们想要在LunarG SDK的x86_64/lib文件夹下找到libvulkan.so 这样的库。第二个组件调用pkg-config ，来自动地检索所有需要用于和GLFW一起编译成应用程序的链接标志。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Specifying the rule to compile &lt;code&gt;VulkanTest&lt;/code&gt; is straightforward now. Make sure to use tabs for indentation instead of spaces.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编写编译VulkanTest 的规则就很直截了当了。确保使用tab键来缩进，不要用空格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;VulkanTest: main.cpp
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     g++ $(CFLAGS) -o VulkanTest main.cpp $(LDFLAGS)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Verify that this rule works by saving the makefile and running &lt;code&gt;make&lt;/code&gt; in the directory with &lt;code&gt;main.cpp&lt;/code&gt; and &lt;code&gt;Makefile&lt;/code&gt;. This should result in a &lt;code&gt;VulkanTest&lt;/code&gt; executable.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;保存这个makefile文件，在此文件夹下，配合main.cpp 和Makefile，运行make命令，以验证这个规则是否正常工作。这应该会产生一个VulkanTest 可执行文件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;We'll now define two more rules, &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;clean&lt;/code&gt;, where the former will run the executable and the latter will remove a built executable:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在我们再定义2个规则，test 和clean。前者会运行可执行文件，后者会清除已编译的可执行文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;.PHONY: test clean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;test: VulkanTest
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     ./&lt;span&gt;VulkanTest
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;  
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;clean:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     rm -f VulkanTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;You will find that &lt;code&gt;make clean&lt;/code&gt; works perfectly fine, but &lt;code&gt;make test&lt;/code&gt; will most likely fail with the following error message:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你将发现make clean 工作得很好，但是make test 很可能失败，并提供下述错误消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./VulkanTest: error &lt;span&gt;while&lt;/span&gt; loading shared libraries: libvulkan.so.&lt;span&gt;1&lt;/span&gt;: cannot open shared &lt;span&gt;object&lt;/span&gt; file: No such file or directory
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;That's because &lt;code&gt;libvulkan.so&lt;/code&gt; is not installed as system library. To alleviate this problem, explicitly specify the library loading path using the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是因为libvulkan.so没有被安装为系统库。为缓解这个问题，用环境变量LD_LIBRARY_PATH显式地声明这个库的加载路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;test: VulkanTest
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib ./VulkanTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;The program should now run successfully, and display the number of Vulkan extensions. The application should exit with the success return code (&lt;code&gt;0&lt;/code&gt;) when you close the empty window. However, there is one more variable that you need to set. We will start using validation layers in Vulkan and you need to tell the Vulkan library where to load these from using the &lt;code&gt;VK_LAYER_PATH&lt;/code&gt; variable:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在程序应该能成功运行了，显示出Vulkan扩展的数量。当你关闭空窗口时，这个应用程序应该退出并返回代码（0）。但是，你还需要设置一个变量。我们将开始在Vulkan中使用验证层，你需要用VK_LAYER_PATH变量告诉Vulkan库去哪儿加载这些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;test: VulkanTest
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/vulkan/explicit_layer.d ./VulkanTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;You should now have a complete makefile that resembles the following:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在你应该有一个完整的makefile了，其内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/&lt;span&gt;x86_64
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; CFLAGS = -std=c++&lt;span&gt;17&lt;/span&gt; -I$(VULKAN_SDK_PATH)/&lt;span&gt;include
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; LDFLAGS = -L$(VULKAN_SDK_PATH)/lib `pkg-config --&lt;span&gt;static&lt;/span&gt; --libs glfw3` -&lt;span&gt;lvulkan
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;VulkanTest: main.cpp
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     g++ $(CFLAGS) -&lt;span&gt;o VulkanTest main.cpp $(LDFLAGS)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;.PHONY: test clean
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;test: VulkanTest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/vulkan/explicit_layer.d ./&lt;span&gt;VulkanTest
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;clean:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     rm -f VulkanTest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;You can now use this directory as a template for your Vulkan projects. Make a copy, rename it to something like &lt;code&gt;HelloTriangle&lt;/code&gt; and remove all of the code in &lt;code&gt;main.cpp&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在你可以将此文件夹作为你的Vulkan项目的模板了。复制一份，重命名为HelloTriangle 之类，删掉main.cpp中所有代码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Before we move on, let's explore the Vulkan SDK a bit more. There is another program in it that will be very useful for development. The &lt;code&gt;x86_64/bin/glslangValidator&lt;/code&gt; program will be used to compile shaders from the human-readable &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenGL_Shading_Language&quot;&gt;&lt;span&gt;GLSL&lt;/span&gt;&lt;/a&gt; to bytecode. We'll cover this in depth in the &lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules&quot;&gt;&lt;span&gt;shader modules&lt;/span&gt;&lt;/a&gt; chapter.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;继续之前，我们来探索一下Vulkan SDK。有一个程序会很有用。程序&lt;code&gt;x86_64/bin/glslangValidator&lt;/code&gt; 会被用于将shader从人类可读的&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenGL_Shading_Language&quot;&gt;GLSL&lt;/a&gt; 编译为字节码。我们将在&lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules&quot;&gt;shader modules&lt;/a&gt; 章节细说。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The &lt;code&gt;Doc&lt;/code&gt; directory contains useful information about the Vulkan SDK and an offline version of the entire Vulkan specification. Feel free to explore the other files, but we won't need them for this tutorial.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;文件夹Doc 包含Vulkan SDK的有用信息，还有一个离线版本的Vulkan说明书。你可以自由探索这些文件，但是本教程中就不谈它们了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;You are now all set for &lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Base_code&quot;&gt;&lt;span&gt;the real adventure&lt;/span&gt;&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你已经准备好开启真正的探险了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;These instructions will assume you are using Xcode and the &lt;a href=&quot;https://brew.sh/&quot;&gt;&lt;span&gt;Homebrew package manager&lt;/span&gt;&lt;/a&gt;. Also, keep in mind that you will need at least MacOS version 10.11, and your device needs to support the &lt;a href=&quot;https://en.wikipedia.org/wiki/Metal_(API)#Supported_GPUs&quot;&gt;&lt;span&gt;Metal API&lt;/span&gt;&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本段教程将假设你在使用Xcode和&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew package manager&lt;/a&gt;。另外，记住你将需要最新的MacOS版本10.11，且你的设备需要支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Metal_(API)#Supported_GPUs&quot;&gt;Metal API&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Vulkan SDK&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开发Vulkan应用程序所需的最重要的组件是SDK。它包含头文件，标准验证层，调试工具和Vulkan函数的加载器。加载器在在运行时查询driver中的函数，这与OpenGL的GLEW类似——如果你熟悉它的话。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The SDK can be downloaded from &lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;&lt;span&gt;the LunarG website&lt;/span&gt;&lt;/a&gt; using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SDK可以从&lt;a href=&quot;https://vulkan.lunarg.com/&quot;&gt;LunarG 网站&lt;/a&gt;下载，按钮就在页面下边。你不用创建账户，但有了账户你可以得到一些对你有用的额外文档。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234653015-1400320402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The SDK version for MacOS internally uses &lt;a href=&quot;https://moltengl.com/&quot;&gt;&lt;span&gt;MoltenVK&lt;/span&gt;&lt;/a&gt;. There is no native support for Vulkan on MacOS, so what MoltenVK does is actually act as a layer that translates Vulkan API calls to Apple's Metal graphics framework. With this you can take advantage of debugging and performance benefits of Apple's Metal framework.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际上MacOS的SDK版本使用&lt;a href=&quot;https://moltengl.com/&quot;&gt;MoltenVK&lt;/a&gt;。MacOS没有对Vulkan的本地支持，所以MoltenVK实际上是在将Vulkan API调用翻译到Apple的Metal图形框架。藉此，你可以利用Apple的Metal框架的调试和性能优势。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;After downloading it, simply extract the contents to a folder of your choice (keep in mind you will need to reference it when creating your projects on Xcode). Inside the extracted folder, in the &lt;code&gt;Applications&lt;/code&gt; folder you should have some executable files that will run a few demos using the SDK. Run the &lt;code&gt;cube&lt;/code&gt; executable and you will see the following:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载后，解压缩到一个合适的文件夹（记住你会在用Xcode创建项目的时候引用它）。在解压的文件夹内，在Applications 文件夹内，你应该有一些可执行文件，它们是使用SDK的示例。运行cube文件，你将看到如下画面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234702236-369780232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;GLFW&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creation a window to display the rendered results. We'll use the &lt;a href=&quot;http://www.glfw.org/&quot;&gt;&lt;span&gt;GLFW library&lt;/span&gt;&lt;/a&gt; to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like &lt;a href=&quot;https://www.libsdl.org/&quot;&gt;&lt;span&gt;SDL&lt;/span&gt;&lt;/a&gt;, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如前所述，Vulkan是个平台不可知论的API，它没有创建窗口的工具。我们将使用&lt;a href=&quot;http://www.glfw.org/&quot;&gt;GLFW library&lt;/a&gt;来创建窗口，它支持Windows、Linux和MacOS。还有其他的库也能做到这一点，例如&lt;a href=&quot;https://www.libsdl.org/&quot;&gt;SDL&lt;/a&gt;，但是GLFW的优势是，它也抽象了Vulkan中一些除创建窗口外的其它跨平台的东西。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;To install GLFW on MacOS we will use the Homebrew package manager. Vulkan support for MacOS is still not fully available on the current (at the time of this writing) stable version 3.2.1. Therefore we will install the latest version of the &lt;code&gt;glfw3&lt;/code&gt; package using:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们将用Homebrew包管理器来在MacOS上安装GLFW。Vulkan对MacOS的支持还不完全，写作本教程时的版本是3.2.1。因此我们将安装最新的glfw3 包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
brew install glfw3 --HEAD
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;GLM&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Vulkan does not include a library for linear algebra operations, so we'll have to download one. &lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;&lt;span&gt;GLM&lt;/span&gt;&lt;/a&gt; is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Vulkan没有用于线性代数操作的库，所以我们不得不下载一个。&lt;a href=&quot;http://glm.g-truc.net/&quot;&gt;GLM&lt;/a&gt; 是一个为图形API设计的库，广泛用于OpenGL中。&lt;/p&gt;
&lt;p&gt;It is a header-only library that can be installed from the &lt;code&gt;glm&lt;/code&gt; package:&lt;/p&gt;
&lt;p&gt;它是只有头文件的库，可以从glm 包安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew install glm
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Setting up Xcode 配置Xcode&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Now that all the dependencies are installed we can set up a basic Xcode project for Vulkan. Most of the instructions here are essentially a lot of &quot;plumbing&quot; so we can get all the dependencies linked to the project. Also, keep in mind that during the following instructions whenever we mention the folder &lt;code&gt;vulkansdk&lt;/code&gt; we are refering to the folder where you extracted the Vulkan SDK.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然你已经安装了所有的依赖，我们可以设置一个基础的Vulkan的Xcode项目。这里大多数指导本质上都是很多“管道”，所以我们可以让所有依赖链接到这个项目。另外，记住下述指导中，无论何时我们提到vulkansdk 文件夹，我们知道是你解压缩Vulkan SDK的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Start Xcode and create a new Xcode project. On the window that will open select Application &amp;gt; Command Line Tool.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;启动Xcode，创建一个新的Xcode项目。在窗口上选择Application &amp;gt; Command Line Tool。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234714930-703508121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Select &lt;code&gt;Next&lt;/code&gt;, write a name for the project and for &lt;code&gt;Language&lt;/code&gt; select &lt;code&gt;C++&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择Next，输入一个项目名，Language 选择C++。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234719872-286985454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Press &lt;code&gt;Next&lt;/code&gt; and the project should have been created. Now, let's change the code in the generated &lt;code&gt;main.cpp&lt;/code&gt; file to the following code:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击Next ，项目就应该创建出来了。现在，让我们在生成的main.cpp 文件中修改代码为如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLFW_INCLUDE_VULKAN
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;GLFW/glfw3.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_RADIANS
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GLM_FORCE_DEPTH_ZERO_TO_ONE
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;glm/vec4.hpp&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;glm/mat4x4.hpp&amp;gt;
&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    glfwInit();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GLFWwindow* window = glfwCreateWindow(&lt;span&gt;800&lt;/span&gt;, &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vulkan window&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nullptr, nullptr);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;     uint32_t extensionCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vkEnumerateInstanceExtensionProperties(nullptr, &amp;amp;&lt;span&gt;extensionCount, nullptr);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  
&lt;span&gt;20&lt;/span&gt;     std::cout &amp;lt;&amp;lt; extensionCount &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; extensions supported&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    glm::mat4 matrix;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    glm::vec4 vec;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     auto test = matrix *&lt;span&gt; vec;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;  
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;glfwWindowShouldClose(window)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        glfwPollEvents();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    glfwDestroyWindow(window);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;  
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    glfwTerminate();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;  
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Keep in mind you are not required to understand all this code is doing yet, we are just setting up some API calls to make sure everything is working.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;记住，你现在还不需要理解这些代码，我们只是要设置一些API调用来确保一切工作正常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Xcode should already be showing some errors such as libraries it cannot find. We will now start configuring the project to get rid of those errors. On the &lt;em&gt;Project Navigator&lt;/em&gt; panel select your project. Open the &lt;em&gt;Build Settings&lt;/em&gt; tab and then:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Find the &lt;strong&gt;Header Search Paths&lt;/strong&gt; field and add a link to &lt;code&gt;/usr/local/include&lt;/code&gt; (this is where Homebrew installs headers, so the glm and glfw3 header files should be there) and a link to &lt;code&gt;vulkansdk/macOS/include&lt;/code&gt; for the Vulkan headers.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Find the &lt;strong&gt;Library Search Paths&lt;/strong&gt; field and add a link to &lt;code&gt;/usr/local/lib&lt;/code&gt; (again, this is where Homebrew installs libraries, so the glm and glfw3 lib files should be there) and a link to &lt;code&gt;vulkansdk/macOS/lib&lt;/code&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;Xcode应该已经显示一些错误，例如库没有找到。我们现在将开始配置项目来搞定这些错误。在&lt;em&gt;Project Navigator&lt;/em&gt; 面板选择你的项目，打开&lt;em&gt;Build Settings&lt;/em&gt; 选项卡，然后：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找到字段&lt;strong&gt;Header Search Paths&lt;/strong&gt; ，添加链接到/usr/local/include（这是Homebrew安装头文件的位置，所以glm和glfw3的头文件应该在这里）和vulkansdk/macOS/include（这是关于Vulkan头文件的）。&lt;/li&gt;
&lt;li&gt;找到字段&lt;strong&gt;Library Search Paths&lt;/strong&gt; ，添加链接到/usr/local/lib（这是Homebrew安装库的位置，所以glm和glfw3的lib文件应该在这里）和vulkansdk/macOS/lib。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;It should look like so (obviously, paths will be different depending on where you placed on your files):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这应该看起来是这样的（显然，基于你放置文件的位置，路径会有所不同）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234735479-431436005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Now, in the &lt;em&gt;Build Phases&lt;/em&gt; tab, on &lt;strong&gt;Link Binary With Libraries&lt;/strong&gt; we will add both the &lt;code&gt;glfw3&lt;/code&gt; and the &lt;code&gt;vulkan&lt;/code&gt;frameworks. To make things easier we will be adding he dynamic libraries in the project (you can check the documentation of these libraries if you want to use the static frameworks).&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;For glfw open the folder &lt;code&gt;/usr/local/lib&lt;/code&gt; and there you will find a file name like &lt;code&gt;libglfw.3.x.dylib&lt;/code&gt; (&quot;x&quot; is the library's version number, it might be different depending on when you downloaded the package from Homebrew). Simply drag that file to the Linked Frameworks and Libraries tab on Xcode.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;For vulkan, go to &lt;code&gt;vulkansdk/macOS/lib&lt;/code&gt;. Do the same for the file both files &lt;code&gt;libvulkan.1.dylib&lt;/code&gt; and &lt;code&gt;libvulkan.1.x.xx.dylib&lt;/code&gt; (where &quot;x&quot; will be the version number of the the SDK you downloaded).&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;现在，在&lt;em&gt;Build Phases&lt;/em&gt; 选项卡，在&lt;strong&gt;Link Binary With Libraries&lt;/strong&gt; 上，我们添加glfw3 和vulkan框架。为了让事情简单点，我们将动态库添加到项目里（如果你想用静态框架，你可以查看这些库的文档）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于glfw，打开文件夹/usr/local/lib，你会发现一个文件libglfw.3.x.dylib（&quot;x&quot;是库的版本号，基于你从Homebrew下载的包，这个版本号可能不同）。拖拽这个文件到Xcode的Linked Frameworks和Libraries选项卡。&lt;/li&gt;
&lt;li&gt;对于Vulkan，打开文件夹vulkansdk/macOS/lib。对文件libvulkan.1.dylib 和libvulkan.1.x.xx.dylib （其中&quot;x&quot;是你下载的SDK的版本号）做上述相同的拖拽操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;After adding those libraries, in the same tab on &lt;strong&gt;Copy Files&lt;/strong&gt; change &lt;code&gt;Destination&lt;/code&gt; to &quot;Frameworks&quot;, clear the subpath and deselect &quot;Copy only when installing&quot;. Click on the &quot;+&quot; sign and add all those three frameworks here as well.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;添加了这些库后，在这个tab选项卡里的&lt;strong&gt;Copy Files&lt;/strong&gt; 上，将Destination 修改为&quot;Frameworks&quot;，清空subpath，取消选择&quot;Copy only when installing&quot;。点击&quot;+&quot;符号，添加所有这3个框架。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Your Xcode configuration should look like:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你的Xcode配置应该如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234743790-1112613704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The last thing you need to setup are a couple of environment variables. On Xcode toolbar go to &lt;code&gt;Product&lt;/code&gt; &amp;gt; &lt;code&gt;Scheme&lt;/code&gt;&amp;gt; &lt;code&gt;Edit Scheme...&lt;/code&gt;, and in the &lt;code&gt;Arguments&lt;/code&gt; tab add the two following environment variables:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;VK_ICD_FILENAMES = &lt;code&gt;vulkansdk/macOS/etc/vulkan/icd.d/MoltenVK_icd.json&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VK_LAYER_PATH = &lt;code&gt;vulkansdk/macOS/etc/vulkan/explicit_layer.d&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;最后一件事，你要设置几个环境变量。在Xcode工具栏，选择Product &amp;gt; Scheme&amp;gt; Edit Scheme...,，在Arguments 选项卡添加2个环境变量，如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;VK_ICD_FILENAMES = vulkansdk/macOS/etc/vulkan/icd.d/MoltenVK_icd.json&lt;/li&gt;
&lt;li&gt;VK_LAYER_PATH = vulkansdk/macOS/etc/vulkan/explicit_layer.d&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;It should look like so:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这应该如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234756165-1019301985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Finally, you should be all set! Now if you run the project (remembering to setting the build configuration to Debug or Release depending on the configuration you chose) you should see the following:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后，大功告成！现在如果你运行项目（记得根据你选择配置来选择Debug或Release），你应该看到下图所示的画面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201906/383191-20190621234801419-1565890770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The number of extensions should be non-zero. The other logs are from the libraries, you might get different messages from those depending on your configuration.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;扩展的数目应该是非零的。其他的日志来自库，根据你的配置不同，你可能得到不同的消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;You are now all set for &lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Base_code&quot;&gt;&lt;span&gt;the real thing&lt;/span&gt;&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你已准备就绪，可以开始真家伙了。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 21 Jun 2019 16:21:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>[译]Vulkan教程(03)开发环境 这是我翻译（https://vulkan-tutorial.com）上的Vulkan教程的第3篇。 In this chapter we'll set</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bitzhuwei/p/Vulkan-Tutorial-03-Developmenet-Environment.html</dc:identifier>
</item>
<item>
<title>python算法与数据结构-冒泡排序(32) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/11067394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/11067394.html</guid>
<description>&lt;h3&gt;一、冒泡排序介绍&lt;/h3&gt;
&lt;p&gt;　　冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p&gt;
&lt;h3&gt;二、冒泡排序原理&lt;/h3&gt;
&lt;ol class=&quot;custom_num para-list list-paddingleft-1&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;list-num-1-1 list-num-paddingleft-1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-num-1-2 list-num-paddingleft-1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这一步做完，最后的元素应该会是最大的数。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-num-1-3 list-num-paddingleft-1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-num-1-4 list-num-paddingleft-1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;三、冒泡排序图解&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621215414527-1844480790.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621220137940-1612738006.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621220844792-1721006191.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621221322172-19014345.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621221650604-120069804.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201906/751754-20190621221940172-1107577169.png&quot; alt=&quot;&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四、冒泡排序总结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;有N个数据需要比较N-1趟&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每趟比较N-i次,i表示第几趟，例如7个数据，第四趟需要比较 7-4 = 3次&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;五、冒泡排序python代码实现 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bubble_sort(numlist):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要排列的数据个数&lt;/span&gt;
    N =&lt;span&gt; len(numlist)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; i 控制一共需要多少趟 N-1&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(N-1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; j 控制每趟需要比较多少次(因为i是从0开始，所以N-i-1)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N-i-1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断j和j+1两个位置的数据大小&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; numlist[j]&amp;gt;numlist[j+1&lt;span&gt;]:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 交换（交换的代码有很多种写法）&lt;/span&gt;
                temp =&lt;span&gt; numlist[j]
                numlist[j] &lt;/span&gt;= numlist[j+1&lt;span&gt;]
                numlist[j&lt;/span&gt;+1] =&lt;span&gt; temp
            
list &lt;/span&gt;= [19,2,13,8,34,25,7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排序前list = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;list)
bubble_sort(list)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排序后list = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
排序前list = [19, 2, 13, 8, 34, 25, 7&lt;span&gt;]
排序后list &lt;/span&gt;= [2, 7, 8, 13, 19, 25, 34]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、冒泡排序C语言代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个冒泡函数，需要传递一个数组,和数组的长度&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bubble_sort(&lt;span&gt;int&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arrayLength)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i 控制一共需要循环多少趟，&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;arrayLength-&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; j 控制每趟循环多少次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;arrayLength-i-&lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断j和j+1位置上数的大小&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (array[j]&amp;gt;array[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; array[j];
                array[j] &lt;/span&gt;= array[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                array[j&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; temp;
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的声明&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; bubble_sort(&lt;span&gt;int&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arrayLength);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个数组&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; numArray[] = {&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行排序&lt;/span&gt;
    bubble_sort(numArray,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
   
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印排序后的数组是：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;7&lt;/span&gt;; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,numArray[i]);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运算结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;打印排序后的数组是：
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;19&lt;/span&gt; &lt;span&gt;25&lt;/span&gt; &lt;span&gt;34&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;七、冒泡排序的优化&lt;/h3&gt;
&lt;p&gt;　　通过上面的案例我们已经知道冒泡排序的原理和实现过程，但是在处理一些特殊数据上的时候，我们还可以对冒泡排序优化，例如：一个数组本来就是有序，1，2，3，4，5，6，7，这样的一个数组已经是正确的顺序的，我们只需要比较一趟后，发现这一趟所有的数据都没有发生改变，就说明这已经是一个正确的顺序的，后面的循环就没必要循环下去了，这样便能提高程序的效率，而我们只需要在冒泡排序的代码中，判断是否这一样都没发生交换即可。&lt;/p&gt;
&lt;p&gt;python代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bubble_sort(numlist):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要排列的数据个数&lt;/span&gt;
    N =&lt;span&gt; len(numlist)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; i 控制一共需要多少趟 N-1&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(N-1&lt;span&gt;):
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个变量，用于记录是否在本趟中发生了交换&lt;/span&gt;
        isChange =&lt;span&gt; 0
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; j 控制每趟需要比较多少次(因为i是从0开始，所以N-i-1)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N-i-1&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断j和j+1两个位置的数据大小&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; numlist[j]&amp;gt;numlist[j+1&lt;span&gt;]:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 交换（交换的代码有很多种写法）&lt;/span&gt;
                temp =&lt;span&gt; numlist[j]
                numlist[j] &lt;/span&gt;= numlist[j+1&lt;span&gt;]
                numlist[j&lt;/span&gt;+1] =&lt;span&gt; temp
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只要发生了交换，我们就改变isChange的值为1&lt;/span&gt;
                isChange = 1
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只要isChange =0说明已经是正确顺序了，直接break即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; isChange ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            
list &lt;/span&gt;= [19,2,13,8,34,25,7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排序前list = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;list)
bubble_sort(list)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;排序后list = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
排序前list = [19, 2, 13, 8, 34, 25, 7&lt;span&gt;]
排序后list &lt;/span&gt;= [2, 7, 8, 13, 19, 25, 34]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C语言代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个冒泡函数，需要传递一个数组,和数组的长度&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bubble_sort(&lt;span&gt;int&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arrayLength)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i 控制一共需要循环多少趟，&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;arrayLength-&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个变量，用于记录是否在本趟中发生了改变&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; isChange = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; j 控制每趟循环多少次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;arrayLength-i-&lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断j和j+1位置上d数的大小&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (array[j]&amp;gt;array[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; array[j];
                array[j] &lt;/span&gt;= array[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                array[j&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; temp;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要发生了交换，我们就改变isChange的值为1&lt;/span&gt;
                isChange = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要isChange =0说明已经是正确顺序了，直接break即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (isChange == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的声明&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; bubble_sort(&lt;span&gt;int&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arrayLength);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个数组&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; numArray[] = {&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行排序&lt;/span&gt;
    bubble_sort(numArray,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
   
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印排序后的数组是：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;7&lt;/span&gt;; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,numArray[i]);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;打印排序后的数组是：
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;19&lt;/span&gt; &lt;span&gt;25&lt;/span&gt; &lt;span&gt;34&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;八、冒泡排序的时间复杂度&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）&lt;/li&gt;
&lt;li&gt;最坏时间复杂度：O(n2)&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;九、冒泡排序算法的稳定性 &lt;/h3&gt;
&lt;p&gt;　　冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 16:10:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、冒泡排序介绍 冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Se7eN-HOU/p/11067394.html</dc:identifier>
</item>
<item>
<title>Spring  Shell入门介绍 - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/11067342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/11067342.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;spring-shell是什么&quot;&gt;Spring Shell是什么&lt;/h2&gt;
&lt;p&gt;Spring Shell是Spring生态中的一员，用于开发命令行应用程序，官网：https://projects.spring.io/spring-shell/ 。&lt;br/&gt;Spring Shell构建在&lt;a href=&quot;https://github.com/jline/jline3&quot;&gt;JLine&lt;/a&gt;之上，集成&lt;a href=&quot;https://beanvalidation.org/&quot;&gt;Bean Validation API&lt;/a&gt;实现命令参数校验。&lt;br/&gt;从2.0版本开始，Spring Shell还可以非常方便地与Spring Boot进行集成，直接使用Spring Boot提供的一些非常实用的功能（如：打包可执行jar文件）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190621234929583-1889951530.png&quot; alt=&quot;Spring Shell是什么&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;入门实践&quot;&gt;入门实践&lt;/h2&gt;
&lt;p&gt;使用Spring Shell非常简单，直接添加对应的依赖配置即可，而为了使用Spring Boot提供的便利性，通常都是与Spring Boot集成使用。&lt;/p&gt;
&lt;h3 id=&quot;基础配置&quot;&gt;基础配置&lt;/h3&gt;
&lt;p&gt;集成&lt;a href=&quot;https://start.spring.io/&quot;&gt;Spring Boot&lt;/a&gt;本质上就是先新建一个Spring Boot工程，然后添加Spring Shell依赖即可，如下所示：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;chench.org.extra&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;test-springshell&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;test-springshell&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Test Spring Shell&amp;lt;/description&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 在Spring Boot项目中添加Spring Shell依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.shell&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-shell-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- 打包可执行文件 --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完上述配置之后，一个基于Spring Boot的使用Spring Shell开发命令行应用程序的基础开发框架已经搭建完毕，打包运行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mvn clean package -Dmaven.test.skip=true
$ java -jar test-springshell-0.0.1-SNAPSHOT.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.6.RELEASE)

2019-06-21 11:23:54.966  INFO 11286 --- [           main] c.o.e.t.TestSpringshellApplication       : Starting TestSpringshellApplication v0.0.1-SNAPSHOT on chench9-pc with PID 11286 (/home/chench9/sun/workspace/test-springshell/target/test-springshell-0.0.1-SNAPSHOT.jar started by chench9 in /home/chench9)
2019-06-21 11:23:54.970  INFO 11286 --- [           main] c.o.e.t.TestSpringshellApplication       : No active profile set, falling back to default profiles: default
2019-06-21 11:23:56.457  INFO 11286 --- [           main] c.o.e.t.TestSpringshellApplication       : Started TestSpringshellApplication in 2.26 seconds (JVM running for 2.771)
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，使用Spring Shell开发的命令行应用程序与其他普通应用不同，启动之后停留在命令交互界面，等待用户输入。&lt;br/&gt;目前还没有编写任何与业务相关的代码，输入&lt;code&gt;help&lt;/code&gt;命令看看。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.


shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Spring Shell已经内置了一些常用的命令，如：&lt;code&gt;help&lt;/code&gt;命令显示帮助信息，&lt;code&gt;clear&lt;/code&gt;命令清空命令行界面，&lt;code&gt;exit&lt;/code&gt;退出应用。&lt;br/&gt;在交互界面输出&lt;code&gt;exit&lt;/code&gt;命令退出应用程序。&lt;/p&gt;
&lt;h3 id=&quot;简单示例&quot;&gt;简单示例&lt;/h3&gt;
&lt;p&gt;按照国际惯例，通过编写一个简单的“Hello，World!”程序来介绍Spring Shell的相关概念。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellComponent
public class HelloWorld {

    @ShellMethod(&quot;Say hello&quot;)
    public void hello(String name) {
        System.out.println(&quot;hello, &quot; + name + &quot;!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，&lt;code&gt;HellWorld&lt;/code&gt;是一个非常简单的Java类，在Spring Shell应用中Java类需要使用注解&lt;code&gt;@ShellComponent&lt;/code&gt;来修饰，类中的方法使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;表示为一个具体的命令。&lt;br/&gt;打包运行，输入&lt;code&gt;help&lt;/code&gt;命令之后将会看到，默认情况下在Java类中定义的方法名就是在交互界面中可以使用的命令名称。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.

Hello World              # 命令所属组名
        hello: Say hello # 具体的命令


shell:&amp;gt;hello World
hello, World!
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，一个简单的基于Spring Shell的命令行交互应用就完成了，下面对Spring Shell中的相关组件进行详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;注解shellmethod&quot;&gt;注解@ShellMethod&lt;/h2&gt;
&lt;p&gt;默认情况下，使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;修饰的Java方法名称就是具体的交互命令名称，如上述示例。&lt;br/&gt;追溯注解&lt;code&gt;@ShellMethod&lt;/code&gt;源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Documented
public @interface ShellMethod {
    String INHERITED = &quot;&quot;;

    String[] key() default {};    // 设置命令名称

    String value() default &quot;&quot;;    // 设置命名描述

    String prefix() default &quot;--&quot;; // 设置命令参数前缀，默认为“--”

    String group() default &quot;&quot;;    // 设置命令分组
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;的属性key设置命令名称（注意：可以为一个命令设置多个名称）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellComponent
public class Calculator {
    // 为一个命令指定多个名称
    @ShellMethod(value = &quot;Add numbers.&quot;, key = {&quot;sum&quot;, &quot;addition&quot;})
    public void add(int a, int b) {
        int sum = a + b;
        System.out.println(String.format(&quot;%d + %d = %d&quot;, a, b, sum));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.

Calculator
        addition, sum: Add numbers.


shell:&amp;gt;addition 1 2
1 + 2 = 3
shell:&amp;gt;sum 1 2
1 + 2 = 3
shell:&amp;gt;sum --a 1 --b 2  # 使用带命令参数前缀的方式
1 + 2 = 3
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;的key属性可以为方法指定多个命令名称，而且，此时方法名不再是可用的命令了。&lt;br/&gt;除了可以自定义命令名称，还可以自定义命令参数前缀（默认为“--”）和命令分组（默认为命令对应Java方法所在的类名称）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 1.使用属性value定义命令描述
// 2.使用属性key定义命令名称
// 3.使用属性prefix定义参数前缀
// 4.使用属性group定义命令分组
@ShellMethod(value = &quot;Add numbers.&quot;, key = {&quot;sum&quot;, &quot;addition&quot;}, prefix = &quot;-&quot;, group = &quot;Cal&quot;)
public void add(int a, int b) {
    int sum = a + b;
    System.out.println(String.format(&quot;%d + %d = %d&quot;, a, b, sum));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下为自定义了注解&lt;code&gt;@ShellMethod&lt;/code&gt;各个属性之后的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.
        exit, quit: Exit the shell.
        help: Display help about available commands.
        script: Read and execute commands from a file.
        stacktrace: Display the full stacktrace of the last error.

Cal
        addition, sum: Add numbers.


shell:&amp;gt;sum --a 1 --b 2
Too many arguments: the following could not be mapped to parameters: '--b 2'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.
shell:&amp;gt;sum -a 1 -b 2
1 + 2 = 3
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，命令分组为自定义的“Cal”，命令参数前缀为自定义的“-”（此时将不能再使用默认的参数前缀“--”）。&lt;/p&gt;
&lt;h2 id=&quot;注解shelloption&quot;&gt;注解@ShellOption&lt;/h2&gt;
&lt;p&gt;注解&lt;code&gt;@ShellMethod&lt;/code&gt;应用在Java方法上对命令进行定制，还可以使用注解&lt;code&gt;@ShellOption&lt;/code&gt;对命令参数进行定制。&lt;/p&gt;
&lt;h3 id=&quot;自定义参数名称&quot;&gt;自定义参数名称&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellMethod(&quot;Echo params&quot;)
public void echo(int a, int b, @ShellOption(&quot;--third&quot;) int c) {
    System.out.println(String.format(&quot;a=%d, b=%d, c=%d&quot;, a, b, c));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，使用注解&lt;code&gt;@ShellOption&lt;/code&gt;为第三个参数指定名称为“third”。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;echo 1 2 3
a=1, b=2, c=3
shell:&amp;gt;echo --a 1 --b 2 --c 3    # 显然，当明确指定了参数名称之后，必须使用指定的名称
Too many arguments: the following could not be mapped to parameters: '3'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.
shell:&amp;gt;echo --a 1 --b 2 --third 3
a=1, b=2, c=3
shell:&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用注解&lt;code&gt;@ShellOption&lt;/code&gt;还可以为命令参数指定多个名称：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellMethod(&quot;Echo command help&quot;)
public void myhelp(@ShellOption({&quot;-C&quot;, &quot;--command&quot;}) String cmd) {
    System.out.println(cmd);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;myhelp action
action
shell:&amp;gt;myhelp -C action
action
shell:&amp;gt;myhelp --command action
action&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置参数默认值&quot;&gt;设置参数默认值&lt;/h3&gt;
&lt;p&gt;还可以使用注解&lt;code&gt;@ShellOption&lt;/code&gt;通过属性“defaultValue”为参数指定默认值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellMethod(&quot;Say hello&quot;)
public void hello(@ShellOption(defaultValue = &quot;World&quot;) String name) {
    System.out.println(&quot;hello, &quot; + name + &quot;!&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;hello          # 显然，当参数值为空时使用默认值
hello, World!
shell:&amp;gt;hello zhangsan
hello, zhangsan!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为一个参数传递多个值&quot;&gt;为一个参数传递多个值&lt;/h3&gt;
&lt;p&gt;通常，一个命令参数只对应一个值，如果希望为一个参数传递多个值（对应Java中的数组或集合），可以使用注解&lt;code&gt;@ShellOption&lt;/code&gt;的属性arity指定参数值的个数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 参数为一个数组
@ShellMethod(&quot;Add by array&quot;)
public void addByArray(@ShellOption(arity = 3) int[] numbers) {
    int sum = 0;
    for(int number : numbers) {
        sum += number;
    }
    System.out.println(String.format(&quot;sum=%d&quot;, sum));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;add-by-array 1 2 3
sum=6
shell:&amp;gt;add-by-array --numbers 1 2 3
sum=6
shell:&amp;gt;add-by-array --numbers 1 2 3 4  # 传递的参数个数超过arity属性值时报错
Too many arguments: the following could not be mapped to parameters: '4'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 参数为集合
@ShellMethod(&quot;Add by list&quot;)
public void addByList(@ShellOption(arity = 3) List&amp;lt;Integer&amp;gt; numbers) {
    int s = 0;
    for(int number : numbers) {
        s += number;
    }
    System.out.println(String.format(&quot;s=%d&quot;, s));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;add-by-list 1 2 3
s=6
shell:&amp;gt;add-by-list --numbers 1 2 3
s=6
shell:&amp;gt;add-by-list --numbers 1 2 3 4  # 传递的参数个数超过arity属性值时报错
Too many arguments: the following could not be mapped to parameters: '4'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 传递的参数个数不能大于&lt;code&gt;@ShellOption&lt;/code&gt;属性arity设置的值。&lt;/p&gt;
&lt;h3 id=&quot;对布尔参数的特殊处理&quot;&gt;对布尔参数的特殊处理&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 参数为Boolean类型
@ShellMethod(&quot;Shutdown action&quot;)
public void shutdown(boolean shutdown) {
    System.out.println(String.format(&quot;shutdown=%s&quot;, shutdown));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;shutdown 
shutdown=false
shell:&amp;gt;shutdown --shutdown
shutdown=true
shell:&amp;gt;shutdown --shutdown true
Too many arguments: the following could not be mapped to parameters: 'true'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述示例可以知道，对于布尔类型的参数，默认值为false，当明确传递参数名时，值为true。&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt; 对于布尔参数值处理比较特别，无需像普通参数一样传递参数值，否则报错。&lt;/p&gt;
&lt;h2 id=&quot;带空格的参数处理&quot;&gt;带空格的参数处理&lt;/h2&gt;
&lt;p&gt;Spring Shell使用空格来分割参数，当需要传递带空格的参数时，需要将参数使用引号（单引号或者双引号）引起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 带空格的参数需要使用引号引起来
@ShellMethod(&quot;Echo.&quot;)
public void echo(String what) {
    System.out.println(what);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;echo &quot;Hello,World!&quot;
Hello,World!
shell:&amp;gt;echo 'Hello,World!'
Hello,World!
shell:&amp;gt;echo &quot;Hello,\&quot;World!\&quot;&quot;
Hello,&quot;World!&quot;
shell:&amp;gt;echo '\&quot;Hello,World!\&quot;'
&quot;Hello,World!&quot;
shell:&amp;gt;echo Hello World         # 当参数值中包含空格时，需要使用引号引起来，否则报错
Too many arguments: the following could not be mapped to parameters: 'World'
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参数校验&quot;&gt;参数校验&lt;/h2&gt;
&lt;p&gt;Spring Shell集成了&lt;a href=&quot;https://beanvalidation.org/&quot;&gt;Bean Validation API&lt;/a&gt;，可用来实现参数校验。可支持参数校验的类型很多，如：是否为空，长度，最大值，最小值等等。&lt;br/&gt;实现参数校验也是通过注解实现的，常用的参数校验注解有：&lt;code&gt;@Size&lt;/code&gt;（校验参数长度），&lt;code&gt;@Max&lt;/code&gt;（校验参数最大值），&lt;code&gt;@Min&lt;/code&gt;（校验参数最小值），&lt;code&gt;@Pattern&lt;/code&gt;（支持自定义正则表达式校验规则）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用@Size注解校验参数长度
@ShellMethod(&quot;Change password&quot;)
public void changePwd(@Size(min = 6, max = 30) String pwd) {
    System.out.println(pwd);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;change-pwd 123                              # 当参数长度小于最小值6时报错
The following constraints were not met:
    --pwd string : size must be between 6 and 30 (You passed '123')
shell:&amp;gt;change-pwd 1234567890123456789012345678901  # 当参数长度大于最大值30时报错
The following constraints were not met:
    --pwd string : size must be between 6 and 30 (You passed '1234567890123456789012345678901')
shell:&amp;gt;change-pwd 1234567890                       # 参数在指定范围是成功
1234567890&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Shell支持的参数注解如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190621235132207-420954266.png&quot; alt=&quot;Spring Shell支持的参数校验注解&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态命令可用性&quot;&gt;动态命令可用性&lt;/h2&gt;
&lt;p&gt;如果存在这样一种场景：命令A是否可以执行需要依赖命令B的执行结果，换言之，当命令B的执行结果不满足条件时不允许执行命令A。&lt;br/&gt;Spring Shell针对这个需求也做了支持，翻译为：动态命令可用性（Dynamic Command Availability），具体实现有2种方式。&lt;br/&gt;这个概念理解起来有些生硬，简而言之：命令必须满足特定条件时才能被执行，也就说命令必须满足特定条件才可用。因为这个“特定条件”是在动态变化的，所以叫做“动态命令可用性”。&lt;/p&gt;
&lt;h3 id=&quot;为单一命令提供动态可用性&quot;&gt;为单一命令提供动态可用性&lt;/h3&gt;
&lt;p&gt;为单一命令提供动态可用性支持通过控制方法命名来实现。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;@ShellComponent
public class Downloader {
    private boolean connected = false;

    @ShellMethod(&quot;Connect server&quot;)
    public void connect() {
        connected = true;
    }

    @ShellMethod(&quot;Download file&quot;)
    public void download() {
        System.out.println(&quot;Downloaded.&quot;);
    }

    // 为命令download提供可用行支持
    public Availability downloadAvailability() {
        return connected ? Availability.available():Availability.unavailable(&quot;you are not connected&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;download    # download命令依赖connect命令的执行结果，因此在执行connect命令成功之前直接调用download命令时报错
Command 'download' exists but is not currently available because you are not connected
Details of the error have been omitted. You can use the stacktrace command to print the full stacktrace.
shell:&amp;gt;connect 
shell:&amp;gt;download    # 在执行命令connect成功之后再执行download命令时成功
Downloaded.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，在这种方式下，必须为需要实现动态可用性的命令提供一个对应名称的方法（方法名必须是：“命令名 + Availability”，如：downloadAvailability），且方法的返回值必须为&lt;code&gt;org.springframework.shell.Availability&lt;/code&gt;对象。&lt;br/&gt;该方式的缺点也很明显，如果需要实现动态可用性的命令比较多，必须定义同等数量的可用性方法，比较繁琐。&lt;/p&gt;
&lt;h3 id=&quot;为多个命令提供动态可用性&quot;&gt;为多个命令提供动态可用性&lt;/h3&gt;
&lt;p&gt;如果需要为多个命令提供动态可用性支持，使用注解&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;才是比较明智的。&lt;br/&gt;而注解&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;的使用方式又有2种：&lt;br/&gt;1.在命令方法上使用&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;指定提供动态可用性支持的方法名&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean connected = false;

@ShellMethod(&quot;Connect server&quot;)
public void connect() {
    connected = true;
}

@ShellMethod(&quot;Download&quot;)
@ShellMethodAvailability({&quot;connectCheck&quot;})
public void download() {
    System.out.println(&quot;Downloaded.&quot;);
}

@ShellMethod(&quot;Upload&quot;)
@ShellMethodAvailability({&quot;connectCheck&quot;})
public void upload() {
    System.out.println(&quot;Uploaded.&quot;);
}

public Availability connectCheck() {
    return connected ? Availability.available():Availability.unavailable(&quot;you are not connected&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，在命令方法&lt;code&gt;download()&lt;/code&gt;和&lt;code&gt;upload()&lt;/code&gt;通过注解&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;指定提供命令动态性实现的方法名：connectCheck，这样就可以很方便地实现使用一个方法为多个命令提供动态可用性支持。&lt;/p&gt;
&lt;p&gt;2.直接在提供命令动态可用性支持的方法上使用注解&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;指定命令方法名&lt;/p&gt;
&lt;p&gt;另外一种实现用一个方法为多个命令提供动态可用性实现的方式是：直接在命令动态可用性方法上使用注解&lt;code&gt;@ShellMethodAvailability&lt;/code&gt;指定对应的命令方法名。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellMethod(&quot;Download&quot;)
public void download() {
    System.out.println(&quot;Downloaded.&quot;);
}

@ShellMethod(&quot;Upload&quot;)
public void upload() {
    System.out.println(&quot;Uploaded.&quot;);
}

// 直接在提供命令动态可用性的方法上通过注解`@ShellMethodAvailability`指定命令方法名
@ShellMethodAvailability({&quot;download&quot;, &quot;upload&quot;})
public Availability connectCheck() {
    return connected ? Availability.available():Availability.unavailable(&quot;you are not connected&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令动态可用性小结&quot;&gt;命令动态可用性小结&lt;/h3&gt;
&lt;p&gt;1.使用了动态命令可用性的命令会在交互界面中显示一个星号提示，明确提示该命令的执行需要依赖指定状态（通常是其他命令的执行结果）。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Downloader
        connect: Connect server
      * download: Download     # download和upload命令的执行都需要依赖指定状态
      * upload: Upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.不论如何，提供动态命令可用性的方法返回值必须是&lt;code&gt;org.springframework.shell.Availability&lt;/code&gt;类型对象。&lt;/p&gt;
&lt;h2 id=&quot;命令分组&quot;&gt;命令分组&lt;/h2&gt;
&lt;p&gt;Spring Shell管理命令分组有3种实现方式，分别是：默认以类名为组名，使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;的group属性指定组名，使用注解&lt;code&gt;@ShellCommandGroup&lt;/code&gt;指定组名。&lt;/p&gt;
&lt;h3 id=&quot;默认命令分组规则&quot;&gt;默认命令分组规则&lt;/h3&gt;
&lt;p&gt;命令所在的组为其对应方法所在的Java类名称按驼峰法则分隔的名称（如：“HelloWord”为类名，则其中的命令组名为“Hello Word”），这是默认的命令组管理方式。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hello World      # 默认的命令组管理方式
        hello: Say hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用shellmethod注解的group属性指定分组&quot;&gt;使用@ShellMethod注解的group属性指定分组&lt;/h3&gt;
&lt;p&gt;通过注解&lt;code&gt;@ShellMethod&lt;/code&gt;的group属性指定命令所属的组名&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellComponent
public class Cmd1 {
    @ShellMethod(value = &quot;Cmd1 action1&quot;, group = &quot;CMD&quot;)
    public void action11() {
        System.out.println(&quot;cmd1 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd1 action2&quot;, group = &quot;CMD&quot;)
    public void action12() {
        System.out.println(&quot;cmd1 action2&quot;);
    }
}

@ShellComponent
public class Cmd2 {
    @ShellMethod(value = &quot;Cmd2 action1&quot;, group = &quot;CMD&quot;)
    public void action21() {
        System.out.println(&quot;cmd2 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd2 action2&quot;, group = &quot;CMD&quot;)
    public void action22() {
        System.out.println(&quot;cmd2 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

CMD
        action11: Cmd1 action1
        action12: Cmd1 action2
        action21: Cmd2 action1
        action22: Cmd2 action2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;的group属性可以将不同类的不同命令指定到同一个命令组下。&lt;/p&gt;
&lt;h3 id=&quot;使用shellcommandgroup注解指定分组&quot;&gt;使用@ShellCommandGroup注解指定分组&lt;/h3&gt;
&lt;p&gt;在使用注解&lt;code&gt;@ShellCommandGroup&lt;/code&gt;指定命令分组时有2种方法：&lt;br/&gt;&lt;strong&gt;方法一：&lt;/strong&gt; 在类上使用注解&lt;code&gt;@ShellCommandGroup&lt;/code&gt;指定组名，则该类下的所有命令都属于该组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellComponent
@ShellCommandGroup(&quot;CMD&quot;)
public class Cmd1 {
    @ShellMethod(value = &quot;Cmd1 action1&quot;)
    public void action11() {
        System.out.println(&quot;cmd1 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd1 action2&quot;)
    public void action12() {
        System.out.println(&quot;cmd1 action2&quot;);
    }
}

@ShellComponent
@ShellCommandGroup(&quot;CMD&quot;)
public class Cmd2 {
    @ShellMethod(value = &quot;Cmd2 action1&quot;)
    public void action21() {
        System.out.println(&quot;cmd2 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd2 action2&quot;)
    public void action22() {
        System.out.println(&quot;cmd2 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 使用注解@ShellCommandGroup将多个类中的命令指定到一个组下
shell:&amp;gt;help
AVAILABLE COMMANDS

CMD
        action11: Cmd1 action1
        action12: Cmd1 action2
        action21: Cmd2 action1
        action22: Cmd2 action2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt; 在&lt;code&gt;package-info.java&lt;/code&gt;中使用注解&lt;code&gt;@ShellCommandGroup&lt;/code&gt;指定整个包下的所有类中的命令为一个组。&lt;/p&gt;
&lt;p&gt;如下图所示，Cmd1.java和Cmd2.java都在包&lt;code&gt;chench.org.extra.testspringshell.group&lt;/code&gt;下，&lt;code&gt;package-info.java&lt;/code&gt;为对应的包描述类。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201906/722072-20190621235044516-1556098999.png&quot; alt=&quot;通过包描述类对命令进行分组&quot;/&gt;&lt;br/&gt;Cmd1.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package chench.org.extra.testspringshell.group;
import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;
@ShellComponent
public class Cmd1 {
    @ShellMethod(value = &quot;Cmd1 action1&quot;)
    public void action11() {
        System.out.println(&quot;cmd1 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd1 action2&quot;)
    public void action12() {
        System.out.println(&quot;cmd1 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cmd2.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package chench.org.extra.testspringshell.group;
import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;
@ShellComponent
public class Cmd2 {
    @ShellMethod(value = &quot;Cmd2 action1&quot;)
    public void action21() {
        System.out.println(&quot;cmd2 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd2 action2&quot;)
    public void action22() {
        System.out.println(&quot;cmd2 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;package-info.java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在Java包描述类中通过注解`@ShellCommandGroup`为该包下的所有类中的命令指定统一组名
@ShellCommandGroup(&quot;CMD&quot;)
package chench.org.extra.testspringshell.group;
import org.springframework.shell.standard.ShellCommandGroup;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

CMD
        action11: Cmd1 action1
        action12: Cmd1 action2
        action21: Cmd2 action1
        action22: Cmd2 action2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 通过注解&lt;code&gt;@ShellCommandGroup&lt;/code&gt;指定的命令分组可以被注解&lt;code&gt;@ShellMethod&lt;/code&gt;的group属性指定的组名覆盖。&lt;/p&gt;
&lt;h2 id=&quot;内置命令&quot;&gt;内置命令&lt;/h2&gt;
&lt;p&gt;Spring Shell提供了5个内置命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

Built-In Commands
        clear: Clear the shell screen.                              # 清空命令行界面
        exit, quit: Exit the shell.                                 # 退出应用
        help: Display help about available commands.                # 显示帮助信息
        script: Read and execute commands from a file.              # 从文件中读取并执行批量命令
        stacktrace: Display the full stacktrace of the last error.  # 报错时读取异常堆栈信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;Spring Shell大大简化了使用Java开发基于命令行交互应用的步骤，只需要简单配置，再使用相关注解就可以开发一个命令行应用了。&lt;br/&gt;同时，Spring Shell还内置了一些有用的命令，如：&lt;code&gt;help&lt;/code&gt;，&lt;code&gt;clear&lt;/code&gt;，&lt;code&gt;stacktrace&lt;/code&gt;，&lt;code&gt;exit&lt;/code&gt;等。&lt;br/&gt;另外，Spring Shell还支持实用TAB键补全命令，非常方便。&lt;/p&gt;
&lt;p&gt;最后，&lt;strong&gt;需要特别注意：&lt;/strong&gt; Spring Shell不允许出现同名的命令（虽然命令对应的同名方法虽然在不同的Java类中被允许，不会出现编译错误，但是运行时将报错，从而无法正确启动应用程序）。即：下面的情形是不允许的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ShellComponent
public class Cmd1 {
    @ShellMethod(value = &quot;Cmd1 action1&quot;)
    public void action1() {
        System.out.println(&quot;cmd1 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd1 action2&quot;)
    public void action2() {
        System.out.println(&quot;cmd1 action2&quot;);
    }
}

@ShellComponent
public class Cmd2 {
    @ShellMethod(value = &quot;Cmd2 action1&quot;)
    public void action1() {
        System.out.println(&quot;cmd2 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd2 action2&quot;)
    public void action2() {
        System.out.println(&quot;cmd2 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非使用注解&lt;code&gt;@ShellMethod&lt;/code&gt;的key属性不同的命令指定为不同的名称，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用注解`@ShellMethod`的key属性不同的命令指定为不同的名称
@ShellComponent
public class Cmd1 {
    @ShellMethod(value = &quot;Cmd1 action1&quot;, key = {&quot;cmd11&quot;})
    public void action1() {
        System.out.println(&quot;cmd1 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd1 action2&quot;, key = {&quot;cmd12&quot;})
    public void action2() {
        System.out.println(&quot;cmd1 action2&quot;);
    }
}

@ShellComponent
public class Cmd2 {
    @ShellMethod(value = &quot;Cmd2 action1&quot;, key = {&quot;cmd21&quot;})
    public void action1() {
        System.out.println(&quot;cmd2 action1&quot;);
    }

    @ShellMethod(value = &quot;Cmd2 action2&quot;, key = {&quot;cmd22&quot;})
    public void action2() {
        System.out.println(&quot;cmd2 action2&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;shell:&amp;gt;help
AVAILABLE COMMANDS

CMD
        cmd11: Cmd1 action1
        cmd12: Cmd1 action2
        cmd21: Cmd2 action1
        cmd22: Cmd2 action2&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 21 Jun 2019 15:53:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>目录 'Spring Shell是什么' '入门实践' '基础配置' '简单示例' '注解@ShellMethod' '注解@ShellOption' '自定义参数名称' '设置参数默认值' '为一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nuccch/p/11067342.html</dc:identifier>
</item>
<item>
<title>SpringBoot加载配置文件(@PropertySource@importSource@Value) - Boblim</title>
<link>http://www.cnblogs.com/fnlingnzb-learner/p/11067338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnlingnzb-learner/p/11067338.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;情景描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最近新搭建了一个项目，从Spring迁到了Springboot，为了兼容Spring加载配置文件的风格，所以还想把PropertyPlaceholderConfigurer放在.xml文件里面，然后通过@importSource来加载.xml文件将配置加载到spring环境中，通过@value或者PropertyUtil来引入对应配置的值。于是发现了以下问题，并根据这些问题进行了问题拓展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.在.xml引入PropertyPlaceholderConfigurer时，若项目中存在@PropertySource注解，@ConfigurationProperties可以正常加载PropertySource中的配置(启动时发现Bean正常)，但是@Value会在启动时报错解析不了占位符；若@ConfigurationProperties加载的是.xml中配置文件的值，则也为空。&lt;/p&gt;
&lt;p&gt;2.在使用PropertyUtil(由.xml加载配置)时发现，在通过.xml加载配置的这个方法上，public static 变量在@Configuration的配置类通过PropertyUtil获取配置值时PropertyUtil还未加载(值为null)，在其他@Component(包括@Controller)中是可以正常获取到值(说明已经加载)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决方案&amp;amp;原理分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中@PropertySource注解管理的所有配置文件相当于一个PropertyPlaceholderConfigurer，只不过是Springboot自己管理的，而.xml中的PropertyPlaceholderConfigurer又是一个，这就会出现多个PropertyPlaceholderConfigurer的问题(目测是由于先加载了@ImportSource中.xml的PropertyPlaceholderConfigurer导致该问题)，多PropertyPlaceholderConfigurer问题原因如下：&lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;82&quot;&gt;
&lt;p&gt;在spring bean装配时，一个PropertyPlaceholderConfigurer就是一个后置处理器BeanFactoryPostProcessor。在装配完PropertyPlaceholderConfigurer之后，就会触发org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(Collection&amp;lt;? extends BeanFactoryPostProcessor&amp;gt;, ConfigurableListableBeanFactory)方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
/**
 * Invoke the given BeanFactoryPostProcessor beans.
 */
private void invokeBeanFactoryPostProcessors(
        Collection&amp;lt;? extends BeanFactoryPostProcessor&amp;gt; postProcessors, ConfigurableListableBeanFactory beanFactory) {

    for (BeanFactoryPostProcessor postProcessor : postProcessors) {
        postProcessor.postProcessBeanFactory(beanFactory);
    }
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在&lt;strong&gt;&lt;span&gt;每调用完一个&lt;/span&gt;&lt;/strong&gt;BeanFactoryPostProcessor之后，就会去解析&lt;strong&gt;&lt;span&gt;所有的&lt;/span&gt;&lt;/strong&gt;bean中引用properties的占位符，这时就会出现占位符不能解析的问题(不能解析的占位在后面的BeanFactoryPostProcessor中，也就是PropertyPlaceholderConfigurer实例)。&lt;/p&gt;
&lt;p&gt;而在使用@Value时，由于使用了占位符，而.xml中的PropertyPlaceholderConfigurer先加载解析占位符但是该配置未存在，所以会报错占位符解析失败。&lt;/p&gt;
&lt;p&gt;而使用@ConfigurationProperties时，并没有使用占位符，所以如果是在@PropertySource中的配置可以正常加载&lt;/p&gt;
&lt;p&gt;但是我个人理解@ConfigurationProperties加载配置是用的@PropertySource的PropertyPlaceholderConfigurer，所以如果配置不是用@PropertySource加载，则加载结果为null(建议配套使用)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;property name=&quot;ignoreUnresolvablePlaceholders&quot; value=&quot;true&quot;/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加上上面的一行，表示可以忽略未解析到的占位符。这样就不会报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题2：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;blog_post_info_block&quot; readability=&quot;34&quot;&gt;
&lt;div id=&quot;blog_post_info&quot; readability=&quot;38&quot;&gt;
&lt;p&gt;我理解@Confituration标识的配置类是在@ImportSource加载.xml之前文件开始加载的，所以它的static值在从PropertyUtil获取值时，PropertyUtil并没有加载配置，所以都为空，但是@Component也即bean加载是在@ImportSource之后的，所以static变量可以获取到正常值。&lt;/p&gt;
&lt;p&gt;经过试验，我发现@Value在@Configuration标识的配置类中是可以正常获取到.xml加载的值的，这样表明@Value应该是在@ImportSource之后注入的了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果对我上面的分析存在异议欢迎讨论啊，希望相互提高。&lt;/p&gt;
&lt;p&gt;转载请注明：&lt;a href=&quot;https://www.cnblogs.com/fnlingnzb-learner/p/11067338.html&quot;&gt;https://www.cnblogs.com/fnlingnzb-learner/p/11067338.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 15:51:00 +0000</pubDate>
<dc:creator>Boblim</dc:creator>
<og:description>情景描述 最近新搭建了一个项目，从Spring迁到了Springboot，为了兼容Spring加载配置文件的风格，所以还想把PropertyPlaceholderConfigurer放在.xml文件里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnlingnzb-learner/p/11067338.html</dc:identifier>
</item>
<item>
<title>Python中可迭代对象、迭代器以及iter()函数的两个用法详解 - Pykk2019</title>
<link>http://www.cnblogs.com/PyKK2019/p/11067206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PyKK2019/p/11067206.html</guid>
<description>&lt;p&gt;在Python中，有这两个概念容易让人混淆。第一个是可迭代对象（Iterable），第二个是迭代器（Iterator），第三个是生成器（Generator），这里暂且不谈生成器。&lt;/p&gt;
&lt;h2 id=&quot;可迭代对象&quot;&gt;可迭代对象&lt;/h2&gt;
&lt;p&gt;列表、元组、字符串、字典等都是可迭代对象，可以使用for循环遍历出所有元素的都可以称为可迭代对象（Iterable）。在Python的内置数据结构中定义了Iterable这个类，在collections.abc模块中，我们可以用这个来检测是否为可迭代对象&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; a = [1,2,3]
&amp;gt;&amp;gt;&amp;gt; isinstance(a, Iterable)
&amp;gt;&amp;gt;&amp;gt; True
&amp;gt;&amp;gt;&amp;gt; b = 'abcd'
&amp;gt;&amp;gt;&amp;gt; isinstance(b, Iterable)
&amp;gt;&amp;gt;&amp;gt; True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些数据结构之所以能称之为Iterable，是因为其内部实现了__iter__()方法，从而可迭代。当我们使用for循环时，解释器会调用内置的iter()函数，调用前首先会检查对象是否实现了__iter__()方法，如果有就调用它获取一个迭代器（接下来会讲）。加入没有__iter__()方法，但是实现了__getitem__()方法，解释器会创建一个迭代器并且按顺序获取元素。如果这两个方法都没有找到，就会抛出TypeError异常。下面我们自定义对象，分别实现这两个方法（&lt;strong&gt;getitem&lt;/strong&gt;(), &lt;strong&gt;iter&lt;/strong&gt;()）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyObj:
    def __init__(self, iterable):
        self._iterable = list(iterable)

    def __getitem__(self, item):
        return self._iterable[item]


obj = MyObj([1,2,3])
for i in obj:
    print(i)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，这里没有实现__iter__方法，只实现了__getitem__方法，也使得Myobj称为可迭代对象。&lt;br/&gt;下面我们实现__iter__方法，这里使用了yield语法用来产出值（这里需要生成器的知识）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyObj:
    def __init__(self, iterable):
        self._iterable = list(iterable)

    def __iter__(self):
        index = 0
        while True:
            try:
                yield self._iterable[index]
            except IndexError:
                break
            index += 1

obj = MyObj([1,2,3])
for i in obj:
    print(i)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里同样让对象称为可迭代对象。&lt;/p&gt;
&lt;h2 id=&quot;迭代器&quot;&gt;迭代器&lt;/h2&gt;
&lt;p&gt;迭代器是一个可以记住遍历的位置的对象。&lt;br/&gt;迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1579698/201906/1579698-20190621230513320-354680153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，迭代器（Iterator）继承可迭代（Iterable），迭代器必须实现__iter__方法和__next__方法。其中__next__方法用于产出下一个元素。&lt;br/&gt;由继承图可见，&lt;strong&gt;迭代器一定是可迭代对象，可迭代对象不一定是迭代器&lt;/strong&gt;&lt;br/&gt;迭代器有两个基本的方法：iter() 和 next()。&lt;br/&gt;我们使用iter(iterable)即可把可迭代对象转换成迭代器&lt;br/&gt;使用next(iterator)来获取迭代器的下一个值&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [3,4,5]
&amp;gt;&amp;gt;&amp;gt; a
&amp;gt;&amp;gt;&amp;gt; [3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; iter(a)
&amp;gt;&amp;gt;&amp;gt; &amp;lt;list_iterator object at 0x10b130ba8&amp;gt;
&amp;gt;&amp;gt;&amp;gt; iterator = iter(a)
&amp;gt;&amp;gt;&amp;gt; next(iterator)
&amp;gt;&amp;gt;&amp;gt; 3
&amp;gt;&amp;gt;&amp;gt; next(iterator)
&amp;gt;&amp;gt;&amp;gt; 4
&amp;gt;&amp;gt;&amp;gt; next(iterator)
&amp;gt;&amp;gt;&amp;gt; 5
&amp;gt;&amp;gt;&amp;gt; next(iterator)
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，因为对象实现了__next__方法，我们可以通过next(iterator)来获取迭代器的下一个值，直到没有值了，抛出StopIteration异常结束。&lt;/p&gt;
&lt;h2 id=&quot;迭代器的背后&quot;&gt;迭代器的背后&lt;/h2&gt;
&lt;p&gt;迭代器Iterator是一个抽象基类，它定义在_collections_abc.py中&lt;br/&gt;&lt;code&gt;Iterator源码&lt;/code&gt;如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Iterator(Iterable):

    __slots__ = ()

    @abstractmethod
    def __next__(self):
        'Return the next item from the iterator. When exhausted, raise StopIteration'
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            return _check_methods(C, '__iter__', '__next__')
        return NotImplemented&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，它实现了__subclasshook__方法，即不用显式继承Iterator，只需要实现__iter__和__next__方法即可称为Iterator的&lt;strong&gt;虚拟子类&lt;/strong&gt;。这里凸现了Python的鸭子类型，实现特定的“协议”即可拥有某种行为。&lt;br/&gt;另外，它自己也定义了__iter__方法，当我们使用iter(Iterator)时直接返回自己，不做任何处理。&lt;/p&gt;
&lt;h2 id=&quot;iter函数的两个用法&quot;&gt;iter（）函数的两个用法&lt;/h2&gt;
&lt;p&gt;官方文档中给出了说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    iter(iterable) -&amp;gt; iterator
    iter(callable, sentinel) -&amp;gt; iterator
    
    Get an iterator from an object.  In the first form, the argument must
    supply its own iterator, or be a sequence.
    In the second form, the callable is called until it returns the sentinel.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个用法：iter(iterable) -&amp;gt; iterator (把可迭代对象转换为迭代器)&lt;br/&gt;第二个用法：iter(callable, sentinel) -&amp;gt; iterator (&lt;strong&gt;第一个参数：任何可调用对象，可以是函数，第二个是标记值，当可调用对象返回这个值时，迭代器抛出StopIteration异常，而不产出标记值&lt;/strong&gt;)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from random import choice
&amp;gt;&amp;gt;&amp;gt; values = [1,2,3,4,5,6,7]
&amp;gt;&amp;gt;&amp;gt; def test_iter():
&amp;gt;&amp;gt;&amp;gt;     return choice(values)
&amp;gt;&amp;gt;&amp;gt; it = iter(test_iter, 2)
&amp;gt;&amp;gt;&amp;gt; it
&amp;gt;&amp;gt;&amp;gt; &amp;lt;callable_iterator object at 0x10b130b00&amp;gt;
&amp;gt;&amp;gt;&amp;gt; for i in it:
&amp;gt;&amp;gt;&amp;gt;     print(i)
&amp;gt;&amp;gt;&amp;gt; 7
&amp;gt;&amp;gt;&amp;gt; 1
&amp;gt;&amp;gt;&amp;gt; 7
&amp;gt;&amp;gt;&amp;gt; 3
&amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码的流程：test_iter函数从values列表中随机挑选一个值并返回，调用iter(callable, sentinel)函数，把sentinel标记值设置为2，返回一个callable_iterator实例，遍历这个特殊的迭代器，如果函数返回标记值2，直接抛出异常退出程序。这就是iter函数的鲜为人知的另一个用法。&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 15:06:00 +0000</pubDate>
<dc:creator>Pykk2019</dc:creator>
<og:description>在Python中，有这两个概念容易让人混淆。第一个是可迭代对象（Iterable），第二个是迭代器（Iterator），第三个是生成器（Generator），这里暂且不谈生成器。 可迭代对象 列表、元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PyKK2019/p/11067206.html</dc:identifier>
</item>
<item>
<title>不得不知的责任链设计模式 - tan日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11066835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11066835.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;世界上最遥远的距离，不是生与死，而是它从你的世界路过无数次，你却选择视而不见，你无情，你冷酷啊......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-06c01689f5e813af.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;love-1089665_640.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;被你忽略的就是责任链设计模式，希望它再次经过你身旁你会猛的发现，并对它微微一笑......&lt;/p&gt;
&lt;h2 id=&quot;责任链设计模式介绍&quot;&gt;责任链设计模式介绍&lt;/h2&gt;
&lt;h3 id=&quot;抽象介绍&quot;&gt;抽象介绍&lt;/h3&gt;
&lt;p&gt;初次见面，了解表象，深入交流之后（看完文中的 demo 和框架中的实际应用后），你我便是灵魂之交（重新站在上帝视角来理解这个概念会更加深刻）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的&lt;code&gt;引用&lt;/code&gt;。如果一个对象能或不能处理该请求，它都会把相同的请求传给下一个接收者，依此类推，直至责任链结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来将概念图形化，用大脑图形处理区理解此概念&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-a4f1c2ba585aa172.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;W3sDesign_Chain_of_Responsibility_Design_Pattern_UML.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上图左侧的 UML 类图中，Sender 类不直接引用特定的接收器类。 相反，Sender 引用Handler 接口来处理请求&lt;code&gt;handler.handleRequest()&lt;/code&gt;，这使得 Sender 独立于具体的接收器（概念当中说的&lt;code&gt;解耦&lt;/code&gt;） Receiver1，Receiver2 和 Receiver3 类通过处理或转发请求来实现 Handler 接口（取决于运行时条件）&lt;/li&gt;
&lt;li&gt;上图右侧的 UML 序列图显示了运行时交互，在此示例中，Sender 对象在 receiver1 对象（类型为Handler）上调用 &lt;code&gt;handleRequest()&lt;/code&gt;， 接收器 1 将请求转发给接收器 2，接收器 2 又将请求转发到处理（执行）请求的接收器3&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;具象介绍&quot;&gt;具象介绍&lt;/h3&gt;
&lt;p&gt;大家小时候都玩过击鼓传花的游戏，游戏的每个参与者就是责任链中的一个处理对象，花球就是待处理的请求，花球就在责任链（每个参与者中）进行传递，只不过责任链的结束时间点是鼓声的结束. 来看 Demo 和实际案例&lt;/p&gt;
&lt;h2 id=&quot;demo设计&quot;&gt;Demo设计&lt;/h2&gt;
&lt;p&gt;程序猿和 log 是老交情了，使用 logback 配置日志的时候有 ConsoleAppender 和 RollingFileAppender，这两个 Appender 就组成了一个 log 记录的责任链。下面的 demo 就是模拟 log 记录：ConsoleLogger 打印所有级别的日志；EmailLogger 记录特定业务级别日志 ；FileLogger 中只记录 warning 和 Error 级别的日志&lt;/p&gt;
&lt;p&gt;抽象概念介绍中，说过实现责任链要有一个抽象接收器接口，和具体接收器，demo 中 &lt;code&gt;Logger&lt;/code&gt; 就是这个抽象接口，由于该接口是 &lt;code&gt;@FunctionalInterface&lt;/code&gt; (函数式接口), 它的具体实现就是 Lambda 表达式，关键代码都已做注释标注&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;
import java.util.EnumSet;
import java.util.function.Consumer;

@FunctionalInterface
public interface Logger {
    /**
     * 枚举log等级
     */
    public enum LogLevel {
        //定义 log 等级
        INFO, DEBUG, WARNING, ERROR, FUNCTIONAL_MESSAGE, FUNCTIONAL_ERROR;

        public static LogLevel[] all() {
            return values();
        }
    }

    /**
     * 函数式接口中的唯一抽象方法
     * @param msg
     * @param severity
     */
    abstract void message(String msg, LogLevel severity);

    default Logger appendNext(Logger nextLogger) {
        return (msg, severity) -&amp;gt; {
            // 前序logger处理完才用当前logger处理
            message(msg, severity);
            nextLogger.message(msg, severity);
        };
    }

    static Logger logger(LogLevel[] levels, Consumer&amp;lt;String&amp;gt; writeMessage) {
        EnumSet&amp;lt;LogLevel&amp;gt; set = EnumSet.copyOf(Arrays.asList(levels));
        return (msg, severity) -&amp;gt; {
            // 判断当前logger是否能处理传递过来的日志级别
            if (set.contains(severity)) {
                writeMessage.accept(msg);
            }
        };
    }

    static Logger consoleLogger(LogLevel... levels) {
        return logger(levels, msg -&amp;gt; System.err.println(&quot;写到终端: &quot; + msg));
    }

    static Logger emailLogger(LogLevel... levels) {
        return logger(levels, msg -&amp;gt; System.err.println(&quot;通过邮件发送: &quot; + msg));
    }

    static Logger fileLogger(LogLevel... levels) {
        return logger(levels, msg -&amp;gt; System.err.println(&quot;写到日志文件中: &quot; + msg));
    }

    public static void main(String[] args) {
        /**
         * 构建一个固定顺序的链 【终端记录——邮件记录——文件记录】
         * consoleLogger：终端记录，可以打印所有等级的log信息
         * emailLogger：邮件记录，打印功能性问题 FUNCTIONAL_MESSAGE 和 FUNCTIONAL_ERROR 两个等级的信息
         * fileLogger：文件记录，打印 WARNING 和 ERROR 两个等级信息
         */
        
        Logger logger = consoleLogger(LogLevel.all())
                .appendNext(emailLogger(LogLevel.FUNCTIONAL_MESSAGE, LogLevel.FUNCTIONAL_ERROR))
                .appendNext(fileLogger(LogLevel.WARNING, LogLevel.ERROR));

        // consoleLogger 可以记录所有 level 的信息
        logger.message(&quot;进入到订单流程，接收到参数，参数内容为XXXX&quot;, LogLevel.DEBUG);
        logger.message(&quot;订单记录生成.&quot;, LogLevel.INFO);

        // consoleLogger 处理完，fileLogger 要继续处理
        logger.message(&quot;订单详细地址缺失&quot;, LogLevel.WARNING);
        logger.message(&quot;订单省市区信息缺失&quot;, LogLevel.ERROR);

        // consoleLogger 处理完，emailLogger 继续处理
        logger.message(&quot;订单短信通知服务失败&quot;, LogLevel.FUNCTIONAL_ERROR);
        logger.message(&quot;订单已派送.&quot;, LogLevel.FUNCTIONAL_MESSAGE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConsoleLogger、EmailLogger 和 FileLogger 组成一个责任链，分工明确；FileLogger 中包含 EmailLogger 的引用，EmailLogger 中包含 ConsoleLogger 的引用，当前具体 Logger 是否记录日志的判断条件是传入的 log level 是否在它的责任范围内. 最终调用 message 方法时的责任链顺序 &lt;code&gt;ConsoleLogger -&amp;gt; EmailLogger -&amp;gt; FileLogger&lt;/code&gt;. 如果不能很好的理解 Lambda ，我们可以通过接口与实现类的方式实现&lt;/p&gt;
&lt;h2 id=&quot;案例介绍&quot;&gt;案例介绍&lt;/h2&gt;
&lt;p&gt;为什么说责任链模式从我们身边路过无数次，你却忽视它，看下面这两个案例，你也许会一声长叹.&lt;/p&gt;
&lt;h3 id=&quot;filter过滤器&quot;&gt;Filter过滤器&lt;/h3&gt;
&lt;p&gt;下面这段代码有没有很熟悉，没错，我们配置拦截器重写 &lt;code&gt;doFilter&lt;/code&gt; 方法时都会执行下面这段代码，传递给下一个 Filter 进行处理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;chain.doFilter(request, response);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随意定义一个拦截器 CustomFilter，都要执行 &lt;code&gt;chain.doFilter(request, response)&lt;/code&gt; 方法进行 Filter 链的传递&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.servlet.*;
import java.io.IOException;

/**
 * @author tan日拱一兵
 * @date 2019-06-19 13:45
 */
public class CustomFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以 debug 模式启动应用，随意请求一个没有被加入 filter 白名单的接口，都会看到如下的调用栈信息：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-b4d76b56804108aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Xnip2019-06-19_13-53-51.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色标记框的内容是 Tomcat 容器设置的责任链，从 Engine 到 Cotext 再到 Wrapper 都是通过这个责任链传递请求，如下类图所示，他们都实现了 Valve 接口中的 invoke 方法&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-10bb716f40dc65aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Xnip2019-06-19_13-54-39.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但这并不是这里要说明的重点，这里要看的是和我们自定义 Filter 息息相关的蓝色框的内容 ApplicationFilterChain ，我们要了解它是如何应用责任链设计模式的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然是责任链，所有的过滤器是怎样加入到这个链条当中的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;ApplicationFilterChain&lt;/code&gt; 类中定义了一个 &lt;code&gt;ApplicationFilterConfig&lt;/code&gt; 类型的数组，用来保存过滤器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Filters.
 */
private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ApplicationFilterConfig 是什么？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ApplicationFilterConfig 是 Filter 的容器，类的描述是：在 web 第一次启动的时候管理 filter 的实例化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implementation of a &amp;lt;code&amp;gt;javax.servlet.FilterConfig&amp;lt;/code&amp;gt; useful in
 * managing the filter instances instantiated when a web application
 * is first started.
 *
 * @author Craig R. McClanahan
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ApplicationFilterConfig[] 是一个大小为 0 的空数组，那它在什么时候被重新赋值的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;是在 ApplicationFilterChain 类调用 &lt;code&gt;addFilter&lt;/code&gt; 的时候重新赋值的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The int which gives the current number of filters in the chain.
 */
private int n = 0;

public static final int INCREMENT = 10;

/**
 * Add a filter to the set of filters that will be executed in this chain.
 *
 * @param filterConfig The FilterConfig for the servlet to be executed
 */
void addFilter(ApplicationFilterConfig filterConfig) {

    // Prevent the same filter being added multiple times
    for(ApplicationFilterConfig filter:filters)
        if(filter==filterConfig)
            return;

    if (n == filters.length) {
        ApplicationFilterConfig[] newFilters =
            new ApplicationFilterConfig[n + INCREMENT];
        System.arraycopy(filters, 0, newFilters, 0, n);
        filters = newFilters;
    }
    filters[n++] = filterConfig;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量 n 用来记录当前过滤器链里面拥有的过滤器数目，默认情况下 n 等于 0，ApplicationFilterConfig 对象数组的长度也等于0，所以当第一次调用 addFilter() 方法时，&lt;code&gt;if (n == filters.length)&lt;/code&gt; 的条件成立，ApplicationFilterConfig 数组长度被改变。之后 filters[n++] = filterConfig；将变量 filterConfig 放入 ApplicationFilterConfig 数组中并将当前过滤器链里面拥有的过滤器数目+1（注意这里 n++ 的使用）&lt;/p&gt;
&lt;p&gt;有了这些我们看整个链是怎样流转起来的&lt;br/&gt;上图红色框的最顶部调用了 &lt;code&gt;StandardWrapperValve&lt;/code&gt; 的 &lt;code&gt;invoke&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;...
// Create the filter chain for this request
ApplicationFilterChain filterChain =
        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);
...
filterChain.doFilter(request.getRequest(), response.getResponse());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;ApplicationFilterFactory.createFilterChain&lt;/code&gt; 实例化 &lt;code&gt;ApplicationFilterChain&lt;/code&gt; (工厂模式)，调用 &lt;code&gt;filterChain.doFilter&lt;/code&gt; 方法正式进入责任链条，来看该方法，方法内部调用了 &lt;code&gt;internalDoFilter&lt;/code&gt; 方法，来看关键代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The int which is used to maintain the current position
 * in the filter chain.
 */
private int pos = 0;

// Call the next filter if there is one
if (pos &amp;lt; n) {
    ApplicationFilterConfig filterConfig = filters[pos++];
    try {
        Filter filter = filterConfig.getFilter();

        if (request.isAsyncSupported() &amp;amp;&amp;amp; &quot;false&quot;.equalsIgnoreCase(
                filterConfig.getFilterDef().getAsyncSupported())) {
            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);
        }
        if( Globals.IS_SECURITY_ENABLED ) {
            final ServletRequest req = request;
            final ServletResponse res = response;
            Principal principal =
                ((HttpServletRequest) req).getUserPrincipal();

            Object[] args = new Object[]{req, res, this};
            SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal);
        } else {
            filter.doFilter(request, response, this);
        }
    } catch (IOException | ServletException | RuntimeException e) {
        throw e;
    } catch (Throwable e) {
        e = ExceptionUtils.unwrapInvocationTargetException(e);
        ExceptionUtils.handleThrowable(e);
        throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e);
    }
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pos&lt;/code&gt; 变量用来标记 filter chain 执行的当前位置，然后调用 &lt;code&gt;filter.doFilter(request, response, this);&lt;/code&gt; 传递 &lt;code&gt;this&lt;/code&gt; （ApplicationFilterChain）进行链路传递，直至 pos &amp;gt; n 的时候停止 (类似击鼓传花中的鼓声停止)，即所有拦截器都执行完毕。&lt;/p&gt;
&lt;p&gt;继续向下看另外一个从我们身边路过无数次的责任链模式&lt;/p&gt;
&lt;h3 id=&quot;mybatis拦截器&quot;&gt;Mybatis拦截器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YVl20QqUHTXMubr68wXR1A&quot;&gt;Mybatis 拦截器执行过程解析&lt;/a&gt; 中留一个问题彩蛋责任链模式，那在 Mybatis 拦截器中是怎样应用的呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class InterceptorChain {

  private final List&amp;lt;Interceptor&amp;gt; interceptors = new ArrayList&amp;lt;Interceptor&amp;gt;();

  public Object pluginAll(Object target) {
    for (Interceptor interceptor : interceptors) {
      target = interceptor.plugin(target);
    }
    return target;
  }

  public void addInterceptor(Interceptor interceptor) {
    interceptors.add(interceptor);
  }
  
  public List&amp;lt;Interceptor&amp;gt; getInterceptors() {
    return Collections.unmodifiableList(interceptors);
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以 Executor 类型的拦截为例，如果存在多个同类型的拦截器，当执行到 pluginAll 方法时，他们是怎样在责任链条中传递的呢？&lt;br/&gt;调用&lt;code&gt;interceptor.plugin(target)&lt;/code&gt; 为当前 target 生成代理对象，当多个拦截器遍历的时候，也就是会继续为代理对象再生成代理对象，直至遍历结束，拿到最外层的代理对象，触发 &lt;code&gt;invoke&lt;/code&gt; 方法就可以完成链条拦截器的传递，以图来说明一下&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-4c60a920598d727d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Xnip2019-06-19_15-19-36.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了这些，你和责任链设计模式会是灵魂之交吗？&lt;/p&gt;
&lt;h2 id=&quot;总结与思考&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;敲黑板，敲黑板，敲黑板 （重要的事情敲三次黑板）&lt;br/&gt;看了这么多之后，我们要总结出责任链设计模式的关键了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设计一个链条，和抽象处理方法&lt;/li&gt;
&lt;li&gt;将具体处理器初始化到链条中，并做抽象方法具体的实现&lt;/li&gt;
&lt;li&gt;具体处理器之间的引用和处理条件判断&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;设计链条结束标识&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1，2 都可以很模块化设计，3，4 设计可以多种多样，比如文中通过 pos 游标，或嵌套动态代理等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在实际业务中，如果存在相同类型的任务需要顺序执行，我们就可以拆分任务，将任务处理单元最小化，这样易复用，然后串成一个链条，应用责任链设计模式就好了. 同时读框架源码时如果看到 &lt;code&gt;chain&lt;/code&gt; 关键字，也八九不离十是应用责任链设计模式了，看看框架是怎样应用责任链设计模式的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在请你回看文章开头，重新站在上帝视角审视责任链设计模式，什么感觉，欢迎留言交流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Lambda 函数式编程，你可以灵活应用，实现优雅编程吗？&lt;/li&gt;
&lt;li&gt;多个拦截器或过滤器，如果需要特定的责任链顺序，我们都有哪些方式控制顺序？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;那些可以提高效率的工具&quot;&gt;那些可以提高效率的工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-217c0a094787e2dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;a (1).png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vnote&quot;&gt;VNote&lt;/h3&gt;
&lt;p&gt;留言中有朋友让我推荐一款 MarkDown 编辑器，我用过很多种（包括在线的），这次推荐 &lt;a href=&quot;https://vnote.readthedocs.io/zh_CN/latest/&quot;&gt;VNote&lt;/a&gt;, VNote 是一个受Vim启发的更懂程序员和Markdown的一个笔记软件, 都说 vim是最好的编辑器，更懂程序猿，但是多数还是应用在类 Unix 环境的 shell 脚本编写中，熟练使用 vim 也是我们必备的基本功，VNote 满足这一切需求，同时提供非常多方便的快捷键满足日常 MarkDown 的编写. 通过写文字顺路学习 vim，快哉...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-8fdae4137f8dd0d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Xnip2019-06-19_15-56-41.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17985603-699cea14b5d99c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;a (1).png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 13:04:00 +0000</pubDate>
<dc:creator>tan日拱一兵</dc:creator>
<og:description>世界上最遥远的距离，不是生与死，而是它从你的世界路过无数次，你却选择视而不见，你无情，你冷酷啊...... 被你忽略的就是责任链设计模式，希望它再次经过你身旁你会猛的发现，并对它微微一笑......</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11066835.html</dc:identifier>
</item>
<item>
<title>MySQL数据库详解（二）一条SQL更新语句是如何执行的？ - 续杯凉茶</title>
<link>http://www.cnblogs.com/whgk/p/11066798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whgk/p/11066798.html</guid>
<description>&lt;p&gt;​ 前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。&lt;/p&gt;
&lt;p&gt;那么，一条更新语句的执行流程又是怎样的呢？之前你可能经常听 DBA 同事说，MySQL 可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也会不免会好奇，这是怎样做到的呢？&lt;/p&gt;
&lt;p&gt;我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;mysql&amp;gt; create table T(
    ID int primary key, 
    c int
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;mysql&amp;gt; update T set c=c+1 where ID=2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。&lt;/p&gt;
&lt;p&gt;你执行语句前要先连接数据库，这是连接器的工作。&lt;/p&gt;
&lt;p&gt;前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。&lt;/p&gt;
&lt;p&gt;接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用 ID 这个索引。然后，执行器负责具体执行，找到这一行，然后更新。&lt;/p&gt;
&lt;p&gt;与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。&lt;/p&gt;
&lt;h5 id=&quot;重要的日志模块redo-log&quot;&gt;重要的日志模块：redo log&lt;/h5&gt;
&lt;p&gt;不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。&lt;/p&gt;
&lt;p&gt;如果有人要赊账或者还账的话，掌柜一般有两种做法：&lt;br/&gt;一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。&lt;/p&gt;
&lt;p&gt;在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。&lt;/p&gt;
&lt;p&gt;这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？&lt;/p&gt;
&lt;p&gt;同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。&lt;/p&gt;
&lt;p&gt;而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。&lt;/p&gt;
&lt;p&gt;具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。&lt;/p&gt;
&lt;p&gt;如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。&lt;/p&gt;
&lt;p&gt;与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874710/201906/874710-20190621203317414-920655168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;wirte pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。&lt;/p&gt;
&lt;p&gt;checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。&lt;/p&gt;
&lt;p&gt;write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。&lt;/p&gt;
&lt;p&gt;有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。&lt;/p&gt;
&lt;p&gt;要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。&lt;/p&gt;
&lt;h5 id=&quot;重要的日志模块binlog&quot;&gt;重要的日志模块：binlog&lt;/h5&gt;
&lt;p&gt;前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。我想你肯定会问，为什么会有两份日志呢？&lt;/p&gt;
&lt;p&gt;因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。&lt;/p&gt;
&lt;p&gt;这两种日志有以下三点不同。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。&lt;/li&gt;
&lt;li&gt;redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。&lt;/li&gt;
&lt;li&gt;redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update语句时的内部流程。&lt;/li&gt;
&lt;li&gt;执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。&lt;/li&gt;
&lt;li&gt;执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。&lt;/li&gt;
&lt;li&gt;引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redolog 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。&lt;/li&gt;
&lt;li&gt;执行器生成这个操作的 binlog，并把 binlog 写入磁盘。&lt;/li&gt;
&lt;li&gt;执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。这里我给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874710/201906/874710-20190621204341319-1213541380.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可能注意到了，最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是&quot;两阶段提交&quot;。&lt;/p&gt;
&lt;h5 id=&quot;两阶段提交&quot;&gt;两阶段提交&lt;/h5&gt;
&lt;p&gt;为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：怎样让数据库恢复到半个月内任意一秒的状态？&lt;/p&gt;
&lt;p&gt;前面我们说过了，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。&lt;/p&gt;
&lt;p&gt;当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：&lt;br/&gt;首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。&lt;/p&gt;
&lt;p&gt;这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。&lt;/p&gt;
&lt;p&gt;好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。&lt;/p&gt;
&lt;p&gt;由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。&lt;/p&gt;
&lt;p&gt;仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。&lt;/li&gt;
&lt;li&gt;先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。&lt;/li&gt;
&lt;li&gt;可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。&lt;br/&gt;你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;小结&quot;&gt;小结&lt;/h5&gt;
&lt;p&gt;今天，我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。&lt;/p&gt;
&lt;p&gt;sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。&lt;/p&gt;
&lt;p&gt;我还跟你介绍了与 MySQL 日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？&lt;/p&gt;
</description>
<pubDate>Fri, 21 Jun 2019 12:55:00 +0000</pubDate>
<dc:creator>续杯凉茶</dc:creator>
<og:description>​ 前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。 那么，一条更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whgk/p/11066798.html</dc:identifier>
</item>
</channel>
</rss>