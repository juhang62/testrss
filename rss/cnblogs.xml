<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Win10安装Linux系统 - 酷学大叔</title>
<link>http://www.cnblogs.com/az4215/p/11470848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/az4215/p/11470848.html</guid>
<description>&lt;p&gt;&lt;span&gt;windows系统安装虚拟机，常见的是利用VMware Workstation这款软件来进行安装。在未接触Docker之前，我一直通过这款软件来进行管理的。docker是运行在linux环境下的，那怎样才能让docker运行在Windows环境下呢，于是windows提供了Hyper-V管理器并自动安装了DockerDesktopVM的虚拟机，运行docker时会自动启动Hyper-V下的虚拟机，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906075035522-143968399.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Win10中如何安装Hyper-V呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906075415350-793777810.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;432&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt; 对，就是这么简单。既然Hyper-V是虚拟机管理器，那当然可以安装自己想要的虚拟机系统，只要你的电脑够强悍，这里我将演示centos7的安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、打开Hyper-V管理器，在右侧点击新增&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906080353431-578053659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、出现如下界面，点击下一步&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906080455314-1584231421.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、指定虚拟机名称以及虚拟机存储位置，点击下一步。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906080721639-724199415.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、Hyper-V的版本有2代，第二代虚拟机启动更快，模拟加载的硬件资源更少，性能更高，但是不是所有的机器都支持第二代，所以建议默认选择第一代。点击下一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906081039595-1868851817.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5、为虚拟机分配运行内存，勾选动态分配内存，虚拟机会使用系统内存，点击下一步。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906081144990-233345519.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、为虚拟机配置网络，这一步可以先行跳过，直接进入下一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906081439403-1628150928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、为虚拟机分配磁盘空间，可以直接默认，也可以自定义修改名称及存储位置。点击下一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906081602218-311005320.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 8、这里我们采用镜像安装。先搜索centos镜像文件，下载到本地，点击浏览，选择下载的镜像文件。点击下一步或者直接点击完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906082124305-1574030956.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、安装的虚拟机信息。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906082221352-925510500.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10、最后我们进行虚拟机的网络配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445321/201909/1445321-20190906082541117-2016204411.png&quot; alt=&quot;&quot; width=&quot;1501&quot; height=&quot;912&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由图我们可以看到虚拟机有三种类型，外部、内部及专用，那这些分别是什么状态呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内部：即（NAT模式），Virtual Switch 不能连接物理网络适配器，只能用于在本地物理机上创建的VM，用于VM和本地物理机的通信，见 &lt;a href=&quot;https://www.cnblogs.com/az4215/p/11416050.html&quot;&gt;https://www.cnblogs.com/az4215/p/11416050.html&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　外部：将Virtual Switch绑定到物理网络适配器上，这样，VM能够通过访问物理网络和外网通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　专用：Vitrual Switch 只能用于在本地物理机上创建的VM，使VMs之间能够互相通信。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Sep 2019 00:35:00 +0000</pubDate>
<dc:creator>酷学大叔</dc:creator>
<og:description>windows系统安装虚拟机，常见的是利用VMware Workstation这款软件来进行安装。在未接触Docker之前，我一直通过这款软件来进行管理的。docker是运行在linux环境下的，那怎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/az4215/p/11470848.html</dc:identifier>
</item>
<item>
<title>StackOverflow 周报 - 与高关注的问题过过招（Java） - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11470402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11470402.html</guid>
<description>&lt;p&gt;&lt;span&gt;本篇文章是 Stack Overflow 周报的第二周，共收集了 4 道高关注的问题和对应的高赞回答。公众号&lt;strong&gt;「渡码」&lt;/strong&gt;为日更，欢迎关注。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;DAY1.  serialVersionUID 的重要性  &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;关注: 2820，最高赞: 2152&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇文章介绍一下 Java 中 serialVersionUID 属性的含义以及重要性。从属性可以看出它与序列化有关系，所以在  java.io.Serializable 接口的注释中对它有详细的介绍，下面我们对照文档注释来学习一下。Java 中每个可序列化的类都有一个版本号与之关联，这个版本号就是 serialVersionUID。它在对象反序列化时使用， 用于判断该类的发送方和接收方的 serialVersionUID 是否一致，如果接收方装载的类的 serialVersionUID 与发送方不一致，则抛出 InvalidClassException 异常。一个可序列化的类可以显示地声明 serialVersionUID 属性，但必须是 static，final，long 修饰的，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ANY-ACCESS-MODIFIER &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 42L;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面结合实际的例子来看看 serialVersionUID 的用法以及作用，上面说了 serialVersionUID 属性是定义在可序列化的类中，所以我们的类需要实现 java.io.Serializable 接口。因此，我们定义的 Person 类如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs.duma.week2;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 42L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; age + &quot;,&quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来，我们在定义两个方法分别用来序列化和反序列化，序列化方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 Person 对象序列化后存到文件&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ser() {
    Person p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(28, &quot;duma&quot;&lt;span&gt;);
    System.out.println(&lt;/span&gt;&quot;person Seria:&quot; +&lt;span&gt; p);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        FileOutputStream fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;person.txt&quot;&lt;span&gt;);
        ObjectOutputStream oos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(fos);
        oos.writeObject(p);
        oos.flush();
        oos.close();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        e.printStackTrace();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;序列化方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从文件中反序列化出 Person 对象&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deser() {
    Person p;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        FileInputStream fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;person.txt&quot;&lt;span&gt;);
        ObjectInputStream ois &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(fis);
        p &lt;/span&gt;=&lt;span&gt; (Person) ois.readObject();
        ois.close();
        System.out.println(p.toString());
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IOException |&lt;span&gt; ClassNotFoundException e) {
        e.printStackTrace();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;先调用 ser 方法，成功后可以看到项目根目录下生成了 person.txt 文件，然后在调用 deser 方法可以成功反序列化 Person 对象并输出结果。这波操作就是正常的序列化和反序列化操作。回到今天的主题，为了验证 serialVersionUID 属性的作用，我们可以在调用完 ser 方法后，先修改 serialVersionUID 值，然后再调用 deser 方法，这时就会抛出 java.io.InvalidClassException 异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;明白了 serialVersionUID 属性的含义和作用，接下来我们再来看看它的重要性。在我们的例子中我们显式地定义了 serialVersionUID 属性，如果没有显式地指定 serialVersionUID，序列化运行时会根据类的信息计算一个默认值，《Effective Java》一书中提到这些信息包括类名、实现的接口、public和protected的成员。虽然有默认值，但 Java 官方文档强烈建议我们显式地定义 serialVersionUID 属性，因为默认的 serialVersionUID 依赖类的信息，而类的信息可能在不同编译器下会不同。因此，如果发送方和接收方使用的编译器不同，有可能导致默认的 serialVersionUID 不一致从而导致接收方无法正常反序列化，同时 Java 官方也建议使用 private 修饰 serialVersionUID，这样可以防止子类继承这个属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于上面提到的《Effective Java》一书中的内容，我们可以做个简单的验证。因为生成默认的 serialVersionUID 会用到 public 成员信息，那我们改变成员变量就会导致 serialVersionUID 值改变。首先我们将 Person 类中的 serialVersionUID 属性删掉，调用 ser 方法序列化。然后在 Person 中加一个成员，比如：public String nickname = &quot;zhangsan&quot;; ，然后调用 deser 方法，可以看到程序抛出 java.io.InvalidClassException 异常。这同时也警示我们尽量显示地定义 serialVersionUID 属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjcwMjk4OA==&amp;amp;mid=2247483838&amp;amp;idx=1&amp;amp;sn=38a0fae303709ff41d9179d3989b5321&amp;amp;chksm=a6a376dd91d4ffcb34a5ec0ace9e0035079a4b356df99a66dc9592e2b8b136f59a4dde0df66f&amp;amp;token=428338994&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;查看原文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;DAY2.  创建线程到底用哪种方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;关注: 1972，最高赞: 1583&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道 Java 实现线程的方式有两种， 一种是继承 Thread 类，另一种是实现 Runnable 接口。那么问题来了，这两种方式有什么区别呢？我们应该用哪种方式更好呢？下面先简单看下这两种方式的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 继承 Thread 类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 实现 Runnable 接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Workder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对于这两种方式的选择，Stack Overflow 的回答者普遍认为优先选择实现 Runnable 接口的方式，理由如下：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在面向对象中，继承意味着添加新功能、修改或者改进父类的行为，如果我们没有这方面的改动，那就尽量避免使用继承，因为我们的代码只是单纯需要执行一些任务，而不需要改造 Thread 的行为，所以继承 Runnable 接口更合理，所以上面代码中继承的方式类名是 Thread1 是一种（is a）Thread，而实现 Runnable 接口的类名是 Worker，一个 Worker 对象（工人）的“工作”逻辑可以放在 run 方法中，然而这并不意味这这个工人 7*24 小时一直工作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于 Java 中不支持多继承，因此继承 Thread 类意味着无法在继承其他的类，影响代码的扩展性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;继承 Thread 意味着每个线程都有一个唯一的 Thread 的对象与之对应，而实现 Runnable 接口可以让多个线程共享同一个对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;总之，如果我们的类定位在单纯地执行任务，并不需要改造 Thread 类，那我们就应该实现 Runnable 接口。反之，如果我们需要改造 Thread 类，或者它是一种（is a）线程，那我们就继承 Thread 类。我目前正在写的一本关于 RPC 的书中，创建线程就是以继承 Thread 为主。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjcwMjk4OA==&amp;amp;mid=2247483849&amp;amp;idx=1&amp;amp;sn=0a7715e39b23e82958161eabaf25d913&amp;amp;chksm=a6a376aa91d4ffbce1c04b4032840c35b5c0e09b503b5ea1b84e9db65b4c71e1610001c6ff9f&amp;amp;token=428338994&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;查看原文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;DAY3. 反射非用不可吗&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;关注: 1960，最高赞: 1611&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相信有 Java 基础的朋友都知道反射的概念。然而如果你仅仅了解概念，而在工程实践中没有应用的话，那可能总是感觉有层窗户纸模模糊糊的。我之前学习反射就有这种感觉。那么今天这篇文章我就完整地梳理一下反射的概念和作用，结合 Hadoop RPC 框架聊聊反射为什么非用不可或者说用了反射是不是给程序带来了非常大的便利性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们看定义：反射是语言提供了一种在运行时检查和动态调用类、方法和属性的能力。基于这个能力，反射一般大量应用在框架中，如：Spring，Hadoop。从反射的定义我们可能会问一个问题，为什么要在运行时动态地调用？既然 Java 是静态语言，任何需要调用的东西为什么不在编译时就确定好呢？这个问题也就是在问反射的作用是什么以及是不是非用不可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以简单猜想一下，以类的反射为例，当我们使用第三方框架时，框架并不知道用户定义了什么类，因此框架想要使用用户的类，只能在运行时动态地检查类是否存在，再进行调用。下面以 Hadoop 的 MapReduce 框架为例，看一下它使用反射的一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户自定义的类如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要继承 Mapper 基类，Hadoop 框架才能正常使用它&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WordCountMapper
        &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;Object, Text, Text, IntWritable&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hadoop 框架会在创建 WordCountMapper 对象后调用 map 方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; map(Object key, Text value, Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据处理逻辑&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Hadoop 框架通过反射调用 WordCountMapper 的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; taskContext.getMapperClass() 为运行时用户传入的类，WordCountMapper&lt;/span&gt;
org.apache.hadoop.mapreduce.Mapper&amp;lt;INKEY,INVALUE,OUTKEY,OUTVALUE&amp;gt; mapper =&lt;span&gt;
  (org.apache.hadoop.mapreduce.Mapper&lt;/span&gt;&amp;lt;INKEY,INVALUE,OUTKEY,OUTVALUE&amp;gt;&lt;span&gt;)
    ReflectionUtils.newInstance(taskContext.getMapperClass(), job);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run 方法中循环调用 map 方法处理数据&lt;/span&gt;
mapper.run(mapperContext);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面是 Hadoop 代码的一部分，它将类的反射代码封装在 ReflectionUtils.newInstance 方法中，该方法用类的默认构造方法动态地创建一个对象。上述代码中该方法创建的对象被强转为 Mapper 类，这就是为什么因为我们的 WordCounterMapper 类要继承 Mapper。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，可以看到 Hadoop 框架在编译的时候并不知道用户定义了WordCountMapper 类，只能在运行时根据配置动态地检查、调用。当然为了框架能够正常使用我们定义的类，就需要定义类时符合框架定义的规范，在我们的例子中需要遵循的规范是实现一个 Mapper 基类，并且需要有默认构造函数。如果我们在代码中修改 WordCountMapper 的构造函数，那就不符合框架的规范，反射就会报错，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WordCountMapper
        &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;Object, Text, Text, IntWritable&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有参构造函数覆盖默认构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; WordCountMapper(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a) {
        a &lt;/span&gt;= 100&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次运行，当 Hadoop 调用 ReflectionUtils.newInstance 时找不默认构造函数便会以下报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Error: java.lang.RuntimeException: java.lang.NoSuchMethodException: com.cnblogs.duma.mapreduce.WordCountMapper.&amp;lt;init&amp;gt;()
    at org.apache.hadoop.util.ReflectionUtils.newInstance(ReflectionUtils.java:&lt;/span&gt;135&lt;span&gt;)
    at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:&lt;/span&gt;751)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来，再举一个动态调用方法的例子，假设我们要在运行时才能检查并调用某方法，写法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Method method = foo.getClass().getMethod(&quot;doSomething&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
method.invoke(foo, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种场景也是框架比较喜欢用的，比如：Java 的单元测试框架 Junit4，通过反射检查类中带有 @Test 注解的方法，然后调用他们运行单元测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面两个例子可以看到为什么框架对反射如此钟情。框架不需要关心用户定义了什么类，只要用户的代码符合框架定义的规范，框架就会在运行时进行检查，并按照自己定义的规范调用代码即可。因此反射可以让框架和用户的应用解耦，使得开发更方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjcwMjk4OA==&amp;amp;mid=2247483859&amp;amp;idx=1&amp;amp;sn=919880091ed358bc6104e0da58a84a01&amp;amp;chksm=a6a376b091d4ffa6169a110dc341bbecf7d0dcaf78ce7db65c28e2fe961d466101dc547e9a21&amp;amp;token=428338994&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;查看原文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;DAY4. 一行代码搞定数组的初始化、搜索、打印&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们平时遇到的好多问题可能一行代码就搞定了。平时遇到问题可以多想想是不是已经有工具已经实现了， 如果有的话可以直接拿来用，避免重复造轮子。这篇文章今天发在公众号上，算是关注公众号读者的一个福利吧。后续再发博客。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上便是 Stack Overflow 的第二周周报，希望对你有用，后续会继续更新，如果想看日更内容欢迎关注公众号。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;公众号&lt;strong&gt;「渡码」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201905/1129006-20190519220125818-12935098.png&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Sep 2019 00:35:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>本篇文章是 Stack Overflow 周报的第二周，共收集了 4 道高关注的问题和对应的高赞回答。公众号「渡码」为日更，欢迎关注。 DAY1. serialVersionUID 的重要性 关注:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11470402.html</dc:identifier>
</item>
<item>
<title>深入浅出TypeScript（3）- 函数重载和泛型 - 受戒人</title>
<link>http://www.cnblogs.com/qixingduanyan/p/11470851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixingduanyan/p/11470851.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;面向对象特性中，最根本的就是面向对象的三大基本特征：封装、继承、多态。同时，TypeScript中也存在多态的使用，比如函数重载，今天我们先看一下函数重载以及泛型的概念。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说，函数重载具有两个特征：名称相同，参数不同（参数类型、个数不同。）所以，函数重载的解释应该是具备不同参数的同名函数。&lt;strong&gt;注意：函数重载是多态的一种体现&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;TypeScript中，函数重载主要包括两部分：函数声明，和函数实现。函数声明主要是TSC解析的一种声明体现，实际编译中，并不会编译成具体代码。我们可以通过TypeScript的&lt;a href=&quot;https://www.tslang.cn/play/index.html&quot;&gt;playground&lt;/a&gt;来查看。&lt;/p&gt;
&lt;h2&gt;1、参数不同的函数重载&lt;/h2&gt;
&lt;p&gt;加入我们有一个打印函数，可以打印输入的一个string信息，我们可以将函数声明如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 函数声明
function print(info: string): void;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而还有另一种情况，就是输入的有可能是两个string类型的参数，我们都需要打印下来，于是我们的函数声明可以是这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 函数声明
function print(info: string, message: string): void;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而当这两种声明，同时存在TypeScript的声明文件中，我们就需要用函数重载来实现，这是JavaScript没有的特性。&lt;/p&gt;
&lt;p&gt;而实现函数重载的要求就是，我们要在一个更为宽泛的范围去实现函数重载，所以，TypeScript中的我们实现print函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 在更宽泛的范围，我们用可选参数来实现重载
function print(info: string, message ?: string) {
    let printValue: string = info;
    if(message){
        printValue += message;
    }
    console.log(printValue);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2、参数个数相同，但类型不同的函数重载&lt;/h2&gt;
&lt;p&gt;函数重载的第二种情况，参数个数相同，但是参数类型不一样，这种情况下也可以通过重载来实现。&lt;/p&gt;
&lt;p&gt;比如，上述打印信息的函数，有可能接受的输入是一个string字符串，也有可能输入接受的是一个number类型的数字，那么我们第一步的函数声明便是如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function print(info: string): void;
function print(num: number): void;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上可以看到，我们的函数声明中，参数的类型是不同的，在这种情况下，TypeScript是如何在一个宽泛的范围内实现呢？这里就要用到联合类型，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function print(message: string | number) {
    console.log(message)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从我们实现两个函数重载的例子可以看出，我们在TypeScript中实现函数重载的方式分别是利用了TypeScript中的两个类型特性：可选类型以及联合类型。&lt;/p&gt;
&lt;p&gt;所以，如果从便捷的角度来讲，我们如果是遇到了类似的实现，其实可以直接使用可选参数和联合类型来实现自己想要的函数效果。&lt;/p&gt;

&lt;p&gt;在函数重载的不同参数类型，相同参数个数的重载中，我们介绍了它的重载实现方式，利用联合类型来实现，但是如果要打印出来的类型有很多，那么我们最终只能用any类型来实现print函数了。&lt;/p&gt;
&lt;p&gt;但是，如果用any类型实现一个可以打印任意值的print函数，这样又让我们的函数变得类型缺失，这个时候，泛型这种解决方案也就应运而生。&lt;/p&gt;

&lt;p&gt;泛型指的是一种情况：定义是可以是任意类型，但是在编译的时候，必须有明确的类型。&lt;/p&gt;
&lt;p&gt;有点绕，那么我们用泛型来实现上述第二个函数重载的例子，结合这个例子，可以体会一下这句话的含义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function print&amp;lt;T&amp;gt;(message: T) {
     console.log(message);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这个函数中，泛型表示的方式是：函数名称&amp;lt;泛型参数&amp;gt;（arg: 泛型参数）。&lt;/p&gt;
&lt;p&gt;这个函数在声明之后，函数类型是一个泛型。我们可以传递任意的类型参数到print函数中，但是当我们传递一个string类型的时候，这个函数便是一个string类型的函数了，已经在tsc编译阶段开始明确指定类型，这是和any函数所不一样的地方。&lt;/p&gt;

&lt;p&gt;首先，我们不用定义过多的联合类型来让函数变得复杂而又冗长，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function print(arg: string | number | boolean | array | 自定义类型) {
    // 我们应该尽量避免多类型的传值函数，此时我们应该用泛型来实现。
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其次，泛型可以是任何类型，但是在编译时一定是类型确定的。而且泛型也可以有继承属性，可以继承接口获取更多的类型定义等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function print&amp;lt;T extends Interface&amp;gt; (arg: T) {
    // 通过继承，来让泛型有更多的可变性。
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，类型别名也可以是泛型，如我们可以做如下类型定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
type Person&amp;lt;T&amp;gt; = { age: T } 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;总体来说，利用泛型，也是为了更准确的让我们使用类型思维，是为了更准确的描述参数、或者声明的类型准确性，如果能够熟练的掌握泛型，那么在TypeScript的开发中，将会有不一样的体验。&lt;/p&gt;
&lt;p&gt;而常常以类型思维去思考JavaScript中的函数或者变量，我们也就会减少很多因为类型方面的犯错，使得我们的项目不仅更好的测试，也会更少的出错。&lt;/p&gt;
&lt;p&gt;不得不说，在大前端领域，类型思维的缺失的确是个普遍现象，如果将类型思维捡起来，将会是一个可能存在着痛苦的过程，但是我相信，如果你做到了，那么你不仅会在开发代码的时候会更谨慎，能开发出更优秀的应用程序，还会体验到前端行业别样的魅力。&lt;/p&gt;
&lt;p&gt;我的博客地址：&lt;a href=&quot;http://www.gaoyunjiao.fun/?p=130&quot;&gt;http://www.gaoyunjiao.fun/?p=130&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Sep 2019 00:26:00 +0000</pubDate>
<dc:creator>受戒人</dc:creator>
<og:description>面向对象特性中，最根本的就是面向对象的三大基本特征：封装、继承、多态。同时，TypeScript中也存在多态的使用，比如函数重载，今天我们先看一下函数重载以及泛型的概念。 什么是函数重载 简单来说，函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qixingduanyan/p/11470851.html</dc:identifier>
</item>
<item>
<title>听说你不会调参？TextCNN的优化经验Tricks汇总 - ModifyBlog</title>
<link>http://www.cnblogs.com/ModifyRong/p/11442661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ModifyRong/p/11442661.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;前两篇可见：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ModifyRong/p/11442595.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;TextCNN代码详解(附测试数据集以及GitHub 地址)（二）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    大家如果跑过模型的话，不论是demo还是实际项目，通常的情况都是先跑一次看看效果，然后针对某些效果不好的地方做一些调优，俗称「调参狗」，调优有很多方法，基本的方法是：&lt;strong&gt;根据模型在测试集合的badcase 来分析有没有共性的问题&lt;/strong&gt;，譬如做一个文本分类，我们在训练集上效果很好，但是测试集上，某一类的文本总是容易判断错误，那么这就属于一个共性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何解决这种问题呢？两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从特征的角度优化&lt;/span&gt;。我们可以通过做一些特征分析等来找到有区分度的特征来进行优化。特征与特征之间如何结合，如何判断与测试结果是否有相关性，都是我们重点需要分析的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从模型结构上调整&lt;/span&gt;。深度学习虽然大家可能认为是一个黑盒，可解释性差，但是不同的网络模型确实能对结果产生一些变化。我们可以从网络模型上优化，适当调整结构，再来训练看测试的效果。不断的迭代再调整。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;     这是我们调优的基本思路和两个着手点。如果只是按照常规的手段直接去调参，往往达不到我们想要的效果，所以通过分析bascase，可以针对性的解决问题，更加符合我们的应用场景和实际项目。如果单纯的通过使用更fancy的模型来替换老模型来提高准确率，无异盲人摸像，很可能达不到我们最终想要的效果。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;具体调优方法介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：明确所有类别预测错误的badcase&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    假设我们的任务是一个三分类的任务，其中一个类别是&quot;movie&quot;，即判断一个query 是不是属于视频。在测试集的预测结果中，有部分预测错误，如图一所示&lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;label&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;predict&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;错误分类原因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;movie&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;music&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;标注问题&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;movie&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;book&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;数据分布不平衡&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;movie&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;music&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;缺乏先验知识&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;movie&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;book&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;过于依赖A特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;movie&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;book&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;181&quot; height=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;数据分布不平衡&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;分析示例一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    从表中我们可以看到，一共有5条文本，原label是movie，预测结果与label都不相同，其中3条预测成book、2条预测成music等，这些就属于“badcase”。除了可以统计这一个label的错误预测，也可以把其他类别的badcase全部统一集合，做成list来具体分析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2: 分析badcse预测错误的共性原因&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们把这些badcase挑出来以后，需要分析每个预测错误的badcase的具体原因是什么，譬如，表中有两条预测成book的原因是“数据分布不一致”，这就属于找到badcase的共性。把原始的特征拿出来再分析，就可以分析出预测错误的共性是什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    总结出共性原因后，按照错误原因的频次从高到低排列，可以看到我们当前最需要解决的问题有哪些。假设我们一共分析出四类原因，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;训练集合和测试集合部分特征抽取方式不一致&lt;/span&gt;，如训练集合是用python 来实现抽取特征，但是部署到线上的时候是用java实现来抽取特征，训练和预测抽取特征的时候不是同一套代码，虽然理论上两者应该一致，但是实现的时候由于语言差异以及二次开发的差异很容易造成某一特征在java版本和python版本有不同的结果 (占比约&lt;strong&gt;40%&lt;/strong&gt;) &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;最后的结果过于依赖某一特征&lt;/span&gt;，比如我们的模型过于依赖A特征，但是A 特征的准确率只有88%左右，导致A特征的准确率成了我们模型优化的瓶颈 (占比约&lt;strong&gt;30%&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;泛化能力较差&lt;/span&gt;，比如&quot;我要看黄渤的电影&quot;可以判别正确，但是&quot;我要看周星驰的电影&quot;就判别不对 (占比约&lt;strong&gt;20%&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;缺乏先验知识&lt;/span&gt;，比如&quot;青花瓷&quot; 更容易出现在音乐当中, 而不是出现在baike 当中，但是我们在训练数据当中并没有特征可以体现这一先验知识(占比约&lt;strong&gt;10%&lt;/strong&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3: 针对原因，专项优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;原因一：训练集合和测试集合部分特征抽取方式不一致&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;原因二：过于依赖效果不佳的特征&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;优化方法&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;优化结果&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;针对方法1，效果提升了0.11%，可以认为在这里随机扔掉30%的所有特征(包括A特征),让训练结果与A特征不强相关&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;针对方法2，效果提升了0.29%，因为我们只是过于依赖A特征,并没有过分依赖其他特征，故只在数据预处理的随机去掉10%的A特征，更有针对性的&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原因三：泛化能力差&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;优化方法&lt;/span&gt;：增加槽位抽取：针对部分query, 增加槽位抽取的处理，比如将&quot;黄渤&quot;, &quot;周星驰&quot; 等映射为aritist. 这样此类query, 模型见到的都是 我要看artist的电影，不存在缺乏泛化能力的问题. 瓶颈在于槽位抽取的准确率。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;优化结果&lt;/span&gt;：没有单独实验, 增加槽位抽取后共同实验，分析badcase发现此类问题基本解决&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;原因四：缺乏先验知识&lt;/span&gt;&lt;/h4&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;优化方法&lt;/span&gt;：引入200万外部词表以及 计算”青花瓷“在整体语料中出现在其他类别的频率来部分解决这个问题&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;优化结果&lt;/span&gt;：模型提升了0.5%&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.模型调优实操&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1) 模型优化术语说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在我们下面行文中，会有一些术语，为了方便说明我们先提前解释一下&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;baseline&lt;/span&gt;: 最开始的实验结果, 后续所有的实验结果，都会和baseline的结果进行对比，来体现每一次实验优化的提升&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;baseline diff&lt;/span&gt;：相比baseline的结果, 我们实验的提升有多少&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;测试集acc&lt;/span&gt;：即我们的模型在测试集合的准确率&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;epoch&lt;/span&gt; :一个epoch 表示将将所有训练样本学习一遍&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;iteration(step)或者叫迭代步数&lt;/span&gt;: 表示运行一次iteration或者(step) 更新一次参数。每运行一次iteration 都需要一个batch size 的数据进行学习，学习完一个batch size 的数据，更新一次参数, 下面的所有实验 迭代步数全部为26万步&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;batch size&lt;/span&gt;: 迭代一次需要的样本量，下面的实验,batch size 全部设置为64&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666027/201909/666027-20190901160632282-904310446.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;举例说明&lt;/span&gt;：exampleNums(样本数) = 100000, epoch = 64, batch size = 64, 那么iteration = 100000&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;2) 模型优化过程说明&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;实验BaseLine&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;无论是论文还是日常的工作，最首要一点是跑出baseline 即我们实验的起点，我们本次的baseline 即不对textCNN的网络结构做任何调整在我们测试集合的准确率&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验0 baseline 测试基本参数在测试集合的表现&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;无任何修改&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.14%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;优化实验一：修改embedding_dim长度&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;Embeddinga_dim :128, 即将我们的query 映射成向量的时候，向量本身的维度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数调整：我们将query 初始化成embedding的时候，修改了embed_dim 从128降低到64,相比于baseline 并没有明显的提升，降低了0.17%，在这里我们希望了解不同的向量维度对最后的实验结果的影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验一 修改测试embed_dim 长度对最后结果的影响&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;修改  embed_dim 128 -&amp;gt; 64&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;84.97%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;-0.17%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;优化实验二：&lt;/strong&gt;&lt;strong&gt;在全连接层增加dropout层，keep_rate = 0.7&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;keep rate 是dropout 的一个参数即：表示本层要保留多少比例神经单元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数调整：我们在前面的分析当中发现，badcase 与A 特征高度相关，于是在最后的全链接层增加dropout，并将keep_rate 设置为0.7，即随机丢掉30%的数据，相比baseline有0.11%的提升&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验二 在全连接层增加dropout 层，keep_rate = 0.7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;在全连接层增加dropout层, keep_rate = 0.7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.25%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+0.11%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;优化实验三：&lt;/strong&gt;&lt;strong&gt;在全连接层增加dropout层，keep_rate = 0.5&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;参数调整:在实验二的基础上，我们希望测试丢掉更多的数据，是否会有更加明显的提升，发现反而降低了0.04%,原因待进一步探究&lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验三 在全连接层增加dropout 层，keep_rate = 0.5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;在全连接层增加dropout层, keep_rate = 0.5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.09%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;-0.04%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt;优化实验四：随机去掉10%A特征信&lt;strong&gt;息&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;参数调整：在实验三的基础上，进一步思考其实我们只是过于依赖A特征, 并没有过分依赖其他特征，故只在数据预处理的时候，随机去掉10%的A特征，相比baseline 提升0.29%&lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验四 随机去掉10% A特征 打分&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在数据增广的时候，设置概率值, 如果 随机数小于0.1就不输出所有A特征信息, 如果随机数高于该概率值就输出打分信息&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.43%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+0.29%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt;优化实验五：限制高频query权重&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;参数调整：我们在实验的时候，会对数据数据重采样，使之符合一定的分布，在重采样的时候，我们限制了部分query的权重，相比baseline 提升0.03%，这个的目的是增加数据的多样性&lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验五 限制高频query 权重&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在数据增广的时候，限制高频query&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.17%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+0.03%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;优化实验六：&lt;/strong&gt;&lt;strong&gt;随机去掉20%A特征&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;参数调整：在实验四的基础上，在数据预处理的时候，随机去掉20%的A特征，相比baseline 提升0.28%， 并没有优于随机去掉10%，最终选择随机去掉10%A特征&lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验六 随机去掉20% A 特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在数据增广的时候，设置概率值, 如果 随机数小于0.2就不输出A特征, 如果随机数高于该概率值就输出A 特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.42%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+0.28%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;优化实验七：&lt;/strong&gt;&lt;strong&gt;随机去掉10%A特征，使用一致的特征抽取方式&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;参数调整：在实验四的基础上，我们分析了测试集合与训练集合特征抽取不一致的来源，统一来源，相比baseline 提升了0.64%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;811&quot; height=&quot;15&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验七 随机去掉10% A特征 使用一致的特征抽取方式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;311&quot; height=&quot;15&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在数据增广的时候，设置概率值, 如果 随机数小于0.1就不输出A特征, 如果随机数高于该概率值就输出A特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;111&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;85.78%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+0.64%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;优化实验八：随机去掉10% A 特征，使用一致的特征抽取方式，引入B特征&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数调整：在实验七的基础上，我们进一步分析出B特征对badcase 有很好的区分度，将B特征引入训练，相比baseline 提升了1.14%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;4&quot; width=&quot;801&quot; height=&quot;19&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实验八 随机去掉10% A 特征 使用一致的特征抽取方式，引入B特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;300&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;修改内容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;123&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;测试集acc&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;迭代步数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;baseline diff&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;300&quot; height=&quot;15&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;在数据增广的时候，设置概率值, 如果随机数小于0.1就不输出A特征, 如果随机数高于该概率值就输出A特征，训练与测试集合使用一致的特征抽取方式，额外引入B特征&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;123&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;86.28%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;79&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;26w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;172&quot; height=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;+1.14%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;   这篇文章主要总结了文本分类算法TextCNN调优的方法，先给大家分享了下一般基本做调优我们会采取什么方法——找到badcase，分析共性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析共性问题后，可以从&lt;strong&gt;模型和特征&lt;/strong&gt;两个方面去优化。在这里我们以文本分类为例，针对具体出现的badcase，我们总结了四个原因：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;抽取方式差异&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;过于依赖某个特征&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;泛化能力差&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;缺乏先验知识&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;    这些问题可能不仅仅在文本分类这个领域中出现，在其他的应用场景中也可能会出现。那么，具体如何优化呢，我们做了八个实验来解决问题：其中实验五，实验八是从数据层面来优化模型，其余的都是从模型方面来优化&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;8&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;实验一：我们通过&lt;strong&gt;修改embedding_dim长度&lt;/strong&gt;希望了解不同的向量维度对最后的实验结果的影响，发现embedding_dim 降低到64会对最后结果有比较明显的影响，下次要实验一下embedding dim 到512 会不会对实验结果有提升&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;实验二：在全连接层增加dropout 层，keep_rate = 0.7，随机丢掉30%，来降低最后结果与A特征相关性&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;实验三：在全连接层增加dropout 层，keep_rate = 0.5，随机丢掉50%，来降低最后结果与A特征相关性&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;实验四：只在数据预处理的时候，随机去掉10%的A特征，相比baseline 提升&lt;span&gt;0.29%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;实验五：对数据数据重采样，在重采样的时候，限制了部分query的权重，相比baseline 提升0.03%，目的是增加数据的多样性，提升了&lt;span&gt;0.03%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;实验六：在实验四的基础上，随机去掉20%的A特征，相比baseline 提升&lt;span&gt;0.28%&lt;/span&gt;， 并没有优于随机去掉&lt;span&gt;10%&lt;/span&gt;，最终选择随机去掉10%A特征&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;实验七：在实验四的基础上，统一来源，相比baseline 提升了&lt;span&gt;0.64%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;实验八：在实验七的基础上，将B特征引入训练，相比baseline 提升了&lt;span&gt;1.14%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;    大家不要觉得这些实验很多觉得很麻烦，其实在实际工作中，通常来说，最有效的方法是：分析badcase，引入更有区分度的特征，如果你的项目效果不好，再试试引入dropout等等。具体的参数如何调整，是根据具体的项目而定，但是不管如何优化，都要先跑baseline。在baseline的基础上再进行优化。其次快速迭代实验，做好实验记录也是非常有必要的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    希望这一次的优化经验总结能对大家有所帮助，下一篇会给大家讲解训练好的textcnn模型如何部署上线，实际应用于工业场景里。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Sep 2019 00:15:00 +0000</pubDate>
<dc:creator>ModifyBlog</dc:creator>
<og:description>前言：本篇是TextCNN系列的第三篇，分享TextCNN的优化经验 前两篇可见： 文本分类算法TextCNN原理详解（一） TextCNN代码详解(附测试数据集以及GitHub 地址)（二） 调优模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ModifyRong/p/11442661.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之Jenkins资源调度 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11470838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11470838.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前的示例我们主要关注点在于功能的实现,都是在一个节点的完成了.有了多个节点后,必须涉及到资源的调度问题.本节我们讲解在创建任务时与资源调度的有关选项以及一些平时没有注意到的但在生产环境需要精细控制的选项.&lt;/p&gt;
&lt;p&gt;我们随便创建一个自由式风格任务,这里主要讲解General里的一些选项&lt;/p&gt;
&lt;h2 id=&quot;restrict-where-this-project-can-be-run&quot;&gt;Restrict where this project can be run&lt;/h2&gt;
&lt;p&gt;限制项目运行的节点,勾选后出现&lt;code&gt;Label Expression&lt;/code&gt;选项供输入要限制此任务运行节点的标签,可以指定多个标签,也可以使用一些逻辑运算符以构建更为复杂的标签选择.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此选项除了可以输入标签外,也可以输入节点的名称.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如输入的是&lt;code&gt;master&lt;/code&gt;则限定此任务在master节点运行.&lt;/p&gt;
&lt;p&gt;支持的运算符:&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;(表达式)用于复杂的表达式,类似编程语言中的括号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;!表达式,逻辑运算,例如!linux则任务运行在不包含linux标签的机器上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a&amp;amp;&amp;amp;b 逻辑且&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a||b逻辑或&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;a -&amp;gt; b 这里举个例子说明它的使用方法.比如&lt;code&gt;windows-&amp;gt;x64&lt;/code&gt;则限定如果节点运行在windows机器上,则必须运行在&lt;code&gt;x64&lt;/code&gt;类型的windows机器上(即一节点同时包含windows x64两个label),如果不是windows机器,则不必是x64系统.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;a &amp;lt;-&amp;gt; b 这里仍然举例说明.比如&lt;code&gt;windows&amp;lt;-&amp;gt;datacenter1&lt;/code&gt;,如果主机是windows系统,则必须运行在&lt;code&gt;datacenter1&lt;/code&gt;机房,如果不是windows系统,则必须不能运行在&lt;code&gt;datacenter1&lt;/code&gt;机房.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其它示例:&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;linux-machine-42,任务运行在主机名为&lt;code&gt;linux-machine-42&lt;/code&gt;的节点上,或者标签为&lt;code&gt;linux-machine-42&lt;/code&gt;的节点上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;windows &amp;amp;&amp;amp; jdk9,任务必须运行在windows主机上,并且jdk版本为9(需要注意的是这里仅仅是逻辑上的限制,实际上我们为一个节点打上jdk9标签,这台机器并不一定安装了jdk9,这里还是需要我们人为控制)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;postgres &amp;amp;&amp;amp; !vm &amp;amp;&amp;amp; (linux || freebsd) 运行在有postgres数据库的linux或者freebsd系统类型,并且不是虚拟机的节点上.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;this-build-requires-lockable-resources&quot;&gt;This build requires lockable resources&lt;/h2&gt;
&lt;p&gt;此构建需要锁定的资源,锁定的资源由我们在全局配置里使用.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建&lt;code&gt;lockable resources&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进入&lt;code&gt;manage jenkins&lt;/code&gt;-&amp;gt;&lt;code&gt;system configuration&lt;/code&gt;,然后向下滚动找到&lt;code&gt;Lockable Resources Manager&lt;/code&gt;,然后点击&lt;code&gt;Add lockable resource&lt;/code&gt;按钮.出现输入框,下面讲解每一项的含义&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Name lockable资源的名称,只有定义的名称创建项目的时候才可以使用它,比如&lt;code&gt;printers&lt;/code&gt;定义了一个名叫作printers类型的lockable资源&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Description 描述,可以随便添加一些描述信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Labels 要选择的节点,多个之间用空格分割.比如&lt;code&gt;printer1 printer2 printer3&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Reserved by 被某个对象预留,这里可以填写任意名称,如果有值,则资源不可用,此选项用于对资源的维护,比如我们要对安装了打印机的主机进行维护,则可以在这里填写一个值,此时任务不能使用此资源,直到值被清除.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们返回jenkins主界面,点击左侧的&lt;code&gt;Lockable Resources&lt;/code&gt;就可以看到有哪些lockable resource,并且可以看到资源的状态&lt;/p&gt;
&lt;p&gt;新建一个项目,general选项里选择&lt;code&gt;This build requires lockable resources&lt;/code&gt;便可以使用lockable资源,有&lt;code&gt;Resources&lt;/code&gt;和&lt;code&gt;labels&lt;/code&gt;两个选项可以选,此两个选项是互斥的,即只能选择一个,比如我们可以在&lt;code&gt;Resources&lt;/code&gt;里指定&lt;code&gt;printers&lt;/code&gt;,或者在labels里指定&lt;code&gt;printer1&lt;/code&gt;或者&lt;code&gt;printer2&lt;/code&gt;,具体要根据要锁定的资源而定.如果仅仅要锁定一个打印机,则可以用resoures,如果想要锁定某个特定类型的资源,则可以使用lable.&lt;/p&gt;
&lt;p&gt;我们构建完任务后,点击构建号进入详细构建信息页面,点击左侧的&lt;code&gt;lockable resources&lt;/code&gt;则可以看到本次构建锁定的资源.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里说锁定资源,是指此构建对资源的独占,如果其它构建也锁定了相同的资源,则需要排除等待.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;由于jenkins里的资源都是节点资源,即没有其它类型的资源,因此使用lockable resources能完成的工作使用label选择也同样能完成,使用kockable resources的好处在于对资源的管理更为方便,有些资源是有限的,如果lable过于复杂很难理清关系,而lockable resoure则有单独的资源管理界面,方便对这些关键的资源进行管理.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;高级选项之quiet-period&quot;&gt;高级选项之Quiet period&lt;/h2&gt;
&lt;p&gt;勾选后,会出现&lt;code&gt;Quiet period&lt;/code&gt;,值默认为秒.此选项的意义为在实践中有些用户往往会在提交git后又马上发现问题,紧接着进行数次提交.这样就会触发多个hook事件,导致多次构建,如果指定一个&lt;code&gt;Quiet period&lt;/code&gt;jenkins中待处理的队列中在一个任务添加后的&lt;code&gt;Quiet period&lt;/code&gt;范围内再添加任务将不会被加入到队列.保证一个相关的提交只构建一次,防止不必要的资源浪费.&lt;/p&gt;
&lt;h2 id=&quot;高级选项之retry-count&quot;&gt;高级选项之Retry Count&lt;/h2&gt;
&lt;p&gt;此选项也是对SCM的,如果一个构建使用了SCM(git,svn等),则在拉取代码失败后会进行若干次重试,如果在指定的重试次数用完后仍然未能拉取,则此次构建标记为失败.&lt;/p&gt;
&lt;p&gt;此选项如果不勾选默认的行为是如果拉取代码失败,则任务马上标识为失败,相当于&lt;code&gt;Retry count&lt;/code&gt;值设置为0&lt;/p&gt;
&lt;h2 id=&quot;高级选项之execute-concurrent-builds-if-necessary&quot;&gt;高级选项之Execute concurrent builds if necessary&lt;/h2&gt;
&lt;p&gt;必要时执行并行构建.默认情况下,如果对同一任务触发多次构建,这些任务会形成队列,上一个完成后下一个才开始构建,如果机器资源充足的情况下可以勾选此选项,这样jenkins就会并行调度任务(同一任务可能同时运行多个构建),我们不用担心资源覆盖问题,因为jenkins在构建时会自动为同一构建不同编号的任务创建不同的构建目录.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;需要注意的是,如果构建勾选了&lt;code&gt;Use custom workspace&lt;/code&gt;并且指定了自定义构建目录,则jenkins不会为不同的构建创建隔离的目录,这种情况下同一任务并行构建就会出问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;高级选项之use-custom-workspace&quot;&gt;高级选项之Use custom workspace&lt;/h2&gt;
&lt;p&gt;jenkins并不只是构建项目用,还可以执行一些其它的任务,比如在特定的目录下执行一些操作.但是jenkins会为每个任务创建一个固定的文件夹,此时如何指定&lt;code&gt;Use custom workspace&lt;/code&gt;则会改变jenkins的默认行为,让jenkins在特定的目录上下文环境下执行任务.&lt;/p&gt;
&lt;h2 id=&quot;任务组织和管理&quot;&gt;任务组织和管理&lt;/h2&gt;
&lt;h3 id=&quot;创建view&quot;&gt;创建view&lt;/h3&gt;
&lt;p&gt;默认情况下Jenkins里有一个All view,默认创建的任务都会显示在这里,随着接入jenkins项目越来越多,这个view就会变得越来越臃肿,难以管理.这时候我们可以创建更多的view来对任任务进行逻辑上管理.创建view也很简单,&lt;code&gt;All&lt;/code&gt;后面一个&lt;code&gt;+&lt;/code&gt;号就可以创建一个新的view,详细步骤这里就不再介绍了.创建完以后&lt;code&gt;All&lt;/code&gt;后面就会多出一个标签,点击这个标签就可以切换到这个视图,在当前view激活的情况下,创建新的项目时,默认会勾选&lt;code&gt;Add to current view&lt;/code&gt;把项目添加到当前视图.&lt;/p&gt;
&lt;h3 id=&quot;把部分已有任务添加到当前视图&quot;&gt;把部分已有任务添加到当前视图&lt;/h3&gt;
&lt;p&gt;如果你新创建视图后没有进行任何操作,则当前视图下有这样一句话&lt;/p&gt;
&lt;p&gt;&lt;code&gt;This view has no jobs associated with it. You can either add some existing jobs to this view or create a new job in this view.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;add some existing jobs&lt;/code&gt;在出现的页面里就可以从&lt;code&gt;jobs&lt;/code&gt;里勾选想要添加进来的任务,然后点击ok即可.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这个页面和创建view页面类似,创建view的界面里同样也有添加job到view的选项,选择即可.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们已经添加了任务,则上面的链接就会消失了,此时我们可以在视图激活的情况下,点击左侧的&lt;code&gt;Edit view&lt;/code&gt;按钮,进入和刚才一样的界面,然后在这个页面里选择要添加的job.&lt;/p&gt;
&lt;h3 id=&quot;删除一个已有view&quot;&gt;删除一个已有view&lt;/h3&gt;
&lt;p&gt;在当前view激活状态下,左侧有一个&lt;code&gt;delete view&lt;/code&gt;按钮,我们点击它就可以删除当前view&lt;/p&gt;
&lt;p&gt;需要注意的是,删除view并不删除它里面的任务,view删除以后里面的任务会被移到&lt;code&gt;All&lt;/code&gt;里面&lt;/p&gt;
&lt;h2 id=&quot;创建文件夹&quot;&gt;创建文件夹&lt;/h2&gt;
&lt;p&gt;文件夹也是用来组织任务的一种方式,我们点击&lt;code&gt;New Item&lt;/code&gt;下面有一个&lt;code&gt;Folder&lt;/code&gt;类型,我们选择它以后就可以创建一个文件夹.我们进入到里面会发现,里面也包含一个&lt;code&gt;all&lt;/code&gt;类型的视图,和外层一样.也可以像在外层一下添加项目.点击左侧的&lt;code&gt;delete folder&lt;/code&gt;按钮则可以删除当前文件夹.&lt;/p&gt;
&lt;h3 id=&quot;把文件夹移动到其它视图&quot;&gt;把文件夹移动到其它视图&lt;/h3&gt;
&lt;p&gt;点击左侧的&lt;code&gt;move&lt;/code&gt;按钮,就会出现一个下拉列表,列出了当前所有的view,选择想要移动到的view即可.&lt;/p&gt;
</description>
<pubDate>Fri, 06 Sep 2019 00:15:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 之前的示例我们主要关注点在于功能的实现,都是在一个节点的完成了.有了多个节点后,必须涉及到资源的调度问题.本节我们讲解在创建任务时与资源调度的有关选项以及一些平时没有注意到的但在生产环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11470838.html</dc:identifier>
</item>
<item>
<title>Java多线程（十二）：中断机制 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/11470748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/11470748.html</guid>
<description>&lt;p&gt;这里详细分析interrupt(),interrupted(),isInterrupted()三个方法&lt;/p&gt;
&lt;h2 id=&quot;interrupt&quot;&gt;interrupt()&lt;/h2&gt;
&lt;p&gt;中断这个线程，设置中断标识位&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来找下如何设置中断标识位的&lt;br/&gt;找到interrupt0()的源码，src/hotspot/share/prims/jvm.cpp&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
  ...
  if (is_alive) {
    // jthread refers to a live JavaThread.
    Thread::interrupt(receiver);
  }
JVM_END&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了Thread::interrupt方法&lt;br/&gt;src/hotspot/share/runtime/thread.cpp&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;void Thread::interrupt(Thread* thread) {
  ...
  os::interrupt(thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;os::interrupt方法，src/hotspot/os/posix/os_posix.cpp&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;void os::interrupt(Thread* thread) {
  ...
  OSThread* osthread = thread-&amp;gt;osthread();
  if (!osthread-&amp;gt;interrupted()) {
    //设置中断标识位
    osthread-&amp;gt;set_interrupted(true);
    ...
  }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;isinterrupted&quot;&gt;isInterrupted()&lt;/h2&gt;
&lt;p&gt;测试线程是否被中断，线程的中断状态不会改变&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean isInterrupted() {
        return isInterrupted(false);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看native isInterrupted(boolean ClearInterrupted)源码，查找方式同上&lt;br/&gt;src/hotspot/os/posix/os_posix.cpp&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;bool os::is_interrupted(Thread* thread, bool clear_interrupted) {
  debug_only(Thread::check_for_dangling_thread_pointer(thread);)

  OSThread* osthread = thread-&amp;gt;osthread();
  // 查看是否被中断
  bool interrupted = osthread-&amp;gt;interrupted();

  // 清除标识位后再设置false
  if (interrupted &amp;amp;&amp;amp; clear_interrupted) {
    osthread-&amp;gt;set_interrupted(false);
  }

  return interrupted;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java传递ClearInterrupted为false，对应C++的clear_interrupted&lt;/p&gt;
&lt;h2 id=&quot;interrupted&quot;&gt;interrupted()&lt;/h2&gt;
&lt;p&gt;测试线程是否被中断，清除中断标识位&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread45 {
    public static void main(String[] args) throws Exception
    {
        Runnable runnable = new Runnable()
        {
            public void run()
            {
                while (true)
                {
                    if (Thread.currentThread().isInterrupted())
                    {
                        System.out.println(&quot;线程被中断了&quot;);
                        return ;
                    }
                    else
                    {
                        System.out.println(&quot;线程没有被中断&quot;);
                    }
                }
            }
        };
        Thread t = new Thread(runnable);
        t.start();
        Thread.sleep(500);
        t.interrupt();
        System.out.println(&quot;线程中断了，程序到这里了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查线程是否中断，中断线程，运行结果如下&lt;/p&gt;
&lt;pre class=&quot;graph&quot;&gt;
&lt;code&gt;······
线程没有被中断
线程没有被中断
线程没有被中断
线程被中断了
线程中断了，程序到这里了&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 05 Sep 2019 19:07:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>这里详细分析interrupt(),interrupted(),isInterrupted()三个方法 interrupt() 中断这个线程，设置中断标识位 我们来找下如何设置中断标识位的 找到int</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Java-Starter/p/11470748.html</dc:identifier>
</item>
<item>
<title>NN入门，手把手教你用Numpy手撕NN(二) - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/11470718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/11470718.html</guid>
<description>&lt;p&gt;&lt;strong&gt;这是一篇包含较少数学推导的NN入门文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上篇&lt;a href=&quot;https://www.cnblogs.com/csu-lmw/p/NN入门(1).md&quot;&gt;文章&lt;/a&gt;中简单介绍了如何手撕一个NN，但其中仍有可以改进的地方，将在这篇文章中进行完善。&lt;/p&gt;

&lt;p&gt;之前的NN计算梯度是利用数值微分法，虽容易实现，但是计算速度慢，这里介绍的&lt;code&gt;误差反向传播法&lt;/code&gt;能够高效计算权重参数的梯度的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里将通过&lt;code&gt;计算图&lt;/code&gt;的方法来讲解反向传播&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;计算图&quot;&gt;计算图&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问题一：&lt;/p&gt;
&lt;p&gt;​ 小明在超市买了2个100元一个的苹果，消费税是10%，请计算支付金额&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906012949398-907465605.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题二：&lt;/p&gt;
&lt;p&gt;​ 小明在超市买了2个苹果、3个橘子。其中，苹果每个100元， 橘子每个150元。消费税是10%，请计算支付金额。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013005203-1497207623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面两问计算图的表示中可以很容易理解其计算原理，从左到右的计算称为&lt;code&gt;正向传播&lt;/code&gt;。同时，我们也可以利用这种方法进行&lt;code&gt;反向传播&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;再来思考一个问题：&lt;/p&gt;
&lt;p&gt;​ 问题1中，我们计算了购买2个苹果时加上消费税最终需要支付的金额。这里，假设我们想知道苹果价格的上涨会在多大程度上影响最终的支付金额，即求“支付金额关于苹果的价格的导数”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013016980-370409810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，反向传播使用与正方向相反的箭头（粗线）表示。反向传播传递“局部导数”，将导数的值写在箭头的下方。在这个例子中，反向传播从右向左传递导数的值为（1→1.1→2.2）。从这个结果中可知，“支付金额 关于苹果的价格的导数”的值是2.2。这意味着，如果苹果的价格上涨1元， 最终的支付金额会增加2.2元（严格地讲，如果苹果的价格增加某个微小值， 则最终的支付金额将增加那个微小值的2.2倍）。&lt;/p&gt;
&lt;p&gt;可见，利用计算图可以通过正向传播与反向传播高效地计算各个变量的导数值。&lt;/p&gt;
&lt;h2 id=&quot;链式法则&quot;&gt;链式法则&lt;/h2&gt;
&lt;p&gt;上面提到的反向传播实际上是基于链式法则进行的，这里将介绍下其原理。&lt;/p&gt;
&lt;p&gt;假设存在 &lt;span class=&quot;math inline&quot;&gt;\(y=f(x)\)&lt;/span&gt; 的计算，这个计算的反向传播如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013035934-2070301359.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，反向传播的计算顺序是，将信号E乘以节点的局部导数 ，然后将结果传递给下一个节点。通过这样的计算，可以高效地求出导数的 值，这是反向传播的要点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，为什么链式传播在这里会有效呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学过高数话，就知道什么是链式传播&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以 &lt;span class=&quot;math inline&quot;&gt;\(z=(x+y)^2\)&lt;/span&gt; 为例，可以看成由下面两个式子构成&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ z=t^2 \\ t=x+y \tag{1} \]&lt;/span&gt;&lt;br/&gt;那么&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial z}{\partial x} = \frac{\partial z}{\partial t} \frac{\partial t}{\partial x}\tag{2} \]&lt;/span&gt;&lt;br/&gt;现在来使用链式法则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial z}{\partial t} = 2t\\ \frac{\partial t}{\partial x} = 1\tag{3} \]&lt;/span&gt;&lt;br/&gt;所以&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial z}{\partial x} = 2t \cdot 1=2(x+y)\tag{4} \]&lt;/span&gt;&lt;br/&gt;将上式按照计算图表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013053758-638381432.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013103354-1527798077.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们的反向传播就算介绍完了，下面将介绍简单实现。&lt;/p&gt;
&lt;h2 id=&quot;乘法层&quot;&gt;乘法层&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MulLayer:    
    def __init__(self):        
        self.x = None        
        self.y = None
    
    def forward(self, x, y):        
        self.x = x        
        self.y = y        
        out = x * y
        
        return out
        
    def backward(self, dout):        
        dx = dout * self.y # 翻转x和y        
        dy = dout * self.x
        
        return dx, dy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;__ init __()中会初始化实例变量x和y，它们用于保存正向传播时的输入值。 forward()接收x和y两个参数，将它们相乘后输出。backward()将从上游传来的导数（dout）乘以正向传播的翻转值，然后传给下游。&lt;/p&gt;
&lt;p&gt;至于为什么要翻转x和y可能会有点迷惑，看下面这张图再结合上面的例子就能理解了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013117238-2008230465.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;apple = 100 
apple_num = 2 
tax = 1.1
# layer 
mul_apple_layer = MulLayer() 
mul_tax_layer = MulLayer()
# forward 
apple_price = mul_apple_layer.forward(apple, apple_num) 
price = mul_tax_layer.forward(apple_price, tax)
print(price) # 220

# backward 
dprice = 1 
dapple_price, dtax = mul_tax_layer.backward(dprice) 
dapple, dapple_num = mul_apple_layer.backward(dapple_price)
print(dapple, dapple_num, dtax) # 2.2 110 200&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;加法层&quot;&gt;加法层&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AddLayer:    
    def __init__(self):        
        pass
    
    def forward(self, x, y):        
        out = x + y        
        return out
    
    def backward(self, dout):        
        dx = dout * 1        
        dy = dout * 1        
        return dx, dy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加法层不需要特意进行初始化，所以__ init __()中什么也不运行。加法层的forward()接收x和y两个参数，将它们相加后输出。backward()将上游传来的导数（dout）原封不动地传递给下游。&lt;/p&gt;

&lt;p&gt;前面介绍了如何利用计算图来计算导数，下面将介绍如何利用计算图来设计NN的其它层。&lt;/p&gt;
&lt;h2 id=&quot;激活函数层&quot;&gt;激活函数层&lt;/h2&gt;
&lt;h3 id=&quot;relu层&quot;&gt;ReLU层&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=\begin{cases} x,\quad x &amp;gt; 0\\ 0,\quad x&amp;lt;=0 \end{cases}\tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对上式求导&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial y}{\partial x}=\begin{cases} 1,\quad x &amp;gt; 0\\ 0,\quad x&amp;lt;=0 \end{cases}\tag{6} \]&lt;/span&gt;&lt;br/&gt;可以看出，如果正向传播时的输入x大于0，则反向传播会将上游的值原封不动地传给下游。反过来，如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处。计算图表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013211791-1192566986.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Relu:    
    def __init__(self):        
        self.mask = None
    
    def forward(self, x):        
        self.mask = (x &amp;lt;= 0)        
        out = x.copy()        
        out[self.mask] = 0
        
        return out
    
    def backward(self, dout):        
        dout[self.mask] = 0        
        dx = dout
        
        return dx&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sigmoid层&quot;&gt;Sigmoid层&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=\frac{1}{1+exp(-x)}\tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其正向传播的计算图可以表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013227377-1721340716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，依次进行求导&lt;/p&gt;
&lt;p&gt;节点“/”&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=\frac{1}{x} \\ \frac{\partial y}{\partial x} = -\frac{1}{x^2}=-y^2\tag{8} \]&lt;/span&gt;&lt;br/&gt;节点“+”&lt;/p&gt;
&lt;p&gt;​ 原封不动传给下一节点&lt;/p&gt;
&lt;p&gt;节点“exp”&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial y}{\partial x} = exp(x)\tag{9} \]&lt;/span&gt;&lt;br/&gt;节点“x”&lt;/p&gt;
&lt;p&gt;​ 上一节点的传来的导数乘上-1&lt;/p&gt;
&lt;p&gt;最后计算图表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013240019-1455776736.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;化简一下就是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013253972-1910632882.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还能将公式进一步化简&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} \frac{\partial L}{\partial y}y^2\exp(-x) &amp;amp;= \frac{\partial L}{\partial y}\frac{1}{(1+\exp{-x})^2}\exp(-x)\\ &amp;amp;=\frac{\partial L}{\partial y}\frac{1}{1+\exp{-x}}\frac{\exp{-x}}{1+\exp{-1}}\\ &amp;amp;= \frac{\partial L}{\partial y}y(1-y) \end{aligned} \tag{10} \]&lt;/span&gt;&lt;br/&gt;此时计算图为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013305935-692940057.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Sigmoid:    
    def __init__(self):        
        self.out = None
    
    def forward(self, x):        
        out = 1 / (1 + np.exp(-x))        
        self.out = out
        
        return out
    
    def backward(self, dout):        
        dx = dout * (1.0 - self.out) * self.out
        
        return dx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;affinesoftmax层&quot;&gt;Affine/Softmax层&lt;/h2&gt;
&lt;h3 id=&quot;affine&quot;&gt;Affine&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿射变换” A。因此，这里将进行仿射变换的处理实现为“Affine层”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于矩阵运算的反向传播实现，涉及到了对矩阵求导，之前看到一篇很好的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22473137&quot;&gt;文章&lt;/a&gt;，里面介绍了如何进行计算。这里将直接给出结论，对下图&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial L}{\partial X}=\frac{\partial L}{\partial Y} \cdot W^T \\ \frac{\partial L}{\partial W}=X^T \cdot \frac{\partial L}{\partial X} \tag{11} \]&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013324495-1695275574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反向传播的计算图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013333913-1510811805.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面只是以单个数据为对象，如果是N个数据一起进行正向传播呢？先来看看计算图表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013345114-1833883023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Class Affine:
    def __init__(self, W, b):
        self.W = W
        self.b = b
        self.x = None
        self.dW = None
        self.db = None
       
    def forward(self, x):
        self.x = x
        out = np.dot(x, self.W) + self.b
        
        return out
    
    def backward(self, dout):
        dx = np.dot(dout, self.W.T)
        self.dW = np.dot(self.x.T, dout)
        self.db = np.sum(dout, axis=1)
        
        return dx&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;softmax-with-loss&quot;&gt;Softmax-with-Loss&lt;/h3&gt;
&lt;p&gt;Softmax-with-loss层由Softmax层与Cross Entropy Error层组合而成，其结构如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013932913-957975892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公式表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Softmax&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y_k=\frac{\exp{(a_k)}}{\sum^{n}_{i=1}\exp{(a_i)}}\tag{12} \]&lt;/span&gt;&lt;br/&gt;Cross Entropy Error&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L=-\sum_{k}t_klogy_k\tag{13} \]&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;Cross Entropy Error 反向传播&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始值为1&lt;/li&gt;
&lt;li&gt;&quot;x&quot;节点的反向传播将正向传播时的输入值翻转，乘以上游传来的导数后，再传给下游&lt;/li&gt;
&lt;li&gt;&quot;+&quot;节点将上游传来的导数原封不动传给下游&lt;/li&gt;
&lt;li&gt;&quot;log&quot;节点的反向传播如下式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=logy\\ \frac{\partial y}{\partial x} = \frac{1}{x} \tag{14} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;综上，可求得Cross Entropy Error层的反向传播的结果为 &lt;span class=&quot;math inline&quot;&gt;\((-\frac{t_1}{y_1},-\frac{t_2}{y_2},-\frac{t_3}{y_3})\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Softmax层反向传播&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left. \begin{gathered} y_i=\frac{\exp{(a_i)}}{S} \\ -\frac{t_i}{y_i}\exp{(a_i)} \end{gathered} \right\} \implies -t_i\frac{S}{\exp{(a_i)}}\exp{(a_i)}=-t_iS \tag{15} \]&lt;/span&gt;&lt;br/&gt;&quot;/&quot;节点反向传播为&lt;span class=&quot;math inline&quot;&gt;\(-\frac{1}{S^2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，Softmax层中间最上面的结果为&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{S}(t_1+t_2+t_3)\)&lt;/span&gt;，由于&lt;span class=&quot;math inline&quot;&gt;\(t_1, t_2, t_3\)&lt;/span&gt;为one-hot表示，所以仅有一个的值为1，所以此处导数为&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{S}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;“/”节点后的''+&quot;节点，原封不动传递上游的值，此时反向传播计算图如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201909/1413964-20190906013415727-114233202.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着是中间的横向&quot;x&quot;节点，将值翻转后相乘&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ -\frac{t_i}{y_i}\frac{1}{S}=-\frac{t_i}{\exp{(a_i)}}\tag{16} \]&lt;/span&gt;&lt;br/&gt;然后就是&quot;exp&quot;节点&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y=\exp{(x)}\\ \frac{\partial y}{\partial x}=\exp{(x)} \tag{17} \]&lt;/span&gt;&lt;br/&gt;根据上式，两个分支输入和乘以&lt;span class=&quot;math inline&quot;&gt;\(\exp(a_i)\)&lt;/span&gt;后的值就是所求的反向传播值。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left. \begin{gathered} y_i=\frac{\exp{(a_i)}}{S} \\ (\frac{1}{S}-\frac{t_i}{\exp{(a_i)}})\exp{(a_i)} \end{gathered} \right\} \implies y_i-t_i \tag{18} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到此为止，Softmax-with-Loss层的反向传播就算好了，下面来看看代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Class SoftWithLoss:
    def __init__(self):
        self.loss = None # 损失
        self.y = None # softmax的输出
        self.t = None # 监督输出(one-hot vector)
        
    def forward(self, x, t):
        self.t = t
        self.y = softmax(x)
        self.loss = cross_entropy_error(self.y, self.t)
        
        return self.loss
    
    def backward(self, dout=1):
        batch_size = self.t.shape[0]
        dx = (self.y - self.t) / batch_size # 请注意反向传播时，需除以批的大小（batch_size）
        
        return dx&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面介绍了各层如何利用反向传播进行实现，这里将介绍利用反向传播构建NN。&lt;/p&gt;
&lt;h2 id=&quot;神经网络学习步骤&quot;&gt;神经网络学习步骤&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;步骤一（mini-batch）&lt;/p&gt;
&lt;p&gt;从训练数据中随机选择一部分数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;步骤二（计算梯度）&lt;/p&gt;
&lt;p&gt;计算损失函数关于各个权重参数的梯度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;步骤三（更新参数）&lt;/p&gt;
&lt;p&gt;将权重参数沿梯度方向进行微小的更新&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;步骤四（重复）&lt;/p&gt;
&lt;p&gt;重复步骤一、二、三&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;反向传播将出现在步骤二中。&lt;/p&gt;
&lt;p&gt;先来个简单的两层NN&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys, os
sys.path.append(os.pardir)
import numpy as np
from collections import OrderDict

Class TwoLayerNet:
    def __init__(self, input_size, hidden_size, output_size, weight_init_std=0.01):
        # 初始化权重
        self.params = {}
        self.params['W1'] = weight_init_std * np.random.randn(input_size, hidden_size)
        self.params['b1'] = np.zeros(hidden_size)
        self.params['W2'] = weight_init_std * np.random.randn(hidden_size, output_size)
        self.params['b2'] = np.zeros(output_size)
        
        # 生成层
        self.layers = OrderdDict()
        self.layers['Affine1'] = Affine(self.params['W1'], self.params['b1'])
        self.layers['Relu1'] = Relu()
        self.layers['Affine2'] = Affine(self.params['W2'], self,params['b2'])
        self.lastLayer = SoftmaxWithLoss()
        
    def predict(self, x):
        for layer in self.layers.values():
            x = layer.forward(x)
        
        return x
    
    # x: 输入数据, t：监督数据
    def loss(self, x, t):
        y = self.predict(x)
        return self.lastLayer.forward(x, y)
    
    def accuracy(self, x, t):
        y = self.predict(x)
        y = np.argmax(y, axis=1)
        if t.ndim != 1 :
            t = np.argmax(t, axis=1)
        accuracy = np.sum(y==t) / float(x.shape[0])
        return accuracy
    
    # x：输入数据，t：监督数据 微分法梯度计算
    def numerical_gradient(self, x, t):
        loss_W = lambda W: self.loss(x, t)
        
        grads = {}
        grads['W1'] = numerical_gradient(loss_W, self.params['W1'])
        grads['b1'] = numerical_gradient(loss_W, self.params['b1'])
        grads['W2'] = numerical_gradient(loss_W, self.params['W2'])
        grads['b2'] = numerical_gradient(loss_W, self.params['b2'])
        
        return grads
    
    # x：输入数据，t：监督数据 计算图法梯度计算
    def gradient(self, x, t):
        # forward
        self.loss(x, t)
        # backward
        dout = 1
        dout = self.lastLayer.backward(dout)
        
        layers = list(self.layers.values()).reverse()
        for layer in layers:
            dout = layer.backward(dout)
        
        grads = {}
        grads['W1'] = self.layers['Affine1'].dW
        grads['b1'] = self.layers['Affine1'].db
        grads['W2'] = self.layers['Affine2'].dW
        grads['b2'] = self.layers['Affine2'].db
        
        return grads&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里插入一点内容，我们之前使用的数值微分的优点是实现简单，因此，一般情况下不太容易出错。而误差反向传播法的实现很复杂，容易出错。所以，经常会比较数值微分的结果和误差反向传播法的结果，以确认误差反向传播法的实现是否正确。确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致&lt;u&gt;（严格地讲，是非常相近）&lt;/u&gt;的操作称为梯度确认（gradient check）。&lt;/p&gt;
&lt;p&gt;代码实现如下&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 读入数据 
(x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_ hot_label = True)
network = TwoLayerNet(input_size=784, hidden_size=50, output_size=10)

x_batch = x_train[:3]
t_batch = t_train[:3]

grad_numerical = network.numerical_gradient(x_batch, t_batch) 
grad_backprop = network.gradient(x_batch, t_batch)

# 求各个权重的绝对误差的平均值 
for key in grad_numerical.keys():    
    diff = np.average(np.abs(grad_backprop[key] - grad_numerical[key]))    
    print(key + &quot;:&quot; + str(diff))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上面的网络进行学习&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys, os 
sys.path.append(os.pardir) 
import numpy as np

# 读入数据 
(x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, one_hot_label=True)
network = TwoLayerNet(input_size=784, hidden_size=50, output_size=10)

iters_num = 10000 
train_size = x_train.shape[0] 
batch_size = 100 
learning_rate = 0.1 
train_loss_list = [] 
train_acc_list = [] 
test_acc_list = []

iter_per_epoch = max(train_size / batch_size, 1)

for i in range(iters_num):    
    batch_mask = np.random.choice(train_size, batch_size)    
    x_batch = x_train[batch_mask]    
    t_batch = t_train[batch_mask]
    
    # 通过误差反向传播法求梯度    
    grad = network.gradient(x_batch, t_batch)
    
    # 更新    
    for key in ('W1', 'b1', 'W2', 'b2'):        
        network.params[key] -= learning_rate * grad[key]
    
    loss = network.loss(x_batch, t_batch)    
    train_loss_list.append(loss)
    
    if i % iter_per_epoch == 0:        
        train_acc = network.accuracy(x_train, t_train)        
        test_acc = network.accuracy(x_test, t_test)        
        train_acc_list.append(train_acc)        
        test_acc_list.append(test_acc)        
        print(train_acc, test_acc)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：数据加载与微分求导的代码在上篇中已给出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样我们就完成了一个利用误差反向传播实现的简单的两层NN，当然，代码可以更加一般化，生成多层的全连接神经网络，可能将在后面的文章中给出其实现。&lt;/p&gt;

&lt;p&gt;这篇中介绍了基于反向传播法，对上篇中实现的两层神经网络进行了更进一步的优化。在NN的参数更新方面，还有待优化，其方法有许多，如SGD、Momentum、AdaGrad、Adam等方法；另外还有对于权重的初始值的设置，也有蛮多的研究；以及如何抑制过拟合等，这些都得去了解，并思考其中原理。&lt;/p&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://zhuanlan.zhihu.com/c_1092003351746777088&quot;&gt;我的知乎&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Sep 2019 17:41:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>这是一篇包含较少数学推导的NN入门文章 上篇 '文章' .md)中简单介绍了如何手撕一个NN，但其中仍有可以改进的地方，将在这篇文章中进行完善。 误差反向传播 之前的NN计算梯度是利用数值微分法，虽容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/11470718.html</dc:identifier>
</item>
<item>
<title>SpringCloud（二）服务注册与发现 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/11470618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/11470618.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;离上一篇微服务的基本概念已经过去了几个月，在写那篇博客之前，自己还并未真正的使用微服务架构，很多理解还存在概念上。后面换了公司，新公司既用了SpringCloud也用了Dubbo+Zookeeper，就像上一篇文章说的，当一个服务是面向外部或者是直接提供给前端调用的，那么就使用SpringCloud，而一些内部公用的（如发送短信），就使用Dubbo+Zookeeper，因为他在内部调用更像调用接一个接口，效率也会比较高，而一些模块型的功能，我们则使用SpringCloud。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在已经存在了成熟的开发框架后，微服务本身也没什么技术难点，架构思想才是最重要的，要在不断的实践中去探索，废话不多说，来学习SpringCloud的技术。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一、SpringCloud技术栈&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;SpringCloud是一套完整的分布式微服务架构，我们可以去官网上看下整体的架构图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235033263-554928445.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; SpringCloud基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而SpringBoot并没有重复制造轮子，它将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;SpringCloud提供了全家桶式技术解决方案，对我们使用者来说是极其简单的。但是要学会SpringCloud的前提那必定要学会SpringBoot。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;了解完整体的架构图后，就来进行一个个的技术栈的学习，学习的网站推荐：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Cloud中国社区：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://springcloud.cn/&quot;&gt;http://springcloud.cn/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Cloud中文网： &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.springcloud.cc/&quot;&gt;https://www.springcloud.cc/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;二、服务注册与发现&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一般架构的开发过程中，我们也会去调用一些外部服务，这个时候都是直接去调用，没有服务注册与发现的概念。但在微服务架构中，我们会按照模块将系统分为多个微服务，而且每个服务我们会做成集群，那这些服务的数量是很大的，这些服务之间可能会被前端直接调用，也有可能互相调用，而且调用关系十分复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;每个服务实例的网络位置（IP与端口）信息，而且这些服务有可能会下线（奔溃），也有可能扩容，那这个时候服务之间相互去记录这些信息肯定是非常麻烦的，这个时候我们需要一个服务的治理组件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在定义服务治理之前，我们可以类比一个场景，就是我们工作大楼的物业，公司入驻这栋大楼，就会在物业处注册自己的一些信息，并且交物业费，那这个物业管理类似服务治理。公司相当于一个一个服务，当外面的人想要找到公司提供服务时，可以去物业处了解我们的信息，然后再找到我们，而本身不需要记录我们公司的信息，因为他记不想记住这么多信息，而且就算记了，我们公司信息也可能会改变，比如破产倒闭了，或者又发展壮大换了地方了。我们定时向物业交管理费，一旦我们不交物业费了，那物业就认为我们不在这里了，那其他人在来找也当做公司不存在了，Eureka的服务注册与发现就有点类似这种场景。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现，Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心（物业管理）。而系统中的其他微服务（公司），使用 Eureka 的客户端连接到 Eureka Server，并维持心跳连接（交物业费）。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。Spring Cloud 的一些其他模块（访问人员）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Eureka包含两个组件：&lt;span&gt;&lt;strong&gt;Eureka Server&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;Eureka Client&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Eureka Server&lt;/strong&gt;&lt;span&gt;提供服务注册服务各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;EurekaClient&lt;/strong&gt;&lt;span&gt;是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235109367-673897925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;三大角色：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Eureka Server 提供服务注册和发现。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;三、构建&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;了解了概念，我们现在来实践一下，因为还会学习更多的的组件，那么我们创建工程也是从整体来创建，还要了解的一点是，我们现在做的是微服务项目，那其实这些微服务就是一个个独立的项目，这些项目可以是完全分开的，跟之前的模块概念是不一样的。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.1 创建整体项目&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;直接先创建一个名为spring-cloud-learn 的文件夹，这个文件夹是为了放各个工程的，然后通过idea 打开这个文件夹，然后在这个文件夹下面创建一个文件夹：spring-cloud-learn-parent&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235209349-438405006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 然后在这个文件夹下增加一个pom.xml文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.2.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Environment Settings &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.reporting.outputEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Settings &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Finchley.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;finalName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;finalName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 资源文件配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;excludes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;**/*.java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclude&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;excludes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/resources&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-resources-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delimiters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delimit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;$&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delimit&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delimiters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将这个项目手动托管成maven项目，这个项目是用于管理依赖的，管理一些公共的依赖，就是一些简单的依赖，需要主要以的是SpringCloud的版本很让人头疼，他不仅有数字，还有字母，这些字母是伦敦地铁站的开头字母。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.2 创建服务注册中心&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主要的项目创建完成之后，我们来创建一个用于服务注册的项目，创建过程与spring-cloud-learn-parent相同，也是创建一个文件夹spring-cloud-learn-eureka，然后在文件夹下增加pom.xml文件，然后再手动托管&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235311319-1294257537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235326353-806863613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&amp;gt;spring-cloud-learn-eureka&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;eureka-server服务端 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再按照maven的目录结构来创建目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235413388-1600864382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后创建一个启动类，这些都是Springboot项目中的知识，然后再增加一个启动类，上面增加@EnableEurekaServer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableEurekaServer
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后增加配置文件application.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-eureka

server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    #表示是否将自己注册到Eureka Server，默认为true。
    registerWithEureka: false
    #表示是否从Eureka Server获取注册信息，默认为true。
    fetchRegistry: false
    serviceUrl:
      #设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的配置都写在上面了，很好理解，这个时候我们可以启动项目了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235534352-1423129831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这个时候相当于已经创建好注册中心了，也就是Eureka Server，那现在再来创建服务提供者&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.3 创建服务提供者&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照上面创建注册服务的方式我们再创建一个部门服务提供者，pom.xml文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-provider-dept&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-provider-dept

server:
  port: 8762

eureka:
  client:
    serviceUrl:
      #服务注册地址
      defaultZone: http://localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后创建启动类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableEurekaClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProviderDeptApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ProviderDeptApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动时idea会弹出此对话框，选择第一个这个时候我们可以方便的管理多个启动服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235719364-765775986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RestTemplateConfiguration {

    @Bean
    @LoadBalanced
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要创建一个service，用来请求服务，这里调用的地方指定了服务名称，不用管ip 地址与端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeptService {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHi(String message) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里指指定了服务名称，不用管ip 地址与端口&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(&quot;http://SPRING-CLOUD-LEARN-PROVIDER-DEPT/hi?message=&quot; + message, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后创建一个controller，给前端接口调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeptController {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptService deptService;

    @RequestMapping(value &lt;/span&gt;= &quot;hi&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHi(@RequestParam String message) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptService.sayHi(message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 启动成功后，刷新Eureka 服务可以看到服务已经注册上来了，这里的红色提示是指Eureka 服务只部署了一台，不具备高可用，后面我们再来部署集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235750117-1799576726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 不过这个时候服务者没有提供确切的服务，添加一个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeptController {
    @Value(&lt;/span&gt;&quot;${server.port}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String port;

    @RequestMapping(value &lt;/span&gt;= &quot;hi&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String sayHi(@RequestParam(value = &quot;message&quot;&lt;span&gt;) String message) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.format(&quot;Hi，your message is : %s i am from port : %s&quot;&lt;span&gt;, message, port);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里为了后面显示集群效果，我们返回端口号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190905235841429-454588372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.4 创建服务消费者&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;上面的注册中心和提供者都已建好，那现在来创建一个消费者，我们使用Ribbon，先不用管这个，依然按照上面的创建方式再创建一个工程，pom.xml文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-learn-consumer-dept-ribbon&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-tomcat&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Boot End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud Begin &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-ribbon&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spring Cloud End &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring-cloud-learn-consumer-dept-ribbon
server:
  port: 8764

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动项：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableDiscoveryClient
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerDeptRibbonApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConsumerDeptRibbonApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个服务我们稍微要给一个配置，因为我们要调用服务提供者，会使用到RestTemplate调用方式，添加一个配置项，这里面还有一个负载均衡功能，用起来也很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeptController {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptService deptService;

    @RequestMapping(value &lt;/span&gt;= &quot;hi&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHi(@RequestParam String message) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptService.sayHi(message);
    }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样消费者就算完成了，我们可以访问这个消费者了，这个消费者调用的是提供者的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190906000217353-1512169524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这样就已经完成了服务的注册中心开发，提供者开发及消费者开发，用起来非常简单，这里我们看到有@LoadBalanced这个注解，但是服务只有一个，所有没有效果，我们可以再启动一个提供者，这里我们可以直接修改端口号再启动，只要注意修改一个地方的配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190906000240501-1658061865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们把提供者的端口号改成8763，再启动一次&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190906000301379-1025034877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这里启动了两个提供者，我们刷新下注册中心：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190906000318896-1017770822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 增加了一个服务，但是消费者是感受不到的，然后我们在多次刷新消费者，可以看到两个服务在轮训调用，这里我们就实现了负载均衡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201909/1113901-20190906000335172-2027454629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用这些组件就是这么简单，这里只是做了最简单的微服务注册与发现，未做服务中心集群，后面我们将再深入的学习。&lt;/p&gt;

</description>
<pubDate>Thu, 05 Sep 2019 16:14:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>离上一篇微服务的基本概念已经过去了几个月，在写那篇博客之前，自己还并未真正的使用微服务架构，很多理解还存在概念上。后面换了公司，新公司既用了SpringCloud也用了Dubbo+Zookeeper，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/11470618.html</dc:identifier>
</item>
<item>
<title>shell 操作钉钉机器人实现告警提醒 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/11469039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/11469039.html</guid>
<description>&lt;p&gt;我们知道，之前的运维告警多通过mail 等方式通知到相应的人员，难以实现随时随地的查看。随着手机APP的发展，很多告警开始发送到IM软件上去。目前比较常用的是发送到微信和钉钉上，今天我们将重点放在钉钉上。群机器人是钉钉群的高级扩展功能，群机器人可以将第三方服务的信息聚合到群聊中，实现自动化的信息同步。借助钉钉机器人，通过官方提供的API，可以很方便的post数据到相应的接收人 。群机器人支持Webhook协议的自定义接入，支持更多可能性，例如：你可将运维报警通过自定义机器人聚合到钉钉群实现提醒功能。&lt;/p&gt;
&lt;p&gt;Shell 脚本语言是实现Linux系统管理及自动化所必须的重要工具。熟练地编写Shell语言可以提升运维人员的工作效率，适应复杂的工作环境。&lt;/p&gt;
&lt;p&gt;在本文，我们聚焦通过shell脚本语言实现借助钉钉机器人发送告警信息。&lt;/p&gt;
&lt;h4&gt;1: 了解更多群机器人的信息，大家可登入官网学习&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq&quot;&gt;https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;2.给自己的机器人起个好听的名字&lt;/h4&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190905163234358-603688724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 3.使用命令行工具curl&lt;/h4&gt;
&lt;p&gt;curl是一个命令行工具，通过指定的URL来上传或下载数据，并将数据展示出来。curl中的&lt;code&gt;c&lt;/code&gt;表示client，而URL，就是URL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 与curl一起使用的协议，最多的还是HTTP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每一个HTTP请求中，都有一个对应的方法，常用的方法有：&lt;code&gt;GET&lt;/code&gt;、&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;HEAD&lt;/code&gt;和&lt;code&gt;PUT&lt;/code&gt;。如果在一个curl命令中不指定具体的方法，那么默认的就是使用&lt;code&gt;GET&lt;/code&gt;方法。对于其它的方法，可以在curl命令中指定：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;option&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-d&lt;/code&gt;或&lt;code&gt;-F&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-I&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-T&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;POST&lt;/code&gt;是HTTP中向服务端提交数据的一种方法。在浏览器中，可以在表单中填写完数据后，浏览器就会默认将填写的数据使用&lt;code&gt;key=value&lt;/code&gt;串的形式进行转化。在curl中，我们可以使用&lt;code&gt;-d&lt;/code&gt;或&lt;code&gt;--data&lt;/code&gt;选项来指定具体的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 钉钉使用curl工具主要相关的两个参数&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;参数（短形式）&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;参数（长形式）&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;具体描述&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;--data&lt;/td&gt;
&lt;td&gt; HTTP POST data (H)&lt;/td&gt;
&lt;td&gt;把指定的数据发送到服务器上.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;-H&lt;/td&gt;
&lt;td&gt;--header&lt;/td&gt;
&lt;td&gt;Custom header to pass to server (H)&lt;/td&gt;
&lt;td readability=&quot;5.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;当使用&lt;code&gt;POST&lt;/code&gt;方法提交数据时，对于提交的数据主要有如下四种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;：默认的形式，即&lt;code&gt;key1=value1&amp;amp;key2=value2&lt;/code&gt;的形式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;：使用表单上传文件时使用这个形式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application/json&lt;/code&gt;：提交JSON格式的数据；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text/xml&lt;/code&gt;：提交XML格式的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Content-Type是一个Header，如果不指定的话，默认使用&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;形式传输数据，当需要使用别的形式进行数据传输的话，需要指定Header。&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;3.3 调用格式（案例）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
   &lt;/span&gt;-H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
   &lt;/span&gt;-d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;msgtype&quot;: &quot;text&quot;, &lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我就是我, 是不一样的烟火&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
      }&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-spm-anchor-id=&quot;0.0.0.i4.6c38126dh0Fexy&quot;&gt;测试过程中，请将上面命令直接&lt;span data-spm-anchor-id=&quot;0.0.0.i2.6c38126dh0Fexy&quot;&gt;复制到命令行，再将xxxxxxxx替换为真实access_token。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;4.不一样的markdown类型&lt;/h4&gt;
&lt;p&gt;官网中除markdown类型，其它的消息类型的 测试例子（脚本） 都可以直接在shell中演示&lt;/p&gt;
&lt;p&gt;官网markdown类型的测试案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
     &quot;msgtype&quot;: &quot;markdown&quot;,
     &quot;markdown&quot;: {
         &quot;title&quot;:&quot;杭州天气&quot;,
         &quot;text&quot;: &quot;#### 杭州天气 @156xxxx8827\n&quot; +
                 &quot;&amp;gt; 9度，西北风1级，空气良89，相对温度73%\n\n&quot; +
                 &quot;&amp;gt; ![screenshot](https://gw.alicdn.com/tfs/TB1ut3xxbsrBKNjSZFpXXcXhFXa-846-786.png)\n&quot;  +
                 &quot;&amp;gt; ###### 10点20分发布 [天气](http://www.thinkpage.cn/) \n&quot;
     },
    &quot;at&quot;: {
        &quot;atMobiles&quot;: [
            &quot;156xxxx8827&quot;, 
            &quot;189xxxx8325&quot;
        ], 
        &quot;isAtAll&quot;: false
    }
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　在shell中执行报错信息，错误信息为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;40035&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;errmsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;缺少参数 json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190905183035308-187734362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 报错原因是  &quot;text&quot; 栏位对应的 value 值中的 “+” 运算符导致，将中间的&lt;/p&gt;

&lt;p&gt;删除。&lt;/p&gt;
&lt;p&gt;即可执行代码更新为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgtype&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;markdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;markdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;杭州天气&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#### 杭州天气 @156xxxx8827\n&amp;gt; 9度，西北风1级，空气良89，相对温度73%\n\n&amp;gt; ![screenshot](https://gw.alicdn.com/tfs/TB1ut3xxbsrBKNjSZFpXXcXhFXa-846-786.png)\n&amp;gt; ###### 10点20分发布 [天气](http://www.thinkpage.cn/) \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;atMobiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;156xxxx8827&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;189xxxx8325&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        ], 
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isAtAll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行OK，错误消失。&lt;/p&gt;
&lt;p&gt;执行情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190905183758363-626822620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 成功收到的信息，内容截图如下：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190906001337811-1400637650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5. 将钉钉机器人代码放到文件中，方便调用&lt;/h3&gt;
&lt;p&gt;例如：创建用于监控当QQOrder_ERP集群的VIP漂移时，调用用来发送钉钉告警的可执行文件 ddalarm.sh。&lt;/p&gt;
&lt;p&gt;其主要代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

webhook&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://oapi.dingtalk.com/robot/send?access_token=34XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
cluster&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;QQOrder_ERP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
host&lt;/span&gt;=`&lt;span&gt;hostname&lt;/span&gt; -I | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
vip&lt;/span&gt;=$&lt;span&gt;1&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SendMsgToDingding() {
    curl $webhook &lt;/span&gt;-H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d &lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msgtype&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;集群名称：$cluster\n告警信息：虚拟IP&amp;lt;$vip&amp;gt;已漂移至节点&amp;lt;$host&amp;gt;，请注意\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;at&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;isAtAll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    }&lt;/span&gt;&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;}


SendMsgToDingding&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此测试文件，调用执行时需要传入一个参数（VIP）。&lt;/p&gt;
&lt;p&gt;触发执行，案例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190905190145349-1561748290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 手机钉钉收到的告警信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201909/780228-20190906001434658-1676605776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;参考资料：&lt;/h4&gt;
&lt;p&gt;1.钉钉群机器人&lt;/p&gt;
&lt;p&gt;https://ding-doc.dingtalk.com/doc#/serverapi2/krgddi &lt;/p&gt;
&lt;p&gt;2.curl使用指南&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/fc0eb6c60816&lt;/p&gt;
</description>
<pubDate>Thu, 05 Sep 2019 16:00:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>我们知道，之前的运维告警多通过mail 等方式通知到相应的人员，难以实现随时随地的查看。随着手机APP的发展，很多告警开始发送到IM软件上去。目前比较常用的是发送到微信和钉钉上，今天我们将重点放在钉钉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuliuzai/p/11469039.html</dc:identifier>
</item>
<item>
<title>深入理解 Handler 消息机制 - 秉心说</title>
<link>http://www.cnblogs.com/bingxinshuo/p/11470573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingxinshuo/p/11470573.html</guid>
<description>&lt;p&gt;记得很多年前的一次面试中，面试官问了这么一个问题，&lt;code&gt;你在项目中一般如何实现线程切换？&lt;/code&gt; 他的本意应该是考察 RxJava 的使用，只是我的答案是 &lt;code&gt;Handler&lt;/code&gt;，他也就没有再追问下去了。在早期 Android 开发的荒芜时代，Handler 的确承担了项目中大部分的线程切换工作，通常包括子线程更新 UI 和消息传递。不光在我们自己的应用中，在整个 Android 体系中，Handler 消息机制也是极其重要的，不亚于 Binder 的地位。 &lt;code&gt;ActivityThread.java&lt;/code&gt; 中的内部类 &lt;code&gt;H&lt;/code&gt; 就是一个 Handler，它内部定义了几十种消息类型来处理一些系统事件。&lt;/p&gt;
&lt;p&gt;Handler 的重要性毋庸置疑，今天就通过 AOSP 源码来深入学习 Handler。相关类的源码包含注释均已上传到我的 Github 仓库 &lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45&quot;&gt;android_9.0.0_r45&lt;/a&gt; :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/android/os/Handler.java&quot;&gt;Handler.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/android/os/Looper.java&quot;&gt;Looper.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/android/os/Message.java&quot;&gt;Message.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lulululbj/android_9.0.0_r45/blob/master/frameworks/base/core/java/android/os/MessageQueue.java&quot;&gt;MessageQueue.java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;handler&quot;&gt;Handler&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 用来发送和处理线程对应的消息队列 &lt;code&gt;MessageQueue&lt;/code&gt; 中存储的 &lt;code&gt;Message&lt;/code&gt;。每个 Handler 实例对应一个线程以及该线程的消息队列。当你创建一个新的 Handler，它会绑定创建它的线程和消息队列，然后它会向消息队列发送 &lt;code&gt;Message&lt;/code&gt; 或者 &lt;code&gt;Runnable&lt;/code&gt;，并且在它们离开消息队列时执行。&lt;/p&gt;
&lt;p&gt;Handler 有两个主要用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;规划 Message 或者 Runnable 在未来的某个时间点执行&lt;/li&gt;
&lt;li&gt;在另一个线程上执行代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上翻译自官方注释。说白了，Handler 只是安卓提供给开发者用来发送和处理事件的，而消息如何存储，消息如何循环取出，这些逻辑则交给 &lt;code&gt;MessageQueue&lt;/code&gt; 和 &lt;code&gt;Looper&lt;/code&gt; 来处理，使用者并不需要关心。但要真正了解 Handler 消息机制，认真读一遍源码就必不可少了。&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;p&gt;Handler 的构造函数大致上可以分为两类，先来看第一类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Handler() {
    this(null, false);
}

public Handler(Callback callback) {
    this(callback, false);
}

public Handler(Callback callback, boolean async) {
    // 如果是匿名类、内部类、本地类，且没有使用 static 修饰符，提示可能导致内存泄漏
    if (FIND_POTENTIAL_LEAKS) {
        final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }

    // 从当前线程的 ThreadLocal获取 Looper
    mLooper = Looper.myLooper();
    if (mLooper == null) {  // 创建 Handler 之前一定要先创建 Looper。主线程已经自动为我们创建。
        throw new RuntimeException(
            &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                    + &quot; that has not called Looper.prepare()&quot;);
    }
    mQueue = mLooper.mQueue; // Looper 持有一个 MessageQueue
    mCallback = callback; // handleMessage 回调
    mAsynchronous = async; // 是否异步处理
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一类构造函数最终调用的都是两个参数的方法，参数中不传递 &lt;code&gt;Looper&lt;/code&gt;，所以要显式检查是否已经创建 Looper。创建 Handler 之前一定要先创建 Looper，否则会直接抛出异常。在主线程中 Looper 已经自动创建好，无需我们手动创建，在 &lt;code&gt;ActivityThread.java&lt;/code&gt; 的 &lt;code&gt;main()&lt;/code&gt; 方法中可以看到。Looper 持有一个消息队列 &lt;code&gt;MessageQueue&lt;/code&gt;，并赋值给 Handler 中的 &lt;code&gt;mQueue&lt;/code&gt; 变量。&lt;code&gt;Callback&lt;/code&gt; 是一个接口，定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Callback {
    public boolean handleMessage(Message msg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过构造器参数传入 CallBack 也是 Handler 处理消息的一种实现方式。&lt;/p&gt;
&lt;p&gt;再回头看一下在上面的构造函数中是如何获取当前线程的 Looper 的？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; mLooper = Looper.myLooper(); // 获取当前线程的 Looper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里先记着，回头看到 Looper 源码时再详细解析。&lt;/p&gt;
&lt;p&gt;看过 Handler 的第一类构造函数，第二类其实就很简单了，只是多了 &lt;code&gt;Looper&lt;/code&gt; 参数而已：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Handler(Looper looper) {
    this(looper, null, false);
}
    
public Handler(Looper looper, Callback callback) {
    this(looper, callback, false);
}
    
public Handler(Looper looper, Callback callback, boolean async) {
    mLooper = looper;
    mQueue = looper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接赋值即可。&lt;/p&gt;
&lt;p&gt;除此之外还有几个标记为 &lt;code&gt;@hide&lt;/code&gt; 的构造函数就不作说明了。&lt;/p&gt;
&lt;h3 id=&quot;发送消息&quot;&gt;发送消息&lt;/h3&gt;
&lt;p&gt;发送消息大家最熟悉的方法就是 &lt;code&gt;sendMessage(Message msg)&lt;/code&gt; 了，可能有人不知道其实还有 &lt;code&gt;post(Runnable r)&lt;/code&gt; 方法。虽然方法名称不一样，但最后调用的都是同一个方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sendMessage(Message msg)
sendEmptyMessage(int what)
sendEmptyMessageDelayed(int what, long delayMillis)
sendEmptyMessageAtTime(int what, long uptimeMillis)
sendMessageAtTime(Message msg, long uptimeMillis)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几乎所有的 &lt;code&gt;sendXXX()&lt;/code&gt; 最后调用的都是 &lt;code&gt;sendMessageAtTime()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;post(Runnable r)
postAtTime(Runnable r, long uptimeMillis)
postAtTime(Runnable r, Object token, long uptimeMillis)
postDelayed(Runnable r, long delayMillis)
postDelayed(Runnable r, Object token, long delayMillis)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的 &lt;code&gt;postXXX()&lt;/code&gt; 方法都是调用 &lt;code&gt;getPostMessage()&lt;/code&gt; 将 参数中的 Runnable 包装成 Message，再调用对应的 &lt;code&gt;sendXXX()&lt;/code&gt; 方法。看一下 &lt;code&gt;getPostMessage()&lt;/code&gt; 的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}

private static Message getPostMessage(Runnable r, Object token) {
    Message m = Message.obtain();
    m.obj = token;
    m.callback = r;
    return m;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是把参数中的 Runnable 赋给 Message 的 &lt;code&gt;callback&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;殊途同归，发送消息的重任最后都落在了 &lt;code&gt;sendMessageAtTime()&lt;/code&gt; 身上。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
    
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis); // 调用 Messagequeue 的 enqueueMessage() 方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Handler 就是一个撒手掌柜，发送消息的任务转手又交给了 &lt;code&gt;MessageQueue&lt;/code&gt; 来处理。&lt;/p&gt;
&lt;p&gt;再额外提一点，&lt;code&gt;enqueueMessage()&lt;/code&gt; 方法中的参数 &lt;code&gt;uptimeMillis&lt;/code&gt; 并不是我们传统意义上的时间戳，而是调用 &lt;code&gt;SystemClock.updateMillis()&lt;/code&gt; 获取的，它表示自开机以来的毫秒数。&lt;/p&gt;
&lt;h2 id=&quot;messagequeue&quot;&gt;MessageQueue&lt;/h2&gt;
&lt;h3 id=&quot;enqueuemessage&quot;&gt;enqueueMessage()&lt;/h3&gt;
&lt;p&gt;Message 的入队工作实际上是由 MessageQueue 通过 &lt;code&gt;enqueueMessage()&lt;/code&gt; 函数来完成的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;boolean enqueueMessage(Message msg, long when) {
    if (msg.target == null) { // msg 必须有 target
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) { // msg 不能正在被使用
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }

    synchronized (this) {
        if (mQuitting) { // 正在退出，回收消息并直接返回
            IllegalStateException e = new IllegalStateException(
                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }

        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &amp;lt; p.when) {
            // New head, wake up the event queue if blocked.
            // 插入消息队列头部，需要唤醒队列
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &amp;lt; p.when) { // 按消息的触发时间顺序插入队列
                    break;
                }
                if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码中可以看出来，MessageQueue 是用链表结构来存储消息的，消息是按触发时间的顺序来插入的。&lt;/p&gt;
&lt;p&gt;enqueueMessage() 方法是用来存消息的，既然存了，肯定就得取，这靠的是 &lt;code&gt;next()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;next&quot;&gt;next()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 阻塞方法，主要是通过 native 层的 epoll 监听文件描述符的写入事件来实现的。
        // 如果 nextPollTimeoutMillis = -1，一直阻塞不会超时。
        // 如果 nextPollTimeoutMillis = 0，不会阻塞，立即返回。
        // 如果 nextPollTimeoutMillis &amp;gt; 0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;amp;&amp;amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                // msg.target == null表示此消息为消息屏障（通过postSyncBarrier方法发送来的）
                // 如果发现了一个消息屏障，会循环找出第一个异步消息（如果有异步消息的话），
                // 所有同步消息都将忽略（平常发送的一般都是同步消息）
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;amp;&amp;amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &amp;lt; msg.when) {
                    // 消息触发时间未到，设置下一次轮询的超时时间
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    // 得到 Message
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse(); // 标记 FLAG_IN_USE
                    return msg;
                }
            } else {
                // No more messages.
                // 没有消息，会一直阻塞，直到被唤醒
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            // Idle handle 仅当队列为空或者队列中的第一个消息将要执行时才会运行
            if (pendingIdleHandlerCount &amp;lt; 0
                    &amp;amp;&amp;amp; (mMessages == null || now &amp;lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &amp;lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                // 没有 idle handler 需要运行，继续循环
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        // 只有第一次循环时才会执行下面的代码块
        for (int i = 0; i &amp;lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        // 将 pendingIdleHandlerCount 置零保证不再运行
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt; 方法是一个死循环，但是当没有消息的时候会阻塞，避免过度消耗 CPU。&lt;code&gt;nextPollTimeoutMillis&lt;/code&gt; 大于 0 时表示等待下一条消息需要阻塞的时间。等于 -1 时表示没有消息了，一直阻塞到被唤醒。&lt;/p&gt;
&lt;p&gt;这里的阻塞主要靠 native 函数 &lt;code&gt;nativePollOnce()&lt;/code&gt; 来完成。其具体原理我并不了解，想深入学习的同学可以参考 Gityuan 的相关文 &lt;a href=&quot;http://gityuan.com/2015/12/27/handler-message-native/&quot;&gt;Android消息机制2-Handler(Native层)&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;MessageQueue 提供了消息入队和出队的方法，但它自己并不是自动取消息。那么，谁来把消息取出来并执行呢？这就要靠 &lt;strong&gt;Looper&lt;/strong&gt; 了。&lt;/p&gt;
&lt;h2 id=&quot;looper&quot;&gt;Looper&lt;/h2&gt;
&lt;p&gt;创建 Handler 之前必须先创建 Looper，而主线程已经为我们自动创建了 Looper，无需再手动创建，见 &lt;code&gt;ActivityThread.java&lt;/code&gt; 的 &lt;code&gt;main()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
...
 Looper.prepareMainLooper(); // 创建主线程 Looper
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;preparemainlooper&quot;&gt;prepareMainLooper()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sMainLooper&lt;/code&gt; 只能被初始化一次，也就是说 &lt;code&gt;prepareMainLooper()&lt;/code&gt; 只能调用一次，否则将直接抛出异常。&lt;/p&gt;
&lt;h3 id=&quot;prepare&quot;&gt;prepare()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void prepare() {
        prepare(true);
}

private static void prepare(boolean quitAllowed) {
    // 每个线程只能执行一次 prepare()，否则会直接抛出异常
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    // 将 Looper 存入 ThreadLocal
    sThreadLocal.set(new Looper(quitAllowed));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主线程中调用的是 &lt;code&gt;prepare(false)&lt;/code&gt;，说明主线程 Looper 是不允许退出的。因为主线程需要源源不断的处理各种事件，一旦退出，系统也就瘫痪了。而我们在子线程调用 &lt;code&gt;prepare()&lt;/code&gt; 来初始化 Looper时，默认调动的是 &lt;code&gt;prepare(true)&lt;/code&gt;，子线程 Looper 是允许退出的。&lt;/p&gt;
&lt;p&gt;每个线程的 Looper 是通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 来存储的，保证其线程私有。&lt;/p&gt;
&lt;p&gt;再回到文章开头介绍的 Handler 的构造函数中 &lt;code&gt;mLooper&lt;/code&gt; 变量的初始化：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;mLooper = Looper.myLooper();&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也是通过当前线程的 &lt;code&gt;ThreadLocal&lt;/code&gt; 来获取的。&lt;/p&gt;
&lt;h3 id=&quot;构造函数-1&quot;&gt;构造函数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Looper(boolean quitAllowed) {
    mQueue = new MessageQueue(quitAllowed); // 创建 MessageQueue
    mThread = Thread.currentThread(); // 当前线程
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再对照 Handler 的构造函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Handler(Looper looper, Callback callback, boolean async) {
    mLooper = looper;
    mQueue = looper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的关系就很清晰了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Looper&lt;/code&gt; 持有 &lt;code&gt;MessageQueue&lt;/code&gt; 对象的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handler&lt;/code&gt; 持有 &lt;code&gt;Looper&lt;/code&gt; 对象的引用以及 &lt;code&gt;Looper&lt;/code&gt; 对象的 &lt;code&gt;MessageQueue&lt;/code&gt; 的引用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;loop&quot;&gt;loop()&lt;/h3&gt;
&lt;p&gt;看到这里，消息队列还没有真正的运转起来。我们先来看一个子线程使用 Handler 的标准写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class LooperThread extends Thread {
    public Handler mHandler;
  
    public void run() {
        Looper.prepare();
  
        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // process incoming messages here
            }
        };
  
        Looper.loop();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让消息队列转起来的核心就是 &lt;code&gt;Looper.loop()&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void loop() {
    final Looper me = myLooper(); // 从 ThreadLocal 中获取当前线程的 Looper
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue; // 获取当前线程的消息队列

   ...  // 省略部分代码

    for (;;) { // 循环取出消息，没有消息的时候可能会阻塞
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        ...  // 省略部分代码
       

        try {
            msg.target.dispatchMessage(msg); // 通过 Handler 分发 Message
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }

        ...  // 省略部分代码

        msg.recycleUnchecked(); // 将消息放入消息池，以便重复利用
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说就是一个死循环不停的从 MessageQueue 中取消息，取到消息就通过 Handler 来进行分发，分发之后回收消息进入消息池，以便重复利用。&lt;/p&gt;
&lt;p&gt;从消息队列中取消息调用的是 &lt;code&gt;MessageQueue.next()&lt;/code&gt; 方法，之前已经分析过。在没有消息的时候可能会阻塞，避免死循环消耗 CPU。&lt;/p&gt;
&lt;p&gt;取出消息之后进行分发调用的是 &lt;code&gt;msg.target.dispatchMessage(msg)&lt;/code&gt;，&lt;code&gt;msg.target&lt;/code&gt; 是 Handler 对象，最后再来看看 Handler 是如何分发消息的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void dispatchMessage(Message msg) {
    if (msg.callback != null) { // callback 是 Runnable 类型，通过 post 方法发送
        handleCallback(msg);
    } else {
        if (mCallback != null) { // Handler 的 mCallback参数 不为空时，进入此分支
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg); // Handler 子类实现的  handleMessage 逻辑
    }
}

private static void handleCallback(Message message) {
    message.callback.run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Message 的 callback 属性不为空时，说明消息是通过 &lt;code&gt;postXXX()&lt;/code&gt; 发送的，直接执行 Runnable 即可。&lt;/li&gt;
&lt;li&gt;Handler 的 mCallback 属性不为空，说明构造函数中传入了 Callback 实现，调用 &lt;code&gt;mCallback.handleMessage(msg)&lt;/code&gt; 来处理消息&lt;/li&gt;
&lt;li&gt;以上条件均不满足，只可能是 Handler 子类重写了 &lt;code&gt;handleMessage()&lt;/code&gt; 方法。这好像也是我们最常用的一种形式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;message&quot;&gt;Message&lt;/h2&gt;
&lt;p&gt;之所以把 &lt;code&gt;Message&lt;/code&gt; 放在最后说，因为我觉得对整个消息机制有了一个完整的深入认识之后，再来了解 Message 会更加深刻。首先来看一下它有哪些重要属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int what ：消息标识
int arg1 : 可携带的 int 值
int arg2 : 可携带的 int 值
Object obj : 可携带内容
long when : 超时时间
Handler target : 处理消息的 Handler
Runnable callback : 通过 post() 发送的消息会有此参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Message 有 &lt;code&gt;public&lt;/code&gt; 修饰的构造函数，但是一般不建议直接通过构造函数来构建 Message，而是通过 &lt;code&gt;Message.obtain()&lt;/code&gt; 来获取消息。&lt;/p&gt;
&lt;h3 id=&quot;obtain&quot;&gt;obtain()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sPool&lt;/code&gt; 是消息缓存池，链表结构，其最大容量 &lt;code&gt;MAX_POOL_SIZE&lt;/code&gt; 为 50。&lt;code&gt;obtain()&lt;/code&gt; 方法会直接从消息池中取消息，循环利用，节约资源。当消息池为空时，再去新建消息。&lt;/p&gt;
&lt;h3 id=&quot;recycleunchecked&quot;&gt;recycleUnchecked()&lt;/h3&gt;
&lt;p&gt;还记得 &lt;code&gt;Looper.loop()&lt;/code&gt; 方法中最后会调用 &lt;code&gt;msg.recycleUnchecked()&lt;/code&gt; 方法吗？这个方法会回收已经分发处理的消息，并放入缓存池中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize &amp;lt; MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;说到这里，Handler 消息机制就全部分析完了，相信大家也对整个机制了然于心了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Handler 被用来发送消息，但并不是真正的自己去发送。它持有 MessageQueue 对象的引用，通过 MessageQueue 来将消息入队。&lt;/li&gt;
&lt;li&gt;Handler 也持有 Looper 对象的引用，通过 &lt;code&gt;Looper.loop()&lt;/code&gt; 方法让消息队列循环起来。&lt;/li&gt;
&lt;li&gt;Looper 持有 MessageQueue 对象应用，在 &lt;code&gt;loop()&lt;/code&gt; 方法中会调用 MessageQueue 的 &lt;code&gt;next()&lt;/code&gt; 方法来不停的取消息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop()&lt;/code&gt; 方法中取出来的消息最后还是会调用 Handler 的 &lt;code&gt;dispatchMessage()&lt;/code&gt; 方法来进行分发和处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，关于 Handler 一直有一个很有意思的面试题：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Looper.loop()&lt;/code&gt; 是死循环为什么不会卡死主线程 ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来问的好像有点道理，实则不然。你仔细思考一下，loop() 方法的死循环和卡死主线程有任何直接关联吗？其实并没有。&lt;/p&gt;
&lt;p&gt;回想一下我们经常在测试代码时候写的 &lt;code&gt;main()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(){
    System.out.println(&quot;Hello World&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;姑且就把这里当做主线程，它里面没有死循环，执行完就直接结束了，没有任何卡顿。但是问题是它就直接结束了啊。在一个 Android 应用的主线程上，你希望它直接就结束了吗？那肯定是不行的。所以这个死循环是必要的，保证程序可以一直运行下去。Android 是基于事件体系的，包括最基本的 Activity 的生命周期都是由事件触发的。主线程 Handler 必须保持永远可以相应消息和事件，程序才能正常运行。&lt;/p&gt;
&lt;p&gt;另一方面，这并不是一个时时刻刻都在循环的死循环，当没有消息的时候，loop() 方法阻塞，并不会消耗大量 CPU 资源。&lt;/p&gt;
&lt;p&gt;关于 Handler 就说到这里了。还记得文章说过线程的 Looper 对象是保存在 &lt;strong&gt;ThreadLocal&lt;/strong&gt; 中的吗？下一篇文章就来说说 &lt;code&gt;ThreadLocal&lt;/code&gt; 是如何保存 &lt;strong&gt;线程局部变量&lt;/strong&gt; 的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;文章首发微信公众号： &lt;strong&gt;&lt;code&gt;秉心说&lt;/code&gt;&lt;/strong&gt; ， 专注 Java 、 Android 原创知识分享，LeetCode 题解。&lt;/p&gt;
&lt;p&gt;更多最新原创文章，扫码关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/800205/201909/800205-20190905234237695-485397820.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Sep 2019 15:43:00 +0000</pubDate>
<dc:creator>秉心说</dc:creator>
<og:description>记得很多年前的一次面试中，面试官问了这么一个问题， 他的本意应该是考察 RxJava 的使用，只是我的答案是 ，他也就没有再追问下去了。在早期 Android 开发的荒芜时代，Handler 的确承担</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingxinshuo/p/11470573.html</dc:identifier>
</item>
</channel>
</rss>