<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>k8s学习 - 概念 - ReplicationController - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/11198733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/11198733.html</guid>
<description>&lt;p&gt;我们有了 pod，那么就需要对 pod 进行控制，就是同一个服务的 podv我需要启动几个？如果需要扩容了，怎么办？这里就有个控制器，ReplicationController（简称rc）。&lt;/p&gt;
&lt;p&gt;不过我们看官网：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/136188/201907/136188-20190717084723991-574575363.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里告诉我们，ReplicationController 现在已经过时了，现在建议使用 Deployment 配合ReplicaSet。ReplicationController的主要功能是保证Pod的数量、健康，弹性收缩等。但是Deployment除了有这些功能之外，还增加了回滚功能（当升级 pod 镜像或者相关参数的时候，如果有错误，可以回滚到上一个稳定版本），版本记录（每一次对 Deployment 的操作都能保存下来）。暂停和启动（升级的时候，能随时暂停和启动）。&lt;/p&gt;
&lt;p&gt;估计不久的将来，ReplicationController 就不会有人用了。不过我们还是基本了解下 ReplicationController 的一些配置。&lt;/p&gt;
&lt;p&gt;下面是官方的一份ReplicationController的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中spec.template是spec中必须填写的，它就是一个pod的配置。pod的配置全集在上一篇我们看到了。&lt;/p&gt;
&lt;p&gt;其中.spec.replicas表示这个pod需要维持几份。如果没有配置的话，它就是为1。比如上面那个例子，就保持3份nginx服务。&lt;/p&gt;
&lt;h2 id=&quot;标签选择器&quot;&gt;标签选择器&lt;/h2&gt;
&lt;p&gt;其中的selector我们这里可以好好研究下，这个是我们第一次见到。&lt;/p&gt;
&lt;p&gt;标签选择器在很多概念都是会使用到的，比如pod在哪个node上，ReplicationController作用在哪个pod上，service作用在哪个pod上，等等。tag标注的系统化也是k8s应用集群必要的设计之一。&lt;/p&gt;
&lt;p&gt;标签选择器理解起来倒是很简单，就是一堆的key:value。比如我可以给pod设置3个label:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;metadata:
  labels:
    key1: value1,
    key2: value2,
    key3: value3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;key1=value1, key2=value2, key3=value3。&lt;/p&gt;
&lt;p&gt;然后在ReplicationController的selector里面，有两种写法，一种是简单写法，一种高级写法。（好像网上没有这种说法，但是我理解就是这样的）&lt;/p&gt;
&lt;p&gt;简单写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selector:
  key1: value1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代表这个ReplicationController选择labels有key1标签，且标签值为value1的pod进行控制。&lt;/p&gt;
&lt;p&gt;高级写法：（这个高级写法里面的matchExpressions其实ReplicationController是不支持的，ReplicaSet才开始支持。不知道后续会不会支持个正则匹配）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selector:
  matchLabels:
    key1: value1
  matchExpressions:
    - {key: key2, operator: In, values: [value2, value4]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代表这个ReplicationController选择labels有标签和标签值，key1:value1，且key2在value2和value4集合中的pod进行控制。&lt;/p&gt;
&lt;p&gt;我们可以在查看资源的时候带上&lt;code&gt;--show-labels&lt;/code&gt;来获取labels，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get pod --show-labels
NAME                            READY     STATUS    RESTARTS   AGE       LABELS
busybox                         1/1       Running   26         3d        &amp;lt;none&amp;gt;
busybox1                        1/1       Running   26         3d        name=busybox
busybox2                        1/1       Running   26         3d        name=busybox
frontend-5c548f4769-l9cts       1/1       Running   0          1h        app=guestbook,pod-template-hash=1710490325,tier=frontend
frontend-5c548f4769-nnp2b       1/1       Running   0          1h        app=guestbook,pod-template-hash=1710490325,tier=frontend
frontend-5c548f4769-zjwwm       1/1       Running   0          1h        app=guestbook,pod-template-hash=1710490325,tier=frontend
redis-master-55db5f7567-929np   1/1       Running   0          1h        app=redis,pod-template-hash=1186193123,role=master,tier=backend
redis-slave-584c66c5b5-dsbcc    1/1       Running   0          1h        app=redis,pod-template-hash=1407227161,role=slave,tier=backend
redis-slave-584c66c5b5-kfhnq    1/1       Running   0          1h        app=redis,pod-template-hash=1407227161,role=slave,tier=backend
task-pv-pod                     1/1       Running   0          1d        &amp;lt;none&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然官网有推荐了一些labels&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;release&quot; : &quot;stable&quot;, &quot;release&quot; : &quot;canary&quot;
&quot;environment&quot; : &quot;dev&quot;, &quot;environment&quot; : &quot;qa&quot;, &quot;environment&quot; : &quot;production&quot;
&quot;tier&quot; : &quot;frontend&quot;, &quot;tier&quot; : &quot;backend&quot;, &quot;tier&quot; : &quot;cache&quot;
&quot;partition&quot; : &quot;customerA&quot;, &quot;partition&quot; : &quot;customerB&quot;
&quot;track&quot; : &quot;daily&quot;, &quot;track&quot; : &quot;weekly&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我感觉大家写集群的时候也并没有按照这些建议的labels。基本上一个集群有自己的一套设计。&lt;/p&gt;

&lt;p&gt;最后在总结下，ReplicationController这个已经是被淘汰的了，连k8s官网的demo已经都切换到deployment+replicaset了，所以遇到有用ReplicationController的书和文章，可以弃读了。&lt;/p&gt;
&lt;p&gt;-- 当前日期：2019年7月9日&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 00:48:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>k8s学习 概念 ReplicationController 我们有了 pod，那么就需要对 pod 进行控制，就是同一个服务的 podv我需要启动几个？如果需要扩容了，怎么办？这里就有个控制器，Re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yjf512/p/11198733.html</dc:identifier>
</item>
<item>
<title>Docker笔记（四）：Docker镜像管理 - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11198723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11198723.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.jboost.cn/2019/07/16/docker-4.html&quot;&gt;http://blog.jboost.cn/2019/07/16/docker-4.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的关系——没有类的定义就谈不上实例的创建与使用，没有镜像的定义就谈不上容器的创建与运行。&lt;/p&gt;
&lt;h2 id=&quot;1-获取镜像&quot;&gt;1. 获取镜像&lt;/h2&gt;
&lt;p&gt;镜像从哪里来，一般两个途径，一是公共镜像库，如官方镜像库Docker Hub，上面有大量的高质量的镜像直接可拿来用；二是自定义，我们可基于一个已有镜像，在其基础上增加一些层（还记得镜像的分层存储特性吧），然后构建形成自己的镜像。&lt;/p&gt;
&lt;p&gt;如果我们知道某个镜像的名称，则可直接通过&lt;code&gt;docker pull&lt;/code&gt;来下载镜像到本地，如ubuntu、redis、nginx等，&lt;code&gt;docker pull&lt;/code&gt;命令的格式如下（中括号表示可有可没有）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull [选项] [Docker Registry的地址[:端口号]/]仓库名[:标签]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中选项可设置： &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-a, –all-tags：下载仓库中所有标签（一般指版本）的镜像&lt;/li&gt;
&lt;li&gt;–disable-content-trust：跳过镜像验证，默认为true&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Docker Registry的地址即镜像仓库地址，一般为域名或IP加端口号，如果不指定则默认为Docker Hub；仓库名包含两部分，&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;，对于Docker Hub，如果不给出用户名，则默认为library，表示官方提供；标签一般是对应软件的版本号，如果不指定则默认为latest。&lt;/p&gt;
&lt;p&gt;比如我们要下一个nginx镜像，则可执行如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@iZwz9dbodbaqxj1gxhpnjxZ ~&lt;span&gt;]# docker pull nginx
Using default tag: latest
latest: Pulling from library&lt;/span&gt;/&lt;span&gt;nginx
fc7181108d40: Already exists 
d2e987ca2267: Pull complete 
0b760b431b11: Pull complete 
Digest: sha256:48cbeee0cb0a3b5e885e36222f969e0a2f41819a68e07aeb6631ca7cb356fed1
Status: Downloaded newer image &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; nginx:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们没有指定选项，也没有指定镜像仓库地址，那么默认会从Docker Hub获取镜像（但Docker Hub由于在国外，速度比较慢，所以一般要设置国内加速器，参考&lt;a href=&quot;http://blog.jboost.cn/2019/07/14/docker-3.html&quot;&gt;Docker笔记（三）：Docker安装与配置&lt;/a&gt;第二部分：配置国内镜像)，也没有给出用户名，所以默认是library（第三行），没有指定标签，所以默认是latest（第二行），由第四至第六行可见，这个镜像包含三个层，并且第一个层已经存在了（之前下载的镜像已经包含了这个层， 直接复用），镜像分层的概念及层的复用，应该已经理解了。&lt;/p&gt;

&lt;p&gt;如果我们不知道镜像的完整名称怎么办，那就搜索一下，有两个途径，一是通过命令，假设我们记不起nginx全称了， 只记得&lt;code&gt;ngi&lt;/code&gt;，则可通过如下命令搜索&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@iZwz9dbodbaqxj1gxhpnjxZ ~&lt;span&gt;]# docker search ngi
NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
nginx                             Official build of Nginx.                        &lt;/span&gt;&lt;span&gt;11693&lt;/span&gt;&lt;span&gt;               [OK]                
jwilder&lt;/span&gt;/nginx-proxy               Automated Nginx reverse proxy &lt;span&gt;for&lt;/span&gt; docker con…   &lt;span&gt;1628&lt;/span&gt;&lt;span&gt;                                    [OK]
richarvey&lt;/span&gt;/nginx-php-fpm           Container running Nginx + PHP-FPM capable of…   &lt;span&gt;726&lt;/span&gt;&lt;span&gt;                                     [OK]
bitnami&lt;/span&gt;/nginx                     Bitnami nginx Docker Image                      &lt;span&gt;69&lt;/span&gt;&lt;span&gt;                                      [OK]
linuxserver&lt;/span&gt;/nginx                 An Nginx container, brought to you by LinuxS…   &lt;span&gt;69&lt;/span&gt;&lt;span&gt;                                      
tiangolo&lt;/span&gt;/nginx-rtmp               Docker image with Nginx using the nginx-rtmp…   &lt;span&gt;48&lt;/span&gt;&lt;span&gt;                                      [OK]
nginx&lt;/span&gt;/nginx-ingress               NGINX Ingress Controller &lt;span&gt;for&lt;/span&gt; Kubernetes         &lt;span&gt;20&lt;/span&gt;&lt;span&gt;                                      
nginxdemos&lt;/span&gt;/hello                  NGINX webserver that serves a simple page co…   &lt;span&gt;18&lt;/span&gt;&lt;span&gt;                                      [OK]
jlesage&lt;/span&gt;/nginx-proxy-manager       Docker container &lt;span&gt;for&lt;/span&gt; Nginx Proxy Manager        &lt;span&gt;17&lt;/span&gt;&lt;span&gt;                                      [OK]
schmunk42&lt;/span&gt;/nginx-redirect          A very simple container to redirect HTTP tra…   &lt;span&gt;17&lt;/span&gt;&lt;span&gt;                                      [OK]
crunchgeek&lt;/span&gt;/nginx-pagespeed        Nginx with PageSpeed + GEO IP + VTS + more_s…   &lt;span&gt;13&lt;/span&gt;&lt;span&gt;                                      
blacklabelops&lt;/span&gt;/nginx               Dockerized Nginx Reverse Proxy Server.          &lt;span&gt;12&lt;/span&gt;&lt;span&gt;                                      [OK]
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令会从Docker Hub搜索镜像名包含&lt;code&gt;ngi&lt;/code&gt;的镜像，其中STARS表示收藏用户数，OFFICIAL为[OK]表示官方提供的镜像，AUTOMATED [OK]表示由自动构建生成，一般选择STARS最多，官方提供的镜像。 &lt;/p&gt;
&lt;p&gt;这种方式获取到的信息有限，比如具体包含哪些版本不知道。还有一个途径是直接在Docker Hub网站上搜索，打开 &lt;a href=&quot;https://hub.docker.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com&lt;/a&gt; ， 在搜索框输入&lt;code&gt;ngi&lt;/code&gt;，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/docker-hub.png&quot; alt=&quot;docker-hub&quot;/&gt;&lt;/p&gt;

&lt;p&gt;则会列出所有满足条件的镜像，点开&lt;code&gt;nginx&lt;/code&gt;结果链接，可以看到提供的版本（通过版本链接可以查看定义对应镜像的Dockerfile），及相应的文档说明。这种方式获取的信息更加全面，所以推荐这种方式！&lt;/p&gt;

&lt;p&gt;另外，当我们没有执行&lt;code&gt;docker pull&lt;/code&gt;，直接通过&lt;code&gt;docker run xx&lt;/code&gt;来运行一个容器时，如果没有对应的镜像，则会先自动下载镜像，再基于镜像启动一个容器，比如我们在&lt;a href=&quot;http://blog.jboost.cn/2019/07/14/docker-3.html&quot;&gt;Docker笔记（三）：Docker安装与配置&lt;/a&gt;中检验docker是否安装成功时运行的&lt;code&gt;hello-world&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/hello-docker.png&quot; alt=&quot;hello-docker&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;2-管理本地镜像&quot;&gt;2. 管理本地镜像&lt;/h2&gt;
&lt;p&gt;将镜像下载到本地后，我们可以基于镜像来创建、运行容器，及对镜像进行管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看本地镜像&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              f68d6e55e065        &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; weeks ago         109MB
mysql               latest              c7109f74d339        &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; weeks ago         443MB
hello&lt;/span&gt;-world         latest              fce289e99eb9        &lt;span&gt;6&lt;/span&gt; months ago        &lt;span&gt;1&lt;/span&gt;.84kB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面各列依次列出了镜像名称、标签（版本）、镜像ID、创建时间、镜像大小。镜像可以拥有多个标签（版本）。镜像的大小总和一般要大于实际的磁盘占有量，为什么？回忆一下镜像的分层存储概念，层是可以复用的，某个层其中一个镜像有了，另一个镜像就不会再下载了。口说无凭，我们来验证下，&lt;code&gt;docker system df&lt;/code&gt;可列出镜像、容器、数据卷所占用的空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker system &lt;span&gt;df&lt;/span&gt;&lt;span&gt;
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                   &lt;span&gt;1&lt;/span&gt;                   &lt;span&gt;497&lt;/span&gt;.1MB             &lt;span&gt;497&lt;/span&gt;.1MB (&lt;span&gt;99&lt;/span&gt;%&lt;span&gt;)
Containers          &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;                   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;                   0B                  0B
Local Volumes       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;                   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;                   0B                  0B
Build Cache         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;                   &lt;span&gt;0&lt;/span&gt;                   0B                  0B
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code&gt;docker image ls&lt;/code&gt;列出的各镜像大小总共约552MB，但这里列出的镜像大小只有约497MB，这下有凭有据了吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据条件列出镜像&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker image &lt;span&gt;ls&lt;/span&gt;&lt;span&gt; nginx # 根据名称列出镜像
docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt; nginx:latest # 根据名称与标签列出镜像
docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; -f since=hello-world:latest # -f 是--filter的缩写，过滤器参数，列出在hello-world:latest之后建立的镜像，before=hello-world:latest则查看之前建立的镜像
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;指定显示格式&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker image &lt;span&gt;ls&lt;/span&gt; -&lt;span&gt;q # 只显示镜像ID
docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; --&lt;span&gt;digests # 列出镜像摘要

docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; --format &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{.ID}}: {{.Repository}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  # 使用Go的模板语法格式化显示，这里显示格式为 镜像ID：镜像名称
docker image &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt; --format &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; # 自己定义表格格式
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;虚悬镜像&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;有时候会看到某些镜像既没有仓库名，也没有标签，均为 &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;。这些镜像原本是有镜像名和标签的，随着官方镜像维护，发布了新版本后(新版本会复用之前的镜像名称与标签，一般是bug修复版)，重新&lt;code&gt;docker pull xx&lt;/code&gt; 时， 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt; 。除了&lt;code&gt;docker pull&lt;/code&gt;可能导致这种情况， &lt;code&gt;docker build&lt;/code&gt;也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 &lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt; 的镜像。这类无标签镜像被称为虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker image &lt;span&gt;ls&lt;/span&gt; -f dangling=&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般虚悬镜像没什么意义了，可以通过如下命令删除 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker image prune
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;中间层镜像&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;为了加速镜像构建、重复利用资源，Docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的&lt;code&gt;docker image ls&lt;/code&gt;列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，可以加 -a&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ docker image &lt;span&gt;ls&lt;/span&gt; -a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会看到很多无标签的镜像，与虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;删除镜像&lt;/strong&gt;&lt;br/&gt;删除镜像命令格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker image &lt;span&gt;rm&lt;/span&gt; [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; ...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选项可以设置： &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-f, –force 强制删除镜像&lt;/li&gt;
&lt;li&gt;–no-prune 不删除没有标签的父镜像&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&amp;lt;镜像1&amp;gt;、&amp;lt;镜像2&amp;gt; 等可以是镜像的名称，镜像的全ID，也可以是镜像ID的前面几个数字（只要与其它镜像区分开来就行），或者是镜像摘要。 如删除镜像名称为mysql的镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@iZwz9dbodbaqxj1gxhpnjxZ ~]# docker image &lt;span&gt;rm&lt;/span&gt;&lt;span&gt; mysql
Untagged: mysql:latest
Untagged: mysql@sha256:415ac63da0ae6725d5aefc9669a1c02f39a00c574fdbc478dfd08db1e97c8f1b
Deleted: sha256:c7109f74d339896c8e1a7526224f10a3197e7baf674ff03acbab387aa027882a
Deleted: sha256:35d60530f024aa75c91a123a69099f7f6eaf5ad7001bb983f427f674980d8482
Deleted: sha256:49d8bb533eee600076e3a513a203ee24044673fcef0c1b79e088b2ba43db2c17
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上面命令的执行结果可见，删除镜像包括另个行为：&lt;strong&gt;Untagged&lt;/strong&gt;、&lt;strong&gt;Deleted&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;当我们使用上面命令来删除镜像的时候，实际上是在要求删除某个/某些标签的镜像。所以首先需要做的是将满足要求的所有镜像标签都取消，这就是Untagged的行为。一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么Delete行为就不会发生，仅仅是取消了这个镜像的符合要求的所有标签。所以并非所有的&lt;code&gt;docker image rm&lt;/code&gt;都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。&lt;/p&gt;
&lt;p&gt;当该镜像所有的标签都被取消了，该镜像很可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果某个其它镜像正依赖于当前镜像的某一层，这种情况，依旧不会触发删除该层的行为。直到没有任何镜像依赖当前层时，才会真实的删除当前层。&lt;/p&gt;
&lt;p&gt;另外还需要注意是容器对镜像的依赖。如果基于镜像启动的容器存在（即使容器没有运行处于停止状态） ，同样不可以删除这个镜像。我们之前说了容器是以镜像为基础，再加一层容器存储层组成的多层存储结构去运行的。所以如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过组合命令来删除&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker image &lt;span&gt;rm&lt;/span&gt; $(docker image &lt;span&gt;ls&lt;/span&gt; -&lt;span&gt;q nginx) # 删除镜像名称为nginx的所有镜像
docker image &lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; $(docker image &lt;span&gt;ls&lt;/span&gt; -q -f since=hello-world:latest) # 删除所有在hello-world:latest之后建立的镜像
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;3. 总结&lt;/span&gt; &lt;/h2&gt;
&lt;p&gt;本文对镜像的获取及本地镜像的基本管理做了介绍，本文镜像的获取途径都是从镜像仓库直接获取，镜像的另一个获取途径便是自定义，接下来会通过实例来进行介绍，欢迎关注。&lt;/p&gt;&lt;p&gt;我的个人博客地址：&lt;a href=&quot;http://blog.jboost.cn/&quot;&gt;http://blog.jboost.cn&lt;/a&gt;&lt;br/&gt;我的微信公众号：jboost-ksxy （一个不只有技术干货的公众号，欢迎关注，及时获取更新内容）&lt;br/&gt;———————————————————————————————————————————————————————————&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/qrcode-05.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 00:46:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>原文地址：http://blog.jboost.cn/2019/07/16/docker-4.html 在Docker中，应用是通过容器来运行的，而容器的运行是基于镜像的，类似面向对象设计中类与对象的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11198723.html</dc:identifier>
</item>
<item>
<title>Spring Boot 邮件发送的 5 种姿势！ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11198718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11198718.html</guid>
<description>&lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。&lt;/p&gt;

&lt;p&gt;我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。&lt;/p&gt;
&lt;p&gt;SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。&lt;/p&gt;
&lt;p&gt;生活中我们投递一封邮件要经过如下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;深圳的小王先将邮件投递到深圳的邮局&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;深圳的邮局将邮件运送到上海的邮局&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;上海的小张来邮局取邮件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 aaa@qq.com 发送邮件到 111@163.com ：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;aaa@qq.com 先将邮件投递到腾讯的邮件服务器&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;111@163.com 登录网易的邮件服务器查看邮件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。&lt;/p&gt;
&lt;p&gt;SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。&lt;/p&gt;
&lt;p&gt;也就是说 aaa@qq.com 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。&lt;/p&gt;
&lt;p&gt;而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， 111@163.com 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。&lt;/p&gt;
&lt;p&gt;最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。&lt;/p&gt;

&lt;p&gt;目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083838964-539414750.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击账户选项卡：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083852975-1048905519.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在账户选项卡中找到开启POP3/SMTP选项，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083903262-1005598228.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。&lt;/p&gt;

&lt;p&gt;接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先创建一个 Spring Boot 项目，引入邮件发送依赖：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083915999-1534329487.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，项目依赖如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置邮箱基本信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.mail.host=smtp.qq.com
spring.mail.port=587
spring.mail.username=1510161612@qq.com
spring.mail.password=ubknfzhjkhrbbabe
spring.mail.default-encoding=UTF-8
spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.debug=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置含义分别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置 SMTP 服务器地址&lt;/li&gt;
&lt;li&gt;SMTP 服务器的端口&lt;/li&gt;
&lt;li&gt;配置邮箱用户名&lt;/li&gt;
&lt;li&gt;配置密码，注意，不是真正的密码，而是刚刚申请到的授权码&lt;/li&gt;
&lt;li&gt;默认的邮件编码&lt;/li&gt;
&lt;li&gt;配饰 SSL 加密工厂&lt;/li&gt;
&lt;li&gt;表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;amp;&amp;amp;id=28&amp;amp;&amp;amp;no=371&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 &lt;code&gt;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration&lt;/code&gt; 类中，部分源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ConditionalOnClass({ MimeMessage.class, MimeType.class, MailSender.class })
@ConditionalOnMissingBean(MailSender.class)
@Conditional(MailSenderCondition.class)
@EnableConfigurationProperties(MailProperties.class)
@Import({ MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class })
public class MailSenderAutoConfiguration {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这段代码中，可以看到，导入了另外一个配置 &lt;code&gt;MailSenderPropertiesConfiguration&lt;/code&gt; 类，这个类中，提供了邮件发送相关的工具类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ConditionalOnProperty(prefix = &quot;spring.mail&quot;, name = &quot;host&quot;)
class MailSenderPropertiesConfiguration {
        private final MailProperties properties;
        MailSenderPropertiesConfiguration(MailProperties properties) {
                this.properties = properties;
        }
        @Bean
        @ConditionalOnMissingBean
        public JavaMailSenderImpl mailSender() {
                JavaMailSenderImpl sender = new JavaMailSenderImpl();
                applyProperties(sender);
                return sender;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里创建了一个 &lt;code&gt;JavaMailSenderImpl&lt;/code&gt; 的实例， &lt;code&gt;JavaMailSenderImpl&lt;/code&gt; 是 &lt;code&gt;JavaMailSender&lt;/code&gt; 的一个实现，我们将使用 &lt;code&gt;JavaMailSenderImpl&lt;/code&gt; 来完成邮件的发送工作。&lt;/p&gt;
&lt;p&gt;做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。&lt;/p&gt;
&lt;p&gt;具体的发送，有 5 种不同的方式，我们一个一个来看。&lt;/p&gt;
&lt;h2 id=&quot;发送简单邮件&quot;&gt;发送简单邮件&lt;/h2&gt;
&lt;p&gt;简单邮件就是指邮件内容是一个普通的文本文档：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
JavaMailSender javaMailSender;
@Test
public void sendSimpleMail() {
    SimpleMailMessage message = new SimpleMailMessage();
    message.setSubject(&quot;这是一封测试邮件&quot;);
    message.setFrom(&quot;1510161612@qq.com&quot;);
    message.setTo(&quot;25xxxxx755@qq.com&quot;);
    message.setCc(&quot;37xxxxx37@qq.com&quot;);
    message.setBcc(&quot;14xxxxx098@qq.com&quot;);
    message.setSentDate(new Date());
    message.setText(&quot;这是测试邮件的正文&quot;);
    javaMailSender.send(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上往下，代码含义分别如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建一个邮件对象&lt;/li&gt;
&lt;li&gt;设置邮件主题&lt;/li&gt;
&lt;li&gt;设置邮件发送者&lt;/li&gt;
&lt;li&gt;设置邮件接收者，可以有多个接收者&lt;/li&gt;
&lt;li&gt;设置邮件抄送人，可以有多个抄送人&lt;/li&gt;
&lt;li&gt;设置隐秘抄送人，可以有多个&lt;/li&gt;
&lt;li&gt;设置邮件发送日期&lt;/li&gt;
&lt;li&gt;设置邮件的正文&lt;/li&gt;
&lt;li&gt;发送邮件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后执行该方法，就可以实现邮件的发送，发送效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083932977-613086797.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;发送带附件的邮件&quot;&gt;发送带附件的邮件&lt;/h2&gt;
&lt;p&gt;邮件的附件可以是图片，也可以是普通文件，都是支持的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void sendAttachFileMail() throws MessagingException {
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true);
    helper.setSubject(&quot;这是一封测试邮件&quot;);
    helper.setFrom(&quot;1510161612@qq.com&quot;);
    helper.setTo(&quot;25xxxxx755@qq.com&quot;);
    helper.setCc(&quot;37xxxxx37@qq.com&quot;);
    helper.setBcc(&quot;14xxxxx098@qq.com&quot;);
    helper.setSentDate(new Date());
    helper.setText(&quot;这是测试邮件的正文&quot;);
    helper.addAttachment(&quot;javaboy.jpg&quot;,new File(&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;));
    javaMailSender.send(mimeMessage);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。&lt;/p&gt;
&lt;p&gt;最后通过 addAttachment 方法来添加一个附件。&lt;/p&gt;
&lt;p&gt;执行该方法，邮件发送效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083946303-1731253585.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;发送带图片资源的邮件&quot;&gt;发送带图片资源的邮件&lt;/h2&gt;
&lt;p&gt;图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void sendImgResMail() throws MessagingException {
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
    helper.setSubject(&quot;这是一封测试邮件&quot;);
    helper.setFrom(&quot;1510161612@qq.com&quot;);
    helper.setTo(&quot;25xxxxx755@qq.com&quot;);
    helper.setCc(&quot;37xxxxx37@qq.com&quot;);
    helper.setBcc(&quot;14xxxxx098@qq.com&quot;);
    helper.setSentDate(new Date());
    helper.setText(&quot;&amp;lt;p&amp;gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;第一张图片：&amp;lt;/p&amp;gt;&amp;lt;img src='cid:p01'/&amp;gt;&amp;lt;p&amp;gt;第二张图片：&amp;lt;/p&amp;gt;&amp;lt;img src='cid:p02'/&amp;gt;&quot;,true);
    helper.addInline(&quot;p01&quot;,new FileSystemResource(new File(&quot;C:\\Users\\sang\\Downloads\\javaboy.png&quot;)));
    helper.addInline(&quot;p02&quot;,new FileSystemResource(new File(&quot;C:\\Users\\sang\\Downloads\\javaboy2.png&quot;)));
    javaMailSender.send(mimeMessage);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。&lt;/p&gt;
&lt;p&gt;setText 之后，再通过 addInline 方法来添加图片资源。&lt;/p&gt;
&lt;p&gt;最后执行该方法，发送邮件，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717083958018-97712426.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 &lt;code&gt;Freemarker&lt;/code&gt; 模板和 &lt;code&gt;Thyemeleaf&lt;/code&gt; 模板了。&lt;/p&gt;
&lt;h2 id=&quot;使用-freemarker-作邮件模板&quot;&gt;使用 Freemarker 作邮件模板&lt;/h2&gt;
&lt;p&gt;首先需要引入 Freemarker 依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-freemarker&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 &lt;code&gt;resources/templates&lt;/code&gt; 目录下创建一个 &lt;code&gt;mail.ftl&lt;/code&gt; 作为邮件发送模板：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;hello 欢迎加入 xxx 大家庭，您的入职信息如下：&amp;lt;/p&amp;gt;
&amp;lt;table border=&quot;1&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;姓名&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${username}&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;工号&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${num}&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;薪水&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${salary}&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;div style=&quot;color: #ff1a0e&quot;&amp;gt;一起努力创造辉煌&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，将邮件模板渲染成 HTML ，然后发送即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void sendFreemarkerMail() throws MessagingException, IOException, TemplateException {
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
    helper.setSubject(&quot;这是一封测试邮件&quot;);
    helper.setFrom(&quot;1510161612@qq.com&quot;);
    helper.setTo(&quot;25xxxxx755@qq.com&quot;);
    helper.setCc(&quot;37xxxxx37@qq.com&quot;);
    helper.setBcc(&quot;14xxxxx098@qq.com&quot;);
    helper.setSentDate(new Date());
    //构建 Freemarker 的基本配置
    Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);
    // 配置模板位置
    ClassLoader loader = MailApplication.class.getClassLoader();
    configuration.setClassLoaderForTemplateLoading(loader, &quot;templates&quot;);
    //加载模板
    Template template = configuration.getTemplate(&quot;mail.ftl&quot;);
    User user = new User();
    user.setUsername(&quot;javaboy&quot;);
    user.setNum(1);
    user.setSalary((double) 99999);
    StringWriter out = new StringWriter();
    //模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可
    template.process(user, out);
    helper.setText(out.toString(),true);
    javaMailSender.send(mimeMessage);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，虽然引入了 &lt;code&gt;Freemarker&lt;/code&gt; 的自动化配置，但是我们在这里是直接 &lt;code&gt;new Configuration&lt;/code&gt; 来重新配置 &lt;code&gt;Freemarker&lt;/code&gt; 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 &lt;code&gt;templates&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;调用该方法，发送邮件，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717084012217-441303768.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-thymeleaf-作邮件模板&quot;&gt;使用 Thymeleaf 作邮件模板&lt;/h2&gt;
&lt;p&gt;推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。&lt;/p&gt;
&lt;p&gt;首先，引入 Thymeleaf 依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，创建 &lt;code&gt;Thymeleaf&lt;/code&gt; 邮件模板：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;hello 欢迎加入 xxx 大家庭，您的入职信息如下：&amp;lt;/p&amp;gt;
&amp;lt;table border=&quot;1&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;姓名&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&quot;${username}&quot;&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;工号&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&quot;${num}&quot;&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;薪水&amp;lt;/td&amp;gt;
        &amp;lt;td th:text=&quot;${salary}&quot;&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;div style=&quot;color: #ff1a0e&quot;&amp;gt;一起努力创造辉煌&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来发送邮件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
TemplateEngine templateEngine;

@Test
public void sendThymeleafMail() throws MessagingException {
    MimeMessage mimeMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);
    helper.setSubject(&quot;这是一封测试邮件&quot;);
    helper.setFrom(&quot;1510161612@qq.com&quot;);
    helper.setTo(&quot;25xxxxx755@qq.com&quot;);
    helper.setCc(&quot;37xxxxx37@qq.com&quot;);
    helper.setBcc(&quot;14xxxxx098@qq.com&quot;);
    helper.setSentDate(new Date());
    Context context = new Context();
    context.setVariable(&quot;username&quot;, &quot;javaboy&quot;);
    context.setVariable(&quot;num&quot;,&quot;000001&quot;);
    context.setVariable(&quot;salary&quot;, &quot;99999&quot;);
    String process = templateEngine.process(&quot;mail.html&quot;, context);
    helper.setText(process,true);
    javaMailSender.send(mimeMessage);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用该方法，发送邮件，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190717084025949-409997168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？&lt;/p&gt;
&lt;p&gt;本文案例已经上传到 GitHub：&lt;a href=&quot;https://github.com/lenve/javaboy-code-samples&quot; class=&quot;uri&quot;&gt;https://github.com/lenve/javaboy-code-samples&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;有问题欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190710095647242-469154686.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 00:41:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11198718.html</dc:identifier>
</item>
<item>
<title>高精度计算（四）：大整数乘法（采用“万进制”） - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/11198710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/11198710.html</guid>
<description>&lt;p&gt;【例1】大整数乘法。&lt;/p&gt;
&lt;p&gt;      编写一个程序，求两个不超过200 位的非负整数的积。&lt;/p&gt;
&lt;p&gt;      （1）编程思路。&lt;/p&gt;
&lt;p&gt;      大整数乘大整数，实质就是在小学竖式乘法的基础上枚举各个乘数位与被乘数相乘，累加到结果当中。其中乘数中的第j位与被乘数中的第i位相乘时，结果应该保存到结果的第i＋j－1位中。&lt;/p&gt;
&lt;p&gt;      （2）源程序。&lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt;using namespace std;&lt;br/&gt;const int base=10000;&lt;br/&gt;const int maxlen=50+2;&lt;br/&gt;void charTobignum(char *ch,int *bignum)&lt;br/&gt;{&lt;br/&gt;      int len,i,j,p,num;&lt;br/&gt;      memset(bignum,0,sizeof(int)*maxlen);&lt;br/&gt;      len=strlen(ch);&lt;br/&gt;      bignum[0]=len%4==0?len/4:len/4+1;&lt;br/&gt;      i=1;&lt;br/&gt;      while (i&amp;lt;=len/4)&lt;br/&gt;      {&lt;br/&gt;          num=0;&lt;br/&gt;          p=len-4*i;&lt;br/&gt;          for(j=1;j&amp;lt;=4;j++)&lt;br/&gt;              num=num*10+(ch[p++]-'0');&lt;br/&gt;          bignum[i]=num;&lt;br/&gt;          i++;&lt;br/&gt;       }&lt;br/&gt;       if (len%4!=0)&lt;br/&gt;       {&lt;br/&gt;            num=0;&lt;br/&gt;            for (i=0;i&amp;lt;=len%4-1;i++)&lt;br/&gt;                 num=num*10+(ch[i]-'0');&lt;br/&gt;            bignum[len/4+1]=num;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;void printbignum(int *bignum)&lt;br/&gt;{&lt;br/&gt;       int *p=*bignum+bignum;&lt;br/&gt;       cout&amp;lt;&amp;lt;*p--;&lt;br/&gt;       cout.fill('0'); // 定义填充字符'0'&lt;br/&gt;       while(p&amp;gt;bignum)  { cout.width(4); cout&amp;lt;&amp;lt;*p--; }&lt;br/&gt;       cout&amp;lt;&amp;lt;endl;&lt;br/&gt;}&lt;br/&gt;void multiply( int *bignum1, int *bignum2, int *bignum_ans)&lt;br/&gt;{&lt;br/&gt;      int carry=0, i, j;&lt;br/&gt;      memset(bignum_ans, 0, sizeof(int)*2*maxlen);&lt;br/&gt;      for (j=1; j&amp;lt;=bignum2[0]; j++){&lt;br/&gt;           for(i=1; i&amp;lt;=bignum1[0]; i++){&lt;br/&gt;               bignum_ans[i+j-1]+=carry+bignum1[i]*bignum2[j];&lt;br/&gt;               carry=bignum_ans[i+j-1]/base;&lt;br/&gt;               bignum_ans[i+j-1]%=base;&lt;br/&gt;            }&lt;br/&gt;            i=j+bignum1[0];&lt;br/&gt;            while(carry){&lt;br/&gt;                 bignum_ans[i++]=carry%base;&lt;br/&gt;                carry/=base;&lt;br/&gt;            }&lt;br/&gt;       }&lt;br/&gt;       bignum_ans[0]=bignum1[0]+bignum2[0];&lt;br/&gt;       while( !bignum_ans[*bignum_ans] ) --bignum_ans[0];&lt;br/&gt;}&lt;br/&gt;int main()&lt;br/&gt;{&lt;br/&gt;       int bignum1[maxlen],bignum2[maxlen],bignum_result[2*maxlen];&lt;br/&gt;      char numstr[maxlen];&lt;br/&gt;      cout&amp;lt;&amp;lt;&quot;请输入第1个大整数：&quot;;&lt;br/&gt;      cin&amp;gt;&amp;gt;numstr;  &lt;br/&gt;      charTobignum(numstr,bignum1);&lt;br/&gt;      cout&amp;lt;&amp;lt;&quot;请输入第2个大整数：&quot;;&lt;br/&gt;      cin&amp;gt;&amp;gt;numstr;&lt;br/&gt;      charTobignum(numstr,bignum2);&lt;br/&gt;      multiply(bignum1,bignum2,bignum_result);&lt;br/&gt;      cout&amp;lt;&amp;lt;&quot;两个大整数的积是 ：&quot;;&lt;br/&gt;      printbignum(bignum_result);&lt;br/&gt;      return 0;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;      将上面源程序中的输入输出提示语句删除后，提交给POJ 2389 &lt;span&gt;“Bull Math”&lt;/span&gt;，可以Accepted。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jul 2019 00:39:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>【例1】大整数乘法。 编写一个程序，求两个不超过200 位的非负整数的积。 （1）编程思路。 大整数乘大整数，实质就是在小学竖式乘法的基础上枚举各个乘数位与被乘数相乘，累加到结果当中。其中乘数中的第j</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/11198710.html</dc:identifier>
</item>
<item>
<title>架构杂谈《四》 - AjuPrince</title>
<link>http://www.cnblogs.com/haoxiaozhang/p/11197729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxiaozhang/p/11197729.html</guid>
<description>&lt;h2&gt;分布式一致性协议&lt;/h2&gt;
&lt;h3&gt;一、引言&lt;/h3&gt;
&lt;p&gt;　　在分布式系统中，为了保证数据的高可用，通常会将数据保留多个副本(replica)，这些个副本会放在不同的物理机上，为了对用户提供正确的数据，我们需要保证这些放在不同物理机上的副本是一致的。为了解决这种分布式一致性问题，提出了很多经典的协议和算法，比较著名的是 两阶段提交协议和三阶段提交协议。&lt;/p&gt;
&lt;h3&gt;二、两阶段提交协议&lt;/h3&gt;
&lt;p&gt;　　两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，一个是提交阶段。准备阶段和提交阶段都是由事务管理器发起的，两阶段提交协议的流程如下：&lt;/p&gt;
&lt;p&gt;　　1、准备阶段：事务管理器向资源管理器发起指令，资源管理器评估自己的状态，如果资源管理器评估指令可以完成。则会写redo或者undo日志，然后锁定资源，执行操作，但是并不会提交&lt;/p&gt;
&lt;p&gt;　　2、提交阶段：如果每个资源管理器明确返回准备成功，事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何一个资源管理明确返回准备失败，则事务管理器向资源管理器发起中止指令，资源管理器取消已经变更的事务，执行undo日志。释放锁定的资源。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/562098/201907/562098-20190716210233728-1252766898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（&lt;span class=&quot;fontstyle0&quot;&gt;两阶段提交协议的成功场景图&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　我们从上图中可以看到，两阶段提交协议在准备阶段锁定资源，这是一个重量级的操作，能保证强一致性，但是实现起来复杂、成本大、不够灵活。还有以下缺点：&lt;/p&gt;
&lt;p&gt;　　　  （1）、阻塞：对于任何一次指令都必须收到明确的响应，才会继续进行下一步，否则处于阻塞状态，占用的资源一直被锁定，不会释放&lt;/p&gt;
&lt;p&gt;　　　  （2）、单点故障：如果事务管理器（协调者）挂了（宕机），资源管理器（参与者）没有事务管理器（协调者）指挥，则会一直阻塞，尽管可以通过选举新的协调者替代原有的协调者，但是参与者接收后也宕机，则新上任的协调者无法处理这种情况&lt;/p&gt;
&lt;p&gt;　　　  （3）、脑裂：协调者发送提交指令，有的参与者接收到并执行了事务，有的参与者没有接收到事务就没有执行事务，多个参与者之间是不一致的。&lt;/p&gt;
&lt;p&gt;　　上面的问题虽然很少发生，但每次发生都需要人工参与，没有自动化解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但在出现异常的情况下，需要人工干预解决，因此可用性不够好，其实这也符合CAP协议的一致性和可用性不能兼得的原理。&lt;/p&gt;
&lt;h3&gt;三、三阶段提交协议&lt;/h3&gt;
&lt;p&gt;　　三阶段提交协议是两阶段提交协议的改进版本，它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段。&lt;/p&gt;
&lt;p&gt;　　1、询问阶段：事务管理器（协调者）询问参与者（资源管理器）是否可以完成指令，参与者只需要回答是或者否，而不需要做真正的操作，这个阶段超时会导致中止。&lt;/p&gt;
&lt;p&gt;　　2、准备阶段：如果在询问阶段所有参与者都返回可以执行操作，则协调者向参与者发送预执行请求，然后参与者写 redo 和 undo 日志，执行操作但不提交操作；如果在询问阶段任何一个参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑和两阶段提交协议的准备阶段是相似的。&lt;/p&gt;
&lt;p&gt;　　3、提交阶段：如果每个参与者在准备阶段返回准备成功，则协调者向参与者发送提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回准备失败，则协调者向参与者发送中止指令，参与者自己取消已经变更的事务，执行 undo 日志，释放锁定的资源。这里的逻辑和两阶段提交协议的提交阶段一致。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/562098/201907/562098-20190716212348201-1626075452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　（三阶段提交协议的成功场景图）&lt;/p&gt;
&lt;p&gt;　　三阶段提交协议与两阶段提交协议主要有以下不同点：&lt;/p&gt;
&lt;p&gt;　　　　（1）、增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生。&lt;/p&gt;
&lt;p&gt;　　　　（2）、在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，则协调者和参与者都会继续提交事务，默认为成功。&lt;/p&gt;
&lt;p&gt;　　三阶段提交协议与两阶段提交协议相比，具有以上的优点，但是一旦发生超时，系统仍然会发生不一致，只不过这种情况很少见。好处是不会阻塞和永远锁定资源。　　&lt;/p&gt;
&lt;h3&gt;四、TCC&lt;/h3&gt;
&lt;p&gt;　　两阶段和三阶段提交协议，在遇到极端情况时，系统会产生阻塞或者不一致的问题，需要人干预解决。两阶段及三阶段方案中都包含多个参与者、多个阶段实现一个事务。实现事务，性能也是一个很大的问题。因此在互联网的高并发系统中，很少有使用两阶段提交和三阶段提交协议的场景。&lt;/p&gt;
&lt;p&gt;　　后来有人提出了TCC协议，TCC协议将一个任务分成 Try、Confirm、Cancel 三个步骤。正常的流程会先执行 Try，如果执行没有问题，则再执行 Confirm，如果执行过程中出现了异常。则执行操作的逆操作 Cancel。从正常的流程上讲。这还是一个两阶段提交协议，但在执行出现异常后有一定的自我修复能力，如果任何参与者出现了问题，则协调者通过执行操作的逆操作来 Cancel 之前的操作。达到最终一致性状态。&lt;/p&gt;
&lt;p&gt;　　可以看出，从时序上讲，如果遇到机端情况，则TCC会有很多问题，如：如果在取消时一些参与者收到指令，而另一些参与者没有收到指令，则整个系统任然是不一致的，对于这种复杂的情况，系统首先会通过补偿的方式尝试自我修复，如果系统无法修复。还是需要人工干预解决。&lt;/p&gt;
&lt;p&gt;　　从 TCC 的逻辑上来看，它是简化版的三阶段提交协议，解决了两阶段提交协议的阻塞问题，但还是没有解决极端情况下出现的问题（不一致和脑裂问题）。然而，TCC 通过自动化补偿手段，将需要人工处理的不一致问题降到最低，也是一种很有用的解决方案。&lt;/p&gt;
&lt;p&gt;                                  &lt;img src=&quot;https://img2018.cnblogs.com/blog/562098/201907/562098-20190716214546399-1690219193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（TCC 协议的使用场景）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、参考书籍：《分布式服务架构：原理、设计与实战》&lt;/p&gt;
&lt;p&gt;　　2、如有不合适的地方请反馈。综合后更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562098/201907/562098-20190714145641229-1447018335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jul 2019 00:35:00 +0000</pubDate>
<dc:creator>AjuPrince</dc:creator>
<og:description>架构杂谈《四》 分布式一致性协议 一、引言 在分布式系统中，为了保证数据的高可用，通常会将数据保留多个副本(replica)，这些个副本会放在不同的物理机上，为了对用户提供正确的数据，我们需要保证这些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxiaozhang/p/11197729.html</dc:identifier>
</item>
<item>
<title>徒手教你制作运维监控大屏 - 欢醉</title>
<link>http://www.cnblogs.com/zhangs1986/p/11180694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangs1986/p/11180694.html</guid>
<description>&lt;p&gt;　　公司业务的不断发展，紧接而来的是业务种类的增加、服务器数量的增长、网络环境的越发复杂以及发布更加频繁，从而不可避免地带来了线上事故的增多，因此需要对服务器到应用的全方位监控，提前预警。&lt;/p&gt;
&lt;p&gt;　　建立在Zabbix上的服务器监控、基础应用监控（mysql、redis、ES等）、预警功能 基本满足底层的监控预警要求，超过设定的阀值就会提前通知相关人员去解决。&lt;/p&gt;
&lt;p&gt;　　有了Zabbix为什么还需要Grafana？&lt;/p&gt;
&lt;p&gt;　　Zabbix图表聚合功能非常薄弱，这不是它的强项，而且数据源只限定自己的收集器，图表展示类就是Grafana的强项。&lt;/p&gt;
&lt;p&gt;　　日志监控用ELG来查看，Kibana在日志量达到一个级别后展现会出现性能问题，集中展示没有Grafana强大，因此用Grafana代替Kibana。&lt;/p&gt;
&lt;p&gt;　　微服务容器相关的监控用Prometheus生态工具，查看容器应用的CPU、内存、JVM等相关指标。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　还有服务的链路监控APM，对分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统，查看微服务间的调用链路状态。&lt;/p&gt;
&lt;p&gt;　　现有整套监控系统现状是各自平台监控内容分散，无法统一实时查看，分散精力，因此需要将各平台主要监控的内容抽出来，统一在一个平台展示。&lt;/p&gt;
&lt;p&gt;　　在公司开发人员资源紧张的情况下，想要快速搭建起一套运维大屏可以使用Grafana。&lt;/p&gt;
&lt;p&gt;　　Grafana 是一个开源的监控数据分析和可视化套件。最常用于对基础设施和应用数据分析的时间序列数据进行可视化分析，也可以用于其他需要数据可视化分析的领域。Grafana 可以帮助你查询、可视化、告警、分析你所在意的指标和数据。可以与整个团队共享，有助于培养团队的数据驱动文化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Grafana 有强大的社区支持，有丰富的模板插件，足够满足需要的功能特性。几乎可以集成ElasticSearch、Mysql、Zabbix、InfluxDB、Prometheus和OpenTSDB作为数据源。&lt;/p&gt;
&lt;p&gt;        下面就Grafana对接各平台实践操作过程做详细介绍。&lt;/p&gt;
&lt;h2&gt;展示服务器可用内存指标&lt;/h2&gt;
&lt;p&gt;　　服务器可用内存是一个非常重要的指标，因此需要实时关注，防止出现陡坡式的下滑而被忽略。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　内存信息可从Zabbix中抽取，先添加Zabbix数据源&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在Grafana添加数据源，选择Zabbix，然后填写Zabbix的API地址，用户名密码。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　url：http://192.168.0.1:8080/zabbix/php/api_jsonrpc.php&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713145959271-179755661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存后，添加一个看板，选择Graph&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150034492-931334019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入编辑页面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150043414-2077257242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;选择Zabbix为数据源&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150057087-1761808886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;选择Group和Host，对应下拉框是Grafana自动从数据源拉取的内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150105363-171350551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150112289-444723500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Group对应Zabbix中的群组，Host对应主机，Application对应应用集，item对应是的指标。&lt;/p&gt;
&lt;p&gt;这里我们选择想要监控服务器后，选择item对应的可用内存指标：Available memory。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150126044-381732814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到Axes,选择单位&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150135717-617408505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到Legend，选择展示最小值和最大值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150201086-106989877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;切换到Display调整线条和背景色的深浅。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150208642-792985734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;切换到Thresholds设置警戒线，在20G以上是安全的，20G到5G是警告，5G以下就是报警红色（请忽略下面图中的值）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150218492-879761149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到此可以看到已经配置完成可看到完整的可用内存走势。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150227011-75237243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;几十台服务器需要一台一台配置？&lt;/h3&gt;
&lt;p&gt;如果想要看所有服务器的可用内存指标难道需要一台一台添加？&lt;/p&gt;
&lt;p&gt;Grafana提供复制功能，制作好一个可按照规则复制，先添加服务器分类&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150236784-1262402766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150245527-505200217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体内容：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150257116-571315087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Host选项时因为有Windows服务器，服务器名以B开头，所以先排除以B开头的服务器，这里要说明的是正则是以javascript正则表达式为准的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150307213-1328070082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保存返回后，就会显示两个下拉框，可以对图形展示进行过滤。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150315512-856457304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择上图的Repeat，value选择按照服务器名host指标（上一步配置的）进行横向复制，一行最少24/4=6个。&lt;/p&gt;
&lt;p&gt;将监控指标更改为下图所示，item更改为包含memory关键字的，会显示 总内存和可用内存。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150441689-601846566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保存刷新页面就会将所有服务器的内存展示出来。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150502858-1581570994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其它属性请自行调整。&lt;/p&gt;
&lt;h3&gt;流量监控&lt;/h3&gt;
&lt;p&gt;所有服务器的进出流量监控大屏制作步骤参考内存监控内容，不过监控项item改成如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150517341-1251503800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;日志监控&lt;/h2&gt;
&lt;p&gt;日志监控包括了业务的访问日志accesslog和自定义info\error log日志。&lt;/p&gt;
&lt;p&gt;可以从访问日志中提取某个业务的访问量、响应时长、客户端ip、响应码等等。&lt;/p&gt;
&lt;p&gt;这里就其中一个做介绍。&lt;/p&gt;
&lt;p&gt;先添加数据源，ElasticSearch，有认证的话需要填写认证信息。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150533662-1547773440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查询访问量最多的前10个服务，用饼形图展示占比。&lt;/p&gt;
&lt;p&gt;添加图形组件，选择数据源为上步添加的内容。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150547839-82039229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;指标选择条数count，按servername（这里记录到ES服务的名称，若有自定义的自行更改）维度统计，选择Top 10。&lt;/p&gt;
&lt;p&gt;切换Options，显示total指标到图形右侧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150556657-1945551054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样就完成了对接ElasticSearch的图表制作。&lt;/p&gt;
&lt;p&gt;与服务访问相关的内容其实Grafana官方有Nginx等相关的看板模板，直接下载模板后选择数据源就可以展现相关的指标，非常漂亮。&lt;/p&gt;
&lt;h3&gt;如何排除访问量中非业务相关的内容？&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150607521-1971140067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ES的Query语法，非常粗暴直接的方法用NOT排除不关心的内容或干扰内容。&lt;/p&gt;
&lt;h2&gt;带查询的表格方式展示日志列表&lt;/h2&gt;
&lt;p&gt;查询日志时可按条件过滤，如只按关心的服务或关键字查询。&lt;/p&gt;
&lt;p&gt;添加看板，选择Table。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150620892-1042175235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先添加服务列表和日志等级，关键字输入框&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150649430-2097712367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150656464-180440055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细内容如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150708588-1532260606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第二个参数&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150716404-774351980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Info指标是自己定义的，就不从数据里面读取。&lt;/p&gt;
&lt;p&gt;第三个参数选择输入框类型。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150728549-249749904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编辑图表，查询内容按以下条件过滤，$代表所选变量。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150738082-1103155363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Json Data，然后添加需要展示的列。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150748373-191044035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由于列名都是code，不太直观，因此可以映射成中文名，切换标签后填写需要映射的列名和中文名，选择类型，可以格式化，可以对值为空时作处理，最后可以对值落入的范围判断进行颜色标示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150800610-20478033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后样式如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150808670-130122580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;展示Docker中容器内服务的内存监控&lt;/h2&gt;
&lt;p&gt;容器内的监控采用的是Prometheus + Cadvisor方案，这里只讲收集后的展示。&lt;/p&gt;
&lt;p&gt;添加数据源，指向部署好的Prometheus&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713150823342-1407036606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Prometheus的查询使用的是PromSQL，PromQL (Prometheus Query Language) 是 Prometheus 自己开发的数据查询 DSL 语言，语言表现力非常丰富，内置函数很多，在日常数据可视化以及rule 告警中都会使用到它。&lt;/p&gt;
&lt;p&gt;　　在页面 http://localhost:9099/graph 中，输入下面的查询语句，查看结果，例如：&lt;/p&gt;
&lt;p&gt;　　http_requests_total{code=&quot;200&quot;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与Mysql&lt;/strong&gt;&lt;strong&gt;的查询对比，模糊查询: code&lt;/strong&gt; &lt;strong&gt;为 2xx&lt;/strong&gt; &lt;strong&gt;的数据&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PromQL
http_requests_total{code&lt;/span&gt;&lt;span&gt;~=&lt;/span&gt;&lt;span&gt;&quot;2xx&quot;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MySQL
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; http_requests_total &lt;span&gt;WHERE&lt;/span&gt; code &lt;span&gt;LIKE&lt;/span&gt; &quot;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&quot; &lt;span&gt;AND&lt;/span&gt; created_at &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;1495435700&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;1495435710&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;添加一个图表，选择数据源Prometheus&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220207978-1982209516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;监控容器内服务内存用方法container_memory_rss，具体语法使用可进入Prometheus页面去查看每个指标，&lt;a href=&quot;https://songjiayang.gitbooks.io/prometheus/content/promql/summary.html&quot;&gt;https://songjiayang.gitbooks.io/prometheus/content/promql/summary.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它的图表属性设置与前面的设置方法一致，这里不做展开讲，最后保存展示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220222051-1799304108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上不会自己去画每个图表，而是去Grafana模板市场去下载别人上传的模板或官方模板，&lt;a href=&quot;https://grafana.com/plugins?utm_source=grafana_plugin_list&quot;&gt;https://grafana.com/plugins?utm_source=grafana_plugin_list&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;关于同环比的问题&lt;/h3&gt;
&lt;p&gt;　　Gafana没有提供一个同环比展示的图表，这一块也是与每个数据源有关，数据源不支持，Gafana也无法展示，在众多数据源里面PromSQL是基于时间序列的，是可以实现同环比功能的，因此可以先用PromSQL来查询出同环比数据再进行展示。&lt;/p&gt;
&lt;h2&gt;综合大屏展示&lt;/h2&gt;
&lt;p&gt;　　以上内容都是分模块的，现在想把服务器、业务访问流量、容器状态放在一个大屏内显示，每一块都来各自的数据源。&lt;/p&gt;
&lt;p&gt;        关键在于一块大屏要展示哪些关键信息，摈弃掉无关紧要的内容，下面是其中一个大屏，具体制作方式与上面一样，其中图形大小与布局需要根据投影到大屏上的分辨率有关，需要现场调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220246987-589821469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;关于大屏展示的技巧&lt;/h3&gt;
&lt;p&gt;Grafana提供一个大屏展示轮播功能，几个看板之间自动切换，具体就是Playlists。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220301024-1703270450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给大屏一个名字，和切换间隔，然后将需要轮播的看板加入。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220310659-861836499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存后，回到列表，选择播放模式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/273387/201907/273387-20190713220320888-891164310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　与普通模式区别在于，这两种模式下会全屏，隐藏不相关的内容，如地址栏、任务栏和图标，而且图表自适应屏幕大小。两种模式的介绍参考官网：&lt;a href=&quot;https://grafana.com/docs/reference/playlist/&quot;&gt;https://grafana.com/docs/reference/playlist/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;关于Grafana预警功能&lt;/h3&gt;
&lt;p&gt;　　Grafana的预警功能比较薄弱，最大的问题是预警配置不支持模板变量，这就导致如内存低于2G时预警，图表用的是模板内容，含有$host变量就无法预警，只适合于不含变量的图表，没有Zabbix的预警功能方便，因此建议预警用Zabbix来实现。&lt;/p&gt;
&lt;p&gt;        Grafana还可对接很多数据源，需要自行去探索，有能力的可以进行二次开发，打造自己的监控大屏。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jul 2019 00:26:00 +0000</pubDate>
<dc:creator>欢醉</dc:creator>
<og:description>公司业务的不断发展，紧接而来的是业务种类的增加、服务器数量的增长、网络环境的越发复杂以及发布更加频繁，从而不可避免地带来了线上事故的增多，因此需要对服务器到应用的全方位监控，提前预警。 建立在Zabb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangs1986/p/11180694.html</dc:identifier>
</item>
<item>
<title>Git使用小技巧之免密登录 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11198658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11198658.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小代同学在使用Git的过程中发现，每次向远程仓库推送代码的时候都需要输入账号密码。做为一个程序员，多多少少都会有偷懒的思维。那么如何才能避免每次都要输入账号密码呢？一番研究之后，小代同学发现了两种实现方式。一种是让Git记住密码，第二种就是使用SSH协议推送。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;首先我们需要准备一个和小代差不多的环境，这样才能完整的模拟小代同学的操作。第一步我们需要在Github上创建一个仓库，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/17/16bfd364377b7ed6?w=730&amp;amp;h=661&amp;amp;f=png&amp;amp;s=41575&quot; alt=&quot;创建Github仓库&quot;/&gt;&lt;br/&gt;远程仓库创建完成后，我们需要将其克隆到本地。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/ganchaoyang/git-test.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现每次向远程仓库&lt;code&gt;PUSH&lt;/code&gt;代码的时候都会提示输入账号密码，如下所示：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;root@server01:~/git-test# git push
Username for 'https://github.com': ganchaoyang
Password for 'https://ganchaoyang@github.com':&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我本地就有了一个和小代同学差不多的环境，下面我们就一起来看下小代同学是如何操作的吧。&lt;/p&gt;
&lt;h3 id=&quot;git记住密码&quot;&gt;Git记住密码&lt;/h3&gt;
&lt;p&gt;首先小代同学尝试的是第一种方式--记住密码。这种方式只需要设置&lt;code&gt;credential.helper = store&lt;/code&gt;配置就可以了。那么怎么设置呢？很简单一行命令就可以搞定。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git config --global credential.helper store&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完这句命令后，我们会发现在用户主目录下的&lt;code&gt;.git/config&lt;/code&gt;文件里面会多了一项配置。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[credential]
        helper = store&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们发现我只需要在第一次推送的时候输入账号密码，第二次往后都不需要再输入密码了。&lt;code&gt;--global&lt;/code&gt;的配置是对该用户全局生效的，如果你只想当前项目生效，在配置的时候只需要去掉&lt;code&gt;--global&lt;/code&gt;即可。当然了，如果你不想执行命令，直接Copy上面配置的内容到你的&lt;code&gt;.git/config&lt;/code&gt;文件里面也是可以的。&lt;/p&gt;
&lt;h3 id=&quot;ssh协议方式&quot;&gt;SSH协议方式&lt;/h3&gt;
&lt;p&gt;小代还发现一种可以实现无需密码就往远程推送代码的方式，那就是配置SSH KEY。那么如何配置呢？&lt;br/&gt;1.首先，我们需要在我们本地的机器上生成一对ssh的公私钥。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;root@server01:~/git-test# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:iik07xiElU3zph5Gv3VbwSUEhRX9vpHhz1ZaRegndzw root@server01
The key's randomart image is:
+---[RSA 2048]----+
|    o     .**o.. |
|   + o    .. oo .|
|  o o o     o. + |
| o . +       .oEB|
|. + + . S . . .=*|
| o = + + . o   ++|
|  o = o   .    +=|
|   =          ..+|
|  . .          . |
+----[SHA256]-----+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间的&lt;code&gt;Enter passphrase&lt;/code&gt;是让你输入密钥的访问密码，如果不需要的话直接回车即可。公私钥对默认生成在用户主目录下的&lt;code&gt;.ssh/&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;2.第二步我们需要将公钥复制到Github上。在用户设置界面有个&lt;code&gt;SSH and GPG keys&lt;/code&gt;，我们点击它并选择新建一个&lt;code&gt;SSH key&lt;/code&gt;,然后将公钥复制进去即可。在Github上添加SSH公钥的详细操作步骤可以参考&lt;a href=&quot;https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account&quot;&gt;官网的教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/17/16bfd364378e69b4?w=1009&amp;amp;h=572&amp;amp;f=png&amp;amp;s=34650&quot; alt=&quot;添加SSH key&quot;/&gt;&lt;br/&gt;3.这一步我们需要修改本地仓库中的远程仓库的地址，其实我们只需将.git/config文件中远程仓库的地址由http的地址换成ssh的地址即可。（PS：这两种协议的地址都可以在Github上获取。）&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 修改前
[remote &quot;origin&quot;]
    url = https://github.com/ganchaoyang/git-test.git
    fetch = +refs/heads/*:refs/remotes/origin/*

# 修改后
[remote &quot;origin&quot;]
    url = git@github.com:ganchaoyang/git-test.git
    fetch = +refs/heads/*:refs/remotes/origin/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.到这一步我们已经完成了SSH的配置，只需要推送一下代码测试一下即可。你会发现真的不需要密码了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 259 bytes | 259.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:ganchaoyang/git-test.git
   e8bcffc..6e1e8a9  master -&amp;gt; master
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;今天这篇文章主要介绍了两种推送代码无需输入远程仓库账号密码的方式，分别是让Git记住密码以及配置&lt;code&gt;SSH KEY&lt;/code&gt;，希望能够对你有所帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:学习不止，码不停蹄！如果您喜欢我的文章，就关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://g-blog.oss-cn-beijing.aliyuncs.com/image/qrcode_for_gh_526c6f450b21_258.jpg&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 17 Jul 2019 00:06:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<og:description>想要获取更多文章可以访问我的博客 '代码无止境' 。 小代同学在使用Git的过程中发现，每次向远程仓库推送代码的时候都需要输入账号密码。做为一个程序员，多多少少都会有偷懒的思维。那么如何才能避免每次都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11198658.html</dc:identifier>
</item>
<item>
<title>零基础ASP.NET Core WebAPI团队协作开发 - sylla</title>
<link>http://www.cnblogs.com/sylla/p/11198631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sylla/p/11198631.html</guid>
<description>&lt;p&gt;&lt;span&gt;相信大家对&lt;/span&gt;“前后端分离”和“微服务”这两个词应该是耳熟能详了。网上也有很多介绍这方面的文章。我这里提这个是因为接下来我要分享的内容和这个有些关联。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;随着前端应用场景的繁荣，用户体验需求的提高，原先传统的后端渲染页面返回给前端展示的模式面临挑战。后端工作除了处理数据逻辑还得适应界面&lt;/span&gt;UI&lt;span&gt;的业务，越来越不堪负重。前端的重要性逐渐体现出来，在这种情况下使用前后端分离模式开发的逐渐增多。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;前端框架（&lt;span&gt;比如&lt;/span&gt;Vue/Angular/React）的发力，大厂的推广使用，前后端分离已经很成熟。包括传统信息化这块以前使用传统WebMVC&lt;span&gt;模式的开发&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;BS&lt;span&gt;应用有些&lt;/span&gt;都逐步转为前后端分离模式。特别是开发人员分工之后专注做好各自的工作，效率更高，做出来的产品也就更好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、&lt;/span&gt;浏览器端（Vue/Angular/React&lt;span&gt;）&lt;/span&gt;+&lt;span&gt;服务端&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、&lt;/span&gt;桌面客户端（mfc/winform/wpf&lt;span&gt;）&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、&lt;/span&gt;&lt;span&gt;移动客户端（各种&lt;/span&gt;App/App&lt;span&gt;内置浏览器）&lt;/span&gt;+&lt;span&gt;服务端&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;、其他终端（大数据展示平台&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;报表展示平台）&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;客户端越来越强调轻量化，交互体验，不在满足于能用。&lt;span&gt;服务端端只管提供&lt;/span&gt;API&lt;span&gt;数据，这样&lt;/span&gt;业务逻辑大多在服务端处理，随着需求增加服务端的模块会越来越多。&lt;span&gt;但是有些接口是共用的，有些是根据业务变动的，还有的&lt;/span&gt;API&lt;span&gt;新旧版本过渡更新替换等等是服务端&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;要考虑的事情。设计好&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;开发框架面灵活应对这么多场景就很有必要了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;原先可能会做一个单体式应用，把所有用到的接口都加进去。但这样粒度很粗，如果某个场景下只使用了部分接口，那也得把这整个应用部署，无法做到按需添加。还有就是可能要修改其中部分方法，需要整体重新编译发布。这都存在可能影响其他模块的风险。&lt;/p&gt;
&lt;p&gt;服务端任务量大了，怎么分工？这个时候单体明显已经不适用了。这里就引出了微服务。对微服务可能每个人有不同的理解，但有一点是有共识的，就是把一个大的单体式应用根据功能模块拆分，这样粒度细分之后很多接口就可以共用。之后的修改增加都是可以按需发布部署，局部出现问题不会影响整体。&lt;/p&gt;

&lt;p&gt;这个服务的粒度怎么拆分也是需要慎重考虑的问题。除了功能拆分还得考虑人员匹配。&lt;/p&gt;
&lt;p&gt;案例场景：&lt;span&gt;一个系统有&lt;/span&gt;10&lt;span&gt;个子系统（模块），每个子系统（模块）又有&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;个功能，每个功能再具体又可能有&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;左右的方法代码。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个案例，最后大概有&lt;/span&gt;2000&lt;span&gt;个方法代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果开始安排&lt;/span&gt;10&lt;span&gt;人的团队开发，中途因为项目紧急再增加了&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;个人进来，总共变成了&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;人，项目组怎么做才能快速适应这种人员变动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有时候不是人越多越能做好事情，在人员增加情况下除了增加沟通协调成本，实际情况会遇到新加的人参与进来的门槛很高，不能快速着手展开工作，有时候还会出现不知道从何入手的困境。这就是因为拆分的不合理，任何的改动可能会影响到他人。这样虽然为了赶进度加人了，但实际的效果却不是很理想。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、功能拆分分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么拆分这有两个极端例子&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、粒度最粗，全部在一个解决方案&lt;/span&gt;（极端例子，类似单体式应用，适合一人开发）&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、粒度最细，细分到每个方法一个解决方案（极端例子，实际肯定不会这样做）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实际项目中功能拆分就是在这两个极端情况之间找适合的平衡点。具体拆分到多大的粒度，这个就只能是根据具体项目情况具体分析了。但是微服务可能是建议往细的方向拆。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是项目型的会发现如果拆的太细，上线一套系统要带&lt;/span&gt;N&lt;span&gt;个接口，运维实施都很麻烦；如果是做平台型的产品可能就是有限的几套系统，不会随着项目铺开太多定制化。也就没有了项目型里面的经常部署实施等繁琐的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如上面的案例，一般都是先根据子系统拆分，具体到每个子系统，有一人或多人开发也有后期临时加入的情况。每个子系统一套接口还是比较合适的。&lt;/p&gt;

&lt;p&gt;实际情况项目型比较多，考虑实施运维情况拆分的粒度不会太细，让实施去部署太多业务接口会把他们逼疯。如果有和我类似情况的下面的方案提供了一种解决办法。开发时候可以横向任意扩展，新加入的人员分配任务清晰，不用担心有耦合冲突。发布部署也不会因为粒度太细，增加部署工作量。总结就是插件式开发，微服务部署。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们都知道&lt;/span&gt;vs&lt;span&gt;里面建立一个解决方案，两&lt;/span&gt;三个开发人员在同一个解决方案里面开发，只要协调好还行，如果再加入人员，参与的开发人员一旦多了，就算分工好做各自模块，但还是会存在一个些冲突，比如增加文件，增加引用等等都会引起项目文件或者解决方案文件冲突问题。而且这种情况代码权限还不好细分控制。&lt;/p&gt;

&lt;p&gt;最好的方式是每个开发人员做的事情都在自己的解决方案里面，只要是公共使用的引用协调好大家使用统一的版本，其他的自己完全可控，完全不用担心影响他人，或者他人的修改影响自己。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;大家可以看下这个&lt;/span&gt; &lt;a href=&quot;https://github.com/dotnet/corefx/tree/master/src&quot;&gt;&lt;span&gt;https://github.com/dotnet/corefx/tree/master/src&lt;/span&gt;&lt;/a&gt;，&lt;span&gt;如图&lt;/span&gt;1。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071807948-1348209652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;1&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是&lt;/span&gt;dotnet基础库的源码，每个基础类库都是单独一个解决方案维护，随便点一个进去看下，如图2&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071819624-2023635518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;2&lt;/p&gt;
&lt;p&gt;每个类库都有独立解决方案文件。&lt;/p&gt;

&lt;p&gt;微软肯定有更好的方式去管理，但从这里可以看出，独立开发维护的优势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、接口项目准备&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面分享过一篇&lt;a href=&quot;https://www.cnblogs.com/sylla/p/11180628.html&quot; target=&quot;_blank&quot;&gt;《零基础&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/sylla/p/11180628.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core MVC&lt;/a&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/sylla/p/11180628.html&quot; target=&quot;_blank&quot;&gt;插件式开发》&lt;/a&gt;的文章&lt;/span&gt;，那边文章其实也就是强调团队开发的时候能做到尽量独立，可以横向扩展，项目灵活变动增加开发人员可以快速参与，开发之后能汇总到一个个的子系统，最后完成整体开发。在&lt;span&gt;这里&lt;/span&gt;API&lt;span&gt;的开发也可以&lt;/span&gt;使用类似方案，因为API没有视图部分，处理起来&lt;span&gt;比&lt;/span&gt;MVC&lt;span&gt;简单。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来重点介绍该方案在&lt;/span&gt;API&lt;span&gt;开发中的使用。开始这部分内容之前先简单介绍我这边&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;项目开发总结的两个共性问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;使用&lt;/span&gt;swagger&lt;span&gt;显示&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;文档（&lt;/span&gt;&lt;span&gt;nuget&lt;/span&gt; &lt;span&gt;引用&lt;/span&gt; &lt;span&gt;Swashbuckle.AspNetCore&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;API&lt;span&gt;是没有试图的，为了可视化，以及方便测试，使用&lt;/span&gt;&lt;span&gt;swagger&lt;/span&gt;&lt;span&gt;作为&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;的展示界面。具体使用看下面提供的&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;span&gt;使用版本控制&lt;/span&gt;API&lt;span&gt;版本号（&lt;/span&gt;&lt;span&gt;nuget&lt;/span&gt; &lt;span&gt;引用&lt;/span&gt;&lt;span&gt;Microsoft.AspNetCore.Mvc.Versioning&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本控制对&lt;/span&gt;API&lt;span&gt;也是同样重要，看&lt;/span&gt;&lt;span&gt;BAT&lt;/span&gt;&lt;span&gt;大厂提供的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;都是有版本控制的，要向他们看齐。实际应用中，程序不可能维持一套最新，有时候新旧版本需要过渡，所以需要有版本来区分。这里使用微软提供的版本控制。具体使用看下面提供的&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;代码&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这两个使用这里就不细说了，穿插下面主题做些简单介绍，具体看案例&lt;/span&gt;demo&lt;span&gt;就可以。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、接口插件式开发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回到我们的主题，这里重点介绍下一个子系统（模块）任务拆分与人员分工&lt;/p&gt;

&lt;p&gt;项目组接下一个项目，一般有个开发组长，着手模块划分并且开发任务分工&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组长（公共部分接口&lt;/span&gt;+&lt;span&gt;核心功能模块接口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组员&lt;/span&gt;1&lt;span&gt;：细分的模块插件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组员&lt;/span&gt;2&lt;span&gt;：细分的模块插件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组员&lt;/span&gt;3&lt;span&gt;：细分的模块插件&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;

&lt;p&gt;对于的解决方案结构，具体命名自己可以根据喜好自己自定义。&lt;/p&gt;

&lt;p&gt;Agile.ModuleName.API  &lt;span&gt;如下图&lt;/span&gt;3&lt;/p&gt;
&lt;p&gt;Agile.ModuleName.Plug1.API &lt;span&gt;图下图&lt;/span&gt;4&lt;/p&gt;
&lt;p&gt;Agile.ModuleName.Plug2.API&lt;/p&gt;
&lt;p&gt;Agile.ModuleName.Plug3.API&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071835134-1406647006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;3&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071841022-153510193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;4&lt;/p&gt;

&lt;p&gt;Demo&lt;span&gt;使用的是&lt;/span&gt;&lt;span&gt;vs2019&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Asp.net core 2.1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意：如果一个模块里面接口比较多，一个解决方案里面不适合团队开发。所以对这种接口功能比较多，拆成各个插件方便团队开发，最后发布的时候合并到一起。&lt;strong&gt;但是如果这个模块接口不是很多，就没必要&lt;/strong&gt;&lt;strong&gt;过度设计&lt;/strong&gt;&lt;strong&gt;为了插件化而拆开。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个独立开发的都是vs&lt;span&gt;里面建立的&lt;/span&gt;标准ASP.NET Core WebAPI项目，&lt;span&gt;这里主项目和各个插件项目没有从属关系，完全平等&lt;/span&gt;API&lt;span&gt;项目开发，最后只是可以汇合到主项目作为一个站点发布交付。&lt;/span&gt;各自独立调试运行各自开发功能模块，测试没问题发布汇总到主项目，部署运行，之后哪个接口问题只需要找到对应的模块修改，完全隔离开，不用担心修改会影响其他正常使用的模块。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;主项目解决方案结构，如图&lt;/span&gt;5&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071848702-1150383412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;5&lt;/p&gt;

&lt;p&gt;v1&lt;span&gt;，&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;里面的是有版本控制的，放在外面的就不需要版本控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有&lt;/span&gt;Extensions&lt;span&gt;文件夹里面两个类也是为了版本的显示做处理，具体看&lt;/span&gt;&lt;span&gt;Startup.cs&lt;/span&gt;&lt;span&gt;里面代码，如图&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071856570-1135691110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;6&lt;/p&gt;

&lt;p&gt;&lt;span&gt;搭建好之后，主项目运行，选择&lt;/span&gt;v1&lt;span&gt;版本显示如图&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071904441-131404032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;7&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果选择&lt;/span&gt;v2&lt;span&gt;，显示如图&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071913588-1807056493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;8&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过上面两个切换，应该看到不管选择&lt;/span&gt;v1&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;下面不受版本控制的都会显示。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果把图&lt;/span&gt;4&lt;span&gt;的代码注释掉，看下运行效果，如图&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071924800-484207791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;9&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示就这样，不能根据&lt;/span&gt;swagger&lt;span&gt;选择，直观的显示是&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;还是&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;。这个就是&lt;/span&gt;&lt;span&gt;RemoveVersionFromParameter&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ReplaceVersionWithExactValueInPath&lt;/span&gt;&lt;span&gt;两个类的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这两个类的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RemoveVersionFromParameter : IOperationFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(Operation operation, OperationFilterContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operation.Parameters.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; versionParameter = operation.Parameters.FirstOrDefault(p =&amp;gt; p.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                operation.Parameters.Remove(versionParameter);
            }
        }
    }


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReplaceVersionWithExactValueInPath : IDocumentFilter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(SwaggerDocument swaggerDoc, DocumentFilterContext context)
        {
            swaggerDoc.Paths &lt;/span&gt;=&lt;span&gt; swaggerDoc.Paths
                .ToDictionary(
                    path &lt;/span&gt;=&amp;gt; path.Key.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v{version}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, swaggerDoc.Info.Version),
                    path &lt;/span&gt;=&amp;gt;&lt;span&gt; path.Value
                );
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;到这里主项目&lt;/span&gt;API&lt;span&gt;运行正常，接下来看下插件项目&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插件&lt;/span&gt;1&lt;span&gt;项目结构，和主项目类似，如图&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071931563-1134942835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;10&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单独运行下这个插件&lt;/span&gt;1&lt;span&gt;项目，效果如图&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071942173-1409068631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;11&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里作为插件&lt;/span&gt;API&lt;span&gt;项目同样有一点要注意，不要出现和其他插件或者主项目同名的路由（&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;三个完全一样，分工之后各自命名规范估计这种情况也不会出现，主要还是注意避免合并之后路由重名问题）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里先把插件&lt;/span&gt;1&lt;span&gt;编译的&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;放到主项目的运行目录来，如图&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717071952639-131960710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;12&lt;/p&gt;

&lt;p&gt;&lt;span&gt;并且在主项目的&lt;/span&gt;Startup.cs&lt;span&gt;里面增加这段代码，如图&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072014935-595023386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;13&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行看下效果，如图&lt;/span&gt;14&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072027550-584450788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;14&lt;/p&gt;

&lt;p&gt;&lt;span&gt;汇合成功，插件&lt;/span&gt;1&lt;span&gt;的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;能展示出来，测试也正常，测试就不截图了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，插件&lt;/span&gt;1&lt;span&gt;，插件&lt;/span&gt;&lt;span&gt;2...&lt;/span&gt;&lt;span&gt;等等也是一样处理。开发阶段，各自开发的功能都是可以独立调试运行的。有没有主项目对各自开发的不影响。&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;五、&lt;strong&gt;问题总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果插件项目里面引用了一个第三方的程序集，如图&lt;/span&gt;15&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072039226-260254482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;15&lt;/p&gt;

&lt;p&gt;&lt;span&gt;引用一个测试类库，在&lt;/span&gt;Plug1NoVerController&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;方法里面写一个测试代码，如图&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072046792-2120114241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;16&lt;/p&gt;
&lt;p&gt;在插件项目单独测试，运行正常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再把插件&lt;/span&gt;1&lt;span&gt;相关文件拷贝到主项目，这时候多了个插件项目自己引用的&lt;/span&gt;&lt;span&gt;OtherLib.dll&lt;/span&gt;&lt;span&gt;，如图&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072056028-1520245931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;17&lt;/p&gt;

&lt;p&gt;&lt;span&gt;正常运行，如图&lt;/span&gt;18&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072110324-945599461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;18&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试下刚才插件&lt;/span&gt;1&lt;span&gt;里面用到&lt;/span&gt;&lt;span&gt;OtherLib&lt;/span&gt;&lt;span&gt;类的接口，看效果如图&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072119486-1705805489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;19&lt;/p&gt;

&lt;p&gt;&lt;span&gt;汗，居然报错了，提示&lt;/span&gt;FileNotFoundException&lt;span&gt;，但是看上面的错误信息截图提示找不到&lt;/span&gt;&lt;span&gt;OtherLib.dll&lt;/span&gt;&lt;span&gt;文件。&lt;/span&gt;&lt;span&gt;OtherLib.dll&lt;/span&gt;&lt;span&gt;这个文件明明在这个目录有的。查了相关资料都说是&lt;/span&gt;&lt;span&gt;.net core&lt;/span&gt;&lt;span&gt;的加载机制变了，但还是没理解透彻，不知道&lt;/span&gt;&lt;span&gt;.net core3.0&lt;/span&gt;&lt;span&gt;会不会解决这个问题。希望有大神看到可以解惑下这个问题。不过这里我使用一种方式可以解决这个报错，在主程序这里加这段代码。在注册插件项目之前，遍历所有&lt;/span&gt;&lt;span&gt;dll&lt;/span&gt;&lt;span&gt;，做一次加载就可以了。如图&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072127308-1145639267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;20&lt;/p&gt;

&lt;p&gt;&lt;span&gt;需要在注册插件之前，把所有&lt;/span&gt;dll&lt;span&gt;文件这样加载一遍，就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再运行，测试就正常了，如图&lt;/span&gt;21&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072136350-407641174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;21&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;六、&lt;strong&gt;发布运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各个独立开发的插件&lt;/span&gt;API&lt;span&gt;，各自独立开发调试正常之后，发布出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，插件&lt;/span&gt;1&lt;span&gt;，插件&lt;/span&gt;&lt;span&gt;2...&lt;/span&gt;&lt;span&gt;等等各自都开发好了，各自模块调试没问题，最后汇总到主的项目来，基本也就没什么问题了，并且还可以作为一个站点部署。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的一个站点只是一个接口服务，不要理解成一个系统就这一个接口服务，虽然可以这样做，但不建议，部署还是各个子系统一个服务，这样数量也不会很多。这里是指在开发阶段对一个子系统（模块）的&lt;/span&gt;N&lt;span&gt;个接口做开发方面的分工独立开发调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子系统（模块）有&lt;/span&gt;N&lt;span&gt;个接口，开发分工如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主插件，插件&lt;/span&gt;1&lt;span&gt;，插件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，插件&lt;/span&gt;&lt;span&gt;3...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全部汇总到主插件的发布目录，或者手动拷贝，最后提供一个完成的子系统接口发布版本，目录如图&lt;/span&gt;22&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072149979-1694976150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;22&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样命令行运行，或者宿主到&lt;/span&gt;iis&lt;span&gt;，这里命令行运行，如图&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072327579-1997545477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;23&lt;/p&gt;

&lt;p&gt;&lt;span&gt;浏览器打开，如图&lt;/span&gt;24&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190717072334258-1455275887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图&lt;/span&gt;24&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直接&lt;/span&gt;swagger&lt;span&gt;测试各个接口，正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;独立插件化开发，微服务发布部署。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;希望你看了之后有点收获，代码程序下面附件提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/sylla/ASP.NETCoreWebAPI%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91.zip&quot; target=&quot;_blank&quot;&gt;Demo&lt;span&gt;程序&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jul 2019 23:32:00 +0000</pubDate>
<dc:creator>sylla</dc:creator>
<og:description>零基础ASP.NET Core WebAPI团队协作开发 相信大家对“前后端分离”和“微服务”这两个词应该是耳熟能详了。网上也有很多介绍这方面的文章。我这里提这个是因为接下来我要分享的内容和这个有些关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sylla/p/11198631.html</dc:identifier>
</item>
<item>
<title>React躬行记（8）——样式 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/10653067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/10653067.html</guid>
<description>&lt;p&gt;　　由于React推崇组件模式，因此会要求HTML、CSS和JavaScript混合在一起，虽然这与过去的关注点分离正好相反，但是更有利于组件之间的隔离。React已将HTML用JSX封装，而对CSS只进行了较弱的封装，仅仅给出了基本的样式设置。不过，好在第三方库提供了CSS in JS的解决方案，让开发者能更高效的书写组件的样式，促进CSS工程化的发展。&lt;/p&gt;

&lt;p&gt;　　在React中的元素都包含style属性，用来定义内联样式。style的属性值是一个对象而不是一段字符串，该对象的属性就是CSS属性，但属性名要用小驼峰的方式命名，例如line-height改成lineHeight，具体如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Btn extends React.Component {
  render() {
    let btnStyle &lt;/span&gt;=&lt;span&gt; {
      height: &lt;/span&gt;40&lt;span&gt;,
      lineHeight: &lt;/span&gt;1.5&lt;span&gt;,
      WebkitBorderRadius: &lt;/span&gt;&quot;10%&quot;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;button style={btnStyle}&amp;gt;提交&amp;lt;/button&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在CSS中，有些属性是需要单位的，例如代码中的height，如果没有写明，那么React会自动给它们的数值加上像素（px）单位。还有一点要注意，属性名不会自动补全浏览器前缀，除了IE的ms前缀是纯小写之外，其它前缀的首字母都得是大写，例如Moz、O和Webkit。&lt;/p&gt;

&lt;p&gt;　　元素的className属性能够设置CSS类，它的值是一段字符串，如下代码所示，为&amp;lt;button&amp;gt;元素添加了一个名为btn的CSS类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Btn extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;button className=&quot;btn&quot;&amp;gt;提交&amp;lt;/button&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果要动态处理（增、删或改）元素的CSS类，那么借助第三方的classnames库就能大大降低开发复杂度。下面有两个示例，完成了相同的功能，都会根据组件的active状态（布尔值）决定是否添加一个名为active的CSS类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Btn1 extends React.Component {
  render() {
    let className &lt;/span&gt;= &quot;btn&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.state.active) className += &quot; active&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;button className={className}&amp;gt;提交&amp;lt;/button&amp;gt;;
&lt;span&gt;  }
}
class Btn2 extends React.Component {
  render() {
    let btnClass &lt;/span&gt;=&lt;span&gt; classNames({
      btn: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      active: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.active
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;button className={btnClass}&amp;gt;提交&amp;lt;/button&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Btn1组件通过条件语句和字符串拼接实现了CSS类的添加，而Btn2组件的实现方式更为优雅和清晰，只需要调用classNames()函数就行。该函数能接收一个由CSS类组成的对象，其中属性名就是类名，属性值是布尔类型的，当为true时，就添加该属性，否则忽略。&lt;/p&gt;

&lt;p&gt;　　由于前端的职能和项目规模正在扩大，因此工程化是大势所趋，而CSS的先天缺陷却在阻碍这一发展进程，目前碰到的主要问题如下所列。&lt;/p&gt;
&lt;p&gt;（1）全局作用域，任意一个CSS规则都对整个页面有效，当多个CSS规则发生冲突（即样式污染）时，会根据计算出的特殊性再决定采用哪个CSS规则。虽然可以通过OOCSS、BEM等规范避免多人协作时的代码冲突，但毕竟是自选方案，需要依靠团队的执行力度，无法在语言或工具级别强制实施。&lt;/p&gt;
&lt;p&gt;（2）缺少编程特性，没有变量、循环或函数等编程语言所需的语法，使得样式表有很多冗余代码。虽然社区发展的CSS预处理器（Sass、Less等）和CSS后处理器（PostCSS）有效缓解了这种状况，但是无法共享CSS处理器和JavaScript中的变量，不能满足某些特定复杂的场景。&lt;/p&gt;
&lt;p&gt;（3）没有依赖管理，在引入一个组件时，应该只加载与之关联的CSS，而不是像现在这样将整个CSS文件中的样式都导入进来。目前，市面上已经出现了好多用JavaScript管理CSS依赖的第三方库，例如styled-components、css-loader等。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）React的应对&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在将CSS应用到React中时，为了能有效的规避上述问题，引入了CSS in JS的编程思想，即用JavaScript编写CSS，相关的解决方案有40多种之多，可谓百家争鸣，这其中又分为抛弃CSS和沿用CSS两种。&lt;/p&gt;
&lt;p&gt;　　第一节所讲解的style属性（内联样式）就彻底抛弃了CSS，完全用JavaScript控制CSS，不仅CSS属性的命名方式不同，而且还无法使用伪类、伪元素、媒体查询等CSS特性。&lt;/p&gt;
&lt;p&gt;　　而CSS Modules与前者不同，依然采用JavaScript和CSS分离的写法，不仅沿用现有的CSS生态和JavaScript模块化的能力，还支持CSS预处理器的语法，并且能够零成本对接遗留项目。通过将选择器编译成唯一的CSS类名后，就能实现CSS模块化。不过，由于采用了BEM（Block Element Modifier）命名规范，因此得到的CSS类名将会比较复杂，并且没有充分利用JavaScript来控制样式，例如没有打通JavaScript和CSS中的变量。&lt;/p&gt;
&lt;p&gt;　　其实这两种解决方案只有在适合的场景中，才能最大限度的发挥它的作用，真正意义上的银弹并不存在，本节接下来要介绍一个介于这两者之间的第三方库：styled-components。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）标签模板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　styled-components的实现基于ES6新增的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/10173486.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;标签模板&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，移除了元素和样式之间的映射，通过JavaScript完全控制了CSS，不仅支持所有的CSS特性（例如伪类、媒体查询、动画等），还能自动添加浏览器前缀，但不支持Less、Sass等CSS预处理器的语法。下面的示例创建了一个带样式的Content组件，之所以定义在render()方法之外，是为了避免缓存失效，提升渲染速度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const Content =&lt;span&gt; styled.button`
  color: red;
  appearance: none;
`;
class Btn extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Content&amp;gt;提交&amp;lt;/Content&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在将Btn组件挂载到DOM中后，会渲染出一个包含CSS类的&amp;lt;button&amp;gt;元素，下面是生成的HTML代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .iCQFTl &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    -webkit-appearance&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;iCQFTl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由styled-components为该按钮生成了一个名称唯一的CSS类iCQFTl，并且被内嵌到了页面中。注意，appearance是一个实验中的CSS属性，用于设置元素的默认样式，在不同浏览器中会被styled-components添加不同的前缀，例如上面CSS规则中的-webkit。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）样式继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过构造函数styled()能够继承指定组件的样式，例如可以用下面的方式继承上例的Content组件，并额外声明背景颜色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const BgContent =&lt;span&gt; styled(Content)`
  background: yellow;
`;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）属性传递&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过组件的props能够调整其自身的样式，如下代码所示，占位符内是一个箭头函数，其参数就是传递进来的props。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const AttrContent =&lt;span&gt; styled.button`
  background: ${props &lt;/span&gt;=&amp;gt; props.active ? &quot;blue&quot; : &quot;white&quot;&lt;span&gt;}
`;
class Btn extends React.Component {
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;AttrContent active&amp;gt;提交&amp;lt;/AttrContent&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）选择器嵌套&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　styled-components使用了一个轻量级的CSS预处理器：stylis，用JavaScript实现了选择器的嵌套，如下代码所示，其中&amp;amp;符号表示父级选择器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const ProContent =&lt;span&gt; styled.button`
  &lt;/span&gt;&amp;amp;&lt;span&gt;:hover {
    color: yellow;
  }
`;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　限于篇幅原因，本节只列出了styled-components的几个基础功能，其他诸如主题、附加属性、Refs、动画等功能可以参考&lt;span&gt;&lt;a href=&quot;https://www.styled-components.com/docs&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;官方文档&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　styled-components开辟了一种新的控制CSS的方式，不但保持了原生CSS的写法，而且还忽略了CSS和HTML元素之间的关联，让React组件更简单。&lt;/p&gt;

</description>
<pubDate>Tue, 16 Jul 2019 21:19:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>由于React推崇组件模式，因此会要求HTML、CSS和JavaScript混合在一起，虽然这与过去的关注点分离正好相反，但是更有利于组件之间的隔离。React已将HTML用JSX封装，而对CSS只进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/10653067.html</dc:identifier>
</item>
<item>
<title>PostgreSQL 窗口函数 ( Window Functions ) 如何使用？ - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/11198566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/11198566.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;我们直接用例子来说明，这里有一张学生考试成绩表&lt;code&gt;testScore&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201907/896608-20190717031712162-1570051900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在有个需求，需要查询的时候多出一列&lt;code&gt;subject_avg_score&lt;/code&gt;，为此科目所有人的平均成绩，好跟每个人的成绩做对比。&lt;/p&gt;
&lt;p&gt;传统方法肯定是用聚合，但是写起来很麻烦也很累赘，这时候窗口函数就排上了用场。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;窗口函数不会像聚合一样将参与计算的行合并成一行输出，而是将计算出来的结果带回到了计算行上。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;聚合和窗口函数的区别&quot;&gt;1、聚合和窗口函数的区别&lt;/h3&gt;
&lt;p&gt;聚合：聚合函数(sum，min，avg……) + GROUP BY&lt;/p&gt;
&lt;p&gt;窗口函数：聚合函数(sum，min，avg……) + OVER ( …… )&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;2、使用&lt;/h3&gt;
&lt;p&gt;还用上面的例子：&lt;/p&gt;
&lt;h5 id=&quot;取每个不同科目的平均值subject_avg_score-这正是上面提到的需求&quot;&gt;(1) 取每个不同科目的平均值&lt;code&gt;subject_avg_score&lt;/code&gt; [这正是上面提到的需求]&lt;/h5&gt;
&lt;p&gt;这里的 OVER 里用到了 &lt;code&gt;PARTITION BY&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *, 
       avg(&quot;score&quot;) OVER (PARTITION BY &quot;subject&quot;) as &quot;subject_avg_score&quot;
FROM &quot;testScore&quot;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201907/896608-20190717031726475-1892199034.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;取所有成绩的平均值subject_avg_score&quot;&gt;(2) 取所有成绩的平均值&lt;code&gt;subject_avg_score&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;这里的 OVER 里为空&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *, 
       avg(&quot;score&quot;) OVER () as &quot;subject_avg_score&quot;
FROM &quot;testScore&quot;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201907/896608-20190717031734763-2032402294.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;/&gt;
&lt;h5 id=&quot;取此人该科目成绩班上排第几名subject_rank_score&quot;&gt;(3) 取此人该科目成绩班上排第几名&lt;code&gt;subject_rank_score&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;这里的 OVER 里用到了 &lt;code&gt;PARTITION BY&lt;/code&gt; + &lt;code&gt;ORDER BY&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ORDER BY 只能用在一些特殊的聚合函数里，比如这里的 rank()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *, 
        avg(&quot;score&quot;) OVER (PARTITION BY &quot;subject&quot;) as &quot;subject_avg_score&quot;,
                rank() OVER (PARTITION BY &quot;subject&quot; ORDER BY &quot;score&quot; DESC) as &quot;subject_rank_score&quot; 
FROM &quot;testScore&quot;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201907/896608-20190717031747732-1573788469.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;拓展知识：&lt;strong&gt;rank()、dense_rank()、row_number() 区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rank() 最适合用来做排名的功能，它是若两人并列第一，那第三个人就排名第三&lt;/p&gt;
&lt;p&gt;dense_rank() 跟 rank() 的区别是，若两人并列第一，那第三个人紧随其后排名第二&lt;/p&gt;
&lt;p&gt;row_number() 则单纯是序号，所以不会出现多个人并列的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;提取-over-变量&quot;&gt;(4) 提取 OVER 变量&lt;/h5&gt;
&lt;p&gt;如果在 sql 里写了很多重复的 OVER()，可以提取成一个 window 变量，简化代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *, 
        avg(&quot;score&quot;) OVER window_frame as &quot;subject_avg_score&quot;,
        avg(&quot;score&quot;) OVER window_frame as &quot;subject_avg_score_2&quot;,
        avg(&quot;score&quot;) OVER window_frame as &quot;subject_avg_score_3&quot;
FROM &quot;testScore&quot;  
window window_frame as (PARTITION BY &quot;subject&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/896608/201907/896608-20190717031759990-1881531549.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://www.postgres.cn/docs/9.3/tutorial-window.html&quot; class=&quot;uri&quot;&gt;http://www.postgres.cn/docs/9.3/tutorial-window.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008332604&quot;&gt;Postgresql窗口函数（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010082851&quot;&gt;Postgresql窗口函数（二）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jul 2019 19:19:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<og:description>一、为什么要有窗口函数 我们直接用例子来说明，这里有一张学生考试成绩表 ： 现在有个需求，需要查询的时候多出一列 ，为此科目所有人的平均成绩，好跟每个人的成绩做对比。 传统方法肯定是用聚合，但是写起来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xjnotxj/p/11198566.html</dc:identifier>
</item>
</channel>
</rss>