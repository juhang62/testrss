<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM调优之垃圾定位、垃圾回收算法、垃圾处理器对比 - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14365167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14365167.html</guid>
<description>&lt;p&gt;谈垃圾回收器之前,要先讲讲垃圾回收算法,以及JVM对垃圾的认定策略,JVM垃圾回收器是垃圾回收算法的具体实现,了解了前面的前置知识,有利于对垃圾回收器的理解。&lt;/p&gt;
&lt;h2 id=&quot;什么是垃圾&quot;&gt;什么是垃圾?&lt;/h2&gt;
&lt;p&gt;垃圾,主要是指堆上的对象,那么如何确定这些对象是可以被回收的呢?&lt;/p&gt;
&lt;p&gt;大概思路就是,如果一个对象永远不可能被访问到,那么就是垃圾,可以被回收了如何确定对象永远不会被使用呢?&lt;/p&gt;
&lt;h3 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h3&gt;
&lt;p&gt;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084331391-107771590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图,每一个对象的引用都是1,构成了循环引用,但是并不能被其他对象访问,这两个对象再无任何引用，引用计数算法也就无法回收它们。&lt;/p&gt;
&lt;p&gt;代码验证:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.courage;
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[5* _1MB];
    public static void testGC() {
        //5 M
        ReferenceCountingGC objA = new ReferenceCountingGC();
        //5 M
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
// 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
    public static void main(String[] args) {
        testGC();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[0.004s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
[0.012s][info   ][gc,heap] Heap region size: 1M
[0.015s][info   ][gc     ] Using G1
[0.015s][info   ][gc,heap,coops] Heap address: 0x0000000701000000, size: 4080 MB, Compressed Oops mode: Zero based, Oop shift amount: 3
......
[0.119s][info   ][gc,metaspace   ] GC(0) Metaspace: 805K-&amp;gt;805K(1056768K)
[0.119s][info   ][gc             ] GC(0) Pause Full (System.gc()) 14M-&amp;gt;0M(8M) 2.886ms
[0.119s][info   ][gc,cpu         ] GC(0) User=0.03s Sys=0.00s Real=0.00s
[0.120s][info   ][gc,heap,exit   ] Heap
......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了篇幅,我将部分打印内容省略了,可见System.gc()后内存占用由14M-&amp;gt;0M,将对象这10M释放了。也就是JVM里面并没使用引用计数法来标记垃圾。&lt;/p&gt;
&lt;h3 id=&quot;根可达算法&quot;&gt;根可达算法&lt;/h3&gt;
&lt;p&gt;这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084344801-179446415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的&lt;br/&gt;参数、局部变量、临时变量等在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。&lt;/li&gt;
&lt;li&gt;在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。&lt;/li&gt;
&lt;li&gt;在本地方法栈中JNI（即通常所说的Native方法）引用的对象。&lt;/li&gt;
&lt;li&gt;Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如&lt;br/&gt;NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。&lt;/li&gt;
&lt;li&gt;所有被同步锁（synchronized关键字）持有的对象。&lt;/li&gt;
&lt;li&gt;反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;垃圾回收算法&quot;&gt;垃圾回收算法&lt;/h2&gt;
&lt;p&gt;本文介绍了常见的三种垃圾回收算法（mark-sweep,mark-compact,mark-copy），是java虚拟机各种垃圾收集器的算法基础。&lt;/p&gt;
&lt;h3 id=&quot;垃圾回收算法思想&quot;&gt;垃圾回收算法思想&lt;/h3&gt;
&lt;p&gt;当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：&lt;br/&gt;1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。&lt;br/&gt;2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。&lt;/p&gt;
&lt;p&gt;这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；&lt;/p&gt;
&lt;p&gt;如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。&lt;/p&gt;
&lt;h3 id=&quot;标记-清除算法-mark-sweep&quot;&gt;标记-清除算法 Mark-Sweep&lt;/h3&gt;
&lt;p&gt;算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084357103-1174811964.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的主要缺点有两个：&lt;/p&gt;
&lt;p&gt;第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；&lt;/p&gt;
&lt;p&gt;第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;h3 id=&quot;标记-复制-mark-copy&quot;&gt;标记-复制 Mark-Copy&lt;/h3&gt;
&lt;p&gt;标记-复制算法常被简称为复制算法它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084406126-1118655885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了。&lt;/p&gt;
&lt;h3 id=&quot;标记-压缩-mark-compact&quot;&gt;标记-压缩 Mark-Compact&lt;/h3&gt;
&lt;p&gt;标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。&lt;/p&gt;
&lt;p&gt;标记-压缩算法其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084414953-1887090337.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序(STW问题)才能进行 。&lt;/p&gt;
&lt;h2 id=&quot;垃圾处理器&quot;&gt;垃圾处理器&lt;/h2&gt;
&lt;p&gt;基于上面的三种垃圾回收算法,衍生出7种垃圾回收器:&lt;/p&gt;
&lt;h3 id=&quot;serial收集器&quot;&gt;Serial收集器&lt;/h3&gt;
&lt;p&gt;这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084424375-468148789.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint） [1] 最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&quot;parnew收集器&quot;&gt;ParNew收集器&lt;/h3&gt;
&lt;p&gt;ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之&lt;br/&gt;外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：&lt;br/&gt;PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规&lt;br/&gt;则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084433387-508051938.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它&lt;br/&gt;却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集&lt;br/&gt;器，其中有一个与功能、性能无关但其实很重要的原因是：&lt;strong&gt;除了Serial收集器外，目前只有它能与CMS&lt;br/&gt;收集器配合工作,另一方面CMS的出现巩固了ParNew的地位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程&lt;br/&gt;交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时&lt;br/&gt;系统资源的高效利用还是很有好处的。&lt;/p&gt;
&lt;h3 id=&quot;parallel-scavenge收集器&quot;&gt;Parallel Scavenge收集器&lt;/h3&gt;
&lt;p&gt;Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢？&lt;/p&gt;
&lt;p&gt;Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：&lt;/p&gt;
&lt;p&gt;\[吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集器的时间} \]&lt;/p&gt;
&lt;p&gt;如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。&lt;/p&gt;
&lt;p&gt;由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”。&lt;/p&gt;
&lt;h3 id=&quot;serial-old收集器&quot;&gt;Serial Old收集器&lt;/h3&gt;
&lt;p&gt;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084446222-100603229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;parallel-old收集器&quot;&gt;Parallel Old收集器&lt;/h3&gt;
&lt;p&gt;Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PSMarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。&lt;/p&gt;
&lt;p&gt;由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。&lt;/p&gt;
&lt;p&gt;同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084453708-2000526851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cms收集器&quot;&gt;CMS收集器&lt;/h3&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。&lt;/p&gt;
&lt;p&gt;从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：&lt;br/&gt;1）初始标记（CMS initial mark）&lt;br/&gt;2）并发标记（CMS concurrent mark）&lt;br/&gt;3）重新标记（CMS remark）&lt;br/&gt;4）并发清除（CMS concurrent sweep）&lt;/p&gt;
&lt;p&gt;其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084504068-2000031218.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优点：并发收集、低停顿&lt;br/&gt;缺点：1.对处理器资源非常敏感&lt;/p&gt;
&lt;p&gt;​ 2.无法处理“浮动垃圾”（Floating Garbage）&lt;/p&gt;
&lt;p&gt;​ 3.空间碎片&lt;/p&gt;
&lt;h3 id=&quot;garbage-first收集器&quot;&gt;Garbage First收集器&lt;/h3&gt;
&lt;p&gt;Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的垃圾收集器。&lt;/p&gt;
&lt;p&gt;在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。&lt;/p&gt;
&lt;p&gt;Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待，如图3-12所示。&lt;/p&gt;
&lt;p&gt;虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。&lt;/p&gt;
&lt;h2 id=&quot;垃圾处理器总结&quot;&gt;垃圾处理器总结&lt;/h2&gt;
&lt;p&gt;目前是新生代老年代垃圾回收器组合方式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203084519168-1372460080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Feb 2021 00:46:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>谈垃圾回收器之前,要先讲讲垃圾回收算法,以及JVM对垃圾的认定策略,JVM垃圾回收器是垃圾回收算法的具体实现,了解了前面的前置知识,有利于对垃圾回收器的理解。 什么是垃圾? 垃圾,主要是指堆上的对象,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14365167.html</dc:identifier>
</item>
<item>
<title>分布式理论 PACELC 了解么？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14365162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14365162.html</guid>
<description>&lt;p&gt;PACELC 基于 CAP 理论演进而来。&lt;/p&gt;
&lt;p&gt;CAP 理论是一个分布式系统中老生常谈的理论了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C（Consistency）：一致性，所有节点在同一时间的数据完全一致。&lt;/li&gt;
&lt;li&gt;A（Availability）：可用性，服务一直可用。&lt;/li&gt;
&lt;li&gt;P（Partition tolerance）：分区容错性，遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统设计中，这三点只能取其二，一般的分布式系统要求必须&lt;strong&gt;有分区容错性&lt;/strong&gt;。剩下的只能从 C 或者 A 中取舍。&lt;/p&gt;
&lt;p&gt;但是这个理论并不能很好地应用于实际，首先， A 中是有一定争议的，很长时间才返回，虽然可用，但是业务上可能不能接受。并且，系统大部分时间下，分区都是平稳运行的，并不会出错，在这种情况下，系统设计要均衡的其实是延迟与数据一致性的问题，为了保证数据一致性，写入与读取的延迟就会增高。这就引出了 PACELC 理论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/PACELC/0.%20PACELC.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在出现分区错误的情况下，取前半部分 PAC，理论和 CAP 内容一致。没有出现分区错误的情况下（PACELC 中的 E 代表 Else），取 LC，也就是 Latency（延迟）与 Consistency（一致性）。&lt;/p&gt;
&lt;p&gt;现在，&lt;strong&gt;其实很多存储，都已经实现了不同的 PACELC 的兼顾策略，并且交由用户配置去灵活根据不同业务场景使用不同的策略&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;dynamodb，riak，cassandra-的-nwr-模型&quot;&gt;DynamoDB，Riak，Cassandra 的 NWR 模型&lt;/h2&gt;
&lt;p&gt;例如 DynamoDB 和 Riak 还有 Cassandra 都是 Dynamo 理论论文的基于一致性哈希写多份实现最终一致性的存储，在&lt;strong&gt;默认情况下，是 P+A 以及 E+L 的系统&lt;/strong&gt;，但是可以根据配置修改，主要基于&lt;strong&gt;NWR模型与同步和异步备份&lt;/strong&gt;。N 代表 N 个备份，W 代表要写入至少 W 份才认为成功，R 表示至少读取 R 个备份。配置的时候要求 W+R &amp;gt; N。 因为 W+R &amp;gt; N， 所以 R &amp;gt; N-W。这个是什么意思呢?就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。&lt;br/&gt;也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候(例如，amazon 的购物车的添加请求应该是永远不被拒绝的)我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。&lt;br/&gt;大家注意，一个操作的耗时是几个并行操作中最慢一个的耗时。比如R=3的时候，实际上是向三个节点同时发了读请求，要三个节点都返回结果才能认为成功。假设某个节点的响应很慢，它就会严重拖累一个读操作的响应速度。&lt;/p&gt;
&lt;h2 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h2&gt;
&lt;p&gt;MongoDB 和上面的 Dynamo 类似，MongoDB关于一致性、可用性的权衡，取决于三者：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;write-concern&lt;/code&gt;: 表示当写请求在value个MongoDB实例处理之后才向客户端返回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read-concern&lt;/code&gt;: 设定是否必须从 primary 读取最新的数据还是可以从 secondary 读取最终一致性的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read-preference&lt;/code&gt;: 对于replica set，是返回当前节点的最新数据，还是返回写入节点最多的数据，还是根据一些函数计算出的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mysql-同步&quot;&gt;MySQL 同步&lt;/h2&gt;
&lt;p&gt;MySQL主从复制包括异步模式、半同步模式、全同步复制&lt;/p&gt;
&lt;p&gt;默认情况下是&lt;strong&gt;异步模式&lt;/strong&gt;，MySQL 一主多从部署读写分离的情况下，实现的为最终一致性，如果考虑一定延迟可以接受，一般可以通过 &lt;code&gt;show slave status&lt;/code&gt;来查看主从延迟从而决定数据是否可以从 slave 读取。 MyCat 等中间件就是用了这种机制。可以通过对于这个时延的容忍性，控制 L 与 C 的取舍 以及 A 与 C 的取舍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全同步复制&lt;/strong&gt;：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。这样保证了强一致性，但是响应时间变长了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;半同步复制&lt;/strong&gt;：主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回给客户端。这样虽然还是有延迟，但是延迟小了很多并且数据相比于异步复制更加不容易丢失。&lt;/p&gt;
&lt;h2 id=&quot;一致性协议&quot;&gt;一致性协议&lt;/h2&gt;
&lt;p&gt;一致性协议一般包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2PC，两阶段提交&lt;/li&gt;
&lt;li&gt;3PC，三阶段提交&lt;/li&gt;
&lt;li&gt;Paxos，Paxos 是很细致的一致性协议，但是一般实现过于复杂仅仅是理论&lt;/li&gt;
&lt;li&gt;Raft，Raft 是能够实现分布式系统强一致性的算法，TiDB 的一致性协议就是基于 Raft&lt;/li&gt;
&lt;li&gt;ZAB，Zookeeper 的一致性协议，基于 Paxos 简化&lt;/li&gt;
&lt;li&gt;NWR，上面提到的 dynamo 理论基础的协议，将 PACELC 均衡交给用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Feb 2021 00:43:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>PACELC 基于 CAP 理论演进而来。 CAP 理论是一个分布式系统中老生常谈的理论了： C（Consistency）：一致性，所有节点在同一时间的数据完全一致。 A（Availability）：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14365162.html</dc:identifier>
</item>
<item>
<title>flutter--Dart基础语法（三）类和对象、泛型、库 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/14362563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/14362563.html</guid>
<description>&lt;p&gt;&lt;span&gt;Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，Flutter 开源、免费，拥有宽松的开源协议，支持移动、Web、桌面和嵌入式平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flutter是使用Dart语言开发的跨平台移动UI框架，通过自建绘制引擎，能高性能、高保真地进行Android和IOS开发。Flutter采用Dart语言进行开发，而并非Java，Javascript这类热门语言，这是Flutter团队对当前热门的10多种语言慎重评估后的选择。因为Dart囊括了多数编程语言的优点，它更符合Flutter构建界面的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文主要就是简单梳理一下Dart语言的一些基础知识和语法。关于编程语言的基本语法无外乎那么些内容，注释、变量、数据类型、运算符、流程控制、函数、类、异常、文件、异步、常用库等内容，相信大部分读者都是有一定编程基础的，所以本文就简单地进行一个梳理，不做详细的讲解。大家也可以参考 &lt;a href=&quot;https://www.dartcn.com/guides/language/language-tour&quot; target=&quot;_blank&quot;&gt;Dart编程语言中文网&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一篇文章主要是写了Dart语言的流程控制、函数和异常处理，本文将接着上一篇文章继续往后写，本文将主要介绍Dart语言的类和对象、泛型以及库的使用。&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;254&quot;&gt;
&lt;p&gt;&lt;span&gt;Dart 是一种基于类和 mixin 继承机制的面向对象的语言。 每个对象都是一个类的实例，所有的类都继承于 Object。面向对象中非常重要的概念就是类，类产生了对象。&lt;/span&gt;&lt;span&gt;接下来我们就具体来学习类和对象，但是Dart对类进行了很多其他语言没有的特性，所以，这里我会花比较长的篇幅来讲解。&lt;/span&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-11&quot;&gt;2.1  类的定义&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在Dart中，定义类用&lt;code&gt;class关键字&lt;/code&gt;。类通常有两部分组成：成员（member）和方法（method）。定义类的伪代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class 类名 {
  类型 成员名;
  返回值类型 方法名(参数列表) {
    方法体
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;编写一个简单的Person类：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;这里有一个注意点:&lt;/strong&gt; 我们在方法中使用属性(成员/实例变量)时，&lt;code&gt;并没有加this&lt;/code&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Dart的开发风格中，在方法中通常使用属性时，会&lt;code&gt;省略this&lt;/code&gt;，但是有&lt;code&gt;命名冲突&lt;/code&gt;时，&lt;code&gt;this不能省略&lt;/code&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
  String name;

  eat() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$name在吃东西&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们来使用这个类，创建对应的对象：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注意：从Dart2开始，new关键字可以省略。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建类的对象&lt;/span&gt;
  var p = new Person(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接使用Person()也可以创建

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.给对象的属性赋值&lt;/span&gt;
  p.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.调用对象的方法&lt;/span&gt;
&lt;span&gt;  p.eat();
}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-12&quot;&gt;2.2 构造方法&lt;/h2&gt;
&lt;p data-id=&quot;heading-13&quot;&gt;&lt;span&gt;Dart语言中构造方法分为普通构造方法、命名构造方法、重定向构造方法、常量构造方法、工厂构造方法以及初始化列表等多种。下面我们就一一给大家简单解释一下其中的区别。&lt;/span&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-13&quot;&gt;2.2.1 普通构造方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们知道, 当通过类创建一个对象时，会调用这个类的构造方法。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当类中&lt;code&gt;没有明确指定构造方法&lt;/code&gt;时，将默认拥有一个&lt;code&gt;无参的构造方法&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;前面的Person中我们就是在调用这个构造方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们也可以根据自己的需求，定义自己的构造方法:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意一&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;当有了自己的构造方法时，&lt;code&gt;默认的构造方法将会失效&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;，不能使用&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当然，你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这是因为&lt;strong&gt;&lt;span&gt;Dart本身&lt;code&gt;不支持函数的重载&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;（名称相同, 参数不同的方式）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;注意二&lt;/strong&gt;：这里我还实现了toString方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
  String name;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

  Person(String name, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
    this.name &lt;/span&gt;=&lt;span&gt; name;
    this.age &lt;/span&gt;=&lt;span&gt; age;
  }

  @override
  String toString() {
    return &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name=$name age=$age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，在实现构造方法时，通常做的事情就是通过 &lt;code&gt;参数&lt;/code&gt;&lt;strong&gt;给&lt;/strong&gt;&lt;code&gt;属性 &lt;/code&gt;赋值。为了简化这一过程, Dart提供了一种更加简洁的&lt;code&gt;语法糖形式。&lt;/code&gt;上面的构造方法可以优化成下面的写法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Person(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
    this.name &lt;/span&gt;=&lt;span&gt; name;
    this.age &lt;/span&gt;=&lt;span&gt; age;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等同于&lt;/span&gt;
  Person(this.name, this.age);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-14&quot;&gt;2.2.2 命名构造方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;但是在开发中, 我们确实希望实现更多的构造方法，怎么办呢？因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法。因此，我们需要使用&lt;strong&gt;命名构造方法&lt;/strong&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
  String name;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

  Person() {
    name &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
    age &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命名构造方法&lt;/span&gt;
  Person.withArgments(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
    this.name &lt;/span&gt;=&lt;span&gt; name;
    this.age &lt;/span&gt;=&lt;span&gt; age;
  }

  @override
  String toString() {
    return &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name=$name age=$age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象&lt;/span&gt;
var p1 =&lt;span&gt; new Person();
print(p1);
var p2 &lt;/span&gt;= new Person.withArgments(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;&lt;span&gt;);
print(p2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式。比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  //&lt;/span&gt;&lt;span&gt; 新的构造方法&lt;/span&gt;
  Person.fromMap(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map) {
    this.name &lt;/span&gt;= map[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
    this.age &lt;/span&gt;= map[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过上面的构造方法创建对象&lt;/span&gt;
  var p3 = new Person.fromMap({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kobe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;30&lt;/span&gt;&lt;span&gt;});
  print(p3);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-15&quot;&gt;2.2.3 初始化列表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Point {
  final num x;
  final num y;
  final num distance;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误写法
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Point(this.x, this.y) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   distance = sqrt(x * x + y * y);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确的写法&lt;/span&gt;
  Point(this.x, this.y) : distance = sqrt(x * x + y *&lt;span&gt; y);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面这种初始化变量的方法, 我们称之为&lt;code&gt;&lt;span&gt;&lt;strong&gt;初始化列表&lt;/strong&gt;&lt;/span&gt;(Initializer list)&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-16&quot;&gt;2.2.4 重定向构造方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用&lt;code&gt;重定向构造方法&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
  String name;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

  Person(this.name, this.age);

  Person.fromName(String name) : this(name, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-17&quot;&gt;2.2.5 常量构造方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在某些情况下，&lt;code&gt;传入相同值时&lt;/code&gt;，我们希望&lt;code&gt;返回同一个对象&lt;/code&gt;，这个时候，可以使用常量构造方法.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这里我们使用&lt;code&gt;identical(对象1, 对象2)&lt;/code&gt;函数来判断两个对象是否是同一个对象:&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var p1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  var p2 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  print(identical(p1, p2)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;}

class Person {
  String name;

  Person(this.name);
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是, 如果将构造方法前加&lt;code&gt;const进行修饰&lt;/code&gt;，那么可以保证同一个参数，创建出来的对象是相同的&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这样的构造方法就称之为&lt;code&gt;常量构造方法&lt;/code&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var p1 &lt;/span&gt;= const Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  var p2 &lt;/span&gt;= const Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  const p3 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  var p4 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  var p5 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

  print(identical(p1,p2)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
  print(identical(p1,p3)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
  print(identical(p1,p4)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
  print(identical(p1,p5)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;
}

class Person {
  final String name;

  const Person(this.name);
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;常量构造方法有一些注意点:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;注意一：&lt;span&gt;拥有常量构造方法的类中，所有的成员变量必须是final修饰&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/strong&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;注意二:&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果是将结果赋值给const修饰的标识符时，const可以省略.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-id=&quot;heading-18&quot;&gt;2.2.6 工厂构造方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Dart提供了factory关键字, 用于通过工厂去获取对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var p1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  var p2 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  print(identical(p1, p2)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;}

class Person {
  String name;

  static final Map&lt;/span&gt;&amp;lt;String, Person&amp;gt; _cache = &amp;lt;String, Person&amp;gt;&lt;span&gt;{};

  factory Person(String name) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_cache.containsKey(name)) {
      return _cache[name];
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      final p &lt;/span&gt;=&lt;span&gt; Person._internal(name);
      _cache[name] &lt;/span&gt;=&lt;span&gt; p;
      return p;
    }
  }

  Person._internal(this.name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-19&quot;&gt;2.3 setter和getter&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;默认情况下，Dart中类定义的属性是可以直接被外界访问的。但是某些情况下，我们希望监控这个&lt;code&gt;类的属性&lt;/code&gt;被访问的过程，这个时候就可以使用&lt;code&gt;setter和getter&lt;/code&gt;了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  final d &lt;/span&gt;= Dog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黄色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  d.setColor &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黑色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  print(d.getColor);
}

class Dog {
  String color;

  String get getColor {
    return color;
  }
  set setColor(String color) {
    this.color &lt;/span&gt;=&lt;span&gt; color;
  }

  Dog(this.color);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-20&quot;&gt;2.4 类的继承&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;面向对象的其中一大特性就是继承，继承不仅仅可以&lt;code&gt;减少我们的代码量&lt;/code&gt;，也是&lt;code&gt;多态的使用前提&lt;/code&gt;。Dart中的继承使用&lt;code&gt;extends关键字&lt;/code&gt;，子类中使用super来访问父类。&lt;span&gt;&lt;strong&gt;父类中的所有成员变量和方法都会被继承，但是构造方法除外&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var p &lt;/span&gt;=&lt;span&gt; new Person();
  p.age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
  p.run();
  print(p.age);
}

class Animal {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在奔跑ing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}

class Person extends Animal {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;子类可以&lt;code&gt;拥有自己的成员变量,&lt;/code&gt; 并且可以&lt;code&gt;对父类的方法进行重写&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person extends Animal {
  String name;

  @override
  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$name在奔跑ing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;子类中可以调用父类的构造方法，对某些属性进行初始化：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;子类的构造方法在执行前，将隐含调用父类的&lt;code&gt;无参默认构造方法&lt;/code&gt;（没有参数且与类同名的构造方法）。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如果父类没有&lt;code&gt;无参默认构造方法&lt;/code&gt;，则子类的构造方法必须在初始化列表中通过&lt;code&gt;super&lt;/code&gt;显式调用父类的某个构造方法&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Animal {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

  Animal(this.age);

  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在奔跑ing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}

class Person extends Animal {
  String name;

  Person(String name, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; age) : name=&lt;span&gt;name, super(age);

  @override
  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$name在奔跑ing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }

  @override
  String toString() {
    return &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name=$name, age=$age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-21&quot;&gt;2.5 抽象类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们知道，继承是多态使用的前提。所以在定义很多通用的 &lt;code&gt;调用接口 &lt;/code&gt;时, 我们通常会让调用者&lt;code&gt;传入父类&lt;/code&gt;，通过多态来实现更加灵活的调用方式。但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法，我们可以定义为&lt;strong&gt;抽象方法&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是 &lt;strong&gt;抽象方法&lt;/strong&gt;? 在Dart中没有具体实现的方法(没有方法体)，就是抽象方法。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;抽象方法，必须存在于抽象类中。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;抽象类是使用&lt;em&gt;&lt;code&gt;abstract&lt;/code&gt;&lt;/em&gt;声明的类。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面的代码中, Shape类就是一个抽象类, 其中包含一个抽象方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract class Shape {
  getArea();
}

class Circle extends Shape {
  &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; r;

  Circle(this.r);

  @override
  getArea() {
    return r &lt;/span&gt;* r * &lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;;
  }
}

class Reactangle extends Shape {
  &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;w&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; h;

  Reactangle(this.&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;, this.h);

  @override
  getArea() {
    return &lt;/span&gt;&lt;span&gt;w&lt;/span&gt; *&lt;span&gt; h;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意事项:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注意一：抽象类不能实例化.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注意二：抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-id=&quot;heading-22&quot;&gt;2.6 隐式接口&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Dart中的接口比较特殊, 没有一个专门的关键字来声明接口。默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承)。在开发中，我们通常将用于给别人实现的类声明为抽象类:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;abstract class Runner {
  run();
}

abstract class Flyer {
  fly();
}

class SuperMan implements Runner, Flyer {
  @override
  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;超人在奔跑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }

  @override
  fly() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;超人在飞&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-23&quot;&gt;2.7  Mixin混入&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在通过implements实现某个类时，类中所有的方法都必须&lt;code&gt;被重新实现 &lt;/code&gt;(无论这个类原来是否已经实现过该方法)&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢?&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Dart提供了另外一种方案: &lt;strong&gt;&lt;span&gt;Mixin混入&lt;/span&gt;的方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;只是通过mixin定义的类用于被其他类混入使用，通过&lt;strong&gt;with&lt;/strong&gt;关键字来进行混入。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var superMan &lt;/span&gt;=&lt;span&gt; SuperMain();
  superMan.run();
  superMan.fly();
}

mixin Runner {
  run() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在奔跑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}

mixin Flyer {
  fly() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在飞翔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; implements的方式要求必须对其中的方法进行重新实现
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; class SuperMan implements Runner, Flyer {}&lt;/span&gt;
&lt;span&gt;
class SuperMain with Runner, Flyer {

}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-24&quot;&gt;2.8 类成员和方法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法。在Dart中我们使用&lt;span&gt;static&lt;/span&gt;关键字来定义，需要注意的是，&lt;span&gt;&lt;strong&gt;类方法和类成员只能通过类名进行访问，不能通过对象名进行访问&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  var stu &lt;/span&gt;=&lt;span&gt; Student();
  stu.name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;why&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  stu.sno &lt;/span&gt;= &lt;span&gt;110&lt;/span&gt;&lt;span&gt;;
  stu.study();

  Student.&lt;/span&gt;&lt;span&gt;time&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;早上8点&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stu.time = '早上9点'; 错误做法, 实例对象不能访问类成员&lt;/span&gt;
&lt;span&gt;  Student.attendClass();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stu.attendClass(); 错误做法, 实现对象不能访问类方法&lt;/span&gt;
&lt;span&gt;}

class Student {
  String name;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sno;

  static String &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;;

  study() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$name在学习&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }

  static attendClass() {
    print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;去上课&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;枚举在开发中也非常常见, 枚举也是一种特殊的类, 通常用于表示固定数量的&lt;strong&gt;常量值&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-26&quot;&gt;3.1 枚举的定义&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;枚举使用enum关键字来进行定义:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  print(Colors.red);
}

enum Colors {
  red,
  green,
  blue
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-27&quot;&gt;3.2 枚举的属性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;枚举类型中有两个比较常见的属性:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;index: 用于表示每个枚举常量的索引, 从0开始.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;values: 包含每个枚举值的List.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
main(List&amp;lt;String&amp;gt;&lt;span&gt; args) {
  print(Colors.red.index);
  print(Colors.green.index);
  print(Colors.blue.index);

  print(Colors.values);
}

enum Colors {
  red,
  green,
  blue
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;枚举类型的注意事项:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注意一: 您不能子类化、混合或实现枚举。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;注意二: 不能显式实例化一个枚举&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;泛型的定义主要有以下两种：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;para&quot;&gt;&lt;span&gt;在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（人们大多把这称作模板）不论使用哪个定义，泛型的参数在真正使用泛型时都必须作出指明。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一些强类型编程语言支持泛型，其主要目的是加强类型安全及减少类转换的次数，但一些支持泛型的编程语言只能达到部分目的。&lt;/span&gt;&lt;span&gt;在Dart的 API 文档中你会发现基础数组类型 List 的实际类型是 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; 。 &amp;lt;…&amp;gt; 符号将 List 标记为 &lt;em&gt;泛型&lt;/em&gt; (或 &lt;em&gt;参数化&lt;/em&gt;) 类型。 这种类型具有形式化的参数。 通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。&lt;/span&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-29&quot;&gt;4.1 为什么使用泛型?&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在类型安全上通常需要泛型支持， 它的好处不仅仅是保证代码的正常运行：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;正确指定泛型类型可以提高代码质量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用泛型可以减少重复的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果想让 List 仅仅支持字符串类型， 可以将其声明为 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; （读作“字符串类型的 list ”）。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。 例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var names = List&amp;lt;String&amp;gt;&lt;span&gt;();
names.addAll([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Kathy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
names.add(&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外一个使用泛型的原因是减少重复的代码。 泛型可以在多种类型之间定义同一个实现， 同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设你创建了一个用于缓存对象的接口：&lt;/span&gt;
&lt;span&gt;abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后来发现需要一个相同功能的字符串类型接口，因此又创建了另一个接口：&lt;/span&gt;
&lt;span&gt;abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后来，又发现需要一个相同功能的数字类型接口 … 这里你应该明白了。

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 泛型可以省去创建所有这些接口的麻烦。 通过创建一个带有泛型参数的接口，来代替上述接口：&lt;/span&gt;
abstract class Cache&amp;lt;T&amp;gt;&lt;span&gt; {
  T getByKey(String key);
  void setByKey(String key, T value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在上面的代码中，T 是一个备用类型。 这是一个类型占位符，在开发者调用该接口的时候会指定具体类型。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用集合字面量&quot;&gt;4.2 List、Set、Map中泛型的使用&lt;/h2&gt;
&lt;h3&gt;4.2.1 字面量中的泛型&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;List , Set 和 Map 字面量也是可以参数化的。 参数化字面量和之前的字面量定义类似， 对于 List 或 Set 只需要在声明语句前加 &lt;code&gt;&amp;lt;&lt;em&gt;type&lt;/em&gt;&amp;gt;&lt;/code&gt; 前缀， 对于 Map 只需要在声明语句前加 &lt;code&gt;&amp;lt;&lt;em&gt;keyType&lt;/em&gt;, &lt;em&gt;valueType&lt;/em&gt;&amp;gt;&lt;/code&gt; 前缀， 下面是参数化字面量的示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
var names = &amp;lt;String&amp;gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Kathy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
var uniqueNames &lt;/span&gt;= &amp;lt;String&amp;gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Kathy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};
var pages &lt;/span&gt;= &amp;lt;String, String&amp;gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Homepage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;robots.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hints for web robots&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;humans.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;We are people, not machines&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用泛型类型的构造函数&quot;&gt;4.2.2 使用泛型类型的构造函数&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在调用构造函数的时，在类名字后面使用尖括号（&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;...&amp;gt;&lt;/code&gt;）来指定泛型类型。 例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个元素为字符串的Set集合&lt;/span&gt;
var nameSet = Set&amp;lt;String&amp;gt;&lt;span&gt;.from(names);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面代码创建了一个 key 为 integer， value 为 View 的 map 对象：&lt;/span&gt;
var views = Map&amp;lt;&lt;span&gt;int&lt;/span&gt;, View&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;运行时中的泛型集合&quot;&gt;4.2.3 运行时中的泛型集合&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Dart 中泛型类型是 &lt;em&gt;固化的&lt;/em&gt;，也就是说它们&lt;span&gt;&lt;strong&gt;在运行时是携带着类型信息的&lt;/strong&gt;&lt;/span&gt;。 例如， 在运行时检测集合的类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
var names = List&amp;lt;String&amp;gt;&lt;span&gt;();
names.addAll([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Kathy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lars&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
print(names is List&lt;/span&gt;&amp;lt;String&amp;gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;alert alert-info&quot; readability=&quot;7&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;提示： 相反，Java中的泛型会被 &lt;em&gt;擦除&lt;/em&gt; ，也就是说在运行时泛型类型参数的信息是不存在的。 在Java中，可以测试对象是否为 List 类型， 但无法测试它是否为 &lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;限制泛型类型&quot;&gt;4.3 创建类时限制泛型类型&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用泛型类型的时候， 可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt; 实现参数类型的限制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
class Foo&amp;lt;T extends SomeBaseClass&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Implementation goes here...&lt;/span&gt;
  String toString() =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance of 'Foo&amp;lt;$T&amp;gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

class Extender extends SomeBaseClass {...}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以使用 SomeBaseClass 或其任意子类作为通用参数：&lt;/span&gt;
var someBaseClassFoo = Foo&amp;lt;SomeBaseClass&amp;gt;&lt;span&gt;();
var extenderFoo &lt;/span&gt;= Foo&amp;lt;Extender&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也可以不指定泛型参数：&lt;/span&gt;
var foo =&lt;span&gt; Foo();
print(foo); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instance of 'Foo&amp;lt;SomeBaseClass&amp;gt;'

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定任何非 SomeBaseClass 类型会导致错误：&lt;/span&gt;
var foo = Foo&amp;lt;Object&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用泛型函数&quot;&gt;4.4 使用泛型函数&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;最初，Dart 的泛型只能用于类。 新语法_泛型方法_，允许在方法和函数上使用类型参数&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
T first&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt;&lt;span&gt; ts) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do some initial work or error checking, then...&lt;/span&gt;
  T tmp = ts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do some additional checking or processing...&lt;/span&gt;
&lt;span&gt;  return tmp;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;first&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;T&amp;gt;&lt;/code&gt;) 泛型可以在如下地方使用参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; ：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;函数的返回值类型 (&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;).&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;参数的类型 (&lt;code class=&quot;highlighter-rouge&quot;&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;).&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;局部变量的类型 (&lt;code class=&quot;highlighter-rouge&quot;&gt;T tmp&lt;/code&gt;).&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;40.5&quot;&gt;

&lt;p&gt;&lt;span&gt;在Dart中，你可以导入一个库来使用它所提供的功能。&lt;/span&gt;&lt;span&gt;库的使用可以使代码的重用性得到提高，并且可以更好的组合代码。&lt;/span&gt;&lt;span&gt;Dart中任何一个dart文件都是一个库，即使你没有用关键字&lt;code&gt;library&lt;/code&gt;声明。&lt;/span&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-34&quot;&gt;5.1 库的导入&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;import语句用来导入一个库，后面跟一个字符串形式的Uri来指定表示要引用的库，语法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库所在的uri&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5.1.1 常见的库URI有三种不同的形式&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;来自dart标准版，比如dart:io、dart:html、dart:math、dart:core(但是这个可以省略)&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dart:前缀表示Dart的标准库，如dart:io、dart:html、dart:math&lt;/span&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dart:io&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;使用相对路径导入的库，通常指自己项目中定义的其他dart文件&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然，你也可以用相对路径或绝对路径的dart文件来引用&lt;/span&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib/student/student.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;span&gt;Pub包管理工具管理的一些库，包括自己的配置以及一些第三方的库，通常使用前缀package&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pub包管理系统中有很多功能强大、实用的库，可以使用前缀 package:&lt;/span&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;package:flutter/material.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;5.1.2 库文件中内容的显示和隐藏&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果希望&lt;code&gt;只导入库中某些内容&lt;/code&gt;，或者刻意&lt;code&gt;隐藏库里面某些内容&lt;/code&gt;，可以使用&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;hide&lt;/code&gt;关键字&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;show关键字：可以显示某个成员（屏蔽其他）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;hide关键字：可以隐藏某个成员（显示其他）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只显示Student, Person，其他的都屏蔽&lt;/span&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib/student/student.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; show Student, Person;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只屏蔽Person，其他的都显示&lt;/span&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib/student/student.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; hide Person;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5.1.3 库中内容和当前文件中的名字冲突&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当各个库有命名冲突的时候，可以使用&lt;code&gt;as关键字&lt;/code&gt;来使用命名空间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lib/student/student.dart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; as Stu;

Stu.Student s &lt;/span&gt;= new Stu.Student();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-id=&quot;heading-35&quot;&gt;5.2 库的定义&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;5.2.1 library关键字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通常在定义库时，我们可以使用 library 关键字给库起一个名字。但目前我发现，库的名字并不影响导入，因为import语句用的是字符串URI&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
library math;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5.2.2 part关键字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在开发中，如果一个库文件太大，将所有内容保存到一个文件夹是不太合理的，我们有可能希望将这个库进行拆分，这个时候就可以使用&lt;code&gt;part&lt;/code&gt;关键字了。不过官方已经不建议使用这种方式了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/12/16d25658b1d173d5?imageView2/0/w/1280/h/960/ignore-error/1&quot; alt=&quot;image-20190911173722226&quot; class=&quot;lazyload inited loaded&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/9/12/16d25658b1d173d5?imageView2/0/w/1280/h/960/ignore-error/1&quot; data-width=&quot;858&quot; data-height=&quot;64&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mathUtils.dart文件&lt;/span&gt;&lt;span&gt;
part of &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2) {
  return num1 &lt;/span&gt;+&lt;span&gt; num2;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dateUtils.dart文件&lt;/span&gt;&lt;span&gt;
part of &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

String dateFormat(DateTime &lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;) {
  return &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils.dart文件&lt;/span&gt;&lt;span&gt;
part &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mathUtils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
part &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dateUtils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; test_libary.dart文件&lt;/span&gt;&lt;span&gt;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lib/utils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

main(List&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; args) {
  print(&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;));
  print(dateFormat(DateTime.now()));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/926487/202102/926487-20210202163214748-540308306.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;474&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2.3 export关键字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;官方不推荐使用&lt;code&gt;part关键字&lt;/code&gt;，那如果库非常大，如何进行管理呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将每一个dart文件作为库文件，使用export关键字在某个库文件中单独导入&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mathUtils.dart文件&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; num1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num2) {
  return num1 &lt;/span&gt;+&lt;span&gt; num2;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dateUtils.dart文件&lt;/span&gt;
String dateFormat(DateTime &lt;span&gt;date&lt;/span&gt;&lt;span&gt;) {
  return &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils.dart文件&lt;/span&gt;
&lt;span&gt;library utils;

export &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mathUtils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dateUtils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; test_libary.dart文件&lt;/span&gt;
&lt;span&gt;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lib/utils.dart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

main(List&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; args) {
  print(&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;));
  print(dateFormat(DateTime.now()));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后，也可以通过Pub管理自己的库自己的库，在项目开发中个人觉得不是非常有必要，所以暂时不讲解这种方式。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 03 Feb 2021 00:25:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<og:description>一、前言 Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，Flutter 开源、免费，拥有宽松的开源协议，支持移动、Web、桌面和嵌入式平台。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mukekeheart/p/14362563.html</dc:identifier>
</item>
<item>
<title>编写 Dockerfile 生成自定义镜像  - Cocowool</title>
<link>http://www.cnblogs.com/cocowool/p/dockerfile.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cocowool/p/dockerfile.html</guid>
<description>&lt;p&gt;一般情况下我们可以从公共渠道诸如 &lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;DockerHub&lt;/a&gt; 获取镜像上获取镜像，但是在实际生产过程中，往往需要定制化的镜像，例如修改一些配置文件，增加一些特殊的命令或软件等需求，这时就需要通过编写 Dockerfile 来生成自定义的镜像文件。&lt;/p&gt;
&lt;h2 id=&quot;dockerfile介绍&quot;&gt;Dockerfile介绍&lt;/h2&gt;
&lt;p&gt;Dockerfile 是一个文本格式的配置文件，通过编写 Dockerfile 脚本来定义自己需要的镜像。Dockerfile 文件由一行行命令语句组成，文件中的注释信息以 # 开头。编辑好 Dcokerfile 文件之后，我们可以通过 &lt;code&gt;docker build -t .&lt;/code&gt; 命令生成自己定义的镜像文件。&lt;/p&gt;
&lt;h2 id=&quot;dockerfile基本结构&quot;&gt;Dockerfile基本结构&lt;/h2&gt;
&lt;p&gt;我们看一下 &lt;a href=&quot;https://github.com/alpinelinux/docker-alpine/blob/f3d17bcb7b1fa51cf9b011403cd58e00fbbcd000/x86_64/Dockerfile&quot; target=&quot;_blank&quot;&gt;alpine&lt;/a&gt; 的 Dockerfile 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;FROM scratch
ADD alpine-minirootfs-20201218-x86_64.tar.gz /
CMD [&quot;/bin/sh&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dockerfile 文件主要由三部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FROM 属于配置指令部分，表明基于的镜像名称。&lt;code&gt;scratch&lt;/code&gt; 指从空白开始。&lt;/li&gt;
&lt;li&gt;ADD 属于操作指令部分，表示向镜像内加入内容。&lt;/li&gt;
&lt;li&gt;CMD 也属于操作指令部分，一般做为最后一行，表示运行容器时的操作命令。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;指令说明&quot;&gt;指令说明&lt;/h2&gt;
&lt;p&gt;Dockerfile 中指令的一般格式为 &lt;code&gt;INSTRUCTION arguments&lt;/code&gt; ，指令分两种 配置指令 和 操作指令，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置指令
&lt;ul&gt;&lt;li&gt;ARG : 定义创建镜像过程中使用的变量，格式为 &lt;code&gt;ARG &amp;lt;name&amp;gt;[=&amp;lt;default value&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FROM : 指定所创建镜像的基础镜像。格式为 &lt;code&gt;FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LABEL : 为生成的镜像添加元数据标签信息，辅助过滤特定镜像。格式为 &lt;code&gt;LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;EXPOSE : 声明镜像内服务监听的端口。格式为 &lt;code&gt;EXPOSE &amp;lt;port&amp;gt;[/&amp;lt;protocol&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ENV : 指定环境变量，该变量在容器中存在，也可在容器启动时覆盖。格式为 &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ENTRYPOINT : 指定镜像的默认入口命令，做为容器启动时的根命令执行。格式为 &lt;code&gt;ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 或者 &lt;code&gt;ENTRYPOINT command param1 param2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;VOLUME : 创建一个数据卷挂载点。格式为 &lt;code&gt;VOLUME [&quot;/data&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;USER : 指定容器运行时的用户名或UID，后续的RUN指令也使用该用户身份。格式为 &lt;code&gt;USER daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WORKDIR : 配置RUN\CMD\ENTRYPOINT等指令的工作目录，推荐使用绝对路径。格式为：&lt;code&gt;WORKDIR /path/to/workdir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ONBUILD : 指定当基于所生成镜像创建子镜像时，自动执行的操作指令。&lt;/li&gt;
&lt;li&gt;STOPSIGNAL : 指定容器接收退出的信号值。格式为: &lt;code&gt;STOPSIGNAL signal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HEALTHCHECK : 配置容器健康检查命令，自 Docker 1.12 开始支持。格式为: &lt;code&gt;HEALTHCHECK [OPTIONS] CMD command&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SHELL : 指定默认的shell类型。格式为: &lt;code&gt;SHELL [&quot;executable&quot;, &quot;parameters&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;操作指令
&lt;ul&gt;&lt;li&gt;RUN : 运行指定命令。格式为: &lt;code&gt;RUN &amp;lt;command&amp;gt;&lt;/code&gt; 或 &lt;code&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 当命令较长时，可以用 \ 来换行。&lt;/li&gt;
&lt;li&gt;CMD : 指定容器启动时默认执行的命令，每个Dockerfile只能有一条CMD命令。格式有三种，分别为：&lt;code&gt;CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 或 &lt;code&gt;CMD command param1 param2&lt;/code&gt; 或 &lt;code&gt;CMD [&quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ADD : 添加内容到镜像中，将SRC内容复制到DEST中。格式为: &lt;code&gt;ADD &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;COPY : 复制内容到镜像中。格式为 : &lt;code&gt;COPY &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建镜像&quot;&gt;创建镜像&lt;/h2&gt;
&lt;p&gt;创建镜像的命令格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build [OPTIONS] PATH | URL | -
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker build 命令读取指定路径下的 Dockerfile 文件，并将该路径下的所有数据作为上下文发送给 Docker 服务端。服务端完成 Dockerfile 格式校验后，按顺序执行指令命令，遇到ADD、COPY和RUN指令会生成新一层的镜像文件。镜像创建成功后，返回镜像ID。&lt;/p&gt;
&lt;p&gt;docker build 还有很多选项，最常用的是通过 &lt;code&gt;-t&lt;/code&gt; 增加标签。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build -t test:0.1 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Dockerfile 所在的文件夹文件过多时，为避免向服务端上传上下文过大，可以通过 .dockerignore 文件来让 Docker 忽略无关的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ cat .dockerignore
*xls
*docx
README.md
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战案例&quot;&gt;实战案例&lt;/h2&gt;
&lt;p&gt;总的来说，通过编写 Dockerfile 生成自定义镜像的过程不复杂，但是能生成高效的镜像还需要不断的尝试和联系，一般来说用于生产的镜像都尽量保证用途单一，减少镜像的层数，选择合适的基础镜像减小镜像文件大小，形成自己的版本号和标签管理规则，这样能提高自己生成镜像的质量。&lt;/p&gt;
&lt;p&gt;下面就以一个简单定义 python 基础镜像的例子，基础的 python 镜像缺少很多包例如爬虫常用的 requests ，自己定义一个包含 requests 包的镜像，编写的 Dockerfile 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;FROM python:3.6

RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行镜像的创建命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build -t python-requests-3.6:0.1 .
$ docker images
REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE
python-requests-3.6                             0.1                 3c2bb72b2066        2 minutes ago       884MB
python                                          3.6                 85146760634c        7 weeks ago         874MB
$ docker run --rm -it -v &quot;$PWD&quot;:/usr/src -w /usr/src python-requests-3.6:0.1 python3
Python 3.6.12 (default, Nov 18 2020, 14:46:32) 
[GCC 8.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import requests
&amp;gt;&amp;gt;&amp;gt; response = requests.get(&quot;http://baidu.com&quot;)
&amp;gt;&amp;gt;&amp;gt; print(response.text)
&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到镜像内的 python 环境已经支持 requests 包了。利用这种方式，我们不用在本地维护开发环境，特别是多个版本的开发环境，通过 Docker 生成不同版本的镜像能够快速的实现多版本的开发环境，大家可以参考 &lt;a href=&quot;http://edulinks.cn/2020/11/12/20201111-build-java-devlopment-env-with-docker/&quot; target=&quot;_blank&quot;&gt;利用 Docker 构建一个简单的 java 开发编译环境&lt;/a&gt; 。自己定义的各种镜像，可以上传到 DockerHub，更换电脑后仅需要安装 Docker，之前的各种开发环境就回来了。&lt;/p&gt;
&lt;p&gt;对于 Docker 有进一步兴趣的，可以参考我的其他文章：&lt;/p&gt;
</description>
<pubDate>Wed, 03 Feb 2021 00:07:00 +0000</pubDate>
<dc:creator>Cocowool</dc:creator>
<og:description>一般情况下我们可以从公共渠道诸如 DockerHub 获取镜像上获取镜像，但是在实际生产过程中，往往需要定制化的镜像，例如修改一些配置文件，增加一些特殊的命令或软件等需求，这时就需要通过编写 Dock</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cocowool/p/dockerfile.html</dc:identifier>
</item>
<item>
<title>基于efcore的分表组件开源 - 薛家明</title>
<link>http://www.cnblogs.com/xuejiaming/p/14359359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuejiaming/p/14359359.html</guid>
<description>&lt;p&gt;&lt;code&gt;ShardingCore&lt;/code&gt; 是一个支持efcore 2.x 3.x 5.x的一个对于数据库分表的一个简易扩展,.Net下并没有类似mycat或者sharding-jdbc之类的开源组件或者说有但是并没有非常适用的或者说个人在用过后有一些地方因为限制没法很好使用所以决定自己开发这个库,目前该库暂未支持分库(未来会支持),仅支持分表,该项目的理念是让你可以已最少的代码量来实现自动分表的实现,经过多个开源项目的摸索参考目前正式开源本项目&lt;br/&gt;项目地址 &lt;a href=&quot;https://github.com/xuejmnet/sharding-core&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; 喜欢的朋友可以点下star Thanks♪(･ω･)ﾉ&lt;/p&gt;
&lt;h3 id=&quot;依赖&quot;&gt;依赖&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Release&lt;/th&gt;
&lt;th&gt;EF Core&lt;/th&gt;
&lt;th&gt;.NET Standard&lt;/th&gt;
&lt;th&gt;.NET (Core)&lt;/th&gt;
&lt;th&gt;Sql Server&lt;/th&gt;
&lt;th&gt;Pomelo.EntityFrameworkCore.MySql&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.nuget.org/packages/ShardingCore/5.0.0.4&quot; target=&quot;_blank&quot;&gt;5.x.x.x&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;= 5.0.x&lt;/td&gt;
&lt;td&gt;2.1&lt;/td&gt;
&lt;td&gt;3.0+&lt;/td&gt;
&lt;td&gt;&amp;gt;= 2012&lt;/td&gt;
&lt;td&gt;5.0.0-alpha.2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.nuget.org/packages/ShardingCore/3.0.0.4&quot; target=&quot;_blank&quot;&gt;3.x.x.x&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;3.1.10&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;2.0+&lt;/td&gt;
&lt;td&gt;&amp;gt;= 2012&lt;/td&gt;
&lt;td&gt;3.2.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://www.nuget.org/packages/ShardingCore/2.0.0.4&quot; target=&quot;_blank&quot;&gt;2.x.x.x&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2.2.6&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;2.0+&lt;/td&gt;
&lt;td&gt;&amp;gt;= 2008&lt;/td&gt;
&lt;td&gt;2.2.6&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;以下所有例子都以Sql Server为例 MySql亦如此&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;目前该库处于初期阶段,有很多bug也希望各位多多理解,一起努力为.net生态做出一份微薄之力,目前该库支持的分表可以进行完全的自定义,基本上可以满足95%以上的&lt;br/&gt;业务需求，唯一的限制就是分表规则必须满足 x+y+z,x表示固定的表名,y表示固定的表名和表后缀之间的联系(可以为空),z表示表后缀,可以按照你自己的任意业务逻辑进行切分,&lt;br/&gt;如:user_0,user_1或者user202101,user202102...当然该库同样适用于多租户模式下的隔离,该库为了支持之后的分库已经重写了之前的union all查询模式,并且支持多种api,&lt;br/&gt;支持多种查询包括&lt;code&gt;join,group by,max,count,min,avg,sum&lt;/code&gt; ...等一系列查询,之后可能会添加更多支持,目前该库的使用非常简单,基本上就是针对IQueryable的扩展，为了保证&lt;br/&gt;该库的简介目前仅使用该库无法或者说难以实现自动建表,但是只需要配合定时任务该库即可完成24小时无人看管自动管理。该库提供了 &lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/src/ShardingCore/TableCreator/IShardingTableCreator.cs&quot; target=&quot;_blank&quot;&gt;IShardingTableCreator&lt;/a&gt;&lt;br/&gt;作为建表的依赖,如果需要可以参考 &lt;a href=&quot;https://github.com/xuejmnet/sharding-core/tree/main/samples/Samples.AutoByDate.SqlServer&quot; target=&quot;_blank&quot;&gt;按天自动建表&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;本库的几个简单的核心概念:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[Tail]&lt;br/&gt;尾巴、后缀物理表的后缀&lt;/li&gt;
&lt;li&gt;[TailPrefix]&lt;br/&gt;尾巴前缀虚拟表和物理表的后缀中间的字符&lt;/li&gt;
&lt;li&gt;[物理表]&lt;br/&gt;顾名思义就是数据库对应的实际表信息,表名(tablename+ tailprefix+ tail) &lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/src/ShardingCore/Core/PhysicTables/IPhysicTable.cs&quot; target=&quot;_blank&quot;&gt;IPhysicTable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[虚拟表]&lt;br/&gt;虚拟表就是系统将所有的物理表在系统里面进行抽象的一个总表对应到程序就是一个entity&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/src/ShardingCore/Core/VirtualTables/IVirtualTable.cs&quot; target=&quot;_blank&quot;&gt;IVirtualTable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[虚拟路由]&lt;br/&gt;虚拟路由就是联系虚拟表和物理表的中间介质,虚拟表在整个程序中只有一份,那么程序如何知道要查询系统哪一张表呢,最简单的方式就是通过虚拟表对应的路由&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/src/ShardingCore/Core/VirtualRoutes/IVirtualRoute.cs&quot; target=&quot;_blank&quot;&gt;IVirtualRoute&lt;/a&gt;&lt;br/&gt;,由于基本上所有的路由都是和业务逻辑相关的所以虚拟路由由用户自己实现,该框架提供一个高级抽象&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;[支持自定义分表规则]&lt;/li&gt;
&lt;li&gt;[支持任意类型分表key]&lt;/li&gt;
&lt;li&gt;[针对iqueryable的扩展方便使用]&lt;/li&gt;
&lt;li&gt;[支持分表下的连表] &lt;code&gt;join&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[支持针对批处理的使用] &lt;code&gt;BulkInsert、BulkUpdate、BulkDelete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[提供多种默认分表规则路由] 按时间按取模,自定义(&lt;code&gt;AbstractShardingOperatorVirtualRoute&amp;lt;T, TKey&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;[针对分页进行优化] 大页数跳转支持低内存流式处理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;[暂不支持分库(不久后会支持)]&lt;/li&gt;
&lt;li&gt;[消耗连接]出现分表与分表对象进行join如果条件没法索引到具体表会生成&lt;code&gt;笛卡尔积&lt;/code&gt;导致连接数爆炸,后期会进行针对该情况的配置&lt;/li&gt;
&lt;li&gt;[该库比较年轻] 可能会有一系列bug或者单元测试不到位的情况,但是只要你在群里或者提了issues我会尽快解决&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PackageReference Include=&quot;ShardingCore.SqlServer&quot; Version=&quot;5.0.0.4&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;配置entity 推荐 &lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/modeling/&quot; target=&quot;_blank&quot;&gt;fluent api&lt;/a&gt; 可以实现自动建表功能&lt;br/&gt;&lt;code&gt;IShardingEntity&lt;/code&gt;数据库对象必须继承该接口&lt;br/&gt;&lt;code&gt;ShardingKey&lt;/code&gt;分表字段需要使用该特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;    public class SysUserMod:IShardingEntity
    {
        /// &amp;lt;summary&amp;gt;
        /// 用户Id用于分表
        /// &amp;lt;/summary&amp;gt;
        [ShardingKey]
        public string Id { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 用户名称
        /// &amp;lt;/summary&amp;gt;
        public string Name { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 用户姓名
        /// &amp;lt;/summary&amp;gt;
        public int Age { get; set; }
    }
    
    public class SysUserModMap:IEntityTypeConfiguration&amp;lt;SysUserMod&amp;gt;
    {
        public void Configure(EntityTypeBuilder&amp;lt;SysUserMod&amp;gt; builder)
        {
            builder.HasKey(o =&amp;gt; o.Id);
            builder.Property(o =&amp;gt; o.Id).IsRequired().HasMaxLength(128);
            builder.Property(o =&amp;gt; o.Name).HasMaxLength(128);
            builder.ToTable(nameof(SysUserMod));
        }
    }
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建virtual route&lt;br/&gt;实现 &lt;code&gt;AbstractShardingOperatorVirtualRoute&amp;lt;T, TKey&amp;gt;&lt;/code&gt;&lt;br/&gt;抽象,或者实现系统默认的虚拟路由&lt;br/&gt;框架默认有提供几个简单的路由 &lt;a href=&quot;https://www.cnblogs.com/xuejiaming/p/14359359.html#默认路由&quot;&gt;默认路由&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;
    public class SysUserModVirtualRoute : AbstractSimpleShardingModKeyStringVirtualRoute&amp;lt;SysUserMod&amp;gt;
    {
        public SysUserModVirtualRoute() : base(3)
        {
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GetAllTails&lt;/code&gt;&lt;br/&gt;现在数据库已存在的尾巴有哪些&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt; 下的 &lt;code&gt;ConfigureServices(IServiceCollection services)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;
 services.AddShardingSqlServer(o =&amp;gt;
  {
      o.ConnectionString = &quot;&quot;;
      o.AddSharding&amp;lt;SysUserModVirtualRoute&amp;gt;();
      o.UseShardingCoreConfig((provider, config) =&amp;gt;
      {
          //如果是development就判断并且新建数据库如果不存在的话(ishardingentity不会被创建)
          config.EnsureCreated = provider.GetService&amp;lt;IHostEnvironment&amp;gt;().IsDevelopment();
          //ishardingentity表是否需要在启动时创建(如果已创建可以选择不创建)
          config.CreateShardingTableOnStart = true;
      });
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup.cs&lt;/code&gt; 下的 &lt;code&gt;Configure(IApplicationBuilder app, IWebHostEnvironment env)&lt;/code&gt; 你也可以自行封装&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/samples/Sample.SqlServer/DIExtension.cs&quot; target=&quot;_blank&quot;&gt;app.UseShardingCore()&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;
            var shardingBootstrapper = app.ApplicationServices.GetRequiredService&amp;lt;IShardingBootstrapper&amp;gt;();
            shardingBootstrapper.Start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;    
        private readonly IVirtualDbContext _virtualDbContext;

        public ctor(IVirtualDbContext virtualDbContext)
        {
            _virtualDbContext = virtualDbContext;
        }

        public async Task ToList_All()
        {
             //查询list集合
            var all=await _virtualDbContext.Set&amp;lt;SysUserMod&amp;gt;().ToShardingListAsync();
            //链接查询
            var list = await (from u in _virtualDbContext.Set&amp;lt;SysUserMod&amp;gt;()
                join salary in _virtualDbContext.Set&amp;lt;SysUserSalary&amp;gt;()
                    on u.Id equals salary.UserId
                select new
                {
                    Salary = salary.Salary,
                    DateOfMonth = salary.DateOfMonth,
                    Name = u.Name
                }).ToShardingListAsync();
            //聚合查询
            var ids = new[] {&quot;200&quot;, &quot;300&quot;};
            var dateOfMonths = new[] {202111, 202110};
            var group = await (from u in _virtualDbContext.Set&amp;lt;SysUserSalary&amp;gt;()
                    .Where(o =&amp;gt; ids.Contains(o.UserId) &amp;amp;&amp;amp; dateOfMonths.Contains(o.DateOfMonth))
                group u by new
                {
                    UId = u.UserId
                }
                into g
                select new
                {
                    GroupUserId = g.Key.UId,
                    Count = g.Count(),
                    TotalSalary = g.Sum(o =&amp;gt; o.Salary),
                    AvgSalary = g.Average(o =&amp;gt; o.Salary),
                    MinSalary = g.Min(o =&amp;gt; o.Salary),
                    MaxSalary = g.Max(o =&amp;gt; o.Salary)
                }).ToShardingListAsync();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多操作可以参考单元测试&lt;/p&gt;
&lt;h2 id=&quot;api&quot;&gt;Api&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/test/ShardingCore.Test50/ShardingTest.cs&quot; target=&quot;_blank&quot;&gt;SqlServer Unit Test&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/blob/main/test/ShardingCore.Test50.MySql/ShardingTest.cs&quot; target=&quot;_blank&quot;&gt;MySql Unit Test&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;获取集合&lt;/td&gt;
&lt;td&gt;ToShardingListAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;第一条&lt;/td&gt;
&lt;td&gt;ShardingFirstOrDefaultAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;最大&lt;/td&gt;
&lt;td&gt;ShardingMaxAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;最小&lt;/td&gt;
&lt;td&gt;ShardingMinAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;是否存在&lt;/td&gt;
&lt;td&gt;ShardingAnyAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;分页&lt;/td&gt;
&lt;td&gt;ToShardingPageResultAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数目&lt;/td&gt;
&lt;td&gt;ShardingCountAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;求和&lt;/td&gt;
&lt;td&gt;ShardingSumAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;分组&lt;/td&gt;
&lt;td&gt;ShardingGroupByAsync&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;默认路由&quot;&gt;默认路由&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;抽象abstract&lt;/th&gt;
&lt;th&gt;路由规则&lt;/th&gt;
&lt;th&gt;tail&lt;/th&gt;
&lt;th&gt;索引&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingModKeyIntVirtualRoute&lt;/td&gt;
&lt;td&gt;取模&lt;/td&gt;
&lt;td&gt;0,1,2...&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingModKeyStringVirtualRoute&lt;/td&gt;
&lt;td&gt;取模&lt;/td&gt;
&lt;td&gt;0,1,2...&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingDayKeyDateTimeVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间&lt;/td&gt;
&lt;td&gt;yyyyMMdd&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingDayKeyLongVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间戳&lt;/td&gt;
&lt;td&gt;yyyyMMdd&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingWeekKeyDateTimeVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间&lt;/td&gt;
&lt;td&gt;yyyyMMdd_dd&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingWeekKeyLongVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间戳&lt;/td&gt;
&lt;td&gt;yyyyMMdd_dd&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingMonthKeyDateTimeVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间&lt;/td&gt;
&lt;td&gt;yyyyMM&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingMonthKeyLongVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间戳&lt;/td&gt;
&lt;td&gt;yyyyMM&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingYearKeyDateTimeVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间&lt;/td&gt;
&lt;td&gt;yyyy&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AbstractSimpleShardingYearKeyLongVirtualRoute&lt;/td&gt;
&lt;td&gt;按时间戳&lt;/td&gt;
&lt;td&gt;yyyy&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,=,contains&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注:&lt;code&gt;contains&lt;/code&gt;表示为&lt;code&gt;o=&amp;gt;ids.contains(o.shardingkey)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;批量操作&quot;&gt;批量操作&lt;/h2&gt;
&lt;p&gt;批量操作将对应的dbcontext和数据进行分离由用户自己选择第三方框架比如zzz进行批量操作或者batchextension&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; virtualDbContext.BulkInsert&amp;lt;SysUserMod&amp;gt;(new List&amp;lt;SysUserMod&amp;gt;())
.BatchGroups.ForEach(pair =&amp;gt;
{
    ///zzz or other
    pair.Key.BlukInsert(pair.Value);
});
var shardingBatchUpdateEntry = virtualDbContext.BulkUpdate&amp;lt;SysUserMod&amp;gt;(o =&amp;gt; o.Id == &quot;1&quot;, o =&amp;gt; new SysUserMod()
{
Name = &quot;name_01&quot;
});
shardingBatchUpdateEntry.DbContexts.ForEach(context =&amp;gt;
{
//zzz or other
context.Where(shardingBatchUpdateEntry.Where).Update(shardingBatchUpdateEntry.UpdateExp);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;手动路由&quot;&gt;手动路由&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;        var shardingQueryable = _virtualDbContext.Set&amp;lt;SysUserMod&amp;gt;().AsSharding();
        //禁用自动路由
        shardingQueryable.DisableAutoRouteParse();
        //添加路由直接查询尾巴0的表
        shardingQueryable.AddManualRoute&amp;lt;SysUserMod&amp;gt;(&quot;0&quot;);
        //添加路由针对该条件的路由
        shardingQueryable.AddManualRoute&amp;lt;SysUserMod&amp;gt;(o=&amp;gt;o.Id==&quot;100&quot;);
        var list=await shardingQueryable.ToListAsync();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动建表&quot;&gt;自动建表&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuejmnet/sharding-core/tree/main/samples/Samples.AutoByDate.SqlServer&quot; target=&quot;_blank&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;默认savechanges支持事务如果需要where.update需要手动开启事务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;
            _virtualDbContext.BeginTransaction();
            var shardingBatchUpdateEntry = _virtualDbContext.BulkUpdate&amp;lt;SysUserMod&amp;gt;(o=&amp;gt;o.Id==&quot;123&quot;,o=&amp;gt;new SysUserMod()
            {
                Name = &quot;name_modify&quot;
            });
            foreach (var dbContext in shardingBatchUpdateEntry.DbContexts)
            {
             //zzz or other batch   
            }
            await  _virtualDbContext.SaveChangesAsync();
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;该库的IVirtualDbContext.Set使用asnotracking所以基本不支持跟踪,目前框架采用AppDomain.CurrentDomain.GetAssemblies();&lt;br/&gt;可能会导致程序集未被加载所以尽可能在api层加载所需要的dll&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;[提供官网如果该项目比较成功的话]&lt;/li&gt;
&lt;li&gt;[开发更完善的文档]&lt;/li&gt;
&lt;li&gt;[支持分库]&lt;/li&gt;
&lt;li&gt;[支持更多数据库查询]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上该库的思想可以解决大部分orm的分表,目前是仅针对efcore的后期如果可以获取也会对其他orm进行sharding库的开发&lt;br/&gt;该框架借鉴了大部分分表组件的思路,目前提供的接口都已经实现,并且支持跨表查询,基于分页查询该框架也使用了流式查询保证不会再skip大数据的时候内存会爆炸,至于groupby目前已经在开发支持了,相信不久后就会发布新版本,目前这个库只是一个刚刚成型的库还有很多不完善的地方希望大家多多包涵,如果喜欢的话也希望大家给个star.&lt;br/&gt;该文档是我晚上赶工赶出来的也想趁热打铁希望更多的人关注,也希望更多的人可以交流。&lt;/p&gt;
&lt;p&gt;凭借各大开源生态圈提供的优秀代码和思路才有的这个框架,希望可以为.Net生态提供一份微薄之力,该框架本人会一直长期维护,有大神技术支持可以联系下方方式欢迎star 😃&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuejiaming&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QQ群:771630778&lt;/p&gt;
&lt;p&gt;个人QQ:326308290(欢迎技术支持提供您宝贵的意见)&lt;/p&gt;
&lt;p&gt;个人邮箱:326308290@qq.com&lt;/p&gt;
</description>
<pubDate>Tue, 02 Feb 2021 23:51:00 +0000</pubDate>
<dc:creator>薛家明</dc:creator>
<og:description>ShardingCore ShardingCore 是一个支持efcore 2.x 3.x 5.x的一个对于数据库分表的一个简易扩展,.Net下并没有类似mycat或者sharding-jdbc之类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuejiaming/p/14359359.html</dc:identifier>
</item>
<item>
<title>JAVA对象分析之偏向锁、轻量级锁、重量级锁升级过程 - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14364988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14364988.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Courage129/1906773/o_2102021655461.jpg&quot; class=&quot;desc_img&quot;/&gt;本文总结JAVA对象构成,结合对象头的Mark Word分析锁升级的过程。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;153&quot;&gt;
&lt;p&gt;在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：&lt;/p&gt;
&lt;p&gt;对象头（Header）&lt;/p&gt;
&lt;p&gt;实例数据（Instance Data）&lt;/p&gt;
&lt;p&gt;对齐填充（Padding）。&lt;/p&gt;
&lt;h2 id=&quot;对象头&quot;&gt;对象头&lt;/h2&gt;
&lt;p&gt;HotSpot虚拟机(后面没有说明的话默认是这个虚拟机)对象头包括三部分:&lt;/p&gt;
&lt;p&gt;1、Mark Word&lt;/p&gt;
&lt;p&gt;2、指向类的指针&lt;/p&gt;
&lt;p&gt;3、数组长度（只有数组对象才有）&lt;/p&gt;
&lt;h3 id=&quot;对象头之mark-word&quot;&gt;对象头之Mark Word&lt;/h3&gt;
&lt;p&gt;Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。&lt;/p&gt;
&lt;p&gt;Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。&lt;/p&gt;
&lt;p&gt;Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210203005347058-865263320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一共32位,两位用来记录锁的信息,1位用来记录是否是偏向锁,如果偏向锁是1的话,那么会分配23位来记录偏向的线程id,当计算过Hash后,意味着会分配25bit来记录HashCode,那么久没有空间用来记录偏向锁的线程ID了,所以&lt;strong&gt;计算过HashCode后就没法再进入偏向锁&lt;/strong&gt;。如果进入轻量级锁或者重量级锁,意味着会用30bit指向指针,那么此时对象头中就只有两种信息,锁标志、指向锁的指针。&lt;/p&gt;
&lt;p&gt;其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。&lt;/p&gt;
&lt;p&gt;JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。&lt;/p&gt;
&lt;p&gt;结合Mark Word分析锁升级的流程：&lt;/p&gt;
&lt;p&gt;1，当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0(0则false , 1 则true)。&lt;/p&gt;
&lt;p&gt;2，当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态。&lt;/p&gt;
&lt;p&gt;3，当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。&lt;/p&gt;
&lt;p&gt;4，当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。&lt;/p&gt;
&lt;p&gt;5，偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的副本，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。&lt;/p&gt;
&lt;p&gt;6，轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。&lt;/p&gt;
&lt;p&gt;7，自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。&lt;/p&gt;
&lt;h3 id=&quot;对象头之指向类的指针&quot;&gt;对象头之指向类的指针&lt;/h3&gt;
&lt;p&gt;该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。&lt;/p&gt;
&lt;p&gt;Java对象的类数据保存在方法区。 并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。&lt;/p&gt;
&lt;h3 id=&quot;对象头之数组长度&quot;&gt;对象头之数组长度&lt;/h3&gt;
&lt;p&gt;如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。&lt;/p&gt;
&lt;p&gt;只有数组对象保存了这部分数据, 该数据在32位和64位JVM中长度都是32bit。&lt;/p&gt;
&lt;h2 id=&quot;实例数据&quot;&gt;实例数据&lt;/h2&gt;
&lt;p&gt;实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（&lt;code&gt;-XX：FieldsAllocationStyle&lt;/code&gt;参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为&lt;code&gt;longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）&lt;/code&gt;，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的&lt;code&gt;+XX：CompactFields&lt;/code&gt;参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。&lt;/p&gt;
&lt;h2 id=&quot;对齐填充&quot;&gt;对齐填充&lt;/h2&gt;
&lt;p&gt;这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。&lt;/p&gt;
&lt;h2 id=&quot;站在巨人的肩膀上&quot;&gt;站在巨人的肩膀上&lt;/h2&gt;
&lt;p&gt;1.&amp;lt;&amp;lt;深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） (华章原创精品)&amp;gt;&amp;gt;,周志明&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 02 Feb 2021 16:57:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分： 对象头（Header） 实例数据（Instance Data） 对齐填充（Padding）。 对象头 HotSpot虚拟机(后面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14364988.html</dc:identifier>
</item>
<item>
<title>Java并发包源码学习系列：阻塞队列实现之LinkedTransferQueue源码解析 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14364841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14364841.html</guid>
<description>&lt;p&gt;系列传送门：&lt;/p&gt;
&lt;h2 id=&quot;linkedtransferqueue概述&quot;&gt;LinkedTransferQueue概述&lt;/h2&gt;
&lt;p&gt;LinkedTransferQueue在JDK1.7版本诞生，是由链表组成的无界&lt;strong&gt;TransferQueue&lt;/strong&gt;，相对于其他阻塞队列，多了tryTransfer和transfer方法。&lt;/p&gt;
&lt;p&gt;TransferQueue：&lt;u&gt;生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费（不仅仅是添加到队列里就完事）。&lt;/u&gt;新添加的transfer方法用来实现这种约束。顾名思义，阻塞就是发生在元素从一个线程transfer到另一个线程的过程中，它有效地实现了元素在线程之间的传递（以建立Java内存模型中的happens-before关系的方式）。&lt;/p&gt;
&lt;blockquote readability=&quot;8.5730659025788&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html&quot; target=&quot;_blank&quot;&gt;http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Doug Lea评价TransferQueue是ConcurrentLinkedQueue、SynchronousQueue（在公平模式下）、无界的LinkedBlockingQueue等的超集，功能十分强大，最重要的是，它的实现也更加的高效。&lt;/p&gt;
&lt;p&gt;总结：基于&lt;strong&gt;无锁CAS&lt;/strong&gt;方式实现的&lt;strong&gt;无界FIFO队列&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;transferqueue&quot;&gt;TransferQueue&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinkedTransferQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt;
    implements TransferQueue&amp;lt;E&amp;gt;, java.io.Serializable {
    //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LinkedTransferQueue不同于其他的阻塞队列，它实现了TransferQueue接口，这一定是核心所在，我们直接来看看接口定义的方法规范：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 继承了BlockingQueue接口，并增加若干新方法
public interface TransferQueue&amp;lt;E&amp;gt; extends BlockingQueue&amp;lt;E&amp;gt; {
    /**
     * 将元素 传给等待的消费者【如果有的话】， 返回true， 如果不存在，返回false，不入队。
     */
    boolean tryTransfer(E e);

    /**
     * 将元素传递给等待的消费者【如果有的话】， 如果没有，则将e插入队列尾部，
     * 会一直等待，直到它被消费者接收
     */
    void transfer(E e) throws InterruptedException;

    /**
     * 在transfer的基础上，增加了超时操作，时间到了还没有被消费的话，返回false，并移除元素
     */
    boolean tryTransfer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * 如果存在消费者线程，返回true
     */
    boolean hasWaitingConsumer();

    /**
     * 得到等待获取元素的消费者线程的数量
     */
    int getWaitingConsumerCount();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;类图结构及重要字段&quot;&gt;类图结构及重要字段&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202102/1771072-20210202234022250-266226820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LinkedTransferQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt;
    implements TransferQueue&amp;lt;E&amp;gt;, java.io.Serializable {
    private static final long serialVersionUID = -3223113410248163686L;

    /** 是否为多核处理器 */
    private static final boolean MP =
        Runtime.getRuntime().availableProcessors() &amp;gt; 1;

    /**
     * 当一个节点目前是队列的第一个waiter时，阻塞前的自旋次数
     */
    private static final int FRONT_SPINS   = 1 &amp;lt;&amp;lt; 7;

    /**
     * 前驱节点正在处理，当前节点需要自旋的次数
     */
    private static final int CHAINED_SPINS = FRONT_SPINS &amp;gt;&amp;gt;&amp;gt; 1;

    /**
     * 
     */
    static final int SWEEP_THRESHOLD = 32;
    
    // 队列中的节点
    static final class Node {...}
    
    // 头节点
    transient volatile Node head;

    /** 尾指针，注意可能不是最后一个节点，初始化为null */
    private transient volatile Node tail;

    /** 删除节点失败的次数 */
    private transient volatile int sweepVotes;
    
    /*
     * xfer方法中使用，定义how，解释很清楚了，每个变量对应不同的方法
     */
    private static final int NOW   = 0; // for untimed poll, tryTransfer
    private static final int ASYNC = 1; // for offer, put, add
    private static final int SYNC  = 2; // for transfer, take
    private static final int TIMED = 3; // for timed poll, tryTransfer
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;有耐心的同学其实可以看一下javadoc的介绍，LinkedTransferQueue使用的队列结构其实是这样的：是&lt;code&gt;slack dual queue&lt;/code&gt;，他和普通的&lt;code&gt;M&amp;amp;S dual queue&lt;/code&gt;的区别在于，它不会每次操作的时候都更新head或tail，而是保持有针对性的slack懈怠，所以它的结构可能是下面这样，tail指针指向的节点未必就是最后一个节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       head           tail
         |              |
         v              v
         M -&amp;gt; M -&amp;gt; U -&amp;gt; U -&amp;gt; U -&amp;gt; U
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;node节点&quot;&gt;Node节点&lt;/h2&gt;
&lt;p&gt;Node节点的结构其实和SynchronousQueue公平模式差不太多，这一次看起来就比较清晰了，这边再总结一下，主要包含几个部分：几个重要字段，以及一些CAS方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static final class Node {
        final boolean isData;   // isData == true表示存数据，否则为获取数据
        volatile Object item;   // 存数据，item非null， 获取数据，匹配后，item为null
        volatile Node next; // next域
        volatile Thread waiter; // 等待线程

        // CAS操作next域 如果next为cmp，则变为val
        final boolean casNext(Node cmp, Node val) {
            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
        }
                // CAS操作item域，如果item为cmp，变为val
        final boolean casItem(Object cmp, Object val) {
            // assert cmp == null || cmp.getClass() != Node.class;
            return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
        }

        // 构造器
        Node(Object item, boolean isData) {
            UNSAFE.putObject(this, itemOffset, item); // relaxed write
            this.isData = isData;
        }

        // 将next指向自身this
        final void forgetNext() {
            UNSAFE.putObject(this, nextOffset, this);
        }
                // 匹配或取消节点调用
        final void forgetContents() {
            UNSAFE.putObject(this, itemOffset, this);
            UNSAFE.putObject(this, waiterOffset, null);
        }

        /**
         * 判断节点是否已经匹配，匹配取消也为true
         */ 
        final boolean isMatched() {
            Object x = item;
            return (x == this) || ((x == null) == isData);
        }

        /**
         * 是否为一个未匹配的请求 item为null表示未匹配
         */
        final boolean isUnmatchedRequest() {
            return !isData &amp;amp;&amp;amp; item == null;
        }

        /**
         * 如果给定的节点不能挂到当前节点后面，则返回true
         */
        final boolean cannotPrecede(boolean haveData) {
            boolean d = isData;
            Object x;
            return d != haveData &amp;amp;&amp;amp; (x = item) != this &amp;amp;&amp;amp; (x != null) == d;
        }

        /**
         * 尝试去匹配一个数据节点
         */
        final boolean tryMatchData() {
            // assert isData;
            Object x = item;
            if (x != null &amp;amp;&amp;amp; x != this &amp;amp;&amp;amp; casItem(x, null)) {
                LockSupport.unpark(waiter);
                return true;
            }
            return false;
        }

        private static final long serialVersionUID = -3375979862319811754L;

        // Unsafe mechanics
        private static final sun.misc.Unsafe UNSAFE;
        private static final long itemOffset;
        private static final long nextOffset;
        private static final long waiterOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class&amp;lt;?&amp;gt; k = Node.class;
                itemOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(&quot;item&quot;));
                nextOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(&quot;next&quot;));
                waiterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(&quot;waiter&quot;));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;前置：xfer方法的定义&quot;&gt;前置：xfer方法的定义&lt;/h2&gt;
&lt;p&gt;我们接下来将会介绍LinkedTransferQueue提供的各种操作，他们都会调用一个方法：xfer。&lt;/p&gt;
&lt;p&gt;这里我们暂且不谈具体的实现，我们只需要知道一下这个方法的四个入参分别是什么意思。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * xfer方法实现了所有的队列方法
     *
     * @param e take操作传入null， 否则传入具体元素
     * @param haveData put操作为true， take操作为false
     * @param how NOW, ASYNC, SYNC, or TIMED  不同字段，先从名称上猜测一下他们的大意
     * @param nanos 如果是TIMED模式，也就是具有超时机制的方法啦，具体超时的时间
     * @return an item if matched, else e  返回匹配的元素，否则返回e
     * @throws NullPointerException 插入null值抛出空指针异常： haveData==true &amp;amp;&amp;amp; e == null
     */
    private E xfer(E e, boolean haveData, int how, long nanos) {
        //     
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们将分几类来分别看一下各种操作的定义。&lt;/p&gt;
&lt;h2 id=&quot;队列操作三大类&quot;&gt;队列操作三大类&lt;/h2&gt;
&lt;h3 id=&quot;插入元素put、add、offer&quot;&gt;插入元素put、add、offer&lt;/h3&gt;
&lt;p&gt;LinkedTransferQueue是无界的，下面三个插入方法不会阻塞，他们都调用了xfer方法，传入元素e，havaData为true，how字段类型都为&lt;code&gt;SYNC&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void put(E e) {
        xfer(e, true, ASYNC, 0);
    }

    public boolean offer(E e, long timeout, TimeUnit unit) {
        xfer(e, true, ASYNC, 0);
        return true;
    }

    public boolean offer(E e) {
        xfer(e, true, ASYNC, 0);
        return true;
    }

    public boolean add(E e) {
        xfer(e, true, ASYNC, 0);
        return true;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取元素take、poll&quot;&gt;获取元素take、poll&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // take
        public E take() throws InterruptedException {
        E e = xfer(null, false, SYNC, 0);
        if (e != null)
            return e;
        Thread.interrupted();
        throw new InterruptedException();
    }

        // timed poll
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        E e = xfer(null, false, TIMED, unit.toNanos(timeout));
        if (e != null || !Thread.interrupted())
            return e;
        throw new InterruptedException();
    }

        // untimed poll
    public E poll() {
        return xfer(null, false, NOW, 0);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，获取元素的方法也都调用了xfer方法，他们都传入null，havaData都为false，但是传入的how字段类型不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;take方法传入SYNC。&lt;/li&gt;
&lt;li&gt;超时机制的poll传入TIMED，因此需要设置nanos。&lt;/li&gt;
&lt;li&gt;普通的poll传入NOW。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;transfer、trytransfer&quot;&gt;transfer、tryTransfer&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public boolean tryTransfer(E e) {
        return xfer(e, true, NOW, 0) == null;
    }

    public void transfer(E e) throws InterruptedException {
        if (xfer(e, true, SYNC, 0) != null) {
            Thread.interrupted(); // failure possible only due to interrupt
            throw new InterruptedException();
        }
    }

    public boolean tryTransfer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
        if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)
            return true;
        if (!Thread.interrupted())
            return false;
        throw new InterruptedException();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xfer三大流程&quot;&gt;xfer三大流程&lt;/h2&gt;
&lt;p&gt;xfer方法的实现，作者已经在注释中说的十分清楚啦，这边简单看下三个核心步骤，细节部分下面会学习。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1、Try to match an existing node 尝试去匹配一个节点&lt;/p&gt;
&lt;p&gt;2、Try to append a new node (method tryAppend) 尝试将一个节点入队，对应tryAppend方法&lt;/p&gt;
&lt;p&gt;3、Await match or cancellation (method awaitMatch) 阻塞等待一个节点被匹配或取消，对应awaitMatch方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;xfer&quot;&gt;xfer&lt;/h3&gt;
&lt;p&gt;这个方法必然是核心方法了，毕竟它可以实现队列中提供的所有操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private E xfer(E e, boolean haveData, int how, long nanos) {
        // 如果 是插入的数据为null， 则NPE
        if (haveData &amp;amp;&amp;amp; (e == null))
            throw new NullPointerException();
        Node s = null;                        // the node to append, if needed

        retry:
        for (;;) {                            // restart on append race
                        // 第一次插入数据的时候，不会进入这个循环，因为p == null
            // 否则进入这个循环，从head首节点开始
            for (Node h = head, p = h; p != null;) { // find &amp;amp; match first node
                boolean isData = p.isData;
                Object item = p.item;
                // 找到还未匹配的节点：  isData的item应该是为非null， 如果是null表明用过了
                if (item != p &amp;amp;&amp;amp; (item != null) == isData) { // unmatched
                    // 节点类型和当前类型一致，无法匹配
                    if (isData == haveData)   // can't match
                        break;
                    // 将参数加入到item域，
                    if (p.casItem(item, e)) { // match
                        // 下面这个for循环，是匹配item之后进行的额外操作，
                        // 比如将head更新为当前这个点
                        for (Node q = p; q != h;) {
                            Node n = q.next;  // update by 2 unless singleton
                            if (head == h &amp;amp;&amp;amp; casHead(h, n == null ? q : n)) {
                                h.forgetNext();
                                break;
                            }                 // advance and retry
                            if ((h = head)   == null ||
                                (q = h.next) == null || !q.isMatched())
                                break;        // unless slack &amp;lt; 2
                        }
                        // 阻塞线程
                        LockSupport.unpark(p.waiter);
                        // 返回item值
                        return LinkedTransferQueue.&amp;lt;E&amp;gt;cast(item);
                    }
                }
                // 如果节点已经匹配过了，向后
                Node n = p.next;
                // p != n的情况很简单，将p移到n的位置， p==n表示什么呢？
                // 其实如果p.next == p 说明p节点已经被其他线程处理，那么p就从head开始
                p = (p != n) ? n : (h = head); // Use head if p offlist
            }
                        // 还没有找到可以匹配的点的话，会走到这
            // 这里 如果 how 字段传入为 NOW ，便不会走里面的逻辑，
            // 也就是说untimed poll、 tryTransfer 不需要将元素入队
            if (how != NOW) {                 // No matches available
                // 这里构造一个节点
                if (s == null)
                    s = new Node(e, haveData);
                // 初始化之后，调用tryAppend入队， 返回前驱节点
                Node pred = tryAppend(s, haveData);
                // pred == null表示竞争失败，返回到retry的地方
                if (pred == null)
                    continue retry;           // lost race vs opposite mode
                // 如果是ASYNC会跳过这里，立刻返回e，不需要阻塞
                if (how != ASYNC)
                    return awaitMatch(s, pred, e, (how == TIMED), nanos);
            }
            return e; // not waiting
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从头开始往后找，&lt;strong&gt;跳过已经匹配过的节点，直到找到mode相反的节点，进行匹配并返回&lt;/strong&gt;。如果需要的话，可以额外改变head的指向。&lt;/li&gt;
&lt;li&gt;如果没有找到可以匹配的点呢？ 那就判断是不是NOW，&lt;strong&gt;如果是NOW的话，直接返回&lt;/strong&gt;【untimed poll, tryTransfer】。&lt;/li&gt;
&lt;li&gt;如果不是NOW，那就构建一个节点，入队，如果&lt;strong&gt;是ASYNC就直接返回&lt;/strong&gt;【offer, put, add】，其他情况需要阻塞等待匹配。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;直接上图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202102/1771072-20210202234034723-194566383.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tryappend&quot;&gt;tryAppend&lt;/h3&gt;
&lt;p&gt;tryAppend包含入队的逻辑，返回前驱节点。代码充分考虑到并发情况，还是比较难懂的，如果要看明白，可以在图上画一画节点的变化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private Node tryAppend(Node s, boolean haveData) {
        for (Node t = tail, p = t;;) {        // move p to last node and append
            Node n, u;                        // temps for reads of next &amp;amp; tail
            // p == null &amp;amp;&amp;amp; head == null  表示此时队头还未初始化
            if (p == null &amp;amp;&amp;amp; (p = head) == null) {
                // cas设置s为队头
                if (casHead(null, s))
                    return s;                 // initialize
            }
            // 这里检测到异常情况，返回null，之后会continue retry；
            else if (p.cannotPrecede(haveData))
                return null;                  // lost race vs opposite mode
            // 这里就是p一直找到tail的位置，
            else if ((n = p.next) != null)    // not last; keep traversing
                // 这段... 吐槽一下
                p = p != t &amp;amp;&amp;amp; t != (u = tail) ? (t = u) : // stale tail
                    (p != n) ? n : null;      // restart if off list
            // 尝试将s插到队尾，如果失败，说明其他线程先插了，那么p向后移，从新开始
            else if (!p.casNext(null, s))
                p = p.next;                   // re-read on CAS failure
            else {
                if (p != t) {                 // update if slack now &amp;gt;= 2
                    // 这里会设置s为tail，如果成功的话，就退出循环了，
                    // 如果失败的话，会进行后面的判断，一开始tail其实都是null的
                    // 
                    while ((tail != t || !casTail(t, s)) &amp;amp;&amp;amp;
                           (t = tail)   != null &amp;amp;&amp;amp;
                           (s = t.next) != null &amp;amp;&amp;amp; // advance and retry
                           (s = s.next) != null &amp;amp;&amp;amp; s != t);
                }
                // 返回加入节点的前驱节点
                return p;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法从当前的tail开始，找到实际的最后一个节点【前面说了，tail可能不是最后一个节点】，并尝试追加一个新的节点【如果head为null，则建立第一个节点】。&lt;/p&gt;
&lt;p&gt;成功追加后，如果how为ASYNC，则返回。&lt;/p&gt;
&lt;p&gt;注意：仅当它的前面节点都已经匹配或mode相同时，才可以追加节点。如果检测到其他的情况，我们需要直接返回null，重新启动retry。&lt;/p&gt;
&lt;h3 id=&quot;awaitmatch&quot;&gt;awaitMatch&lt;/h3&gt;
&lt;p&gt;awaitMatch方法其实和SynchronousQueue的awaitFulfill逻辑差不多，线程会有三种情况：&lt;code&gt;spins/yield/blocks&lt;/code&gt;，直到node s被匹配或取消。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;On multiprocessors, we use &lt;strong&gt;front-of-queue&lt;/strong&gt; spinning: If a node appears to be the first unmatched node in the queue, it spins a bit before blocking.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个节点可能会优先被匹配呢，它会优先选择自旋而不是阻塞，自旋次数到了才阻塞，主要是考虑到阻塞、唤醒需要消耗更多的资源。这边简单过一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        Thread w = Thread.currentThread();
        // 自旋次数
        int spins = -1; // initialized after first item and cancel checks
        // 这里是线程安全的Random
        ThreadLocalRandom randomYields = null; // bound if needed

        for (;;) {
            Object item = s.item;
            // 
            if (item != e) {                  // matched
                // assert item != s;
                s.forgetContents();           // avoid garbage
                return LinkedTransferQueue.&amp;lt;E&amp;gt;cast(item);
            }
            // 如果中断或超时 ，就cas设置s的item为e
            if ((w.isInterrupted() || (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0)) &amp;amp;&amp;amp;
                    s.casItem(e, s)) {        // cancel
                // 断开
                unsplice(pred, s);
                return e;
            }
                        // 计算自旋次数
            if (spins &amp;lt; 0) {                  // establish spins at/near front
                if ((spins = spinsFor(pred, s.isData)) &amp;gt; 0)
                    randomYields = ThreadLocalRandom.current();
            }
            else if (spins &amp;gt; 0) {             // spin
                --spins;
                // 这里作者提示：虽然偶尔执行yield的收益不是很明显
                // 但仍限制了 自旋对busy system 的影响
                if (randomYields.nextInt(CHAINED_SPINS) == 0)
                    Thread.yield();           // occasionally yield
            }
            // 设置一下waiter线程，标记一下谁在等
            else if (s.waiter == null) {
                s.waiter = w;                 // request unpark then recheck
            }
            // 超时阻塞
            else if (timed) {
                nanos = deadline - System.nanoTime();
                if (nanos &amp;gt; 0L)
                    LockSupport.parkNanos(this, nanos);
            }
            // 自旋完还是没有匹配，就park住
            else {
                LockSupport.park(this);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linkedtransferqueue使用案例&quot;&gt;LinkedTransferQueue使用案例&lt;/h2&gt;
&lt;p&gt;最后，来看个简单的案例吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author Summerday
 */
public class TestTransferQueue {

    // 无锁算法 无界队列
    static TransferQueue&amp;lt;Integer&amp;gt; queue = new LinkedTransferQueue&amp;lt;&amp;gt;();

    public static void main (String[] args) {

        for (int i = 1; i &amp;lt;= 10; i++) {
            new Thread(() -&amp;gt; {
                try {
                    System.out.println(Thread.currentThread().getName() + &quot;消费 id - &quot; + queue.take());
                    System.out.println(&quot;---------------------------------------------&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, &quot;consumer&quot; + i).start();
        }

        Thread producer = new Thread(() -&amp;gt; {
            while (true) {
                System.out.println(&quot;当前队列中等待的线程&quot; + queue.getWaitingConsumerCount());
                // 如果队列中有等待的消费者
                if (queue.hasWaitingConsumer()) {
                    int product = new Random().nextInt(500);
                    try {
                        System.out.println(Thread.currentThread().getName() + &quot;生产 id - &quot; + product);
                        queue.tryTransfer(product);
                        TimeUnit.MILLISECONDS.sleep(100); // 等待消费
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, &quot;producer&quot;);
        producer.setDaemon(true);
        producer.start();
    }
}
// 打印结果：
当前队列中等待的线程10
producer生产 id - 266
consumer1消费 id - 266
---------------------------------------------
当前队列中等待的线程9
producer生产 id - 189
consumer2消费 id - 189
---------------------------------------------
//... 省略
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;LinkedTransferQueue在JDK1.7版本诞生，是由链表组成的无界&lt;strong&gt;TransferQueue&lt;/strong&gt;，相对于其他阻塞队列，不仅多了tryTransfer和transfer方法，而且性能方面也有巨大的提升。&lt;/p&gt;
&lt;p&gt;LinkedTransferQueue使用的队列结构是&lt;code&gt;slack dual queue&lt;/code&gt;，不会每次操作的时候都更新head或tail，而是保持有针对性的slack懈怠。&lt;/p&gt;
&lt;p&gt;LinkedTransferQueue的所有队列操作都基于xfer方法，具体情况根据传入的how字段决定：NOW节点不入队，ASYNC节点入队但会立即返回，SYNC节点入队且阻塞，TIMED对应超时机制。&lt;/p&gt;
&lt;p&gt;xfer的实现分为三个流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Try to match an existing node 尝试去匹配一个未匹配过的节点。&lt;/li&gt;
&lt;li&gt;Try to append a new node (method tryAppend) 尝试将一个节点入队，对应tryAppend方法。&lt;/li&gt;
&lt;li&gt;Await match or cancellation (method awaitMatch) 阻塞等待一个节点被匹配或取消，对应awaitMatch方法。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后：具体步骤可以查看上面的解析，如有不足，望评论区指教。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Tue, 02 Feb 2021 15:41:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>系列传送门： Java并发包源码学习系列：AbstractQueuedSynchronizer Java并发包源码学习系列：CLH同步队列及同步资源获取与释放 Java并发包源码学习系列：AQS共享式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14364841.html</dc:identifier>
</item>
<item>
<title>使用timeout-decorator为python函数任务设置超时时间 - 陆言君</title>
<link>http://www.cnblogs.com/dechinphy/p/timeout.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/timeout.html</guid>
<description>&lt;p&gt;这里我们介绍了使用timeout-decorator来进行python的任务超时限制的方法，并且搭配介绍了python的输入参数配置与异常捕获的技巧，使得超时任务的配置和执行更加合理更加优雅。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;145.85839793282&quot;&gt;

&lt;p&gt;在python代码的实现中，假如我们有一个需要执行时间跨度非常大的for循环，如果在中间的某处我们需要定时停止这个函数，而不停止整个程序。那么初步的就可以想到两种方案：第一种方案是我们先预估for循环或者while中的每一步所需要的运行时间，然后设定在到达某一个迭代次数之后就自动退出循环;第二种方案是，在需要设置超时任务的前方引入超时的装饰器，使得超过指定时间之后自动退出函数执行。这里我们将针对第二种方案，进行展开介绍。&lt;/p&gt;

&lt;p&gt;在pypi的标准库中也包含有&lt;code&gt;timeout-decorator&lt;/code&gt;模块，因此可以通过&lt;code&gt;pip&lt;/code&gt;来直接安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro timeout]$ python3 -m pip install timeout_decorator
Collecting timeout_decorator
  Downloading timeout-decorator-0.5.0.tar.gz (4.8 kB)
Building wheels for collected packages: timeout-decorator
  Building wheel for timeout-decorator (setup.py) ... done
  Created wheel for timeout-decorator: filename=timeout_decorator-0.5.0-py3-none-any.whl size=5029 sha256=279f8585a08d5e5c87de887492169d1a81e02060c8ea3b62fdd6f062b7f83601
  Stored in directory: /home/dechin/.cache/pip/wheels/38/05/4e/161d1463ca145ec1023bd4e5e1f31cbf9239aa8f39a2a2b643
Successfully built timeout-decorator
Installing collected packages: timeout-decorator
Successfully installed timeout-decorator-0.5.0
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里我们先展示示例代码，再展开介绍其中各个模块的含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# timeout_test1.py
from tqdm import trange
import sys
import time
import timeout_decorator

@timeout_decorator.timeout(int(sys.argv[2]))
def test():
    if sys.argv[1] == '--timeout':
        for i in trange(3):
            time.sleep(1)
            print ('&amp;gt;&amp;gt;&amp;gt; {} seconds passed.'.format(i+1))
    return 0

if __name__ == '__main__':
    try:
        test()
    except Exception as e:
        print ('Timeout Error Catched!')
        print (e)
    print (&quot;Timeout Task Ended!&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;timeout-decorator装饰器的使用&quot;&gt;timeout-decorator装饰器的使用&lt;/h2&gt;
&lt;p&gt;该超时模块采用装饰器的形式来进行调用，使用时先&lt;code&gt;import&lt;/code&gt;该模块，然后在需要设置定时任务的函数前添加&lt;code&gt;@timeout_decorator.timeout(3)&lt;/code&gt;即可，这里括号中的3表示超时时间设置为3s，也就是3s后该函数就会停止运行。前面写过一篇博客介绍&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/decoretor.html&quot; target=&quot;_blank&quot;&gt;如何自定义一个装饰器&lt;/a&gt;，感兴趣的读者可以自行阅读。在上述的用例中，为了使得超时时间的定义更加灵活，我们采取了从用户输入获取参数的方案，具体内容参考下一章节的介绍。&lt;/p&gt;
&lt;h2 id=&quot;通过sys获取timeout参数&quot;&gt;通过sys获取timeout参数&lt;/h2&gt;
&lt;p&gt;在上述用例的装饰器中，我们看到了&lt;code&gt;int(sys.argv[2])&lt;/code&gt;这样的一个参数，这个参数的意思是用户输入命令行的&lt;code&gt;第三个&lt;/code&gt;用空格隔开的参数。举例子说，如果用户执行了&lt;code&gt;python3 test.py -t 1&lt;/code&gt;，那么这里就会产生三个输入参数：&lt;code&gt;argv[0]&lt;/code&gt;就是&lt;code&gt;test.py&lt;/code&gt;，&lt;code&gt;argv[1]&lt;/code&gt;就是&lt;code&gt;-t&lt;/code&gt;，&lt;code&gt;argv[2]&lt;/code&gt;就是&lt;code&gt;1&lt;/code&gt;，是一个数组的格式。需要注意的是，&lt;code&gt;argv&lt;/code&gt;数组的每一个元素都是字符串格式，如果需要使用数字需要先进行格式转换。这里针对于超时任务的处理，我们指定的执行策略为类似&lt;code&gt;python3 task.py --timeout 5&lt;/code&gt;的格式，&lt;code&gt;--timeout&lt;/code&gt;后面的数字表示任务执行超时的秒数。如果输入变量格式不正确，或者不满足3个以上的变量输入要求，或者第二个参数不是&lt;code&gt;--timeout&lt;/code&gt;，都有可能运行报错。&lt;/p&gt;
&lt;h2 id=&quot;异常捕获&quot;&gt;异常捕获&lt;/h2&gt;
&lt;p&gt;在定义好超时任务之后，如果达到了设定好的超时时间，系统会给出&lt;code&gt;timeout_decorator.timeout_decorator.TimeoutError&lt;/code&gt;报错并结束程序运行。但是我们这里配置超时任务的目的其实是希望在超时任务的函数到达指定时间之后退出，但是不影响其他模块程序的运行，因此这里我们需要对程序给出的报错进行异常捕获，并且通报与抑制该异常。比较简单的方案就是采用&lt;code&gt;except Exception as e&lt;/code&gt;的方式，一般&lt;code&gt;Exception&lt;/code&gt;最好可以指向指定的报错类型，而不是通用的&lt;code&gt;Exception&lt;/code&gt;处理，这有可能带来其他的一些风险。&lt;/p&gt;

&lt;p&gt;以下按照输入参数的不同，我们先划分为几个模块来分析输出结果以及原因。&lt;/p&gt;
&lt;h2 id=&quot;超时任务为2s&quot;&gt;超时任务为2s&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro timeout]$ python3 timeout_test.py --timeout 2
  0%|                                                 | 0/3 [00:00&amp;lt;?, ?it/s]&amp;gt;&amp;gt;&amp;gt; 1 seconds passed.
 33%|█████████████▋                           | 1/3 [00:01&amp;lt;00:03,  1.99s/it]
Timeout Error Catched!
'Timed Out'
Timeout Task Ended!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;结果分析&lt;/em&gt;：由于我们在程序中给定了一个一共会执行3s的任务，而这里在命令行中我们将超时时间设置为了2s，因此还没执行完程序就抛出并捕获了异常，成功打印了&lt;code&gt;Timeout Task Ended!&lt;/code&gt;这一超时任务之外的任务。&lt;/p&gt;
&lt;h2 id=&quot;超时任务为3s&quot;&gt;超时任务为3s&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro timeout]$ python3 timeout_test.py --timeout 3
  0%|                                                 | 0/3 [00:00&amp;lt;?, ?it/s]&amp;gt;&amp;gt;&amp;gt; 1 seconds passed.
 33%|█████████████▋                           | 1/3 [00:01&amp;lt;00:02,  1.00s/it]&amp;gt;&amp;gt;&amp;gt; 2 seconds passed.
 67%|███████████████████████████▎             | 2/3 [00:02&amp;lt;00:01,  1.50s/it]
Timeout Error Catched!
'Timed Out'
Timeout Task Ended!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;结果分析&lt;/em&gt;：由于我们在程序中给定了一个一共会执行3s的任务，虽然在命令行的输入参数中我们给定了3s的执行时间，但是最终程序还是没有执行结束并抛出了异常。这是因为&lt;code&gt;sleep(1)&lt;/code&gt;并不是精准的1s，也许是&lt;code&gt;1.0000001&lt;/code&gt;但是这超出来的时间也会对最终执行的总时间产生影响，况且还有其他模块程序所导致的&lt;code&gt;overlap&lt;/code&gt;，因此最后也没有执行完成。而且从进度条来看，上面一个章节中时间设置为3s的时候，其实也只是完成了33%的任务而不是67%的任务，这也是符合我们的预期的。&lt;/p&gt;
&lt;h2 id=&quot;超时任务为4s&quot;&gt;超时任务为4s&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro timeout]$ python3 timeout_test.py --timeout 4
  0%|                                                 | 0/3 [00:00&amp;lt;?, ?it/s]&amp;gt;&amp;gt;&amp;gt; 1 seconds passed.
 33%|█████████████▋                           | 1/3 [00:01&amp;lt;00:02,  1.00s/it]&amp;gt;&amp;gt;&amp;gt; 2 seconds passed.
 67%|███████████████████████████▎             | 2/3 [00:02&amp;lt;00:01,  1.00s/it]&amp;gt;&amp;gt;&amp;gt; 3 seconds passed.
100%|█████████████████████████████████████████| 3/3 [00:03&amp;lt;00:00,  1.00s/it]
Timeout Task Ended!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;结果分析&lt;/em&gt;：由于我们在程序中给定了一个一共会执行3s的任务，而在参数输入时配置了4s的超时时间，因此最终任务可以顺利执行完成。这里为了验证上面一个小章节中提到的&lt;code&gt;overlap&lt;/code&gt;，我们可以尝试使用系统自带的时间测试模块来测试，如果该程序执行完成之后，一共需要多少的时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[dechin@dechin-manjaro timeout]$ time python3 timeout_test.py --timeout 4
  0%|                                                 | 0/3 [00:00&amp;lt;?, ?it/s]&amp;gt;&amp;gt;&amp;gt; 1 seconds passed.
 33%|█████████████▋                           | 1/3 [00:01&amp;lt;00:02,  1.00s/it]&amp;gt;&amp;gt;&amp;gt; 2 seconds passed.
 67%|███████████████████████████▎             | 2/3 [00:02&amp;lt;00:01,  1.00s/it]&amp;gt;&amp;gt;&amp;gt; 3 seconds passed.
100%|█████████████████████████████████████████| 3/3 [00:03&amp;lt;00:00,  1.00s/it]
Timeout Task Ended!

real    0m3.167s
user    0m0.147s
sys     0m0.017s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们就可以看到，其实额定为3s的任务，执行完成需要约3.2s的实际时间，多出来的时间就是所谓的&lt;code&gt;overlap&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;函数的超时设置是一个比较小众使用的功能，可以用于任务的暂停(并非截断)等场景，并且配合上面章节提到的异常捕获和参数输入来使用，会使得任务更加优雅且合理。&lt;/p&gt;

&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/timeout.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/timeout.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 02 Feb 2021 15:07:00 +0000</pubDate>
<dc:creator>陆言君</dc:creator>
<og:description>这里我们介绍了使用timeout-decorator来进行python的任务超时限制的方法，并且搭配介绍了python的输入参数配置与异常捕获的技巧，使得超时任务的配置和执行更加合理更加优雅。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/timeout.html</dc:identifier>
</item>
<item>
<title>武装你的WEBAPI-OData常见问题 - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/14303517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/14303517.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文属于OData系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;非常喜欢OData，在各种新项目中都使用了这个技术。对于.NET 5.0，&lt;code&gt;OData&lt;/code&gt;推出了8.0preview，于是就试用了一下。发现坑还是非常多，如果不是很有必要的话，建议还是先等等。我使用的原因是在.NET 5.0的情况，7.x版本的OData会造成&lt;code&gt;[Authorize]&lt;/code&gt;无法正常工作，导致权限认证无法正常进行。&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;p&gt;运行环境如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ASP.NET CORE WEBAPI ON .NET 5.0&lt;/li&gt;
&lt;li&gt;Microsoft.AspNetCore.Authentication.JwtBearer 5.0.2&lt;/li&gt;
&lt;li&gt;Swashbuckle.AspNetCore 5.6.3&lt;/li&gt;
&lt;li&gt;Microsoft.AspNetCore.OData 8.0.0-preview3&lt;br/&gt;由于&lt;code&gt;Microsoft.AspNetCore.OData.Versioning.ApiExplorer&lt;/code&gt;这个库不支持新版的&lt;code&gt;OData&lt;/code&gt;，所以版本控制只能使用OData 8.0.0自带的路由方式控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;h3 id=&quot;提示swashbuckleaspnetcoreswaggergenswaggergeneratorexception-conflicting-methodpath-combination-get-apiweatherforecast-for-actions---actions-require-a-unique-methodpath-combination-for-swaggeropenapi-30-use-conflictingactionsresolver-as-a-workaround&quot;&gt;提示Swashbuckle.AspNetCore.SwaggerGen.SwaggerGeneratorException: Conflicting method/path combination &quot;GET api/WeatherForecast&quot; for actions - Actions require a unique method/path combination for Swagger/OpenAPI 3.0. Use ConflictingActionsResolver as a workaround&lt;/h3&gt;
&lt;p&gt;路由的形式有了变化，OData 8.0.0中，在Controller上标记了ODataRoutePrefix之后，不要标记无参数的ODataRoute。现在ODataRoute会从ODataRoutePrefix开始路由，如果标记无参数的ODataRoute，实际上相当于标记了两次，则系统会认为有两个相同的方法，操作重复路由。对于一个有参数，一个无参数的，可以给有参数的方法标记[ODataRoute(&quot;id&quot;)]。有一个例外，如果参数名称是&lt;code&gt;key&lt;/code&gt;，那么可以不标记。&lt;/p&gt;
&lt;p&gt;注意，请不要直接使用[HttpGet(&quot;id&quot;)]的形式给&lt;strong&gt;OData&lt;/strong&gt;指定路由，这个形式会直接忽略掉&lt;strong&gt;OData&lt;/strong&gt;直接从&lt;code&gt;/&lt;/code&gt;开始路由。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实我也觉得新的方式才是更合理的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;提示-swashbuckleaspnetcoreswaggergenswaggergeneratorexception-ambiguous-http-method-for-action---microsoftaspnetcoreodataroutingcontrollersmetadatacontrollergetmetadata-microsoftaspnetcoreodata-actions-require-an-explicit-httpmethod-binding-for-swaggeropenapi-30&quot;&gt;提示 Swashbuckle.AspNetCore.SwaggerGen.SwaggerGeneratorException: Ambiguous HTTP method for action - Microsoft.AspNetCore.OData.Routing.Controllers.MetadataController.GetMetadata (Microsoft.AspNetCore.OData). Actions require an explicit HttpMethod binding for Swagger/OpenAPI 3.0&lt;/h3&gt;
&lt;p&gt;我推测应该是bug，在Controller方法只有一个Get并且明确标志了[HttpGet]的形式，依然提示错误。这个问题可以参考&lt;a href=&quot;https://github.com/OData/AspNetCoreOData/issues/41&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;services.AddSwaggerGen(options =&amp;gt;
{
    // ........................
    options.DocInclusionPredicate((name, api) =&amp;gt; api.HttpMethod != null);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提示systeminvalidoperationexception-no-media-types-found-in-microsoftaspnetcoreodataformatterodataoutputformattersupportedmediatypes-add-at-least-one-media-type-to-the-list-of-supported-media-types&quot;&gt;提示System.InvalidOperationException: No media types found in 'Microsoft.AspNetCore.OData.Formatter.ODataOutputFormatter.SupportedMediaTypes'. Add at least one media type to the list of supported media types.&lt;/h3&gt;
&lt;p&gt;这个我估摸也是bug，请注意，&lt;strong&gt;必须将services.AddOData放在services.AddControllers之前，否则在Controller中无法识别ODataOutputFormatter&lt;/strong&gt;，然后参考&lt;a href=&quot;https://stackoverflow.com/questions/62404125/how-to-add-swagger-in-odata-enabled-web-api-running-on-asp-net-core-3-1&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;解决问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;services.AddControllers(
options =&amp;gt;
{
    foreach (var outputFormatter in options.OutputFormatters.OfType&amp;lt;ODataOutputFormatter&amp;gt;().Where(_ =&amp;gt; _.SupportedMediaTypes.Count == 0))
    {
        outputFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(&quot;application/odata&quot;));
    }

    foreach (var inputFormatter in options.InputFormatters.OfType&amp;lt;ODataInputFormatter&amp;gt;().Where(_ =&amp;gt; _.SupportedMediaTypes.Count == 0))
    {
        inputFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(&quot;application/odata&quot;));
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提示odm的问题the-entity-set-weatherforecast-is-based-on-type-webapplication2weatherforecast-that-has-no-keys-defined&quot;&gt;提示ODM的问题The entity set 'WeatherForecast' is based on type 'WebApplication2.WeatherForecast' that has no keys defined.&lt;/h3&gt;
&lt;p&gt;现在EdmBuilder不能识[Key]来进行主键的标记了，需要显式添加&lt;code&gt;HasKey&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var configuration = builder.EntitySet&amp;lt;WeatherForecast&amp;gt;(&quot;WeatherForecast&quot;).EntityType.HasKey(w=&amp;gt;w.TemperatureC);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;诡异的key与id问题&quot;&gt;诡异的key与id问题&lt;/h3&gt;
&lt;p&gt;如果数据模型使用的主键，在函数中签名为&lt;code&gt;key&lt;/code&gt;，大部分操作都很正常；如果使用&lt;code&gt;id&lt;/code&gt;就会出现各种形形色色的问题，比如不能正确识别函数重载、无法加载路由等问题。感觉和那个Conventional Routing有关系，实在是折腾不动了，老实使用&lt;code&gt;key&lt;/code&gt;算了。&lt;/p&gt;
&lt;h3 id=&quot;诡异的返回所有数据只有主键id的问题&quot;&gt;诡异的返回所有数据只有主键id的问题&lt;/h3&gt;
&lt;p&gt;返回数据数量是正确的，但是只能返回主键id，其他属性通通没有。这是因为原来使用&lt;code&gt;ODataModelBuilder&lt;/code&gt;已经不能正确工作了，现在需要更换成&lt;code&gt;ODataConventionModelBuilder&lt;/code&gt;才可以正常工作映射。&lt;/p&gt;
&lt;h3 id=&quot;返回首字符大小写的问题&quot;&gt;返回首字符大小写的问题&lt;/h3&gt;
&lt;p&gt;之前版本返回的都是默认的小写字母开头的CamelCase，这个版本默认直接返回PascalCase，对前端不是很友好，需要设置一下转换才可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;ODataConventionModelBuilder builder = new ODataConventionModelBuilder();
builder.EnableLowerCamelCase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实体类继承abstract导致的找不到基类的属性问题&quot;&gt;实体类继承abstract导致的找不到基类的属性问题&lt;/h3&gt;
&lt;p&gt;实体类在abstract基类中的属性，还是本质上还是属于基类，默认情况不在EDM中注册也是可以访问的，但是如果设置非默认的行为（比如设置了大小写），那会出现无法访问基类属性的现象（基类行为和实体类行为不一致），这个时候需要在EDM中对基类进行注册（即使没有对应的Controller或者其他引用），参考这个&lt;a href=&quot;https://stackoverflow.com/a/52013381&quot; target=&quot;_blank&quot;&gt;回答&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;完整代码&quot;&gt;完整代码&lt;/h2&gt;
&lt;p&gt;最后贴一下可以正常运行的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.OData;
using Microsoft.AspNetCore.OData.Formatter;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using Microsoft.Net.Http.Headers;
using Microsoft.OData.Edm;
using Microsoft.OData.ModelBuilder;
using Microsoft.OpenApi.Models;
using System.IdentityModel.Tokens.Jwt;
using System.IO;
using System.Linq;
using System.Text;

namespace WebApplication2
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =&amp;gt;
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    NameClaimType = JwtRegisteredClaimNames.Sub,
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = Configuration[&quot;Jwt:Issuer&quot;],
                    ValidAudience = Configuration[&quot;Jwt:Audience&quot;],
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[&quot;Jwt:Key&quot;]))
                };
                //options.Authority = &quot;https://222.31.160.20:5001&quot;;
            });
            services.AddCors(options =&amp;gt;
            {
                options.AddDefaultPolicy(
                    builder =&amp;gt;
                    {
                        builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
                    });
            });

            services.AddOData(opt =&amp;gt; opt.AddModel(&quot;api&quot;, GetEdmModel()).Expand().Filter().Count().OrderBy().Filter());

            services.AddControllers(
            options =&amp;gt;
            {
                foreach (var outputFormatter in options.OutputFormatters.OfType&amp;lt;ODataOutputFormatter&amp;gt;().Where(_ =&amp;gt; _.SupportedMediaTypes.Count == 0))
                {
                    outputFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(&quot;application/odata&quot;));
                }

                foreach (var inputFormatter in options.InputFormatters.OfType&amp;lt;ODataInputFormatter&amp;gt;().Where(_ =&amp;gt; _.SupportedMediaTypes.Count == 0))
                {
                    inputFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(&quot;application/odata&quot;));
                }
            });


            services.AddSwaggerGen(c =&amp;gt;
            {
                c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;WebApplication2&quot;, Version = &quot;v1&quot; });
                var filePath = Path.Combine(System.AppContext.BaseDirectory, &quot;WebApplication2.xml&quot;);
                c.IncludeXmlComments(filePath);
                c.DocInclusionPredicate((name, api) =&amp;gt; api.HttpMethod != null);
            });
        }

        private IEdmModel GetEdmModel()
        {
            ODataModelBuilder builder = new ODataModelBuilder();
            var configuration = builder.EntitySet&amp;lt;WeatherForecast&amp;gt;(&quot;WeatherForecast&quot;).EntityType.HasKey(w=&amp;gt;w.TemperatureC);

            return builder.GetEdmModel();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (true)
            {
                app.UseDeveloperExceptionPage();
                app.UseSwagger();
                app.UseSwaggerUI(c =&amp;gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;WebApplication2 v1&quot;));
            }

            app.UseCors();
            app.UseAuthentication();

            app.UseRouting();

            app.UseAuthorization();
            app.UseStaticFiles();

            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllers();
            });
        }


    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 02 Feb 2021 14:39:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>本文属于OData系列 目录 武装你的WEBAPI-OData入门 武装你的WEBAPI-OData便捷查询 武装你的WEBAPI-OData分页查询 武装你的WEBAPI-OData资源更新Delt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/podolski/p/14303517.html</dc:identifier>
</item>
<item>
<title>python协程 - 忞翛</title>
<link>http://www.cnblogs.com/lczmx/p/14364580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lczmx/p/14364580.html</guid>
<description>[unable to retrieve full-text content]python协程 协程本质上就是一个线程，不过它是协作式的非抢占式的程序，面向的是IO操作。python有GIL的限制，不能充分利用多线程的实现高并发。进程和线程都是通过cpu的调度实现不同任务的有序执行，协程则要在写代码的时候确定执行顺序。由于协程在一个线程中，所以协程不能阻塞。 优缺点： 无需线</description>
<pubDate>Tue, 02 Feb 2021 14:36:00 +0000</pubDate>
<dc:creator>忞翛</dc:creator>
<dc:identifier>http://www.cnblogs.com/lczmx/p/14364580.html</dc:identifier>
</item>
</channel>
</rss>