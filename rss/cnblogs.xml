<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET资源泄露与处理方案 - 未闻·Yokeqi</title>
<link>http://www.cnblogs.com/yokeqi/p/11920706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yokeqi/p/11920706.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;.NET虽然拥有强大易用的&lt;strong&gt;垃圾回收机制&lt;/strong&gt;，但并不是因为这样，你就可以对资源管理放任不管，其实在稍不注意的时候，可能就造成了资源泄露，甚至因此导致系统崩溃，到那时再来排查问题就已经是困难重重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、知识点简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的资源泄露有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存泄漏：非托管资源没有释放、非静态对象注册了静态实例。&lt;/li&gt;
&lt;li&gt;GDI泄露：字体。&lt;/li&gt;
&lt;li&gt;句柄泄露：Socket或线程。&lt;/li&gt;
&lt;li&gt;用户对象泄露：移除的对象未释放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二、具体实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 内存泄漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很常见的现象是分不清哪些对象需要释放，对于控件、Stream等一些非托管资源也只管新增，却没有释放，功能是实现了，却埋了颗不小的雷。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;1000&lt;/span&gt;;i++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Controls.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TabPage());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Form2.ShowDialog();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你觉得写这样的代码很Cool，很简洁，你在项目中也有这么写代码，那你就碰到大麻烦了，你试试在上面Form2中开个大一点的数组来检查内存，然后运行，按几下按钮，你就会发现，内存一直增加，即使你调用了GC也无济于事。所以，对于此类非托管资源要记住释放，用完即废可以采用using关键字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form2()
{
    InitializeComponent();
    MyApp.FormChanged &lt;/span&gt;+=&lt;span&gt; FormChanged;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子中，MyApp是一个静态类，如果在实例对象中向这种类里面注册了事件，而又没有取消注册，这样也会遇到大麻烦，即使在外部已经记得调用了Form2的Dispose也是没用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. GDI泄露&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般会跟字体相关，例如我曾在Android上用Cocos2d做一个小游戏时频繁地切换字体、Dev控件的Font属性赋值也会有这种现象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
XXX.Font = &lt;span&gt;new&lt;/span&gt; Font(...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个问题我目前是采用字体池来解决，类似线程池的概念，相同Key值取同一个对象。若有更好方案欢迎留言讨论&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3. 句柄泄露&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般跟Socket和Thread(线程)有关&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;1000&lt;/span&gt;;i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(()=&amp;gt;&lt;span&gt;{
        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
    }).Start();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Socket的场景暂时没遇到。&lt;/li&gt;
&lt;li&gt;线程问题采用线程池相关的辅助类能有效解决，例如ThreadPool、Task、Parallel。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4. 用户对象泄露&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般跟移除的对象未释放有关&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    tab.Remove(tabPage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、最后特别奉送一个内存释放的大招&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kernel32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SetProcessWorkingSetSize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetProcessWorkingSetSize(IntPtr process, &lt;span&gt;int&lt;/span&gt; minSize, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxSize);
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;    
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 释放内存    
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;    
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearMemory()
{
    GC.Collect();
    GC.WaitForPendingFinalizers();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Environment.OSVersion.Platform ==&lt;span&gt; PlatformID.Win32NT)
    {
        SetProcessWorkingSetSize(System.Diagnostics.Process.GetCurrentProcess().Handle, &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用以上API能让你的内存一下爆减，是不是很给力，一调用内存就降下来了。But，先别高兴太早，这其实是伪释放，只是暂时解决内存大量泄漏导致系统崩溃的应急处理方案。具体原因参考：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_49f8960e0100081x.html&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SetProcessWorkingSetSize函数的骗局&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;，关键信息：物理内存转虚拟内存，涉及磁盘读写。好处坏处都贴出来了，是否需要使用请君自己斟酌。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;实际上由于各个开发人员的水平跟接触面不同，又没有经过统一的培训（各个人对资源释放的理解与关注度不同，或者写代码时就没考虑内存未被释放这种问题），发现问题的时候项目往往已经做到了一个阶段，系统也比较庞大了，这种时候才发现内存泄露的问题确实是很头疼的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;资源泄露的场景往往是相互关联的，发生最多的就是内存泄漏，而除了写法可能有问题外，也可能是因为句柄泄露或用户对象泄露引起的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;五、参考资料&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 15:06:00 +0000</pubDate>
<dc:creator>未闻&amp;#183;Yokeqi</dc:creator>
<og:description>.NET虽然拥有强大易用的垃圾回收机制，但并不是因为这样，你就可以对资源管理放任不管，其实在稍不注意的时候，可能就造成了资源泄露，甚至因此导致系统崩溃，到那时再来排查问题就已经是困难重重。 一、知识点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yokeqi/p/11920706.html</dc:identifier>
</item>
<item>
<title>MachO文件详解--逆向开发 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/11915571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/11915571.html</guid>
<description>&lt;p&gt;今天是逆向开发的第5天内容--MachO文件（Mac 和 iOS 平台可执行的文件），在逆向开发中是比较重要的，下面我们着重讲解一下MachO文件的基本内容和使用。&lt;/p&gt;
&lt;h2&gt;一、MachO概述&lt;/h2&gt;
&lt;h3&gt;1. 概述&lt;/h3&gt;
&lt;p&gt;Mach-O是Mach Object文件格式的缩写，iOS以及Mac上可执行的文件格式，类似Window的exe格式，Linux上的elf格式。Mach-O是一个可执行文件、动态库以及目标代码的文件格式，是a.out格式的替代，提供了更高更强的扩展性。&lt;/p&gt;
&lt;h3&gt;2.常见格式&lt;/h3&gt;
&lt;p&gt;Mach-O常见格式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;目标文件 .o&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;库文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;.a&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.dylib&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.framework&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可执行文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dyld&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.dsym&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;通过&lt;span&gt;file&lt;/span&gt;文件路径查看文件类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们通过部分实例代码来简单研究一下。&lt;/p&gt;
&lt;h4&gt;2.1目标文件.o&lt;/h4&gt;
&lt;p&gt;通过test.c 文件，可以使用clang命令将其编译成目标文件.o&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123111822632-1337038185.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再通过&lt;strong&gt;file&lt;/strong&gt;命令（如下）查看文件类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123112009329-239800861.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是个Mach-O文件。&lt;/p&gt;
&lt;h4&gt;2.2 dylib&lt;/h4&gt;
&lt;p&gt;通过cd /usr/lib命令查看dylib&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123120552688-1175473242.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过file命令查看文件类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123120723740-1013805390.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;59&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 2.3 .&lt;strong&gt;dsym&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;下面是一个截图来说明.dsym是也是Mach-O文件格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123121200512-1383803110.png&quot; alt=&quot;&quot; width=&quot;868&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上只是Mach-O常见格式的某一种，大家可以通过命令来尝试。&lt;/p&gt;
&lt;h3&gt;3. 通用二进制文件&lt;/h3&gt;
&lt;p&gt;希望大家在了解App二进制架构的时候，可以先读一下&lt;span&gt;&lt;span&gt;本人&lt;/span&gt;写&lt;/span&gt;的另一篇博客关于armv7，armv7s以及arm64等的介绍。&lt;a href=&quot;https://www.cnblogs.com/guohai-stronger/p/9447364.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/guohai-stronger/p/9447364.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通用二进制文件是苹果自身发明的，基本内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123152009305-785975085.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面通过指令查看Macho文件来看下通用二进制文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123152243634-1694477585.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后通过file指令查看文件类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123152311667-1951770402.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面该MachO文件包含了3个架构分别是arm v7，arm v7s 以及arm 64 。&lt;/p&gt;
&lt;p&gt;针对该MachO文件我们做几个操作，利用&lt;strong&gt;&lt;span&gt;lipo&lt;/span&gt;&lt;/strong&gt;命令拆分合并架构&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3.1&lt;/span&gt; 利用lipo-info查看MachO文件架构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123153717729-597063376.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2 瘦身MachO文件，拆分&lt;/h4&gt;
&lt;p&gt;利用lipo-thin瘦身架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123200538325-629977004.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 查看一下结果如下，多出来一个新建的MachO_armv7&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123200643234-844910356.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3.3 增加架构，合并&lt;/h4&gt;
&lt;p&gt;利用lipo -create 合并多种架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123201306947-977402508.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现多出一种框架，合并成功多出Demo可执行文件。结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123201459899-1775947888.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整理出lipo命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123201915288-1208731629.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;208&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;二、MachO文件&lt;/h3&gt;
&lt;h3&gt;2.1 文件结构&lt;/h3&gt;
&lt;p&gt;下面是苹果官方图解释MachO文件结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123203247605-649756095.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MachO文件的组成结构如上，看包括了三个部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Header&lt;/strong&gt;包含了该二进制文件的一般信息，信息如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;字节顺序、加载指令的数量以及架构类型&lt;/li&gt;
&lt;li&gt;快速的确定一些信息，比如当前文件是32位或者64位，对应的文件类型和处理器是什么&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Load commands&lt;/strong&gt; 包含很多内容的表&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;包括区域的位置、动态符号表以及符号表等&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt;一般是对象文件的最大部分&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;一般包含Segement具体数据&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;2.2 Header的数据结构&lt;/h3&gt;
&lt;p&gt;在项目代码中，按下Command+ 空格，然后输入loader.h  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123213731074-712264334.png&quot; alt=&quot;&quot; width=&quot;502&quot; height=&quot;575&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看loader.h文件，找到mach_header&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123213844713-2135030334.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是mach_header，对应结构体的意义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123214034116-417068310.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过MachOView查看Mach64 Header头部信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123214325281-1877084420.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 LoadCommands&lt;/h3&gt;
&lt;p&gt;LoadCommand包含了很多内容的表，通过MachOView查看LoadCommand的信息，图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123215502848-788859148.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;677&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是大家看的可能并不了解内容，下面有图进行注解，可以看下主要的意思&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123215737565-1989439284.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.4 Data&lt;/h3&gt;
&lt;p&gt;Data包含Segement，存储具体数据，通过MachOView查看，地址映射内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123220539743-953973415.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;544&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、DYLD&lt;/h2&gt;
&lt;h3&gt;3.1 dyld概述&lt;/h3&gt;
&lt;p&gt;dyld（the dynamic link editor）是苹果动态链接器，是苹果系统一个重要的组成部分，系统内核做好准备工作之后，剩下的就会交给了dyld。&lt;/p&gt;
&lt;h3&gt;3.2 dyld加载过程&lt;/h3&gt;
&lt;p&gt;程序的入口一般都是在main函数中，但是比较少的人关心main()函数之前发生了什么？这次我们先探索dyld的加载过程。（但是比在main函数之前，load方法就在main函数之前）&lt;/p&gt;
&lt;h4&gt;3.2.1 新建项目，在main函数下断&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1305302/201911/1305302-20191123224050064-373049705.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;

&lt;p&gt;main()之前有个libdyld.dylib start入口，但是不是我们想要的，根据dyld源码找到__dyld_start函数&lt;/p&gt;
&lt;h3&gt;3.2.2 dyld main()函数&lt;/h3&gt;
&lt;p&gt;dyld main()函数是关键函数，下面是函数实现内容。（&lt;span&gt;此时的main实现函数和程序App的main 函数是不一样的，因为dyld也是一个可执行文件，也是具有main函数的&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d3ffb7ee-f435-4853-8253-e805f57f436c')&quot; readability=&quot;60.5&quot;&gt;&lt;img id=&quot;code_img_closed_d3ffb7ee-f435-4853-8253-e805f57f436c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d3ffb7ee-f435-4853-8253-e805f57f436c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d3ffb7ee-f435-4853-8253-e805f57f436c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d3ffb7ee-f435-4853-8253-e805f57f436c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;116&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sets up some registers and call this function.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Returns address of main() in target program which __dyld_start jumps to
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;uintptr_t
_main(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; macho_header*&lt;span&gt; mainExecutableMH, uintptr_t mainExecutableSlide, 
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* argv[], &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* envp[], &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; apple[], 
        uintptr_t&lt;/span&gt;*&lt;span&gt; startGlue)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Grab the cdHash of the main executable from the environment
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步，设置运行环境&lt;/span&gt;
    uint8_t mainExecutableCDHashBuffer[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint8_t* mainExecutableCDHash =&lt;span&gt; nullptr;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( hexToBytes(_simple_getenv(apple, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable_cdhash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;40&lt;/span&gt;&lt;span&gt;, mainExecutableCDHashBuffer) )
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主程序的hash&lt;/span&gt;
        mainExecutableCDHash =&lt;span&gt; mainExecutableCDHashBuffer;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trace dyld's load&lt;/span&gt;
    notifyKernelAboutImage((macho_header*)&amp;amp;__dso_handle, _simple_getenv(apple, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dyld_file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; !TARGET_IPHONE_SIMULATOR
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Trace the main executable's load&lt;/span&gt;
    notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable_file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

    uintptr_t result &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主程序的macho_header结构&lt;/span&gt;
    sMainExecutableMachHeader =&lt;span&gt; mainExecutableMH;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主程序的slide值&lt;/span&gt;
    sMainExecutableSlide =&lt;span&gt; mainExecutableSlide;

    CRSetCrashLogMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dyld: launch started&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置上下文信息&lt;/span&gt;
&lt;span&gt;    setContext(mainExecutableMH, argc, argv, envp, apple);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pickup the pointer to the exec path.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主程序路径&lt;/span&gt;
    sExecPath = _simple_getenv(apple, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executable_path&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;rdar:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;problem/13868260&amp;gt; Remove interim apple[0] transition code from dyld&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!sExecPath) sExecPath = apple[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( sExecPath[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; have relative path, use cwd to make absolute&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt;&lt;span&gt; cwdbuff[MAXPATHLEN];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( getcwd(cwdbuff, MAXPATHLEN) !=&lt;span&gt; NULL ) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; maybe use static buffer to avoid calling malloc so early...&lt;/span&gt;
            &lt;span&gt;char&lt;/span&gt;* s = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[strlen(cwdbuff) + strlen(sExecPath) + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
            strcpy(s, cwdbuff);
            strcat(s, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            strcat(s, sExecPath);
            sExecPath &lt;/span&gt;=&lt;span&gt; s;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remember short name of process for later logging
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取进程名称&lt;/span&gt;
    sExecShortName = ::strrchr(sExecPath, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( sExecShortName !=&lt;span&gt; NULL )
        &lt;/span&gt;++&lt;span&gt;sExecShortName;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        sExecShortName &lt;/span&gt;=&lt;span&gt; sExecPath;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置进程受限模式&lt;/span&gt;
&lt;span&gt;    configureProcessRestrictions(mainExecutableMH);


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测环境变量&lt;/span&gt;
&lt;span&gt;    checkEnvironmentVariables(envp);
    defaultUninitializedFallbackPaths(envp);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( sEnv.DYLD_PRINT_OPTS )
        printOptions(argv);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( sEnv.DYLD_PRINT_ENV ) 
        printEnvironmentVariables(envp);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前程序架构&lt;/span&gt;
&lt;span&gt;    getHostInfo(mainExecutableMH, mainExecutableSlide);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------第一步结束-------------
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load shared cache
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步，加载共享缓存
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查共享缓存是否开启，iOS必须开启&lt;/span&gt;
    checkSharedRegionDisable((mach_header*&lt;span&gt;)mainExecutableMH);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( gLinkContext.sharedRegionMode !=&lt;span&gt; ImageLoader::kDontUseSharedRegion ) {
        mapSharedCache();
    }
    ...

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add dyld itself to UUID list&lt;/span&gt;
&lt;span&gt;        addDyldImageToUUIDList();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; instantiate ImageLoader for main executable
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步 实例化主程序&lt;/span&gt;
        sMainExecutable =&lt;span&gt; instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);
        gLinkContext.mainExecutable &lt;/span&gt;=&lt;span&gt; sMainExecutable;
        gLinkContext.mainExecutableCodeSigned &lt;/span&gt;=&lt;span&gt; hasCodeSignatureLoadCommand(mainExecutableMH);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now that shared cache is loaded, setup an versioned dylib overrides&lt;/span&gt;
    &lt;span&gt;#if&lt;/span&gt; SUPPORT_VERSIONED_PATHS&lt;span&gt;
        checkVersionedPaths();
    &lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;


        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dyld_all_image_infos image list does not contain dyld
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add it as dyldPath field in dyld_all_image_infos
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for simulator, dyld_sim is in image list, need host dyld added&lt;/span&gt;
&lt;span&gt;#if&lt;/span&gt; TARGET_IPHONE_SIMULATOR
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get path of host dyld from table of syscall vectors in host dyld&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;* addressInDyld =&lt;span&gt; gSyscallHelpers;
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get path of dyld itself&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;*  addressInDyld = (&lt;span&gt;void&lt;/span&gt;*)&amp;amp;&lt;span&gt;__dso_handle;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt; dyldPathBuffer[MAXPATHLEN+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = proc_regionfilename(getpid(), (uint64_t)(&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)addressInDyld, dyldPathBuffer, MAXPATHLEN);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( len &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
            dyldPathBuffer[len] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; proc_regionfilename() does not zero terminate returned string&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( strcmp(dyldPathBuffer, gProcessInfo-&amp;gt;dyldPath) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
                gProcessInfo&lt;/span&gt;-&amp;gt;dyldPath =&lt;span&gt; strdup(dyldPathBuffer);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load any inserted libraries
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步 加载插入的动态库&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;  ( sEnv.DYLD_INSERT_LIBRARIES !=&lt;span&gt; NULL ) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* &lt;span&gt;const&lt;/span&gt;* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++&lt;span&gt;lib)
                loadInsertedDylib(&lt;/span&gt;*&lt;span&gt;lib);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; record count of inserted libraries so that a flat search will look at 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; inserted libraries, then main, then others.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录插入的动态库数量&lt;/span&gt;
        sInsertedDylibCount = sAllImages.size()-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; link main executable
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步 链接主程序&lt;/span&gt;
        gLinkContext.linkingMainExecutable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; SUPPORT_ACCELERATE_TABLES
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( mainExcutableAlreadyRebased ) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; previous link() on main executable has already adjusted its internal pointers for ASLR
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; work around that by rebasing by inverse amount&lt;/span&gt;
            sMainExecutable-&amp;gt;rebase(gLinkContext, -&lt;span&gt;mainExecutableSlide);
        }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, ImageLoader::RPathChain(NULL, NULL), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        sMainExecutable&lt;/span&gt;-&amp;gt;&lt;span&gt;setNeverUnloadRecursive();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( sMainExecutable-&amp;gt;&lt;span&gt;forceFlat() ) {
            gLinkContext.bindFlat &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            gLinkContext.prebindUsage &lt;/span&gt;=&lt;span&gt; ImageLoader::kUseNoPrebinding;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; link any inserted libraries
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do this after linking main executable so that any dylibs pulled in by inserted 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; dylibs (e.g. libSystem) will not be in front of dylibs the program uses
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步 链接插入的动态库&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( sInsertedDylibCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(unsigned &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; sInsertedDylibCount; ++&lt;span&gt;i) {
                ImageLoader&lt;/span&gt;* image = sAllImages[i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                link(image, sEnv.DYLD_BIND_AT_LAUNCH, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, ImageLoader::RPathChain(NULL, NULL), -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                image&lt;/span&gt;-&amp;gt;&lt;span&gt;setNeverUnloadRecursive();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; only INSERTED libraries can interpose
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register interposing info after all inserted libraries are bound so chaining works&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(unsigned &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; sInsertedDylibCount; ++&lt;span&gt;i) {
                ImageLoader&lt;/span&gt;* image = sAllImages[i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                image&lt;/span&gt;-&amp;gt;&lt;span&gt;registerInterposing();
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;rdar:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;problem/19315404&amp;gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt; i=sInsertedDylibCount+&lt;span&gt;1&lt;/span&gt;; i &amp;lt; sAllImages.size(); ++&lt;span&gt;i) {
            ImageLoader&lt;/span&gt;* image =&lt;span&gt; sAllImages[i];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( image-&amp;gt;&lt;span&gt;inSharedCache() )
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            image&lt;/span&gt;-&amp;gt;&lt;span&gt;registerInterposing();
        }
        ...

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; apply interposing to initial set of images&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; sImageRoots.size(); ++&lt;span&gt;i) {
            sImageRoots[i]&lt;/span&gt;-&amp;gt;&lt;span&gt;applyInterposing(gLinkContext);
        }
        gLinkContext.linkingMainExecutable &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;rdar:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;problem/12186933&amp;gt; do weak binding only after all inserted images linked
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第七步 执行弱符号绑定&lt;/span&gt;
        sMainExecutable-&amp;gt;&lt;span&gt;weakBind(gLinkContext);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If cache has branch island dylibs, tell debugger about them&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( (sSharedCacheLoadInfo.loadAddress != NULL) &amp;amp;&amp;amp; (sSharedCacheLoadInfo.loadAddress-&amp;gt;header.mappingOffset &amp;gt;= &lt;span&gt;0x78&lt;/span&gt;) &amp;amp;&amp;amp; (sSharedCacheLoadInfo.loadAddress-&amp;gt;header.branchPoolsOffset != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) ) {
            uint32_t count &lt;/span&gt;= sSharedCacheLoadInfo.loadAddress-&amp;gt;&lt;span&gt;header.branchPoolsCount;
            dyld_image_info info[count];
            &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint64_t* poolAddress = (uint64_t*)((&lt;span&gt;char&lt;/span&gt;*)sSharedCacheLoadInfo.loadAddress + sSharedCacheLoadInfo.loadAddress-&amp;gt;&lt;span&gt;header.branchPoolsOffset);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;rdar:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;problem/20799203&amp;gt; empty branch pools can be in development cache&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( ((mach_header*)poolAddress)-&amp;gt;magic == sMainExecutableMachHeader-&amp;gt;&lt;span&gt;magic ) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; poolIndex=&lt;span&gt;0&lt;/span&gt;; poolIndex &amp;lt; count; ++&lt;span&gt;poolIndex) {
                    uint64_t poolAddr &lt;/span&gt;= poolAddress[poolIndex] +&lt;span&gt; sSharedCacheLoadInfo.slide;
                    info[poolIndex].imageLoadAddress &lt;/span&gt;= (mach_header*)(&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)poolAddr;
                    info[poolIndex].imageFilePath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dyld_shared_cache_branch_islands&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    info[poolIndex].imageFileModDate &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add to all_images list&lt;/span&gt;
&lt;span&gt;                addImagesToAllImages(count, info);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tell gdb about new branch island images&lt;/span&gt;
                gProcessInfo-&amp;gt;&lt;span&gt;notification(dyld_image_adding, count, info);
            }
        }

        CRSetCrashLogMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dyld: launch, running initializers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run all initializers
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第八步 执行初始化方法&lt;/span&gt;
&lt;span&gt;        initializeMainExecutable(); 

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; notify any montoring proccesses that this process is about to enter main()&lt;/span&gt;
        dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_MAIN_DYLD2, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        notifyMonitoringDyldMain();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; find entry point for main executable
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第九步 查找入口点并返回&lt;/span&gt;
        result = (uintptr_t)sMainExecutable-&amp;gt;&lt;span&gt;getThreadPC();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( result != &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main executable uses LC_MAIN, needs to return to glue in libdyld.dylib&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( (gLibSystemHelpers != NULL) &amp;amp;&amp;amp; (gLibSystemHelpers-&amp;gt;version &amp;gt;= &lt;span&gt;9&lt;/span&gt;&lt;span&gt;) )
                &lt;/span&gt;*startGlue = (uintptr_t)gLibSystemHelpers-&amp;gt;&lt;span&gt;startGlueToCallExit;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                halt(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;libdyld.dylib support not present for LC_MAIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()&lt;/span&gt;
            result = (uintptr_t)sMainExecutable-&amp;gt;&lt;span&gt;getMain();
            &lt;/span&gt;*startGlue = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; message) {
        syncAllImages();
        halt(message);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(...) {
        dyld::log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dyld: launch failed\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    ...
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;折叠开dyld main函数，步骤总结如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置运行环境，获取当前运行架构&lt;/li&gt;
&lt;li&gt;加载共享缓存，映射到当前运行架构&lt;/li&gt;
&lt;li&gt;进行实例化主程序&lt;/li&gt;
&lt;li&gt;开始加载插入的动态库&lt;/li&gt;
&lt;li&gt;然后链接主程序&lt;/li&gt;
&lt;li&gt;开始链接插入的动态库&lt;/li&gt;
&lt;li&gt;弱符号绑定&lt;/li&gt;
&lt;li&gt;初始化方法&lt;/li&gt;
&lt;li&gt;寻找主程序的入口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对待dyld的讲述，是非常不易的，因为本身过程是比较复杂的，上面仅仅是自身的抽出来的。下面再画一张流程图，帮助大家理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1305302/201911/1305302-20191123225736859-2075903793.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p&gt;MachO文件对于逆向开发是非常重要的，通过本次讲解，希望对大家理解逆向开发有所帮助，也希望大家真正可以提高技术，应对iOS市场的大环境，下一篇我们将讲述Hook原理--逆向开发。谢谢！！！&lt;/p&gt;







</description>
<pubDate>Sat, 23 Nov 2019 15:05:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>今天是逆向开发的第5天内容--MachO文件（Mac 和 iOS 平台可执行的文件），在逆向开发中是比较重要的，下面我们着重讲解一下MachO文件的基本内容和使用。 一、MachO概述 1. 概述 M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guohai-stronger/p/11915571.html</dc:identifier>
</item>
<item>
<title>SpringBoot 正式环境必不可少的外部化配置 - 逸飞兮</title>
<link>http://www.cnblogs.com/lw5946/p/11920709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lw5946/p/11920709.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201911/1775867-20191123230246344-1245467273.jpg&quot; alt=&quot;SpringBoot 外部化配置&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MDIxODU2Nw==&amp;amp;mid=2247483692&amp;amp;idx=1&amp;amp;sn=04fe1bbb5e1d07e0dd591a9da4f485a9&amp;amp;chksm=ce28f484f95f7d92583bdab398c0c2b6256e1387a5cce6f263de77e70ac104921c207c625b1a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1573392057076&amp;amp;sharer_shareid=a676e0ed20ad819ca1459ece28973a8a#rd&quot;&gt;《【源码解析】凭什么？spring boot 一个 jar 就能开发 web 项目》&lt;/a&gt; 中有读者反应：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;部署后运维很不方便，比较修改一个 IP 配置，需要重新打包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一点我是深有体会，17 年自学，并很大胆的直接在生产环境用的时候，我都是让产品经理（此时他充当我们的运维，嘿嘿）用压缩软件打开 jar，然后复制出配置，修改完之后再替换回去。为什么我这么大胆，因为当时才入行一年，而且觉得有架构师兜底，我就奔放了。你是不知道，当时负责这个项目的开发（c#开发）一开始不想用 SpringBoot 的。&lt;/p&gt;
&lt;p&gt;不过如今看到这个问题，我有点震惊，都 9102 年了，竟然还担心这样的问题。我想说，哥们，这真的不是事儿。SpringBoot 早就提供了方法来解决这个问题。&lt;/p&gt;

&lt;p&gt;SpringBoot 有很多生产特性，可以在生产环境中使用时更加方便。其中外部化配置基本都会用到。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spring Boot 允许外部化配置，以便相同的应用在不同的环境中工作。&lt;br/&gt;属性值可以在 Spring 环境中使用 @Value 或 @ConfigurationProperties 使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此次参考的版本是 &lt;code&gt;SpringBoot-2.2.0.RELEASE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;外部化配置的优先级顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Devtools 全局配置：当 devtools 启用时，&lt;code&gt;$HOME/.config/spring-boot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试类中的 &lt;code&gt;@TestPropertySource&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试中的 &lt;code&gt;properties&lt;/code&gt; 属性：在 @SpringBootTest 和 用来测试特定片段的测试注解&lt;/li&gt;
&lt;li&gt;命令行参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; 中的属性：内嵌在环境变量或系统属性中的 JSON&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletConfig&lt;/code&gt; 初始化参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContext&lt;/code&gt; 初始化参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java:comp/env&lt;/code&gt; 中的 JNDI 属性&lt;/li&gt;
&lt;li&gt;Java 系统属性：&lt;code&gt;System.getProperties()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;操作系统环境变量&lt;/li&gt;
&lt;li&gt;随机值（&lt;code&gt;RandomValuePropertySource&lt;/code&gt;）：&lt;code&gt;random.*&lt;/code&gt;属性&lt;/li&gt;
&lt;li&gt;jar 包&lt;strong&gt;外&lt;/strong&gt;的指定 profile 配置文件：&lt;code&gt;application-{profile}.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jar 包&lt;strong&gt;内&lt;/strong&gt;的指定 profile 配置文件：&lt;code&gt;application-{profile}.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jar 包&lt;strong&gt;外&lt;/strong&gt;的默认配置文件：&lt;code&gt;application.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jar 包&lt;strong&gt;内&lt;/strong&gt;的默认配置文件：&lt;code&gt;application.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;代码内的 &lt;code&gt;@PropertySource&lt;/code&gt;注解：用于 &lt;code&gt;@Configuration&lt;/code&gt; 类上&lt;/li&gt;
&lt;li&gt;默认属性：通过设置 &lt;code&gt;SpringApplication.setDefaultProperties&lt;/code&gt; 指定&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：以上用 &lt;code&gt;properties&lt;/code&gt; 文件的地方也可用 &lt;code&gt;yml&lt;/code&gt;文件&lt;/p&gt;

&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;my.uuid=${random.uuid}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar -Ddemo=vm demo.jar --demo=arg&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-Dxxx 为 vm 参数，在代码中通过 &lt;code&gt;System#getProperty&lt;/code&gt; 获取&lt;/li&gt;
&lt;li&gt;--xxx 为 spring 命令行参数，通过 &lt;code&gt;Environment#getProperty&lt;/code&gt; 获取，若通过此方法获取不到，会获取 vm 同名参数&lt;/li&gt;
&lt;li&gt;xxx.jar 之后的参数都是 arg 参数，都会在 main 方法中的 arg 数组中获取到&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    ConfigurableApplicationContext context = SpringApplication.run(ArgApplication.class, args);
    LOGGER.info(&quot;----------------&quot;);
    /* 打印 arg 参数 */
    Arrays.stream(args)
        .forEach(
            arg -&amp;gt; {
              LOGGER.info(&quot;arg:{}&quot;, arg);
            });
    /* 命令行传参 demo */
    LOGGER.info(&quot;System#getProperty:{}&quot;, System.getProperty(&quot;demo&quot;));
    LOGGER.info(&quot;Environment#getProperty:{}&quot;, context.getEnvironment().getProperty(&quot;demo&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar -Ddemo=vm arg-0.0.1-SNAPSHOT.jar aaa bbb ccc --demo=arg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----------------
arg:aaa
arg:bbb
arg:ccc
arg:--demo=arg
System#getProperty:vm
Environment#getProperty:arg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果执行命令是：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar -Ddemo=vm arg-0.0.1-SNAPSHOT.jar aaa bbb ccc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arg:aaa
arg:bbb
arg:ccc
System#getProperty:vm
Environment#getProperty:vm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果执行命令是：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar arg-0.0.1-SNAPSHOT.jar aaa bbb ccc --demo=arg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arg:aaa
arg:bbb
arg:ccc
arg:--demo=arg
System#getProperty:null
Environment#getProperty:arg&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;优先级：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;file:./config/&lt;/li&gt;
&lt;li&gt;file:./&lt;/li&gt;
&lt;li&gt;classpath:/config/&lt;/li&gt;
&lt;li&gt;classpath:/&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果定义了 &lt;code&gt;spring.config.location&lt;/code&gt;，如：&lt;code&gt;classpath:/custom-config/,file:./customr-config/&lt;/code&gt;，优先级如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;file:./custom-config/&lt;/li&gt;
&lt;li&gt;classpath:custom-config/&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果指定了 &lt;code&gt;spring.config.additional-location&lt;/code&gt;，会先加载 &lt;strong&gt;additional&lt;/strong&gt; 配置 如：&lt;code&gt;spring.config.additional-location=classpath:/custom-config/,file:./customr-config/&lt;/code&gt;，优先级如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;file:./custom-config/&lt;/li&gt;
&lt;li&gt;classpath:/custom-config/&lt;/li&gt;
&lt;li&gt;file:./config/&lt;/li&gt;
&lt;li&gt;file:./&lt;/li&gt;
&lt;li&gt;classpath:/config/&lt;/li&gt;
&lt;li&gt;classpath:/&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认的 profile 是 &lt;code&gt;default&lt;/code&gt;，当没有指定&lt;code&gt;spring.profiles.active&lt;/code&gt; 属性时，默认会加载&lt;code&gt;application-default.properties&lt;/code&gt; 文件。指定 profiles 文件的加载顺序与上述不指定 profiles 文件的加载一致。&lt;code&gt;指定 profile 文件的属性始终覆盖未指定文件的属性&lt;/code&gt;。如：&lt;code&gt;spring.profiles.active=dev&lt;/code&gt;，则 &lt;code&gt;application-dev.properties&lt;/code&gt;文件内的属性会覆盖 &lt;code&gt;application.properties&lt;/code&gt; 内的同名属性。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：如果在 &lt;code&gt;spring.config.location&lt;/code&gt; 属性中指定了 &lt;code&gt;文件&lt;/code&gt;，则此文件对应的特定 profiles 类文件不起作用。如果想要起作用，在 &lt;code&gt;spring.config.location&lt;/code&gt; 中使用 &lt;code&gt;文件夹&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置文件中可以引用之前定义的值，如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;app.name=MyApp
app.description=${app.name} is a Spring Boot application.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用此特性创建一些已存在的 Spring Boot 配置的较短、易于使用的变量。如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# nacos 配置示例
spring:
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        namespace: d9a39d78-xxxxxxxx-ea4f282e9d99
      discovery:
        server-addr: 127.0.0.1:8848
        namespace: d9a39d78-xxxxxxxx-ea4f282e9d99
# Discovery 配置示例        
nacos:
  plugin:
    namespace: d9a39d78-xxxxxxxx-ea4f282e9d99&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可改为如下配置&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    nacos:
      config:
        server-addr: ${app.server-addr}
        namespace: ${app.namespace}
      discovery:
        server-addr: ${app.server-addr}
        namespace: ${app.namespace}
# Discovery 配置示例        
nacos:
  plugin:
    namespace: ${app.namespace}

app:
  server-addr: 127.0.0.1:8848
  namespace: d9a39d78-xxxxxxxx-ea4f282e9d99&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在命令行可以直接通过 &lt;code&gt;-Dapp.namespace&lt;/code&gt; 或 &lt;code&gt;--app.namespace&lt;/code&gt; 来传参，会方便很多。特别是在多个地方用到同一个属性的时候。&lt;/p&gt;

&lt;p&gt;Spring Boot 不支持属性加密，但提供钩子节点修改配置属性。&lt;code&gt;EnvironmentPostProcessor&lt;/code&gt; 接口允许在应用启动前操作 &lt;code&gt;Environment&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;yaml 文件使用的时候非常直观、方便。而且在 Spring Boot 中做了处理，获取 yaml 和 properties 文件中的属性基本是一样的操作。&lt;/p&gt;
&lt;h2 id=&quot;一个文件指定多-pfofile&quot;&gt;一个文件指定多 pfofile&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;spring.profiles&lt;/code&gt; 指示何时使用对应的配置，使用 &lt;code&gt;---&lt;/code&gt;进行配置分隔&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# application.yml
server:
  address: 192.168.1.100
---
spring:
  profiles: development
server:
  address: 127.0.0.1
---
spring:
  profiles: production &amp;amp; eu-central
server:
  address: 192.168.1.120&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;yaml-缺点&quot;&gt;yaml 缺点&lt;/h2&gt;
&lt;p&gt;用 &lt;code&gt;@PropertySource&lt;/code&gt; 不能加载 yaml 文件，这种情况下只能使用 properties 文件。&lt;/p&gt;
&lt;p&gt;在特定 profile 的 yaml 文件中使用多 profile 配置，会有意料之外的情况：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# application-dev.yml
server:
  port: 8000
---
spring:
  profiles: &quot;!test&quot;
  security:
    user:
      password: &quot;secret&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当运行时指定 &lt;code&gt;--spring.profiles.active=dev&lt;/code&gt; ，启用 dev profile，其它的 profile 会忽略。也就是此例中 &lt;code&gt;spring.security.user.password&lt;/code&gt; 属性会失效。&lt;/p&gt;
&lt;p&gt;因此，不要在指定 profile 的 yaml 文件中使用多种 profile 配置。&lt;/p&gt;

&lt;h2 id=&quot;javabean-属性绑定&quot;&gt;JavaBean 属性绑定&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解将属性（properties、yml 文件、环境变量等）绑定到类对象中。与自动配置类类似。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(&quot;acme&quot;)
public class AcmeProperties{
    private boolean enabled;
    private InetAddress remoteAddress;
    private final Security security = new Security();
    // getter and setter
    public static class Security{
        private String username;
        private String password;
        private List&amp;lt;String&amp;gt; roles = new ArrayList&amp;lt;&amp;gt;(Collections.singleton(&quot;USER&quot;));
         // getter and setter
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这种安排依赖于默认的无参构造器，getter 和 setter 通常是必需的，因为绑定就像 Spring MVC 一样是通过标准的 Java Beans 属性描述符进行的。在下列情况下，可省略 setter：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Maps：只要被初始化后，getter 必须而 setter 不必须，binder 可以对它们进行修改&lt;/li&gt;
&lt;li&gt;Collections 和 数组：可以通过索引或逗号分隔的值来设定属性。后者必须有 setter 方法。建议对于这种情况一直加上 setter。如果初始化了一个 Collection，确保它不是不可变类型。&lt;/li&gt;
&lt;li&gt;如果初始化了嵌套的 POJO 属性（如上例中的 Security），setter 不是必须的。如果需要 binder 通过其默认构造器动态创建实例，则需要 setter&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：如果使用 Lombok 生成 getter 和 setter，确保不会生成任何特定的构造器，不然容器会自动使用它来实例化对象。&lt;br/&gt;最后，只有标准 Java Bean 属性可以这样绑定属性，静态属性不支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构造器绑定&quot;&gt;构造器绑定&lt;/h2&gt;
&lt;p&gt;上述示例可以改成如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConstructorBinding
@ConfigurationProperties(&quot;acme&quot;)
public class AcmeProperties{
  private final boolean enabled;
  private final InetAddress remoteAddress;
  private final Security security;
  
  public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security){
      this.enabled = enabled;
      this.remoteAddress = remoteAddress;
      this.security = security;
  }
  // getter and setter
  
  public static class Security{
      private final String username;
      private final String password;
      private final List&amp;lt;String&amp;gt; roles;
      public Security(String username, String password, @DefaultValue(&quot;USER&quot;) List&amp;lt;String&amp;gt; roles){
          this.username = username;
          this.password = password;
          this.roles = roles;
      }
      // getter and setter
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@ConstructorBinding&lt;/code&gt; 注解表示使用构造函数绑定属性值。这意味着 &lt;code&gt;binder&lt;/code&gt; 将期望找到一个包含待绑定参数的构造器。&lt;br/&gt;&lt;code&gt;@ConstructorBinding&lt;/code&gt; 类的嵌套成员也将通过构造函数绑定属性值。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;@DefaultValue&lt;/code&gt; 指定默认值，转换服务将字符串值强转为缺少属性的目标类型。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;要使用构造绑定，类必须允许使用 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 或 配置属性扫描方式。不能对由常规 Spring 机制创建的 bean 使用构造函数绑定。如：@Component Bean、通过@Bean 方法创建的 Bean 或使用@Import 加载的 Bean&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果类中有多个构造器，可以直接将 &lt;code&gt;@ConstructorBinding&lt;/code&gt; 注解使用在要绑定的构造器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;启用-configurationproperties-注解类型&quot;&gt;启用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解类型&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Boot 提供了一个基础设施来绑定这些类型并将它们自动注册为 bean。&lt;br/&gt;如果应用程序中使用 &lt;code&gt;@SpringBootsApplication&lt;/code&gt;，用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解的类将被自动扫描并注册为 bean。默认情况下，将从声明此注解的类的包中进行扫描。如果要扫描特定的包，可以对 ·&lt;code&gt;@SpringBootsApplication&lt;/code&gt; 注解的类显式使用 &lt;code&gt;@ConfigurationPropertiescan&lt;/code&gt; 注解，如下例所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@ConfigurationPropertiesScan({ &quot;com.example.app&quot;, &quot;org.acme.another&quot; })
public class MyApplication {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有时，用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注释的类可能不适合扫描，例如，如果正在开发自己的自动配置，在这些情况下，可以在任何@Configuration 类上指定要处理的类型列表，如下例所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration(proxyBeanMethods = false) @EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration { }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：当使用配置属性扫描或通过@EnableConfigurationProperties 注册@ConfigurationProperties bean 时，bean 有一个常规名称：&lt;code&gt;&amp;lt;prefix&amp;gt;-&amp;lt;fqn&amp;gt;&lt;/code&gt;，其中 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 是 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解中指定的环境 key 前缀，&lt;code&gt;&amp;lt;fqn&amp;gt;&lt;/code&gt; 是 bean 的完全限定名。如果注解没有提供任何前缀，则只使用 bean 的完全限定名。&lt;br/&gt;上例中 bean name 是 &lt;code&gt;acme-com.example.AcmeProperties&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用configurationproperties-注解类型&quot;&gt;使用&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解类型&lt;/h2&gt;
&lt;p&gt;这种类型的配置在 SpringApplication 外部 YAML 配置中特别适用，如下例所示：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;# application.yml

acme:
  remote-address: 192.168.1.1
  security:
    username: admin
    roles:
      - USER
      - ADMIN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean 可以像其它 bean 一样注入使用。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class MyService{
    private final AcmeProperties properties;
    
    @Autowired
    public MyService(AcmeProperties properties){
        this.properties = properties;
    }
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 还可以生成元数据文件，IDE 可以使用这些文件提供代码自动完成功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第三方配置&quot;&gt;第三方配置&lt;/h2&gt;
&lt;p&gt;除了可以在 &lt;code&gt;类&lt;/code&gt; 上使用 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解，还可以在 public @Bean &lt;code&gt;方法&lt;/code&gt;上使用它。如果要将属性绑定到不在控制范围内的第三方组件，那么这样做特别有用。&lt;/p&gt;
&lt;p&gt;要从 &lt;code&gt;Environment&lt;/code&gt; 属性配置 bean，将 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 添加到其 bean 注册中，如下例所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;another&quot;)
@Bean
public AnotherComponent anotherComponent() {
    //... 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用 &lt;code&gt;another&lt;/code&gt; 前缀定义的任何 JavaBean 属性都映射到 &lt;code&gt;AnotherComponent&lt;/code&gt; bean 上，映射方式类似于前面的 AcmeProperties 示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;松绑定&quot;&gt;松绑定&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Boot 使用一些宽松的规则将 &lt;code&gt;Environment&lt;/code&gt; 属性绑定到&lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean，因此环境属性名和 bean 属性名之间不需要完全匹配。常见的包括短划线分隔的环境属性（例如，&lt;code&gt;context-path&lt;/code&gt; 绑定到 &lt;code&gt;contextPath&lt;/code&gt;）和大写的环境属性（例如，&lt;code&gt;PORT&lt;/code&gt; 绑定到 &lt;code&gt;port&lt;/code&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix=&quot;acme.my-project.person&quot;)
public class OwnerProperties {
    private String firstName;
    public String getFirstName() {
        return this.firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于以上 Java Bean，可以使用以下属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201911/1775867-20191123230246779-1728570904.jpg&quot; alt=&quot;属性松绑定&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：注解的前缀值必须是短横线 (小写，用-分隔，如：acme.my-project.person)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;放宽每个属性源的绑定规则&quot;&gt;放宽每个属性源的绑定规则&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201911/1775867-20191123230247224-1517675906.jpg&quot; alt=&quot;放宽每个属性源的绑定规则&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;建议：如果可能的话，将属性存储为小写的短横线格式，例如：my.property-name=acme。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在绑定到 &lt;code&gt;Map&lt;/code&gt; 属性时，如果 &lt;code&gt;key&lt;/code&gt; 包含除小写字母-数字字符或 &lt;code&gt;-&lt;/code&gt; 之外的任何内容，则需要使用括号符号，以便保留原始值。如果 &lt;code&gt;key&lt;/code&gt; 没有被&lt;code&gt;[]&lt;/code&gt;包围，则删除任何不是字母数字或 &lt;code&gt;-&lt;/code&gt;的字符。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;acme:
  map:
    &quot;[/key1]&quot;: value1
    &quot;[/key2]&quot;: value2
    /key3: value3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的属性将绑定到 &lt;code&gt;Map&lt;/code&gt; 的这些 &lt;code&gt;key&lt;/code&gt; 中：&lt;code&gt;/key1&lt;/code&gt;、&lt;code&gt;/key2&lt;/code&gt;、&lt;code&gt;key3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;合并复杂类型&quot;&gt;合并复杂类型&lt;/h2&gt;
&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
&lt;p&gt;当在多个位置配置 list 时，通过&lt;strong&gt;替换&lt;/strong&gt;（而非添加）整个 list 来覆盖。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(&quot;acme&quot;)
public class AcmeProperties {
    private final List&amp;lt;MyPojo&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    public List&amp;lt;MyPojo&amp;gt; getList() { return this.list;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;acme:
  list:
    - name: my name
      description: my description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当启用 &lt;code&gt;dev&lt;/code&gt; 配置时，&lt;code&gt;AcmeProperties.list&lt;/code&gt; 中值包含一个 &lt;code&gt;MyPojo&lt;/code&gt; 对象（name 为&lt;code&gt;my another name&lt;/code&gt;），不是添加操作，而是覆盖操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当一个 &lt;code&gt;List&lt;/code&gt; 在多个 profiles 中定义时，最高优先级的被使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;map&quot;&gt;Map&lt;/h3&gt;
&lt;p&gt;对于 &lt;code&gt;Map&lt;/code&gt; 属性，&lt;strong&gt;可以&lt;/strong&gt;使用从多个属性源获取属性值进行绑定。但是，对于多个源中的同一属性，将使用优先级最高的属性。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(&quot;acme&quot;)
public class AcmeProperties {
    private final Map&amp;lt;String, MyPojo&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    public Map&amp;lt;String, MyPojo&amp;gt; getMap() {
    return this.map;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 dev 配置启用时，&lt;code&gt;AcmeProperties.map&lt;/code&gt; 中包含两个键值对。&lt;code&gt;key1&lt;/code&gt; 中 pojo name 为 dev name 1，description 为 my description 1；&lt;code&gt;key2&lt;/code&gt; 中 pojo name 为 dev name 2，description 为 dev description 2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同属性源的配置进行了合并&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上合并规则适用于所有的属性源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;属性转换&quot;&gt;属性转换&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Boot 试图在绑定到 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean 时将外部应用程序属性强转为正确的类型。如果需要自定义类型转换，可以提供 &lt;code&gt;ConversionService&lt;/code&gt; bean（带有名为 &lt;code&gt;ConversionService&lt;/code&gt; 的 bean）或自定义属性编辑器（通过 &lt;code&gt;CustomEditorConfigurer&lt;/code&gt; bean）或自定义 &lt;code&gt;Converters&lt;/code&gt; （使用 bean 定义注解 &lt;code&gt;@ConfigurationPropertiesBinding&lt;/code&gt; ）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：由于此 bean 在应用程序生命周期的早期被请求，请确保限制 &lt;code&gt;ConversionService&lt;/code&gt; 正在使用的依赖项。通常，需要的任何依赖项在创建时都可能未完全初始化。如果自定义的 &lt;code&gt;ConversionService&lt;/code&gt; 不需要配置 keys 强转，并且仅依赖于使用 &lt;code&gt;@ConfigurationPropertiesBinding&lt;/code&gt; 限定的自定义转换器，则可能需要将它重命名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;时间区间转换&quot;&gt;时间区间转换&lt;/h2&gt;
&lt;p&gt;SpringBoot 对表示持续时间有专门的支持。如果暴露 &lt;code&gt;java.time.Duration&lt;/code&gt; 属性，则可以用以下格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常规的 &lt;code&gt;long&lt;/code&gt; 表示（除非指定了 &lt;code&gt;@DurationUnit&lt;/code&gt;，否则使用毫秒作为默认单位）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.time.Duration&lt;/code&gt; 使用的标准 ISO-8601 格式&lt;/li&gt;
&lt;li&gt;一种更可读的格式，其中值和单位是耦合的（例如，10s 表示 10 秒）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(&quot;app.system&quot;)
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要指定 30 秒的 sessionTimeout，30、PT30S 和 30s 都是等效的。500ms 的 readTimeout 可以用以下任何形式指定：500、PT0.5S 和 500ms。&lt;br/&gt;也可以使用以下任何支持的单位：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ns&lt;/code&gt;：纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;us&lt;/code&gt;：微妙&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ms&lt;/code&gt;：毫秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;：秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;：分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt;：时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;：天&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认的单位是毫秒，可以使用 &lt;code&gt;@DurationUnit&lt;/code&gt; 指定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据-size-转换&quot;&gt;数据 size 转换&lt;/h2&gt;
&lt;p&gt;Spring 框架有一个 &lt;code&gt;DataSize&lt;/code&gt; 类型，以字节表示大小。如果暴露一个 &lt;code&gt;DataSize&lt;/code&gt; 属性，则可以用以下格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常规的 &lt;code&gt;long&lt;/code&gt; 表示（除非指定了 &lt;code&gt;@DataSizeUnit&lt;/code&gt;，否则使用字节作为默认单位）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.time.Duration&lt;/code&gt; 使用的标准 ISO-8601 格式&lt;/li&gt;
&lt;li&gt;一种更可读的格式，其中值和单位是耦合的（例如，&lt;code&gt;10MB&lt;/code&gt; 表示 10 兆字节）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(&quot;app.io&quot;)
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要指定 10 兆字节的 &lt;code&gt;bufferSize&lt;/code&gt;，&lt;code&gt;10&lt;/code&gt; 和 &lt;code&gt;10MB&lt;/code&gt; 是等效的。256 字节的 &lt;code&gt;sizeThreshold&lt;/code&gt; 可以指定为 &lt;code&gt;256&lt;/code&gt; 或 &lt;code&gt;256B&lt;/code&gt; 。&lt;br/&gt;也可以使用以下任何支持的单位：&lt;br/&gt;&lt;code&gt;B&lt;/code&gt;：字节&lt;br/&gt;&lt;code&gt;KB&lt;/code&gt;：千字节&lt;br/&gt;&lt;code&gt;MB&lt;/code&gt;：兆字节&lt;br/&gt;&lt;code&gt;GB&lt;/code&gt;：千兆字节&lt;br/&gt;&lt;code&gt;TB&lt;/code&gt;：兆兆字节&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认的单位是字节，可以使用 &lt;code&gt;@DataSizeUnit&lt;/code&gt; 指定&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每当对 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 类使用 Spring 的&lt;code&gt;@Validated&lt;/code&gt; 注解时，Spring Boot 就会验证它们。可以直接在配置类上使用 JSR-303 &lt;code&gt;javax.validation&lt;/code&gt; 约束注解。必须确保类路径上有一个兼容的 JSR-303 实现（如：hibernate-validator），然后将约束注解添加到字段中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix=&quot;acme&quot;)
@Validated
public class AcmeProperties {
    @NotNull
    private InetAddress remoteAddress;
    
    // ... getters and setters
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：还可以通过注解@Bean 方法来触发验证，该方法使用@Validated 创建配置属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;尽管嵌套属性在绑定时也将被验证，但最好对关联字段使用 &lt;code&gt;@Valid&lt;/code&gt;。这确保即使找不到嵌套属性，也会触发验证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix=&quot;acme&quot;)
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;还可以通过创建&lt;code&gt;ConfigurationPropertiesValidator&lt;/code&gt; bean 来添加自定义 Spring &lt;code&gt;Validator&lt;/code&gt;。&lt;code&gt;@Bean&lt;/code&gt; 方法应该声明为 &lt;code&gt;static&lt;/code&gt; 。配置属性验证器是在应用程序生命周期的早期创建的，将@Bean 方法声明为 static 可以创建 Bean，而无需实例化@configuration 类。这样做可以避免任何可能由早期实例化引起的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;spring-boot-actuator&lt;/code&gt; 模块包含一个端点，该端点暴露所有 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean。访问 &lt;code&gt;/actuator/configprops&lt;/code&gt; 可获得相关信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt; 注解是一个核心容器特性，它不提供与 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 相同的特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201911/1775867-20191123230247558-1924989614.jpg&quot; alt=&quot;@ConfigurationProperties vs. @Value&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果需要为组件定义了一组配置键，建议将它们配置到一个 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解的 POJO 中。由于 &lt;code&gt;@Value&lt;/code&gt; 不支持松绑定，如果需要使用环境变量提供值，则它不是一个好的选项。&lt;br/&gt;虽然可以在 &lt;code&gt;@Value&lt;/code&gt; 中编写 &lt;code&gt;SpEL&lt;/code&gt; 表达式，但此类表达式不会从 properties 文件中处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果项目比较大的话，分成了好几个 SpringBoot 工程，可以使用某些 SpringCloud 组件，比如：配置中心。配置中心支持一个地方管理所有的配置，有些还可以支持修改配置实时生效而不用重启应用，真的是很棒棒呢。推荐使用 &lt;code&gt;nacos&lt;/code&gt;。如果项目比较小，你用 &lt;code&gt;git&lt;/code&gt; 或者&lt;code&gt;指定文件夹&lt;/code&gt;来作为配置存放的地方也可以。&lt;/p&gt;
&lt;p&gt;怎么样？有了这些用法的支持，你还会觉得 Springboot 打成一个 &lt;code&gt;jar&lt;/code&gt; 会在部署的时候很不方便吗？&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.2.0.RELEASE/reference/htmlsingle/#boot-features-external-config&quot;&gt;官方文档&lt;/a&gt;&lt;br/&gt;公众号：逸飞兮（专注于 Java 领域知识的&lt;strong&gt;深入学习&lt;/strong&gt;，从源码到原理，系统有序的学习）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1775867/201911/1775867-20191123230247858-647712397.png&quot; alt=&quot;逸飞兮&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 15:03:00 +0000</pubDate>
<dc:creator>逸飞兮</dc:creator>
<og:description>前言 '《【源码解析】凭什么？spring boot 一个 jar 就能开发 web 项目》 ' 中有读者反应： 部署后运维很不方便，比较修改一个 IP 配置，需要重新打包。 这一点我是深有体会，17</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lw5946/p/11920709.html</dc:identifier>
</item>
<item>
<title>.Net Core读取Json配置文件 - 江北、</title>
<link>http://www.cnblogs.com/zhangnever/p/11909842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangnever/p/11909842.html</guid>
<description>&lt;p&gt;前言：在与传统的asp.net MVC项目相比,.net core项目在项目目录的文件结构上和功能上与前者都有很大的区别。例如：在.net core中使用Startup.cs取代Global.asax文件用于加载应用程序的配置和各种启动项。appsettings.json取代web.config文件用于存储应用程序所需的配置参数等等。。。&lt;/p&gt;
&lt;p&gt;OK！步入正题,下面来说一下如何读取Json配置文件中的参数。&lt;/p&gt;
&lt;p&gt;第一种:使用IConfiguration接口&lt;/p&gt;
&lt;p&gt;我们先在appsettings.json中配置好数据库连接字符串,然后读取它&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=.;Initial Catalog=test;User ID=sa;Password=123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Hosting.Lifetime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123103411665-1499950658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在控制器中注入IConfiguration接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Read.json.Controllers
{
    [ApiController]
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReadController(IConfiguration configuration)
        {
            _configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ReadJson()
        {&lt;br/&gt;//读参
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; conn = _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection:dbContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123104028575-1713834130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 当然也可以读取数组形式的json,一样的先在appsettings.json中写好配置参数，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=.;Initial Catalog=test;User ID=sa;Password=123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trade_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小熊饼干&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;旺仔QQ糖&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈牛奶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
  ],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------&lt;/span&gt;

  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Hosting.Lifetime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如我们想读取test1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;string&lt;/span&gt; commodity_test1 = _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content:0:Trade_name:test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 第二种：使用IOptions&amp;lt;T&amp;gt;来读取json配置文件&lt;/p&gt;
&lt;p&gt;先把NuGet包导进项目：Microsoft.Extensions.Options.ConfigurationExtensions&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123135953458-1064950233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先在appsettings.json中添加节点如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=.;Initial Catalog=test;User ID=sa;Password=123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trade_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小熊饼干&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;旺仔QQ糖&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;娃哈哈牛奶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
  ],
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------&lt;/span&gt;

  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Hosting.Lifetime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedHosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============================&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;I&lt;/span&gt;&lt;span&gt;ntroduce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实验小学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中班&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;R&lt;/span&gt;&lt;span&gt;egion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;湖北&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;City&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;武汉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Area&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;洪山区&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Detailed_address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;佳园路207号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
      ]
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==============================&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然和再建立一个与这个节点&quot;相同&quot;的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Read.json
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Information
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; School school { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; School
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Introduce Introduce { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Region Region { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Detailed_address&amp;gt; data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Introduce
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Class { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Number { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Region
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Province { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Area { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Detailed_address
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Startup中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;#region&lt;/span&gt; 服务注册,在控制器中通过注入的形式使用&lt;span&gt;
            services.AddOptions();
            services.Configure&lt;/span&gt;&amp;lt;Information&amp;gt;(Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123145003550-1063267979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 控制器中使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Read.json.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;

        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Information _Information;

        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt; IOptions&amp;lt;Information&amp;gt;&lt;span&gt; _options;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReadController(IConfiguration configuration,
                              Information Information,
                              IOptions&lt;/span&gt;&amp;lt;Information&amp;gt;&lt;span&gt; options)
        {
            _configuration &lt;/span&gt;=&lt;span&gt; configuration;
            _Information &lt;/span&gt;=&lt;span&gt; Information;
            _options &lt;/span&gt;=&lt;span&gt; options;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; ReadInformation()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Address = _options.Value.school.Region.Province + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Region.City &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Region.Area &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Detailed_address[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].Address + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Introduce.Name &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Introduce.Class &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                             _options.Value.school.Introduce.Number;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(Address);
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; ReadJson()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; conn = _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection:dbContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; commodity = _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content:0:Trade_name:test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123150449434-1518732223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123150626334-2131981360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;第三种：这种应该比较常见,任意读取自定义的json文件&lt;/p&gt;
&lt;p&gt;首先建立一个json文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system_version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Edition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Net Core 3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project_Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Read.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123154444451-1602701635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 再建一个类,封装一个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Read.json
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Json_File
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IConfigurationRoot Read_Json_File()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这句代码会读取read_json.json中的内容&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConfigurationBuilder().AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read_json.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                             .Build();

        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123154556324-2133132027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在控制器中调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; ReadSystemVersion()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration =&lt;span&gt; _json_File.Read_Json_File();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; system = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用的是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system_version:Edition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的版本&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;项目名称是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system_version:Project_Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                data &lt;/span&gt;=&lt;span&gt; system
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123154755785-786191351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123155117479-1704404882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Demo地址：Func&amp;lt;Address,Project&amp;gt; func = (address) =&amp;gt; &lt;span&gt;git clone &lt;/span&gt;address&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; project = func(&quot;https://github.com/Davenever/Read_Json.git&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1677460/201911/1677460-20191123180016218-484611681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 23 Nov 2019 14:05:00 +0000</pubDate>
<dc:creator>江北、</dc:creator>
<og:description>前言：在与传统的asp.net MVC项目相比,.net core项目在项目目录的文件结构上和功能上与前者都有很大的区别。例如：在.net core中使用Startup.cs取代Global.asax</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangnever/p/11909842.html</dc:identifier>
</item>
<item>
<title>人脸识别技术原理与工程实践（10个月人脸识别领域实战总结） - dskit</title>
<link>http://www.cnblogs.com/dskit/p/11920405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dskit/p/11920405.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1人脸识别应用场景（验证）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215515679-1894360207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们先来看看人脸识别的几个应用。第一个是苹果的FACE ID，自从苹果推出FaceID后，业界对人脸识别的应用好像信心大增，各种人脸识别的应用从此开始“野蛮生长”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;事实上，&lt;strong&gt;人脸识别技术在很多场景的应用确实可以提升认证效率，同时提升用户体验。&lt;/strong&gt;前两年，很多机场安检都开始用上了人脸验证；今年4月，很多一、二线城市的火车站也开通了“刷脸进站”的功能；北京的一些酒店开始使用人脸识别技术来做身份验证。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 人脸识别应用场景（识别）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们再来看看几个场景。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215548383-337436586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一个是刷脸的自动售货机。当我第一次看到这个机器的时候就有个疑问：”现在人脸识别算法已经做到万无一失了吗，认错人，扣错钱怎么办？”，后来才发现，其实关键不在于算法，产品设计才是最重要的。用过这个售货机的人可能知道，第一次使用的时候，要求输入手机号的后四位，这个看似简单的产品设计，可以让自动售货机的误识别率降低到亿分之一，这样底概率的条件下，误识别带来的损失完全可以忽略。同时这款自动售货机还会提醒你，你的消费行为会绑定“芝麻信用”，想想有多少人会为了一瓶“可乐”去影响自己的征信记录呢？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二个是刷脸买咖啡，进入咖啡店后，在你选好和什么咖啡前，系统已经识别出站在点单台前的用户是谁，并做好点单准备；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三个是在人脸门禁系统。小伙伴们再已不用担心忘记带工卡了。人脸门禁对识别速度和准确度的要求是相对较高的，设备挂在门的侧面墙也会影响体验，增加产品设计和开发的难度。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 “人脸验证”还是“人脸识别”？&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;其实，前面两页的场景是有些区别的，不知道大家看出来了没有。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215614450-1202486677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一个的场景，用户实际提供了两个信息，一是用户的证件信息，比如身份证号码，或APP账号；另一个信息是用户的现场照片；这类场景的目标实际上是：&lt;strong&gt;让人脸识别系统验证现场照片是否是证件所宣称的那个人&lt;/strong&gt;。我们把这类场景&lt;strong&gt;叫着“人脸验证”&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二个的场景，用户实际只提供的现场照片，&lt;strong&gt;需要人脸识别系统判断照片上的人是谁&lt;/strong&gt;。我们把这类场景&lt;strong&gt;叫着“人脸识别”&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;“人脸验证”拿现场人脸跟用户所宣称的人脸做1比1的比较，而“人脸识别”是拿现场人脸跟后台注册人脸库中的所有人脸比较，是1比N的搜索&lt;/strong&gt;。可以看出，两种场景的技术原理一致，但是难度不同,第二页场景的难度普遍比第一页高得多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 人脸识别原理&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;计算机是怎么识别人脸的呢？如果我们大家是人脸识别系统的设计者，我们应用怎样来设计这个系统？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;“把人脸区域从图片中抠出来，然后拿抠出来的人脸跟事先注册的人脸进行比较”，没错，就是这样，说起来简单，做又是另外一回事了，这里又有两个新的问题：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一是，“怎样判断图片中是有没有人脸？”，“怎样知道人脸在图片中的具体位置呢”，这是人脸检测要解决的问题，人脸检测告诉我们图像中是否有人脸以及人脸的具体位置坐标。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二是，“我们怎样比较两个人脸是不是同一个人呢？”，一个像素一个像素比较吗？光照，表情不一致，人脸偏转都将导致该方法不可行。”人是怎样判断两种照片中的人脸是不是同一个人的呢？”，我们是不是通过比较两种照片上的人，是不是高鼻梁、大眼睛、瓜子脸这样的面部特征来做判断的呢？ &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215632928-1477029383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们来看一下计算机人脸识别的流程，首先是获取输入图像，然后检测图像中是否有人脸，人脸的具体位置，然后判断图像的质量，比如图像是否模糊，光照度是否足够，然后检测人脸偏转的角度，旋转人脸到一个正脸位置，再然后提取人脸特征，比对人脸特征，最后输出识别结果。其中图像质量检测和人脸对齐这两步是可选的步骤，根据具体应用场景来决定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 人脸检测-经典方法&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们来看看经典的人脸检测方法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215654480-1465411731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;OpenCV和Dlib是两个常用的算法库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;OpenCV 中使用Haar Cascade来做人脸检测，其实Haar Cascade可以检测任何对象，比如人脸和脸上眼睛的位置。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;DLIB中是使用方向梯度直方图（Histogram of Oriented Gradient, HOG），即通过计算图像局部区域的梯度方向直方图来提取特征，这种方法的本质在于梯度的统计信息，而梯度主要存在于边缘的地方。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;OpenCV和DLIB各自也有他们自己的基于深度学习的人脸检测方法，使用起来非常简单。从这几种方法都可以做到CPU实时或GPU实时；&lt;strong&gt;经典的检测方法对正脸的检测效果比较好，深度学习的方法适应性更强，可以检测各种角度的人脸&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 MTCNN人脸检测&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2016年提出来的MTCNN算法是目前公认比较好的人脸检测算法是（Multi-task Cascaded Convolutional Networks），可以同时实现face detection和alignment，也就是人脸检测和对齐。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里的对齐指的是检测人脸眼睛、鼻子、嘴巴轮廓关键点LandMark。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215710294-1390034397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;MTCNN算法主要包含三个子网络：&lt;strong&gt;P-Net （Proposal Network）、 R-Net(Refine Network)、O-Net(Output Network)，这3个网络按照由粗到细的方式处理输入照片，每个网络有3条支路用来分别做人脸分类、人脸框的回归和人脸关键点定位&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;左上角，&lt;strong&gt;最开始对在多个尺度上对图像做了resize，构成了图像金字塔，然后这些不同尺度的图像作为P、P、O网络的输入进行训练，目的是为了可以检测不同尺度的人脸&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;P-Net主要用来生成候选人脸框。 R-Net主要用来去除大量的非人脸框。O-Net和R-Net有点像，在R-NET基础上增加了landmark位置的回归，最终输出包含一个或多个人脸框的位置信息和关键点信息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7 人脸特征提取-经典方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们来看一下人脸特征提取。经典的人脸特征提取方法有EigenFace和FisherFace两种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215735415-658215758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;EigenFace的思想是把人脸从像素空间变换到另一个空间，在另一个空间中做相似性的计算。EigenFace的空间变换方法是主成分分析PCA。这个方法90年代开始应用于人脸识别，因为主成分有人脸的形状，所以也称为“特征脸”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;FisherFace是一种基于线性判别分析LDA(全称Linear  Discriminant Analysis,)的人脸特征提取算法， LDA和PCA都是利用特征值排序找到主元的过程。LDA强调的是不同人脸的差异而不是照明条件、人脸表情和方向的变化。所以，Fisherface对人脸光照、人脸姿态变化的影响更不敏感。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8 人脸特征提取-深度学习法&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们再来看看深度学习法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215752647-378408804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;利用神经网络学习高度抽象的人脸特征，然后将特征表示为特征向量，通过比较特征向量之间的欧式距离来判定两张照片是否是同一个人&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9人脸特征提取-深度学习法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215808448-1267277718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;总体思路是把人脸识别人物当分类任务来训练，&lt;strong&gt;通过在损失函数上施加约束，让相同的人的照片提取的特征距离尽可能近，不是同一个人的照片的提取的特征距离尽可能的远&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一个Logit的地方输出的是人脸的特征向量，一般是128维或者512维，浮点向量。这个Logit前面是CNN分类网络，这个Logit后面的部分是通过在损失函数上施加约束来训练模型，让模型区分相同的人和不同的人，后面的部分只需要在训练阶段计算，推理阶段是不需要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10 人脸特征提取-Metric Learning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于深度学习的人脸特征提取方法主要有两类，一类Metric Learning，另一个是Additive Margin，这两类方法的底层原理都是一样的，就是“&lt;strong&gt;通过训练网络，让相同人的特征距离尽可能近，不同人的特征距离尽可能的远&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215824404-1242980278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;孪生网络和Triplet都属于 Metric Learning这类方法。左边孪生网络顾名思义，就是有两个网络，一个网络训练让相同的人之间的距离尽可能的近，另一个网络让不同人之间的距离尽可能远。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;右边Triplet网络是对孪生网络的改进，将样本组织为锚点、正样本、负样本的元组，通过训练网络让锚点与正样本之间的距离尽可能的近，锚点与负样本之间的距离尽可能的远，并且至少远于一个阀值阿尔法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11 人脸特征提取-Additive Margin&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Additive Margin这类方法主要是在分类模型的基础，通过控制损失函数来达到“让相同人的特征距离尽可能近，让不同人的特征距离尽可能远”的目标。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;前面介绍的&lt;strong&gt;Metric Learning的方法最大的问题在于：需要重新组织样本，模型最终能否收敛很大程度上取决于采样是不是合理&lt;/strong&gt;。基于Additive Margin的方法则不需要这一步，完全将人脸特征提取当做分类任务来训练，参数的设置也不需要太多trick，Additive Margin的方法大都是在损失函数上做文章。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215841704-314649006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最近几年，这个类方法研究的比较多，上面这个图中的softmax，Sphereface，Cosface，ArcFace都是Additive Margin方法，&lt;strong&gt;可以看出它都是通过改进损失函数，来实现“让相同人的特征距离尽可能近，让不同人的特征距离尽可能远”这个目标&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面这个图中，颜色相同的点表示一个人，不同的点表示不同的人，这个图的展示比较形象，可以看出&lt;strong&gt;最后一个超球体的效果非常不错&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Additive Margin正在成为主流， InsightFace也属于这一类，损失函数正是这个ArcFace。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;大家可用思考一下，为什么分类方法不能直接用于人脸识别？这里不做详细讨论了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12 人脸特征提取-效果评估&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们再来看一下怎样评估人脸特征提取算法的效果。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215857983-298838064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;主要是通过召回率和虚警率两个指标来衡量。应用场景不同，这个两个指标的设置也不同，一般情况下，&lt;strong&gt;在实践中我们都要求在虚警率小于某个值（比如万分之一）的条件下，召回率达到某个值（比如99%）&lt;/strong&gt;。很多产品宣称的识别准确率达到多少多少，很大可能是在公开数据集比如LFW上的测试结果。&lt;/p&gt;
&lt;p&gt;公开的训练数据集比较推荐的有：&lt;strong&gt;MS1MV2，这个数据集微软前段事件已经宣布撤回不再提供下载，这个数据集大概有85000个不同的人的380万张照片&lt;/strong&gt;。另一个数据集是GLINT_ASIA，有9万多人的280万张照片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13 工程实践的挑战及经验分享&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;很多人都认为人脸识别应用，算法包打天下，事实并非如此，即使是最好的识别算法也扛不住像图像质量差。图像质量差、姿势变化、面部形状/纹理随着时间推移的变化、遮挡这些问题，是我们在工程实践中面临的挑战。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当然，大多数问题工程上我们有应对方法。比如图像模糊，光照不足，我们可以先检测图像是否模糊，关照是否不足，质量不过关，就不把图像送给识别算法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;再比如，用他人照片或视频来欺骗人脸识别系统，目前已经有多种活体检测方法来检测并防止这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/78343/201911/78343-20191123215914804-1602659887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;经过一段时间在人脸识别领域的摸爬滚打，个人认为&lt;strong&gt;影响用户体验的关键因素是识别快、识别准，识别快主要靠产品设计，识别准主要靠算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;拿人脸门禁来举个例子，产品设计上可以在前端采集照片的时候过滤掉模糊、无人脸的照片，避免无效识别，同时前端在采集照片的时候，可以同时采集多张并发传给后台，做并发识别，这些方法都可以大大提升识别通过的速度，提升用户体验。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 14:00:00 +0000</pubDate>
<dc:creator>dskit</dc:creator>
<og:description>10个月人脸识别领域的实战总结，上干货！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dskit/p/11920405.html</dc:identifier>
</item>
<item>
<title>SpringBoot系列之切换log4j日志框架 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/11920395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/11920395.html</guid>
<description>&lt;p&gt;SpringBoot系列之使用切换log4j日志框架&lt;/p&gt;
&lt;p&gt;ok，在pom文件右键-&amp;gt;Diagrams-&amp;gt;show Dependencies....，如图，找到spring-boot-starter-logging，可以看到SpringBoot的日志实现默认依赖与logback，ok，如果你对这些知识不是很理解的，建议先看我Springboot专栏的日志系列博客：&lt;a href=&quot;https://smilenicky.blog.csdn.net/category_9195353.html&quot; class=&quot;uri&quot;&gt;https://smilenicky.blog.csdn.net/category_9195353.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本博客要实现的是切换默认日志框架为log4j，当然是不建议这样做的，因为log4j有性能问题，所以其作者才开发了logback，不过作为学习的话，还是可以学一下怎么切换Springboot默认的日志框架&lt;/p&gt;
&lt;p&gt;先去&lt;a href=&quot;http://www.slf4j.org/legacy.html&quot;&gt;slf4j官网&lt;/a&gt;拿一张图：图示，切换日志框架，为了避免冲突，一般都是先排除日志框架的实现jar，然后再将之前博客提到的偷梁换柱jar，比如log4j-to-slf4j.jar等等先排除，然后再引入对应的日志实现jar，如图所示的slf4j-log4j12.jar，因为本博客并非入门教程，所以学习之前请先参考我之前Springboot日志方面的博客，再来学习&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019111720052660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;ok，基于slf4j官方提供的知识，我们就可以实践了，首先选中logback-classic.jar(logback实现jar)、log4j-to-slf4j.jar(将log4j API强制切换回slf4j的偷梁换柱jar)，然后右键，选择exclusion&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191117195757502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，再次打开pom文件，可以看到idea自动帮我们exclusion一些jar了&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
                &amp;lt;exclusion&amp;gt;
                        &amp;lt;artifactId&amp;gt;log4j-to-slf4j&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，避免日志冲突，exclusion了logback的实现jar和偷梁换柱的log4j-to-slf4j之后，我们还需要引入log4j的实现jar&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，这是slf4j官网的说法，但是我发现在一些旧的版本SpringBoot是有提供spring-boot-starter-log4j这个场景启动器的，所以我们可以更简便的做log4j引入&lt;/p&gt;
&lt;p&gt;直接exclusion spring-boot-starter-logging：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后直接引入log4j的场景启动器，建议加上版本，因为有些版本并没有提供log4j配置，本博客是换回1.5.7才支持的，2.2.1的版本仲裁都没提供对应版本的&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.8.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，然后在resources直接丢log4j.properties&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;# LOG4J rootCategory config
log4j.rootCategory=INFO, stdout, file
# LOG4J console config
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %5p %c{1}:%L - %m%n

# root日志输出
log4j.appender.file=org.apache.log4j.DailyRollingFileAppender
log4j.appender.file.file=logs/springboot.log
log4j.appender.file.DatePattern='.'yyyy-MM-dd
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %5p %c{1}:%L - %m%n

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动SpringBoot日志：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191118140411556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 13:59:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>SpringBoot系列之使用切换log4j日志框架 ok，在pom文件右键 Diagrams show Dependencies....，如图，找到spring boot starter loggi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mzq123/p/11920395.html</dc:identifier>
</item>
<item>
<title>算法导论 - 云山之巅</title>
<link>http://www.cnblogs.com/yszd/p/11919791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yszd/p/11919791.html</guid>
<description>&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1343081/201911/1343081-20191123212319277-502432066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一.算法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　非形式地说，算法【algorithm】就是任何定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。&lt;/p&gt;
&lt;p&gt;　　我们也可以把算法看成是用于求解计算问题的工具。一般来说，问题陈述说明了期望的输入/输出关系。算法则描述一个特定的计算过程来实现该输入/输出关系。例如，我们可能需要把一个数列进行升序排序。实际上，这个问题经常出现，并且为引入许多标准的设计技术和分析工具提供了足够的理由。&lt;/p&gt;
&lt;p&gt;　　输入：n个数的一个序列(a&lt;sub&gt;&lt;span&gt;1&lt;/span&gt;&lt;/sub&gt;,a2,...,an)&lt;/p&gt;
&lt;p&gt;　　输出：输入序列的一个排序(a`&lt;sub&gt;1&lt;/sub&gt;,a`2,...,a`n)&lt;/p&gt;
&lt;p&gt;　　例如，给定输入序列(6,3,1,2,8,5)，排序算法将返回序列(1,2,3,5,6,8)作为输出。这样的输入序列称为排序问题的一个实例。一般来说，问题实例由计算该问题解所必需的【满足问题陈述中的各种约束】输入组成。&lt;/p&gt;
&lt;p&gt;　　因为许多程序使用排序作为中间步骤，所以排序是计算机科学中的一个基本操作。因此，已有许多好的排序算法供我们任意使用。对于给定应用，哪个算法最好依赖于一下因素：将要被排序的项数、这些项已被稍微排序的程度、关于项值的可能限制、计算机的体系结构、以及使用的存储设备的种类【内存、磁盘或磁带】。&lt;/p&gt;
&lt;p&gt;　　若对每个输入实例算法都以正确的输出结束，则称该算法是正确的，并称正确的算法解决了给定的计算问题。不正确的算法对某些输入实例可能根本不停止，也可能以不正确的方式结束。与人们期望的相反，不正确的算法只要其错误率是可控的，有时还是有用的。例如：在研究大素数算法时，将会是一个具有可控错误率的算法。&lt;/p&gt;
&lt;p&gt;　　算法可以用英文说明，也可以说明成计算机程序，甚至说明成硬件设计。唯一的要求是这个说明必须准确描述所要遵循的计算过程。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二.算法解决那些问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　排序绝不是已开发算法的唯一计算问题，实际上，算法的实际应用是无处不在的，例如：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1343081/201911/1343081-20191123212557891-378024717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.人类基因工程&lt;/p&gt;
&lt;p&gt;　　　　识别人类DNA中所有10万个基因，确定构成人类DNA的30亿个化学基对的序列。&lt;/p&gt;
&lt;p&gt;　　2.互联网搜索&lt;/p&gt;
&lt;p&gt;　　　　互联网使得全世界的人都能快速地访问与检索大量信息。借助于一些聪明的算法，互联网上的网站能够管理和处理这些海量数据。&lt;/p&gt;
&lt;p&gt;　　3.电子商务&lt;/p&gt;
&lt;p&gt;　　　　电子商务使得货物能够以电子方式洽谈与交换，并且依赖于信用卡号、密码和银行结单这类个人信息的保密性。&lt;/p&gt;
&lt;p&gt;　　4.制造业、广告推送等等&lt;/p&gt;
&lt;p&gt;　　5.A/B两点的最短路径&lt;/p&gt;
&lt;p&gt;　　6.最长公共子序列&lt;/p&gt;
&lt;p&gt;　　7.工厂流水线设计等等&lt;/p&gt;
&lt;p&gt;　　虽然这些问题的列表还未穷尽，但是它们却展示了许多有趣的算法问题所共有的两个特征：&lt;/p&gt;
&lt;p&gt;　　　　1.存在许多候选解，但绝大多数候选解都没有解决手头上的问题。寻找一个真正的解或一个最好的解可能是一个很大的挑战。&lt;/p&gt;
&lt;p&gt;　　　　2.存在实际应用。例如，最短路径问题就是一个很常见的例子。地图导航、货物运输、网络路由等等&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三.数据结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　数据结构是一种存储和组织数据的方式，旨在便于访问和修改。没有一种单一的数据结构对所有用途都有效，所有重要的是知道不同数据结构的优点和局限。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;四.技术&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1343081/201911/1343081-20191123212755133-1671890066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然你可能掌握了很多的算法，但是也许某一天你会遇到这样一个问题，你一时无法找到一个你所知晓或搜索到的算法来解决它。那么你需要知道如何自己设计与分析一个算法，并且可以去证明及测试它的效率。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五.并行性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　我们或许可以指望处理器时钟速度能以某个持续的比率增加多年。然而物理的限制对不断提高的时钟速度给出了一个限制：因为功率密度随着时钟速度超线性增长，一旦时钟速度变的足够快，芯片就有融化的危险。因此，为了每秒执行更多的计算，芯片被设计成包含不止一个核心，不同核心之间可以并行执行。因此，为了算法从多核计算机中获得最佳性能，设计算法时必须考虑并行性。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;六.算法无处不在&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1343081/201911/1343081-20191123212919720-1737305374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们应该像计算机硬件一样把算法看成一种技术。整个系统的性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法。可能你会想，我只是开发一个简单的WEB程序，只有html和css，那么抱歉，其中还是设计了不少算法，其中，图形界面的渲染依赖了算法，WEB程序依赖互联网，网络中的路由高度依赖路由算法。程序需要中有需要编译的代码没？编译器也广泛使用算法。因此，算法时当前计算机中使用的大多数计算的核心。&lt;/p&gt;
&lt;p&gt;　　进一步说，随着计算机能力的不断增强，我们使用计算机来解决比之前更大的问题，因此，在面对海量的数据时，算法的优劣就显得尤为重要。&lt;/p&gt;
&lt;p&gt;　　是否具有算法知识与技术的坚实基础是区分真正熟练的程序员与初学者的一个特征。使用现代计算技术，如果你对算法懂得不多，你也可以完成一些任务，但是，如果有一个好的算法背景，那么你可以做的事情就会多得多。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 13:31:00 +0000</pubDate>
<dc:creator>云山之巅</dc:creator>
<og:description>一.算法 非形式地说，算法【algorithm】就是任何定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。 我们也可以把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yszd/p/11919791.html</dc:identifier>
</item>
<item>
<title>PL真有意思（二）：程序设计语言语法 - dejavudwh</title>
<link>http://www.cnblogs.com/secoding/p/11919712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secoding/p/11919712.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;虽然标题是程序语言的语法，但是讲的是对词法和语法的解析，其实关于这个前面那个写编译器系列的描述会更清楚，有关语言语法的部分应该是穿插在整个设计当中的，也看语言设计者的心情了&lt;/p&gt;
&lt;p&gt;和英语汉语这些自然语言不一样，计算机语言必须是精确的，它们的语法和语义都必须保证没有歧义，这当然也让语法分析更加简单&lt;/p&gt;
&lt;p&gt;所以对于编译器一项很重要的任务就是时别程序设计语言的结构规则，要完成这个目标就需要两个要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;完成对语法规则的描述&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定给定程序是否按照这些规则构造起来，也就是符合语法规则&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个要求主要由正则表达式和上下文无关文法来描述完成，而第二个要求就是由编译器来完成，也就是语法分析了&lt;/p&gt;
&lt;h2 id=&quot;描述语法正则表达式和上下文无关语法&quot;&gt;描述语法：正则表达式和上下文无关语法&lt;/h2&gt;
&lt;p&gt;对于词法，都可以用三种规则描述出来：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拼接&lt;/li&gt;
&lt;li&gt;选择&lt;/li&gt;
&lt;li&gt;Kleene（也就是重复任意多次）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如一个整数常量就可以是多个数字重复任意多次，也叫做正则语言。如果对于一个字符串，我们再加入递归定义即可以描述整个语法，就可以称作上下文无关语法&lt;/p&gt;
&lt;h3 id=&quot;单词正则表达式&quot;&gt;单词正则表达式&lt;/h3&gt;
&lt;p&gt;对于程序语言，单词的类型不外乎关键字、标识符、符合和各种类型的常量&lt;/p&gt;
&lt;p&gt;对于整数常量就可以用这样的正则表达式来表示&lt;/p&gt;
&lt;p&gt;&lt;code&gt;integer -&amp;gt; digit digit* digit -&amp;gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;上下文无关文法&quot;&gt;上下文无关文法&lt;/h2&gt;
&lt;p&gt;一般正则表达式只适用于描述单词，因为正则表达式无法描述嵌套结构，一般正则表达式的实现都是用有限状态自动机，之前用Python实现了一个简单的&lt;a href=&quot;https://github.com/dejavudwh/Regex&quot;&gt;正则表达式引擎&lt;/a&gt;也是这样，但是对于匹配任意深度的嵌套结构就需要有一个任意大的状态机，显然不符合。而定义嵌套结构对于描述语法非常有用，所以就有了上下文无关文法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expr := id | number | - expr | ( expr ) | expr or expr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;op := + | - | * | /&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于上下文无关文法，每条规则叫做一个产生式，产生式左部的符合称为非终结符，而右部则是多个终结符或者非终结符，最后所有规则都会推到至终结符上，而终结符就是正则表达式定义的单词&lt;/p&gt;
&lt;h2 id=&quot;推导和语法树&quot;&gt;推导和语法树&lt;/h2&gt;
&lt;p&gt;一个正确的上下文无关文法，就可以指导我们如何生成一个合乎语法的终结符串&lt;/p&gt;
&lt;p&gt;最简单的就是从开始符号开始，用这个产生式的右部取代开始符合，再从得到的串选择一个非终结符继续进行推导，直到没有剩下的非终结符，这个过程就像递归构造一个树的过程&lt;/p&gt;
&lt;pre class=&quot;bnf&quot;&gt;
&lt;code&gt;expr := expr op expr
     := expr op id
     := expr + id
     := expr op expr + id
     := expr op id + id
     := expr * id + id
     := id * id + id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是对于给定的上下文语法有可能会推导出不止一颗语法分析树，我们就说这个上下文语法是存在歧义性的。所以对于上面的上下文无关语法还有更好的文法&lt;/p&gt;
&lt;h2 id=&quot;扫描&quot;&gt;扫描&lt;/h2&gt;
&lt;p&gt;扫描也就是词法分析，词法分析完全可以不需要什么正则表达式、自动机什么的，徒手撸出来，现在业界为了更好的生成错误信息，应该很多也是手工的词法分析器&lt;/p&gt;
&lt;p&gt;手工的词法分析器，无非就是一直读入字符，到能判断出它的token在送入语法分析器&lt;/p&gt;
&lt;h3 id=&quot;有限状态自动机&quot;&gt;有限状态自动机&lt;/h3&gt;
&lt;p&gt;使用有限状态机的词法分析一般都是这样的几个步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;给出词法的正则表达式&quot;&gt;给出词法的正则表达式&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&quot;将正则表达式转换为非确定有限自动机nfa&quot;&gt;将正则表达式转换为非确定有限自动机（NFA）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实对于任意的正则表达式都可以用拼接、选择和Kleene闭包来表示&lt;/p&gt;
&lt;p&gt;而同样的，有限自动机也可以通过这三种方式来表示，图就不画了，这个在之前写Python正则表达式引擎的文章里都画过了（溜了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;将nfa转换为确定性有限状态自动机dfa&quot;&gt;将NFA转换为确定性有限状态自动机（DFA）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将NFA转换到DFA可以采用的是子集构造法，主要思想就是，在读入给定输入之后所到达的DFA状态，表示的是原来NFA读入同样输入之后可能澳大的所有状态&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;最小化dfa&quot;&gt;最小化DFA&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于最小化DFA的主要思想是，我们把DFA所有状态分为两个等价类，终止态状态和非终止状态。然后我们就反复搜索等价类X和输入符合c，使得当给定C作为输入时，X的状态能转换到位于k&amp;gt;1个不同等价类中的状态。之后我们就把X划分为k个类，使得类中所有转台对于C都会转移到同一个老类的成员。直到无法再按这种方式找到划分的类时，我们就完成了&lt;/p&gt;
&lt;p&gt;这四个步骤在之前的写的正则表达式引擎中都完成了，在那三篇文章里会更详细一点&lt;/p&gt;
&lt;h2 id=&quot;语法分析&quot;&gt;语法分析&lt;/h2&gt;
&lt;p&gt;一般语法分析器的输入是token流，而输出是一颗语法分析树。其中分析方法一般可以分为自上而下和自下而上两类，这些类中最重要的两个分别称为LL和LR&lt;/p&gt;
&lt;p&gt;LL表示从左向右，最左推导，LR表示从左向右，最右推导。这两类文法都是从左到右的顺序读取输入，然后语法分析器试图找出输入的推导结果&lt;/p&gt;
&lt;h3 id=&quot;自上而下的方式&quot;&gt;自上而下的方式&lt;/h3&gt;
&lt;p&gt;一般自上而下的语法分析器比较符合之前的推导方法，从根节点开始像叶节点反复的递归推导，直到当前的叶节点都是终结符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;递归下降&quot;&gt;递归下降&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;递归下降很符合上面说的从根节点出发进行推导，一般用于一些相对简单一些的语言&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;read A
read B
sum := A + B
write sum
write sum / 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如对于这个程序的递归下降，语法分析器一开始调用program函数，在读入第一个单词read后，program将调用stmt_list，再接着调用stmt才真正开始匹配read A。以这种方式继续下去，语法分析器执行路径将追溯出语法分析树的从左向右、自上而下的遍历&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;表格驱动的ll自上而下&quot;&gt;表格驱动的LL自上而下&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表格驱动的LL是基于一个语法分析表格和一个栈&lt;/p&gt;
&lt;p&gt;分析流程是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化一个栈&lt;/li&gt;
&lt;li&gt;将开始符号压入栈&lt;/li&gt;
&lt;li&gt;弹出栈顶，然后根据栈顶的符号和当前的输入符号查表&lt;/li&gt;
&lt;li&gt;如果弹出的是非终结符，将会继续查表来确定下一个压入栈中的产生式&lt;/li&gt;
&lt;li&gt;如果是终结符将进行匹配&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;预测集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看出来最重要的就是那个语法分析表格了，语法分析表格其实就是根据当前输入字符对下一个产生式的预测，这里就要用到一个概念：预测集合，也就是First和Follow集合。这个在之前写编译器系列讲的比较详细，在这里就不写了&lt;/p&gt;
&lt;p&gt;当然LL语法也会有很多处理不了的文法，所以也才会有其它的语法分析方法&lt;/p&gt;
&lt;h3 id=&quot;自下而上的方式&quot;&gt;自下而上的方式&lt;/h3&gt;
&lt;p&gt;在实践中，自下而上的语法分析都是表格驱动的，这种分析器在一个栈中保存所有部分完成的子树的根。当它从扫描器中得到一个新的单词时，就会将这个单词移入栈。当它发现位于栈顶的若干符号组成一个右部时，它就会将这些符号归约到对应的左部。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个自底向上的语法分析过程对应为一个输入串构造语法分析书的过程，它从叶子节点开始，通过shift和reduce操作逐渐向上到达根节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自底向上的语法分析需要一个堆栈来存放解析的符号，例如对于如下语法：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;0.  statement -&amp;gt; expr
1.  expr -&amp;gt; expr + factor
2.           | factor
3.  factor -&amp;gt;  ( expr )
4.           | NUM&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来解析1+2&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;1 + 2&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NUM&lt;/td&gt;
&lt;td&gt;+ 2&lt;/td&gt;
&lt;td&gt;开始读入一个字符，并把对应的token放入解析堆栈，称为shift操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;factor&lt;/td&gt;
&lt;td&gt;+ 2&lt;/td&gt;
&lt;td&gt;根据语法推导式，factor -&amp;gt; NUM,将NUM出栈，factor入栈，这个操作称为reduce&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;expr&lt;/td&gt;
&lt;td&gt;+ 2&lt;/td&gt;
&lt;td&gt;这里继续做reduce操作，但是由于语法推导式有两个产生式，所以需要向前看一个符合才能判断是进行shift还是reduce，也就是语法解析的LA&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;expr +&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;shift操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;expr + NUM&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;shift操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;expr + factor&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;根据fator的产生式进行reduce&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;expr&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;reduce操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;statement&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;reduce操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;此时规约到开始符号，并且输入串也为空，代表语法解析成功&lt;/p&gt;
&lt;h4 id=&quot;有限状态自动机的构建&quot;&gt;有限状态自动机的构建&lt;/h4&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;0.  s -&amp;gt; e
1.  e -&amp;gt; e + t
2.  e -&amp;gt; t
3.  t -&amp;gt; t * f
4.  t -&amp;gt; f
5.  f -&amp;gt; ( e )
6.  f -&amp;gt; NUM&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对起始推导式做闭包操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先在起始产生式-&amp;gt;右边加上一个.&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;s -&amp;gt; .e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对.右边的符号做闭包操作，也就是说如果 . 右边的符号是一个非终结符，那么肯定有某个表达式，-&amp;gt;左边是该非终结符，把这些表达式添加进来&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;s -&amp;gt; . e
e -&amp;gt; . e + t
e -&amp;gt; . t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对新添加进来的推导式反复重复这个操作，直到所有推导式-&amp;gt;右边是非终结符的那个所在推导式都引入&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对引入的产生式进行分区&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;把 . 右边拥有相同非终结符的表达式划入一个分区，比如&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;e -&amp;gt; t .
t -&amp;gt; t . * f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就作为同一个分区。最后把每个分区中的表达式中的 . 右移动一位，形成新的状态节点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对所有分区节点构建跳转关系&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据每个节点 . 左边的符号来判断输入什么字符来跳入该节点&lt;/p&gt;
&lt;p&gt;比如， . 左边的符号是 t, 所以当状态机处于状态0时，输入时 t 时， 跳转到状态1。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对所有新生成的节点重复构建&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后对每个新生成的节点进行重复的构建，直到完成所有所有的状态节点的构建和跳转&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这一篇主要是提了对词法和语法的分析过程，因为想要结合语言设计和实践，更详细的应该去看前面的写一个编译器系列&lt;/p&gt;
</description>
<pubDate>Sat, 23 Nov 2019 13:10:00 +0000</pubDate>
<dc:creator>dejavudwh</dc:creator>
<og:description>前言 虽然标题是程序语言的语法，但是讲的是对词法和语法的解析，其实关于这个前面那个写编译器系列的描述会更清楚，有关语言语法的部分应该是穿插在整个设计当中的，也看语言设计者的心情了 和英语汉语这些自然语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secoding/p/11919712.html</dc:identifier>
</item>
<item>
<title>scrapy介绍及使用 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/11919540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/11919540.html</guid>
<description>&lt;h3 id=&quot;43-scrapy的流程&quot;&gt;scrapy的流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123201802306-1003705512.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其流程可以描述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调度器把requests--&amp;gt;引擎--&amp;gt;下载中间件---&amp;gt;下载器&lt;/li&gt;
&lt;li&gt;下载器发送请求，获取响应----&amp;gt;下载中间件----&amp;gt;引擎---&amp;gt;爬虫中间件---&amp;gt;爬虫&lt;/li&gt;
&lt;li&gt;爬虫提取url地址，组装成request对象----&amp;gt;爬虫中间件---&amp;gt;引擎---&amp;gt;调度器&lt;/li&gt;
&lt;li&gt;爬虫提取数据---&amp;gt;引擎---&amp;gt;管道&lt;/li&gt;
&lt;li&gt;管道进行数据的处理和保存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图中绿色线条的表示数据的传递&lt;/li&gt;
&lt;li&gt;注意图中中间件的位置，决定了其作用&lt;/li&gt;
&lt;li&gt;注意其中引擎的位置，所有的模块之前相互独立，只和引擎进行交互&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;44-scrapy中每个模块的具体作用&quot;&gt;scrapy中每个模块的具体作用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123201943437-1044472873.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;1-scrapy项目实现流程&quot;&gt; 1.scrapy项目实现流程&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建一个scrapy项目:&lt;code&gt;scrapy startproject 项目名&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生成一个爬虫:&lt;code&gt;scrapy genspider 爬虫名 允许爬取的范围&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;提取数据:&lt;code&gt;完善spider，使用xpath等方法&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保存数据:&lt;code&gt;pipeline中保存数据&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-创建scrapy项目&quot;&gt;2. 创建scrapy项目&lt;/h2&gt;
&lt;p&gt;命令：&lt;code&gt;scrapy startproject +&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;项目名字&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;code&gt;scrapy startproject myspider&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成的目录和文件结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123202157587-1772379175.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;code&gt;settings.py&lt;/code&gt;中的重点字段和内涵&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;USER_AGENT&lt;/code&gt; 设置ua&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROBOTSTXT_OBEY&lt;/code&gt; 是否遵守robots协议，默认是遵守&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONCURRENT_REQUESTS&lt;/code&gt; 设置并发请求的数量，默认是16个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOWNLOAD_DELAY&lt;/code&gt; 下载延迟，默认无延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COOKIES_ENABLED&lt;/code&gt; 是否开启cookie，即每次请求带上前一次的cookie，默认是开启的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEFAULT_REQUEST_HEADERS&lt;/code&gt; 设置默认请求头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPIDER_MIDDLEWARES&lt;/code&gt; 爬虫中间件，设置过程和管道相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOWNLOADER_MIDDLEWARES&lt;/code&gt; 下载中间件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3-创建爬虫&quot;&gt;创建爬虫&lt;/h2&gt;
&lt;p&gt;命令：&lt;code&gt;scrapy genspider +&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;爬虫名字&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt; + &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;允许爬取的域名&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成的目录和文件结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123202346444-961473736.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-完善spider&quot;&gt;完善spider&lt;/h2&gt;
&lt;p&gt;完善spider即通过方法进行数据的提取等操做：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123202456146-575384495.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;response.xpath&lt;/code&gt;方法的返回结果是一个类似list的类型，其中包含的是selector对象，操作和列表一样，但是有一些额外的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extract()&lt;/code&gt; 返回一个包含有字符串的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extract_first()&lt;/code&gt; 返回列表中的第一个字符串，列表为空没有返回None&lt;/li&gt;
&lt;li&gt;spider中的parse方法必须有&lt;/li&gt;
&lt;li&gt;需要抓取的url地址必须属于allowed_domains,但是start_urls中的url地址没有这个限制&lt;/li&gt;
&lt;li&gt;启动爬虫的时候注意启动的位置，是在项目路径下启动&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;5-数据传递到pipeline&quot;&gt;数据传递到pipeline&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123202917912-753402254.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么要使用yield？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让整个函数变成一个生成器，有什么好处呢？&lt;/li&gt;
&lt;li&gt;遍历这个函数的返回值的时候，挨个把数据读到内存，不会造成内存的瞬间占用过高&lt;/li&gt;
&lt;li&gt;python3中的range和python2中的xrange同理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yield能够传递的对象只能是：&lt;code&gt;BaseItem&lt;/code&gt;,&lt;code&gt;Request&lt;/code&gt;,&lt;code&gt;dict&lt;/code&gt;,&lt;code&gt;None&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;6-完善pipeline&quot;&gt;6. 完善pipeline&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123203001531-271510359.png&quot; alt=&quot;&quot; width=&quot;657&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1394466/201911/1394466-20191123203027150-268500903.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;


&lt;p&gt;pipeline在settings中能够开启多个，为什么需要开启多个？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同的pipeline可以处理不同爬虫的数据&lt;/li&gt;
&lt;li&gt;不同的pipeline能够进行不同的数据处理的操作，比如一个进行数据清洗，一个进行数据的保存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;pipeline使用注意点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用之前需要在settings中开启&lt;/li&gt;
&lt;li&gt;pipeline在setting中键表示位置(即pipeline在项目中的位置可以自定义)，值表示距离引擎的远近，越近数据会越先经过&lt;/li&gt;
&lt;li&gt;有多个pipeline的时候，process_item的方法必须&lt;code&gt;return item&lt;/code&gt;,否则后一个pipeline取到的数据为None值&lt;/li&gt;
&lt;li&gt;pipeline中process_item的方法必须有，否则item没有办法接受和处理&lt;/li&gt;
&lt;li&gt;process_item方法接受item和spider，其中spider表示当前传递item过来的spider&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 23 Nov 2019 12:31:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>scrapy的流程 其流程可以描述如下： 调度器把requests--&amp;gt;引擎--&amp;gt;下载中间件 &amp;gt;下载器 下载器发送请求，获取响应 &amp;gt;下载中间件 &amp;gt;引擎 &amp;gt;爬虫中间件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/skaarl/p/11919540.html</dc:identifier>
</item>
<item>
<title>SpringBoot 配置文件与依赖库分离打包配置 - 风象南</title>
<link>http://www.cnblogs.com/yuboon/p/11919329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuboon/p/11919329.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下我们对springboot应用打包时使用springboot的maven插件spring-boot-maven-plugin的maven进行打包，打包完成得到一个fatjar，fatjar的优点是可以直接运行，缺点是体积太大，不利于传输，springboot应用打出来的fatjar体积少则几十M，多则上百M，在往服务器部署传输时十分便，可能只改了某个类文件，都需要重新将整个fatjar重新传输一次，特别是走公网传输的时候，可能上传速度只有几百甚至几十KB，而整个fatjar中真正我们项目的代码文件可能也就几百KB或几兆的大小，所以有必要将fatjar中的依赖库与我们项目的class进行分离打包，这样每次更换项目class就方便很多，而将配置文件也分离出来的原因在于我们可能经常需要更改配置文件的内容，如果放在fatjar中这样修改是非常不方便的，所以也需要将配置文件也分离出来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &amp;gt;  fatjar 即将项目需要的所有依赖库及配置文件等打进一个jar或war，该文件可直接运行&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 POM配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面对pom.xml进行配置，来实现分离打包，配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;chenyb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;v1.2-release&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.6.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; springboot 打包插件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;mainClass&amp;gt;com.xx.xx&amp;lt;/mainClass&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; maven 打包插件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;archive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;addClasspath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;addClasspath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; MANIFEST.MF 中 Class-Path 加入前缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classpathPrefix&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lib/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classpathPrefix&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jar包不包含唯一版本标识 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;useUniqueVersions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;useUniqueVersions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定入口类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.test.DemoApplication&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;archive&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${project.build.directory}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拷贝依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-dependency-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;copy-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;package&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;copy-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${project.build.directory}/lib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;outputDirectory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;overWriteReleases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;overWriteReleases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;overWriteSnapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;overWriteSnapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;overWriteIfNewer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;overWriteIfNewer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键配置说明：&lt;/p&gt;
&lt;p&gt;(1) 去掉了spring-boot-maven-plugin打包插件&lt;/p&gt;
&lt;p&gt;(2) 添加 maven-jar-plugin （maven标准打包插件）&lt;/p&gt;
&lt;p&gt;(3) maven-dependency-plugin（依赖拷贝插件，主要用于将maven依赖库拷贝出来）&lt;/p&gt;
&lt;p&gt;插件具体的配置，pom.xml中已添加备注说明&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 打包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行maven package 命令进行打包，得到的结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123191121644-806768483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 将 &lt;strong&gt;lib目录 &lt;/strong&gt;及 &lt;strong&gt;项目jar &lt;/strong&gt;文件拷贝到同一目录下，我为了测试方便，先全部拷贝到桌面上，&lt;strong&gt;（放置服务器上时也需保证在同一目录下）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123191238785-901180378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 打开demo-v1.2-release可以看到，并没有将依赖jar打进来，大小只有不到4KB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123192115145-196220044.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123192200876-1294131020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 config目录创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上做完还还需要将项目配置文件拷贝出来，在与jar包平级目录建立&lt;strong&gt;config目录&lt;/strong&gt;，将项目中的&lt;strong&gt;application.properties或yaml&lt;/strong&gt;文件拷贝进来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123191535881-1150795048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  config 下的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123191605292-1542856649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过以上步骤，全部配置完毕，下面进行一下简单的测试&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 为了保证加载的是外部config目录的配置文件，我将application-test.yaml中的server.port改为8085， 打开命令行输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
C:\Users\Administrator\Desktop&amp;gt;java -jar -Dspring.profiles.active=dev -Dspring.location.config=config/ C:\Users\Administrator\Desktop\demo-v1.2-release.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回车运行，能正常启动说明外部依赖可以正常加载进来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123194952177-179189317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看到启动完成后tomcat监听端口为8085，说明外部配置加载成功。&lt;/p&gt;
&lt;p&gt;PS : 如果外部配置文件加载失败，会使用项目jar中的配置文件，如下图，也就是启动后会是8080端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123192115145-196220044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123194531101-973848648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;application-dev.yaml中配置的端口是8080&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123194556763-1873161443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而我已将外部config目录下application-dev.yaml中端口做了修改，使用外部配置文件启动后会是8085端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123195024938-778112862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、一点小坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下window命令行打开后，是在当前用户目录下，像这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123192708268-1319288833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 而我的config、lib、项目jar拷贝在桌面上，实际路径是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1592195/201911/1592195-20191123192801177-1418909800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一开始我在  C:\Users\Administrator&amp;gt; 直接执行下方命令，一直加载不到配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
java -jar -Dspring.profiles.active=dev -Dspring.location.config=config/ C:\Users\Administrator\Desktop\demo-v1.2-release.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因就在于程序与配置文件不在同一目录下，我在C:\Users\Administrator&amp;gt;运行启动命令，而程序实际目录在 C:\Users\Administrator\Desktop&amp;gt; 下，因为程序使用了绝对路径，可以找到文件，所以程序的实际运行路径为C:\Users\Administrator\Desktop，而我使用的配置 spring.location.config=config/ 使用的是相对路径，，这个相对路径又是相对 C:\Users\Administrator&amp;gt; 目录，所以就会出现找不到配置文件的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令行切换到 C:\Users\Administrator\Desktop 目录，即项目jar所在目录，运行 java -jar 命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将config拷贝到C:/Users/Administrator下，保证C:/Users/Administrator相对路径下存在config目录及配置文件（该方法可解决问题，但是不建议）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法三：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring.location.config=config/ 处使用绝对路径，即C:/Users/Administrator/Desktop/config/ &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以很重要一点，一定保证 执行命令 的目录 与项目jar、lib、config都在同一目录下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、完整demo地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/yuboon/java-examples/tree/master/springboot-package-segment&quot;&gt;https://github.com/yuboon/java-examples/tree/master/springboot-package-segment&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 23 Nov 2019 12:11:00 +0000</pubDate>
<dc:creator>风象南</dc:creator>
<og:description>一、应用场景 一般情况下我们对springboot应用打包时使用springboot的maven插件spring-boot-maven-plugin的maven进行打包，打包完成得到一个fatjar，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuboon/p/11919329.html</dc:identifier>
</item>
</channel>
</rss>