<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mongodb连接配置实践 - 超超boy</title>
<link>http://www.cnblogs.com/jycboy/p/10077080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jycboy/p/10077080.html</guid>
<description>&lt;p&gt;之前百度,google了很多,发现并没有介绍mongodb生产环境如何配置的文章, 当时想参考下都不行, 所以写篇文章,大家可以一块讨论下.&lt;/p&gt;
&lt;h2&gt;1. MongoClientOptions中的连接池配置:&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;配置如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
connectionPoolSettings =&lt;span&gt; ConnectionPoolSettings.builder()
                                                       .minSize(getMinConnectionsPerHost())
                                                       .maxSize(getConnectionsPerHost())
                                                       .maxWaitQueueSize(getThreadsAllowedToBlockForConnectionMultiplier()
                                                                         &lt;/span&gt;*&lt;span&gt; getConnectionsPerHost())
                                                       .maxWaitTime(getMaxWaitTime(), MILLISECONDS)
                                                       .maxConnectionIdleTime(getMaxConnectionIdleTime(), MILLISECONDS)
                                                       .maxConnectionLifeTime(getMaxConnectionLifeTime(), MILLISECONDS)
                                                       .build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;minSize: 线程池空闲时保持的最小连接数, 默认是0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxSize: 线程池允许的最大连接数,默认是100.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxWaitQueueSize: 线程池等待队列的大小, 默认是500.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxWaitTime: 线程等待连接变为可用的最长时间.默认为2分钟. 值为0意味着它不会等待. 负值意味着它将无限期地等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxConnectionIdleTime: 线程池中连接的最大空闲时间, 0标志Udine空闲时间没有限制,超过这个时间会被关闭.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxConnectionLifeTime: 线程池中连接的最长生存时间. 0表示没有限制. 超过寿命的会被关闭,必要时通过新连接进行替换.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. MongoClientOptions初始化&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;mongodb驱动中 MongoClientOptions 使用Buidler模式配置,有关所有属性的默认值,都是在Builder里边配置的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于Builder 的配置如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Builder {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String applicationName;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取偏好, 这里默认的是从主节点读取.&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; ReadPreference readPreference =&lt;span&gt; ReadPreference.primary();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用服务器默认的写关注?&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; WriteConcern writeConcern =&lt;span&gt; WriteConcern.ACKNOWLEDGED;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用服务的默认读关注,默认是local&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; ReadConcern readConcern =&lt;span&gt; ReadConcern.DEFAULT;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; CodecRegistry codecRegistry =&lt;span&gt; MongoClient.getDefaultCodecRegistry();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;CommandListener&amp;gt; commandListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;CommandListener&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ClusterListener&amp;gt; clusterListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ClusterListener&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ServerListener&amp;gt; serverListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ServerListener&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ServerMonitorListener&amp;gt; serverMonitorListeners = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ServerMonitorListener&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; minConnectionsPerHost;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxConnectionsPerHost = 100&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadsAllowedToBlockForConnectionMultiplier = 5&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置服务器选择超时（以毫秒为单位），它定义驱动程序在抛出异常之前等待服务器选择成功的时间
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值为0表示如果没有可用的服务器，它将立即超时。 负值意味着无限期等待&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; serverSelectionTimeout = 1000 * 30&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程等待连接变为可用的最长时间&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxWaitTime = 1000 * 60 * 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中连接的最大空闲时间&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxConnectionIdleTime;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxConnectionLifeTime;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接超时时间,必须大于0&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; connectTimeout = 1000 * 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket超时时间&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; socketTimeout = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket是否保活&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; socketKeepAlive = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sslEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sslInvalidHostNameAllowed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; alwaysUseMBeans = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置心跳频率。 这是驱动程序将尝试确定群集中每个服务器的当前状态的频率。 默认值为10,000毫秒&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; heartbeatFrequency = 10000&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最小心跳频率。 如果驱动程序必须经常重新检查服务器的可用性，它将至少在上一次检查后等待很长时间，以避免浪费精力。 默认值为500毫秒。&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minHeartbeatFrequency = 500&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置用于集群心跳的连接的连接超时&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; heartbeatConnectTimeout = 20000&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置用于集群心跳的连接的套接字超时&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; heartbeatSocketTimeout = 20000&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地阈值&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; localThreshold = 15&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String requiredReplicaSetName;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DBDecoderFactory dbDecoderFactory =&lt;span&gt; DefaultDBDecoder.FACTORY;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DBEncoderFactory dbEncoderFactory =&lt;span&gt; DefaultDBEncoder.FACTORY;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SocketFactory socketFactory;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cursorFinalizerEnabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 需要关心的配置&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里就因人而异了, 我这列出比较重要的几个配置,具体的值看业务场景.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 3.1 读写相关&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这应该是程序最应该关注的配置了,读关注,写关注,读取偏好.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//读取偏好, 首先从从节点读取.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private ReadPreference readPreference = ReadPreference.secondaryPreferred();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//写关注为1 ,写入主节点即返回.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private WriteConcern writeConcern = WriteConcern.W1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//使用服务的默认读关注,默认是local(决定到某个读取数据时，能读到什么样的数据)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private ReadConcern readConcern = ReadConcern.LOCAL;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;3.2 线程池配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;//线程池空闲时保持的最小连接数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;minConnectionsPerHost=20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//线程池允许的最大连接数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;connectionsPerHost=100&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//connectionsPerHost* 5 =最大队列数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;threadsAllowedToBlockForConnectionMultiplier=5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//线程池中连接的最大空闲时间,5分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxConnectionIdleTime = 5*60*1000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; // 线程池中连接的最长生存时间,采用默认值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxConnectionLifeTime&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.3 连接配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;//设置服务器选择超时（以毫秒为单位），它定义驱动程序在抛出异常之前等待服务器选择成功的时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//值为0表示如果没有可用的服务器，它将立即超时。 负值意味着无限期等待&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private int serverSelectionTimeout = 1000 * 30;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//连接超时时间,必须大于0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private int connectTimeout = 1000 * 5;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//线程等待连接变为可用的最长时间.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxWaitTime=6000&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里建议 这两个参数: maxWaitTime,connectTimeout,根据公司具体的业务来..&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是目前我在公司的配置参数, 借鉴了其他的连接池配置比如: redis和mysql的,并不是最优的,还在摸索实践....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;转发注明出处: &lt;a href=&quot;https://www.cnblogs.com/jycboy/p/10077080.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jycboy/p/10077080.html&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Dec 2018 07:44:00 +0000</pubDate>
<dc:creator>超超boy</dc:creator>
<og:description>之前百度,google了很多,发现并没有介绍mongodb生产环境如何配置的文章, 当时想参考下都不行, 所以写篇文章,大家可以一块讨论下. 1. MongoClientOptions中的连接池配置:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jycboy/p/10077080.html</dc:identifier>
</item>
<item>
<title>java线程状态 以及 sheep（）、wait()、yield() 区别 - blueskyli</title>
<link>http://www.cnblogs.com/blueskyli/p/10076975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueskyli/p/10076975.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近看到很多人都在讨论多线程的问题，于是写出了这篇博客，希望可以帮到正在学习和使用这块的朋友们，首先我们先看看两个图（两个图都来自其他码农的分享）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/354604/201812/354604-20181205115922719-1715770542.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/354604/201812/354604-20181205115932223-1905703432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个图是一样的逻辑，这里一起罗列出来，下面让我们用语句来简单描述下两个图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sleep 让线程从 【running】 -&amp;gt; 【阻塞态】 时间结束/interrupt -&amp;gt; 【runnable】&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;wait 让线程从 【running】 -&amp;gt; 【等待队列】notify -&amp;gt; 【锁池】 -&amp;gt; 【runnable】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们看到这个图的时候首先会看到线程的几种状态，下面让我们先来分别说明一下：&lt;/p&gt;
&lt;p&gt;线程共包括一下5种状态：&lt;/p&gt;
&lt;p&gt;1，新建、初始状态（New） ：线程对象被创建后就进入了新建状态，Thread thread = new Thread();&lt;/p&gt;
&lt;p&gt;2，就绪（Runnable）：也被称之为“可执行状态”，当线程被new出来后，其他的线程调用了该对象的start()方法，即thread.start()，此时线程位于“可运行线程池”中，只等待获取CPU的使用权，随时可以被CPU调用。进入就绪状态的进程除CPU之外，其他运行所需的资源都已经全部获得。&lt;/p&gt;
&lt;p&gt;3，运行（Running）：线程获取CPU权限开始执行。注意：&lt;span&gt;线程只能从就绪状态进入到运行状态&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;4，阻塞（Bloacked）：阻塞状态是线程因为某种原因放弃CPU的使用权，暂时停止运行，知道线程进入就绪状态后才能有机会转到运行状态。&lt;/p&gt;
&lt;p&gt;阻塞的情况分三种：&lt;/p&gt;
&lt;p&gt;(01) 等待阻塞：运行的线程执行&lt;strong&gt;wait()&lt;/strong&gt;方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池中”。进入这个状态后是不能自动唤醒的，必须依靠其他线程调用notify()或者notifyAll()方法才能被唤醒。&lt;/p&gt;
&lt;p&gt;(02)同步阻塞：运行的线程在获取对象的（synchronized）同步锁时，若该同步锁被其他线程占用，则JVM会吧该线程放入“锁池”中。&lt;/p&gt;
&lt;p&gt;(03)其他阻塞：通过调用线程的sleep()或者join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新回到就绪状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上三种阻塞状态请参考上面的2个图示来理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5，死亡（Dead）：线程执行完了或因异常退出了run()方法，则该线程结束生命周期。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt; wait(), notify(), notifyAll()等方法介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; 这三个方法都是定义到Object类中，wait的作用是当当前线程释放它所持有的锁进入等待状态，而notify和notifyAll则是唤醒当前对象上的等待线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;notify()        &lt;/strong&gt;-- 唤醒在此对象监视器上等待的单个线程。&lt;br/&gt;&lt;strong&gt;notifyAll() &lt;/strong&gt;   -- 唤醒在此对象监视器上等待的所有线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wait()         &lt;/strong&gt;  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。&lt;br/&gt;&lt;strong&gt;wait(long timeout)    &lt;/strong&gt; -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。&lt;br/&gt;&lt;strong&gt;wait(long timeout, int nanos)  &lt;/strong&gt;-- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。&lt;/p&gt;
&lt;p&gt;wait()会使“当前线程”等待，并且会释放到它所占用的“锁标志”，从而使线程所在对象中的其他synchronized数据可以被其他线程使用。&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronizedblock中进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。&lt;/p&gt;
&lt;p&gt;负责唤醒等待线程的那个线程(我们称为“&lt;strong&gt;唤醒线程&lt;/strong&gt;”)，它只有在获取“该对象的同步锁”(&lt;strong&gt;这里的同步锁必须和等待线程的同步锁是同一个&lt;/strong&gt;)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;suspend()和 resume()方法&lt;/strong&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;36&quot;&gt;
&lt;p&gt;两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。&lt;strong&gt;典型地，&lt;/strong&gt;&lt;strong&gt;suspend()和 resume() 被用在等待另一个线程产生的结果的情形：&lt;/strong&gt;测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume()使其恢复。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初看起来wait() 和 notify() 方法与suspend()和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。&lt;strong&gt;区别的核心在于&lt;/strong&gt;，前面叙述的suspend()及其它所有方法在线程阻塞时都不会释放占用的锁（如果占用了的话），而wait() 和 notify() 这一对方法则相反。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;52&quot;&gt;
&lt;h2&gt; sleep() 和 yield()方法&lt;/h2&gt;
&lt;p&gt;这两个方法都定义在Thread.java中&lt;/p&gt;
&lt;p&gt;sleep()的作用是让当前线程休眠（正在执行的线程主动让出cpu，然后cpu就可以去执行其他任务），即当前线程会从“运行状态”进入到“休眠（阻塞）状态”。sleep()会指定休眠时间，线程休眠的时候会大于或者等于该休眠时间，当时间过后该线程重新被会形式，他会由“阻塞状态”编程“就绪状态”，从而等待cpu的调度执行，注意：&lt;span&gt;sleep方法只是让出了cpu的执行权，并不会释放同步资源锁&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;yield()的作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行，注意：&lt;span&gt;这里我将上面的“具有相同优先级”的线程直接改为了线程，很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，优先级低的线程在拿到cpu执行权后也是可以执行，只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有可能是其他人先上车了，也有可能是Yield先上车了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;wait和sleep的区别&lt;/h2&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;p&gt;1，他们都是在多线程的环境下，都可以在程序的调用出阻塞指定的毫秒数并且返回&lt;/p&gt;
&lt;p&gt;2，两个方法都可以通过interrupt()方法打断线程的暂停状态，但是线程会抛出InterruptedException。需要注意的是，I&lt;span&gt;nterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;p&gt;1，Thread类的方法：sleep(),yield()&lt;br/&gt;     Object的方法：wait()和notify()、notifyAll()&lt;/p&gt;
&lt;p&gt;2，每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 &lt;/p&gt;
&lt;p&gt;3， wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 。注意：&lt;span&gt;wiat()必须放在synchronized block中，否则会在program runtime时扔出“java.lang.IllegalMonitorStateException”异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4，sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常&lt;/p&gt;
&lt;p&gt;综上可得两者最大的区别：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.445432977461&quot;&gt;
&lt;div readability=&quot;17.914590747331&quot;&gt;
&lt;p&gt;第一：调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。&lt;/p&gt;
&lt;p&gt;第二：除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。&lt;/p&gt;
&lt;p&gt;谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend()方法和不指定超时期限的wait()方法的调用都可能产生死锁。遗憾的是，&lt;a href=&quot;https://link.jianshu.com/?t=http://lib.csdn.net/base/java&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Java&lt;/a&gt;并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 06 Dec 2018 07:31:00 +0000</pubDate>
<dc:creator>blueskyli</dc:creator>
<og:description>前言 最近看到很多人都在讨论多线程的问题，于是写出了这篇博客，希望可以帮到正在学习和使用这块的朋友们，首先我们先看看两个图（两个图都来自其他码农的分享） 这两个图是一样的逻辑，这里一起罗列出来，下面让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blueskyli/p/10076975.html</dc:identifier>
</item>
<item>
<title>MySQL高级查询和编程基础 - 雨落秋垣</title>
<link>http://www.cnblogs.com/ceet/p/10076942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ceet/p/10076942.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第一章 数据库设计&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、数据需求分析：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;数据需求分析是为后续概念设计和逻辑结构设计做准备。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;结构：&lt;/span&gt;&lt;span&gt;（1）对现实世界要处理的对象进行详细的调查。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;     （2）收集基础数、据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;     （3）对所收集的数据进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;     （4）确定新的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;二、概念结构设计：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;主要的五项概念：&lt;/span&gt;&lt;span&gt;实体、属性、域、码、实体间联系。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;实体之间的联系：&lt;/span&gt;&lt;span&gt;（1）1：1 在任意一方建立另外一方的外键。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;               （2）1：m 在多的一方建立一的外键。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;               （3）m：n 建立第三张表，双方的主键在第三张表中作为外键。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;三、使用E-R模型进行概念结构设计：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;E-R图概述：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （1）真实、充分的反映现实世界中事物和事物之间的联系。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （2）简明易懂。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （3）易于修改。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （4）便于向数据逻辑模型转换。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;标识实体的原则包括以下4项：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （1）实体通常是一个名词，其名称应简明扼要、恰如其分。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （2）每个实体仅描述一件事情或一个事物。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （3）每个实体都是唯一的，即不能出现含义相同的实体。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  （4）联系通常是一个动词或动名词，其名称应反映出实体之间的内在关联。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;四、逻辑结构设计：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;当1：m 的联系转换为关系模式时，通常采用与m端相对应的关系模式进行合并。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;五、使用PowerDesigner设计数据库：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;概念模型、物理模型、生成数据库。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第二章 基本查询应用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、SELECT基本结构：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;select &amp;lt;column1, column2, column3...&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;from &amp;lt;table_name&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[where &amp;lt;条件表达式&amp;gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[group by column1, column2, column3... | having &amp;lt;条件表达式&amp;gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[order by &amp;lt; column1, column2, column3...&amp;gt; [ASC或者DESC]]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）必须的子句只有select和from子句。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）where子句用于对查询结果进行过滤。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）group by子句根据指定列分组，having子句对分组后的结果进行过滤。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）order by子句用于对查询结果进行排序。ASC表示升序排序，DESC表示降序排序，默认按照ASC排序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;LIMIT子句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;select * from table LIMIT [offset,] rows&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;二、聚合函数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;常用的聚合函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.AVG 返回指定组中的平均值，空值被忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,avg(qty) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. COUNT 返回指定组中项目的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select count(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. MAX 返回指定数据的最大值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,max(qty) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. MIN 返回指定数据的最小值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,min(qty) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. SUM 返回指定数据的和，只能用于数字列，空值被忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,sum(qty) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6. COUNT_BIG 返回指定组中的项目数量，与COUNT函数不同的是COUNT_BIG返回bigint值，而COUNT返回的是int值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select count_big(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7. GROUPING 产生一个附加的列，当用CUBE或ROLLUP运算符添加行时，输出值为1.当所添加的行不是由CUBE或ROLLUP产生时，输出值为0.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,sum(qty),grouping(prd_no) from sales group by prd_no with rollup&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8. BINARY_CHECKSUM 返回对表中的行或表达式列表计算的二进制校验值，用于检测表中行的更改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,binary_checksum(qty) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9. CHECKSUM_AGG 返回指定数据的校验值，空值被忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select prd_no,checksum_agg(binary_checksum(*)) from sales group by prd_no&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;10. CHECKSUM 返回在表的行上或在表达式列表上计算的校验值，用于生成哈希索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11. STDEV 返回给定表达式中所有值的统计标准偏差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select stdev(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;12. STDEVP 返回给定表达式中的所有值的填充统计标准偏差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select stdevp(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;13. VAR 返回给定表达式中所有值的统计方差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select var(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;14. VARP 返回给定表达式中所有值的填充的统计方差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：select varp(prd_no) from sales&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分组查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.使用group by进行分组查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在使用group by关键字时，在select列表中可以指定的项目是有限制的，select语句中仅许以下几项：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;〉被分组的列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;〉为每个分组返回一个值得表达式，例如用一个列名作为参数的聚合函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;group by&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select courseID,avg(score) as 课程平均成绩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from score&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;group by courseID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select studentID as 学员编号,courseID as 内部测试,avg(score) as 内部测试平均成绩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from score&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;group by studentID,courseID&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.使用having子句进行分组筛选&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where子句只能对没有分组统计前的数据行进行筛选,对分组后的条件的筛选必须使用having子句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select studentID as 学员编号,courseID as 内部测试,avg(score) as 内部测试平均成绩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from score&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;group by studentID,courseID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;having avg(score)&amp;gt;60&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在select语句中，where、group by、having子句和统计函数的执行次序如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;where子句从数据源中去掉不符合去搜索条件的数据；group by子句搜集数据行到各个组中，统计函数为各个组计算统计值；having子句去掉不符合其组搜索条件的各组数据行 。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;联接查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;概述：&lt;/span&gt;&lt;span&gt;连接查询是关系数据库中最主要的查询，主要包括&lt;/span&gt;&lt;span&gt;内连接&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;外连接&lt;/span&gt;&lt;span&gt;和交叉连接等。通过连接&lt;/span&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;span&gt;可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型&lt;/span&gt;&lt;span&gt;数据库管理系统&lt;/span&gt;&lt;span&gt;的一个标志。 在&lt;/span&gt;&lt;span&gt;关系数据库管理系统&lt;/span&gt;&lt;span&gt;中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，然后通过连接进行查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方式形式：&lt;/span&gt;&lt;span&gt;内连接&lt;/span&gt;&lt;span&gt;的连接查询结果集中仅包含满足条件的行，内连接是&lt;/span&gt;&lt;span&gt;SQL Server&lt;/span&gt;&lt;span&gt;缺省的连接方式，可以把&lt;/span&gt;&lt;span&gt;INNERJOIN&lt;/span&gt;&lt;span&gt;简写成&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;根据所使用的比较方式不同，内连接又分为等值连接、&lt;/span&gt;&lt;span&gt;自然连接&lt;/span&gt;&lt;span&gt;和不等连接三种；&lt;/span&gt;&lt;span&gt;交叉连接&lt;/span&gt;&lt;span&gt;的连接查询结果集中包含两个表中所有行的组合；&lt;/span&gt;&lt;span&gt;外连接&lt;/span&gt;&lt;span&gt;的连接查询结果集中既包含那些满足条件的行，还包含其中某个表的全部行，有3种形式的外连接：左外连接、右外连接、全外连接。&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第三章 子查询&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、子查询的基本知识：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;嵌套在select、insert、update和deleted语句或其他子查询中的查询，允许使用任何表达式的地方均可以使用子查询，但是子查询通常位于where子句中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子查询的实质：&lt;/span&gt;&lt;span&gt;一个select语句的查询结果能够座位另一个语句的输入值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、单行子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单行子查询是指子查询的返回结果只有一行数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当主查询的条件语句中引用子查询的结果时，可使用单行比较符（=、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=和&amp;lt;&amp;gt;）进行比较。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三、多行子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多行子查询是指查询的返回结果是多行数据。常见的多行比较符包括IN、ALL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IN比较符：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用IN时，主查询会与子查询中的每一个值进行比较，如果预期中的任何一个值相同，则返回。NOT IN 与IN的含义恰好相反。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单行子查询中的“=”可以用多行子查询中的“IN”替换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用ALL关键字的子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;span&gt;表达式或字段 单行比较运算符 ALL（子查询）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ALL运算符的含义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&amp;lt;ALL，表示小于最小值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&amp;gt;ALL，表示大于最大值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ANY运算符的含义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&amp;lt;ANY，表示大于最小值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&amp;gt;ANY，表示小于最大值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四、在FROM子句中使用子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在from中使用子查询的实质是将子查询看作一张虚表与主查询中的表作联接查询。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五、在SELECT子句中使用子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实质：&lt;/span&gt;&lt;span&gt;将子查询的执行结果作为SELECT子句的列，可以起到与联接查询异曲同工的作用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;六、EXISTS子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;span&gt;主查询表达式 [NOT] EXISTS （子查询）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;EXISTS用于检查子查询是否会返回一行数据，该子查询实际上并不返回任何数据，而是返回TRUE或FALSE。EXISTS指定一个字查询，用于检测行的存在。当子查询的行存在时，则执行主查询表达式，否则不执行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;七、在DML语句中使用子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在UPDATE子句中使用子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UPDATE [原表] SET [要修改的列] WHERE [条件]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在DELETE子句中使用子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DELETE FROM [原表] WHERE [条件]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;八、补充：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子查询依赖子查询称为相关子查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）表扫描适合外大内小（效率高）不适合外小内大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交叉连接(cross join)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交叉连接是把所有第一个表和第二个表的值一一对应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select u.username , t.toyname from user as u cross join tay ast ;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第四章 视图、索引&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、视图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;概念和特点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）视图是一种数据库对象，是一个从一张表、多张表或视图中导出的虚表。视图的结构和数据是数据表进行查询的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）仅存放视图的定义，不存放视图所对应的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）如果基表中的数据发生变化，则从视图中查询出的数据也随之改变。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、关注点聚焦。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、简化操作。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、定制数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4、合并分割数据。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;5、安全性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;创建和使用：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;利用CREATE VIEW语句可以创建视图，该命令的基本语法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;CREATE VIEW view_name AS SELECT column_names FROM table_name1 , [table_name2 , table_name3 , ... table_namen] WHERE condition&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;参数说明：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;view_name：视图名。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;column_names：视图中的字段列表，可以来源于多个表。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;table_name1：表名1.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;condition：条件表达式，如果是多表则该表达式还包含表的联接条件。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用视图创建复杂查询：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;视图中的列不仅可以是基表的数据列，还可以是计算机或聚合函数列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;二、索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;概述：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;数据库中的索引是一个表中所包含值的列表，它注明了这些值所对应的存储位置。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;基本价值：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;提高效率。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;作用和弊端：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）可以大大加快数据的检索速度。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）可以加速表与表之间的联接，在实现数据参考完整性方面有特别的意义。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）使用分组和排序子句进行数据检索时同样可以显著减少查询中分组和排序的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（5）通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统性能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;弊端：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）因为创建索引所需的工作空间约为数据库表的1.2倍，所以带索引的表在数据库中会占据更多的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）为维护索引，在对数据进行插入、更新和删除操作时会耗费系统时间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）在建立索引时，由于需要复制数据，同样会耗费系统的时间和空间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用场合：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）在经常需要搜索的列上，可以加快搜索的速度。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）在作为主键的列上。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）在经常用联接的列（这些列主要是一些外键）上，建立索引可以加快联接的速度。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）在经常需要根据范围进行搜索的列上创建索引。因为索引已经排序，其指定的范围是连续的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（5）在经常需要排序的列上创建索引。因为索引已经排序，这样查询可以利用索引的排序节省查询的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（6）在使用WHERE子句的列上创建索引，加快条件的判断速度。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一般而言，不应该创建索引的列具有以下4个特点：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）对于那些在查询中很少使用或参考的列不应该创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）对于那些只有很少数据值的列而言，同样不应该增加索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）对于那些定义text、image和bit数据类型的列不应该增加索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）当修改性能远大于检索性能时，不应该创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;分类：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）聚集索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;聚集索引是将数据的值在表内排序并储存对应的数据记录，是数据表物理排序与索引顺序相一致。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）非聚集索引（普通索引）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;非聚集索引也称为普通索引，它是一种完全独立于数据进行的文件结构。数据储存在一个地方，索引储存在另一个地方。非聚集索引中的数据排列顺序并非表中结构的排列顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）聚集索引和非聚集索引的比较：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;a. 聚集索引相比非聚集索引，在插入数据时速度要慢（时间花费在“物理存储排序”上，即首先要找到位置然后插入），但在查询数据时速度要快。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;b. 如果硬盘和内存空间有限，则应限制非聚集索引的使用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;创建索引的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）MySQL自动创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;MySQL在创建表中其他对象时可以附带创建新索引。通常情况下，MySQL在创建UNIQUE约束或PRIMARY KEY约束时，系统会自动在这些约束上创建聚集索引；另外系统通常也会在自动外键列上创建非聚集索引（即普通索引）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）用户创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;除了MySQL自动生成索引外，也可以根据实际需要，使用MySQL集成开发平台（如Navicat For MySQL），或者利用SQL语句CREATE INDEX命令直接创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用ALTER命令创建索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ALTER TABLE table_name ADD INDEX index_name (column_list);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ALTER TABLE table_name ADD UNIQUE (column_list);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ALTER TABLE table_name ADD PRIMARY KEY (column_list);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用CREATE命令创建索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;CREATE INDEX index_name ON table_name (column_list);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;CREATE UNIQUE INDEX index_name ON table_name (column_list);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用DROP和ALTER命令删除索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;DROP INDEX index_name ON table_name; 或&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ALTER TABLE table_name DROP INDEX index_name;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第五章 MySQL存储过程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、用户自定义变量：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;用户会话变量：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法1：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;set @user_variable1=expression1 [,@user_variable2=expression2,......]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法2：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;select @user_variable1:=expression1 [,@user_variable2:=expression2,......]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法3：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;select expression1 into @user_variable1,expression2 into @user_variable2,......&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;用户会话变量与SQL语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;检索数据时，如果select语句的结果集是单个值，可以将select语句的返回结果赋予用户会话变量。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;局部变量：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;declare 数据类型 局部变量;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;重置命令结束标记：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;begin-end语句快中通常存在多条MySQL表达式，每条MySQL表达式都是用“；”作为结束标记。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;二、条件控制语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;if语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;if语句根据条件表达式的值确定执行不同的语句块。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;if 条件表达式1 then 语句块1;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[elseif 条件表达式2 then 语句块2]...&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[else 语句块n]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;endif;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;case语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;case语句用于实现比if语句分支更为复杂的条件判断。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;case 表达式&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;when value1 then 语句块1;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;when value1 then 语句块2;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;else 语句块n;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;end case;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;while语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当条件表达式的值为true时，反复执行循环体，直到条件表达式的值为false。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[循环标签:] while 条件表达式 do&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;循环体;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;end while[循环标签];&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;leave语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;leave语句用于跳出当前的循环语句（如while语句），它的作用等同于高级编程语言中的break语句。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;leave 循环标签;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;iterator语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;iterator语句用于跳出本次循环，进而进行下次循环，它的作用等同于高级编程语言中的continue语句。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;iterator 循环标签;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;三、存储过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;创建和执行存储过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;创建：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;create procedure 存储过程的名字(&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[in | out | inout] 参数1 数据类型1,&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[in | out | inout] 参数2 数据类型2,&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;[no sql | reads sql data | modifies sql data]&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;begin&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;存储过程语句块,&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;end&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;执行：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;call 存储过程名(参数列表)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;不带参数的存储过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;执行：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;call 存储过程名&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;带输入参数的存储过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;执行带参数的存储过程时，传入值的类型、个数和顺序都需要与存储过程中定义的参数逐一对应。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;带输出参数的存储过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果需要存储过程中返回一格值或者多个值，可通过使用输出参数来实现。输出参数必须在创建存储过程时，使用out关键字进行声明。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;四、游标：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;MySQL中使用游标的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）声明游标：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;declare 游标名 cursor for select 语句;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）打开游标：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;open 游标名;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）从游标中提取数据：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;fetch 游标名 into 变量名1 , 变量名2 , ......;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）关闭游标：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;close 游标;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;游标使用：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;略。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;第七章 数据库事物查询与查询优化&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;一、事物：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;事物概述：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;事物是一个由所定义的完整的工作单元，一个事物内所有语句诶作为一个整体来执行。即或者全部执行，或者全部都不执行。当遇到错误时，可以回滚事务，取消事物内所做的所有改变，从而保证数据库中数据的一致性和可恢复性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;事物特性：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、原子性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、隔离性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4、持久性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;关闭MySQL自动提交：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;方法一：（显示的关闭自动提交）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;set autocommit=0;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;方法二：（隐示的关闭自动提交）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;start transaction;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;MySQL事物操作语句：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;start transaction： 标识一个事物的开始，即启动事物。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;commit： 提交事务。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;rollback： 回滚事务。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;二、查询优化基本知识：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;数据库优化查询的必要性：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;查询优化原理：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;选择一个高效的查询处理策略。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;三、查询优化方法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;基于索引的优化：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）主键和外键列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）需要在指定范围内快速或频繁查询的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）需要按顺序快速或平凡查询的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）在集合过程中需要快速频繁组合在一起的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;以下场合不考虑创建索引：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）在查询中几乎不涉及的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）很少有唯一的值，如记录性别的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）有text、image数据类型定义的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（4）只有较少行数的表。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;where子句优化：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、避免在where子句中对字段进行null值判断。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、避免在where子句中适应！=或者&amp;lt;&amp;gt;操作符。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、慎用in和not in。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4、避免在where子句中对字段进行表达式操作。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;5、避免在where子句的“=”左边进行函数、算术运算或其他表达式运算。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;6、尽量使用exists。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;子查询性能优化：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、尽量使用联接查询代替子查询。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、not in、not exists 子查询可以改用left join代替。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、如果子查询结果集没有重复记录，in、exists子查询可以用inner join代替。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4、in子查询用exists代替。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;5、不要使用含有count(*)的子查询判断是否存在记录，最好使用left join和exists。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;6、尽量避免嵌套子查询。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;7、子查询中尽量过滤可能多的行。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;其他SQL语句优化：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、查询时按需取材，不要返回不需要的行、列，即避免使用“select * from 表”。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、避免或简化排序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）索引中不包括一个或几个待排序的列。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）group by子句或order by子句中列的次序与索引的次序不一致。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）排序的列来自不同的表。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、尽量在group by子句、having子句之前剔除多余的行。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）select中的where子句选择所有合适的行。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）group by子句用于分组统计。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（3）having子句用于剔除多余的分组。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;4、消除对大型表数据的顺序存取。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）对联接的列创建索引。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）使用并集。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;5、尽量用distinct（唯一）,不要使用group by。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;6、避免困难的正规表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;7、尽量使用存储过程。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;8、尽量少使用视图，特别是嵌套视图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;9、SQL语句中的字段值要与数据类型精确匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;连接查询心得&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;连接不限与两张表，连接查询也可以是三张、四张，甚至N张表的连接查询。通常连接查询不可能需要整个笛卡尔积，而只是需要其中一部分，那么这时就需要使用条件来去除不需要的记录。这个条件大多数情况下都是使用主外键关系去除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两张表的连接查询一定有一个主外键关系，三张表的连接查询就一定有两个主外键关系，所以在大家不是很熟悉连接查询时，首先要学会去除无用笛卡尔积，那么就是用主外键关系作为条件来处理。如果两张表的查询，那么至少有一个主外键条件，三张表连接至少有两个主外键条件。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 06 Dec 2018 07:27:00 +0000</pubDate>
<dc:creator>雨落秋垣</dc:creator>
<og:description>第一章 数据库设计 一、数据需求分析： 数据需求分析是为后续概念设计和逻辑结构设计做准备。 结构：（1）对现实世界要处理的对象进行详细的调查。 （2）收集基础数、据。 （3）对所收集的数据进行处理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ceet/p/10076942.html</dc:identifier>
</item>
<item>
<title>带着新人学springboot的应用09（springboot+异步任务） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10076949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10076949.html</guid>
<description>&lt;p&gt;　　本来想说说检索的，不过不知道什么鬼，下载ElasticSearch太慢了，还是放一下，后面有机会再补上！今天就说个简单的东西，来说说任务。&lt;/p&gt;
&lt;p&gt;　　什么叫做任务呢？其实就是类中实现了一个什么功能的方法。常见的任务就是异步任务，定时任务，发邮件。&lt;/p&gt;
&lt;p&gt;　　异步任务：其实就是一个很特别的方法，这个方法没有返回值（也可以有返回值，后面会说的），但是方法内部的逻辑会耗费很多时间！例如，用户请求每次到controller，要执行到这个异步方法的时候，我们只需要命令一个空闲状态的线程去执行它即可，由于没有返回值不影响后续代码的运行，controller直接去执行后续的代码。这样可以极为迅速的响应用户，用户体验非常好。&lt;/p&gt;
&lt;p&gt;　　定时任务：这个其实看名字就知道了，你可以选定一个月的哪一天哪个小时的具体时分秒，去执行一个方法。这个方法是自动执行的，极大的减轻了我们的工作量。&lt;/p&gt;
&lt;p&gt;　　发邮件：这个还是比较常见的吧！注册什么的大多都要邮件激活，我们也可以用java程序的方式，来给你邮箱发邮件。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;提前准备：大概了解一下javase中多线程和线程池概念，重点是ThreadPoolTaskExecutor这个类。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.简单说说异步任务和RabbitMQ&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;不知道看了我上面说了异步任务，大家有没有想到前面说过的一个东西，就是RabbitMQ啊！这个消息队列，不就是也是这样的吗？生产者发消息给交换器之后，就不管了，也许生产者就可以直接响应用户响应成功了。而内部也许还有交换器发消息给队列，然后消费者消费消息，但这个过程就跟用户就没什么关系了，干嘛要用户浪费时间在那瞎等呢？&lt;/p&gt;
&lt;p&gt;　　就我而言，异步任务和RabbitMQ最大的区别应该是访问量的差异；可以将异步任务看作是简化版RabbitMQ 。&lt;/p&gt;
&lt;p&gt;　　你想啊，假如你做了一个系统，最大访问量总共那么点人，你还要去用个RabbitMQ去搞这搞那的，麻不麻烦啊。。。&lt;/p&gt;
&lt;p&gt;　　但是假如你在一家大公司，做的系统是给几十万甚至几百万用户用的，那么肯定要用RabbitMQ啊。这个时候如果用异步任务，哪有这么多空闲线程去给你执行这个任务啊，而且线程到了一个数目之后，效率反而是降低的。&lt;/p&gt;
&lt;p&gt;　　补充小知识：大家知不知道服务器怎么处理多个请求的啊？&lt;/p&gt;
&lt;p&gt;　　假如都是同步任务：请用请求一到，服务器就出用一个线程去执行，并且到了service层之后，假设会有个任务需要几十秒才能执行完毕；那么执行到这里就会卡住了，请求到这里都要卡住几十秒，人多的时候可能还要排队，等时间过了你才会得到响应。&lt;/p&gt;
&lt;p&gt;　　那就等着呗，然而不巧的是，这个时候又有几千人来来给服务器发请求，于是这几千人每人等几十秒，而且由于服务器又比较水，一下子开了几千个线程还有点卡于是要等更长时间。（咳，所以越贵的服务器配置高，线程能够开得多，运行速度快，处理多人请求的能力就很牛），于是这几千人用了这个系统之后，心中大骂日了狗了哦，下次再也不用这个鬼系统了。 &lt;/p&gt;
&lt;p&gt;　　那假如是异步任务：还是用订单/库存系统举例，几千人都在买买买，一时间几千个订单请求到controller，然后调用service（注：service还是跟上面一样要几十秒），一到service，判断是个异步方法，于是赶紧让处理异步任务的线程过来慢慢处理就好，controller可以直接响应用户“订单成功”。用户极短时间就收到响应，于是可以继续买买买。&lt;/p&gt;
&lt;p&gt;　　这里就要说个东西，那个处理异步方法的线程哪里来的啊？其实是从异步方法线程池里拿的。大家应该知道连接池啊，是处理与数据库连接问题的，还能设置个数，最大超时时间等等，还能防止频繁的销毁创建线程的资源消耗。这里的线程池也差不多，可以设置个数啊什么的。。。。后面我们就会试试简单的配置一个连接池专门处理异步任务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.简单使用异步任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个简单的springboot项目，web模块+1.5.xx版本。&lt;/p&gt;
&lt;p&gt;　　简单写个controller和一个处理逻辑的类,先看看同步处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206121257307-1544356974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206121511516-1668937582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ok,你可以测试一下，等5秒钟浏览器才会响应，emmm...玛德，等得真烦。。。&lt;/p&gt;

&lt;p&gt;　　测试异步处理，加两个注解就ok了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206122225437-1586699928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206122311375-124799669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后这次就能不超过一秒钟，就返回响应成功了，你们也可以自己用&lt;span class=&quot;typ&quot;&gt;System&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;currentTimeMillis&lt;span class=&quot;pun&quot;&gt;()这个方法去测测时间，这里就不多说了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　这里就需要考虑了，假如访问量很多，每个请求都过来调用HelloTask方法，那就要拿到相应数量的处理异步的线程，来处理这个HelloTask方法！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　处理异步任务的线程也是属于服务器的线程啊，线程数太多服务器会很卡的，默认是有线程池的！但是我们根据自己项目的需求，于是要自定义线程池的一些配置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　假如线程池里就设置最多30个线程（这里也会有个类似RabbitMq的简单消息队列），那么即使几千人来调用HelloTask方法，那么最多也就拿到30个处理异步的线程，来处理这个方法；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;至于其他的那么多请求就丢到请求队列里，等这30个线程中某些率先处理完任务的线程就会从这消息队列中拿任务继续处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;3.自定义异步任务的线程池&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;刚刚查一下资料，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;其实也是可以用多线程来做的，只是每次都用多线程比较麻烦，不过小伙伴们可以试试。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;　　线程池就相当于包装了一下多线程的操作，做了很多配置！就类似ArrayList和Object数组的关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206134035635-1297449667.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　在下面方法打印当前线程（注意，这里注解@Async（“自己配置的线程池的名字”），这里可以指定配置的哪个线程池，可以自己试试，我们这里要写应该是taskExecutor）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206134159673-815422691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;然后运行，打开浏览器，疯狂刷新，控制台打印如下；（注意：可以把线程池中线程数目弄少一点，把sleep时间调整短一点，就能明显看到线程不会按顺序使用了，而是随机的！这个自己可以测试一下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206135759963-1782828551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.给异步方法设置返回值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　  &lt;/strong&gt;&lt;/span&gt;前面说的都是异步方法返回值为void的情况，但是有的时候我们要拿到异步方法的返回值。&lt;/p&gt;
&lt;p&gt;　　这个逻辑是怎么回事呢？有了返回值还能异步吗？答案是可以的。&lt;/p&gt;
&lt;p&gt;　　举个例子，当请求到controller，线程就会去执行controller方法，碰到了要执行一个异步方法，于是异步方法立马返回一个Future对象敷衍controller一下（玛德，controller真是老实人...），然后继续执行controller后面的方法，不会停顿；&lt;/p&gt;
&lt;p&gt;　　这个Future就是异步方法的返回值，只是刚开始还没有数据，等异步方法执行完毕，自动的就会将数据放入Future，比较常见的是利用Future来捕获异常。&lt;/p&gt;
&lt;p&gt;　　其中，Future是个接口，实现类是AsyncResult，下面就看看修改后的controller：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206150245467-1680751815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　再看看异步方法内部代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206150620679-1747798238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　ok，可以了，运行应用，测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206150816162-1310360226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　简单的看了看异步任务的用法，应该还是比较容易的，用起来也没什么难度，就是真实项目碰到的情况可能就会很复杂，要考虑的情况比较多了。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 07:27:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>本来想说说检索的，不过不知道什么鬼，下载ElasticSearch太慢了，还是放一下，后面有机会再补上！今天就说个简单的东西，来说说任务。 什么叫做任务呢？其实就是类中实现了一个什么功能的方法。常见的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10076949.html</dc:identifier>
</item>
<item>
<title>树的遍历--树的广度遍历（层次遍历），深度遍历（前序遍历，中序遍历，后序遍历的递归和非递归实现） - lgp20151222</title>
<link>http://www.cnblogs.com/ydymz/p/10076891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydymz/p/10076891.html</guid>
<description>&lt;p&gt;由于本人的码云太多太乱了，于是决定一个一个的整合到一个springboot项目里面。&lt;/p&gt;
&lt;p&gt;附上自己的github项目地址 &lt;a href=&quot;https://github.com/247292980/spring-boot&quot; target=&quot;_blank&quot;&gt;https://github.com/247292980/spring-boot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;附上汇总博文地址 &lt;a href=&quot;https://www.cnblogs.com/ydymz/p/9391653.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ydymz/p/9391653.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以整合功能&lt;/p&gt;
&lt;p&gt;spring-boot，FusionChart，thymeleaf，vue，ShardingJdbc，mybatis-generator，微信分享授权，drools，spring-security，spring-jpa，webjars，Aspect，drools-drt，rabbitmq，zookeeper，mongodb，mysql存储过程，前端的延迟加载，netty，postgresql&lt;/p&gt;

&lt;p&gt;这次就来整合下 树的遍历&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没什么难的&lt;/span&gt;看了一上午，看完发现，真说出来我的理解，也不是你们的理解方式，所以这篇全代码好了。&lt;/p&gt;
&lt;p&gt;递归很好理解就是非递归...debug几次，细心点就好了&lt;/p&gt;

&lt;p&gt;ps.&lt;/p&gt;
&lt;p&gt;广度遍历叫层次遍历，一层一层的来就简单了。&lt;/p&gt;
&lt;p&gt;前序遍历，中序遍历，后序遍历的区别就是根在前（根左右），根在中（左根右），根在后（左右根）&lt;/p&gt;
&lt;p&gt;在最后补全所有源码&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;广度优先遍历 &lt;span&gt;层次遍历 &lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelIterator(TreeNode n) {
        Queue&lt;/span&gt;&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        queue.offer(n);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;queue.isEmpty()) {
            TreeNode t &lt;/span&gt;=&lt;span&gt; queue.poll();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                visted(t);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.leftChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                queue.offer(t.leftChild);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.rightChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                queue.offer(t.rightChild);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            visted(subTree);
            preOrder(subTree.leftChild);
            preOrder(subTree.rightChild);
        }
    }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序遍历的非递归实现  &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nonRecPreOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; || stack.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                visted(node);
                stack.push(node);
                node &lt;/span&gt;=&lt;span&gt; node.leftChild;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stack.size() &amp;gt; 0&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; stack.pop();
                node &lt;/span&gt;=&lt;span&gt; node.rightChild;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            inOrder(subTree.leftChild);
            visted(subTree);
            inOrder(subTree.rightChild);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历的非递归实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nonRecInOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; || stack.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在左子树&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(node);
                node &lt;/span&gt;=&lt;span&gt; node.leftChild;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈非空&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (stack.size() &amp;gt; 0&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; stack.pop();
                visted(node);
                node &lt;/span&gt;=&lt;span&gt; node.rightChild;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后续遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            postOrder(subTree.leftChild);
            postOrder(subTree.rightChild);
            visted(subTree);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后序遍历的非递归实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; noRecPostOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树入栈&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (; p.leftChild != &lt;span&gt;null&lt;/span&gt;; p =&lt;span&gt; p.leftChild) {
                stack.push(p);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点无右子树或右子树已经输出&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (p.rightChild == &lt;span&gt;null&lt;/span&gt; || p.rightChild ==&lt;span&gt; node)) {
                visted(p);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纪录上一个已输出结点&lt;/span&gt;
                node =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack.empty()) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                p &lt;/span&gt;=&lt;span&gt; stack.pop();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理右子树&lt;/span&gt;
&lt;span&gt;            stack.push(p);
            p &lt;/span&gt;=&lt;span&gt; p.rightChild;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TreeNode {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String data;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode leftChild;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode rightChild;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isVisted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key, String data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; TreeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key, String data, TreeNode leftChild, TreeNode rightChild) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.leftChild =&lt;span&gt; leftChild;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rightChild =&lt;span&gt; rightChild;
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinaryTree {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; TreeNode root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BinaryTree() {
        root &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(1, &quot;rootNode(A)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建一棵二叉树
     *           A
     *     B          C
     *  D     E            F
     *      X    M   N
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; root
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createBinTree(TreeNode root) {
        TreeNode newNodeB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(2, &quot;B&quot;&lt;span&gt;);
        TreeNode newNodeC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(3, &quot;C&quot;&lt;span&gt;);
        TreeNode newNodeD &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(4, &quot;D&quot;&lt;span&gt;);
        TreeNode newNodeE &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(5, &quot;E&quot;&lt;span&gt;);
        TreeNode newNodeF &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(6, &quot;F&quot;&lt;span&gt;);
        root.leftChild &lt;/span&gt;=&lt;span&gt; newNodeB;
        root.rightChild &lt;/span&gt;=&lt;span&gt; newNodeC;
        root.leftChild.leftChild &lt;/span&gt;=&lt;span&gt; newNodeD;
        root.leftChild.rightChild &lt;/span&gt;=&lt;span&gt; newNodeE;
        root.rightChild.rightChild &lt;/span&gt;=&lt;span&gt; newNodeF;
        root.leftChild.rightChild.leftChild &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(7, &quot;M&quot;&lt;span&gt;);
        root.leftChild.rightChild.rightChild &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(8, &quot;N&quot;&lt;span&gt;);

        root.leftChild.leftChild.rightChild &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TreeNode(9, &quot;X&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;树的高度&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; height(root);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点个数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size(root);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归结束：空树高度为0&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; height(subTree.leftChild);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; height(subTree.rightChild);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (i &amp;lt; j) ? (j + 1) : (i + 1&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1 +&lt;span&gt; size(subTree.leftChild)
                    &lt;/span&gt;+&lt;span&gt; size(subTree.rightChild);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回双亲结点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode parent(TreeNode element) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root == element) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : parent(root, element);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode parent(TreeNode subTree, TreeNode element) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree.leftChild == element || subTree.rightChild ==&lt;span&gt; element) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回父结点地址&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; subTree;
        }
        TreeNode p;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在左子树中找，如果左子树中没有找到，才到右子树去找&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((p = parent(subTree.leftChild, element)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归在左子树中搜索&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归在右子树中搜索&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent(subTree.rightChild, element);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode getLeftChildNode(TreeNode element) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (element != &lt;span&gt;null&lt;/span&gt;) ? element.leftChild : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode getRightChildNode(TreeNode element) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (element != &lt;span&gt;null&lt;/span&gt;) ? element.rightChild : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeNode getRoot() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在释放某个结点时，该结点的左右子树都已经释放，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以应该采用后续遍历，当访问某个结点时将该结点的存储空间释放&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除根为subTree的子树&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除左子树&lt;/span&gt;
&lt;span&gt;            destroy(subTree.leftChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除右子树&lt;/span&gt;
&lt;span&gt;            destroy(subTree.rightChild);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除根结点&lt;/span&gt;
            subTree = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visted(TreeNode subTree) {
        subTree.isVisted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;key:&quot; + subTree.key + &quot;--name:&quot; +&lt;span&gt; subTree.data);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            visted(subTree);
            preOrder(subTree.leftChild);
            preOrder(subTree.rightChild);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; inOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            inOrder(subTree.leftChild);
            visted(subTree);
            inOrder(subTree.rightChild);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后续遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postOrder(TreeNode subTree) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (subTree != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            postOrder(subTree.leftChild);
            postOrder(subTree.rightChild);
            visted(subTree);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序遍历的非递归实现  ABDXEMNCF&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nonRecPreOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; || stack.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                visted(node);
                stack.push(node);
                node &lt;/span&gt;=&lt;span&gt; node.leftChild;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stack.size() &amp;gt; 0&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; stack.pop();
                node &lt;/span&gt;=&lt;span&gt; node.rightChild;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历的非递归实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nonRecInOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; || stack.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在左子树&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(node);
                node &lt;/span&gt;=&lt;span&gt; node.leftChild;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈非空&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (stack.size() &amp;gt; 0&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; stack.pop();
                visted(node);
                node &lt;/span&gt;=&lt;span&gt; node.rightChild;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后序遍历的非递归实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; noRecPostOrder(TreeNode p) {
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        TreeNode node &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树入栈&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (; p.leftChild != &lt;span&gt;null&lt;/span&gt;; p =&lt;span&gt; p.leftChild) {
                stack.push(p);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点无右子树或右子树已经输出&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (p.rightChild == &lt;span&gt;null&lt;/span&gt; || p.rightChild ==&lt;span&gt; node)) {
                visted(p);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纪录上一个已输出结点&lt;/span&gt;
                node =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack.empty()) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                p &lt;/span&gt;=&lt;span&gt; stack.pop();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理右子树&lt;/span&gt;
&lt;span&gt;            stack.push(p);
            p &lt;/span&gt;=&lt;span&gt; p.rightChild;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;层次遍历 广度优先遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; levelIterator(TreeNode n) {
        Queue&lt;/span&gt;&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        queue.offer(n);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;queue.isEmpty()) {
            TreeNode t &lt;/span&gt;=&lt;span&gt; queue.poll();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                visted(t);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.leftChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                queue.offer(t.leftChild);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.rightChild != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                queue.offer(t.rightChild);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        BinaryTree bt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryTree();
        bt.createBinTree(bt.root);
        System.out.println(&lt;/span&gt;&quot;the size of the tree is &quot; +&lt;span&gt; bt.size());
        System.out.println(&lt;/span&gt;&quot;the height of the tree is &quot; +&lt;span&gt; bt.height());

        System.out.println(&lt;/span&gt;&quot;*******(前序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.preOrder(bt.root);

        System.out.println(&lt;/span&gt;&quot;*******(中序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.inOrder(bt.root);

        System.out.println(&lt;/span&gt;&quot;*******(后序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.postOrder(bt.root);

        System.out.println(&lt;/span&gt;&quot;层次遍历*****************&quot;&lt;span&gt;);
        bt.levelIterator(bt.root);

        System.out.println(&lt;/span&gt;&quot;***非递归实现****(前序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.nonRecPreOrder(bt.root);

        System.out.println(&lt;/span&gt;&quot;***非递归实现****(中序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.nonRecInOrder(bt.root);

        System.out.println(&lt;/span&gt;&quot;***非递归实现****(后序遍历)遍历*****************&quot;&lt;span&gt;);
        bt.noRecPostOrder(bt.root);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 06 Dec 2018 07:20:00 +0000</pubDate>
<dc:creator>lgp20151222</dc:creator>
<og:description>一 由于本人的码云太多太乱了，于是决定一个一个的整合到一个springboot项目里面。 附上自己的github项目地址 https://github.com/247292980/spring-boo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydymz/p/10076891.html</dc:identifier>
</item>
<item>
<title>写于2018年底，有点丧 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4615676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4615676.html</guid>
<description>&lt;p&gt;　　致敬那些漂泊在外的外来务工者，你们是一群有梦想的人！&lt;/p&gt;
&lt;h2&gt;1 现状&lt;/h2&gt;
&lt;p&gt;　　本人沪漂一族，有次坐高铁去杭州，由于没有买到有座位的车票了，想着路途不远，就买了站票。后来站累了，我发现一节特别的车厢有很多空的座位，看起来很豪华，很舒服的样子，我没多想，就径直坐了上去。坐了不一会儿，来了位美女乘务员查票，把我赶了出去，原来，这TMD的是商务座。在众人的注视下，我悻悻地走出车厢，默默感概，人生艰辛，生活所累，不得自由，连TMD的出行工具都分三六九等。&lt;/p&gt;
&lt;p&gt;　　我不喜欢怨天尤人，我对未来抱有最大的期望。在老婆深夜回家，累到哭泣时，我安慰她说，未来是美好的，我们还年轻，奋斗使得人生更有意义。当老爸累得腰疼，卧床不起，只能趴在床上吃饭时，我感到莫名的心酸，我对老爸说：“爸，看到你这个样子，我心理难受，我不想让你这么拼命地挣钱，这段时间你好好修养身体；我长大了，你不用这么拼了。”当爷爷担心医药费、住院费太贵，自己拔掉药瓶，执意要回家时，我已无力劝阻，毕竟大伯、叔叔和我爸都阻止不了，我能奈何？&lt;/p&gt;
&lt;p&gt;　　这世上，还有比生病更可怕的病，那恐怕就只有穷病了。钱这个东西，生不带来，死不带走，但是，它能让你活的更自由；在生病的时候，它让你更有尊严。&lt;/p&gt;
&lt;h2&gt;2 启蒙&lt;/h2&gt;
&lt;p&gt;　　当一个农村人，来到上海工作，他会发现上海的繁华；当他想买房时，他会发现自己的贫穷。这或许是低阶层的人，第一次意识到阶层的存在。&lt;/p&gt;
&lt;p&gt;　　很多人不愿承认，却能切身感受到阶层这个无形的壁垒。社会分阶层，阶层是无形的、看不见的，却是真实存在的。比如，买东西，我考虑的是实用，他考虑的是享受；花钱，我考虑的是性价比，他考虑的是心情等。比如，我举全家之力，只能买套老破小，他说怎么也得买套1000万的房子吧？比如，在2018年国庆节过后，个税起征点上浮到5000，我说工资多了好几百呢，可以买套衣服穿了，他说，几百的衣服能穿吗？我被雷的外焦里嫩，我能说什么呢？&lt;/p&gt;
&lt;p&gt;　　阶层就是这样，你看不见，不代表不存在。正常情况下，财富是几代人积累起来的，高阶层的人，财富积累的速度快的惊人。在我爷爷还在务农耕田时，他爷爷已经是个富翁了。我们本来是两个世界的人，却相遇到同一个空间，差距高低立判。想要追赶，你会发现：蜀道难，难于上青天。&lt;/p&gt;
&lt;h2&gt;3 反思&lt;/h2&gt;
&lt;p&gt;　　“自己的人生，别人定了规则，自己还不知”，这无疑是一种荒诞的困境。关于一个国家的地区之间的贫富差距，我创建了一个模型来解释：总的来说，贫富差距是由两次剥削来扩大的。&lt;/p&gt;
&lt;p&gt;　　第一次剥削：货币增发。货币是凭空出现的，是国家开动印钞机日夜不停地制造出来的，国家拿着这些钱到地方A修建公共基础设置、建设工厂，而地方B没有拿到国家的任何投资。国家投资的结果是地方A的居民坐收国家经济发展的红利，经济收入增加；而地方B的经济基本上是停滞的，居民收入增加十分缓慢。由于国家总的货币量是不停增长的，地方A的居民收入增加的快，地方B的居民收入增加的缓慢，此消彼长，使得地方B的居民受到国家的第一次剥削。&lt;/p&gt;
&lt;p&gt;　　第二次剥削：同税负。国家利用宪法赋予的权力向全国人民征税，对来自贫困地区B的居民来说，虽然家境不好，家底薄，收入低，但是，还要负担和来自富裕地区A居民同样的税负，这无疑是对地区B的居民的第二次剥削。&lt;/p&gt;
&lt;p&gt;　　而财富一旦聚集到富人手里，就会世袭下去，那些先富裕的人，具有先入优势，接受更好的&lt;span&gt;&lt;strong&gt;教育&lt;/strong&gt;&lt;/span&gt;（关键点），进而任职更好的工作岗位，拿更高的薪水，富人永远是富人，这就是阶层。阶层天生流动性不足，阶层的结构一旦完成，就会固化，向上的通道很窄，寒门难出贵子。你可能会问，既然阶层固化，那我们即使上不去，保持现状总可以吧。不好意思，阶层还有向下的快速通道，永久大开，想要保持阶层不变，也需要付出很大的努力，或许，正因为如此，那些比你有钱的人，还比你更努力。&lt;/p&gt;
&lt;p&gt;　　既然国家有如此大的能量，优先分配资源的地方，必定先富裕起来，个人只有跟随国家的脚步，国家让你干什么，你就干什么，顺势而为，坐收国家经济发展的红利，才能更容易实现阶层的跃迁。在风口，猪也能起飞。例如，当下国家搞基建，是为了刺激经济，促进经济增长，那你就要知道，投资水泥、钢铁、运输、挖掘机等不会亏。当国家说，银行贷款降息，房贷降息，你就要知道，余额宝利息要降低了，借钱的成本更低了；房价要涨了，必须买房了；买完房，要还债，那就好好干活去吧。&lt;/p&gt;
&lt;p&gt;　　这个世界还是相对公平的，个人经过努力是可以实现阶层跃迁的。&lt;/p&gt;
&lt;p&gt;　　阶层向上的通道虽然很窄，但不是没有。理论上，一旦你有了最初的财富积累，那你财富积累的过程就会加快，这就是马太效应，使得富人更富，穷人更穷。古人云，天道酬勤，是非常有道理的，勤奋使得你能比同龄人更快挣得人生的第一桶金，而马太效应对于成功是一个正向的循环，先入优势会放大奋斗者的成功，使成功者更容易获得财富和地位。　&lt;/p&gt;
&lt;p&gt;　　曾经有一个非常NB的人说过，为什么我要努力奋斗，因为，财富与我而言，是为了拥有更多的试错机会。为了更自由，fight！&lt;/p&gt;
&lt;h2&gt;4 希望&lt;/h2&gt;
&lt;p&gt;　　有次，问老婆一个问题：为什么司马懿笑到最后？她开玩笑地说：司马懿聪明比不过诸葛亮，权术比不过曹操，但是，司马懿长寿啊。&lt;/p&gt;
&lt;p&gt;　　看透了，不要自怨自艾，自己的本钱只有自己，锻炼身体，专注于自己的本职工作，把主要精力放在本职业务上，提升自己的核心竞争力，投资自己，收益才是最大的。&lt;/p&gt;
&lt;p&gt;　　....&lt;/p&gt;
&lt;p&gt;　　我深感自己的渺小，智商的不足，能做的就只有努力学习和奋斗，梦想着有一天可以改变现状，让父母和老婆能过上幸福的日子，不敢奢求富裕，只求健健康康、快快乐乐，足矣。&lt;/p&gt;


&lt;p&gt;重读了麦子的《我奋斗了18年才和你坐在一起喝咖啡》，深刻感受到教育的重要性，这种直击内心的文字，催人泪下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;　　来到上海这个大都市，我发现与我的同学相比我真是土得掉渣。我不会作画，不会演奏乐器，不认识港台明星，没看过武侠小说，不认得MP3，不知道什么是walkman，为了弄明白营销管理课上讲的“仓储式超市”的概念，我在“麦德隆”好奇地看了一天，我从来没见过如此丰富的商品。&lt;/p&gt;
&lt;p&gt;　　我没摸过计算机，为此我花了半年时间泡在学校机房里学习你在中学里就学会的基础知识和操作技能。我的英语是聋子英语、哑巴英语，我的发音中国人和外国人都听不懂，这也不能怪我，我们家乡没有外教，老师自己都读不准，怎么可能教会学生如何正确发音？基础没打好，我只能再花一年时间矫正我的发音。我真的很羡慕大城市的同学多才多艺，知识面那么广，而我只会读书，我的学生时代只有学习、考试、升学，因为只有考上大学，我才能来到你们中间，才能与你们一起学习，所有的一切都必须服从这个目标。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bbs.tianya.cn/post-free-5292992-1.shtml&quot; target=&quot;_blank&quot;&gt;揭露社会运行最大的秘密——让我们认识真正的世界&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 07:19:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>致敬那些漂泊在外的外来务工者，你们是一群有梦想的人！ 1 现状 本人沪漂一族，有次坐高铁去杭州，由于没有买到有座位的车票了，想着路途不远，就买了站票。后来站累了，我发现一节特别的车厢有很多空的座位，看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4615676.html</dc:identifier>
</item>
<item>
<title>30分钟学会前端模块化开发 - 张果</title>
<link>http://www.cnblogs.com/best/p/10076782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/best/p/10076782.html</guid>
<description>&lt;p&gt;早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181128162655341-2033851678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前端模块化规范如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204155136389-1035561659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.1、模块概要&lt;/h2&gt;
&lt;p&gt;JavaScript在早期的设计中就没有模块、包、类的概念，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;模块化开发的四点好处：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）、 避免变量污染，命名冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）、提高代码复用率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（3）、提高了可维护性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（4）、方便依赖关系管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了避免缺少模块带来的问题，我们可以看看程序员应对的历程：&lt;/p&gt;
&lt;h2&gt;1.2、函数封装&lt;/h2&gt;
&lt;p&gt;我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数1&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn1(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;statement&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数2&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;statement&lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在需要的以后夹在函数所在文件，调用函数就可以了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3、对象封装&lt;/h2&gt;
&lt;p&gt;为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myModule =&lt;span&gt; {
var1: &lt;/span&gt;1&lt;span&gt;,

var2: &lt;/span&gt;2&lt;span&gt;,

fn1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

},

fn2: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们在希望调用模块的时候引用对应文件，然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
myModule.fn2();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺陷：外部可以随意修改内部成员，这样就会产生意外的安全问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
myModel.var1 = 100;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;1.4、立即执行函数表达式（IIFE）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;可以通过立即执行函数表达式（IIFE），来达到隐藏细节的目的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myModule = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; var1 = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; var2 = 2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn1(){

}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2(){

}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
fn1: fn1,
fn2: fn2
};
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在模块外部无法修改我们没有暴露出来的变量、函数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：功能相对较弱，封装过程增加了工作量、仍会导致命名空间污染可能、闭包是有成本的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。&lt;/p&gt;
&lt;p&gt;后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery.artDialog.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;main.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;app1.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;app2.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;app3.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。&lt;/p&gt;
&lt;p&gt;对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。&lt;/p&gt;
&lt;p&gt;依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.5、模块化规范&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;常见的的JavaScript模块规范有：CommonJS、AMD、CMD、UMD、原生模块化&lt;/p&gt;
&lt;h3&gt;1.5.1、CommonJS&lt;/h3&gt;
&lt;p&gt;CommonJs 是服务器端模块的规范，Node.js采用了这个规范。&lt;/p&gt;
&lt;p&gt;根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; foobar.js&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有变量&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; test = 123&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有方法&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foobar () {

&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.foo = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do someing ...&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bar = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do someing ...&lt;/span&gt;
&lt;span&gt;}
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;exports对象上的方法和变量是公有的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; foobar = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; foobar();
exports.foobar &lt;/span&gt;=&lt;span&gt; foobar;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;require方法默认读取js文件，所以可以省略js后缀&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; test = require('./foobar'&lt;span&gt;).foobar;

test.bar();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。&lt;/p&gt;
&lt;h3&gt;1.5.2、AMD((Asynchromous Module Definition) 异步模块定义&lt;/h3&gt;
&lt;p&gt;AMD 是 RequireJS 在推广过程中对模块定义的规范化产出&lt;/p&gt;
&lt;p&gt;AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。&lt;/p&gt;
&lt;p&gt;适用AMD规范适用define方法定义模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过数组引入依赖 ，回调函数通过形参传入依赖&lt;/span&gt;
define(['someModule1', ‘someModule2’], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (someModule1, someModule2) {

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/ someing&lt;/span&gt;
&lt;span&gt;someModule1.test();
}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {foo: foo}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AMD规范允许输出模块兼容CommonJS规范，这时define方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require, exports, module) {

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reqModule = require(&quot;./someModule&quot;&lt;span&gt;);
requModule.test();

exports.asplode &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;someing&lt;/span&gt;
&lt;span&gt;}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.5.3、CMD（Common Module Definition）通用模块定义&lt;/h3&gt;
&lt;p&gt;CMD是SeaJS 在推广过程中对模块定义的规范化产出&lt;/p&gt;
&lt;p&gt;CMD和AMD的区别有以下几点：&lt;/p&gt;
&lt;p&gt;1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。&lt;/p&gt;
&lt;p&gt;2.CMD推崇依赖就近，AMD推崇依赖前置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AMD&lt;/span&gt;
define(['./a','./b'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a, b) {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依赖一开始就写好&lt;/span&gt;
&lt;span&gt;a.test();
b.test();
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (requie, exports, module) {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依赖可以就近书写&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = require('./a'&lt;span&gt;);
a.test();

...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;软依赖&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (status) {

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = requie('./b'&lt;span&gt;);
b.test();
}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。&lt;/p&gt;
&lt;p&gt;3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。&lt;/p&gt;
&lt;p&gt;SeaJS 和 RequireJS的主要区别 在此有解释&lt;/p&gt;
&lt;h3&gt;1.5.4、UMD&lt;/h3&gt;
&lt;p&gt;UMD是AMD和CommonJS的综合产物。&lt;/p&gt;
&lt;p&gt;AMD 浏览器第一的原则发展 异步加载模块。&lt;/p&gt;
&lt;p&gt;CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。&lt;/p&gt;
&lt;p&gt;这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。&lt;/p&gt;
&lt;p&gt;UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。&lt;/p&gt;
&lt;p&gt;在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (window, factory) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; exports === 'object'&lt;span&gt;) {

module.exports &lt;/span&gt;=&lt;span&gt; factory();
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; define === 'function' &amp;amp;&amp;amp;&lt;span&gt; define.amd) {

define(factory);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

window.eventUtil &lt;/span&gt;=&lt;span&gt; factory();
}
})(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;module ...&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.5.5、原生JS模块化（Native JS）&lt;/h3&gt;
&lt;p&gt;上述的模块都不是原生 JavaScript 模块。它们只不过是我们用模块模式（module pattern）、CommonJS 或 AMD 模仿的模块系统。&lt;/p&gt;&lt;p&gt;JavaScript标准制定者在 TC39（该标准定义了 ECMAScript 的语法与语义）已经为 ECMAScript 6（ES6）引入内置的模块系统了。&lt;/p&gt;&lt;p&gt;ES6 为导入（importing）导出（exporting）模块带来了很多可能性。下面是很好的资源：&lt;/p&gt;
&lt;p&gt;http://jsmodules.io/&lt;/p&gt;
&lt;p&gt;http://exploringjs.com/&lt;/p&gt;&lt;p&gt;相对于 CommonJS 或 AMD，ES6 模块如何设法提供两全其美的实现方案：简洁紧凑的声明式语法和异步加载，另外能更好地支持循环依赖。&lt;/p&gt;
&lt;h3&gt;1.5.6、小结&lt;/h3&gt;
&lt;p&gt;AMD（异步模块定义） 是 RequireJS 在推广过程中对模块定义的规范化产出，CMD（通用模块定义）是SeaJS 在推广过程中被广泛认知。RequireJs出自dojo加载器的作者James Burke，SeaJs出自国内前端大师玉伯。&lt;/p&gt;
&lt;p&gt;两者的区别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;RequireJS 和 SeaJS 都是很不错的模块加载器，两者区别如下：

&lt;/span&gt;1. 两者定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino /&lt;span&gt; Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端

&lt;/span&gt;2. 两者遵循的标准有差异。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者 API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。

3&lt;span&gt;. 两者社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，而采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。

&lt;/span&gt;4&lt;span&gt;. 两者代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。

&lt;/span&gt;5&lt;span&gt;. 两者对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便便捷。RequireJS 无这方面的支持。

&lt;/span&gt;6. 两者的插件机制有差异。RequireJS 采取的是在源码中预留接口的形式，源码中留有为插件而写的代码。SeaJS 采取的插件机制则与 Node 的方式一致：开放自身，让插件开发者可直接访问或修改，从而非常灵活，可以实现各种类型的插件。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端NodeJS中，前端的webpack也是对CommonJS原生支持的。&lt;/p&gt;
&lt;p&gt;根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。&lt;/p&gt;
&lt;p&gt;CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。&lt;/p&gt;
&lt;p&gt;CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。&lt;/p&gt;
&lt;p&gt;2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志&quot;Javascript模块化编程&quot;正式诞生。因为老实说，在浏览器环境下，以前没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;require()用来引入外部模块；&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;exports对象用于导出当前模块的方法或变量，唯一的导出口；&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;module对象就代表模块本身。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nodejs的模块是基于CommonJS规范实现的，通过转换也可以运行在浏览器端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130104503977-688996773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;1、所有代码都运行在模块作用域，不会污染全局作用域。&lt;/p&gt;
&lt;p&gt;2、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。&lt;/p&gt;
&lt;p&gt;3、模块加载的顺序，按照其在代码中出现的顺序。&lt;/p&gt;
&lt;h2&gt;2.1、NodeJS中使用CommonJS模块管理&lt;/h2&gt;
&lt;p&gt;1、模块定义&lt;/p&gt;
&lt;p&gt;根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。&lt;/p&gt;
&lt;p&gt;模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。&lt;/p&gt;
&lt;p&gt;mathLib.js模块定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; message=&quot;Hello CommonJS!&quot;&lt;span&gt;;

module.exports.message&lt;/span&gt;=&lt;span&gt;message;
module.exports.add&lt;/span&gt;=(m,n)=&amp;gt;console.log(m+n);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、模块依赖&lt;/p&gt;
&lt;p&gt;加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象。&lt;/p&gt;
&lt;p&gt;myApp.js 模块依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; math=require('./mathLib'&lt;span&gt;);
console.log(math.message);
math.add(&lt;/span&gt;333,888);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、测试运行&lt;/p&gt;
&lt;p&gt;安装好node.JS&lt;/p&gt;
&lt;p&gt;打开控制台，可以使用cmd命令，也可以直接在开发工具中访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130142600744-662580048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130142621586-1528715093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2、在浏览器中使用CommonJS 模块管理&lt;/h2&gt;
&lt;p&gt;由于浏览器不支持 CommonJS 格式。要想让浏览器用上这些模块，必须转换格式。浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量（module、exports、require、global）。只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; math = require('math'&lt;span&gt;);
math.add(&lt;/span&gt;2, 3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二行math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态&lt;/p&gt;
&lt;p&gt;而browserify这样的一个工具，可以把nodejs的模块编译成浏览器可用的模块，解决上面提到的问题。本文将详细介绍Browserify实现Browserify是目前最常用的CommonJS格式转换的工具&lt;/p&gt;
&lt;p&gt;请看一个例子，b.js模块加载a.js模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.js&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 100&lt;span&gt;;
module.exports.a &lt;/span&gt;=&lt;span&gt; a;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; b.js&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; result = require('./a'&lt;span&gt;);
console.log(result.a);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html直接引用b.js会报错，提示require没有被定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130150607414-963416567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;//index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;myApp_01.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，就要使用Browserify了&lt;/p&gt;
&lt;p&gt;【安装】&lt;/p&gt;
&lt;p&gt;使用下列命令安装browserify&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt; -g browserify
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【转换】&lt;/p&gt;
&lt;p&gt;使用下面的命令，就能将b.js转为浏览器可用的格式bb.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ browserify myApp.js &amp;gt; myApp_01.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转换结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130152629008-1057924332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看myapp_01.js，browserify将mathLib.js和myApp.js这两个文件打包为MyApp01.js，使其在浏览器端可以运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; r(e, n, t) {
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; o(i, f) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;n[i]) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;e[i]) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &quot;function&quot; == &lt;span&gt;typeof&lt;/span&gt; require &amp;amp;&amp;amp;&lt;span&gt; require;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!f &amp;amp;&amp;amp; c) &lt;span&gt;return&lt;/span&gt; c(i, !0&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (u) &lt;span&gt;return&lt;/span&gt; u(i, !0&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; Error(&quot;Cannot find module '&quot; + i + &quot;'&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; a.code = &quot;MODULE_NOT_FOUND&quot;&lt;span&gt;, a
                }
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = n[i] =&lt;span&gt; {exports: {}};
                e[i][&lt;/span&gt;0].call(p.exports, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (r) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n = e[i][1&lt;span&gt;][r];
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; o(n ||&lt;span&gt; r)
                }, p, p.exports, r, e, n, t)
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n[i].exports
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; u = &quot;function&quot; == &lt;span&gt;typeof&lt;/span&gt; require &amp;amp;&amp;amp; require, i = 0; i &amp;lt; t.length; i++&lt;span&gt;) o(t[i]);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
})()({
    &lt;/span&gt;1: [&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require, module, exports) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = &quot;Hello CommonJS!&quot;&lt;span&gt;;

        module.exports.message &lt;/span&gt;=&lt;span&gt; message;
        module.exports.add &lt;/span&gt;= (m, n) =&amp;gt; console.log(m +&lt;span&gt; n);


    }, {}], &lt;/span&gt;2: [&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require, module, exports) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; math = require('./mathLib'&lt;span&gt;);
        console.log(math.message);
        math.add(&lt;/span&gt;333, 888&lt;span&gt;);
    }, {&lt;/span&gt;&quot;./mathLib&quot;: 1&lt;span&gt;}]
}, {}, [&lt;/span&gt;2]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html引用bb.js，控制台显示100&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//index.html
&lt;/span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bb.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201811/63651-20181130152701002-933600914.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。&lt;/p&gt;


&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不太适用于浏览器端。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;3.1、概要&lt;/h2&gt;
&lt;p&gt;CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。&lt;/p&gt;
&lt;h2&gt;3.1、require.js&lt;/h2&gt;
&lt;p&gt;Asynchronous Module Definition，中文名是异步模块定义。它是一个在浏览器端模块化开发的规范，由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。Asynchronous Module Definition，中文名是异步模块。它是一个在浏览器端模块化开发的规范，由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.requirejs.cn&quot; target=&quot;_blank&quot;&gt;http://www.requirejs.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;requireJS主要解决两个问题：&lt;/p&gt;
&lt;p&gt;1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。&lt;/p&gt;
&lt;p&gt;2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
//定义模块&lt;br/&gt;define(['dependency'],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'foo'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; printName(){
        console.log(name);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        printName:printName
    }

})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载模块&lt;/span&gt;
&lt;span&gt;
require([&lt;/span&gt;'myModule'],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(my){
    my.printName();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;AMD标准中，定义了下面两个API：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.require([module], callback)

2. define(id, [depends], callback)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。&lt;/p&gt;
&lt;p&gt;requireJS定义了一个函数define，它是全局变量，用来定义模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;define(id,dependencies,factory)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;——id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）&lt;/p&gt;
&lt;p&gt;——dependencies 是一个当前模块用来的模块名称数组&lt;/p&gt;
&lt;p&gt;——factory 工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。&lt;/p&gt;
&lt;p&gt;在页面上使用require函数加载模块；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;require([dependencies], function(){});&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;require()函数接受两个参数：&lt;/p&gt;
&lt;p&gt;——第一个参数是一个数组，表示所依赖的模块；&lt;/p&gt;
&lt;p&gt;——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块&lt;/p&gt;
&lt;p&gt;定义alert模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; alertName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (str) {
alert(&lt;/span&gt;&quot;I am &quot; +&lt;span&gt; str);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; alertAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num) {
alert(&lt;/span&gt;&quot;I am &quot; + num + &quot; years old&quot;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
alertName: alertName,
alertAge: alertAge
};
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
require(['alert'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (alert) {
alert.alertName(&lt;/span&gt;'zhangsan'&lt;span&gt;);
alert.alertAge(&lt;/span&gt;21&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;适合在浏览器环境中异步加载模块。可以并行加载多个模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。&lt;/p&gt;
&lt;h2&gt;3.3、使用技巧&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;请记住使用requirejs的口诀：&lt;strong&gt;两函数一配置一属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.3.1、data-main属性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;requirejs需要一个根来作为搜索依赖的开始，data-main用来指定这个根。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;scripts/require.js&quot;&lt;/span&gt;&lt;span&gt; data-main&lt;/span&gt;&lt;span&gt;=&quot;scripts/app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就指定了根是app.js,只有直接或者间接与app.js有依赖关系的模块才会被插入到html中。&lt;/p&gt;
&lt;h3&gt;3.3.2、require.config() 配置&lt;/h3&gt;
&lt;p&gt;通过这个函数可以对requirejs进行灵活的配置，其参数为一个配置对象，配置项及含义如下：&lt;/p&gt;
&lt;p&gt;baseUrl——用于加载模块的根路径。&lt;/p&gt;
&lt;p&gt;paths——用于映射不存在根路径下面的模块路径。&lt;/p&gt;
&lt;p&gt;shims——配置在脚本/模块外面并没有使用RequireJS的函数依赖并且初始化函数。假设underscore并没有使用 RequireJS定义，但是你还是想通过RequireJS来使用它，那么你就需要在配置中把它定义为一个shim。&lt;/p&gt;
&lt;p&gt;deps——加载依赖关系数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;require.config({
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认情况下从这个文件开始拉去取资源&lt;/span&gt;
    baseUrl:'scripts/app'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果你的依赖模块以pb头，会从scripts/pb加载模块。&lt;/span&gt;
&lt;span&gt;    paths:{
        pb:&lt;/span&gt;'../pb'&lt;span&gt;
    },
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load backbone as a shim，所谓就是将没有采用requirejs方式定义&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;模块的东西转变为requirejs模块&lt;/span&gt;
&lt;span&gt;    shim:{
        &lt;/span&gt;'backbone'&lt;span&gt;:{
            deps:[&lt;/span&gt;'underscore'&lt;span&gt;],
            exports:&lt;/span&gt;'Backbone'&lt;span&gt;
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3.3、define()函数&lt;/h3&gt;
&lt;p&gt;该函数用于定义模块。形式如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;logger.js&lt;/span&gt;
define([&quot;a&quot;], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a) {
    &lt;/span&gt;'use strict'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; info() {
        console.log(&lt;/span&gt;&quot;我是私有函数&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        name:&lt;/span&gt;&quot;一个属性&quot;&lt;span&gt;,
        test:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a){
            console.log(a&lt;/span&gt;+&quot;你好！&quot;&lt;span&gt;);
            a.f();
            info();
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;define函数就受两个参数。&lt;/p&gt;
&lt;p&gt;* 第一个是一个字符串数组，表示你定义的模块依赖的模块，这里依赖模块a;&lt;/p&gt;
&lt;p&gt;* 第二个参数是一个函数，参数是注入前面依赖的模块，顺序同第一参数顺序。在函数中可做逻辑处理，通过return一个对象暴露模块的属性和方法，不在return中的可以认为是私有方法和私有属性。&lt;/p&gt;
&lt;h3&gt;3.3.4、require()函数&lt;/h3&gt;
&lt;p&gt;该函数用于调用定义好的模块，可以是用define函数定义的，也可以是一个shim。形式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.js&lt;/span&gt;
require(['logger'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (logger) {
    logger.test(&lt;/span&gt;&quot;tom&quot;&lt;span&gt;);
    console.log(logger.name);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;tom你好！&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;不确定（取决于a模块的f方法）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;我是私有函数&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;一个属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c8d5b954-b2b9-498f-a6c2-f40356ea3bc3')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_c8d5b954-b2b9-498f-a6c2-f40356ea3bc3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8d5b954-b2b9-498f-a6c2-f40356ea3bc3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c8d5b954-b2b9-498f-a6c2-f40356ea3bc3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8d5b954-b2b9-498f-a6c2-f40356ea3bc3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//index.html
&lt;/span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/require.js&quot;&lt;/span&gt;&lt;span&gt; data-main&lt;/span&gt;&lt;span&gt;=&quot;app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.js&lt;/span&gt;
&lt;span&gt;require.config({
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;By default load any module IDs from js/&lt;/span&gt;
&lt;span&gt;    baseUrl: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;except, if the module ID starts with &quot;pb&quot;&lt;/span&gt;
&lt;span&gt;    paths: {
        pb: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../pb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    },
    shim: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            deps:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;animalWorld&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use the global 'Backbone' as the module name.&lt;/span&gt;
&lt;span&gt;            exports: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        }
    }
});
require([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;], &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (cat,dog,world) {
    world.world();
    cat.say();
    dog.say();
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;animal.js&lt;/span&gt;
&lt;span&gt;define([], &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; _showName(name){
        console.log(name);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        say(words){
            console.log(words);
        },
        showName(name){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;练习私有方法&lt;/span&gt;
&lt;span&gt;            _showName(name);
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cat.js&lt;/span&gt;
&lt;span&gt;define([
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pb/animal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
], &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(animal) {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        say(){
            animal.say(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;喵喵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            animal.showName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;猫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dog.js&lt;/span&gt;
&lt;span&gt;define([
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pb/animal&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
], &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(animal) {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        say(){
            animal.say(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;汪汪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            animal.showName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;狗&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;animalWorld.js&lt;/span&gt;
&lt;span&gt;window.animal &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是动物世界！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
world.js

define([], &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        world(){
            animal();
        }
    }
});
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.4、简单示例&lt;/h2&gt;
&lt;p&gt;目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181203101842258-1035754571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模块定义：&lt;/p&gt;
&lt;p&gt; mathModule.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
       message:&lt;/span&gt;&quot;Hello AMD!&quot;&lt;span&gt;,
       add:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (n1,n2) {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n1+&lt;span&gt;n2;
       }
   }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块依赖：&lt;/p&gt;
&lt;p&gt; app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
require(['mathModule'],&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (mathModule) {
    console.log(mathModule.message);
    console.log(mathModule.add(&lt;/span&gt;100,200&lt;span&gt;));
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/require2.1.11.js&quot;&lt;/span&gt;&lt;span&gt; data-main&lt;/span&gt;&lt;span&gt;=&quot;app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181203102041045-786757635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.5、加载 JavaScript 文件&lt;/h2&gt;
&lt;p&gt;RequireJS的目标是鼓励代码的模块化，它使用了不同于传统&amp;lt;script&amp;gt;标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。&lt;/p&gt;
&lt;p&gt;RequireJS以一个相对于baseUrl的地址来加载所有的代码。 页面顶层&amp;lt;script&amp;gt;标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。下列示例中展示了baseUrl的设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;This sets the baseUrl to the &quot;scripts&quot; directory, and
loads a script that will have a module ID of 'main'&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;data-main&lt;/span&gt;&lt;span&gt;=&quot;scripts/main.js&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;scripts/require.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;baseUrl亦可通过RequireJS config手动设置。如果没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。&lt;/p&gt;
&lt;p&gt;RequireJS默认假定所有的依赖资源都是js脚本，因此无需在module ID上再加&quot;.js&quot;后缀，RequireJS在进行module ID到path的解析时会自动补上后缀。你可以通过paths config设置一组脚本，这些有助于我们在使用脚本时码更少的字。&lt;/p&gt;
&lt;p&gt;有时候你想避开&quot;baseUrl + paths&quot;的解析过程，而是直接指定加载某一个目录下的脚本。此时可以这样做：如果一个module ID符合下述规则之一，其ID解析会避开常规的&quot;baseUrl + paths&quot;配置，而是直接将其加载为一个相对于当前HTML文档的脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;以 &quot;.js&quot; 结束.
以 &quot;/&quot; 开始.
包含 URL 协议, 如 &quot;http:&quot; or &quot;https:&quot;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般来说，最好还是使用baseUrl及&quot;paths&quot; config去设置module ID。它会给你带来额外的灵活性，如便于脚本的重命名、重定位等。 同时，为了避免凌乱的配置，最好不要使用多级嵌套的目录层次来组织代码，而是要么将所有的脚本都放置到baseUrl中，要么分置为项目库/第三方库的一个扁平结构，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;www/
index.html
js/
app/
sub.js
lib/
jquery.js
canvas.js
app.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;data-main&lt;/span&gt;&lt;span&gt;=&quot;js/app.js&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/require.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;requirejs.config({
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;By default load any module IDs from js/lib&lt;/span&gt;
    baseUrl: 'js/lib'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;except, if the module ID starts with &quot;app&quot;,&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;load it from the js/app directory. paths&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;config is relative to the baseUrl, and&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;never includes a &quot;.js&quot; extension since&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;the paths config could be for a directory.&lt;/span&gt;
&lt;span&gt;    paths: {
        app: &lt;/span&gt;'../app'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start the main app logic.&lt;/span&gt;
requirejs(['jquery', 'canvas', 'app/sub'&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($, canvas, sub) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jQuery, canvas and the app/sub module are all&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;loaded and can be used here now.&lt;/span&gt;
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意在示例中，三方库如jQuery没有将版本号包含在他们的文件名中。我们建议将版本信息放置在单独的文件中来进行跟踪。使用诸如volo这类的工具，可以将package.json打上版本信息，并在磁盘上保持文件名为&quot;jquery.js&quot;。这有助于你保持配置的最小化，避免为每个库版本设置一条path。例如，将&quot;jquery&quot;配置为&quot;jquery-1.7.2&quot;。&lt;/p&gt;
&lt;p&gt;理想状况下，每个加载的脚本都是通过define()来定义的一个模块；但有些&quot;浏览器全局变量注入&quot;型的传统/遗留库并没有使用define()来定义它们的依赖关系，你必须为此使用shim config来指明它们的依赖关系。 如果你没有指明依赖关系，加载可能报错。这是因为基于速度的原因，RequireJS会异步地以无序的形式加载这些库。&lt;/p&gt;
&lt;h3&gt;3.5.1、路径处理&lt;/h3&gt;
&lt;p&gt;假定当前路径如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204093828227-1247637107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;moduleA：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        show: m &lt;/span&gt;=&amp;gt;&lt;span&gt; console.info(m)
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;moduleB:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(['moduleA'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        add: (m, n) &lt;/span&gt;=&amp;gt; a.show(m +&lt;span&gt; n)
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
require(['module/moduleB'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b) {
    b.add(&lt;/span&gt;100, 500&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/require2.1.11.js&quot;&lt;/span&gt;&lt;span&gt; data-main&lt;/span&gt;&lt;span&gt;=&quot;js/app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接运行时，报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204094035017-1083788250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看出运行时报错，原因是baseUrl的值与app.js所在位置有关，当前应该是:baseUrl='js/'，那么所有模块在依赖时都默认以js/开始，所以moduleB依赖ModuleA时也以js/开始，可以通过指定当前目录解决该问题，修改moduleB如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(['./moduleA'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        add: (m, n) &lt;/span&gt;=&amp;gt; a.show(m +&lt;span&gt; n)
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;./表示当前目录，../上一级，/表示从域名开始不含虚拟目录&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204094429021-773274173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方法二：&lt;/p&gt;
&lt;p&gt;手动配置baseUrl，修改后如下：&lt;/p&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;
&lt;span&gt;requirejs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块依赖的基础路径，默认模块的加载位置&lt;/span&gt;
    baseUrl:'js/module/'&lt;span&gt;
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块引用&lt;/span&gt;
require(['moduleB'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b) {
    b.add(&lt;/span&gt;100, 500&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;moduleB.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(['moduleA'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (a) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        add: (m, n) &lt;/span&gt;=&amp;gt; a.show(m +&lt;span&gt; n)
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204094429021-773274173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.5.2、依赖第三方的库（AMD依赖jQuery）&lt;/h3&gt;
&lt;p&gt;jQuery 1.7 开始支持将 jQuery 注册为一个AMD异步模块。有很多兼容的脚本加载器（包括 RequireJS 和 curl）都可以用一个异步模块格式来加载模块，这也就表示不需要太多 hack 就能让一切运行起来。可以看看jQuery 1.7 中的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;typeof&lt;/span&gt; define === &quot;function&quot; &amp;amp;&amp;amp; define.amd &amp;amp;&amp;amp;&lt;span&gt; define.amd.jQuery ) {
　　define( &lt;/span&gt;&quot;jquery&quot;, [], &lt;span&gt;function&lt;/span&gt; () { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jQuery; } );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其工作的原理是，所使用的脚本加载器通过指定一个属性，即 define.amd.jQuery 为 true，来标明自己可以支持多个 jQuery 版本。如果有兴趣了解特定的实现细节的话，我们可以将 jQuery 注册为一个具名模块，因为可能会有这样的风险，即它可能被与其它使用了 AMD 的 define() 方法的文件拼合在一起，而没有使用一个合适的、理解匿名 AMD 模块定义的拼合脚本。&lt;/p&gt;
&lt;p&gt;高版本的jQuery （1.11.1） 去掉了define.amd.jQuery判断：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;typeof&lt;/span&gt; define === &quot;function&quot; &amp;amp;&amp;amp;&lt;span&gt; define.amd ) {
    define( &lt;/span&gt;&quot;jquery&quot;, [], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jQuery;
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;
&lt;span&gt;requirejs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块依赖的基础路径，默认模块的加载位置&lt;/span&gt;
    baseUrl:'js/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;    paths:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在路径前写上m/，则表示为：js/module/&lt;/span&gt;
        m:&quot;module/&quot;&lt;span&gt;,
        jquery:&lt;/span&gt;'common/jquery/jquery-1.12.4'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块引用&lt;/span&gt;
require(['m/moduleB','m/moduleC','jquery'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b,c,$) {
    let m&lt;/span&gt;=500,n=100&lt;span&gt;;
    b.add(m, n);
    c.sub(m,n);
    $(&lt;/span&gt;&quot;body&quot;).css({&quot;background&quot;:&quot;yellow&quot;&lt;span&gt;});
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204103409516-1619572059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.6、data-main 入口点&lt;/h2&gt;
&lt;p&gt;require.js 在加载的时候会检察data-main 属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;when require.js loads it will inject another script tag
(with async attribute) for scripts/main.js&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;data-main&lt;/span&gt;&lt;span&gt;=&quot;scripts/main&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;scripts/require.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以在data-main指向的脚本中设置模板加载 选项，然后加载第一个应用模块。.注意：你在main.js中所设置的脚本是异步加载的。所以如果你在页面中配置了其它JS加载，则不能保证它们所依赖的JS已经加载成功。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;data-main&lt;/span&gt;&lt;span&gt;=&quot;scripts/main&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;scripts/require.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;scripts/other.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; main.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contents of main.js:&lt;/span&gt;
&lt;span&gt;require.config({
    paths: {
        foo: &lt;/span&gt;'libs/foo-1.1.3'&lt;span&gt;
    }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; contents of other.js:&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This code might be called before the require.config() in main.js&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; has executed. When that happens, require.js will attempt to&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; load 'scripts/foo.js' instead of 'scripts/libs/foo-1.1.3.js'&lt;/span&gt;
require( ['foo'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( foo ) {

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.7、定义模块&lt;/h2&gt;
&lt;p&gt;模块不同于传统的脚本文件，它良好地定义了一个作用域来避免全局名称空间污染。它可以显式地列出其依赖关系，并以函数(定义此模块的那个函数)参数的形式将这些依赖进行注入，而无需引用全局变量。RequireJS的模块是模块模式的一个扩展，其好处是无需全局地引用其他模块。&lt;/p&gt;
&lt;p&gt;RequireJS的模块语法允许它尽快地加载多个模块，虽然加载的顺序不定，但依赖的顺序最终是正确的。同时因为无需创建全局变量，甚至可以做到在同一个页面上同时加载同一模块的不同版本。&lt;/p&gt;
&lt;p&gt;(如果你熟悉ConmmonJS，可参看CommonJS的注释信息以了解RequireJS模块到CommonJS模块的映射关系)。&lt;/p&gt;
&lt;p&gt;一个磁盘文件应该只定义 1 个模块。多个模块可以使用内置优化工具将其组织打包。&lt;/p&gt;
&lt;h3&gt;3.7.1、简单的值对&lt;/h3&gt;
&lt;p&gt;如果一个模块仅含值对，没有任何依赖，则在define()中定义这些值对就好了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Inside file my/shirt.js:&lt;/span&gt;
&lt;span&gt;define({
    color: &lt;/span&gt;&quot;black&quot;&lt;span&gt;,
    size: &lt;/span&gt;&quot;unisize&quot;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7.2、函数式定义&lt;/h3&gt;
&lt;p&gt;如果一个模块没有任何依赖，但需要一个做setup工作的函数，则在define()中定义该函数，并将其传给define()：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my/shirt.js now does setup work&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;before returning its module definition.&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Do setup work here&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        color: &lt;/span&gt;&quot;black&quot;&lt;span&gt;,
        size: &lt;/span&gt;&quot;unisize&quot;&lt;span&gt;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7.3、存在依赖的函数式定义&lt;/h3&gt;
&lt;p&gt;如果模块存在依赖：则第一个参数是依赖的名称数组；第二个参数是函数，在模块的所有依赖加载完毕后，该函数会被调用来定义该模块，因此该模块应该返回一个定义了本模块的object。依赖关系会以参数的形式注入到该函数上，参数列表与依赖名称列表一一对应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;my/shirt.js now has some dependencies, a cart and inventory&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;module in the same directory as shirt.js&lt;/span&gt;
define([&quot;./cart&quot;, &quot;./inventory&quot;], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cart, inventory) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return an object to define the &quot;my/shirt&quot; module.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            color: &lt;/span&gt;&quot;blue&quot;&lt;span&gt;,
            size: &lt;/span&gt;&quot;large&quot;&lt;span&gt;,
            addToCart: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                inventory.decrement(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                cart.add(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本示例创建了一个my/shirt模块，它依赖于my/cart及my/inventory。磁盘上各文件分布如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
my/cart.js
my/inventory.js
my/shirt.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块函数以参数&quot;cart&quot;及&quot;inventory&quot;使用这两个以&quot;./cart&quot;及&quot;./inventory&quot;名称指定的模块。在这两个模块加载完毕之前，模块函数不会被调用。&lt;/p&gt;
&lt;p&gt;严重不鼓励模块定义全局变量。遵循此处的定义模式，可以使得同一模块的不同版本并存于同一个页面上(参见 高级用法 )。另外，函参的顺序应与依赖顺序保存一致。&lt;/p&gt;
&lt;p&gt;返回的object定义了&quot;my/shirt&quot;模块。这种定义模式下，&quot;my/shirt&quot;不作为一个全局变量而存在。&lt;/p&gt;
&lt;h3&gt;3.7.4、将模块定义为一个函数&lt;/h3&gt;
&lt;p&gt;对模块的返回值类型并没有强制为一定是个object，任何函数的返回值都是允许的。此处是一个返回了函数的模块定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;A module definition inside foo/title.js. It uses&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;my/cart and my/inventory modules from before,&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;but since foo/title.js is in a different directory than&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;the &quot;my&quot; modules, it uses the &quot;my&quot; in the module dependency&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;name to find them. The &quot;my&quot; part of the name can be mapped&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;to any directory, but by default, it is assumed to be a&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;sibling to the &quot;foo&quot; directory.&lt;/span&gt;
define([&quot;my/cart&quot;, &quot;my/inventory&quot;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cart, inventory) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return a function to define &quot;foo/title&quot;.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;It gets or sets the window title.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(title) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; title ? (window.title =&lt;span&gt; title) :
                inventory.storeName &lt;/span&gt;+ ' ' +&lt;span&gt; cart.name;
        }
    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7.5、简单包装CommonJS来定义模块&lt;/h3&gt;
&lt;p&gt;如果你现有一些以CommonJS模块格式编写的代码，而这些代码难于使用上述依赖名称数组参数的形式来重构，你可以考虑直接将这些依赖对应到一些本地变量中进行使用。你可以使用一个CommonJS的简单包装来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = require('a'&lt;span&gt;),
            b &lt;/span&gt;= require('b'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Return the module value&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {};
    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该包装方法依靠Function.prototype.toString()将函数内容赋予一个有意义的字串值，但在一些设备如PS3及一些老的Opera手机浏览器中不起作用。考虑在这些设备上使用优化器将依赖导出为数组形式。&lt;/p&gt;
&lt;p&gt;更多的信息可参看CommonJS Notes页面，以及&quot;Why AMD&quot;页面的&quot;Sugar&quot;段落。&lt;/p&gt;
&lt;h3&gt;3.7.6、定义一个命名模块&lt;/h3&gt;
&lt;p&gt;你可能会看到一些define()中包含了一个模块名称作为首个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Explicitly defines the &quot;foo/title&quot; module:&lt;/span&gt;
define(&quot;foo/title&quot;&lt;span&gt;,
    [&lt;/span&gt;&quot;my/cart&quot;, &quot;my/inventory&quot;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cart, inventory) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Define foo/title object in here.&lt;/span&gt;
&lt;span&gt;    }
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些常由优化工具生成。你也可以自己显式指定模块名称，但这使模块更不具备移植性——就是说若你将文件移动到其他目录下，你就得重命名。一般最好避免对模块硬编码，而是交给优化工具去生成。优化工具需要生成模块名以将多个模块打成一个包，加快到浏览器的载人速度。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;moduleD.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(&quot;md&quot;,[],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {hi: () =&amp;gt; console.info(&quot;Hello ModuleD!&quot;&lt;span&gt;)};
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;
&lt;span&gt;requirejs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块依赖的基础路径，默认模块的加载位置&lt;/span&gt;
    baseUrl:'js/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;    paths:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在路径前写上m/，则表示为：js/module/&lt;/span&gt;
        m:&quot;module/&quot;&lt;span&gt;,
        jquery:&lt;/span&gt;'common/jquery/jquery-1.12.4'&lt;span&gt;,
        md:&lt;/span&gt;'module/moduleD'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块引用&lt;/span&gt;
require(['m/moduleB','m/moduleC','jquery','md'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b,c,$,d) {
    let m&lt;/span&gt;=500,n=100&lt;span&gt;;
    b.add(m, n);
    c.sub(m,n);
    d.hi();
    $(&lt;/span&gt;&quot;body&quot;).css({&quot;background&quot;:&quot;yellow&quot;&lt;span&gt;});
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用命名模块时需要为命名模块指定路径，名称需唯一。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204111047691-568664882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.7.7、依赖非AMD模块&lt;/h3&gt;
&lt;p&gt;&lt;span id=&quot;config-shim&quot;&gt;配置中shim参数为那些没有使用define()来声明依赖关系、设置模块的&quot;浏览器全局变量注入&quot;型脚本做依赖和导出配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加一个非amd模块moduleE.js：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; moduleE =&lt;span&gt; {
    hello: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.info(&lt;/span&gt;&quot;Hello ModuleE!&quot;&lt;span&gt;);
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引用ModuleE：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;
&lt;span&gt;requirejs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块依赖的基础路径，默认模块的加载位置&lt;/span&gt;
    baseUrl:'js/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;    paths:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在路径前写上m/，则表示为：js/module/&lt;/span&gt;
        m:&quot;module/&quot;&lt;span&gt;,
        jquery:&lt;/span&gt;'common/jquery/jquery-1.12.4'&lt;span&gt;,
        md:&lt;/span&gt;'module/moduleD'&lt;span&gt;,
        moduleE:&lt;/span&gt;'module/moduleE'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理非标准的amd模块&lt;/span&gt;
&lt;span&gt;    shim:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个键名为要载入的目标文件的文件名，不能随便命名否则拿不到改文件对外提供的接口的&lt;/span&gt;
        'moduleE'&lt;span&gt;:{
            exports:&lt;/span&gt;'moduleE'&lt;span&gt;
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块引用&lt;/span&gt;
require(['m/moduleB','m/moduleC','jquery','md','moduleE'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b,c,$,d,e) {
    let m&lt;/span&gt;=500,n=100&lt;span&gt;;
    b.add(m, n);
    c.sub(m,n);
    d.hi();
    $(&lt;/span&gt;&quot;body&quot;).css({&quot;background&quot;:&quot;yellow&quot;&lt;span&gt;});
    e.hello();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204114425864-1438229996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.7.8、注意事项&lt;/h3&gt;
&lt;p&gt;一个文件一个模块: 每个Javascript文件应该只定义一个模块，这是模块名-至-文件名查找机制的自然要求。多个模块会被优化工具组织优化，但你在使用优化工具时应将多个模块放置到一个文件中。&lt;/p&gt;
&lt;p&gt;define()中的相对模块名: 为了可以在define()内部使用诸如require(&quot;./relative/name&quot;)的调用以正确解析相对名称，记得将&quot;require&quot;本身作为一个依赖注入到模块中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define([&quot;require&quot;, &quot;./relative/name&quot;], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mod = require(&quot;./relative/name&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者更好地，使用下述为转换CommonJS模块所设的更短的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mod = require(&quot;./relative/name&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相对路径在一些场景下格外有用，例如：为了以便于将代码共享给其他人或项目，你在某个目录下创建了一些模块。你可以访问模块的相邻模块，无需知道该目录的名称。&lt;/p&gt;
&lt;p&gt;生成相对于模块的URL地址: 你可能需要生成一个相对于模块的URL地址。你可以将&quot;require&quot;作为一个依赖注入进来，然后调用require.toUrl()以生成该URL:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
define([&quot;require&quot;], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cssUrl = require.toUrl(&quot;./style.css&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台调试:如果你需要处理一个已通过require([&quot;module/name&quot;], function(){})调用加载了的模块，可以使用模块名作为字符串参数的require()调用来获取它:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
require(&quot;module/name&quot;).callSomeFunction()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这种形式仅在&quot;module/name&quot;已经由其异步形式的require([&quot;module/name&quot;])加载了后才有效。只能在define内部使用形如&quot;./module/name&quot;的相对路径。&lt;/p&gt;

&lt;p&gt;CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $ = require('jquery'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Spinning = require('./spinning'&lt;span&gt;);
    exports.doSomething &lt;/span&gt;=&lt;span&gt; ...
    module.exports &lt;/span&gt;=&lt;span&gt; ...
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样实现了浏览器端的模块化加载。&lt;/p&gt;
&lt;p&gt;可以按需加载，依赖就近。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依赖SPM打包，模块的加载逻辑偏重。&lt;/p&gt;
&lt;p&gt;其实，这时我们就可以看出AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AMD&lt;/span&gt;
define(['./a', './b'], &lt;span&gt;function&lt;/span&gt;(a, b) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖必须一开始就写好 &lt;/span&gt;
&lt;span&gt;    a.doSomething()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处略去 100 行 &lt;/span&gt;
&lt;span&gt;    b.doSomething()
...
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CMD&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = require('./a'&lt;span&gt;)
    a.doSomething()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处略去 100 行 &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; b = require('./b'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖可以就近书写 &lt;/span&gt;
&lt;span&gt;    b.doSomething()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 模块定义语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
define(id, deps, factory)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；&lt;br/&gt;CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。&lt;/p&gt;
&lt;p&gt;factory有三个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;(require, exports, module){}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一、require&lt;/p&gt;
&lt;p&gt;require 是 factory 函数的第一个参数，require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口；&lt;/p&gt;
&lt;p&gt;二、exports&lt;/p&gt;
&lt;p&gt;exports 是一个对象，用来向外提供模块接口；&lt;/p&gt;
&lt;p&gt;三、module&lt;/p&gt;
&lt;p&gt;module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义模块 myModule.js&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {
　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $ = require('jquery.js'&lt;span&gt;)
　　$(&lt;/span&gt;'div').addClass('active'&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载模块&lt;/span&gt;
seajs.use(['myModule.js'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(my){

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.1、Seajs&lt;/h2&gt;
&lt;p&gt;Seajs是一个加载器、遵循 CMD 规范模块化开发，依赖的自动加载、配置的简洁清晰。&lt;/p&gt;
&lt;p&gt;SeaJS是一个遵循CMD规范的JavaScript模块加载框架，可以实现JavaScript的模块化开发及加载机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204142720311-955415772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与jQuery等JavaScript框架不同，SeaJS不会扩展封装语言特性，而只是实现JavaScript的模块化及按模块加载。SeaJS的主要目的是令JavaScript开发模块化并可以轻松愉悦进行加载，将前端工程师从繁重的JavaScript文件及对象依赖处理中解放出来，可以专注于代码本身的逻辑。SeaJS可以与jQuery这类框架完美集成。使用SeaJS可以提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/seajs/seajs&quot; target=&quot;_blank&quot;&gt;github:https://github.com/seajs/seajs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www6.seajs.org&quot; target=&quot;_blank&quot;&gt;http://www6.seajs.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sea.js 追求简单、自然的代码书写和组织方式，具有以下核心特性：&lt;/p&gt;
&lt;p&gt;（一）、简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。&lt;/p&gt;
&lt;p&gt;（二）、自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。&lt;/p&gt;
&lt;p&gt;Sea.js 还提供常用插件，非常有助于开发调试和性能优化，并具有丰富的可扩展接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;兼容：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Chrome 3+&lt;span&gt;
Firefox &lt;/span&gt;2+&lt;span&gt;
Safari &lt;/span&gt;3.2+&lt;span&gt;
Opera &lt;/span&gt;10+&lt;span&gt;
IE &lt;/span&gt;5.5+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;基本应用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导入Seajs库&lt;/p&gt;
&lt;p&gt;去官网下载最新的seajs文件，http://seajs.org/docs/#downloads&lt;/p&gt;
&lt;p&gt;在页尾引入seajs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/site/script/sea.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在它下面写模块的配置和入口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载入口模块&lt;/span&gt;
seajs.use(&quot;../static/hello/src/main&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置和入口&lt;/p&gt;
&lt;p&gt;这里解释下配置和入口的意思。&lt;/p&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;p&gt;通常在配置上修改seajs的路径和别名。&lt;/p&gt;
&lt;p&gt;seajs的路径是相对于前面引入的seajs文件的。假如是这样的目录结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
examples/
|--&lt;span&gt; index.html
&lt;/span&gt;|&lt;span&gt;
`&lt;/span&gt;--&lt;span&gt;about
&lt;/span&gt;| |--&lt;span&gt; news.html
&lt;/span&gt;|&lt;span&gt;
`&lt;/span&gt;--&lt;span&gt; script
&lt;/span&gt;|--&lt;span&gt; seajs.js
&lt;/span&gt;|--&lt;span&gt; jquery.js
`&lt;/span&gt;-- main.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们平时如果我们在index.html上引用main.js路径应该是这样写的script/main.js，从news.html引用main.js就要这样写，../script/main.js。&lt;/p&gt;
&lt;p&gt;而在seajs是相对于seajs文件的，一律直接使用main.js就OK了，是不是很方便呢？&lt;/p&gt;
&lt;p&gt;既然这么方便那在什么情况需要配置呢？一般情况是用不到的。但是假如你的路径特别深 或者要做路径映射的时候它的作用就来了。下面介绍下常用的几个配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;seajs.config({
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了）&lt;/span&gt;
    base: 'http://example.com/path/to/base/'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 别名配置（用变量表示文件，解决路径层级过深和实现路径映射）&lt;/span&gt;
&lt;span&gt;    alias: {
        &lt;/span&gt;'es5-safe': 'gallery/es5-safe/0.9.3/es5-safe'&lt;span&gt;,
        &lt;/span&gt;'json': 'gallery/json/1.0.2/json'&lt;span&gt;,
        &lt;/span&gt;'jquery': 'jquery/jquery/1.10.1/jquery'&lt;span&gt;
    },
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路径配置（用变量表示路径，解决路径层级过深的问题）&lt;/span&gt;
&lt;span&gt;    paths: {
        &lt;/span&gt;'gallery': 'https://a.alipayobjects.com/gallery'&lt;span&gt;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;入口即加载，需要加载什么文件（模块加载器）就在这里引入。sea.js 在下载完成后，会自动加载入口模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
seajs.use(&quot;abc/main&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入seajs.js同级的abc文件夹下的main.js模块的（后缀名可略去不写）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;seajs.use()还有另外一种用法。&lt;/p&gt;
&lt;p&gt;有时候我们写一个简单的单页并不想为它单独写一个js文件，选择在直接把js代码写在页面上，seajs通过seajs.use()实现了这个。接收两个参数第一个是文件依赖(单个用字符串数组都可以，多个需用数组表示)，第二个是回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载单个依赖&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载模块 main，并在加载完成时，执行指定回调&lt;/span&gt;
seajs.use('./main', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(main) {
　　main.init();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;加载多个依赖&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调&lt;/span&gt;
seajs.use(['./a', './b'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b) {
    a.init();
    b.init();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里回掉函数中的a和b参数是与前面的模块暴露出来的接口一一对应的。有时候也许只需要使用b的接口，但是也要把a参数写上。什么是暴露接口下面会解释。&lt;/p&gt;
&lt;p&gt;通过seajs.use()只能在第一个参数中引入模块，不能在回调函数中使用require()载入模块。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里才是重点，其实也很简单就是一个书写规范（CMD）而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有模块都通过 define 来定义&lt;/span&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(require, exports, module) {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 require 引入依赖&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; $ = require('jquery'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Spinning = require('./spinning'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 exports 对外提供接口&lt;/span&gt;
exports.doSomething =&lt;span&gt; ...

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者通过 module.exports 提供整个接口&lt;/span&gt;
module.exports =&lt;span&gt; ...

});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块是通过define()方法包装的，然后内部痛过require()方法引入需要的依赖文件(模块)。&lt;/p&gt;
&lt;p&gt;模块最好是面向对象开发的，这样最后可以方便的通过exports.doSomething或module.exports把模块的接口给暴露出来。如果你是写的是jq插件的话就不需要这个功能了，因为你的接口是写在jquery的对象里的。如果你不需要提供接口的话也可以不使用这两个属性哦！&lt;/p&gt;
&lt;p&gt;事实上define方法还有另外几个参数，一般情况我们用不到。具体看官方API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模块内的函数依赖必须交代清楚，防止模块在函数依赖加载前先加载出来。而且还增强了模块的独立性。&lt;/p&gt;
&lt;p&gt;引入seajs的时候最好给&amp;lt;script&amp;gt;标签加个id，可以快速访问到这个标签（我是在模块合并时用到它的）&lt;/p&gt;
&lt;p&gt;还有前面提到的使用seajs.use()在.html页面上写js时如果有多个模块依赖，需要使用暴露出来的接口就要让参数与它一一对应。&lt;/p&gt;
&lt;h2&gt;4.2、seajs示例&lt;/h2&gt;
&lt;p&gt;目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204180217886-1052234478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;moduleH.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
define(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (require,exports,module) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{
        msg:&lt;/span&gt;&quot;Hello SeaJS!&quot;&lt;span&gt;,
        show:()&lt;/span&gt;=&amp;gt;&lt;span&gt;console.info(obj.msg)
    };
    exports.moduleH&lt;/span&gt;=&lt;span&gt;obj;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;seajs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了）&lt;/span&gt;
    base: './js/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;别名配置（用变量表示文件，解决路径层级过深和实现路径映射）&lt;/span&gt;
&lt;span&gt;    alias: {
        &lt;/span&gt;'jquery': 'common/jquery/jquery-1.12.4'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径配置（用变量表示路径，解决路径层级过深的问题）&lt;/span&gt;
&lt;span&gt;    paths: {
        &lt;/span&gt;'m': 'module/'&lt;span&gt;
    }
});

seajs.use([&lt;/span&gt;&quot;m/moduleH.js&quot;,'jquery'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (mh,$) {
    mh.moduleH.show();
    $(&lt;/span&gt;&quot;body&quot;).append(&quot;&amp;lt;h2&amp;gt;Hello CMD!&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/sea.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/main.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181204180632848-20217839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.3、官方文档&lt;/h2&gt;
&lt;p&gt;如果您要更加深入学习CMD与seajs可以参考下面的文档、&lt;a href=&quot;https://seajs.github.io/seajs/docs/&quot; target=&quot;_blank&quot;&gt;https://seajs.github.io/seajs/docs/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4.3.1、入门&lt;/h3&gt;
&lt;h3&gt;4.3.2、基础&lt;/h3&gt;
&lt;h3&gt;4.3.3、插件&lt;/h3&gt;
&lt;h3&gt;4.3.4、进阶&lt;/h3&gt;
&lt;h3&gt;4.3.5、探讨&lt;/h3&gt;

&lt;p&gt;ES6之前使用RequireJS或者seaJS实现模块化， requireJS是基于AMD规范的模块化库， 而像seaJS是基于CMD规范的模块化库， 两者都是为了为了推广前端模块化的工具。&lt;/p&gt;
&lt;p&gt;现在ES6自带了模块化， 也是JS第一次支持module， 在很久以后 ，我们可以直接作用import和export在浏览器中导入和导出各个模块了， 一个js文件代表一个js模块；&lt;/p&gt;
&lt;p&gt;现代浏览器对模块(module)支持程度不同， 目前都是使用babelJS， 或者Traceur把ES6代码转化为兼容ES5版本的js代码;&lt;/p&gt;
&lt;p&gt;之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。&lt;/p&gt;
&lt;p&gt;虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import store from '../store/index'&lt;span&gt;
import {mapState, mapMutations, mapActions} from &lt;/span&gt;'vuex'&lt;span&gt;
import axios from &lt;/span&gt;'../assets/js/request'&lt;span&gt;
import util from &lt;/span&gt;'../utils/js/util.js'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    created () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClassify();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.RESET_VALUE();
        console.log(&lt;/span&gt;'created' ,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime());

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.1、ES6模块化特点&lt;/h2&gt;
&lt;p&gt;1、每一个模块只加载一次， 每一个JS只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象；&lt;/p&gt;
&lt;p&gt;2、每一个模块内声明的变量都是局部变量， 不会污染全局作用域；&lt;/p&gt;
&lt;p&gt;3、模块内部的变量或者函数可以通过export导出；&lt;/p&gt;
&lt;p&gt;4、一个模块可以导入别的模块&lt;/p&gt;
&lt;h2&gt;5.2、在Chrome浏览器使用Module&lt;/h2&gt;
&lt;p&gt;Chrome 61就提供了对ES2015 import语句的支持，实现模块加载&lt;/p&gt;
&lt;p&gt;查看版本的办法是：在chrome浏览器中输入chrome://version/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109135840722-2033817153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;谷歌浏览器(Canary 60) – 需要在chrome:flags里开启”实验性网络平台功能(Experimental Web Platform)”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109140119457-1187190867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例：lib.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *定义模块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出&lt;/span&gt;
export let msg=&quot;求和：&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(n){
    let total&lt;/span&gt;=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
        total&lt;/span&gt;+=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Module模块&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&lt;strong&gt; &amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
&lt;span&gt;            import {sum,msg} from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./lib.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            let result&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;sum(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            console.log(msg&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;result);
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109141253582-889350680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.3、在Node.js中使用Module&lt;/h2&gt;
&lt;h3&gt;5.3.1、方法一&lt;/h3&gt;
&lt;p&gt;在 Node.js 模块系统中，每个文件都被视为独立的模块。&lt;/p&gt;
&lt;p&gt;例子，假设有一个名为 foo.js 的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const circle = require('./circle.js'&lt;span&gt;);
console.log(`半径为 &lt;/span&gt;4 的圆的面积是 ${circle.area(4)}`);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一行中，foo.js 加载了同一目录下的 circle.js 模块。&lt;/p&gt;
&lt;p&gt;circle.js 文件的内容为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const { PI } =&lt;span&gt; Math;

exports.area &lt;/span&gt;= (r) =&amp;gt; PI * r ** 2&lt;span&gt;;

exports.circumference &lt;/span&gt;= (r) =&amp;gt; 2 * PI * r;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;circle.js 模块导出了 area() 和 circumference() 两个函数。 通过在特殊的 exports 对象上指定额外的属性，函数和对象可以被添加到模块的根部。&lt;/p&gt;
&lt;p&gt;模块内的本地变量是私有的，因为模块被 Node.js 包装在一个函数中（详见模块包装器）。 在这个例子中，变量 PI 是 circle.js 私有的。&lt;/p&gt;
&lt;p&gt;module.exports属性可以被赋予一个新的值（例如函数或对象）。&lt;/p&gt;
&lt;p&gt;如下，bar.js 会用到 square 模块，square 模块导出了 Square 类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const Square = require('./square.js'&lt;span&gt;);
const mySquare &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Square(2&lt;span&gt;);
console.log(`mySquare 的面积是 ${mySquare.area()}`);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;square 模块定义在 square.js 中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值给 `exports` 不会修改模块，必须使用 `module.exports`&lt;/span&gt;
module.exports =&lt;span&gt; class Square {
constructor(width) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
}

area() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.width ** 2&lt;span&gt;;
}
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块系统在 `require('module')` 模块中实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问主模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 Node.js 直接运行一个文件时，require.main 会被设为它的 module。 这意味着可以通过 require.main === module 来判断一个文件是否被直接运行：&lt;/p&gt;
&lt;p&gt;对于 foo.js 文件，如果通过 node foo.js 运行则为 true，但如果通过 require('./foo') 运行则为 false。&lt;/p&gt;
&lt;p&gt;因为 module 提供了一个 filename 属性（通常等同于 __filename），所以可以通过检查 require.main.filename 来获取当前应用程序的入口点。&lt;/p&gt;
&lt;p&gt;参考API：&lt;a href=&quot;http://nodejs.cn/api/modules.html&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/api/modules.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5.3.2、方法二：experimental-modules&lt;/h3&gt;
&lt;p&gt;升级node 8.5 使用 experimental-modules参数，且要求所有文件名后缀都要修改为mjs&lt;br/&gt;node --experimental-modules index.mjs&lt;br/&gt;定义模块lib.mjs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *定义模块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出&lt;/span&gt;
export let msg=&quot;求和：&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(n){
    let total&lt;/span&gt;=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
        total&lt;/span&gt;+=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义main.mjs文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 使用模块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
import { sum, msg } from './lib.mjs'&lt;span&gt;;
let result &lt;/span&gt;= sum(100&lt;span&gt;);
console.log(msg &lt;/span&gt;+ &quot;&quot; + result);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命令行下转换到当前目录，使用node加参数experimental-modules执行，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109142234238-1284799056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.4、Babel&lt;/h2&gt;
&lt;p&gt;Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109123456519-972958795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.4.1、配置环境&lt;/h3&gt;
&lt;p&gt;安装babel命令行工具：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt; --global babel-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109123855160-1509282356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功后可以使用babel -V查看版本，可以使用babel -help 查看帮助&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109151217269-563943955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建项目，在当前项目中依赖babel-core&lt;/p&gt;
&lt;p&gt;假定当前项目的目录为：E:\Desktop-temp\xww\FastResponse\Mobile\Hybird\vue2_01\vue07_03_babel&lt;/p&gt;
&lt;p&gt;使用npm init可以初始化当前项目为node项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt; babel-core --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依赖插件babel-preset-es2015&lt;/p&gt;
&lt;p&gt;如果想使用es6语法，必须安装一个插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt; babel-preset-es2015
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在文件夹下面创建一个叫.babelrc的文件，并写入如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&quot;presets&quot;: [&quot;es2015&quot;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;windows不支持直接命令为.babelrc，可以在DOS下使用@echo结合&amp;gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109152348894-812752102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;.babelrc文件以rc结尾的文件通常代表运行时自动加载的文件，配置等等的，类似bashrc,zshrc。同样babelrc在这里也是有同样的作用的，而且在babel6中，这个文件必不可少。&lt;br/&gt;在babel6中，预设了6种，分别是：es2015、stage-0、stage-1、stage-2、stage-3、react&lt;/p&gt;
&lt;h3&gt;5.4.2、转换ES6为ES5&lt;/h3&gt;
&lt;p&gt;当环境准备好了，就可以编写一个es6风格的文件如：es6.js，内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let add=(x,y)=&amp;gt;x+&lt;span&gt;y;
const n1&lt;/span&gt;=100,n2=200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result=&lt;span&gt;add(n1,n2);
console.log(result);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在当前目录执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
babel es6.js -o es5.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109153854566-2066677435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转换后的结果es5.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&quot;use strict&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; add = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add(x, y) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n1 = 100&lt;span&gt;,
    n2 &lt;/span&gt;= 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; add(n1, n2);
console.log(result);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从转换后的结果可以看出es6已变成es5了，箭头函数不见了。 &lt;/p&gt;
&lt;h3&gt;5.4.3、使用babel-node运行ES6模块化代码&lt;/h3&gt;
&lt;p&gt;babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境。它支持Node的REPL（交互式解释器环境）环境的所有功能，而且可以直接运行ES6代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109154451129-1193770269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在当前目录下创建lib.js文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *定义模块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出&lt;/span&gt;
export let msg=&quot;求和：&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(n){
    let total&lt;/span&gt;=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
        total&lt;/span&gt;+=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建main.js文件调用定义好的模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 使用模块
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入&lt;/span&gt;
import { sum, msg } from './lib.js'&lt;span&gt;;
let result &lt;/span&gt;= sum(100&lt;span&gt;);
console.log(msg &lt;/span&gt;+ &quot;&quot; + result);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在命令行执行：babel-node main.js 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180109154721801-964643018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里共讲解了3种可以运行ES6模块化的环境，任选一种可以用于学习。&lt;/p&gt;
&lt;h2&gt;5.5、模块(Modules)&lt;/h2&gt;
&lt;p&gt;ES6从语言层面对模块进行了支持。编写方式借鉴了流行的JavaScript模块加载器（AMD, CommonJS）。由宿主环境的默认加载器定义模块运行时的行为，采取隐式异步模式——在模块可以被获取和加载前不会有代码执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义模块：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;// lib/math.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum(x, y) {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
}
export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pi = 3.141593;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;导入模块：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全部导入  &lt;/span&gt;
import people from './example'  
  
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有一种特殊情况，即允许你将整个模块当作单一对象进行导入  &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;该模块的所有导出都会作为对象的属性存在  &lt;/span&gt;
import * as example from &quot;./example.js&quot;&lt;span&gt;  
console.log(example.name)  
console.log(example.age)  
console.log(example.getName())  
  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入部分  &lt;/span&gt;
import {name, age} from './example'  
  
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出默认, 有且只有一个默认  &lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; App  
  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 部分导出  &lt;/span&gt;
export class App extend Component {};  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;*表示所有，as取别名&lt;/p&gt;
&lt;p&gt;// app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import * as math from &quot;lib/math&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&quot;2π = &quot; + math.sum(math.pi, math.pi));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// otherApp.js&lt;/p&gt;
&lt;p&gt;导入部分内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import {sum, pi} from &quot;lib/math&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&quot;2π = &quot; + sum(pi, pi));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有的功能包括：export default and export *:&lt;/p&gt;
&lt;p&gt;// lib/mathplusplus.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export * from &quot;lib/math&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = 2.71828182846&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(x) {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.exp(x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;// app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import exp, {pi, e} from &quot;lib/mathplusplus&quot;&lt;span&gt;;
console.log(&lt;/span&gt;&quot;e^π = &quot; + exp(pi));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入的时候有没有大括号的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.当用export default people导出时，就用 import people 导入（不带大括号）&lt;/li&gt;
&lt;li&gt;2.一个文件里，有且只能有一个export default。但可以有多个export。&lt;/li&gt;
&lt;li&gt;3.当用export name 时，就用import { name }导入（记得带上大括号）&lt;/li&gt;
&lt;li&gt;4.当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age }&lt;/li&gt;
&lt;li&gt;5.当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;模块的格式：&lt;/p&gt;
&lt;p&gt;Babel可以将ES2015的模块转换为一下几种格式：Common.js，AMD，System，以及UMD。你甚至可以创建你自己的方式。&lt;/p&gt;
&lt;h3&gt;5.5.1、导出方式一&lt;/h3&gt;
&lt;p&gt;使用 export{接口} 导出接口， 大括号中的接口名字为上面定义的变量， import和export是对应的；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js 文件&lt;/span&gt;
let bar = &quot;stringBar&quot;&lt;span&gt;;
let foo &lt;/span&gt;= &quot;stringFoo&quot;&lt;span&gt;;
let fn0 &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;fn0&quot;&lt;span&gt;);
};
let fn1 &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;fn1&quot;&lt;span&gt;);
};
export{ bar , foo, fn0, fn1}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js文件&lt;/span&gt;
import {bar,foo, fn0, fn1} from &quot;./lib&quot;&lt;span&gt;;
console.log(bar&lt;/span&gt;+&quot;_&quot;+&lt;span&gt;foo);
fn0();
fn1();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;先配置babel的运行环境，创建util.js文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let PI=3.14&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getArea(r){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; PI*r*&lt;span&gt;r;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集中导出对象&lt;/span&gt;
export {PI,getArea}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入模块main.js：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import {PI,getArea} from './util'&lt;span&gt;

console.log(&lt;/span&gt;&quot;R=5时面积为：&quot;+getArea(5));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180111091944035-802183271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201801/63651-20180111092124316-1450068584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.5.2、导出方式二&lt;/h3&gt;
&lt;p&gt;在export接口的时候， 我们可以使用 XX as YY， 把导出的接口名字改了， 比如： closureFn as sayingFn， 把这些接口名字改成不看文档就知道干什么的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js文件&lt;/span&gt;
let fn0 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&quot;fn0&quot;&lt;span&gt;);
};
let obj0 &lt;/span&gt;=&lt;span&gt; {}
export { fn0 as foo, obj0 as bar};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js文件&lt;/span&gt;
import {foo, bar} from &quot;./lib&quot;&lt;span&gt;;
foo();
console.log(bar);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5.3、导出方式三&lt;/h3&gt;
&lt;p&gt;这种方式是直接在export的地方定义导出的函数，或者变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js文件&lt;/span&gt;
export let foo = ()=&amp;gt; {console.log(&quot;fnFoo&quot;) ;&lt;span&gt;return&lt;/span&gt; &quot;foo&quot;},bar = &quot;stringBar&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js文件&lt;/span&gt;
import {foo, bar} from &quot;./lib&quot;&lt;span&gt;;
console.log(foo());
console.log(bar);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5.4、导出方式四&lt;/h3&gt;
&lt;p&gt;这种导出的方式不需要知道变量的名字， 相当于是匿名的， 直接把开发的接口给export；&lt;br/&gt;如果一个js模块文件就只有一个功能， 那么就可以使用export default导出；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt; &quot;string&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js&lt;/span&gt;
import defaultString from &quot;./lib&quot;&lt;span&gt;;
console.log(defaultString);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5.5、导出方式五&lt;/h3&gt;
&lt;p&gt;export也能默认导出函数， 在import的时候， 名字随便写， 因为每一个模块的默认接口就一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js&lt;/span&gt;
let fn = () =&amp;gt; &quot;string&quot;&lt;span&gt;;
export {fn as &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js&lt;/span&gt;
import defaultFn from &quot;./lib&quot;&lt;span&gt;;
console.log(defaultFn());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5.6、导出方式六&lt;/h3&gt;
&lt;p&gt;使用通配符* ,重新导出其他模块的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lib.js&lt;/span&gt;
export * from &quot;./other&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果只想导出部分接口， 只要把接口名字列出来&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;export {foo,fnFoo} from &quot;./other&quot;;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;other.js&lt;/span&gt;
export let foo = &quot;stringFoo&quot;, fnFoo = &lt;span&gt;function&lt;/span&gt;() {console.log(&quot;fnFoo&quot;&lt;span&gt;)};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.js&lt;/span&gt;
import {foo, fnFoo} from &quot;./lib&quot;&lt;span&gt;;
console.log(foo);
console.log(fnFoo());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在import的时候可以使用通配符*导入外部的模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import * as obj from &quot;./lib&quot;&lt;span&gt;;
console.log(obj);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.6、模块加载器(Module Loaders)&lt;/h2&gt;
&lt;p&gt;这并不是ES2015的一部分：这部分ECMAScript 2015规范是由实现定义（implementation-defined）的。最终的标准将在WHATWG的Loader 规范中确定，目前这项工作正在进行中，下面的内容来自于之前的ES2015草稿。&lt;/p&gt;
&lt;p&gt;模块加载器支持以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;动态加载（Dynamic loading）&lt;/li&gt;
&lt;li&gt;状态一致性（State isolation）&lt;/li&gt;
&lt;li&gt;全局空间一致性（Global namespace isolation）&lt;/li&gt;
&lt;li&gt;编译钩子（Compilation hooks）&lt;/li&gt;
&lt;li&gt;嵌套虚拟化（Nested virtualization）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以对默认的加载器进行配置，构建出新的加载器，可以被加载于独立或受限的执行环境。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态加载 – ‘System’ 是默认的加载器&lt;/span&gt;
System.import(&quot;lib/math&quot;).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(m) {
alert(&lt;/span&gt;&quot;2π = &quot; +&lt;span&gt; m.sum(m.pi, m.pi));
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建执行沙箱 – new Loaders&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; loader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Loader({
global: fixup(window) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; replace ‘console.log’&lt;/span&gt;
&lt;span&gt;});
loader.eval(&lt;/span&gt;&quot;console.log(\&quot;hello world!\&quot;);&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接操作模块的缓存&lt;/span&gt;
System.get(&quot;jquery&quot;&lt;span&gt;);
System.set(&lt;/span&gt;&quot;jquery&quot;, Module({$: $})); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; WARNING: not yet finalized&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要额外的polyfill&lt;br/&gt;由于Babel默认使用common.js的模块，你需要一个polyfill来使用加载器API。&lt;/p&gt;
&lt;p&gt;使用模块加载器&lt;br/&gt;为了使用此功能，你需要告诉Babel使用system模块格式化工具。&lt;/p&gt;

&lt;p&gt;UMD（Universal Module Definition）通用的模块定义、UMD等于CommonJS加上AMD。UMD的工作其实就是做了一个判断：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;- 先判断当前环境对NodeJs支持的模块是否存在，存在就用Node.js模块模式（exports）。&lt;/li&gt;
&lt;li&gt;- 如果不支持，就判断是否支持AMD（define），存在就使用AMD方式加载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CommonJs和AMD风格一样流行，似乎缺少一个统一的规范。所以人们产生了这样的需求，希望有支持两种风格的“通用”模式，于是通用模块规范（UMD）诞生了。&lt;/p&gt;
&lt;p&gt;不得不承认，这个模式略难看，但是它兼容了AMD和CommonJS，同时还支持老式的“全局”变量规范，同时兼容前后端，模块定义写法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (root, factory) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; define === 'function' &amp;amp;&amp;amp;&lt;span&gt; define.amd) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AMD. Register as an anonymous module.&lt;/span&gt;
        define(['b'&lt;span&gt;], factory);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; module === 'object' &amp;amp;&amp;amp;&lt;span&gt; module.exports) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Node. Does not work with strict CommonJS, but&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; only CommonJS-like environments that support module.exports,&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; like Node.&lt;/span&gt;
        module.exports = factory(require('b'&lt;span&gt;));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Browser globals (root is window)&lt;/span&gt;
        root.returnExports =&lt;span&gt; factory(root.b);
    }
}(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;use b in some fashion.&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just return a value to define the module export.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; This example returns an object, but the module&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; can return a function as the exported value.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
}));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;写法2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (root, factory) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; define === 'function' &amp;amp;&amp;amp;&lt;span&gt; define.amd) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AMD&lt;/span&gt;
        define(['jquery', 'underscore'&lt;span&gt;], factory);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; exports === 'object'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Node, CommonJS之类的&lt;/span&gt;
        module.exports = factory(require('jquery'), require('underscore'&lt;span&gt;));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 浏览器全局变量(root 即 window)&lt;/span&gt;
        root.returnExports =&lt;span&gt; factory(root.jQuery, root._);
    }
}(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($, _) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; a() {
    }; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法，因为它没被返回 (见下面)&lt;/span&gt;

    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; b() {
    }; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公共方法，因为被返回了&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; c() {
    };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公共方法，因为被返回了&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 暴露公共方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        b: b,
        c: c
    }
}));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写法3(Vue)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;!
 * Vue.js v2.5.17
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (global, factory) {
    &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; exports === 'object' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; module !== 'undefined' ? module.exports =&lt;span&gt; factory() :
    &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; define === 'function' &amp;amp;&amp;amp; define.amd ?&lt;span&gt; define(factory) :
    (global.Vue &lt;/span&gt;=&lt;span&gt; factory());
}(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};

})));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.1、UMD示例&lt;/h2&gt;
&lt;h3&gt;6.1.1、定义模块Utils.js&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (global, factory) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; define === 'function' &amp;amp;&amp;amp; (define.amd ||&lt;span&gt; define.cmd)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AMD规范. 注册一个匿名模块，兼容AMD与CMD&lt;/span&gt;
&lt;span&gt;        define([], factory);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; module === 'object' &amp;amp;&amp;amp;&lt;span&gt; module.exports) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CommonJS规范，NodeJS运行环境&lt;/span&gt;
        module.exports =&lt;span&gt; factory();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器全局对象注册&lt;/span&gt;
        global.UMD =&lt;span&gt; factory();
    }
}(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = &quot;UMD!&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回要导出的对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        show: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log(&lt;/span&gt;&quot;Hello &quot; +&lt;span&gt; msg);
        }
    };
}));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6.1.2、在CommonJS规范下运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;useUtils.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; utils=require('./Utils.js'&lt;span&gt;);
utils.show();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181206105331793-1309714018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1.3、在AMD规范下运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt;
&lt;span&gt;requirejs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块依赖的基础路径，默认模块的加载位置&lt;/span&gt;
    baseUrl:'js/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;    paths:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在路径前写上m/，则表示为：js/module/&lt;/span&gt;
        m:&quot;module/&quot;&lt;span&gt;,
        jquery:&lt;/span&gt;'common/jquery/jquery-1.12.4'&lt;span&gt;,
        md:&lt;/span&gt;'module/moduleD'&lt;span&gt;,
        moduleE:&lt;/span&gt;'module/moduleE'&lt;span&gt;,
        mf:&lt;/span&gt;'module/moduleF'&lt;span&gt;,
        moduleG:&lt;/span&gt;'module/moduleG'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理非标准的amd模块&lt;/span&gt;
&lt;span&gt;    shim:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个键名为要载入的目标文件的文件名，不能随便命名否则拿不到改文件对外提供的接口的&lt;/span&gt;
        'moduleE'&lt;span&gt;:{
            exports:&lt;/span&gt;'moduleE'&lt;span&gt;
        },
        &lt;/span&gt;'moduleG'&lt;span&gt;:{
            exports:&lt;/span&gt;'moduleG'&lt;span&gt;
        }
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块引用&lt;/span&gt;
require(['m/moduleB','m/moduleC','jquery','md','moduleE','mf','moduleG','m/Tools','m/Utils'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (b,c,$,d,e,f,g,umd,mu) {
    mu.show();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AMD - requirejs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/require2.1.11.js&quot;&lt;/span&gt;&lt;span&gt; data-main&lt;/span&gt;&lt;span&gt;=&quot;js/app.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181206112417526-6818711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1.4、在CMD规范下运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;seajs.config({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了）&lt;/span&gt;
    base: './javascript/module/'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;别名配置（用变量表示文件，解决路径层级过深和实现路径映射）&lt;/span&gt;
&lt;span&gt;    alias:{
        &lt;/span&gt;'jquery':'common/jquery/jquery-1.12.4'&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路径配置（用变量表示路径，解决路径层级过深的问题）&lt;/span&gt;
&lt;span&gt;    paths: {
        &lt;/span&gt;'xy': 'xDirectory/yDirectory/'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用模块，依赖模块&lt;/span&gt;
seajs.use(['moduleA','jquery','xy/moduleC','xy/moduleD','Utils'],&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ma,$,mc,md,mu) {
    mu.show();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/sea.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/main.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181206112656998-1223096555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1.5、原生浏览器环境运行&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UMD&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;javascript/module/Utils.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    UMD.show();
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/63651/201812/63651-20181206112840741-1409334678.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的示例运行结果可以看出采用UMD定义的模块可以兼容CommonJS、AMD、CMD与浏览器原生环境，同时兼容前后台。写法并非固定可以根据需要变化。&lt;/p&gt;

&lt;p&gt;npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 &lt;em&gt;包（package）&lt;/em&gt; （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot;&gt;仓库：https://www.npmjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;7.1、npm概要&lt;/h2&gt;
&lt;p&gt;npm全称为Node Package Manager，是一个基于&lt;a class=&quot;replace_word&quot; title=&quot;Node.js知识库&quot; href=&quot;http://lib.csdn.net/base/nodejs&quot; target=&quot;_blank&quot;&gt;Node.js&lt;/a&gt;的包管理器，也是整个Node.js社区最流行、支持的第三方模块最多的包管理器。&lt;/p&gt;
&lt;p&gt;npm的初衷：JavaScript开发人员更容易分享和重用代码。&lt;/p&gt;
&lt;p&gt;npm的使用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许用户获取第三方包并使用。&lt;/li&gt;
&lt;li&gt;允许用户将自己编写的包或命令行程序进行发布分享。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;npm版本查询：npm -v &lt;/p&gt;
&lt;p&gt;npm安装：&lt;/p&gt;
&lt;p&gt;　　1、安装nodejs&lt;/p&gt;
&lt;p&gt;　　　　由于新版的nodejs已经集成了npm，所以可直接通过输入npm -v来测试是否成功安装。&lt;/p&gt;
&lt;p&gt;　　2、使用npm命令来升级npm: npm install npm -g&lt;/p&gt;
&lt;h2&gt;7.2、包（package）&lt;/h2&gt;
&lt;p&gt;包是描述一个文件或一个目录。一个包的配置通常由以下构成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个文件夹包含一个package.json配置文件。&lt;/li&gt;
&lt;li&gt;包含（含有package.json文件的文件夹）的Gzip压缩文件。&lt;/li&gt;
&lt;li&gt;解析gzip的url&lt;/li&gt;
&lt;li&gt;为注册表添加&amp;lt;name&amp;gt;@&amp;lt;version&amp;gt;的url 信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意的是即使你从来没有在注册中心发布你的公共包,你可能仍然可以得到很多所有这些package&lt;/p&gt;
&lt;h2&gt;7.3、模块（module）&lt;/h2&gt;
&lt;p&gt;模板是通过配置文件中的一个dom节点进行包含一个或多个包。通常一般由包和配置文件以及相关模块程序构成完成一个或多个业务功能操作。&lt;/p&gt;
&lt;p&gt;一个模块可以在node . js 程序中装满任何的require()任何。 以下是所有事物加载模块的例子 :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
一个文件夹package.json文件包含一个main字段。

一个文件夹index.js文件。

一个JavaScript文件。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.4、包和模块的关系&lt;/h2&gt;
&lt;p&gt;一般来说在js程序中使用require加载它们的模块在节点中进行配置npm包，一个模块不一定是一个包。&lt;/p&gt;
&lt;p&gt;例如,一些cli包, js程序节点中只包含一个可执行的 命令行界面,不提供main字段。 那么这些包不是模块。&lt;/p&gt;
&lt;p&gt;几乎所有npm包(至少,那些节点计划)包含许多模块在他们(因为每个文件加载require()是一个模块)。&lt;/p&gt;
&lt;p&gt;几乎所有的npm包都关联着多个模块，因为每个文件都使用require()加载一个模块。&lt;/p&gt;
&lt;p&gt;从module加载文件中的上下文node节点。如：var req = require('request')。我们可能会说,“request模块赋值给req这个变量”。&lt;/p&gt;
&lt;h2&gt;7.5.npm的生态系统&lt;/h2&gt;
&lt;p&gt;package.json文件定义的是包。&lt;/p&gt;
&lt;p&gt;node_modules文件夹是存储模块的地方。便于js查找模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
例如：
如果创建一个node_modules/foo.js文件，通过var f=require('foo.js')进行加载模块。因为它没有package.json文件所以foo.js不是一个包。
如果没有创建index.js包或者package.json文件&quot;main&quot;字段,即使是在安装node_modules,因为它没有require()所以它不是一个模块。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
npm install [-g] 本地或全局安装模块
npm uninstall [-g] 本地或全局卸载模块
npm update 更新模块
npm ls 查看安装的模块
npm list 列出已安装模块
npm show  显示模块详情
npm info 查看模块的详细信息
npm search 搜索模块
npm publish 发布模块
npm unpublish 删除已发布的模块
npm -v 或 npm version显示版本信息
npm view npm versions 列出npm 的所有有效版本
npm install -g npm@2.14.14 /npm update -g npm@2.14.14  安装指定的npm版本
npm init 引导创建一个package.json文件，包括名称、版本、作者这些信息等
npm outdated  #检查模块是否已经过时
npm root  [-g] 查看包的安装路径，输出 node_modules的路径，
npm help 查看某条命令的详细帮助 例如输入npm help install
npm config 管理npm的配置路径
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多介绍：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com.cn/&quot; target=&quot;_blank&quot;&gt;npm中文网：https://www.npmjs.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击查看&lt;a href=&quot;https://www.cnblogs.com/best/p/6204116.html&quot; target=&quot;_blank&quot;&gt;《Node.js开发Web后台服务》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av37008594/&quot; target=&quot;_blank&quot;&gt; https://www.bilibili.com/video/av37008594/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://git.dev.tencent.com/zhangguo5/ModuleDemo.git&quot; target=&quot;_blank&quot;&gt;https://git.dev.tencent.com/zhangguo5/ModuleDemo.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git.dev.tencent.com/zhangguo5/Module01.git&quot; target=&quot;_blank&quot;&gt;https://git.dev.tencent.com/zhangguo5/Module01.git&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 06 Dec 2018 07:05:00 +0000</pubDate>
<dc:creator>张果</dc:creator>
<og:description>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切。 前端模块化规范如下： 一、前端模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/best/p/10076782.html</dc:identifier>
</item>
<item>
<title>谷歌公墓，埋葬谷歌淘汰的产品 - 极光推送</title>
<link>http://www.cnblogs.com/jpush88/p/10076679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpush88/p/10076679.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;简评：Google 一向喜欢尝试各种各样的新产品和好创意。但是由于产品人气、行业趋势和公司整体战略调整等因素，很多产品最终难逃被关闭的命运。逝去的 Google Reader 并不孤单，还有很多被 Google 淘汰的产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发者 Naeem Nur 搭建了一个网站「The Google Cemetery」，顾名思义 —— 谷歌公墓，这个网站收录了 Google 淘汰的自家产品。&lt;/p&gt;
&lt;p&gt;网站上各个产品简介中指出了其诞生与死亡时间，并链接到该产品的具体描述页面，同时还标注了为什么死亡的原因。&lt;/p&gt;
&lt;p&gt;点开下图可以查看有没有你熟悉的产品：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/cb60505ad6dd737426f336499559f166b79.jpg&quot;/&gt;&lt;br/&gt;详情可查看文末的原文链接&lt;/p&gt;
&lt;p&gt;最近被淘汰的一个产品是 Google+，这是 Google 旗下的一款社交网站，谷歌将在 2019 年 8 月彻底关闭 Google+ 服务，它们为用户准备了 10 个月的停摆期。&lt;/p&gt;
&lt;p&gt;不过 Google 官方也很实诚，大方承认了 Google+ 被关闭的真正原因还是用户太少。值得一提的是，Google+ 被彻底抛弃除了社交败北、用户流失之外，还因为这项服务出现了巨大漏洞，恶意开发者有可能通过该漏洞收集数亿谷歌用户的数据。&lt;/p&gt;
&lt;p&gt;不得不承认这不仅是一个有趣的网站，也是一个能让人们收获知识的平台。&lt;/p&gt;
&lt;blockquote readability=&quot;2.2058823529412&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://link.zhihu.com/?target=https://gcemetery.co/&quot;&gt;The Google Cemetery&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 06 Dec 2018 06:51:00 +0000</pubDate>
<dc:creator>极光推送</dc:creator>
<og:description>简评：Google 一向喜欢尝试各种各样的新产品和好创意。但是由于产品人气、行业趋势和公司整体战略调整等因素，很多产品最终难逃被关闭的命运。逝去的 Google Reader 并不孤单，还有很多被 G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpush88/p/10076679.html</dc:identifier>
</item>
<item>
<title>存储过程优缺点-附加简单例子 - 逗小先森</title>
<link>http://www.cnblogs.com/lau-4/p/10076624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lau-4/p/10076624.html</guid>
<description>&lt;p&gt;1、什么是存储过程？&lt;/p&gt;
&lt;p&gt;       存储过程（Stored Procedure）是在大型&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&quot; target=&quot;_blank&quot;&gt;数据库系统&lt;/a&gt;中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。&lt;/p&gt;
&lt;p&gt;2、存储过程的优点：&lt;/p&gt;
&lt;p&gt;        A、 存储过程允许标准组件式编程&lt;/p&gt;
&lt;p&gt;        存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。&lt;/p&gt;
&lt;p&gt;        B、 存储过程能够实现较快的执行速度&lt;/p&gt;
&lt;p&gt;        如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。因为&lt;strong&gt;存储过程是预编译的&lt;/strong&gt;，在首次运行一个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。&lt;/p&gt;
&lt;p&gt;        C、 存储过程减轻网络流量&lt;/p&gt;
&lt;p&gt;        对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。&lt;/p&gt;
&lt;p&gt;        D、 存储过程可被作为一种安全机制来充分利用&lt;/p&gt;
&lt;p&gt;        系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。&lt;/p&gt;
&lt;p&gt;　　 E、可扩展性：应用程序和数据库操作分开，独立进行，而不是相互在一起。方便以后的扩展和DBA维护优化。&lt;/p&gt;
&lt;p&gt;　　总述：执行快、减少网络传输、可以维护性强、加强安全性、可扩展性强&lt;/p&gt;
&lt;p&gt;3、存储过程的缺点：&lt;/p&gt;
&lt;p&gt;　　 A. SQL本身是一种结构化查询语言，但不是面向对象的的，本质上还是过程化的语言，面对复杂的业务逻辑，过程化的处理会很吃力。同时SQL擅长的是数据查询而非业务逻辑的处理，如果如果把业务逻辑全放在存储过程里面，违背了这一原则。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; 　　B. 如果需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则您仍需要更新程序集中的代码以添加参数、更新调用，等等，这时候估计会比较繁琐了。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; 　　C. 开发调试复杂，由于IDE的问题，存储过程的开发调试要比一般程序困难。     &lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; 　　D. 没办法应用缓存。虽然有全局临时表之类的方法可以做缓存，但同样加重了数据库的负担。如果缓存并发严重，经常要加锁，那效率实在堪忧。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　 E. 不支持群集，数据库服务器无法水平扩展，或者数据库的切割（水平或垂直切割）。数据库切割之后，存储过程并不清楚数据存储在哪个数据库中。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　总述：编写复杂度高、逻辑性强、更改不便等&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;4、优缺点总述：&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　1、我们要适当的使用存储过程来提高我们查询的质量，如复杂的连接查询等&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　2、避免滥用，因为开发存储过程需要时间，避免复杂的逻辑而去使用存储过程，减少数据库的压力&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;5、数据库中的存储过程有二部分：&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　1、系统存储过程：系统存储过程是系统创建的存储过程以“sp”下划线开头的存储过程一般存放在master数据库中，其目的是为了帮助我们调用、更新和管理系统相关的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
exec sp_databases; --&lt;span&gt;查看数据库
exec sp_tables;        &lt;/span&gt;--&lt;span&gt;查看表
exec sp_columns student;&lt;/span&gt;--&lt;span&gt;查看列
exec sp_helpIndex student;&lt;/span&gt;--&lt;span&gt;查看索引
exec sp_helpConstraint student;&lt;/span&gt;--&lt;span&gt;约束
exec sp_stored_procedures;
exec sp_helptext &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sp_stored_procedures&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;--&lt;span&gt;查看存储过程创建、定义语句
exec sp_rename student, stuInfo;&lt;/span&gt;--&lt;span&gt;修改表、索引、列的名称
exec sp_renamedb myTempDB, myDB;&lt;/span&gt;--&lt;span&gt;更改数据库名称
exec sp_defaultdb &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;myDB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;--&lt;span&gt;更改登录名的默认数据库
exec sp_helpdb;&lt;/span&gt;--&lt;span&gt;数据库帮助，查询数据库信息
exec sp_helpdb master;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、用户自定义的存储过程：&lt;/p&gt;
&lt;p&gt;　　基本语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
create proc |&lt;span&gt; procedure pro_name
    [{@参数数据类型} [&lt;/span&gt;=&lt;span&gt;默认值] [output],
     {@参数数据类型} [&lt;/span&gt;=&lt;span&gt;默认值] [output],
     ....
    ]
&lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt;
    SQL_statements&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不带参数的存储过程语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (exists (&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; sys.objects &lt;span&gt;where&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proc_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    drop proc proc_name
go
create proc proc_name
&lt;/span&gt;&lt;span&gt;as&lt;/span&gt;
    &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; student;

&lt;/span&gt;--&lt;span&gt;调用、执行存储过程
exec proc_name;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　掌握了基本语法之后，试着去写几个复杂的存储过程，在实际应用中还是有很多好处的，毕竟对于后端开发工程师来说：这是一个必经之路，当然对于DBA（数据库管理员）来说，这个都是非常EASY的事情&lt;/p&gt;
&lt;p&gt;　　最后作者在奉献一个我在开发中写的一个存储过程：非常简单希望各位大神不要笑(*^_^*)&lt;/p&gt;
&lt;p&gt;　　这是一个红酒检验检疫查询&lt;/p&gt;
&lt;p&gt;展示存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE PROC [dbo].[Proc_Check_Checkout] 
    @pageIndex AS INT,
    @pageSize AS INT,
    @ForecastBegin AS NVARCHAR(MAX),&lt;/span&gt;--&lt;span&gt;预检
    @ForecastEnd AS NVARCHAR(MAX),
    @InspectionBegin AS NVARCHAR(MAX),&lt;/span&gt;--&lt;span&gt;报检
    @InspectionEnd AS NVARCHAR(MAX), 
    @CheckoutID AS NVARCHAR(MAX),&lt;/span&gt;--&lt;span&gt;预检单号
    @InspectionID AS NVARCHAR(MAX),&lt;/span&gt;--&lt;span&gt;报检单号
    @recordCount  AS INT OUTPUT
AS
    SET NOCOUNT ON
    DECLARE @tempPageSize INT;
    SET @tempPageSize &lt;/span&gt;= (@pageIndex - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; @pageSize;

 SELECT 
 &lt;/span&gt;--&lt;span&gt;第一二条查询
 t1.ID,t2.CheckoutID,t1.QuarantineID,t1.PurchaseContract,t1.Origin,t1.Consignee,t1.GoodsName,t1.Bottle,t1.Numbers,t1.RiseNumber,t1.Mount,CONVERT(NVARCHAR(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;),t1.ForecastDate,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) AS ForecastDate,
 t2.InspectionID,t2.KBottle,t2.KNumbers,t2.KRiseNumber,
 &lt;/span&gt;--&lt;span&gt;三四条查询
 t2.Franchisee,t2.Brand,t2.BottleInspection,t2.NewspaperNumber,t2.NumberInspection,t2.CheckMount,CONVERT(NVARCHAR(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;),t2.HisDate,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;) AS HisDate,t2.InspectionDate
 INTO #TempData1
 FROM dbo.TBPreview_Table AS t1 

 LEFT JOIN dbo.TBCheckout AS t2 ON t2.CheckoutID &lt;/span&gt;=&lt;span&gt; t1.ID
 ORDER BY t1.Date DESC ;


 SELECT &lt;/span&gt;* INTO #TempData2 FROM #TempData1 WHERE &lt;span&gt;1&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

 &lt;/span&gt;--&lt;span&gt;时间检索 
 IF @ForecastBegin IS NOT NULL AND LEN(@ForecastBegin) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.ForecastDate &amp;gt;=&lt;span&gt; @ForecastBegin;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END
 
 &lt;/span&gt;--&lt;span&gt;
 IF @ForecastEnd IS NOT NULL AND LEN(@ForecastEnd) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.ForecastDate &amp;lt; DATEADD(DAY,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,@ForecastEnd) ;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END
 
 &lt;/span&gt;--&lt;span&gt;时间检索 报检时间
 IF @InspectionBegin IS NOT NULL AND LEN(@InspectionBegin) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.InspectionDate &amp;gt;=&lt;span&gt; @InspectionBegin;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END
 
 &lt;/span&gt;--&lt;span&gt;
 IF @InspectionEnd IS NOT NULL AND LEN(@InspectionEnd) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.InspectionDate &amp;lt; DATEADD(DAY,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,@InspectionEnd) ;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END
 
 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 预检单号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  IF @CheckoutID IS NOT NULL AND LEN(@CheckoutID) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.QuarantineID LIKE &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+@CheckoutID+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 报检单号&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   IF @InspectionID IS NOT NULL AND LEN(@InspectionID) &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 BEGIN
        TRUNCATE TABLE #TempData2;
        INSERT INTO #TempData2 
        SELECT &lt;/span&gt;*FROM #TempData1 AS t WHERE t.InspectionID LIKE &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+@InspectionID+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ;
        TRUNCATE TABLE #TempData1;
        INSERT INTO #TempData1 SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData2;
 END

SELECT @recordCount &lt;/span&gt;= COUNT(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) FROM #TempData1;
    DROP TABLE #TempData2;
    SELECT &lt;/span&gt;* INTO #TempData3 FROM #TempData1 WHERE &lt;span&gt;1&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    INSERT INTO #TempData3
    SELECT TOP (@pageSize) t1.&lt;/span&gt;*&lt;span&gt; FROM #TempData1 AS t1 , 
    (SELECT &lt;/span&gt;*&lt;span&gt; , ROW_NUMBER() OVER (ORDER BY ID) AS RowNumber FROM #TempData1) AS t2
    WHERE t1.ID &lt;/span&gt;= t2.ID AND RowNumber &amp;gt;&lt;span&gt; @tempPageSize 
    ORDER BY t2.RowNumber;
    DROP TABLE #TempData1;
    SELECT &lt;/span&gt;*&lt;span&gt; FROM #TempData3;
GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后作者希望各位指出作者的不足，毕竟在程序这条路才刚刚起步！&lt;/p&gt;



&lt;p class=&quot;p0&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 06:43:00 +0000</pubDate>
<dc:creator>逗小先森</dc:creator>
<og:description>1、什么是存储过程？ 存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lau-4/p/10076624.html</dc:identifier>
</item>
<item>
<title>异常处理 - ReFantasy</title>
<link>http://www.cnblogs.com/refantasy/p/10076574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refantasy/p/10076574.html</guid>
<description>&lt;p&gt;异常处理字面的意思就是：当程序出现了不符合预期的情况（不一定是错误），采取一定的后续措施进行处理。&lt;/p&gt;
&lt;h2 id=&quot;异常处理机制&quot;&gt;异常处理机制&lt;/h2&gt;
&lt;p&gt;我们以一个简单但不是很严谨的例子作为开始，来介绍异常处理机制。&lt;/p&gt;
&lt;p&gt;假设我们有一个图书销售系统。系统里面有某个自定义类型&lt;code&gt;class BookISBN;&lt;/code&gt;，表示某本书的ISBN编号。&lt;/p&gt;
&lt;p&gt;主程序大概是这样：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;class BookISBN
{
public:
    // ...
    std::string GetISBN() const;  // 成员函数，返回ISBN编号
    // ...
}

// ...
int main()
{
    Init();     // 初始化系统
    while(1)
    {
        run();  // 运行系统
    }
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设系统的运行过程中需要比较两本图数的价格：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void run()
{
    // ...
    if(book_a.GetISBN() == book_b.GetISBN())        // book_a book_b 假设已经定义
    {
        // 继续后面的处理
    }
    else
    {
        cout&amp;lt;&amp;lt; &quot;错误！两本书的ISBN不一样，不能进行比较！&quot;;
        // 进行出错后的其它后续操作，比如释放内存一类的
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，在上面的程序中，我们可以采用分支条件来处理意外出现的情况。&lt;/p&gt;
&lt;p&gt;现在我们思考两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果程序不止一处需要做这样的意外处理呢？&lt;/li&gt;
&lt;li&gt;如果意外情况是嵌套在系统的深层（上面的 if-else 是被 run 间接调用），而出现错误后需要跳转到上层调用的某个特定位置呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对第一个问题：我们可以将意外处理（也就是异常处理）封装成一个函数，然后在需要的地方调用。&lt;/p&gt;
&lt;p&gt;针对第二个问题：我们可以精心设计函数的接口，使其满足我们的处理流程。但这是很困难的一件事。&lt;/p&gt;
&lt;p&gt;所以上面给出的解决方案，理论上可以实现我们的需求，但是较为繁琐，对于程序设计的能力要求也就高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是，异常处理机制便出现了。异常处理从感官上来看表现得更为优雅，从功能上来说还能将问题的检测和解决分离开，实现统一处理。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;异常处理机制的流程&quot;&gt;异常处理机制的流程&lt;/h2&gt;
&lt;p&gt;当程序出现异常的时候，我们需要记录下发生的异常信息，比如数组越界，内存不足等等。而记录异常信息的方式便是通过一个对象来保存这些信息，这个对象也叫做异常对象。&lt;/p&gt;
&lt;p&gt;异常对象的类型既可以是&lt;strong&gt;STL&lt;/strong&gt;提供的类型，也可以是自定义的类。&lt;strong&gt;如果是自定义异常类型，该类型必须具有拷贝构造函数或者移动构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常处理机制的流程是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抛出异常对象。在异常发生的位置通过关键字&lt;code&gt;throw&lt;/code&gt;抛出一个异常对象&lt;/li&gt;
&lt;li&gt;接收异常对象并进行异常处理。在异常发生的作用域内或者外层作用域内接受异常并处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面主要分两个部分介绍异常处理。&lt;/p&gt;
&lt;h2 id=&quot;抛出异常对象&quot;&gt;抛出异常对象&lt;/h2&gt;
&lt;p&gt;我们先定义一个异常类型&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;class Error
{
public:
    Error() = default;
    Error(string error_type):_error_type(error_type){}
    Error(const Error &amp;amp;error) = default;                  // 使用合成的拷贝构造函数
private:
    string _error_type;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如何抛出异常呢？&lt;/p&gt;
&lt;p&gt;通过关键字&lt;code&gt;throw&lt;/code&gt;。抛出异常对象的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;// ...
Error error(&quot;这是一个异常&quot;);  // 定义异常对象
throw error;                // 抛出异常
// 当然也可以这样 throw Error(&quot;这是一个异常&quot;);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们的图数销售系统中使用抛出异常的完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;// 系统中的类类型
class BookISBN
{
public:
    // ...
    std::string GetISBN() const;  // 成员函数，返回ISBN编号
}

// 异常对象类型
class Error
{
public:
    Error() = default;
    Error(string error_type):_error_type(error_type){}
    Error(const Error &amp;amp;error) = default;                  // 使用合成的拷贝构造函数
private:
    string _error_type;
}

// 主函数
void run()
{
    // ...
    if(book_a.GetISBN() == book_b.GetISBN())        // book_a book_b 假设已经定义
    {
        // 继续后面的处理
    }
    else
    {
        /************************************************************/
        *    抛出异常                                                 *
        *    异常的处理交给异常接收代码（后面介绍如何接收异常）              *
        *************************************************************/
        throw Error(&quot;错误！两本书的ISBN不一样，不能进行比较！&quot;);  // 抛出异常
    }
}

// 主程序
int main()
{
    Init();     // 初始化系统
    
    while(1)
    {
        run();  // 运行系统
    }
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;程序在执行&lt;code&gt;throw error_object&lt;/code&gt;后到底做了什么事呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在全局作用域内创建了一个&lt;code&gt;error_object&lt;/code&gt;的副本。这个临时全局对象的地址由编译器进行分配管理，在合适的时候（比如异常处理结束）由编译器进行销毁。程序员不用操心。&lt;/p&gt;
&lt;p&gt;所以这也是为什么异常对象必须要有拷贝（移动）构造函数的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;销毁&lt;code&gt;throw&lt;/code&gt;语句前已经创建的局部对象。大家可以把&lt;code&gt;throw&lt;/code&gt;理解为具有&lt;code&gt;return&lt;/code&gt;功能的关键字。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;throw&lt;/code&gt;之前一定要释放&lt;code&gt;new/malloc&lt;/code&gt;的对象防止内存泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外需要声明的一点就是，在创建异常对象的全局副本的时候是按照静态类型来拷贝。&lt;/p&gt;
&lt;p&gt;假设类&lt;code&gt;Derived&lt;/code&gt;继承自类&lt;code&gt;Base&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;Derived d;
Base &amp;amp;rd = d;
throw rd;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，创建的异常对象&lt;code&gt;d&lt;/code&gt;的全局副本只包含基类&lt;code&gt;Base&lt;/code&gt;的部分。（这个是很自然的事，特别写出来是担心大家有疑虑）&lt;/p&gt;
&lt;h2 id=&quot;接收异常对象并处理&quot;&gt;接收异常对象并处理&lt;/h2&gt;
&lt;p&gt;当我们抛出对象之后，程序就开始搜索可以接收异常对象的代码。接收异常的方式是使用&lt;code&gt;try catch&lt;/code&gt;两个关键字。&lt;/p&gt;
&lt;p&gt;具体的用法入下代码：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;try
{
    // 这里是包含可能抛出异常的代码
}
catch(ErrorType1 error)  // 
{
    // 处理异常。想怎么处理就怎么写呗。
}
catch(ErrorType2 error)
{
    // 同上
    // catch 分支可以有一个也可以有多个，看自己需要
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;try&lt;/code&gt;的作用域内抛出异常。编译器在外部作用域查找到&lt;code&gt;catch&lt;/code&gt;关键字接收异常，然后就像函数调用一样，用异常对象的全局副本作为实参，传进与之类型相匹配的&lt;code&gt;catch&lt;/code&gt;块中，然后继续执行代码。&lt;/p&gt;
&lt;p&gt;我们把接收异常的代码加入主程序后的完整代码：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;// 系统中的类类型
class BookISBN
{
public:
    // ...
    std::string GetISBN() const;  // 成员函数，返回ISBN编号
}

// 异常对象类型
class Error
{
public:
    Error() = default;
    Error(string error_type):_error_type(error_type){}
    Error(const Error &amp;amp;error) = default;                  // 使用合成的拷贝构造函数
private:
    string _error_type;
}

// 主函数
void run()
{
    // ...
    if(book_a.GetISBN() == book_b.GetISBN())        // book_a book_b 假设已经定义
    {
        // 继续后面的处理
    }
    else
    {
        throw Error(&quot;错误！两本书的ISBN不一样，不能进行比较！&quot;);  // 抛出异常
    }
}

// 主程序
int main()
{
    Init();     // 初始化系统
    
    while(1)
    {
        /************************************************************/
        *    将可能抛出异常的代码用 try 块包含                           *
        *    一旦 try 中的代码抛出异常 跟随 try 后面的 catch 便会捕捉到抛出 *
        *    的异常。（如果没有匹配的catch块就继续往上一层搜索，如果最后没有任 *
        *    何相匹配的catch，则程序直接终止。                            *
        *************************************************************/
        try
        {
            run();  // 运行系统
        }
        catch(Error e)
        {
            // 处理异常
        }
    }
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外需要注意的三点说明：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;注意&lt;code&gt;catch&lt;/code&gt;块的接收顺序，尤其是异常类型是具有继承关系的类型。&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;class Base;
class Derived:public Base;
void f()
{
    try
    {
        throw Derived();  // 抛出 Derived 类型的异常
    }
    catch(Base b)
    {
        // 异常会被 Base 接收。（进行了隐式类型转换。这是和赋值操作一样的嘛，很好理解。）
    }
    catch(Derived d)
    {
        // 异常不会进入这里
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;catch&lt;/strong&gt;会进行的隐式类型转换只有三种：常量-&amp;gt;非常量、子类-&amp;gt;父类、数组-&amp;gt;指向数组首元素的指针（函数类似）。其它的任何类型都不会隐式转换，比如catch(int) 不能就收double类型的异常对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;重抛出&lt;/p&gt;
&lt;p&gt;如果直接&lt;code&gt;throw;&lt;/code&gt;不跟异常对象，那么就会抛出当前作用域内的异常对象，如果当前作用域没有则抛出上层作用域内的对象。&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;try
{
    // ...
}
catch(Error e)
{
    // ...
    throw ;  // 相当于 throw e; 
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;捕获所有的异常&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;catch&lt;/code&gt;的参数是&lt;code&gt;...&lt;/code&gt;即&lt;code&gt;catch(...)&lt;/code&gt;则这个catch块将接收当前作用域内（包括嵌套的内存作用域）之前所有没被接收的异常对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;异常处理的其它相关细节&quot;&gt;异常处理的其它相关细节&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;构造函数初始化列表抛出异常&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;class Test
{
public:
    Test(Object ob)
        :_ob(bo)        // 如果此时抛出异常，那么构造函数内的异常处理并不能接收到
        {               // 这个异常将会跑到构造Test类的作用域中，而且未构造完的Test对象并不会析构
            // ...
            try
            {
                
            }
            catch
            {
                
            }
        }
private:
    Object _ob;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换的方法如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Test
{
public:
    Test(Object ob) try:_ob(bo)      
    {               
        // ...
    }
    catch(...)        // catch既能接收初始化列表抛出的异常
    {                 // 也能够接收构造函数块里面的异常
        
    }
private:
    Object _ob;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;noexcept说明符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;noexcept&lt;/code&gt;的意思是不抛出异常&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void f()noexcept
{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果声明了 &lt;code&gt;noexcept&lt;/code&gt;的函数抛出了异常，则程序直接终止。局部对象是否被释放是未定义的。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Dec 2018 06:35:00 +0000</pubDate>
<dc:creator>ReFantasy</dc:creator>
<og:description>异常处理字面的意思就是：当程序出现了不符合预期的情况（不一定是错误），采取一定的后续措施进行处理。 异常处理机制 我们以一个简单但不是很严谨的例子作为开始，来介绍异常处理机制。 假设我们有一个图书销售</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refantasy/p/10076574.html</dc:identifier>
</item>
</channel>
</rss>