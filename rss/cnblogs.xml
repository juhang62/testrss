<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>AppBoxFuture(五): 分布式文件存储-Store Everything - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/10415698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/10415698.html</guid>
<description>&lt;p&gt;  本来本篇是想介绍前端组件化开发用户界面，发现框架还未实现文件存储，原本计划是后续设计开发的，索性把计划提前，所以本篇将介绍基于Raft实现分布式的文件存储引擎。&lt;/p&gt;

&lt;p&gt;  既然是分布式存储，就需要解决以下几个关键问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何将文件以多副本的形式存储在集群的节点上，且保证副本间的一致性？这个问题可基于Raft协议实现相应的状态机来解决；&lt;/li&gt;
&lt;li&gt;如何将大量的文件分组，即如何划分多个Raft组？这个问题可通过在目录元数据内保存多个Raft组信息，每个组存储限制在64M（暂定）来解决；&lt;/li&gt;
&lt;li&gt;如何存储与管理目录及文件的元数据？这个问题可通过实现元数据状态机来管理，利用已实现的KV存储引擎来存储元数据；&lt;/li&gt;
&lt;li&gt;如何保证元数据与文件数据的一致性？这个问题开始时想用已实现的EntityStore的事务引擎来解决，虽能保证强一致性但逻辑复杂，性能损失大。因此放弃了强一致性改为保证最终一致性，元数据状态机及文件状态机内都有定时器来检查不一致的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  开始时想设计为一个集群对应一个BlobMetaRaftGroup，后来考虑到单个RaftGroup可能会压力较大，所以改为每个Application对应一个BlobMetaRaftGroup。每个元数据状态机主要存储以下各项信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目录元数据：包括目录名称及标识，该目录下分配了多少个Chunk，每个Chunk占用了多少空间，隶属于哪个RaftGroup等；&lt;/li&gt;
&lt;li&gt;文件元数据：包括文件名称及标识，该文件隶属的目录标识及隶属的ChunkRaftGroup标识等；&lt;/li&gt;
&lt;li&gt;Chunk元数据： 包括Chunk的RaftGroup内的各个RaftNode分配在集群的哪个节点上；&lt;/li&gt;
&lt;li&gt;写锁数据：用于并发写时加锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  确认了需要存储哪些信息后，就需要确认如何将这些数据映射至底层的KV存储，既要保证高效又要方便Api检索这些元数据，经过一些尝试后最终定为以下方案。&lt;/p&gt;
&lt;h3 id=&quot;目录元数据-key&quot;&gt;目录元数据 Key&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;8bit&lt;/td&gt;
&lt;td&gt;8bit&lt;/td&gt;
&lt;td&gt;n bit&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;TypeFlag = 0&lt;/li&gt;
&lt;li&gt;注意:最后一个'/' 0x2F被替换为0x00，以方便扫描某一目录下所有子目录&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;目录元数据-value&quot;&gt;目录元数据 Value&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;128bit&lt;/td&gt;
&lt;td&gt;16bit&lt;/td&gt;
&lt;td&gt;n * 64bit&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;文件元数据-key&quot;&gt;文件元数据 Key&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;8bit&lt;/td&gt;
&lt;td&gt;8bit&lt;/td&gt;
&lt;td&gt;128bit&lt;/td&gt;
&lt;td&gt;8bit&lt;/td&gt;
&lt;td&gt;n bit&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;TypeFlag = 1&lt;/li&gt;
&lt;li&gt;分隔占位始终 = 0&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件元数据-value&quot;&gt;文件元数据 Value&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;128bit&lt;/td&gt;
&lt;td&gt;32bit&lt;/td&gt;
&lt;td&gt;64bit&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;文件存储-blobchunkstatemachine&quot;&gt;2. 文件存储-BlobChunkStateMachine&lt;/h2&gt;
&lt;p&gt;  根据上述设计，每个目录下的文件分成了多个存储组（BlobChunkRaftGroup），本来想用MemoryMapFile来实现底层Chunk存储，但考虑到有更重要的功能要实现所以暂偷懒直接利用Linux文件系统来存储文件，状态机Apply文件写命令时，将文件直接写入节点运行时blob/ChunkRaftGroupId/目录下。&lt;/p&gt;
&lt;h2 id=&quot;读写流程&quot;&gt;3. 读写流程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;读流程较简单: 发送读元数据命令至BlobMetaRaftGroup获取文件元数据（缓存），然后再分小块发读命令至目标ChunkRaftGroup获取文件小块数据；&lt;/li&gt;
&lt;li&gt;写流程要考虑元数据与文件数据的一致性，还要考虑在目录下无可用ChunkRaftGroup时创建新的组，具体参考以下设计草图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201902/4928-20190221221406005-1751039725.jpg&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  根据以上设计在经历了1个月的编码后已初步实现（其中约一半时间在更改架构，抛弃了Mono依赖，改为Hosting CoreCLR，性能提升1倍），在框架IDE内每个Application内有个&quot;BlobStore&quot;节点，如下图所示可测试上传文件，然后通过浏览器访问上传至/pub目录内的文件（&lt;a href=&quot;http://%7B%E5%9C%B0%E5%9D%80:%E7%AB%AF%E5%8F%A3%7D/blob/%7Bapp%E5%90%8D%E7%A7%B0%7D/%7B%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%7D&quot; class=&quot;uri&quot;&gt;http://{地址:端口}/blob/{app名称}/{文件路径}&lt;/a&gt; eg: &lt;a href=&quot;http://xx.xx.xx.xx:5000/blob/sys/imgs/aa.jpg&quot; class=&quot;uri&quot;&gt;http://xx.xx.xx.xx:5000/blob/sys/imgs/aa.jpg&lt;/a&gt;）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201902/4928-20190221221418198-1750554165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  作者简单测试了一下通过框架WebHost下载文件的性能(测试时尚未实现缓存元数据, 虚拟机I74C8G)，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201902/4928-20190221221429943-368652057.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  本实现适用于存储大量小文件，如业务单证的附件，或者用于OA系统作为文档库。目前只是实现了基本的上传下载功能，删除、重命名、Chunk合并等功能尚未实现，另待将来框架实现反向索引后再实现全文搜索功能。&lt;/p&gt;
&lt;p&gt;  框架已更新，如何安装测试请参考&lt;a href=&quot;https://www.cnblogs.com/BaiCai/p/10018947.html&quot;&gt;AppBoxFuture(一): Hello Future!&lt;/a&gt;（架构图尚未更新）。如果您有问题或Bug报告，请留言或在&lt;a href=&quot;https://github.com/enjoycode/appbox.deploy&quot;&gt;Github&lt;/a&gt;提交Issue。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 23:36:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  本来本篇是想介绍前端组件化开发用户界面，发现框架还未实现文件存储，原本计划是后续设计开发的，索性把计划提前，所以本篇将介绍基于Raft实现分布式的文件存储引擎。 一. 实现思路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BaiCai/p/10415698.html</dc:identifier>
</item>
<item>
<title>都2019年了，还问GET和POST的区别 - Fundebug</title>
<link>http://www.cnblogs.com/fundebug/p/10416234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fundebug/p/10416234.html</guid>
<description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 对比GET与POST。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;1. 前言&lt;/h3&gt;
&lt;p&gt;最近看了一些同学的面经，发现无论什么技术岗位，还是会问到 get 和 post 的区别，而搜索出来的答案并不能让我们装得一手好逼，那就让我们从 HTTP 报文的角度来撸一波，从而搞明白他们的区别。&lt;/p&gt;
&lt;h3 id=&quot;标准答案&quot;&gt;2. 标准答案&lt;/h3&gt;
&lt;p&gt;在开撸之前吗，让我们先看一下标准答案长什么样子 &lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_httpmethods.asp&quot;&gt;w3school: GET 对比 POST&lt;/a&gt;。标准答案很美好，但是在面试的时候把下面的表格甩面试官一脸，估计会装逼不成反被*。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;后退按钮/刷新&lt;/td&gt;
&lt;td&gt;无害&lt;/td&gt;
&lt;td&gt;数据会被重新提交（浏览器应该告知用户数据会被重新提交）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;书签&lt;/td&gt;
&lt;td&gt;可收藏为书签&lt;/td&gt;
&lt;td&gt;不可收藏为书签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;缓存&lt;/td&gt;
&lt;td&gt;能被缓存&lt;/td&gt;
&lt;td&gt;不能缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;编码类型&lt;/td&gt;
&lt;td&gt;application/x-www-form-urlencoded&lt;/td&gt;
&lt;td&gt;application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;历史&lt;/td&gt;
&lt;td&gt;参数保留在浏览器历史中。&lt;/td&gt;
&lt;td&gt;参数不会保存在浏览器历史中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;对数据长度的限制&lt;/td&gt;
&lt;td&gt;是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。&lt;/td&gt;
&lt;td&gt;无限制。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;对数据类型的限制&lt;/td&gt;
&lt;td&gt;只允许 ASCII 字符。&lt;/td&gt;
&lt;td&gt;没有限制。也允许二进制数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;安全性&lt;/td&gt;
&lt;td&gt;与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！&lt;/td&gt;
&lt;td&gt;POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可见性&lt;/td&gt;
&lt;td&gt;数据在 URL 中对所有人都是可见的。&lt;/td&gt;
&lt;td&gt;数据不会显示在 URL 中。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意，并不是说标准答案有误，上述区别在&lt;strong&gt;大部分浏览器&lt;/strong&gt;上是存在的，因为这些浏览器实现了 HTTP 标准。&lt;/p&gt;
&lt;p&gt;所以从标准上来看，GET 和 POST 的区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GET 用于获取信息，是无副作用的，是幂等的，且可缓存&lt;/li&gt;
&lt;li&gt;POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，既然本文从报文角度来说，那就先不讨论 RFC 上的区别，单纯从数据角度谈谈。&lt;/p&gt;
&lt;h3 id=&quot;get-和-post-报文上的区别&quot;&gt;3. GET 和 POST 报文上的区别&lt;/h3&gt;
&lt;p&gt;先下结论，&lt;strong&gt;GET 和 POST 方法没有实质区别&lt;/strong&gt;，只是报文格式不同。&lt;/p&gt;
&lt;p&gt;GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。&lt;/p&gt;
&lt;p&gt;报文格式上，不带参数时，最大区别就是第一行方法名不同&lt;/p&gt;
&lt;p&gt;POST方法请求报文第一行是这样的 &lt;code&gt;POST /uri HTTP/1.1 \r\n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;GET方法请求报文第一行是这样的 &lt;code&gt;GET /uri HTTP/1.1 \r\n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是的，不带参数时他们的区别就仅仅是报文的前几个字符不同而已&lt;/p&gt;
&lt;p&gt;带参数时报文的区别呢？ 在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中&lt;/p&gt;
&lt;p&gt;举个例子，如果参数是 name=qiming.c, age=22。&lt;/p&gt;
&lt;p&gt;GET 方法简约版报文是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /index.php?name=qiming.c&amp;amp;age=22 HTTP/1.1
Host: localhost&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;POST 方法简约版报文是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /index.php HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&amp;amp;age=22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们知道了两种方法本质上是 TCP 连接，没有差别，也就是说，如果我不按规范来也是可以的。我们可以在 URL 上写参数，然后方法使用 POST；也可以在 Body 写参数，然后方法使用 GET。当然，这需要服务端支持。&lt;/p&gt;
&lt;h3 id=&quot;常见问题&quot;&gt;4. 常见问题&lt;/h3&gt;
&lt;h4 id=&quot;get-方法参数写法是固定的吗&quot;&gt;GET 方法参数写法是固定的吗？&lt;/h4&gt;
&lt;p&gt;在约定中，我们的参数是写在 &lt;code&gt;?&lt;/code&gt; 后面，用 &lt;code&gt;&amp;amp;&lt;/code&gt; 分割。&lt;/p&gt;
&lt;p&gt;我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。&lt;/p&gt;
&lt;p&gt;也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是 &lt;code&gt;http://www.example.com/user/name/chengqm/age/22&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;post-方法比-get-方法安全&quot;&gt;POST 方法比 GET 方法安全？&lt;/h4&gt;
&lt;p&gt;按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。&lt;/p&gt;
&lt;p&gt;然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。&lt;/p&gt;
&lt;p&gt;要想安全传输，就只有加密，也就是 HTTPS。&lt;/p&gt;
&lt;h4 id=&quot;get-方法的长度限制是怎么回事&quot;&gt;GET 方法的长度限制是怎么回事？&lt;/h4&gt;
&lt;p&gt;在网上看到很多关于两者区别的文章都有这一条，提到浏览器地址栏输入的参数是有限的。&lt;/p&gt;
&lt;p&gt;首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。&lt;/p&gt;
&lt;p&gt;浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。&lt;/p&gt;
&lt;h4 id=&quot;post-方法会产生两个tcp数据包&quot;&gt;POST 方法会产生两个TCP数据包？&lt;/h4&gt;
&lt;p&gt;有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。&lt;/p&gt;
&lt;p&gt;HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。&lt;/p&gt;
&lt;p&gt;所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。&lt;/p&gt;
&lt;h3 id=&quot;talk-is-cheap-show-me-the-code&quot;&gt;5. talk is cheap show me the code&lt;/h3&gt;
&lt;p&gt;如果对 get 和 post 报文区别有疑惑，直接起一个 Socket 服务端，然后封装简单的 HTTP 处理方法，直接观察和处理 HTTP 报文，就能一目了然&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import socket

HOST, PORT = '', 23333


def server_run():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind((HOST, PORT))
    listen_socket.listen(1)
    print('Serving HTTP on port %s ...' % PORT)
    while True:
        # 接受连接
        client_connection, client_address = listen_socket.accept()
        handle_request(client_connection)


def handle_request(client_connection):
    # 获取请求报文
    request = ''
    while True:
        recv_data = client_connection.recv(2400)
        recv_data = recv_data.decode()
        request += recv_data
        if len(recv_data) &amp;lt; 2400:
            break

    # 解析首行
    first_line_array = request.split('\r\n')[0].split(' ')

    # 分离 header 和 body
    space_line_index = request.index('\r\n\r\n')
    header = request[0: space_line_index]
    body = request[space_line_index + 4:]

    # 打印请求报文
    print(request)

    # 返回报文
    http_response = b&quot;&quot;&quot;\
HTTP/1.1 200 OK

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello, World!&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p style=&quot;color: green&quot;&amp;gt;Hello, World!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&quot;&quot;&quot;
    client_connection.sendall(http_response)
    client_connection.close()


if __name__ == '__main__':
    server_run()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码就是简单的打印请求报文然后返回 HelloWorld 的 html 页面，我们运行起来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@chengqm shell]# python httpserver.py 
Serving HTTP on port 23333 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后从浏览器中请求看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.fundebug.com/2019-02-21-01.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打印出来的报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.fundebug.com/2019-02-21-02.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以手动证明上述说法，比如说要测试 header 和 body 是否分开传输，由于代码没有返回 100 状态码，如果我们 post 请求成功就说明是一起传输的(Chrome/postman)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.fundebug.com/2019-02-21-03.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又比如 w3school 里面说 URL 的最大长度是 2048 个字符，那我们在代码里面加上一句计算 uri 长度的代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;...
# 解析首行
first_line_array = request.split('\r\n')[0].split(' ')
print('uri长度: %s' % len(first_line_array[1]))
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们用 postman 直接发送超过 2048 个字符的请求看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.fundebug.com/2019-02-21-04.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们可以得出结论，url 长度限制是某些浏览器和服务器的限制，和 HTTP 协议没有关系。&lt;/p&gt;
&lt;p&gt;到此，我们可以愉快地装逼了 :)&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;h3 id=&quot;关于fundebug&quot;&gt;关于Fundebug&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.fundebug.com/&quot;&gt;Fundebug&lt;/a&gt;专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了6亿+错误事件，得到了Google、360、金山软件等众多知名用户的认可。欢迎免费试用！&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 23:28:00 +0000</pubDate>
<dc:creator>Fundebug</dc:creator>
<og:description>对比GET与POST。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fundebug/p/10416234.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2.x（十一）：AOP实战--打印接口日志 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/10416230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/10416230.html</guid>
<description>&lt;h3 id=&quot;接口日志有啥用&quot;&gt;接口日志有啥用&lt;/h3&gt;
&lt;p&gt;在我们日常的开发过程中，我们可以通过接口日志去查看这个接口的一些详细信息。比如客户端的IP，客户端的类型，响应的时间，请求的类型，请求的接口方法等等，我们可以对这些数据进行统计分析，提取出我们想要的信息。&lt;/p&gt;
&lt;h3 id=&quot;怎么拿到接口日志&quot;&gt;怎么拿到接口日志&lt;/h3&gt;
&lt;p&gt;这里，我们使用的是Spring的两大杀器之AOP，通过在Controller层定义切点，然后对请求对象进行分析获取接口信息，同时开启一个ThreadLocal来记录响应时间。&lt;/p&gt;
&lt;h3 id=&quot;关于aop的注解&quot;&gt;关于AOP的注解&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Aspect&lt;/code&gt;：将一个类定义为切面类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut&lt;/code&gt;：定义一个切入点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Before&lt;/code&gt;：在切入点开始处切入内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@After&lt;/code&gt;：在切入点结尾处切入内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AfterReturning&lt;/code&gt;：在切入点返回内容之后切入内容（可以用来对处理返回值做一些加工处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Around&lt;/code&gt;：在切入点前后切入内容，并自己控制何时执行切入点自身的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AfterThrowing&lt;/code&gt;：用来处理当切入内容部分抛出异常之后的处理逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Order&lt;/code&gt;：在切入点前的操作，按order的值由小到大执行；在切入点后的操作，按order的值由大到小执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实战应用&quot;&gt;实战应用&lt;/h3&gt;
&lt;h4 id=&quot;一引入依赖&quot;&gt;一：引入依赖&lt;/h4&gt;
&lt;p&gt;首先，我们需要新增引入aop的依赖，以及用于分析客户端信息的UserAgentUtils包，还有用于&lt;code&gt;@Slf4j&lt;/code&gt;打印日志的Lombok的包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;eu.bitwalker&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;UserAgentUtils&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.20&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二定义一个responseaop切面类&quot;&gt;二：定义一个ResponseAop切面类&lt;/h4&gt;
&lt;p&gt;在之前的统一返回值和异常处理中我们已经定义过这个类，这里是对其进行完善。这里我再把代码再写一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Order(5)
@Component
@Slf4j
public class ResponseAop&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三定义一个threadlocal变量&quot;&gt;三：定义一个ThreadLocal变量&lt;/h4&gt;
&lt;p&gt;直接在这里定义基本类型会有同步问题，所以我们定义一个ThreadLocal对象来记录消耗的时间。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadLocal&amp;lt;Long&amp;gt; startTime = new ThreadLocal&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四定义切点&quot;&gt;四：定义切点&lt;/h4&gt;
&lt;p&gt;这里需要注意的是切点的写法，一定要正确才能保证AOP生效！这里附上一些简单的写法，后续会单独开一章讲解execution表达式的书写。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任意公共方法：&lt;br/&gt;&lt;code&gt;execution(public * *(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任何一个以“set”开始的方法的执行：&lt;br/&gt;&lt;code&gt;execution(* set*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Service接口的任意方法的执行：&lt;br/&gt;&lt;code&gt;execution(* com.xyz.service.Service.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义在service包里的任意方法的执行：&lt;br/&gt;&lt;code&gt;execution(* com.xyz.service.*.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;定义在service包和所有子包里的任意类的任意方法的执行：&lt;br/&gt;e&lt;code&gt;xecution(* com.xyz.service..*.*(..))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 切点
     */
    @Pointcut(&quot;execution(public * indi.viyoung.viboot.*.controller..*(..))&quot;)
    public void httpResponse() {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;五在before中获取请求信息&quot;&gt;五：在@Before中获取请求信息&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Before(&quot;httpResponse()&quot;)
    public void doBefore(JoinPoint joinPoint){
        //开始计时
        startTime.set(System.currentTimeMillis());
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        //打印请求的内容
        UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(&quot;User-Agent&quot;));//获取请求头中的User-Agent
        log.info(&quot;接口路径：{}&quot; , request.getRequestURL().toString());
        log.info(&quot;浏览器：{}&quot;, userAgent.getBrowser().toString());
        log.info(&quot;浏览器版本：{}&quot;,userAgent.getBrowserVersion());
        log.info(&quot;操作系统: {}&quot;, userAgent.getOperatingSystem().toString());
        log.info(&quot;IP : {}&quot; , request.getRemoteAddr());
        log.info(&quot;请求类型：{}&quot;, request.getMethod());
        log.info(&quot;类方法 : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
        log.info(&quot;请求参数 : {} &quot; + Arrays.toString(joinPoint.getArgs()));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;六在afterreturning中获取方法的返回值和执行时间&quot;&gt;六：在@AfterReturning中获取方法的返回值和执行时间&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @AfterReturning(returning = &quot;ret&quot; , pointcut = &quot;httpResponse()&quot;)
    public void doAfterReturning(Object ret){
        //处理完请求后，返回内容
        log.info(&quot;方法返回值：{}&quot; , ret);
        log.info(&quot;方法执行时间：{}毫秒&quot;, (System.currentTimeMillis() - startTime.get()));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;七测试结果&quot;&gt;七：测试结果&lt;/h4&gt;
&lt;p&gt;下面，我们对一个接口进行访问：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2019-02-21 21:03:31.358  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 接口路径：http://localhost:8090/users
2019-02-21 21:03:31.359  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 浏览器：CHROME
2019-02-21 21:03:31.359  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 浏览器版本：72.0.3626.109
2019-02-21 21:03:31.360  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 操作系统: MAC_OS_X
2019-02-21 21:03:31.360  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : IP : 0:0:0:0:0:0:0:1
2019-02-21 21:03:31.360  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 请求类型：GET
2019-02-21 21:03:31.360  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 类方法 : indi.viyoung.viboot.apilog.controller.UserController.findAll
2019-02-21 21:03:31.360  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 请求参数 : {} []
...
2019-02-21 21:03:31.393  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 方法返回值：ReturnVO{code='2000', message='操作成功', data=[User(id=10000001, password=123456, userName=vi-young), User(id=10000002, password=123456, userName=vi-young), User(id=10000003, password=123123, userName=lxt), User(id=10000004, password=123456, userName=yangwei)]}
2019-02-21 21:03:31.393  INFO 11788 --- [nio-8090-exec-5] indi.viyoung.viboot.aop.ResponseAop      : 方法执行时间：36毫秒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，我们已经获取到我们想要的信息~&lt;/p&gt;
&lt;p&gt;在后面的应用实战中，我们会将这些信息保存到数据库中，并且使用一些数据分析工具进行分析。&lt;/p&gt;
&lt;h3 id=&quot;活动预告&quot;&gt;活动预告&lt;/h3&gt;
&lt;p&gt;本公号为了反馈广大读者对我的支持，特将在近期举办送书活动，&lt;strong&gt;无套路&lt;/strong&gt;，&lt;strong&gt;包邮&lt;/strong&gt;，扫码关注即可参与即将开始的抽奖活动，敬请期待。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190222065015829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZpX3lvdW5nXzk1,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190222064829854.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;您的推荐是对我最大的帮助！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 23:09:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>接口日志有啥用 在我们日常的开发过程中，我们可以通过接口日志去查看这个接口的一些详细信息。比如客户端的IP，客户端的类型，响应的时间，请求的类型，请求的接口方法等等，我们可以对这些数据进行统计分析，提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viyoung/p/10416230.html</dc:identifier>
</item>
<item>
<title>Scss预处理器的使用总结 - fozero</title>
<link>http://www.cnblogs.com/fozero/p/10416170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fozero/p/10416170.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;变量 、嵌套、Mixin混合、function函数、插值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变量及文件导入&quot;&gt;变量及文件导入&lt;/h3&gt;
&lt;p&gt;通过$定义变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$white:#fff;
$black:#000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.containner{
    color:$black;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常我们会单独创建一个局部scss文件来定义这些变量 例如 _varables.scss&lt;br/&gt;varables前面的下划线用来区分这是局部文件，不会生成对应的css文件，通过@import方式在其他文件中导入该文件（下划线可以省略）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@import 'varables';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套&quot;&gt;嵌套&lt;/h3&gt;
&lt;p&gt;例如我们有这样一个html结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;containner&quot;&amp;gt;
        &amp;lt;div class=&quot;banner&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用嵌套语法可以写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.containner{
    background: #eee;
    color:$black;
    .banner{
        background: red;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后编译成css：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.containner {
  background: #eee;
  color: #000; }
  .containner .banner {
    background: red; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;高级用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;、&amp;gt;、+、~&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&amp;amp;符合使得区分元素不以后代选择器的方式连接，例如链接使用到的hover效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a{
        color:red;
        &amp;amp;:hover{
            color:blue;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.containner a:hover {
      color: blue; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mixin混合&quot;&gt;mixin混合&lt;/h3&gt;
&lt;p&gt;如果我们有多个地方使用到相同的样式，我们就可以将其写成一个mixin方法，然后在不同的地方去使用它&lt;/p&gt;
&lt;p&gt;一般通过@mixin来定义一个函数，@include来引用&lt;/p&gt;
&lt;p&gt;例如定义一个用于清除浮动的mixin方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @mixin clearfix() {
  &amp;amp;::after {
    display: block;
    clear: both;
    content: &quot;&quot;;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们就可以这样使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.list{
        list-style: none;
        @include clearfix();
        .item{
            float: left;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mixin方法传参&quot;&gt;mixin方法传参&lt;/h4&gt;
&lt;p&gt;类似JavaScript函数我们可以传递参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@mixin colorlink($normal, $hover, $visited){
    color: $normal;
      &amp;amp;:hover { color: $hover; }
      &amp;amp;:visited { color: $visited; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@include colorlink(blue,red,green);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用这种方式，不用区分参数顺序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@include colorlink(
                $normal: blue,
                  $visited: green,
                  $hover: red
            );&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置默认参数值&quot;&gt;设置默认参数值&lt;/h4&gt;
&lt;p&gt;通过以下方式来这是默认参数值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@mixin size($size:50px){
    font-size: $size;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的时候我们可以根据需求来决定是否传递参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.title{
        // @include size();
        @include size(20px);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;fuction和mixin&quot;&gt;@fuction和@mixin&lt;/h3&gt;
&lt;h4 id=&quot;区别&quot;&gt;区别：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;sass本身就有一些内置的函数，方便我们调用，如强大的color函数，还有darken、rgba、ie-hex-str、percentage、lighten、length、nth、unit、unitless等&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;其次就是它返回的是一个值，而不是一段css样式代码什么的&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内置函数&quot;&gt;内置函数&lt;/h4&gt;
&lt;p&gt;1、rgba&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rgba(blue, 0.2) =&amp;gt; rgba(0, 0, 255, 0.2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、percentage&lt;/p&gt;
&lt;p&gt;将一个没有单位的数字转成百分比形式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;percentage(0.2) =&amp;gt; 20%&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过function来自定义函数&quot;&gt;通过@function来自定义函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// px转em 
@function pxToEm($px, $base: 16) { 
    @return ($px / $base) * 1em; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p{
    font-size:pxToEm(20);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p{
    font-size: 1.25em;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;1、插值语句 #{}&lt;br/&gt;通过 #{} 插值语句可以在选择器或属性名中使用变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p.foo {
  border-color: blue; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、使用@for指令输出重复格式内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@for $i from 1 through 28
{
    .bg-#{$i}
    {
      background: url(brand_day_review#{$i}.jpg) no-repeat center / 1560px auto;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.containner .bg-1 {
    background: url(brand_day_review1.jpg) no-repeat center/1560px auto; }
  .containner .bg-2 {
    background: url(brand_day_review2.jpg) no-repeat center/1560px auto; }
  .containner .bg-3 {
    background: url(brand_day_review3.jpg) no-repeat center/1560px auto; }
  .containner .bg-4 {
    background: url(brand_day_review4.jpg) no-repeat center/1560px auto; }
  .containner .bg-5 {
    background: url(brand_day_review5.jpg) no-repeat center/1560px auto; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了@for，其他的还有@if 、@each、@while等，这些都属于控制指令&lt;/p&gt;
&lt;h3 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sass.hk/&quot;&gt;sass中文网&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cplus.com/preprocessor/organize-your-sass-files.html&quot;&gt;组织你的Sass文件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cplus.com/preprocessor/sass-mixins-function-placeholder.html&quot;&gt;sass揭秘之@mixin，%，@function&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html&quot;&gt;Sass基础——Rem与Px的转换&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 17:45:00 +0000</pubDate>
<dc:creator>fozero</dc:creator>
<og:description>变量 、嵌套、Mixin混合、function函数、插值 变量及文件导入 通过$定义变量 变量引用 通常我们会单独创建一个局部scss文件来定义这些变量 例如 _varables.scss varab</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fozero/p/10416170.html</dc:identifier>
</item>
<item>
<title>还在为记不住Markdown语法犯愁？收藏这篇文章吧！ - Coding小僧</title>
<link>http://www.cnblogs.com/tuike/p/10416106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tuike/p/10416106.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文已同步发表到我的技术微信公众号，扫一扫文章底部的二维码或在微信搜索 “程序员驿站”即可关注，每天都会更新优质技术文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在用Markdown记录生活，发现有些语法总记不住，特此写下这篇文字，方便自己查阅。如果有和我情况一样的小伙伴，欢迎查阅或收藏这篇文章！讲解顺序和官方一致！&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691081cc00bee14?w=534&amp;amp;h=381&amp;amp;f=png&amp;amp;s=22588&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;blockquote readability=&quot;4.3862068965517&quot;&gt;
&lt;p&gt;本篇文章基于：&lt;a href=&quot;https://www.appinn.com/markdown/&quot;&gt;Markdown 语法说明 (简体中文版)&lt;/a&gt; 的说明和例子实践之后所写，文章所用文字多摘录于官方文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文中描述文字中用到的HTML标签均在方括号&quot;&amp;lt;&amp;gt;&quot;中字母前加了空格，防止被Markdown编译器识别，如 &amp;lt; div&amp;gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;宗旨&quot;&gt;宗旨&lt;/h3&gt;
&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;/p&gt;
&lt;p&gt;可读性，无论如何，都是最重要的。一份使用Markdown格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown语法受到一些既有text-to-HTML格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext和EtText，而最大灵感来源其实是纯文本电子邮件的格式。&lt;br/&gt;总之， Markdown的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown的列表看起来，嗯，就是列表。Markdown的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样.&lt;/p&gt;
&lt;p&gt;Markdown 不是想要取代HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown的构想不是要使得HTML文档更容易书写。在我看来， HTML 已经很容易写了。Markdown的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。&lt;/p&gt;
&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。&lt;/p&gt;
&lt;p&gt;要制约的只有一些 HTML区块元素――比如&amp;lt; div&amp;gt;、&amp;lt; table&amp;gt;、&amp;lt; pre&amp;gt;、&amp;lt; p&amp;gt;等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &amp;lt; p&amp;gt; 标签。&lt;/p&gt;
&lt;p&gt;例子如下，在 Markdown 文件里加上一段 HTML 表格：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691087f47cf5884?w=606&amp;amp;h=304&amp;amp;f=png&amp;amp;s=71051&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对应效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/169108872f478ff7?w=446&amp;amp;h=248&amp;amp;f=png&amp;amp;s=45189&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。&lt;/p&gt;
&lt;p&gt;HTML 的区段（行内）标签如 &amp;lt; span&amp;gt;、&amp;lt; cite&amp;gt;、&amp;lt; del&amp;gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &amp;lt; a&amp;gt; 或 &amp;lt; img&amp;gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。&lt;/p&gt;
&lt;p&gt;和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。&lt;/p&gt;
&lt;h3 id=&quot;特殊字符自动转换&quot;&gt;特殊字符自动转换&lt;/h3&gt;
&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &amp;lt; 和 &amp;amp; 。 &amp;lt; 符号用于起始标签，&amp;amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;amp;lt; 和 &amp;amp;amp;。&lt;/p&gt;
&lt;p&gt;&amp;amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;amp;T」 ，你必须要写成「AT&amp;amp;amp;T」。而网址中的 &amp;amp; 字符也要转换。比如你要链接到：&lt;br/&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird&lt;/code&gt;&lt;br/&gt;你必须要把网址转换写为：&lt;br/&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird&lt;/code&gt;&lt;br/&gt;才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。&lt;/p&gt;
&lt;p&gt;Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp;amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;amp ; 。&lt;/p&gt;
&lt;p&gt;所以你如果要在文档中插入一个版权符号©，你可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;copy;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Markdown 会保留它不动。而若你写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AT&amp;amp;T&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Markdown 就会将它转为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AT&amp;amp;amp;T&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似的状况也会发生在 &amp;lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &amp;lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4 &amp;lt; 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Markdown 将会把它转换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4 &amp;amp;lt; 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过需要注意的是，code 范围内，不论是行内还是区块， &amp;lt; 和 &amp;amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &amp;lt; 和 &amp;amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）&lt;/p&gt;
&lt;h2 id=&quot;区块元素&quot;&gt;区块元素&lt;/h2&gt;
&lt;h3 id=&quot;段落和换行&quot;&gt;段落和换行&lt;/h3&gt;
&lt;p&gt;有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。&lt;/p&gt;
&lt;p&gt;「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &amp;lt; br /&amp;gt; 标签。&lt;/p&gt;
&lt;p&gt;如果你确实想要依赖 Markdown 来插入 &amp;lt; br /&amp;gt; 标签的话，在插入处先按入两个以上的空格然后回车。&lt;/p&gt;
&lt;p&gt;的确，需要多费点事（多加空格）来产生 &amp;lt; br /&amp;gt; ，但是简单地「每个换行都转换为 &amp;lt; br /&amp;gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。&lt;/p&gt;
&lt;h3 id=&quot;标题&quot;&gt;标题&lt;/h3&gt;
&lt;p&gt;Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。&lt;/p&gt;
&lt;p&gt;类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;This is an H1
=============
This is an H2
-------------&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910918ff6baf74?w=596&amp;amp;h=294&amp;amp;f=png&amp;amp;s=53649&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何数量的 = 和 - 都可以有效果。&lt;/p&gt;
&lt;p&gt;类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 这是 H1

## 这是 H2

###### 这是 H6&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/169109364f5ed0c7?w=656&amp;amp;h=362&amp;amp;f=png&amp;amp;s=61951&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
---&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691094af1dcfca4?w=664&amp;amp;h=416&amp;amp;f=png&amp;amp;s=71404&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;区块引用-blockquotes&quot;&gt;区块引用 Blockquotes&lt;/h3&gt;
&lt;p&gt;Markdown 标记区块引用是使用类似 email 中用 &amp;gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &amp;gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691095c2881c4fc?w=872&amp;amp;h=336&amp;amp;f=png&amp;amp;s=162885&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &amp;gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691096d92b34425?w=882&amp;amp;h=336&amp;amp;f=png&amp;amp;s=162689&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &amp;gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; ## 这是一个标题。
&amp;gt; 
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691097f1f0d4999?w=922&amp;amp;h=436&amp;amp;f=png&amp;amp;s=128971&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。&lt;/p&gt;
&lt;h3 id=&quot;列表&quot;&gt;列表&lt;/h3&gt;
&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;br/&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   Red
*   Green
*   Blue

等同于：
+   Red
+   Green
+   Blue

也等同于：
-   Red
-   Green
-   Blue&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/1691099badce6b58?w=828&amp;amp;h=682&amp;amp;f=png&amp;amp;s=112716&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.  Bird
2.  McHale
3.  Parish &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/169109a85bfcf9b3?w=764&amp;amp;h=190&amp;amp;f=png&amp;amp;s=32591&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/169109a85bfcf9b3?w=764&amp;amp;h=190&amp;amp;f=png&amp;amp;s=32591&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你的列表标记写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a06b910f328?w=696&amp;amp;h=384&amp;amp;f=png&amp;amp;s=68837&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/169109ff4c94469b?w=794&amp;amp;h=426&amp;amp;f=png&amp;amp;s=76231&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。&lt;/p&gt;
&lt;p&gt;如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。&lt;/p&gt;
&lt;p&gt;列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。&lt;/p&gt;
&lt;p&gt;要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a2020acf71d?w=896&amp;amp;h=296&amp;amp;f=png&amp;amp;s=141383&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是如果你懒，那也行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a2c12bd8e46?w=912&amp;amp;h=262&amp;amp;f=png&amp;amp;s=136401&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &amp;lt; p&amp;gt; 标签包起来，举例来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a3aeb9334f9?w=836&amp;amp;h=854&amp;amp;f=png&amp;amp;s=178387&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a41065e640a?w=876&amp;amp;h=780&amp;amp;f=png&amp;amp;s=139683&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a5235a11dd1?w=898&amp;amp;h=392&amp;amp;f=png&amp;amp;s=167932&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a67e341ea87?w=890&amp;amp;h=328&amp;amp;f=png&amp;amp;s=123832&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在列表项目内放进引用，那 &amp;gt; 就需要缩进:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a774e7bbd35?w=688&amp;amp;h=188&amp;amp;f=png&amp;amp;s=48185&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   一列表项包含一个列表区块：

        &amp;lt;代码写在这&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a86cabd6311?w=904&amp;amp;h=232&amp;amp;f=png&amp;amp;s=52903&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，项目列表很可能会不小心产生，像是下面这样的写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1986. What a great season.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910a991679fc89?w=390&amp;amp;h=96&amp;amp;f=png&amp;amp;s=18829&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1986\. What a great season.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910aa8b5780f7f?w=474&amp;amp;h=96&amp;amp;f=png&amp;amp;s=20218&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代码区块&quot;&gt;代码区块&lt;/h3&gt;
&lt;p&gt;和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &amp;lt; pre&amp;gt; 和 &amp;lt; code&amp;gt; 标签来把代码区块包起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910acb34caebb8?w=634&amp;amp;h=438&amp;amp;f=png&amp;amp;s=112913&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910ad1049d99c1?w=916&amp;amp;h=494&amp;amp;f=png&amp;amp;s=115568&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910ad9da9ae278?w=790&amp;amp;h=582&amp;amp;f=png&amp;amp;s=154627&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910ae15374480f?w=928&amp;amp;h=646&amp;amp;f=png&amp;amp;s=158231&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。&lt;/p&gt;
&lt;p&gt;在代码区块里面， &amp;amp; 、 &amp;lt; 和 &amp;gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910aed0d1953af?w=776&amp;amp;h=436&amp;amp;f=png&amp;amp;s=133569&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910af2dcfa3561?w=930&amp;amp;h=486&amp;amp;f=png&amp;amp;s=125858&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。&lt;/p&gt;
&lt;h3 id=&quot;分隔线&quot;&gt;分隔线&lt;/h3&gt;
&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910afbfdee8a40?w=822&amp;amp;h=412&amp;amp;f=png&amp;amp;s=53809&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b009c4a0a32?w=928&amp;amp;h=290&amp;amp;f=png&amp;amp;s=35486&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;区段元素&quot;&gt;区段元素&lt;/h2&gt;
&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。&lt;/p&gt;
&lt;p&gt;不管是哪一种，链接文字都是用 [方括号] 来标记。&lt;/p&gt;
&lt;p&gt;要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b0dc868ded4?w=830&amp;amp;h=618&amp;amp;f=png&amp;amp;s=205639&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b1362fa624c?w=690&amp;amp;h=398&amp;amp;f=png&amp;amp;s=92494&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你是要链接到同样主机的资源，你可以使用相对路径：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b1fa6020b1d?w=728&amp;amp;h=92&amp;amp;f=png&amp;amp;s=29973&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b279a6a99ac?w=630&amp;amp;h=88&amp;amp;f=png&amp;amp;s=22732&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b3494c7229c?w=830&amp;amp;h=432&amp;amp;f=png&amp;amp;s=171618&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b52bc0d3af7?w=894&amp;amp;h=318&amp;amp;f=png&amp;amp;s=128546&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接内容定义的形式为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字&lt;/li&gt;
&lt;li&gt;接着一个冒号&lt;/li&gt;
&lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
&lt;li&gt;接着链接的网址&lt;/li&gt;
&lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;br/&gt;下面这三种链接的定义都是相同：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[foo]: http://example.com/  &quot;Optional Title Here&quot;  
[foo]: http://example.com/  'Optional Title Here'  
[foo]: http://example.com/  (Optional Title Here)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b6d3f0866bf?w=688&amp;amp;h=166&amp;amp;f=png&amp;amp;s=78091&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。&lt;/p&gt;
&lt;p&gt;链接网址也可以用方括号包起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b78fbadf92b?w=662&amp;amp;h=76&amp;amp;f=png&amp;amp;s=28805&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910b8c4eef85da?w=886&amp;amp;h=116&amp;amp;f=png&amp;amp;s=48158&quot;/&gt;&lt;br/&gt;网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[link text][a]   
[link text][A] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 &quot;Google&quot; 链接到 google.com，你可以简化成：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910ba53a3c1c91?w=584&amp;amp;h=82&amp;amp;f=png&amp;amp;s=23104&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910baa03af6b6e?w=410&amp;amp;h=64&amp;amp;f=png&amp;amp;s=17491&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bb51f0c4797?w=820&amp;amp;h=238&amp;amp;f=png&amp;amp;s=80965&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bb8d8b7faac?w=590&amp;amp;h=98&amp;amp;f=png&amp;amp;s=26156&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。&lt;/p&gt;
&lt;p&gt;下面是一个参考式链接的范例：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bc9df1e544f?w=844&amp;amp;h=1520&amp;amp;f=png&amp;amp;s=644114&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运行效果图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bd288716cdf?w=884&amp;amp;h=650&amp;amp;f=png&amp;amp;s=264661&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。&lt;/p&gt;
&lt;p&gt;使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。&lt;/p&gt;
&lt;h3 id=&quot;强调&quot;&gt;强调&lt;/h3&gt;
&lt;p&gt;Markdown 使用星号（&lt;em&gt;）和底线（&lt;/em&gt;）作为标记强调字词的符号，被 * 或 包围的字词会被转成用 &amp;lt; em&amp;gt; 标签包围，用两个 或 _ 包起来的话，则会被转成 &amp;lt; strong&amp;gt;，例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bde1aec3f8d?w=786&amp;amp;h=698&amp;amp;f=png&amp;amp;s=185060&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910be46b3ad81e?w=644&amp;amp;h=674&amp;amp;f=png&amp;amp;s=141417&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。&lt;/p&gt;
&lt;p&gt;强调也可以直接插在文字中间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;un*frigging*believable&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bf13ab24738?w=472&amp;amp;h=86&amp;amp;f=png&amp;amp;s=17441&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。&lt;/p&gt;
&lt;p&gt;如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;\*this text is surrounded by literal asterisks\*&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910bff23ade5ea?w=672&amp;amp;h=90&amp;amp;f=png&amp;amp;s=26816&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c073e18019b?w=828&amp;amp;h=236&amp;amp;f=png&amp;amp;s=66217&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c0b5c339f61?w=478&amp;amp;h=232&amp;amp;f=png&amp;amp;s=47362&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c1f8f530a1f?w=786&amp;amp;h=292&amp;amp;f=png&amp;amp;s=85293&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果为：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c221609256d?w=664&amp;amp;h=244&amp;amp;f=png&amp;amp;s=60780&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c2b89c37e3e?w=824&amp;amp;h=496&amp;amp;f=png&amp;amp;s=156768&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c31aac2a218?w=788&amp;amp;h=386&amp;amp;f=png&amp;amp;s=120242&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在代码区段内，&amp;amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c42ae419f86?w=802&amp;amp;h=506&amp;amp;f=png&amp;amp;s=159961&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/21/16910c46c950aec4?w=870&amp;amp;h=384&amp;amp;f=png&amp;amp;s=109420&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;图片&quot;&gt;图片&lt;/h3&gt;
&lt;p&gt;很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。&lt;/p&gt;
&lt;p&gt;Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910c91ee6b0b76?w=852&amp;amp;h=462&amp;amp;f=png&amp;amp;s=324002&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910c97daf82044?w=822&amp;amp;h=964&amp;amp;f=png&amp;amp;s=591247&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细叙述如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个惊叹号 !&lt;/li&gt;
&lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
&lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详细叙述如下：&lt;/p&gt;
&lt;p&gt;一个惊叹号 !&lt;br/&gt;接着一个方括号，里面放上图片的替代文字&lt;br/&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。&lt;/p&gt;
&lt;p&gt;参考式的图片语法则长得像这样：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910ca7928338c2?w=844&amp;amp;h=412&amp;amp;f=png&amp;amp;s=163366&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;自动链接&quot;&gt;自动链接&lt;/h3&gt;
&lt;p&gt;Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910cafff125cab?w=830&amp;amp;h=250&amp;amp;f=png&amp;amp;s=75857&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910cb550d6941f?w=594&amp;amp;h=252&amp;amp;f=png&amp;amp;s=52449&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910cc1cf97a1df?w=844&amp;amp;h=460&amp;amp;f=png&amp;amp;s=234870&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910cc673d2cd4c?w=578&amp;amp;h=244&amp;amp;f=png&amp;amp;s=54399&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;在浏览器里面，这段字串（其实是 &amp;lt;a href=&quot;mailto:address@example.com&quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;）会变成一个可以点击的「address@example.com」链接。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）&lt;/p&gt;
&lt;h3 id=&quot;反斜杠&quot;&gt;反斜杠&lt;/h3&gt;
&lt;p&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &amp;lt; em&amp;gt; 标签），你可以在星号的前面加上反斜杠：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/22/16910ce80bc88cf7?w=834&amp;amp;h=708&amp;amp;f=png&amp;amp;s=177100&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关注技术公众号&quot;程序员驿站&quot;，微信搜索“程序员驿站”，或者微信扫一扫下方二维码即可关注：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/20/16908e42fad91e20?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27043&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 21 Feb 2019 16:27:00 +0000</pubDate>
<dc:creator>Coding小僧</dc:creator>
<og:description>本文已同步发表到我的技术微信公众号，扫一扫文章底部的二维码或在微信搜索 “程序员驿站”即可关注，每天都会更新优质技术文章。 最近在用Markdown记录生活，发现有些语法总记不住，特此写下这篇文字，方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tuike/p/10416106.html</dc:identifier>
</item>
<item>
<title>StackExchange.Redis中文使用文档 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/StackExchange-Redis-docs-cn.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/StackExchange-Redis-docs-cn.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;最近想深入学习一些 Redis 相关的东西。于是看了看官方的项目 &lt;a href=&quot;https://github.com/StackExchange/StackExchange.Redis&quot;&gt;StackExchange&lt;/a&gt;，发现里面有一份文档，于是打算翻译成中文，方便大家学习参考，如果有什么翻译不准确的地方，欢迎大家指出。&lt;/p&gt;
&lt;p&gt;StackExchange.Redis 是 Stackoverflow 开发的 Redis C# 客户端，是目前.net应用使用的最多的 redis 客户端，性能优越。&lt;/p&gt;

&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;作者水平有限，若有疏漏或错误还望提醒，十分感谢。&lt;/p&gt;
&lt;p&gt;您可以在这里 &lt;a href=&quot;https://github.com/WeihanLi/StackExchange.Redis-docs-cn/issues/new&quot;&gt;提出问题&lt;/a&gt; 。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 16:10:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>StackExchange.Redis中文使用文档 Intro 最近想深入学习一些 Redis 相关的东西。于是看了看官方的项目 'StackExchange' ，发现里面有一份文档，于是打算翻译成中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/StackExchange-Redis-docs-cn.html</dc:identifier>
</item>
<item>
<title>【设计模式+原型理解】第二章：基于构造函数扩展出来的原型模式 - 彭胜光</title>
<link>http://www.cnblogs.com/pengshengguang/p/10416044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengshengguang/p/10416044.html</guid>
<description>&lt;p&gt;       在第一章的时候，说过了单例模式、工厂模式、构造函数模式，你还记得构造模式是怎么样的吗？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function CreateJsPerson(name, age) {
        this.name = name;
        this.age = age;
        this.writeJs = function() {
                console.log(&quot;my name is &quot; + this.name + &quot;, i can write js.&quot;);
        }
}
var p1 = new CreateJsPerson(&quot;p1&quot;, 18);
var p2 = new CreateJsPerson(&quot;p2&quot;, 17);
p1.writeJs();
p2.writeJs();
console.log(p1.writeJs() === p2.writeJs()); //-&amp;gt; false
// 构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立开的
// -&amp;gt; 叫做实例识别
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       上面的就是构造函数模式，你知道，为什么p1、p2的writeJs()方法为什么不相等吗？这是因为正如上面所说的，两个实例是相互独立的，也就是说，两个实例的属性都是各自私有属性。&lt;/p&gt;
&lt;p&gt;   -&amp;gt; 问题来了，两个实例里面的属性都是私有的以外，是不是还得有公有的部分？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、【&lt;span&gt;基于构造函数的原型模式&lt;/span&gt;】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;使用基于构造函数模式的原型模式，能够实现把writeJs()方法&lt;span&gt;变成公有的&lt;/span&gt;&lt;/strong&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function CreateJsPerson(name, age) {
        this.name = name;
        this.age = age;
        // this.writeJs = function() {
        //       console.log(&quot;my name is &quot; + this.name + &quot;, i can write js.&quot;);
        // }
}
CreateJsPerson.prototype.writeJsG = function() {
        console.log(&quot;my name is &quot; + this.name + &quot;, i can write js.&quot;);
};

var p1 = new CreateJsPerson(&quot;p1&quot;, 18);
var p2 = new CreateJsPerson(&quot;p2&quot;, 17);
p1.writeJs();
p2.writeJs();
console.log(p1.writeJsG() === p2.writeJsG()); //-&amp;gt;true
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        为什么这样写，就能把属性变为公有的呢？&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;基于构造函数模式扩展出来的原型模式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                -&amp;gt;它解决了方法或者属性公有的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                -&amp;gt;即把实例之间公有的属性和方法提出成公有的属性和方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                -&amp;gt;想让谁公有，就把它放在prototype上即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、【原型基础3句话】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         想要学习原型，要记住下面的三句话（&lt;strong&gt;不要问为什么&lt;/strong&gt;~~）：&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;&lt;em&gt;&lt;strong&gt;1）每一个函数数据类型（普通函数、类）都有一个天生自带的属性，prototype（原型），并且这个属性是一个对象数据类型的值。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;          2）并且在prototype上浏览器会天生给它加上一个属性contructor（构造函数），属性值是当前函数（类）本身。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;          3）每一个对象数据类型（普通对象，实例，prototype...）也天生自带一个属性：__proto__，属性值是当前实例所属类的原型（prototype）。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面这段代码，可以说明一下上面的3句话：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function Fn() {
        this.x = 100;
};
Fn.prototype.getX = function() {
        console.log(this.x);
};
var f1 = new Fn;
var f2 = new Fn;
console.log(Fn.prototype.constructor === Fn); //-&amp;gt;true
// 堆内存：存储 对象、函数里面的代码字符串
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码的原型链如下图所示，正方形代表栈内存（即函数作用域），椭圆正方形代表堆内存（即对象）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201902/1254758-20190221233254173-43068746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    从画图可以很清晰看到，整个基于构造函数扩展出来的原型链函数，类与实例的原型链，实例与JS基类Object的原型链关系，一览无遗。&lt;/p&gt;
&lt;p&gt;    上图+代码，可以总结出：&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt; 1、Object是JS中所有对象数据类型的基类（最顶层的类）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           1） f1 instanceof Object -&amp;gt; true，这是因为f1通过__proto__可以向上级查找，不管有多少级，最后总能找到Object&lt;/p&gt;
&lt;p&gt;            2）在Object.prototype上没有__proto__这个属性（因为自己指向自己没意义）&lt;/p&gt;
&lt;p&gt;     &lt;span&gt; &lt;strong&gt;&lt;span&gt;2、&lt;span&gt;原型链模&lt;/span&gt;式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            举个简单的例子，f1.hasOwnProperty(&quot;x&quot;);  //-&amp;gt;hasWwnProperty是f1的一个属性，但是我们发现f1的私有属性上并没有这个方法，那如何处理的呢？&lt;/p&gt;
&lt;p&gt;            通过 对象名.属性名 的方式获取属性值的时候，首先在对象的私有的属性上进行查找，如果私有中存在这个属性，则获取的是私有的属性值；&lt;/p&gt;
&lt;p&gt;         -&amp;gt;如果私有的没有，则通过__proto__找到所属类的原型（类的原型上定义的属性和方法都是当前实例的公有的属性和方法），原型上存在的话，获取的是公有的属性值；&lt;/p&gt;
&lt;p&gt;        -&amp;gt; 如果原型上也没有，则继续通过原型上的__proto__继续向上查找，一直找到Object.prototype为止...&lt;/p&gt;
&lt;p&gt;         -&amp;gt;这种查找的机制就是我们的原型链模式&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、【原型知识玩起来】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
cconsole.log(f1.getX === f2.getX); //-&amp;gt;true
console.log(f1.__proto__.getX === f2.getX); //-&amp;gt;true 
console.log(f1.getX === Fn.prototype.getX); //-&amp;gt;true
// f1.getX 跟 f1.__proto__.getX的区别
// 前者是浏览器先找私有作用域，找不到再找公有作用域
// 后者是浏览器直接查找公有作用域
// 
console.log(f1.hasOwnProperty === f1.__proto__.__proto__.hasOwnProperty);

// 在IE浏览器中，我们原型模式也是同样的原理，但是IE浏览器怕你通过__proto__把公有的修改，
// 禁止我们使用__proto__，下面的例子就可以很明显的说明为啥IE禁止了

f1.sum == function() {
        //修改自己私有的sum
};
f1.__proto__.sum = function() {
        //修改所属类原型上的sum
};
// 所以修改公有的，IE只能通过prototype
Fn.prototype.sum = function() {
        // 修改公有的sum
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、【总结】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        在这一章中，主要说的是原型模式，但是原型模式是通过构造函数扩展出来的，同时也通过代码+图的方式，把原型模式的实现原理给画了出来。&lt;/p&gt;
&lt;p&gt;        既然原型这个知识点出来了，&lt;strong&gt;我会在后面介绍一下，&lt;span&gt;使用原型来实现类的封装、继承、多态&lt;/span&gt;（里面的重写），并且会介绍&lt;span&gt;使用原型来实现7中继承方法&lt;/span&gt;，将会非常有趣。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Feb 2019 16:02:00 +0000</pubDate>
<dc:creator>彭胜光</dc:creator>
<og:description>在第一章的时候，说过了单例模式、工厂模式、构造函数模式，你还记得构造模式是怎么样的吗？ 上面的就是构造函数模式，你知道，为什么p1、p2的writeJs()方法为什么不相等吗？这是因为正如上面所说的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengshengguang/p/10416044.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：超级好用的可视化PyQt GUI构建工具(Qt Designer) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/10416052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/10416052.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;PyQt GUI构建工具Qt Designer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　痞子衡开博客至今已有好几年，一直以嵌入式开发相关主题的文章为主线，偶尔穿插一些其他技术或工具的介绍，前段时间因为要做一个跟恩智浦MCU启动相关的上位机工具 &lt;a href=&quot;https://github.com/JayHeng/NXP-MCUBootUtility&quot;&gt;NXP-MCUBootUtility&lt;/a&gt;，网上搜索对比了几个Python下的GUI框架，最终选择了wxPython这个成熟稳定的GUI库，从而接触到wxFormBuilder这个配套wxPython使用的GUI构建工具。苦于网上关于该构建工具的中文资料不多，所以根据自己使用经验写了一篇 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/9426966.html&quot;&gt;极易上手的可视化wxPython GUI构建工具(wxFormBuilder)&lt;/a&gt;，没想到该篇博客很受欢迎，居然目前是痞子衡博客里阅读量最高的一篇博客，而且也是搜索 wxFormBuilder 关键字出来的中文结果排名第二位的链接，真是万万没想到。&lt;/p&gt;
&lt;p&gt;　　wxPython框架虽然成熟稳定，但是相对最近更火的PyQt框架来说，还是显得古老了一些，控件风格不符合现代审美观，因此痞子衡决定学习一下PyQt的用法，感受下PyQt做出来的界面效果到底如何。根据wxPython学习经验，当然首先要从PyQt的可视化GUI构建工具Qt Designer开始下手，因此便有了本篇博客。&lt;/p&gt;
&lt;h3 id=&quot;一qt-designer工具背景&quot;&gt;一、Qt Designer工具背景&lt;/h3&gt;
&lt;p&gt;　　Qt Designer从名字上来看显然就是久负盛名的跨平台GUI库Qt的配套设计工具。Qt库本身是C++语言实现的；Riverbank公司用Python语言对Qt做了一层封装，封装后便成了Python版GUI库PyQt（目前最新的版本是PyQt5）；下面是这两个GUI库的官方主页：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Qt的各种UI控件功能均是通过class来实现的，这个链接 &lt;a href=&quot;https://doc.qt.io/qt-5/classes.html&quot; class=&quot;uri&quot;&gt;https://doc.qt.io/qt-5/classes.html&lt;/a&gt; 列出了Qt里的所有class。PyQt5其用法基本与Qt一致，这个链接 &lt;a href=&quot;https://www.riverbankcomputing.com/static/Docs/PyQt5/module_index.html#ref-module-index&quot; class=&quot;uri&quot;&gt;https://www.riverbankcomputing.com/static/Docs/PyQt5/module_index.html#ref-module-index&lt;/a&gt; 列出了PyQt5里所有的Modules，其中用于设计界面最常用的便是 &lt;a href=&quot;https://www.riverbankcomputing.com/static/Docs/PyQt5/api/qtwidgets/qtwidgets-module.html&quot;&gt;QtWidgets&lt;/a&gt; 模块。&lt;/p&gt;
&lt;p&gt;　　在Qt官网的Tools下面可以看到所有Qt相关的工具，在UI design tools下面可以找到Qt Designer，可见Qt Designer是用于设计GUI界面的工具之一。由于痞子衡介绍的PyQt5下的GUI构建工具，因此本文的Qt Designer并不是直接在Qt官网下载安装的，具体安装方法详见下一章节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-Toolset.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二qt-designer快速上手&quot;&gt;二、Qt Designer快速上手&lt;/h3&gt;
&lt;p&gt;　　使用Qt Designer去设计GUI界面可以不用掌握PyQt5里的各个控件class的具体用法，你只需要在Qt Designer软件里添加这些控件即可，下面痞子衡将简介Qt Designer的用法：&lt;/p&gt;
&lt;h4 id=&quot;软件安装&quot;&gt;2.1软件安装&lt;/h4&gt;
&lt;p&gt;　　简单了解PyQt5的module和class便可以开始设计GUI界面，首先得安装Qt Designer，在安装完Python3之后（痞子衡安装的是Python 3.6），借助\Python36\Scripts\下的pip.exe工具来分别安装PyQt5和Qt Designer，命令见如下主页：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　安装完成之后打开\Python36\Lib\site-packages\pyqt5_tools\designer.exe，这便是Qt Designer。&lt;/p&gt;
&lt;h4 id=&quot;软件界面&quot;&gt;2.2软件界面&lt;/h4&gt;
&lt;p&gt;　　打开Qt Designer可见到如下界面，界面主要分为四大区：项目区、控件区、编辑区、属性区。软件使用起来非常简单，就是在【控件区】里点击添加需要的控件，这些控件的效果会在【编辑区】里实时显示，并在【属性区】这些控件的属性，【项目区】用于显示控件间的层级关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-mainWin.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础布局&quot;&gt;2.3基础布局&lt;/h4&gt;
&lt;p&gt;　　让我们开始创建一个GUI的基础框架，基础框架包括：Container（局部外围轮廓）、Layout（内部控件区）、menubar（顶部菜单栏）、statusbar（底部状态栏）。&lt;br/&gt;　　第一步是添加一个Container（此处选择常用的Frame），这是GUI的轮廓基础，有了Frame之后还需要在Frame里添加Layout（此处选择竖排样式），用于规范后续控件的排列样式。默认GUI即有menubar和statusbar。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-step1-containerLayout.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;多种控件&quot;&gt;2.4多种控件&lt;/h4&gt;
&lt;p&gt;　　基础布局搞定之后，接下来便是在Layout里添加控件，PyQt5支持的控件非常丰富，其中比较常用的是如下几个：各种Button（按钮）、Label（静态显示文本框）、Text Edit（输入输出文本框）、Check Box（选中框）、各种Slider（滑动条）等。由于前面痞子衡选择的是verticalLayout，因此你会看到控件们都是竖着排的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-step2-ctrl.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;控件属性&quot;&gt;2.5控件属性&lt;/h4&gt;
&lt;p&gt;　　添加了所有控件之后，下一步便是分别设置控件的属性，进一步调整控件。痞子衡以Push Button属性为例，痞子衡勾选了如下3项比较重要的属性设置，分别是objectName（button在后续python代码的对象名，一般需要按其功能修改，修改后使得代码阅读/修改起来更直观）、geometry（设置button的尺寸与位置，如果是放在Layout里，则受限于Layout不可设置）、text（button在GUI里显示的标签名，此处是PushButton，也需要按其功能修改，方便用户使用软件）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-step3-button_property.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;保存为xml代码工程文件&quot;&gt;2.6保存为xml代码（工程文件）&lt;/h4&gt;
&lt;p&gt;　　当GUI界面布局全部完成之后，需选择File-&amp;gt;Save As保存为.ui文件，该文件既是Qt Designer的工程文件也是最终生成的GUI xml代码文件，痞子衡保存在了my_win.ui文件里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-step4-xml.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;转换成python代码&quot;&gt;2.7转换成python代码&lt;/h4&gt;
&lt;p&gt;　　虽然保存的my_win.ui文件里是可以直接在python代码里被加载使用的，但是更好的办法是直接将.ui文件转换成相应的.py文件。需要借助 \Python36\Scripts\pyuic5.exe工具，命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;pyuic5 - o my_win.py my_win.ui&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　转换成功后，让我们打开my_win.py文件，可以简单看一下这个my_win.py里的内容，代码里首先import了PyQt5相关库，并定义了名为Ui_MainWindow的class，这个class主要包含两个函数setupUi()和retranslateUi()。setupUi()里初始化了各个控件成员self.xx，这与我们在Qt Designer里添加控件是对应的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file '.\my_win.ui'
#
# Created by: PyQt5 UI code generator 5.11.3
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName(&quot;MainWindow&quot;)
        MainWindow.resize(603, 448)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
        self.frame = QtWidgets.QFrame(self.centralwidget)
        self.frame.setGeometry(QtCore.QRect(100, 80, 361, 211))
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName(&quot;frame&quot;)
        self.verticalLayoutWidget = QtWidgets.QWidget(self.frame)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(30, 20, 160, 172))
        self.verticalLayoutWidget.setObjectName(&quot;verticalLayoutWidget&quot;)
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName(&quot;verticalLayout&quot;)
        self.pushButton = QtWidgets.QPushButton(self.verticalLayoutWidget)
        self.pushButton.setEnabled(True)
        self.pushButton.setObjectName(&quot;pushButton&quot;)
        self.verticalLayout.addWidget(self.pushButton)
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)
        self.label.setObjectName(&quot;label&quot;)
        self.verticalLayout.addWidget(self.label)
        self.textEdit = QtWidgets.QTextEdit(self.verticalLayoutWidget)
        self.textEdit.setObjectName(&quot;textEdit&quot;)
        self.verticalLayout.addWidget(self.textEdit)
        self.checkBox = QtWidgets.QCheckBox(self.verticalLayoutWidget)
        self.checkBox.setObjectName(&quot;checkBox&quot;)
        self.verticalLayout.addWidget(self.checkBox)
        self.horizontalSlider = QtWidgets.QSlider(self.verticalLayoutWidget)
        self.horizontalSlider.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider.setObjectName(&quot;horizontalSlider&quot;)
        self.verticalLayout.addWidget(self.horizontalSlider)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 603, 21))
        self.menubar.setObjectName(&quot;menubar&quot;)
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName(&quot;statusbar&quot;)
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;))
        self.pushButton.setText(_translate(&quot;MainWindow&quot;, &quot;PushButton&quot;))
        self.label.setText(_translate(&quot;MainWindow&quot;, &quot;TextLabel&quot;))
        self.checkBox.setText(_translate(&quot;MainWindow&quot;, &quot;CheckBox&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三使用qt-designer生成的代码&quot;&gt;三、使用Qt Designer生成的代码&lt;/h3&gt;
&lt;p&gt;　　前面已经使用Qt Designer生成GUI界面类Ui_MainWindow并保存在my_win.py文件中，此时需要创建一个主函数文件去调用Ui_MainWindow，下面是痞子衡创建的main_win.py中的代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
# 导入my_win.py中内容
from my_win import *

# 创建mainWin类并传入Ui_MainWindow
class mainWin(QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        super(mainWin, self).__init__(parent)
        self.setupUi(self)

if __name__ == '__main__':
    # 下面是使用PyQt5的固定用法
    app = QApplication(sys.argv)
    main_win = mainWin()
    main_win.show()
    sys.exit(app.exec_())&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;触发事件与响应&quot;&gt;3.1触发事件与响应&lt;/h4&gt;
&lt;p&gt;　　有了Button，我们肯定希望其能与一个响应函数相联系起来，此处痞子衡定义了showMessage()函数，并且将showMessage()与PushButton绑定起来，点击Button便会执行一次这个showMessage()函数。代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class mainWin(QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        super(mainWin, self).__init__(parent)
        self.setupUi(self)
        # 将响应函数绑定到指定Button
        self.pushButton.clicked.connect(self.showMessage)

    # Button响应函数
    def showMessage(self):
        self.textEdit.setText('hello world')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　最后让我们测试一下这个GUI软件，在命令行下运行main_win.py&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;PS D:\my_git_repo\&amp;gt; python .\main_win.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/QtDesigner-gui_run.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，PyQt5 GUI构建工具Qt Designer痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/rrxc/p/4462890.html&quot;&gt;使用PyQt来编写第一个Python GUI程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/5b063c5745d0&quot;&gt;PyQT5速成教程-2 Qt Designer介绍与入门&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Thu, 21 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>wxPython框架虽然成熟稳定，但是相对最近更火的PyQt框架来说，还是显得古老了一些，控件风格不符合现代审美观，因此痞子衡决定学习一下PyQt的用法，感受下PyQt做出来的界面效果到底如何。根据w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/10416052.html</dc:identifier>
</item>
<item>
<title>SLAM+语音机器人DIY系列：（六）SLAM建图与自主避障导航——2.google-cartographer机器人SLAM建图 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10415865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10415865.html</guid>
<description>&lt;p&gt;&lt;span&gt;通过前面的基础学习，本章进入最为激动的&lt;span&gt;机器人自主导航&lt;span&gt;的学习。在前面的学习铺垫后，终于迎来了最大乐趣的时刻，就是赋予我们的miiboo机器人能自由行走的生命。本章将围绕机器人SLAM建图、导航避障、巡航、监控等内容展开。本章内容：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10412509.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;1.在机器人上使用传感器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10415865.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;2.google-cartographer机器人SLAM建图&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10416081.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;3.ros-navigation机器人自主避障导航&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10416104.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;4.多目标点导航及任务调度&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hiram-zhang/p/10416115.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;5.机器人巡航与现场监控&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;主流的激光&lt;/span&gt;SLAM&lt;span&gt;算法有&lt;/span&gt;&lt;span&gt;hector&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gmapping&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;karto&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hector&lt;span&gt;是一种结合了鲁棒性较好的扫描匹方法&lt;/span&gt;&lt;span&gt;2D_SLAM&lt;/span&gt;&lt;span&gt;方法和使用惯性传感系统的导航技术。传感器的要求较高，高更新频率小测量噪声的激光扫描仪，不需要里程计。使空中无人机与地面小车在不平坦区域运行存在运用的可能性。作者利用现代激光雷达的高更新率和低距离测量噪声，通过扫描匹配实时地对机器人运动进行估计。所以当只有低更新率的激光传感器时，即便测距估计很精确，对该系统都会出现一定的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gmapping&lt;span&gt;是一种基于粒子滤波的激光&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法，它已经集成在&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中，是移动机器人中使用最多的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法。基于粒子滤波的算法用许多加权粒子表示路径的后验概率，每个粒子都给出一个重要性因子。但是，它们通常需要大量的粒子才能获得比较好的的结果，从而增加该算法的的计算复杂性。此外，与&lt;/span&gt;&lt;span&gt;PF&lt;/span&gt;&lt;span&gt;重采样过程相关的粒子退化耗尽问题也降低了算法的准确性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;karto&lt;span&gt;是基于图优化的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法，用高度优化和非迭代&lt;/span&gt;&lt;span&gt;cholesky&lt;/span&gt;&lt;span&gt;矩阵进行稀疏系统解耦作为解。图优化方法利用图的均值表示地图，每个节点表示机器人轨迹的一个位置点和传感器测量数据集，箭头的指向的连接表示连续机器人位置点的运动，每个新节点加入，地图就会依据空间中的节点箭头的约束进行计算更新。路标&lt;/span&gt;&lt;span&gt;landmark&lt;/span&gt;&lt;span&gt;越多&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;内存需求越大&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;然而图优化方式相比其他方法在大环境下制图优势更大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cartographer&lt;span&gt;是&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;开发的实时室内&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;项目，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;采用基于&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;自家开发的&lt;/span&gt;&lt;span&gt;ceres&lt;/span&gt;&lt;span&gt;非线性优化的方法，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;的量点在于代码规范与工程化，非常适合于商业应用和再开发。并且&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;基于&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图构建全局地图的思想，能有效的避免建图过程中环境中移动物体的干扰。并且&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;支持多传感器数据（&lt;/span&gt;&lt;span&gt;odometry&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;等）建图，支持&lt;/span&gt;&lt;span&gt;2D_SLAM&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;3D_SLAM&lt;/span&gt;&lt;span&gt;建图。所以，我果断采用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;来建图，我的树莓派&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;主板跑&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;实时建图是十分的流畅，这一点很欣慰&lt;/span&gt;&lt;span&gt;^_^&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.1.google-cartographer&lt;span&gt;建图算法原理分析&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cartographer&lt;span&gt;采用的是主流的&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;框架，也就是特征提取、闭环检测、后端优化的三段式。由一定数量的&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;组成一个&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图，一系列的&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图构成了全局地图。用&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;构建&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;的短时间过程累计误差不大，但是用&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;构建全局地图的长时间过程就会存在很大的累计误差，所以需要利用闭环检测来修正这些&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;的位置，闭环检测的基本单元是&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;，闭环检测采用&lt;/span&gt;&lt;span&gt;scan_match&lt;/span&gt;&lt;span&gt;策略。&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;的重点内容就是融合多传感器数据（&lt;/span&gt;&lt;span&gt;odometry&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;LaserScan&lt;/span&gt;&lt;span&gt;等）的&lt;/span&gt;&lt;span&gt;submap&lt;/span&gt;&lt;span&gt;子图创建以及用于闭环检测的&lt;/span&gt;&lt;span&gt;scan_match&lt;/span&gt;&lt;span&gt;策略的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221221104857-1739201579.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;图&lt;/span&gt;18&lt;span&gt;）&lt;/span&gt;cartographer&lt;span&gt;算法系统框图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.2.cartographer_ros&lt;span&gt;安装         &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们直接参考&lt;/span&gt;google-cartographer&lt;span&gt;官方教程安装就行，官方教程分为&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;，其实&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;就是核心算法层、&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;是核心算法层的&lt;/span&gt;&lt;span&gt;ros&lt;/span&gt;&lt;span&gt;调用层。官方教程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer.readthedocs.io/en/latest/index.html#&quot;&gt;&lt;span&gt;https://google-cartographer.readthedocs.io/en/latest/index.html#&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer-ros.readthedocs.io/en/latest/index.html#&quot;&gt;&lt;span&gt;https://google-cartographer-ros.readthedocs.io/en/latest/index.html#&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接按照第二个链接&lt;/span&gt;cartographer_ros&lt;span&gt;的安装教程，就可将&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;、以及各种依赖都安装了。&lt;/span&gt;&lt;span&gt;不过特别说明一点，为了解决从官网下载&lt;/span&gt;ceres-solver&lt;span&gt;速度慢的问题，我将&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;的下载地址换到了&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;源；我需要将官方教程中生成的&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;替换成了自己的内容，如图&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;。其余安装过程和官方教程一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）安装编译工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我来编译&lt;/span&gt;cartographer_ros&lt;span&gt;，我们需要用到&lt;/span&gt;&lt;span&gt;wsool&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;rosdep&lt;/span&gt;&lt;span&gt;。为了加快编译，我们使用&lt;/span&gt;&lt;span&gt;ninja&lt;/span&gt;&lt;span&gt;工具进行编译。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; -y python-wstool python-rosdep ninja-build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）创建存放&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;的专门工作空间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt;&lt;span&gt; catkin_ws_carto
cd catkin_ws_carto
wstool init src

wstool merge &lt;/span&gt;-t src https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/googlecartographer/cartographer_ros/master/cartographer_ros.rosinstall&lt;/span&gt;
&lt;span&gt;
wstool update &lt;/span&gt;-t src
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;特别说明，在执行&lt;/span&gt;wstool update -t src&lt;span&gt;之前，需要将&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;文件修改成以下内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;以&lt;span&gt;解决&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;下载不了的问题&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，如图&lt;/span&gt;19&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221221821509-921051722.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;19&lt;span&gt;）我修改后的&lt;/span&gt;&lt;span&gt;src/.rosinstall&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;（3&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;安装依赖项&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;安装&lt;/span&gt;cartographer_ros&lt;span&gt;的依赖项&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;deb&lt;/span&gt;&lt;span&gt;包等。如果执行&lt;/span&gt;&lt;span&gt;sudo rosdep init&lt;/span&gt;&lt;span&gt;报错，可以直接忽略。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
src/cartographer/scripts/install_proto3.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; rosdep init
rosdep update

rosdep &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; --from-paths src --ignore-src --rosdistro=${ROS_DISTRO} -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）编译和安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的配置和依赖都完成后，就可以开始编译和安装&lt;/span&gt;cartographer_ros&lt;span&gt;整个项目工程了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;特别提醒，以后对&lt;/span&gt;cartographer_ros&lt;span&gt;中的配置文件或源码有改动时，都需要执行这个编译命令使修改生效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.3.cartographer_ros&lt;span&gt;使用        &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cartographer_ros&lt;span&gt;整体代码结构分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最顶层的是&lt;/span&gt;cartographer_ros&lt;span&gt;，作为&lt;/span&gt;&lt;span&gt;rosj&lt;/span&gt;&lt;span&gt;接口调用层，通过调用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;核心算法，订阅多传感器数据（&lt;/span&gt;&lt;span&gt;/scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;等），并发布地图、机器人位置信息（&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/tf&lt;/span&gt;&lt;span&gt;等）；其次是&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;，作为&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;算法的核心实现，特征提取、子图构建、闭环检测、全局优化都在这里实现，其中优化过程需要调用&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;非线性优化库；最后是&lt;/span&gt;&lt;span&gt;ceres-solver&lt;/span&gt;&lt;span&gt;，是非线性优化库，用于求解&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;中的优化问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221222946330-1867929710.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;图&lt;/span&gt;20&lt;span&gt;）&lt;/span&gt;cartographer_ros&lt;span&gt;整体代码结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;miiboo&lt;span&gt;机器人上用&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;多传感器建图进行配置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过前面对&lt;/span&gt;cartographer_ros&lt;span&gt;进行安装后，我们肯定迫不及待想在实际的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人上使用&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;进行&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图了。为了最大限度的提高&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图的性能，我们的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人提供了激光雷达、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、轮式里程计（&lt;/span&gt;&lt;span&gt;/scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;）这三种传感器的数据，所以我们需要先将&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;配置成对应的工作模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cartographer&lt;span&gt;算法是一个非常通用和适应不同平台的开放框架算法，所以支持多种配置与工作模式。我们就来看看&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;如何进行配置。配置文件由&lt;/span&gt;&lt;span&gt;*.lua&lt;/span&gt;&lt;span&gt;书写被放在路径&lt;/span&gt;&lt;span&gt;cartographer_ros/configuration_files/&lt;/span&gt;&lt;span&gt;，我们需要建立一个我们自己的配置文件，取名就叫&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;span&gt;吧，具体内容如图&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;。由于我们的&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人采用激光雷达、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;、轮式里程计三种传感器融合建图，所以以下参数一定要设置正确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;tracking_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;imu_link&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;published_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;odom&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;provide_odom_frame&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;，因为我们使用外部&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;，所以这里不需要内部提供；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;use_odometry&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，因为我们使用外部&lt;/span&gt;&lt;span&gt;/odom&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;use_imu_data&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，因为我们使用&lt;/span&gt;&lt;span&gt;/imu&lt;/span&gt;&lt;span&gt;的数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;imu_gravity_time_constant&lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;，这个是&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;的重力加速度常数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其余参数根据需要自行调整，由于&lt;/span&gt;cartographer&lt;span&gt;是发展很迅速的算法，所以很多代码和文档一直在更新，所以参考官方文档来解读这些参数的含义是最好的选择，官方文档连接地址我贴在下面了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google-cartographer-ros.readthedocs.io/en/latest/index.html&quot;&gt;&lt;span&gt;https://google-cartographer-ros.readthedocs.io/en/latest/index.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223308133-1363879864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;21&lt;span&gt;）我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的建图配置文件&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后需要配置&lt;/span&gt;*.launch&lt;span&gt;文件，我们给&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人建立启动文件取名叫&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.launch&lt;/span&gt;&lt;span&gt;，存放路径在&lt;/span&gt;&lt;span&gt;cartographer_ros/launch/&lt;/span&gt;&lt;span&gt;里面，具体内容如图&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不难发现&lt;/span&gt;launch&lt;span&gt;文件中包含三个&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;启动项，即&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型启动项、&lt;/span&gt;&lt;span&gt;cartographer_node&lt;/span&gt;&lt;span&gt;启动项、&lt;/span&gt;&lt;span&gt;cartographer_occupancy_grid_node&lt;/span&gt;&lt;span&gt;启动项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个启动项是启动&lt;/span&gt;urdf&lt;span&gt;模型，这个接口是提供给那些只使用&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;单独建图的应用场景，由于我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人建立完地图后还需要继续进行自动导航任务，所以我们使用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘提供的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型，而不使用这里的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型，所以这个启动项被注释掉了，这样建图和导航就更容易管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个启动项是启动&lt;/span&gt;cartographer_node&lt;span&gt;建图节点，这个是&lt;/span&gt;&lt;span&gt;SLAM&lt;/span&gt;&lt;span&gt;建图主节点，我们建立的配置&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.lua&lt;/span&gt;&lt;span&gt;将在这里被载入，同时这里可以对建图输入数据&lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;imu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;odom&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;名称做重映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个启动项是启动&lt;/span&gt;cartographer_occupancy_grid_node&lt;span&gt;地图格式转换节点，由于&lt;/span&gt;&lt;span&gt;cartographer_node&lt;/span&gt;&lt;span&gt;建图节点提供的地图是&lt;/span&gt;&lt;span&gt;submapList&lt;/span&gt;&lt;span&gt;格式的，需要转换成&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;格式才能在&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中显示和使用。这里面有两个可配参数，&lt;/span&gt;&lt;span&gt;resolution&lt;/span&gt;&lt;span&gt;用来设置&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;地图的分辨率，&lt;/span&gt;&lt;span&gt;publish_period_sec&lt;/span&gt;&lt;span&gt;用来设置&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;地图发布的频率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223608845-564058946.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;22&lt;span&gt;）我们&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的建图启动文件&lt;/span&gt;&lt;span&gt;miiboo_mapbuild.launch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;配置参数修改好后，不要忘了再编译一次整个&lt;/span&gt;catkin_ws_carto&lt;span&gt;工作空间，切换到&lt;/span&gt;&lt;span&gt;catkin_ws_carto&lt;/span&gt;&lt;span&gt;目录，执行下面的编译命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;启动&lt;/span&gt;cartographer_ros&lt;span&gt;建图：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要在&lt;/span&gt;miiboo&lt;span&gt;机器人上，启动&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;建图，分为这几个步骤：启动机器人上的各个传感器、启动&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;、在&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端启动键盘控制机器人运动并启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图（或者在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，启动机器人上的各个传感器，为了操作方便，我已经将要启动的传感器都写入&lt;/span&gt;miiboo_bringup/launch/miiboo_all_sensor.launch&lt;span&gt;这个启动文件了，文件内容如图&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;。这个启动文件包含机器人&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;启动项、&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘启动项、激光雷达启动项、&lt;/span&gt;&lt;span&gt;IMU&lt;/span&gt;&lt;span&gt;启动项、摄像头启动项、广播&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;启动项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221223854757-495095153.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;23&lt;span&gt;）各个传感器启动文件&lt;/span&gt;&lt;span&gt;miiboo_all_sensor.launch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;打开终端，通过下面的命令直接启动就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws/devel/&lt;span&gt;setup.bash 
roslaunch miiboo_bringup miiboo_all_sensor.launch &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后，启动&lt;/span&gt;cartographer_ros&lt;span&gt;，由于前面已经做好了相应的配置，所以直接使用命令启动就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws_carto/install_isolated/&lt;span&gt;setup.bash
roslaunch cartographer_ros miiboo_mapbuild.launch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里给个小提示，为了查看&lt;/span&gt;cartographer_ros&lt;span&gt;建图算法有没有正常开始工作，我们可以用&lt;/span&gt;&lt;span&gt;rosrun rqt_tf_tree rqt_tf_tree&lt;/span&gt;&lt;span&gt;查看整个&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树的结构，正常的&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树如图&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;map-&amp;gt;odom&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;建图节点提供，&lt;/span&gt;&lt;span&gt;odom-&amp;gt;base_footprint&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘的轮式里程计提供，&lt;/span&gt;&lt;span&gt;base_footprint-&amp;gt;imu_link&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;base_link&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;base_laser_link&lt;/span&gt;&lt;span&gt;之间的关系由&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人的&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型提供。从&lt;/span&gt;&lt;span&gt;tf&lt;/span&gt;&lt;span&gt;树不难看出整个建图过程中机器人定位的实现原理，&lt;/span&gt;&lt;span&gt;cartographer&lt;/span&gt;&lt;span&gt;建图节点通过维护&lt;/span&gt;&lt;span&gt;map-&amp;gt;odom&lt;/span&gt;&lt;span&gt;之间的关系最终实现全局定位，&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;底盘的轮式里程计通过维护&lt;/span&gt;&lt;span&gt;odom-&amp;gt;base_footprint&lt;/span&gt;&lt;span&gt;之间的关系来实现局部定位，传感器之间的安装关系由&lt;/span&gt;&lt;span&gt;urdf&lt;/span&gt;&lt;span&gt;模型提供，这个静态关系主要用于多传感器数据融合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224144407-1294687944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;24&lt;span&gt;）&lt;/span&gt;cartographer&lt;span&gt;运行时正常的&lt;/span&gt;tf&lt;span&gt;树&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，在&lt;/span&gt;PC&lt;span&gt;端启动键盘控制机器人运动并启动&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图（或者在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图）。如果用&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端控制和观察，启动命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PC&lt;span&gt;端打开一个新终端，运行&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rosrun rviz rviz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;rviz&lt;span&gt;窗口中添加订阅&lt;/span&gt;&lt;span&gt;/map&lt;/span&gt;&lt;span&gt;，就可以看到建图效果了，如图&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224414583-2080969512.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;25&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;PC&lt;/span&gt;&lt;span&gt;端用&lt;/span&gt;&lt;span&gt;rviz&lt;/span&gt;&lt;span&gt;观察地图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;PC&lt;span&gt;端再打开一个新终端，运行键盘控制启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rosrun teleop_twist_keyboard teleop_twist_keyboard.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在该终端下，用键盘就可以控制机器人前进、后退、左转、右转了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是在&lt;/span&gt;Android&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图，直接就能使用，如图&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224615521-1957755232.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;26&lt;span&gt;）在&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;手机端用&lt;/span&gt;&lt;span&gt;miiboo&lt;/span&gt;&lt;span&gt;机器人&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;控制机器人运动和观察地图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;保存&lt;/span&gt;cartographer_ros&lt;span&gt;建图结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们在房间里面扫描一圈，地图建立的差不多了，就可以将建图结果保存下来了，&lt;/span&gt;cartographer_ros&lt;span&gt;提供了将建图结果保存为&lt;/span&gt;&lt;span&gt;*.pbstream&lt;/span&gt;&lt;span&gt;专门的方法，其实就是一条命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
source ~/catkin_ws_carto/install_isolated/&lt;span&gt;setup.bash
rosservice call &lt;/span&gt;/write_state  /home/ubuntu/map/carto_map.pbstream
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实就是调用&lt;/span&gt;cartographer_ros&lt;span&gt;提供的叫&lt;/span&gt;/write_state&lt;span&gt;这个名字的服务，服务传入参数&lt;/span&gt;/home/ubuntu/map/carto_map.pbstream&lt;span&gt;为地图的保存路径。保存成功后，会返回相应的状态信息，如图&lt;/span&gt;27&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224815511-753768000.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;27&lt;span&gt;）调用&lt;/span&gt;/write_state&lt;span&gt;服务保存建图结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;地图格式转换：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于用&lt;/span&gt;cartographer_ros&lt;span&gt;提供的&lt;/span&gt;/write_state&lt;span&gt;方法保存的地图是&lt;/span&gt;*.pbstream&lt;span&gt;的格式，而要在后续的自主导航中使用这个地图，我们需要将其转换为&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;中通用的&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;格式。其实很简单，&lt;/span&gt;&lt;span&gt;cartographer_ros&lt;/span&gt;&lt;span&gt;已经跟我们提供了&lt;/span&gt;cartographer_pbstream_to_ros_map&lt;span&gt;这个节点&lt;/span&gt;&lt;span&gt;用于转换的实现。所以，我们只需要写一个启动文件启动这个节点就行了，我给这个启动文件取名&lt;/span&gt;miiboo_pbstream2rosmap.launch&lt;span&gt;，存放路径是&lt;/span&gt;&lt;span&gt;cartographer_ros/launch/&lt;/span&gt;&lt;span&gt;，启动文件的内容如图&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;。在使用这个启动文件进行启动时，需要从外部传入两个参数，参数&lt;/span&gt;&lt;span&gt;pbstream_filename&lt;/span&gt;&lt;span&gt;为待转换的&lt;/span&gt;&lt;span&gt;*.pbstream&lt;/span&gt;&lt;span&gt;文件路径，参数&lt;/span&gt;&lt;span&gt;map_filestem&lt;/span&gt;&lt;span&gt;为转换后存放结果的文件路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221224908818-377349320.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;28&lt;span&gt;）&lt;/span&gt;&lt;span&gt;pbstream&lt;/span&gt;&lt;span&gt;转&lt;/span&gt;&lt;span&gt;GridMap&lt;/span&gt;&lt;span&gt;启动文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;配置参数修改好后，不要忘了再编译一次整个&lt;/span&gt;catkin_ws_carto&lt;span&gt;工作空间，切换到&lt;/span&gt;&lt;span&gt;catkin_ws_carto&lt;/span&gt;&lt;span&gt;目录，执行下面的编译命令。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
catkin_make_isolated --&lt;span&gt;install&lt;/span&gt; --use-ninja
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;最后，就可以打开终端，使用启动这个启动文件，对地图格式进行转换了，命令如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
roslaunch cartographer_ros miiboo_pbstream2rosmap.launch pbstream_filename:=/home/ubuntu/map/carto_map.pbstream map_filestem:=/home/ubuntu/map/carto_map
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;保存结束后，节点会自动退出，这时我们可以得到转换后的地图，转换后的&lt;/span&gt;GridMap&lt;span&gt;地图由&lt;/span&gt;&lt;span&gt;*.pgm&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;*.yaml&lt;/span&gt;&lt;span&gt;两部分构成，这时标准的&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;格式地图，可以被&lt;/span&gt;&lt;span&gt;ROS&lt;/span&gt;&lt;span&gt;导航框架中的&lt;/span&gt;&lt;span&gt;map_server&lt;/span&gt;&lt;span&gt;节点直接调用，&lt;/span&gt;&lt;span&gt;转换后的地图结果如图&lt;/span&gt;29&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190221225100401-2112777935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;29&lt;span&gt;）地图格式转换后的结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果大家对博文的相关类容感兴趣，或有什么技术疑问，欢迎加入下面的《SLAM+语音机器人DIY》QQ技术交流群，一起讨论学习^_^&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190220162438739-1654241751.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 通过前面的基础学习，本章进入最为激动的机器人自主导航的学习。在前面的学习铺垫后，终于迎来了最大乐趣的时刻，就是赋予我们的miiboo机器人能自由行走的生命。本章将围绕机器人SLAM建图、导航避障</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10415865.html</dc:identifier>
</item>
<item>
<title>我们为什么要搞长沙.NET技术社区（二） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10415886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10415886.html</guid>
<description>&lt;h3 align=&quot;center&quot;&gt;我们为什么要搞长沙.NET技术社区（二）&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　某种意义上讲，长沙和中国大部分内地城市一样，都是互联网时代的灯下黑。没有真正意义上的互联网公司，例如最近发布的中国互联网企业一百强中没有一家湖南或者长沙的公司就是明证。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　然而长沙并非没有互联网人，在麓谷几十万计的IT 从业人员就是明证。即便如此，长沙依然是一个互联网氛围很不好的城市。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　表面上看互联网氛围是一个不可度量的东西，有人说他不过是许多公司的所说的企业文化一般，都是看不见，摸不着，大概只存在于老板的PPT 和公司吹过的牛逼里面。但是在互联网思维飞速发展的今天，他实际上已经深深的影响了我们的方方面面，尤其是对于IT 领域来说，更是如此。近多少年来，但凡是优秀的互联网公司，都以封闭为耻，充分的利用开源社区营造的众多基础设施，为企业的飞速发展插上了无穷想象力，在企业获得成功之后，再通过同样的开源的形式，将技术回馈社区，影响了许多同样需要基础设施的其他企业，如此周而往复，形成了一个又一个完善的闭环。除此之外，这些公司也会定期的组织技术分享，让开发者积极的了解技术的同时，也加深了许多对目标企业的好感。因此，做开源和做社区，实际上对开发者社区和企业来说是互利互惠的好事。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　与北上广深杭相比，长沙并没有那么多做开源和分享技术的企业，但也充满了无穷潜力。这也是多少年来，长沙唐胡子俱乐部把营造互联网氛围当作使命的主要原因，实际上到目前为止，他已经取得了不错的成绩。从QQ群，微信群开始，到线下的活动基地，他已经成功举办了数十次互联网类型的分享。而且前每个月都会组织各种类型的技术活动或互联网活动，惠及了不少互联网从业人员。尤其是2018年4月份，由俱乐部举办的岳麓峰会-互联网技术CTO专场，更是成为地区瞩目的焦点。当时报名人数一度突破三千人，而参与聆听技术分享的互联网从业人员超过一千人。借着岳麓峰会的东风，为了将互联网技术分享落到实处，俱乐部又发起成立了长沙互联网活动基地。去年笔者曾经作为唐胡子俱乐部的成员参与了众多长沙互联网活动，并深度参与了互联网活动基地的建设过程，深知互联网社区运营之艰难，尤其是要做落地的互联网技术社区，更是难上加难。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　为了让社区落地，我们打算成立技术社区，并从.NET社区开始。非常有幸，我认识了一群优秀的开发者，他们非常也愿意参与社区的建设。同样非常有幸，我们获得了来自全国各地微软.NET俱乐部的大力支持。尤其是作为这个时代最美丽的开发者微软MVP们，例如苏州俱乐部的潘老师，深圳.NET俱乐部的张队长、广州俱乐部的叶老师和陈老师，上海俱乐部的汪老师，微软的许老师等等，他们都非常支持我们的决定。来自苏州的潘老师甚至把苏州的经验无条件的全部分享给我，让我能够更加直观的了解到组建社区的基本流程。为此，我们开始了从设计到实践的全过程。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　于是，我们把群拉了起来，并打算开始逐步的进行下一步计划。不到一周时间，我们的微信群已经拥有将近600位成员，去掉重复的，还有560人。当然，我们的群获得了短期的活跃，然后第二天、第三天热度就急剧的下滑了。因为，大概是我们不想做水群。我们究竟打算怎样来建一个怎样的社区，后面几篇再分享。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　建群只是第一步，后期还有一万步。建一个群，或者建一万个群，没有落地都没有任何价值，只有落地才是王道。而究竟怎么落地？我们需要大家的积极参与，例如现在，为我们提建议，可以让我们能更好的规划我们的未来。也期待大家一起加入分享者的行列，让我们共同把社区经营好。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2018年我的朋友嘉鹏写了一首诗，正文是这样的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;余常踱步而思，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;社群之发展，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;该如天公作法，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;雷厉风行。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;又该如春风化雨，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;润物无声。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;余又常想古人圣言，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;逝者如斯，白驹过隙。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;沧海桑田，朱颜易改。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;古人悬梁刺股，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵使白发葬青丝，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;不可荒嬉学仲永。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;我辈中人，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当敏，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;而好学，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;方无悔矣。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵观古今社群之流，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;盛蔚乎如菁英荟萃之泰山。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;草芥兮不洁庭庑。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;社群之路，任重而道远。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当此盛世，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;当炳开放，平等，迅疾，协作，分享，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;之互联网精神。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以精师长技为本心，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以广纳益友为心念，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以开拓创新为旗帜，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;以繁盛星网为目标，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;合抱生于毫末，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;九层起于累土。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;星城之精英，当聚于此，共襄盛举。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;奇花初绽，矞矞皇皇！&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;干将发硎，有作其芒！&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;纵有千古，横有八荒。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;前途似海，来日方长，&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;未来可期！未来可期！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　说那么多，都是为了继续征集问卷调查，请长沙.NET社区的开发者们百忙之中抽空填写问卷。非常感谢。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201902/191302-20190221225845358-1038623864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;https://www.wjx.top/jq/34721880.aspx&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 21 Feb 2019 15:04:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>我们为什么要搞长沙.NET技术社区（二） 某种意义上讲，长沙和中国大部分内地城市一样，都是互联网时代的灯下黑。没有真正意义上的互联网公司，例如最近发布的中国互联网企业一百强中没有一家湖南或者长沙的公司</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10415886.html</dc:identifier>
</item>
</channel>
</rss>