<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>贪婪算法回顾 - 牛牛的编程之路</title>
<link>http://www.cnblogs.com/hujingnb/p/10947152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujingnb/p/10947152.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;回顾&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;还记的贪婪算法么? 如果你不记得了, 看了下面这个例子你一定会想起来, 因为这个例子太普遍了, 几乎每个将贪婪算法的地方, 第一个例子都是它, 言归正传.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;: 现在有如下课程表, 要将这些课尽可能多的安排在教室A内.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;课程名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开始时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语文课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;数学课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;音乐课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;政治课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:30&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;美术课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;12:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;首先将所有课程都安排在教师A是不现实的, 因为时间上存在冲突. 那改怎么安排呢?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这个问题很难, 对吧. 算了, 至少我第一次看的时候, 完全没有头绪. 但看了下面的思路, 你又会发现, 啊?这么简单么?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;具体思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;选出结束时间最早的课程, 将它加到教室A的第一节课&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;找出在当前教室A最后一节课的结束时间之后开始, 并且结束时间最早的课程, 将其加到教室A的课表中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;经过上面的步骤, 得出的课表为:&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;课程名&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开始时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束时间&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;语文课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;音乐课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;10:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;美术课&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;11:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;12:00&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如何, 是不是感觉这个算法太简单了, 简单到我都不敢相信最终的结果是正确的.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;但是&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这正是贪婪算法的优点, 简单, 容易实施.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;贪婪算法的思想就是(个人理解), 每一步都找到当前状态的最优解, 继续.&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;显然,贪婪算法并不总是能够找到最优解&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;来了, 又来了, 又是一个被用烂了的例子, 但我就是要用, 哼.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;: 现在有一个小偷, 带着一个可以装35kg重东西的包包, 他要将最贵重的东西带走, 那么, 贪婪算法思路如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将可装下的最贵的东西装入背包&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是, 如果物品如下:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品A: 价值300, 重量30kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品B: 价值200, 重量20kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;物品C: 价值150, 重量15kg&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;按照上面的思路, 装入的内容为: 物品A, 总价值300&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是, 很显然, 如果装入的是: 物品B+物品C, 总价值350&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这时, 贪婪算法找出的就不是最优解了.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果换一种思路呢?&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将可装下的最轻的东西装入背包&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;重复步骤2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你很惊喜的发现, 结果就是我们要的, 但是, 不好意思, 这只是这种情况下的满足.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果换一种情况呢? 如果物品A价值是500, 其它条件不变呢?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;很显然, 在这里, 物品有价值和重量两个值需要考量, 并不能够单单拿出一个来进行判断(之前的教室问题只需要考虑时间), 需要综合考虑.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实我个人觉得, 这个例子举得并不恰当, 这种问题本就不适合使用贪婪算法来进行求解. 但是到处都用这个例子, 那我就用吧, 因为我也想不出更好的例子了.......&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最终的结果虽然不是最优解, 但是也比较接近了. 主要是算法简单啊&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;贪婪算法是不是感觉优点动态规划的意思? 没错, 贪婪算法可以说是动态规划的一种特例,也就是说, 所有使用贪婪算法能够解决的问题都可以通过动态规划来解决, 但是反过来并不成立.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实, 贪婪算法个人感觉并不能叫做贪婪算法, 应该叫贪婪思想, 嘿嘿. 因为它并不是一个具体的算法, 而是一种解决问题的思路:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;每一步都寻找当前状态的最有解(局部最优解), 最终得到的就是由所有局部最优解组成的全局最优解, 或接近全局最优解的解&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;有点只顾眼前利益, 不看长远利益的感觉哈. 这种思路听起来, 简单、容易实现, 甚至简单到让人怀疑他的正确性, 你的怀疑是对的, 并不是每次局部最优解的组合就是全局最优解, 但他的优点就是简单啊, 而且对于上面第一个例子中这样的方法就很好的解决了.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;最后, 贪婪算法, 重点在于一个贪字, 哈哈, 请记住贪婪算法的精髓就是&lt;span&gt;&lt;strong&gt;贪&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 15:49:00 +0000</pubDate>
<dc:creator>牛牛的编程之路</dc:creator>
<og:description>回顾 还记的贪婪算法么? 如果你不记得了, 看了下面这个例子你一定会想起来, 因为这个例子太普遍了, 几乎每个将贪婪算法的地方, 第一个例子都是它, 言归正传. 问题: 现在有如下课程表, 要将这些课</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hujingnb/p/10947152.html</dc:identifier>
</item>
<item>
<title>RN 从上手到“放弃” - adouwt</title>
<link>http://www.cnblogs.com/adouwt/p/10947047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adouwt/p/10947047.html</guid>
<description>&lt;h3 id=&quot;rn-从上手到放弃&quot;&gt;RN 从上手到“放弃”&lt;/h3&gt;
&lt;p&gt;前言： react-native，相对于最近🔥的飞起的flutter，不算是一个新技术，2015年Facebook 开源，到现在已经4 5 个年头，一直在维护当中，但是至今未发布 v1 版本，目前已经更新到0.59。 该技术目标： 跨平台实现原生应用。 GitHub start 数目： 77602（2019-5-29）。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;h3 id=&quot;项目预览&quot;&gt;1、项目预览&lt;/h3&gt;
&lt;p&gt;现在已完成的功能展示：&lt;/p&gt;
&lt;p&gt;入手demo项目，本打算模仿微信的功能做一遍。现在已经完成微信的一级界面。截图如下：&lt;br/&gt;首页：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232657472-2117129083.png&quot;/&gt;通信录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232741994-2110244119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232756759-635462233.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232813172-132115920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;朋友圈（上拉加载和下拉刷新）：&lt;br/&gt;（未完成，就是调用了接口）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232825579-2127487560.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;聊天界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232839186-1235748673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摄像头拍照（安卓虚拟机）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232851164-2114112859.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/adouwt/react-native-wx&quot;&gt;react-native-wx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs后台：&lt;a href=&quot;https://github.com/adouwt/nodejsAPI&quot;&gt;nodejsApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目主要使用插件（库）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;react-native-camera （调用摄像头）&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;react-native-vector-icons （图标库）&lt;/li&gt;
&lt;li&gt;react-navigation （路由导航）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h3 id=&quot;项目运行&quot;&gt;2、项目运行&lt;/h3&gt;
&lt;p&gt;～前提： 环境搭建及相关软件、安卓或者ios 的模拟器安装， 参考官网即可，https://reactnative.cn/docs/getting-started.html&lt;/p&gt;
&lt;h4 id=&quot;git-clone-httpsgithub.comadouwtreact-native-wx.git&quot;&gt;git clone https://github.com/adouwt/react-native-wx.git&lt;/h4&gt;
&lt;h4 id=&quot;cd-react-native-wx&quot;&gt;cd react-native-wx&lt;/h4&gt;
&lt;h4 id=&quot;npm-i&quot;&gt;npm i&lt;/h4&gt;
&lt;h4 id=&quot;npm-run-and-安卓&quot;&gt;npm run and (安卓)&lt;/h4&gt;
&lt;h4 id=&quot;npm-run-ios-苹果&quot;&gt;npm run ios (苹果)&lt;/h4&gt;
&lt;p&gt;（上面的运行命令，我在package.json 做了封装，一些处理编译错误的命令，我也已经封装进去）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529232922373-704575256.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行命令后，会自动弹出nodejs 执行终端界面，这个是程序运行的一个监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233008049-1921778092.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模拟器显示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233026431-1613598783.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;分步实现&quot;&gt;3、分步实现&lt;/h3&gt;
&lt;h4 id=&quot;初始化并运行项目&quot;&gt;3.1 初始化并运行项目&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;```
react-native init AwesomeProject
react-native run-ios
```&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;项目结构说明&quot;&gt;3.2 项目结构说明&lt;/h4&gt;
&lt;h4 id=&quot;新建文件夹-app接下来所有的源码文件代码将在这里&quot;&gt;3.3 新建文件夹 app，接下来所有的源码文件代码将在这里&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233048762-1922811017.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前新建 component组件、page页面、及utils 工具三个，后面会根据需要建新的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233112399-1218645065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四个一级界面+ 聊天和朋友圈的界面&lt;/p&gt;
&lt;h4 id=&quot;安装插件做页面导航跳转&quot;&gt;3.4 安装插件做页面导航跳转&lt;/h4&gt;
&lt;h4 id=&quot;npm-install-react-navigation--s&quot;&gt;3.4.1 npm install react-navigation -S&lt;/h4&gt;
&lt;h4 id=&quot;修改项目文件下的app.js&quot;&gt;3.4.2 修改项目文件下的App.js&lt;/h4&gt;
&lt;p&gt;这是根文件，我们的页面导航写进这个组件，我项目中已经完成代码片段，这里直接使用，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React from 'react';
import HomeScreen  from './app/page/Home'
import DiscoverScreen from './app/page/Discover'
import UserListScreen from './app/page/UserList'
import MyScreen from './app/page/My'
import CameraComponent from './app/component/camera'
import ChatScreen from './app/page/Chat'
import FriendCircle from './app/page/friendCircle'
import Icon from &quot;react-native-vector-icons/Ionicons&quot;;
import { View, Text } from 'react-native';
import { createAppContainer, createBottomTabNavigator, createStackNavigator, createDrawerNavigator } from 'react-navigation'; // Version can be specified in package.json


const HomeNav = createStackNavigator({
  Home: {
    screen: HomeScreen,
    navigationOptions:{
      headerTitle:'微信',
      headerBackTitle:null,
    }
  },
})
const UserListNav = createStackNavigator({
  UserList: {
    screen: UserListScreen,
  },
})

// 二级页面写进一级页面中
const DiscoverNav = createStackNavigator(
  {
    Discover: {
      screen: DiscoverScreen,
    },
  }
)

const MyNav = createStackNavigator(
  {
    My: MyScreen,
  }
);

let BottomNav = createBottomTabNavigator(
  // createBottomTabNavigator 两个参数，一个页面路由，一个是路由配置
  {
    微信: HomeNav,
    通讯录: UserListNav,
    发现: DiscoverNav,
    我: MyNav,
  },
  {
    defaultNavigationOptions: ({ navigation }) =&amp;gt; ({
      tabBarIcon: ({ focused, horizontal, tintColor }) =&amp;gt; {
        const { routeName } = navigation.state;
        let iconName;
        let badgeCount = 3
        switch(routeName) {
          case '微信':
            iconName = 'ios-text';
            break;
          case '通讯录':
            iconName = 'md-person-add';
            break;
          case '发现':
            iconName = 'md-compass';
            break;
          case '我':
            iconName = 'ios-person';
            break;
        }
        iconColor = `${focused ? '#1AAD19' : '#4D4D4D'}`;

        return (
          &amp;lt;View&amp;gt;
            &amp;lt;Icon name={iconName} size={18} color={iconColor}&amp;gt;&amp;lt;/Icon&amp;gt;
            { routeName === '发现' &amp;amp;&amp;amp; badgeCount &amp;gt; 0 &amp;amp;&amp;amp; (
              &amp;lt;View style={{
                // If you're using react-native &amp;lt; 0.57 overflow outside of the parent
                // will not work on Android, see https://git.io/fhLJ8
                position: 'absolute',
                right: -6,
                top: -3,
                backgroundColor: 'red',
                borderRadius: 6,
                width: 12,
                height: 12,
                justifyContent: 'center',
                alignItems: 'center',
                color: '#fff'
              }}&amp;gt;
                &amp;lt;Text style={{ color: '#fff', fontSize: 10, fontWeight: 'bold' }}&amp;gt;{badgeCount}&amp;lt;/Text&amp;gt;
              &amp;lt;/View&amp;gt;
            )}
          &amp;lt;/View&amp;gt;
        )
      },
    }),
    tabBarOptions: {
      activeTintColor: '#1AAD19',
      inactiveTintColor: '#4D4D4D',
    },
  }
);

let RootNav = createStackNavigator({
  BottomNav: {
    screen: BottomNav,
    navigationOptions: ({ navigation, screenProps }) =&amp;gt; {
      return {
        header: null,
      };
    }
  },
  Camera: {
    screen: CameraComponent
  },
  Chat: {
    screen: ChatScreen
  },
  FriendCircle: {
    screen: FriendCircle
  }
})

export default createAppContainer(RootNav);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要参考导航资料：&lt;a href=&quot;https://reactnavigation.org/docs/en/tab-based-navigation.html&quot;&gt;navigation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档讲的很明白，看看示例就知道怎么用了，我下面讲两个注意内容，这也是在这几天的学习中遇到的troubles.&lt;/p&gt;
&lt;h4 id=&quot;a创建底部导航&quot;&gt;a、创建底部导航：&lt;/h4&gt;
&lt;p&gt;createBottomTabNavigator 方法，接受两个参数，一个页面路由，一个是路由配置，&lt;br/&gt;直接看这个方法名字，就知道这个是创建底部导航的方法。&lt;br/&gt;--第一个参数，页面路由，这里你写多少tab, 底部就会呈现几个tab 均匀分布，（不要有杠精来袭，“要是有100个tab,怎么显示？”，哪有这样的设计，你要是有100个tab，你试试这样排版？）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233150680-271214341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数的key,就是底部显示的名称，value 就是这个页面 screen。页面screen可以单独定义引入，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233200363-1658898248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以像第一个DiscoverNav，以screen定义的方式引入，也可以简略使用，如下面的MyNav&lt;/p&gt;
&lt;p&gt;-- 第二个参数，路由配置，在这里配置，底部导航的样式、图标、foucs 状态及badge等&lt;br/&gt;tabBarIcon 顾名思义，配置他的图标，我这里根据navigation.state 里的routeName 来区分页面路由，从而为他们配置不同的 icon&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233216751-787806361.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;b二级页面注入stack-navigator&quot;&gt;b、二级页面注入Stack Navigator&lt;/h4&gt;
&lt;p&gt;我们写的页面要注入我们的导航，这样才能访问到，我们这里采用的是react-navigation的 createStackNavigaor 的createStackNavigator方法，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233232689-1630378810.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;具体页面逻辑&quot;&gt;3.4.3 具体页面逻辑&lt;/h4&gt;
&lt;p&gt;这里讲两个页面，一个是静态页面，一个是调用接口的长列表的界面。&lt;/p&gt;
&lt;h5 id=&quot;静态页面-discoverscreen&quot;&gt;静态页面 discoverScreen&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;布局方式&lt;/strong&gt;： flex， 属性和web 书写不一致，语法参考这个不完全手册： https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击按钮封装：&lt;/strong&gt; RN 里面的点击方法只能绑定在它的button 组件上，提供的其他组件我们么办法直接绑定事件，它提供了一个封装子组件可以绑定事件的自定义按钮-Touchable 系列 （TouchableOpacity ，TouchableNativeFeedback）如下书写可以点击的item：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233249025-558876019.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 上面划线的位置，这个样式（flex: 1, flexDirection: 'row',）要写上。有一定的兼容问题，如果没有这个样式，在安卓上无法点击，ios上没有影响。说明在实际开发中，我们还要处理一定的平台差异问题，真正实现无差异的跨平台还是有些困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面header：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在static 里面没办法直接调用组件的方法，需要借助 navigation 来做一下中转，调用setParams将方法放进navigation里面，这样在static里面就可以使用navigation.getParams 获取这个方法了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233454908-1379632168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过渡动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法实现的是一个 动画，我们在 写web 的时候，会用 transform transaction 这样的动画属性，RN里面也支持这样的动画，具体语法有所差异。这里我们用一个绝对定位里面的 right值 做过渡效果。&lt;br/&gt;开始定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234312904-425708425.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在点击时候，修改这个 this.state.animateRightValue 的值，实现动画效果，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233553984-1457881206.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Animated有几个动画（），这里采用了timing,他接受两个参数，一个是监听的动画值，另一个是这个值的配置，配置动画方式，动画时间等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233617466-131025360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面也没有复杂的页面逻辑，基本一看就知道怎么回事，一些语法 api 不会的话，可以上官网lou 一眼：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234556665-1204937439.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;调接口的页面-friendcircle&quot;&gt;调接口的页面 friendCircle&lt;/h5&gt;
&lt;p&gt;这个页面调用了一个分页接口，上拉加载更多，长列表的组件用的是RN 原生的 FlatList 组件，这个具体使用可以参考api 文档看看，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234637984-830967980.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是就个人使用之后的感觉而言，这个真正要用到生产，还得要稍微改造一下，比如loading菊花图片要改一改。&lt;br/&gt;在生命周期函数componentDidMount 里面，调用我们的接口。说道这里，我们引出了接口封装问题，用的是自带的fetch，这个fetch 底层具体我们就不考虑怎么实现的，现在我们需要对fetch 封装一下，方便后面在多处使用，fetch 封装如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let base_url = 'https://api.scampus.cn';  //服务器基本地址
// let base_url = 'http://18.10.1.115:4000';  //服务器基本地址
let token = '';   
/**
 * @param {string} url 接口地址
 * @param {string} method 请求方法：GET、POST，只能大写
 * @param {JSON} [params=''] body的请求参数，默认为空
 * @return 返回Promise
 */
const  fetchRequest = (url, method, params = '') =&amp;gt; {
    let header = {
        &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,
        &quot;accesstoken&quot;:token  //用户登陆后返回的token，某些涉及用户数据的接口需要在header中加上token
    };
    if(params == ''){   //如果网络请求中带有参数
        return new Promise(function (resolve, reject) {
            fetch(base_url + url, {
                method: method,
                headers: header
            }).then((response) =&amp;gt; response.json())
                .then((responseData) =&amp;gt; {
                    resolve(responseData);
                })
                .catch( (err) =&amp;gt; {
                    reject(err);
                });
        });
    } else{   //如果网络请求中没有参数
        return new Promise(function (resolve, reject) {
            fetch(base_url + url, {
                method: method,
                headers: header,
                body:JSON.stringify(params)   //body参数，通常需要转换成字符串后服务器才能解析
            }).then((response) =&amp;gt; response.json())
                .then((responseData) =&amp;gt; {
                    resolve(responseData);
                })
                .catch( (err) =&amp;gt; {
                    reject(err);
                });
        });
    }
}

export default fetchRequest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Promise 处理异步问题，将我们最后的需要的数据统统resolve 出去。封装中规中距，基本是按照文档说明 fetch 的用法，稍加修改&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529234746290-412023186.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用第三方的图标&quot;&gt;4、使用第三方的图标&lt;/h3&gt;
&lt;p&gt;npm install -S react-native-vector-icons&lt;br/&gt;图标地址: https://oblador.github.io/react-native-vector-icons/ 注意这站点不是图标全部可用，滚动条快速找到中间位置，就能看到我们需要的图标。&lt;br/&gt;使用： name 值可以在上面的地址中寻找，哪个合适就用哪个，&lt;br/&gt;就个人看来，这个图标库基本够开发使用，如果不够可以继续引用字体图标库。&lt;/p&gt;
&lt;h3 id=&quot;调用手机硬件设备-摄像头&quot;&gt;5、调用手机硬件设备-摄像头&lt;/h3&gt;
&lt;p&gt;具体演示实例，拍照功能，用的第三方库，&lt;a href=&quot;https://github.com/react-native-community/react-native-camera/blob/master/docs/RNCamera.md&quot;&gt;react-native-camera&lt;/a&gt;&lt;br/&gt;安装： npm install -S react-native-camera&lt;br/&gt;使用：import { RNCamera } from 'react-native-camera';&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;View style={styles.container}&amp;gt;
    &amp;lt;RNCamera
        ref={ref =&amp;gt; {
            this.camera = ref;
        }}
        style={styles.preview}
        type={ this.state.cameraType}
        flashMode={RNCamera.Constants.FlashMode.on}
        autoFocus={RNCamera.Constants.AutoFocus.on}
        androidCameraPermissionOptions={{
            title: 'Permission to use camera',
            message: 'We need your permission to use your camera',
            buttonPositive: 'Ok',
            buttonNegative: 'Cancel',
        }}
        androidRecordAudioPermissionOptions={{
            title: 'Permission to use audio recording',
            message: 'We need your permission to use your audio',
            buttonPositive: 'Ok',
            buttonNegative: 'Cancel',
        }}
        onGoogleVisionBarcodesDetected={({ barcodes }) =&amp;gt; {
            console.log(barcodes);
        }}
    &amp;gt;
        {({ camera, status, recordAudioPermissionStatus }) =&amp;gt; {
            if (status !== 'READY') return &amp;lt;PendingView /&amp;gt;;
            return (
            &amp;lt;View style={{ flex: 1, flexDirection: 'row', justifyContent: 'space-around',marginBottom: 20 }}&amp;gt;
                &amp;lt;TouchableOpacity onPress={() =&amp;gt; this.takePicture(camera)} style={styles.capture}&amp;gt;
                    &amp;lt;Text style={{ fontSize: 14 }}&amp;gt; 拍照 &amp;lt;/Text&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;
                &amp;lt;TouchableOpacity onPress={this.swtichCamera} style={styles.capture}&amp;gt;
                    &amp;lt;Icon name=&quot;ios-reverse-camera&quot; size={18} color=&quot;#333&quot;&amp;gt;&amp;lt;/Icon&amp;gt;
                &amp;lt;/TouchableOpacity&amp;gt;

                &amp;lt;TouchableOpacity onPress={this.lookAlbum} style={styles.imgPreview}&amp;gt;
                        &amp;lt;Image
                            style={styles.imgPreview}
                            source={{uri: this.state.currentUri || 'https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?', isStatic: true}}
                        /&amp;gt;
                    &amp;lt;/TouchableOpacity&amp;gt;
                    
                &amp;lt;/View&amp;gt;
                );
            }}
        &amp;lt;/RNCamera&amp;gt;
    &amp;lt;/View&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在组件里面可以定义照相机界面的ui，可以自定义拍照按钮，切换摄像头的按钮，拍照图片预览等，调用api 不难，问题难点在配置调用的文件，你得有权限调用原生的设备。&lt;br/&gt;1、修改android/gradle/wrapper/gradle-wrapper.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、修改android/app/build.gradle&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;missingDimensionStrategy 'react-native-camera', 'general'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529235007203-2052221341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际安装使用的时候会有相关的提示报错，按照报错信息去寻找解决办法，这里还是得推荐github，上面有很多类似的问题，可以耐心找找。&lt;/p&gt;
&lt;h3 id=&quot;结言&quot;&gt;6、结言&lt;/h3&gt;
&lt;p&gt;从一开始了解RN 到最后上手demo，到现在陆续修改项目，差不多十天时间，本人的技术栈是vue,react 并没有生产项目，看看文档，基本可以上手。总结而言，使用一些基本的功能，并不难，文档很全，使用的群体很大，所以遇到的问题也可以在相关社区找到合适的解决方法或者替换方案。还没有具体开发生产项目，但是我觉得我将要面临的问题，应该在体验优化上，比如过渡动画，上拉下拉刷新加载，切换视图；集成第三方库，调用硬件设备；性能优化问题等。&lt;/p&gt;
&lt;h3 id=&quot;todo&quot;&gt;7、TODO&lt;/h3&gt;
&lt;p&gt;后面有时间，继续把这个项目做下去，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录注册&lt;/li&gt;
&lt;li&gt;聊天，后面集成聊天机器人&lt;/li&gt;
&lt;li&gt;通讯录的人员分组，现在因为是后台接口还没有完成，只是本地造了一个数据&lt;/li&gt;
&lt;li&gt;扫码功能&lt;/li&gt;
&lt;li&gt;发动态&lt;/li&gt;
&lt;li&gt;集成地图&lt;/li&gt;
&lt;li&gt;拍照后，图像识别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有兴趣的同学欢迎加入一起完成。&lt;/p&gt;
&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/adouwt/react-native-wx&quot;&gt;react-native-wx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nodejs后台：&lt;a href=&quot;https://github.com/adouwt/nodejsAPI&quot;&gt;nodejsApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;班门弄斧之作，若有RN 老手见到，请勿见笑，有不对不合理之处，敬请指教！我是迩伶贰！&lt;/p&gt;
&lt;h3 id=&quot;相关错误处理&quot;&gt;-1、相关错误处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;react-native-camera 插件的使用问题：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529235207534-2103149828.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;解决： https://github.com/react-native-community/react-native-camera/issues/2150&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编译问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201905/1102860-20190529233845078-910593008.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    解决： cd android   &amp;amp;&amp;amp;  ./gradlew clean&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;开发中还遇到了其他问题，但是忘了做记录 ~~ RN 暂时放一段落，接下来要使用 flutter，打算两周后 出一个flutter版本。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 15:39:00 +0000</pubDate>
<dc:creator>adouwt</dc:creator>
<og:description>RN 从上手到“放弃” 前言： react native，相对于最近🔥的飞起的flutter，不算是一个新技术，2015年Facebook 开源，到现在已经4 5 个年头，一直在维护当中，但是至今未</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adouwt/p/10947047.html</dc:identifier>
</item>
<item>
<title>面向对象的三大特征，封装、继承、多态的个人理解以及代码分析 - 技高一筹俊G</title>
<link>http://www.cnblogs.com/GGYC/p/10947052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GGYC/p/10947052.html</guid>
<description>&lt;p&gt;面向过程：我们以前使用的是面向过程编程，你需要清除每个实现步骤，每个步骤每行代码都要仔仔细细的编写，&lt;/p&gt;
&lt;p&gt;　　　　　不知道过程就找不到结果，找到实现过程就可以得到实现结果。&lt;/p&gt;
&lt;p&gt;　　　　　例如： 我们在外打工租房子，我们需要了解每个每个房屋的出租信息，不然是找不到房子的。&lt;/p&gt;
&lt;p&gt;面向对象：对象帮我们做事情，找到对应的对象我们就可以得到想要的结果。&lt;/p&gt;
&lt;p&gt;　　　　   例如： 我们找房子不在如此的繁琐，只要找到中介我们就不怕没有地方住，中介会帮你找房子，你只需支付对应的服务费即可。&lt;/p&gt;
&lt;p&gt;面向对象的三大特征给我们带了巨大的好处，下面我们就来讲解一下。&lt;/p&gt;
&lt;p&gt;　　　　1.什么是封装？&lt;br/&gt;　　　　　　1.1 封装是面向对象的三大特征之一。&lt;br/&gt;　　　　　　1.2 它就是把细节信息封装起来，对外提供操作它的对应的方法。&lt;br/&gt;　　　　　　　　例如：就像一辆车，你从来不关心它是怎么建造的，你只需要懂怎么操作它就可以了。&lt;/p&gt;&lt;p&gt;　　　　2.怎么实现封装&lt;br/&gt;　　　　　　　　2.1 封装的实现方式就是将你需要封装属性提到一个公共的类中，&lt;br/&gt;　　　　　　　　　　将属性私有化，对外提供setter,getter方法，对需要重复使用的实现过程进行抽取为方法。&lt;br/&gt;　　　　3.封装的好处&lt;br/&gt;　　　　　　　　3.1 封装使整个软件开发复杂度大大降低。&lt;br/&gt;　　　　　　　　3.2 将需要重复使用的实现过程进行封装，提高代码的重用性。&lt;br/&gt;　　　　　　　　3.3 你只需找到其对应的方法即可，无需关系它是怎么实现的。&lt;br/&gt;　　　　　　　　3.4 私有化数据将数据隐藏，对无需安全考虑的数据通过setter,getter往外提供，对需要考虑安全问题的数据进行私有化。&lt;br/&gt;　　　　　　　　3.5 你可以对其参数进行限定，适应你的业务范围。&lt;br/&gt;　　　　　　　　　　例如：就像年龄一样，你声明的参数类型为int,int是可以为负值的,&lt;br/&gt;　　　　　　　　　　但是在我们的现实生活中，&lt;br/&gt;　　　　　　　　　　年龄是没有负值的，这时你可以将年龄对应的setter方法内添加一个&lt;br/&gt;　　　　　　　　　　if-else if-else来限制它的范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jq;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 封装
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PackageDemo {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * 将抽象的事物共有的属性进行私有化
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 将不需要对外提供的属性进行私有化。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String phone;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    可以对传入参数进行限定来适应业务需求
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(age&amp;lt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.age = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(age&amp;gt;1000&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.age=1000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * 无需关注代码细节,只需调用即可
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         System.out.println(&quot;吃东西&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        提高代码的重用性
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object add(Double numa,Double numb){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; numa+&lt;span&gt;numb;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接调用方法实现功能,降低了代码的复杂度,也无需关系代码的实现过程&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PackageDemo().add(1d,2d));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
1.什么是继承&lt;br/&gt;1.1 继承就是将共有特征或者行为进行向上抽取,将其共有的东西进行实现或者抽象化。&lt;br/&gt;例如：小明跟小丽都有年龄、性别和名字，人类也有这三个特征，&lt;br/&gt;人类的范畴比小明小丽这个特有个体的范围大，所以可以将年龄、&lt;br/&gt;性别和名字这三个特征向上抽取。&lt;br/&gt;小明跟小丽都是人，都有吃东西这个功能，所以可以向上抽取，&lt;br/&gt;但是小明可能是南方人，小丽可能是北方人，一个是吃面食，一个是吃水稻的。&lt;br/&gt;所以可以将这个共有的行为抽象化。让小明小丽这个特有的个体来进行实现。&lt;br/&gt;2.怎么样继承&lt;br/&gt;2.1 只需将共有的特征或者行为封装为对象，然后使用extends这个关键字进行继承即可。&lt;br/&gt;如有抽象方法需要对抽象方法进行实现。&lt;br/&gt;3.继承的好处&lt;br/&gt;3.1 继承的好处是对共有的属性或者行为进行向上提取，降低了代码的复杂度。&lt;br/&gt;3.2 继承为实现多态提供了前提，没有继承就没有多态。&lt;br/&gt;4.注意事项&lt;br/&gt;4.1 继承时子类共有方法会覆盖父类的共有方法。&lt;br/&gt;例如：子类父类都有吃东西的方法，子类是吃饭，而父类是吃东西，&lt;br/&gt;在使用多态类创建对象( Fu fu = new Zi() )时，调用eat方法是时，会是吃东西而不是吃饭。&lt;br/&gt;4.2 继承时子类属性不会覆盖父类的属性。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jq;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 继承
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;  human {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽取共有特征&lt;/span&gt;
&lt;span&gt;    String name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽取共有方法,特有行为让其子类实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat();

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;human{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}'&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; XiaoMing  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; human{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; XiaoMing() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.name=&quot;小明&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.age=25&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;吃面&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; XiaoLi  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; human{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; XiaoLi() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.name=&quot;小丽&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.age=18&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
        System.out.println(&lt;/span&gt;&quot;吃面&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtendsDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XiaoMing());
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XiaoLi());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
1.什么是多态&lt;br/&gt;1.1 多态就是同一个事物但是他具有多种形态。&lt;br/&gt;例如： 一只二哈，二哈是一只狗，二哈是犬科动物，二哈是一直动物，这就是多态。&lt;br/&gt;2.怎么实现多态&lt;br/&gt;2.1 只需具有继承关系，然后进行类型转换即可。&lt;br/&gt;3.多态的好处&lt;br/&gt;3.1 多态切换多种形态来使用特有的方法。&lt;br/&gt;4.多态的弊端&lt;br/&gt;4.1 只能使用本形态下的属性和方法。&lt;br/&gt;4.2 如果在使用数组或者没有使用泛型的集合内的对象时，需要用到子类特有的方法，必须用instanceof这个关键字来进行类型判断，&lt;br/&gt;否则有可能会出现ClassCastException这个异常。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jq;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 多态
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
    String name&lt;/span&gt;=&quot;二哈&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call(){
        System.out.println(&lt;/span&gt;&quot;汪汪汪汪&quot;&lt;span&gt;);
    }

}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; erha &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Dog {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
        System.out.println(&lt;/span&gt;&quot;吃的一手好狗粮&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; xiaomao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call(){
        System.out.println(&lt;/span&gt;&quot;喵喵喵&quot;&lt;span&gt;);
    }

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PolymorphicDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Object[] animal &lt;/span&gt;= {&lt;span&gt;new&lt;/span&gt; erha(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; xiaomao()};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : animal) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Dog dog =(Dog)o;
            dog.call();
            以上代码会抛异常 java.lang.ClassCastException: com.jq.xiaomao cannot be cast to com.jq.Dog
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Dog){
                Dog dog &lt;/span&gt;=&lt;span&gt;(Dog)o;
                dog.call();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt;  xiaomao){
                xiaomao cat &lt;/span&gt;=&lt;span&gt;(xiaomao)o;
                cat.call();
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 29 May 2019 15:25:00 +0000</pubDate>
<dc:creator>技高一筹俊G</dc:creator>
<og:description>面向过程：我们以前使用的是面向过程编程，你需要清除每个实现步骤，每个步骤每行代码都要仔仔细细的编写， 不知道过程就找不到结果，找到实现过程就可以得到实现结果。 例如： 我们在外打工租房子，我们需要了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GGYC/p/10947052.html</dc:identifier>
</item>
<item>
<title>Spring AOP——Spring 中面向切面编程 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/10941543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/10941543.html</guid>
<description>&lt;p&gt;前面两篇文章记录了 Spring IOC 的相关知识，本文记录 Spring 中的另一特性 AOP 相关知识。&lt;/p&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;部分参考资料：&lt;br/&gt;《Spring实战（第4版）》&lt;br/&gt;《轻量级 JavaEE 企业应用实战（第四版）》&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/core.html#spring-core&quot;&gt;Spring 官方文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cschool.cn/wkspring/&quot;&gt;W3CSchool Spring教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.yiibai.com/spring/&quot;&gt;易百教程 Spring教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;什么是-aop&quot;&gt;1.1 什么是 AOP&lt;/h2&gt;
&lt;p&gt;AOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。&lt;br/&gt;从《Spring实战（第4版）》图书中扒了一张图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225344641-152289598.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从该图可以很形象地看出，所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要-aop&quot;&gt;1.2 为什么需要 AOP&lt;/h2&gt;
&lt;p&gt;想象下面的场景，开发中在多个模块间有某段重复的代码，我们通常是怎么处理的？显然，没有人会靠“复制粘贴”吧。在传统的面向过程编程中，我们也会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。然而需求总是变化的，有一天，新增了一个需求，需要再多出做修改，我们需要再抽象出一个方法，然后再在需要的地方分别调用这个方法，又或者我们不需要这个方法了，我们还是得删除掉每一处调用该方法的地方。实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。&lt;/p&gt;
&lt;h2 id=&quot;aop-实现分类&quot;&gt;1.3 AOP 实现分类&lt;/h2&gt;
&lt;p&gt;AOP 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码，看到这其实应该明白了，AOP 其实就是前面一篇文章讲的代理模式的典型应用。&lt;br/&gt;按照 AOP 框架修改源代码的时机，可以将其分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。&lt;/li&gt;
&lt;li&gt;动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面给出常用 AOP 实现比较&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225400887-1590896890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如不清楚动态代理的，可参考我前面的一篇文章，有讲解静态代理、JDK动态代理和 CGlib 动态代理。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/joy99/p/10865391.html&quot;&gt;静态代理和动态代理 https://www.cnblogs.com/joy99/p/10865391.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AOP 领域中的特性术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。&lt;/li&gt;
&lt;li&gt;连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。&lt;/li&gt;
&lt;li&gt;切点（PointCut）: 可以插入增强处理的连接点。&lt;/li&gt;
&lt;li&gt;切面（Aspect）: 切面是通知和切点的结合。&lt;/li&gt;
&lt;li&gt;引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。&lt;/li&gt;
&lt;li&gt;织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;概念看起来总是有点懵，并且上述术语，不同的参考书籍上翻译还不一样，所以需要慢慢在应用中理解。&lt;/p&gt;

&lt;h2 id=&quot;spring-aop-的特点&quot;&gt;3.1 Spring AOP 的特点&lt;/h2&gt;
&lt;p&gt;AOP 框架有很多种，1.3节中介绍了 AOP 框架的实现方式有可能不同， Spring 中的 AOP 是通过动态代理实现的。不同的 AOP 框架支持的连接点也有所区别，例如，AspectJ 和 JBoss,除了支持方法切点，它们还支持字段和构造器的连接点。而 Spring AOP 不能拦截对对象字段的修改，也不支持构造器连接点,我们无法在 Bean 创建时应用通知。&lt;/p&gt;
&lt;h2 id=&quot;spring-aop-的简单例子&quot;&gt;3.2 Spring AOP 的简单例子&lt;/h2&gt;
&lt;p&gt;下面先上代码，对着代码说比较好说，看下面这个例子：&lt;br/&gt;这个例子是基于gradle创建的，首先 build.gradle 文件添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先创建一个接口 IBuy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

public interface IBuy {
    String buy();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Boy 和 Gril 两个类分别实现了这个接口：&lt;br/&gt;Boy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Boy implements IBuy {
    @Override
    public String buy() {
        System.out.println(&quot;男孩买了一个游戏机&quot;);
        return &quot;游戏机&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public String buy() {
        System.out.println(&quot;女孩买了一件漂亮的衣服&quot;);
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件, AppConfig.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类， AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        boy.buy();
        girl.buy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225425832-1733905596.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里运用SpringIOC里的自动部署。现在需求改变了，我们需要在男孩和女孩的 buy 方法之前，需要打印出“男孩女孩都买了自己喜欢的东西”。用 Spring AOP 来实现这个需求只需下面几个步骤：&lt;br/&gt;1、 &lt;strong&gt;既然用到 Spring AOP, 首先在 &lt;code&gt;build.gralde&lt;/code&gt; 文件中引入相关依赖：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    compile 'org.springframework:spring-context:5.0.6.RELEASE'
    compile 'org.springframework:spring-aspects:5.0.6.RELEASE'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、 &lt;strong&gt;定义一个切面类，BuyAspectJ.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void haha(){
        System.out.println(&quot;男孩女孩都买自己喜欢的东西&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类，我们使用了注解 &lt;code&gt;@Component&lt;/code&gt; 表明它将作为一个Spring Bean 被装配，使用注解 &lt;code&gt;@Aspect&lt;/code&gt; 表示它是一个切面。&lt;br/&gt;类中只有一个方法 &lt;code&gt;haha&lt;/code&gt; 我们使用 &lt;code&gt;@Before&lt;/code&gt; 这个注解，表示他将在方法执行之前执行。关于这个注解后文再作解释。&lt;br/&gt;参数&lt;code&gt;(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)&lt;/code&gt; 声明了切点，表明在该切面的切点是&lt;code&gt;com.sharpcj.aopdemo.test1.Ibuy&lt;/code&gt;这个接口中的&lt;code&gt;buy&lt;/code&gt;方法。至于为什么这么写，下文再解释。&lt;br/&gt;3、 &lt;strong&gt;在配置文件中启用AOP切面功能&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在配置文件类增加了&lt;code&gt;@EnableAspectJAutoProxy&lt;/code&gt;注解，启用了 AOP 功能，参数&lt;code&gt;proxyTargetClass&lt;/code&gt;的值设为了 true 。默认值是 false，两者的区别下文再解释。&lt;br/&gt;OK，下面只需测试代码,运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225446321-1741506938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，结果与我们需求一致，我们并没有修改 Boy 和 Girl 类的 Buy 方法，也没有修改测试类的代码，几乎是完全无侵入式地实现了需求。这就是 AOP 的“神奇”之处。&lt;/p&gt;

&lt;h2 id=&quot;通过注解声明切点指示器&quot;&gt;4.1 通过注解声明切点指示器&lt;/h2&gt;
&lt;p&gt;Spring AOP 所支持的 AspectJ 切点指示器&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225507103-314276426.png&quot;/&gt;&lt;br/&gt;在spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。&lt;/p&gt;
&lt;p&gt;当我们查看上面展示的这些spring支持的指示器时，注意只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器，在此基础上，我们使用其他指示器来限制所匹配的切点。&lt;/p&gt;
&lt;p&gt;下图的切点表达式表示当Instrument的play方法执行时会触发通知。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225530124-1714809272.png&quot;/&gt;&lt;br/&gt;我们使用execution指示器选择Instrument的play方法，方法表达式以 &lt;code&gt;*&lt;/code&gt; 号开始，标识我们不关心方法的返回值类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用 &lt;code&gt;..&lt;/code&gt; 标识切点选择任意的play方法，无论该方法的入参是什么。&lt;br/&gt;多个匹配之间我们可以使用链接符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;！&lt;/code&gt;来表示 “且”、“或”、“非”的关系。但是在使用 XML 文件配置时，这些符号有特殊的含义，所以我们使用 “and”、“or”、“not”来表示。&lt;/p&gt;
&lt;p&gt;举例：&lt;br/&gt;限定该切点仅匹配的包是 &lt;code&gt;com.sharpcj.aopdemo.test1&lt;/code&gt;,可以使用&lt;br/&gt;&lt;code&gt;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; within(com.sharpcj.aopdemo.test1.*)&lt;/code&gt;&lt;br/&gt;在切点中选择 bean,可以使用&lt;br/&gt;&lt;code&gt;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; bean(girl)&lt;/code&gt;&lt;br/&gt;修改 BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;amp;&amp;amp; within(com.sharpcj.aopdemo.test1.*) &amp;amp;&amp;amp; bean(girl)&quot;)
    public void hehe(){
        System.out.println(&quot;男孩女孩都买自己喜欢的东西&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，切面只会对 &lt;code&gt;Girl.java&lt;/code&gt; 这个类生效，执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225548745-1785519580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的你，可能发现了，切面中的方法名，已经被我悄悄地从&lt;code&gt;haha&lt;/code&gt;改成了&lt;code&gt;hehe&lt;/code&gt;，丝毫没有影响结果，说明方法名没有影响。和 Spring IOC 中用 java 配置文件装配 Bean 时，用&lt;code&gt;@Bean&lt;/code&gt; 注解修饰的方法名一样，没有影响。&lt;/p&gt;
&lt;h2 id=&quot;通过注解声明-5-种通知类型&quot;&gt;4.2 通过注解声明 5 种通知类型&lt;/h2&gt;
&lt;p&gt;Spring AOP 中有 5 中通知类型，分别如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225613898-1522094074.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面修改切面类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {
    @Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便看效果,我们测试类中，只要 Boy 类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        boy.buy();
        // girl.buy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225633682-474468038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果显而易见。指的注意的是 &lt;code&gt;@Around&lt;/code&gt; 修饰的环绕通知类型，是将整个目标方法封装起来了，在使用时，我们传入了 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt; 类型的参数，这个对象是必须要有的，并且需要调用 &lt;code&gt;ProceedingJoinPoint&lt;/code&gt; 的 &lt;code&gt;proceed()&lt;/code&gt; 方法。 如果没有调用 该方法，执行结果为 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Around aaa ...
Around bbb ...
After ...
AfterReturning ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，如果不调用该对象的 proceed() 方法，表示原目标方法被阻塞调用，当然也有可能你的实际需求就是这样。&lt;/p&gt;
&lt;h2 id=&quot;通过注解声明切点表达式&quot;&gt;4.3 通过注解声明切点表达式&lt;/h2&gt;
&lt;p&gt;如你看到的，上面我们写的多个通知使用了相同的切点表达式，对于像这样频繁出现的相同的表达式，我们可以使用 &lt;code&gt;@Pointcut&lt;/code&gt;注解声明切点表达式，然后使用表达式，修改代码如下：&lt;br/&gt;BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {

    @Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void point(){}

    @Before(&quot;point()&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;point()&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;point()&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;point()&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果没有变化。&lt;br/&gt;这里，我们使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
public void point(){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了一个切点表达式，该方法 point 的内容并不重要，方法名也不重要，实际上它只是作为一个标识，供通知使用。&lt;/p&gt;
&lt;h2 id=&quot;通过注解处理通知中的参数&quot;&gt;4.4 通过注解处理通知中的参数&lt;/h2&gt;
&lt;p&gt;上面的例子，我们要进行增强处理的目标方法没有参数，下面我们来说说有参数的情况，并且在增强处理中使用该参数。&lt;br/&gt;下面我们给接口增加一个参数，表示购买所花的金钱。通过AOP 增强处理，如果女孩买衣服超过了 68 元，就可以赠送一双袜子。&lt;br/&gt;更改代码如下：&lt;br/&gt;IBuy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

public interface IBuy {
    String buy(double price);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public String buy(double price) {
        System.out.println(String.format(&quot;女孩花了%s元买了一件漂亮的衣服&quot;, price));
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Boy.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Boy implements IBuy {
    @Override
    public String buy(double price) {
        System.out.println(String.format(&quot;男孩花了%s元买了一个游戏机&quot;, price));
        return &quot;游戏机&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看 BuyAspectJ 类，我们将之前的通知都注释掉。用一个环绕通知来实现这个功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class BuyAspectJ {

    /*
    @Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)
    public void point(){}

    @Before(&quot;point()&quot;)
    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    @After(&quot;point()&quot;)
    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    @AfterReturning(&quot;point()&quot;)
    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    @Around(&quot;point()&quot;)
    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
    */


    @Pointcut(&quot;execution(String com.sharpcj.aopdemo.test1.IBuy.buy(double)) &amp;amp;&amp;amp; args(price) &amp;amp;&amp;amp; bean(girl)&quot;)
    public void gif(double price) {
    }

    @Around(&quot;gif(price)&quot;)
    public String hehe(ProceedingJoinPoint pj, double price){
        try {
            pj.proceed();
            if (price &amp;gt; 68) {
                System.out.println(&quot;女孩买衣服超过了68元，赠送一双袜子&quot;);
                return &quot;衣服和袜子&quot;;
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前文提到，当不关心方法返回值的时候，我们在编写切点指示器的时候使用了 &lt;code&gt;*&lt;/code&gt; ， 当不关心方法参数的时候，我们使用了 &lt;code&gt;..&lt;/code&gt;。现在如果我们需要传入参数，并且有返回值的时候，则需要使用对应的类型。在编写通知的时候，我们也需要声明对应的返回值类型和参数类型。&lt;/p&gt;
&lt;p&gt;测试类：AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import com.sharpcj.aopdemo.test1.Boy;
import com.sharpcj.aopdemo.test1.Girl;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Boy boy = context.getBean(&quot;boy&quot;,Boy.class);
        Girl girl = (Girl) context.getBean(&quot;girl&quot;);
        String boyBought = boy.buy(35);
        String girlBought = girl.buy(99.8);

        System.out.println(&quot;男孩买到了：&quot; + boyBought);
        System.out.println(&quot;女孩买到了：&quot; + girlBought);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225709155-1683416178.png&quot;/&gt;&lt;br/&gt;可以看到，我们成功通过 AOP 实现了需求，并将结果打印了出来。&lt;/p&gt;
&lt;h2 id=&quot;通过注解配置织入的方式&quot;&gt;4.5 通过注解配置织入的方式&lt;/h2&gt;
&lt;p&gt;前面还有一个遗留问题，在配置文件中，我们用注解 &lt;code&gt;@EnableAspectJAutoProxy()&lt;/code&gt; 启用Spring AOP 的时候，我们给参数 &lt;code&gt;proxyTargetClass&lt;/code&gt; 赋值为 &lt;code&gt;true&lt;/code&gt;,如果我们不写参数，默认为 false。这个时候运行程序，程序抛出异常&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225724860-1448694025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个强制类型转换异常。为什么会抛出这个异常呢？或许已经能够想到，这跟Spring AOP 动态代理的机制有关，这个 &lt;code&gt;proxyTargetClass&lt;/code&gt; 参数决定了代理的机制。当这个参数为 false 时，&lt;br/&gt;通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常。&lt;br/&gt;反之，&lt;code&gt;proxyTargetClass&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被&lt;code&gt;final&lt;/code&gt;修饰时，无法进行织入。&lt;br/&gt;测试一下，我们将 &lt;code&gt;proxyTargetClass&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt;，同时将 Girl.java 的 Buy 方法用 &lt;code&gt;final&lt;/code&gt; 修饰：&lt;br/&gt;AppConfig.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackageClasses = {com.sharpcj.aopdemo.test1.IBuy.class})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Girl.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test1;

import org.springframework.stereotype.Component;

@Component
public class Girl implements IBuy {
    @Override
    public final String buy(double price) {
        System.out.println(String.format(&quot;女孩花了%s元买了一件漂亮的衣服&quot;, price));
        return &quot;衣服&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529225755992-1036671637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们的切面并没有织入生效。&lt;/p&gt;

&lt;p&gt;前面的示例中，我们已经展示了如何通过注解配置去声明切面，下面我们看看如何在 XML 文件中声明切面。下面先列出 XML 中声明 AOP 的常用元素：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190529232014979-1838628294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们依然可以使用 &lt;code&gt;&amp;lt;aop:aspectj-autoproxy&amp;gt;&lt;/code&gt; 元素，他能够自动代理AspectJ注解的通知类。&lt;/p&gt;
&lt;h2 id=&quot;xml-配置文件中切点指示器&quot;&gt;5.1 XML 配置文件中切点指示器&lt;/h2&gt;
&lt;p&gt;在XML配置文件中，切点指示器表达式与通过注解配置的写法基本一致，区别前面有提到，即XML文件中需要使用 “and”、“or”、“not”来表示 “且”、“或”、“非”的关系。&lt;/p&gt;
&lt;h2 id=&quot;xml-文件配置-aop-实例&quot;&gt;5.2 XML 文件配置 AOP 实例&lt;/h2&gt;
&lt;p&gt;下面我们不使用任何注解改造上面的例子：&lt;br/&gt;BuyAspectJ.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.aopdemo.test2;

import org.aspectj.lang.ProceedingJoinPoint;

public class BuyAspectJ {

    public void hehe() {
        System.out.println(&quot;before ...&quot;);
    }

    public void haha() {
        System.out.println(&quot;After ...&quot;);
    }

    public void xixi() {
        System.out.println(&quot;AfterReturning ...&quot;);
    }

    public void xxx(ProceedingJoinPoint pj) {
        try {
            System.out.println(&quot;Around aaa ...&quot;);
            pj.proceed();
            System.out.println(&quot;Around bbb ...&quot;);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Resource 目录下新建一个配置文件 aopdemo.xml ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;boy&quot; class=&quot;com.sharpcj.aopdemo.test2.Boy&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;girl&quot; class=&quot;com.sharpcj.aopdemo.test2.Girl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;buyAspectJ&quot; class=&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;aop:config proxy-target-class=&quot;true&quot;&amp;gt;
        &amp;lt;aop:aspect id=&quot;qiemian&quot; ref=&quot;buyAspectJ&quot;&amp;gt;
            &amp;lt;aop:before pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;hehe&quot;/&amp;gt;
            &amp;lt;aop:after pointcut=&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot; method=&quot;haha&quot;/&amp;gt;
            &amp;lt;aop:after-returning&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 29 May 2019 15:13:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>这篇文章简单记录了 AOP 的编程思想，然后重点有序地介绍了 Spring 中 AOP 的相关概念，以及通过注解方式和XML配置文件两种方式使用 Spring AOP进行编程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/joy99/p/10941543.html</dc:identifier>
</item>
<item>
<title>【tf.keras】tf.keras加载AlexNet预训练模型 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10942877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10942877.html</guid>
<description>&lt;p&gt;tf.keras 的预训练模型都放在了'tensorflow.python.keras.applications' 目录下，在 tensorflow 1.10 版本中，预训练好的模型有：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DenseNet121, DenseNet169, DenseNet201, InceptionResNetV2, InceptionV3, MobileNet, NASNetLarge, NASNetMobile, ResNet50, VGG16, VGG19, Xception.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;找了半天，发现 keras 没有预训练好的 AlexNet。。。&lt;/p&gt;
&lt;p&gt;所以本文提供一种从其它框架（如 PyTorch）导入预训练模型的方法，下面以 AlexNet 为例。&lt;/p&gt;
&lt;h2 id=&quot;从-pytorch-中导出模型参数&quot;&gt;从 PyTorch 中导出模型参数&lt;/h2&gt;
&lt;p&gt;首先明白一点，当模型的结构一样时，我们只需要导入模型的参数即可复现模型，所以我们要做的就是从 PyTorch 中导出预训练好的模型参数，并用 keras 加载。&lt;/p&gt;
&lt;p&gt;这里要介绍一个微软的项目：&lt;a href=&quot;https://github.com/microsoft/MMdnn&quot;&gt;MMdnn&lt;/a&gt;。MMdnn 使我们可以在不同深度学习框架之间转换模型，这里我也使用 MMdnn 来转换 AlexNet（PyTorch to Keras）。&lt;/p&gt;
&lt;h3 id=&quot;第-0-步配置环境&quot;&gt;第 0 步：配置环境&lt;/h3&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;必须一致配置：
- PyTorch: 0.4.0 （如果其它版本出现了问题，请退回到 0.4.0 版）

非必须一致配置：
- numpy: 1.14.5 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第-1-步安装-mmdnn&quot;&gt;第 1 步：安装 MMdnn&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ pip3 install mmdnn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它安装方式请参考 &lt;a href=&quot;https://github.com/microsoft/MMdnn#installation&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;第-2-步得到-pytorch-保存完整结构和参数的模型pth-文件&quot;&gt;第 2 步：得到 PyTorch 保存完整结构和参数的模型（pth 文件）&lt;/h3&gt;
&lt;p&gt;PyTorch 保存模型时，可以保存整个模型，也可以仅保存模型的参数，都是存放到 pth 文件中。&lt;/p&gt;
&lt;p&gt;mmdnn 操作的 pth 文件是要求含有模型结构的，具体参见 &lt;a href=&quot;https://github.com/Microsoft/MMdnn/blob/master/mmdnn/conversion/pytorch/README.md#faq&quot;&gt;FAQ&lt;/a&gt;，而在 PyTorch 中预训练 AlexNet 仅保存了参数。&lt;/p&gt;
&lt;p&gt;通过以下程序得到包含有模型结构和权重的 AlexNet 预训练模型（pth 文件）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torchvision

m = torchvision.models.alexnet(pretrained=True)                    
torch.save(m, './alexnet.pth')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于其它模型，如 resnet101，可以通过以下指令直接得到含有结构和权重的预训练模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mmdownload -f pytorch -n resnet101 -o ./&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（不要通过上述指令得到 alexnet.pth，因为其仅仅包含权重，而不含结构，故后面一步会出现错误 &quot;AttributeError: 'collections.OrderedDict' object has no attribute 'state_dict'&quot;。）&lt;/p&gt;
&lt;h3 id=&quot;第-3-步导出-pytorch-模型的参数保存至-hdf5-文件&quot;&gt;第 3 步：导出 PyTorch 模型的参数，保存至 hdf5 文件&lt;/h3&gt;
&lt;p&gt;依次执行以下三条指令，最后会得到一个 'keras_alexnet.h5' 文件，这就是我们想要的 keras 能加载的预训练权重文件。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ mmtoir -f pytorch -d alexnet --inputShape 3,227,227 -n alexnet.pth
IR network structure is saved as [alexnet.json].
IR network structure is saved as [alexnet.pb].
IR weights are saved as [alexnet.npy].
$ mmtocode -f keras --IRModelPath alexnet.pb --IRWeightPath alexnet.npy --dstModelPath keras_alexnet.py
Using TensorFlow backend.
Parse file [alexnet.pb] with binary format successfully.
Target network code snippet is saved as [keras_alexnet.py].
$ python3 -m mmdnn.conversion.examples.keras.imagenet_test -n keras_alexnet.py -w alexnet.npy --dump keras_alexnet.h5
Using TensorFlow backend.
Keras model file is saved as [keras_alexnet.h5], generated by [keras_alexnet.py.py] and [alexnet.npy].&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可能遇到的问题&quot;&gt;可能遇到的问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AttributeError: 'Conv2d' object has no attribute 'padding_mode'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Solution：PyTorch 版本问题，1.1.0 版会出现这个问题，回退到 0.4.0 版本即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade torch==0.4.0 torchvision==0.2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Solution：请更改 numpy 版本。&lt;/p&gt;
&lt;p&gt;Solution：pth 文件仅含模型参数而不含模型结构，在 PyTorch 中加载一下然后保存含有模型结构和参数的 pth 文件。&lt;/p&gt;
&lt;h2 id=&quot;验证从-pytorch-导出的-alexnet-预训练模型&quot;&gt;验证从 PyTorch 导出的 AlexNet 预训练模型&lt;/h2&gt;
&lt;p&gt;测试用的几张图片、代码以及生成的 keras_alexnet.h5 文件都存放到了云盘：(链接:&lt;a href=&quot;https://pan.baidu.com/s/1TCbSHn5DC7pPIk-0dnbmgg&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1TCbSHn5DC7pPIk-0dnbmgg&lt;/a&gt; 密码:8njp)。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch
import torchvision
import cv2
import numpy as np

from torch.autograd import Variable

import tensorflow as tf
from tensorflow.keras import layers,regularizers


filename_test = 'data/dog2.png'

img = cv2.imread(filename_test)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# 数据预处理
img = cv2.resize(img, (227, 227))
img = img / 255.0
img = np.reshape(img, (1, 227, 227, 3))
# 标准化，这是 PyTorch 预训练 AlexNet 模型的预处理方式，详情请见 https://pytorch.org/docs/stable/torchvision/models.html
mean = np.array([0.485, 0.456, 0.406]).reshape([1, 1, 1, 3])
std = np.array([0.229, 0.224, 0.225]).reshape([1, 1, 1, 3])
img = (img - mean) / std

# PyTorch
# PyTorch 数据输入 channel 排列和 Keras 不一致
img_tmp = np.transpose(img, (0, 3, 1, 2))

model = torchvision.models.alexnet(pretrained=True)

# torch.save(model, './model/alexnet.pth')
model = model.double()
model.eval()

y = model(Variable(torch.tensor(img_tmp)))
# 预测的类别
print(np.argmax(y.detach().numpy()))


# Keras
def get_AlexNet(num_classes=1000, drop_rate=0.5, regularizer_rate=0.01):
    &quot;&quot;&quot;
    PyTorch 中实现的 AlexNet 预训练模型结构，filter 的深度分别为：（64，192，384，256，256）。
    返回 AlexNet 的 inputs 和 outputs
    &quot;&quot;&quot;
    inputs = layers.Input(shape=[227, 227, 3])

    conv1 = layers.Conv2D(64, (11, 11), strides=(4, 4), padding='valid', activation='relu')(inputs)

    pool1 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv1)

    conv2 = layers.Conv2D(192, (5, 5), strides=(1, 1), padding='same', activation='relu')(pool1)

    pool2 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv2)

    conv3 = layers.Conv2D(384, (3, 3), strides=(1, 1), padding='same', activation='relu')(pool2)

    conv4 = layers.Conv2D(256, (3, 3), strides=(1, 1), padding='same', activation='relu')(conv3)

    conv5 = layers.Conv2D(256, (3, 3), strides=(1, 1), padding='same', activation='relu')(conv4)

    pool3 = layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2))(conv5)

    flat = layers.Flatten()(pool3)

    dense1 = layers.Dense(4096, activation='relu', kernel_regularizer=regularizers.l2(regularizer_rate))(flat)
    dense1 = layers.Dropout(drop_rate)(dense1)
    dense2 = layers.Dense(4096, activation='relu', kernel_regularizer=regularizers.l2(regularizer_rate))(dense1)
    dense2 = layers.Dropout(drop_rate)(dense2)
    outputs = layers.Dense(num_classes, activation='softmax', kernel_regularizer=regularizers.l2(regularizer_rate))(dense2)

    return inputs, outputs

inputs, outputs = get_AlexNet()
model2 = tf.keras.Model(inputs, outputs)
model2.load_weights('./keras_alexnet.h5')
# 预测的类别
print(np.argmax(model2.predict(img)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预测结果代表的类别请看博客 &lt;a href=&quot;https://blog.csdn.net/weixin_41770169/article/details/80482942&quot;&gt;ImageNet图像库1000个类别名称（中文注释不断更新）&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;attentions&quot;&gt;Attentions&lt;/h2&gt;
&lt;p&gt;PyTorch 中的预训练 AlexNet 模型卷积层 filter 的个数和原论文不一致，filter 的个数分别 &lt;span class=&quot;math inline&quot;&gt;\(64，192，384，256，256\)&lt;/span&gt;。具体参见 &lt;a href=&quot;https://github.com/pytorch/vision/blob/master/torchvision/models/alexnet.py&quot;&gt;GitHub - pytorch: vision/torchvision/models/alexnet.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyTorch 给出的解释是，它的预训练 AlexNet 模型用的是论文 &lt;a href=&quot;https://arxiv.org/abs/1404.5997&quot;&gt;Krizhevsky, A. (2014). One weird trick for parallelizing convolutional neural networks. arXiv preprint arXiv:1404.5997.&lt;/a&gt; 给出的架构，但 PyTorch 的模型架构和这篇论文还是有区别，这篇论文中第四个卷积层 filter 个数为 384，而 PyTorch 为 256。&lt;/p&gt;
&lt;p&gt;而 caffe 中实现的 AlexNet 含有原始的 LRN 层，去掉 LRN 层后，个人感觉预训练的权重就不能直接拿来用了。&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/MMdnn&quot;&gt;GitHub - microsoft/MMdnn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_41770169/article/details/80482942&quot;&gt;ImageNet图像库1000个类别名称（中文注释不断更新）-- 徐小妹&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 14:49:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>本文介绍了如何将 PyTorch 中实现的 AlexNet 预训练模型加载到 tf.keras 中。tf.keras没有预训练好的AlexNet模型，如果我们想要在keras上用AlexNet来做迁移</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuliytTaotao/p/10942877.html</dc:identifier>
</item>
<item>
<title>从Flux到Redux详解单项数据流 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/10946783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/10946783.html</guid>
<description>&lt;p&gt;从Flux到Redux是状态管理工具的演变过程，但两者还是有细微的区别的。但是最核心的都还是观察者模式的应用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Flux&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. Flux的处理逻辑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗来讲，应用的状态被放到了store中，组件是store状态的一个映射，用户通过事件触发action，再通过Dispatcher根据不同的actionType进行分发，并做不同的逻辑处理，但核心都是通过直接改变store的状态，再触发emitChange间接改变组件中的数据。（后面会上代码）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/849191/201905/849191-20190529211700422-1214409283.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;从代码层面来讲，store中的数据通过EventEmitter注册监听，并通知引入此store的组件状态变化，view中的数据实时通过store获取，action中则是通过AppDispatcher分发，而注册后的AppDispatcher则根据对应的actionTypes做不通的逻辑处理。&lt;/p&gt;
&lt;p&gt;常规方法使用Flux需要引入的库有：Dispatcher，EventEmitter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Flux的劣势：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Flux可以有多个store，而当逻辑复杂时，多个store的依赖会非常繁琐。异步操作也不是很友好。&lt;/p&gt;
&lt;p&gt;2. 难以进行服务端渲染，同构成本较高。&lt;/p&gt;
&lt;p&gt;3. store混杂了处理逻辑与状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Flux项目的关联核心代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;js/countPanel.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类的构造函数初始化store的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
constructor (props) {
　　super(props);
　　this.state = {max: 15, fluxData: CounterValues};
　　this.setMax = this.setMax.bind(this);
　　this.totalChange = this.totalChange.bind(this);
　　this.fluxTest = this.fluxTest.bind(this);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在事件中调用action&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;button onClick={this.fluxTest}&amp;gt;click flux&amp;lt;/button&amp;gt;

fluxTest () {
    increment();
}    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./Action.js&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import * as ActionTypes from './ActionTypes.js';
import AppDispatcher from './AppDispatcher.js';

export const increment = (counterCaption) =&amp;gt; {
　　AppDispatcher.dispatch({
　　　　type: ActionTypes.INCREMENT,
　　　　counterCaption: counterCaption
　　})
}

export const decrement = (counterCaption) =&amp;gt; {
　　AppDispatcher.dispatch({
　　　　type: ActionTypes.DECREMENT,
　　　　counterCaption: counterCaption
　　})
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./AppDispatcher.js&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import {Dispatcher} from 'flux';
import * as ActionTypes from './ActionTypes.js';
import CounterStore from './store/CounterStore.js';
let AppDispatcher = new Dispatcher();

AppDispatcher.register((actions) =&amp;gt; {
　　if (actions.type === ActionTypes.INCREMENT) {
　　　　// CounterValues[actions.counterCaption]++;
　　　　CounterStore.doChange('First', 1000)
　　　　CounterStore.emitChange();
　　} else if (actions.type === ActionTypes.DECREMENT) {
　　　　// doSomthing
　　}
})
export default AppDispatcher;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./store/CounterStore.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过EventEmitter（观察者模式最典型的应用）注册数据监听与处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import {EventEmitter} from 'events';
const CounterValues = {
　　First: 0,
　　Second: 10,
　　Third: 30
}
const CounterStore = Object.assign({}, EventEmitter.prototype, {
　　doChange (counterKey, CounterVal) {
　　　　CounterValues[counterKey] = CounterVal;
　　},
　　getCounterValues: function () {
　　　　return CounterValues;
　　},
　　emitChange: function () {
　　　　this.emit('change');
　　},
　　addChangeListener: function (callBack) {
　　　　this.on('change', callBack);
　　},
　　removeChangeListener: function (callBack) {
　　　　this.removeChangeListener('change', callBack)
　　}
})
export {CounterValues};
export default CounterStore;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Redux&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Redux的三条原则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）唯一数据源&lt;/p&gt;
&lt;p&gt;（2）保持状态只读&lt;/p&gt;
&lt;p&gt;（3）通过纯函数改变数据&lt;/p&gt;
&lt;p&gt;ps： 纯函数：1.不得改写参数 2. 不得调用系统的IO 3. 不能调用Date.now()或Math.random()等方法，因为每次获取的结果都不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Redux的逻辑处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/849191/201905/849191-20190529222125429-920552101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;与Flux的区别在于：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）Flux中对action的处理没有返回值，只是通过Dispatcher分发动作，由Dispatcher的注册函数中做逻辑处理；而Redux中则取消了Dispatcher对象，action只是通过store的dispatch方法提交动作，再由store注册的reducer根据对应的ActionTypes做逻辑处理。&lt;/p&gt;
&lt;p&gt;（2）Flux中的逻辑处理是直接对现有的state做处理，而Redux则是通过纯函数进行处理，在原有的state基础上返回新生成的state，不会对原有数据产生副作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Redux实际使用的核心代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;./counter.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在事件处理函数中通过store.dispatch分发动作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
onIncrement() {
    store.dispatch(Actions.increment(this.props.caption));
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过subscribe进行监听：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
componentDidMount() {
   store.subscribe(this.onChange);
}

componentWillUnmount() {
   store.unsubscribe(this.onChange);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./action.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对应的dispatch处理函数中，返回一个action对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
export const increment = (counterCaption) =&amp;gt; {
  return {
    type: ActionTypes.INCREMENT,
    counterCaption: counterCaption
  };
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./reducer.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过纯函数处理对应的action&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
export default (state, action) =&amp;gt; {
  const {counterCaption} = action;
  switch (action.type) {
    case ActionTypes.INCREMENT:
      return {...state, [counterCaption]: state[counterCaption] + 1};
    case ActionTypes.DECREMENT:
      return {...state, [counterCaption]: state[counterCaption] - 1};
    default:
      return state
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;./store.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过createStore将reducer与store数据联系起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import {createStore} from 'redux';
import reducer from './reducer.js';

const initValues = {
  'First': 0,
  'Second': 10,
  'Third': 20
};

const store = createStore(reducer, initValues);

export default store;
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Wed, 29 May 2019 14:39:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<og:description>从Flux到Redux是状态管理工具的演变过程，但两者还是有细微的区别的。但是最核心的都还是观察者模式的应用。 一、Flux 1. Flux的处理逻辑 通俗来讲，应用的状态被放到了store中，组件是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pomelott/p/10946783.html</dc:identifier>
</item>
<item>
<title>语音信号预处理——数字滤波器 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/10886622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/10886622.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518211219190-407862173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\omega _p$：通带截止频率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\omega _s$：阻带截止频率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\delta_p$：通带波动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\delta_s$：阻带波动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;衰减单位是db&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;butterworth低通滤波器的频域特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$|H(jw)|^2=\frac{1}{1+(\frac{\omega }{\omega _c})^{2N}}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N：滤波器的阶数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\omega _c$：3dB截频&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518215408080-730525917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图  典型BW低通滤波器的幅度响应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特点：在通带的频率响应曲线最平滑&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Python实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;butter&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;N, Wn, btype='low', analog=False, output='ba'&lt;big&gt;)&lt;/big&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;N&lt;/strong&gt;：滤波器的阶数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Wn&lt;/strong&gt;：对于数字滤波器：Wn应该归一化为(0,1)，Wn=截止频率/信号频率，（信号频率=采样率的一半，奈奎斯特采样定理）对于模拟滤波器：Wn是角频率，弧度/样本，rad/s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;btype&lt;/strong&gt;：滤波器的类型{'&lt;strong&gt;lowpass&lt;/strong&gt;'，'&lt;strong&gt;highpass&lt;/strong&gt;'，'&lt;strong&gt;bandpass&lt;/strong&gt;'，'&lt;strong&gt;bandstop&lt;/strong&gt;'}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;analog&lt;/strong&gt;：如果为True，则返回模拟滤波器，否则返回数字滤波器。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：滤波器系数， a为分母，b为分子。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;scipy.signal.&lt;/code&gt;&lt;code&gt;freqs&lt;/code&gt;(b, a, worN=200, plot=None)　&lt;/strong&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算&lt;span&gt;&lt;strong&gt;模拟滤波器&lt;/strong&gt;&lt;/span&gt;的频率响应H(w)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：滤波器的分子和分母，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;worN：可选，如果为None，则计算响应曲线的有趣部分周围的200个频率。如果是一个整数，则计算那么多频率。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;w：&lt;span&gt;&lt;span&gt;计算&lt;/span&gt;&lt;/span&gt;&lt;em class=&quot;xref py py-obj&quot;&gt;&lt;span&gt;&lt;span&gt;h&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;的&lt;strong&gt;角频率&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;h：频率响应&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;freqz&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;b, a=1, worN=None, whole=False, plot=None)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算数字滤波器的频率响应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：线性滤波器的分子和分母&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;worN：&lt;span&gt;如果为None（默认值），则计算在单位圆周围等间隔的512个频率。&lt;/span&gt;&lt;span&gt;如果是一个整数，则计算那么多频率。&lt;/span&gt;&lt;span&gt;如果是array_like，则计算给定频率的响应（以弧度/样本为单位）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;w：计算h的归一化频率，以弧度/样本计算。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;h：频率响应&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;lfilter&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;b, a, x, axis=-1, zi=None&lt;big&gt;)&lt;/big&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用IIR或FIR滤波器沿一维过滤数据。使用数字滤波器过滤数据序列x。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：分子和分母，即滤波器系数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;x：输入数据&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回：数字滤波器的输出&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scipy.signal &lt;span&gt;import&lt;/span&gt;&lt;span&gt; butter, lfilter
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

b, a &lt;/span&gt;= signal.butter(4, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, analog=True)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设计N阶数字或模拟Butterworth滤波器并返回滤波器系数&lt;/span&gt;
w, h = signal.freqs(b, a)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据系数计算滤波器的频率响应，w是角频率，h是频率响应&lt;/span&gt;
plt.semilogx(w, 20 *&lt;span&gt; np.log10(abs(h)))
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Butterworth filter frequency response&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency [radians / second]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude [dB]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.margins(0, &lt;/span&gt;0.1&lt;span&gt;)
plt.grid(which&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axvline(&lt;/span&gt;100, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cutoff frequency&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518225222333-242883936.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;提取窄带语音信号&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对采样率为16000Hz，奈奎斯特频率为8000Hz的语音，通过巴特沃斯低通滤波器，滤除高于4000Hz频率的语音，提取低频语音。过滤出的信号，在采样率相同的情况下，频率只有原来的一半。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; librosa 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy.signal &lt;span&gt;import&lt;/span&gt;&lt;span&gt; butter, lfilter, freqz
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; butter_lowpass(cutoff, fs, order=5&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cutoff：截止频率&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fs 采样率&lt;/span&gt;
    nyq = 0.5 * fs                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 信号频率&lt;/span&gt;
    normal_cutoff = cutoff / nyq    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正常截止频率=截止频率/信号频率&lt;/span&gt;
    b, a = butter(order, normal_cutoff, btype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lowpass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, analog=&lt;span&gt;False)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b, a


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; butter_lowpass_filter(data, cutoff, fs, order=5&lt;span&gt;):
    b, a &lt;/span&gt;= butter_lowpass(cutoff, fs, order=&lt;span&gt;order)
    y &lt;/span&gt;=&lt;span&gt; lfilter(b, a, data)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; y  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Filter requirements.&lt;/span&gt;
&lt;span&gt;

order &lt;/span&gt;= 10&lt;span&gt;
fs &lt;/span&gt;= 16000                                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采样率, Hz&lt;/span&gt;
cutoff = 4000                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 滤波器的期望截止频率，Hz # 得到滤波器系数，这样我们就可以检查它的频率响应。&lt;/span&gt;
b, a = butter_lowpass(cutoff, fs, order)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制频率响应&lt;/span&gt;
w, h =&lt;span&gt; freqz(b, a)
plt.subplot(&lt;/span&gt;3, 1, 1&lt;span&gt;)
plt.plot(&lt;/span&gt;0.5*fs*w/np.pi, np.abs(h), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axvline(cutoff, color&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlim(0, &lt;/span&gt;0.5*&lt;span&gt;fs)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lowpass Filter Frequency Response&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency [Hz]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

data, wav_fs &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=True)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 48000---&amp;gt;16000&lt;/span&gt;
y =&lt;span&gt; butter_lowpass_filter(data, cutoff, fs, order)

plt.subplot(&lt;/span&gt;3, 1, 2&lt;span&gt;)
plt.specgram(data, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time [sec]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;3, 1, 3&lt;span&gt;)
plt.specgram(y, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time [sec]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519082847646-2115534799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CB I型低通滤波器的频域特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$|H(jw)|^2=\frac{1}{1+\varepsilon ^2C_N^2(\frac{w}{w_c})}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N：滤波器的阶数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\varepsilon$：通带波纹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\omega _c$：通带截频&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518215251693-1489545768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图  CB I型低通滤波器的幅度响应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特点：通带是等波动的，阻带是单调的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;cheby1&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;N, rp, Wn, btype='low', analog=False, output='ba'&lt;big&gt;)&lt;/big&gt;&lt;/span&gt;&lt;span&gt;&lt;a class=&quot;reference external&quot; href=&quot;http://github.com/scipy/scipy/blob/v0.18.1/scipy/signal/filter_design.py#L1935-L2018&quot;&gt;&lt;span class=&quot;viewcode-link&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chebyshev I型数字和模拟滤波器，设计N阶数字或模拟Chebyshev I型滤波器并返回滤波器系数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;N：&lt;/strong&gt;滤波器的阶数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rp：&lt;/strong&gt;通带中允许的最大纹波低于单位增益，以分贝为单位，正数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Wn：&lt;/strong&gt;对于数字滤波器：Wn应该归一化为(0,1)，Wn=截止频率/信号频率，（信号频率=采样率的一半，奈奎斯特采样定理）对于模拟滤波器：Wn是角频率，弧度/样本，rad/s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;btype&lt;/strong&gt;：滤波器的类型{'&lt;strong&gt;lowpass&lt;/strong&gt;'，'&lt;strong&gt;highpass&lt;/strong&gt;'，'&lt;strong&gt;bandpass&lt;/strong&gt;'，'&lt;strong&gt;bandstop&lt;/strong&gt;'}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;analog&lt;/strong&gt;：如果为True，则返回模拟滤波器，否则返回数字滤波器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;output：&lt;/strong&gt;默认“ba”,输出分子和分母&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：滤波器系数， a为分母，b为分子。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

b, a &lt;/span&gt;= signal.cheby1(4, 5, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, analog=&lt;span&gt;True)
w, h &lt;/span&gt;=&lt;span&gt; signal.freqs(b, a)
plt.semilogx(w, &lt;/span&gt;20 *&lt;span&gt; np.log10(abs(h)))
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chebyshev Type I frequency response (rp=5)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency [radians / second]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude [dB]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.margins(0, &lt;/span&gt;0.1&lt;span&gt;)
plt.grid(which&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axvline(&lt;/span&gt;100, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cutoff frequency&lt;/span&gt;
plt.axhline(-5, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rp&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519100104261-1842698757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CB II型低通滤波器的频域特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; $$|H(jw)|^2=1-\frac{1}{1+\varepsilon ^2C_N^2(\frac{w}{w_c})}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;N：滤波器的阶数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\varepsilon$：阻带波纹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$\omega _c$：阻带截频&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518215205586-454600741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图  CB II型低通滤波器的幅度响应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特点：通带是单调的，阻带是等波动的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;cheby2&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;N, rs, Wn, btype='low', analog=False, output='ba'&lt;big&gt;)&lt;/big&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;a class=&quot;reference external&quot; href=&quot;http://github.com/scipy/scipy/blob/v0.18.1/scipy/signal/filter_design.py#L2021-L2099&quot;&gt;&lt;span class=&quot;viewcode-link&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chebyshev II型数字和模拟滤波器，设计N阶数字或模拟Chebyshev II型滤波器并返回滤波器系数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;N：&lt;/strong&gt;滤波器的阶数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rs：&lt;/strong&gt;阻带所需最小衰减，以分贝为单位，正数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Wn：&lt;/strong&gt;对于数字滤波器：Wn应该归一化为(0,1)，Wn=截止频率/信号频率，（信号频率=采样率的一半，奈奎斯特采样定理）对于模拟滤波器：Wn是角频率，弧度/样本，rad/s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;btype&lt;/strong&gt;：滤波器的类型{'&lt;strong&gt;lowpass&lt;/strong&gt;'，'&lt;strong&gt;highpass&lt;/strong&gt;'，'&lt;strong&gt;bandpass&lt;/strong&gt;'，'&lt;strong&gt;bandstop&lt;/strong&gt;'}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;analog&lt;/strong&gt;：如果为True，则返回模拟滤波器，否则返回数字滤波器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;output：&lt;/strong&gt;默认“ba”,输出分子和分母&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：滤波器系数， a为分母，b为分子。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

b, a &lt;/span&gt;= signal.cheby2(4, 40, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, analog=&lt;span&gt;True)
w, h &lt;/span&gt;=&lt;span&gt; signal.freqs(b, a)
plt.semilogx(w, &lt;/span&gt;20 *&lt;span&gt; np.log10(abs(h)))
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chebyshev Type II frequency response (rs=40)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency [radians / second]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude [dB]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.margins(0, &lt;/span&gt;0.1&lt;span&gt;)
plt.grid(which&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axvline(&lt;/span&gt;100, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cutoff frequency&lt;/span&gt;
plt.axhline(-40, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rs&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519095408355-312434616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;椭圆模拟低通滤波器的频域特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190518215055238-1669507894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图  椭圆低通滤波器的幅度相应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特点：通带和阻带都等波动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;ellip&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;N, rp, rs, Wn, btype='low', analog=False, output='ba'&lt;big&gt;)&lt;/big&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;椭圆数字和模拟滤波器，设计N阶数字或模拟椭圆滤波器并返回滤波器系数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;N：&lt;/strong&gt;滤波器的阶数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rp：&lt;/strong&gt;通带中允许的最大纹波低于单位增益，以分贝为单位，正数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rs：&lt;/strong&gt;阻带所需最小衰减，以分贝为单位，正数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Wn：&lt;/strong&gt;对于数字滤波器：Wn应该归一化为(0,1)，Wn=截止频率/信号频率，（信号频率=采样率的一半，奈奎斯特采样定理）对于模拟滤波器：Wn是角频率，弧度/样本，rad/s&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;btype&lt;/strong&gt;：滤波器的类型{'&lt;strong&gt;lowpass&lt;/strong&gt;'，'&lt;strong&gt;highpass&lt;/strong&gt;'，'&lt;strong&gt;bandpass&lt;/strong&gt;'，'&lt;strong&gt;bandstop&lt;/strong&gt;'}&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;analog&lt;/strong&gt;：如果为True，则返回模拟滤波器，否则返回数字滤波器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;output：&lt;/strong&gt;默认“ba”,输出分子和分母&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;b,a：滤波器系数， a为分母，b为分子。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

b, a &lt;/span&gt;= signal.ellip(4, 5, 40, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;low&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, analog=&lt;span&gt;True)
w, h &lt;/span&gt;=&lt;span&gt; signal.freqs(b, a)
plt.semilogx(w, &lt;/span&gt;20 *&lt;span&gt; np.log10(abs(h)))
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Elliptic filter frequency response (rp=5, rs=40)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Frequency [radians / second]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude [dB]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.margins(0, &lt;/span&gt;0.1&lt;span&gt;)
plt.grid(which&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.axvline(&lt;/span&gt;100, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cutoff frequency&lt;/span&gt;
plt.axhline(-40, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rs&lt;/span&gt;
plt.axhline(-5, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rp&lt;/span&gt;
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519100903725-992905734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;插值方法进行下采样&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Volodymyr Kuleshov的论文中使用抗混叠滤波器对语音信号进行下采样，再通过三次样条插值把下采样信号上采样到相同的长度。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scipy.signal &lt;span&gt;import&lt;/span&gt;&lt;span&gt; decimate
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; librosa 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; interpolate

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; upsample(x_lr, r):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    上采样，每隔一步去掉语音波形的r个点，然后用三次样条插值的方法把去掉的点补回来，有机会可以画图看看
    :param x_lr:    音频数据
    :param r:       样条插值前个数
    :return:        样条插值后的音频信号
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    x_lr &lt;/span&gt;= x_lr.flatten()                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把x_lr数组折叠成一维的数组&lt;/span&gt;
    x_hr_len = len(x_lr) *&lt;span&gt; r
    i_lr &lt;/span&gt;= np.arange(x_hr_len, step=&lt;span&gt;r)
    i_hr &lt;/span&gt;=&lt;span&gt; np.arange(x_hr_len)

    f &lt;/span&gt;= interpolate.splrep(i_lr, x_lr)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 样条曲线插值系数&lt;/span&gt;
    x_sp = interpolate.splev(i_hr, f)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给定样条表示的节点和系数，返回在节点处的样条值&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x_sp


yt, wav_fs &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=&lt;span&gt;True)
x_lr &lt;/span&gt;= decimate(yt, 2)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 应用抗混叠滤波器后对信号进行下采样，获得低分辨率音频，下采样因子scale=2&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(yt))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(x_lr))

plt.subplot(&lt;/span&gt;2, 1, 1&lt;span&gt;)
plt.specgram(yt, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

x_lr &lt;/span&gt;= upsample(x_lr, 2)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上采样&lt;/span&gt;
plt.subplot(2, 1, 2&lt;span&gt;)
plt.specgram(x_lr, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519103708296-978933057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;重采样(&lt;/span&gt;&lt;span&gt;signal.resample)&lt;/span&gt;&lt;span&gt;——下采样&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;利用重新采样的方法对语音进行下采样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;tt&gt;scipy.signal.&lt;/tt&gt;&lt;tt&gt;resample&lt;/tt&gt;&lt;big&gt;(&lt;/big&gt;x, num, t=None, axis=0, window=None&lt;big&gt;)&lt;/big&gt;&lt;a href=&quot;http://github.com/scipy/scipy/blob/v0.18.1/scipy/signal/signaltools.py#L1788-L1903&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;沿给定轴使用傅立叶方法重新采样x到num个样本。因为使用傅立叶方法，所以假设信号是周期性的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;x：要重采样的数组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;num：重采样信号的样本数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;返回：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;resample_x：重新采样返回的数组&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; librosa 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

y, wav_fs &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=&lt;span&gt;True) 
f &lt;/span&gt;= signal.resample(y, len(y)//2&lt;span&gt;)
f &lt;/span&gt;=&lt;span&gt; signal.resample(f, len(y))

plt.subplot(&lt;/span&gt;2,1,1&lt;span&gt;)
plt.specgram(y, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;2,1,2&lt;span&gt;)
plt.specgram(f, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519110601158-567749319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;凌振华老师的下采样方法和上面的一样&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; librosa 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signal
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

y, wav_fs &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=&lt;span&gt;True) 
audio8k &lt;/span&gt;= librosa.core.resample(y, wav_fs, wav_fs/2)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下采样率 16000--&amp;gt;8000&lt;/span&gt;
audio8k = librosa.core.resample(audio8k, wav_fs/2, wav_fs)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上采样率 8000--&amp;gt;16000，并不恢复高频部分&lt;/span&gt;
&lt;span&gt;
plt.subplot(&lt;/span&gt;2,1,1&lt;span&gt;)
plt.specgram(y, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;2,1,2&lt;span&gt;)
plt.specgram(audio8k, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190519110946264-1089735823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;librosa.load下采样&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;用librosa.load想下采样，再不恢复频率的情况下上采样。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; librosa 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

y_16k, fs_16k &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=&lt;span&gt;True) 
y_8k, fs_8k &lt;/span&gt;= librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./48k/p225_001.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=8000, mono=&lt;span&gt;True) 
librosa.output.write_wav(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./8k_sample.wav&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y_8k, sr=8000)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把下采样的写好&lt;/span&gt;
y_8k, fs_8k = librosa.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./8k_sample.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sr=16000, mono=True)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 失去的就补不回来了&lt;/span&gt;
&lt;span&gt;

plt.subplot(&lt;/span&gt;2, 1, 1&lt;span&gt;)
plt.specgram(y_16k, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;16k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

plt.subplot(&lt;/span&gt;2, 1, 2&lt;span&gt;)
plt.specgram(y_8k, Fs&lt;/span&gt;=16000, scale_by_freq=True, sides=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201905/1433301-20190529205251036-1322133884.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av26706434/?p=51&amp;amp;t=91&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;北京交通大学（数字信号处理）陈后金教授&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/signal.html&quot; target=&quot;_blank&quot;&gt;信号处理（&lt;tt class=&quot;xref py py-mod docutils literal&quot;&gt;scipy.signal&lt;/tt&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/signal.html&quot; target=&quot;_blank&quot;&gt;）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.butter.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;scipy.signal.butter&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.freqs.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;scipy.signal.freqs&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.freqz.html#scipy.signal.freqz&quot; target=&quot;_blank&quot;&gt;scipy.signal.freqz&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.cheby1.html#scipy.signal.cheby1&quot; target=&quot;_blank&quot;&gt;scipy.signal.cheby1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.ellip.html#scipy.signal.ellip&quot; target=&quot;_blank&quot;&gt;scipy.signal.ellip&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.decimate.html#scipy.signal.decimate&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;scipy.signal.decimate&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.signal.resample.html#scipy.signal.resample&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;scipy.signal.resample&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 29 May 2019 14:14:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>滤波器的技术指标 $\omega _p$：通带截止频率 $\omega _s$：阻带截止频率 $\delta_p$：通带波动 $\delta_s$：阻带波动 衰减单位是db 巴特沃斯滤波器 butte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/10886622.html</dc:identifier>
</item>
<item>
<title>SpringBoot源码篇（一）：深度分析SpringBoot如何省去web.xml - 超级小小黑</title>
<link>http://www.cnblogs.com/hello-shf/p/10926271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-shf/p/10926271.html</guid>
<description>&lt;p&gt;　　从本博文开始，正式开启Spring及SpringBoot源码分析之旅。这可能是一个漫长的过程，因为本人之前阅读源码都是很片面的，对Spring源码没有一个系统的认识。从本文开始我会持续更新，争取在系列文章更完之后，也能让自己对Spring源码有一个系统的认识。&lt;/p&gt;
&lt;p&gt;　　在此立下一个flag，希望自己能够坚持下去。如果有幸让您能从系列文章中学到丁点的知识，还请评论，关注，或推荐。如有错误还请在评论区指出，一起讨论共同成长。&lt;/p&gt;

&lt;p&gt; 　　随着使用 Spring 进行开发的个人和企业越来越多，Spring 也慢慢从一个单一简洁的小框架变成一个大而全的开源软件，Spring 的边界不断的进行扩充，到了后来 Spring 几乎可以做任何事情了，市面上主流的开源软件、中间件都有 Spring 对应组件支持，人们在享用 Spring 的这种便利之后，也遇到了一些问题。Spring 每集成一个开源软件，就需要增加一些基础配置，慢慢的随着人们开发的项目越来越庞大，往往需要集成很多开源软件，因此后期使用 Spirng 开发大型项目需要引入很多配置文件，太多的配置非常难以理解，并容易配置出错，到了后来人们甚至称 Spring 为配置地狱。&lt;/p&gt;
&lt;p&gt;　　Spring 似乎也意识到了这些问题，急需有这么一套软件可以解决这些问题，这个时候微服务的概念也慢慢兴起，快速开发微小独立的应用变得更为急迫，Spring 刚好处在这么一个交叉点上，于 2013 年初开始的 Spring Boot 项目的研发，2014年4月，Spring Boot 1.0.0 发布。&lt;/p&gt;
&lt;p&gt;　　Spring Boot 诞生之初，就受到开源社区的持续关注，陆续有一些个人和企业尝试着使用了 Spring Boot，并迅速喜欢上了这款开源软件。直到2016年，在国内 Spring Boot 才被正真使用了起来，期间很多研究 Spring Boot 的开发者在网上写了大量关于 Spring Boot 的文章，同时有一些公司在企业内部进行了小规模的使用，并将使用经验分享了出来。从2016年到2018年，使用 Spring Boot 的企业和个人开发者越来越多。2018年SpringBoot2.0的发布，更是将SpringBoot的热度推向了一个前所未有的高度。&lt;/p&gt;

&lt;h2&gt;　1、Spring的发展历史&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201905/1635748-20190527221632689-854660421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）spring1.0时代&lt;/p&gt;
&lt;p&gt; 　　Spring的诞生大大促进了JAVA的发展。也降低了企业java应用开发的技术和时间成本。&lt;/p&gt;
&lt;div readability=&quot;18.5&quot;&gt;
&lt;div readability=&quot;32&quot;&gt;
&lt;p&gt;（2）spring2.0时代&lt;br/&gt;　　对spring1.0在繁杂的xml配置文件上做了一定的优化,让配置看起来越来越简单,但是并没语完全解决xml冗余的问题。&lt;/p&gt;
&lt;p&gt;（3）spring3.0时代&lt;br/&gt;　　可以使用spring提供的java注解来取代曾经xml配置上的问题,似乎我们曾经忘记了发生什么,spring变得前所未有的简单。&lt;strong&gt;Spring3.0奠定了SpringBoot自动装配的基础。&lt;/strong&gt;3.0提供的java注解使得我们可以通过注解的方式来配置spring容器。省去了使用类似于spring-context.xml的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;同年，&lt;strong&gt;Servlet3.0规范的诞生为SpringBoot彻底去掉xml（web.xml）奠定了了理论基础（对于servlet3.0来说，web.xml不再是必需品。但是Servlet3.0规范还是建议保留web.xml）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（4）spring4.0时代&lt;br/&gt;　　4.0 时代我们甚至连xml配置文件都不需要了完全使用java源码级别的配置与spring提供的注解就能快速的开发spring应用程序,但仍然无法改变Java Web应用程序的运行模式,我们仍然需要将war部署到Web Server 上，才能对外提供服务。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.0开始全面支持java8.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　同年，&lt;strong&gt;Servlet3.1规范诞生（tomcat8开始采用Servlet3.1规范）。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt; 　2、Servlet3.0奠定了SpringBoot 零xml配置的基础&lt;/h2&gt;
&lt;p&gt; 　　分析SpringBoot如何省去web.xml还得从Servlet3.0的规范说起。Servlet3.0规范规定如下（摘自穆茂强 张开涛翻译的Servlet3.1规范，3.0和3.1在这一点上只有一些细节上的变换，在此不做过多介绍）：&lt;/p&gt;
&lt;p&gt;　　ServletContainerInitializer类通过jar services API查找。对于每一个应用，应用启动时，由容器创建一个ServletContainerInitializer 实例。 框架提供的ServletContainerInitializer实现必须绑定在 jar 包 的META-INF/services 目录中的一个叫做 javax.servlet.ServletContainerInitializer 的文件，根据 jar services API，指定 ServletContainerInitializer 的实现。除 ServletContainerInitializer 外，我们还有一个注解@HandlesTypes。在 ServletContainerInitializer 实现上的@HandlesTypes注解用于表示感兴趣的一些类，它们可能指定了 HandlesTypes 的 value 中的注解（类型、方法或自动级别的注解），或者是其类型的超类继承/实现了这些类之一。无论是否设置了 metadata-complete，@HandlesTypes 注解将应用。当检测一个应用的类看是否它们匹配 ServletContainerInitializer 的 HandlesTypes 指定的条件时，如果应用的一个或多个可选的 JAR 包缺失，容器可能遇到类装载问题。由于容器不能决定是否这些类型的类装载失败将阻止应用正常工作，它必须忽略它们，同时也提供一个将记录它们的配置选项。如果ServletContainerInitializer 实现没有@HandlesTypes 注解，或如果没有匹配任何指定的@HandlesType，那么它会为每个应用使用 null 值的集合调用一次。这将允许 initializer 基于应用中可用的资源决定是否需要初始化 Servlet/Filter。在任何 Servlet Listener 的事件被触发之前，当应用正在启动时，ServletContainerInitializer 的 onStartup 方法将被调用。ServletContainerInitializer’s 的onStartup 得到一个类的 Set，其或者继承/实现 initializer 表示感兴趣的类，或者它是使用指定在@HandlesTypes 注解中的任意类注解的。&lt;/p&gt;
&lt;p&gt;　　这个规范如何理解呢？&lt;/p&gt;
&lt;p&gt;　　简单来说，当实现了Servlet3.0规范的容器（比如tomcat7及以上版本）启动时，通过SPI扩展机制自动扫描所有已添加的jar包下的META-INF/services/javax.servlet.ServletContainerInitializer中指定的全路径的类，并实例化该类，然后回调META-INF/services/javax.servlet.ServletContainerInitializer文件中指定的ServletContainerInitializer的实现类的onStartup方法。 如果该类存在@HandlesTypes注解，并且在@HandlesTypes注解中指定了我们感兴趣的类，所有实现了这个类的onStartup方法将会被调用。&lt;/p&gt;
&lt;p&gt;　　再直白一点来说，存在web.xml的时候，Servlet容器会根据web.xml中的配置初始化我们的jar包（也可以说web.xml是我们的jar包和Servlet联系的中介）。而在Servlet3.0容器初始化时会调用jar包META-INF/services/javax.servlet.ServletContainerInitializer中指定的类的实现（javax.servlet.ServletContainerInitializer中的实现替代了web.xml的作用，而所谓的在@HandlesTypes注解中指定的感兴趣的类，可以理解为具体实现了web.xml的功能，当然也可以有其他的用途）。&lt;/p&gt;

&lt;h3&gt;1、META-INF/services/javax.servlet.ServletContainerInitializer&lt;/h3&gt;
&lt;p&gt;上一节中我们介绍了SpringBoot诞生的技术基础和Servlet3.0规范。这一章节，我们通过Spring源码来分析，Spring是如何实现省去web.xml的。&lt;/p&gt;
&lt;p&gt;如下图所示，在org.springframework:spring-web工程下，META-INF/services/javax.servlet.ServletContainerInitializer文件中，指定了将会被Servlet容器启动时回调的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635748/201905/1635748-20190528214050392-481345805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、SpringServletContainerInitializer &lt;/h3&gt;
&lt;p&gt;查看 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringServletContainerInitializer&lt;/span&gt;  类的源码，发现确实如如上文所说，实现了 &lt;span class=&quot;cnblogs_code&quot;&gt;ServletContainerInitializer&lt;/span&gt;  ，并且也在 &lt;span class=&quot;cnblogs_code&quot;&gt;@HandlesTypes&lt;/span&gt; 注解中指定了，感兴趣的类 &lt;span class=&quot;cnblogs_code&quot;&gt;WebApplicationInitializer&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;可以看到onStartup方法上有一大段注释，翻译一下大致意思：&lt;/p&gt;
&lt;p&gt;servlet 3.0+容器启动时将自动扫描类路径以查找实现Spring的webapplicationinitializer接口的所有实现，将其放进一个Set集合中，提供给 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringServletContainerInitializer&lt;/span&gt;  onStartup的第一个参数（翻译结束）。&lt;/p&gt;
&lt;p&gt;在Servlet容器初始化的时候会调用 &lt;span class=&quot;cnblogs_code&quot;&gt;SpringServletContainerInitializer&lt;/span&gt;  的onStartup方法，继续看onStartup方法的代码逻辑，在该onStartup方法中利用逐个调用webapplicationinitializer所有实现类中的onStartup方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @HandlesTypes(WebApplicationInitializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpringServletContainerInitializer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletContainerInitializer {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * Delegate the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ServletContext} to any {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationInitializer}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * implementations present on the application classpath.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Because this class declares @{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HandlesTypes(WebApplicationInitializer.class)},
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * Servlet 3.0+ containers will automatically scan the classpath for implementations
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * of Spring's {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} interface and provide the set of all
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * such types to the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; webAppInitializerClasses} parameter of this method.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;If no {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} implementations are found on the classpath,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * this method is effectively a no-op. An INFO-level log message will be issued notifying
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * the user that the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ServletContainerInitializer} has indeed been invoked but that
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * no {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} implementations were found.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Assuming that one or more {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} types are detected,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * they will be instantiated (and &amp;lt;em&amp;gt;sorted&amp;lt;/em&amp;gt; if the @{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * org.springframework.core.annotation.Order @Order} annotation is present or
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.core.Ordered Ordered} interface has been
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * implemented). Then the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationInitializer#onStartup(ServletContext)}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * method will be invoked on each instance, delegating the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ServletContext} such
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * that each instance may register and configure servlets such as Spring's
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DispatcherServlet}, listeners such as Spring's {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ContextLoaderListener},
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * or any other Servlet API componentry such as filters.
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; webAppInitializerClasses all implementations of
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} found on the application classpath
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; servletContext the servlet context to be initialized
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; WebApplicationInitializer#onStartup(ServletContext)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; AnnotationAwareOrderComparator
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onStartup(@Nullable Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; webAppInitializerClasses, ServletContext servletContext)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         List&amp;lt;WebApplicationInitializer&amp;gt; initializers = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (webAppInitializerClasses != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; waiClass : webAppInitializerClasses) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Be defensive: Some servlet containers provide us with invalid classes,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no matter what @HandlesTypes says...&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!waiClass.isInterface() &amp;amp;&amp;amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;amp;&amp;amp;
&lt;span&gt;41&lt;/span&gt;                         WebApplicationInitializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(waiClass)) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                        initializers.add((WebApplicationInitializer)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                                ReflectionUtils.accessibleConstructor(waiClass).newInstance());
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;&lt;span&gt;, ex);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (initializers.isEmpty()) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;         servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        AnnotationAwareOrderComparator.sort(initializers);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (WebApplicationInitializer initializer : initializers) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            initializer.onStartup(servletContext);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3、WebApplicationInitializer &lt;/h3&gt;
&lt;p&gt;查看 &lt;span class=&quot;cnblogs_code&quot;&gt;WebApplicationInitializer&lt;/span&gt;  接口，这个接口也就是上文中所说的Servlet3.0规范中 &lt;span class=&quot;cnblogs_code&quot;&gt;@HandlesTypes(WebApplicationInitializer.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt; 注解中所指定的感兴趣的类。&lt;/p&gt;
&lt;p&gt;截取一段很重要的注释。这段注释告诉我们实现该接口的类主要需要实现的功能就是web.xml中配置文件中配置的内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * &amp;lt;servlet&amp;gt;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *   &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *   &amp;lt;servlet-class&amp;gt;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *     org.springframework.web.servlet.DispatcherServlet
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *   &amp;lt;/servlet-class&amp;gt;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *   &amp;lt;init-param&amp;gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; *     &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; *     &amp;lt;param-value&amp;gt;/WEB-INF/spring/dispatcher-config.xml&amp;lt;/param-value&amp;gt;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *   &amp;lt;/init-param&amp;gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; *   &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &amp;lt;/servlet&amp;gt;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * &amp;lt;servlet-mapping&amp;gt;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *   &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *   &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * &amp;lt;/servlet-mapping&amp;gt;}&amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; WebApplicationInitializer {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; onStartup(ServletContext servletContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、SpringBoot的 &lt;span class=&quot;cnblogs_code&quot;&gt;WebApplicationInitializer&lt;/span&gt; 的实现&lt;/h3&gt;
&lt;p&gt;查看SpringBoot  &lt;span class=&quot;cnblogs_code&quot;&gt;SpringBootServletInitializer&lt;/span&gt; 源码，该类在spring-boot依赖包中。&lt;/p&gt;
&lt;p&gt;仔细看下面的标蓝的代码。不难发现这正是Servlet容器（tomcat）如何找到SpringBoot并启动它的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.support;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.Filter;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.Servlet;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletContext;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletContextEvent;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletException;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.Log;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.logging.LogFactory;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.builder.ParentContextApplicationContextInitializer;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.builder.SpringApplicationBuilder;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.servlet.ServletContextInitializer;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.annotation.AnnotationUtils;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.Assert;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.WebApplicationInitializer;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.ContextLoaderListener;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.support.StandardServletEnvironment;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt; * An opinionated {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationInitializer} to run a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringApplication}
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt; * from a traditional WAR deployment. Binds {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Servlet}, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Filter} and
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ServletContextInitializer} beans from the application context to the servlet
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt; * container.
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt; * To configure the application either override the
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #configure(SpringApplicationBuilder)} method (calling
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder#sources(Object...)}) or make the initializer itself a
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Configuration}. If you are using {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringBootServletInitializer} in
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt; * combination with other {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationInitializer WebApplicationInitializers} you
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt; * might also want to add an {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Ordered} annotation to configure a specific startup
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt; * order.
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt; * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt; * Note that a WebApplicationInitializer is only needed if you are building a war file and
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt; * deploying it. If you prefer to run an embedded container then you won't need this at
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt; * all.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Dave Syer
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Phillip Webb
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Andy Wilkinson
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.4.0
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #configure(SpringApplicationBuilder)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpringBootServletInitializer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebApplicationInitializer {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; Log logger; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't initialize early&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; registerErrorPageFilter = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;     * Set if the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ErrorPageFilter} should be registered. Set to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false} if
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;     * error page mappings should be handled via the Servlet container and not Spring
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;     * Boot.
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registerErrorPageFilter if the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ErrorPageFilter} should be registered.
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRegisterErrorPageFilter(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; registerErrorPageFilter) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.registerErrorPageFilter =&lt;span&gt; registerErrorPageFilter;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onStartup(ServletContext servletContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Logger initialization is deferred in case a ordered
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LogServletContextInitializer is being used&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.logger =&lt;span&gt; LogFactory.getLog(getClass());
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;WebApplicationContext rootAppContext =&lt;span&gt; createRootApplicationContext(
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                servletContext);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (rootAppContext != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             servletContext.addListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextLoaderListener(rootAppContext) {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent event) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no-op because the application context is already initialized&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.logger.debug(&quot;No ContextLoaderListener registered, as &quot;
&lt;span&gt; 83&lt;/span&gt;                     + &quot;createRootApplicationContext() did not &quot;
&lt;span&gt; 84&lt;/span&gt;                     + &quot;return an application context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WebApplicationContext createRootApplicationContext(
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            ServletContext servletContext) {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         SpringApplicationBuilder builder =&lt;span&gt; createSpringApplicationBuilder();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         StandardServletEnvironment environment = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardServletEnvironment();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         environment.initPropertySources(servletContext, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        builder.environment(environment);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;        builder.main(getClass());
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         ApplicationContext parent =&lt;span&gt; getExistingRootWebApplicationContext(servletContext);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.logger.info(&quot;Root context already created (using as parent).&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            servletContext.setAttribute(
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             builder.initializers(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParentContextApplicationContextInitializer(parent));
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        builder.initializers(
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletContextApplicationContextInitializer(servletContext));
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         builder =&lt;span&gt; configure(builder);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;SpringApplication application =&lt;span&gt; builder.build();
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (application.getSources().isEmpty() &amp;amp;&amp;amp;&lt;span&gt; AnnotationUtils
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                 .findAnnotation(getClass(), Configuration.&lt;span&gt;class&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            application.getSources().add(getClass());
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         Assert.state(!&lt;span&gt;application.getSources().isEmpty(),
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &quot;No SpringApplication sources have been defined. Either override the &quot;
&lt;span&gt;113&lt;/span&gt;                         + &quot;configure method or add an @Configuration annotation&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure error pages are registered&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerErrorPageFilter) {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             application.getSources().add(ErrorPageFilterConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; run(application);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;     * Returns the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder} that is used to configure and create
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;     * the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringApplication}. The default implementation returns a new
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder} in its default state.
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder}.
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.3.0
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder createSpringApplicationBuilder() {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder();
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt; &lt;span&gt;     * Called to run a fully configured {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SpringApplication}.
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; application the application to run
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; WebApplicationContext}
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WebApplicationContext run(SpringApplication application) {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (WebApplicationContext) application.run();
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ApplicationContext getExistingRootWebApplicationContext(
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            ServletContext servletContext) {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         Object context =&lt;span&gt; servletContext.getAttribute(
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;                WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ApplicationContext) {
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (ApplicationContext) context;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;     * Configure the application. Normally all you would need to do is to add sources
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;     * (e.g. config classes) because other settings have sensible defaults. You might
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;     * choose (for instance) to add default command line arguments, or set an active
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;     * Spring profile.
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; builder a builder for the application context
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the application builder
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 5、查看Spring官方文档&lt;/h3&gt;
&lt;p&gt; 查看Spring 5.0.14官方文档：&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.14.RELEASE/spring-framework-reference/web.html#spring-web&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring/docs/5.0.14.RELEASE/spring-framework-reference/web.html#spring-web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档中给出在传统的springMVC中在web.xml中的配置内容&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 初始化Spring上下文 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定Spring的配置文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/WEB-INF/app-context.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 初始化DispatcherServlet &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;app&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;app&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/app/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文档中提供了一个如何使用基于java代码的方式配置Servlet容器example&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyWebApplicationInitializer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebApplicationInitializer {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStartup(ServletContext servletCxt) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load Spring web application configuration
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过注解的方式初始化Spring的上下文&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         AnnotationConfigWebApplicationContext ac = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnotationConfigWebApplicationContext();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册spring的配置类（替代传统项目中xml的configuration）&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         ac.register(AppConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        ac.refresh();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create and register the DispatcherServlet
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于java代码的方式初始化DispatcherServlet&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         DispatcherServlet servlet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DispatcherServlet(ac);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;&lt;span&gt;, servlet);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         registration.setLoadOnStartup(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         registration.addMapping(&quot;/app/*&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 对比官方文档给出的example，不难发现上面这段java代码就是SpringBoot省去web.xml的具体实现方法。上面  &lt;span class=&quot;cnblogs_code&quot;&gt;MyWebApplicationInitializer&lt;/span&gt;   正是 &lt;span class=&quot;cnblogs_code&quot;&gt;WebApplicationInitializer （ @HandlesTypes(WebApplicationInitializer.&lt;span&gt;class&lt;/span&gt;) ）&lt;/span&gt;  接口的实现。&lt;/p&gt;
&lt;p&gt;官方文档提供的 &lt;span class=&quot;cnblogs_code&quot;&gt;MyWebApplicationInitializer&lt;/span&gt;  类正是SpringBoot不依赖与web.xml的关键代码。&lt;/p&gt;
&lt;p&gt;SpringBoot中具体实现web.xml中配置的代码没有官方文档中的example这么简单，SpringBoot中具体初始化 &lt;span class=&quot;cnblogs_code&quot;&gt;DispatcherServlet&lt;/span&gt; 的类是 &lt;span class=&quot;cnblogs_code&quot;&gt;DispatcherServletAutoConfiguration&lt;/span&gt; 。感兴趣的话可以断点调试一下。&lt;/p&gt;


&lt;p&gt;以上章节介绍了SpringBoot诞生的历史背景，每一个新技术的诞生，都是场景驱动的。然后介绍了SpringBoot能做到不依赖web.xml的技术条件。最后通过源码分析了SpringBoot中具体的实现。&lt;/p&gt;
&lt;p&gt;下一篇博文将利用本文讲到的知识基于Spring springframework内置tomcat简单模拟SpringBoot的基本功能。简单说就是实现一个简易版的SpringBoot。&lt;/p&gt;

&lt;p&gt;本文是笔者查阅大量资料，阅读大量Spring源码总结出来的，原创不易，转载请注明出处。&lt;/p&gt;
&lt;p&gt;如有错误请在评论区留言指正。&lt;/p&gt;
&lt;p&gt; 参考文献：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/adingyb/article/details/80707471&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/c6f4df3d720c&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 14:09:00 +0000</pubDate>
<dc:creator>超级小小黑</dc:creator>
<og:description>一、前言 从本博文开始，正式开启Spring及SpringBoot源码分析之旅。这可能是一个漫长的过程，因为本人之前阅读源码都是很片面的，对Spring源码没有一个系统的认识。从本文开始我会持续更新，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hello-shf/p/10926271.html</dc:identifier>
</item>
<item>
<title>GraphQL实战经验和性能问题的解决方案 - ChaosYang1987</title>
<link>http://www.cnblogs.com/chaosyang/p/graphql-practice-and-resolve-performance-issue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaosyang/p/graphql-practice-and-resolve-performance-issue.html</guid>
<description>&lt;p&gt;在现在的公司使用GraphQL有一段时间了。&lt;/p&gt;
&lt;p&gt;现公司从创立之后的很长一段时间内是纯PHP的技术栈，前端、后端都在PHP代码中糅合在一起。新功能越加越多，页面越来越复杂之后，那些混在在PHP代码中的HTML代码越来越不可维护，于是终于有公司里的程序员看不下去，开始了技术革命，将PHP代码抽象成一个个微服务提供API，前端则采用Node+React，解放了前端工程师的生产力，使得新界面的开发越来越顺利，前端程序员也越发不用关心后端的实现了。&lt;/p&gt;
&lt;p&gt;故事说到这里听起来皆大欢喜，然而时间长了，新的问题出现了——我们的微服务需要的调整越来越多。PM永远想要尝试新的点子，我们的新需求仍然是更加“花里胡哨”的页面，原先一个页面调用的微服务，在新的需求下需要新的数据，于是和原来比，要做的工作反而多了：在纯PHP的框架下，PHP后端代码和HTML前端代码都在同一个文件中，新需求也可能需要改一个（套）文件；然而在新的架构下，我们即需要调整微服务（PHP文件），又需要去调整前端代码（JS文件），还需要更改两者之间的协议（Apache Thrift），并且还需要严格的遵守Release的顺序和向前兼容的问题。&lt;/p&gt;
&lt;p&gt;GraphQL就是在这样的背景下被引入到我们的技术栈之中，关于GraphQL的介绍网上有很多博文，在这里就不展开描述，个人觉得对于我们的产品开发中最有利的两点：&lt;/p&gt;
&lt;p&gt;1. 降低了后端API的调整频度。所谓的新“需求”，有很多时候其实就是将数据转移，比如将本来在A页面展示的数据挪到B页面，或者将A和B页面合并成一个页面，抑或是A页面拆成B和C两个页面。在GraphQL引入之前，这样的展示层面的增删改都必将导致后端API的变化，但在GraphQL引入之后，前端程序员只需在Node端调整查询语句，就可以自己定制出自己需要的API。&lt;/p&gt;
&lt;p&gt;2. 增加了前端的灵活性和可调试性。前端可以根据需求，理论上可以将整个数据库的数据在一个页面上实现任意的组合，并且由于有graphiql等强大的工具，可以边实现新的页面，边调整自己的查询语言，在出现问题时也可以通过直接执行查询语句来看是否后端返回的数据有问题。&lt;/p&gt;
&lt;p&gt;比如有一款社交网络的应用，我们后端有一个getUserByUserId的API，可以查询一个用户的信息（ID，用户名，朋友们的ID），如果我们要做一个页面来显示一个用户的三度好友树，如果不使用GraphQL的解决方案，需要创建一个新的API，在API中先通过getUserByUserId去查询一个用户的信息和所有好友ID，再通过getUserByUserId去获得每个朋友的信息和好友ID，如此循环最后返回。&lt;/p&gt;
&lt;p&gt;而如果使用GraphQL的解决方案，我们只需要定义用户和API的Schema：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
type User&lt;span&gt; {
    userId: Int&lt;span&gt;
    userName: String
    friends: [User]&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
extend type Query {&lt;br/&gt;getUserByUserId(userId: Int): User //根据用户Id查询单个用户&lt;br/&gt;getUsersByUserIds(userIds: [Int]): [User] //根据多个用户Id查询多个用户
&lt;/pre&gt;
&lt;pre&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而对应的Resolver逻辑为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
export default&lt;span&gt; {
    Query: {
        getUserByUserId: async (root, args, context) =&amp;gt;&lt;span&gt; await context.service.getUserByUserId(args.userId).then(response =&amp;gt; response.user),
        getUsersByUserIds: async (root, args, context) =&amp;gt;&lt;span&gt; await context.service.getUsersByUserIds(args.userIds).then(response =&amp;gt; response.users),
    }

    User: {
        userId: (root) =&amp;gt;&lt;span&gt; root.userId,
        userName: (root) =&amp;gt;&lt;span&gt; root.userName,
        friends: (root, args, context) =&amp;gt;&lt;span&gt; await context.service.getUsersByUserIds(root.friendIds).then(response =&amp;gt; response.users),
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而getUserByUserId的返回格式为以下的格式，getUserByUserIds的话则是以下格式的列表形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
context.service.getUserByUserId(10001&lt;span&gt;)

{
    &lt;/span&gt;&quot;userId&quot;: 10001&lt;span&gt;,
    &lt;/span&gt;&quot;userName&quot;: &quot;Sample User Name&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;friendIds&quot;: [ 10002, 10003, 10004&lt;span&gt; ] 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们提供了两个API，一个是单数形式getUserByUserId，一个是复数形式getUsersByUsersId，实际实现中单数形式的API可以坍缩成复数形式API只有一个参数的调用，所以可以继续简化其实现。为什么不只创建单数形式的API呢？这在之后的实战问题中会描述。&lt;/p&gt;
&lt;p&gt;这样，我们如果要实现上面所描述的三度好友页面，只需要定义两个API——getUserByUserId和getUsersByUserIds和下面的一条GraphQL查询语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
query getUserByUserId ($userId: Int&lt;span&gt;) {
    user&lt;span&gt;: getUserByUserId(userId: $userId) {
        userId
        userName
        friends { //&lt;span&gt;朋友
            userId
            userName
            friends { //&lt;span&gt;朋友的朋友
                userId
                userName&lt;span&gt;
            }
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个查询会返回给我们这样的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10001&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;friends&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
         {
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10002&lt;/span&gt;&lt;span&gt;,
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;friends&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                   {
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10003&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                   }， 
                    {
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10004&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                   },
                   ....
              ]
         },
        {
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10005&lt;/span&gt;&lt;span&gt;,
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;friends&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                   {
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10006&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                   }， 
                    {
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10007&lt;/span&gt;&lt;span&gt;,
                       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sample User Name 7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                   },
                   ....
              ]
         },
         ....
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们只用了一个API（单复数共用一个实现的话）就组合出了这样的一个复合API，如果将来想要实现四度好友，五度好友，则可以在以上面的查询基础上继续嵌套，仍旧不需要增加后台的API代码。&lt;/p&gt;
&lt;p&gt;这个示例只是最简单的示例，理论上如果你的服务的所有实体数据之间都有联结关系，那么只需要你实现每个实体数据根据ID的自查询API和实体之间的联结查询API，那么用GraphQL就可以将所有的实体连接成一张图（Graph），你可以通过GraphQL查询语句来构建这张图中的任何子图。&lt;/p&gt;
&lt;p&gt;-------------------------- 我是和谐的分割线 --------------------------&lt;/p&gt;
&lt;p&gt;正如每颗硬币都有正反面，在实际使用GraphQL的时候我们也遇到了很多问题，特别是性能上的问题。拿以上这个三度好友的GraphQL查询来举例，它有哪些问题呢？&lt;/p&gt;
&lt;p&gt;1. 过度查询（Overfetching）&lt;/p&gt;
&lt;p&gt;在一个页面中我们可能只会用一个实体的某几个属性，那么我们在后端的查询最好只需要选取需要的字段。而我们在实现GraphQL和后端服务的桥接时，不论GraphQL的查询语句请求了几个字段，后端服务永远会查询实体的所有字段并返回，而GraphQL的引擎则会根据查询语句只提取需要的字段作为返回结果。但是在这个过程中，不必要的字段占用了数据库的传输以及前后端网络传输的带宽。&lt;/p&gt;
&lt;p&gt;比如上面的例子，如果我们的页面只要求获得用户ID并不要求返回用户名，那么我们的query可以改成以下的模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;query getUserByUserId ($userId: Int) {
    user: getUserByUserId(userId: $userId) {
        userId
        friends { 
            userId
            friends {
                userId
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表面上来看我们确实没有去查询userName，但实际上由于我们的API会返回所有的userId, userName, friendIds，所以这个查询和前面那个例子的查询开销上是一样的。&lt;/p&gt;
&lt;p&gt;解决方案：针对整个问题，我们在GraphQL的Resolver层面做了一些改造，在查询被执行的时候从GraphQL引擎获得当前的查询语句请求的字段，并将字段作为隐藏参数传递给后端服务，后端服务根据传进来的字段进行数据库查询的优化。解决方案的伪代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {

    User: {
        userId: (root) &lt;/span&gt;=&amp;gt;&lt;span&gt; root.userId,
        userName: (root) &lt;/span&gt;=&amp;gt;&lt;span&gt; root.userName,
        friends: (root, args, context, info) &lt;/span&gt;=&amp;gt;&lt;span&gt; await context.service.getUsersByUserIds(root.friendIds, info.fields).then(response =&amp;gt; response.users), // 传入GraphQL查询中的field
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而服务器端的API返回值也随着调用传参也变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
context.service.getUserByUserId(10001，[&quot;userId&quot;&lt;span&gt;])

{
    &lt;/span&gt;&quot;userId&quot;: 10001&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. 重复查询（Repeated Query）&lt;/p&gt;
&lt;p&gt;一个较为复杂的页面中可能一个实体在页面的不同位置都有展现，比如上面那个查询，用户的一度好友们的二度好友们，很有可能互相之间也是好友，那么我们的两层嵌套查询中，有部分的查询实际上是可以避免的。&lt;/p&gt;
&lt;p&gt;解决方案：这一点暂时没有很完美的解决方案，我们目前可以做到的是在上层Query中已经查询到的数据，如果下层Query也要查询，那么通过缓存的方式，使的下层的Query不去访问API，但是如果本身是不同的Query，暂时没有办法做跨请求的缓存。缓存实现的伪代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {

    User: {
        userId: (root) &lt;/span&gt;=&amp;gt;&lt;span&gt; root.userId,
        userName: (root) &lt;/span&gt;=&amp;gt;&lt;span&gt; root.userName,
        friends: (root, args, context, info) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                let cachedUsers &lt;/span&gt;= root.friendIds.map(id =&amp;gt; context.cache.users[id]).filter(x =&amp;gt; !!&lt;span&gt;x); //找出所有缓存的用户
                let idsToFetch &lt;/span&gt;= root.friendIds.filter(id =&amp;gt; !&lt;span&gt;context.cache.users[id]); //取得未缓存的用户ID
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context.service.getUsersByUserIds(idsToFetch, info.fields).then(response =&amp;gt;&lt;span&gt; { //查询未缓存的用户信息
                       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let user &lt;span&gt;in&lt;/span&gt;&lt;span&gt; response.users) {
                            context.cache.users[user.id]  &lt;/span&gt;=&lt;span&gt; user;//将结果存储到缓存中
                       }
                       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.users.concat(cachedUsers)://合并缓存结果和返回结果
                });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. N+1查询 （N+1 Query）&lt;/p&gt;
&lt;p&gt;N+1查询是GraphQL使用中最可能也是最经常遇到的性能问题，当出现查询嵌套并且在内部嵌套的数据是列表类型时最容易出现这样的性能问题。还是以上面的查询为例，如果系统中每个用户平均有10个好友，那么以上的三度好友查询一共进行了多少次后端API的调用？答案是1 + 1 + 10 = 12次, 为什么是12次呢？&lt;/p&gt;
&lt;p&gt;1. 第一次调用getUserByUserId， 获得了目标用户的ID和用户名信息以及平均10个朋友的ID&lt;/p&gt;
&lt;p&gt;2. 第二次调用getUsersByUserIds，获得了10个目标的用户民信息已经他们10*10个朋友的ID&lt;/p&gt;
&lt;p&gt;3. 对于2中获得的10批朋友ID，我们需要分别调用10次getUsersByUserIds，去获得者100个朋友的用户名信息&lt;/p&gt;
&lt;p&gt;第二次调用获得了N批朋友ID，每批朋友信息的查询带来了N次的额外查询，所以我们将这种Pattern称为N+1查询。这里我们可以看出为什么我们一开始在定义API的时候一定要定义复数形式的API，这样一开始我们就考虑到了会有批（Batch）查询的的需求，否则的话如果只有单查询的接口，我们则需要1 + 10 + 10 * 10 = 111次API查询。但是12次查询也是非常大的消耗，并且收到前段和后端通信的并发限制，这最后的10次通信可能需要分批进行，那么最终会导致服务器端的返回速度收到了极大的限制。&lt;/p&gt;
&lt;p&gt;解决方案：N+1 Query的问题没有一个非常好的解决方案，我们目前的做法是在GraphQL的Resolver逻辑中插入了自己的逻辑，当我们遇到这种多层嵌套查询的时候，在第N层去尝试等待其他的resolver，拿上面的例子，我们的第二次调用后，获得了10批朋友的ID，那么在第三层的结构进行resolve逻辑的时候，我们会收集所有需要调用getUsersByUserIds的参数，将其合并成一次调用，这次调用返回的Promise在全局共享，同时在运行时将每个resolver的逻辑替换成合并后调用的结果中找出自己需要的结果并返回。为了更好的帮助大家理解，可以参照下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1694706/201905/1694706-20190529214922687-597159346.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;GraphQL为前后端的API提供了一种便利的解决方案，但同时收到自身设计的限制，会有各种各样的问题需要针对具体的应用场景去优化，在使用之前不妨先问问自己：我到底需不需要GraphQL。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 13:54:00 +0000</pubDate>
<dc:creator>ChaosYang1987</dc:creator>
<og:description>在现在的公司使用GraphQL有一段时间了。 现公司从创立之后的很长一段时间内是纯PHP的技术栈，前端、后端都在PHP代码中糅合在一起。新功能越加越多，页面越来越复杂之后，那些混在在PHP代码中的HT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaosyang/p/graphql-practice-and-resolve-performance-issue.html</dc:identifier>
</item>
<item>
<title>机器学习框架ML.NET学习笔记【2】入门之二元分类 - seabluescn</title>
<link>http://www.cnblogs.com/seabluescn/p/10907109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seabluescn/p/10907109.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、准备样本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接上一篇文章提到的问题：根据一个人的身高、体重来判断一个人的身材是否很好。但我手上没有样本数据，只能伪造一批数据了，伪造的数据比较标准，用来学习还是蛮合适的。&lt;/p&gt;
&lt;p&gt;下面是我用来伪造数据的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('eeae42ab-a3df-46a2-be99-4a4782aa9659')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_eeae42ab-a3df-46a2-be99-4a4782aa9659&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eeae42ab-a3df-46a2-be99-4a4782aa9659&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('eeae42ab-a3df-46a2-be99-4a4782aa9659',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eeae42ab-a3df-46a2-be99-4a4782aa9659&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;string&lt;/span&gt; Filename = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./figure_full.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            StreamWriter sw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StreamWriter(Filename, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            sw.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Height,Weight,Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; height, weight;
            Result result;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2000&lt;/span&gt;; i++&lt;span&gt;)
            {
                height &lt;/span&gt;= random.Next(&lt;span&gt;150&lt;/span&gt;, &lt;span&gt;195&lt;/span&gt;&lt;span&gt;);
                weight &lt;/span&gt;= random.Next(&lt;span&gt;70&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (height &amp;gt; &lt;span&gt;170&lt;/span&gt; &amp;amp;&amp;amp; weight &amp;lt; &lt;span&gt;120&lt;/span&gt;&lt;span&gt;)
                    result &lt;/span&gt;=&lt;span&gt; Result.Good;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    result &lt;/span&gt;=&lt;span&gt; Result.Bad;
               
                sw.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{height},{weight},{(int)result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }


   &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Result
    {
        Bad&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        Good&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;制造成功后的数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190522210230139-1061117948.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 用记事本打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190522211707741-309217740.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、源码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据准备好了，我们就用准备好的数据进行学习了，先贴出全部代码，然后再逐一解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('dbdd82c2-9d44-4259-a3d7-5787bb43d956')&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_dbdd82c2-9d44-4259-a3d7-5787bb43d956&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dbdd82c2-9d44-4259-a3d7-5787bb43d956&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('dbdd82c2-9d44-4259-a3d7-5787bb43d956',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dbdd82c2-9d44-4259-a3d7-5787bb43d956&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BinaryClassification_Figure
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DataPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;figure_full.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ModelPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FastTree_Model.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            TrainAndSave();
            LoadAndPrediction();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press any to exit!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TrainAndSave()
        {
            MLContext mlContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MLContext();           

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fulldata = mlContext.Data.LoadFromTextFile&amp;lt;FigureData&amp;gt;(path: DataPath, hasHeader: &lt;span&gt;true&lt;/span&gt;, separatorChar: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);           
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainTestData = mlContext.Data.TrainTestSplit(fulldata,testFraction:&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainData =&lt;span&gt; trainTestData.TrainSet;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testData =&lt;span&gt; trainTestData.TestSet;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;训练 &lt;/span&gt;
            IEstimator&amp;lt;ITransformer&amp;gt; dataProcessPipeline = mlContext.Transforms.Concatenate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Features&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
                .Append(mlContext.Transforms.NormalizeMeanVariance(inputColumnName: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Features&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, outputColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeaturesNormalizedByMeanVar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            IEstimator&lt;/span&gt;&amp;lt;ITransformer&amp;gt; trainer = mlContext.BinaryClassification.Trainers.FastTree(labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeaturesNormalizedByMeanVar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IEstimator&lt;/span&gt;&amp;lt;ITransformer&amp;gt; trainingPipeline =&lt;span&gt; dataProcessPipeline.Append(trainer); 
            ITransformer model &lt;/span&gt;=&lt;span&gt; trainingPipeline.Fit(trainData);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;评估&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predictions =&lt;span&gt; model.Transform(testData);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = mlContext.BinaryClassification.Evaluate(data: predictions, labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, scoreColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            PrintBinaryClassificationMetrics(trainer.ToString(), metrics);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存模型&lt;/span&gt;
&lt;span&gt;            mlContext.Model.Save(model, trainData.Schema, ModelPath);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model file saved to :{ModelPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }      

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadAndPrediction()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mlContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MLContext();
            ITransformer model &lt;/span&gt;= mlContext.Model.Load(ModelPath, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; inputSchema);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; predictionEngine = mlContext.Model.CreatePredictionEngine&amp;lt;FigureData, FigureDatePredicted&amp;gt;&lt;span&gt;(model);

            FigureData test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FigureData();
            test.Weight &lt;/span&gt;= &lt;span&gt;115&lt;/span&gt;&lt;span&gt;;
            test.Height &lt;/span&gt;= &lt;span&gt;171&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prediction =&lt;span&gt; predictionEngine.Predict(test);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Predict Result :{prediction.PredictedLabel}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }      
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FigureData
    {
        [LoadColumn(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Height { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Weight { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }       
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FigureDatePredicted : FigureData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; PredictedLabel;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、对代码的解释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、读取样本数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;string&lt;/span&gt; DataPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;figure_full.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        MLContext mlContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MLContext();          

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; fulldata = mlContext.Data.LoadFromTextFile&amp;lt;FigureData&amp;gt;(path: DataPath, hasHeader: &lt;span&gt;true&lt;/span&gt;, separatorChar: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);           
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainTestData = mlContext.Data.TrainTestSplit(fulldata,testFraction:&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; trainData =&lt;span&gt; trainTestData.TrainSet;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testData = trainTestData.TestSet;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; LoadFromTextFile&amp;lt;FigureData&amp;gt;(path: DataPath, hasHeader: true, separatorChar: ',')用来读取数据到DataView&lt;/p&gt;
&lt;p&gt;FigureData类是和样本数据对应的实体类，LoadColumn特性指示该属性对应该条数据中的第几个数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FigureData
    {
        [LoadColumn(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Height { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Weight { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }       
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; path:文件路径&lt;/p&gt;
&lt;p&gt;hasHeader:文本文件是否包含标题&lt;/p&gt;
&lt;p&gt;separatorChar:用来分割数据的字符，我们用的是逗号，常用的还有跳格符‘\t’&lt;/p&gt;
&lt;p&gt;TrainTestSplit(fulldata,testFraction:0.2)用来随机分割数据，分成学习数据和评估用的数据，通常情况，如果数据较多，测试数据取20%左右比较合适，如果数据量较少，测试数据取10%左右比较合适。&lt;/p&gt;
&lt;p&gt;如果不通过分割，准备两个数据文件,一个用来训练、一个用来评估，效果是一样的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、训练 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;训练 &lt;/span&gt;
            IEstimator&amp;lt;ITransformer&amp;gt; dataProcessPipeline = mlContext.Transforms.Concatenate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Features&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
                .Append(mlContext.Transforms.NormalizeMeanVariance(inputColumnName: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Features&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, outputColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeaturesNormalizedByMeanVar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            IEstimator&lt;/span&gt;&amp;lt;ITransformer&amp;gt; trainer = mlContext.BinaryClassification.Trainers.FastTree(labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, featureColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FeaturesNormalizedByMeanVar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IEstimator&lt;/span&gt;&amp;lt;ITransformer&amp;gt; trainingPipeline =&lt;span&gt; dataProcessPipeline.Append(trainer); 
            ITransformer model &lt;/span&gt;= trainingPipeline.Fit(trainData);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  IDataView这个数据集就类似一个表格，它的列（Column）是可以动态增加的，一开始我们通过LoadFromTextFile获得的数据集包括：Height、Weight、Result这几个列，在进行训练之前，我们还要对这个数据集进行处理，形成符合我们要求的数据集。&lt;/p&gt;
&lt;p&gt;Concatenate这个方法是把多个列，组合成一个列，因为二元分类的机器学习算法只接收一个特征列，所以要把多个特征列（Height、Weight）组合成一个特征列Features（组合的结果应该是个float数组）。&lt;/p&gt;
&lt;p&gt;NormalizeMeanVariance是对列进行归一化处理，这里输入列为：Features，输出列为：FeaturesNormalizedByMeanVar，归一化的含义见本文最后一节介绍。&lt;/p&gt;
&lt;p&gt;数据集就绪以后，就要选择学习算法，针对二元分类，我们选择了快速决策树算法FastTree，我们需要告诉这个算法特征值放在哪个列里面（FeaturesNormalizedByMeanVar），标签值放在哪个列里面（Result）。&lt;/p&gt;
&lt;p&gt;链接数据处理管道和算法形成学习管道，将数据集中的数据逐一通过学习管道进行学习，形成机器学习模型。&lt;/p&gt;
&lt;p&gt;有了这个模型我们就可以通过它进行实际应用了。但我们一般不会现在就使用这个模型，我们需要先评估一下这个模型，然后把模型保存下来。以后应用时再通过文件读取出模型，然后进行应用，这样就不用等待学习的时间了，通常学习的时间都比较长。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、评估 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;评估&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predictions =&lt;span&gt; model.Transform(testData);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metrics = mlContext.BinaryClassification.Evaluate(data: predictions, labelColumnName: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            PrintBinaryClassificationMetrics(trainer.ToString(), metrics);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  评估的过程就是对测试数据集进行批量转换（Transform），转换过的数据集会多出一个“PredictedLabel”的列，这个就是模型评估的结果，逐条将这个结果和实际结果（Result）进行比较，就最终形成了效果评估数据。&lt;/p&gt;
&lt;p&gt;我们可以打印这个评估结果，查看其成功率，一般成功率大于97%就是比较好的模型了。由于我们伪造的数据比较整齐，所以我们这次评估的成功率为100%。&lt;/p&gt;
&lt;p&gt;注意：评估过程不会提升现有的模型能力，只是对现有模型的一种检测。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、保存模型 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存模型&lt;/span&gt;
           &lt;span&gt;string&lt;/span&gt; ModelPath = Path.Combine(Environment.CurrentDirectory, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FastTree_Model.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            mlContext.Model.Save(model, trainData.Schema, ModelPath);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Model file saved to :{ModelPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个没啥好解释的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、读取模型并创建预测引擎 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取模型&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; mlContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MLContext();
            ITransformer model &lt;/span&gt;= mlContext.Model.Load(ModelPath, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; inputSchema);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建预测引擎&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; predictionEngine = mlContext.Model.CreatePredictionEngine&amp;lt;FigureData, FigureDatePredicted&amp;gt;(model);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 创建预测引擎的功能和Transform是类似的，不过Transform是处理批量记录，这里只处理一条数据，而且这里的输入输出是实体对象，定义如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FigureData
    {
        [LoadColumn(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Height { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Weight { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [LoadColumn(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }       
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FigureDatePredicted : FigureData
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; PredictedLabel;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 由于预测结果里放在“PredictedLabel”字段中，所以FigureDatePredicted类必须要包含PredictedLabel属性，目前FigureDatePredicted 类是从FigureData类继承的，由于我们只用到PredictedLabel属性，所以不继承也没有关系，如果继承的话，后面要调试的话会方便一点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、应用 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            FigureData test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FigureData
            {
                Weight &lt;/span&gt;= &lt;span&gt;115&lt;/span&gt;&lt;span&gt;,
                Height &lt;/span&gt;= &lt;span&gt;171&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prediction =&lt;span&gt; predictionEngine.Predict(test);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Predict Result :{prediction.PredictedLabel}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这部分代码就比较简单，test是我们要预测的对象，预测后打印出预测结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、附：数据归一化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 机器学习的算法中一般会有很多的乘法运算，当运算的数字过大时，很容易在多次运算后溢出，为了防止这种情况，就要对数据进行归一化处理。归一化的目标就是把参与运算的特征数变为（0，1）或（-1，1）之间的浮点数，常见的处理方式有：min-max标准化、Log函数转换、对数函数转换等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190523095258475-2015530973.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这次采用的是平均方差归一化方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码下载地址：https://github.com/seabluescn/Study_ML.NET&lt;/p&gt;
&lt;p&gt;工程名称：BinaryClassification_Figure&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 13:36:00 +0000</pubDate>
<dc:creator>seabluescn</dc:creator>
<og:description>一个利用ML.NET进行二元分类的例子。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seabluescn/p/10907109.html</dc:identifier>
</item>
</channel>
</rss>