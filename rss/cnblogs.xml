<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>scrapy-redis源码解读之发送POST请求 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10867285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10867285.html</guid>
<description>&lt;p&gt;这段时间在研究美团爬虫，用的是scrapy-redis分布式爬虫框架，奈何scrapy-redis与scrapy框架不同，默认只发送GET请求，换句话说，不能直接发送POST请求，而美团的数据请求方式是POST，网上找了一圈，发现关于scrapy-redis发送POST的资料寥寥无几，只能自己刚源码了。&lt;/p&gt;

&lt;p&gt;先来说一说需求，也就是说美团POST请求形式。我们以获取某个地理坐标下，所有店铺类别列表请求为例。获取所有店铺类别列表时，我们需要构造一个包含位置坐标经纬度等信息的表单数据，以及为了向下一层parse方法传递的一些必要数据，即meta，然后发起一个POST请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;url：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;请求地址，即url是固定的，如下所示：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://i.waimai.meituan.com/openh5/poi/filterconditions?_=1557367197922&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;url最后面的13位数字是时间戳，实际应用时用time模块生成一下就好了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表单数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
form_data =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25.618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105.644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;actualLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25.618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;actualLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105.644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;geoType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_actual_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_actual_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;meta数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;meta数据不是必须的，但是，如果你在发送请求时，有一些数据需要向下一层parse方法（解析爬虫返回的response的方法）中传递的话，就可以构造这一数据，然后作为参数传递进request中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
meta =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**省&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;area&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;采集店铺类别列表时需要发送怎样一个POST请求在上面已经说明了，那么，在scrapy-redis框架中，这个POST该如何来发送呢？我相信，打开我这篇博文的读者都是用过scrapy的，用scrapy发送POST肯定没问题（重写start_requests方法即可），但scrapy-redis不同，scrapy-redis框架只会从配置好的redis数据库中读取起始url，所以，在scrapy-redis中，就算重写start_requests方法也没用。怎么办呢？我们看看源码。&lt;/p&gt;
&lt;p&gt;我们知道，scrapy-redis与scrapy的一个很大区别就是，scrapy-redis不再继承Spider类，而是继承RedisSpider类的，所以，RedisSpider类源码将是我们分析的重点，我们打开RedisSpider类，看看有没有类似于scrapy框架中的start_requests、make_requests_from_url这样的方法。RedisSpider源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisSpider(RedisMixin, Spider):
    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; from_crawler(self, crawler, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= super(RedisSpider, self).from_crawler(crawler, *args, **&lt;span&gt;kwargs)
        obj.setup_redis(crawler)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很遗憾，在RedisSpider类中没有找到类似start_requests、make_requests_from_url这样的方法，而且，RedisSpider的源码也太少了吧，不过，从第一行我们可以发现RedisSpider继承了RedisMinxin这个类，所以我猜RedisSpider的很多功能是从父类继承而来的（拼爹的RedisSpider）。继续查看RedisMinxin类源码。RedisMinxin类源码太多，这里就不将所有源码贴出来了，不过，惊喜的是，在RedisMinxin中，真找到了类似于start_requests、make_requests_from_url这样的方法，如：start_requests、next_requests、make_request_from_data等。有过scrapy使用经验的童鞋应该都知道，start_requests方法可以说是构造一切请求的起源，没分析scrapy-redis源码之前，谁也不知道scrapy-redis是不是和scrapy一样（后面打断点的方式验证过，确实一样，话说这个验证有点多余，因为源码注释就是这么说的），不过，还是从start_requests开始分析吧。start_requests源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; start_requests(self):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.next_requests()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;呵，真简洁，直接把所有任务丢给next_requests方法，继续：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; next_requests(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Returns a request to be scheduled or none.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    use_set &lt;/span&gt;= self.settings.getbool(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REDIS_START_URLS_AS_SET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,             defaults.START_URLS_AS_SET)
    fetch_one &lt;/span&gt;= self.server.spop &lt;span&gt;if&lt;/span&gt; use_set &lt;span&gt;else&lt;/span&gt;&lt;span&gt; self.server.lpop
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; XXX: Do we need to use a timeout here?&lt;/span&gt;
    found =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO: Use redis pipeline execution.&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; found &amp;lt; self.redis_batch_size: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次读取的量&lt;/span&gt;
        data = fetch_one(self.redis_key) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从redis中读取一条记录&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Queue empty.&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        req &lt;/span&gt;= self.make_request_from_data(data) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据从redis中读取的记录，实例化一个request&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; req:
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; req
        found &lt;/span&gt;+= 1
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            self.logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Request not made from data: %r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, data)
 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; found:
        self.logger.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Read %s requests from '%s'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, found, self.redis_key)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面next_requests方法中，关键的就是那个while循环，每一次循环都调用了一个make_request_from_data方法，从函数名可以函数，这个方法就是根据从redis中读取从来的数据，实例化一个request，那不就是我们要找的方法吗？进入make_request_from_data方法一探究竟：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_request_from_data(self, data):
    url &lt;/span&gt;=&lt;span&gt; bytes_to_str(data, self.redis_encoding)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.make_requests_from_url(url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是重点，圈起来，要考&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为scrapy-redis默认值发送GET请求，所以，在这个make_request_from_data方法中认为data只包含一个url，但如果我们要发送POST请求，这个data包含的东西可就多了，我们上面美团POST请求说明中就说到，至少要包含url、form_data。所以，如果我们要发送POST请求，这里必须改，make_request_from_data方法最后调用的make_requests_from_url是scrapy中的Spider中的方法，不过，我们也不需要继续往下看下去了，我想诸位都也清楚了，要发送POST请求，重写这个make_request_from_data方法，根据传入的data，实例化一个request返回就好了。&lt;/p&gt;

&lt;p&gt;明白上面这些东西后，就可以开始写代码了。修改源码吗？不，不存在的，改源码可不是好习惯。我们直接在我们自己的Spider类中重写make_request_from_data方法就好了：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scrapy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; FormRequest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; scrapy_redis.spiders &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RedisSpider
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MeituanSpider(RedisSpider):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    此处省略若干行
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
 
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_request_from_data(self, data):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        重写make_request_from_data方法，data是scrapy-redis读取redis中的[url,form_data,meta]，然后发送post请求
        :param data: redis中都去的请求数据，是一个list
        :return: 一个FormRequest对象
    　　&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        data &lt;/span&gt;=&lt;span&gt; json.loads(data)
        url &lt;/span&gt;= data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        form_data &lt;/span&gt;= data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        meta &lt;/span&gt;= data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;meta&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; FormRequest(url=url, formdata=form_data, meta=meta, callback=&lt;span&gt;self.parse)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;搞清楚原理之后，就是这么简单。万事俱备，只欠东风——将url，form_data，meta存储到redis中。另外新建一个模块实现这一部分功能：&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; push_start_url_data(request_data):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    将一个完整的request_data推送到redis的start_url列表中
    :param request_data: {'url':url, 'form_data':form_data, 'meta':meta}
    :return:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    r.lpush(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;meituan:start_urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, request_data)
 
 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://i.waimai.meituan.com/openh5/poi/filterconditions?_=1557367197922&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    form_data &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25.618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105.644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;actualLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25.618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;actualLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105.644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;geoType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_actual_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;25618626&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_actual_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;105644569&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }
    meta &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;initialLng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lat2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_latitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lng2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wm_longitude&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**省&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;area&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**区&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }
    request_data &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: url,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: form_data,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;meta&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: meta
    }
    push_start_url_data(json.dumps(request_data))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在启动scrapy-redis之前，运行一下这一模块即可。如果有很多POI（地理位置兴趣点），循环遍历每一个POI，生成request_data，push到redis中。这一循环功能就你自己写吧。&lt;/p&gt;

&lt;p&gt;没有什么是撸一遍源码解决不了的，如果有，就再撸一遍！&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 23:32:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>scrapy-redis是对scrapy改进，在分布式爬虫开发上有卓越的表现，但由于scrapy-redis只从redis中读取起始url，导致发送POST困难，本文从源码出发，逐步探寻、解释scra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10867285.html</dc:identifier>
</item>
<item>
<title>测试merge效率 - 皇家救星</title>
<link>http://www.cnblogs.com/kingstarer/p/10865941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingstarer/p/10865941.html</guid>
<description>&lt;p&gt;测试说明：&lt;/p&gt;
&lt;p&gt;MERGE是oracle提供的一种特殊的sql语法，非常适用于数据同步场景，即： （把A表数据插到B表，如果B表存在相同主键的记录则使用A表数据对B表进行更新） 数据同步的常规做法是先尝试插入，插入失败再进行更新，MERGE比这种常规做法效率高很多。 （特别是A与B表基本一致，同步时主键冲突比较多的情况，效率能相差10倍以上）&lt;/p&gt;
&lt;p&gt;为了验证MERGE效率，我建了两张表，tab_test_C（初始化生成50000条记录）和tab_test_Q（初始化从tab_test_C生成40000条记录）， 写了两个plsql脚本，分别将tab_test_C的数据同步到tab_test_Q，看它们效率区别。&lt;/p&gt;
&lt;p&gt;第一个脚本使用merge语法，第二个脚本使用常规先插入，出现主键冲突的操作。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;测试结果：&lt;br/&gt;&lt;span&gt; 使用merge语法的脚本同步数据耗时0.04秒，使用常规操作耗时14.77秒，效率差369倍&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;测试脚本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; SERVEROUTPUT &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 启动计时 以便观察脚本执行时间&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; TIMING &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; TIME &lt;span&gt;ON&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 数据初始化 &lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_test_C;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_test_C 
(
    C1 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C2 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C3 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C4 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C5 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C6 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C7 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C8 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C9 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;),
    C10 &lt;/span&gt;&lt;span&gt;VARCHAR2&lt;/span&gt;(&lt;span&gt;512&lt;/span&gt;&lt;span&gt;)
);

&lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt;&lt;span&gt;
    v_total &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt;
    v_total :&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LOOP
        &lt;/span&gt;&lt;span&gt;EXIT&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; v_total &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;50000&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; cur &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; owner, &lt;span&gt;object_name&lt;/span&gt;, subobject_name, &lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;, data_object_id, object_type, 
            created, last_ddl_time, &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; all_objects &lt;span&gt;where&lt;/span&gt; rownum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;101&lt;/span&gt;&lt;span&gt;)
        loop
            &lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; tab_test_C &lt;span&gt;values&lt;/span&gt; (cur.owner, cur.&lt;span&gt;object_name&lt;/span&gt;&lt;span&gt;, cur.subobject_name, 
            cur.&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;, cur.data_object_id, 
            cur.object_type, cur.created, 
            cur.last_ddl_time, cur.&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;, v_total);
            v_total :&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; v_total &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt; loop;
    &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; LOOP;
    &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 建唯一索引&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tab_test_C;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; uid_test_c_1 &lt;span&gt;on&lt;/span&gt; tab_test_C(C10);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;初始化tab_test_Q表数据，先从tab_test_C生成同步40000条数据，剩下10000条数据使用脚本同步过来&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_test_Q;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; tab_test_Q &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tab_test_C &lt;span&gt;where&lt;/span&gt; rownum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;40001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; uid_test_q_1 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; tab_test_Q(C10);
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 验证数据未同步成功 此时记录数差1000&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tab_test_Q;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用merge语法同步tab_test_C的数据到tab_test_Q&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt;
    &lt;span&gt;CURSOR&lt;/span&gt; cur &lt;span&gt;is&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tab_test_C;
    type mergeArray_t &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; tab_test_C &lt;span&gt;%&lt;/span&gt; ROWTYPE &lt;span&gt;index&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; BINARY_INTEGER;
    mergeArray mergeArray_t;
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;OPEN&lt;/span&gt;&lt;span&gt; cur;
    LOOP
        &lt;/span&gt;&lt;span&gt;EXIT&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt; cur &lt;span&gt;%&lt;/span&gt;&lt;span&gt; NOTFOUND;
        &lt;/span&gt;&lt;span&gt;FETCH&lt;/span&gt; cur &lt;span&gt;bulk&lt;/span&gt; collect &lt;span&gt;into&lt;/span&gt; mergeArray LIMIT &lt;span&gt;16&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 每次限十几条记录，不要占用太多内存 这个数字调大点效率会更高&lt;/span&gt;
        &lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt;
            FORALL rw &lt;/span&gt;&lt;span&gt;IN&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; .. mergeArray.&lt;span&gt;count&lt;/span&gt;&lt;span&gt;
                MERGE &lt;/span&gt;&lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; tab_test_Q A
                USING (&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; mergeArray(rw).C1 C1, mergeArray(rw).C2 C2, mergeArray(rw).C3 C3, mergeArray(rw).C4 C4, 
                    mergeArray(rw).C5 C5, mergeArray(rw).C6 C6, mergeArray(rw).C7 C7, mergeArray(rw).C8 C8, 
                    mergeArray(rw).C9 C9, mergeArray(rw).C10 C10 &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; DUAL) B
                &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; (A.C10 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; B.C10)
                &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; MATCHED &lt;span&gt;THEN&lt;/span&gt;
                    &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; A.C1 &lt;span&gt;=&lt;/span&gt; mergeArray(rw).C1, A.C2 &lt;span&gt;=&lt;/span&gt; mergeArray(rw).C2, A.C3 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; mergeArray(rw).C3, 
                        A.C4 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; mergeArray(rw).C4, A.C5 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; mergeArray(rw).C5, 
                        A.C6 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; mergeArray(rw).C6, A.C7 &lt;span&gt;=&lt;/span&gt; mergeArray(rw).C7, A.C8 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; mergeArray(rw).C8, 
                        A.C9 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; mergeArray(rw).C9
                &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; MATCHED &lt;span&gt;THEN&lt;/span&gt;
                    &lt;span&gt;INSERT&lt;/span&gt; (C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) &lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;(mergeArray(rw).C1, mergeArray(rw).C2,
                        mergeArray(rw).C3, mergeArray(rw).C4, mergeArray(rw).C5, mergeArray(rw).C6, 
                        mergeArray(rw).C7, mergeArray(rw).C8, mergeArray(rw).C9, mergeArray(rw).C10);
            &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; DBMS_OUTPUT.PUT_LINE(mergeArray.count);&lt;/span&gt;
&lt;span&gt;        EXCEPTION
            &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; OTHERS &lt;span&gt;THEN&lt;/span&gt;&lt;span&gt;
                    DBMS_OUTPUT.PUT_LINE(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; LOOP;
    &lt;/span&gt;&lt;span&gt;CLOSE&lt;/span&gt;&lt;span&gt; cur;
    &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;耗时0.04秒&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 验证数据同步成功 &lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tab_test_Q;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;初始化tab_test_Q表数据，先从tab_test_C生成同步40000条数据，剩下10000条数据使用脚本同步过来&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tab_test_Q;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; tab_test_Q &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tab_test_C &lt;span&gt;where&lt;/span&gt; rownum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;40001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; uid_test_q_1 &lt;span&gt;on&lt;/span&gt;&lt;span&gt; tab_test_Q(C10);
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 验证数据未同步成功 此时记录数差1000&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tab_test_Q;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用常规语法同步tab_test_C的数据到tab_test_Q&lt;/span&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; cur &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tab_test_C)
    LOOP
        &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
            &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; tab_test_Q(C1, C2, C3, C4, C5, C6, C7, C8, C9, C10) 
            &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;(cur.C1, cur.C2, cur.C3, cur.C4, cur.C5, cur.C6, cur.C7, cur.C8, cur.C9, cur.C10);
        EXCEPTION
            &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; DUP_VAL_ON_INDEX &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;唯一索引冲突时更新&lt;/span&gt;
                &lt;span&gt;UPDATE&lt;/span&gt; tab_test_Q &lt;span&gt;SET&lt;/span&gt; C1 &lt;span&gt;=&lt;/span&gt; cur.C1, C2 &lt;span&gt;=&lt;/span&gt; cur.C2, C3 &lt;span&gt;=&lt;/span&gt; cur.C3, C4 &lt;span&gt;=&lt;/span&gt; cur.C4, C5 &lt;span&gt;=&lt;/span&gt; cur.C5, C6 &lt;span&gt;=&lt;/span&gt; cur.C6, C7 &lt;span&gt;=&lt;/span&gt; cur.C7, C8 &lt;span&gt;=&lt;/span&gt; cur.C8, C9 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; cur.C9
                &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; C10 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; cur.C10;
            &lt;/span&gt;&lt;span&gt;WHEN&lt;/span&gt; OTHERS &lt;span&gt;THEN&lt;/span&gt;&lt;span&gt;
                    DBMS_OUTPUT.PUT_LINE(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; LOOP;
    &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;耗时14.77秒&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 验证数据同步成功&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tab_test_Q;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 May 2019 16:20:00 +0000</pubDate>
<dc:creator>皇家救星</dc:creator>
<og:description>测试说明： MERGE是oracle提供的一种特殊的sql语法，非常适用于数据同步场景，即： （把A表数据插到B表，如果B表存在相同主键的记录则使用A表数据对B表进行更新） 数据同步的常规做法是先尝试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingstarer/p/10865941.html</dc:identifier>
</item>
<item>
<title>静态代理和动态代理 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/10865391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/10865391.html</guid>
<description>&lt;p&gt;学习 Spring 的过程中，不可避免要掌握代理模式。这篇文章总结一下代理模式。顾名思义，代理，就是你委托别人帮你办事，所以代理模式也有人称作委托模式的。比如领导要做什么事，可以委托他的秘书去帮忙做，这时就可以把秘书看做领导的代理。下面将以这个例子来讲解。&lt;br/&gt;代理模式又分为静态代理和动态代理。&lt;/p&gt;

&lt;h2 id=&quot;静态代理的使用&quot;&gt;静态代理的使用&lt;/h2&gt;
&lt;p&gt;静态代理，代理类和被代理的类实现了同样的接口，代理类同时持有被代理类的引用，这样，当我们需要调用被代理类的方法时，可以通过调用代理类的方法来做到。举例如下：&lt;br/&gt;假设领导的工作是开会和给员工考评。&lt;br/&gt;先定义一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public interface IWork {
    void meeting();

    int evaluate(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义领导类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import java.util.Random;

public class Leader implements IWork {

    @Override
    public void meeting() {
        System.out.println(&quot;领导早上要组织会议&quot;);
    }

    @Override
    public int evaluate(String name) {
        int score = new Random(System.currentTimeMillis()).nextInt(20) + 80;
        System.out.println(String.format(&quot;领导给%s的考评为%s分&quot;, name, score));
        return score;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;秘书类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public class Secretary implements IWork {
    private Leader mLeader;

    public Secretary(Leader mLeader) {
        this.mLeader = mLeader;
    }

    @Override
    public void meeting() {
        System.out.println(&quot;秘书先给老板准备材料&quot;);
        mLeader.metting();
    }

    @Override
    public int evaluate(String name) {
        return mLeader.evaluate(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public class TestApp {
    public static void main(String[] args) {
        Leader leader = new Leader();
        Secretary secretary = new Secretary(leader);
        secretary.meeting();
        secretary.evaluate(&quot;Joy&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233856680-1281100521.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个代码很简单，注意在调用&lt;code&gt;Secretary&lt;/code&gt;类的 meeting 方法时，我们调用了&lt;code&gt;Leader&lt;/code&gt;类的 meeting 的方法，在此之前，我们还扩充了该方法。这时有的人可能有疑惑了，这看起来有点是装饰者模式了。这到底怎么回事？&lt;/p&gt;
&lt;h2 id=&quot;与装饰者模式的区别&quot;&gt;与装饰者模式的区别&lt;/h2&gt;
&lt;p&gt;实际上，在装饰器模式和代理模式之间还是有很多差别的。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们可以用另外一句话来总结这些差别：使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看两者的 UML 类图区别：&lt;br/&gt;&lt;code&gt;代理模式&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233917258-845805849.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;装饰者模式&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233922928-800993165.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两者伪代码：&lt;br/&gt;代理模式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Interface Subject {
    void doAction()
}

public class RealSubject implements Subject{
    @Override
    public void doAction() {};
}


public class Proxy implements Subject{
       private RealSubject realSubject;

       public Proxy(RealSubject realSubject) {
             //关系在编译时确定
            this.realSubject = realSubject;
       }

       @Override
       public void doAction() {
             ….
             realSubject.doAction();
             ….
       }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 装饰者模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Interface Component {
    void doAction()
}

public class ConcreteComponent implement Component {
    @Override
    public void doAction() {};
}

public class Decorator implements Component {
       private Component component;

       public Decorator(Component component) {
             //关系在编译时确定
            this.component = new component;
       }
       public void doAction() {
             ….
             component.doAction();
             ….
       }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实代理模式和装饰者模式侧重点不一样，代理模式重点在于明确了被代理的类。如上例中，秘书很明确要代理的是的领导。而装饰者模式侧重于拓展类的方法，装饰类持有的实现Component接口的类的对象不是固定的，也就是说，装饰类可以根据在调用时传入的参数，装饰任意一个实现了 Component 接口的类。&lt;/p&gt;

&lt;p&gt;动态代理的根据实现方式的不同可以分为 JDK 动态代理和 CGlib 动态代理。&lt;br/&gt;JDK 动态代理：利用反射机制生成一个实现代理接口的类，在调用具体方法前调用InvokeHandler来处理。&lt;br/&gt;CGlib 动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。&lt;br/&gt;区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。&lt;/p&gt;
&lt;h2 id=&quot;jdk-动态代理&quot;&gt;JDK 动态代理&lt;/h2&gt;
&lt;p&gt;还是以上面的例子为例：&lt;br/&gt;首先，定一个类实现 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口，并实现 invoke 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class WorkInvocationHandler implements InvocationHandler {
    private Object object;

    public WorkInvocationHandler(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;object: &quot; + object.getClass().getSimpleName());
        System.out.println(&quot;proxy: &quot; + proxy.getClass().getSimpleName());

        if (&quot;meeting&quot;.equals(method.getName())) {
            System.out.println(&quot;代理先准备会议材料...&quot;);
            return method.invoke(object, args);
        } else if (&quot;evaluate&quot;.equals(method.getName())) {
            if(args[0] instanceof String) {
                if (&quot;James&quot;.equals(args[0])) {
                    System.out.println(&quot;James 犯过错误，所以考评分数较低...&quot;);
                    return 70;
                }
            }
            return method.invoke(object, args);
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过 &lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt; 方法创建代理对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        /*Leader leader = new Leader();
        Secretary secretary = new Secretary(leader);
        secretary.meeting();
        secretary.evaluate(&quot;Joy&quot;);*/

        Leader leader = new Leader();
        IWork proxy = (IWork) Proxy.newProxyInstance(Leader.class.getClassLoader(),
                new Class[]{IWork.class}, new WorkInvocationHandler(leader));
        proxy.meeting();
        proxy.evaluate(&quot;Joy&quot;);
        proxy.evaluate(&quot;James&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233937713-1310854921.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，通过 WorkInvocationHandler 类，我们同样可以代理 Leader 类的方法的实现，实际上我们实现的是任意的方法的实现，只是我们在创建代理对象的时候传入的是 Iwork 接口以及 Leader 类对象。&lt;br/&gt;这里需要注意的是：在 InvocationHandler 接口的 invoke 方法中第一个参数 proxy, 并不是我们调用方法的对象，那这个参数是什么呢？代码中，我特别增加相应打印，打印出了 proxy 的类名，实际上 proxy 是代理对象本身，它的意义在于，我们可以在 invoke 方法中，返回该代理对象，然后进行连续调用。&lt;br/&gt;看如下例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.proxytest;

public interface IWork {
    IWork work(String subject);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.proxytest;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class WorkInvocationHandler implements InvocationHandler {
    private Object object;

    public WorkInvocationHandler(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (&quot;work&quot;.equals(method.getName())){
            System.out.println(&quot;--- work: &quot; + args[0]);
            return proxy;
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.proxytest;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        IWork worker = (IWork) Proxy.newProxyInstance(IWork.class.getClassLoader(), new Class[]{IWork.class},
                new WorkInvocationHandler(new IWork() {
                    @Override
                    public IWork work(String subject) {
                        return null;
                    }
                }));
        worker.work(&quot;AAA&quot;).work(&quot;BBB&quot;).work(&quot;CCC&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233947809-486719770.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cglib-动态代理实现&quot;&gt;CGlib 动态代理实现&lt;/h2&gt;
&lt;p&gt;首先添加 cglib 依赖&lt;br/&gt;build.gradle 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;... 

dependencies {
    // 引入 cglib 库
    compile 'cglib:cglib:3.1'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说了，cglib 针对类进行代理，我们以上面的 Leader 类为例，先创建一个类实现 &lt;code&gt;MethodInterceptor&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class LeaderMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        if (&quot;meeting&quot;.equals(method.getName())) {
            System.out.println(&quot;代理先准备会议材料...&quot;);
            return methodProxy.invokeSuper(o, objects);
        } else if (&quot;evaluate&quot;.equals(method.getName())) {
            if(objects[0] instanceof String) {
                if (&quot;James&quot;.equals(objects[0])) {
                    System.out.println(&quot;James 犯过错误，所以考评分数较低...&quot;);
                    return 70;
                }
            }
            return methodProxy.invokeSuper(o, objects);
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import net.sf.cglib.core.DebuggingClassWriter;
import net.sf.cglib.proxy.Enhancer;

import java.lang.reflect.Proxy;

public class TestApp {
    public static void main(String[] args) {
        // System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\temp\\code&quot;);  //保存生成的 class 文件
        Enhancer enhancer = new Enhancer(); // 通过CGLIB动态代理获取代理对象的过程
        enhancer.setSuperclass(Leader.class); // 设置enhancer对象的父类
        enhancer.setCallback(new LeaderMethodInterceptor()); // 设置enhancer的回调对象
        Leader proxy= (Leader)enhancer.create(); // 创建代理对象

        // 通过代理对象调用目标方法
        proxy.meeting();
        proxy.evaluate(&quot;Joy&quot;);
        proxy.evaluate(&quot;James&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190514233955761-2017683894.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MethodInterceptor&lt;/code&gt; 接口只有一个 &lt;code&gt;intercept&lt;/code&gt; 方法，这个方法有4个参数：&lt;br/&gt;1）obj表示增强的对象，即实现这个接口类的一个对象；&lt;br/&gt;2）method表示要被拦截的方法；&lt;br/&gt;3）args表示要被拦截方法的参数；&lt;br/&gt;4）proxy表示要触发父类的方法对象；&lt;/p&gt;
&lt;p&gt;需要注意的是，实际调用是 &lt;code&gt;methodProxy.invokeSuper()&lt;/code&gt;, 如果使用 &lt;code&gt;invoke()&lt;/code&gt; 方法，则需要传入被代理的类对象，否则出现死循环，造成 stackOverflow 。&lt;br/&gt;详情参考： &lt;a href=&quot;https://blog.csdn.net/kingmax54212008/article/details/83902535&quot;&gt;聊聊cglib动态代理遇到的坑: https://blog.csdn.net/kingmax54212008/article/details/83902535&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 16:08:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>这篇文章记录了 java 中的代理模式的使用。讲静态代理时，简单介绍了与装饰者模式的区别，讲动态代理，分别介绍 JDK 动态代理和 CGlib 动态代理的使用方式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/10865391.html</dc:identifier>
</item>
<item>
<title>JDK1.8源码(十一)——java.util.TreeMap类 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/10300976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/10300976.html</guid>
<description>&lt;p&gt;　　在前面几篇博客分别介绍了这样几种集合，基于数组实现的&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_5&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/ysocean/p/8622264.html&quot;&gt;ArrayList 类&lt;/a&gt;，基于链表实现的&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_4&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/ysocean/p/8657850.html&quot;&gt;LinkedList 类&lt;/a&gt;，基于散列表实现的&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_3&quot; class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/ysocean/p/8711071.html&quot;&gt;HashMap 类&lt;/a&gt;，本篇博客我们来介绍另一种数据类型，基于树实现的&lt;strong&gt;TreeSet&lt;/strong&gt;类。&lt;/p&gt;
&lt;h3&gt;1、TreeMap 定义&lt;/h3&gt;
&lt;p&gt;　　听名字就知道，TreeMap 是由Tree 和 Map 集合有关的，没错，TreeMap 是由红黑树实现的有序的 key-value 集合。&lt;/p&gt;
&lt;p&gt;　　PS:想要学懂TreeMap的实现原理，&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8004211.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;的了解是必不可少的！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TreeMap&amp;lt;K,V&amp;gt;
    extends AbstractMap&amp;lt;K,V&amp;gt;
    implements NavigableMap&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201901/1120165-20190121213836953-1363088203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　TreeMap 首先继承了 AbstractMap 抽象类，表示它具有散列表的性质，也就是由 key-value 组成。&lt;/p&gt;
&lt;p&gt;　　其次 TreeMap 实现了 NavigableMap 接口，该接口支持一系列获取指定集合的导航方法，比如获取小于指定key的集合。&lt;/p&gt;
&lt;p&gt;　　最后分别实现 Serializable 接口以及 Cloneable 接口，分别表示支持对象序列化以及&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8482979.html&quot; target=&quot;_blank&quot;&gt;对象克隆&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;2、字段定义&lt;/h3&gt;
&lt;p&gt; 　　①、Comparator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The comparator used to maintain order in this tree map, or
     * null if it uses the natural ordering of its keys.
     *
     * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; comparator;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看上面的英文注释，Comparator 是用来维护treemap集合中的顺序，如果为null，则按照key的自然顺序。&lt;/p&gt;
&lt;p&gt;　　Comparator 是一个接口，&lt;strong&gt;排序时需要实现其 compare 方法，该方法返回正数，零，负数分别代表大于，等于，小于&lt;/strong&gt;。那么怎么使用呢？这里举个例子：&lt;/p&gt;
&lt;p&gt;　　这里有一个Person类，里面有两个属性pname，page，我们将该person对象放入ArrayList集合时，需要对其按照年龄进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('21687b4f-8462-4dc7-a479-29d1e05917a1')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_21687b4f-8462-4dc7-a479-29d1e05917a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_21687b4f-8462-4dc7-a479-29d1e05917a1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('21687b4f-8462-4dc7-a479-29d1e05917a1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_21687b4f-8462-4dc7-a479-29d1e05917a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String pname;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer page;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String pname, Integer page) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pname =&lt;span&gt; pname;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.page =&lt;span&gt; page;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPname() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pname;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPname(String pname) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pname =&lt;span&gt; pname;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getPage() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; page;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPage(Integer page) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.page =&lt;span&gt; page;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
&lt;span&gt;37&lt;/span&gt;                 &quot;pname='&quot; + pname + '\'' +
&lt;span&gt;38&lt;/span&gt;                 &quot;, page=&quot; + page +
&lt;span&gt;39&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　排序代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; List&amp;lt;Person&amp;gt; personList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; personList.add(&lt;span&gt;new&lt;/span&gt; Person(&quot;李四&quot;,20&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; personList.add(&lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;,10&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; personList.add(&lt;span&gt;new&lt;/span&gt; Person(&quot;王五&quot;,30&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; System.out.println(&quot;原始顺序为：&quot;+&lt;span&gt;personList.toString());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Collections.sort(personList, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person o1, Person o2) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;升序
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return o1.getPage()-o2.getPage();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;降序&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; o2.getPage()-&lt;span&gt;o1.getPage();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不变
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return 0&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; System.out.println(&quot;排序后顺序为：&quot;+personList.toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打印结果为：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201902/1120165-20190220214637269-349676356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　②、Entry&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; root;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于Entry详细源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fdbe4378-23f6-4b96-893a-a3da5f112799')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_fdbe4378-23f6-4b96-893a-a3da5f112799&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fdbe4378-23f6-4b96-893a-a3da5f112799&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fdbe4378-23f6-4b96-893a-a3da5f112799',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fdbe4378-23f6-4b96-893a-a3da5f112799&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        K key;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        V value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt;&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt;&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; color =&lt;span&gt; BLACK;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         * Make a new cell with given key, value, and parent, and with
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} child links, and BLACK color.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         Entry(K key, V value, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         * Returns the key.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the key
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; K getKey() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;         * Returns the value associated with the key.
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the value associated with the key
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getValue() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;         * Replaces the value currently associated with the key with the given
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;         * value.
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the value associated with the key before this method was
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;         *         called
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V setValue(V value) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             V oldValue = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;)o;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; valEquals(key,e.getKey()) &amp;amp;&amp;amp;&lt;span&gt; valEquals(value,e.getValue());
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; keyHash = (key==&lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : key.hashCode());
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; valueHash = (value==&lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : value.hashCode());
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; keyHash ^&lt;span&gt; valueHash;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; +&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　这里主要看 Entry 类的几个字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;K key;
V value;
Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; left;
Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;
Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; color = BLACK;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相信对&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8004211.html&quot; target=&quot;_blank&quot;&gt;红黑树&lt;/a&gt;这种数据结构了解的人，一看这几个字段就明白了，这也印证了前面所说的TreeMap底层有红黑树这种数据结构。&lt;/p&gt;
&lt;p&gt;　　③、size&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The number of entries in the tree
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用来表示entry的个数，也就是key-value的个数。&lt;/p&gt;
&lt;p&gt;　　④、modCount&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The number of structural modifications to the tree.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　基本上前面讲的在ArrayList,LinkedList,HashMap等线程不安全的集合都有此字段，用来实现Fail-Fast 机制，如果在迭代这些集合的过程中，有其他线程修改了这些集合，就会抛出ConcurrentModificationException异常。&lt;/p&gt;
&lt;p&gt;　　⑤、红黑树常量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; RED   = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; BLACK = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、构造函数&lt;/h3&gt;
&lt;p&gt;　　①、无参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeMap() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将比较器 comparator 置为 null，表示按照key的自然顺序进行排序。&lt;/p&gt;
&lt;p&gt;　　②、带比较器的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeMap(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要自己实现Comparator。&lt;/p&gt;
&lt;p&gt;　　③、构造包含指定map集合的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        putAll(m);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用该构造器创建的TreeMap,会默认插入m表示的集合元素，并且comparator表示按照自然顺序进行插入。&lt;/p&gt;
&lt;p&gt;　　④、带 SortedMap的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TreeMap(SortedMap&amp;lt;K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         comparator =&lt;span&gt; m.comparator();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             buildFromSorted(m.size(), m.entrySet().iterator(), &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (java.io.IOException cannotHappen) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException cannotHappen) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　和上面带Map的构造函数不一样，map是无序的，而SortedMap 是有序的，使用 buildFromSorted() 方法将SortedMap集合中的元素插入到TreeMap 中。&lt;/p&gt;
&lt;h3&gt;4、添加元素&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加元素&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; t =&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果根节点为空，即TreeMap中一个元素都没有，那么设置新添加的元素为根节点
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且设置集合大小size=1,以及modCount+1，这是用于快速失败&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             compare(key, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; type (and possibly null) check&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             root = &lt;span&gt;new&lt;/span&gt; TreeMap.Entry&amp;lt;&amp;gt;(key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             size = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cmp;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; parent;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; split comparator and comparable paths&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; cpr =&lt;span&gt; comparator;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果比较器不为空，即初始化TreeMap构造函数时，有传递comparator类
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么插入新的元素时，按照comparator实现的类进行排序&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (cpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过do-while循环不断遍历树，调用比较器对key值进行比较&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 parent =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 cmp =&lt;span&gt; cpr.compare(key, t.key);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     t =&lt;span&gt; t.left;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     t =&lt;span&gt; t.right;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遇到key相等，直接将新值覆盖到原值上&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果比较器为空，即初始化TreeMap构造函数时，没有传递comparator类
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么插入新的元素时，按照key的自然顺序&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果key==null，直接抛出异常
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，上面构造TreeMap传入了Comparator，是可以允许key==null&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt;) key;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 parent =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 cmp =&lt;span&gt; k.compareTo(t.key);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     t =&lt;span&gt; t.left;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     t =&lt;span&gt; t.right;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.setValue(value);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到父亲节点，根据父亲节点创建一个新节点&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; e = &lt;span&gt;new&lt;/span&gt; TreeMap.Entry&amp;lt;&amp;gt;&lt;span&gt;(key, value, parent);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             parent.left =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             parent.right =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修正红黑树（包括节点的左旋和右旋，具体可以看我Java数据结构和算法中对红黑树的介绍）&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        fixAfterInsertion(e);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　添加元素，如果初始化TreeMap构造函数时，没有传递comparator类，是不允许插入key==null的键值对的，相反，如果实现了Comparator，则可以传递key=null的键值对。&lt;/p&gt;
&lt;p&gt;　　另外，当插入一个新的元素后（除了根节点），会对TreeMap数据结构进行修正，也就是对红黑树进行修正，使其满足红黑树的几个特点，具体修正方法包括改变节点颜色，左旋，右旋等操作，这里我不做详细介绍了，具体可以参考我的这篇博客：&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8004211.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ysocean/p/8004211.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5、删除元素&lt;/h3&gt;
&lt;p&gt;　　①、根据key删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据key找到该节点&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt; getEntry(key);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取该节点的value，并返回&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         V oldValue =&lt;span&gt; p.value;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用deleteEntry()方法删除节点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        deleteEntry(p);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteEntry(TreeMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         size--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果删除节点的左右节点都不为空，即有两个孩子&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; p.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到该节点的中序后继节点&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             TreeMap.Entry&amp;lt;K,V&amp;gt; s =&lt;span&gt; successor(p);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             p.key =&lt;span&gt; s.key;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             p.value =&lt;span&gt; s.value;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             p =&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; p has 2 children
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start fixup at replacement node, if it exists.&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; replacement = (p.left != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; p.left : p.right);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待删除节点只有一个子节点，直接删除该节点，并用该节点的唯一子节点顶替该节点&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (replacement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Link replacement to parent&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             replacement.parent =&lt;span&gt; p.parent;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 root =&lt;span&gt; replacement;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; p.parent.left)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 p.parent.left  =&lt;span&gt; replacement;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                 p.parent.right =&lt;span&gt; replacement;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Null out links so they are OK to use by fixAfterDeletion.&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             p.left = p.right = p.parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fix replacement&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.color ==&lt;span&gt; BLACK)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                fixAfterDeletion(replacement);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TreeMap中只有待删除节点P，也就是只有一个节点，直接返回nul即可&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p.parent == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return if we are the only node.&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  No children. Use self as phantom replacement and unlink.
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待删除节点没有子节点，即为叶子节点，直接删除即可&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.color ==&lt;span&gt; BLACK)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                fixAfterDeletion(p);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; p.parent.left)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     p.parent.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; p.parent.right)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     p.parent.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 p.parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　删除节点分为四种情况：&lt;/p&gt;
&lt;p&gt;　　1、根据key没有找到该节点：也就是集合中不存在这一个节点，直接返回null即可。&lt;/p&gt;
&lt;p&gt;　　2、根据key找到节点，又分为三种情况：&lt;/p&gt;
&lt;p&gt;　　　　①、待删除节点没有子节点，即为叶子节点：直接删除该节点即可。&lt;/p&gt;
&lt;p&gt;　　　　②、待删除节点只有一个子节点：那么首先找到待删除节点的子节点，然后删除该节点，用其唯一子节点顶替该节点。&lt;/p&gt;
&lt;p&gt;　　　　③、待删除节点有两个子节点：首先找到该节点的中序后继节点，然后把这个后继节点的内容复制给待删除节点，然后删除该中序后继节点，删除过程又转换成前面①、②两种情况了，这里主要是找到中序后继节点，相当于待删除节点的一个替身。&lt;/p&gt;
&lt;h3&gt;6、查找元素&lt;/h3&gt;
&lt;p&gt;　　①、根据key查找&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt; getEntry(key);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (p==&lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : p.value);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; TreeMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Offload comparator-based version for sake of performance&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (comparator != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getEntryUsingComparator(key);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt; k = (Comparable&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt;) key;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         TreeMap.Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cmp =&lt;span&gt; k.compareTo(p.key);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 p =&lt;span&gt; p.left;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 p =&lt;span&gt; p.right;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、遍历元素&lt;/h3&gt;
&lt;p&gt;　　通常有下面两种方法，第二种方法效率要快很多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; TreeMap&amp;lt;String,Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; map.put(&quot;A&quot;,1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; map.put(&quot;B&quot;,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; map.put(&quot;C&quot;,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方法
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先利用keySet()方法得到key的集合，然后利用map.get()方法根据key得到value&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; Iterator&amp;lt;String&amp;gt; iterator =&lt;span&gt; map.keySet().iterator();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iterator.hasNext()){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     String key =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     System.out.println(key+&quot;:&quot;+&lt;span&gt;map.get(key));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;String,Integer&amp;gt;&amp;gt; iterator1 =&lt;span&gt; map.entrySet().iterator();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iterator1.hasNext()){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     Map.Entry&amp;lt;String,Integer&amp;gt; entry =&lt;span&gt; iterator1.next();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     System.out.println(entry.getKey()+&quot;:&quot;+&lt;span&gt;entry.getValue());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 14 May 2019 14:42:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>JDK1.8源码(十一)——java.util.TreeMap类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/10300976.html</dc:identifier>
</item>
<item>
<title>Leetcode 第136场周赛解题报告 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10864973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10864973.html</guid>
<description>&lt;p&gt;周日的比赛的时候正在外面办事，没有参加。赛后看了下题目，几道题除了表面要考的内容，还是有些能发散扩展的地方。&lt;/p&gt;
&lt;p&gt;做题目不是最终目的，通过做题发现知识盲区，去研究学习，才能不断提高。&lt;/p&gt;
&lt;p&gt;理论和实际是有关系的，一些题目也都有现实意义。计算机的一些模拟操作，通过数学算法，能够大大减轻代码量和算法复杂度。&lt;/p&gt;
&lt;p&gt;第一题是机器人在坐标系上直走和转弯，通过简单的模拟就能实现。但是仔细思考发现还能通过线性代数，坐标变换的方式做，这样在实际中计算更快。甚至还可以用复数来做。&lt;/p&gt;
&lt;p&gt;实际扫地机器人可能就用到了类似的算法。让他能够不至于始终原地打转。&lt;/p&gt;
&lt;p&gt;第四题是典型的后缀树、后缀数组应用，找字符串最长重复子串。在搜索引擎，或DNA检测中，都是有实际使用场景的。在70年代就已经有应用了，是一个很经典的算法。而且在90年代至今，一直有科学家提升创建后缀树和后缀数组的时间复杂度。这个算法也是在不断发展的。而且在2016年中国的&lt;code&gt;李志泽，李建和霍红卫&lt;/code&gt;三位科学家提出了线性时间复杂度，常数空间的最优构造算法。是中国人对算法的贡献。&lt;/p&gt;
&lt;p&gt;下面是详细的题解和思考。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;比赛的地址 Weekly Contest 136&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-136&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-136&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;困于环中的机器人&quot;&gt;困于环中的机器人&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;困于环中的机器人(Robot Bounded In Circle)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-136/problems/robot-bounded-in-circle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：&lt;/p&gt;
&lt;p&gt;&quot;G&quot;：直走 1 个单位&lt;br/&gt;&quot;L&quot;：左转 90 度&lt;br/&gt;&quot;R&quot;：右转 90 度&lt;/p&gt;
&lt;p&gt;机器人按顺序执行指令 instructions，并一直重复它们。&lt;/p&gt;
&lt;p&gt;只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设机器人重复走N次指令后，面朝北：&lt;/p&gt;
&lt;p&gt;此时如果坐标在原点，则N次循环后就会重复从前的路径。&lt;/p&gt;
&lt;p&gt;如果坐标不在原点，此时把当前位置当作原点，就会每N次移动远离一段和当前原点的距离。距离最初的（0，0）位置越来越远。就不存在循环会最原始原点的问题。&lt;/p&gt;
&lt;p&gt;其实至多经过四次，机器人就会面朝北。&lt;/p&gt;
&lt;p&gt;经过一次指令后，机器人面朝西或东，相当于逆时针或顺时针转了90度，则再经过三次，就面朝北了。&lt;/p&gt;
&lt;p&gt;经过一次指令后，朝南则转了180度，共移动两次指令后朝北。&lt;/p&gt;
&lt;p&gt;数学方法：&lt;/p&gt;
&lt;p&gt;还可以把指令集先计算一遍，得出经过一个指令集后的相对移动位置和方向转角。用矩阵计算，就不用每次都运行一大堆指令模拟，加快运算速度；&lt;/p&gt;
&lt;p&gt;还可以用复数来运算，复数对于转90度有简单的运算方法。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Solution {
public:
    bool isRobotBounded(string instructions) {
        int x = 0;
        int y = 0;
        int i = 0;
        int dir[][2] = {{0,1},{1,0},{0,-1},{-1,0}};
        do
        {
            for(auto ch : instructions)
            {
            if(ch=='G')
            {
                x+=dir[i][0];
                y+=dir[i][1];
            }
            else if(ch=='R')
            {
                ++i;
                i%=4;
            }
            else
            {
                i+=4;
                i--;
                i%=4;
            }
            }   
        }while(i!=0);
        if(x==0&amp;amp;&amp;amp;y==0)
            return true;   
        return false;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不邻接植花&quot;&gt;不邻接植花&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不邻接植花(Flower Planting With No Adjacent)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个无向图中，每个点的出度都不超过3。有四种颜色，给每个点着色，要求有边相连的点颜色不同。&lt;/p&gt;
&lt;p&gt;给出着色方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于每个点出度不超过3，四个颜色，肯定可以有解。暴力枚举即可。由于图的点很多，边少。在寻找和点相连的点时，不要按点遍历，要按边遍历，否则会超时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Solution {
public:
    map&amp;lt;int, map&amp;lt;int, int&amp;gt;&amp;gt; mr;
    vector&amp;lt;int&amp;gt; res;
    int dfs(int index, int N)
    {
        if(index &amp;gt; N)
            return 0;
        for(int color=1;color&amp;lt;=4;++color)
        {
            res[index-1] = color;
            map&amp;lt;int, int&amp;gt; &amp;amp; tmp = mr[index];
            bool flag = false;
            for(auto it=tmp.begin();it!=tmp.end();++it)
            {
                if(res[it-&amp;gt;first-1]==color)
                {
                    flag = true;
                    break;
                }
            }
            if(flag == true)
                continue;
            int ret = dfs(index+1, N);
            if(ret == 0)
                return 0;
        }
        return -1;
    }
    vector&amp;lt;int&amp;gt; gardenNoAdj(int N, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; paths) {
        res.resize(N, 0);
        for(int i=0; i&amp;lt;paths.size(); ++i)
        {
            int x = paths[i][0];
            int y = paths[i][1];
            mr[x][y] = 1;
            mr[y][x] = 1;
        }
        dfs(1, N);
        return res;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分隔数组以得到最大和&quot;&gt;分隔数组以得到最大和&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分隔数组以得到最大和(Partition Array for Maximum Sum)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。&lt;/p&gt;
&lt;p&gt;返回给定数组完成分隔后的最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该问题可以划分为子问题求解。&lt;/p&gt;
&lt;p&gt;设数组有N个元素A[0]A[1]...A[N-1]，sum(i)表示从A[i]~A[N]求解的最大和。&lt;/p&gt;
&lt;p&gt;则sum(i) = max( max(A[i]-A[i+m-1])*m + sum(m) ) 其中i&amp;lt;=m&amp;lt;=k;&lt;/p&gt;
&lt;p&gt;就是每个从i开始到数组结尾的最大和，等于前m个元素单独划分，再加上剩下元素的最大和。这k中划分方案最大的，就是从i开始到数组结尾最大和最大的。&lt;/p&gt;
&lt;p&gt;依次计算到第0个位置结束。&lt;/p&gt;
&lt;p&gt;为了计算统一，会用到sum(n),实际没有这个元素，初始化零计算即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Solution {
public:
    int dp[501]={0};
    int maxSumAfterPartitioning(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) {
        int n = A.size();
            for(int i = n-1; i&amp;gt;=0; --i)
            {
                int ma = 0;
                int j;
                for(j=i;j&amp;lt;i+K &amp;amp;&amp;amp; j &amp;lt; n ;++j)
                {
                    ma = max(ma, A[j]);
                    dp[i] = max(dp[i], ma*(j - i + 1) + dp[j + 1]);
                }
            }
        return dp[0];
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最长重复子串&quot;&gt;最长重复子串&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最长重复子串(Longest Duplicate Substring)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/&quot; class=&quot;uri&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-136/problems/longest-duplicate-substring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出一个字符串 S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。&lt;/p&gt;
&lt;p&gt;返回任何具有最长可能长度的重复子串。（如果 S 不含重复子串，那么答案为 &quot;&quot;。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后缀数组教科书般的例题。&lt;/p&gt;
&lt;p&gt;后缀数组是后缀树的一种变种，能够节省空间。构造的方法有「倍增算法」，「DC3算法」。&lt;/p&gt;
&lt;p&gt;主要思想：&lt;/p&gt;
&lt;p&gt;设字符串为S(1-n)由n个字符组成。则字符串有n个相同后缀的子串。分别为s(1-n),s(2-n),...,s(n-n)。&lt;/p&gt;
&lt;p&gt;然后构建一个SA数组，每个数组存储这些后缀的子串，存储后进行字典序排序。&lt;/p&gt;
&lt;p&gt;最后构造出一个height数组，表示SA数组每个元素和前一个元素相同前缀的字符个数。&lt;/p&gt;
&lt;p&gt;那么，最长重复子串的长度就是height数组的最大值。&lt;/p&gt;
&lt;p&gt;因为最长重复子串一定是两个不同后缀的公共前缀，而且这两个不同后缀的字典序排列后一定是相连的。否则一定有比他更长的。&lt;/p&gt;
&lt;p&gt;所以height的最大值能够找到那两个后缀，然后提取公共前缀就找到答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;namespace SA
{
bool cmp(int *r, int a, int b, int l)
{
    return r[a] == r[b] &amp;amp;&amp;amp; r[a + l] == r[b + l];
}
void da(int str[], int sa[], int rank[], int height[], int n, int m)
{
    n++;
    int i, j, p, *x = t1, *y = t2;
    for (i = 0; i &amp;lt; m; i++)
        c[i] = 0;
    for (i = 0; i &amp;lt; n; i++)
        c[x[i] = str[i]]++;
    for (i = 1; i &amp;lt; m; i++)
        c[i] += c[i - 1];
    for (i = n - 1; i &amp;gt;= 0; i--)
        sa[--c[x[i]]] = i;
    for (j = 1; j &amp;lt;= n; j &amp;lt;&amp;lt;= 1)
    {
        p = 0;
        for (i = n - j; i &amp;lt; n; i++)
            y[p++] = i;
        for (i = 0; i &amp;lt; n; i++)
            if (sa[i] &amp;gt;= j)
                y[p++] = sa[i] - j;
        for (i = 0; i &amp;lt; m; i++)
            c[i] = 0;
        for (i = 0; i &amp;lt; n; i++)
            c[x[y[i]]]++;
        for (i = 1; i &amp;lt; m; i++)
            c[i] += c[i - 1];
        for (i = n - 1; i &amp;gt;= 0; i--)
            sa[--c[x[y[i]]]] = y[i];
        swap(x, y);
        p = 1;
        x[sa[0]] = 0;
        for (i = 1; i &amp;lt; n; i++)
            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;
        if (p &amp;gt;= n)
            break;
        m = p;
    }
    int k = 0;
    n--;
    for (i = 0; i &amp;lt;= n; i++)
        rank[sa[i]] = i;
    for (i = 0; i &amp;lt; n; i++)
    {
        if (k)
            k--;
        j = sa[rank[i] - 1];
        while (str[i + k] == str[j + k])
            k++;
        height[rank[i]] = k;
    }
}
int num_rank[MAXN], height[MAXN];
int num[MAXN];
int sa[MAXN];
} // namespace SA

class Solution
{
  public:
    string longestDupSubstring(string S)
    {
        using namespace SA;
        int pos = 0;
        int len = 0;
        int n = S.length();
        for (int i = 0; i &amp;lt;= n; ++i)
        {
            num[i] = S[i]&amp;amp;0x3f;
        }
        num[n] = 0;
        da(num, sa, num_rank, height, n, 256);
        for (int i = 2; i &amp;lt;= n; ++i)
        {
            if (height[i] &amp;gt; len)
            {
                pos = sa[i];
                len = height[i];
            }
        }
        return S.substr(pos, len);
    }
};&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 14 May 2019 14:11:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>周日的比赛的时候正在外面办事，没有参加。赛后看了下题目，几道题除了表面要考的内容，还是有些能发散扩展的地方。 做题目不是最终目的，通过做题发现知识盲区，去研究学习，才能不断提高。 理论和实际是有关系的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/10864973.html</dc:identifier>
</item>
<item>
<title>死磕 java同步系列之开篇 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/Synchronize.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/Synchronize.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;同步系列，这是彤哥想了好久的名字，本来是准备写锁相关的内容，但是java中的CountDownLatch、Semaphore、CyclicBarrier这些类又不属于锁，它们和锁又有很多共同点，都是为了协同多线程的执行，都是一种同步器，所以这里就借用同步来取名字了，也就是“同步系列”的来源。&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;概览&lt;/h2&gt;
&lt;p&gt;这一篇的内容会比较多，大致包含三大主题：java中的锁、同步器、分布式锁，大致讲的内容如下：&lt;/p&gt;
&lt;p&gt;（1）volatile&lt;/p&gt;
&lt;p&gt;（2）synchronized&lt;/p&gt;
&lt;p&gt;（3）AQS及Condition&lt;/p&gt;
&lt;p&gt;（4）ReentrantLock&lt;/p&gt;
&lt;p&gt;（5）ReentrantReadWriteLock&lt;/p&gt;
&lt;p&gt;（6）StampedLock&lt;/p&gt;
&lt;p&gt;（7）CountDownLatch&lt;/p&gt;
&lt;p&gt;（8）Semaphore&lt;/p&gt;
&lt;p&gt;（9）CyclicBarrier&lt;/p&gt;
&lt;p&gt;（10）Phaser&lt;/p&gt;
&lt;p&gt;（11）Mysql实现分布式锁&lt;/p&gt;
&lt;p&gt;（12）Redis实现分布式锁&lt;/p&gt;
&lt;p&gt;（13）Zookeeper实现分布锁&lt;/p&gt;
&lt;p&gt;这些内容都比较晦涩难懂，网上也有比较多的资料，但往往讲得不够透彻，彤哥会尽量用通俗易懂的语言把这些问题讲清楚。&lt;/p&gt;
&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;关于锁的名词也有很多，彤哥大致整理了下，全部列到这里：&lt;/p&gt;
&lt;p&gt;（1）公平锁/非公平锁&lt;/p&gt;
&lt;p&gt;公平锁，是指按照线程申请的顺序获取锁。&lt;/p&gt;
&lt;p&gt;非公平锁，是指不是按照线程申请的顺序获取锁，有可能后申请的线程反而先获取到锁，假如先来的线程一直获取不到锁，会造成锁饥饿现象。&lt;/p&gt;
&lt;p&gt;ReentrantLock中可以通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。&lt;/p&gt;
&lt;p&gt;synchronized无法指定为公平锁，一直都是非公平锁。&lt;/p&gt;
&lt;p&gt;（2）可重入锁&lt;/p&gt;
&lt;p&gt;可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。&lt;/p&gt;
&lt;p&gt;ReentrantLock和synchronized都是可重入锁。&lt;/p&gt;
&lt;p&gt;（3）独享锁/共享锁&lt;/p&gt;
&lt;p&gt;独享锁，是指锁一次只能被一个线程持有。&lt;/p&gt;
&lt;p&gt;共享锁，是指锁一次可以被多个线程持有。&lt;/p&gt;
&lt;p&gt;ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。&lt;/p&gt;
&lt;p&gt;（4）互斥锁/读写锁&lt;/p&gt;
&lt;p&gt;与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现。&lt;/p&gt;
&lt;p&gt;ReentrantLock和synchronized都是互斥锁&lt;/p&gt;
&lt;p&gt;ReadWriteLock是读写锁&lt;/p&gt;
&lt;p&gt;（5）乐观锁/悲观锁&lt;/p&gt;
&lt;p&gt;悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。&lt;/p&gt;
&lt;p&gt;乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。&lt;/p&gt;
&lt;p&gt;悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。&lt;/p&gt;
&lt;p&gt;（6）分段锁&lt;/p&gt;
&lt;p&gt;分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。&lt;/p&gt;
&lt;p&gt;（7）偏向锁/轻量级锁/重量级锁&lt;/p&gt;
&lt;p&gt;这三个锁主要是针对synchronized进行优化使用的，主要是通过对象监视器在对象头中的字段来表明的。&lt;/p&gt;
&lt;p&gt;偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。&lt;/p&gt;
&lt;p&gt;轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。&lt;/p&gt;
&lt;p&gt;重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。&lt;/p&gt;
&lt;p&gt;（8）自旋锁&lt;/p&gt;
&lt;p&gt;自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU。&lt;/p&gt;
&lt;p&gt;（9）监视器锁&lt;/p&gt;
&lt;p&gt;synchronized的实现方式，使用monitorenter和monitorexit来实现。&lt;/p&gt;
&lt;p&gt;（10）mutex锁&lt;/p&gt;
&lt;p&gt;互斥锁，LockSupport.part()底层是通过mutex实现的。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;招募令：&lt;/p&gt;
&lt;p&gt;因为彤哥本身工作也比较繁忙，很难做到日更，所以这里诚邀广大好友积极投稿，大家一起学习一起进步。&lt;/p&gt;
&lt;p&gt;可在公众号后台给我留言“投稿”，互加好友详细讨论投稿内容。&lt;/p&gt;
&lt;p&gt;当然，其它问题也可在公众号后台留言，不管是生活上、工作上、心理上还是身体上的，欢迎叨扰，留言必回。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 13:56:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>java中的同步器是指什么？ 哪些类是使用AQS实现的？ 分布式环境中怎么实现同步？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/Synchronize.html</dc:identifier>
</item>
<item>
<title>[Python] 利用Python做定时任务, 及时了解互联网动态 - Amd794</title>
<link>http://www.cnblogs.com/Mifen2952277346/p/10864517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mifen2952277346/p/10864517.html</guid>
<description>&lt;p&gt;　　本人因为比较喜欢看漫画和动漫, 所以总会遇到一些问题, 因为订阅的漫画或者动漫太多, 总会忘记自己看到那一章节或者不知道什么时候更新. 故会有这么一个需求, 想记录自己想看的漫画或动画并在其更新的时候第一时间知道, &lt;/p&gt;
&lt;p&gt;当然, 你可以拓展到任何你想关注的, 都可以通过邮件及时推送.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190511213018623-631473497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190511213244636-119260012.png&quot; alt=&quot;&quot; width=&quot;1073&quot; height=&quot;825&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512124336962-520852389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;Python3.6&lt;/li&gt;
&lt;li&gt;第三方库
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip3 install -r requirements.txt -i http://pypi.douban.com/simple
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取全部代码, 请移步:  &lt;a href=&quot;https://github.com/Amd794/Checkupdate.git&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
git clone https://github.com/Amd794/Checkupdate.git 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要用到smtplib发送邮件和email构造邮件.&lt;/p&gt;
&lt;p&gt;SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。&lt;/p&gt;
&lt;p&gt;下面来构造一封完整的邮件, 首先导入需要用到的方法或类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr&lt;p&gt;&lt;code class=&quot;python&quot;&gt;import smtplib&lt;/code&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 我们先构造好头部,  工欲善其事，必先利其器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 发送人
from_name = 'Amd794'
# 发送人邮箱
from_addr = '2952277346@qq.com'
# 发送人密码
password = '你的密码'
# 收件人
to_name = 'Your'
# 收件人邮箱
to_addr = '2952277346@qq.com'
# 邮箱服务
smtp_server = 'smtp.qq.com'&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用到QQ的SMTP服务, 你也可以换成你喜欢的, 比如163, Google 等, 自选&lt;/p&gt;
&lt;p&gt;但是你必须开启邮箱的SMTP服务, 下面来介绍下QQ邮箱打开服务的方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你需要登录你的qq邮箱账号, &lt;a href=&quot;https://mail.qq.com/&quot; target=&quot;_blank&quot;&gt;https://mail.qq.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121130381-913923930.png&quot; alt=&quot;&quot; width=&quot;716&quot; height=&quot;361&quot;/&gt;&lt;/li&gt;
&lt;li&gt;登录后, 点击设置&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121222139-183640890.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后点击账户&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121258032-1619174555.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;滑动滚轮, 找到如下所示, 我是已经开了, 你只需要点击开启, 然后按说明一步一步就行&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121622065-1015943318.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后再点击生成授权码, 将得到的密码, 填到上面的password 字段&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121742045-928854475.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512121758662-1272246148.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样, 头部就构造好了&lt;/p&gt;

&lt;p&gt;然后, 构造发送体&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def _contact(self, msg, from_addr, to_addr, title):
    msg['From'] = self._format_addr('%s &amp;lt;%s&amp;gt;' % (from_name, from_addr))
    msg['To'] = self._format_addr('%s &amp;lt;%s&amp;gt;' % (to_name, to_addr))
    msg['Subject'] = Header(title, 'utf-8').encode()
msg = MIMEText(content, 'plain', 'utf-8')
_contact(msg, from_addr, to_addr, title)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 发送邮件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512122349260-552185946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;思路是通过, 获取云端数据 然后 通过与本地缓存 对比, 得到更新情况&lt;/p&gt;
&lt;p&gt;构造本地数据, 自定义自己想要订阅的漫画, 格式 平台-名称-链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 支持平台 漫画台, 土豪漫画, 腾讯漫画,腾讯视频 对应 Manhuatai Tohomh123 TencentComic TencentVedio
ComecDict = {
    'Manhuatai-武动乾坤': 'https://www.manhuatai.com/wudongqiankun',
    'Manhuatai-斗破苍穹': 'https://www.manhuatai.com/doupocangqiong',
    'Tohomh123-妖神记': 'https://www.tohomh123.com/yaoshenji/',
    'Manhuatai-大主宰': 'https://www.manhuatai.com/dazhuzai',
    'TencentComic-海贼王': 'https://ac.qq.com/Comic/comicInfo/id/505430',
    'Tohomh123-全职法师': 'https://www.tohomh123.com/quanzhifashi/',
    'Tohomh123-永恒至尊': 'https://www.tohomh123.com/yonghengzhizun/',
    'TencentVedio-万界神主': 'https://v.qq.com/x/cover/y0jueuihog64xhb/j0030ajsgq9.html',
    'TencentVedio-斗罗大陆': 'https://v.qq.com/x/cover/m441e3rjq9kwpsc/r0030jqn37g.html',
    'TencentVedio-狐妖小红娘': 'https://v.qq.com/x/cover/0sdnyl7h86atoyt.html',
    'TencentVedio-万界仙踪 第2季' : 'https://v.qq.com/x/cover/7s65u4bg66so7e6/y0030u40wuu.html',
    'TencentVedio-天行九歌' : 'https://v.qq.com/x/cover/rm3tmmat4li8uul/w0030phkr6h.html',
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后检测实现, 部分代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def main():
    # 支持的平台
    paltfromList = {
        'Manhuatai': Manhuatai,  # 漫画台
        'TencentComic': TencentComic,  # 腾讯动漫平台
        'Tohomh123': Tohomh123,  # 土豪漫画平台
        'TencentVedio': TencentVedio,  #  腾讯视频
    }
    with open('datas.json', encoding='utf-8') as fr:  # 读取本地漫画状态
        datas = json.load(fr)
    for key, value in ComecDict.items():
        try:
            paltfrom, key = key.split('-')
            obj = paltfromList.get(paltfrom)().run(value)  # 获取漫画最新更新状态
            if obj:
                content, url = obj
                new_data = content  # 最新章节数据
                old_data = datas.get(key, None)  # 本地章节数据
                if old_data != new_data:  # 判断是否有更新
                    datas[key] = content  # 更新本地章节

                    with open('template.html', encoding='utf-8') as f:
                        tx = f.read().format(url=url, new_data=new_data, old_data=old_data)  # 构造邮件内容

                    SendEmail(content=tx, title='{key} 更新通知'.format(key=key),
                              emtype='htmlcontent').sendEmail()  # 发送邮件, 推送更新

                    with open('datas.json', 'w', encoding='utf-8') as fw:  # 存储更新后的状态
                        json.dump(datas, fw, ensure_ascii=False, indent=4, separators=(', ', ': '))
                else:
                    print('\033[22;35;m {} \033[m 暂无更新, 当前章节: \033[22;35;m {} \033[m'.format(key, old_data))
        except TypeError:
            print('检测{key}失败, 该平台没有{key}, 或者平台配置有误'.format(key=key))
        except Exception:
            SendEmail(content=traceback.format_exc(),
                      title='获取 {key} 时脚本异常通知'.format(key=key)).sendEmail()  # 发送邮件, 脚本异常
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512123233983-5202127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546022/201905/1546022-20190512123310624-1762241543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 14 May 2019 12:50:00 +0000</pubDate>
<dc:creator>Amd794</dc:creator>
<og:description>前言 本人因为比较喜欢看漫画和动漫, 所以总会遇到一些问题, 因为订阅的漫画或者动漫太多, 总会忘记自己看到那一章节或者不知道什么时候更新. 故会有这么一个需求, 想记录自己想看的漫画或动画</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mifen2952277346/p/10864517.html</dc:identifier>
</item>
<item>
<title>Android APK反编译技巧全讲解 - Geeksongs</title>
<link>http://www.cnblogs.com/geeksongs/p/10864200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geeksongs/p/10864200.html</guid>
<description>&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;导言：在我们安卓开发当中，我们不仅需要掌握基础的开发技能，也需要掌握软件的安全技能，这样才可以让我们的软件能够成为一款能够真正可以进行发布的软件，同时也可以让自己的核心技术不会被别人所盗取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先我们应当了解的是，对于反编译我们一共需要三个工具，它们分别是：APKTool,dex2jar,和jd-gui。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;APKTool&lt;/strong&gt;:用于解析apk的res文件以及AndroidManifest.xml文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;dex2jar&lt;/strong&gt;：用于把apk解压后生成的classes.dex文件解析为后缀为jar的文件，与下面的jd-gui工具联合使用则可以得到我们的核心Java代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;jd-gui&lt;/strong&gt;：将上一步所得到的jar文件解析为Java文件，从而得到软件的核心代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这就是反编译的核心流程，凡是没有被MD5算法加密,或者加固过的APK都可以利用这个方法来进行反编译破解。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;第一步.来到官网下载APKtool&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;界面如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401183248190-1737960607.png&quot; alt=&quot;&quot; width=&quot;984&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;我们需要把下载的两个文件都放在同一个文件夹下，这个文件夹可以自己进行选择或者新建，本人这里在E盘下创建了一个androidsafe的文件夹用于保存这个工具，点击第二个链接之后会出现如下界面：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401183712732-1092147533.png&quot; alt=&quot;&quot; width=&quot;1133&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;第二步.将需要进行反编译的文件放到刚刚我们创建好的那个文件夹下&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401183936934-393714729.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;此时我们的E:/androidsafe文件夹下只有这三个文件，同时我们也需要把下载的第二个文件apktool-2.4.0.jar更改成apktool.jar，不然是无法运行这个工具的。同时把需要反编译的apk文件移动到这个文件夹下。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;第三步.开始反编译&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;键盘输入win+r，进入cmd的windows命令行模式。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用cd命令将命令行模式进入刚刚创建的这个文件夹下，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再输入：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apktool d 您拿到这个文件夹下的需要反编译的apk文件名.apk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401184542428-193421620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样我们的反编译过程就完成了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们再来看看刚刚我们所创建的文件夹就会多出一个名为appdebug的文件了&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401184916577-751543390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190401184943806-1417566600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以说是十分成功了。其中的res文件夹是程序当中的所有资源文件，smali文件夹下存放了程序所有的反汇编代码。apktool这个工具主要是用来解析资源res和资源AndroidManifest.xml的，除此之外的，我们还需要另外的工具来解析Java源码，利用下以下两个工具则可以用于解析Java源代码，它们分别是：dex2jar和jd-gui.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;第四步.将apk文件解析为后缀为dex的文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.首先我们把刚刚用于解析的apk文件的后缀改为zip,然后随便用一个你已经安装过的压缩包软件把它解压就可以了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.解压之后你会在解压之后的文件当中发现一个名为：classes.dex的文件，这样就把apk的dex文件得到啦！如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201905/1363478-20190514191312095-1718123338.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;第五步.利用&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;dex2jar工具把dex文件解析成后缀为jar的文件&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;dex2jar的下载网址是：https://bitbucket.org/pxb1988/dex2jar/downloads/&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;1.下载到我们刚刚安装apktool的文件夹下，然后解压，更改解压后的文件名为dex2jar&lt;br/&gt;2.将刚刚所得到的classes.dex文件剪切到dex2jar文件夹下,如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201905/1363478-20190514191845883-1652077490.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.打开命令行cmd模式，利用cd命令将目录切换到&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;dex2jar&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;的文件夹下，同时键入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
d2j-dex2jar.bat classes.dex
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候返回文件夹，立刻就可以看到在classes.dex文件夹下就多了个jar文件了。&lt;/p&gt;
&lt;h2&gt;第六步.将jar文件解析为Java文件&lt;/h2&gt;
&lt;p&gt;下面就来到最激动人心的一步，得到我们的Java文件啦！&lt;/p&gt;
&lt;p&gt;首先下载&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;jd-gui，网址如下：&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/java-decompiler/jd-gui/releases/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里windows版本的就直接下载后解压，解压后点击后缀为exe的可执行文件打开就是了，再将jar文件拖进去就好啦！：&lt;br/&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201905/1363478-20190514194927184-305053228.png&quot; alt=&quot;&quot; width=&quot;1173&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反编译的步骤还是挺简单的，但是如果被加密后再进行反编译难度就大了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 May 2019 11:52:00 +0000</pubDate>
<dc:creator>Geeksongs</dc:creator>
<og:description>导言：在我们安卓开发当中，我们不仅需要掌握基础的开发技能，也需要掌握软件的安全技能，这样才可以让我们的软件能够成为一款能够真正可以进行发布的软件，同时也可以让自己的核心技术不会被别人所盗取。 首先我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geeksongs/p/10864200.html</dc:identifier>
</item>
<item>
<title>与技术无关，但却值得码农们好好读一读的怪书：禅与摩托车维修艺术 - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/10863713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/10863713.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190514180709979-1476311456.jpg&quot; alt=&quot;&quot;/&gt;最近在读《禅与摩托车维修艺术》这本书，说它很奇怪，其实是因为觉得书名很有意思。看书名，很容易被误解成是一本教人修摩托车的教程，事实上它是一本非常经典的哲学书籍，很多大牛都有推介过这本书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;著名的物理学家 霍金 曾这样评价这本书：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“我因为写了一部人们把它和《禅与摩托车维修艺术》相比较的书而感到甚受恭维，我希望拙作（《时间简史》）和《禅与摩托车维修艺术》一样使人们觉得他们不必自处于伟大的智慧及哲学的问题之外”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实不单单是霍金，乔布斯也曾经极力的推崇过这本书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家如果留心就会注意到很多程序员大牛也在自己的一些技术著作或者书单中提到过这本书，我当时看到这个书名就很奇怪，修个摩托车跟程序员有啥关系，为啥这么多大牛都这么崇拜呢。哈哈，现在看过之后，才发现真的是一本很有意思的哲学小说。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;其实这并不是一本非常容易理解的书，尤其是在看第一遍的时候。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这是一本“游记”，讲述的是作者带着儿子的一次摩托车旅行经历，但在游记中穿插了很多作者对自己内心思想的描述，对追求「 良质 」的思考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「 良质 」是这本书的重点，一种说不清道不明，不能用言语文字表达的东西，但又是我们每个人在生活工作中所应追求的境界。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;虽然书名叫做《禅与摩托车维修艺术》，但本书并不讲“禅”。况且如果是一位外国人来讲“禅学”，咱们也不信啊。那作者为什么要取这么个书名呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“禅”是一个哲学概念，表现的大家对内心朴质的探索。而“摩托车维修”又是一门科学知识。作者其实是想在旅行中探索这种内心的主观追求与现实的客观世界之间寻求一种平衡的境界。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;作者希望大家能看到不一样景，能思考着不一样的问题，能悟到不一样的东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如在讲骑摩托车旅行的感受时描述到：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;骑摩托车旅游和其他的方式完全不同。坐在汽车里，你只是局限在一个小空间之内，因为已经习惯了，你意识不到从车窗向外看风景和看电视差不多。你只是个被动的观众，景物只能呆板地从窗外飞驰而过。骑摩托车可就不同了。它没有什么车窗玻璃在面前阻挡你的视野，你会感到自己和大自然紧密地结合在了一起。你就处在景致之中，而不再是观众，你能感受到那种身临其境的震撼。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;span&gt;4.&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;我并不想仓促行事，因为仓促本身就是 20 世纪最要不得的态度，当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这段话简直道出了真谛。如果我们在做一件自己真正关心、真正喜欢、真正享受的事情，我们的内心不会去追求快，我们反而会希望慢起来，享受这个过程，用心的去做。如果我们在仓促行事，说明我们手里虽然在做，但是心里想着别的事情，想赶紧把手头的事情赶紧仓促完成。如果是这样，那何不干脆一开始就不做呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举一个生活中例子，有的朋友会炫耀自己每个月读了多少多少书，看了多少多少文章，为这些数字所自豪。但是那些书是他们用心去看完的吗，还是仓促的翻完的。看书的终极目的到底是在于享受知识获取的过程，还是在于炫耀读过的数量呢。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;「 良质 」到底是什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内心的宁静、全心投入当下、感受幸福。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「 良质 」是一种境界，需要大家自己去悟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者在书中反复思量、反复论证、反复比喻，但终无法用一段文字去定义。不可说，不是不想说，是无法用文字语言去描述，强行去描述，其实也就不是那个东西了。虽然不可说，但又可以用行动去“证”、去“悟”。全情投入到一件事情中，到达禅宗讲到的“物我两忘”的境界，在境界里所产生的那种愉悦感，那种感受也许就是「 良质 」，王阳明也称之为「 致良知 」。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;书中以维修摩托车为题材，认为大多数人对待手头上做的事情是不关心的、浮躁的，所以很麻木、按部就班的按照说明书在进行，也非常容易遇到卡壳儿的问题，卡住了之后，更是不知道如何进入下一步。但具有「 良质 」的境界却是这样：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;一个人在维修摩托车的时候，对车子的了解分分秒秒都在改变，因而得到了全新认识，其中蕴含了更多的良质。维修的人不会受限于传统的做法，因为他有足够理性的基础拒绝这些思想。真实不再是静态的，它不是让你决定是要去奋战还是打退堂鼓的思想，它们是会跟着你成长的思想。所以具有良质的真实，它的本质不再是静态的，而具有爆炸性的威力，一旦你了解了这一点，就永远不会被卡住了。它虽然有形式，但是这种形式可以改变。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果换做程序员的角度，其实我们写程序跟维修摩托车难道有很大不同吗，如果程序员只是为了完成任务，并不是真心关心自己在写的东西，一样会枯燥、一样会乏味。如果我们是用心，用一种具有「 良质 」的境界去对待这份事情，结果可能就会大不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者认为：如果一个人在工作的时候，能够看到良质，而且感觉到它的存在，那么他就是一个懂得关心的人。如果一个人对自己所看到的和手中所做的都细致入微地关心，那么他一定有某些良质的特性。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;7.&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;在所有关乎技艺方面的工作背后，都有一个“道”或类似于“禅”的东西，一通百通。有时，你就得放弃已有的工匠情结，更多地要把自己的理念，思想都糅合在一个物件上，这时技术只是一个副产品罢了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;作者虽然讲的是维修摩托车，但这一段似乎更像是程序员的编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们不能沉迷与编程技术的表面，我们应该去看到代码的背后，用心的去对待这件事情，把自己的思想融入进去，投入你的热忱到编程这件事上，让自己接近「 良质 」，也许这就是为什么无论哪行哪业做到最顶峰的时候都呈现出一副艺术家的气息，不要小瞧编程这件事，码农艺术家多着呢。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;8.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;作者把看世界的角度分为2个认知，一个是「 古典的认知 」、另一个是「 浪漫的认知 」。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;古典的认知认为这个世界是由一些基本形式组成的，而浪漫的认知则是从它的表象来观察。如果你拿一部发动机或是机械图，或是电子仪表给浪漫的人看，他一定不感兴趣，因为他所看到的只是表象，枯燥无味，只是列出一大堆复杂的专有名词、线条和数字，没有让他觉得有趣的事。但是如果你把这些东西拿给一个偏向古典思想的人看，他会仔细地观察，然后就会着迷，因为他看到在这些线条和符号之后是丰富的基本形式。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;作者的这个思想，跟一个我之前看过的叫做「 二元论 」思想很类似。百度百科上是这么解释「 二元论 」：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「 二元论 」认为世界是存在2个实体的，一个是只有广延而不能思维的“物质实体”，另一个是只能思维而不具广延的“精神实体”，二者性质完全不同，各自独立存在和发展，谁也不影响和决定谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是本书的作者明显是反对这种二分法的，他认为这两种认知是可以融合的，并且他认为「 良质 」就是这两种认知的结合体，甚至认为「 良质 」就是「 古典的认知 」与「 浪漫的认知 」的发源地。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;9.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;阅读这类哲学书籍，其实难度挺大的，我自己理解的很浅显。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在读书的时候，是一颗浮躁的心，就更难融入进去，很难理解到书中的思想。但哲学其实存在于每个人的心中，在思考问题和解决问题的时候，大家都会不自主的使用到哲学的理论。所以这本书值得每年翻开读一遍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，就是对《禅与摩托车维修艺术》这本书的一些思考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190514180721555-1944479089.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 May 2019 10:08:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>最近在读《禅与摩托车维修艺术》这本书，说它很奇怪，其实是因为觉得书名很有意思。看书名，很容易被误解成是一本教人修摩托车的教程，事实上它是一本非常经典的哲学书籍，很多大牛都有推介过这本书。 著名的物理学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/10863713.html</dc:identifier>
</item>
<item>
<title>以测量的角度：从中心极限定理到假设检验 - LeslieXong</title>
<link>http://www.cnblogs.com/lesliexong/p/10832939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lesliexong/p/10832939.html</guid>
<description>&lt;p&gt;近来读一篇Paper，研究者利用假设检验来验证两个不同消费者是否一起逛商场。&lt;/p&gt;
&lt;p&gt;同时最近在看 G.H.韦恩堡的《数理统计初级教程》，借着这个机会，所以把假设检验梳理归纳了一下，从测量的角度。个人统计测量水平有限，错漏之处，若有大神指点，不胜感激。&lt;/p&gt;

&lt;h2&gt;一切的基础，高斯分布&lt;/h2&gt;
&lt;p&gt;所有知道数理统计的人，恐怕没有不知道高斯分布（正态分布）的，所以这里直接引维基的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172684/201905/1172684-20190508165605298-1517920293.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172684/201905/1172684-20190508165638137-522161601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/blockquote&gt;
&lt;p&gt;大部分的统计问题，测量问题，包括像最小二乘的平差，都是建立在正态分布的基础上。对于很多非高斯分布， 也有通过某种转化变成到高斯分布来分析。&lt;/p&gt;

&lt;h2&gt;中心极限定理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; 维基的解释为：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.4587155963303&quot;&gt;
&lt;p&gt;&lt;strong&gt;中心极限定理&lt;/strong&gt;是&lt;a title=&quot;概率论&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA&quot;&gt;概率论&lt;/a&gt;中的一组定理。中心极限定理说明，在适当的条件下，大量相互独立&lt;a title=&quot;随机变量&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F&quot;&gt;随机变量&lt;/a&gt;的均值经适当标准化后&lt;a class=&quot;mw-redirect&quot; title=&quot;依分布收敛&quot; href=&quot;https://zh.wikipedia.org/wiki/%E4%BE%9D%E5%88%86%E5%B8%83%E6%94%B6%E6%95%9B&quot;&gt;依分布收敛&lt;/a&gt;于&lt;a title=&quot;正态分布&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83&quot;&gt;正态分布&lt;/a&gt;。这组定理是&lt;a title=&quot;数理统计学&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%AD%A6&quot;&gt;数理统计学&lt;/a&gt;和误差分析的理论基础，指出了大量随机变量之和近似服从正态分布的条件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但《数理统计初级教程》的说法恐怕更好懂：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;  假定等容量的随机样本都从同一无限总体采样，则每一个样本的和构成的新分布渐进正态分布。（而且！！ 原总体分布不一定要是正态分布）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同理根据正态分布的特性，把该定义拓展到对于每个样本的均值构成的新分布，也是渐进正态分布的。 而且该新分布的均值与原总体的均值相同，而该新分布的标准差与原总体的标准差之比为根号N.&lt;/p&gt;

&lt;h2&gt;一个尺子测量的例子&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题的提出：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有一把尺子，用来测量一段距离，大部分人都知道，多测几次取均值是可取的。如果有粗差知识（outlier），可能会进行粗差剔除后取均值。类似于裁判打分去掉最高分，去掉一个最低分。&lt;/p&gt;

&lt;p&gt;那么这个取均值的背后，事实上是基于观测数据仅含有偶然误差，也就是说尺子本身没有系统误差的情况下的最优估计。那么如何判断一把尺子到底有没有系统误差呢？&lt;/p&gt;

&lt;p&gt;自然而然，我们会想到需要一个基准（或者说一个真实值已知的距离，这里叫他基线）然后通过测量该值来对尺子进行检验。具体一点，假如有一根基线长为100cm, 利用一把尺子测量了该基线多次，结果为99，100，101, 101，测量均值u=100.3，那么这个0.3到底是偶然误差（也就说这个尺子可以认为没系统误差，可以拿去测量其他的东西），还是具有系统误差（需要纠偏，比如说每个测量值都减去0.3）呢？&lt;/p&gt;
&lt;p&gt;直观上，0.3/100很小，尺子应该没误差吧。 但是，直觉对科学很重要，仅靠直觉不去量化验证又是不科学的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么统计学的做法是什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，光靠100.3这个值我们其实很难保证说这个尺子就一定没问题，因为你不能通过举正例来证明你的观点。但是话说回来，如果利用反证法，也就说我们假如能够证明没误差的尺子测出来100.3的概率非常小，那么这个尺子几乎是一定有问题，需要再校正的。这其实就是假设检验最基础的intuition.&lt;/p&gt;

&lt;p&gt;而这个intuition放在正态分布里面，反例是什么确定的呢？ 反例就是那些只有极小概率才会发生的值，对应到正态分布概率密度钟型曲线靠近两边的那些取值。 也就是说，假如你告诉我说你这个x~N（100,1），然后我取一个观测值x，结果这个x竟然是很小概率（p&amp;lt;5%）才会发生的值,那么我就不得不怀疑你这个假设的正确性了。对应到尺子的例子，那就是这个正态分布的准确性了（基线长度）或者就得怀疑这个观测值x的取值方法（尺子有系统误差）是不是正确了！！！也就是否认你这个x~N（100, 1）的假设了！&lt;/p&gt;

&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;这是因为正态分布的特征主要由期望和方差决定：&lt;/p&gt;
&lt;p&gt;   1. 这个均值分布的总体期望我们知道，假如方差也知道，那么分布就完全确定了&lt;/p&gt;
&lt;p&gt;   3. 所以在这个均值方差都知道的分布里，我们可以计算某个概率区间的上下限（比如说可以知道落在X1-X2的概率是95%）。&lt;/p&gt;
&lt;p&gt;   4. 那么如果一个样本在X1-X2中，那么我们没理由认为这个尺子有问题（虽然它还是可能有问题，但是我们无法判断它 只能接受它没问题）。而如果落在那5%的区间里（x&amp;lt;X1或者x&amp;gt;X2），我们认为你在逗我吧这么小的概率你也搞到，那肯定是你自己有问题（尺子有系统误差），也就是拒绝接受尺子没问题这个设定，你回去再校正吧。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;再举个例子：你假设你手上的硬币是均匀的，然后你投掷了100次，结果发现90次都是正面，那你敢相信这个假设是对的吗？所以这也牵涉出来，假设检验的目的，在于否定原假设，原假设否定不了我们才接受备选假设。注意是接受了假设，而不是证明了假设。什么意思呢，比如100次投掷里50次正面，符合我们的假设，但是依然没人敢保证这个假设是严格正确的，只能说从统计数据来看没办法证明它是错的，那就暂时认为它是对的吧。&lt;/p&gt;

&lt;p&gt;在这个intuition明白之后，假设检验的流程也明白了：&lt;/p&gt;
&lt;p&gt;1.  确定原假设H0（比如尺子没问题，硬币均匀）, 和备选假设H1（尺子有问题，硬币不均匀）&lt;/p&gt;
&lt;p&gt;2. 确定我们在什么时候会拒绝原假设，通常是0.05 也就是说假如统计数据竟然落在那5%里面，我要拒绝原假设&lt;/p&gt;
&lt;p&gt;3. 在原假设的基础上去探寻该统计数据可能出现的概率，看齐是否小于5%&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么这个intuition如何拓展开呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.  假设可能不是直接针对于分布本身 （统计量的选取，字样的函数，其分布应该已知比如t分布）&lt;/p&gt;
&lt;p&gt;2. 如果抽样的数据本身不是正态分布呢？ ---&amp;gt; 中心极限定理&lt;/p&gt;
&lt;p&gt;3. 如果主体的方差和期望并不已知的情况下如何判断概率呢？&lt;/p&gt;
&lt;p&gt;     这个时候就是利用t-分布这个统计量了：值得注意的是，当子样容量n&amp;gt;=200 用样本方差代替总体方差被认为是严密的，&amp;gt;30时候认为用样本方差代替总体方差进行检验的结果可信（u检验和t检验一致）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中心极限定理： 为什么我们假设尺子没问题的话多测测量的均值满足正态分布？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   首先，这把尺子测量的4次结果，相当于统计中的从总体中（无数把尺子对该基线进行测量的数据总体）抽出来来的一个样本，不难想象，假如总体样本有无限把尺子进行测量，就算尺子本身有系统误差也会有不同的系统误差相互抵消，也就是说总体的期望值为100， 这就是中心极限定理：从大容量的同一总体中抽取等容量的样本，则每一个样本的均值构成的分布趋近于正态分布且期望为总体的期望。&lt;/p&gt;

&lt;p&gt;写到这里突然觉得，还是先看《数理统计初级教程》第十，第十一章后，细看《误差理论与测量平差基础》第十一章来的清楚，作罢作罢。&lt;/p&gt;

&lt;h2&gt;参考：&lt;/h2&gt;




</description>
<pubDate>Tue, 14 May 2019 09:43:00 +0000</pubDate>
<dc:creator>LeslieXong</dc:creator>
<og:description>近来读一篇Paper，研究者利用假设检验来验证两个不同消费者是否一起逛商场。 同时最近在看 G.H.韦恩堡的《数理统计初级教程》，借着这个机会，所以把假设检验梳理归纳了一下，从测量的角度。个人统计测量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lesliexong/p/10832939.html</dc:identifier>
</item>
</channel>
</rss>