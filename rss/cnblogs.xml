<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Gif开发笔记(一)：gif介绍、编译和工程模板 - 红胖子(红模仿)</title>
<link>http://www.cnblogs.com/qq21497936/p/14100745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq21497936/p/14100745.html</guid>
<description>

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  实现gif图片的解码和生成。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;  GIF格式的名称是Graphics Interchange Format的缩写，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。GIF可以被PC和Mactiontosh等多种平台上被支持。&lt;br/&gt;  GIF是一种位图。位图的大致原理是：图片由许多的像素组成，每一个像素都被指定了一种颜色，这些像素综合起来就构成了图片。GIF采用的是Lempel-Zev-Welch（LZW）压缩算法，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用真彩色的场合，那么GIF的表现力就有限了。GIF通常会自带一个调色板，里面存放需要用到的各种颜色。在Web运用中，图像的文件量的大小将会明显地影响到下载的速度，因此我们可以根据GIF带调色板的特性来优化调色板，减少图像使用的颜色数（有些图像用不到的颜色可以舍去），而不影响到图片的质量。&lt;br/&gt;  GIF格式和其他图像格式的最大区别在于，它完全是作为一种公用标准而设计的，由于Compu Serve网络的流行，许多平台都支持GIF格式。Compu Serve通过免费发行格式说明书推广GIF，但要求使用GIF文件格式的软件要包含其版权信息的说明。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;版本&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  GIF具有GIF87a和GIF89a两个版本。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;GIF87a版本是1987年推出的，一个文件存储一个图像，严格不支持透明像素；GIF87a采用LZW压缩算法，它能够在保持图像质量的前提下将图像尺寸压缩百分之二十到二十五。&lt;/li&gt;
&lt;li&gt;GIF89a版本是1989年推出的很有特色的版本，该版本允许一个文件存储多个图像，可实现动画功能，允许某些像素透明。在这个版本中，为GIF文档扩充了图形控制区块、备注、说明、应用程序编程接口4个区块，并提供了对透明色和多帧动画的支持。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;  其中GIF89a在透明、隔行交错和动画GIF方面做出了重大改进。首先是支持透明，GIF89a允许图片中的某些部分不可见。这项特性非常重要，使得我们在某些场合能够利用这样一种特性来使图像的边缘不再呈现出矩形边框，而变成我们想要的任意形状。这些透明区域，可以很方便地在Photoshop、Fireworks中生成并且导出为GIF89a格式的GIF图片来实现。当然，透明并不意味着边框就不再存在事实上，它是存在的，只不过不显示罢了，这样可以使插入的图片和整体网页更加协调。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  GIF格式的图像文件具有如下特点：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;GIF格式图像文件的扩展名是“.gif”。&lt;/li&gt;
&lt;li&gt;对于灰度图像表现最佳。&lt;/li&gt;
&lt;li&gt;具有GIF87a和GIF89a两个版本。&lt;/li&gt;
&lt;li&gt;采用改进的LZW压缩算法处理图像数据。&lt;/li&gt;
&lt;li&gt;调色板数据有通用调色板和局部调色板之分，有不同的颜色取值。&lt;/li&gt;
&lt;li&gt;不支持24bit彩色模式，最多存储256色。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;  图形交换格式（c）是CompuServe Incorporated的版权所有。GIF（sm）是CompuServe Incorporated的服务标记属性。&lt;br/&gt;  该库用可以用于任何需要读/写GIF文件格式的应用程序。&lt;br/&gt;  CSDN:QQ群：1047134658（点击“文件”搜索“giflib”，群内与博文同步更新）&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;步骤一：解压&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020120314390790.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  查看项目的目录结构，其实是linux的，所以应该是使用linux编译，先上msys。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;步骤二：使用mysy重新部署目录结构&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143856641.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;步骤三：引入Qt的mingw32&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;export PATH=$PATH:/mingw530_32/bin
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;步骤四：目录make，错误缺乏cc&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143820616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  make出现错误&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143800413.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  引入CC&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;pre&gt;
&lt;code&gt;export CC=gcc
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143749767.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  继续编译。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;步骤五：出现错误“GifErrorString”&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143725523.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  本来准备解决，结果一看，已经有libgif.a了，所以其实报错的编译可能是其测试的其他demo示例需要依赖（经验之谈）。&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020120314370372.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143633992.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;gifManager.pri&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code&gt;INCLUDEPATH += $$PWD
DEPENDPATH += $$PWD

HEADERS += \
    $$PWD/GifManager.h

SOURCES += \
    $$PWD/GifManager.cpp


# mingw32 版本
INCLUDEPATH += \
        $$PWD/giflib-5.2.1-mingw32/include

LIBS += $$PWD/giflib-5.2.1-mingw32/lib/libgif.a
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void GifManager::testRunEnv()
{
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt;  QString(GifErrorString(D_GIF_SUCCEEDED));
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt;  QString(GifErrorString(D_GIF_ERR_OPEN_FAILED));
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt;  QString(GifErrorString(D_GIF_ERR_READ_FAILED));
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt;  QString(GifErrorString(D_GIF_ERR_NOT_GIF_FILE));
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt;  QString(GifErrorString(D_GIF_ERR_NO_IMAG_DSCR));
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143601508.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;运行结果&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201203143358764.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  对应模板“gifDemo_v1.0.0_基础模板_测试库是否加载成功.rar”。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 08 Dec 2020 00:45:00 +0000</pubDate>
<dc:creator>红胖子(红模仿)</dc:creator>
<og:description>前言 实现gif图片的解码和生成。 Gif 简介 GIF格式的名称是Graphics Interchange Format的缩写，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qq21497936/p/14100745.html</dc:identifier>
</item>
<item>
<title>手写Json解析器学习心得 - 抑菌</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/14100735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/14100735.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4Kicia369ptWGnwyBS6byzsaibkTuvBG6lYJKXfp7jhicjUiby1WoBswWLvAvAldDwmia0zvlAVfgOUT3wk6u1DLyVOQ/0?wx_fmt=png&quot; alt=&quot;噢~从&amp;quot;{&amp;quot;开始，看来是个对象了！&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一周前，老同学阿立给我转了一篇知乎回答，答主说检验一门语言是否掌握的标准是实现一个Json解析器，网易游戏过去的Python入门培训作业之一就是五天时间实现一个Json解析器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/50701819/answer/122610566&quot;&gt;知乎回答---链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该回答对应的问题提及了一个开源的“从零开始的JSON库教程”，恰好我刚开始学习go语言，对Json的理解也仅停留在一种端到端之间交互的数据格式，于是便跟着教程写了一遍，受益良多，至少对我这种编程经验少的人来说十分有帮助，以下是我的学习心得。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/miloyip/json-tutorial&quot;&gt;从零开始的JSON库教程地址---链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liuyj24/easyjson&quot;&gt;自己的实现---链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-测试与重构&quot;&gt;1. 测试与重构&lt;/h3&gt;
&lt;p&gt;其实在刚开始接触编程的时候，也经常听说要给自己的代码写测试，但是一直没有学过相关的方法论，也不知道如何实践，直到在公司实习的时候才慢慢意识到测试的重要性。当时每写完一个功能，导师都会要求我造数据进行测试，从我当时的理解上看，自己写测试用例的目的在于尽量去覆盖用户的各种行为，保证系统运行的稳定性。&lt;/p&gt;
&lt;p&gt;但是在经历了这门Json解析器教程后，我对编写测试用例又有了更进一步的理解。该教程详细地介绍了一种叫TDD的开发模式，中文是测试驱动开发，并从第一单元开始就贯彻执行。&lt;/p&gt;
&lt;p&gt;在我看来，先写测试后进行开发能帮助我们明确我们想要开发的功能，减少我们走弯路的可能性。但有时提前做计划往往不太容易，可能会出现测试不太好写的情况，这个时候我们先把功能开发出来反而会更轻松一些。教程作者也推荐我们在实际开发中两种风格并用，以达到平衡。&lt;/p&gt;
&lt;p&gt;说实话，刚开始看到自己的代码能顺利通过全部测试的时候还蛮有成就感的。但是随着课程的深入，我发现完备的测试不只是给我成就感这么简单，更多的是一种安全感。&lt;/p&gt;
&lt;p&gt;因为随着解析器的功能增加，我们的代码会出现一些通用的模块，为了提高通用性，我们需要进行重构，而完备的单元测试是我们放胆去重构的重要保障。&lt;/p&gt;
&lt;p&gt;另外，由于和教程使用的语言不一样，有些地方需要按自己的理解去写，不能够全盘照搬，许多地方一开始实现得不太周全。我印象最深的地方是一开始我们要解析null，false，true，数字和字符串，这些都是单个功能，各自通过单独的测试用例不会很难。但是当我们要解析数组的时候，由于数组中有多个值，而且还可能有嵌套数组，这个时候就要保证单个值的解析不影响全局的解析。&lt;/p&gt;
&lt;p&gt;我当时在做数组解析的时候遇到了不少的问题，基本都是单值解析的代码不够完善而导致的。还好之前跟着教程写了足够的测试用例，支撑着我把整个数组解析功能写正确，从此爱上写单元测试。&lt;/p&gt;
&lt;h3 id=&quot;2-c语言的魅力&quot;&gt;2. C语言的魅力&lt;/h3&gt;
&lt;p&gt;教程是用标准的C语言写的，作者本身是C/C++的大牛，功力深厚。虽然我对C语言了解不多，但是跟着教程的解释去阅读C代码也没有太大的问题。&lt;/p&gt;
&lt;p&gt;教程关于C语言的知识点很多，比如宏的定义，内存的分配与释放，内存泄漏检测等，最令我赞叹的是作者对指针的运用，太精巧了。虽然Go语言里面也有指针，但是在我做这个教程的过程中，Go的指针更多时候只是用来传址。也由于指针没那么强大，我不太方便像作者一样实现一个通用强大的堆栈，用于暂存Json的解析内容。但Go语言有强大的Slices，用起来也很爽，很方便。&lt;/p&gt;
&lt;p&gt;既然是用不同的语言实现同样的功能，那我们肯定要充分发挥自己所用语言的优势了，这也是我们想通过项目入门一门语言的关键。&lt;/p&gt;

&lt;h3 id=&quot;1-启程&quot;&gt;1. 启程&lt;/h3&gt;
&lt;p&gt;开始的第一章中我最大的收获就是弄清楚了整个解析器的结构。&lt;/p&gt;
&lt;p&gt;在项目的开始阶段，我们首先搭建一个简单测试框架，比如把测试通过的数量，没有通过的数量和出错信息打印出来，方便自己观察测试通过情况。&lt;/p&gt;
&lt;p&gt;然后需要定义好Json解析器的数据结构，一旦数据结构定义好了，软件就完成了一半。这里我们会用一个树状结构来组织我们解析到的数据，每个数据保存在一个节点里，我们要做的就是把这个节点定义出来。&lt;/p&gt;
&lt;p&gt;根据Json协议，Json一共有7种数据类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;object, array, string, number, &quot;true&quot;, &quot;false&quot;, &quot;null&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了分辨一个节点是哪种数据类型，我们需要给节点增加一个type字段，用于标识节点的类型，type的数值我们可以用一个枚举进行维护。同时为各种数据类型准备一个接收的字段（为了方便处理，没有为&lt;code&gt;true/false/null&lt;/code&gt;设置字段）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type EasyValue struct {
        vType int //节点数据类型
        num   float64
        str   []byte
        len   int
        e     []EasyValue
        o     []EasyObj
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据结构搭建好了之后，我们整个解析器的框架就很清晰了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传入一个Json字符串，创建一个根节点，并用解析器进行解析，具体来说就是逐个字符进行分析。&lt;/li&gt;
&lt;li&gt;假设分析出是一个数字，那么就把这个根节点的数字类型设置为数字，并将解析出来的数字放入到节点的num字段中。&lt;/li&gt;
&lt;li&gt;当我们想要获取解析的结果时，只需要根据节点的数据类型到节点相应的字段获取对应的值就好了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是整个Json解析器的思路了，在第一章脑子里奠定了这样的基础后，就有了整体的大局观，后面的章节就是根据各种数据类型进行解析。&lt;/p&gt;
&lt;h3 id=&quot;2-解析数字&quot;&gt;2. 解析数字&lt;/h3&gt;
&lt;p&gt;在解析数字的时候，作者选择了直接调用字符串转数字的库函数，由于库函数的接收域比较宽，有些错误情况需要我们提前做处理，总体来说还是好实现的。&lt;/p&gt;
&lt;p&gt;但是在处理的过程中我却遇到了一个Go语言中比较棘手的问题：在我们调用字符串转数字的库函数时，是有可能出错的，通常会有两种错误，一个是数字非法（这个字符串不是一个数字），另一个是数字溢出。在其他语言中都能够很好地判断错误类型，然后向用户端返回相应的错误码。但是Go语言对错误的处理比较简洁，它只提供了一个error接口，接口中只有一个string字段用于说明错误信息。这意味着如果一个函数里同时抛出两个错误，得通过错误信息来判断发生了什么错误。具体来说就是通过判断一个字符串中是否包含另一个字符串来分辨错误类型，这似乎有点土。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;f, err := strconv.ParseFloat(convStr, 64)
if err != nil {
        if strings.Contains(err.Error(), strconv.ErrRange.Error()) {
                return EASY_PARSE_NUMBER_TOO_BIG
        }
        return EASY_PARSE_INVALID_VALUE
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;谷歌一番后似乎还是没有特别好的解决方案，现有的开源方案和官方给出的方案基本都是对错误进行多一层封装，但这招好像对库函数不太管用。也可能是我刚开始用go语言，阅历比较少，在今后的使用中我得留意一下这个问题。&lt;/p&gt;
&lt;h3 id=&quot;3-解析字符串---4-unicode&quot;&gt;3. 解析字符串 - 4. Unicode&lt;/h3&gt;
&lt;p&gt;接下来到了解析字符串，在这章被作者的一顿指针操作所折服，但是到了自己实现，发现用Go的Slices似乎很简单就实现了，就是不知道性能差得大不大。&lt;/p&gt;
&lt;p&gt;在这章最大的收获是，入门了Unicode编码。以前编程就是一把梭，编码这些知识扫两眼就跳过去了，出了乱码就谷歌解决方案，没有考虑过背后的知识。但在这里得实打实地处理字符的转换，我们的目标是把字符串存储为UTF-8的形式，背后的关系得搞清楚。&lt;/p&gt;
&lt;p&gt;最早的时候用的是ASCII码，ASCII码只有7位，也就是只能表示128个字符。但是世界上的字符太多了，128远远不够，这个时候就出来了Unicode编码。Unicode编码记录了成千上万个字符，但这也意味着它要更多的存储空间，Unicode的转换形式的缩写就是我们常见的UTF，而UTF-8就是说把Unicode以8位为一个单元进行存储。&lt;/p&gt;
&lt;p&gt;有了这些前置知识之后，我们就需要对字符串中的Unicode编码进行转换，具体的过程是把Unicode字符转换为对应的码元（十六进制数），然后把十六进制数编码成UTF-8的形式。&lt;/p&gt;
&lt;p&gt;按照教程做下来对编码也有了初步的认识，感觉良好，这估计就是知识的乐趣吧&lt;code&gt;^_^&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-解析数组---6-解析对象&quot;&gt;5. 解析数组 - 6. 解析对象&lt;/h3&gt;
&lt;p&gt;到了做解析数组和对象功能时，我感受到了递归的力量，这可能就是作者称之为递归下降解析器的原因吧。&lt;/p&gt;
&lt;p&gt;但是在这个部分，我最大的收获是深度体会到了单元测试的好处。当解析数组的时候，我们很可能需要对多个类型的值进行解析，这个时候就把之前单独实现的解析功能给串起来了。&lt;/p&gt;
&lt;p&gt;比如说这样一个字符串：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&quot;[123,null,\&quot;abc\&quot;,[1,2,3]]&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先需要解析&lt;code&gt;123&lt;/code&gt;，然后解析&lt;code&gt;null&lt;/code&gt;，在我们解析完&lt;code&gt;123&lt;/code&gt;的时候，指针应该来到&lt;code&gt;,&lt;/code&gt;的位置，通过&lt;code&gt;,&lt;/code&gt;进行划分后再继续下一个值的解析。记得当时我在解析单个值的时候没有处理好指针的位置，导致整个数组解析失败了，不过这也加深了我对整个Json字符串解析过程的理解。&lt;/p&gt;
&lt;p&gt;至此整个Json解析器的功能已经基本完成，后面两个小节是关于生成器和解析对象访问及其他功能的。&lt;/p&gt;

&lt;p&gt;这个教程是用C语言写的，作者用了很多C语言的特性，能很好地提高性能，而我刚入门Go语言，对Go的特性了解甚少，可能在一些地方没有用更适合Go语言的处理方式去处理。&lt;/p&gt;
&lt;p&gt;而在我们日常的开发中，通常会这么用Json：把一个自定义的数据结构转化成Json串，或者是把Json串转换为我们自定义的结构，目前我还没有实现这样的功能。而对于这样的功能，Go语言给予了原生支持。&lt;/p&gt;
&lt;p&gt;我看了一下Go原生解析Json的源码，在解析的思路上和教程是有很多相通之处的。比较大的区别是：在我们手写的Json解析器中，我们把解析后的数据存储放我们自定义的节点结构中。而在Go语言中，由于Json的使用场景常常和结构体相关联，Go语言会把解析出来的数值通过反射直接赋给相应的结构体，这么一来省去了自建数据结构的步骤。&lt;/p&gt;
&lt;p&gt;最后非常感谢这个教程，让我对Json的解析有了初步的认识，对测试与重构有了更深的理解，同时也达到了自己的初衷，能熟悉地使用Go语言写分支循环判断了。但我知道Go语言的魅力不在于此，还有很多特性等待着我去学习，继续加油~&lt;/p&gt;
</description>
<pubDate>Tue, 08 Dec 2020 00:39:00 +0000</pubDate>
<dc:creator>抑菌</dc:creator>
<og:description>一. 介绍 一周前，老同学阿立给我转了一篇知乎回答，答主说检验一门语言是否掌握的标准是实现一个Json解析器，网易游戏过去的Python入门培训作业之一就是五天时间实现一个Json解析器。 知乎回答</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tanshaoshenghao/p/14100735.html</dc:identifier>
</item>
<item>
<title>SQL Server 批量插入数据方案 SqlBulkCopy 的简单封装，让批量插入更方便 - NewAI</title>
<link>http://www.cnblogs.com/liuzhenliang/p/SqlBulkCopyComponents.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhenliang/p/SqlBulkCopyComponents.html</guid>
<description>&lt;p&gt;SQL Server 批量插入数据方案 SqlBulkCopy 的简单封装，让批量插入更方便&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;248.99858892075&quot;&gt;

&lt;ul&gt;&lt;li&gt;关于 &lt;code&gt;SqlServer&lt;/code&gt; 批量插入的方式，有三种比较常用的插入方式，&lt;code&gt;Insert&lt;/code&gt;、&lt;code&gt;BatchInsert&lt;/code&gt;、&lt;code&gt;SqlBulkCopy&lt;/code&gt;,下面我们对比以下三种方案的速度&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1普通的insert插入方法&quot;&gt;1.普通的&lt;code&gt;Insert&lt;/code&gt;插入方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static void Insert(IEnumerable&amp;lt;Person&amp;gt; persons)
{
    using (var con = new SqlConnection(&quot;Server=.;Database=DemoDataBase;User ID=sa;Password=8888;&quot;))
    {
        con.Open();
        foreach (var person in persons)
        {
            using (var com = new SqlCommand(
                &quot;INSERT INTO dbo.Person(Id,Name,Age,CreateTime,Sex)VALUES(@Id,@Name,@Age,@CreateTime,@Sex)&quot;,
                con))
            {
                com.Parameters.AddRange(new[]
                {
                    new SqlParameter(&quot;@Id&quot;, SqlDbType.BigInt) {Value = person.Id},
                    new SqlParameter(&quot;@Name&quot;, SqlDbType.VarChar, 64) {Value = person.Name},
                    new SqlParameter(&quot;@Age&quot;, SqlDbType.Int) {Value = person.Age},
                    new SqlParameter(&quot;@CreateTime&quot;, SqlDbType.DateTime)
                        {Value = person.CreateTime ?? (object) DBNull.Value},
                    new SqlParameter(&quot;@Sex&quot;, SqlDbType.Int) {Value = (int)person.Sex},
                });
                com.ExecuteNonQuery();
            }
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2拼接batchinsert插入语句&quot;&gt;2.拼接&lt;code&gt;BatchInsert&lt;/code&gt;插入语句&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static void BatchInsert(Person[] persons)
{
    using (var con = new SqlConnection(&quot;Server=.;Database=DemoDataBase;User ID=sa;Password=8888;&quot;))
    {
        con.Open();
        var pageCount = (persons.Length - 1) / 1000 + 1;
        for (int i = 0; i &amp;lt; pageCount; i++)
        {
            var personList = persons.Skip(i * 1000).Take(1000).ToArray();
            var values = personList.Select(p =&amp;gt;
                $&quot;({p.Id},'{p.Name}',{p.Age},{(p.CreateTime.HasValue ? $&quot;'{p.CreateTime:yyyy-MM-dd HH:mm:ss}'&quot; : &quot;NULL&quot;)},{(int) p.Sex})&quot;);
            var insertSql =
                $&quot;INSERT INTO dbo.Person(Id,Name,Age,CreateTime,Sex)VALUES{string.Join(&quot;,&quot;, values)}&quot;;
            using (var com = new SqlCommand(insertSql, con))
            {
                com.ExecuteNonQuery();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3sqlbulkcopy插入方案&quot;&gt;3.&lt;code&gt;SqlBulkCopy&lt;/code&gt;插入方案&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static void BulkCopy(IEnumerable&amp;lt;Person&amp;gt; persons)
{
    using (var con = new SqlConnection(&quot;Server=.;Database=DemoDataBase;User ID=sa;Password=8888;&quot;))
    {
        con.Open();
        var table = new DataTable();
        table.Columns.AddRange(new []
        {
            new DataColumn(&quot;Id&quot;, typeof(long)), 
            new DataColumn(&quot;Name&quot;, typeof(string)), 
            new DataColumn(&quot;Age&quot;, typeof(int)), 
            new DataColumn(&quot;CreateTime&quot;, typeof(DateTime)), 
            new DataColumn(&quot;Sex&quot;, typeof(int)), 
        });
        foreach (var p in persons)
        {
            table.Rows.Add(new object[] {p.Id, p.Name, p.Age, p.CreateTime, (int) p.Sex});
        }

        using (var copy = new SqlBulkCopy(con))
        {
            copy.DestinationTableName = &quot;Person&quot;;
            copy.WriteToServer(table);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3三种方案速度对比&quot;&gt;3.三种方案速度对比&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;
&lt;td&gt;1千条&lt;/td&gt;
&lt;td&gt;145.4351ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BatchInsert&lt;/td&gt;
&lt;td&gt;1千条&lt;/td&gt;
&lt;td&gt;103.9061ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlBulkCopy&lt;/td&gt;
&lt;td&gt;1千条&lt;/td&gt;
&lt;td&gt;7.021ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;
&lt;td&gt;1万条&lt;/td&gt;
&lt;td&gt;1501.326ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BatchInsert&lt;/td&gt;
&lt;td&gt;1万条&lt;/td&gt;
&lt;td&gt;850.6274ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlBulkCopy&lt;/td&gt;
&lt;td&gt;1万条&lt;/td&gt;
&lt;td&gt;30.5129ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Insert&lt;/td&gt;
&lt;td&gt;10万条&lt;/td&gt;
&lt;td&gt;13875.4934ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BatchInsert&lt;/td&gt;
&lt;td&gt;10万条&lt;/td&gt;
&lt;td&gt;8278.9056ms&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SqlBulkCopy&lt;/td&gt;
&lt;td&gt;10万条&lt;/td&gt;
&lt;td&gt;314.8402ms&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;两者插入效率对比，&lt;code&gt;Insert&lt;/code&gt;明显比&lt;code&gt;SqlBulkCopy&lt;/code&gt;要慢太多，大概20~40倍性能差距，下面我们将&lt;code&gt;SqlBulkCopy&lt;/code&gt;封装一下，让批量插入更加方便&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1方法介绍&quot;&gt;1.方法介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;批量插入扩展方法签名&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;方法参数&lt;/th&gt;
&lt;th&gt;介绍&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BulkCopy&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;同步的批量插入方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;SqlConnection connection&lt;/td&gt;
&lt;td&gt;sql server 连接对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;IEnumerable&amp;lt;T&amp;gt; source&lt;/td&gt;
&lt;td&gt;需要批量插入的数据源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;string tableName = null&lt;/td&gt;
&lt;td&gt;插入表名称【为NULL默认为实体名称】&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;int bulkCopyTimeout = 30&lt;/td&gt;
&lt;td&gt;批量插入超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td/&gt;
&lt;td&gt;int batchSize = 0&lt;/td&gt;
&lt;td&gt;写入数据库一批数量【如果为0代表全部一次性插入】最合适数量【这取决于您的环境，尤其是行数和网络延迟。就个人而言，我将从BatchSize属性设置为1000行开始，然后看看其性能如何。如果可行，那么我将使行数加倍（例如增加到2000、4000等），直到性能下降或超时。否则，如果超时发生在1000，那么我将行数减少一半（例如500），直到它起作用为止。】&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;SqlBulkCopyOptions options = SqlBulkCopyOptions.Default&lt;/td&gt;
&lt;td&gt;批量复制参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;SqlTransaction externalTransaction = null&lt;/td&gt;
&lt;td&gt;执行的事务对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BulkCopyAsync&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;异步的批量插入方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;SqlConnection connection&lt;/td&gt;
&lt;td&gt;sql server 连接对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;IEnumerable&amp;lt;T&amp;gt; source&lt;/td&gt;
&lt;td&gt;需要批量插入的数据源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;string tableName = null&lt;/td&gt;
&lt;td&gt;插入表名称【为NULL默认为实体名称】&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;td&gt;int bulkCopyTimeout = 30&lt;/td&gt;
&lt;td&gt;批量插入超时时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td/&gt;
&lt;td&gt;int batchSize = 0&lt;/td&gt;
&lt;td&gt;写入数据库一批数量【如果为0代表全部一次性插入】最合适数量【这取决于您的环境，尤其是行数和网络延迟。就个人而言，我将从BatchSize属性设置为1000行开始，然后看看其性能如何。如果可行，那么我将使行数加倍（例如增加到2000、4000等），直到性能下降或超时。否则，如果超时发生在1000，那么我将行数减少一半（例如500），直到它起作用为止。】&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;SqlBulkCopyOptions options = SqlBulkCopyOptions.Default&lt;/td&gt;
&lt;td&gt;批量复制参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td/&gt;
&lt;td&gt;SqlTransaction externalTransaction = null&lt;/td&gt;
&lt;td&gt;执行的事务对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;这个方法主要解决了两个问题：
&lt;ul&gt;&lt;li&gt;免去了手动构建&lt;code&gt;DataTable&lt;/code&gt;或者&lt;code&gt;IDataReader&lt;/code&gt;接口实现类，手动构建的转换比较难以维护，如果修改字段就得把这些地方都进行修改，特别是还需要将枚举类型特殊处理，转换成他的基础类型（默认&lt;code&gt;int&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不用亲自创建&lt;code&gt;SqlBulkCopy&lt;/code&gt;对象，和配置数据库列的映射，和一些属性的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;此方案也是在我公司中使用，以满足公司的批量插入数据的需求，例如第三方的对账数据&lt;/li&gt;
&lt;li&gt;此方法使用的是&lt;code&gt;Expression&lt;/code&gt;动态生成数据转换函数，其效率和手写的原生代码差不多，和原生手写代码相比，多余的转换损失很小【最大的性能损失都是在&lt;code&gt;值类型&lt;/code&gt;拆装箱上】&lt;/li&gt;
&lt;li&gt;此方案和其他网上的方案有些不同的是：不是将&lt;code&gt;List&lt;/code&gt;先转换成&lt;code&gt;DataTable&lt;/code&gt;，然后写入&lt;code&gt;SqlBulkCopy&lt;/code&gt;的，而是使用一个实现&lt;code&gt;IDataReader&lt;/code&gt;的读取器包装&lt;code&gt;List&lt;/code&gt;，每往&lt;code&gt;SqlBulkCopy&lt;/code&gt;插入一行数据才会转换一行数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;IDataReader&lt;/code&gt;方案和&lt;code&gt;DataTable&lt;/code&gt;方案相比优点&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;效率高：&lt;code&gt;DataTable&lt;/code&gt;方案需要先完全转换后，才能交由&lt;code&gt;SqlBulkCopy&lt;/code&gt;写入数据库，而&lt;code&gt;IDataReader&lt;/code&gt;方案可以边转换边交给&lt;code&gt;SqlBulkCopy&lt;/code&gt;写入数据库（&lt;strong&gt;例如：10万数据插入速度可提升30%&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;占用内存少：&lt;code&gt;DataTable&lt;/code&gt;方案需要先完全转换后，才能交由&lt;code&gt;SqlBulkCopy&lt;/code&gt;写入数据库，需要占用大量内存，而&lt;code&gt;IDataReader&lt;/code&gt;方案可以边转换边交给&lt;code&gt;SqlBulkCopy&lt;/code&gt;写入数据库，无须占用过多内存&lt;/li&gt;
&lt;li&gt;强大：因为是边写入边转换，而且&lt;code&gt;EnumerableReader&lt;/code&gt;传入的是一个迭代器，可以实现持续插入数据的效果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2实现原理&quot;&gt;2.实现原理&lt;/h2&gt;
&lt;h3 id=&quot;①-实体model与表映射&quot;&gt;① 实体Model与表映射&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据库表代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE [dbo].[Person](
        [Id] [BIGINT] NOT NULL,
        [Name] [VARCHAR](64) NOT NULL,
        [Age] [INT] NOT NULL,
        [CreateTime] [DATETIME] NULL,
        [Sex] [INT] NOT NULL,
PRIMARY KEY CLUSTERED 
(
        [Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实体类代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    public long Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public DateTime? CreateTime { get; set; }
    public Gender Sex { get; set; }
}

public enum Gender
{
    Man = 0,
    Woman = 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建字段映射【如果没有此字段映射会导致数据填错位置，如果类型不对还会导致报错】【因为：没有此字段映射默认是按照列序号对应插入的】&lt;/li&gt;
&lt;li&gt;创建映射使用的&lt;code&gt;SqlBulkCopy&lt;/code&gt;类型的&lt;code&gt;ColumnMappings&lt;/code&gt;属性来完成，数据列与数据库中列的映射&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//创建批量插入对象
using (var copy = new SqlBulkCopy(connection, options, externalTransaction))
{
    foreach (var column in ModelToDataTable&amp;lt;TModel&amp;gt;.Columns)
    {
        //创建字段映射
        copy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;②-实体转换成数据行&quot;&gt;② 实体转换成数据行&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将数据转换成数据行采用的是：&lt;code&gt;反射&lt;/code&gt;+&lt;code&gt;Expression&lt;/code&gt;来完成
&lt;ul&gt;&lt;li&gt;其中&lt;code&gt;反射&lt;/code&gt;是用于获取编写&lt;code&gt;Expression&lt;/code&gt;所需程序类，属性等信息&lt;/li&gt;
&lt;li&gt;其中&lt;code&gt;Expression&lt;/code&gt;是用于生成高效转换函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其中&lt;code&gt;ModelToDataTable&amp;lt;TModel&amp;gt;&lt;/code&gt;类型利用了静态泛型类特性，实现泛型参数的缓存效果&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;ModelToDataTable&amp;lt;TModel&amp;gt;&lt;/code&gt;的静态构造函数中，生成转换函数，获取需要转换的属性信息，并存入静态只读字段中，完成缓存&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;③-使用idatareader插入数据的重载&quot;&gt;③ 使用IDataReader插入数据的重载&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;EnumerableReader&lt;/code&gt;是实现了&lt;code&gt;IDataReader&lt;/code&gt;接口的读取类，用于将模型对象，在迭代器中读取出来，并转换成数据行，可供&lt;code&gt;SqlBulkCopy&lt;/code&gt;读取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SqlBulkCopy&lt;/code&gt;只会调用三个方法：&lt;code&gt;GetOrdinal&lt;/code&gt;、&lt;code&gt;Read&lt;/code&gt;、&lt;code&gt;GetValue&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;其中&lt;code&gt;GetOrdinal&lt;/code&gt;只会在首行读取每个列所代表序号【需要填写：&lt;code&gt;SqlBulkCopy&lt;/code&gt;类型的&lt;code&gt;ColumnMappings&lt;/code&gt;属性】&lt;/li&gt;
&lt;li&gt;其中&lt;code&gt;Read&lt;/code&gt;方法是迭代到下一行，并调用&lt;code&gt;ModelToDataTable&amp;lt;TModel&amp;gt;.ToRowData.Invoke()&lt;/code&gt;来将模型对象转换成数据行&lt;code&gt;object[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其中&lt;code&gt;GetValue&lt;/code&gt;方法是获取当前行指定下标位置的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3完整代码&quot;&gt;3.完整代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;扩展方法类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public static class SqlConnectionExtension
    {
        /// &amp;lt;summary&amp;gt;
        /// 批量复制
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModel&quot;&amp;gt;插入的模型对象&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;需要批量插入的数据源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;connection&quot;&amp;gt;数据库连接对象&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;tableName&quot;&amp;gt;插入表名称【为NULL默认为实体名称】&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;bulkCopyTimeout&quot;&amp;gt;插入超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;batchSize&quot;&amp;gt;写入数据库一批数量【如果为0代表全部一次性插入】最合适数量【这取决于您的环境，尤其是行数和网络延迟。就个人而言，我将从BatchSize属性设置为1000行开始，然后看看其性能如何。如果可行，那么我将使行数加倍（例如增加到2000、4000等），直到性能下降或超时。否则，如果超时发生在1000，那么我将行数减少一半（例如500），直到它起作用为止。】&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;options&quot;&amp;gt;批量复制参数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;externalTransaction&quot;&amp;gt;执行的事务对象&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;插入数量&amp;lt;/returns&amp;gt;
        public static int BulkCopy&amp;lt;TModel&amp;gt;(this SqlConnection connection,
            IEnumerable&amp;lt;TModel&amp;gt; source,
            string tableName = null,
            int bulkCopyTimeout = 30,
            int batchSize = 0,
            SqlBulkCopyOptions options = SqlBulkCopyOptions.Default,
            SqlTransaction externalTransaction = null)
        {
            //创建读取器
            using (var reader = new EnumerableReader&amp;lt;TModel&amp;gt;(source))
            {
                //创建批量插入对象
                using (var copy = new SqlBulkCopy(connection, options, externalTransaction))
                {
                    //插入的表
                    copy.DestinationTableName = tableName ?? typeof(TModel).Name;
                    //写入数据库一批数量
                    copy.BatchSize = batchSize;
                    //超时时间
                    copy.BulkCopyTimeout = bulkCopyTimeout;
                    //创建字段映射【如果没有此字段映射会导致数据填错位置，如果类型不对还会导致报错】【因为：没有此字段映射默认是按照列序号对应插入的】
                    foreach (var column in ModelToDataTable&amp;lt;TModel&amp;gt;.Columns)
                    {
                        //创建字段映射
                        copy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                    }
                    //将数据批量写入数据库
                    copy.WriteToServer(reader);
                    //返回插入数据数量
                    return reader.Depth;
                }
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 批量复制-异步
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModel&quot;&amp;gt;插入的模型对象&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;需要批量插入的数据源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;connection&quot;&amp;gt;数据库连接对象&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;tableName&quot;&amp;gt;插入表名称【为NULL默认为实体名称】&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;bulkCopyTimeout&quot;&amp;gt;插入超时时间&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;batchSize&quot;&amp;gt;写入数据库一批数量【如果为0代表全部一次性插入】最合适数量【这取决于您的环境，尤其是行数和网络延迟。就个人而言，我将从BatchSize属性设置为1000行开始，然后看看其性能如何。如果可行，那么我将使行数加倍（例如增加到2000、4000等），直到性能下降或超时。否则，如果超时发生在1000，那么我将行数减少一半（例如500），直到它起作用为止。】&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;options&quot;&amp;gt;批量复制参数&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;externalTransaction&quot;&amp;gt;执行的事务对象&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;插入数量&amp;lt;/returns&amp;gt;
        public static async Task&amp;lt;int&amp;gt; BulkCopyAsync&amp;lt;TModel&amp;gt;(this SqlConnection connection,
            IEnumerable&amp;lt;TModel&amp;gt; source,
            string tableName = null,
            int bulkCopyTimeout = 30,
            int batchSize = 0,
            SqlBulkCopyOptions options = SqlBulkCopyOptions.Default,
            SqlTransaction externalTransaction = null)
        {
            //创建读取器
            using (var reader = new EnumerableReader&amp;lt;TModel&amp;gt;(source))
            {
                //创建批量插入对象
                using (var copy = new SqlBulkCopy(connection, options, externalTransaction))
                {
                    //插入的表
                    copy.DestinationTableName = tableName ?? typeof(TModel).Name;
                    //写入数据库一批数量
                    copy.BatchSize = batchSize;
                    //超时时间
                    copy.BulkCopyTimeout = bulkCopyTimeout;
                    //创建字段映射【如果没有此字段映射会导致数据填错位置，如果类型不对还会导致报错】【因为：没有此字段映射默认是按照列序号对应插入的】
                    foreach (var column in ModelToDataTable&amp;lt;TModel&amp;gt;.Columns)
                    {
                        //创建字段映射
                        copy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                    }
                    //将数据批量写入数据库
                    await copy.WriteToServerAsync(reader);
                    //返回插入数据数量
                    return reader.Depth;
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;封装的迭代器数据读取器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    /// &amp;lt;summary&amp;gt;
    /// 迭代器数据读取器
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;TModel&quot;&amp;gt;模型类型&amp;lt;/typeparam&amp;gt;
    public class EnumerableReader&amp;lt;TModel&amp;gt; : IDataReader
    {
        /// &amp;lt;summary&amp;gt;
        /// 实例化迭代器读取对象
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;模型源&amp;lt;/param&amp;gt;
        public EnumerableReader(IEnumerable&amp;lt;TModel&amp;gt; source)
        {
            _source = source ?? throw new ArgumentNullException(nameof(source));
            _enumerable = source.GetEnumerator();
        }

        private readonly IEnumerable&amp;lt;TModel&amp;gt; _source;
        private readonly IEnumerator&amp;lt;TModel&amp;gt; _enumerable;
        private object[] _currentDataRow = Array.Empty&amp;lt;object&amp;gt;();
        private int _depth;
        private bool _release;

        public void Dispose()
        {
            _release = true;
            _enumerable.Dispose();
        }

        public int GetValues(object[] values)
        {
            if (values == null) throw new ArgumentNullException(nameof(values));
            var length = Math.Min(_currentDataRow.Length, values.Length);
            Array.Copy(_currentDataRow, values, length);
            return length;
        }

        public int GetOrdinal(string name)
        {
            for (int i = 0; i &amp;lt; ModelToDataTable&amp;lt;TModel&amp;gt;.Columns.Count; i++)
            {
                if (ModelToDataTable&amp;lt;TModel&amp;gt;.Columns[i].ColumnName == name) return i;
            }

            return -1;
        }

        public long GetBytes(int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length)
        {
            if (dataIndex &amp;lt; 0) throw new Exception($&quot;起始下标不能小于0！&quot;);
            if (bufferIndex &amp;lt; 0) throw new Exception(&quot;目标缓冲区起始下标不能小于0！&quot;);
            if (length &amp;lt; 0) throw new Exception(&quot;读取长度不能小于0！&quot;);
            var numArray = (byte[])GetValue(ordinal);
            if (buffer == null) return numArray.Length;
            if (buffer.Length &amp;lt;= bufferIndex) throw new Exception(&quot;目标缓冲区起始下标不能大于目标缓冲区范围！&quot;);
            var freeLength = Math.Min(numArray.Length - bufferIndex, length);
            if (freeLength &amp;lt;= 0) return 0;
            Array.Copy(numArray, dataIndex, buffer, bufferIndex, length);
            return freeLength;
        }

        public long GetChars(int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length)
        {
            if (dataIndex &amp;lt; 0) throw new Exception($&quot;起始下标不能小于0！&quot;);
            if (bufferIndex &amp;lt; 0) throw new Exception(&quot;目标缓冲区起始下标不能小于0！&quot;);
            if (length &amp;lt; 0) throw new Exception(&quot;读取长度不能小于0！&quot;);
            var numArray = (char[])GetValue(ordinal);
            if (buffer == null) return numArray.Length;
            if (buffer.Length &amp;lt;= bufferIndex) throw new Exception(&quot;目标缓冲区起始下标不能大于目标缓冲区范围！&quot;);
            var freeLength = Math.Min(numArray.Length - bufferIndex, length);
            if (freeLength &amp;lt;= 0) return 0;
            Array.Copy(numArray, dataIndex, buffer, bufferIndex, length);
            return freeLength;
        }

        public bool IsDBNull(int i)
        {
            var value = GetValue(i);
            return value == null || value is DBNull;
        }
        public bool NextResult()
        {
            //移动到下一个元素
            if (!_enumerable.MoveNext()) return false;
            //行层+1
            Interlocked.Increment(ref _depth);
            //得到数据行
            _currentDataRow = ModelToDataTable&amp;lt;TModel&amp;gt;.ToRowData.Invoke(_enumerable.Current);
            return true;
        }

        public byte GetByte(int i) =&amp;gt; (byte)GetValue(i);
        public string GetName(int i) =&amp;gt; ModelToDataTable&amp;lt;TModel&amp;gt;.Columns[i].ColumnName;
        public string GetDataTypeName(int i) =&amp;gt; ModelToDataTable&amp;lt;TModel&amp;gt;.Columns[i].DataType.Name;
        public Type GetFieldType(int i) =&amp;gt; ModelToDataTable&amp;lt;TModel&amp;gt;.Columns[i].DataType;
        public object GetValue(int i) =&amp;gt; _currentDataRow[i];
        public bool GetBoolean(int i) =&amp;gt; (bool)GetValue(i);
        public char GetChar(int i) =&amp;gt; (char)GetValue(i);
        public Guid GetGuid(int i) =&amp;gt; (Guid)GetValue(i);
        public short GetInt16(int i) =&amp;gt; (short)GetValue(i);
        public int GetInt32(int i) =&amp;gt; (int)GetValue(i);
        public long GetInt64(int i) =&amp;gt; (long)GetValue(i);
        public float GetFloat(int i) =&amp;gt; (float)GetValue(i);
        public double GetDouble(int i) =&amp;gt; (double)GetValue(i);
        public string GetString(int i) =&amp;gt; (string)GetValue(i);
        public decimal GetDecimal(int i) =&amp;gt; (decimal)GetValue(i);
        public DateTime GetDateTime(int i) =&amp;gt; (DateTime)GetValue(i);
        public IDataReader GetData(int i) =&amp;gt; throw new NotSupportedException();
        public int FieldCount =&amp;gt; ModelToDataTable&amp;lt;TModel&amp;gt;.Columns.Count;
        public object this[int i] =&amp;gt; GetValue(i);
        public object this[string name] =&amp;gt; GetValue(GetOrdinal(name));
        public void Close() =&amp;gt; Dispose();
        public DataTable GetSchemaTable() =&amp;gt; ModelToDataTable&amp;lt;TModel&amp;gt;.ToDataTable(_source);
        public bool Read() =&amp;gt; NextResult();
        public int Depth =&amp;gt; _depth;
        public bool IsClosed =&amp;gt; _release;
        public int RecordsAffected =&amp;gt; 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模型对象转数据行工具类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    /// &amp;lt;summary&amp;gt;
    /// 对象转换成DataTable转换类
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;TModel&quot;&amp;gt;泛型类型&amp;lt;/typeparam&amp;gt;
    public static class ModelToDataTable&amp;lt;TModel&amp;gt;
    {
        static ModelToDataTable()
        {
            //如果需要剔除某些列可以修改这段代码
            var propertyList = typeof(TModel).GetProperties().Where(w =&amp;gt; w.CanRead).ToArray();
            Columns = new ReadOnlyCollection&amp;lt;DataColumn&amp;gt;(propertyList
                .Select(pr =&amp;gt; new DataColumn(pr.Name, GetDataType(pr.PropertyType))).ToArray());
            //生成对象转数据行委托
            ToRowData = BuildToRowDataDelegation(typeof(TModel), propertyList);
        }

        /// &amp;lt;summary&amp;gt;
        /// 构建转换成数据行委托
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;传入类型&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;propertyList&quot;&amp;gt;转换的属性&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换数据行委托&amp;lt;/returns&amp;gt;
        private static Func&amp;lt;TModel, object[]&amp;gt; BuildToRowDataDelegation(Type type, PropertyInfo[] propertyList)
        {
            var source = Expression.Parameter(type);
            var items = propertyList.Select(property =&amp;gt; ConvertBindPropertyToData(source, property));
            var array = Expression.NewArrayInit(typeof(object), items);
            var lambda = Expression.Lambda&amp;lt;Func&amp;lt;TModel, object[]&amp;gt;&amp;gt;(array, source);
            return lambda.Compile();
        }

        /// &amp;lt;summary&amp;gt;
        /// 将属性转换成数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;源变量&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;property&quot;&amp;gt;属性信息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;获取属性数据表达式&amp;lt;/returns&amp;gt;
        private static Expression ConvertBindPropertyToData(ParameterExpression source, PropertyInfo property)
        {
            var propertyType = property.PropertyType;
            var expression = (Expression)Expression.Property(source, property);
            if (propertyType.IsEnum)
                expression = Expression.Convert(expression, propertyType.GetEnumUnderlyingType());
            return Expression.Convert(expression, typeof(object));
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取数据类型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;属性类型&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;数据类型&amp;lt;/returns&amp;gt;
        private static Type GetDataType(Type type)
        {
            //枚举默认转换成对应的值类型
            if (type.IsEnum)
                return type.GetEnumUnderlyingType();
            //可空类型
            if (type.IsGenericType &amp;amp;&amp;amp; type.GetGenericTypeDefinition() == typeof(Nullable&amp;lt;&amp;gt;))
                return GetDataType(type.GetGenericArguments().First());
            return type;
        }

        /// &amp;lt;summary&amp;gt;
        /// 列集合
        /// &amp;lt;/summary&amp;gt;
        public static IReadOnlyList&amp;lt;DataColumn&amp;gt; Columns { get; }

        /// &amp;lt;summary&amp;gt;
        /// 对象转数据行委托
        /// &amp;lt;/summary&amp;gt;
        public static Func&amp;lt;TModel, object[]&amp;gt; ToRowData { get; }

        /// &amp;lt;summary&amp;gt;
        /// 集合转换成DataTable
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;集合&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;tableName&quot;&amp;gt;表名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;转换完成的DataTable&amp;lt;/returns&amp;gt;
        public static DataTable ToDataTable(IEnumerable&amp;lt;TModel&amp;gt; source, string tableName = &quot;TempTable&quot;)
        {
            //创建表对象
            var table = new DataTable(tableName);
            //设置列
            foreach (var dataColumn in Columns)
            {
                table.Columns.Add(new DataColumn(dataColumn.ColumnName, dataColumn.DataType));
            }

            //循环转换每一行数据
            foreach (var item in source)
            {
                table.Rows.Add(ToRowData.Invoke(item));
            }

            //返回表对象
            return table;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1测试代码&quot;&gt;1.测试代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创表代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE [dbo].[Person](
        [Id] [BIGINT] NOT NULL,
        [Name] [VARCHAR](64) NOT NULL,
        [Age] [INT] NOT NULL,
        [CreateTime] [DATETIME] NULL,
        [Sex] [INT] NOT NULL,
PRIMARY KEY CLUSTERED 
(
        [Id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实体类代码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义的实体的属性名称需要和&lt;code&gt;SqlServer&lt;/code&gt;列名称类型对应&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    public long Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public DateTime? CreateTime { get; set; }
    public Gender Sex { get; set; }
}

public enum Gender
{
    Man = 0,
    Woman = 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//生成10万条数据
var persons = new Person[100000];
var random = new Random();
for (int i = 0; i &amp;lt; persons.Length; i++)
{
    persons[i] = new Person
    {
        Id = i + 1,
        Name = &quot;张三&quot; + i,
        Age = random.Next(1, 128),
        Sex = (Gender)random.Next(2),
        CreateTime = random.Next(2) == 0 ? null : (DateTime?) DateTime.Now.AddSeconds(i)
    };
}

//创建数据库连接
using (var conn = new SqlConnection(&quot;Server=.;Database=DemoDataBase;User ID=sa;Password=8888;&quot;))
{
    conn.Open();
    var sw = Stopwatch.StartNew();
    //批量插入数据
    var qty = conn.BulkCopy(persons);
    sw.Stop();
    Console.WriteLine(sw.Elapsed.TotalMilliseconds + &quot;ms&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;执行批量插入结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;226.4767ms
请按任意键继续. . .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201128002635787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI1MTU0Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;GitHub代码地址：&lt;a href=&quot;https://github.com/liu-zhen-liang/PackagingComponentsSet/tree/main/SqlBulkCopyComponents&quot;&gt;https://github.com/liu-zhen-liang/PackagingComponentsSet/tree/main/SqlBulkCopyComponents&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 08 Dec 2020 00:37:00 +0000</pubDate>
<dc:creator>NewAI</dc:creator>
<og:description>SQL Server 批量插入数据方案 SqlBulkCopy 的简单封装，让批量插入更方便</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuzhenliang/p/SqlBulkCopyComponents.html</dc:identifier>
</item>
<item>
<title>ADF 第二篇：使用UI创建数据工厂 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/14086241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/14086241.html</guid>
<description>&lt;p&gt;用户可以通过UI来创建ADF，在UI中创建ADF时，用户不需要下载单独的IDE，而仅仅通过 Microsoft Edge 或者 Google Chrome浏览器。用户登录Azure Portal，选择 “Data factories” 服务，通过 Data factories 服务中创建ADF。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204174124615-1455203745.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一，创建Data Factory实例&lt;/h2&gt;
&lt;p&gt;打开 Data factories之后，点击“+ Add”，创建自己的数据工厂实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204174224286-462570450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1，填写Basics信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 “Create Data Factory” 面板中开始创建数据工厂实例，首先填写“Basics”信息：Subscription（订阅）、资源组（Resource group）、区域（Region）、名称（Name）和版本（Version），版本选择V2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204175444537-1975722481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2：配置git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在V2版本中，用户在创建数据工厂时，还可以配置“Git configuration”，用于版本控制，可以勾选“Configure Git later”，在创建数据工厂实例之后，择机配置git。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204175420157-1991935623.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step3：检查和创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;检查（Review+Create）无误后，点击“Create” 按钮创建Data factory 实例。等实例创建完成，点击Next Step “Go to resource” 导航到数据工厂页面。&lt;/p&gt;
&lt;h2&gt;二，作者和监视器&lt;/h2&gt;
&lt;p&gt;在Data factory的overview页面上，点击&quot;Authoer &amp;amp; Monitor&quot;按钮，这会导航到 Azure Data Factory的用户界面（UI）页面中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204180048962-1050711099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ADF的UI界面如下图所示，界面中显示了常用的几个功能：Create Pipeline、Create Data Flow等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204180304025-1276338956.png&quot; alt=&quot;&quot; width=&quot;789&quot; height=&quot;284&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我们是第一次创建Data Factory，在创建Pipeline之前，我们还需要创建连接（connection）和数据集（dataset）。&lt;/p&gt;
&lt;h2&gt;三，&lt;strong&gt;创建连接服务&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;点击UI界面左侧的“Manage”选项卡，首先创建连接，连接有两种类型：Linked services 和 Integration runtimes，本文创建Liked Services，由于Linked Services 依赖于Integration runtimes，因此，我们首先创建Integration runtimes。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，创建Integration runtimes（IR）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何创建Integration runtimes，请阅读：《&lt;a href=&quot;https://www.cnblogs.com/ljhdo/p/14096866.html&quot; target=&quot;_blank&quot;&gt;ADF 第三篇：Integration runtime和 Linked Service&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，创建Linked Services&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Connections中选中“Linked Services”，点击“+New”，创建一个新的Linked Services：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204180805610-138464732.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的数据源，有不同的Linked Service，要根据实际的数据源，选择合适的数据源的类型，下图创建的Linked Service的类型是SQL Server，输入 Name、Connect via integration runtime、Server name、Database name、Authentication type 、 User name和 Password。&lt;/p&gt;
&lt;p&gt;注意，Connect via integration runtime 就是上一节创建的Integration runtimes。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204181727180-1954860401.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Azure Key Vault是一个存储空间，用户把密码存储到Azure Key Vault中，输入Key Vault的名称和密码就能提取它存储的信息。&lt;/p&gt;
&lt;h2&gt;四，创建Dataset&lt;/h2&gt;
&lt;p&gt;dataset 代表数据存储的结构（schema），它既可以代表数据源，从数据源中读取数据；也可以代表数据目标，把数据存储到该数据目标中。&lt;/p&gt;
&lt;p&gt;创建一个dataset实例，只是存储了数据存储的结构等元数据信息，而不会真正存储实际的数据。数据真正存储在dataset指向的底层存储对象中，举个例子，dataset执行SQL Server实例中的一个表，那么数据实际存储在这个表中，而dataset存储的数据是表的结构和导航到表的Linked Service。同一个dataset，既可以作为获取数据的数据源，也可以作为存储数据的数据目标。&lt;/p&gt;
&lt;p&gt;点击“铅笔”对应的“Author”选项卡，进入到Fact Resources界面，点击“+”，选择 Dataset，进入到创建Dataset的界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204182357069-23729624.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置Dataset的属性，设置Dataset的Name，通过Linked service来获取源数据的连接，通过Table name来指定表，建议把Import schema设置为From conneciton/store。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204182611340-734912221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五，创建Pipeline&lt;/h2&gt;
&lt;p&gt;创建管道，管道相当于一个容器，可以把一个或多个Activity拖放到管道中。&lt;/p&gt;
&lt;p&gt;如果向管道中放置Activity？用户不需要编写任何代码，只需要从“Activities”列表中选择需要的Activity，拖放到Pipeline中，常用的Activity 通常位于“General”子目录中。&lt;/p&gt;
&lt;p&gt;本文演示Copy data Activity的用法，从“Move &amp;amp; transform”子目录，选择Copy data：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201204183250735-1726561102.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Copy Activity的作用是把数据从一个dataset转移到另一个dataset中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，设置Copy Activity的Source属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Source 属性表示数据源，Copy Activity 从Source dataset中获取数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201207183534682-986357552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，Copy Activity的Sink属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sink属性用于设置数据目标，Sink dataset用于存储数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201207183639846-1873578057.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，Copy Activity的其他属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mapping属性选项卡用于设置Source dataset和Sink dataset之间的列映射，并可以设置列类型的转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，调试Pipeline&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击“Debug”对当前Pipeline进行调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/628084/202012/628084-20201207183958828-355167133.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，一个简单的ADF就创建完成。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/data-factory/quickstart-create-data-factory-portal&quot; target=&quot;_blank&quot;&gt;Quickstart: Create a data factory by using the Azure Data Factory UI&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Dec 2020 00:32:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>用户可以通过UI来创建ADF，在UI中创建ADF时，用户不需要下载单独的IDE，而仅仅通过 Microsoft Edge 或者 Google Chrome浏览器。用户登录Azure Portal，选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljhdo/p/14086241.html</dc:identifier>
</item>
<item>
<title>Java 中的语法糖，真甜。 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14100716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14100716.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在日常开发中经常会使用到诸如&lt;strong&gt;泛型、自动拆箱和装箱、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式&lt;/strong&gt;等，我们只觉得用的很爽，因为这些特性能够帮助我们减轻开发工作量；但我们未曾认真研究过这些特性的本质是什么，那么这篇文章，cxuan 就来为你揭开这些特性背后的真相。&lt;/p&gt;
&lt;h2 id=&quot;语法糖&quot;&gt;语法糖&lt;/h2&gt;
&lt;p&gt;在聊之前我们需要先了解一下 &lt;code&gt;语法糖&lt;/code&gt; 的概念：&lt;code&gt;语法糖（Syntactic sugar）&lt;/code&gt;，也叫做糖衣语法，是英国科学家发明的一个术语，通常来说使用语法糖能够增加程序的&lt;code&gt;可读性&lt;/code&gt;，从而减少程序代码出错的机会，真是又香又甜。&lt;/p&gt;
&lt;p&gt;语法糖指的是计算机语言中添加的某种语法，&lt;strong&gt;这种语法对语言的功能并没有影响，但是更方便程序员使用&lt;/strong&gt;。因为 Java 代码需要运行在 JVM 中，&lt;strong&gt;JVM 是并不支持语法糖的，语法糖在程序编译阶段就会被还原成简单的基础语法结构，这个过程就是&lt;code&gt;解语法糖&lt;/code&gt;&lt;/strong&gt;。所以在 Java 中，真正支持语法糖的是 Java 编译器，真是换汤不换药，万变不离其宗，关了灯都一样。。。。。。&lt;/p&gt;
&lt;p&gt;下面我们就来认识一下 Java 中的这些语法糖&lt;/p&gt;
&lt;h3 id=&quot;泛型&quot;&gt;泛型&lt;/h3&gt;
&lt;p&gt;泛型是一种语法糖。在 JDK1.5 中，引入了泛型机制，但是泛型机制的本身是通过&lt;code&gt;类型擦除&lt;/code&gt; 来实现的，在 JVM 中没有泛型，只有普通类型和普通方法，泛型类的类型参数，在编译时都会被擦除。泛型并没有自己独特的 Class类型。如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; aList = new ArrayList();
List&amp;lt;String&amp;gt; bList = new ArrayList();

System.out.println(aList.getClass() == bList.getClass());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;Ineger&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 被认为是不同的类型，但是输出却得到了相同的结果，这是因为，&lt;strong&gt;泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除&lt;/strong&gt;。但是，如果将一个 Integer 类型的数据放入到 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 中或者将一个 String 类型的数据放在 &lt;code&gt;List&amp;lt;Ineger&amp;gt;&lt;/code&gt; 中是不允许的。&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081318875-1220422331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无法将一个 Integer 类型的数据放在 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 和无法将一个 String 类型的数据放在 &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 中是一样会编译失败。&lt;/p&gt;
&lt;h3 id=&quot;自动拆箱和自动装箱&quot;&gt;自动拆箱和自动装箱&lt;/h3&gt;
&lt;p&gt;自动拆箱和自动装箱是一种语法糖，它说的是八种基本数据类型的包装类和其基本数据类型之间的自动转换。简单的说，装箱就是自动将基本数据类型转换为&lt;code&gt;包装器&lt;/code&gt;类型；拆箱就是自动将包装器类型转换为基本数据类型。&lt;/p&gt;
&lt;p&gt;我们先来了解一下基本数据类型的包装类都有哪些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081331116-2146893008.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，上面这些基本数据类型和包装类在进行转换的过程中会发生自动装箱/拆箱，例如下面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer integer = 66; // 自动拆箱

int i1 = integer;   // 自动装箱
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中的 integer 对象会使用基本数据类型来进行赋值，而基本数据类型 i1 却把它赋值给了一个对象类型，一般情况下是不能这样操作的，但是编译器却允许我们这么做，这其实就是一种语法糖。这种语法糖使我们方便我们进行数值运算，如果没有语法糖，在进行数值运算时，你需要先将对象转换成基本数据类型，基本数据类型同时也需要转换成包装类型才能使用其内置的方法，无疑增加了代码冗余。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么自动拆箱和自动装箱是如何实现的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这背后的原理是编译器做了优化。将基本类型赋值给包装类其实是调用了包装类的 &lt;code&gt;valueOf()&lt;/code&gt; 方法创建了一个包装类再赋值给了基本类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int i1 = Integer.valueOf(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而包装类赋值给基本类型就是调用了包装类的 xxxValue() 方法拿到基本数据类型后再进行赋值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer i1 = new Integer(1).intValue(); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用 javap -c 反编译一下上面的自动装箱和自动拆箱来验证一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081345759-1081109917.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在 Code 2 处调用 &lt;code&gt;invokestatic&lt;/code&gt; 的时候，相当于是编译器自动为我们添加了一下 Integer.valueOf 方法从而把基本数据类型转换为了包装类型。&lt;/p&gt;
&lt;p&gt;在 Code 7 处调用了 &lt;code&gt;invokevirtual&lt;/code&gt; 的时候，相当于是编译器为我们添加了 Integer.intValue() 方法把 Integer 的值转换为了基本数据类型。&lt;/p&gt;
&lt;h3 id=&quot;枚举&quot;&gt;枚举&lt;/h3&gt;
&lt;p&gt;我们在日常开发中经常会使用到 &lt;code&gt;enum&lt;/code&gt; 和 &lt;code&gt;public static final ...&lt;/code&gt; 这类语法。那么什么时候用 enum 或者是 public static final 这类常量呢？好像都可以。&lt;/p&gt;
&lt;p&gt;但是在 Java 字节码结构中，并没有枚举类型。&lt;strong&gt;枚举只是一个语法糖，在编译完成后就会被编译成一个普通的类，也是用 Class 修饰。这个类继承于 java.lang.Enum，并被 final 关键字修饰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们举个例子来看一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum School {
    STUDENT,
    TEACHER;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个 School 的枚举，里面包括两个字段，一个是 STUDENT ，一个是 TEACHER，除此之外并无其他。&lt;/p&gt;
&lt;p&gt;下面我们使用 &lt;code&gt;javap&lt;/code&gt; 反编译一下这个 School.class 。反编译完成之后的结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081356788-185952488.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看到，枚举其实就是一个继承于 &lt;code&gt;java.lang.Enum&lt;/code&gt; 类的 class 。而里面的属性 STUDENT 和 TEACHER 本质也就是 &lt;code&gt;public static final&lt;/code&gt; 修饰的字段。这其实也是一种编译器的优化，毕竟 STUDENT 要比 public static final School STUDENT 的美观性、简洁性都要好很多。&lt;/p&gt;
&lt;p&gt;除此之外，编译器还会为我们生成两个方法，&lt;code&gt;values()&lt;/code&gt; 方法和 &lt;code&gt;valueOf&lt;/code&gt; 方法，这两个方法都是编译器为我们添加的方法，通过使用 values() 方法可以获取所有的 Enum 属性值，而通过 valueOf 方法用于获取单个的属性值。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，Enum 的 values() 方法不属于 JDK API 的一部分，在 Java 源码中，没有 values() 方法的相关注释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum School {

    STUDENT(&quot;Student&quot;),
    TEACHER(&quot;Teacher&quot;);

    private String name;

    School(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public static void main(String[] args) {

        System.out.println(School.STUDENT.getName());

        School[] values = School.values();
        for(School school : values){
            System.out.println(&quot;name = &quot;+ school.getName());
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;内部类&quot;&gt;内部类&lt;/h3&gt;
&lt;p&gt;内部类是 Java 一个&lt;code&gt;小众&lt;/code&gt; 的特性，我之所以说小众，并不是说内部类没有用，而是我们日常开发中其实很少用到，但是翻看 JDK 源码，发现很多源码中都有内部类的构造。比如常见的 &lt;code&gt;ArrayList&lt;/code&gt; 源码中就有一个 &lt;code&gt;Itr&lt;/code&gt; 内部类继承于 &lt;code&gt;Iterator&lt;/code&gt; 类；再比如 &lt;code&gt;HashMap&lt;/code&gt; 中就构造了一个 &lt;code&gt;Node&lt;/code&gt; 继承于 Map.Entry&amp;lt;K,V&amp;gt; 来表示 HashMap 的每一个节点。&lt;/p&gt;
&lt;p&gt;Java 语言中之所以引入内部类，是因为有些时候一个类只想在一个类中有用，不想让其在其他地方被使用，也就是对外隐藏内部细节。&lt;/p&gt;
&lt;p&gt;内部类其实也是一个语法糖，因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class 文件，名为 outer$innter.class。&lt;/p&gt;
&lt;p&gt;下面我们就根据一个示例来验证一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class OuterClass {

    private String label;

    class InnerClass {

        public String linkOuter(){
            return label = &quot;inner&quot;;
        }

    }
    public static void main(String[] args) {

        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        System.out.println(innerClass.linkOuter());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段编译后就会生成两个 class 文件，一个是 &lt;code&gt;OuterClass.class&lt;/code&gt; ，一个是 &lt;code&gt;OuterClass$InnerClass.class&lt;/code&gt; ，这就表明，外部类可以链接到内部类，内部类可以修改外部类的属性等。&lt;/p&gt;
&lt;p&gt;我们来看一下内部类编译后的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081414624-1752488342.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，内部类经过编译后的 linkOuter() 方法会生成一个指向外部类的 this 引用，这个引用就是连接外部类和内部类的引用。&lt;/p&gt;
&lt;h3 id=&quot;变长参数&quot;&gt;变长参数&lt;/h3&gt;
&lt;p&gt;变长参数也是一个比较小众的用法，所谓变长参数，就是方法可以接受长度不定确定的参数。一般我们开发不会使用到变长参数，而且变长参数也不推荐使用，它会使我们的程序变的难以处理。但是我们有必要了解一下变长参数的特性。&lt;/p&gt;
&lt;p&gt;其基本用法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VariableArgs {

    public static void printMessage(String... args){
        for(String str : args){
            System.out.println(&quot;str = &quot; + str);
        }
    }

    public static void main(String[] args) {
        VariableArgs.printMessage(&quot;l&quot;,&quot;am&quot;,&quot;cxuan&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变长参数也是一种语法糖，那么它是如何实现的呢？我们可以猜测一下其内部应该是由数组构成，否则无法接受多个值，那么我们反编译看一下是不是由数组实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081427720-1670053421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，printMessage() 的参数就是使用了一个数组来接收，所以千万别被变长参数&lt;code&gt;忽悠&lt;/code&gt;了！&lt;/p&gt;
&lt;p&gt;变长参数特性是在 JDK 1.5 中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。&lt;/p&gt;
&lt;h3 id=&quot;增强-for-循环&quot;&gt;增强 for 循环&lt;/h3&gt;
&lt;p&gt;为什么有了普通的 for 循环后，还要有增强 for 循环呢？想一下，普通 for 循环你不是需要知道遍历次数？每次还需要知道数组的索引是多少，这种写法明显有些繁琐。增强 for 循环与普通 for 循环相比，功能更强并且代码更加简洁，你无需知道遍历的次数和数组的索引即可进行遍历。&lt;/p&gt;
&lt;p&gt;增强 for 循环的对象要么是一个数组，要么实现了 Iterable 接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    String[] params = new String[]{&quot;hello&quot;,&quot;world&quot;};
    //增强for循环对象为数组
    for(String str : params){
        System.out.println(str);
    }

    List&amp;lt;String&amp;gt; lists = Arrays.asList(&quot;hello&quot;,&quot;world&quot;);
    //增强for循环对象实现Iterable接口
    for(String str : lists){
        System.out.println(str);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过编译后的 class 文件如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
   String[] params = new String[]{&quot;hello&quot;, &quot;world&quot;};
   String[] lists = params;
   int var3 = params.length;
   //数组形式的增强for退化为普通for
   for(int str = 0; str &amp;lt; var3; ++str) {
       String str1 = lists[str];
       System.out.println(str1);
   }

   List var6 = Arrays.asList(new String[]{&quot;hello&quot;, &quot;world&quot;});
   Iterator var7 = var6.iterator();
   //实现Iterable接口的增强for使用iterator接口进行遍历
   while(var7.hasNext()) {
       String var8 = (String)var7.next();
       System.out.println(var8);
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示，如果对数组进行增强 for 循环的话，其内部还是对数组进行遍历，只不过语法糖把你忽悠了，让你以一种更简洁的方式编写代码。&lt;/p&gt;
&lt;p&gt;而对继承于 Iterator 迭代器进行增强 for 循环遍历的话，相当于是调用了 Iterator 的 &lt;code&gt;hasNext()&lt;/code&gt; 和 &lt;code&gt;next()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;switch-支持字符串和枚举&quot;&gt;Switch 支持字符串和枚举&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 关键字原生只能支持&lt;code&gt;整数&lt;/code&gt;类型。如果 switch 后面是 String 类型的话，编译器会将其转换成 String 的&lt;code&gt;hashCode&lt;/code&gt; 的值，所以其实 switch 语法比较的是 String 的 hashCode 。&lt;/p&gt;
&lt;p&gt;如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SwitchCaseTest {

    public static void main(String[] args) {

        String str = &quot;cxuan&quot;;
        switch (str){
            case &quot;cuan&quot;:
                System.out.println(&quot;cuan&quot;);
                break;
            case &quot;xuan&quot;:
                System.out.println(&quot;xuan&quot;);
                break;
            case &quot;cxuan&quot;:
                System.out.println(&quot;cxuan&quot;);
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们反编译一下，看看我们的猜想是否正确&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081446513-1316059123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据字节码可以看到，进行 switch 的实际是 hashcode 进行判断，然后通过使用 equals 方法进行比较，因为字符串有可能会产生哈希冲突的现象。&lt;/p&gt;
&lt;h3 id=&quot;条件编译&quot;&gt;条件编译&lt;/h3&gt;
&lt;p&gt;这个又是让小伙伴们摸不着头脑了，什么是条件编译呢？其实，如果你用过 C 或者 C++ 你就知道可以通过预处理语句来实现条件编译。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么什么是条件编译呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般情况下，源程序中所有的行都参加编译。但有时希望对其中一部分内容只在满足一定条件下才进行编译，即对一部分内容指定编译条件，这就是 &lt;code&gt;条件编译（conditional compile）&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#define DEBUG  
#IFDEF DEBUUG  
  /* 
   code block 1 
   */   
#ELSE  
  /* 
   code block 2 
  */  
#ENDIF  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在 Java 中没有预处理和宏定义这些内容，那么我们想实现条件编译，应该怎样做呢？&lt;/p&gt;
&lt;p&gt;使用 final + if 的组合就可以实现条件编译了。如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {  
  final boolean DEBUG = true;  
  if (DEBUG) {  
    System.out.println(&quot;Hello, world!&quot;);  
  }  else {
    System.out.println(&quot;nothing&quot;);
  }
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码会发生什么？我们反编译看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081457556-1116341545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，我们明明是使用了 if ...else 语句，但是编译器却只为我们编译了 DEBUG = true 的条件，&lt;/p&gt;
&lt;p&gt;所以，Java 语法的条件编译，是通过判断条件为常量的 if 语句实现的，编译器不会为我们编译分支为 false 的代码。&lt;/p&gt;
&lt;h3 id=&quot;断言&quot;&gt;断言&lt;/h3&gt;
&lt;p&gt;你在 Java 中使用过断言作为日常的判断条件吗？&lt;/p&gt;
&lt;p&gt;断言：也就是所谓的 &lt;code&gt;assert&lt;/code&gt; 关键字，是 jdk 1.4 后加入的新功能。它主要使用在代码开发和测试时期，用于对某些关键数据的判断，如果这个关键数据不是你程序所预期的数据，程序就提出警告或退出。当软件正式发布后，可以取消断言部分的代码。它也是一个语法糖吗？现在我不告诉你，我们先来看一下 assert 如何使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//这个成员变量的值可以变，但最终必须还是回到原值5  
static int i = 5;  
public static void main(String[] args) {  
  assert i == 5;  
  System.out.println(&quot;如果断言正常，我就被打印&quot;);  
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要开启断言检查，则需要用开关 -enableassertions 或 -ea 来开启。其实断言的底层实现就是 if 判断，如果断言结果为 true，则什么都不做，程序继续执行，如果断言结果为 false，则程序抛出 AssertError 来打断程序的执行。&lt;/p&gt;
&lt;p&gt;assert 断言就是通过对布尔标志位进行了一个 if 判断。&lt;/p&gt;
&lt;h3 id=&quot;try-with-resources&quot;&gt;try-with-resources&lt;/h3&gt;
&lt;p&gt;JDK 1.7 开始，java引入了 try-with-resources 声明，将 try-catch-finally 简化为 try-catch，这其实是一种&lt;code&gt;语法糖&lt;/code&gt;，在编译时会进行转化为 try-catch-finally 语句。新的声明包含三部分：try-with-resources 声明、try 块、catch 块。它要求在 try-with-resources 声明中定义的变量实现了 AutoCloseable 接口，这样在系统可以自动调用它们的 close 方法，从而替代了 finally 中关闭资源的功能。&lt;/p&gt;
&lt;p&gt;如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TryWithResourcesTest {

    public static void main(String[] args) {
        try(InputStream inputStream = new FileInputStream(new File(&quot;xxx&quot;))) {
            inputStream.read();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下 try-with-resources 反编译之后的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081511218-29688216.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，生成的 try-with-resources 经过编译后还是使用的 try...catch...finally 语句，只不过这部分工作由编译器替我们做了，这样能让我们的代码更加简洁，从而消除样板代码。&lt;/p&gt;
&lt;h3 id=&quot;字符串相加&quot;&gt;字符串相加&lt;/h3&gt;
&lt;p&gt;这个想必大家应该都知道，字符串的拼接有两种，如果能够在编译时期确定拼接的结果，那么使用 &lt;code&gt;+&lt;/code&gt; 号连接的字符串会被编译器直接优化为相加的结果，如果编译期不能确定拼接的结果，底层会直接使用 &lt;code&gt;StringBuilder&lt;/code&gt; 的 &lt;code&gt;append&lt;/code&gt; 进行拼接，如下图所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StringAppendTest {

    public static void main(String[] args) {
        String s1 = &quot;I am &quot; + &quot;cxuan&quot;;
        String s2 = &quot;I am &quot; + new String(&quot;cxuan&quot;);
        String s3 = &quot;I am &quot;;
        String s4 = &quot;cxuan&quot;;
        String s5 = s3 + s4;

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码就包含了两种字符串拼接的结果，我们反编译看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201208081525457-1080764574.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先来看一下 s1 ，s1 因为 = 号右边是两个常量，所以两个字符串拼接会被直接优化成为 &lt;code&gt;I am cxuan&lt;/code&gt;。而 s2 由于在堆空间中分配了一个 cxuan 对象，所以 + 号两边进行字符串拼接会直接转换为 StringBuilder ，调用其 append 方法进行拼接，最后再调用 toString() 方法转换成字符串。&lt;/p&gt;
&lt;p&gt;而由于 s5 进行拼接的两个对象在编译期不能判定其拼接结果，所以会直接使用 StringBuilder 进行拼接。&lt;/p&gt;
&lt;h2 id=&quot;学习语法糖的意义&quot;&gt;学习语法糖的意义&lt;/h2&gt;
&lt;p&gt;互联网时代，有很多标新立异的想法和框架层出不穷，但是，我们对于学习来说应该抓住技术的核心。然而，软件工程是一门协作的艺术，对于工程来说如何提高工程质量，如何提高工程效率也是我们要关注的，既然这些语法糖能辅助我们以更好的方式编写备受欢迎的代码，我们程序员为什么要 &lt;code&gt;抵制&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;语法糖也是一种进步，这就和你写作文似的，大白话能把故事讲明白的它就没有语言优美、酣畅淋漓的把故事讲生动的更令人喜欢。&lt;/p&gt;
&lt;p&gt;我们要在敞开怀抱拥抱变化的同时也要掌握其 &lt;code&gt;屠龙之技&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ax1x.com/2020/11/30/DgOK6f.png&quot;&gt;六本 PDF 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201130090550310-1032998206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Dec 2020 00:28:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star https://github.com/crisxuan/bestJavaer 我们在日常开发中经常会使用到诸如泛型、自动拆箱和装箱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14100716.html</dc:identifier>
</item>
<item>
<title>5分钟入门MP4文件格式 - 程序猿小卡</title>
<link>http://www.cnblogs.com/chyingp/p/mp4-file-format.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chyingp/p/mp4-file-format.html</guid>
<description>&lt;p&gt;最近经常回答团队小伙伴关于直播 &amp;amp; 短视频的问题，比如 “flv.js的实现原理”、“为什么设计同学给的mp4文件浏览器里播放不了、但本地可以正常播放”、“MP4兼容性很好，可不可以用来做直播” 等。 本文主要内容包括，什么是MP4、MP4文件的基本结构、Box的基本结构、常见且重要的box介绍、普通MP4与fMP4的区别、如何通过代码解析MP4文件 等。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;497.28819407296&quot;&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;本文主要内容包括，什么是MP4、MP4文件的基本结构、Box的基本结构、常见且重要的box介绍、普通MP4与fMP4的区别、如何通过代码解析MP4文件 等。&lt;/p&gt;
&lt;p&gt;写作背景：最近经常回答团队小伙伴关于直播 &amp;amp; 短视频的问题，比如 “flv.js的实现原理”、“为什么设计同学给的mp4文件浏览器里播放不了、但本地可以正常播放”、“MP4兼容性很好，可不可以用来做直播” 等。&lt;/p&gt;
&lt;p&gt;在解答的过程中，发现经常涉及 MP4 协议的介绍。之前这块有简单了解过并做了笔记，这里稍微整理一下，顺便作为团队参考文档，如有错漏，敬请指出。&lt;/p&gt;
&lt;h2 id=&quot;什么是mp4&quot;&gt;什么是MP4&lt;/h2&gt;
&lt;p&gt;首先，介绍下封装格式。多媒体封装格式（也叫容器格式），是指按照一定的规则，将视频数据、音频数据等，放到一个文件中。常见的 MKV、AVI 以及本文介绍的 MP4 等，都是封装格式。&lt;/p&gt;
&lt;p&gt;MP4是最常见的封装格式之一，因为其跨平台的特性而得到广泛应用。MP4文件的后缀为.mp4，基本上主流的播放器、浏览器都支持MP4格式。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;MP4文件的格式主要由 MPEG-4 Part 12、MPEG-4 Part 14 两部分进行定义。其中，MPEG-4 Part 12 定义了ISO基础媒体文件格式，用来存储基于时间的媒体内容。MPEG-4 Part 14 实际定义了MP4文件格式，在MPEG-4 Part 12的基础上进行扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对从事直播、音视频相关工作的同学，很有必要了解MP4格式，下面简单介绍下。&lt;/p&gt;
&lt;h2 id=&quot;mp4文件格式概览&quot;&gt;MP4文件格式概览&lt;/h2&gt;
&lt;p&gt;MP4文件由多个box组成，每个box存储不同的信息，且box之间是树状结构，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be249051d03f45748b3055c842d75793~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;box类型有很多，下面是3个比较重要的顶层box：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ftyp：File Type Box，描述文件遵从的MP4规范与版本；&lt;/li&gt;
&lt;li&gt;moov：Movie Box，媒体的metadata信息，有且仅有一个。&lt;/li&gt;
&lt;li&gt;mdat：Media Data Box，存放实际的媒体数据，一般有多个；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79de26cf6b5145228a9f6c71c8ca572d~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然box类型有很多，但基本结构都是一样的。下一节会先介绍box的结构，然后再对常见的box进行进一步讲解。&lt;/p&gt;
&lt;p&gt;下表是常见的box，稍微看下有个大致的印象就好，然后直接跳到下一节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ee4c90565a49f6aca5c350934ebb3d~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mp4-box简介&quot;&gt;MP4 Box简介&lt;/h2&gt;
&lt;p&gt;1个box由两部分组成：box header、box body。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;box header：box的元数据，比如box type、box size。&lt;/li&gt;
&lt;li&gt;box body：box的数据部分，实际存储的内容跟box类型有关，比如mdat中body部分存储的媒体数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;box header中，只有type、size是必选字段。当size==0时，存在largesize字段。在部分box中，还存在version、flags字段，这样的box叫做Full Box。当box body中嵌套其他box时，这样的box叫做container box。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6b3386f5de345cc9688a6f5e968ae28~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;字段定义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type：box类型，包括 “预定义类型”、“自定义扩展类型”，占4个字节；
&lt;ul&gt;&lt;li&gt;预定义类型：比如ftyp、moov、mdat等预定义好的类型；&lt;/li&gt;
&lt;li&gt;自定义扩展类型：如果type==uuid，则表示是自定义扩展类型。size（或largesize）随后的16字节，为自定义类型的值（extended_type）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;size：包含box header在内的整个box的大小，单位是字节。当size为0或1时，需要特殊处理：
&lt;ul&gt;&lt;li&gt;size等于0：box的大小由后续的largesize确定（一般只有装载媒体数据的mdat box会用到largesize）；&lt;/li&gt;
&lt;li&gt;size等于1：当前box为文件的最后一个box，通常包含在mdat box中；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;largesize：box的大小，占8个字节；&lt;/li&gt;
&lt;li&gt;extended_type：自定义扩展类型，占16个字节；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Box的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class Box (unsigned int(32) boxtype, optional unsigned int(8)[16] extended_type) {
    unsigned int(32) size;
    unsigned int(32) type = boxtype;
    if (size==1) {
        unsigned int(64) largesize;
    } else if (size==0) {
        // box extends to end of file
    }
    if (boxtype==‘uuid’) {
        unsigned int(8)[16] usertype = extended_type;
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;box-body&quot;&gt;Box Body&lt;/h3&gt;
&lt;p&gt;box数据体，不同box包含的内容不同，需要参考具体box的定义。有的 box body 很简单，比如 ftyp。有的 box 比较复杂，可能嵌套了其他box，比如moov。&lt;/p&gt;
&lt;h3 id=&quot;box-vs-fullbox&quot;&gt;Box vs FullBox&lt;/h3&gt;
&lt;p&gt;在Box的基础上，扩展出了FullBox类型。相比Box，FullBox 多了 version、flags 字段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;version：当前box的版本，为扩展做准备，占1个字节；&lt;/li&gt;
&lt;li&gt;flags：标志位，占24位，含义由具体的box自己定义；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FullBox 伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class FullBox(unsigned int(32) boxtype, unsigned int(8) v, bit(24) f) extends Box(boxtype) {
        unsigned int(8) version = v;
        bit(24) flags = f;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FullBox主要在moov中的box用到，比如 &lt;code&gt;moov.mvhd&lt;/code&gt;，后面会介绍到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieHeaderBox extends FullBox(‘mvhd’, version, 0) {
        // 字段略... 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ftyp（file-type-box）&quot;&gt;ftyp（File Type Box）&lt;/h2&gt;
&lt;p&gt;ftyp用来指出当前文件遵循的规范，在介绍ftyp的细节前，先科普下isom。&lt;/p&gt;
&lt;h3 id=&quot;什么是isom&quot;&gt;什么是isom&lt;/h3&gt;
&lt;p&gt;isom（ISO Base Media file）是在 MPEG-4 Part 12 中定义的一种基础文件格式，MP4、3gp、QT 等常见的封装格式，都是基于这种基础文件格式衍生的。&lt;/p&gt;
&lt;p&gt;MP4 文件可能遵循的规范有mp41、mp42，而mp41、mp42又是基于isom衍生出来的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;3gp(3GPP)：一种容器格式，主要用于3G手机上；&lt;br/&gt;QT：QuickTime的缩写，.qt 文件代表苹果QuickTime媒体文件；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ftyp定义&quot;&gt;ftyp定义&lt;/h3&gt;
&lt;p&gt;ftyp 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class FileTypeBox extends Box(‘ftyp’) {  
  unsigned int(32) major_brand;  
  unsigned int(32) minor_version;  
  unsigned int(32) compatible_brands[]; // to end of the box  
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是是 brand 的描述，其实就是具体封装格式对应的代码，用4个字节的编码来表示，比如 mp41。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;A brand is a four-letter code representing a format or subformat. Each file has a major brand (or primary brand), and also a compatibility list of brands.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ftyp 的几个字段的含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;major_brand：比如常见的 isom、mp41、mp42、avc1、qt等。它表示“最好”基于哪种格式来解析当前的文件。举例，major_brand 是 A，compatible_brands 是 A1，当解码器同时支持 A、A1 规范时，最好使用A规范来解码当前媒体文件，如果不支持A规范，但支持A1规范，那么，可以使用A1规范来解码；&lt;/li&gt;
&lt;li&gt;minor_version：提供 major_brand 的说明信息，比如版本号，不得用来判断媒体文件是否符合某个标准/规范；&lt;/li&gt;
&lt;li&gt;compatible_brands：文件兼容的brand列表。比如 mp41 的兼容 brand 为 isom。通过兼容列表里的 brand 规范，可以将文件 部分（或全部）解码出来；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在实际使用中，不能把 isom 做为 major_brand，而是需要使用具体的brand（比如mp41），因此，对于 isom，没有定义具体的文件扩展名、mime type。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是常见的几种brand，以及对应的文件扩展名、mime type，更多brand可以参考 &lt;a href=&quot;http://fileformats.archiveteam.org/wiki/Boxes/atoms_format#Brands&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9290f510d66a45699e0c6c9d3b32562e~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是实际例子的截图，不赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af192a4acc141c69ee75b932874f418~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于avcavc1&quot;&gt;关于AVC/AVC1&lt;/h3&gt;
&lt;p&gt;在讨论 MP4 规范时，提到AVC，有的时候指的是“AVC文件格式”，有的时候指的是&quot;AVC压缩标准（H.264）&quot;，这里简单做下区分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AVC文件格式：基于 ISO基础文件格式 衍生的，使用的是AVC压缩标准，可以认为是MP4的扩展格式，对应的brand 通常是 avc1，在MPEG-4 PART 15 中定义。&lt;/li&gt;
&lt;li&gt;AVC压缩标准（H.264）：在MPEG-4 Part 10中定义。&lt;/li&gt;
&lt;li&gt;ISO基础文件格式(Base Media File Format) 在 MPEG-4 Part 12 中定义。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;moov（movie-box）&quot;&gt;moov（Movie Box）&lt;/h2&gt;
&lt;p&gt;Movie Box，存储 mp4 的 metadata，一般位于mp4文件的开头。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieBox extends Box(‘moov’){ }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;moov中，最重要的两个box是 mvhd 和 trak：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mvhd：Movie Header Box，mp4文件的整体信息，比如创建时间、文件时长等；&lt;/li&gt;
&lt;li&gt;trak：Track Box，一个mp4可以包含一个或多个轨道（比如视频轨道、音频轨道），轨道相关的信息就在trak里。trak是container box，至少包含两个box，tkhd、mdia；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;mvhd针对整个影片，tkhd针对单个track，mdhd针对媒体，vmhd针对视频，smhd针对音频，可以认为是从 宽泛 &amp;gt; 具体，前者一般是从后者推导出来的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MP4文件的整体信息，跟具体的视频流、音频流无关，比如创建时间、文件时长等。&lt;/p&gt;
&lt;p&gt;定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieHeaderBox extends FullBox(‘mvhd’, version, 0) { if (version==1) {
      unsigned int(64)  creation_time;
      unsigned int(64)  modification_time;
      unsigned int(32)  timescale;
      unsigned int(64)  duration;
   } else { // version==0
      unsigned int(32)  creation_time;
      unsigned int(32)  modification_time;
      unsigned int(32)  timescale;
      unsigned int(32)  duration;
}
template int(32) rate = 0x00010000; // typically 1.0
template int(16) volume = 0x0100; // typically, full volume const bit(16) reserved = 0;
const unsigned int(32)[2] reserved = 0;
template int(32)[9] matrix =
{ 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 };
      // Unity matrix
   bit(32)[6]  pre_defined = 0;
   unsigned int(32)  next_track_ID;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字段含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;creation_time：文件创建时间；&lt;/li&gt;
&lt;li&gt;modification_time：文件修改时间；&lt;/li&gt;
&lt;li&gt;timescale：一秒包含的时间单位（整数）。举个例子，如果timescale等于1000，那么，一秒包含1000个时间单位（后面track等的时间，都要用这个来换算，比如track的duration为10,000，那么，track的实际时长为10,000/1000=10s）；&lt;/li&gt;
&lt;li&gt;duration：影片时长（整数），根据文件中的track的信息推导出来，等于时间最长的track的duration；&lt;/li&gt;
&lt;li&gt;rate：推荐的播放速率，32位整数，高16位、低16位分别代表整数部分、小数部分（[16.16]），举例 0x0001 0000 代表1.0，正常播放速度；&lt;/li&gt;
&lt;li&gt;volume：播放音量，16位整数，高8位、低8位分别代表整数部分、小数部分（[8.8]），举例 0x01 00 表示 1.0，即最大音量；&lt;/li&gt;
&lt;li&gt;matrix：视频的转换矩阵，一般可以忽略不计；&lt;/li&gt;
&lt;li&gt;next_track_ID：32位整数，非0，一般可以忽略不计。当要添加一个新的track到这个影片时，可以使用的track id，必须比当前已经使用的track id要大。也就是说，添加新的track时，需要遍历所有track，确认可用的track id；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tkhd（track-box）&quot;&gt;tkhd（Track Box）&lt;/h3&gt;
&lt;p&gt;单个 track 的 metadata，包含如下字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;version：tkhd box的版本；&lt;/li&gt;
&lt;li&gt;flags：按位或操作获得，默认值是7（0x000001 | 0x000002 | 0x000004），表示这个track是启用的、用于播放的 且 用于预览的。
&lt;ul&gt;&lt;li&gt;Track_enabled：值为0x000001，表示这个track是启用的，当值为0x000000，表示这个track没有启用；&lt;/li&gt;
&lt;li&gt;Track_in_movie：值为0x000002，表示当前track在播放时会用到；&lt;/li&gt;
&lt;li&gt;Track_in_preview：值为0x000004，表示当前track用于预览模式；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;creation_time：当前track的创建时间；&lt;/li&gt;
&lt;li&gt;modification_time：当前track的最近修改时间；&lt;/li&gt;
&lt;li&gt;track_ID：当前track的唯一标识，不能为0，不能重复；&lt;/li&gt;
&lt;li&gt;duration：当前track的完整时长（需要除以timescale得到具体秒数）；&lt;/li&gt;
&lt;li&gt;layer：视频轨道的叠加顺序，数字越小越靠近观看者，比如1比2靠上，0比1靠上；&lt;/li&gt;
&lt;li&gt;alternate_group：当前track的分组ID，alternate_group值相同的track在同一个分组里面。同个分组里的track，同一时间只能有一个track处于播放状态。当alternate_group为0时，表示当前track没有跟其他track处于同个分组。一个分组里面，也可以只有一个track；&lt;/li&gt;
&lt;li&gt;volume：audio track的音量，介于0.0~1.0之间；&lt;/li&gt;
&lt;li&gt;matrix：视频的变换矩阵；&lt;/li&gt;
&lt;li&gt;width、height：视频的宽高；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TrackHeaderBox 
  extends FullBox(‘tkhd’, version, flags){ 
        if (version==1) {
              unsigned int(64)  creation_time;
              unsigned int(64)  modification_time;
              unsigned int(32)  track_ID;
              const unsigned int(32)  reserved = 0;
              unsigned int(64)  duration;
           } else { // version==0
              unsigned int(32)  creation_time;
              unsigned int(32)  modification_time;
              unsigned int(32)  track_ID;
              const unsigned int(32)  reserved = 0;
              unsigned int(32)  duration;
        }
        const unsigned int(32)[2] reserved = 0;
        template int(16) layer = 0;
        template int(16) alternate_group = 0;
        template int(16) volume = {if track_is_audio 0x0100 else 0}; const unsigned int(16) reserved = 0;
        template int(32)[9] matrix= { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }; // unity matrix
        unsigned int(32) width;
        unsigned int(32) height;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e980ad2bc583418f8bdd7ce122e9d035~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hdlr（handler-reference-box）&quot;&gt;hdlr（Handler Reference Box）&lt;/h3&gt;
&lt;p&gt;声明当前track的类型，以及对应的处理器（handler）。&lt;/p&gt;
&lt;p&gt;handler_type的取值包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vide（0x76 69 64 65），video track；&lt;/li&gt;
&lt;li&gt;soun（0x73 6f 75 6e），audio track；&lt;/li&gt;
&lt;li&gt;hint（0x68 69 6e 74），hint track；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;name为utf8字符串，对handler进行描述，比如 L-SMASH Video Handler（参考 &lt;a href=&quot;http://avisynth.nl/index.php/LSMASHSource&quot;&gt;这里&lt;/a&gt;）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class HandlerBox extends FullBox(‘hdlr’, version = 0, 0) { 
        unsigned int(32) pre_defined = 0;
        unsigned int(32) handler_type;
        const unsigned int(32)[3] reserved = 0;
        string   name;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18839d47f31841e69ab1f902f854131b~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;stbl（sample-table-box）&quot;&gt;stbl（Sample Table Box）&lt;/h2&gt;
&lt;p&gt;MP4文件的媒体数据部分在mdat box里，而stbl则包含了这些媒体数据的索引以及时间信息，了解stbl对解码、渲染MP4文件很关键。&lt;/p&gt;
&lt;p&gt;在MP4文件中，媒体数据被分成多个chunk，每个chunk可包含多个sample，而sample则由帧组成（通常1个sample对应1个帧），关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/chyingp/p/1607019210268.png&quot; alt=&quot;Alt text&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;stbl中比较关键的box包含stsd、stco、stsc、stsz、stts、stss、ctts。下面先来个概要的介绍，然后再逐个讲解细节。&lt;/p&gt;
&lt;h3 id=&quot;stco--stsc--stsz--stts--stss--ctts--stsd-概述&quot;&gt;stco / stsc / stsz / stts / stss / ctts / stsd 概述&lt;/h3&gt;
&lt;p&gt;下面是这几个box概要的介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stsd：给出视频、音频的编码、宽高、音量等信息，以及每个sample中包含多少个frame；&lt;/li&gt;
&lt;li&gt;stco：thunk在文件中的偏移；&lt;/li&gt;
&lt;li&gt;stsc：每个thunk中包含几个sample；&lt;/li&gt;
&lt;li&gt;stsz：每个sample的size（单位是字节）；&lt;/li&gt;
&lt;li&gt;stts：每个sample的时长；&lt;/li&gt;
&lt;li&gt;stss：哪些sample是关键帧；&lt;/li&gt;
&lt;li&gt;ctts：帧解码到渲染的时间差值，通常用在B帧的场景；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;stsd（sample-description-box）&quot;&gt;stsd（Sample Description Box）&lt;/h3&gt;
&lt;p&gt;stsd给出sample的描述信息，这里面包含了在解码阶段需要用到的任意初始化信息，比如 编码 等。对于视频、音频来说，所需要的初始化信息不同，这里以视频为例。&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) abstract class SampleEntry (unsigned int(32) format) extends Box(format){
        const unsigned int(8)[6] reserved = 0;
        unsigned int(16) data_reference_index;
}

// Visual Sequences
class VisualSampleEntry(codingname) extends SampleEntry (codingname){ 
        unsigned int(16) pre_defined = 0;
        const unsigned int(16) reserved = 0;
        unsigned int(32)[3] pre_defined = 0;
        unsigned int(16) width;
        unsigned int(16) height;
        template unsigned int(32) horizresolution = 0x00480000; // 72 dpi 
        template unsigned int(32) vertresolution = 0x00480000; // 72 dpi 
        const unsigned int(32) reserved = 0;
        template unsigned int(16) frame_count = 1;
        string[32] compressorname;
        template unsigned int(16) depth = 0x0018;
        int(16) pre_defined = -1;
}

// AudioSampleEntry、HintSampleEntry 定义略过


aligned(8) class SampleDescriptionBox (unsigned int(32) handler_type) extends FullBox('stsd', 0, 0){
        int i ;
        unsigned int(32) entry_count;
        for (i = 1 ; i u entry_count ; i++) {
              switch (handler_type){
                case ‘soun’: // for audio tracks
                                AudioSampleEntry();
                                break;
                        case ‘vide’: // for video tracks
                           VisualSampleEntry();
                           break;
                        case ‘hint’: // Hint track
                           HintSampleEntry();
                           break;                
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SampleDescriptionBox 中，handler_type 参数 为 track 的类型（soun、vide、hint），entry_count 变量代表当前box中 smaple description 的条目数。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;stsc 中，sample_description_index 就是指向这些smaple description的索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对不同的handler_type，SampleDescriptionBox 后续应用不同的 SampleEntry 类型，比如video track为VisualSampleEntry。&lt;/p&gt;
&lt;p&gt;VisualSampleEntry包含如下字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data_reference_index：当MP4文件的数据部分，可以被分割成多个片段，每一段对应一个索引，并分别通过URL地址来获取，此时，data_reference_index 指向对应的片段（比较少用到）；&lt;/li&gt;
&lt;li&gt;width、height：视频的宽高，单位是像素；&lt;/li&gt;
&lt;li&gt;horizresolution、vertresolution：水平、垂直方向的分辨率（像素/英寸），16.16定点数，默认是0x00480000（72dpi）；&lt;/li&gt;
&lt;li&gt;frame_count：一个sample中包含多少个frame，对video track来说，默认是1；&lt;/li&gt;
&lt;li&gt;compressorname：仅供参考的名字，通常用于展示，占32个字节，比如 AVC Coding。第一个字节，表示这个名字实际要占用N个字节的长度。第2到第N+1个字节，存储这个名字。第N+2到32个字节为填充字节。compressorname 可以设置为0；&lt;/li&gt;
&lt;li&gt;depth：位图的深度信息，比如 0x0018（24），表示不带alpha通道的图片；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;In video tracks, the frame_count field must be 1 unless the specification for the media format explicitly documents this template field and permits larger values. That specification must document both how the individual frames of video are found (their size information) and their timing established. That timing might be as simple as dividing the sample duration by the frame count to establish the frame duration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58a74d77e6114719aee48b31eaeb781b~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stco（chunk-offset-box）&quot;&gt;stco（Chunk Offset Box）&lt;/h3&gt;
&lt;p&gt;chunk在文件中的偏移量。针对小文件、大文件，有两种不同的box类型，分别是stco、co64，它们的结构是一样的，只是字段长度不同。&lt;/p&gt;
&lt;p&gt;chunk_offset 指的是在文件本身中的 offset，而不是某个box内部的偏移。&lt;/p&gt;
&lt;p&gt;在构建mp4文件的时候，需要特别注意 moov 所处的位置，它对于chunk_offset 的值是有影响的。有一些MP4文件的 moov 在文件末尾，为了优化首帧速度，需要将 moov 移到文件前面，此时，需要对 chunk_offset 进行改写。&lt;/p&gt;
&lt;p&gt;stco 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Box Type: ‘stco’, ‘co64’
# Container: Sample Table Box (‘stbl’) Mandatory: Yes
# Quantity: Exactly one variant must be present

aligned(8) class ChunkOffsetBox
        extends FullBox(‘stco’, version = 0, 0) { 
        unsigned int(32) entry_count;
        for (i=1; i u entry_count; i++) {
                unsigned int(32)  chunk_offset;
        }
}

aligned(8) class ChunkLargeOffsetBox
        extends FullBox(‘co64’, version = 0, 0) { 
        unsigned int(32) entry_count;
        for (i=1; i u entry_count; i++) {
                unsigned int(64)  chunk_offset;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下例子所示，第一个chunk的offset是47564，第二个chunk的偏移是120579，其他类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e481c07776c7476cbfeca5a55d4aff65~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stsc（sample-to-chunk-box）&quot;&gt;stsc（Sample To Chunk Box）&lt;/h3&gt;
&lt;p&gt;sample 以 chunk 为单位分成多个组。chunk的size可以是不同的，chunk里面的sample的size也可以是不同的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;entry_count：有多少个表项（每个表项，包含first_chunk、samples_per_chunk、sample_description_index信息）；&lt;/li&gt;
&lt;li&gt;first_chunk：当前表项中，对应的第一个chunk的序号；&lt;/li&gt;
&lt;li&gt;samples_per_chunk：每个chunk包含的sample数；&lt;/li&gt;
&lt;li&gt;sample_description_index：指向 stsd 中 sample description 的索引值（参考stsd小节）；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;aligned(8) class SampleToChunkBox
        extends FullBox(‘stsc’, version = 0, 0) { 
        unsigned int(32) entry_count;
        for (i=1; i u entry_count; i++) {
                unsigned int(32) first_chunk;
                unsigned int(32) samples_per_chunk; 
                unsigned int(32) sample_description_index;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面描述比较抽象，这里看个例子，这里表示的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;序号1~15的chunk，每个chunk包含15个sample；&lt;/li&gt;
&lt;li&gt;序号16的chunk，包含30个sample；&lt;/li&gt;
&lt;li&gt;序号17以及之后的chunk，每个chunk包含28个sample；&lt;/li&gt;
&lt;li&gt;以上所有chunk中的sample，对应的sample description的索引都是1；&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;first_chunk&lt;/th&gt;
&lt;th&gt;samples_per_chunk&lt;/th&gt;
&lt;th&gt;sample_description_index&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09390dea426f49f68cf0cebb64547afc~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stsz（sample-size-boxes）&quot;&gt;stsz（Sample Size Boxes）&lt;/h3&gt;
&lt;p&gt;每个sample的大小（字节），根据 sample_size 字段，可以知道当前track包含了多少个sample（或帧）。&lt;/p&gt;
&lt;p&gt;有两种不同的box类型，stsz、stz2。&lt;/p&gt;
&lt;p&gt;stsz：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sample_size：默认的sample大小（单位是byte），通常为0。如果sample_size不为0，那么，所有的sample都是同样的大小。如果sample_size为0，那么，sample的大小可能不一样。&lt;/li&gt;
&lt;li&gt;sample_count：当前track里面的sample数目。如果 sample_size==0，那么，sample_count 等于下面entry的条目；&lt;/li&gt;
&lt;li&gt;entry_size：单个sample的大小（如果sample_size==0的话）；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;aligned(8) class SampleSizeBox extends FullBox(‘stsz’, version = 0, 0) { 
        unsigned int(32) sample_size;
        unsigned int(32) sample_count;
        if (sample_size==0) {
                for (i=1; i u sample_count; i++) {
                        unsigned int(32)  entry_size;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;stz2：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;field_size：entry表中，每个entry_size占据的位数（bit），可选的值为4、8、16。4比较特殊，当field_size等于4时，一个字节上包含两个entry，高4位为entry[i]，低4位为entry[i+1]；&lt;/li&gt;
&lt;li&gt;sample_count：等于下面entry的条目；&lt;/li&gt;
&lt;li&gt;entry_size：sample的大小。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;aligned(8) class CompactSampleSizeBox extends FullBox(‘stz2’, version = 0, 0) { 
        unsigned int(24) reserved = 0;
        unisgned int(8) field_size;
        unsigned int(32) sample_count;
        for (i=1; i u sample_count; i++) {
                unsigned int(field_size) entry_size;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/838cc3afb5a24faf97917a3f3482a1dc~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stts（decoding-time-to-sample-box）&quot;&gt;stts（Decoding Time to Sample Box）&lt;/h3&gt;
&lt;p&gt;stts包含了DTS到sample number的映射表，主要用来推导每个帧的时长。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TimeToSampleBox extends FullBox(’stts’, version = 0, 0) {
        unsigned int(32)  entry_count;
        int i;
        for (i=0; i &amp;lt; entry_count; i++) {
                unsigned int(32)  sample_count;
                unsigned int(32)  sample_delta;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;entry_count：stts 中包含的entry条目数；&lt;/li&gt;
&lt;li&gt;sample_count：单个entry中，具有相同时长（duration 或 sample_delta）的连续sample的个数。&lt;/li&gt;
&lt;li&gt;sample_delta：sample的时长（以timescale为计量）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是看例子，如下图，entry_count为3，前250个sample的时长为1000，第251个sample时长为999，第252~283个sample的时长为1000。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;假设timescale为1000，则实际时长需要除以1000。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4eb5af45ab42b68662f08267c2cdef~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;stss（sync-sample-box）&quot;&gt;stss（Sync Sample Box）&lt;/h3&gt;
&lt;p&gt;mp4文件中，关键帧所在的sample序号。如果没有stss的话，所有的sample中都是关键帧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;entry_count：entry的条目数，可以认为是关键帧的数目；&lt;/li&gt;
&lt;li&gt;sample_number：关键帧对应的sample的序号；（从1开始计算）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;aligned(8) class SyncSampleBox
   extends FullBox(‘stss’, version = 0, 0) {
   unsigned int(32)  entry_count;
   int i;
   for (i=0; i &amp;lt; entry_count; i++) {
      unsigned int(32)  sample_number;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子如下，第1、31、61、91、121...271个sample是关键帧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0900b5bd5b8046c7ae5781e8f85feb6d~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ctts（composition-time-to-sample-box）&quot;&gt;ctts（Composition Time to Sample Box）&lt;/h3&gt;
&lt;p&gt;从解码（dts）到渲染（pts）之间的差值。&lt;/p&gt;
&lt;p&gt;对于只有I帧、P帧的视频来说，解码顺序、渲染顺序是一致的，此时，ctts没必要存在。&lt;/p&gt;
&lt;p&gt;对于存在B帧的视频来说，ctts就需要存在了。当PTS、DTS不相等时，就需要ctts了，公式为 CT(n) = DT(n) + CTTS(n) 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class CompositionOffsetBox extends FullBox(‘ctts’, version = 0, 0) { unsigned int(32) entry_count;
      int i;
   for (i=0; i &amp;lt; entry_count; i++) {
      unsigned int(32)  sample_count;
      unsigned int(32)  sample_offset;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子如下，不赘述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a54659994b47339fbffddd8f5397ae~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;fmp4（fragmented-mp4）&quot;&gt;fMP4（Fragmented mp4）&lt;/h2&gt;
&lt;p&gt;fMP4 跟普通 mp4 基本文件结构是一样的。普通mp4用于点播场景，fmp4通常用于直播场景。&lt;/p&gt;
&lt;p&gt;它们有以下差别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;普通mp4的时长、内容通常是固定的。fMP4 时长、内容通常不固定，可以边生成边播放；&lt;/li&gt;
&lt;li&gt;普通mp4完整的metadata都在moov里，需要加载完moov box后，才能对mdat中的媒体数据进行解码渲染；&lt;/li&gt;
&lt;li&gt;fMP4中，媒体数据的metadata在moof box中，moof 跟 mdat （通常）结对出现。moof 中包含了sample duration、sample size等信息，因此，fMP4可以边生成边播放；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例来说，普通mp4、fMP4顶层box结构可能如下。以下是通过笔者编写的MP4解析小工具打印出来，代码在文末给出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 普通mp4
ftyp size=32(8+24) curTotalSize=32
moov size=4238(8+4230) curTotalSize=4270
mdat size=1124105(8+1124097) curTotalSize=1128375

// fmp4
ftyp size=36(8+28) curTotalSize=36
moov size=1227(8+1219) curTotalSize=1263
moof size=1252(8+1244) curTotalSize=2515
mdat size=65895(8+65887) curTotalSize=68410
moof size=612(8+604) curTotalSize=69022
mdat size=100386(8+100378) curTotalSize=169408
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么判断mp4文件是普通mp4，还是fMP4呢？一般可以看下是否存在存在mvex（Movie Extends Box）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e3c4d17857f464ea0afe8da5d2e677c~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mvex（movie-extends-box）&quot;&gt;mvex（Movie Extends Box）&lt;/h2&gt;
&lt;p&gt;当存在mvex时，表示当前文件是fmp4（非严谨）。此时，sample相关的metadata不在moov里，需要通过解析moof box来获得。&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieExtendsBox extends Box(‘mvex’){ }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;mehd是可选的，用来声明影片的完整时长（fragment_duration）。如果不存在，则需要遍历所有的fragment，来获得完整的时长。对于fmp4的场景，fragment_duration一般没办法提前预知。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieExtendsHeaderBox extends FullBox(‘mehd’, version, 0) {
        if (version==1) {
                unsigned int(64)  fragment_duration;
        } else { // version==0
                unsigned int(32)  fragment_duration;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;trex（track-extends-box）&quot;&gt;trex（Track Extends Box）&lt;/h3&gt;
&lt;p&gt;用来给 fMP4 的 sample 设置各种默认值，比如时长、大小等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TrackExtendsBox extends FullBox(‘trex’, 0, 0){ 
        unsigned int(32) track_ID;
        unsigned int(32) default_sample_description_index; 
        unsigned int(32) default_sample_duration;
        unsigned int(32) default_sample_size;
        unsigned int(32) default_sample_flags
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字段含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;track_id：对应的 track 的 ID，比如video track、audio track 的ID；&lt;/li&gt;
&lt;li&gt;default_sample_description_index：sample description 的默认 index（指向stsd）；&lt;/li&gt;
&lt;li&gt;default_sample_duration：sample 默认时长，一般为0；&lt;/li&gt;
&lt;li&gt;default_sample_size：sample 默认大小，一般为0；&lt;/li&gt;
&lt;li&gt;default_sample_flags：sample 的默认flag，一般为0；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;default_sample_flags 占4个字节，比较复杂，结构如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老版本规范里，前6位都是保留位，新版规范里，只有前4位是保留位。is_leading 含义不是很直观，下一小节会专门讲解下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;reserved：4 bits，保留位；&lt;/li&gt;
&lt;li&gt;is_leading：2 bits，是否 leading sample，可能的取值包括：
&lt;ul&gt;&lt;li&gt;0：当前 sample 不确定是否 leading sample；（一般设为这个值）&lt;/li&gt;
&lt;li&gt;1：当前 sample 是 leading sample，并依赖于 referenced I frame 前面的 sample，因此无法被解码；&lt;/li&gt;
&lt;li&gt;2：当前 sample 不是 leading sample；&lt;/li&gt;
&lt;li&gt;3：当前 sample 是 leading sample，不依赖于 referenced I frame 前面的 sample，因此可以被解码；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sample_depends_on：2 bits，是否依赖其他sample，可能的取值包括：
&lt;ul&gt;&lt;li&gt;0：不清楚是否依赖其他sample；&lt;/li&gt;
&lt;li&gt;1：依赖其他sample（不是I帧）；&lt;/li&gt;
&lt;li&gt;2：不依赖其他sample（I帧）；&lt;/li&gt;
&lt;li&gt;3：保留值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sample_is_depended_on：2 bits，是否被其他sample依赖，可能的取值包括：
&lt;ul&gt;&lt;li&gt;0：不清楚是否有其他sample依赖当前sample；&lt;/li&gt;
&lt;li&gt;1：其他sample可能依赖当前sample；&lt;/li&gt;
&lt;li&gt;2：其他sample不依赖当前sample；&lt;/li&gt;
&lt;li&gt;3：保留值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sample_has_redundancy：2 bits，是否有冗余编码，可能的取值包括：
&lt;ul&gt;&lt;li&gt;0：不清楚是否存在冗余编码；&lt;/li&gt;
&lt;li&gt;1：存在冗余编码；&lt;/li&gt;
&lt;li&gt;2：不存在冗余编码；&lt;/li&gt;
&lt;li&gt;3：保留值；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;sample_padding_value：3 bits，填充值；&lt;/li&gt;
&lt;li&gt;sample_is_non_sync_sample：1 bits，不是关键帧；&lt;/li&gt;
&lt;li&gt;sample_degradation_priority：16 bits，降级处理的优先级（一般针对如流传过程中出现的问题）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c9729a775a84c0b9b82fc476372a427~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于-is_leading&quot;&gt;关于 is_leading&lt;/h3&gt;
&lt;p&gt;is_leading 不是特别好解释，这里贴上原文，方便大家理解。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;A leading sample (usually a picture in video) is defined relative to a reference sample, which is the immediately prior sample that is marked as “sample_depends_on” having no dependency (an I picture). A leading sample has both a composition time before the reference sample, and possibly also a decoding dependency on a sample before the reference sample. Therefore if, for example, playback and decoding were to start at the reference sample, those samples marked as leading would not be needed and might not be decodable. A leading sample itself must therefore not be marked as having no dependency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为方便讲解，下面的 leading frame 对应 leading sample，referenced frame 对应 referenced samle。&lt;/p&gt;
&lt;p&gt;以 H264编码 为例，H264 中存在 I帧、P帧、B帧。由于 B帧 的存在，视频帧的 解码顺序、渲染顺序 可能不一致。&lt;/p&gt;
&lt;p&gt;mp4文件的特点之一，就是支持随机位置播放。比如，在视频网站上，可以拖动进度条快进。&lt;/p&gt;
&lt;p&gt;很多时候，进度条定位的那个时刻，对应的不一定是 I帧。为了能够顺利播放，需要往前查找最近的一个 I帧，如果可能的话，从最近的 I帧 开始解码播放（也就是说，不一定能从前面最近的I帧播放）。&lt;/p&gt;
&lt;p&gt;将上面描述的此刻定位到的帧，称作 leading frame。leading frame 前面最近的一个 I 帧，叫做 referenced frame。&lt;/p&gt;
&lt;p&gt;回顾下 is_leading 为 1 或 3 的情况，同样都是 leading frame，什么时候可以解码（decodable），什么时候不能解码（not decodable）？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1: this sample is a leading sample that has a dependency before the referenced I‐picture (and is therefore not decodable);&lt;br/&gt;3: this sample is a leading sample that has no dependency before the referenced I‐picture (and is therefore decodable);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、is_leading 为 1 的例子： 如下所示，帧2（leading frame） 解码依赖 帧1、帧3（referenced frame）。在视频流里，从 帧2 往前查找，最近的 I帧 是 帧3。哪怕已经解码了 帧3，帧2 也解不出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8e86ab8545e4d98a302239ec4e6646f~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、is_leading 为 3 的例子： 如下所示，此时，帧2（leading frame）可以解码出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e268b132dfc5473ba225e74da3a186d9~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;moof（movie-fragment-box）&quot;&gt;moof（Movie Fragment Box）&lt;/h2&gt;
&lt;p&gt;moof是个container box，相关 metadata 在内嵌box里，比如 mfhd、 tfhd、trun 等。&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieFragmentBox extends Box(‘moof’){ }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a12d514de0264993bc7a585e4a771ca3~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;结构比较简单，sequence_number 为 movie fragment 的序列号。根据 movie fragment 产生的顺序，从1开始递增。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class MovieFragmentHeaderBox extends FullBox(‘mfhd’, 0, 0){
        unsigned int(32)  sequence_number;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;traf（track-fragment-box）&quot;&gt;traf（Track Fragment Box）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TrackFragmentBox extends Box(‘traf’){ }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 fmp4 来说，数据被氛围多个 movie fragment。一个 movie fragment 可包含多个track fragment（每个 track 包含0或多个 track fragment）。每个 track fragment 中，可以包含多个该 track 的 sample。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个 track fragment 中，包含多个 track run，每个 track run 代表一组连续的 sample。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/108fa9e7b05a4be99541472e3f38cdf2~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;tfhd 用来设置 track fragment 中 的 sample 的 metadata 的默认值。&lt;/p&gt;
&lt;p&gt;伪代码如下，除了 track_ID，其他都是 可选字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TrackFragmentHeaderBox extends FullBox(‘tfhd’, 0, tf_flags){
        unsigned int(32) track_ID;
        // all the following are optional fields 
        unsigned int(64) base_data_offset; 
        unsigned int(32) sample_description_index; 
        unsigned int(32) default_sample_duration; 
        unsigned int(32) default_sample_size; 
        unsigned int(32) default_sample_flags
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sample_description_index、default_sample_duration、default_sample_size 没什么好讲的，这里只讲解下 tf_flags、base_data_offset。&lt;/p&gt;
&lt;p&gt;首先是 tf_flags，不同 flag 的值如下（同样是求按位求或） ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0x000001 base‐data‐offset‐present：存在 base_data_offset 字段，表示 数据位置 相对于整个文件的 基础偏移量。&lt;/li&gt;
&lt;li&gt;0x000002 sample‐description‐index‐present：存在 sample_description_index 字段；&lt;/li&gt;
&lt;li&gt;0x000008 default‐sample‐duration‐present：存在 default_sample_duration 字段；&lt;/li&gt;
&lt;li&gt;0x000010 default‐sample‐size‐present：存在 default_sample_size 字段；&lt;/li&gt;
&lt;li&gt;0x000020 default‐sample‐flags‐present：存在 default_sample_flags 字段；&lt;/li&gt;
&lt;li&gt;0x010000 duration‐is‐empty：表示当前时间段不存在sample，default_sample_duration 如果存在则为0 ，；&lt;/li&gt;
&lt;li&gt;0x020000 default‐base‐is‐moof：如果 base‐data‐offset‐present 为1，则忽略这个flag。如果 base‐data‐offset‐present 为0，则当前 track fragment 的 base_data_offset 是从 moof 的第一个字节开始计算；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sample 位置计算公式为 base_data_offset + data_offset，其中，data_offset 每个 sample 单独定义。如果未显式提供 base_data_offset，则 sample 的位置的通常是基于 moof 的相对位置。&lt;/p&gt;
&lt;p&gt;举个例子，比如 tf_flags 等于 57，表示 存在 base_data_offset、default_sample_duration、default_sample_flags。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f34233d518c9489a9b624112356a22e6~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;base_data_offset 为 1263 （ftyp、moov 的size 之和为 1263）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c5d1f7ada804204a194e47e85a87b5f~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;trun（track-fragment-run-box）&quot;&gt;trun（Track Fragment Run Box）&lt;/h3&gt;
&lt;p&gt;trun 伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aligned(8) class TrackRunBox extends FullBox(‘trun’, version, tr_flags) {
   unsigned int(32)  sample_count;
   // the following are optional fields
   signed int(32) data_offset;
   unsigned int(32)  first_sample_flags;
   // all fields in the following array are optional
   {
      unsigned int(32)  sample_duration;
      unsigned int(32)  sample_size;
      unsigned int(32)  sample_flags
      if (version == 0)
         { unsigned int(32) sample_composition_time_offset; }
      else
         { signed int(32) sample_composition_time_offset; }
   }[ sample_count ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面听过，track run 表示一组连续的 sample，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sample_count：sample 的数目；&lt;/li&gt;
&lt;li&gt;data_offset：数据部分的偏移量；&lt;/li&gt;
&lt;li&gt;first_sample_flags：可选，针对当前 track run中 第一个 sample 的设置；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tr_flags 如下，大同小异：&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;0x000001 data‐offset‐present：存在 data_offset 字段；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;0x000004 first‐sample‐flags‐present：存在 first_sample_flags 字段，这个字段的值，只会覆盖第一个 sample 的flag设置；当 first_sample_flags 存在时，sample_flags 则不存在；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;0x000100 sample‐duration‐present：每个 sample 都有自己的 sample_duration，否则使用默认值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;0x000200 sample‐size‐present：每个 sample 都有自己的 sample_size，否则使用默认值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;0x000400 sample‐flags‐present：每个 sample 都有自己的 sample_flags，否则使用默认值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;0x000800 sample‐composition‐time‐offsets‐present：每个 sample 都有自己的 sample_composition_time_offset；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;0x000004 first‐sample‐flags‐present，覆盖第一个sample的设置，这样就可以把一组sample中的第一个帧设置为关键帧，其他的设置为非关键帧；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例如下，tr_flags 为 2565。此时，存在 data_offset 、first_sample_flags、sample_size、sample_composition_time_offset。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/544c682c84034ccc8f020046418a5da4~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380fd57d872848148bd51b9fd82d45bb~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编程实践：解析mp4文件结构&quot;&gt;编程实践：解析MP4文件结构&lt;/h2&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要coding。根据 mp4 文件规范，可以写个简易的 mp4 文件解析工具，比如前文对比 普通mp4、fMP4 的 box 结构，就是笔者自己写的分析脚本。&lt;/p&gt;
&lt;p&gt;核心代码如下，完整代码有点长，可以在 &lt;a href=&quot;https://github.com/chyingp/blog/tree/master/demo/2020.08.24-mp4-analyze&quot;&gt;笔者的github&lt;/a&gt; 上找到。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;class Box {
        constructor(boxType, extendedType, buffer) {
                this.type = boxType; // 必选，字符串，4个字节，box类型
                this.size = 0; // 必选，整数，4个字节，box的大小，单位是字节
                this.headerSize = 8; // 
                this.boxes = [];

                // this.largeSize = 0; // 可选，8个字节
                // this.extendedType = extendedType || boxType; // 可选，16个字节
                this._initialize(buffer);
        }

        _initialize(buffer) {                           
                this.size = buffer.readUInt32BE(0); // 4个字节
                this.type = buffer.slice(4, 8).toString(); // 4个字节

                let offset = 8;

                if (this.size === 1) {
                        this.size = buffer.readUIntBE(8, 8); // 8个字节，largeSize
                        this.headerSize += 8;
                        offset = 16;
                } else if (this.size === 1) {
                        // last box
                }

                if (this.type === 'uuid') {
                        this.type = buffer.slice(offset, 16); // 16个字节
                        this.headerSize += 16;
                }
        }

        setInnerBoxes(buffer, offset = 0) {
                const innerBoxes = getInnerBoxes(buffer.slice(this.headerSize + offset, this.size));

                innerBoxes.forEach(item =&amp;gt; {
                        let { type, buffer } = item;

                        type = type.trim(); // 备注，有些box类型不一定四个字母，比如 url、urn

                        if (this[type]) {
                                const box = this[type](buffer);
                                this.boxes.push(box);
                        } else {
                                this.boxes.push('TODO 待实现');
                                // console.log(`unknowed type: ${type}`);
                        }
                });
        }
}

class FullBox extends Box {
        constructor(boxType, buffer) {
                super(boxType, '', buffer);

                const headerSize = this.headerSize;

                this.version = buffer.readUInt8(headerSize); // 必选，1个字节
                this.flags = buffer.readUIntBE(headerSize + 1, 3); // 必选，3个字节

                this.headerSize = headerSize + 4;
        }
}

// FileTypeBox、MovieBox、MediaDataBox、MovieFragmentBox 代码有点长这里就不贴了
class Movie {
        constructor(buffer) {

                this.boxes = [];
                this.bytesConsumed = 0;

                const innerBoxes = getInnerBoxes(buffer);

                innerBoxes.forEach(item =&amp;gt; {
                        const { type, buffer, size } = item;
                        if (this[type]) {
                                const box = this[type](buffer);
                                this.boxes.push(box);
                        } else {
                                // 自定义 box 类型
                        }
                        this.bytesConsumed += size;
                });
        }

        ftyp(buffer) {
                return new FileTypeBox(buffer);
        }

        moov(buffer) {
                return new MovieBox(buffer);
        }

        mdat(buffer) {
                return new MediaDataBox(buffer);
        }

        moof(buffer) {
                return new MovieFragmentBox(buffer);
        }
}

function getInnerBoxes(buffer) {
        let boxes = [];
        let offset = 0;
        let totalByteLen = buffer.byteLength;

        do {
                let box = getBox(buffer, offset);
                boxes.push(box);

                offset += box.size;
        } while(offset &amp;lt; totalByteLen);

        return boxes;
}

function getBox(buffer, offset = 0) {
        let size = buffer.readUInt32BE(offset); // 4个字节
        let type = buffer.slice(offset + 4, offset + 8).toString(); // 4个字节

        if (size === 1) {
                size = buffer.readUIntBE(offset + 8, 8); // 8个字节，largeSize
        } else if (size === 0) {
                // last box
        }

        let boxBuffer = buffer.slice(offset, offset + size);

        return {
                size,
                type,
                buffer: boxBuffer
        };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;受限于时间，同时为了方便讲解，部分内容可能不是很严谨，如有错漏，敬请指出。如有问题，也欢迎随时交流。&lt;/p&gt;
&lt;h2 id=&quot;相关链接&quot;&gt;相关链接&lt;/h2&gt;
&lt;p&gt;ISO/IEC 14496-12:2015 Information technology — Coding of audio-visual objects — Part 12: ISO base media file format&lt;br/&gt;&lt;a href=&quot;https://www.iso.org/standard/68960.html&quot;&gt;https://www.iso.org/standard/68960.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Introduction to QuickTime File Format Specification&lt;br/&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html#//apple_ref/doc/uid/TP40000939-CH202-TPXREF101&quot;&gt;https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface.html#//apple_ref/doc/uid/TP40000939-CH202-TPXREF101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AVC_(file_format)&lt;br/&gt;&lt;a href=&quot;http://fileformats.archiveteam.org/wiki/AVC_(file_format)&quot;&gt;http://fileformats.archiveteam.org/wiki/AVC_(file_format)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AV1 Codec ISO Media File Format Binding&lt;br/&gt;&lt;a href=&quot;https://aomediacodec.github.io/av1-isobmff/&quot;&gt;https://aomediacodec.github.io/av1-isobmff/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 08 Dec 2020 00:17:00 +0000</pubDate>
<dc:creator>程序猿小卡</dc:creator>
<og:description>最近经常回答团队小伙伴关于直播 &amp; 短视频的问题，比如 “flv.js的实现原理”、“为什么设计同学给的mp4文件浏览器里播放不了、但本地可以正常播放”、“MP4兼容性很好，可不可以用来做直播” 等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chyingp/p/mp4-file-format.html</dc:identifier>
</item>
<item>
<title>Python运算符可不只有加减乘除 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14096138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14096138.html</guid>
<description>&lt;p&gt;数学里面的加减乘除，就是运算符，但是 Python 的运算符更多样，更复杂，分为算术运算符、比较运算符、赋值运算符、位运算符、逻辑运算符、成员运算符、身份运算符。为了更直观的看到运算符的使用，本文采用代码和注释结合的方式进行讲解。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 21
b = 10
c = 0

# 加
c = a + b  # 31

# 减
c = a - b  # 11

# 乘
c = a * b  # 210

# 除
c = a / b  # 2.1

# 求余数
c = a % b  # 1

# 幂（次方）
a = 2
b = 3
c = a**b  # 8

# 取整数，向下取接近商的整数
c = 9//2  # 4
c = -9//2  # -5
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;代码中的 &lt;code&gt;if ... else ...&lt;/code&gt; 是指“如果，满足条件，做什么事，否则，做其他事”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 21
b = 10
c = 0

# 等于
if ( a == b ):
   print(&quot;a 等于 b&quot;)
else:
   print(&quot;a 不等于 b&quot;)

# 不等于
if ( a != b ):
   print(&quot;a 不等于 b&quot;)
else:
   print(&quot;a 等于 b&quot;)

# 小于
if ( a &amp;lt; b ):
   print(&quot;a 小于 b&quot;)
else:
   print(&quot;a 大于等于 b&quot;)

# 大于
if ( a &amp;gt; b ):
   print(&quot;a 大于 b&quot;)
else:
   print(&quot;a 小于等于 b&quot;)
 
a = 5
b = 20

# 小于等于
if ( a &amp;lt;= b ):
   print(&quot;a 小于等于 b&quot;)
else:
   print(&quot;a 大于  b&quot;)

# 大于等于
if ( b &amp;gt;= a ):
   print(&quot;b 大于等于 a&quot;)
else:
   print(&quot;b 小于 a&quot;)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 是赋值运算符，算术运算符都可以右边加上 &lt;code&gt;=&lt;/code&gt; 变成“算术赋值”运算符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 21
b = 10
c = 0

# 简单的赋值
c = a + b  # 31

# 等价于 c = c + a
c += a  # 52

# 等价于 c = c - a
c -= a  # 31

# 等价于 c = c * a
c *= a  # 651

# 等价于 c = c / a
c /= a  # 31.0
 
c = 2
# 等价于 c = c % a
c %= a  # 2

# 等价于 c = c ** a
c **= a  # 2097152

# 等价于 c = c // a
c //= a  # 99864
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Python3.8 新增了海象运算符 &lt;code&gt;:=&lt;/code&gt;，可以在表达式内部为变量赋值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;if (n := len(a)) &amp;gt; 10:
    print(f&quot;List is too long ({n} elements, expected &amp;lt;= 10)&quot;)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们常见的数字是十进制的，十进制可以转换为 01 形式的二进制，例如 60 的转换为二进制后变成了 0011 1100。位运算符就是把数字看作二进制来进行计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 
c = 0

# 与，两个值都为1，结果为1，否则为0
c = a &amp;amp; b        # 12 = 0000 1100

# 或，两个值有一个为1，结果就为1
c = a | b        # 61 = 0011 1101 

# 异或，两个值不同，结果为1
c = a ^ b        # 49 = 0011 0001

# 取反，0变成1,1变成0
c = ~a           # -61 = 1100 0011

# 左移，高位丢弃，低位补0
c = a &amp;lt;&amp;lt; 2       # 240 = 1111 0000

# 右移，低位丢弃，高位补0
c = a &amp;gt;&amp;gt; 2       # 15 = 0000 1111
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;经常用在判断条件里面，判断条件为 True / False。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 10
b = 20

# 布尔“与”，2个值都为True，结果为True
if ( a and b ):
   print(&quot;变量 a 和 b 都为 true&quot;)
else:
   print(&quot;变量 a 和 b 有一个不为 true&quot;)

# 布尔“或”，只要有一个为True，结果就为True
if ( a or b ):
   print(&quot;变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print(&quot;变量 a 和 b 都不为 true&quot;)
 
# 修改变量 a 的值
a = 0
if ( a and b ):
   print(&quot;变量 a 和 b 都为 true&quot;)
else:
   print(&quot;变量 a 和 b 有一个不为 true&quot;)
 
if ( a or b ):
   print(&quot;变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print(&quot;变量 a 和 b 都不为 true&quot;)
 
if not( a and b ):
   print(&quot;变量 a 和 b 都为 false，或其中一个变量为 false&quot;)
else:
   print(&quot;变量 a 和 b 都为 true&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，逻辑运算符是从左到右依次运算的，只要不符合条件就不会继续运算，比如 and，只要出现了 False，就会停止运算，结果直接判定为 False。比如 or，只要出现了 True，就会停止运算，结果直接判定为 True。&lt;/p&gt;

&lt;p&gt;成员是指字符串、列表、元组等系列中的元素，成员运算符用于判断元素是否在系列里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 10
b = 20
list = [1, 2, 3, 4, 5 ]

# in 在里面
if ( a in list ):
   print(&quot;变量 a 在给定的列表中 list 中&quot;)
else:
   print(&quot;变量 a 不在给定的列表中 list 中&quot;)

# not in 不在里面
if ( b not in list ):
   print(&quot;变量 b 不在给定的列表中 list 中&quot;)
else:
   print(&quot;变量 b 在给定的列表中 list 中&quot;)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Python 里面的对象其实都有一个内存地址，可以使用 &lt;code&gt;id()&lt;/code&gt; 函数来获取，身份就是指的内存地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 20
b = a
 
if ( a is b ):
   print(&quot;a 和 b 有相同的标识&quot;)  # 结果
else:
   print(&quot;a 和 b 没有相同的标识&quot;)
 
if ( id(a) == id(b) ):
   print(&quot;a 和 b 有相同的标识&quot;)  # 结果
else:
   print(&quot;a 和 b 没有相同的标识&quot;)
 
# 修改变量 b 的值
b = 30
if ( a is b ):
   print(&quot;a 和 b 有相同的标识&quot;)
else:
   print(&quot;a 和 b 没有相同的标识&quot;)  # 结果
 
if ( a is not b ):
   print(&quot;a 和 b 没有相同的标识&quot;)  # 结果
else:
   print(&quot;a 和 b 有相同的标识&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在前面知道 &lt;code&gt;==&lt;/code&gt; 是可以判断变量是否相等的，注意，&lt;code&gt;==&lt;/code&gt; 判断的是值是否相等，&lt;code&gt;is&lt;/code&gt; 判断的是引用（内存地址）是否相等。&lt;/p&gt;

&lt;p&gt;不用刻意记优先级，实际编码时请尽情滥用小括号 &lt;code&gt;()&lt;/code&gt;，防止优先级算错。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数 (最高优先级)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;~ + -&lt;/td&gt;
&lt;td&gt;按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;* / % //&lt;/td&gt;
&lt;td&gt;乘，除，求余数和取整除&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;加法减法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt;&amp;gt; &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;右移，左移运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;位 'AND'&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;^ |&lt;/td&gt;
&lt;td&gt;位运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;lt;= &amp;lt; &amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td&gt;比较运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;== !=&lt;/td&gt;
&lt;td&gt;等于运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;= %= /= //= -= += *= **=&lt;/td&gt;
&lt;td&gt;赋值运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;is is not&lt;/td&gt;
&lt;td&gt;身份运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;in not in&lt;/td&gt;
&lt;td&gt;成员运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;not and or&lt;/td&gt;
&lt;td&gt;逻辑运算符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;本文以实例的形式直观的介绍了 Python 运算符的使用。运算符是 Python 中相对简单的知识点。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python3/python3-basic-operators.html&quot;&gt;https://www.runoob.com/python3/python3-basic-operators.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 23:59:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>数学里面的加减乘除，就是运算符，但是 Python 的运算符更多样，更复杂，分为算术运算符、比较运算符、赋值运算符、位运算符、逻辑运算符、成员运算符、身份运算符。为了更直观的看到运算符的使用，本文采用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14096138.html</dc:identifier>
</item>
<item>
<title>.NET 开源导入导出库 Magicodes.IE 2.5发布 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/14100687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/14100687.html</guid>
<description>&lt;p&gt;今天我们发布了2.5版本，这当然也离不开大家对&lt;code&gt;Magicodes.IE&lt;/code&gt;的支持，今天我也是跟往常一样列举了该版本一些重要的更新内容。&lt;/p&gt;
&lt;p&gt;当然也要说一下，在这个版本中我们设计了全新的LOGO&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-7c871463-411f-4be3-b1aa-b38dae0ae981.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;excel导出&quot;&gt;Excel导出&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Excel导出支持HeaderRowIndex &lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE/issues/164&quot;&gt;#164&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在&lt;code&gt;ExcelExporterAttribute&lt;/code&gt;导出特性类中添加&lt;code&gt;HeaderRowIndex&lt;/code&gt;属性，方便导出时去指定从第一行开始导出。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加Excel枚举导出对DescriptionAttribute的支持 &lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE/issues/168&quot;&gt;#168&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在导出枚举类型时起初我们可以通过ValueMapping和导出枚举本身的字符串名称，在现在我们可以通过&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.descriptionattribute?WT.mcid=DT-MVP-5003855&quot;&gt;DescriptionAttribute&lt;/a&gt;、&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.DisplayAttribute?WT.mcid=DT-MVP-5003855&quot;&gt;DisplayAttribute&lt;/a&gt;,&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.DisplayNameAttribute?WT.mcid=DT-MVP-5003855&quot;&gt;DisplayNameAttribute&lt;/a&gt;&lt;br/&gt;实现Text值导出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;enum Sex
{
        /// &amp;lt;summary&amp;gt;
        /// 男
        /// &amp;lt;/summary&amp;gt;
        [Description(&quot;男&quot;)]
        boy = 1,
        /// &amp;lt;summary&amp;gt;
        /// 女
        /// &amp;lt;/summary&amp;gt;
        [Description(&quot;女&quot;)]
        girl = 2
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;TableStyle修改为枚举类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这之前我们将&lt;code&gt;TableStyle&lt;/code&gt;属性放在了&lt;code&gt;ExporterAttribute&lt;/code&gt;基础特性中，起初我们的TableStyle属性为字符串，&lt;br/&gt;但是带给了我们不必要的麻烦，很难让使用者去查找这些样式名称，所以此处我们将其换成了枚举类型，方便使用者从列表中&lt;br/&gt;进行查找相关样式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;  [ExcelExporter(Name = &quot;测试&quot;, TableStyle = TableStyles.Light10)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;excel导入&quot;&gt;Excel导入&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Excel生成导入模板支持内置数据验证&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE/issues/167&quot;&gt;#167&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于内置数据验证的支持可通过&lt;code&gt;IsInterValidation&lt;/code&gt;属性开启，并且需要注意的是仅&lt;br/&gt;支持&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.dataannotations.maxlengthattribute?WT.mc_id=DT-MVP-5003855&amp;amp;view=net-5.0&quot;&gt;MaxLengthAttribute&lt;/a&gt;、&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.dataannotations.minlengthattribute?WT.mc_id=DT-MVP-5003855&quot;&gt;MinLengthAttribute&lt;/a&gt;、&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.dataannotations.StringLengthAttribute?WT.mc_id=DT-MVP-5003855&amp;amp;view=net-5.0&quot;&gt;StringLengthAttribute&lt;/a&gt;、&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.dataannotations.RangeAttribute?WT.mc_id=DT-MVP-5003855&amp;amp;view=net-5.0&quot;&gt;RangeAttribute&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持对内置数据验证的开启操作。&lt;br/&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-ab2a0fc7-ce9c-48f1-b9d9-ce6e68f5d1c2.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-eb2e85c4-46d3-4640-9451-4947949532bc.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持对输入提示的展示操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-e0def8aa-343a-4dc0-b100-41089b7f4400.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class GenerateStudentImportSheetDataValidationDto
    {
        /// &amp;lt;summary&amp;gt;
        ///     序号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;序号&quot;, IsInterValidation = true)]
        [Range(minimum: 0, maximum: 20, ErrorMessage = &quot;序号最大为20&quot;)]
        public long SerialNumber { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     学籍号
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;学籍号&quot;, IsAllowRepeat = false, IsInterValidation = true)]
        [MaxLength(30, ErrorMessage = &quot;学籍号字数超出最大限制,请修改!&quot;)]
        public string StudentCode { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     姓名
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;姓名&quot;)]
        [Required(ErrorMessage = &quot;学生姓名不能为空&quot;)]
        [MaxLength(50, ErrorMessage = &quot;名称字数超出最大限制,请修改!&quot;)]
        public string Name { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     年龄
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;年龄&quot;, IsInterValidation = true)]
        [Range(minimum: 18, maximum: 20, ErrorMessage = &quot;年龄范围需要在18-20岁哦&quot;)]
        public int Age { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     MinTest
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;MinTest&quot;, IsInterValidation = true)]
        [MinLength(5, ErrorMessage = &quot;最小长度为5哦&quot;)]
        public string MinTest { get; set; }

        /// &amp;lt;summary&amp;gt;
        ///     忽略类型
        /// &amp;lt;/summary&amp;gt;
        [ImporterHeader(Name = &quot;忽略类型&quot;, IsInterValidation = true)]
        [Range(minimum: 18, maximum: 20, ErrorMessage = &quot;年龄范围需要在18-20岁哦&quot;, ErrorMessageResourceType = typeof(string))]
        public int IgnoreType { get; set; }

        [ImporterHeader(Name = &quot;出生日期&quot;, IsInterValidation = true, ShowInputMessage = &quot;输入日期&quot;)]
        [Range(typeof(DateTime), minimum: &quot;2020-10-20&quot;, maximum: &quot;2020-10-24&quot;, ErrorMessage = &quot;日期范围超出了哦&quot;)]
        public DateTime Birthday { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：数据范围验证仅支持DateTime和int类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;导入对ColumnIndex的支持&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE/issues/198&quot;&gt;#198&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导入功能支持&lt;code&gt;ColumnIndex&lt;/code&gt;可以通过去指定某一列数据列，这样在复杂的列名时结构时，我们也可以直接&lt;br/&gt;轻松的应对&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.stackable.cn/uploads/img-96a6523a-9130-42ec-b71f-c77f9645f23b.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[ImporterHeader(Name = &quot;年龄&quot;, ColumnIndex = 3)]
public int? Age { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;欢迎扫码加入微信群&lt;/p&gt;
&lt;img width=&quot;25%&quot; src=&quot;https://blog.stackable.cn/uploads/img-9b4d1538-f1db-4845-a7d3-8a21ee18d4c0.png&quot;/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE&quot;&gt;https://github.com/dotnetcore/Magicodes.IE&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Dec 2020 23:56:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>今天我们发布了2.5版本，这当然也离不开大家对Magicodes.IE的支持，今天我也是跟往常一样列举了该版本一些重要的更新内容。 当然也要说一下，在这个版本中我们设计了全新的LOGO Excel导出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/14100687.html</dc:identifier>
</item>
<item>
<title>Kubernetes的Local Persistent Volumes使用小记 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14100683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14100683.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于local-persistent-volumes&quot;&gt;关于Local Persistent Volumes&lt;/h3&gt;
&lt;p&gt;文中将Local Persistent Volumes简称为Local PV；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kubernetes的Local PV自1.7版本进行alpha发布，在1.10版本beta发布，最终的正式发布(General Availability)是在1.14版本；&lt;/li&gt;
&lt;li&gt;一个Local PV对应指定节点上的一处本地磁盘空间；&lt;/li&gt;
&lt;li&gt;相比NFS之类的远程存储，Local PV提供了本地IO带来的更好性能；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;和hostpath-volume的区别&quot;&gt;和HostPath Volume的区别&lt;/h3&gt;
&lt;p&gt;Local PV出现之前，使用本地磁盘的方法是HostPath Volume，同为使用本地磁盘，区别在哪呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最重要的区别，就是Local PV和具体节点是有关联的，这意味着使用了Local PV的pod，重启多次都会被Kubernetes scheduler调度到同一节点，而如果用的是HostPath Volume，每次重启都可能被Kubernetes scheduler调度到新的节点，然后使用同样的本地路径；&lt;/li&gt;
&lt;li&gt;当我们要用HostPath Volume的时候，既可以在PVC声明，又可以直接写到Pod的配置中，但是Local PV只能在PVC声明，对于PV资源，通常都有专人管理，这样就避免了Pod开发者擅自使用本地磁盘带来的冲突和风险；&lt;/li&gt;
&lt;li&gt;另外要注意的是，HostPath Volume和Local PV都是在使用本地磁盘，和常见的分布式文件系统相比，本地磁盘故障会导致数据丢失，&lt;span&gt;保存重要数据请勿使用HostPath Volume和Local PV&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基本概念说完了，接下来实战体验；&lt;/p&gt;
&lt;h3 id=&quot;实战环境信息&quot;&gt;实战环境信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.8.2003 (Core)&lt;/li&gt;
&lt;li&gt;kubernetes：1.15.3&lt;/li&gt;
&lt;li&gt;helm：2.16.1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;体验local-pv的步骤简述&quot;&gt;体验Local PV的步骤简述&lt;/h3&gt;
&lt;p&gt;本次实战的目标是快速创建Local PV，并验证该Local PV正常可用，全文由以下部分组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建Local PV；&lt;/li&gt;
&lt;li&gt;通过helm下载tomcat的chart；&lt;/li&gt;
&lt;li&gt;修改chart，让tomcat使用刚才创建的Local PV；&lt;/li&gt;
&lt;li&gt;部署tomcat；&lt;/li&gt;
&lt;li&gt;在服务器上检查文件夹已正常写入；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;如果您想了解Kubernetes和helm的更多信息，请参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/103106314&quot;&gt;《kubespray2.11安装kubernetes1.15》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/103667500&quot;&gt;《部署和体验Helm(2.16.1版本)》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕，开始实操；&lt;/p&gt;
&lt;h3 id=&quot;创建pv&quot;&gt;创建PV&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在kubernetes工作节点创建文件夹给Local PV使用，我这是：&lt;span&gt;/root/temp/202005/24/local-pv/&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;给上述文件夹读写权限：&lt;span&gt;chmod -R a+r,a+w /root/temp/202005/24/local-pv&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;创建文件&lt;span&gt;local-storage-pv.yaml&lt;/span&gt;，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /root/temp/202005/24/local-pv
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;关于local-storage-pv.yaml有以下几点需要注意：&lt;br/&gt;a. spec.storageClassName等于&lt;span&gt;local-storage&lt;/span&gt;，后面的PVC中也要指定storageClassName等于&lt;span&gt;local-storage&lt;/span&gt;；&lt;br/&gt;b. spec.nodeAffinity是必填参数，用于建立Local PV和节点的关系，spec.nodeAffinity.required,nodeSelectorTerms.matchExpressions.values的值包含&lt;span&gt;node1&lt;/span&gt;，表示该Local PV可以在主机名为&lt;span&gt;node1&lt;/span&gt;的节点创建；&lt;/li&gt;
&lt;li&gt;执行命令&lt;span&gt;kubectl apply -f local-storage-pv.yaml&lt;/span&gt;，即可创建PV；&lt;/li&gt;
&lt;li&gt;执行&lt;span&gt;kubectl describe pv example-pv&lt;/span&gt;检查是否创建成功，如下图红框所示，此PV已经可用：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074135716-846394936.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用pv&quot;&gt;使用PV&lt;/h3&gt;
&lt;p&gt;接下来通过helm部署tomcat，并且让tomcat使用上述Local PV，请确保helm已经装好;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;增加helm仓库(带有tomcat的仓库)：&lt;span&gt;helm repo add bitnami &lt;a href=&quot;https://charts.bitnami.com/bitnami&quot;&gt;https://charts.bitnami.com/bitnami&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;下载tomcat的chart：&lt;span&gt;helm fetch bitnami/tomcat&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;chart下载成功后，当前目录出现tomcat配置压缩包tomcat-6.2.4.tgz，解压：&lt;span&gt;tar -zxvf tomcat-6.2.4.tgz&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;解压得到tomcat文件夹，进入后打开values.yaml文件，找到&lt;span&gt;persistence&lt;/span&gt;节点，增加下图红框中的内容：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074137005-1268924347.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在tomcat目录下执行命令：&lt;span&gt;helm install --name-template tomcat001 -f values.yaml . --namespace hello-storageclass&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查看tomcat的pod和service情况，一切正常，并且端口映射到了宿主机的31835：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074137752-239355716.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;span&gt;宿主机IP:31835&lt;/span&gt;，出现tomcat欢迎页面：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074138873-1832822747.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;去目录&lt;span&gt;/root/temp/202005/24/local-pv/&lt;/span&gt;检查磁盘使用情况，如下图，可见已分配给tomcat的PVC，并且写入了tomcat的基本数据：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074139832-771586843.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;再次查看Local PV，发现状态已经改变：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201208074141001-1061044729.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此可以确认，tomcat用上了Local PV，数据被保存在宿主机的指定文件夹；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;清理local-pv&quot;&gt;清理Local PV&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一般来说，清理PV要做如下操作：&lt;br/&gt;a. 删除pod，或者deployment；&lt;br/&gt;b. 删除pvc；&lt;br/&gt;c. 删除Local PV；&lt;/li&gt;
&lt;li&gt;这里由于用上了helm，因此通过helm将上述步骤1和2执行掉，既命令helm delete tomcat001&lt;/li&gt;
&lt;li&gt;再在local-storage-pv.yaml所在目录执行kubectl delete -f local-storage-pv.yaml即可删除Local PV；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，Local PV的学习和实践就完成了，如果您正在使用这种存储，希望本文能给您一些参考；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 07 Dec 2020 23:42:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14100683.html</dc:identifier>
</item>
<item>
<title>Android10_原理机制系列_事件传递机制 - 流浪_归家</title>
<link>http://www.cnblogs.com/fanglongxiang/p/14091511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanglongxiang/p/14091511.html</guid>
<description>&lt;p&gt;Android的输入设备，最常用的就是 触摸屏和按键 了。当然还有其他方式，比如游戏手柄，比如支持OTG设备，则可以链接鼠标、键盘等。&lt;br/&gt;那么这些设备的操作 是如何传递到系统 并 控制界面的呢？系统如何知道是如何知道点击了某个界面按钮，按了某个按键，知道交给哪个应用处理的？&lt;br/&gt;该篇主要介绍这些，即 &lt;strong&gt;输入事件从生成(存于设备节点中) 传递到目标View的过程。&lt;/strong&gt; 在进入输入事件传递机制之前，首先了解一个东西---设备节点。&lt;/p&gt;
&lt;h2 id=&quot;了解设备节点&quot;&gt;&lt;span&gt;了解设备节点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当有输入事件时，Linux内核会将事件数据写入 设备节点 中，供上层读取最终传递到具体的View中。 该备节点 位于/dev/input/。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-查看：输入事件相关设备信息&quot;&gt;1. 查看：输入事件相关设备信息&lt;/h3&gt;
&lt;p&gt;与事件相关的设备信息位于：/proc/bus/input/devices。&lt;br/&gt;下面是一部分，大致了解下。Name对应的Handlers注意下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//查看所有事件相关设备信息
$ adb shell cat /proc/bus/input/devices
    I: Bus=0019 Vendor=0000 Product=0000 Version=0000
    N: Name=&quot;ACCDET&quot;
    P: Phys=
    S: Sysfs=/devices/virtual/input/input0
    U: Uniq=
    H: Handlers=event0
    B: PROP=0
    B: EV=23
    B: KEY=40 0 0 0 0 0 0 0 0 0 0 0 0 10 0 c0000 0 0 0
    B: SW=d4

    I: Bus=0019 Vendor=2454 Product=6500 Version=0010
    N: Name=&quot;mtk-kpd&quot;
    P: Phys=
    S: Sysfs=/devices/platform/10010000.kp/input/input1
    U: Uniq=
    H: Handlers=event1
    B: PROP=0
    B: EV=3
    B: KEY=1000000 0 0 0 0 0 0 0 0 1c0000 0 0 0
    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-命令：getevent-和-sendenvent&quot;&gt;2. 命令：getevent 和 sendenvent&lt;/h3&gt;
&lt;h4 id=&quot;21-getevent&quot;&gt;2.1 getevent&lt;/h4&gt;
&lt;p&gt;通过设备的getevent命令，可以查看输入事件的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取输入事件，这里是按了下电源键
$ adb shell getevent
    add device 1: /dev/input/event0
      name:     &quot;ACCDET&quot;
    add device 2: /dev/input/event2
      name:     &quot;sf-keys&quot;
    add device 3: /dev/input/event3
      name:     &quot;mtk-tpd&quot;
    add device 4: /dev/input/event1
      name:     &quot;mtk-kpd&quot;
    /dev/input/event1: 0001 0074 00000001
    /dev/input/event1: 0000 0000 00000000
    /dev/input/event1: 0001 0074 00000000
    /dev/input/event1: 0000 0000 00000000

//从/proc/bus/input/devices获取到要关注的设备的节点，可以单独获取
//下面是获取也是按的电源键获取到的
$ adb shell getevent  /dev/input/event1
    0001 0074 00000001
    0000 0000 00000000
    0001 0074 00000000
    0000 0000 00000000

//多了解参数，这个-l就很清楚了
//-l: label event types and names in plain text
$ adb shell getevent -l /dev/input/event1
    EV_KEY       KEY_POWER            DOWN
    EV_SYN       SYN_REPORT           00000000
    EV_KEY       KEY_POWER            UP
    EV_SYN       SYN_REPORT           00000000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面列出的3种，第一种没有参数 获取所有输入事件。加上 &lt;strong&gt;-l参数&lt;/strong&gt; 的结果就很清晰了。&lt;br/&gt;&lt;strong&gt;事件类型：&lt;/strong&gt; 0001 即 EV_KEY，按键&lt;br/&gt;&lt;strong&gt;事件代码：&lt;/strong&gt; 0074 即 KEY_POWER，电源键&lt;br/&gt;&lt;strong&gt;事件的值：&lt;/strong&gt; 00000001 即 DOWN，按下；00000000 即 UP，抬起。&lt;/p&gt;
&lt;p&gt;/dev/input/event1: 0001 0074 00000001 就是 电源键按下了。&lt;br/&gt;/dev/input/event1: 0001 0074 00000000 就是 电源键抬起了。&lt;/p&gt;
&lt;p&gt;注意：这里的值 都是 16进制的。&lt;/p&gt;
&lt;p&gt;触摸屏幕也一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//触摸屏幕截取
/dev/input/event3: EV_ABS       ABS_MT_TOUCH_MAJOR   0000001e
/dev/input/event3: EV_ABS       ABS_MT_TRACKING_ID   00000000
/dev/input/event3: EV_ABS       ABS_MT_POSITION_X    000001b5
/dev/input/event3: EV_ABS       ABS_MT_POSITION_Y    000001e1
/dev/input/event3: EV_SYN       SYN_MT_REPORT        00000000
/dev/input/event3: EV_SYN       SYN_REPORT           00000000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;22-sendenvent&quot;&gt;2.2 sendenvent&lt;/h4&gt;
&lt;p&gt;输入事件 设备节点也是可写的，通过sendevent可模拟用户输入。&lt;br/&gt;但 &lt;strong&gt;sendevent 的参数是 十进制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;格式：sendevent &amp;lt;设备节点&amp;gt; &amp;lt;事件类型&amp;gt; &amp;lt;事件代码&amp;gt; &amp;lt;事件的值&amp;gt;&lt;/p&gt;
&lt;p&gt;所以getevent中，电源按下/抬起的：事件类型即1，事件代码即116，事件的值即1/0。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//电源键按下
$ adb shell sendevent /dev/input/event1 1 116 1
//电源键抬起
$ adb shell sendevent /dev/input/event1 1 116 0
//由上述getevent个人理解，0 0 0上报后生效，同按一次电源键操作
$ adb shell sendevent /dev/input/event1 0 0 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;该篇也是基于Android10的代码分析。 该篇写时后期调整过几次标题编号，如果文中有参考的编号不对应，请指出。下面图片由于博客显示不是原图，可能部分不清晰，可以单独查看图片原图。&lt;br/&gt;文章很长，但分的3个模块比较清晰，可以根据需要查看。&lt;br/&gt;好，这里正式开始了。&lt;/p&gt;&lt;p&gt;下面是画的一张图，即本章的大致内容。也是方便自己查阅，&lt;strong&gt;主要介绍了 输入事件是如何从 设备节点中 传递到具体的View的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整篇文章比较长，需要耐心。事件传递的过程 与 WMS关系比较密切，若有需要可以先参考：&lt;a href=&quot;https://www.cnblogs.com/fanglongxiang/p/13995868.html&quot;&gt;Android10_原理机制系列_Activity窗口添加到WMS过程&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/fanglongxiang/p/13951212.html&quot;&gt;Android10_原理机制系列_Window介绍及WMS的启动过程。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;若有不对，欢迎指出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git.oschina.net/flx_fdbm/BlogPictures/raw/master/ims/wms_ims.png&quot; alt=&quot;wms_ims&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图中&lt;strong&gt;3个红色虚线框：&lt;/strong&gt; 即下面输入事件传递 介绍的3部分内容。IMS中事件的读取和派发；WMS中Window获取事件和传递；View中事件的传递和处理。&lt;/li&gt;
&lt;li&gt;图中&lt;strong&gt;2种颜色区域：&lt;/strong&gt; 标识2个进程。system_server 和 应用进程。&lt;/li&gt;
&lt;li&gt;图中&lt;strong&gt;红色实线箭头：&lt;/strong&gt; 文章介绍的 事件传递的 主要过程。&lt;/li&gt;
&lt;li&gt;图中&lt;strong&gt;2个红色虚线箭头：&lt;/strong&gt; 列出了 两个比较常见的policy拦截的大致阶段 (当然不止这两个)，说明了最终如何回调到PhoneWindowManager的同名方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;输入事件的传递过程，如概述中所述，这里分成了3个部分来说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IMS中事件的读取和派发&lt;/li&gt;
&lt;li&gt;WMS中Window获取事件和传递&lt;/li&gt;
&lt;li&gt;View中事件的传递和处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来具体看看。&lt;/p&gt;
&lt;h2 id=&quot;1--ims中事件的读取和派发&quot;&gt;&lt;span&gt;1. IMS中事件的读取和派发&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们从IMS(InputManagerService)的创建和启动开始看。&lt;/p&gt;
&lt;p&gt;IMS是在SystemServer的 startOtherServices() 方法中启动。（之前总结了AMS/PMS/WMS等，这里类似）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//SystemServer.java
private void startOtherServices() {
    WindowManagerService wm = null;
    InputManagerService inputManager = null;
    try {
        //参考1.1，创建IMS对象
        inputManager = new InputManagerService(context);
        wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,
                new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);
        //注册服务：&quot;input&quot;
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager,
                /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL);
        //参考1.4，设置回调
        inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());
        //参考1.5， 启动
        inputManager.start();
    }
    final InputManagerService inputManagerF = inputManager;
    mActivityManagerService.systemReady(() -&amp;gt; {
        try {
            if (inputManagerF != null) {
                inputManagerF.systemRunning();
            }
        }
    }, BOOT_TIMINGS_TRACE_LOG);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SystemServer中 关于IMS主要看3个内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;new InputManagerService()，最后进入native 最终创建了InputManager及一系列相关内容。&lt;/li&gt;
&lt;li&gt;inputManager.setWindowManagerCallbacks(），设置了回调，这里说明了 最终如何回调到PhoneWindowManager。&lt;/li&gt;
&lt;li&gt;inputManager.start()，主要是IntputManager中两个线程运行起来。InputReaderThread读取和处理，InputDispatcherThread派发。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;11--创建了inputmanager&quot;&gt;1.1 创建了InputManager&lt;/h3&gt;
&lt;p&gt;先看IMS的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputManagerService.java
public class InputManagerService extends IInputManager.Stub implements Watchdog.Monitor {
    private static native long nativeInit(InputManagerService service,
        Context context, MessageQueue messageQueue);
    
    public InputManagerService(Context context) {
        this.mContext = context;
        //创建了InputManagerHandler，其Looper是DisplayThead的Looper
        this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper());
        //进入native，并返回了mPtr
        mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue());
        LocalServices.addService(InputManagerInternal.class, new LocalService());
    }
    
    private final class InputManagerHandler extends Handler {
        public InputManagerHandler(Looper looper) {
            super(looper, null, true /*async*/);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到 this.mHandler 的Looper 是 DisplayThread的Looper。 这个Looper的消息队列 作为参数 传入到 nativeInit() 方法中。关于Looper，如果不太了解，也可以参考：&lt;a href=&quot;https://www.cnblogs.com/fanglongxiang/p/13285896.html&quot;&gt;Android10_原理机制系列_Android消息机制(Handler)详述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面进入 nativeInit() 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//com_android_server_input_InputManagerService.cpp
static const JNINativeMethod gInputManagerMethods[] = {
    /* name, signature, funcPtr */
    { &quot;nativeInit&quot;,
     &quot;(Lcom/android/server/input/InputManagerService;Landroid/content/Context;Landroid/os/MessageQueue;)J&quot;,
      (void*) nativeInit },
}

static jlong nativeInit(JNIEnv* env, jclass /* clazz */,
        jobject serviceObj, jobject contextObj, jobject messageQueueObj) {
    sp&amp;lt;MessageQueue&amp;gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    ...
    //创建NativeInputManager
    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,
            messageQueue-&amp;gt;getLooper());
    //system/core/libutils/RefBase.cpp查看
    im-&amp;gt;incStrong(0);
    //返回给IMS，IMS后续会用到。IMS保存在mPtr。
    return reinterpret_cast&amp;lt;jlong&amp;gt;(im);
}

//com_android_server_input_InputManagerService.cpp
//NativeInputManager的构造方法：
NativeInputManager::NativeInputManager(jobject contextObj,
        jobject serviceObj, const sp&amp;lt;Looper&amp;gt;&amp;amp; looper) :
        mLooper(looper), mInteractive(true) {
    //创建InputManager
    mInputManager = new InputManager(this, this);
    defaultServiceManager()-&amp;gt;addService(String16(&quot;inputflinger&quot;),
            mInputManager, false);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里看到，nativeInit() 中创建NativeInputManager。 返回给IMS的是 &lt;code&gt;reinterpret_cast&amp;lt;jlong&amp;gt;(im)&lt;/code&gt; ，这是某种转换，可以看作是将NativeInputManager返回给了java层。&lt;/p&gt;
&lt;p&gt;NativeInputManager中又创建了 InputManager。接着看InputManager的创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputManager.cpp
InputManager::InputManager(
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; readerPolicy,
        const sp&amp;lt;InputDispatcherPolicyInterface&amp;gt;&amp;amp; dispatcherPolicy) {
    //创建InputDispatcher
    mDispatcher = new InputDispatcher(dispatcherPolicy);
    mClassifier = new InputClassifier(mDispatcher);
    //创建InputReader
    mReader = createInputReader(readerPolicy, mClassifier);
    //创建了两个线程 InputReaderThread和InputDispatcherThread
    initialize();
}

void InputManager::initialize() {
    mReaderThread = new InputReaderThread(mReader);
    mDispatcherThread = new InputDispatcherThread(mDispatcher);
}

//InputReaderFactory.cpp
sp&amp;lt;InputReaderInterface&amp;gt; createInputReader(
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; policy,
        const sp&amp;lt;InputListenerInterface&amp;gt;&amp;amp; listener) {
    //EventHub作为参数 传入InputReader
    return new InputReader(new EventHub(), policy, listener);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码，可以看到，InputManager中基本都是创建操作，创建了InputDispatcher、InputClassifier、InputReader、EventHub、InputReaderThread、InputDispatcherThread。&lt;/p&gt;
&lt;p&gt;下面会逐步看到他们的作用 以及如何运行的。 &lt;strong&gt;这里先简单说明下其中几个主要的部分，&lt;/strong&gt; 先有个大致了解。&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;EventHub：创建InputReader时 可以看到先创建了EventHub作为参数。&lt;/p&gt;
&lt;p&gt;EventHub 通过Linux内核的INotify与Epoll机制 监听设备，可直接访问 设备节点。通过 getEvents() 方法 读取设备节点的原始输入事件 数据。&lt;/p&gt;
&lt;p&gt;关于 EventHub的创建 这里不讨论了，这里只需简单了解它上面一点就可以了。它涉及内核和一些机制，暂时我也还不熟悉，哈哈。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;InputReader：负责输入事件的获取。在独立线程（InputReaderThread）中 循环执行，有以下几个功能：&lt;/p&gt;
&lt;p&gt;功能1-通过 EventHub 不断 &lt;strong&gt;获取设备节点的 原始输入数据&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;功能2-然后 &lt;strong&gt;进行加工处理后 交由 InputDispatcher分派&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;功能3-它还有 &lt;strong&gt;管理 输入设备列表和配置&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;InputDispatcher：负责输入事件的派发。在独立线程（InputDispatcherThread）中运行，其保存有WMS的所有窗口信息。&lt;/p&gt;
&lt;p&gt;在接收到 InputReader 的输入事件后，会在窗口信息中找到合适的 窗口 并 派发消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;InputReaderThread、InputDispatcherThread：因为InputReader 和 InputDispatcher都是耗时操作，因此创建 单独线程 来运行他们。这就是他们运行的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建完成后，他们是如何联系 并 运行的？&lt;/p&gt;
&lt;p&gt;这个下面从 InputReaderThread和InputDispatcherThread两个线程的运行起来 理一下就可以大致了解。&lt;/p&gt;
&lt;h3 id=&quot;12-inputreaderthread的运行inputreader读取和处理事件&quot;&gt;1.2 InputReaderThread的运行:InputReader读取和处理事件&lt;/h3&gt;
&lt;p&gt;这里从InputReaderThread的运行开始介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于InputReaderThread和InputDispatcherThread 是如何运行起来，如何执行的threadLoop()&lt;/strong&gt; ，后面也介绍了，请参考1.5&lt;/p&gt;
&lt;h4 id=&quot;121-inputreader-获取输入事件&quot;&gt;1.2.1 InputReader 获取输入事件&lt;/h4&gt;
&lt;p&gt;这里从 InputReaderThread::threadLoop() 开始跟踪：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReaderBase.cpp
bool InputReaderThread::threadLoop() {
    mReader-&amp;gt;loopOnce();
    return true;
}

//InputReader.cpp
void InputReader::loopOnce() {
    ...
    //获取事件
    size_t count = mEventHub-&amp;gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);
    { // acquire lock
        AutoMutex _l(mLock);
        mReaderIsAliveCondition.broadcast();
        if (count) {
            //处理输入事件，参考1.2.2
            processEventsLocked(mEventBuffer, count);
        }
        ...
    } // release lock
    // Send out a message that the describes the changed input devices.
    if (inputDevicesChanged) {
        mPolicy-&amp;gt;notifyInputDevicesChanged(inputDevices);
    }
    // Flush queued events out to the listener.
    // This must happen outside of the lock because the listener could potentially call
    // back into the InputReader's methods, such as getScanCodeState, or become blocked
    // on another thread similarly waiting to acquire the InputReader lock thereby
    // resulting in a deadlock.  This situation is actually quite plausible because the
    // listener is actually the input dispatcher, which calls into the window manager,
    // which occasionally calls into the input reader.
    //将事件 推送给 InputDispatcher 进行处理。参考1.2.2.3
    mQueuedListener-&amp;gt;flush();
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程 运行起来后，会执行threadLoop，这里返回true，会循环执行该threadLoop方法。&lt;/p&gt;
&lt;p&gt;threadLoop中调用 loopOnce，通过3步将消息 发送到InputDispatcher：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过 mEventHub-&amp;gt;getEvents(）获取所有 输入事件的原始数据。&lt;/strong&gt; 这部分该篇不讨论&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过 processEventsLocked() 处理输入事件。&lt;/strong&gt; 参考1.2.2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过 mQueuedListener-&amp;gt;flush() 推送到InputDispatcher。&lt;/strong&gt; 参考1.2.2.3&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;122-inputreader-处理输入事件&quot;&gt;1.2.2 InputReader 处理输入事件&lt;/h4&gt;
&lt;p&gt;看下处理输入事件的方法：processEventsLocked()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) {
    for (const RawEvent* rawEvent = rawEvents; count;) {
        int32_t type = rawEvent-&amp;gt;type;
        size_t batchSize = 1;
        if (type &amp;lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) {
            int32_t deviceId = rawEvent-&amp;gt;deviceId;
            while (batchSize &amp;lt; count) {
                if (rawEvent[batchSize].type &amp;gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT
                        || rawEvent[batchSize].deviceId != deviceId) {
                    break;
                }
                batchSize += 1;
            }
            //处理 真正的输入事件，参考 1.2.2.2
            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
        } else {
            //处理 设备增加、删除、扫描更新。参考1.2.2.1
            switch (rawEvent-&amp;gt;type) {
            case EventHubInterface::DEVICE_ADDED:
                addDeviceLocked(rawEvent-&amp;gt;when, rawEvent-&amp;gt;deviceId);
                break;
            ...
            }
        }
        count -= batchSize;
        rawEvent += batchSize;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面讲了InputReader有3个功能，这里可以看到功能2和3：对输入事件进行加工处理后 交由InputDispatcher；对输入设备 列表的管理和配置。先看功能3，在看功能2。&lt;/p&gt;
&lt;h5 id=&quot;1221-了解输入设备的管理&quot;&gt;1.2.2.1 了解输入设备的管理&lt;/h5&gt;
&lt;p&gt;先看下功能3：对输入设备 列表的管理和配置。&lt;/p&gt;
&lt;p&gt;这里以增加设备 为例，看下addDeviceLocked()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) {
    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
    if (deviceIndex &amp;gt;= 0) {
        ALOGW(&quot;Ignoring spurious device added event for deviceId %d.&quot;, deviceId);
        return;
    }
    InputDeviceIdentifier identifier = mEventHub-&amp;gt;getDeviceIdentifier(deviceId);
    uint32_t classes = mEventHub-&amp;gt;getDeviceClasses(deviceId);
    int32_t controllerNumber = mEventHub-&amp;gt;getDeviceControllerNumber(deviceId);
    //创建InputDevice
    InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);
    device-&amp;gt;configure(when, &amp;amp;mConfig, 0);
    device-&amp;gt;reset(when);
    ...
        //加入mDevices
    mDevices.add(deviceId, device);
    ...
}

//mDevices 和 InputDevice定义(截取部分)
//InputReader.h
class InputReader : public InputReaderInterface {
        KeyedVector&amp;lt;int32_t, InputDevice*&amp;gt; mDevices;
}
class InputDevice {
        int32_t mId;//通过mId从EventHub中找到对应的输入设备
        std::vector&amp;lt;InputMapper*&amp;gt; mMappers;//处理上报的事件
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里创建了一个InputDevice，然后将其加入到mDevices。&lt;strong&gt;mDevices 中保存了 设备的id 以及 对应的InputDevice。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EventHub 中也有个 mDevices，保存了 设备的id 和 对应的Device信息。 如下（截取部分）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//EventHub.h
class EventHub : public EventHubInterface {
    KeyedVector&amp;lt;int32_t, Device*&amp;gt; mDevices;
    
    struct Device {
        Device* next;
        int fd; // may be -1 if device is closed  //设备节点 的文件句柄
        const int32_t id;
        const std::string path;
        const InputDeviceIdentifier identifier; //记录设备信息，设备的名称、供应商、型号等等
        std::unique_ptr&amp;lt;TouchVideoDevice&amp;gt; videoDevice;
        uint32_t classes;
                std::unique_ptr&amp;lt;VirtualKeyMap&amp;gt; virtualKeyMap;
        KeyMap keyMap;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看下 创建InputDevice的过程，createDeviceLocked()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
InputDevice* InputReader::createDeviceLocked(int32_t deviceId, int32_t controllerNumber,
        const InputDeviceIdentifier&amp;amp; identifier, uint32_t classes) {
    //创建InputDevice
    InputDevice* device = new InputDevice(&amp;amp;mContext, deviceId, bumpGenerationLocked(),
            controllerNumber, identifier, classes);

    // External devices.
    if (classes &amp;amp; INPUT_DEVICE_CLASS_EXTERNAL) {
        device-&amp;gt;setExternal(true);
    }
    // Keyboard-like devices.
    ...
    if (keyboardSource != 0) {
        device-&amp;gt;addMapper(new KeyboardInputMapper(device, keyboardSource, keyboardType));
    }
    // Touchscreens and touchpad devices.
    if (classes &amp;amp; INPUT_DEVICE_CLASS_TOUCH_MT) {
        device-&amp;gt;addMapper(new MultiTouchInputMapper(device));
    } else if (classes &amp;amp; INPUT_DEVICE_CLASS_TOUCH) {
        device-&amp;gt;addMapper(new SingleTouchInputMapper(device));
    }
    return device;
}

void InputDevice::addMapper(InputMapper* mapper) {
    mMappers.push_back(mapper);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了InputDevice后，进行一些设置。值得关注的是 &lt;strong&gt;一个InputDevice保存了多个 InputMapper，这些InputMapper保存在mMappers。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单理一下：&lt;strong&gt;InputReader添加设备，首先创建了一个InputDevice，然后加入到mDevices中。而根据设备类型，可以创建多个InputMapper，这多个InputMapper保存在InputDevice中的mMappers中。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;1222-输入事件处理&quot;&gt;1.2.2.2 输入事件处理&lt;/h5&gt;
&lt;p&gt;接着看功能2，对输入事件进行处理 processEventsForDeviceLocked() ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
void InputReader::processEventsForDeviceLocked(int32_t deviceId,
        const RawEvent* rawEvents, size_t count) {
    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
    //最终根据deviceId获得设备对应的InputDevice
    InputDevice* device = mDevices.valueAt(deviceIndex);
    //事件交由 对应InputDevice处理。rawEvents是一组事件，可以注意下来源。                       
    device-&amp;gt;process(rawEvents, count);
}

//InputReader.cpp
void InputDevice::process(const RawEvent* rawEvents, size_t count) {
    // Process all of the events in order for each mapper.
    // We cannot simply ask each mapper to process them in bulk because mappers may
    // have side-effects that must be interleaved.  For example, joystick movement events and
    // gamepad button presses are handled by different mappers but they should be dispatched
    // in the order received.
    for (const RawEvent* rawEvent = rawEvents; count != 0; rawEvent++) {
        ...
        if (mDropUntilNextSync) {
            if (rawEvent-&amp;gt;type == EV_SYN &amp;amp;&amp;amp; rawEvent-&amp;gt;code == SYN_REPORT) {
                mDropUntilNextSync = false;
                ...
            } 
            ...
        } else if (rawEvent-&amp;gt;type == EV_SYN &amp;amp;&amp;amp; rawEvent-&amp;gt;code == SYN_DROPPED) {
            ALOGI(&quot;Detected input event buffer overrun for device %s.&quot;, getName().c_str());
            mDropUntilNextSync = true;
            reset(rawEvent-&amp;gt;when);
        } else {
                        //将InputDvices对象中的mMappers依次取出来，调用process()进行处理
            for (InputMapper* mapper : mMappers) {
                mapper-&amp;gt;process(rawEvent);
            }
        }
        --count;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;InputReader 获得某设备相关一组事件，然后找到对应InputDevice进行处理，执行 &lt;code&gt;InputDevice::process()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;InputDevice则将InputDvices对象中的mMappers依次取出来，调用process()进行处理。各个 InputMapper 对事件进行判断，若是属于自己处理的类型 再进行不同的处理。&lt;/p&gt;
&lt;p&gt;下面 以键盘事件 为例说明，则InputMapper是KeyboardInputMapper：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
void KeyboardInputMapper::process(const RawEvent* rawEvent) {
    switch (rawEvent-&amp;gt;type) {
        case EV_KEY: {
            int32_t scanCode = rawEvent-&amp;gt;code;
            int32_t usageCode = mCurrentHidUsage;
            mCurrentHidUsage = 0;
            if (isKeyboardOrGamepadKey(scanCode)) {
                //处理事件，这里即处理按键的方法
                processKey(rawEvent-&amp;gt;when, rawEvent-&amp;gt;value != 0, scanCode, usageCode);
            }
            break;
        }
        ...
    }
}

//InputReader.cpp
//内核上报的扫描码(scanCode)，转换成Android系统使用的按键码(keyCode)，重构NotifyArgs，加入 mArgsQueue队列
void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t scanCode,
        int32_t usageCode) {
    int32_t keyCode;
    int32_t keyMetaState;
    uint32_t policyFlags;
    ...
    //重构args
    NotifyKeyArgs args(mContext-&amp;gt;getNextSequenceNum(), when, getDeviceId(), mSource,
            getDisplayId(), policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,
            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime);
    //插入到 mArgsQueue 队列中
    getListener()-&amp;gt;notifyKey(&amp;amp;args);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个处理过程 主要是 封装各个参数，重新构造成 NotifyKeyArgs ，然后 将构造的 NotifyKeyArgs对象加入 mArgsQueue队列。&lt;/p&gt;
&lt;p&gt;加入到 mArgsQueue的过程， getListener()-&amp;gt;notifyKey(&amp;amp;args)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputReader.cpp
InputListenerInterface* InputReader::ContextImpl::getListener() {
    return mReader-&amp;gt;mQueuedListener.get();
}
InputReader::InputReader(const sp&amp;lt;EventHubInterface&amp;gt;&amp;amp; eventHub,
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; policy,
        const sp&amp;lt;InputListenerInterface&amp;gt;&amp;amp; listener) : ... {
    mQueuedListener = new QueuedInputListener(listener);
}

//InputListener.cpp
QueuedInputListener::QueuedInputListener(const sp&amp;lt;InputListenerInterface&amp;gt;&amp;amp; innerListener) :
        mInnerListener(innerListener) {
}
void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) {
    mArgsQueue.push_back(new NotifyKeyArgs(*args));//push_back() 在Vector尾部插入
}
//InputListener.h
class QueuedInputListener : public InputListenerInterface {
    std::vector&amp;lt;NotifyArgs*&amp;gt; mArgsQueue;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在1.1中 创建InputReader时已经知道(可以回去看下)，InputReader中的lister是InputClassifier对象，所以 QueuedInputListener中的innerListener 也就是 InputClassifier。&lt;/p&gt;
&lt;p&gt;到这里再理一下：&lt;strong&gt;事件先交由了对应的InputDevice，然后找对处理该事件类型的InputMapper 进行处理。InputMapper 将事件等信息 构造了NotifyArgs，然后加入到了mArgsQueue中。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;1223-输入事件传入到-inputdispatcher&quot;&gt;1.2.2.3 输入事件传入到 InputDispatcher&lt;/h5&gt;
&lt;p&gt;看 InputReader::loopOnce() 的最后一句：&lt;code&gt;mQueuedListener-&amp;gt;flush();&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputListener.cpp
void QueuedInputListener::flush() {
    size_t count = mArgsQueue.size();
    //依次从mArgsQueue中取出NotifyArgs
    for (size_t i = 0; i &amp;lt; count; i++) {
        NotifyArgs* args = mArgsQueue[i];
        //mInnerListener是InputClassifier，上面（1.2.2.2最后）已经特意指出
        args-&amp;gt;notify(mInnerListener);
        delete args;
    }
    mArgsQueue.clear();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如注释所说。接着看 args-&amp;gt;notif()，接下来都是以键盘事件为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//NotifyArgs是所有args的超类。 以键盘为例，args即NotifyKeyArgs
void NotifyKeyArgs::notify(const sp&amp;lt;InputListenerInterface&amp;gt;&amp;amp; listener) const {
    listener-&amp;gt;notifyKey(this);
}


//InputManager.cpp
InputManager::InputManager(
        const sp&amp;lt;InputReaderPolicyInterface&amp;gt;&amp;amp; readerPolicy,
        const sp&amp;lt;InputDispatcherPolicyInterface&amp;gt;&amp;amp; dispatcherPolicy) {
    mDispatcher = new InputDispatcher(dispatcherPolicy);
    mClassifier = new InputClassifier(mDispatcher);
}
//InputClassifier.cpp
//mListener是InputDispatcher
InputClassifier::InputClassifier(const sp&amp;lt;InputListenerInterface&amp;gt;&amp;amp; listener)
      : mListener(listener), mHalDeathRecipient(new HalDeathRecipient(*this)) {}


void InputClassifier::notifyKey(const NotifyKeyArgs* args) {
    // pass through
    mListener-&amp;gt;notifyKey(args);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很清楚列出了，这里的mListener即InputDispatcher。所以最终走到了 InputDispatcher::notifyKey()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::notifyKey(const NotifyKeyArgs* args) {
    ...
    int32_t keyCode = args-&amp;gt;keyCode;
    //Meta + Backspace -&amp;gt; generate BACK; Meta + Enter -&amp;gt; generate HOME
    accelerateMetaShortcuts(args-&amp;gt;deviceId, args-&amp;gt;action, keyCode, metaState);

    KeyEvent event;
    event.initialize(args-&amp;gt;deviceId, args-&amp;gt;source, args-&amp;gt;displayId, args-&amp;gt;action,
            flags, keyCode, args-&amp;gt;scanCode, metaState, repeatCount,
            args-&amp;gt;downTime, args-&amp;gt;eventTime);

    android::base::Timer t;
    //mPolicy是NativeInputManager，最终回调到PhoneWindowManager的同名方法。参考1.2.2.4
    mPolicy-&amp;gt;interceptKeyBeforeQueueing(&amp;amp;event, /*byref*/ policyFlags);
    ...
    bool needWake;
    { // acquire lock
        mLock.lock();
        ...
        KeyEntry* newEntry = new KeyEntry(args-&amp;gt;sequenceNum, args-&amp;gt;eventTime,
                args-&amp;gt;deviceId, args-&amp;gt;source, args-&amp;gt;displayId, policyFlags,
                args-&amp;gt;action, flags, keyCode, args-&amp;gt;scanCode,
                metaState, repeatCount, args-&amp;gt;downTime);

        needWake = enqueueInboundEventLocked(newEntry);
        mLock.unlock();
    } // release lock

    if (needWake) {
        mLooper-&amp;gt;wake();
    }
}

bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) {
    bool needWake = mInboundQueue.isEmpty();
    //entry加入到mInboundQueue
    mInboundQueue.enqueueAtTail(entry);
    ...
    return needWake;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终，&lt;strong&gt;输入事件 由InputReader 获取处理后，传递到InputDispatcher，封装成EventEntry并加入mInboundQueue 队列了。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;1224-事件入队前的拦截：interceptkeybeforequeueing&quot;&gt;1.2.2.4 事件入队前的拦截：interceptKeyBeforeQueueing()&lt;/h5&gt;
&lt;p&gt;注意上面 &lt;code&gt;InputDispatcher::notifyKey&lt;/code&gt; 中有 &lt;code&gt;mPolicy-&amp;gt;interceptKeyBeforeQueueing(&amp;amp;event, /*byref*/ policyFlags);&lt;/code&gt; 这句话，对PhoneWindowManager有过了解的，应该比较清楚。&lt;/p&gt;
&lt;p&gt;这里就是 policy拦截的 比较常见的一处，从这最终回调 的是 PhoneWindowManager中的方法。&lt;/p&gt;
&lt;p&gt;这个大致看下，这里mPolicy即 NativeInputManager ，所以直接看&lt;code&gt;NativeInputManager::interceptKeyBeforeQueueing()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//com_android_server_input_InputManagerService.cpp
void NativeInputManager::interceptKeyBeforeQueueing(const KeyEvent* keyEvent,
        uint32_t&amp;amp; policyFlags) {
    ...
        wmActions = env-&amp;gt;CallIntMethod(mServiceObj,
                    gServiceClassInfo.interceptKeyBeforeQueueing,
                    keyEventObj, policyFlags);
    ...
}
//InputManagerService.java
private int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    return mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个跟踪 就是执行了IMS中的interceptKeyBeforeQueueing()方法。&lt;/p&gt;
&lt;p&gt;最终是如何调用到 PhoneWindowManager 中的方法的？&lt;/p&gt;
&lt;p&gt;这里的mWindowManagerCallbacks是 wms中创建的InputManagerCallback对象。这个如何来的 参考1.4。&lt;/p&gt;
&lt;p&gt;所以 &lt;code&gt;mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);&lt;/code&gt; 即：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputManagerCallback.java
public InputManagerCallback(WindowManagerService service) {
    mService = service;
}
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    return mService.mPolicy.interceptKeyBeforeQueueing(event, policyFlags);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里的mService.mPolicy就是PhoneWindowManager对象，在WMS创建时设置的。所以最终 回调的 PhoneWindowManager 中的 interceptKeyBeforeQueueing() 方法。&lt;/strong&gt; PhoneWindowManager 是 WindowManagerPolicy 的实现类。&lt;/p&gt;
&lt;h3 id=&quot;13-inputdispatcherthread运行：inputdispatcher派发事件&quot;&gt;1.3 InputDispatcherThread运行：InputDispatcher派发事件&lt;/h3&gt;
&lt;p&gt;前面讲到，输入事件 在InputDispatcher中 封装成EventEntry并加入mInboundQueue 队列了。接着看 InputDispatcher是如何继续处理 派发的。&lt;br/&gt;如同InputReaderThread中介绍，这里直接看threadLoop()。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//frameworks/native/services/inputflinger/InputDispatcher.cpp
bool InputDispatcherThread::threadLoop() {
    mDispatcher-&amp;gt;dispatchOnce();
    return true;
}

void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    { // acquire lock
        std::scoped_lock _l(mLock);
        mDispatcherIsAlive.notify_all();

        // Run a dispatch loop if there are no pending commands.
        // The dispatch loop might enqueue commands to run afterwards.
        //若mCommandQueue为空
        if (!haveCommandsLocked()) {
            //参考1.3.1
            dispatchOnceInnerLocked(&amp;amp;nextWakeupTime);
        }

        // Run all pending commands if there are any.
        // If any commands were run then force the next poll to wake up immediately.
        //参考1.3.4，运行 mCommandQueue 中命令
        if (runCommandsLockedInterruptible()) {
            nextWakeupTime = LONG_LONG_MIN;
        }
    } // release lock

    // Wait for callback or timeout or wake.  (make sure we round up, not down)
    nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&amp;gt;pollOnce(timeoutMillis);
}

//InputDispatcher.h
EventEntry* mPendingEvent GUARDED_BY(mLock);
Queue&amp;lt;EventEntry&amp;gt; mInboundQueue GUARDED_BY(mLock);
Queue&amp;lt;EventEntry&amp;gt; mRecentQueue GUARDED_BY(mLock);
Queue&amp;lt;CommandEntry&amp;gt; mCommandQueue GUARDED_BY(mLock);

//InputDispatcher.cpp
bool InputDispatcher::haveCommandsLocked() const {
    return !mCommandQueue.isEmpty();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;131-inputdispatcher-取得输入事件&quot;&gt;1.3.1 InputDispatcher 取得输入事件&lt;/h4&gt;
&lt;p&gt;1.2.2.3讲到：输入事件 由InputReader 获取处理后，加入到了InputDispatcher中的 mInboundQueue 队列了。&lt;/p&gt;
&lt;p&gt;事件派发 首先从 mInboundQueue队列中 取出输入事件，然后进行处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {
    ...
    // Ready to start a new event.
    // If we don't already have a pending event, go grab one.
    if (! mPendingEvent) {
        if (mInboundQueue.isEmpty()) {
            ...
        } else {
            // Inbound queue has at least one entry.
            //从mInboundQueue中 出队 一个元素
            mPendingEvent = mInboundQueue.dequeueAtHead();
            traceInboundQueueLengthLocked();
        }

        // Poke user activity for this event.
        if (mPendingEvent-&amp;gt;policyFlags &amp;amp; POLICY_FLAG_PASS_TO_USER) {
            pokeUserActivityLocked(mPendingEvent);
        }

        // Get ready to dispatch the event.
        //这里注意下，ANR相关。这里先mark下，这篇不说明
        resetANRTimeoutsLocked();
    }

    // Now we have an event to dispatch.
    // All events are eventually dequeued and processed this way, even if we intend to drop them.
    ...

    switch (mPendingEvent-&amp;gt;type) {
    ...
    case EventEntry::TYPE_KEY: {
        KeyEntry* typedEntry = static_cast&amp;lt;KeyEntry*&amp;gt;(mPendingEvent);
        ...
        //分派事件
        done = dispatchKeyLocked(currentTime, typedEntry, &amp;amp;dropReason, nextWakeupTime);
        break;
    }
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取出事件后，然后分派，这里同样以 键盘按键事件为例，直接看 dispatchKeyLocked()：&lt;/p&gt;
&lt;h4 id=&quot;132-分派事件前处理&quot;&gt;1.3.2 分派事件前处理&lt;/h4&gt;
&lt;p&gt;直接看 dispatchKeyLocked()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,
        DropReason* dropReason, nsecs_t* nextWakeupTime) {
    ...

    // Give the policy a chance to intercept the key.
    if (entry-&amp;gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) {
        //派发给用户，参考1.3.2.1
        if (entry-&amp;gt;policyFlags &amp;amp; POLICY_FLAG_PASS_TO_USER) {
            //将InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible函数指针作为参数
            //执行postCommandLocked()，执行后 该函数被封装到CommandEntry 加入到 mCommandQueue队列
            CommandEntry* commandEntry = postCommandLocked(
                    &amp;amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);
            //InputWindowHandle保存了窗口相关信息，由java层而来
            //获取焦点窗口的InputWindowHandle
            sp&amp;lt;InputWindowHandle&amp;gt; focusedWindowHandle =
                    getValueByKey(mFocusedWindowHandlesByDisplay, getTargetDisplayId(entry));
            if (focusedWindowHandle != nullptr) {
                //InputChannel也是一种跨进程
                commandEntry-&amp;gt;inputChannel =
                    getInputChannelLocked(focusedWindowHandle-&amp;gt;getToken());
            }
            commandEntry-&amp;gt;keyEntry = entry;
            entry-&amp;gt;refCount += 1;
            return false; // wait for the command to run
        } else {
            entry-&amp;gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;
        }
    } 
    ...
    
    // Identify targets.
    //参考 1.3.2.3 
    std::vector&amp;lt;InputTarget&amp;gt; inputTargets;
    int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,
            entry, inputTargets, nextWakeupTime);
    ...
    // Add monitor channels from event's or focused display.
    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));

    // Dispatch the key.
    //参考1.3.3
    dispatchEvenfentLocked(currentTime, entry, inputTargets);
    return true;
}

InputDispatcher::CommandEntry* InputDispatcher::postCommandLocked(Command command) {
    CommandEntry* commandEntry = new CommandEntry(command);
    mCommandQueue.enqueueAtTail(commandEntry);
    return commandEntry;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;1321-事件分派前的拦截：interceptkeybeforedispatching&quot;&gt;1.3.2.1 事件分派前的拦截：interceptKeyBeforeDispatching()&lt;/h5&gt;
&lt;p&gt;通过postCommandLocked() 将 doInterceptKeyBeforeDispatchingLockedInterruptible 函数作为参数，封装到CommandEntry 最后加入到 mCommandQueue队列。这个函数并没有马上运行。&lt;/p&gt;
&lt;p&gt;这个doInterceptKeyBeforeDispatchingLockedInterruptible():&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible(
        CommandEntry* commandEntry) {
    KeyEntry* entry = commandEntry-&amp;gt;keyEntry;
    ...
    sp&amp;lt;IBinder&amp;gt; token = commandEntry-&amp;gt;inputChannel != nullptr ?
        commandEntry-&amp;gt;inputChannel-&amp;gt;getToken() : nullptr;
    nsecs_t delay = mPolicy-&amp;gt;interceptKeyBeforeDispatching(token,
            &amp;amp;event, entry-&amp;gt;policyFlags);
    ...
    entry-&amp;gt;release();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interceptKeyBeforeDispatching() 类似1.2.2.4。最终也是 调用到PhoneWindowManager 中的同名方法。&lt;/p&gt;
&lt;h5 id=&quot;1322-了解inputwindowhandle和inputchannel&quot;&gt;1.3.2.2 了解InputWindowHandle和InputChannel&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;InputWindowHandle：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InputWindowHandle保存了窗口相关信息，由java层而来。&lt;/p&gt;
&lt;p&gt;关于InputWindowHandle 知道这大概是什么，不影响此篇理解，就没有完全跟踪下去。下面个人查看的路径开始，内容挺多，也没跟踪完全。先记录下，后续再看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//WindowManagerService.java
public int addWindow(Session session, IWindow client, int seq, ...) {
    displayContent.getInputMonitor().updateInputWindowsLw(false /*force*/);
}

//InputMonitor.java
/* Updates the cached window information provided to the input dispatcher. */
void updateInputWindowsLw(boolean force) {
    if (!force &amp;amp;&amp;amp; !mUpdateInputWindowsNeeded) {
        return;
    }
    scheduleUpdateInputWindows();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;InputChannel：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InputChannel也是一种跨进程, 本质也是socket。是一对创建的。&lt;/p&gt;
&lt;p&gt;WindowState创建了一对InputChannel。server端注册到InputDispatcher，建立了Connect。client端返回给应用进程的窗口，ViewRootImpl.setView()时传入的参数mInputChannel。&lt;/p&gt;
&lt;p&gt;InputDispatcher向其InputChannel中写入事件，窗口就可以从InputChannel中读取了。&lt;/p&gt;
&lt;p&gt;简单列出下相关代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//WindowManagerService.java
public int addWindow(Session session, IWindow client, int seq,
        LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,
        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,
        InsetsState outInsetsState) {
    final boolean openInputChannels = (outInputChannel != null
            &amp;amp;&amp;amp; (attrs.inputFeatures &amp;amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0);
    if  (openInputChannels) {
        //outInputChannel来自 ViewRootImpl.setView()时创建的
        win.openInputChannel(outInputChannel);
    }
}

//WindowState.java
void openInputChannel(InputChannel outInputChannel) {
    if (mInputChannel != null) {
        throw new IllegalStateException(&quot;Window already has an input channel.&quot;);
    }
    String name = getName();
    //创建一对InputChannel，创建过程该篇不说明。         
    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
    mInputChannel = inputChannels[0];
    mClientChannel = inputChannels[1];
    mInputWindowHandle.token = mClient.asBinder();
    if (outInputChannel != null) {
        //mClientChannel传递给 outInputChannel
        mClientChannel.transferTo(outInputChannel);
        mClientChannel.dispose();
        mClientChannel = null;
    } else {
        // If the window died visible, we setup a dummy input channel, so that taps
        // can still detected by input monitor channel, and we can relaunch the app.
        // Create dummy event receiver that simply reports all events as handled.
        mDeadWindowEventReceiver = new DeadWindowEventReceiver(mClientChannel);
    }
    //mInputChannel注册到了InputDispatcher，注册过程也不说明了。           
    mWmService.mInputManager.registerInputChannel(mInputChannel, mClient.asBinder());
}

//InputDispatcher.cpp
status_t InputDispatcher::registerInputChannel(const sp&amp;lt;InputChannel&amp;gt;&amp;amp; inputChannel,
        int32_t displayId) {
    { // acquire lock
        sp&amp;lt;Connection&amp;gt; connection = new Connection(inputChannel, false /*monitor*/);
        int fd = inputChannel-&amp;gt;getFd();
        mConnectionsByFd.add(fd, connection);
        mInputChannelsByToken[inputChannel-&amp;gt;getToken()] = inputChannel;
        mLooper-&amp;gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);
    } // release lock
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;1323-确认目标&quot;&gt;1.3.2.3 确认目标&lt;/h5&gt;
&lt;p&gt;直接看 findFocusedWindowTargetsLocked() :&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,
        const EventEntry* entry, std::vector&amp;lt;InputTarget&amp;gt;&amp;amp; inputTargets, nsecs_t* nextWakeupTime) {
    int32_t injectionResult;
    std::string reason;
    int32_t displayId = getTargetDisplayId(entry);
    sp&amp;lt;InputWindowHandle&amp;gt; focusedWindowHandle =
            getValueByKey(mFocusedWindowHandlesByDisplay, displayId);
    sp&amp;lt;InputApplicationHandle&amp;gt; focusedApplicationHandle =
            getValueByKey(mFocusedApplicationHandlesByDisplay, displayId);
    ...
    // Success!  Output targets.
    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
    addWindowTargetLocked(focusedWindowHandle,
            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(0),
            inputTargets);
    ...
    return injectionResult;
}

void InputDispatcher::addWindowTargetLocked(const sp&amp;lt;InputWindowHandle&amp;gt;&amp;amp; windowHandle,
        int32_t targetFlags, BitSet32 pointerIds, std::vector&amp;lt;InputTarget&amp;gt;&amp;amp; inputTargets) {
    sp&amp;lt;InputChannel&amp;gt; inputChannel = getInputChannelLocked(windowHandle-&amp;gt;getToken());
    if (inputChannel == nullptr) {
        ALOGW(&quot;Window %s already unregistered input channel&quot;, windowHandle-&amp;gt;getName().c_str());
        return;
    }
    const InputWindowInfo* windowInfo = windowHandle-&amp;gt;getInfo();
    InputTarget target;
    target.inputChannel = inputChannel;
    target.flags = targetFlags;
    target.xOffset = - windowInfo-&amp;gt;frameLeft;
    target.yOffset = - windowInfo-&amp;gt;frameTop;
    target.globalScaleFactor = windowInfo-&amp;gt;globalScaleFactor;
    target.windowXScale = windowInfo-&amp;gt;windowXScale;
    target.windowYScale = windowInfo-&amp;gt;windowYScale;
    target.pointerIds = pointerIds;
    inputTargets.push_back(target);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到目标的InputWindowHandle，生成一个InputTarget 然后加入到inputTargets中。&lt;/p&gt;
&lt;p&gt;InputTarget包含了窗口的各种信息，如上可以仔细看下。&lt;/p&gt;
&lt;h4 id=&quot;133--分派事件&quot;&gt;1.3.3 分派事件&lt;/h4&gt;
&lt;p&gt;直接看 dispatchEventLocked(),。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::dispatchEventLocked(nsecs_t currentTime,
        EventEntry* eventEntry, const std::vector&amp;lt;InputTarget&amp;gt;&amp;amp; inputTargets) {
    ATRACE_CALL();
    ...
    pokeUserActivityLocked(eventEntry);

    for (const InputTarget&amp;amp; inputTarget : inputTargets) {
        ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);
        if (connectionIndex &amp;gt;= 0) {
            sp&amp;lt;Connection&amp;gt; connection = mConnectionsByFd.valueAt(connectionIndex);
            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;amp;inputTarget);
        }
        ...
    }
}

void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,
        const sp&amp;lt;Connection&amp;gt;&amp;amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) {
    ...
    // Not splitting.  Enqueue dispatch entries for the event as is.
    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环取出inputTargets的目标，一个个处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime,
        const sp&amp;lt;Connection&amp;gt;&amp;amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) {
    ...
    bool wasEmpty = connection-&amp;gt;outboundQueue.isEmpty();
    // Enqueue dispatch entries for the requested modes.
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_IS);
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);
    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,
            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);
    // If the outbound queue was previously empty, start the dispatch cycle going.
    if (wasEmpty &amp;amp;&amp;amp; !connection-&amp;gt;outboundQueue.isEmpty()) {
        startDispatchCycleLocked(currentTime, connection);
    }
}
void InputDispatcher::enqueueDispatchEntryLocked(
        const sp&amp;lt;Connection&amp;gt;&amp;amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget,
        int32_t dispatchMode) {
    ...
    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, // increments ref
            inputTargetFlags, inputTarget-&amp;gt;xOffset, inputTarget-&amp;gt;yOffset,
            inputTarget-&amp;gt;globalScaleFactor, inputTarget-&amp;gt;windowXScale,
            inputTarget-&amp;gt;windowYScale);
    ...
    // Enqueue the dispatch entry.
    connection-&amp;gt;outboundQueue.enqueueAtTail(dispatchEntry);
    traceOutboundQueueLength(connection);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Connection个人理解是一个通道。Connection中有一个outboundQueue队列，上面将符合的事件封装为DispatchEntry放到Connection的outboundQueue队列中了。&lt;/p&gt;
&lt;p&gt;然后接着看分派周期 startDispatchCycleLocked()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
        const sp&amp;lt;Connection&amp;gt;&amp;amp; connection) {
    ...
    while (connection-&amp;gt;status == Connection::STATUS_NORMAL
            &amp;amp;&amp;amp; !connection-&amp;gt;outboundQueue.isEmpty()) {
        //从connection的outboundQueue队列取出一个元素
        DispatchEntry* dispatchEntry = connection-&amp;gt;outboundQueue.head;
        dispatchEntry-&amp;gt;deliveryTime = currentTime;

        // Publish the event.
        status_t status;
        EventEntry* eventEntry = dispatchEntry-&amp;gt;eventEntry;
        switch (eventEntry-&amp;gt;type) {
        case EventEntry::TYPE_KEY: {
            KeyEntry* keyEntry = static_cast&amp;lt;KeyEntry*&amp;gt;(eventEntry);

            // Publish the key event.
            //派发按键事件
            status = connection-&amp;gt;inputPublisher.publishKeyEvent(dispatchEntry-&amp;gt;seq,
                    keyEntry-&amp;gt;deviceId, keyEntry-&amp;gt;source, keyEntry-&amp;gt;displayId,
                    dispatchEntry-&amp;gt;resolvedAction, dispatchEntry-&amp;gt;resolvedFlags,
                    keyEntry-&amp;gt;keyCode, keyEntry-&amp;gt;scanCode,
                    keyEntry-&amp;gt;metaState, keyEntry-&amp;gt;repeatCount, keyEntry-&amp;gt;downTime,
                    keyEntry-&amp;gt;eventTime);
            break;
        }
        ...
        // Re-enqueue the event on the wait queue.
        connection-&amp;gt;outboundQueue.dequeue(dispatchEntry);
        traceOutboundQueueLength(connection);
        connection-&amp;gt;waitQueue.enqueueAtTail(dispatchEntry);
        traceWaitQueueLength(connection);
    }
}

//InputTransport.cpp
InputPublisher::InputPublisher(const sp&amp;lt;InputChannel&amp;gt;&amp;amp; channel) :
        mChannel(channel) {
}
status_t InputPublisher::publishKeyEvent(
       ...) {
    ...
    InputMessage msg;
    msg.header.type = InputMessage::TYPE_KEY;
    msg.body.key.seq = seq;
    msg.body.key.deviceId = deviceId;
    msg.body.key.source = source;
    msg.body.key.displayId = displayId;
    msg.body.key.action = action;
    msg.body.key.flags = flags;
    msg.body.key.keyCode = keyCode;
    msg.body.key.scanCode = scanCode;
    msg.body.key.metaState = metaState;
    msg.body.key.repeatCount = repeatCount;
    msg.body.key.downTime = downTime;
    msg.body.key.eventTime = eventTime;
    //通过InputChannel发送消息
    return mChannel-&amp;gt;sendMessage(&amp;amp;msg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环取出Connection中outboundQueue队列中的 事件依次处理分派。这里还是 以按键 为例，通过 &lt;code&gt;inputPublisher.publishKeyEvent()&lt;/code&gt; 分派了事件，即 &lt;strong&gt;最终是 将事件等信息 封装为InputMessage， 通过InputChannel将 这个消息发送出去。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputTransport.cpp
status_t InputChannel::sendMessage(const InputMessage* msg) {
    const size_t msgLength = msg-&amp;gt;size();
    InputMessage cleanMsg;
    msg-&amp;gt;getSanitizedCopy(&amp;amp;cleanMsg);
    ssize_t nWrite;
    do {
        //
        nWrite = ::send(mFd, &amp;amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);
    } while (nWrite == -1 &amp;amp;&amp;amp; errno == EINTR);
    ...
    return OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;134-分派事件后-执行挂起命令&quot;&gt;1.3.4 分派事件后 执行挂起命令&lt;/h4&gt;
&lt;p&gt;在InputDispatcher::dispatchOnce()中 ，前面讲到的事件分派 都是 dispatchOnceInnerLocked()的执行，这个是 没有挂起命令情况下执行的（即mCommandQueue为空）。&lt;/p&gt;
&lt;p&gt;如果mCommandQueue非空，则会执行挂起的命令。如 在1.3.2.1中 拦截命令 被封装 加入了mCommandQueue 队列，然后分派就结束了。&lt;/p&gt;
&lt;p&gt;如果mCommandQueue非空，会执行其中的命令，即 runCommandsLockedInterruptible() ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputDispatcher.cpp
bool InputDispatcher::runCommandsLockedInterruptible() {
    if (mCommandQueue.isEmpty()) {
        return false;
    }
    do {
        CommandEntry* commandEntry = mCommandQueue.dequeueAtHead();

        Command command = commandEntry-&amp;gt;command;
        (this-&amp;gt;*command)(commandEntry); // commands are implicitly 'LockedInterruptible'
        commandEntry-&amp;gt;connection.clear();
        delete commandEntry;
    } while (! mCommandQueue.isEmpty());
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;14-设置回调：setwindowmanagercallbacks&quot;&gt;1.4 设置回调：setWindowManagerCallbacks&lt;/h3&gt;
&lt;p&gt;在startOtherServices()中，创建了InputManagerService后，执行了 &lt;code&gt;inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());&lt;/code&gt; 。这个就是设置的回调(即设置了mWindowManagerCallbacks)，与前面提到的 两个拦截有关，1.2.2.4已经说的比较明白了。这里主要其中mWindowManagerCallbacks是什么。&lt;/p&gt;
&lt;p&gt;这句话很简单，直接看下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//WindowManagerService.java 
final InputManagerCallback mInputManagerCallback = new InputManagerCallback(this);
public InputManagerCallback getInputManagerCallback() {
    return mInputManagerCallback;
}

//InputManagerService.java
public void setWindowManagerCallbacks(WindowManagerCallbacks callbacks) {
    mWindowManagerCallbacks = callbacks;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 mWindowManagerCallbacks 就是 wm.getInputManagerCallback()，即 创建的InputManagerCallback对象。&lt;/p&gt;
&lt;h3 id=&quot;15-启动：start&quot;&gt;1.5 启动：start()&lt;/h3&gt;
&lt;p&gt;前面 InputReader读取事件 和 InputDispatcher分派事件，&lt;strong&gt;这个过程是在 InputReaderThread和InputDispatcherThread 两个线程运行起来，执行了 threadLoop() 基础上讲解的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么 这两个线程是如何 运行起来，执行 threadLoop() 的？下面就来看下。&lt;/p&gt;
&lt;h4 id=&quot;151--进入native&quot;&gt;1.5.1 进入native&lt;/h4&gt;
&lt;p&gt;在 startOtherServices()中，创建IMS后，设置了回调，最后有 &lt;code&gt;inputManager.start();&lt;/code&gt; ，这个就是 两个线程运行起来 并执行了 threadLoop() 的起点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputManagerService.java
private static native void nativeStart(long ptr);

public void start() {
    ...
    nativeStart(mPtr);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要看下 nativeStart() 这个方法。 在 上面部分1.1 创建 InputManagerService中，大家还记得 mPtr 是：通过nativeInit(）进入native创建 NativeInputManager 后的相关返回值（mPtr 是 reinterpret_cast(im)，某一种转换）。&lt;/p&gt;
&lt;p&gt;继续跟踪下去。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//com_android_server_input_InputManagerService.cpp
static const JNINativeMethod gInputManagerMethods[] = {
    { &quot;nativeStart&quot;, &quot;(J)V&quot;, (void*) nativeStart },
}

static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) {
    //mPtr又转换成了NativeInputManager
    NativeInputManager* im = reinterpret_cast&amp;lt;NativeInputManager*&amp;gt;(ptr);
    status_t result = im-&amp;gt;getInputManager()-&amp;gt;start();
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mPtr又转换成了NativeInputManager，然后调用了InputManager的 start()方法。 继续看：&lt;/p&gt;
&lt;h4 id=&quot;152-run-操作&quot;&gt;1.5.2 run() 操作&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputManager.cpp
status_t InputManager::start() {
    status_t result = mDispatcherThread-&amp;gt;run(&quot;InputDispatcher&quot;, PRIORITY_URGENT_DISPLAY);
    ...
    result = mReaderThread-&amp;gt;run(&quot;InputReader&quot;, PRIORITY_URGENT_DISPLAY);
    ...
    return OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看，这里就是 InputReaderThread 和 InputDispatcherThread 两个线程 执行了 run() 操作。 具体看下这个run() 做了些啥，需要看其父类Thread。&lt;/p&gt;
&lt;h4 id=&quot;153-创建线程-并-执行-threadloop&quot;&gt;1.5.3 创建线程 并 执行 threadLoop()&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//system/core/libutils/Threads.cpp
Thread::Thread(bool canCallJava)
    : mCanCallJava(canCallJava),
      ...
{
}
status_t Thread::run(const char* name, int32_t priority, size_t stack)
{
    Mutex::Autolock _l(mLock);
    ...
    bool res;
        //InputReaderThread 和 InputDispatcherThread 创建时传入的 为true。
    if (mCanCallJava) {
        //创建线程。 注意这里的 _threadLoop
        res = createThreadEtc(_threadLoop,
                this, name, priority, stack, &amp;amp;mThread);
    } else {
        res = androidCreateRawThreadEtc(_threadLoop,
                this, name, priority, stack, &amp;amp;mThread);
    }
    ...
    return OK;
}

//frameworks/native/services/inputflinger/InputReaderBase.cpp
InputReaderThread::InputReaderThread(const sp&amp;lt;InputReaderInterface&amp;gt;&amp;amp; reader) :
        Thread(/*canCallJava*/ true), mReader(reader) {
}
//frameworks/native/services/inputflinger/InputDispatcher.cpp
InputDispatcherThread::InputDispatcherThread(const sp&amp;lt;InputDispatcherInterface&amp;gt;&amp;amp; dispatcher) :
        Thread(/*canCallJava*/ true), mDispatcher(dispatcher) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，mCanCallJava 是 true（创建 InputReaderThread和InputDispatcherThread时 传入的，上面代码也列出），然后通过createThreadEtc() 即创建 线程。 注意其中有个参数 _threadLoop。下面是 _threadLoop。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//system/core/libutils/Threads.cpp
int Thread::_threadLoop(void* user)
{
    Thread* const self = static_cast&amp;lt;Thread*&amp;gt;(user);
    ...
    result = self-&amp;gt;threadLoop();
    ...
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里 就是 执行 自身的 threadLoop()，即 InputReaderThread 和 InputDispatcherThread 两线程 执行 threadLoop()。&lt;/p&gt;
&lt;h2 id=&quot;2-wms中window获取事件和传递&quot;&gt;&lt;span&gt;2. WMS中Window获取事件和传递&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;IMS端讲完了，我们知道最后消息通过InputChannel发送到目标窗口的进程了。接下来看目标窗口是如何接收传递的。&lt;/p&gt;
&lt;p&gt;首先，来看下ViewRootImpl.setView() :&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
InputQueue.Callback mInputQueueCallback;
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    synchronized (this) {
        if (mView == null) {
            mView = view;
            ...
            if ((mWindowAttributes.inputFeatures
                    &amp;amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                //创建InputChannel对象 mInputChannel
                mInputChannel = new InputChannel();
            }
            mForceDecorViewVisibility = (mWindowAttributes.privateFlags
                    &amp;amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;
            try {
                ...
                //这里主要关注mInputChannel，它就是前面讲到的一个InputChannel,wms创建一对后传递回来的
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                        getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,
                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,
                        mTempInsets);
                setFrame(mTmpFrame);
            } 
            ...
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                //创建WindowInputEventReceiver，这里的Looper是应用主线程的Looper
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                        Looper.myLooper());
            }
            ...
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面也提到过，这里创建的mInputChannel 最终作为参数传递到WMS中，此时它什么都没有。在 WMS.addWindow()中 WindowState创建了一对InputChannel，其中一个通过transferTo()传递给了 mInputChannel。接下来就看WindowInputEventReceiver的创建。&lt;/p&gt;
&lt;h3 id=&quot;21-windowinputeventreceiver-的创建&quot;&gt;2.1 WindowInputEventReceiver 的创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
final class WindowInputEventReceiver extends InputEventReceiver {
    public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) {
        super(inputChannel, looper);
    }
}

//InputEventReceiver.java
public InputEventReceiver(InputChannel inputChannel, Looper looper) {
    ...
    mInputChannel = inputChannel;
    mMessageQueue = looper.getQueue();
    mReceiverPtr = nativeInit(new WeakReference&amp;lt;InputEventReceiver&amp;gt;(this),
            inputChannel, mMessageQueue);

    mCloseGuard.open(&quot;dispose&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过nativeInit() 进入 native层：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//android_view_InputEventReceiver.cpp
static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak,
        jobject inputChannelObj, jobject messageQueueObj) {
    ...
    //参考2.2，创建NativeInputEventReceiver
    sp&amp;lt;NativeInputEventReceiver&amp;gt; receiver = new NativeInputEventReceiver(env,
            receiverWeak, inputChannel, messageQueue);
    //参考2.3，执行initialize
    status_t status = receiver-&amp;gt;initialize();
    ...
    receiver-&amp;gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object
    return reinterpret_cast&amp;lt;jlong&amp;gt;(receiver.get());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;22-创建nativeinputeventreceiver&quot;&gt;2.2 创建NativeInputEventReceiver&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//android_view_InputEventReceiver.cpp
class NativeInputEventReceiver : public LooperCallback {
NativeInputEventReceiver::NativeInputEventReceiver(JNIEnv* env,
        jobject receiverWeak, const sp&amp;lt;InputChannel&amp;gt;&amp;amp; inputChannel,
        const sp&amp;lt;MessageQueue&amp;gt;&amp;amp; messageQueue) :
        mReceiverWeakGlobal(env-&amp;gt;NewGlobalRef(receiverWeak)),
        mInputConsumer(inputChannel), mMessageQueue(messageQueue),
        mBatchedInputEventPending(false), mFdEvents(0) {
    ...
}

InputConsumer::InputConsumer(const sp&amp;lt;InputChannel&amp;gt;&amp;amp; channel) :
        mResampleTouch(isTouchResamplingEnabled()),
        mChannel(channel), mMsgDeferred(false) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建NativeInputEventReceiver，注意两个地方 后面会讲到的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inputChannel封装到mInputConsumer&lt;/li&gt;
&lt;li&gt;NativeInputEventReceiver是LooperCallback的派生类，实现了handleEvent()方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23-执行initialize&quot;&gt;2.3 执行initialize()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//android_view_InputEventReceiver.cpp
status_t NativeInputEventReceiver::initialize() {
    setFdEvents(ALOOPER_EVENT_INPUT);
    return OK;
}

void NativeInputEventReceiver::setFdEvents(int events) {
    if (mFdEvents != events) {
        mFdEvents = events;
        
        int fd = mInputConsumer.getChannel()-&amp;gt;getFd();
        if (events) { 
            //fd添加到Looper中，监听InputChannel 读取事件
            mMessageQueue-&amp;gt;getLooper()-&amp;gt;addFd(fd, 0, events, this, NULL);
        } else {
            mMessageQueue-&amp;gt;getLooper()-&amp;gt;removeFd(fd);
        }
    }
}

/**
* The file descriptor is available for read operations.
*/
ALOOPER_EVENT_INPUT = 1 &amp;lt;&amp;lt; 0,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;addFd()参数this是LooperCallback，即NativeInputEventReceiver。&lt;br/&gt;跟踪下，fd最终添加到Looper的mRequests列表中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当Looper监听到有输入事件时，会回调 NativeInputEventReceiver的handleEvent()方法。&lt;/strong&gt; （这里面的机制也还没细究）&lt;/p&gt;
&lt;p&gt;这个可以参考下：Looper::pollInner()中 &lt;code&gt;int callbackResult = response.request.callback-&amp;gt;handleEvent(fd, events, data);&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;24-回调handleevent&quot;&gt;2.4 回调handleEvent()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//android_view_InputEventReceiver.cpp
int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) {
    ...
    if (events &amp;amp; ALOOPER_EVENT_INPUT) {
        JNIEnv* env = AndroidRuntime::getJNIEnv();
        //获取事件，然后回调到java层的 InputEventReceiver.dispatchInputEvent
        status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL);
    }
    ...
    return 1;
}

//android_view_InputEventReceiver.cpp
status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
        bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) {
    ...
    ScopedLocalRef&amp;lt;jobject&amp;gt; receiverObj(env, NULL);
    bool skipCallbacks = false;
    for (;;) {
        uint32_t seq;
        InputEvent* inputEvent;
        //从InputChannel读取信息，并处理保存事件到inputEvent，参考2.4.1
        status_t status = mInputConsumer.consume(&amp;amp;mInputEventFactory,
                consumeBatches, frameTime, &amp;amp;seq, &amp;amp;inputEvent);
        ...
        if (!skipCallbacks) {
            ...
            if (inputEventObj) {
                ...
                //回调java层的 InputEventReceiver.dispatchInputEvent，参考2.4.2
                env-&amp;gt;CallVoidMethod(receiverObj.get(),
                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);
            } 
        }
        ...
    }
}

//jni注册：android_view_InputEventReceiver.cpp
int register_android_view_InputEventReceiver(JNIEnv* env) {
    int res = RegisterMethodsOrDie(env, &quot;android/view/InputEventReceiver&quot;,
            gMethods, NELEM(gMethods));
    jclass clazz = FindClassOrDie(env, &quot;android/view/InputEventReceiver&quot;);
    gInputEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz);
    gInputEventReceiverClassInfo.dispatchInputEvent = GetMethodIDOrDie(env,
            gInputEventReceiverClassInfo.clazz,
            &quot;dispatchInputEvent&quot;, &quot;(ILandroid/view/InputEvent;)V&quot;);
    gInputEventReceiverClassInfo.dispatchBatchedInputEventPending = GetMethodIDOrDie(env,
            gInputEventReceiverClassInfo.clazz, &quot;dispatchBatchedInputEventPending&quot;, &quot;()V&quot;);
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NativeInputEventReceiver::handleEvent() 到 NativeInputEventReceiver::consumeEvents(）。这里关注两个:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从InputChannel读取信息，并处理保存事件到inputEvent&lt;/li&gt;
&lt;li&gt;回调java层的 InputEventReceiver.dispatchInputEvent&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;241-从inputchannel读取事件&quot;&gt;2.4.1 从InputChannel读取事件&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputTransport.cpp
status_t InputConsumer::consume(InputEventFactoryInterface* factory,
        bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) {
    ...
    *outSeq = 0;
    *outEvent = nullptr;

    // Fetch the next input message.
    // Loop until an event can be returned or no additional events are received.
    while (!*outEvent) {
        //前面列出过InputConsumer创建时 mMsgDeferred为false
        if (mMsgDeferred) {
            ...
        } else {
            // Receive a fresh message.
            //mChannel接收消息，即从socket中读取
            status_t result = mChannel-&amp;gt;receiveMessage(&amp;amp;mMsg);
            ...
        }
        ...
    }
    switch (mMsg.header.type) {
        case InputMessage::TYPE_KEY: {
            ...
            initializeKeyEvent(keyEvent, &amp;amp;mMsg);
            *outSeq = mMsg.body.key.seq;
            *outEvent = keyEvent;
            break;
        }

        case InputMessage::TYPE_MOTION: {
            ...
            updateTouchState(mMsg);
            initializeMotionEvent(motionEvent, &amp;amp;mMsg);
            *outSeq = mMsg.body.motion.seq;
            *outEvent = motionEvent;
            break;
        }
    }
    return OK;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过InputChannel接受IMS端发送过来的消息，并且根据事件类型做了一些处理。&lt;/p&gt;
&lt;h4 id=&quot;242-回调java层的-inputeventreceiverdispatchinputevent&quot;&gt;2.4.2 回调java层的 InputEventReceiver.dispatchInputEvent&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InputEventReceiver.java
@UnsupportedAppUsage
private void dispatchInputEvent(int seq, InputEvent event) {
    mSeqMap.put(event.getSequenceNumber(), seq);
    onInputEvent(event);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面知道，创建的是InputEventReceiver的子类WindowInputEventReceiver，因此onInputEvent()调用的是子类中方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
final class WindowInputEventReceiver extends InputEventReceiver {
    @Override
    public void onInputEvent(InputEvent event) {
        ...
        if (processedEvents != null) {
            ...
        } else {
            //输入事件 加入队列
            enqueueInputEvent(event, this, 0, true);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;25-输入事件处理&quot;&gt;2.5 输入事件处理&lt;/h3&gt;
&lt;p&gt;这里继续看 enqueueInputEvent():&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
@UnsupportedAppUsage
void enqueueInputEvent(InputEvent event,
        InputEventReceiver receiver, int flags, boolean processImmediately) {
    //获取QueuedInputEvent，event等封装进去。
    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);
    //获取队尾
    QueuedInputEvent last = mPendingInputEventTail;
    //插入队尾
    if (last == null) {
        mPendingInputEventHead = q;
        mPendingInputEventTail = q;
    } else {
        last.mNext = q;
        mPendingInputEventTail = q;
    }
    //数目加1
    mPendingInputEventCount += 1;
    Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,
            mPendingInputEventCount);
    //是否立即执行
    if (processImmediately) {
        doProcessInputEvents();
    } else {
        scheduleProcessInputEvents();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enqueueInputEvent() 首先将event等信息封装到了QueuedInputEvent，然后将其插入输入事件队列的队尾。&lt;/p&gt;
&lt;p&gt;继续看doProcessInputEvents():&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
void doProcessInputEvents() {
    // Deliver all pending input events in the queue.
    while (mPendingInputEventHead != null) {
        QueuedInputEvent q = mPendingInputEventHead;
        ...
        deliverInputEvent(q);
    }
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;循环处理队列中所有事件，每次取队首元素 传递处理。交由deliverInputEvent()方法处理。&lt;/p&gt;
&lt;h3 id=&quot;26-输入事件-传递到view&quot;&gt;2.6 输入事件 传递到View&lt;/h3&gt;
&lt;p&gt;继续看deliverInputEvent()：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
private void deliverInputEvent(QueuedInputEvent q) {
    ...
    InputStage stage;
    if (q.shouldSendToSynthesizer()) {
        stage = mSyntheticInputStage;
    } else {
        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
    }

    if (q.mEvent instanceof KeyEvent) {
        mUnhandledKeyManager.preDispatch((KeyEvent) q.mEvent);
    }

    if (stage != null) {
        handleWindowFocusChanged();
        //传递，参考3.1
        stage.deliver(q);
    } else {
        finishInputEvent(q);
    }
}
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    // Set up the input pipeline.
    CharSequence counterSuffix = attrs.getTitle();
    mSyntheticInputStage = new SyntheticInputStage();
    InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
    InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,
            &quot;aq:native-post-ime:&quot; + counterSuffix);
    InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
    InputStage imeStage = new ImeInputStage(earlyPostImeStage,
            &quot;aq:ime:&quot; + counterSuffix);
    InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
    InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,
            &quot;aq:native-pre-ime:&quot; + counterSuffix);

    mFirstInputStage = nativePreImeStage;
    mFirstPostImeInputStage = earlyPostImeStage;
    mPendingInputEventQueueLengthCounterName = &quot;aq:pending:&quot; + counterSuffix;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在setView() 中，创建了 input pipeline，将事件一层层传递下去。 调用&lt;code&gt;stage.deliver(q);&lt;/code&gt; 传递下去。&lt;/p&gt;

&lt;p&gt;前面讲到 事件已经传递到input pipeline中。这个暂不细究，往下继续看传递到View中的传递。&lt;/p&gt;
&lt;h3 id=&quot;31-传递到decorview&quot;&gt;3.1 传递到DecorView&lt;/h3&gt;
&lt;p&gt;直接看 stage.deliver(q) ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
abstract class InputStage {
    public final void deliver(QueuedInputEvent q) {
        if ((q.mFlags &amp;amp; QueuedInputEvent.FLAG_FINISHED) != 0) {
            forward(q);
        } else if (shouldDropInputEvent(q)) {
            finish(q, false);
        } else {
            apply(q, onProcess(q));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;onProcess(q)返回一个处理结果，apply根据这个结果再决定是否传递到InputStage的下一层。&lt;/p&gt;
&lt;p&gt;这主要关注的 onProcess()。在ViewPostImeInputStage阶段，开始向DecorView传递。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ViewRootImpl.java
final class ViewPostImeInputStage extends InputStage {
    @Override
    protected int onProcess(QueuedInputEvent q) {
        //处理不同类型的事件
        if (q.mEvent instanceof KeyEvent) {
            //按键事件处理
            return processKeyEvent(q);
        } else {
            final int source = q.mEvent.getSource();
            if ((source &amp;amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
                return processPointerEvent(q);
            } else if ((source &amp;amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                return processTrackballEvent(q);
            } else {
                return processGenericMotionEvent(q);
            }
        }
    }
    
    private int processKeyEvent(QueuedInputEvent q) {
        final KeyEvent event = (KeyEvent)q.mEvent;
        ...
        // Deliver the key to the view hierarchy.
        if (mView.dispatchKeyEvent(event)) {
            return FINISH_HANDLED;
        }
        ...
        return FORWARD;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;onProcess()中对不同类型事件进行不同的处理。这里仍然以按键事件为例，处理方法processKeyEvent()。&lt;/p&gt;
&lt;p&gt;这个mView即DecorView，setView()时 传入的。&lt;/p&gt;
&lt;p&gt;为什么是DecorView? 这个过程请参考： &lt;a href=&quot;https://www.cnblogs.com/fanglongxiang/p/13995868.html&quot;&gt;Android10_原理机制系列_Activity窗口添加到WMS过程。&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-传递到activity&quot;&gt;3.2 传递到Activity&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//DecorView.java
@Override
public boolean dispatchKeyEvent(KeyEvent event) {
    final int keyCode = event.getKeyCode();
    final int action = event.getAction();
    final boolean isDown = action == KeyEvent.ACTION_DOWN;
    ...
    if (!mWindow.isDestroyed()) {
        final Window.Callback cb = mWindow.getCallback();
        final boolean handled = cb != null &amp;amp;&amp;amp; mFeatureId &amp;lt; 0 ? cb.dispatchKeyEvent(event)
                : super.dispatchKeyEvent(event);
        if (handled) {
            return true;
        }
    }
    return isDown ? mWindow.onKeyDown(mFeatureId, event.getKeyCode(), event)
            : mWindow.onKeyUp(mFeatureId, event.getKeyCode(), event);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是Activity的窗口，cb获取到的是Activity，mFeatureId是-1。这里的mWindow是PhoneWindow，即Activity在attach()时 创建的PhoneWindow，在setContentView()过程 通过mDecor.setWindow()传入到DecorView中的。&lt;/p&gt;
&lt;p&gt;这个mWindow.getCallback()获取的是Activity本身，即Activity在attach()时setCallback() 传入的this本身。&lt;/p&gt;
&lt;p&gt;这个过程请参考( 那篇窗口添加到WMS中 说的很明白，这里不列出了)： &lt;a href=&quot;https://www.cnblogs.com/fanglongxiang/p/13995868.html&quot;&gt;Android10_原理机制系列_Activity窗口添加到WMS过程。&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-事件在view中传递处理&quot;&gt;3.3 事件在View中传递处理&lt;/h3&gt;
&lt;p&gt;由于按键事件 和 触摸事件是 最常见的，这里都简单列举了下。&lt;/p&gt;
&lt;h4 id=&quot;331-按键事件传递处理&quot;&gt;3.3.1 按键事件传递处理&lt;/h4&gt;
&lt;p&gt;接着前面，按键事件 可以直接看cb.dispatchKeyEvent(event)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Activity.java
public boolean dispatchKeyEvent(KeyEvent event) {
    ...
    Window win = getWindow();
    //交由Window继续传递，返回false，则继续交由Activity处理。若返回的true，则下层已处理掉了。          
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null) decor = win.getDecorView();
    return event.dispatch(this, decor != null
            ? decor.getKeyDispatcherState() : null, this);
}
//PhoneWindow.java
@Override
public boolean superDispatchKeyEvent(KeyEvent event) {
    //传递给DecorView
    return mDecor.superDispatchKeyEvent(event);
}
//DecorView.java
public boolean superDispatchKeyEvent(KeyEvent event) {
    ...
    //传递到ViewGroup。返回true，则下层处理了 上层不处理。  
    if (super.dispatchKeyEvent(event)) {
        return true;
    }

    return (getViewRootImpl() != null) &amp;amp;&amp;amp; getViewRootImpl().dispatchUnhandledKeyEvent(event);
}
//ViewGroup.java
@Override
public boolean dispatchKeyEvent(KeyEvent event) {
    if ((mPrivateFlags &amp;amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))
            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        //传递给具体的View
        if (super.dispatchKeyEvent(event)) {
            return true;
        }
    } else if (mFocused != null &amp;amp;&amp;amp; (mFocused.mPrivateFlags &amp;amp; PFLAG_HAS_BOUNDS)
            == PFLAG_HAS_BOUNDS) {
        if (mFocused.dispatchKeyEvent(event)) {
            return true;
        }
    }
    return false;
}
//View.java
public boolean dispatchKeyEvent(KeyEvent event) {
    ...
    // Give any attached key listener a first crack at the event.
    //noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null &amp;amp;&amp;amp; li.mOnKeyListener != null &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
            &amp;amp;&amp;amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    if (event.dispatch(this, mAttachInfo != null
                       ? mAttachInfo.mKeyDispatchState : null, this)) {
        return true;
    }
    return false;
}
//KeyEvent.java
public final boolean dispatch(Callback receiver, DispatcherState state,
                Object target) {
        switch (mAction) {
                case ACTION_DOWN: {
                        mFlags &amp;amp;= ~FLAG_START_TRACKING;
                        boolean res = receiver.onKeyDown(mKeyCode, this);
                        ...
                        return res;
                }
                case ACTION_UP:
                        ...
                        return receiver.onKeyUp(mKeyCode, this);
                case ACTION_MULTIPLE:
                        ...
                        return false;
        }
        return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述代码过程，keyEvent由外到内传递，由Activity到具体的View。&lt;/p&gt;
&lt;p&gt;ListenerInfo就是关联的我们自定义的监听，如setOnClickListener()，setOnLongClickListener。&lt;/p&gt;
&lt;p&gt;这里的传递是：由Activity到ViewGrop再到View，如果某个环节返回true，即事件被处理掉不再向下层传递。如果最底层View仍未处理 而返回false，则再依次向外传递至Activity(向外传递中仍未被处理的话)处理。&lt;/p&gt;
&lt;p&gt;注意：dispatchKeyEvent()都是有的。 onKeyDown，onKeyUp、onKeyLongPress等是View中有，同样为true即处理掉 不在传递了。&lt;/p&gt;
&lt;h4 id=&quot;332-触摸事件传递处理&quot;&gt;3.3.2 触摸事件传递处理&lt;/h4&gt;
&lt;p&gt;触摸事件，类似按键事件，这里直接看 最终传递到的Activity的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//Activity.java
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    //传递到Window
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    //若下层不处理，则调用onTouchEvent()处理掉。
    return onTouchEvent(ev);
}
//PhoneWindow.java
public boolean superDispatchTouchEvent(MotionEvent event) {
    return mDecor.superDispatchTouchEvent(event);
}
//DecorView.java
public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
}
//ViewGroup.java
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    ...
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        ...
        // Check for interception.
        final boolean intercepted;
        ...
                //拦截
                intercepted = onInterceptTouchEvent(ev);
        ...
        
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        //Update list of touch targets for pointer down, if needed.
        if (!canceled &amp;amp;&amp;amp; !intercepted) {
            ...
        }

        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
                                ...
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
        }
    }
    return handled;
}

private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
        View child, int desiredPointerIdBits) {
    ...
    // Perform any necessary transformations and dispatch.
    if (child == null) {
        handled = super.dispatchTouchEvent(transformedEvent);
    } else {
        ...
        handled = child.dispatchTouchEvent(transformedEvent);
    }
    return handled;
}
//View.java
public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    if (onFilterTouchEventForSecurity(event)) {
        if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
            result = true;
        }
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    ...
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与按键事件类似，由外到内传递。也有ListenerInfo关联View中自定义的监听。&lt;/p&gt;
&lt;p&gt;传递过程也基本一样：由Activity到ViewGrop再到View，如果某个环节返回true，即事件被处理掉不再向下层传递。如果最底层View仍未处理 而返回false，则再依次向外传递至Activity(向外传递中仍未被处理)处理。&lt;/p&gt;
&lt;p&gt;注意：dispatchTouchEvent()，onTouchEvent()都是有的。 ViewGroup中多了个onInterceptTouchEvent()，若为true， 则是将事件拦截，不在传递。&lt;/p&gt;
&lt;p&gt;到此结束了，本篇差不多有上万字了，但也只是个大概。仍需不断学习。&lt;br/&gt;&lt;strong&gt;多谢阅读，欢迎交流。&lt;/strong&gt;&lt;/p&gt;
&lt;br/&gt;</description>
<pubDate>Mon, 07 Dec 2020 17:25:00 +0000</pubDate>
<dc:creator>流浪_归家</dc:creator>
<og:description>前言和概述 Android的输入设备，最常用的就是 触摸屏和按键 了。当然还有其他方式，比如游戏手柄，比如支持OTG设备，则可以链接鼠标、键盘等。 那么这些设备的操作 是如何传递到系统 并 控制界面的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fanglongxiang/p/14091511.html</dc:identifier>
</item>
</channel>
</rss>