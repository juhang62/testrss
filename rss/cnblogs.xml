<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>1500【自定义函数】走楼梯 - knbit</title>
<link>http://www.cnblogs.com/cyk20081108/p/14351557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyk20081108/p/14351557.html</guid>
<description>[unable to retrieve full-text content]描述 已知一个楼梯有n级，小谢同学从下往上走，一步可以走一级，也可以走两级。问：他走到第n级楼梯有多少种走法？ 输入 一行一个正整数n，1≤n≤40。 输出 一行一个整数，表示走到第n级有多少种走法。 输入样例 1 9 输出样例 1 55这道题一上手时，我相信大多数人都会第一时间想到用递推来解。但是</description>
<pubDate>Sun, 31 Jan 2021 00:31:00 +0000</pubDate>
<dc:creator>knbit</dc:creator>
<dc:identifier>http://www.cnblogs.com/cyk20081108/p/14351557.html</dc:identifier>
</item>
<item>
<title>为什么Redis集群要使用反向代理? - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14351545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14351545.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;38&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202101/2002319-20210131080816965-1179478880.png&quot; class=&quot;desc_img&quot;/&gt;本文从为什么Redis为什么需要代理开始推导,预测这过程中可能出现的问题并提出解决方案,例如对代理负载均衡,以及LVS心跳检测,最后对比了目前常用代理性能的优劣。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;95.798655343241&quot;&gt;
&lt;h2 id=&quot;为什么要使用反向代理&quot;&gt;为什么要使用反向代理?&lt;/h2&gt;
&lt;p&gt;如果没有方向代理,一台Redis可能需要跟很多个客户端连接:&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202101/2002319-20210131080526659-119858341.png&quot; alt=&quot;2002319-20210131080526659-119858341&quot;/&gt;&lt;p&gt;看着是不是很慌?看没关系,主要是连接需要消耗线程资源,没有代理的话,Redis要将很大一部分的资源用在与客户端建立连接上,redis的高可用和可扩展无论是自带的Redis Sentinel还是Redis Cluster都要求客户端进行额外的支持，而目前基本上没有合适的客户端能够做这些事情，客户端来做这些事情也并不合适，它会让维护变得特别困难。&lt;/p&gt;
&lt;p&gt;因此在客户端和redis服务端之间加一层代理成了一种理想的方案，代理屏蔽后端Redis实现细节向客户端提供redis服务，可以完美的解决Redis的高可用和扩展性问题，同时代理的引入也使得Redis维护变得更加简单。&lt;/p&gt;
&lt;p&gt;于是乎,有了代理:&lt;/p&gt;
&lt;h2 id=&quot;如何使用代理&quot;&gt;如何使用代理?&lt;/h2&gt;
&lt;p&gt;很简单,将请求连接到调度代理器上,由Proxy负责将请求转发到后面的Redis服务实例,图示:&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202101/2002319-20210131080732301-1329663942.png&quot; alt=&quot;2002319-20210131080732301-1329663942&quot;/&gt;&lt;p&gt;又有了新的问题,Proxy挂了可咋整?&lt;/p&gt;
&lt;p&gt;所以Proxy又需要做集群,甚至前面可以加一层负载均衡,负载均衡嘛,单机也存在单点故障等问题,一个Director肯定不行,搞不好又挂了,所以整一个主备,备机通过KeepAlived来检测主LVS健康状况,出了问题顶上去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202101/2002319-20210131080816965-1179478880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis代理插件&quot;&gt;Redis代理插件&lt;/h2&gt;
&lt;p&gt;Redis代理插件有很多,这儿简单介绍几款&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://github.com/joyieldInc/predixy&quot; target=&quot;_blank&quot;&gt;predixy&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;高性能全特征redis代理，支持Redis Sentinel和Redis Cluster&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5409836065574&quot;&gt;&lt;tr readability=&quot;1.6470588235294&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://github.com/twitter/twemproxy&quot; target=&quot;_blank&quot;&gt;twemproxy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;快速、轻量级memcached和redis代理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7142857142857&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://github.com/CodisLabs/codis/&quot; target=&quot;_blank&quot;&gt;codis&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;redis集群代理解决方案&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://link.jianshu.com?t=https://github.com/projecteru/redis-cerberus&quot; target=&quot;_blank&quot;&gt;redis-cerberus&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Redis Cluster代理&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;代理详细功能对比&quot;&gt;代理详细功能对比&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;predixy&lt;/th&gt;
&lt;th&gt;twemproxy&lt;/th&gt;
&lt;th&gt;codis&lt;/th&gt;
&lt;th&gt;redis-cerberus&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;高可用&lt;/td&gt;
&lt;td&gt;Redis Sentinel或Redis Cluster&lt;/td&gt;
&lt;td&gt;一致性哈希&lt;/td&gt;
&lt;td&gt;Redis Sentinel&lt;/td&gt;
&lt;td&gt;Redis Cluster&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;可扩展&lt;/td&gt;
&lt;td&gt;Key哈希分布或Redis Cluster&lt;/td&gt;
&lt;td&gt;Key哈希分布&lt;/td&gt;
&lt;td&gt;Key哈希分布&lt;/td&gt;
&lt;td&gt;Redis Cluster&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发语言&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;GO&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;多线程&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;事务&lt;/td&gt;
&lt;td&gt;Redis Sentinel模式单Redis组下支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLPOP/BRPOP/BLPOPRPUSH&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pub/Sub&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Script&lt;/td&gt;
&lt;td&gt;支持load&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Scan&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Select DB&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;Redis Cluster只有一个DB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Auth&lt;/td&gt;
&lt;td&gt;支持定义多个密码，给予不同读写及管理权限和Key访问空间&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;同redis&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;读从节点&lt;/td&gt;
&lt;td&gt;支持，可定义丰富规则读指定的从节点&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持，简单规则&lt;/td&gt;
&lt;td&gt;支持，简单规则&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;多机房支持&lt;/td&gt;
&lt;td&gt;支持，可定义丰富规则调度流量&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;有限支持&lt;/td&gt;
&lt;td&gt;有限支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;统计信息&lt;/td&gt;
&lt;td&gt;丰富&lt;/td&gt;
&lt;td&gt;丰富&lt;/td&gt;
&lt;td&gt;丰富&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单来说，predixy既支持Redis Sentinel也支持Redis Cluster&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后端为Redis Sentinel监控的一组Redis，功能完全等同于原始Redis&lt;/li&gt;
&lt;li&gt;后端为Redis Sentinel监控的多组Redis，则有部分功能受限&lt;/li&gt;
&lt;li&gt;后端为Redis Cluster，功能完全等同于Redis Cluster&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Sun, 31 Jan 2021 00:12:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>为什么要使用反向代理? 如果没有方向代理,一台Redis可能需要跟很多个客户端连接: 看着是不是很慌?看没关系,主要是连接需要消耗线程资源,没有代理的话,Redis要将很大一部分的资源用在与客户端建立</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14351545.html</dc:identifier>
</item>
<item>
<title>【Soul网关探秘】http数据同步-Web端处理变更通知 - 腾业</title>
<link>http://www.cnblogs.com/tengye93/p/14351526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tengye93/p/14351526.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/tengye/vtss9i&quot; target=&quot;_blank&quot;&gt;个人知识库&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇，梳理http 数据同步策略的变更通知机制，本篇开始探究配置变更通知到达后， &lt;code&gt;soul-web&lt;/code&gt; 端的处理响应。&lt;/p&gt;
&lt;p&gt;不同数据变更的通知机制应当是一致的，故本篇以 selector 配置变更通知为切入点进行深入。&lt;/p&gt;
&lt;h2 id=&quot;通知处理入口&quot;&gt;通知处理入口&lt;/h2&gt;
&lt;p&gt;上回我们说到 HttpSyncDataService 的 doLongPolling，在其内部发起通知订阅并接收响应通知：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doLongPolling(final String server) {
    ...
    String listenerUrl = server + &quot;/configs/listener&quot;;
    ...
    try {
        // 发起监听请求
        String json = this.httpClient.postForEntity(listenerUrl, httpEntity, String.class).getBody();
        log.debug(&quot;listener result: [{}]&quot;, json);
        groupJson = GSON.fromJson(json, JsonObject.class).getAsJsonArray(&quot;data&quot;);
    } catch (RestClientException e) {
        ...
    }
        // 处理变更通知
    if (groupJson != null) {
        // fetch group configuration async.
        ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);
        if (ArrayUtils.isNotEmpty(changedGroups)) {
            log.info(&quot;Group config changed: {}&quot;, Arrays.toString(changedGroups));
            // 获取组配置
                this.doFetchGroupConfig(server, changedGroups);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在收到变更通知时，若存在配置组变更，则按变更组获取相应配置。&lt;/p&gt;
&lt;h2 id=&quot;获取配置&quot;&gt;获取配置&lt;/h2&gt;
&lt;p&gt;获取组配置处理如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {
    ...
    String url = server + &quot;/configs/fetch?&quot; + StringUtils.removeEnd(params.toString(), &quot;&amp;amp;&quot;);
    ...
    try {
        json = this.httpClient.getForObject(url, String.class);
    } catch (RestClientException e) {
        ...
    }
    // update local cache
    boolean updated = this.updateCacheWithJson(json);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部发起配置获取请求并更新本地缓存。&lt;/p&gt;
&lt;h2 id=&quot;更新配置组缓存&quot;&gt;更新配置组缓存&lt;/h2&gt;
&lt;p&gt;由 HttpSyncDataService 实现本地缓存更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  private boolean updateCacheWithJson(final String json) {
    JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);
    JsonObject data = jsonObject.getAsJsonObject(&quot;data&quot;);
    // if the config cache will be updated?
    return factory.executor(data);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转成 Json 对象后交由 DataRefreshFactory 进行处理。&lt;/p&gt;
&lt;p&gt;DataRefreshFactory 处理如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean executor(final JsonObject data) {
    final boolean[] success = {false};
    ENUM_MAP.values().parallelStream().forEach(dataRefresh -&amp;gt; success[0] = dataRefresh.refresh(data));
    return success[0];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用相应数据刷新类刷新数据。&lt;/p&gt;
&lt;p&gt;统一由 AbstractDataRefresh 的 refresh 进行处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Boolean refresh(final JsonObject data) {
    boolean updated = false;
    JsonObject jsonObject = convert(data);
    if (null != jsonObject) {
        ConfigData&amp;lt;T&amp;gt; result = fromJson(jsonObject);
        if (this.updateCacheIfNeed(result)) {
            updated = true;
            refresh(result.getData());
        }
    }
    return updated;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先更新本地缓存，再调用子类实现的 refresh。&lt;/p&gt;
&lt;p&gt;此处的更新本地缓存处理，由子类 SelectorDataRefresh 的 updateCacheIfNeed 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean updateCacheIfNeed(final ConfigData&amp;lt;SelectorData&amp;gt; result) {
    return updateCacheIfNeed(result, ConfigGroupEnum.SELECTOR);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向父类 AbstractDataRefresh 的 updateCacheIfNeed 指定更新 selector 配置组。&lt;/p&gt;
&lt;p&gt;父类 AbstractDataRefresh 的 updateCacheIfNeed 处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected boolean updateCacheIfNeed(final ConfigData&amp;lt;T&amp;gt; newVal, final ConfigGroupEnum groupEnum) {
    // 首次初始化缓存
    if (GROUP_CACHE.putIfAbsent(groupEnum, newVal) == null) {
        return true;
    }
    ResultHolder holder = new ResultHolder(false);
    GROUP_CACHE.merge(groupEnum, newVal, (oldVal, value) -&amp;gt; {
        // 必须比较最后更新时间
        if (!StringUtils.equals(oldVal.getMd5(), newVal.getMd5()) &amp;amp;&amp;amp; oldVal.getLastModifyTime() &amp;lt; newVal.getLastModifyTime()) {
            ...
            holder.result = true;
            return newVal;
        }
        ...
        return oldVal;
    });
    return holder.result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过比较新老缓存的 MD5 值来判定是否发生变更，存在变更则更新本地缓存（注意还有最后更新时间判定）。&lt;/p&gt;
&lt;h2 id=&quot;处理刷新事件&quot;&gt;处理刷新事件&lt;/h2&gt;
&lt;p&gt;SelectorDataRefresh 的 refresh 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void refresh(final List&amp;lt;SelectorData&amp;gt; data) {
    if (CollectionUtils.isEmpty(data)) {
        log.info(&quot;clear all selector cache, old cache&quot;);
        data.forEach(pluginDataSubscriber::unSelectorSubscribe);
        pluginDataSubscriber.refreshSelectorDataAll();
    } else {
        // update cache for UpstreamCacheManager
        pluginDataSubscriber.refreshSelectorDataAll();
        data.forEach(pluginDataSubscriber::onSelectorSubscribe);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;若最新数据为空，则循环取消订阅并刷新所有选择器数据，实际是清空选择器缓存。&lt;/li&gt;
&lt;li&gt;若最新数据不为空，则刷新所有选择器数据并循环响应选择器订阅事件处理，实际是更新上游服务缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;取消订阅&quot;&gt;取消订阅&lt;/h3&gt;
&lt;p&gt;CommonPluginDataSubscriber 实现订阅取消：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void unSelectorSubscribe(final SelectorData selectorData) {
    subscribeDataHandler(selectorData, DataEventTypeEnum.DELETE);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;subscribeDataHandler 对 selectorData 的 delete 处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private &amp;lt;T&amp;gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {
    Optional.ofNullable(classData).ifPresent(data -&amp;gt; {
        if (data instanceof PluginData) {
            ...
        } else if (data instanceof SelectorData) {
            SelectorData selectorData = (SelectorData) data;
            if (dataType == DataEventTypeEnum.UPDATE) {
                ...
            } else if (dataType == DataEventTypeEnum.DELETE) {
                BaseDataCache.getInstance().removeSelectData(selectorData);
                Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&amp;gt; handler.removeSelector(selectorData));
            }
        } else if (data instanceof RuleData) {
            ...
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 BaseDataCache 删除目标选择器数据，并移除选择器。&lt;/p&gt;
&lt;p&gt;此处由 DividePluginDataHandler 提供 removeSelector 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void removeSelector(final SelectorData selectorData) {
    UpstreamCacheManager.getInstance().removeByKey(selectorData.getId());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据 selector id 移除缓存的上游服务，注意只是从 UPSTREAM_MAP_TEMP 移除&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void removeByKey(final String key) {
    UPSTREAM_MAP_TEMP.remove(key);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;刷新数据&quot;&gt;刷新数据&lt;/h3&gt;
&lt;p&gt;CommonPluginDataSubscriber 实现数据刷新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void refreshSelectorDataAll() {
    BaseDataCache.getInstance().cleanSelectorData();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里的 refresh all 实际是做的 clean 操作。&lt;/p&gt;
&lt;p&gt;BaseDataCache 的 cleanSelectorData 处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void cleanSelectorData() {
    SELECTOR_MAP.clear();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接清除 SELECTOR_MAP 所有数据。&lt;/p&gt;
&lt;h3 id=&quot;响应订阅&quot;&gt;响应订阅&lt;/h3&gt;
&lt;p&gt;CommonPluginDataSubscriber 实现订阅响应：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void onSelectorSubscribe(final SelectorData selectorData) {
    subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;subscribeDataHandler 对 selectorData 的 update 处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private &amp;lt;T&amp;gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {
    Optional.ofNullable(classData).ifPresent(data -&amp;gt; {
        if (data instanceof PluginData) {
            ...
        } else if (data instanceof SelectorData) {
            SelectorData selectorData = (SelectorData) data;
            if (dataType == DataEventTypeEnum.UPDATE) {
                BaseDataCache.getInstance().cacheSelectData(selectorData);
                Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&amp;gt; handler.handlerSelector(selectorData));
            } else if (dataType == DataEventTypeEnum.DELETE) {
                ...
            }
        } else if (data instanceof RuleData) {
            ...
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缓存选择器数据到 BaseDataCache，并处理选择器。&lt;/p&gt;
&lt;p&gt;此处由 DividePluginDataHandler 提供 handlerSelector 实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void handlerSelector(final SelectorData selectorData) {
    UpstreamCacheManager.getInstance().submit(selectorData);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交选择器数据到 UpstreamCacheManager。&lt;/p&gt;
&lt;p&gt;UpstreamCacheManager 的 submit 处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void submit(final SelectorData selectorData) {
    final List&amp;lt;DivideUpstream&amp;gt; upstreamList = GsonUtils.getInstance().fromList(selectorData.getHandle(), DivideUpstream.class);
    if (null != upstreamList &amp;amp;&amp;amp; upstreamList.size() &amp;gt; 0) {
        UPSTREAM_MAP.put(selectorData.getId(), upstreamList);
        UPSTREAM_MAP_TEMP.put(selectorData.getId(), upstreamList);
    } else {
        UPSTREAM_MAP.remove(selectorData.getId());
        UPSTREAM_MAP_TEMP.remove(selectorData.getId());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据 selector id 更新 UPSTREAM_MAP 和 UPSTREAM_MAP_TEMP。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇梳理和分析了配置变更通知到达后 &lt;code&gt;soul-web&lt;/code&gt; 端的处理流程，最终处理主要是更新本地配置缓存以及维护上游服务散列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;soul-web&lt;/code&gt;收到变更通知后处理流程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;soul-web 端收到响应&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若配置组数据存在变更，则发起获取配置请求获取最新配置信息
&lt;ul&gt;&lt;li&gt;更新配置组缓存&lt;/li&gt;
&lt;li&gt;循环处理配置数据刷新事件
&lt;ul&gt;&lt;li&gt;若最新配置数据为空，则删除本地配置数据并移除上游服务&lt;/li&gt;
&lt;li&gt;若最新配置数据不为空，则缓存配置组数据并更新上游服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;若配置组数据无变更，不作处理&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Sat, 30 Jan 2021 21:17:00 +0000</pubDate>
<dc:creator>腾业</dc:creator>
<og:description>个人知识库 引言 上一篇，梳理http 数据同步策略的变更通知机制，本篇开始探究配置变更通知到达后， soul-web 端的处理响应。 不同数据变更的通知机制应当是一致的，故本篇以 selector</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tengye93/p/14351526.html</dc:identifier>
</item>
<item>
<title>UI自动化测试实战 - Huny</title>
<link>http://www.cnblogs.com/huny/p/14349879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huny/p/14349879.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面我们已经搭建好了wordpress网站，如果需要查看运行效果可以看我前面的搭建文章，下面我们来进行自动化测试的练习。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;首先我们测试自动登陆&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import unittest
from selenium import webdriver
import uuid
from time import sleep

username = passwd = '***'
uid = str(uuid.uuid1())
suid = ''.join(uid.split('-'))
url = 'http://139.199.192.100:8000/wp-login.php'


class Test_Blog(unittest.TestCase):
    '''博客测试用例初始化配置'''
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(url)
        self.driver.implicitly_wait(10)
        self.driver.maximize_window()

    def tearDown(self):
        self.driver.quit()

class test_login(Test_Blog):
    '''博客登陆测试用例'''
    def test_login(self):        
        self.driver.find_element_by_id('user_login').send_keys(username)
        self.driver.find_element_by_id('user_pass').send_keys(passwd)
        self.driver.find_element_by_id('rememberme').click()
        self.driver.find_element_by_id('wp-submit').click()
        sleep(1)
        title_url = self.driver.current_url
        assert 'wp-admin' in title_url, '登陆不成功或者断言错误'
        
if __name__ == '__main__':
    unittest.main()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登陆之后，我们来测试写文章功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import unittest
from selenium import webdriver
import uuid
from time import sleep

username = passwd = '***'
uid = str(uuid.uuid1())
suid = ''.join(uid.split('-'))
url = 'http://139.199.192.100:8000/wp-login.php'


class Test_Blog(unittest.TestCase):
    '''博客测试用例初始化配置'''
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(url)
        self.driver.implicitly_wait(10)
        self.driver.maximize_window()

    def tearDown(self):
        self.driver.quit()

class test_login(Test_Blog):
    '''博客登陆测试用例'''
    def test_login(self):        
        self.driver.find_element_by_id('user_login').send_keys(username)
        self.driver.find_element_by_id('user_pass').send_keys(passwd)
        self.driver.find_element_by_id('rememberme').click()
        self.driver.find_element_by_id('wp-submit').click()
        sleep(1)
        title_url = self.driver.current_url
        assert 'wp-admin' in title_url, '登陆不成功或者断言错误'
        

class test_write_Blog(Test_Blog):
    '''博客写文章测试用例'''
    def test_write_blog(self):
        
        self.driver.find_element_by_id('user_login').send_keys(username)
        self.driver.find_element_by_id('user_pass').send_keys(passwd)
        self.driver.find_element_by_id('rememberme').click()
        self.driver.find_element_by_id('wp-submit').click()
        sleep(1)
        self.driver.find_element_by_css_selector(
            '#menu-posts &amp;gt; a &amp;gt;.wp-menu-name').click()
        self.driver.find_element_by_css_selector('.page-title-action').click()

        self.driver.find_element_by_css_selector(
            'div.components-modal__header &amp;gt; button &amp;gt; svg').click()
        sleep(1)
        self.driver.find_element_by_css_selector(
            '#post-title-0').send_keys(suid)
        self.driver.find_element_by_css_selector(
            '#post-content-0').send_keys(suid)
        self.driver.find_element_by_css_selector(
            'button.components-button.editor-post-publish-panel__toggle.editor-post-publish-button__button.is-primary').click()
        self.driver.find_element_by_css_selector(
            'div.editor-post-publish-panel__header-publish-button &amp;gt; button').click()

        blog_status = self.driver.find_element_by_css_selector(
            'div.components-panel__body.post-publish-panel__postpublish-header.is-opened').text
        assert '已被发布' in blog_status, '文章未发布或断言错误'


if __name__ == '__main__':
    unittest.main()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写文章测试完了，该把文章删除掉了，于是我们再来进行删除的测试用例,并且优化了登陆的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import unittest
from selenium import webdriver
import uuid
from time import sleep

from selenium.webdriver.common.action_chains import ActionChains

username = passwd = '***'
uid = str(uuid.uuid1())
suid = ''.join(uid.split('-'))
url = 'http://139.199.192.100:8000/wp-login.php'


class Test_Blog(unittest.TestCase):
    '''博客测试用例前置和后置'''

    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(url)
        self.driver.implicitly_wait(10)
        self.driver.maximize_window()
        self.driver.find_element_by_id('user_login').send_keys(username)
        self.driver.find_element_by_id('user_pass').send_keys(passwd)
        self.driver.find_element_by_id('rememberme').click()
        self.driver.find_element_by_id('wp-submit').click()
        sleep(1)

    def tearDown(self):
        self.driver.quit()


class test_login(Test_Blog):
    '''博客登陆测试用例'''

    def test_login(self):
        title_url = self.driver.current_url
        assert 'wp-admin' in title_url, '登陆不成功或者断言错误'


class test_write_Blog(Test_Blog):
    '''博客写文章测试用例'''

    def test_write_blog(self):
        self.driver.find_element_by_css_selector(
            '#menu-posts &amp;gt; a &amp;gt;.wp-menu-name').click()
        self.driver.find_element_by_css_selector('.page-title-action').click()      #点击写文章
        sleep(1)
        self.driver.find_element_by_css_selector(
            'div.components-modal__header &amp;gt; button &amp;gt; svg').click()      #关闭弹窗
        self.driver.find_element_by_css_selector(
            '#post-title-0').send_keys(suid)        #写标题
        self.driver.find_element_by_css_selector(
            '#post-content-0').send_keys(suid)      #写文本
        self.driver.find_element_by_css_selector(
            'button.components-button.editor-post-publish-panel__toggle.editor-post-publish-button__button.is-primary').click()     #点击发布
        self.driver.find_element_by_css_selector(
            'div.editor-post-publish-panel__header-publish-button &amp;gt; button').click()    
        blog_status = self.driver.find_element_by_css_selector(
            'div.components-panel__body.post-publish-panel__postpublish-header.is-opened').text     #获取发布状态
        assert '已被发布' in blog_status, '文章未发布或断言错误'


class Test_Delete_Blog(Test_Blog):
    '''博客删除测试用例'''

    def test_delete_blog(self):
        self.driver.find_element_by_css_selector(
            '#menu-posts &amp;gt; a &amp;gt;.wp-menu-name').click()
        mouse = self.driver.find_elements_by_css_selector(
            'td.author.column-author &amp;gt; a')[0]  # 定位第一行作者元素
        ActionChains(self.driver).move_to_element(mouse).perform()  # 鼠标悬停到第一行
        blog_title_old = self.driver.find_elements_by_css_selector(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].text
        self.driver.find_elements_by_css_selector(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].click()
        blog_title_new = self.driver.find_elements_by_css_selector(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].text
        assert blog_title_old != blog_title_new  # 判断删除前和删除后的同一元素位置的文本不相等


if __name__ == '__main__':
    unittest.main()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1510016/202101/1510016-20210131005734017-1487449783.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉还是有很多重复的代码，我们可以在进行优化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import unittest
from selenium import webdriver
import uuid
from time import sleep

from selenium.webdriver.common.action_chains import ActionChains

username = passwd = '***'
uid = str(uuid.uuid1())
suid = ''.join(uid.split('-'))
url = 'http://139.199.192.100:8000/wp-login.php'



class Test_Blog(unittest.TestCase):
    '''博客测试用例前置和后置'''

    def element_find_func(self,e):
        return self.driver.find_element_by_css_selector(e)

    def elements_find_func(self,e):
        return self.driver.find_elements_by_css_selector(e)

    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.get(url)
        self.driver.implicitly_wait(10)
        self.driver.maximize_window()
        self.element_find_func('#user_login').send_keys(username)
        self.element_find_func('#user_pass').send_keys(passwd)
        self.element_find_func('#rememberme').click()
        self.element_find_func('#wp-submit').click()
        sleep(1)

    def tearDown(self):
        self.driver.quit()


class test_login(Test_Blog):
    '''博客登陆测试用例'''

    def test_login(self):
        title_url = self.driver.current_url
        assert 'wp-admin' in title_url, '登陆不成功或者断言错误'


class test_write_Blog(Test_Blog):
    '''博客写文章测试用例'''

    def test_write_blog(self):
        self.element_find_func(
            '#menu-posts &amp;gt; a &amp;gt;.wp-menu-name').click()
        self.element_find_func(
            '.page-title-action').click()       # 点击写文章
        sleep(1)
        self.element_find_func(
            'div.components-modal__header &amp;gt; button &amp;gt; svg').click()      # 关闭弹窗
        self.element_find_func(
            '#post-title-0').send_keys(suid)        # 写标题
        self.element_find_func(
            '#post-content-0').send_keys(suid)      # 写文本
        self.element_find_func(
            'button.components-button.editor-post-publish-panel__toggle.editor-post-publish-button__button.is-primary').click()     # 点击发布
        self.element_find_func(
            'div.editor-post-publish-panel__header-publish-button &amp;gt; button').click()
        blog_status = self.element_find_func(
            'div.components-panel__body.post-publish-panel__postpublish-header.is-opened').text     # 获取发布状态
        assert '已被发布' in blog_status, '文章未发布或断言错误'


class Test_Delete_Blog(Test_Blog):
    '''博客删除测试用例'''

    def test_delete_blog(self):
        self.element_find_func(
            '#menu-posts &amp;gt; a &amp;gt;.wp-menu-name').click()
        mouse = self.elements_find_func(
            'td.author.column-author &amp;gt; a')[0]                               # 定位第一行作者元素
        ActionChains(self.driver).move_to_element(mouse).perform()          # 鼠标悬停到第一行
        blog_title_old = self.elements_find_func(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].text       #定位多个元素中取第一个
        self.elements_find_func(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].click()
        blog_title_new = self.elements_find_func(
            'td.title.column-title.has-row-actions.column-primary.page-title &amp;gt; div.row-actions &amp;gt; span.trash &amp;gt; a')[0].text
        assert blog_title_old != blog_title_new                             # 判断删除前和删除后的同一元素位置的文本不相等


if __name__ == '__main__':
    unittest.main()

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Jan 2021 16:58:00 +0000</pubDate>
<dc:creator>Huny</dc:creator>
<og:description>##前言 前面我们已经搭建好了wordpress网站，如果需要查看运行效果可以看我前面的搭建文章，下面我们来进行自动化测试的练习。 ##示例 首先我们测试自动登陆 import unittest fr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huny/p/14349879.html</dc:identifier>
</item>
<item>
<title>STM32 定时器详细篇（基于HAL库） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/14351398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/14351398.html</guid>
<description>&lt;p&gt;l  16位的向上、向下、向上/向下（中心对齐）计数模式，支持自动重装载&lt;/p&gt;
&lt;p&gt;l  16位的预分频器&lt;/p&gt;
&lt;p&gt;l  每个定时器都有多个独立通道，每个通道可用于&lt;/p&gt;
&lt;p&gt;*  输入捕获&lt;/p&gt;
&lt;p&gt;*  输出比较&lt;/p&gt;
&lt;p&gt;*  PWM输出&lt;/p&gt;
&lt;p&gt;*  单脉冲模式&lt;/p&gt;
&lt;p&gt;l  高级定时器还可以产生互补输出&lt;/p&gt;
&lt;p&gt;l  可以产生中断/DMA请求：&lt;/p&gt;
&lt;p&gt;*  更新事件：计数器向上/向下溢出，计数器初始化（通过软或者内部/外部触发）&lt;/p&gt;
&lt;p&gt;*  触发事件：计数器启动，停止，初始化或者有内部/外部触发计数&lt;/p&gt;
&lt;p&gt;*  输入捕获&lt;/p&gt;
&lt;p&gt;*  输出比较&lt;/p&gt;
&lt;h2&gt;一、定时器之计数模式&lt;/h2&gt;
&lt;h3&gt;(一)  计数模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;向上计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数器从0向上计数（递增）到自动装载值，然后再次回到0开始计数，并产生一个计数溢出事件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;向下计数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数器从自动装载值向下计数（递减）到0，然后再次回到自动装载值开始计数，并产生一个计数器向下溢出事件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中央对齐模式（向上/向下计数）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数器从0开始计数到自动装载值-1，并产生一个计数器溢出事件，然后再向下计数到0+1，并产生一个计数溢出事件，然后再向上计数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002504405-1303876849.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;（二）定时器的溢出时间计算&lt;/h3&gt;
&lt;p&gt;time=(ARR+1)*(PSC+1)/Tclk&lt;/p&gt;

&lt;p&gt;ARR为自动装载值&lt;/p&gt;
&lt;p&gt;PSC:预分频系数&lt;/p&gt;
&lt;p&gt;Tclk:定时器的APB时钟，通常等于系统时钟&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;tclk为72M&lt;/p&gt;
&lt;p&gt;psc为7199&lt;/p&gt;
&lt;p&gt;arr为4999&lt;/p&gt;

&lt;p&gt;time=(4999+1)*(7199+1)/72 000 000 = 0.5s = 500ms&lt;/p&gt;
&lt;h3&gt;（三）CubeMX设置&lt;/h3&gt;
&lt;p&gt;这里需要注意的是你所需要使用的定时器是挂载在APB1还是APB2。相应的要调节他们时钟频率&lt;/p&gt;
&lt;p&gt; 选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002631184-235625640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 选择内部时钟&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002650288-177685304.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基础配置，这里配置的是1秒计数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002706933-203510769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l  Prescaler (PSC- 16 bits value)，预分频器(PSC- 16位值)&lt;/p&gt;
&lt;p&gt;l  Counter Mode，计数器模式：&lt;/p&gt;
&lt;p&gt;up 向上&lt;/p&gt;
&lt;p&gt;down 向下&lt;/p&gt;
&lt;p&gt;Center Aligned mode 中心对齐模式&lt;/p&gt;
&lt;p&gt;l  Counter Period (AutoReload Register - 16 bits value)，重装载值&lt;/p&gt;
&lt;p&gt;l  auto-reload preload，自动重装载开启&lt;/p&gt;

&lt;p&gt;开启更新中断&lt;/p&gt;
&lt;p&gt;中断优先级数字越低越高&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002725819-587992230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（四）编程记录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;中断开启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;溢出事件回调函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *&lt;span&gt;htim);

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *&lt;span&gt;htim){
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(htim-&amp;gt;Instance ==&lt;span&gt; TIM1){
         
        HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单独输出电平取反&lt;/span&gt;
&lt;span&gt;     
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启中断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HAL_TIM_Base_Start_IT(&amp;amp;htim1);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、 定时器之&lt;span lang=&quot;EN-US&quot;&gt;PWM&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;PWM即脉冲宽度调制，是一种模拟控制方式，通常用于LED的亮度调节。其实就是快速的高低电平变化让人感觉不出来。&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（一）了解一下&lt;span lang=&quot;EN-US&quot;&gt;HZ的概念&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1HZ表示1秒变化一个周期&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在家用交流点中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;50HZ表示电流每秒钟来回变化50次，方向改变100次。&lt;/p&gt;
&lt;p&gt;50HZ是50个周期，所以有50个正玄波形&lt;/p&gt;
&lt;p&gt;这个图表示的是1HZ变化，1个周期，1个正玄波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002903725-1228848985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;50HZ表示每个周期的时间=1S/50=0.02S=20ms&lt;/p&gt;

&lt;p&gt;单片机检测交流电可以200ms内没有检测到高电平，则表示无输入。&lt;/p&gt;

&lt;p&gt;在计算机cpu等使用1khz=1000hz&lt;/p&gt;
&lt;p&gt;在电磁波和机械波等，1Khz=1024hz&lt;/p&gt;

&lt;p&gt;在PWM中&lt;/p&gt;

&lt;p&gt;hz是频率的单位&lt;/p&gt;
&lt;p&gt;1hz 表示PWM的周期是一秒&lt;/p&gt;
&lt;p&gt;1Khz表示一秒钟有一千个周期，也就是周期是1ms&lt;/p&gt;
&lt;p&gt;1KKhz、1Mhz表示一秒钟有100万个周期，也就是周期是1us&lt;/p&gt;

&lt;p&gt;y秒=1/xHZ&lt;/p&gt;

&lt;p&gt;1/1000=0.001S=1ms&lt;/p&gt;
&lt;p&gt;1/1000000=0.000001S=1us&lt;/p&gt;

&lt;p&gt;如果实现周期是100us&lt;/p&gt;
&lt;p&gt;100us=0.0001S=1/0.0001= 10,000HZ&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（二）&lt;span lang=&quot;EN-US&quot;&gt;PWM配置&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131002956692-2145734596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ARR为自动装载值&lt;/p&gt;
&lt;p&gt;CCRx 为捕获比较寄存器值&lt;/p&gt;

&lt;p&gt;预分频系数决定了PWM的时钟速度&lt;/p&gt;
&lt;p&gt;ARR的大小决定了PWM的周期&lt;/p&gt;
&lt;p&gt;CRRx决定了输出有效信号的时间&lt;/p&gt;

&lt;p&gt;有效信号：&lt;/p&gt;
&lt;p&gt;高电平&lt;/p&gt;
&lt;p&gt;低电平&lt;/p&gt;

&lt;p&gt;PWM模式：&lt;/p&gt;
&lt;p&gt;模式1，不管是向上还是向下计数，当计数值小于重装载值是输出有效电平。&lt;/p&gt;
&lt;p&gt;模式2，不管是向上还是向下计数，当计数值小于重装载值是输出无效电平。&lt;/p&gt;

&lt;p&gt;PWM周期计算&lt;/p&gt;
&lt;p&gt;Fpwm = 100M / ((arr+1)*(psc+1))(单位：Hz)&lt;/p&gt;

&lt;p&gt;Fpwm = 100M / (arr+1)/(psc+1)(单位：Hz)&lt;/p&gt;

&lt;p&gt;arr 是计数值&lt;/p&gt;
&lt;p&gt;psc 是预分频值&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;3. 主频=100M&lt;/p&gt;
&lt;p&gt;4. arr=100&lt;/p&gt;
&lt;p&gt;5. psc=1000&lt;/p&gt;
&lt;p&gt;100,000,000/100/1000=1000Hz&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（三） &lt;span lang=&quot;EN-US&quot;&gt;CubeMX设置&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设置定时器使用内部时钟&lt;/p&gt;
&lt;p&gt;设置定时器的PWM通道1开启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003051383-208184928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;STM32F103C8T6对应的PWM通道为PA8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003104899-565257468.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置基础参数&lt;/p&gt;
&lt;p&gt;Prescaler,分配系数为36&lt;/p&gt;
&lt;p&gt;Counter Period,重装载值为100&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;PWM的频率为：72 000 000/35/100=20 000 HZ（20KHZ），周期为 1/20000= 0.00005秒&lt;/p&gt;
&lt;p&gt;PWM脉宽调制的最大值与重装载值一致，其范围为[0,100]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003121241-1604794747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通道可以设置的值：&lt;/p&gt;
&lt;p&gt;Mode,PWM的模式，可以选择模式1或模式2&lt;/p&gt;
&lt;p&gt;CH Polarity，有效电平，可选高或底&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（四）编程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启PWM输出&lt;/span&gt;
HAL_TIM_PWM_Start(&amp;amp;&lt;span&gt;htim1,TIM_CHANNEL_1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置默认的占空比值&lt;/span&gt;
__HAL_TIM_SET_COMPARE(&amp;amp;htim1,TIM_CHANNEL_1,&lt;span&gt;10&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while循环改变值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HAL_Delay(&lt;span&gt;30&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时30ms

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量修改&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;100&lt;/span&gt;) i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置占空比值&lt;/span&gt;
__HAL_TIM_SET_COMPARE(&amp;amp;htim1,TIM_CHANNEL_1,i);    
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;三、 定时器之输入捕获&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过检查定时器通道上的边沿信号，在边沿信号跳变（上升沿或者下降沿）的时候，将当前定时器的计数值存储到对应的捕获/比较寄存器里面，完成一次捕获。&lt;/p&gt;

&lt;p&gt;通常用于检测高电平持续时间、低电平持续时间、两次下降沿的持续时间、两次上升沿的持续时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003232064-136965833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滤波器：&lt;/p&gt;
&lt;p&gt;里可以设置以什么频率采集多少次有效电平才说明边沿触发成功，如设置的是上升沿触发，当上升沿发生时，滤波器或以fDTS的频率采集ICF设置的次数，每次检测是否是高电平，这样可以防止误触发所带来的计算干扰。&lt;/p&gt;

&lt;p&gt;边沿检测器：&lt;/p&gt;
&lt;p&gt;设置捕获的触发边沿，可以设置上升沿或下降沿&lt;/p&gt;

&lt;p&gt;通道选择&lt;/p&gt;
&lt;p&gt;通过寄存器可以设置其它通道输入的值到该通道上&lt;/p&gt;
&lt;p&gt;如通道1和通道2都可以映射到IC1,但通常是通道1是IC1,通道2是IC2,每个独立一对一映射，互不干扰。&lt;/p&gt;

&lt;p&gt;分频器：&lt;/p&gt;
&lt;p&gt;每2个事件触发一次捕获，如上升沿捕获时，连续获取到两个上升沿后才会触发计数&lt;/p&gt;
&lt;p&gt;每4个事件触发一次捕获&lt;/p&gt;
&lt;p&gt;每8个事件触发一次捕获&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（一） &lt;span lang=&quot;EN-US&quot;&gt;CubeMX设置&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;开启TIM4的通道1作为输入捕获通道，对应是PB6引脚&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003302131-642922997.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Internal Clock表示内部时钟&lt;/p&gt;
&lt;p&gt;input capture direct mode 表示输入捕获&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003316044-1676812911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据硬件连接，这里设置为上拉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003326989-861483604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启中断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003339281-1156526535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基础配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003351526-1616911677.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时钟：72 000 000 /72 = 1 000 000 HZ= 1MHZ,所以计数一次为1us&lt;/p&gt;
&lt;p&gt;最大计数值为65536，约为65ms&lt;/p&gt;
&lt;p&gt;prolarity selection 为触发计数边沿，下降沿&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（二）编程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;测量低电平的持续时间，先下降沿后上升沿，记录计数值，最终输出us单位。&lt;/p&gt;
&lt;p&gt;通用函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量存储&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; 
{   
    uint8_t   flg; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0为未开始，1已经开始，2为结束&lt;/span&gt;
    uint16_t  num;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数值&lt;/span&gt;
    uint16_t  num_period;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出次数&lt;/span&gt;
&lt;span&gt;}COUNT_TEMP;

COUNT_TEMP count_temp&lt;/span&gt;={&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获中断发送时的回调函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *&lt;span&gt;htim)
{
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断定时器2&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(TIM2 == htim-&amp;gt;&lt;span&gt;Instance){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( count_temp.flg == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
            {   
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清零定时器计数&lt;/span&gt;
                __HAL_TIM_SET_COUNTER(htim,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;); 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置上升沿触发&lt;/span&gt;
                __HAL_TIM_SET_CAPTUREPOLARITY(&amp;amp;&lt;span&gt;htim2, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_RISING);
                count_temp .flg &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置已经开始    &lt;/span&gt;
                count_temp .num_period = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出计数清零        &lt;/span&gt;
                count_temp .num = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数清零&lt;/span&gt;
&lt;span&gt;            }        
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取定时器计数值&lt;/span&gt;
                count_temp .num = HAL_TIM_ReadCapturedValue(&amp;amp;&lt;span&gt;htim2,TIM_CHANNEL_2);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置下降沿触发&lt;/span&gt;
                __HAL_TIM_SET_CAPTUREPOLARITY(&amp;amp;&lt;span&gt;htim2, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING);
                count_temp .flg &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }
}    

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器溢出回调函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *&lt;span&gt;htim)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(TIM2 == htim-&amp;gt;&lt;span&gt;Instance){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次溢出时间为65536us&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(count_temp.flg==&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获&lt;/span&gt;
&lt;span&gt;    {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count_temp.num_period==&lt;span&gt;0XFFFF&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;电平太长了&lt;/span&gt;
&lt;span&gt;                {
                    count_temp.flg&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
                    count_temp .num=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; count_temp .num_period ++&lt;span&gt;;
    }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启定时器溢出中断&lt;/span&gt;
HAL_TIM_Base_Start_IT(&amp;amp;&lt;span&gt;htim2);  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启输入捕获中断，设置下降沿触发中断&lt;/span&gt;
__HAL_TIM_SET_CAPTUREPOLARITY(&amp;amp;&lt;span&gt;htim2, TIM_CHANNEL_2, TIM_INPUTCHANNELPOLARITY_FALLING); 
HAL_TIM_IC_Start_IT(&lt;/span&gt;&amp;amp;htim2, TIM_CHANNEL_2);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动输入捕获&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待测量完毕&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(count_temp.flg == &lt;span&gt;2&lt;/span&gt;&lt;span&gt; )
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数计数值，0xFFFF为最大计数&lt;/span&gt;
    uint32_t ulTime = (uint32_t)count_temp .num_period * &lt;span&gt;0xFFFF&lt;/span&gt; +&lt;span&gt; count_temp .num;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出测量的值&lt;/span&gt;
    printf ( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;低电平时间：%d us\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ulTime); 
    count_temp .flg &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210131003506717-1507003815.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/dongxiaodong/p/14351398.html&quot;&gt;https://www.cnblogs.com/dongxiaodong/p/14351398.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;找作者：&lt;a href=&quot;https://space.bilibili.com/162091292&quot;&gt;https://space.bilibili.com/162091292&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
</description>
<pubDate>Sat, 30 Jan 2021 16:39:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>l 16位的向上、向下、向上/向下（中心对齐）计数模式，支持自动重装载 l 16位的预分频器 l 每个定时器都有多个独立通道，每个通道可用于 * 输入捕获 * 输出比较 * PWM输出 * 单脉冲模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/14351398.html</dc:identifier>
</item>
<item>
<title>学习率衰减加冲量优化的梯度下降法Python实现方案 - 陆言君</title>
<link>http://www.cnblogs.com/dechinphy/p/gradient.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/gradient.html</guid>
<description>&lt;p&gt;通过python来实现基本的梯度下降算法，及其关于衰减学习率以及冲量优化的变种梯度下降的实现和效果分析，我们发现在参数配置得当的情况下，普通的梯度下降法效率甚至比通用库中的BFGS方法实现效率更高。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;256.11925628635&quot;&gt;

&lt;p&gt;优化算法经常被使用在各种组合优化问题中。我们可以假定待优化的函数对象&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;是一个黑盒，我们可以给这个黑盒输入一些参数&lt;span class=&quot;math inline&quot;&gt;\(x_0, x_1, ...\)&lt;/span&gt;，然后这个黑盒会给我们返回其计算得到的函数值&lt;span class=&quot;math inline&quot;&gt;\(f(x_0), f(x_1), ...\)&lt;/span&gt;。我们的最终目的是得到这个黑盒函数的最优输入参数&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;，使得&lt;span class=&quot;math inline&quot;&gt;\(f(x_i)=min\{f(x)\}\)&lt;/span&gt;。那么我们就会想到，通过不断的调整输入给黑盒的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;值，直到找到满足要求的那个&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;值。&lt;/p&gt;
&lt;p&gt;我们需要明确的一个信息是，我们不可能遍历这整个的函数空间。虽然这样能够使得我们找到真正的最优解，但是遍历所带来的时间消耗是一般的项目所无法接受的，因此就需要一些更加聪明的变化方法来对黑盒进行优化。&lt;/p&gt;

&lt;p&gt;梯度下降(Gradient Descent)是最早被提出的一种简单模型，其参数迭代思路较为简单：&lt;/p&gt;
&lt;p&gt;\[x_{n+1} = x_{n} - \gamma\frac{d}{dx}f(x_n) \]&lt;/p&gt;
&lt;p&gt;或者也可以将其写成更加容易理解的差分形式：&lt;/p&gt;
&lt;p&gt;\[x_{n+1} = x_{n} - \gamma\frac{f(x_{n+1})-f(x_n)}{x_{n+1}-x_{n}} \]&lt;/p&gt;
&lt;p&gt;其中的&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;我们一般称之为学习率，在后续的博客中，会介绍一种自适应学习率的梯度优化方法。学习率会直接影响到优化收敛的速率，如果设置不当，甚至有可能导致优化结果发散。我们在优化的过程中一般采用自洽的方法，使得优化过程中满足自洽条件后直接退出优化过程，避免多余的计算量：&lt;/p&gt;
&lt;p&gt;\[\frac{d}{dx}f(x_n)=0 \]&lt;/p&gt;
&lt;p&gt;在该条件下实际上我们找到的很有可能是一个局部最优值，在&lt;code&gt;minimize&lt;/code&gt;的过程中可以认为是找到了一个极小值或者常见的&lt;code&gt;鞍点&lt;/code&gt;(如下图所示)。如果需要跳出极小值，可能需要额外的方法，如随机梯度下降和模拟退火等。&lt;/p&gt;

&lt;p&gt;实际应用中如果直接使用该梯度下降算法，会遇到众多的问题，如：在接近极小值附近时优化过程缓慢，或者由于步长的设置导致一致处于&quot;震荡&quot;的状态，这里我们引入两种梯度下降的优化方案。&lt;/p&gt;
&lt;h2 id=&quot;衰减参数的引入&quot;&gt;衰减参数的引入&lt;/h2&gt;
&lt;p&gt;由于前面提到的梯度下降算法的学习率&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;是固定的，因此在迭代优化的过程中有可能出现这几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于设置的学习率太小，导致一直出于下降优化过程，但是直到达到了最大迭代次数，也没能优化到最优值。如下图所示，正因为学习率设置的太低而导致迭代过程无法收敛。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130230033168-2028163320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;由于设置的学习率太大，导致出现&quot;震荡&quot;现象，同样无法尽快优化到收敛值。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130230522265-1902499691.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，这里我们可以引入衰减参数的概念，使得梯度下降的过程中，学习率也逐步的在衰减，越靠近收敛值跳动就越缓慢：&lt;/p&gt;
&lt;p&gt;\[x_{n+1} = x_{n} - \frac{\gamma}{n+1}\frac{f(x_{n+1})-f(x_n)}{x_{n+1}-x_{n}} \]&lt;/p&gt;
&lt;p&gt;在这种配置下，学习率参数&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;按照如下图所示的趋势进行衰减：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
x = [i for i in range(100)]
y = [1/(i + 1) for i in range(100)]
plt.figure()
plt.plot(x,y,color='black')
plt.title('Decay parameter $\gamma$')
plt.xlabel('n')
plt.ylabel('$\gamma$')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130232619669-531600464.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;冲量参数的引入&quot;&gt;冲量参数的引入&lt;/h2&gt;
&lt;p&gt;在迭代优化的过程中，靠近极小值处的优化效率也是一处难点，也正是因为配置了衰减参数，因此在优化的末尾处会尤其的缓慢(如下图所示)。为此，我们需要一些提高效率的手段。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130232932281-1317944131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;首先我们可以尝试结合一些物理定律来考虑这个问题，比如冲量定理：&lt;/p&gt;
&lt;p&gt;\[Ft=m\frac{d}{dt}x_1-m\frac{d}{dt}x_0 \]&lt;/p&gt;
&lt;p&gt;这个经典力学公式所隐藏的一个规律是：当我们给定一个&quot;迭代冲量&quot;时，本次迭代过程的偏移量&lt;span class=&quot;math inline&quot;&gt;\(\frac{d}{dt}x_1\)&lt;/span&gt;的大小跟前面一次的偏移量&lt;span class=&quot;math inline&quot;&gt;\(\frac{d}{dt}x_0\)&lt;/span&gt;是有一定的关系的。因此这里我们也添加一个&quot;冲量&quot;参数，使得如果前一次梯度前进的方向与本次前进方向相同，则多前进一些步长，而如果两者梯度方向相反，则降低步长以防止&quot;震荡&quot;现象。具体公式变动如下所示：&lt;/p&gt;
&lt;p&gt;\[x_{n+1} = x_{n} - \frac{\gamma}{n+1}\frac{f(x_{n+1})-f(x_n)}{x_{n+1}-x_{n}} + m(x_{n}-x_{n-1}) \]&lt;/p&gt;
&lt;p&gt;在给定上述的迭代策略之后，我们可以开始定义一些简单的问题，并使用该梯度下降的模型去进行优化求解。&lt;/p&gt;

&lt;p&gt;这里我们开始演示梯度下降法的使用方法，为此需要先定义一个代价函数用于黑盒优化，我们可以给定这样的一个函数：&lt;/p&gt;
&lt;p&gt;\[f(x)=5x^2+8 \]&lt;/p&gt;
&lt;p&gt;这个函数所对应的python代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt

def cost_function(x):
    return 5 * x ** 2 + 8

plt.figure()
x = [i / 100 - 5 for i in range(1000)]
y = [cost_function(i) for i in x]
plt.plot(x, y, color = 'black')
plt.title('Cost Function $y = f(x)$') # Latex Type Equation.
plt.xlabel('x')
plt.ylabel('y')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述python代码的输出中，我们可以看到该函数的轮廓结构如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130225047011-480367498.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以获取大概这些信息：函数连续可微，存在极小值且为最小值，最小值对应的输入在0附近。&lt;/p&gt;

&lt;p&gt;根据算法特性，我们将其分为了&lt;code&gt;参数定义&lt;/code&gt;、&lt;code&gt;代价函数定义&lt;/code&gt;、&lt;code&gt;梯度计算&lt;/code&gt;、&lt;code&gt;路径计算&lt;/code&gt;几个模块，最终再将其集成到&lt;code&gt;minimize&lt;/code&gt;函数中。此处我们还额外引用了&lt;code&gt;scipy.optimize.minimize&lt;/code&gt;函数作为一个对比，以及&lt;code&gt;tqdm&lt;/code&gt;可用于展示计算过程中的进度条，相关使用方法可以参考这篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/progress-bar.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from scipy.optimize import minimize as scipy_minimize
from tqdm import trange
import matplotlib.pyplot as plt
import numpy as np

DELTA = 1e-06
EPSILON = 1e-06
MAX_STEPS = 100
GAMMA = 0.6
MOMENTUM =0.2

def cost_function(x):
    return 5 * x ** 2 + 8

def gradient(x, func):
    return (func(x + DELTA) - func(x)) / DELTA

def next_x(x, func, iterations, v):
    _tmpx = x - GAMMA  * gradient(x, func) / (iterations + 1) + MOMENTUM * v
    return _tmpx if cost_function(_tmpx) &amp;lt; cost_function(x) and gradient(_tmpx, func) * gradient(x, func) &amp;gt;= 0 else x

def minimize(x0, func):
    _x1 = x0
    _y1 = func(_x1)
    plot_x = [_x1]
    plot_y = [_y1]
    v = 0
    for i in trange(MAX_STEPS):
        _x = next_x(_x1, func, i, v)
        _y = func(_x)
        v = _x - _x1
        if v == 0:
            continue
        if abs(_y - _y1) &amp;lt;= EPSILON:
            print ('The minimum value {} founded :)'.format(_y))
            print ('The correspond x value is: {}'.format(_x))
            print ('The iteration times is: {}'.format(i))
            return _y, _x, plot_y, plot_x
        _x1 = _x
        _y1 = _y
        plot_x.append(_x1)
        plot_y.append(_y1)
    print ('The last value of y is: {}'.format(_y))
    print ('The last value of x is: {}'.format(_x))
    return _y, _x, plot_y, plot_x

if __name__ == '__main__':
    x0 = 4
    yt, xt, py, px = minimize(x0, cost_function)
    plt.figure()
    x = [i / 100 - 5 for i in range(1000)]
    y = [cost_function(i) for i in x]
    plt.plot(x, y, color = 'black')
    plt.plot(px, py, 'D', color = 'red')
    print ('The function evaluation times is: {}'.format(len(py)))
    plt.plot(px, py, color = 'blue')
    plt.title('Cost Function $y = f(x)$') # Latex Type Equation.
    plt.xlabel('x')
    plt.ylabel('y')
    plt.show()
    result = scipy_minimize(cost_function, x0, method='BFGS', options={'disp':True})
    print ('The scipy method founded x is: {}'.format(result.x))
    print ('The correspond cost function value is: {}'.format(cost_function(result.x)))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简单对代码中的参数作一个解释：&lt;code&gt;DELTA&lt;/code&gt;是计算梯度值时所采用的步长，&lt;code&gt;EPSILON&lt;/code&gt;是精度要求，&lt;code&gt;MAX_STEPS&lt;/code&gt;是最大迭代次数(避免因为达不到自洽收敛条件而陷入死循环)，&lt;code&gt;GAMMA&lt;/code&gt;是学习率(在其他的一些基于梯度的算法中可能会采用自适应的学习率或者逐步下降的学习率来达到更好的收敛效果)。该简单案例得到的结果如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;The last value of y is: 8.00000000000125
The last value of x is: -5.000249774511634e-07
The function evaluation times is: 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130225220959-1800259672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Optimization terminated successfully.
         Current function value: 8.000000
         Iterations: 3
         Function evaluations: 8
         Gradient evaluations: 4
The scipy method founded x is: [-9.56720569e-09]
The correspond cost function value is: [8.]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到，自定义的函数迭代次数&lt;code&gt;4&lt;/code&gt;次要小于通用库中所实现的&lt;code&gt;8&lt;/code&gt;次函数估计。这里由于名称的定义有可能导致迭代次数和函数估计次数被混淆，一般基于梯度的算法是多次函数估计后才会迭代一次，而有些非梯度的优化算法如&lt;code&gt;COBYLA&lt;/code&gt;等，则是每计算一次代价函数就代表迭代一次，这里我们能够简单从数量上理解即可。&lt;/p&gt;

&lt;p&gt;在上面二次函数的优化成功之后，我们可以尝试一些其他形式的函数的优化效果，如本次使用的正弦函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from scipy.optimize import minimize as scipy_minimize
from tqdm import trange
import matplotlib.pyplot as plt
import numpy as np

DELTA = 1e-06
EPSILON = 1e-06
MAX_STEPS = 100
GAMMA = 2
MOMENTUM =0.9

def cost_function(x):
    return np.sin(x)

def gradient(x, func):
    return (func(x + DELTA) - func(x)) / DELTA

def next_x(x, func, iterations, v):
    _tmpx = x - GAMMA  * gradient(x, func) / (iterations + 1) + MOMENTUM * v
    return _tmpx if cost_function(_tmpx) &amp;lt; cost_function(x) and gradient(_tmpx, func) * gradient(x, func) &amp;gt;= 0 else x

def minimize(x0, func):
    _x1 = x0
    _y1 = func(_x1)
    plot_x = [_x1]
    plot_y = [_y1]
    v = 0
    for i in trange(MAX_STEPS):
        _x = next_x(_x1, func, i, v)
        _y = func(_x)
        v = _x - _x1
        if v == 0:
            continue
        if abs(_y - _y1) &amp;lt;= EPSILON:
            print ('The minimum value {} founded :)'.format(_y))
            print ('The correspond x value is: {}'.format(_x))
            print ('The iteration times is: {}'.format(i))
            return _y, _x, plot_y, plot_x
        _x1 = _x
        _y1 = _y
        plot_x.append(_x1)
        plot_y.append(_y1)
    print ('The last value of y is: {}'.format(_y))
    print ('The last value of x is: {}'.format(_x))
    return _y, _x, plot_y, plot_x

if __name__ == '__main__':
    x0 = 1.4
    yt, xt, py, px = minimize(x0, cost_function)
    plt.figure()
    x = [i / 100 - 5 for i in range(1000)]
    y = [cost_function(i) for i in x]
    plt.plot(x, y, color = 'black')
    plt.plot(px, py, 'D', color = 'red')
    print ('The function evaluation times is: {}'.format(len(py)))
    plt.plot(px, py, color = 'blue')
    plt.title('Cost Function $y = f(x)$') # Latex Type Equation.
    plt.xlabel('x')
    plt.ylabel('y')
    plt.show()
    result = scipy_minimize(cost_function, x0, method='BFGS', options={'disp':True})
    print ('The scipy method founded x is: {}'.format(result.x))
    print ('The correspond cost function value is: {}'.format(cost_function(result.x)))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其执行效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;The minimum value -0.9999986210818882 founded :)
The correspond x value is: -1.569135653179335
The iteration times is: 14
The function evaluation times is: 11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202101/2277440-20210130234810738-280789502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Optimization terminated successfully.
         Current function value: -1.000000
         Iterations: 2
         Function evaluations: 16
         Gradient evaluations: 8
The scipy method founded x is: [-1.57079993]
The correspond cost function value is: [-1.]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该测试案例中，通过合理的参数配置，我们同样可以找到比标准库数量更少的迭代次数。其实在大部分的黑盒优化的情况下，我们并不能事先就计算好函数对应的轮廓，也无从获取相关信息，甚至函数运算本身也是一个复杂性较高的计算工作。因此，对于迭代次数或者函数值估计的次数的优化，也是一个值得研究的方向。&lt;/p&gt;

&lt;p&gt;梯度下降法是众多优化算法的基础形式，而一众优化算法在机器学习、神经网络训练以及变分量子算法实现的过程中都发挥着巨大的作用。通过了解基本的梯度下降函数的实现原理，可以为我们带来一些优化的思路，后续也会补充一些梯度下降函数的变种形式。可能有读者注意到，本文中的实际的函数值估计次数要大于结果中所展现的函数值估计次数。这个观点是对的，但是这里我们可以通过后续会单独讲解的&lt;code&gt;lru缓存&lt;/code&gt;法来进行处理，这使得同样的参数输入下对于一个函数的访问可以几乎不需要时间，因此对于一个函数值的估计次数，其实仅跟最后得到的&lt;code&gt;不同函数值的数量&lt;/code&gt;有关，中间存在大量的简并。&lt;/p&gt;

&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/gradient.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/gradient.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 30 Jan 2021 16:00:00 +0000</pubDate>
<dc:creator>陆言君</dc:creator>
<og:description>通过python来实现基本的梯度下降算法，及其关于衰减学习率以及冲量优化的变种梯度下降的实现和效果分析，我们发现在参数配置得当的情况下，普通的梯度下降法效率甚至比通用库中的BFGS方法实现效率更高。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/gradient.html</dc:identifier>
</item>
<item>
<title>Okio源码分析 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/14323085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/14323085.html</guid>
<description>&lt;p&gt;Okio 作为 Okhttp 底层 io 库，它补充了 java.io 和 java.nio 的不足，使访问、存储和处理数据更加容易。Okio 的特点如下：&lt;/p&gt;
&lt;div&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;okio 是一个由 square 公司开发的开源库，它弥补了 Java.io 和 java.nio 的不足，能够更方便快速的读取、存储和处理数据。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;okio 有自己的流类型 Source 和 Sink，对应于 java.io 的 InputStream 和 OutputStream。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;okio 内部引入了 ByteString 和 Buffer，提升了效率和性能。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;okio 引入了超时机制。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;okio 规模不大，代码精巧，是源码学习的好素材&lt;/span&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div readability=&quot;24&quot;&gt;

&lt;p&gt;是指在计算机的输入输出操作中各部件之间的数据流动。按照数据的传输方向，流可分为输入流与输出流。Java语言里的流序列中的数据既可以是未经加工的原始二进制数据，也可以是经过一定编码处理后符合某种特定格式的数据。&lt;/p&gt;
&lt;h3&gt;1．输入输出流&lt;/h3&gt;
&lt;p&gt;在Java中，把不同类型的输入输出源抽象为流，其中输入和输出的数据称为数据流（Data Stream）。数据流是Java程序发送和接收数据的一个通道，数据流中包括输入流（Input Stream）和输出流（Output Stream）。通常应用程序中使用输入流读出数据，输出流写入数据。 流式输入、输出的特点是数据的获取和发送均沿数据序列顺序进行。相对于程序来说，输出流是往存储介质或数据通道写入数据，而输入流是从存储介质或数据通道中读取数据，一般来说关于流的特性有下面几点：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;先进先出，最先写入输出流的数据最先被输入流读取到。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;顺序存取，可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;只读或只写，每个流只能是输入流或输出流的一种，不能同时具备两个功能，在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2．缓冲流&lt;/h3&gt;
&lt;p&gt;为了提高数据的传输效率，引入了缓冲流（Buffered Stream）的概念，即为一个流配备一个缓冲区（Buffer），一个缓冲区就是专门用于传送数据的一块内存。&lt;/p&gt;
&lt;p&gt;当向一个缓冲流写入数据时，系统将数据发送到缓冲区，而不是直接发送到外部设备。缓冲区自动记录数据，当缓冲区满时，系统将数据全部发送到相应的外部设备。当从一个缓冲流中读取数据时，系统实际是从缓冲区中读取数据，当缓冲区为空时，系统就会从相关外部设备自动读取数据，并读取尽可能多的数据填满缓冲区。 使用数据流来处理输入输出的目的是使程序的输入输出操作独立于相关设备，由于程序不需关注具体设备实现的细节（具体细节由系统处理），所以对于各种输入输出设备，只要针对流做处理即可，不需修改源程序，从而增强了程序的可移植性。&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;10.5&quot;&gt;
&lt;h3&gt;&lt;strong&gt;ByteStrings and Buffers&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;Okio 是围绕这两种类型构建的，它们将大量功能打包到一个简单的 API 中：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;ByteString &lt;/code&gt;是不可变的字节序列。&lt;/strong&gt;对于字符数据，最基本的就是 &lt;code&gt;String&lt;/code&gt;。而 &lt;code&gt;ByteString &lt;/code&gt;就像是 &lt;code&gt;String &lt;/code&gt;的兄弟一般，它使得将二进制数据作为一个变量值变得容易。这个类很聪明：它知道如何将自己编码和解码为十六进制、base64 和 utf-8。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;Buffer &lt;/code&gt;是一个可变的字节序列。&lt;/strong&gt;像 Arraylist 一样，你不需要预先设置缓冲区的大小。你可以将缓冲区读写为一个队列：将数据写到队尾，然后从队头读取。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在内部，&lt;code&gt;ByteString&lt;/code&gt;和&lt;code&gt;Buffer&lt;/code&gt;做了一些聪明的事情来节省CPU和内存。如果您将UTF-8字符串编码为&lt;code&gt;ByteString&lt;/code&gt;，它会缓存对该字符串的引用，这样，如果您稍后对其进行解码，就不需要做任何工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Buffer &lt;/code&gt;是作为片段的链表实现的。当您将数据从一个缓冲区移动到另一个缓冲区时，它会重新分配片段的持有关系，而不是跨片段复制数据。这对多线程特别有用：与网络交互的子线程可以与工作线程交换数据，而无需任何复制或多余的操作。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;h3&gt;&lt;span&gt;Sources and Sinks&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;java.io &lt;/code&gt;设计的一个优雅部分是如何对流进行分层来处理加密和压缩等转换。Okio 有自己的 stream 类型: &lt;code&gt;Source &lt;/code&gt;和 &lt;code&gt;Sink&lt;/code&gt;，分别类似于 java 的 &lt;code&gt;Inputstream &lt;/code&gt;和&lt;code&gt;Outputstream&lt;/code&gt;，但是有一些关键区别：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;超时(Timeouts)。流提供了对底层 I/O 超时机制的访问。与&lt;code&gt;java.io &lt;/code&gt;的 socket 字流不同，&lt;code&gt;read() &lt;/code&gt;和 &lt;code&gt;write() &lt;/code&gt;方法都给予超时机制。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;易于实施。&lt;code&gt;source &lt;/code&gt;只声明了三个方法：&lt;code&gt;read()&lt;/code&gt;、&lt;code&gt;close() &lt;/code&gt;和 &lt;code&gt;timeout()&lt;/code&gt;。没有像&lt;code&gt;available()&lt;/code&gt;或单字节读取这样会导致正确性和性能意外的危险操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;使用方便。虽然 &lt;code&gt;source &lt;/code&gt;和 &lt;code&gt;sink &lt;/code&gt;的实现只有三种方法可写，但是调用方可以实现 &lt;code&gt;Bufferedsource &lt;/code&gt;和 &lt;code&gt;Bufferedsink &lt;/code&gt;接口, 这两个接口提供了丰富API能够满足你所需的一切。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;字节流和字符流之间没有人为的区别。都是数据。你可以以字节、UTF-8 字符串、big-endian 的32位整数、little-endian 的短整数等任何你想要的形式进行读写；不再有&lt;code&gt;InputStreamReader&lt;/code&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;易于测试。&lt;code&gt;Buffer &lt;/code&gt;类同时实现了 &lt;code&gt;BufferedSource &lt;/code&gt;和 &lt;code&gt;BufferedSink &lt;/code&gt;接口，即是 source 也是 sink，因此测试代码简单明了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Sources 和 Sinks 分别与 &lt;code&gt;InputStream&lt;/code&gt; 和 &lt;code&gt;OutputStream &lt;/code&gt;交互操作。你可以将任何 &lt;code&gt;Source &lt;/code&gt;看做 &lt;code&gt;InputStream&lt;/code&gt; ，也可以将任何 &lt;code&gt;InputStream&lt;/code&gt; 当做 &lt;code&gt;Source&lt;/code&gt;。对于 &lt;code&gt;Sink &lt;/code&gt;和 &lt;code&gt;Outputstream &lt;/code&gt;也是如此。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;h3&gt;&lt;code&gt;Segment&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;Segment在 Okio 中作为数据缓冲的载体，一个 Segment 的数据缓冲大小为 8192，即 8k。每一个 Segment 都有前驱和后继结点，也就是说 Sement 是一个双向链表链表,准确的来说是一个双向循环链表。读取数据从 Segment 头结点读取，写数据从 Segment 尾结点写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Okio 中引入池的概念也就是源码中SegmentPool的实现。SegmentPool 负责 Segment 创建和销毁，SegmentPool 最大可以缓存 8 个 Segment。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SegmentPool 是一个静态方法，因此也就是全局缓存只有 64 kb；&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;前面说了介绍了很多关键的类，下面看下 Okio 的整体设计：&lt;/p&gt;


&lt;p&gt;通过类图来看，整体设计是很简单明了的，可以结合前面介绍的关键类，这样你会更加理解这个设计图。&lt;/p&gt;

&lt;p&gt;在介绍 Okio 的读写流程的时候，还是得提一下一个关键的类：Okio。&lt;/p&gt;
&lt;p&gt;Okio 类是工具类，内部提供了很多静态方法，方便大家调用，减少大家写了很多重复的代码，使得整个调用变得更加简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210130131924001-491252586.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;397&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;读文本文件&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readLines(File file) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
      Source fileSource &lt;/span&gt;=&lt;span&gt; Okio.source(file);
      BufferedSource bufferedSource &lt;/span&gt;=&lt;span&gt; Okio.buffer(fileSource);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String line; (line = bufferedSource.readUtf8Line()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; ) {
          System.out.println(line);
      }
      bufferedSource.close();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个示例代码是用来读取文本文件的，Okio 通过 &lt;code&gt;Okio.source(File)&lt;/code&gt; 的方式来读取文件流，它返回的是一个 Source 对象，但是 Source 对象的方法是比较少的（只有3个），因此 Okio 提供了一个装饰者对象接口 &lt;code&gt;BufferedSource&lt;/code&gt;，通过 &lt;code&gt;Okio.buffer(fileSource) &lt;/code&gt;来生成，这个方法内部实际会生成一个 &lt;code&gt;RealBufferedSource &lt;/code&gt;类对象，&lt;code&gt;RealBufferedSource &lt;/code&gt;内部持有Buffer缓冲对象可使 IO 速度更快，该类实现了&lt;code&gt;BufferedSource&lt;/code&gt;接口，而 &lt;code&gt;BufferedSource &lt;/code&gt;接口提供了大量丰富的接口方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210130132752372-426124881.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;549&quot; loading=&quot;lazy&quot;/&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210130132846904-1743506876.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;548&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，几乎你想从输入流中读取任何的数据类型都可以，而不需要你自己去转换，可以说是非常强大而且人性化了，除了 read 方法以外，还有一些别的方法，可以说几乎可以满足很多需求。&lt;/p&gt;
&lt;p&gt;在上面的示例代码中，打开输入流对象的方法需要负责关闭对象资源，调用 close 方法，Okio 官方推荐使用 java 的 &lt;code&gt;try-with-source &lt;/code&gt;语法，上面示例代码可以写成下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readLines(File file) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (BufferedSource bufferedSource =&lt;span&gt; Okio.buffer(Okio.source(file))) {
           &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String line; (line = bufferedSource.readUtf8Line()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; ) {
              System.out.println(line);
           }
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;try-with-source &lt;/code&gt;是 jdk1.4 开始提供的语法糖，在 &lt;code&gt;try &lt;/code&gt;语句 () 里面的资源对象，jdk 最终会自动调用它的 &lt;code&gt;close &lt;/code&gt;方法去关闭它, 即便 &lt;code&gt;try &lt;/code&gt;里有多个资源对象也是可以的，这样就不用你手动去关闭资源了。但是在 android 里面使用的话，会提示你要求 API level 最低为 &lt;code&gt;19 &lt;/code&gt;才可以。&lt;/span&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;写文本文件&lt;/span&gt; &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeEnv(File file) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (BufferedSink sink =&lt;span&gt; Okio.buffer(Okio.sink(file))) {
       sink.writeUtf8(&lt;/span&gt;&quot;啊啊啊&quot;&lt;span&gt;)
             .writeUtf8(&lt;/span&gt;&quot;=&quot;&lt;span&gt;)
          .writeUtf8(&lt;/span&gt;&quot;aaa&quot;&lt;span&gt;)
          .writeUtf8(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;Okio.buffer(fileSink) &lt;/code&gt;内部返回的实现对象是一个 &lt;code&gt;RealBufferedSink &lt;/code&gt;类的对象， 跟 &lt;code&gt;RealBufferedSource&lt;/code&gt;一 样它也是一个装饰者对象，具备 &lt;code&gt;Buffer &lt;/code&gt;缓冲功能。&lt;/p&gt;
&lt;p&gt;类似于读文件使用 &lt;code&gt;Source &lt;/code&gt;和 &lt;code&gt;BufferedSource&lt;/code&gt;， 写文件的话，则是使用的 &lt;code&gt;Sink&lt;/code&gt; 和 &lt;code&gt;BufferedSink&lt;/code&gt;，同样的在 &lt;code&gt;BufferedSink &lt;/code&gt;接口中也提供了丰富的接口方法，这里就不展开了，具体可以查看代码。&lt;/p&gt;
&lt;p&gt;此处再次强烈建议去阅读官方文档：&lt;a href=&quot;https://square.github.io/okio/&quot;&gt;https://square.github.io/okio/&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;通过上面的介绍，大家对 Okio 的读取有了一个基本的了解。下面开始进入源码分析，深入去研究其实现，再介绍源码的时候，会先对一些接口做一些简单的介绍。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Source &amp;amp; Sink&lt;/span&gt; &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Sink &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Closeable, Flushable {
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Removes {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; byteCount} bytes from {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; source} and appends them to this. &lt;/span&gt;&lt;span&gt;*/  从 source 中获取到的数据添加到 sink 自身&lt;/span&gt;
  &lt;span&gt;void&lt;/span&gt; write(Buffer source, &lt;span&gt;long&lt;/span&gt; byteCount) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Pushes all buffered bytes to their final destination. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Override &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; flush() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Returns the timeout for this sink. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Timeout timeout();

  @Override &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; close() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Source &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Closeable {
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Removes at least 1, and up to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; byteCount} bytes from this and appends
   * them to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; sink}. Returns the number of bytes read, or -1 if this
   * source is exhausted.  将自身数据给 sink 
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;long&lt;/span&gt; read(Buffer sink, &lt;span&gt;long&lt;/span&gt; byteCount) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Returns the timeout for this source. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Timeout timeout();

   &lt;/span&gt;*/&lt;span&gt;
  @Override &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; close() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两个是 Okio 中最基本的两个接口，分别对应 java 的 &lt;code&gt;InputStream &lt;/code&gt;和 &lt;code&gt;OutputStream &lt;/code&gt;即输入流和输出流，Source 是输入流，Sink 是输出流。接口提供的方法也是非常简单，大家一看就知道这几个方法的目的。&lt;/p&gt;
&lt;h2&gt;BufferedSink &amp;amp; BufferedSource&lt;/h2&gt;
&lt;p&gt;上面 Source和 Sink 提供了极简的接口，接着作者对这两个接口进行丰富的扩展。具体接口方法上文已介绍，这里也不在展开。&lt;/p&gt;
&lt;p&gt;这里简单提一点，这种设计风格是值得我们去学习的，设计接口的时候要简单，专一。然后可以再新建一个接口，去丰富扩展其功能。这样使用者可以选择自己想要的接口来进行实现。&lt;/p&gt;
&lt;h2&gt;RealBufferedSource &amp;amp; RealBufferedSink&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在我们通过 &lt;code&gt;Okio.source() &lt;/code&gt;和 &lt;code&gt;Okio.sink() &lt;/code&gt;获取了 Souce 和 Sink 对象后，一般不会直接使用，而是会再调用一次 &lt;code&gt;Okio.buffer() &lt;/code&gt;生成一个实现 &lt;code&gt;BufferedSource &lt;/code&gt;和 &lt;code&gt;BufferedSink &lt;/code&gt;接口的对象：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Returns a new source that buffers reads from {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; source}. The returned
   * source will perform bulk reads into its in-memory buffer. Use this wherever
   * you read a source to get an ergonomic and efficient access to data.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BufferedSource buffer(Source source) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealBufferedSource(source);
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Returns a new sink that buffers writes to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; sink}. The returned sink
   * will batch writes to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; sink}. Use this wherever you write to a sink to
   * get an ergonomic and efficient access to data.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BufferedSink buffer(Sink sink) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealBufferedSink(sink);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;内部分别返回的是 &lt;code&gt;RealBufferedSource &lt;/code&gt;和 &lt;code&gt;RealBufferedSink &lt;/code&gt;对象，他们分别实现了 &lt;code&gt;BufferedSource &lt;/code&gt;和&lt;code&gt;BufferedSink&lt;/code&gt;接口，而这两个接口则是分别继承了 &lt;code&gt;Source &lt;/code&gt;和 &lt;code&gt;Sink &lt;/code&gt;接口的并基础上进行了方法扩展，提供了丰富的读写接口方法，几乎可以对各种基础数据类型进行读写。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;141&quot;&gt;
&lt;h2&gt;Segment 及 SegmentPool &lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Segment &lt;/code&gt;是 &lt;code&gt;Okio &lt;/code&gt;中非常重要的一环，它可以说是 &lt;code&gt;Buffer &lt;/code&gt;中数据的载体。容量是 8kb，头结点为 head。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Segment {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Segment的容量，最大为8kb&lt;/span&gt;
  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIZE = 8192&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Segment中字节数 &amp;gt; SHARE_MINIMUM时（大Segment），就可以共享，不能添加到SegmentPool&lt;/span&gt;
  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARE_MINIMUM = 1024&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储的数据&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一次读取的开始位置&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos;

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入的开始位置&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; limit;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前Segment是否可以共享&lt;/span&gt;
  &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shared;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;data是否仅当前Segment独有，不share&lt;/span&gt;
  &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; owner;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继节点&lt;/span&gt;
&lt;span&gt;  Segment next;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点&lt;/span&gt;
&lt;span&gt;  Segment prev;

  ...

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除当前Segment&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; @Nullable Segment pop() {
    Segment result &lt;/span&gt;= next != &lt;span&gt;this&lt;/span&gt; ? next : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    prev.next &lt;/span&gt;=&lt;span&gt; next;
    next.prev &lt;/span&gt;=&lt;span&gt; prev;
    next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在当前节点后添加一个新的节点&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Segment push(Segment segment) {
    segment.prev &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    segment.next &lt;/span&gt;=&lt;span&gt; next;
    next.prev &lt;/span&gt;=&lt;span&gt; segment;
    next &lt;/span&gt;=&lt;span&gt; segment;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; segment;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前Segment分裂成2个Segment结点。前面结点pos~limit数据范围是[pos..pos+byteCount)，后面结点pos~limit数据范围是[pos+byteCount..limit)&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Segment split(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; byteCount) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (byteCount &amp;lt;= 0 || byteCount &amp;gt; limit - pos) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    Segment prefix;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果字节数大于SHARE_MINIMUM则拆分成共享节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (byteCount &amp;gt;=&lt;span&gt; SHARE_MINIMUM) {
      prefix &lt;/span&gt;=&lt;span&gt; sharedCopy();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      prefix &lt;/span&gt;=&lt;span&gt; SegmentPool.take();
      System.arraycopy(data, pos, prefix.data, &lt;/span&gt;0&lt;span&gt;, byteCount);
    }

    prefix.limit &lt;/span&gt;= prefix.pos +&lt;span&gt; byteCount;
    pos &lt;/span&gt;+=&lt;span&gt; byteCount;
    prev.push(prefix);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prefix;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前Segment结点和prev前驱结点合并成一个Segment，统一合并到prev，然后当前Segment结点从双向链表移除并添加到SegmentPool复用。当然合并的前提是：2个Segment的字节总和不超过8K。合并后可能会移动pos、limit&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; compact() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;this&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!prev.owner) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot compact: prev isn't writable.&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; byteCount = limit -&lt;span&gt; pos;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; availableByteCount = SIZE - prev.limit + (prev.shared ? 0&lt;span&gt; : prev.pos);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (byteCount &amp;gt; availableByteCount) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot compact: not enough writable space.&lt;/span&gt;
&lt;span&gt;    writeTo(prev, byteCount);
    pop();
    SegmentPool.recycle(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从当前节点移动byteCount个字节到sink中&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeTo(Segment sink, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; byteCount) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!sink.owner) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sink.limit + byteCount &amp;gt;&lt;span&gt; SIZE) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We can't fit byteCount bytes at the sink's current position. Shift sink first.&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (sink.shared) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sink.limit + byteCount - sink.pos &amp;gt; SIZE) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
      System.arraycopy(sink.data, sink.pos, sink.data, &lt;/span&gt;0, sink.limit -&lt;span&gt; sink.pos);
      sink.limit &lt;/span&gt;-=&lt;span&gt; sink.pos;
      sink.pos &lt;/span&gt;= 0&lt;span&gt;;
    }

    System.arraycopy(data, pos, sink.data, sink.limit, byteCount);
    sink.limit &lt;/span&gt;+=&lt;span&gt; byteCount;
    pos &lt;/span&gt;+=&lt;span&gt; byteCount;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SegmentPool &lt;/code&gt;是一个 &lt;code&gt;Segment &lt;/code&gt;池，内部维护了一个 &lt;code&gt;Segment &lt;/code&gt;单向链表，容量为64kb（8 个 &lt;code&gt;Segment&lt;/code&gt;），回收不用的 &lt;code&gt;Segment &lt;/code&gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SegmentPool {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SegmentPool的最大容量&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; MAX_SIZE = 64 * 1024; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 64 KiB.

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继节点&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Segment next;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前池内的总字节数&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; byteCount;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SegmentPool() {
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从池中获取一个Segment对象&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Segment take() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (SegmentPool.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                Segment result &lt;/span&gt;=&lt;span&gt; next;
                next &lt;/span&gt;=&lt;span&gt; result.next;
                result.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                byteCount &lt;/span&gt;-=&lt;span&gt; Segment.SIZE;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Segment(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pool is empty. Don't zero-fill while holding a lock.&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Segment状态初始化并放入池中&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recycle(Segment segment) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (segment.next != &lt;span&gt;null&lt;/span&gt; || segment.prev != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (segment.shared) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This segment cannot be recycled.&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; (SegmentPool.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (byteCount + Segment.SIZE &amp;gt; MAX_SIZE) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pool is full.&lt;/span&gt;
            byteCount +=&lt;span&gt; Segment.SIZE;
            segment.next &lt;/span&gt;=&lt;span&gt; next;
            segment.pos &lt;/span&gt;= segment.limit = 0&lt;span&gt;;
            next &lt;/span&gt;=&lt;span&gt; segment;
        }
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;SegmentPool &lt;/code&gt;可以理解为一个缓存Segment的池，它只有两个方法，一个 &lt;code&gt;take()&lt;/code&gt;，一个 &lt;code&gt;recycle()&lt;/code&gt;，在 &lt;code&gt;SegmentPool &lt;/code&gt;中维护的是一个 &lt;code&gt;Segment&lt;/code&gt; 的单链表，并且它的最大值为 &lt;code&gt;MAX_SIZE = 64 * 1024 &lt;/code&gt;也就是 &lt;code&gt;64kb &lt;/code&gt;即 8 个 Segment 的长度，&lt;code&gt;next &lt;/code&gt;就是单链表中的头结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;take() &lt;/code&gt;方法的作用是取出单链表的头结点 Segment 对象，然后将取出的对象与链表断开并将链表往后移动一个单位，如果是第一次调用 take, next 为 null, 则会直接 new 一个 Segment 对象返回，并且这里创建的Segment是不共享的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;recycle() &lt;/code&gt;方法的作用则是回收一个 Segment 对象，被回收的 Segment 对象将会被插入到 &lt;code&gt;SegmentPool &lt;/code&gt;中的单链表的头部，以便后面继续复用，并且这里源码我们也可以看到如果是 &lt;code&gt;shared &lt;/code&gt;的对象是不处理的，如果是第一次调用 &lt;code&gt;recycle() &lt;/code&gt;方法则链表会由空变为拥有一个节点的链表， 每次回收就会插入一个到表头，直到超过最大容量。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Buffer&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你只看 &lt;code&gt;Segment &lt;/code&gt;的话还是很难理解整个数据的读写流程，因为你只知道它是能够形成一个链表的东西，但是当你看完 &lt;code&gt;Buffer &lt;/code&gt;之后完整的流程就会清晰多了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Buffer &lt;/code&gt;类是 Okio 中最核心并且最丰富的类了，前面分析发现最终的 Source 和 Sink 实现对象中，都是通过该类完成读写操作，而 Buffer 类同时实现了 &lt;code&gt;BufferedSource &lt;/code&gt;和 &lt;code&gt;BufferedSink &lt;/code&gt;接口，因此 &lt;code&gt;Buffer &lt;/code&gt;具备 Okio 中的读和写的所有方法，所以这个类的方法超多！我们只找一个读和写的方法来看一下实现好了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;写&lt;code&gt;byte[]&lt;/code&gt;操作：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Buffer write(&lt;span&gt;byte&lt;/span&gt;[] source, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; byteCount) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;source == null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测参数的合法性&lt;/span&gt;
&lt;span&gt;        checkOffsetAndCount(source.length, offset, byteCount);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算 source 要写入的最后一个字节的 index 值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; limit = offset +&lt;span&gt; byteCount;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (offset &amp;lt;&lt;span&gt; limit) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取循环链表尾部的一个 Segment&lt;/span&gt;
            Segment tail = writableSegment(1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算最多可写入的字节&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; toCopy = Math.min(limit - offset, Segment.SIZE -&lt;span&gt; tail.limit);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把 source 复制到 data 中&lt;/span&gt;
&lt;span&gt;            System.arraycopy(source, offset, tail.data, tail.limit, toCopy);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整写入的起始位置&lt;/span&gt;
            offset +=&lt;span&gt; toCopy;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整尾部Segment 的 limit 位置&lt;/span&gt;
            tail.limit +=&lt;span&gt; toCopy;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整 Buffer 的 size 大小&lt;/span&gt;
        size +=&lt;span&gt; byteCount;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;写操作内部是调用 &lt;code&gt;System.arraycopy &lt;/code&gt;进行字节数组的复制，这里是写到 tail 对象，也就是循环链表的链尾 &lt;code&gt;Segment &lt;/code&gt;对象当中，而且这里会不断循环的获取链尾 &lt;code&gt;Segment &lt;/code&gt;对象进行写入。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;看一下获取链尾的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Returns a tail segment that we can write at least {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; minimumCapacity}
   * bytes to, creating it if necessary.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Segment writableSegment(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minimumCapacity) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (minimumCapacity &amp;lt; 1 || minimumCapacity &amp;gt; Segment.SIZE) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果链表的头指针为null，就会SegmentPool中取出一个&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      head &lt;/span&gt;= SegmentPool.take(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Acquire a first segment.&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; head.next = head.prev =&lt;span&gt; head;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取前驱结点，也就是尾部结点&lt;/span&gt;
    Segment tail =&lt;span&gt; head.prev;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果能写的字节数限制超过了8192，或者不是拥有者&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (tail.limit + minimumCapacity &amp;gt; Segment.SIZE || !&lt;span&gt;tail.owner) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从SegmentPool中获取一个Segment，插入到循环双链表当前结点的后面&lt;/span&gt;
      tail = tail.push(SegmentPool.take()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Append a new empty segment to fill up.&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tail;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个 &lt;code&gt;head &lt;/code&gt;对象，就是 Segment 链表的头结点的引用，这个方法中可以看到如果写的时候头结点&lt;code&gt;head&lt;/code&gt;为空，则会调用 &lt;code&gt;SegmentPool.take()&lt;/code&gt; 方法从Segment池中获取一个 Segment缓存对象，并以此形成一个双向链表的初始节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      head &lt;/span&gt;= SegmentPool.take(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Acquire a first segment.&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; head.next = head.prev =&lt;span&gt; head;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时Segment中会形成下面这样的初始链表：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041611051010.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; width=&quot;602&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时头结点和尾节点其实是同一个节点，然后取得 &lt;code&gt;head.prev &lt;/code&gt;也就是 tail 尾节点返回，但是如果此时 tail 能写的字节数限制超过了 8k 或者尾节点不是 data 的拥有者，就会调用&lt;code&gt;tail.push(SegmentPool.take()); &lt;/code&gt;也就是再调用一次 &lt;code&gt;SegmentPool.take() &lt;/code&gt;取到 Segment 池中下一个 Segment. 通过 &lt;code&gt;tail. push()&lt;/code&gt; 方法插入到循环链表的尾部。这时 Segment 中的链表会变成下面这样：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190416110116405.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; width=&quot;636&quot; height=&quot;330&quot;/&gt;&lt;br/&gt;&lt;span&gt;此时插入的节点会作为新的tail节点返回，下一次获取尾节点的时候就会取到它，每当 tail 进行 push 一次，就会将新 push 的节点作为新的尾节点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190416102501183.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; width=&quot;718&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;读&lt;code&gt;byte[]&lt;/code&gt;操作：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Override 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; read(&lt;span&gt;byte&lt;/span&gt;[] sink, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; byteCount) {
    checkOffsetAndCount(sink.length, offset, byteCount);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到Segment循环链表的表头&lt;/span&gt;
    Segment s =&lt;span&gt; head;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算最多可写入的字节&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; toCopy = Math.min(byteCount, s.limit -&lt;span&gt; s.pos);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据拷贝到链头的data字节数组当中&lt;/span&gt;
&lt;span&gt;    System.arraycopy(s.data, s.pos, sink, offset, toCopy);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整链头的data数组的起始postion和Buffer的size&lt;/span&gt;
    s.pos +=&lt;span&gt; toCopy;
    size &lt;/span&gt;-=&lt;span&gt; toCopy;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pos等于limit的时候，从循环链表中移除该Segment并从SegmentPool中回收复用&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s.pos ==&lt;span&gt; s.limit) {
      head &lt;/span&gt;= s.pop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除的同时返回下一个Segment作为表头&lt;/span&gt;
&lt;span&gt;      SegmentPool.recycle(s);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toCopy;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;读操作内部也是调用 &lt;code&gt;System.arraycopy &lt;/code&gt;进行字节数组的复制，这里是直接对 head 头结点进行读取，也就是说 Buffer 在每次读数据的时候都是从链表的头部进行读取的，如果读取的头结点的 pos 等于 limit, 这里就会调用 &lt;code&gt;s.pop() &lt;/code&gt;将头节点从链表中删除，并返回下一个节点作为新的头结点引用，然后将删除的节点通过 &lt;code&gt;SegmentPool.recycle(s) &lt;/code&gt;进行回收复用。这时链表中的变化如下：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190416105230643.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; width=&quot;585&quot; height=&quot;405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是读写字节数据的过程，读取其它数据类型如 int、long、String，过程类似，所以简单的概括 Buffer 中读的过程就是不断取头结点的过程，而写的过程就是不断取尾节点的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Buffer &lt;/code&gt;除了读写基础数据以外，还有一个比较重要的功能就是 &lt;code&gt;Buffer &lt;/code&gt;之间的数据交换, 还记得在官方对 Buffer 的介绍中写到的：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;当您将数据从一个缓冲区移动到另一个缓冲区时，它会重新分配片段的持有关系，而不是跨片段复制数据。这对多线程特别有用：与网络交互的子线程可以与工作线程交换数据，而无需任何复制或多余的操作。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里说在 Buffer 缓冲区之间移动数据的时候，是重新分配片段也就是 Segment 的持有关系，而不是跨片段的复制数据，那么它说的这个比较牛逼的过程是如何实现的呢, 来看一下实现的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(Buffer source, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; byteCount) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Move bytes from the head of the source buffer to the tail of this buffer
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; while balancing two conflicting goals: don't waste CPU and don't waste
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; memory.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't waste CPU (ie. don't copy data around).
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copying large amounts of data is expensive. Instead, we prefer to
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reassign entire segments from one buffer to the other.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't waste memory.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; As an invariant, adjacent pairs of segments in a buffer should be at
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; least 50% full, except for the head segment and the tail segment.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The head segment cannot maintain the invariant because the application is
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; consuming bytes from this segment, decreasing its level.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The tail segment cannot maintain the invariant because the application is
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; producing bytes, which may require new nearly-empty tail segments to be
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; appended.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Moving segments between buffers
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; When writing one buffer to another, we prefer to reassign entire segments
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; over copying bytes into their most compact form. Suppose we have a buffer
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with these segment levels [91%, 61%]. If we append a buffer with a
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; single [72%] segment, that yields [91%, 61%, 72%]. No bytes are copied.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Or suppose we have a buffer with these segment levels: [100%, 2%], and we
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; want to append it to a buffer with these segment levels [99%, 3%]. This
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; operation will yield the following segments: [100%, 2%, 99%, 3%]. That
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is, we do not spend time copying bytes around to achieve more efficient
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; memory use like [100%, 100%, 4%].
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; When combining buffers, we will compact adjacent buffers when their
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; combined level doesn't exceed 100%. For example, when we start with
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [100%, 40%] and append [30%, 80%], the result is [100%, 70%, 80%].
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Splitting segments
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Occasionally we write only part of a source buffer to a sink buffer. For
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; example, given a sink [51%, 91%], we may want to write the first 30% of
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a source [92%, 82%] to it. To simplify, we first transform the source to
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; an equivalent buffer [30%, 62%, 82%] and then move the head segment,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; yielding sink [51%, 91%, 30%] and source [62%, 82%].&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;source == null&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;this&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;source == this&quot;&lt;span&gt;);
    checkOffsetAndCount(source.size, &lt;/span&gt;0&lt;span&gt;, byteCount);

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (byteCount &amp;gt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a prefix of the source's head segment all that we need to move?
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 Source Buffer 的头结点可用字节数大于要写出的字节数&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (byteCount &amp;lt; (source.head.limit -&lt;span&gt; source.head.pos)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到当前buffer的尾节点&lt;/span&gt;
        Segment tail = head != &lt;span&gt;null&lt;/span&gt; ? head.prev : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果尾部结点有足够空间可以写数据，并且这个结点是底层数组的拥有者&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tail != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; tail.owner
            &lt;/span&gt;&amp;amp;&amp;amp; (byteCount + tail.limit - (tail.shared ? 0 : tail.pos) &amp;lt;=&lt;span&gt; Segment.SIZE)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Our existing segments are sufficient. Move bytes from source's head to our tail.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;source头结点的数据写入到当前尾节点中，然后就直接结束返回了&lt;/span&gt;
          source.head.writeTo(tail, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) byteCount);
          source.size &lt;/span&gt;-=&lt;span&gt; byteCount;
          size &lt;/span&gt;+=&lt;span&gt; byteCount;
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We're going to need another segment. Split the source's head
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; segment in two, then move the first of those two to this buffer.
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果尾节点空间不足或者不是持有者，这时就需要把 Source Buffer 的头结点分割为两个 Segment，
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将source的头指针更新为分割后的第一个Segment, 如[92%, 82%]变成[30%, 62%, 82%]这样&lt;/span&gt;
          source.head = source.head.split((&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) byteCount);
        }
      }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the source's head segment and append it to our tail.
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 Source Buffer 的链表中移除头结点, 并加入到当前Buffer的链尾&lt;/span&gt;
      Segment segmentToMove =&lt;span&gt; source.head;
      &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; movedByteCount = segmentToMove.limit -&lt;span&gt; segmentToMove.pos;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除操作，并移动更新source中的head&lt;/span&gt;
      source.head =&lt;span&gt; segmentToMove.pop();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前buffer的头结点为 null，则头结点直接指向source的头结点，初始化双向链表&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        head &lt;/span&gt;=&lt;span&gt; segmentToMove;
        head.next &lt;/span&gt;= head.prev =&lt;span&gt; head;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则就把Source Buffer的 head 加入到当前Buffer的链尾&lt;/span&gt;
        Segment tail =&lt;span&gt; head.prev;
        tail &lt;/span&gt;= tail.push(segmentToMove);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压入链尾，并更新尾节点&lt;/span&gt;
        tail.compact();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点尝试合并，如果合并成功，则尾节点会被SegmentPool回收掉&lt;/span&gt;
&lt;span&gt;      }
      source.size &lt;/span&gt;-=&lt;span&gt; movedByteCount;
      size &lt;/span&gt;+=&lt;span&gt; movedByteCount;
      byteCount &lt;/span&gt;-=&lt;span&gt; movedByteCount;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;主要就是在这个 &lt;code&gt;write(Buffer source, long byteCount) &lt;/code&gt;方法中实现的，这个方法前面有大段的英文注释，我从源码中直接复制过来的，我们可以翻译过来理解一下说的是啥：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;24.5&quot;&gt;
&lt;p&gt;&lt;span&gt;将字节数据从 source buffer 的头节点复制到当前buffer的尾节点中，这里主要需要平衡两个相互冲突的目标：CPU 和 内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要浪费 CPU（即不要复制全部的数据）。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;复制大量数据代价昂贵。相反，我们更喜欢将整个段从一个缓冲区重新分配到另一个缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;不要浪费内存。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;Segment作为一个不可变量，缓冲区中除了头节点和尾节点的片段以外，相邻的片段，至少应该保证 &lt;code&gt;50% &lt;/code&gt;以上的数据负载量（指的是 &lt;code&gt;Segment &lt;/code&gt;中的&lt;code&gt;data&lt;/code&gt;数据, Okio 认为 &lt;code&gt;data &lt;/code&gt;数据量在 &lt;code&gt;50% &lt;/code&gt;以上才算是被有效利用的）。由于头结点中需要读取消耗字节数据，而尾节点中需要写入产生字节数据，因此头结点和尾节点是不能保持不变性的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;在缓冲区之间移动片段&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;在将一个缓冲区写入另一个缓冲区时，我们更喜欢重新分配整个段，将字节复制到最紧凑的形式。假设我们有一个缓冲区，其中的片段负载为&lt;code&gt;[91%，61%]&lt;/code&gt;，如果我们要在这上面附加一个负载量为 &lt;code&gt;[72%] &lt;/code&gt;的单一片段，这样将产生的结果为 &lt;code&gt;[91%，61%，72%]&lt;/code&gt;。这期间不会进行任何的字节复制操作。（即空间换时间，牺牲内存，提供速度）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再假设，我们有一个缓冲区负载量为：&lt;code&gt;[100%，2%]&lt;/code&gt;，并且我们希望将其附加到一个负载量为 &lt;code&gt;[99%，3%] &lt;/code&gt;的缓冲区中。这个操作将产生以下部分：&lt;code&gt;[100%、2%、99%、3%]&lt;/code&gt;，也就是说，我们不会花时间去复制字节来提高内存的使用效率，如变成 &lt;code&gt;[100%，100%，4%] &lt;/code&gt;这样。（即这种情况下 Okio 不会采取时间换空间的策略，因为太浪费CPU）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在合并缓冲区时，当相邻缓冲区的合并级别不超过 &lt;code&gt;100% &lt;/code&gt;时，我们将压缩相邻缓冲区。例如，当我们在 &lt;code&gt;[100%，40%] &lt;/code&gt;基础上附加 &lt;code&gt;[30%，80%] &lt;/code&gt;时，结果将会是 &lt;code&gt;[100%，70%，80%]&lt;/code&gt;。（也就是中间相邻的负载为 40% 和 30% 的两个 Segment 将会被合并为一个负载为 70% 的 Segment ）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;分割片段&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;有时我们只想将 source buffer 中的一部分写入到sink buffer当中，例如，给定一个sink为 &lt;code&gt;[51%，91%]&lt;/code&gt;，现在我们想要将一个 &lt;code&gt;source &lt;/code&gt;为 &lt;code&gt;[92%，82%] &lt;/code&gt;的前 &lt;code&gt;30% &lt;/code&gt;写入到这个 &lt;code&gt;sink&lt;/code&gt; buffer 当中。为了简化，我们首先将 source buffer 转换为等效缓冲区 &lt;code&gt;[30%，62%，82%]&lt;/code&gt;（即拆分Segment），然后移动 source 的头结点 Segment 即可，最终生成 sink&lt;code&gt;[51%，91%，30%] &lt;/code&gt;和 source&lt;code&gt;[62%，82%]&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里的注释基本上已经说明了这个方法的意图实现过程，主要是通过移动 source 头结点的指向，另外配合分割/合并Segment的操作来平衡 CPU 消耗和内存消耗的两个目标。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Segment 的合并过程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设初始两个 &lt;code&gt;Buffer &lt;/code&gt;中的 &lt;code&gt;Segment &lt;/code&gt;链表如下：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418100324393.jpg&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;776&quot; height=&quot;120&quot;/&gt;&lt;br/&gt;&lt;span&gt;现在将第二个 &lt;code&gt;Buffer &lt;/code&gt;完全写入到第一个 &lt;code&gt;Buffer&lt;/code&gt;：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041810044212.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;683&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，它会直接将第二个 &lt;code&gt;Buffer &lt;/code&gt;的头节点连接到第一个 &lt;code&gt;Buffer &lt;/code&gt;的链尾，然后尝试将链尾的两个 &lt;code&gt;Segment &lt;/code&gt;进行合并，如果合并成功，则在合并之后，图中 &lt;code&gt;40% &lt;/code&gt;的那个 &lt;code&gt;Segment &lt;/code&gt;会被&lt;code&gt;SegmentPool &lt;/code&gt;回收，它的数据完全写入到 &lt;code&gt;30% &lt;/code&gt;的那个 &lt;code&gt;Segment &lt;/code&gt;中，最终生成一个&lt;code&gt;70% &lt;/code&gt;的 &lt;code&gt;Segment&lt;/code&gt;，这样就达到了节约内存的目标。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Segment 的拆分过程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设初始两个 &lt;code&gt;Buffer &lt;/code&gt;中的 Segment 链表如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418100856737.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YWJjMTIzNDU2,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;751&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在要从第二个&lt;code&gt;Buffer&lt;/code&gt;中取前&lt;code&gt;30%&lt;/code&gt;的数据写入到第一个&lt;code&gt;Buffer&lt;/code&gt;当中，那么首先会将第二个Buffer的头结点&lt;code&gt;Segment&lt;/code&gt;进行分割，分割为两个负载为&lt;code&gt;30%&lt;/code&gt;和&lt;code&gt;62%&lt;/code&gt;的&lt;code&gt;Segment&lt;/code&gt;, 接下来移动这个新的&lt;code&gt;30%&lt;/code&gt;的&lt;code&gt;Segment&lt;/code&gt;节点到第一个&lt;code&gt;Buffer&lt;/code&gt;的链表的尾部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019041810120763.jpg&quot; alt=&quot;在这里插入图片描述&quot; width=&quot;796&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就完成了从第二个&lt;code&gt;Buffer&lt;/code&gt;取&lt;code&gt;30%&lt;/code&gt;的数据写入到第一个&lt;code&gt;Buffer&lt;/code&gt;当中的工作。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;
&lt;h2&gt;超时机制&lt;/h2&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;Okio&lt;/code&gt;的亮点之一就是增加了超时机制，防止因为意外导致I/O一直阻塞的问题，默认的超时机制是同步的。&lt;code&gt;AsyncTimeout&lt;/code&gt;是&lt;code&gt;Okio&lt;/code&gt;中异步超时机制的实现，它是一个单链表，结点按等待时间从小到大排序，head是一个头结点，起占位作用。使用了一个&lt;code&gt;WatchDog&lt;/code&gt;的后台线程来不断的遍历所有节点，如果某个节点超时就会将该节点从链表中移除，并关闭&lt;code&gt;Socket&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;AsyncTimeout&lt;/code&gt;提供了3个方法&lt;code&gt;enter&lt;/code&gt;、&lt;code&gt;exit&lt;/code&gt;、&lt;code&gt;timeout&lt;/code&gt;，分别用于流操作开始、结束、超时三种情况调用。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AsyncTimeout &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Timeout {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点，占位使用&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt;
    AsyncTimeout head;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否在链表中&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; inQueue;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后继节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;
    AsyncTimeout next;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeoutAt;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把当前AsyncTimeout对象加入节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enter() {
        ...
        scheduleTimeout(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, timeoutNanos, hasDeadline);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scheduleTimeout(
            AsyncTimeout node, &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeoutNanos, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasDeadline) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建占位头结点并开启子线程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            head &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AsyncTimeout();
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Watchdog().start();
        }

        ...

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入到链表中，按照时间长短进行排序，等待事件越长越靠后&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (AsyncTimeout prev = head; &lt;span&gt;true&lt;/span&gt;; prev =&lt;span&gt; prev.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev.next == &lt;span&gt;null&lt;/span&gt; || remainingNanos &amp;lt;&lt;span&gt; prev.next.remainingNanos(now)) {
                node.next &lt;/span&gt;=&lt;span&gt; prev.next;
                prev.next &lt;/span&gt;=&lt;span&gt; node;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev ==&lt;span&gt; head) {
                    AsyncTimeout.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.notify(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wake up the watchdog when inserting at the front.&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从链表中移除节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; exit() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!inQueue) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        inQueue &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cancelScheduledTimeout(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行真正的移除操作&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; cancelScheduledTimeout(AsyncTimeout node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the node from the linked list.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (AsyncTimeout prev = head; prev != &lt;span&gt;null&lt;/span&gt;; prev =&lt;span&gt; prev.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev.next ==&lt;span&gt; node) {
                prev.next &lt;/span&gt;=&lt;span&gt; node.next;
                node.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The node wasn't found in the linked list: it must have timed out!&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在子类中重写了该方法，主要是进行socket的关闭&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; timedOut() {
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听节点是否超时的子线程&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Watchdog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        Watchdog() {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(&quot;Okio Watchdog&quot;&lt;span&gt;);
            setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    AsyncTimeout timedOut;
                    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (AsyncTimeout.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                        timedOut &lt;/span&gt;=&lt;span&gt; awaitTimeout();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表头结点的后继节点已超时，&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (timedOut == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除头结点外没有任何其他节点&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (timedOut ==&lt;span&gt; head) {
                            head &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭socket&lt;/span&gt;
&lt;span&gt;                    timedOut.timedOut();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ignored) {
                }
            }
        }
    }

    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; AsyncTimeout awaitTimeout() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        AsyncTimeout node &lt;/span&gt;=&lt;span&gt; head.next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除了头结点外没有任何其他节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startNanos =&lt;span&gt; System.nanoTime();
            AsyncTimeout.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.wait(IDLE_TIMEOUT_MILLIS);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; head.next == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (System.nanoTime() - startNanos) &amp;gt;=&lt;span&gt; IDLE_TIMEOUT_NANOS
                    &lt;/span&gt;? head  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The idle timeout elapsed.&lt;/span&gt;
                    : &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The situation has changed.&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; waitNanos =&lt;span&gt; node.remainingNanos(System.nanoTime());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行等待&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (waitNanos &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; waitMillis = waitNanos / 1000000L&lt;span&gt;;
            waitNanos &lt;/span&gt;-= (waitMillis * 1000000L&lt;span&gt;);
            AsyncTimeout.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.wait(waitMillis, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) waitNanos);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表node节点已超时&lt;/span&gt;
        head.next =&lt;span&gt; node.next;
        node.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 默认都是未设置超时时间的，需要我们自己来设置，同步及异步的超时时间设置方式是一样的，通过下面代码即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    sink.timeout().deadline(1&lt;span&gt;, TimeUnit.SECONDS);
    source.timeout().deadline(&lt;/span&gt;1,TimeUnit.MILLISECONDS);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;生产者/消费者模型&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;Okio &lt;/code&gt;中可以使用 &lt;code&gt;Pipe &lt;/code&gt;来实现一个生产者/消费者模型。&lt;code&gt;Pipe &lt;/code&gt;维护了一个一定大小 &lt;code&gt;Buffer&lt;/code&gt;。当该 &lt;code&gt;Buffer &lt;/code&gt;容量达到最大时，线程就会等待直到该 &lt;code&gt;Buffer &lt;/code&gt;有剩余的空间。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pipe {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pipe的最大容量&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxBufferSize;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pipe对应的Buffer&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; Buffer buffer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Buffer();
  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sinkClosed;
  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sourceClosed;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入流，对应着生产者&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Sink sink = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PipeSink();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取流，对应着消费者&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Source source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PipeSource();

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Pipe(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxBufferSize) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大容量不能小于1&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (maxBufferSize &amp;lt; 1L&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;maxBufferSize &amp;lt; 1: &quot; +&lt;span&gt; maxBufferSize);
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maxBufferSize =&lt;span&gt; maxBufferSize;
  }
  ...
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入数据到Pipe中&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PipeSink &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Sink {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Timeout timeout = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timeout();

    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(Buffer source, &lt;span&gt;long&lt;/span&gt; byteCount) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
      &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (buffer) {
        ...

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (byteCount &amp;gt; 0&lt;span&gt;) {
          ...

          &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; bufferSpaceAvailable = maxBufferSize -&lt;span&gt; buffer.size();
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bufferSpaceAvailable == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;buffer中，没有剩余空间，等待消费者消费&lt;/span&gt;
            timeout.waitUntilNotified(buffer); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait until the source drains the buffer.&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
          }

          &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; bytesToWrite =&lt;span&gt; Math.min(bufferSpaceAvailable, byteCount);&lt;br/&gt;&lt;span&gt;　　　　　　// 将数据写入到 buffer的 data 中
&lt;/span&gt;          buffer.write(source, bytesToWrite);&lt;br/&gt;&lt;span&gt;          // 还需要写多少数据
&lt;/span&gt;          byteCount &lt;/span&gt;-=&lt;span&gt; bytesToWrite;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知buffer，有新的数据了，&lt;/span&gt;
          buffer.notifyAll(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Notify the source that it can resume reading.&lt;/span&gt;
&lt;span&gt;        }
      }
    }

    ...
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 Pipe 中读取数据&lt;/span&gt;
  &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PipeSource &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Source {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Timeout timeout = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timeout();

    @Override &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; read(Buffer sink, &lt;span&gt;long&lt;/span&gt; byteCount) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
      &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (buffer) {
        ...

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (buffer.size() == 0&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sinkClosed) &lt;span&gt;return&lt;/span&gt; -1L&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pipe中没有数据，等待生产者写入&lt;/span&gt;
          timeout.waitUntilNotified(buffer); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait until the sink fills the buffer.&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; result =&lt;span&gt; buffer.read(sink, byteCount);
        buffer.notifyAll(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Notify the sink that it can resume writing.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
      }
    }
    ...
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code&gt;Pipe &lt;/code&gt;的代码还是比较少的。简单说下 pipe 的实现原理，其实就是内部维护了一个 buffer 用来存储数据，可读可写；&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;当读数据的时候，就会减少 buffer 里面数据的容量，同时通过 buffer.notifyAll() 告诉外界状态发生了变化；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;当写数据的时候，只能添加最大容量的数据，写好数据之后，就会通过 buffer.notifyAll() 告诉外界状态发生了变化；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面就来如何使用 &lt;code&gt;Pipe&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pipe() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 Pipe 的容量为1024字节，即 1kb&lt;/span&gt;
        Pipe pipe = &lt;span&gt;new&lt;/span&gt; Pipe(1024&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {&lt;br/&gt;&lt;span&gt;　　　　　　　　　　//1 pipe.source 会从 pipe 的 buffer 中读取数据
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (BufferedSource bufferedSource =&lt;span&gt; Okio.buffer(pipe.source())) {
                    &lt;/span&gt;&lt;span&gt;//2 &lt;/span&gt;&lt;span&gt;将Pipe中数据写入env4.txt这个文件中,；&lt;/span&gt;
                    bufferedSource.readAll(Okio.sink(&lt;span&gt;new&lt;/span&gt; File(&quot;file/env4.txt&quot;&lt;span&gt;)));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {&lt;br/&gt;&lt;span&gt;　　　　　　　　　　//3 pipe.sink 会将数据写入到 pipe 的 buffer 中
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (BufferedSink bufferedSink =&lt;span&gt; Okio.buffer(pipe.sink())) {
                    &lt;/span&gt;&lt;span&gt;//4 &lt;/span&gt;&lt;span&gt;将env3.txt中数据写入到Pipe中;&lt;/span&gt;
                    bufferedSink.writeAll(Okio.source(&lt;span&gt;new&lt;/span&gt; File(&quot;file/env3.txt&quot;&lt;span&gt;)));
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里我会简单解释下，按照注释标的数字：&lt;/p&gt;
&lt;div&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Okio.buffer(pipe.source()) 创建一个 source ，可以用于读取数据；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Okio.sink(new File(&quot;file/env4.txt&quot;)) 创建一个 sink，在调用 bufferedSource.readAll (sink ）,意思就是 bufferedSource 将自身 buffer （pipe 中的 buffer 数据）的数据给 sink。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Okio.buffer(pipe.sink()) 创建一个 sink ,可以写数据；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Okio.source(new File(&quot;file/env3.txt&quot;))  创建一个 source , bufferedSink.writeAll(source) 意思就是从 source 里面获取数据添加到自身的 buffer (pipe 中的 buffer 数据)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;本文到这里结束。&lt;/p&gt;


&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904195707912200&quot;&gt;https://juejin.cn/post/6844904195707912200&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lyabc123456/article/details/88830541&quot;&gt;https://blog.csdn.net/lyabc123456/article/details/88830541&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903785236545549&quot; target=&quot;_blank&quot;&gt;https://juejin.cn/post/6844903785236545549&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lyabc123456/article/details/89106168&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/lyabc123456/article/details/89106168&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jan 2021 15:55:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概述 Okio 作为 Okhttp 底层 io 库，它补充了 java.io 和 java.nio 的不足，使访问、存储和处理数据更加容易。Okio 的特点如下： okio 是一个由 square 公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/14323085.html</dc:identifier>
</item>
<item>
<title>Hash Map集合和Hash Set集合 - 古灯青衫</title>
<link>http://www.cnblogs.com/zxl-ll/p/14351065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxl-ll/p/14351065.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;　　&lt;span&gt;1.1、每个集合对象的创建（new）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.2、从集合中添加元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.3、从集合中取出某个元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.4、遍历集合&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;24&quot;&gt;
&lt;span&gt;public class HashMapTest {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        // 创建Map集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Map&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;p&gt;&lt;span&gt;        // 添加元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        map.put(1, &quot;小明&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        map.put(8, &quot;小周&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        map.put(15, &quot;小张&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        map.put(31, &quot;小剑&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        map.put(31, &quot;king&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 获取元素个数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(map.size());&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 获取key是8的元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(map.get(8));&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 重点，遍历Map集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        // 第一种方式，获取所有的key，遍历key的时候，通过key来获取value。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Set&amp;lt;Integer&amp;gt; keys = map.keySet();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for (Integer key : keys) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(key + &quot;=&quot; + map.get(key));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 第二种方法：是将Map集合转换成Set集合Set集合中的每一个元素是node。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        // 这个node节点有key和value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Set&amp;lt;Map.Entry&amp;lt;Integer, String&amp;gt;&amp;gt; nodes = map.entrySet();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for (Map.Entry node : nodes) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(node);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;span&gt;　1.1、每个集合对象的创建（new）&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.2、从集合中添加元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.3、从集合中取出某个元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.4、遍历集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.5、测试HashSet集合的特点&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;47&quot;&gt;
&lt;span&gt;public class HashSetTest {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;p&gt;&lt;span&gt;        // 创建Set集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 添加元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;abc&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;def&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;ghi&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;jkl&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(set.size());&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 遍历集合&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        // 迭代器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Iterator&amp;lt;String&amp;gt; it = set.iterator();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        while (it.hasNext()) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(it.next());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        System.out.println(&quot;----------------&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 增强for循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for (String s : set) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(s);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 无序不可重复&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;abc&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;abc&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;abc&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(set.size());&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        set.add(&quot;1&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;king&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        set.add(&quot;2&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        for (String s : set) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(&quot;----&amp;gt;&quot; + s);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        System.out.println(&quot;----------------&quot;);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 测试Student&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Set&amp;lt;Student&amp;gt; students = new HashSet&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        students.add(new Student(01,&quot;小明&quot;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        students.add(new Student(02,&quot;小花&quot;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        students.add(new Student(01,&quot;小明&quot;));&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        System.out.println(students.size());&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        // 遍历&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        for (Student s : students) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            System.out.println(s);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;class Student {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int id;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    String name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    public Student() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    public Student(int id, String name) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        this.id = id;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        this.name = name;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    @Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public String toString() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        return &quot;Student{&quot; +&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                &quot;name='&quot; + name + '\'' +&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                '}';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    @Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public boolean equals(Object o) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if (this == o) return true;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        if (o == null || getClass() != o.getClass()) return false;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        Student student = (Student) o;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        return Objects.equals(name, student.name);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    @Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public int hashCode() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        return Objects.hash(name);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Jan 2021 15:46:00 +0000</pubDate>
<dc:creator>古灯青衫</dc:creator>
<og:description>HashMap集合的使用 1.1、每个集合对象的创建（new） 1.2、从集合中添加元素 1.3、从集合中取出某个元素 1.4、遍历集合 public class HashMapTest { publ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zxl-ll/p/14351065.html</dc:identifier>
</item>
<item>
<title>扒一扒ELF文件 - 嵌入式与Linux那些事</title>
<link>http://www.cnblogs.com/dongxb/p/14347361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxb/p/14347361.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ELF文件（Executable Linkable Format）是一种文件存储格式。Linux下的目标文件和可执行文件都按照该格式进行存储，有必要做个总结。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-链接举例&quot;&gt;1. 链接举例&lt;/h2&gt;
&lt;p&gt;  在介绍ELF文件之前，我们先看下，一个.c程序是如何变成可执行目标文件的。下面举个例子。&lt;/p&gt;
&lt;p&gt;  该程序由main.c和sum.c两个模块组成。sum.c接收数组和数组长度两个参数，最后将数组求和的结果返回。main.c调用sum函数，并传递一个两元素的int数组array，将计算结果保存在val中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//main.c
int sum(int *a, int n);

int array[2] = {1, 2};

int main(int argc, char** argv)
{
    int val = sum(array, 2);
    return val;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//sum.c
int sum(int *a, int n)
{
    int i, s = 0;

    for (i = 0; i &amp;lt; n; i++) {
        s += a[i];
    }
    return s;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  让我们来看看如果我们使用GCC编译两个模块会发生什么？&lt;/p&gt;
&lt;p&gt;  main.c和sum.c将分别通过&lt;strong&gt;翻译器&lt;/strong&gt;将源文件处理为可重定位的目标文件main.o和sum.o。翻译器处理的过程包括了&lt;strong&gt;预处理（ccp）、编译（ccl）、汇编（as）&lt;/strong&gt;三个过程。最后，&lt;strong&gt;链接器（ld）&lt;/strong&gt;将可重定位的目标文件main.o和sum.o以及一些必要的系统文件组合起来，创建一个可执行目标文件prog。具体过程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/dongxingbo/Picture/raw/master/Blog/2021/%E4%B8%80%E6%9C%88//sum.c%20main.c%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;链接过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  由上面的过程，我们可以看出在经过汇编器后会输出一个.o文件，这个叫做&lt;strong&gt;可重定位的目标文件&lt;/strong&gt;。将main.o和sum.o输入链接器后，链接器输出的prog文件叫做&lt;strong&gt;可执行目标文件&lt;/strong&gt;。那这两个目标文件有什么样的区别呢？&lt;/p&gt;
&lt;h2 id=&quot;2-elf文件类型&quot;&gt;2. ELF文件类型&lt;/h2&gt;
&lt;h3 id=&quot;21-可重定位目标文件（o文件）&quot;&gt;2.1 可重定位目标文件（.o文件）&lt;/h3&gt;
&lt;p&gt;  包含二进制代码和数据，其形式&lt;strong&gt;可以和其他目标文件进行合并&lt;/strong&gt;，创建一个可执行目标文件。例如lib*.o文件。&lt;/p&gt;
&lt;h3 id=&quot;22-可执行目标文件（aout文件）&quot;&gt;2.2 可执行目标文件（a.out文件）&lt;/h3&gt;
&lt;p&gt;  包含二进制代码和数据，&lt;strong&gt;可直接被加载器加载执行&lt;/strong&gt;。例如编译好的可执行文件a.out。&lt;/p&gt;
&lt;h3 id=&quot;23-共享对象文件（so文件）&quot;&gt;2.3 共享对象文件（.so文件）&lt;/h3&gt;
&lt;p&gt;  用于和其他共享目标文件或者可重定位文件一起生成ELF目标文件或者和执行文件一起创建进程映像，例如lib*.so文件。&lt;/p&gt;
&lt;h2 id=&quot;3-elf文件作用&quot;&gt;3. ELF文件作用&lt;/h2&gt;
&lt;p&gt;  ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，所以可以从&lt;strong&gt;不同的角度&lt;/strong&gt;来看待ELF格式的文件：&lt;/p&gt;
&lt;p&gt;  1.如果用于&lt;strong&gt;编译和链接（可重定位文件）&lt;/strong&gt;，则编译器和链接器将把ELF文件看作是节头表描述的节的集合,程序头表可选。&lt;/p&gt;
&lt;p&gt;  2.如果用于&lt;strong&gt;加载执行（可执行文件）&lt;/strong&gt;，则加载器则将把ELF文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。&lt;/p&gt;
&lt;h2 id=&quot;4-elf文件格式&quot;&gt;4. ELF文件格式&lt;/h2&gt;
&lt;h3 id=&quot;41-从编译和链接角度看elf文件（可重定位目标文件）&quot;&gt;4.1 从编译和链接角度看ELF文件（可重定位目标文件）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/dongxingbo/Picture/raw/master/Blog/2021/%E4%B8%80%E6%9C%88//ELF--%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6.png&quot; alt=&quot;从编译和链接角度看ELF文件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELF头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来&lt;strong&gt;描述整个文件的组织&lt;/strong&gt;,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;段头表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  段头表。存放的是所有&lt;strong&gt;不同段将在内存中的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.text section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  代码段。存放已编译程序的机器代码，一般是只读的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.rodata&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  只读数据段。此段的数据不可修改,存放常量。比如，printf中的格式化语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.data&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  数据段。存放已初始化的全局变量、常量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.bss&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  bss段。未初始化全局变量，仅是占位符，&lt;strong&gt;不占据任何实际磁盘空间&lt;/strong&gt;。目标文件格式区分初始化和非初始化是为了空间效率.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/dongxingbo/Picture/raw/master/Blog/2021/%E4%B8%80%E6%9C%88//ELF--%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B62.png&quot; alt=&quot;从编译和链接角度看ELF文件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.symtab&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  符号表，它存放在程序中定义和引用的函数和全局变量的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.rel.txt&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  .text节的重定位信息，用于重新修改代码段的指令中的地址信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.rel.data&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.debug&lt;/strong&gt; &lt;strong&gt;section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  调试用的符号表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.strtab section&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  包含 symtab和 debug节中符号及节名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节头部表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  每个节的节名、偏移和大小。&lt;/p&gt;
&lt;p&gt;  以下是32位系统对应的节头表数据结构,说明了每个节的节名、在文件中的偏移、大小、访问属性、对齐方式等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct {
    Elf32_Word sh_name;   //节名字符串在.strtab节（字符串表）中的偏移
    Elf32_Word sh_type;   //节类型：无效/代码或数据/符号/字符串/...
    Elf32_Word sh_flags;  //节标志：该节在虚拟空间中的访问属性
    Elf32_Addr sh_addr;   //虚拟地址：若可被加载，则对应虚拟地址
    Elf32_Off  sh_offset; //在文件中的偏移地址，对.bss节而言则无意义
    Elf32_Word sh_size;   //节在文件中所占的长度
    Elf32_Word sh_link;   //sh_link和sh_info用于与链接相关的节（如 .rel.text节、.rel.data节、.symtab节等）
    Elf32_Word sh_info;
    Elf32_Word sh_addralign; //节的对齐要求
    Elf32_Word sh_entsize;   //节中每个表项的长度，0表示无固定长度表项
} Elf32_Shdr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  使用readelf命令命令查看节头表内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[ubuntu@localhost interpositioning]$ readelf -S main.o
There are 13 section headers, starting at offset 0x3f8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000071  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000002d0
       0000000000000090  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000b1
       0000000000000049  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  000000b1
       000000000000000c  0000000000000000  WA       0     0     1
  [ 5] .rodata           PROGBITS         0000000000000000  000000b1
       0000000000000019  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  000000ca
       0000000000000035  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000ff
       0000000000000000  0000000000000000           0     0     1
  [ 8] .eh_frame         PROGBITS         0000000000000000  00000100
       0000000000000058  0000000000000000   A       0     0     8
  [ 9] .rela.eh_frame    RELA             0000000000000000  00000360
       0000000000000030  0000000000000018   I      11     8     8
  [10] .shstrtab         STRTAB           0000000000000000  00000390
       0000000000000061  0000000000000000           0     0     1
  [11] .symtab           SYMTAB           0000000000000000  00000158
       0000000000000150  0000000000000018          12     9     8
  [12] .strtab           STRTAB           0000000000000000  000002a8
       0000000000000023  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  可重定位目标文件中，每个可装入节的起始地址总是0。&lt;/p&gt;
&lt;p&gt;  .bss节应占000000000000000c大小，但只有装入内存时才会分配。&lt;/p&gt;
&lt;h3 id=&quot;42-从程序执行角度看elf文件（可执行文件）&quot;&gt;4.2 从程序执行角度看ELF文件（可执行文件）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/dongxingbo/Picture/raw/master/Blog/2021/%E4%B8%80%E6%9C%88//%E4%BB%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%A7%92%E5%BA%A6%E7%9C%8BELF%E6%96%87%E4%BB%B6%EF%BC%88%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%89.png&quot; alt=&quot;从程序执行角度看ELF文件&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  与可重定位文件的不同&lt;/p&gt;
&lt;p&gt;  1.ELF头中字段 e_entry给出执行程序时第一条指令的地址，而在可重定位文件中，此字段为0。&lt;/p&gt;
&lt;p&gt;  2.多一个init节，用于定义init函数，该函数用来进行可执行目标文件开始执行时的初始化工作。&lt;/p&gt;
&lt;p&gt;  3.少两.rel节（无需重定位)。&lt;/p&gt;
&lt;p&gt;  4.多一个程序头表，也称段头表，是一个结构数组。&lt;/p&gt;
&lt;p&gt;  使用readelf命令查看ELF头的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[ubuntu@localhost interpositioning]$readelf -h main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          1064 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           32 (bytes)         //程序头表每项32B
  Number of program headers:         8                  //程序头表共8项
  Size of section headers:           64 (bytes)
  Number of section headers:         13
  Section header string table index: 10                //.strtab在节头表中的索引
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  装入内存时，ELF头、程序头表、.init节、.rodata节会被装入只读代码段。.data节和.bss节会被装入读写数据段。&lt;/p&gt;
&lt;p&gt;  段头表能够描述可执行文件中的节与虚拟空间中的存储段之间的映射关系。一个表项32B，说明虚拟地址空间中一个连续的片段或一个特殊的节。以下是32位系统对应的段头表数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct {
    Elf32_Word p_type;   //此数组元素描述的段的类型，或者如何解释此数组元素的信息。
    Elf32_Off p_offset;  //此成员给出从文件头到该段第一个字节的偏移
    Elf32_Addr p_vaddr;  //此成员给出段的第一个字节将被放到内存中的虚拟地址
    Elf32_Addr p_paddr;  //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。
    Elf32_Word p_filesz; //此成员给出段在文件映像中所占的字节数。可以为0。
    Elf32_Word p_memsz;  //此成员给出段在内存映像中占用的字节数。可以为0。
    Elf32_Word p_flags;  //此成员给出与段相关的标志。
    Elf32_Word p_align;  //此成员给出段在文件中和内存中如何对齐。
} Elf32_phdr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  使用readelf命令某可执行目标文件的程序头表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[ubuntu@localhost interpositioning]$readelf -l main

Elf file type is EXEC (Executable file)
Entry point 0x400550
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000008ac 0x00000000000008ac  R E    200000
  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                 0x0000000000000240 0x0000000000000248  RW     200000
  DYNAMIC        0x0000000000000e28 0x0000000000600e28 0x0000000000600e28
                 0x00000000000001d0 0x00000000000001d0  RW     8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_EH_FRAME   0x0000000000000780 0x0000000000400780 0x0000000000400780
                 0x0000000000000034 0x0000000000000034  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10
                 0x00000000000001f0 0x00000000000001f0  R      1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  程序头表信息有9个表项，其中两个为可装入段(即Type=LOAD)：&lt;/p&gt;
&lt;p&gt;  第一可装入段(第15,16行)：第0x00000~0x0x8ab的长度为0x8ac字节的ELF头、程序头表、.init、.text和.rodata节，映射到虚拟地址0x400000开始长度为0x8ac字节的区域 ，按0x200000=2MB对齐，具有只读/执行权限（Flg=RE），是只读代码段。&lt;/p&gt;
&lt;p&gt;  第二可装入段(第17,18行)：第0xe10~0x104f的长度为0x240字节的.data节和磁盘中不占存储空间的.bss节，映射到虚拟地址0x600e10开始长度为0x248字节的存储区域，在0x248=584B存储区中，前0x240=576B用.data节内容初始化，后面584-576=8B对应.bss节，初始化为0 ，按0x200000=2MB对齐，具有可读可写权限（Flg=RW），是可读写数据段。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;由此看出.bss节在文件中不占用磁盘空间，但在存储器中需要给它分配相应大小的空间&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;5总结&quot;&gt;5.总结&lt;/h2&gt;
&lt;p&gt;  1.链接处理涉及到三种目标文件格式：&lt;strong&gt;可重定位目标文件、可执行目标文件和共享目标文件&lt;/strong&gt;。共享库文件是一种特殊的可重定位目标。&lt;/p&gt;
&lt;p&gt;  2.ELF目标文件格式可以从&lt;strong&gt;编译链接角度&lt;/strong&gt;和&lt;strong&gt;程序执行角度&lt;/strong&gt;两个角度看，前者是可重定位目标格式，后者是可执行目标格式。从编译链接角度看，可重定位目标文件中包含ELF头、各个节以及节头表。可执行目标文件中包含ELF头、程序头表（段头表）以及各种节组成的段。&lt;/p&gt;
&lt;p&gt;  3.bss段在可执行目标文件中不会有它的空间，只有当可执行目标文件&lt;strong&gt;装载运行时&lt;/strong&gt;，才会被分配内存（并且位于data段内存块之后），&lt;strong&gt;并且初始化为0&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;《深入理解计算机系统》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/dongxingbo/Picture/raw/master/Wechat/%E5%8A%A8%E6%80%81%E5%BC%95%E5%AF%BC%E4%B8%89%E8%81%94_CSDN.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jan 2021 15:03:00 +0000</pubDate>
<dc:creator>嵌入式与Linux那些事</dc:creator>
<og:description>ELF文件（Executable Linkable Format）是一种文件存储格式。Linux下的目标文件和可执行文件都按照该格式进行存储，有必要做个总结。 1. 链接举例 在介绍ELF文件之前，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxb/p/14347361.html</dc:identifier>
</item>
<item>
<title>令牌桶、漏斗、冷启动限流在sentinel的应用 - luoxn28</title>
<link>http://www.cnblogs.com/luoxn28/p/14350907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoxn28/p/14350907.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/772134/202101/772134-20210130223942709-1325820580.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;315&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 分布式系统为了保证系统稳定性，在服务治理的限流中会根据不同场景进行限流操作，常见的限流算法有：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;令牌桶&lt;/strong&gt;：可容忍一定突发流量的速率的限流，令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;漏斗&lt;/strong&gt;：固定速率限流，可以启动整流作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在分析sentinel限流之前，我们先看下sentinel是什么，官网说明如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;从限流角度来看，sentinel的限流有2种控制维度，一个是qps，一个是并发数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;qps这个很好理解，也就是每秒处理请求量，当超过设定阈值时，会进行流控，策略有如下几种：拒绝、排队（一定时长）等。&lt;/p&gt;
&lt;p&gt;并发数这个就是当前线程运行数，类似于hystrix，只不过sentinel是进行线程个数统计判断是否达到线程设定值，而hystrix是根据不同线程池来做的。&lt;/p&gt;
&lt;p&gt;sentinel中处理流程是一个责任链，不同功能的逻辑抽象成不同的&lt;code&gt;ProcessorSlot&lt;/code&gt;组合在一起，比如有限流的FlowSlot、打日志的LogSot、数据统计的StatisticSlot。下面重点看限流的&lt;code&gt;com.alibaba.csp.sentinel.slots.block.flow.FlowSlot&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;66&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,
                  boolean prioritized, Object... args) throws Throwable {
    // 是否触发限流检查
    checkFlow(resourceWrapper, context, node, count, prioritized);
    // 继续往下一个节点走
    fireEntry(context, resourceWrapper, node, count, prioritized, args);
}

public void checkFlow(Function&amp;lt;String, Collection&amp;lt;FlowRule&amp;gt;&amp;gt; ruleProvider, ResourceWrapper resource,
                      Context context, DefaultNode node, int count, boolean prioritized) throws BlockException {
    Collection&amp;lt;FlowRule&amp;gt; rules = ruleProvider.apply(resource.getName());
    for (FlowRule rule : rules) { // 多个限流规则检查
        if (!canPassCheck(rule, context, node, count, prioritized)) {
            throw new FlowException(rule.getLimitApp(), rule);
        }
    }
}
// canPassCheck -&amp;gt; passLocalCheck
private static boolean passLocalCheck(FlowRule rule, Context context, DefaultNode node, int acquireCount,
                                      boolean prioritized) {
    return rule.getRater().canPass(selectedNode, acquireCount, prioritized);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;canPass校验目前有以下几种实现类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/772134/202101/772134-20210130224051979-1590552668.png&quot; alt=&quot;&quot; width=&quot;1070&quot; height=&quot;121&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这几个实现类分别使用了如下几种限流算法：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DefaultController：令牌桶&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RateLimiterController：漏斗&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WarmUpController：冷启动的令牌桶&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WarmUpRateLimiterController：冷启动的漏斗&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sentinel中统计信息，比如qps、pass、block等信息都是在滑动时间窗口中维护的，比如时间戳是910时，统计信息会往对应800-1000的时间窗口更新，当时间戳是1001时，由于时间窗口只有5个(每个200ms)，因此会复用第一个时间窗口，在使用前会先进行初始化该窗口统计值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/772134/202101/772134-20210130224117654-27299261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于默认的流控实现 &lt;code&gt;DefaultController&lt;/code&gt;，其是根据时间窗口的统计值是否达到了限流值来决定是否限流的，这也是把它归为令牌桶算法的原因。漏斗算法实现&lt;code&gt;RateLimiterController&lt;/code&gt;，会记录上一次正常通过的时间戳信息（latestPassedTime），当判断是否限流时，会根据&lt;code&gt;当前时间-latestPassedTime&lt;/code&gt;是否大于间隔值，大于的话表示可以正常通过，小于的话表示刚刚已经有流程正常通过，此次需要排队等待，等待时间为&lt;code&gt;期望时间戳-当前时间戳&lt;/code&gt;，并发场景下，多个线程可能都会走到等待这里，因此需要(cas操作)判断当前需等待时间是否大于某个值，大于的话直接进行限流，不再排队等待。&lt;/p&gt;
&lt;p&gt;冷启动限流算法，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。&lt;/p&gt;
&lt;p&gt;sentinel中通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/772134/202101/772134-20210130224129379-1225260683.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;冷启动的两种模式，令牌桶和漏斗大同小异，只不过在流量较大时，冷启动过程 令牌桶走势类似于阶梯向上直到设定的限流值，漏洞走势类似于几个斜线向上之道设定的限流值。&lt;/p&gt;
&lt;p&gt;关于sentinel更多的知识可参考官方文档：https://sentinelguard.io/zh-cn/docs/introduction.html&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Jan 2021 14:44:00 +0000</pubDate>
<dc:creator>luoxn28</dc:creator>
<og:description>分布式系统为了保证系统稳定性，在服务治理的限流中会根据不同场景进行限流操作，常见的限流算法有： 令牌桶：可容忍一定突发流量的速率的限流，令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luoxn28/p/14350907.html</dc:identifier>
</item>
</channel>
</rss>