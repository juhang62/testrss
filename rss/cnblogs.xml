<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员用实力把公司干倒闭了 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12898692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12898692.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;青哥哥（我名字里带个青字），听说你的简历写得很好。我最近失业了，通过实力把公司干倒闭了。打算东山再起，先写份简历。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是大学同学可可发给我的私信，看完后觉得挺心酸的。好久好久没联系了，我问他干的什么，他说做了个智慧社区，但一直拉不来投资，熬了七八个月，终于撑不住了。&lt;/p&gt;
&lt;p&gt;这让我想起了我们之间的一些故事，希望能够给小伙伴们一些警示。&lt;/p&gt;
&lt;p&gt;老读者都知道了，我上的是大专，可可也不例外，毕竟他是我的大学同学（柯南的推理）。学校是河南省大专院校里面非常好的那种，这话可不是我在恭维自己，真的是有一说一，大多数同学的成绩都离二本线差不了六七分；电力专业的同学还有比一本线高很多的。&lt;/p&gt;
&lt;p&gt;为什么这些成绩好的不去上 211、985 呢？原因我简单说一下，电力专业毕业后可以直接进国家电网，算是难得的铁饭碗了，假如家里面还有点关系的话，那就妙不可言了。&lt;/p&gt;
&lt;p&gt;我填写志愿的时候也是冲着电力专业去的，可惜不够格，成绩算是学校里倒数的，所以调剂到了计算机网络专业（学校的边缘专业），于是就和可可成了同班同学。&lt;/p&gt;
&lt;p&gt;可可大学的时候非常沉迷魔兽世界，和几个同学打的那叫一个昏天暗地，不舍昼夜啊。我呢，整天抱着笔记本打单机游戏，之前文章也说过，好不到哪里去。我们俩玩的还可以，算是臭味相投吧。&lt;/p&gt;
&lt;p&gt;托尔斯泰在《安娜·卡列尼娜》说过一句家喻户晓的话，“&lt;strong&gt;幸福的家庭都是相似的，不幸的家庭各有各的不幸&lt;/strong&gt;。”这句话的深层含义放在我们身上也是成立的，之所以我们毕业后要去参加培训，就是因为我们的大学过得浑浑噩噩，蹉跎了大把的时光。&lt;/p&gt;
&lt;p&gt;我们之所以蹉跎，是因为我们不知道 Java（大学主修）是一门非常火热的编程语言，未来能够依靠它来安身立命。我们只知道，专业是学校不重视的，老师们是半路出家的，同学们是很迷茫的。&lt;/p&gt;
&lt;p&gt;大二结束后，我去苏州参加了培训班，可可没去。等我和另外两名同学在一家日企实习了三四个月后，可可和另外一名大学同学也去了苏州，报了培训班，住在离我们公司不远的地方。&lt;/p&gt;
&lt;p&gt;这就是社会的残酷性，当你在大学不学无术，学不到一技之长，毕业后就要遭受社会的毒打，不然那些比你努力，比你条件优渥的人怎么办？&lt;/p&gt;
&lt;p&gt;三年半后，我回到了洛阳，可可在苏州停了一段时间，后来就回郑州了。苏州虽然有一碗饭吃，但高昂的房价是我们承受不起的。&lt;/p&gt;
&lt;p&gt;再后来嘛，我们就很少很少联系了。同学结婚应该是我们聚在一起的唯一理由，随着年龄的增长，没结婚的也就那么一两个了。&lt;/p&gt;
&lt;p&gt;今天恐怕是我们时隔两年后的一次联系。我给可可说，「沉默王二」公众号后台有一份简历模板，我之前整理的，回复「&lt;strong&gt;简历&lt;/strong&gt;」关键字就可以获取。他看了后给我发了两句话，截图如下：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/gongsi-daobi-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;看来的确对他有一些帮助，小伙伴们有需要的也可以去看看。接下来，聊聊我的一些感悟，希望给小伙伴们一些启发。&lt;/p&gt;
&lt;p&gt;读者群体里有一些初中生和高中生，我希望这个年龄段的小伙伴们能够以学业为重，&lt;strong&gt;争取考一个好的学校&lt;/strong&gt;，这是人生当中第一个重要的分水岭。&lt;/p&gt;
&lt;p&gt;我念的大专虽然是个好学校，但与本科院校还是有差距的。就拿老师来说吧，不是我没良心，是说的真心话。教我们这些调剂专业的课程就好像京官被流放到了地方，心里面本身就委屈得很，又怎么能全心全意地教我们呢？&lt;/p&gt;
&lt;p&gt;假如老师能有这个觉悟，说，“你们都好好学 Java，这门语言在市面上很受欢迎，就业岗位非常多，哪怕你们是大专生，毕业后也不愁找工作。”我不敢保证全班同学都下劲学，至少我肯定会下劲学。&lt;/p&gt;
&lt;p&gt;可惜老师们是另外一种态度，“你们想办法往电力专业转，实在转不了的，以后。。。。。。我们也不知道怎么办？”&lt;/p&gt;
&lt;p&gt;大二结束后，苏州的一家培训机构找上门，我们专业的领导是热烈欢迎啊，终于可以把烫手山芋给扔出去了。我现在想起来这件事，觉得蛮可悲的。&lt;/p&gt;
&lt;p&gt;如果没有考上一个好的学校，也没有选择到一个好的专业，那一定要&lt;strong&gt;学会自学&lt;/strong&gt;。现在的互联网比我们当年更开放了，小伙伴们可以链接到很多我们当年链接不到的资源，比如说像我这般贴心的小哥哥，对吧？&lt;/p&gt;
&lt;p&gt;过来聊聊，很多人生问题说不定就迎刃而解了。不要迷茫，不要自卑，可学的知识有很多。&lt;/p&gt;
&lt;p&gt;另外，不要盲目地排斥培训，真的，如果有小伙伴在大学很不幸的没有学到赖以生存的技能，花点钱，找个好的培训课程跟一段时间，真的能帮你撬开一扇窗。&lt;/p&gt;
&lt;p&gt;第二个重要的分水岭就是工作之余，&lt;strong&gt;一定要做一些自己喜欢的，可以给你加分的事情&lt;/strong&gt;，比如说写作。我与可可之所以能够拉开差距，就是因为我从 2014 年就开始坚持做一件事情——写作，无论风吹雨打，真的是。&lt;/p&gt;
&lt;p&gt;网络上喷我的多得是，我有没有受影响，当然有，可我还是在坚持写；最近三周，文章阅读量不咋滴，我有没有受影响，当然有，可我还是在坚持写。&lt;/p&gt;
&lt;p&gt;人生总是起起伏伏嘛，但只要你一直在坚持做一件有意义的事情，就会受益。&lt;/p&gt;
&lt;p&gt;我和可可差不多，都在一家小公司，他能把公司干倒闭，没准我也能。可就算公司倒闭了，我也能继续生存下去，不用像他那样，再去写一份简历才能找到工作。&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复「&lt;strong&gt;简历&lt;/strong&gt;」更有一份 3000+ 人下载过的优质简历模板，从此你的简历再也不会石沉大海了。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4565217391304&quot;&gt;
&lt;p&gt;本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 16 May 2020 00:39:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>青哥哥（我名字里带个青字），听说你的简历写得很好。我最近失业了，通过实力把公司干倒闭了。打算东山再起，先写份简历。 以上是大学同学可可发给我的私信，看完后觉得挺心酸的。好久好久没联系了，我问他干的什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12898692.html</dc:identifier>
</item>
<item>
<title>Redis学习笔记（七） 数据库 - 温暖如太阳</title>
<link>http://www.cnblogs.com/xtt321/p/12898645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xtt321/p/12898645.html</guid>
<description>&lt;p&gt;Redis 服务器将所有的数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDB：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisServer{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个数组保存着服务器中的所有数据库&lt;/span&gt;
  redisDb *&lt;span&gt;db;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库的个数&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dbnum;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dbnum：服务器初始化时，程序根据dbnum 来决定应创建多少少数据库，由服务器配置的database选项决定，默认16.&lt;/p&gt;
&lt;p&gt;在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前目标数据库，这个属性指向redisDb结构的指针：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisClient{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录客户端当前正在使用的数据库&lt;/span&gt;
  redisDb *&lt;span&gt;db;
} redisClient;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redisClient指针指向redisServer 数组的其中一个元素，而被指向的元素就是客户端的目标数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/404258/202005/404258-20200516074842978-485339206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;redisBd结构的dict地点保存了数据库中的所有键值对，我们将这个字典称为键空间。&lt;/p&gt;
&lt;p&gt;键空间的键也就是数据库的键，每个键都是一个字符串对象。&lt;/p&gt;
&lt;p&gt;键空间的值也是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。&lt;/p&gt;

&lt;p&gt;Redis命令对数据库进行读写时，服务器不仅对键执行指定的读写操作，还会执行一些额外的维护工作：&lt;/p&gt;
&lt;p&gt;1、读取一个键后，服务器会根据键是否存在来更新服务器键空间命中次数或键空间不命中次数。&lt;/p&gt;
&lt;p&gt;2、读取一个键之后，服务器会更新键的LRU（最后一次使用时间），这个值用于计算键的空闲时间。&lt;/p&gt;
&lt;p&gt;3、如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后再执行余下的操作。&lt;/p&gt;
&lt;p&gt;4、如果客户端使用Watch命令监视某个键，那么服务器再对被监视的键进行修改后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改过。&lt;/p&gt;
&lt;p&gt;5、服务器每次修改一个键之后，都会对脏键计数器的值加一，这个计数器会触发服务器的持久化以及赋值操作。&lt;/p&gt;
&lt;p&gt;6、如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器将按配置发送相应的数据库通知。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设置过期时间&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;命令 EXPIRE key ttl 设置键生存时间为ttl秒&lt;/p&gt;
&lt;p&gt;命令 PEXPIRE  key ttl 设置键生存时间为ttl毫秒&lt;/p&gt;
&lt;p&gt;命令EXPIREAT key timestamp 命令 设置键key过期时间为timestamp秒数时间戳&lt;/p&gt;
&lt;p&gt;命令 PEXPIREAT key timestamp 设置键key过期时间为timestamp所指定的毫秒时间戳&lt;/p&gt;
&lt;p&gt;1、EXPIRE命令可以转换为 PEXPIRE命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def EXPIRE(key,ttl_in_sec);
ttl_in_ms &lt;/span&gt;=&lt;span&gt; sec_to_ms(ttl_in_sec)
PEXPIRE(key,ttl_in_ms)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、PEXPIRE命令转换为PEXPIREAT命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def PEXPIRE(key,ttl_in_ms)
now_ms &lt;/span&gt;=&lt;span&gt; get_current_unix_timestamp_in_ms();
PEXPIREAT(key,now_ms&lt;/span&gt;+ttl_in_ms)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、EXPIREAT命令转换为PEXPIREAT命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def EXPIREAT(key,expire_time_in_asc)
expire_time_in_ms &lt;/span&gt;=&lt;span&gt; sec_to_ms(expire_time_in_sec)
PEXPIREAT(key,expire_time_in_ms)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redisDB 结构的expires字典保存了数据库所在键的过期时间（过期字典），&lt;/p&gt;
&lt;p&gt;1、过期字典的键是一个指针指向键空间的某个键对象。&lt;/p&gt;
&lt;p&gt;2、过期字典的值是一个long类型的整数（毫秒精度的UNIX时间戳）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过期删除策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、定时删除，在设置过期时间的同时，创建定时器，到期立即删除（内存友好，CPU不友好）。&lt;/p&gt;
&lt;p&gt;2、惰性删除，下一次查询时，查询是否过期，过期删除，（内存不友好，CPU友好）。&lt;/p&gt;
&lt;p&gt;3、定期删除，每隔一段时间执行一次。&lt;/p&gt;
&lt;p&gt;Redis的删除策略使用了 惰性删除和定期删除两种。&lt;/p&gt;

&lt;p&gt;在执行SAVE或者BGSAVE命令生成RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中，因此数据库包含过期键不会对新生成的RDB文件造成影响。&lt;/p&gt;

&lt;p&gt;在载入RDB文件时，如果服务器以主服务器模式运行，载入RDB文件时会对键进行检查，未过期的键加载到数据库中，过期键忽略。从服务器模式运行时，文件中保存的所有键被加载，主从同步时，从服务器过期键被清空。&lt;/p&gt;

&lt;p&gt;AOF文件写入时，如果过期键未清理，AOF文件不会因为过期键而产生影响，过期键被删除后，程序会向AOF文件追加DEL命令，来显示的记录该键已被删除。&lt;/p&gt;

&lt;p&gt;AOF重写时，程序会对数据库中的键检查，已过期的键不会被保存到重写后的AOF文件中。&lt;/p&gt;

&lt;p&gt;服务器在复制模式下，服务器的过期键由主服务器控制：主服务器在删除过期键后会向从服务器发送一条DEL命令，从服务在未收到命令前，客户端的读命令会像对未过期键处理方式一样，直到接到DEL命令，从过期键才会删除。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;每天学一点，总会有收获。&lt;/p&gt;

&lt;p&gt;说明：尊重作者知识产权，文中内容参考《Redis设计与实现》，仅在此做学习与大家分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/404258/202005/404258-20200516075048892-1903437102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 15 May 2020 23:52:00 +0000</pubDate>
<dc:creator>温暖如太阳</dc:creator>
<og:description>Redis 服务器将所有的数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDB： struct redisServer{ //一个数组保存着服务器中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xtt321/p/12898645.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---几个高级功能 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/12898603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/12898603.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;本篇主要介绍一下搜索模板、映射模板、高亮搜索和地理位置的简单玩法。&lt;/p&gt;
&lt;h3 id=&quot;标准搜索模板&quot;&gt;标准搜索模板&lt;/h3&gt;
&lt;p&gt;搜索模板search tempalte高级功能之一，可以将我们的一些搜索进行模板化，使用现有模板时传入指定的参数就可以了，避免编写重复代码。对常用的功能可以利用模板进行封装，使用时更简便。&lt;/p&gt;
&lt;p&gt;这点类似于我们编程时的接口封装，将一些细节处理的东西封装成接口，供别人调用，使用者就只需要关注参数和响应结果就行，这样可以更好地提高代码复用率。&lt;/p&gt;
&lt;p&gt;下面我们来看看最基本的几种用法&lt;/p&gt;
&lt;h4 id=&quot;参数替换&quot;&gt;参数替换&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search/template
{
  &quot;source&quot;: {
    &quot;query&quot;: {
      &quot;match&quot;: {
        &quot;{{field}}&quot;:&quot;{{value}}&quot;
      }
    }
  },
  &quot;params&quot;: {
    &quot;field&quot;:&quot;name&quot;,
    &quot;value&quot;:&quot;bye-bye&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该搜索模板编译后等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;:&quot;bye-bye&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用json格式的条件查询&quot;&gt;使用Json格式的条件查询&lt;/h4&gt;
&lt;p&gt;{{#toJson}}块内可以写稍微复杂一些的条件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search/template
{
  &quot;source&quot;: &quot;{\&quot;query\&quot;:{\&quot;match\&quot;: {{#toJson}}condition{{/toJson}}}}&quot;,
  &quot;params&quot;: {
    &quot;condition&quot;: {
      &quot;name&quot;:&quot;bye-bye&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该搜索模板编译后等同于如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;:&quot;bye-bye&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join语法&quot;&gt;join语法&lt;/h4&gt;
&lt;p&gt;join内的参数names可以写多个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search/template
{
  &quot;source&quot;: {
    &quot;query&quot;: {
      &quot;match&quot;: {
        &quot;name&quot;: &quot;{{#join delimiter=' '}}names{{/join delimiter=' '}}&quot;
      }
    }
  },
  &quot;params&quot;: {
    &quot;name&quot;:[&quot;gymbo&quot;,&quot;you are my sunshine&quot;,&quot;bye-bye&quot;]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该搜索模板编译后等同于如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;:&quot;gymbo you are my sunshine bye-bye&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;搜索模板的默认值设置&quot;&gt;搜索模板的默认值设置&lt;/h4&gt;
&lt;p&gt;可以对搜索模板进行一些默认值的设置，如{{^end}}500表示如果end参数为空，默认值为500&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search/template
{
  &quot;source&quot;:{
    &quot;query&quot;:{
      &quot;range&quot;:{
        &quot;likes&quot;:{
          &quot;gte&quot;:&quot;{{start}}&quot;,
          &quot;lte&quot;:&quot;{{end}}{{^end}}500{{/end}}&quot;
        }
      }
    }
  },
  &quot;params&quot;: {
    &quot;start&quot;:1,
    &quot;end&quot;:300
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该搜索模板编译后等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search
{
  &quot;query&quot;: {
    &quot;range&quot;: {
      &quot;likes&quot;: {
        &quot;gte&quot;: 1,
        &quot;lte&quot;: 300
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;条件判断&quot;&gt;条件判断&lt;/h4&gt;
&lt;p&gt;在Mustache语言中，它没有if/else这样的判断，但是你可以定section来跳过它如果那个变量是false还是没有被定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{{#param1}}
    &quot;This section is skipped if param1 is null or false&quot;
{{/param1}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：创建mustache scripts对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;POST _scripts/condition
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;mustache&quot;,
    &quot;source&quot;: 
    &quot;&quot;&quot;
        {
                &quot;query&quot;: {
              &quot;bool&quot;: {
                &quot;must&quot;: {
                  &quot;match&quot;: {
                    &quot;name&quot;: &quot;{{name}}&quot;
                  }
                },
                &quot;filter&quot;:{
                  {{#isLike}}
                    &quot;range&quot;:{
                      &quot;likes&quot;:{
                        {{#start}}
                          &quot;gte&quot;:&quot;{{start}}&quot;
                          {{#end}},{{/end}}
                        {{/start}}
                        {{#end}}
                          &quot;lte&quot;:&quot;{{end}}&quot;
                        {{/end}}
                      }
                    }
                  {{/isLike}}
                }
              }
            }
        }
    &quot;&quot;&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用mustache template查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET _search/template
{
    &quot;id&quot;: &quot;condition&quot;, 
    &quot;params&quot;: {
      &quot;name&quot;:&quot;gymbo&quot;,
      &quot;isLike&quot;:true,
      &quot;start&quot;:1,
      &quot;end&quot;:500
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是常用的几种搜索模板介绍，如果在大型项目，并且配置了专门的Elasticsearch工程师，就经常会用一些通用的功能进行模板化，开发业务系统的童鞋只需要使用模板即可。&lt;/p&gt;
&lt;h3 id=&quot;定制映射模板&quot;&gt;定制映射模板&lt;/h3&gt;
&lt;p&gt;ES有自己的规则对插入的数据进行类型映射，如10，会自动映射成long类型，&quot;10&quot;会自动映射成text，还会自带一个keyword的内置field。方便是很方便，但有时候这些类型不是我们想要的，比如我们的整数值10，我们期望是这个integer类型，&quot;10&quot;我们希望是keyword类型，这时候我们可以预先定义一个模板，插入数据时，相关的field就按我们预先定义的规则进行匹配，决定这个field值的类型。&lt;/p&gt;
&lt;p&gt;另外要声明一下，实际工作中编码规范一般严谨一些，所有的document都是预先定义好类型再执行数据插入的，哪怕是中途增加的field，也是先执行mapping命令，再插入数据的。&lt;/p&gt;
&lt;p&gt;但自定义动态映射模板也需要了解一下。&lt;/p&gt;
&lt;h4 id=&quot;默认的动态映射效果&quot;&gt;默认的动态映射效果&lt;/h4&gt;
&lt;p&gt;试着插入一条数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /test_index/type/1
{
  &quot;test_string&quot;:&quot;hello kitty&quot;,
  &quot;test_number&quot;:10
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看mapping信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /test_index/_mapping/type&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;响应如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;test_index&quot;: {
    &quot;mappings&quot;: {
      &quot;type&quot;: {
        &quot;properties&quot;: {
          &quot;test_number&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;test_string&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的动态映射规则，可能不是我们想要的。&lt;/p&gt;
&lt;p&gt;例如，我们希望数字类型的默认是integer类型，字符串默认是string类型，但是内置的field名字叫raw，不叫keyword，保留128个字符。&lt;/p&gt;
&lt;h4 id=&quot;动态映射模板&quot;&gt;动态映射模板&lt;/h4&gt;
&lt;p&gt;有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据新加入的field的默认的数据类型，来进行匹配，匹配某个预定义的模板&lt;/li&gt;
&lt;li&gt;根据新加入的field的名字，去匹配预定义的名字，或者去匹配一个预定义的通配符，然后匹配上某个预定义的模板&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;根据数据类型进行匹配&quot;&gt;根据数据类型进行匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /test_index
{
  &quot;mappings&quot;: {
    &quot;type&quot;: {
      &quot;dynamic_templates&quot;: [
        {
          &quot;integers&quot; : {
            &quot;match_mapping_type&quot;: &quot;long&quot;,
            &quot;mapping&quot;: {
              &quot;type&quot;:&quot;integer&quot;
            }
          }
        },
        {
          &quot;strings&quot; : {
            &quot;match_mapping_type&quot;: &quot;string&quot;,
            &quot;mapping&quot;: {
              &quot;type&quot;:&quot;text&quot;,
              &quot;fields&quot;: {
                &quot;raw&quot;: {
                  &quot;type&quot;: &quot;keyword&quot;,
                  &quot;ignore_above&quot;: 128
                }
              }
            }
          }
        }
      ]
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除索引，重新插入数据，查看mapping信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;test_index&quot;: {
    &quot;mappings&quot;: {
      &quot;type&quot;: {
        &quot;dynamic_templates&quot;: [
          {
            &quot;integers&quot;: {
              &quot;match_mapping_type&quot;: &quot;long&quot;,
              &quot;mapping&quot;: {
                &quot;type&quot;: &quot;integer&quot;
              }
            }
          },
          {
            &quot;strings&quot;: {
              &quot;match_mapping_type&quot;: &quot;string&quot;,
              &quot;mapping&quot;: {
                &quot;fields&quot;: {
                  &quot;raw&quot;: {
                    &quot;ignore_above&quot;: 128,
                    &quot;type&quot;: &quot;keyword&quot;
                  }
                },
                &quot;type&quot;: &quot;text&quot;
              }
            }
          }
        ],
        &quot;properties&quot;: {
          &quot;test_number&quot;: {
            &quot;type&quot;: &quot;integer&quot;
          },
          &quot;test_string&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;raw&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 128
              }
            }
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以按预计类型进行映射，符合预期。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按field名称进行映射&lt;/li&gt;
&lt;li&gt;&quot;long_&quot;开头的field，并且原本是long类型的，转换为integer类型&lt;/li&gt;
&lt;li&gt;&quot;string_&quot;开头的field，并且原本是string类型的，转换为string.raw类型&lt;br/&gt;&quot;_text&quot;结尾的field，并且原本是string类型的，保持不变&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /test_index
{
  &quot;mappings&quot;: {
    &quot;type&quot;: {
      &quot;dynamic_templates&quot;:[
       {
         &quot;long_as_integer&quot;: {
                 &quot;match_mapping_type&quot;:&quot;long&quot;,
           &quot;match&quot;: &quot;long_*&quot;,
           &quot;mapping&quot;:{
             &quot;type&quot;:&quot;integer&quot;
           }
         }
       },
       {
         &quot;string_as_raw&quot;: {
                 &quot;match_mapping_type&quot;:&quot;string&quot;,
           &quot;match&quot;: &quot;string_*&quot;,
           &quot;unmatch&quot;:&quot;*_text&quot;,
           &quot;mapping&quot;: {
              &quot;type&quot;:&quot;text&quot;,
              &quot;fields&quot;: {
                &quot;raw&quot;: {
                  &quot;type&quot;: &quot;keyword&quot;,
                  &quot;ignore_above&quot;: 128
                }
              }
            }
         }
       }
      ]
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /test_index/type/1
{
  &quot;string_test&quot;:&quot;hello kitty&quot;,
  &quot;long_test&quot;: 10,
  &quot;title_text&quot;:&quot;Hello everyone&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询mapping信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;test_index&quot;: {
    &quot;mappings&quot;: {
      &quot;type&quot;: {
        &quot;dynamic_templates&quot;: [
          {
            &quot;long_as_integer&quot;: {
              &quot;match&quot;: &quot;long_*&quot;,
              &quot;match_mapping_type&quot;: &quot;long&quot;,
              &quot;mapping&quot;: {
                &quot;type&quot;: &quot;integer&quot;
              }
            }
          },
          {
            &quot;string_as_raw&quot;: {
              &quot;match&quot;: &quot;string_*&quot;,
              &quot;unmatch&quot;: &quot;*_text&quot;,
              &quot;match_mapping_type&quot;: &quot;string&quot;,
              &quot;mapping&quot;: {
                &quot;fields&quot;: {
                  &quot;raw&quot;: {
                    &quot;ignore_above&quot;: 128,
                    &quot;type&quot;: &quot;keyword&quot;
                  }
                },
                &quot;type&quot;: &quot;text&quot;
              }
            }
          }
        ],
        &quot;properties&quot;: {
          &quot;long_test&quot;: {
            &quot;type&quot;: &quot;integer&quot;
          },
          &quot;string_test&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;raw&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 128
              }
            }
          },
          &quot;title_text&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果符合预期。&lt;/p&gt;
&lt;p&gt;在某些日志管理的场景中，我们可以定义好type，每天按日期创建一个索引，这种索引的创建就可以用到映射模板，把我们定义的映射关系全部做进去。&lt;/p&gt;
&lt;h3 id=&quot;高亮搜索&quot;&gt;高亮搜索&lt;/h3&gt;
&lt;p&gt;我们在浏览器上搜索文本时，发现我们输入的关键字有高亮显示，查看html源码就知道，高亮的部分是加了&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签的，ES也支持高亮搜索这种操作的，并且在返回的文档中自动加了&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签，兼容html5页面。&lt;/p&gt;
&lt;h4 id=&quot;highlight基本语法&quot;&gt;highlight基本语法&lt;/h4&gt;
&lt;p&gt;我们还是以音乐网站为案例，开始进行高亮搜索：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search 
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content&quot;: &quot;love&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;fields&quot;: {
      &quot;content&quot;: {}
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;highlight里面的参数即为高亮搜索的语法，指定高亮的字段为content，我们可以看到命中的Love里面带了&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;高亮标签，&lt;code&gt;&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;&lt;/code&gt;表现在html上会变成红色，所以说你的指定的field中，如果包含了那个搜索词的话，就会在那个field的文本中，对搜索词进行红色的高亮显示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;took&quot;: 35,
  &quot;timed_out&quot;: false,
  &quot;_shards&quot;: {
    &quot;total&quot;: 5,
    &quot;successful&quot;: 5,
    &quot;skipped&quot;: 0,
    &quot;failed&quot;: 0
  },
  &quot;hits&quot;: {
    &quot;total&quot;: 1,
    &quot;max_score&quot;: 0.2876821,
    &quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;music&quot;,
        &quot;_type&quot;: &quot;children&quot;,
        &quot;_id&quot;: &quot;5&quot;,
        &quot;_score&quot;: 0.2876821,
        &quot;_source&quot;: {
          &quot;id&quot;: &quot;1740e61c-63da-474f-9058-c2ab3c4f0b0a&quot;,
          &quot;author_first_name&quot;: &quot;Jean&quot;,
          &quot;author_last_name&quot;: &quot;Ritchie&quot;,
          &quot;author&quot;: &quot;Jean Ritchie&quot;,
          &quot;name&quot;: &quot;love somebody&quot;,
          &quot;content&quot;: &quot;love somebody, yes I do&quot;,
          &quot;language&quot;: &quot;english&quot;,
          &quot;tags&quot;: &quot;love&quot;,
          &quot;length&quot;: 38,
          &quot;likes&quot;: 3,
          &quot;isRelease&quot;: true,
          &quot;releaseDate&quot;: &quot;2019-12-22&quot;
        },
        &quot;highlight&quot;: {
          &quot;content&quot;: [
            &quot;&amp;lt;em&amp;gt;love&amp;lt;/em&amp;gt; somebody, yes I do&quot;
          ]
        }
      }
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;highlight下的字段可以指定多个，这样就可以在多个字段命中的关键词进行高亮显示，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search 
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content&quot;: &quot;love&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;fields&quot;: {
      &quot;name&quot;:{},
      &quot;content&quot;: {}
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三种高亮语法&quot;&gt;三种高亮语法&lt;/h4&gt;
&lt;p&gt;有三种高亮的语法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;plain highlight：使用standard Lucene highlighter，对简单的查询支持度非常好。&lt;/li&gt;
&lt;li&gt;unified highlight：默认的高亮语法，使用Lucene Unified Highlighter，将文本切分成句子，并对句子使用BM25计算词条的score，支持精准查询和模糊查询。&lt;/li&gt;
&lt;li&gt;fast vector highlighter：使用Lucene Fast Vector highlighter，功能很强大，如果在mapping中对field开启了term_vector，并设置了with_positions_offsets，就会使用该highlighter，对内容特别长的文本（大于1MB）有性能上的优势。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /music
{
  &quot;mappings&quot;: {
    &quot;children&quot;: {
      &quot;properties&quot;: {
        &quot;name&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;
        },
        &quot;content&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;analyzer&quot;: &quot;ik_max_word&quot;,
          &quot;term_vector&quot; : &quot;with_positions_offsets&quot;
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下，用plain highlight也就足够了，不需要做其他额外的设置&lt;br/&gt;如果对高亮的性能要求很高，可以尝试启用unified highlight&lt;br/&gt;如果field的值特别大，超过了1M，那么可以用fast vector highlight&lt;/p&gt;
&lt;h4 id=&quot;自定义高亮html标签&quot;&gt;自定义高亮html标签&lt;/h4&gt;
&lt;p&gt;我们知道高亮的默认标签是&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;，这个标签可以自己定义的，然后使用自己喜欢的样式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_search 
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;content&quot;: &quot;Love&quot;
    }
  },
  &quot;highlight&quot;: {
    &quot;pre_tags&quot;: [&quot;&amp;lt;tag1&amp;gt;&quot;],
    &quot;post_tags&quot;: [&quot;&amp;lt;/tag2&amp;gt;&quot;], 
    &quot;fields&quot;: {
      &quot;content&quot;: {
        &quot;type&quot;: &quot;plain&quot;
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;高亮片段fragment的设置&quot;&gt;高亮片段fragment的设置&lt;/h4&gt;
&lt;p&gt;针对一些很长的文本，我们不可能在页面上完整显示的，我们需要只显示有关键词的上下文即可，这里设置fragment就行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /_search
{
    &quot;query&quot; : {
        &quot;match&quot;: { &quot;content&quot;: &quot;friend&quot; }
    },
    &quot;highlight&quot; : {
        &quot;fields&quot; : {
            &quot;content&quot; : {&quot;fragment_size&quot; : 150, &quot;number_of_fragments&quot; : 3, &quot;no_match_size&quot;: 150 }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;fragment_size: 设置要显示出来的fragment文本判断的长度，默认是100。&lt;/p&gt;
&lt;p&gt;number_of_fragments：你可能你的高亮的fragment文本片段有多个片段，你可以指定就显示几个片段。&lt;/p&gt;
&lt;h3 id=&quot;地理位置&quot;&gt;地理位置&lt;/h3&gt;
&lt;p&gt;现在基于地理位置的app层出不穷，支持地理位置的组件也有不少，Elasticsearch也不例外，并且ES可以把地理位置、全文搜索、结构化搜索和分析结合到一起，我们来看一下。&lt;/p&gt;
&lt;h4 id=&quot;geo-point数据类型&quot;&gt;geo point数据类型&lt;/h4&gt;
&lt;p&gt;Elasticsearch基于地理位置的搜索，有一个专门的对象geo_point存储地理位置信息（经度，纬度），并且提供了一些基本的查询方法，如geo_bounding_box。&lt;/p&gt;
&lt;p&gt;建立geo_point类型的mapping&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /location
{
  &quot;mappings&quot;: {
    &quot;hotels&quot;: {
      &quot;properties&quot;: {
        &quot;location&quot;: {
          &quot;type&quot;: &quot;geo_point&quot;
        },
        &quot;content&quot;: {
          &quot;type&quot;: &quot;text&quot;
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;插入数据&quot;&gt;插入数据&lt;/h5&gt;
&lt;p&gt;推荐使用如下插入数据方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;#latitude：维度,longitude：经度
PUT /location/hotels/1
{
  &quot;content&quot;:&quot;7days hotel&quot;,
  &quot;location&quot;: {
    &quot;lon&quot;: 113.928619,
    &quot;lat&quot;: 22.528091
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有两种插入数据的方式，但特别容易搞混经纬度的位置，所以不是很推荐：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# location中括号内，前一个是经度，后一个是纬度
PUT /location/hotels/2
{
  &quot;content&quot;:&quot;7days hotel &quot;,
  &quot;location&quot;: [113.923567,22.523988]
}

# location中，前一个是纬度，后一个是经度
PUT /location/hotels/3
{
  &quot;text&quot;: &quot;7days hotel Orient Sunseed Hotel&quot;,
  &quot;location&quot;: &quot;22.521184, 113.914578&quot; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;查询方法&quot;&gt;查询方法&lt;/h5&gt;
&lt;p&gt;geo_bounding_box查询，查询某个矩形的地理位置范围内的坐标点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;query&quot;: {
     &quot;geo_bounding_box&quot;: {
      &quot;location&quot;: {
        &quot;top_left&quot;:{
          &quot;lon&quot;: 112,
          &quot;lat&quot;: 23
        },
        &quot;bottom_right&quot;:{
          &quot;lon&quot;: 114,
          &quot;lat&quot;: 21
        }
      }
    } 
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;常见查询场景&quot;&gt;常见查询场景&lt;/h4&gt;
&lt;h5 id=&quot;geo_bounding_box方式&quot;&gt;geo_bounding_box方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match_all&quot;: {}}
      ],
      &quot;filter&quot;: {
        &quot;geo_bounding_box&quot;: {
          &quot;location&quot;: {
            &quot;top_left&quot;:{
              &quot;lon&quot;: 112,
              &quot;lat&quot;: 23
            },
            &quot;bottom_right&quot;:{
              &quot;lon&quot;: 114,
              &quot;lat&quot;: 21
            }
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;geo_polygon方式三个点组成的多边形（三角形）区域&quot;&gt;geo_polygon方式,三个点组成的多边形（三角形）区域&lt;/h5&gt;
&lt;p&gt;支持多边形，只是这个过滤器使用代价很大，尽量少用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match_all&quot;: {}}
      ],
      &quot;filter&quot;: {
        &quot;geo_polygon&quot;: {
          &quot;location&quot;: {
            &quot;points&quot;: [
              {&quot;lon&quot;: 115,&quot;lat&quot;: 23},
              {&quot;lon&quot;: 113,&quot;lat&quot;: 25},
              {&quot;lon&quot;: 112,&quot;lat&quot;: 21}
            ]
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;geo_distance方式&quot;&gt;geo_distance方式&lt;/h5&gt;
&lt;p&gt;根据当前位置的距离进行搜索，非常实用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match_all&quot;: {}}
      ],
      &quot;filter&quot;: {
        &quot;geo_distance&quot;: {
          &quot;distance&quot;: 500, 
          &quot;location&quot;: {
            &quot;lon&quot;: 113.911231,
            &quot;lat&quot;: 22.523375
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;按距离排序&quot;&gt;按距离排序&lt;/h5&gt;
&lt;p&gt;根据当前位置进行条件搜索，会指定一个距离的上限，2km或5km，并且符合条件查询的结果显示与当前位置的距离（可以指定单位），并且按从近到远排序，这个是非常常用的场景。&lt;/p&gt;
&lt;p&gt;请求示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match_all&quot;: {}}
      ],
      &quot;filter&quot;: {
        &quot;geo_distance&quot;: {
          &quot;distance&quot;: 2000, 
          &quot;location&quot;: {
            &quot;lon&quot;: 113.911231,
            &quot;lat&quot;: 22.523375
          }
        }
      }
    }
  },
  &quot;sort&quot;: [
    {
      &quot;_geo_distance&quot;: {
        &quot;location&quot;: { 
          &quot;lon&quot;: 113.911231,
          &quot;lat&quot;: 22.523375
        },
        &quot;order&quot;:         &quot;asc&quot;,
        &quot;unit&quot;:          &quot;m&quot;, 
        &quot;distance_type&quot;: &quot;plane&quot; 
      }
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;filter.geo_distance.distance: 最大的距离，这里是2000m&lt;/li&gt;
&lt;li&gt;_geo_distance: 固定写法，下面为指定位置的经纬度&lt;/li&gt;
&lt;li&gt;order: 排序方式，asc或desc&lt;/li&gt;
&lt;li&gt;unit: 距离的单位，m/km都行&lt;/li&gt;
&lt;li&gt;distance_type: 计算距离的方式，sloppy_arc (默认值), arc (精准的) and plane (最快速的)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;响应如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&quot;hits&quot;: [
      {
        &quot;_index&quot;: &quot;location&quot;,
        &quot;_type&quot;: &quot;hotels&quot;,
        &quot;_id&quot;: &quot;3&quot;,
        &quot;_score&quot;: null,
        &quot;_source&quot;: {
          &quot;text&quot;: &quot;7days hotel Orient Sunseed Hotel&quot;,
          &quot;location&quot;: &quot;22.521184, 113.914578&quot;
        },
        &quot;sort&quot;: [
          421.35435857277366
        ]
      },
      {
        &quot;_index&quot;: &quot;location&quot;,
        &quot;_type&quot;: &quot;hotels&quot;,
        &quot;_id&quot;: &quot;2&quot;,
        &quot;_score&quot;: null,
        &quot;_source&quot;: {
          &quot;content&quot;: &quot;7days hotel&quot;,
          &quot;location&quot;: [
            113.923567,
            22.523988
          ]
        },
        &quot;sort&quot;: [
          1268.8952707727062
        ]
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sort里面的内容，就是与当前位置的地面距离，单位是m。&lt;/p&gt;
&lt;h5 id=&quot;统计我当前位置几个范围内酒店的数量&quot;&gt;统计我当前位置几个范围内酒店的数量&lt;/h5&gt;
&lt;p&gt;unit表示距离单位，常用的是mi和km。&lt;/p&gt;
&lt;p&gt;distance_type表示计算距离的方式，sloppy_arc (默认值), arc (精准的) and plane (最快速的)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /location/hotels/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;group_by_distance&quot;: {
      &quot;geo_distance&quot;: {
        &quot;field&quot;: &quot;location&quot;,
        &quot;origin&quot;: {
          &quot;lon&quot;: 113.911231,
          &quot;lat&quot;: 22.523375
        },
        &quot;unit&quot;: &quot;mi&quot;, 
        &quot;distance_type&quot;: &quot;arc&quot;, 
        &quot;ranges&quot;: [
          {&quot;from&quot;: 0,&quot;to&quot;: 500},
          {&quot;from&quot;: 500,&quot;to&quot;: 1500},
          {&quot;from&quot;: 150,&quot;to&quot;: 2000}
        ]
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇简单介绍了一下搜索模板、映射模板、高亮搜索和地理位置的简单玩法，有些ES相关的项目做得比较深的，搜索模板和映射模板用处还是很大的。高亮搜索一般体现在浏览器搜索引擎上，地理位置的应用挺有意思，也可以参与到基于Location的APP应用当中。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 May 2020 22:57:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>概要 本篇主要介绍一下搜索模板、映射模板、高亮搜索和地理位置的简单玩法。 标准搜索模板 搜索模板search tempalte高级功能之一，可以将我们的一些搜索进行模板化，使用现有模板时传入指定的参数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/12898603.html</dc:identifier>
</item>
<item>
<title>机器学习中的聚类算法演变及学习笔记 - FinTecher</title>
<link>http://www.cnblogs.com/zhengzhicong/p/12895421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengzhicong/p/12895421.html</guid>
<description>&lt;p&gt;本文主要介绍机器学习中聚类算法的演变路径。一、相似性衡量方法 二、基于划分的聚类 三、基于密度的聚类 四、基于概率模型的聚类 五、 基于层次的聚类 六、基于网格的聚类 七、其他角度的聚类 八、聚类算法的性能度量&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;205.939517093&quot;&gt;
&lt;p&gt;【说在前面】本人博客新手一枚，象牙塔的老白，职业场的小白。以下内容仅为个人见解，欢迎批评指正，不喜勿喷！[认真看图][认真看图]&lt;/p&gt;
&lt;p&gt;【补充说明】聚类算法可以作为独立方法将数据聚成不同簇，也可以作为数据挖掘任务（例如分类、关联规则等）的预处理！&lt;/p&gt;
&lt;p&gt;【补充说明】聚类算法与分类算法的主要区别在于训练时的样本有无标签，聚类算法无监督学习，分类算法有监督学习！&lt;/p&gt;
&lt;p&gt;【再说一句】本文主要介绍机器学习中聚类算法的演变路径，和往常一样，不会详细介绍各算法的具体实现，望理解！&lt;/p&gt;
&lt;h2&gt;一、相似性衡量方法&lt;/h2&gt;
&lt;h3&gt;1. 基于距离&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;闵可夫斯基距离（Minkowski Distance）：计算距离的通用的公式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/643534/201808/643534-20180803232744763-106254771.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;曼哈顿距离（即城市块距离Manhattan distance）：h=1（例如用于L1正则化等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/643534/201808/643534-20180803233908437-1844234831.png&quot; alt=&quot;&quot; width=&quot;339&quot; height=&quot;37&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;欧几里德距离（用的比较多）：h=2（例如用于L2正则化等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/643534/201808/643534-20180803234238647-1687102751.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 其他距离：例如核函数距离K(x,y)、DTW距离、Mahalanobis距离等&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. 基于相似系数&lt;/h3&gt;
&lt;p&gt;例如余弦相似度等，主要优势在于不受原线性变换的影响，可以轻松地转换为距离，但其运算速度相对较慢。&lt;/p&gt;
&lt;h2&gt;二、基于划分的聚类&lt;/h2&gt;
&lt;h3&gt;1. K-Means聚类&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;主要步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;（1）&lt;/span&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;确定要聚类的数量K，并随机初始化K个簇的中心点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（2）将每个样本分配到与其距离最近的中心点所在的簇（这里采用欧氏距离）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;（3）计算每一个簇内所有样本点的平均值，作为该簇的新中心点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;迭代重复以上这些步骤，直到各簇中心点在迭代过程中变化不大（即小于设定的阈值）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515215548907-2046237789.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;K-Means聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;原理简单，实现容易，收敛速度快&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;参数只有K，计算复杂度相对较低&lt;/li&gt;
&lt;li&gt;模型可解释性强&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;K-Means聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要事先确定聚类的簇数（即K值）&lt;/li&gt;
&lt;li&gt;对簇中心初始值的选取比较敏感&lt;/li&gt;
&lt;li&gt;对噪声和离群点很敏感&lt;/li&gt;
&lt;li&gt;采用迭代方法，容易陷入局部最优&lt;/li&gt;
&lt;li&gt;适用场景有限，不能解决非凸数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;2. K值的选取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;根据数据的可视化分布情况，结合对业务场景理解，人工选定K值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;Elbow method（即手肘法则）：通过WSS随聚类数量K的变化曲线，取手肘位置的K（例如Gap Statistic、Jump Statistic等）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;通过计算类内内聚程度和类间分离度来确定K（例如使用平均轮廓系数、类内距离/类间距离等）&lt;/li&gt;
&lt;li&gt;其他：例如使用ISODATA、Gap Statistic公式、计算不同K值下的BIC/AIC、&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;X-means clustering（AIC/BIC）等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;3. K-Means聚类变体：考虑到K-Means对簇中心初始值的选取比较敏感&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;例如k-means++、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;intelligent k-means、genetic k-means、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;CLARANS&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这里以常见的k-means++为例，进行介绍。&lt;/p&gt;
&lt;p&gt;k-means++按照如下的思想选取K个聚类中心：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在选取第一个聚类中心(n=1)时，同样是通过随机的方法。&lt;/li&gt;
&lt;li&gt;在选取第n+1个聚类中心时，距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;4. K-Means聚类变体：考虑到k-means对噪声和离群值很敏感&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;例如k-medoids、k-medians等。这里以常见的k-medians为例，进行介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;k-medians对于中心点的选取方式是中位值。原因在于，噪声和离群点对中位值的变化影响不大。但是需要排序，速度较慢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;5. K-Means聚类变体：考虑到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;k-means不适用于类别型数据&lt;/h3&gt;
&lt;p&gt;例如k-modes等。这里以常见的k-modes为例，进行介绍。&lt;/p&gt;
&lt;p&gt;k-modes算法采用差异度来代替k-means算法中的距离。k-modes算法中差异度越小，则表示距离越小。&lt;/p&gt;
&lt;h3&gt;6. K-Means聚类变体：考虑到k-means不能解决非凸数据&lt;/h3&gt;
&lt;p&gt;例如kernel k-means、谱聚类等。这里以常见的kernel k-means为例，进行介绍。&lt;/p&gt;
&lt;p&gt;kernel k-means通过一个非线性映射，将输入空间中的数据点映射到一个高维特征空间中，使得样本在核空间线性可分，在特征空间聚类。&lt;/p&gt;
&lt;p&gt;值得一提的是，谱聚类算法是建立在图论中的谱图理论基础上，其本质是将聚类问题转化为图的最优划分问题，是一种点对聚类算法。&lt;/p&gt;
&lt;h2&gt;三、基于密度的聚类&lt;/h2&gt;
&lt;h3&gt;1. Mean-Shift聚类&lt;/h3&gt;
&lt;p&gt;均值漂移聚类是基于滑动窗口的算法，寻找数据点的密集区域。类似爬山，每一次迭代都向密度更高的区域移动，直到收敛。&lt;/p&gt;
&lt;p&gt;主要步骤如下：&lt;/p&gt;
&lt;p&gt;（1）确定滑动窗口半径r，以随机选取的中心点C、半径为r的圆形滑动窗口开始滑动。 &lt;/p&gt;
&lt;p&gt;（2）每一次滑动到新区域，计算窗口内的均值作为中心点，窗口内的点数量作为密度。在每一次移动中，窗口会想密度更高的区域移动。&lt;/p&gt;
&lt;p&gt;（3）移动窗口，直到窗口内的密度不再增加为止。&lt;/p&gt;
&lt;p&gt;其中，步骤1到3会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数据点所在的滑动窗口进行聚类。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515230458441-966116166.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Mean-Shift聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同于K-Means算法，均值漂移聚类算法不需要知道有多少簇，能够自动发现&lt;/li&gt;
&lt;li&gt;基于密度的算法，相比于K-Means受均值影响较小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mean-Shift聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;窗口半径r的选择需要仔细考虑&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. DBSCAN聚类&lt;/h3&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;DBSCAN的聚类定义很简单，由密度可达关系导出的最大密度相连的样本集合，即为最终聚类的一个簇。&lt;/p&gt;
&lt;p&gt;主要步骤如下：&lt;/p&gt;
&lt;p&gt;（1）首先任意选择一个没有类别的核心对象作为种子，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。&lt;/p&gt;
&lt;p&gt;（2）接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇。&lt;/p&gt;
&lt;p&gt;一直运行到所有核心对象都有类别为止。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515230226899-874961541.png&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;224&quot;/&gt;&lt;/div&gt;
DBSCAN聚类的优点：&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;不需要知道有多少簇，能够自动发现&lt;/li&gt;
&lt;li&gt;可以在带有噪声的空间数据库中发现任意形状的簇&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DBSCAN聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要确定Eps领域半径、MinPts在领域中点的最少个数（即密度）这两个全局参数，较为敏感&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3. DBSCAN聚类的变体&lt;/h3&gt;
&lt;p&gt;OPTICS聚类通过优先对高密度进行搜索，然后根据高密度的特点设置参数，改善了DBSCAN的不足。&lt;/p&gt;
&lt;p&gt;当然还有其他算法，例如DENCLUE聚类等。&lt;/p&gt;
&lt;h2&gt;四、基于概率模型的聚类&lt;/h2&gt;
&lt;h3 id=&quot;4-用高斯混合模型gmm的最大期望em聚类&quot;&gt;1. 用高斯混合模型（GMM）的最大期望（EM）聚类&lt;/h3&gt;
&lt;p&gt;GMM聚类采用概率模型来表达原型，即通过统计得到每个样本点属于各个类的概率，而不是判定它完全属于一个类，也会被称为软聚类。&lt;/p&gt;
&lt;p&gt;主要步骤如下：&lt;/p&gt;
&lt;p&gt;（1）选择簇的数量，并随机初始化每个簇的高斯分布参数（即均值和方差）。&lt;/p&gt;
&lt;p&gt;（2）给定每个簇的高斯分布，计算每个数据点属于每个簇的概率。一个点越靠近高斯分布的中心就越可能属于该簇。&lt;/p&gt;
&lt;p&gt;（3）计算高斯分布参数，使概率最大化（EM最大期望），可用数据点概率的加权计算这些新的参数，权重就是数据点属于该簇的概率。&lt;/p&gt;
&lt;p&gt;重复迭代步骤2和3，直到迭代中的变化不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515234358394-897210059.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;249&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GMM聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用均值和标准差，簇可以呈现出椭圆形，而不是仅仅限制于圆形。&lt;/li&gt;
&lt;li&gt;使用概率，一个数据点可以属于多个簇。例如数据点X可以有百分之20的概率属于A簇，百分之80的概率属于B簇。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GMM聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行效率不高，特别是分布数量很多并且数据量很少的时候&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. 其他方法&lt;/h3&gt;
&lt;p&gt;例如基于神经网络模型的聚类SOM、基于统计学的聚类COBWeb等。&lt;/p&gt;
&lt;h2&gt;五、基于层次的聚类&lt;/h2&gt;
&lt;p&gt;对给定的数据集进行层次似的分解，直到某种条件满足为止。具体又可分为“自底向上”和“自顶向下”两种方案。&lt;/p&gt;
&lt;h3&gt;1. AGNES聚类&lt;/h3&gt;
&lt;p&gt;是一种自底向上聚合策略的层次聚类算法。&lt;/p&gt;
&lt;p&gt;主要步骤如下：&lt;/p&gt;
&lt;p&gt;（1）先将数据集中的每个样本看做是一个初始聚类簇。&lt;/p&gt;
&lt;p&gt;（2）然后在算法运行的每一步中，找出距离最近的两个聚类簇进行合并。该过程不断重复，直至达到预设的聚类簇个数。&lt;/p&gt;
&lt;p&gt;其中，如何计算簇之间的距离，并进行合并：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单链接算法：两个簇中距离最近的样本的距离（最小距离）&lt;/li&gt;
&lt;li&gt;全链接算法：两个簇中距离最远的样本的距离（最大距离）&lt;/li&gt;
&lt;li&gt;均链接算法：两个簇中每两个样本之间的距离相加求平均的距离（平均距离）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200515235950078-283608847.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AGNES聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;距离和规则的相似度容易定义，限制少&lt;/li&gt;
&lt;li&gt;不需要预先制定聚类数&lt;/li&gt;
&lt;li&gt;可以发现类的层次关系&lt;/li&gt;
&lt;li&gt;可以聚类成其它形状&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AGNES聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算复杂度太高 &lt;/li&gt;
&lt;li&gt;奇异值也能产生很大影响&lt;/li&gt;
&lt;li&gt;算法很可能聚类成链状&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. BIRCH聚类&lt;/h3&gt;
&lt;p&gt;BIRCH算法是个树形结构，树的每一个节点是由若干个聚类特征CF组成。BIRCH算法比较适合于数据量大，类别数K也比较多的情况。&lt;/p&gt;
&lt;p&gt;对于CF Tree，一般有几个重要参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数是每个内部节点的最大CF数B&lt;/li&gt;
&lt;li&gt;第二个参数是每个叶子节点的最大CF数L&lt;/li&gt;
&lt;li&gt;第三个参数是叶节点每个CF的最大样本半径阈值T&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200516001253970-1516393949.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BIRCH聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不用输入聚类数K值&lt;/li&gt;
&lt;li&gt;节约内存，所有的样本都在磁盘上，CF Tree仅仅存了CF节点和对应的指针&lt;/li&gt;
&lt;li&gt;聚类速度快，只需要单遍扫描数据集就能建立CF Tree，CF Tree的增删改都很快&lt;/li&gt;
&lt;li&gt;可以识别噪音点，还可以对数据集进行初步分类的预处理 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BIRCH聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BIRCH的调参较为复杂，几个参数对CF Tree的最终形式影响很大&lt;/li&gt;
&lt;li&gt;由于CF Tree对每个节点的CF个数有限制，导致聚类的结果可能和真实的类别分布不同&lt;/li&gt;
&lt;li&gt;对高维特征的数据聚类效果不好（如果 n_features大于20，通常使用MiniBatchKMeans会更好）&lt;/li&gt;
&lt;li&gt;如果数据集的分布簇不是类似于超球体，或者说不是凸的，则聚类效果不好&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3. 其他方法&lt;/h3&gt;
&lt;p&gt;例如Diana、ROCK、CURE、CAMELEON等。&lt;/p&gt;
&lt;h2&gt;六、基于网格的聚类&lt;/h2&gt;
&lt;p&gt;核心原理就是：&lt;/p&gt;
&lt;p&gt;（1）将数据空间划分为网格单元，将数据对象集映射到网格单元中，并计算每个单元的密度。&lt;/p&gt;
&lt;p&gt;（2）根据预设的阈值判断每个网格单元是否为高密度单元，由邻近的稠密单元组形成”类“。&lt;/p&gt;
&lt;p&gt;网格聚类的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行效率高，其速度只依赖于数据空间中每个维上单元的个数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网格聚类的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对参数敏感&lt;/li&gt;
&lt;li&gt;无法处理不规则分布的数据&lt;/li&gt;
&lt;li&gt;维数灾难&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;STING、CLIQUE、WaveCluster等是该类方法中的代表性算法。以下是CLIQUE的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200516002641872-479226413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;七、其他角度的聚类&lt;/h2&gt;
&lt;p&gt;例如基于约束的聚类（COD）、基于图网络的聚类（图团体检测）等。&lt;/p&gt;
&lt;h2&gt;八、聚类算法的性能度量&lt;/h2&gt;
&lt;p&gt;大佬对常用的聚类算法从可伸缩性、适合的数据类型、高维性、异常数据的抗干扰度、聚类形状和算法效率6个方面进行了综合性能评价。&lt;/p&gt;
&lt;p&gt;还有一些对聚类的评测指标，这里不打算展开介绍了。个人感觉通过聚类来辅助具体业务场景的分析会比较重要，就像开头说的那样，聚类算法可以作为独立方法将数据聚成不同簇，也可以作为数据挖掘任务（例如分类、关联规则等）的预处理。这里要提一嘴的是，很多聚类算法都已经被封装在sklearn中，方便调用。&lt;/p&gt;
&lt;p&gt;当然，聚类算法有很多的应用场景，例如目标用户群体分类、异常值检测等。说到这里，我接着想写一个“异常检测”专题了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200516004718446-100592247.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;337&quot;/&gt; &lt;/p&gt;
&lt;p&gt;如果您对数据挖掘感兴趣，欢迎浏览我的另几篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12728491.html&quot;&gt;数据挖掘比赛/项目全流程介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对智能推荐感兴趣，欢迎先浏览我的另几篇随笔：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12817941.html&quot;&gt;智能推荐算法演变及学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对人工智能算法感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12670260.html&quot;&gt;人工智能新手入门学习路线和学习资源合集（含AI综述/python/机器学习/深度学习/tensorflow）&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12875348.html&quot;&gt;人工智能领域常用的开源框架和库（含机器学习/深度学习/强化学习/知识图谱/图神经网络）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的应届毕业生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650878.html&quot;&gt;如果你是一个计算机领域的应届生，你如何准备求职面试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的本科生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650191.html&quot;&gt;如果你是一个计算机领域的本科生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的研究生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650369.html&quot;&gt;如果你是一个计算机领域的研究生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对金融科技感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12657428.html&quot;&gt;如果你想了解金融科技，不妨先了解金融科技有哪些可能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后博主将持续分享各大算法的学习思路和学习笔记：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12641421.html&quot;&gt;hello world: 我的博客写作思路&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 15 May 2020 17:46:00 +0000</pubDate>
<dc:creator>FinTecher</dc:creator>
<og:description>本文主要介绍机器学习中聚类算法的演变路径。一、相似性衡量方法 二、基于划分的聚类 三、基于密度的聚类 四、基于概率模型的聚类 五、 基于层次的聚类 六、基于网格的聚类 七、其他角度的聚类 八、聚类算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhengzhicong/p/12895421.html</dc:identifier>
</item>
<item>
<title>Mybatis 快速入门(XML方式)第一天 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/12895291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/12895291.html</guid>
<description>&lt;h2&gt;架构原理图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515233953739-783515663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;说明&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;mybatis配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;SqlMapConfig.xml，此文件为mybatis的全局配置文件，配置了mybatis的运行环境等信息&lt;/li&gt;
&lt;li&gt;XXXMapper.xml，此文件作为mybatis的sql映射文件，文件中配置了操作数据库的CRUD语句。需要在SqlMapConfig.xml中加载&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;SqlSessionFactory&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过mybatis环境等配置信息构造SqlSessionFactory，既会话工厂&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;***跟底层源码查看创建SqlSessionFactory流程***&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;注：底层如何获取标签值，请自行研究(&lt;span&gt;&lt;strong&gt;剧透：for循环遍历XML获取标签中的值，然后放入Map&lt;/strong&gt;&lt;/span&gt;)！~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516000220224-175903583.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;SqlSession&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过会员工厂创建SqlSession即会话，程序通过SqlSession会话接口对数据库进行CRUD操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;Executor执行器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　mybatis底层自定义了Executor执行器接口来具体操作数据库，Executor接口有两个实现，一个是基本执行器(默认)，一个缓存执行器，SqlSession底层是通过executor接口操作数据库&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Mapped Statement&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　他是mybatis一个底层封装对象，包装了mybatis配置信息及XXXMapper.xml映射文件等。XXXMapper.xml文件中一个个&lt;span&gt;&lt;strong&gt;select/insert/update/delete标签对应一个Mapped Statement对象&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;原始JDBC代码&lt;/h2&gt;
&lt;p&gt;　　原始JDBC和mybatis操作数据库数据，与上面架构图流程相对应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JDBCTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        PreparedStatement preparedStatement &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ResultSet resultSet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载数据库驱动&lt;/span&gt;
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过驱动管理类获取数据库链接connection = DriverManager&lt;/span&gt;
            connection =&lt;span&gt; DriverManager.getConnection(
                              &lt;/span&gt;&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;&lt;span&gt;,
                             &lt;/span&gt;&quot;root&quot;&lt;span&gt;, 
                              &lt;/span&gt;&quot;root&quot;&lt;span&gt;
                              );

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义sql语句 ?表示占位符&lt;/span&gt;
            String sql = &quot;select * from user where username = ?&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取预处理 statement&lt;/span&gt;
            preparedStatement =&lt;span&gt; connection.prepareStatement(sql);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的&lt;/span&gt;
            preparedStatement.setString(1, &quot;王五&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向数据库发出 sql 执行查询，查询出结果集&lt;/span&gt;
            resultSet =&lt;span&gt; preparedStatement.executeQuery();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历查询结果集&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (resultSet.next()) {
                System.out.println(
                                  resultSet.getString(&lt;/span&gt;&quot;id&quot;&lt;span&gt;) 
                                  &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; 
                                  resultSet.getString(&lt;/span&gt;&quot;username&quot;&lt;span&gt;)
                     );
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放资源&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (resultSet != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    resultSet.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
                    e.printStackTrace();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preparedStatement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    preparedStatement.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
                    e.printStackTrace();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block e.printStackTrace();&lt;/span&gt;
&lt;span&gt;                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;表结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515143610174-1925339717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 表数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515143644747-1004000042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Mybatis环境搭建 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515212923124-1659622180.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515212953441-1054712790.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515213111187-1505174220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515213155000-815498431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加依赖&lt;/h3&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.cyb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;war&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis Maven Webapp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mybatis依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.4.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mysql依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.0.20&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 单元测试 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;finalName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;finalName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SqlMapConfig.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入外部配置文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;db.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数据库链接相关 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${db.driver}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${db.url}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${db.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${db.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加映射文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;UserMapper.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;db.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.driver=com.mysql.jdbc.Driver
db.url=jdbc:mysql://127.0.0.1:3306/cyb
db.username=root
db.password=root&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;UserMapper.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; namespace:为了分类管理映射文件中的MappedStatement &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;queryUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.cyb.mybatis.demo.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user where id = #{id} 
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;User.java&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.mybatis.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birthday;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getBirthday() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; birthday;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBirthday(Date birthday) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birthday =&lt;span&gt; birthday;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSex() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sex) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, birthday=&quot; + birthday + &quot;, sex=&quot; + sex + &quot;, address=&quot;
                + address + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;MybatisDemo.java&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cyb.mybatis.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MybatisDemo {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactory sqlSessionFactory;

    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定全局配置文件路径&lt;/span&gt;
        String resource = &quot;SqlMapConfig.xml&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载资源文件(包括全局文件和映射文件)&lt;/span&gt;
        InputStream inputStream =&lt;span&gt; Resources.getResourceAsStream(resource);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用构建者模式创建SqlSessionFactory&lt;/span&gt;
        sqlSessionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelect() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由SqlSessionFactory工厂去创建SqlSession(会话)&lt;/span&gt;
        SqlSession sqlSession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用SqlSession接口，去实现数据库的CRUD&lt;/span&gt;
        User user = sqlSession.selectOne(&quot;test.queryUserById&quot;, 1&lt;span&gt;);
        System.out.println(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;span&gt;        sqlSession.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;项目结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515232241464-1047273885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515232718319-1832655494.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;功能实现&lt;/h2&gt;
&lt;h3&gt;根据用户id查询一个用户信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515232833403-1449515646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516001020479-1724210812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515232917910-1380009987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200515232938292-1768758627.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;根据用户名称模糊查询用户信息列表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516001546723-1261542208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516001615815-1227275477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加用户&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516002220600-510029973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516002300697-900616637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;更新用户&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516002626543-226491618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516002842198-408016985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516003118794-1303553038.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;删除用户&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516003403678-1302397024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516003610917-1155122959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202005/1504448-20200516003837209-1280420072.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 May 2020 16:41:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 架构原理图 说明 mybatis配置文件 SqlMapConfig.xml，此文件为mybatis的全局配置文件，配置了mybatis的运行环境等信息 XXXMapper.xml，此文件作为my</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/12895291.html</dc:identifier>
</item>
<item>
<title>高通滤波法、微分算子法、神经网络方法实现边缘检测 - TimDyh</title>
<link>http://www.cnblogs.com/timdyh/p/12897833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timdyh/p/12897833.html</guid>
<description>&lt;p&gt;边缘检测（Edge detection）是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。本文使用多种不同的方法，实现对 Lena 肖像的边缘检测，研究分析各算法的效果和优缺点。所涉及的方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;高通滤波法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;理想高通滤波器&lt;/li&gt;
&lt;li&gt;Butterworth 高通滤波器&lt;/li&gt;
&lt;li&gt;指数高通滤波器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分算子法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Roberts 算子&lt;/li&gt;
&lt;li&gt;Sobel 算子&lt;/li&gt;
&lt;li&gt;Laplacian 算子&lt;/li&gt;
&lt;li&gt;Canny 算子&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;神经网络方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HED 算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;高通滤波法&quot;&gt;高通滤波法&lt;/h2&gt;
&lt;p&gt;图像中的边缘或线条等细节部分与图像频谱的高频分量相对应，因此采用高通滤波让高频分量顺利通过，使图像的边缘或线条细节变得清楚，实现边缘提取和图像锐化。&lt;/p&gt;
&lt;p&gt;常见的高通滤波器包括：理想高通滤波器、Butterworth 高通滤波器、指数高通滤波器等。&lt;/p&gt;
&lt;h4 id=&quot;理想高通滤波器&quot;&gt;理想高通滤波器&lt;/h4&gt;
&lt;p&gt;理想高通滤波器的传递函数 &lt;span class=&quot;math inline&quot;&gt;\(H(u, v)\)&lt;/span&gt; 满足下式：&lt;/p&gt;
&lt;p&gt;\[H(u,v) = \begin{cases} 1, &amp;amp;D(u,v)&amp;gt;D_0 \cr 0, &amp;amp;D(u,v) \leq D_0 \end{cases} \]&lt;/p&gt;
&lt;p&gt;理想高通滤波器只是一种理想状况下的滤波器，不能用实际的电子器件实现。&lt;/p&gt;
&lt;h4 id=&quot;butterworth-高通滤波器&quot;&gt;Butterworth 高通滤波器&lt;/h4&gt;
&lt;p&gt;Butterworth 高通滤波器的传递函数 &lt;span class=&quot;math inline&quot;&gt;\(H(u,v)\)&lt;/span&gt; 如下：&lt;/p&gt;
&lt;p&gt;\[H(u,v)=\frac{1}{1+[D_0/D(u,v)]^{2n}} \]&lt;/p&gt;
&lt;p&gt;式中，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 为阶数，&lt;span class=&quot;math inline&quot;&gt;\(D_0\)&lt;/span&gt; 为截止频率。&lt;/p&gt;
&lt;p&gt;Butterworth 高通滤波器在高低频率间的过渡比较平滑，所以由其得到的输出图像的振铃现象不明显。&lt;/p&gt;
&lt;h4 id=&quot;指数高通滤波器&quot;&gt;指数高通滤波器&lt;/h4&gt;
&lt;p&gt;指数高通滤波器的传递函数 &lt;span class=&quot;math inline&quot;&gt;\(H(u,v)\)&lt;/span&gt; 如下：&lt;/p&gt;
&lt;p&gt;\[H(u,v)=\exp\{-[\frac{D_0}{D(u,v)}]^n\} \]&lt;/p&gt;
&lt;p&gt;式中，变量 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 控制从原点算起的传递函数 &lt;span class=&quot;math inline&quot;&gt;\(H(u,v)\)&lt;/span&gt; 的增长率。&lt;/p&gt;
&lt;p&gt;指数高通滤波器的另一种常用的传递函数如下式所示：&lt;/p&gt;
&lt;p&gt;\[H(u,v)=\exp\{[\ln(\frac{1}{\sqrt 2})][\frac{D_0}{D(u,v)}]^n\} \]&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;为了在频率域中实现高通滤波，先通过傅里叶变换得到图像的频谱，根据不同滤波器的不同传递函数，对频率进行相应的过滤，最后再对其进行傅里叶反变换，得到滤波后的图像。&lt;/p&gt;
&lt;h4 id=&quot;傅里叶变换&quot;&gt;傅里叶变换&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;img = plt.imread('images/lena.bmp')
fft_shift = np.fft.fftshift(np.fft.fft2(img))   # 变换后将零频分量移到频谱中心
fft_img = np.log(np.abs(fft_shift))                             # 可视化
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;实现三种滤波器&quot;&gt;实现三种滤波器&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def distance(shape):         # 计算每个像素到中心原点的距离
    n, m = shape
    u = np.arange(n)
    v = np.arange(m)
    u, v = np.meshgrid(u, v)
    return np.sqrt((u - n//2)**2 + (v - m//2)**2)
    
def ideal_filter(shape, d0):
    d = distance(shape)
    mask = d &amp;gt; d0
    return mask.astype(int)

def butterworth_filter(shape, d0, order=1):
    d = distance(shape)
    mask = 1 / (1 + (d0 / d)**(2 * order))
    return mask

def exponential_filter(shape, d0, order=1):
    d = distance(shape)
    mask = np.exp(-(d0 / d)**order)
    return mask
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;滤波后进行傅里叶反变换&quot;&gt;滤波后进行傅里叶反变换&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;ifft_shift = np.fft.ifftshift(fft_shift * mask)
ifft_img = np.abs(np.fft.ifft2(ifft_shift))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行结果及分析&quot;&gt;运行结果及分析&lt;/h3&gt;
&lt;p&gt;下图中，从上到下依次展示了使用理想高通滤波器、Butterworth 高通滤波器和指数高通滤波器对 Lena 进行边缘检测，在不同的截止频率 &lt;span class=&quot;math inline&quot;&gt;\(D_0\)&lt;/span&gt; 下（10、20、40、80）所得到的频谱图以及滤波后的图像输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg8dkkndj31rs0g7e81.jpg&quot; alt=&quot;ideal_spectrum&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg8h0u6zj31rs0fub29.jpg&quot; alt=&quot;ideal_output&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg8mwxc7j31rs0g7hdt.jpg&quot; alt=&quot;butterworth_spectrum&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg8rsf46j31rs0fub29.jpg&quot; alt=&quot;butterworth_output&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg94hrdij31rs0g7e81.jpg&quot; alt=&quot;exponential_spectrum&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg98ec3rj31rs0fub29.jpg&quot; alt=&quot;exponential_output&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对比可以发现，使用理想高通滤波器得到的结果有明显的振铃现象，而 Butterworth 高通滤波器和指数高通滤波器的结果相近，均具有较好的效果。从频谱图中也可以看出，理想高通滤波器对频率的截断非常陡峭，在临界点发生了突变，而后两者的滤波比较平滑，是一种在高低频率间逐渐过渡的过程。&lt;/p&gt;
&lt;h2 id=&quot;微分算子法&quot;&gt;微分算子法&lt;/h2&gt;
&lt;p&gt;针对由于平均或积分运算而引起的图像模糊，可用微分运算来实现图像的锐化。微分运算是求信号的变化率，有加强高频分量的作用，从而使图像轮廓清晰。&lt;/p&gt;
&lt;p&gt;常见的边缘检测算子包括：Roberts 算子、Sobel 算子、Laplacian 算子、Canny 算子等。各种算子的存在就是对这种导数分割原理进行的实例化计算，是为了在计算过程中直接使用的一种计算单位。实际使用时，通常用各种算子对应的模板对原图进行卷积运算，从而提取出图像的边缘信息。&lt;/p&gt;
&lt;p&gt;上述各算子的具体定义就不展开赘述了，具体可以参考相关书籍或文章。这里通过一张表对这些算子进行简要的介绍和比较。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;算子&lt;/th&gt;
&lt;th&gt;介绍及优缺点比较&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Roberts&lt;/td&gt;
&lt;td&gt;一种最简单的算子，采用对角线方向相邻两像素之差近似梯度幅值检测边缘。检测垂直边缘的效果好于斜向边缘，定位精度高，但是对噪声敏感，对具有陡峭边缘且含噪声少的图像效果较好。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Sobel&lt;/td&gt;
&lt;td&gt;根据像素点上下左右四邻域灰度加权差检测边缘，类似局部平均运算，因此对噪声具有平滑作用，对灰度渐变和噪声较多的图像处理效果比较好，对边缘定位比较准确。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Laplacian&lt;/td&gt;
&lt;td&gt;属于二阶微分算子，在只考虑边缘点的位置而不考虑周围的灰度差时适合用该算子进行检测。对噪声非常敏感，只适用于无噪声图像。存在噪声的情况下，使用该算子检测边缘之前需要先进行低通滤波，因此通常把 Laplacian 算子和平滑算子结合起来生成一个新的模板。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Canny&lt;/td&gt;
&lt;td&gt;该算子功能比前面几种都要好，不容易受噪声的干扰，能够检测到真正的弱边缘，但是实现起来较为麻烦，是一个具有滤波、增强、检测的多阶段的优化算子。在进行处理前，Canny 算子先利用高斯平滑滤波器来平滑图像以除去噪声。Canny 分割算法采用一阶偏导的有限差分来计算梯度幅值和方向，在处理过程中，该算子还将经过一个非极大值抑制的过程，最后采用两个阈值来连接边缘。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;Roberts、Sobel 以及 Laplacian 算子方法均为手工实现：先根据不同算子对应的模板，分别定义对单个像素块的卷积运算函数，然后在图像上滑动模板，调用该函数计算每一个卷积块，最终得到经过各算子微分后的输出图像。对于 Canny 算子，由于其实现过程比较复杂，这里选择直接调用 OpenCV 中的 &lt;code&gt;Canny()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h4 id=&quot;实现前三种算子&quot;&gt;实现前三种算子&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def roberts_operator(block):
    kernel1 = np.array([[1,0], [0,-1]])
    kernel2 = np.array([[0,-1], [1,0]])
    return np.abs(np.sum(block[1:,1:] * kernel1)) + np.abs(np.sum(block[1:,1:] * kernel2))

def sobel_operator(block, orientation):         # 水平和垂直两个方向
    if orientation == 'horizontal':
        kernel = np.array([[-1,-2,-1], [0,0,0], [1,2,1]])
    elif orientation == 'vertical':
        kernel = np.array([[-1,0,1], [-2,0,2], [-1,0,1]])
    else:
        raise('Orientation Error')
    return np.abs(np.sum(block * kernel))

def laplacian_operator(block):
    kernel = np.array([[0,-1,0], [-1,4,-1], [0,-1,0]])
    return np.abs(np.sum(block * kernel))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;滑动计算卷积块&quot;&gt;滑动计算卷积块&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def operator_process(img, operator_type, orientation=None):
    n, m = img.shape
    res = np.zeros((n, m))
    for i in range(1, n-1):
        for j in range(1, m-1):
            if operator_type == 'roberts':
                res[i][j] = roberts_operator(img[i-1:i+2, j-1:j+2])
            elif operator_type == 'sobel':
                res[i][j] = sobel_operator(img[i-1:i+2, j-1:j+2], orientation)
            elif operator_type == 'laplacian':
                res[i][j] = laplacian_operator(img[i-1:i+2, j-1:j+2])
            else:
                raise('Operator Type Error')
    return res
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;调用-opencv-中的-canny-算子&quot;&gt;调用 OpenCV 中的 Canny 算子&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;canny_res = cv2.Canny(img, threshold1, threshold2)           # 设置高低阈值参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行结果及分析-2&quot;&gt;运行结果及分析&lt;/h3&gt;
&lt;p&gt;使用 Roberts 算子、Laplacian 算子以及水平和垂直两个方向的 Sobel 算子进行边缘检测所得到的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg9hi5rtj30u00u97wh.jpg&quot; alt=&quot;roberts_sobel_laplacian&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Roberts 算子简单但有效，已经能实现比较好的边缘检测效果；而 Laplacian 算子的效果相对较差，边缘不是很清晰，还出现了很多噪点；Sobel 算子整体表现也较好，可以明显地看出水平和垂直两个方向上结果的差别，前者对水平边缘响应最大（如眼眶、嘴唇、下巴处），后者对垂直边缘响应最大（如鼻梁、两侧脸颊处）。&lt;/p&gt;
&lt;p&gt;下图显示了使用 OpenCV 自带的 Canny 算子在不同阈值下的输出结果，其中低阈值 &lt;code&gt;threshold1&lt;/code&gt; 依次取 30、50、80、120、150，而高阈值 &lt;code&gt;threshold2&lt;/code&gt; 根据 Canny 算法的推荐，均取为 &lt;code&gt;threshold1&lt;/code&gt; 的 3 倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg9n26n2j31rq0cygn5.jpg&quot; alt=&quot;canny&quot;/&gt;&lt;/p&gt;
&lt;p&gt;低于 &lt;code&gt;threshold1&lt;/code&gt; 的像素被认为不是边缘，高于 &lt;code&gt;threshold2&lt;/code&gt; 的像素被认为是边缘，介于二者之间的则会根据相邻的像素点进一步确定。从图中也可以看出，阈值设置得越高，对边缘的过滤就越严格，输出结果中的边缘线条也越发稀疏。&lt;/p&gt;
&lt;h3 id=&quot;噪声测试&quot;&gt;噪声测试&lt;/h3&gt;
&lt;p&gt;为了进一步研究在有噪声的情况下各算子的边缘检测效果，首先使用 &lt;code&gt;skimage&lt;/code&gt; 库中的函数，对 Lena 加入高斯噪声和椒盐噪声。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;img_noise1 = skimage.util.random_noise(img, mode='gaussian')
img_noise2 = skimage.util.random_noise(img, mode='s&amp;amp;p')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getg9scbc5j30vs0g51kx.jpg&quot; alt=&quot;noise_lena&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后分别在这两张有噪声的图像上应用 Roberts 算子、Sobel 算子（水平方向）、Laplacian 算子和 Canny 算子，得到的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getga33rgbj31rs0g7npd.jpg&quot; alt=&quot;gaussian&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getga5uytkj31rs0g7b29.jpg&quot; alt=&quot;s_p&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，第一行是加入高斯噪声后各算子的输出，第二行是加入椒盐噪声后各算子的输出。&lt;/p&gt;
&lt;p&gt;可以发现，Roberts 算子和 Sobel 算子都有一定的抗噪声能力，从图中依然可以看出部分边缘信息，而在 Laplacian 算子则对噪声非常敏感，其输出结果完全看不出任何边缘。对于 Canny 算子，需要将阈值设置得很高，才能得到比较好的效果，否则大量噪点也会被认为是边缘。经过多次尝试，最终将 &lt;code&gt;threshold1&lt;/code&gt; 设为 180，将 &lt;code&gt;threshold2&lt;/code&gt; 设为 &lt;code&gt;3 * threshold1&lt;/code&gt;，得到了上图中最后一列的结果。&lt;/p&gt;
&lt;p&gt;实验过程中还发现，在相同的阈值条件下，Canny 算子对高斯噪声的抵抗能力比对椒盐噪声的抵抗能力强。下图展示了当 &lt;code&gt;threshold1&lt;/code&gt; 取值为 100、120、140、160、180 时，Canny 算子对加入了高斯噪声和椒盐噪声的图像的边缘检测效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getga8lsydj31rq0cygnx.jpg&quot; alt=&quot;canny_gaussian&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getgadixdlj31rq0cyach.jpg&quot; alt=&quot;canny_s_p&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hed-算法&quot;&gt;HED 算法&lt;/h2&gt;
&lt;p&gt;2015年，Saining Xie 等人提出了一种基于卷积神经网络的边缘检测算法——Holistically-Nested Edge Detection（HED）算法。模型使用 VGG-16 作为骨干网络进行多尺度多层级的特征学习。其中 Holistically 的意思是”整体地“，表示该算法试图训练一个 image-to-image 的网络；Nested 则强调在生成的输出过程中，通过不断的集成和学习，得到更精确的边缘预测图。&lt;/p&gt;
&lt;p&gt;HED 算法具有很多优点。单就预测过程来说，对一张图片进行边缘检测的速度是很快的。使用时，根据图片的实际内容，可以通过调整合适的超参数从而得到最优尺度的边缘信息。另外，由于 HED 本身就是基于神经网络的，因而可以很方便地嵌入其他网络模型中，直接参与各种学习任务的训练过程。&lt;/p&gt;
&lt;p&gt;在效果上，HED 算法也具有优越性。论文中，作者把 HED 和传统 Canny 算法进行对比。如下图所示，可以看到 HED 的效果明显优于 Canny 算法。关于 HED 算法的更多内容请参考论文原文。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getgaiyd7mj30l90mh7ib.jpg&quot; alt=&quot;hed&quot;/&gt;&lt;h3 id=&quot;代码实现-3&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;这里采用的是 HED 算法的另一个 &lt;a href=&quot;https://github.com/sniklaus/pytorch-hed&quot; target=&quot;_blank&quot;&gt;PyTorch 实现版本&lt;/a&gt;，直接使用了作者提供的预训练模型进行预测。&lt;/p&gt;
&lt;h3 id=&quot;运行结果及分析-3&quot;&gt;运行结果及分析&lt;/h3&gt;
&lt;p&gt;模型在彩色 Lena 图像上的运行结果如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getgajs5fqj30e80e8766.jpg&quot; alt=&quot;lena-hed&quot;/&gt;&lt;p&gt;在添加了高斯噪声和椒盐噪声后的图像上，运行结果分别如下所示：&lt;/p&gt;
&lt;table readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getgbg502pj30e80e8gmt.jpg&quot;/&gt;&lt;center&gt;添加高斯噪声后的 HED 输出图像&lt;/center&gt;
&lt;/center&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;center&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1getgbidde6j30e80e80tt.jpg&quot;/&gt;&lt;center&gt;添加椒盐噪声后的 HED 输出图像&lt;/center&gt;
&lt;/center&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;可见，虽然 HED 算法的边缘线条比较粗，但整体表现还是相当优秀的，尤其是在存在噪声的情况下，该算法的效果比前述几种基于微分算子的方法都要好。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文通过使用高通滤波法、微分算子法、神经网络方法三大类，共计 8 种不同的方法对 Lena 图像进行了边缘检测，将各种方法得到的结果进行横向比较，并对它们的优缺点和适用场景进行了一定的讨论。对于具有参数的算法，进一步根据参数取值的不同进行了纵向比较，观察参数对于输出结果的影响。此外，还通过对原图像添加高斯噪声和椒盐噪声进行噪声测试，研究各算法对两种噪声的敏感性。&lt;/p&gt;
&lt;p&gt;实验结果表明，不同算法由于原理或核心函数的不同，均具有各自的优缺点和适用场景。使用时应根据图像内容和实际需求进行选择取舍，并通过调整相关参数从而到达最佳的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整源码请见 &lt;a href=&quot;https://github.com/TimDyh/edge-detection&quot; target=&quot;_blank&quot;&gt;GitHub 仓库&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;王一丁，李琛，王蕴红.《数字图像处理》.西安电子科技大学出版社&lt;/li&gt;
&lt;li&gt;Xie, Saining, and Zhuowen Tu. &quot;Holistically-nested edge detection.&quot; &lt;em&gt;Proceedings of the IEEE international conference on computer vision&lt;/em&gt;. 2015.&lt;/li&gt;
&lt;li&gt;PyTorch-HED：&lt;a href=&quot;https://github.com/sniklaus/pytorch-hed&quot; target=&quot;_blank&quot;&gt;https://github.com/sniklaus/pytorch-hed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互联网上的一些博客、文章、资料&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 15 May 2020 15:12:00 +0000</pubDate>
<dc:creator>TimDyh</dc:creator>
<og:description>边缘检测（Edge detection）是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。本文使用多种不同的方法，实现对 Lena 肖像的边缘检测，研究分析各算法的效</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/timdyh/p/12897833.html</dc:identifier>
</item>
<item>
<title>存储过程——公用表表达式(CTE) - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12897818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12897818.html</guid>
<description>&lt;p&gt;公用表表达式(Common Table Expression) 是SQL Server2005版本的引入的一个特性。CTE可以看组是一个临时的结果集，可以再接下来来的一个select,insert,update,delete,merge语句中多次引用。使用公用表达式CTE可以让语句更加清晰简练。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;338.47429575086&quot;&gt;
&lt;p&gt;shanzm-2020年5月15日 23:07:32&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;0-背景说明&quot;&gt;0. 背景说明&lt;/h3&gt;
&lt;p&gt;在编写存储过程的时候，大多数情况都会使用公用表表达式，本文对公用表表达式(CTE)作简单的介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①准备工作&lt;/strong&gt;&lt;br/&gt;创建一个产品表T_Product&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE [dbo].[T_Product]
(
        [Id] [bigint] IDENTITY(1,1) NOT NULL,--自增字段Id
        [Category] [nvarchar](50) NOT NULL,--产品种类
        [Name] [nvarchar](50) NOT NULL,--产品名
        [Price] [decimal](18, 0) NOT NULL,--产品价格
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随便插入一些数据即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②子表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解公用表表达式之前我们要回顾一下SQL语句中的子查询&lt;/p&gt;
&lt;p&gt;之前在我们在select语句中可以使用子查询，&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from (select  * from  T_Product where Category='clothes' )T where T.Price&amp;gt;500`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是使用了一个子查询:查询出T_Product表中的所有的种类为clothes的产品，子查询的结果表定义别名为T，我们在T表中继续查询所有Price大于500的产品&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③表变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子查询虽然不复杂，但是使用多层的子查询嵌套，则SQL语句会变得难以阅读，&lt;/p&gt;
&lt;p&gt;当然，我们可以使用表变量，即：定义一个表变量，然后将子查询的结果集存入表变量中，以供后续的使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--声明一个表变量
declare @T table
(
    Id bigint not null ,
    Category nvarchar(50) not null, 
    Name nvarchar(50) not nul ,
    Prince decimal not null 
)
--将子查询的数据插入表变量中
insert into @T select * from T_Product where Category='clothes'

--使用表变量
select * from @T where  Price&amp;gt;500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;④公用表表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将子查询放在了表变量&lt;code&gt;@T&lt;/code&gt;中，这样做将使SQL语句更容易维护，但又会带来另一个问题，就是性能的损失。&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;表变量实际上使用了临时表&lt;/strong&gt;，从而增加了额外的I/O开销，因此，表变量的方式并不太适合数据量大且频繁查询的情况。&lt;/p&gt;
&lt;p&gt;为此，在SQL Server 2005中提供了另外一种解决方案，这就是公用表表达式（CTE），使用CTE，可以使SQL语句的可维护性，同时，CTE要比表变量的效率高得多。&lt;/p&gt;
&lt;p&gt;这里就先演示一下使用CTE，具体的语法细节后面做说明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--声明一个CTE
with T as 
(
    select * from T_Product where Category='clothes'
)
 
--使用CTE
select * from T where Price &amp;gt;500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们就是使用公用表表达式替换这里的子查询的结果集。&lt;/p&gt;
&lt;p&gt;所以使用使用with&amp;amp;as定义的公用表表达式也称为&lt;strong&gt;子查询部分（subquery factoring）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时，公用表表达式在存储过程中可以用于代替视图的使用，在某个存储过程中需要使用是个结果集，我们没必要为其创建一个视图，可以使用公用表表达式。&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;1-定义及语法细节&quot;&gt;1. 定义及语法细节&lt;/h3&gt;
&lt;h4 id=&quot;11-基本定义&quot;&gt;1.1 基本定义&lt;/h4&gt;
&lt;p&gt;定义：&lt;strong&gt;公用表表达式(Common Table Expression)&lt;/strong&gt; 是SQL Server2005版本的引入的一个特性。CTE可以看组是一个临时的结果集，可以再&lt;strong&gt;接下来来的一个&lt;/strong&gt;&lt;code&gt;select&lt;/code&gt;,&lt;code&gt;insert&lt;/code&gt;,&lt;code&gt;update&lt;/code&gt;,&lt;code&gt;delete&lt;/code&gt;,&lt;code&gt;merge&lt;/code&gt;语句中多次引用。使用公用表达式CTE可以让语句更加清晰简练。&lt;/p&gt;
&lt;p&gt;简而言之：公用表表达式就是用于临时存储结果集。&lt;/p&gt;
&lt;h4 id=&quot;12-基本语法&quot;&gt;1.2 基本语法&lt;/h4&gt;
&lt;p&gt;创建一个公用表表达式,并使用改公用表表达式的基本语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with  subquery_name(column1，column2，column3……)--定义一个CTE
as 
(
    select  column1，column2，column3  from  table_name
)
select * from subquery_name--　引用CTE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;公用表表达式只能使用在其定义后的第一个sql语句中&lt;/span&gt;，否则会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义CTE的时候，可以省略列名，即最终的该CTE的列名就是该CTE中select查询的结果，但是我现在觉得尽量不要省略，可以方便后续阅读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正确示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp as
(
select * from T_Product where Category='外套'
)
select * from temp as temp1 left join temp as temp2 on temp1.Id =temp2.Id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是声明了一个公用表表达式temp,在其之后的第一句sql语句中使用到temp,完全没有问题。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp as
(
select * from T_Product where Category='外套'
)
select * from temp  --公用表表达式temp之后的第一句sql语句
select * from temp as temp1 left join temp as temp2 on temp1.Id =temp2.Id--公用表表达式temp之后的第二句sql语句
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是报错：显示第一句sql语句已执行，但是第二句sql语句报错“对象名'temp'无效”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正是因为只有CTE之后的第一句sql语句可以使用该CTE，所以如果CTE的表达式名称与某个数据表或视图重名，则紧跟在该CTE后面的SQL语句使用的仍然是CTE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CTE语法细节：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;如果将 CTE 用在属于批处理的一部分的语句中，那么在CTE之前的语句必须以分号结尾。&lt;/p&gt;
&lt;p&gt;【补充】：批处理是指从应用程序一次性地发送一组完整sql语句到sql server上执行,批处理的所有语句被当做一个整体,被成批地分析,编译和执行，所有的批处理 指令以&lt;code&gt;GO&lt;/code&gt; 作为结束标志。同时写多个批处理，如果前面所有的批处理没有问题，最后一个有错误那么前面所有的批处理都不会执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CTE中的sql语句是不能使用&lt;code&gt;order by&lt;/code&gt;语句，除非select语句中有&lt;code&gt;top&lt;/code&gt;（其实这里我也没有想明白，理论上子查询使用&lt;code&gt;order by&lt;/code&gt;完全是没有问题的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前面的with子句定义的查询在后面的with子句中可以使用。但是一个with子句内部不能嵌套with子句&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;13-多个cte同时声明&quot;&gt;1.3 多个CTE同时声明&lt;/h4&gt;
&lt;p&gt;这里就要思考一个问题了，那就是若是在语句sql语句中需要多个公用表表达式，我们可以连续的声明多个公用表表达式，但是注意&lt;strong&gt;只需要在第一个公用表表达式上使用&lt;code&gt;with&lt;/code&gt;&lt;/strong&gt;,之后相连的则不需在使用&lt;code&gt;with&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp1 as
( 
    select * from T_Product where Category='外套'
)
,temp2 as--注意这里不在需要使用with ,但是不要忘记as
(
    select * from T_Product where Category='裤子'
)
select * from temp1 ,temp2 where temp1.Price=temp2.Price
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;14-cte嵌套使用&quot;&gt;1.4 CTE嵌套使用&lt;/h4&gt;
&lt;p&gt;一次声明的多个公用表表达式，后面的公用表表达式可以使用前面的公用表表达式&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp1 as 
(
    select * from T_Product where Category='外套'
)
,temp2 as 
(
    select * from temp1 where Price&amp;gt;200--在相连的第二个CTE中使用第一个CTE
)
select * from temp2
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;2-cte递归查询&quot;&gt;2. CTE递归查询&lt;/h3&gt;
&lt;h4 id=&quot;21-简介&quot;&gt;2.1 简介&lt;/h4&gt;
&lt;p&gt;递归查询主要用于层次结构的查询，从叶级（Leaf Level）向顶层（Root Level）查询，或从顶层向叶级查询，或递归的路径（Path）。&lt;/p&gt;
&lt;p&gt;递归 CTE 定义&lt;strong&gt;至少必须包含两个 CTE 查询定义&lt;/strong&gt;，一个&lt;strong&gt;定位点成员&lt;/strong&gt;和一个&lt;strong&gt;递归成员&lt;/strong&gt;。可以定义多个定位点成员和递归成员；但必须将所有定位点成员查询定义置于第一个递归成员定义之前。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第一个子查询称作定点（Anchor）子查询：定点查询只是一个返回有效表的查询，用于设置递归的初始值；&lt;br/&gt;第二个子查询称作递归子查询：该子查询调用CTE名称，触发递归查询，实际上是递归子查询调用递归子查询；&lt;br/&gt;两个子查询使用union all，求并集；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;22-准备工作&quot;&gt;2.2 准备工作&lt;/h4&gt;
&lt;p&gt;创建一个公司表，公司中的部门是分等级的，PId即该部门的上一级部门&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE [dbo].[Company]
(
        [Id] [bigint] IDENTITY(1,1) NOT NULL,
        [PId] [bigint] NOT NULL,
        [Name] [nvarchar](50) NOT NULL,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入数据,我们使用行政等级模拟上下级部门:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name
--------- --------- ----------
1         0         中国
2         1         江苏省
3         2         苏州市
4         3         吴中区
5         1         山东省
6         5         济南市
7         5         青岛市
8         5         烟台市
9         2         南京市
11        9         玄武区
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23-计算每个部门的等级序列&quot;&gt;2.3 计算每个部门的等级序列&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;USE [ShanTest]
GO 

with temp as 
(
        select *,0 as Level from Company where Pid =0
        union all
        select c.Id,c.Pid,c.Name,temp.Level+1 as Level
        from  Company as c,temp  where temp.Id=c.Pid
)
select * from temp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
2         1         江苏省          1
5         1         山东省          1
6         5         济南市          2
7         5         青岛市          2
8         5         烟台市          2
3         2         苏州市          2
9         2         南京市          2
11        9         玄武区          3
4         3         吴中区          3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的理一理这里的递归：&lt;/p&gt;
&lt;p&gt;首先：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select *,0 as Level from Company where Pid =0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;union all
select c.Id,c.Pid,c.Name,temp.Level+1 as Level from  Company as c,temp  where c.Pid=temp .Id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次递归结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
2         1         江苏省          1
5         1         山东省          1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二次递归结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
2         1         江苏省          1
5         1         山东省          1
6         5         济南市          2
7         5         青岛市          2
8         5         烟台市          2
3         2         苏州市          2
9         2         南京市          2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三次递归结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
2         1         江苏省          1
5         1         山东省          1
6         5         济南市          2
7         5         青岛市          2
8         5         烟台市          2
3         2         苏州市          2
9         2         南京市          2
11        9         玄武区          3
4         3         吴中区          3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【注意】：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;递归CTE可能会出现无限递归。从而大量消耗SQL Server的服务器资源.因此，SQL Server提供了OPTION选项，可以设定最大的递归次数。&lt;/p&gt;
&lt;p&gt;这个最大递归次数往往是根据数据所代表的具体业务相关的，比如这里，我们定义最大递归数是2：&lt;code&gt;option(maxrecursion 2)&lt;/code&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;递归查询没有显式的递归终止条件，只有当递归子查询返回空结果集（没有数据行返回）或是超出了递归次数的最大限制时，才停止递归。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;USE [ShanTest]
GO 

with temp as 
(
        select *,0 as Level from Company where Pid =0
        union all
        select c.Id,c.Pid,c.Name,temp.Level+1 as Level
        from  Company as c,temp  where c.Pid=temp .Id
)
select * from temp
option(maxrecursion 2)--设置最大递归数是2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则结果现实如下，即最大递归两次则只能查询到市一级，无法查询到区一级&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id        PId       Name           Level
--------- --------- ------------   ------------
1         0         中国            0
2         1         江苏省          1
5         1         山东省          1
6         5         济南市          2
7         5         青岛市          2
8         5         烟台市          2
3         2         苏州市          2
9         2         南京市          2

消息 530，级别 16，状态 1，第 6 行
语句被终止。完成执行语句前已用完最大递归 2。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;24-查询所有的子级与父级匹配结果&quot;&gt;2.4 查询所有的子级与父级匹配结果&lt;/h4&gt;
&lt;p&gt;作为层级结构，可以使用自连接查询每个部门的上级部门：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;--隐式内连接
select  a.Id ,a.Pid ,a.Name ,b.Name as PName
from Company a ,Company b where a.Pid=b.Id 

--显式内连接：
select a.Id ,a.Pid ,a.Name ,b.Name as PName
from Company a inner join Company b on a.Pid =b.Id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name         PName
-------- -------- ---------   ----------
2        1        江苏省       中国
3        2        苏州市       江苏省
4        3        吴中区       苏州市
5        1        山东省       中国
6        5        济南市       山东省
7        5        青岛市       山东省
8        5        烟台市       山东省
9        2        南京市       江苏省
11       9        玄武区       南京市
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面演示使用递归CTE实现，所有的子级匹配所有的父级&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with subq as
(
        select  Id ,Pid ,Name  ,Name as PName
        from Company  where Pid =0
        union all
        select  c.Id ,c.Pid,c.Name  ,s.Name as PName 
        from subq as s inner join  Company as c on s.Id =c.Pid
        --from subq as s,Company as c where s.Id=c.Pid
)
select * from subq 
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name          PName
-------- -------- ----------   ---------
1        0        中国          中国
2        1        江苏省        中国
5        1        山东省        中国
6        5        济南市        山东省
7        5        青岛市        山东省
8        5        烟台市        山东省
3        2        苏州市        江苏省
9        2        南京市        江苏省
11       9        玄武区        南京市
4        3        吴中区        苏州市
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;理解递归的方式就是，从头理一理：&lt;/p&gt;
&lt;p&gt;首先：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select  Id ,Pid ,Name  ,Name as PName from Company  where Pid =0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name          PName
-------- -------- ----------   ---------
1        0        中国          中国
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select  c.Id ,c.Pid,c.Name  ,s.Name as PName  from subq as s inner join  Company as c on s.Id =c.Pid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次递归结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name          PName
-------- -------- ----------   ---------
1        0        中国          中国
2        1        江苏省        中国
5        1        山东省        中国
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二次递归：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name          PName
-------- -------- ----------   ---------
1        0        中国          中国
2        1        江苏省        中国
5        1        山东省        中国
6        5        济南市        山东省
7        5        青岛市        山东省
8        5        烟台市        山东省
3        2        苏州市        江苏省
9        2        南京市        江苏省
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三次递归&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id       Pid      Name          PName
-------- -------- ----------   ---------
1        0        中国          中国
2        1        江苏省        中国
5        1        山东省        中国
6        5        济南市        山东省
7        5        青岛市        山东省
8        5        烟台市        山东省
3        2        苏州市        江苏省
9        2        南京市        江苏省
11       9        玄武区        南京市
4        3        吴中区        苏州市
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;25-父查子：查询某个部门的下级部门&quot;&gt;2.5 父查子：查询某个部门的下级部门&lt;/h4&gt;
&lt;p&gt;比如说，这里查询表中所有江苏省以下的行政区域&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp as
(
        select * from Company where Id=2--江苏省的Id是2，所以递归初始值就是2
        union all
        select c.* 
        from temp ,szmCompany as c where temp.Id =c.Pid
)

select * from temp
--option(maxrecursion 1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;Id     Pid    Name
------ ------ ----------
2      1      江苏省
3      2      苏州市
9      2      南京市
10     9      玄武区
4      3      吴中区
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这里，若是我们只需要江苏省的下一级（即：市级），而不需要下下级（即：区县级）&lt;br/&gt;则可以设置递归的次数为1即可：&lt;code&gt;option(maxrecursion 1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;Id     Pid    Name
------ ------ ----------
2      1      江苏省
3      2      苏州市
9      2      南京市
消息 530，级别 16，状态 1，第 1 行
语句被终止。完成执行语句前已用完最大递归 1。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;26-子查父：查询某个下级部门的上级部门&quot;&gt;2.6 子查父：查询某个下级部门的上级部门&lt;/h4&gt;
&lt;p&gt;通过子部门查询其父部门，比如查询吴中区的上级行政区域&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;with temp as
(
        select *  from Company where Id=4--吴中区Id
        union all
        select c.* 
        from temp ,Company as c where temp.Pid =c.Id
)

select * from temp
--option(maxrecursion 1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id    Pid   Name
----- ----- --------
4     3     吴中区
3     2     苏州市
2     1     江苏省
1     0     中国
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若是只需要查询吴中区的直系上级行政区域，则只要限制最大递归次数为1即可&lt;/p&gt;
&lt;p&gt;当然，若是只需要查直系上级，我们可以使用之前的上下级匹配的结果集，筛选特定的记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;select * from 
(
    select a.* ,b.Name as PName from Company as a ,Company as b where a.Pid=b.Id--所有的上下级匹配结果集
)X
where X.Id =4--吴中区Id
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Id     Pid     Name       PName
------ ------- --------- ----------
4      3       吴中区      苏州市  
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;h3 id=&quot;3-参考&quot;&gt;3. 参考&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;【待读】&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;想要找一本关于存储过程的书籍，一直没有找到，所以都是在网上的一些博文中学习相关的技巧和语法细节&lt;/p&gt;
&lt;p&gt;感觉不系统，隐隐约约感觉自己关于T-SQL以及存储过程的使用还有许多不了解的地方！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 15 May 2020 15:10:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>公用表表达式(Common Table Expression) 是SQL Server2005版本的引入的一个特性。CTE可以看组是一个临时的结果集，可以再接下来来的一个select,insert,u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12897818.html</dc:identifier>
</item>
<item>
<title>【漫画】互斥锁ReentrantLock不好用？试试读写锁ReadWriteLock - 胖滚猪学编程</title>
<link>http://www.cnblogs.com/liuyanling/p/12897748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyanling/p/12897748.html</guid>
<description>&lt;p&gt;ReentrantLock完美实现了互斥，完美解决了并发问题。但是却意外发现它对于读多写少的场景效率实在不行。此时ReentrantReadWriteLock来救场了！一种适用于读多写少场景的锁，可以大幅度提升并发效率，你必须会哦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/f6c266d1ab1c8798aea3a1dba8d254f579332ab4.jpeg&quot; alt=&quot;_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ReentrantReadWriteLock，顾名思义，是可重用的读写锁。&lt;/p&gt;
&lt;p&gt;在读多写少的场合，读写锁对系统性能是很有好处的。因为如果系统在读写数据时均只使用独占锁，那么读操作和写操作间、读操作和读操作间、写操作和写操作间均不能做到真正的并发，并且需要相互等待。而读操作本身不会影响数据的完整性和一致性。&lt;/p&gt;
&lt;p&gt;因此，理论上讲，在大部分情况下，应该可以允许多线程同时读，读写锁正是实现了这种功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划重点：读写锁适用于读多写少的情况。可以优化性能，提升易用性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读写锁，并不是 Java 语言特有的，而是一个广为使用的通用技术，所有的读写锁都遵守以下三条基本原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许多个线程同时读共享变量；&lt;/li&gt;
&lt;li&gt;只允许一个线程写共享变量；&lt;/li&gt;
&lt;li&gt;如果一个写线程正在执行写操作，此时禁止读线程读共享变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;读写锁与互斥锁的一个重要区别就是读写锁允许多个线程同时读共享变量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的、独占的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。只要没有写操作，读取锁可以由多个读线程同时保持。读写锁访问约束如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;读写锁&lt;/th&gt;
&lt;th&gt;读&lt;/th&gt;
&lt;th&gt;写&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;读&lt;/td&gt;
&lt;td&gt;非阻塞&lt;/td&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;写&lt;/td&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;读写锁维护了一对相关的锁，一个用于只读操作，一个用于写入操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    //读锁
    private final Lock r = rwl.readLock();
    //写锁
    private final Lock w = rwl.writeLock();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了对比读写锁和独占锁的区别，我们可以写一个测试代码，分别传入ReentrantLock 和 ReadLock，对比一下总耗时。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static final ReentrantLock lock = new ReentrantLock();
    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private static final Lock r = rwl.readLock();

    public static String read(Lock lock, String key) throws InterruptedException {
        r.lock();
        try {
            // 模拟读耗时多的场景 更能看出区别
            Thread.sleep(1000 * 10);
            return m.get(key);
        } finally {
            r.unlock();
        }
    }

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;回想一下工作中经常用到的缓存，例如缓存元数据，不就是一种典型的读多写少应用场景吗？缓存之所以能提升性能，一个重要的条件就是缓存的数据一定是读多写少的，例如元数据和基础数据基本上不会发生变化（写少），但是使用它们的地方却很多（读多）。&lt;/p&gt;
&lt;p&gt;我们是不是可以用ReentrantReadWriteLock来手写一个缓存呢？先画一张图模拟简单的缓存流程吧：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2027276/202005/2027276-20200515225522946-162822507.png&quot; alt=&quot;未命名文件.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://yqfile.alicdn.com/35e273e0df05928be19b122f375cd9395e25c142.jpeg&quot; alt=&quot;_2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/b96028b83e1d1f3792ae240d4c897aad5dd934ec.jpeg&quot; alt=&quot;_3&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    String get(String key) throws InterruptedException {
        String v = null;
        r.lock();
        log.info(&quot;{}获取读锁 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
        try {
            v = m.get(key);
        } finally {
            r.unlock();
            log.info(&quot;{}释放读锁 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
        }
        if (v != null) {
            log.info(&quot;{}缓存存在，返回结果 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
            return v;
        }
        w.lock();
        log.info(&quot;{}缓存中不存在，查询数据库，获取写锁 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
        try {
            log.info(&quot;{}二次验证 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
            v = m.get(key);
            if (v == null) {
                log.info(&quot;{}查询数据库完成 time={} &quot;,Thread.currentThread().getName(),System.currentTimeMillis());
                v = &quot;value&quot;;
                log.info(&quot;-------------验证写锁占有的时候 其他线程无法执行写操作和读操作----------------&quot;);
                Thread.sleep(1000*5);
                m.put(key, v);
            }
        } finally {
            log.info(&quot;{}写锁释放 time={}&quot;,Thread.currentThread().getName(),System.currentTimeMillis());
            w.unlock();
        }
        return v;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/4a892dd009d9818009273edafc6378423339c74e.jpeg&quot; alt=&quot;_5&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创声明：本文来源于微信公众号【胖滚猪学编程】，持续更新JAVA\大数据干货，用漫画形式让编程so easy and interesting。转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTcyNw==&amp;amp;mid=2247484334&amp;amp;idx=1&amp;amp;sn=a9a45cbea5155c025a30191d9dd8dee2&amp;amp;chksm=9f1a450ea86dcc18d418552530cc9869be0b6f8862944d7ecb8019b8ae3a3eff121a594de09e#rd&quot;&gt;J.U.C Lock包之ReentrantLock互斥锁&lt;/a&gt;，我们介绍了ReentrantLock相比synchronized的几大特色功能，例如公平锁、非阻塞获取锁、超时、中断。那么ReentrantReadWriteLock是否也有呢？&lt;/p&gt;
&lt;p&gt;简单。。看看源码不就清楚了。以下源码都是在ReentrantReadWriteLock.java中撩出来的~ 剩下的我就不用多说了吧！如果不清楚这些方法可以回头看看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MjY1MTcyNw==&amp;amp;mid=2247484334&amp;amp;idx=1&amp;amp;sn=a9a45cbea5155c025a30191d9dd8dee2&amp;amp;chksm=9f1a450ea86dcc18d418552530cc9869be0b6f8862944d7ecb8019b8ae3a3eff121a594de09e#rd&quot;&gt;J.U.C Lock包之ReentrantLock互斥锁&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        public boolean tryLock(long timeout, TimeUnit unit)
                throws InterruptedException {
            return sync.tryAcquireNanos(1, unit.toNanos(timeout));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        public void lockInterruptibly() throws InterruptedException {
            sync.acquireInterruptibly(1);
        }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;还想跟你聊聊锁的升级和降级。也许你是第一次听到，锁还有升级降级的功能。但其实不难理解，比如在读写锁中，写锁变为读锁是完全可行的方案，不会有任何问题，这里&lt;strong&gt;写锁变读锁就叫做锁的降级&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么可以升级吗？熟话说降级容易，你只要天天不来上班就行了，升级可难哦。锁中也是，只是在锁中更加苛刻，&lt;strong&gt;完全不允许升级，即读锁无法升级为写锁&lt;/strong&gt;。&lt;strong&gt;必须先释放读锁，才可以获取写锁&lt;/strong&gt;。为什么不允许升级？试想有1000个读线程同时执行，同时升级为写锁，会发生什么？获取写锁的前提是读锁和写锁均未被占用，因此可能导致阻塞较长的时间，也可能发生死锁。&lt;/p&gt;
&lt;p&gt;先写个代码验证一下吧，在(2)处我们实现了降级，程序是完全ok的，在(1)处如果你注释掉 r.unlock()，试图升级为读锁，你会发现程序会跑不下去的，据此可以验证我们所说的：读写锁可以降级、无法升级。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    void processCachedData() {
        // 获取读锁
        r.lock();
        if (!cacheValid) {
            // 释放读锁 因为不允许读锁的升级 可以注释掉该行代码 整个程序会阻塞
            r.unlock(); //（1）
            // 获取写锁
            w.lock();
            try {
                // 再次检查状态
                if (!cacheValid) {
                    data = &quot;胖滚猪学编程&quot;;
                    cacheValid = true;
                }

                // 释放写锁前 降级为读锁 降级是可以的
                r.lock(); //（2）
            } finally {
                // 释放写锁
                w.unlock();

            }

        }
        // 此处仍然持有读锁
        try {
            System.out.println(data);
        } finally {
            r.unlock();
        }

    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;读写锁适用于读多写少的情况。可以优化性能，提升易用性。缓存就是个很好的例子。&lt;/p&gt;
&lt;p&gt;读写锁最大的特征是允许多个线程同时读共享变量。但是只允许一个线程写共享变量，且如果一个写线程正在执行写操作，此时禁止读线程读共享变量。&lt;/p&gt;
&lt;p&gt;ReentrantReadWriteLock读写锁类似于 ReentrantLock，支持公平模式和非公平模式、支持非阻塞获取锁、超时、中断等特性。但是有一点需要注意，那就是只有写锁支持条件变量，读锁是不支持条件变量的，读锁调用 newCondition() 会抛出 UnsupportedOperationException 异常。&lt;/p&gt;
&lt;p&gt;所以！我们必须了解各种锁的用途，才能在生产上选择最合适高效的方式。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创声明：本文来源于微信公众号【胖滚猪学编程】，持续更新JAVA\大数据干货，用漫画形式让编程so easy and interesting。转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文转载自公众号【胖滚猪学编程】 用漫画让编程so easy and interesting！欢迎关注！形象来源于微信表情包【胖滚家族】喜欢可以下载哦~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 15 May 2020 14:55:00 +0000</pubDate>
<dc:creator>胖滚猪学编程</dc:creator>
<og:description>ReentrantLock完美实现了互斥，完美解决了并发问题。但是却意外发现它对于读多写少的场景效率实在不行。此时ReentrantReadWriteLock来救场了！一种适用于读多写少场景的锁，可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuyanling/p/12897748.html</dc:identifier>
</item>
<item>
<title>手写一个简易的多周期 MIPS  CPU - hez2010</title>
<link>http://www.cnblogs.com/hez2010/p/12897743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hez2010/p/12897743.html</guid>
<description>&lt;h2&gt;一点前言&lt;/h2&gt;
&lt;p&gt;多周期 CPU 相比单周期 CPU 以及流水线的实现来说其实写起来要麻烦那么一些，但是相对于流水线以及单周期 CPU 而言，多周期 CPU 除了能提升主频之外似乎并没有什么卵用。不过我的课题是多周期 CPU 那么就开始吧。&lt;/p&gt;
&lt;h2&gt;多周期 CPU&lt;/h2&gt;
&lt;p&gt;不同于单周期 CPU，多周期 CPU 指的是将整个 CPU 的执行过程分成几个阶段，每个阶段用一个时钟去完 成，然后开始下一条指令的执行，而每种指令执行时所用的时钟数不尽相同，这就是所谓的多周期CPU。&lt;/p&gt;
&lt;p&gt;CPU在处理指令时，一般需要经过以下几个阶段：&lt;/p&gt;
&lt;p&gt;(1) 取指令(IF)：根据程序计数器 PC 中的指令地址，从存储器中取出一条指令，同时，PC 根据指令字长度自动递增产生下一条指令所需要的指令地址，但遇到“地址转移”指令 时，则控制器把“转移地址”送入 PC，当然得到的“地址”需要做些变换才送入 PC。&lt;/p&gt;
&lt;p&gt;(2) 指令译码(ID)：对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相应的操作控制信号，用于驱动执行状态中的各种操作。&lt;/p&gt;
&lt;p&gt;(3) 指令执行(EXE)：根据指令译码得到的操作控制信号，具体地执行指令动作，然后转移到结果写回状态。&lt;/p&gt;
&lt;p&gt;(4) 存储器访问(MEM)：所有需要访问存储器的操作都将在这个步骤中执行，该步骤给出存储器的数据地址，把数据写入到存储器中数据地址所指定的存储单元或者从存储器中得 到数据地址单元中的数据。&lt;/p&gt;
&lt;p&gt;(5) 结果写回(WB)：指令执行的结果或者访问存储器中得到的数据写回相应的目的寄存器中。&lt;/p&gt;
&lt;p&gt;这也就意味着一条 CPU 指令最长需要 5 个时钟周期才能执行完毕，至于具体需要多少周期则根据指令的不同而不同。&lt;/p&gt;
&lt;p&gt;MIPS 指令集的设计为定长简单指令集，这为 CPU 的实现带来了极大的方便。&lt;/p&gt;
&lt;h2&gt;指令集&lt;/h2&gt;
&lt;p&gt;MIPS 指令分为三种：R、I 和 J，三种指令有不同的存储方式：&lt;/p&gt;
&lt;img src=&quot;https://hez2010.com/wp-content/uploads/2020/05/image-1024x543.png&quot; alt=&quot;&quot; class=&quot;wp-image-72&quot;/&gt;&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;op：操作码；&lt;/li&gt;
&lt;li&gt;rs：第1个源操作数寄存器，寄存器地址（编号）是00000~11111，00~1F；&lt;/li&gt;
&lt;li&gt;rt：第2个源操作数寄存器，或目的操作数寄存器，寄存器地址（同上）；&lt;/li&gt;
&lt;li&gt;rd：目的操作数寄存器，寄存器地址（同上）；&lt;/li&gt;
&lt;li&gt;sa：位移量（shift amt），移位指令用于指定移多少位；&lt;/li&gt;
&lt;li&gt;funct：功能码，在寄存器类型指令中（R类型）用来指定指令的功能；&lt;/li&gt;
&lt;li&gt;immediate：16位立即数，用作无符号的逻辑操作数、有符号的算术操作数、数据加载（Load）/数据保存（Store）指令的数据地址字节偏移量和分支指令中相对程序计数器（PC）的有符号偏移量；&lt;/li&gt;
&lt;li&gt;address：地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在执行指令的过程中，需要在不同的时钟周期之间进行状态转移：&lt;/p&gt;
&lt;img src=&quot;https://hez2010.com/wp-content/uploads/2020/05/image-1.png&quot; alt=&quot;&quot; class=&quot;wp-image-73&quot;/&gt;&lt;p&gt;本简易 CPU 姑且只实现以下指令：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;OpCode&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;000000&lt;/td&gt;
&lt;td&gt;add rd, rs, rt&lt;/td&gt;
&lt;td&gt;带符号加法运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000001&lt;/td&gt;
&lt;td&gt;sub rd, rs, rt&lt;/td&gt;
&lt;td&gt;带符号减法运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;000010&lt;/td&gt;
&lt;td&gt;addiu rt, rs, immediate&lt;/td&gt;
&lt;td&gt;无符号加法运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;010000&lt;/td&gt;
&lt;td&gt;and rd, rs, rt&lt;/td&gt;
&lt;td&gt;与运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;010001&lt;/td&gt;
&lt;td&gt;andi rt, rs, immediate&lt;/td&gt;
&lt;td&gt;对立即数做 0 扩展后进行与运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;010010&lt;/td&gt;
&lt;td&gt;ori rt, rs, immediate&lt;/td&gt;
&lt;td&gt;对立即数做 0 扩展后做或运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;010011&lt;/td&gt;
&lt;td&gt;xori rt, rs, immediate&lt;/td&gt;
&lt;td&gt;对立即数做 0 扩展后做异或运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;011000&lt;/td&gt;
&lt;td&gt;sll rd, rt, sa&lt;/td&gt;
&lt;td&gt;左移指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100110&lt;/td&gt;
&lt;td&gt;slti rt, rs, immediate&lt;/td&gt;
&lt;td&gt;比较指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100111&lt;/td&gt;
&lt;td&gt;slt rd, rs, rt&lt;/td&gt;
&lt;td&gt;比较指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;110000&lt;/td&gt;
&lt;td&gt;sw rt, immediate(rs)&lt;/td&gt;
&lt;td&gt;存数指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;110001&lt;/td&gt;
&lt;td&gt;lw rt, immediate(rs)&lt;/td&gt;
&lt;td&gt;读数指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110100&lt;/td&gt;
&lt;td&gt;beq rs, rt, immediate&lt;/td&gt;
&lt;td&gt;分支指令，相等时跳转&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110101&lt;/td&gt;
&lt;td&gt;bne rs, rt, immediate&lt;/td&gt;
&lt;td&gt;分支指令，不等时跳转&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110110&lt;/td&gt;
&lt;td&gt;bltz rs, immediate&lt;/td&gt;
&lt;td&gt;分支指令，小于 0 时跳转&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111000&lt;/td&gt;
&lt;td&gt;j addr&lt;/td&gt;
&lt;td&gt;跳转指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111001&lt;/td&gt;
&lt;td&gt;jr rs&lt;/td&gt;
&lt;td&gt;跳转指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111010&lt;/td&gt;
&lt;td&gt;jal addr&lt;/td&gt;
&lt;td&gt;调用子程序指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111111&lt;/td&gt;
&lt;td&gt;halt&lt;/td&gt;
&lt;td&gt;停机指令&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;控制单元&lt;/h2&gt;
&lt;p&gt;一个简易的多周期 CPU 的数据通路图如下：&lt;/p&gt;
&lt;img src=&quot;https://hez2010.com/wp-content/uploads/2020/05/image-2-1024x773.png&quot; alt=&quot;&quot; class=&quot;wp-image-74&quot;/&gt;&lt;p&gt;三个 D 触发器用于保存当前状态，是时序逻辑电路，RST用于初始化状态“000“，另外两个部分都是组合逻辑电路，一个用于产生 下一个阶段的状态，另一个用于产生每个阶段的控制信号。从图上可看出，下个状态取决于 指令操作码和当前状态；而每个阶段的控制信号取决于指令操作码、当前状态和反映运算结果的状态 zero 标志和符号 sign标志。&lt;/p&gt;
&lt;p&gt;其中指令和数据各存储在不同存储器中，即有指令存储器和数据存储器。访问存储器时，先给出内存地址，然后由读或写信号控制操作。对于寄存器组， 给出寄存器地址（编号），读操作时不需要时钟信号，输出端就直接输出相应数据；而在写操作时，在 WE使能信号为 1时，在时钟边沿触发将数据写入寄存器。&lt;/p&gt;
&lt;p&gt;IR 指令寄存器目的是使指令代码保持稳定，PC 写使能控制信号PCWre，是确保PC 适时修改，原因都是和多周期工作的CPU有关。ADR、BDR、 ALUoutDR、DBDR四个寄存器不需要写使能信号，其作用是切分数据通路，将大组合逻辑切分为若干个小组合逻辑，大延迟变为多个分段小延迟。&lt;/p&gt;
&lt;p&gt;各控制信号功能如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;控制信号名&lt;/th&gt;
&lt;th&gt;状态 0&lt;/th&gt;
&lt;th&gt;状态 1&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;RST&lt;/td&gt;
&lt;td&gt;对于PC，初始化PC为程序首地址&lt;/td&gt;
&lt;td&gt;对于PC，PC接收下一条指令地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;PCWre&lt;/td&gt;
&lt;td&gt;PC不更改，另 外，除‘000’状态之外，其余状态慎改PC的值。&lt;/td&gt;
&lt;td&gt;PC更改，另外，在‘000’状态时，修改PC的值合适。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;ALUSrcA&lt;/td&gt;
&lt;td&gt;来自寄存器堆 data1 输出&lt;/td&gt;
&lt;td&gt;来自移位数sa，同时，进行(zeroextend)sa，即 {{27{1'b0},sa}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ALUSrcB&lt;/td&gt;
&lt;td&gt;来自寄存器堆 data2 输出&lt;/td&gt;
&lt;td&gt;来自 sign或 zero 扩展的立即数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;DBDataSrc&lt;/td&gt;
&lt;td&gt;来自ALU运算结果的输出&lt;/td&gt;
&lt;td&gt;来自数据存储器（Data MEM）的输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;RegWre&lt;/td&gt;
&lt;td&gt;无写寄存器组寄存器&lt;/td&gt;
&lt;td&gt;寄存器组寄存器写使能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;WrRegDSrc&lt;/td&gt;
&lt;td&gt;写入寄存器组寄存器的数据来自 PC+4(PC4)&lt;/td&gt;
&lt;td&gt;写入寄存器组寄存器的数据来自ALU 运算结果或存储器读出的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;InsMemRW&lt;/td&gt;
&lt;td&gt;写指令存储器&lt;/td&gt;
&lt;td&gt;读指令存储器(Ins. Data)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mRD&lt;/td&gt;
&lt;td&gt;存储器输出高阻态&lt;/td&gt;
&lt;td&gt;读数据存储器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mWR&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;td&gt;写数据存储器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;IRWre&lt;/td&gt;
&lt;td&gt;IR(指令寄存器)不更改&lt;/td&gt;
&lt;td&gt;IR 寄存器写使能。向指令存储器发出读指令代码后，这个信号也接着发出，在时钟上升沿，IR 接收从指令存储器送来的指令代码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ExtSel&lt;/td&gt;
&lt;td&gt;零扩展&lt;/td&gt;
&lt;td&gt;符号扩展&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;PCSrc[1..0]&lt;/td&gt;
&lt;td&gt;00：PC&amp;lt;－PC+4&lt;br/&gt;01：PC&amp;lt;－PC+4+((sign-extend)immediate&amp;lt;&amp;lt;2)&lt;br/&gt;10：PC&amp;lt;－rs&lt;br/&gt;11：PC&amp;lt;－{PC[31:28], addr[27:2],2'b00}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;RegDst[1..0]&lt;/td&gt;
&lt;td&gt;写寄存器组寄存器的地址，来自：&lt;br/&gt;00：0x1F($31)&lt;br/&gt;01：rt 字段&lt;br/&gt;10：rd 字段&lt;br/&gt;11：未用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ALUOp[2..0]&lt;/td&gt;
&lt;td&gt;ALU 8种运算功能选择(000-111)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;相关部件及引脚说明&lt;/h2&gt;
&lt;p&gt;Instruction Memory：指令存储器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Iaddr，指令地址输入端口&lt;/li&gt;
&lt;li&gt;DataIn，存储器数据输入端口&lt;/li&gt;
&lt;li&gt;DataOut，存储器数据输出端口&lt;/li&gt;
&lt;li&gt;RW，指令存储器读写控制信号，为0 写，为 1读&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Data Memory：数据存储器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Daddr，数据地址输入端口&lt;/li&gt;
&lt;li&gt;DataIn，存储器数据输入端口&lt;/li&gt;
&lt;li&gt;DataOut，存储器数据输出端口&lt;/li&gt;
&lt;li&gt;/RD，数据存储器读控制信号，为 0 读&lt;/li&gt;
&lt;li&gt;/WR，数据存储器写控制信号，为0 写&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Register File：寄存器组&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Read Reg1，rs 寄存器地址输入端口&lt;/li&gt;
&lt;li&gt;Read Reg2，rt 寄存器地址输入端口&lt;/li&gt;
&lt;li&gt;Write Reg，将数据写入的寄存器，其地址输入端口（rt、rd）&lt;/li&gt;
&lt;li&gt;Write Data，写入寄存器的数据输入端口&lt;/li&gt;
&lt;li&gt;Read Data1，rs 寄存器数据输出端口&lt;/li&gt;
&lt;li&gt;Read Data2，rt 寄存器数据输出端口&lt;/li&gt;
&lt;li&gt;WE，写使能信号，为1 时，在时钟边沿触发写入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IR： 指令寄存器，用于存放正在执行的指令代码&lt;/p&gt;
&lt;p&gt;ALU： 算术逻辑单元&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;result，ALU运算结果&lt;/li&gt;
&lt;li&gt;zero，运算结果标志，结果为 0，则 zero=1；否则 zero=0&lt;/li&gt;
&lt;li&gt;sign，运算结果标志，结果最高位为0，则 sign=0，正数；否则，sign=1，负数&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;ALU&lt;/h2&gt;
&lt;p&gt;ALU 为算术逻辑运算单元，功能如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ALUOp[2..0]&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;000&lt;/td&gt;
&lt;td&gt;Y=A+B&lt;/td&gt;
&lt;td&gt;加法运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;Y=A-B&lt;/td&gt;
&lt;td&gt;减法运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;010&lt;/td&gt;
&lt;td&gt;Y=B&amp;lt;&amp;lt;A&lt;/td&gt;
&lt;td&gt;左移运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;011&lt;/td&gt;
&lt;td&gt;Y=A∨B&lt;/td&gt;
&lt;td&gt;或运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Y=A∧B&lt;/td&gt;
&lt;td&gt;与运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Y=(A&amp;lt;B) ? 1 : 0&lt;/td&gt;
&lt;td&gt;无符号比较&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;Y=(((A&amp;lt;B)&amp;amp;&amp;amp;(A[31] == B[31])) ||&lt;br/&gt;((A[31]==1&amp;amp;&amp;amp; B[31] == 0))) ? 1 : 0&lt;/td&gt;
&lt;td&gt;带符号比较&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;Y=A⊕B&lt;/td&gt;
&lt;td&gt;异或&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;模块设计&lt;/h2&gt;
&lt;h3&gt;符号定义&lt;/h3&gt;
&lt;p&gt;为了更加明晰程序代码，并避免因二进制代码书写错误导致的问题，对状态码、操 作码等做出如下定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;`define ALU_OP_ADD 3'b000
`define ALU_OP_SUB 3'b001
`define ALU_OP_SLL 3'b010
`define ALU_OP_OR 3'b011
`define ALU_OP_AND 3'b100
`define ALU_OP_LT 3'b101
`define ALU_OP_SLT 3'b110
`define ALU_OP_XOR 3'b111

`define OP_ADD 6'b000000
`define OP_SUB 6'b000001
`define OP_ADDIU 6'b000010
`define OP_AND 6'b010000
`define OP_ANDI 6'b010001
`define OP_ORI 6'b010010
`define OP_XORI 6'b010011
`define OP_SLL 6'b011000
`define OP_SLTI 6'b100110
`define OP_SLT 6'b100111
`define OP_SW 6'b110000
`define OP_LW 6'b110001
`define OP_BEQ 6'b110100
`define OP_BNE 6'b110101
`define OP_BLTZ 6'b110110
`define OP_J 6'b111000
`define OP_JR 6'b111001
`define OP_JAL 6'b111010
`define OP_HALT 6'b111111

`define PC_NEXT 2'b00
`define PC_REL_JUMP 2'b01
`define PC_REG_JUMP 2'b10
`define PC_ABS_JUMP 2'b11

`define STATE_IF 3'b000
`define STATE_ID 3'b001
`define STATE_EXE_AL 3'b110
`define STATE_EXE_BR 3'b101
`define STATE_EXE_LS 3'b010
`define STATE_MEM 3'b011
`define STATE_WB_AL 3'b111
`define STATE_WB_LD 3'b100
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;控制单元&lt;/h3&gt;
&lt;h4&gt;状态转移&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;always @(posedge CLK or negedge RST) begin
    if (!RST) State &amp;lt;= `STATE_IF;
    else begin
        case (State)
            `STATE_IF: State &amp;lt;= `STATE_ID;
            `STATE_ID: begin
                case (OpCode)
                    `OP_ADD, `OP_SUB, `OP_ADDIU, `OP_AND, `OP_ANDI, `OP_ORI, 
                    `OP_XORI, `OP_SLL, `OP_SLTI, `OP_SLT: State &amp;lt;= `STATE_EXE_AL;
                    `OP_BNE, `OP_BEQ, `OP_BLTZ: State &amp;lt;= `STATE_EXE_BR;
                    `OP_SW, `OP_LW: State &amp;lt;= `STATE_EXE_LS;
                    `OP_J, `OP_JAL, `OP_JR, `OP_HALT: State &amp;lt;= `STATE_IF;
                    default: State &amp;lt;= `STATE_EXE_AL;
                endcase
            end
            `STATE_EXE_AL: State &amp;lt;= `STATE_WB_AL;
            `STATE_EXE_BR: State &amp;lt;= `STATE_IF;
            `STATE_EXE_LS: State &amp;lt;= `STATE_MEM;
            `STATE_WB_AL: State &amp;lt;= `STATE_IF;
            `STATE_MEM: begin
                case (OpCode)
                    `OP_SW: State &amp;lt;= `STATE_IF;
                    `OP_LW: State &amp;lt;= `STATE_WB_LD;
                endcase
            end
            `STATE_WB_LD: State &amp;lt;= `STATE_IF;
            default: State &amp;lt;= `STATE_IF;
        endcase
    end
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;控制信号&lt;/h4&gt;
&lt;p&gt;不同控制信号根据不同的操作码得到，因此可以列出对于不同操作码的各控制信号的真值表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Op&lt;/th&gt;
&lt;th&gt;PCWre&lt;/th&gt;
&lt;th&gt;ALUSrcA&lt;/th&gt;
&lt;th&gt;ALUSrcB&lt;/th&gt;
&lt;th&gt;DBDataSrc&lt;/th&gt;
&lt;th&gt;RegWre&lt;/th&gt;
&lt;th&gt;WrRegDSrc&lt;/th&gt;
&lt;th&gt;InsMemRW&lt;/th&gt;
&lt;th&gt;mRD&lt;/th&gt;
&lt;th&gt;mWR&lt;/th&gt;
&lt;th&gt;IRWre&lt;/th&gt;
&lt;th&gt;ExtSel&lt;/th&gt;
&lt;th&gt;PCSrc&lt;/th&gt;
&lt;th&gt;RegDst&lt;/th&gt;
&lt;th&gt;ALUOp&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sub&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;addiu&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;andi&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ori&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;011&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;xori&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sll&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;010&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;slti&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;slt&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sw&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lw&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;beq&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00(Zero=0) 01(Zero=1)&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;bne&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00(Zero=1) 01(Zero=0)&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;bltz&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;00(Sign=0) 01(Sign=1)&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;XXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jr&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;XXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jal&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;XXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;halt&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;XX&lt;/td&gt;
&lt;td&gt;XXX&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;控制信号不仅仅取决于操作码，还取决于当前的状态。各控制信号实现如下：&lt;/p&gt;
&lt;p&gt;ALUSrcA：EXE 阶段 LS、SLL&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;ALUSrcA = ((State == `STATE_EXE_AL || State == `STATE_EXE_BR || State == `STATE_EXE_LS) &amp;amp;&amp;amp; OpCode == `OP_SLL) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ALUSrcB：EXE 阶段 ADDIU、ANDI、ORI、XORI、SLTI、LW、SW&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;ALUSrcB = ((State == `STATE_EXE_AL || State == `STATE_EXE_BR || State == `STATE_EXE_LS) &amp;amp;&amp;amp; (OpCode == `OP_ADDIU || OpCode == `OP_ANDI || OpCode == `OP_ORI || OpCode == `OP_XORI || OpCode == `OP_SLTI || OpCode == `OP_LW || OpCode == `OP_SW)) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RegWre：ID 阶段 JAL，或 WB 阶段 LD&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;RegWre = ((State == `STATE_ID &amp;amp;&amp;amp; OpCode == `OP_JAL) || (State == `STATE_WB_AL || State == `STATE_WB_LD)) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WrRegDSrc：ID 阶段 JAL&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;WrRegDSrc = (State == `STATE_ID &amp;amp;&amp;amp; OpCode == `OP_JAL) ? 0 : 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mRD：MEM 或 WB 阶段 LW&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;mRD = ((State == `STATE_MEM || State == `STATE_WB_LD) &amp;amp;&amp;amp; OpCode == `OP_LW) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mWR：MEM 阶段 SW&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;mWR = (State == `STATE_MEM &amp;amp;&amp;amp; OpCode == `OP_SW) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IRWre：IF 阶段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;IRWre = (State == `STATE_IF) ? 1 : 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExtSel：EXE 阶段 ANDI、ORI、XORI&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;ExtSel = ((State == `STATE_EXE_AL || State == `STATE_EXE_BR || State == `STATE_EXE_LS) &amp;amp;&amp;amp; (OpCode == `OP_ANDI || OpCode == `OP_ORI || OpCode == `OP_XORI)) ? 0 : 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PCSrc：IF 或 ID 阶段 JR 为 PC_REG_JUMP，IF 或 ID 阶段 J、JAL 为 PC_ABS_JUMP，EXE 阶段 BEQ、BNE、BLTZ 为 PC_REL_JUMP，否则均为 PC_NEXT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;if ((State == `STATE_IF || State == `STATE_ID) &amp;amp;&amp;amp; OpCode == `OP_JR) PCSrc = `PC_REG_JUMP;
else if ((State == `STATE_IF || State == `STATE_ID) &amp;amp;&amp;amp; (OpCode == `OP_J || OpCode == `OP_JAL)) PCSrc = `PC_ABS_JUMP;
else if ((State == `STATE_EXE_AL || State == `STATE_EXE_BR || State == `STATE_EXE_LS) &amp;amp;&amp;amp; (OpCode == `OP_BEQ &amp;amp;&amp;amp; Zero) || (OpCode == `OP_BNE &amp;amp;&amp;amp; !Zero) || (OpCode == `OP_BLTZ &amp;amp;&amp;amp; Sign)) PCSrc = `PC_REL_JUMP;
else PCSrc = `PC_NEXT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RegDst：ID 阶段 JAL 为 b00，WB 阶段 ADDIU、ANDI、ORI、XORI、SLTI、LW 为 b01，否则均为 b10&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;if (State == `STATE_ID &amp;amp;&amp;amp; OpCode == `OP_JAL) RegDst = 2'b00;
else if ((State == `STATE_WB_AL || State == `STATE_WB_LD) &amp;amp;&amp;amp; (OpCode == `OP_ADDIU || OpCode == `OP_ANDI || OpCode == `OP_ORI || OpCode == `OP_XORI || OpCode == `OP_SLTI || OpCode == `OP_LW)) RegDst = 2'b01;
else RegDst = 2'b10;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ALUOp：根据真值表即可得出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;case (OpCode)
    `OP_ADD, `OP_ADDIU, `OP_SW, `OP_LW: ALUOp = `ALU_OP_ADD;
    `OP_SUB, `OP_BEQ, `OP_BNE, `OP_BLTZ: ALUOp = `ALU_OP_SUB;
    `OP_SLL: ALUOp = `ALU_OP_SLL;
    `OP_ORI: ALUOp = `ALU_OP_OR;
    `OP_AND, `OP_ANDI: ALUOp = `ALU_OP_AND;
    `OP_SLTI, `OP_SLT: ALUOp = `ALU_OP_SLT;
    `OP_XORI: ALUOp = `ALU_OP_XOR;
endcase
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PCWre：ID 阶段 J、JAL、JR，或 EXE 阶段 BEQ、BNE、BLTZ，或 MEM 阶段 SW，或 WB 阶段。另外，为保证在每条指令最初阶段的时钟上升沿 PC 发生改变，需要在上一条指令的最后一个下降沿将 PCWre 设置为 1，这样才能保证 PC 在每条指令最开始的时钟上升沿改变。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;always @(negedge CLK) begin
    case (State)
        `STATE_ID: begin
            if (OpCode == `OP_J || OpCode == `OP_JAL || OpCode == `OP_JR) PCWre &amp;lt;= 1;
        end
        `STATE_EXE_AL, `STATE_EXE_BR, `STATE_EXE_LS: begin
            if (OpCode == `OP_BEQ || OpCode == `OP_BNE || OpCode == `OP_BLTZ) PCWre &amp;lt;= 1;
        end
        `STATE_MEM: begin
            if (OpCode == `OP_SW) PCWre &amp;lt;= 1;
        end
        `STATE_WB_AL, `STATE_WB_LD: PCWre &amp;lt;= 1;
        default: PCWre &amp;lt;= 0;
    endcase
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;逻辑算术运算单元&lt;/h3&gt;
&lt;p&gt;该模块是一个32位的ALU单元，会根据控制信号对输入的操作数进行不同的运算，例如加、减、与、或等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module ALU(
    input [2:0] ALUOp,
    input [31:0] A,
    input [31:0] B,
    output Sign,
    output Zero,
    output reg [31:0] Result
    );

    always @(*) begin
        case (ALUOp)
            `ALU_OP_ADD: Result = (A + B);
            `ALU_OP_SUB: Result = (A - B);
            `ALU_OP_SLL: Result = (B &amp;lt;&amp;lt; A);
            `ALU_OP_OR: Result = (A | B);
            `ALU_OP_AND: Result = (A &amp;amp; B);
            `ALU_OP_LT: Result = (A &amp;lt; B) ? 1 : 0;
            `ALU_OP_SLT: Result = (((A &amp;lt; B) &amp;amp;&amp;amp; (A[31] == B[31])) || ((A[31] &amp;amp;&amp;amp; !B[31]))) ? 1 : 0;
            `ALU_OP_XOR: Result = (A ^ B);
        endcase
        $display(&quot;[ALU] calculated result [%h] from a = [%h] aluOpCode = [%b] b = [%h]&quot;, Result, A, ALUOp, B);
    end
    
    assign Zero = (Result == 0) ? 1 : 0;
    assign Sign = Result[31];
    
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;寄存器组&lt;/h3&gt;
&lt;p&gt;该模块为一个32位而拥有32个寄存的寄存器组。寄存器组接受 InstructionMemory 的输入，输出对应寄存器的数据，从而实现读取寄存器里的数据的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module RegisterFile(
    input CLK,
    input RST,
    input WE,
    input [4:0] ReadReg1,
    input [4:0] ReadReg2,
    input [4:0] WriteReg,
    input [31:0] WriteData,
    output [31:0] ReadData1,
    output [31:0] ReadData2
    );
    
    reg [31:0] register[1:31];
    integer i;

    assign ReadData1 = ReadReg1 == 0 ? 0 : register[ReadReg1];
    assign ReadData2 = ReadReg2 == 0 ? 0 : register[ReadReg2];

    always @(negedge CLK or negedge RST) begin
        if (!RST) begin
            for (i = 1; i &amp;lt; 32; i = i + 1) begin
                register[i] = 0;
            end
        end
        else if (WE &amp;amp;&amp;amp; WriteReg) begin
            register[WriteReg] &amp;lt;= WriteData;
            $display(&quot;[RegisterFile] wrote data [%h] into reg $[%d]&quot;, WriteData, WriteReg);
        end
    end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;符号扩展单元&lt;/h3&gt;
&lt;p&gt;该组件有两个功能：符号扩展和零扩展，输入的扩展方法和待扩展的数据，输出扩展后的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module SignZeroExtend(
    input ExtSel, // 0 - 0 extend, 1 - sign extend
    input [15:0] Immediate,
    output [31:0] DataOut
    );
    
    assign DataOut[15:0] = Immediate[15:0];
    assign DataOut[31:16] = (ExtSel &amp;amp;&amp;amp; Immediate[15]) ? 16'hFFFF : 16'h0000;
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;指令存储器&lt;/h3&gt;
&lt;p&gt;把指令集以二进制的形式写成一个文件，然后在指令存储器中读进来，以读文件的方式把指令存储到内存中，实现指令的读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module InstructionMemory(
    input RW,
    input [31:0] IAddr,
    output reg [31:0] DataOut
    );
    
    reg [7:0] memory[0:95];
    
    initial begin
        $readmemb(`MEMORY_FILE_PATH, memory);
    end
    
    always @(IAddr or RW) begin
        if (RW) begin
            DataOut[31:24] = memory[IAddr];
            DataOut[23:16] = memory[IAddr + 1];
            DataOut[15:8] = memory[IAddr + 2];
            DataOut[7:0] = memory[IAddr + 3];
            $display(&quot;[InstructionMemory] Loaded instruction [%h] from address [%h]&quot;, DataOut, IAddr);
        end
    end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;数据存储单元&lt;/h3&gt;
&lt;p&gt;数据存储单元负责存取数据，且由时钟下降沿出发写操作。实现为1字节8位的大端方式存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module DataMemory(
    input CLK,
    input mRD,
    input mWR,
    input [31:0] DAddr,
    input [31:0] DataIn,
    output [31:0] DataOut
    );

    reg [7:0] memory[0:127];
    
    assign DataOut[7:0] = mRD ? memory[DAddr + 3] : 8'bz; 
    assign DataOut[15:8] = mRD ? memory[DAddr + 2] : 8'bz;
    assign DataOut[23:16] = mRD ? memory[DAddr + 1] : 8'bz;
    assign DataOut[31:24] = mRD ? memory[DAddr] : 8'bz;
    
    always @(negedge CLK) begin
        if (mWR) begin
            memory[DAddr] &amp;lt;= DataIn[31:24];
            memory[DAddr + 1] &amp;lt;= DataIn[23:16];
            memory[DAddr + 2] &amp;lt;= DataIn[15:8];
            memory[DAddr + 3] &amp;lt;= DataIn[7:0];
            $display(&quot;[DataMemory] saved data [%h] into address [%h]&quot;, DataIn, DAddr);
        end
    end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;程序计数器&lt;/h3&gt;
&lt;p&gt;在时钟上升沿处给出下条指令的地址，或在重置信号下降沿处将PC归零。&lt;/p&gt;
&lt;p&gt;PC的下一条指令可能是当前 PC+4，也可能是跳转指令地址，还有可能因为停机而不变。 因此还需要设计一个选择器来选择下一条指令地址的计算方式，为此创建了 JumpPCHelper用于计算 j 指令的下一条 PC 地址，和 NextPCHelper 用于根据指令选择不同的计算方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module PC(
    input CLK,
    input RST,
    input PCWre,
    input [31:0] PCAddr,
    output reg [31:0] NextPCAddr
    );

    initial NextPCAddr = 0;

    always @(posedge CLK or negedge RST) begin
        if (!RST) NextPCAddr &amp;lt;= 0;
        else if (PCWre || !PCAddr) NextPCAddr &amp;lt;= PCAddr;
    end
endmodule

module JumpPCHelper(
    input [31:0] PC,
    input [25:0] NextPCAddr,
    output reg [31:0] JumpPC);

    wire [27:0] tmp;
    assign tmp = NextPCAddr &amp;lt;&amp;lt; 2; // address * 4

    always @(*) begin
        JumpPC[31:28] = PC[31:28];
        JumpPC[27:2] = tmp[27:2];
        JumpPC[1:0] = 0;
    end
endmodule

module NextPCHelper(
    input RST,
    input [1:0] PCSrc,
    input [31:0] PC,
    input [31:0] Immediate,
    input [31:0] RegPC,
    input [31:0] JumpPC,
    output reg [31:0] NextPC);

    always @(RST or PCSrc or PC or Immediate or RegPC or JumpPC) begin
        if (!RST) NextPC = PC + 4;
        else begin
            case (PCSrc)
                `PC_NEXT: NextPC = PC + 4;
                `PC_REL_JUMP: NextPC = PC + 4 + (Immediate &amp;lt;&amp;lt; 2);
                `PC_REG_JUMP: NextPC = RegPC;
                `PC_ABS_JUMP: NextPC = JumpPC;
                default: NextPC = PC + 4;
            endcase
        end
    end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;选择器&lt;/h3&gt;
&lt;p&gt;数据选择，用于数据存储单元之后的选择，这里需要二选一和三选一数据选择器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module Selector1In2#(
    parameter WIDTH = 5
)(
    input Sel,
    input [WIDTH-1:0] A,
    input [WIDTH-1:0] B,
    output [WIDTH-1:0] Y);

    assign Y = Sel ? B : A;
endmodule

module Selector1In3#(
    parameter WIDTH = 5
)(
    input [1:0] Sel,
    input [WIDTH-1:0] A,
    input [WIDTH-1:0] B,
    input [WIDTH-1:0] C,
    output reg [WIDTH-1:0] Y);

    always @(Sel or A or B or C) begin
        case (Sel)
            2'b00: Y &amp;lt;= A;
            2'b01: Y &amp;lt;= B;
            2'b10: Y &amp;lt;= C;
            default: Y &amp;lt;= 0;
        endcase
    end
    
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;指令寄存器&lt;/h3&gt;
&lt;p&gt;用时钟信号 CLK 驱动，采用边缘触发写入指令二进制码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module IR(
    input CLK,
    input IRWre,
    input [31:0] DataIn,
    output reg [31:0] DataOut
    );
    always @(posedge CLK) begin
        if (IRWre) begin
            DataOut &amp;lt;= DataIn;
        end
    end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;数据延迟处理&lt;/h3&gt;
&lt;p&gt;这部分模块用于切割数据通路。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module XDR(
    input CLK,
    input [31:0] DataIn,
    output reg [31:0] DataOut
    );
    always @(negedge CLK) DataOut &amp;lt;= DataIn;
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;CPU&lt;/h2&gt;
&lt;p&gt;有了以上各个模块，一个简单的 CPU 基本就完成了，最后再将他们串起来即可。&lt;/p&gt;
&lt;p&gt;完结撒花。&lt;/p&gt;
</description>
<pubDate>Fri, 15 May 2020 14:54:00 +0000</pubDate>
<dc:creator>hez2010</dc:creator>
<og:description>一点前言 多周期 CPU 相比单周期 CPU 以及流水线的实现来说其实写起来要麻烦那么一些，但是相对于流水线以及单周期 CPU 而言，多周期 CPU 除了能提升主频之外似乎并没有什么卵用。不过我的课题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hez2010/p/12897743.html</dc:identifier>
</item>
<item>
<title> 详解 Spark 中的 Bucketing - 黑客悟理</title>
<link>http://www.cnblogs.com/hackerphysics/p/12897616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hackerphysics/p/12897616.html</guid>
<description>&lt;p&gt;Bucketing 就是利用 buckets（按列进行分桶）来决定数据分区（partition）的一种优化技术，它可以帮助在计算中避免数据交换（avoid data shuffle）。并行计算的时候shuffle常常会耗费非常多的时间和资源.&lt;/p&gt;
&lt;p&gt;Bucketing 的基本原理比较好理解，它会根据你指定的列（可以是一个也可以是多个）计算哈希值，然后具有相同哈希值的数据将会被分到相同的分区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2009208/202005/2009208-20200515222503969-809156655.png&quot; alt=&quot;bucket&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Bucket的最终目的也是实现分区，但是和Partition的原理不同，当我们根据指定列进行Partition的时候，Spark会根据列的名字对数据进行分区(如果没有指定列名则会根据一个随机信息对数据进行分区)。Bucketing的最大不同在于它使用了指定列的哈希值，这样可以保证具有相同列值的数据被分到相同的分区。&lt;/p&gt;

&lt;h2 id=&quot;按bucket保存&quot;&gt;按Bucket保存&lt;/h2&gt;
&lt;p&gt;目前在使用 bucketBy 的时候，必须和 sortBy，saveAsTable 一起使用，如下。这个操作其实是将数据保存到了文件中（如果不指定path，也会保存到一个临时目录中）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-scala&quot;&gt;df.write
  .bucketBy(10, &quot;name&quot;)
  .sortBy(&quot;name&quot;)
  .mode(SaveMode.Overwrite)
  .option(&quot;path&quot;,&quot;/path/to&quot;)
  .saveAsTable(&quot;bucketed&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据分桶保存之后，我们才能使用它。&lt;/p&gt;
&lt;h2 id=&quot;直接从table读取&quot;&gt;直接从table读取&lt;/h2&gt;
&lt;p&gt;在一个SparkSession内，保存之后你可以通过如下命令通过表名获取其对应的DataFrame.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-scala&quot;&gt;val df = spark.table(&quot;bucketed&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中spark是一个SparkSession对象。获取之后就可以使用DataFrame或者在SQL中使用表。&lt;/p&gt;
&lt;h2 id=&quot;从已经保存的parquet文件读取&quot;&gt;从已经保存的Parquet文件读取&lt;/h2&gt;
&lt;p&gt;如果你要使用历史保存的数据，那么就不能用上述方法了，也不能像读取常规文件一样使用 spark.read.parquet() ，这种方式读进来的数据是不带bucket信息的。正确的方法是利用CREATE TABLE 语句，详情可用参考 &lt;a href=&quot;https://docs.databricks.com/spark/latest/spark-sql/language-manual/create-table.html&quot;&gt;https://docs.databricks.com/spark/latest/spark-sql/language-manual/create-table.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE [IF NOT EXISTS] [db_name.]table_name
  [(col_name1 col_type1 [COMMENT col_comment1], ...)]
  USING data_source
  [OPTIONS (key1=val1, key2=val2, ...)]
  [PARTITIONED BY (col_name1, col_name2, ...)]
  [CLUSTERED BY (col_name3, col_name4, ...) INTO num_buckets BUCKETS]
  [LOCATION path]
  [COMMENT table_comment]
  [TBLPROPERTIES (key1=val1, key2=val2, ...)]
  [AS select_statement]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-scala&quot;&gt;spark.sql(
  &quot;&quot;&quot;
    |CREATE TABLE bucketed
    | (name string)
    |  USING PARQUET
    |  CLUSTERED BY (name) INTO 10 BUCKETS
    |  LOCATION '/path/to'
    |&quot;&quot;&quot;.stripMargin)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在我们join两个表的时候，如果两个表最好按照相同的列划分成相同的buckets，就可以完全避免shuffle。根据前面所述的hash值计算方法，两个表具有相同列值的数据会存放在相同的机器上，这样在进行join操作时就不需要再去和其他机器通讯，直接在本地完成计算即可。假设你有左右两个表，各有两个分区，那么join的时候实际计算就是下图的样子，两个机器进行计算，并且计算后分区还是2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2009208/202005/2009208-20200515222504372-2040153072.png&quot; alt=&quot;with bucket&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当需要shuffle的时候，会是这样的，&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2009208/202005/2009208-20200515222504671-188384196.png&quot; alt=&quot;without bucket&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的你可能发现了，上面两个分区对应两个Executor，下面shuffle之后对应的怎么成了三个Executor了？没错，当数据进行shuffle之后，分区数就不再保持和输入的数据相同了，实际上也没有必要保持相同。&lt;/p&gt;
&lt;h2 id=&quot;本地测试&quot;&gt;本地测试&lt;/h2&gt;
&lt;p&gt;我们考虑的是大数据表的连接，本地测试的时候一般使用小的表，所以逆序需要将小表自动广播的配置关掉。如果开启小表广播，那么两个小表的join之后分区数是不会变的，例如：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表分区数&lt;/th&gt;
&lt;th&gt;右表分区数数&lt;/th&gt;
&lt;th&gt;Join之后的分区数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;关闭配置的命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-scala&quot;&gt;spark.conf.set(&quot;spark.sql.autoBroadcastJoinThreshold&quot;, -1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常情况下join之后分区数会发生变化：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表分区数&lt;/th&gt;
&lt;th&gt;右表分区数数&lt;/th&gt;
&lt;th&gt;Join之后的分区数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个200其实就是 &quot;spark.sql.shuffle.partitions&quot; 配置的值，默认就是200. 所以如果在Join过程中出现了shuffle，join之后的分区一定会变，并且变成spark.sql.shuffle.partitions的值。通常你需要根据自己的集群资源修改这个值，从而优化并行度，但是shuffle是不可避免的。&lt;/p&gt;
&lt;h2 id=&quot;左右两个表bucket数目不一致时&quot;&gt;左右两个表Bucket数目不一致时&lt;/h2&gt;
&lt;p&gt;实际测试结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表Bucket数&lt;/th&gt;
&lt;th&gt;右表Bucekt数&lt;/th&gt;
&lt;th&gt;Join之后的分区数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Spark依然会利用一些Bucekt的信息，但具体怎么执行目前还不太清楚，还是保持一致的好。&lt;/p&gt;
&lt;p&gt;另外，如果你spark job的可用计算核心数小于Bucket值，那么从文件中读取之后Bucekt值会变，就是说bucket的数目不会超过你能使用的最大计算核数。&lt;/p&gt;
&lt;h2 id=&quot;不要使用的--符号！！！&quot;&gt;不要使用的 &amp;lt;=&amp;gt; 符号！！！&lt;/h2&gt;
&lt;p&gt;在处理null值的时候，我们可能会用到一些特殊的函数或者符号，如下表所示。但是在使用bucket的时候这里有个坑，一定要躲过。join的时候千万不要使用 &amp;lt;=&amp;gt; 符号，使用之后spark就会忽略bucket信息，继续shuffle数据，原因可能和hash计算有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2009208/202005/2009208-20200515222505008-77452954.png&quot; alt=&quot;null&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hackerphysics.com/posts/40356/&quot;&gt;原文连接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你喜欢我的文章，可以在&lt;strong&gt;任一&lt;/strong&gt;平台搜索【黑客悟理】关注我，非常感谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 15 May 2020 14:25:00 +0000</pubDate>
<dc:creator>黑客悟理</dc:creator>
<og:description>什么是 Bucketing Bucketing 就是利用 buckets（按列进行分桶）来决定数据分区（partition）的一种优化技术，它可以帮助在计算中避免数据交换（avoid data shu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hackerphysics/p/12897616.html</dc:identifier>
</item>
</channel>
</rss>