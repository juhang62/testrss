<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 9.0 新特性之模式匹配简化 - LiamWang</title>
<link>http://www.cnblogs.com/willick/p/13129012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13129012.html</guid>
<description>&lt;p&gt;阅读本文大概需要 2 分钟。&lt;/p&gt;
&lt;p&gt;记得在 MS Build 2020 大会上，C# 语言开发项目经理 Mads Torgersen 宣称 C# 9.0 将会随着 .NET 5 在今年 11 月份正式发布。目前 .NET 5 已经到了 Preview 5 阶段了，C# 9.0 也已经初具规模。忍不住激动的心情，暂停更新《C#.NET 拾遗补漏》系列几天，先要和大家分享一下我了解到的 C# 9.0 的新特性。由于新特性比较多，所以会分成几篇来讲。这是第一篇，专讲模式匹配这个特性的简化。&lt;/p&gt;
&lt;p&gt;模式匹配（Pattern Matching）是在 C# 7.0 引入的，是对 switch 语句的增强，可以支持实现复杂的条件匹配。下面我先用一个示例来展示一下模式匹配的一般的用法。&lt;/p&gt;
&lt;p&gt;假如现在我们要计算各种车辆在某高速的通行费，比如有下面四种车辆，分别定义为以下四个类，各个类中定义了和通行费计算相关的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Car
{
    public int Passengers { get; set; }
}

public class DeliveryTruck
{
    public int GrossWeightClass { get; set; }
}

public class Taxi
{
    public int Fares { get; set; }
}

public class Bus
{
    public int Capacity { get; set; }
    public int Riders { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面用用模式匹配的方式来实现一个计算通行费的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public decimal CalculateToll(object vehicle) =&amp;gt;
    vehicle switch
{
    Car { Passengers: 0}        =&amp;gt; 2.00m + 0.50m,
    Car { Passengers: 1}        =&amp;gt; 2.0m,
    Car { Passengers: 2}        =&amp;gt; 2.0m - 0.50m,
    Car c                       =&amp;gt; 2.00m - 1.0m,

    Taxi t =&amp;gt; t.Fares switch
    {
        0 =&amp;gt; 3.50m + 1.00m,
        1 =&amp;gt; 3.50m,
        2 =&amp;gt; 3.50m - 0.50m,
        _ =&amp;gt; 3.50m - 1.00m
    },

    Bus b when ((double)b.Riders / (double)b.Capacity) &amp;lt; 0.50 =&amp;gt; 5.00m + 2.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) &amp;gt; 0.90 =&amp;gt; 5.00m - 1.00m,
    Bus b =&amp;gt; 5.00m,

    DeliveryTruck t when (t.GrossWeightClass &amp;gt; 5000) =&amp;gt; 10.00m + 5.00m,
    DeliveryTruck t when (t.GrossWeightClass &amp;lt; 3000) =&amp;gt; 10.00m - 2.00m,
    DeliveryTruck _ =&amp;gt; 10.00m,

    { } =&amp;gt; throw new ArgumentException(message: &quot;Not a known vehicle type&quot;, paramName: nameof(vehicle)),
    null =&amp;gt; throw new ArgumentNullException(nameof(vehicle))
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码来源于文末参考链接&lt;/p&gt;
&lt;p&gt;如果上面代码阅读起来感觉吃力，你可以先阅读文末参考链接中的第一个链接，关于模式匹配的详细介绍。&lt;/p&gt;
&lt;p&gt;实现这个业务逻辑，若在 C# 7.0 之前，需要用一堆的 if/else 来实现。有了模式匹配后，变得方便了很多，而且使用上很灵活，代码结构也更优美。&lt;/p&gt;
&lt;p&gt;对我来说，模式匹配是个极好的特性！但这还不够，C# 9.0 对模式匹配的写法做了进一步的简化！&lt;/p&gt;
&lt;p&gt;以上面代码为例，模式匹配可以分为三种：简单模式、关系模式和逻辑模式。下面分别说说 C# 9.0 对三种模式的简化。&lt;/p&gt;
&lt;h3 id=&quot;简单模式&quot;&gt;简单模式&lt;/h3&gt;
&lt;p&gt;以上面 &lt;code&gt;CalculateToll&lt;/code&gt; 方法示例代码为例，简单模式是这种：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;vehicle switch
{
    ...
    Car c =&amp;gt; 2.00m - 1.0m
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们其实可以发现，上面的变量 &lt;code&gt;c&lt;/code&gt; 声明了却没用被使用，现在 C# 9.0 中可以把它省略了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;vehicle switch
{
    ...
    Car =&amp;gt; 2.00m - 1.0m
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关系模式&quot;&gt;关系模式&lt;/h3&gt;
&lt;p&gt;以上面 &lt;code&gt;CalculateToll&lt;/code&gt; 方法示例代码为例，关系模式是通过比较（大小）关系来匹配的，对应的代码片段如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DeliveryTruck t when (t.GrossWeightClass &amp;gt; 5000) =&amp;gt; 10.00m + 5.00m,
DeliveryTruck t when (t.GrossWeightClass &amp;lt; 3000) =&amp;gt; 10.00m - 2.00m,
DeliveryTruck _ =&amp;gt; 10.00m,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在 C# 9.0 可以简写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DeliveryTruck t when t.GrossWeightClass switch
{
    &amp;gt; 5000 =&amp;gt; 10.00m + 5.00m,
    &amp;lt; 3000 =&amp;gt; 10.00m - 2.00m,
    _ =&amp;gt; 10.00m,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;逻辑模式&quot;&gt;逻辑模式&lt;/h3&gt;
&lt;p&gt;在 C# 9.0 中，你可以通过逻辑操作符 &lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt; 和 &lt;code&gt;not&lt;/code&gt; 对模式进行组合，下面是一些示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;DeliveryTruck t when t.GrossWeightClass switch
{
    &amp;lt; 3000 =&amp;gt; 10.00m - 2.00m,
    &amp;gt;= 3000 and &amp;lt;= 5000 =&amp;gt; 10.00m,
    &amp;gt; 5000 =&amp;gt; 10.00m + 5.00m,
}

not null =&amp;gt; throw new ArgumentException($&quot;Not a known vehicle type: {vehicle}&quot;, nameof(vehicle)),
null =&amp;gt; throw new ArgumentNullException(nameof(vehicle))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，&lt;code&gt;not&lt;/code&gt; 关键字还可以用来替代 if 条件判断中的逻辑非(!)，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;// 原来的写法
if (!(e is Customer)) { ... }

// 新的写法（易读性更好）
if (e is not Customer) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C# 9.0 还有很多其它好用的新特性，下一篇文章继续与你分享。文章写短一点不是因为我偷懒哈，而是为了促使大家一次性看完，方便大家在零碎时间阅读，避免因文章太长而成为“收藏不看”系列。&lt;/p&gt;
&lt;p&gt;敬请关注我明天下一篇关于 C# 9.0 新特性的介绍，明天不见不散。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://bit.ly/2MNc0DJ&quot;&gt;https://bit.ly/2MNc0DJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bit.ly/2UzEIwu&quot;&gt;https://bit.ly/2UzEIwu&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Jun 2020 00:51:00 +0000</pubDate>
<dc:creator>LiamWang</dc:creator>
<og:description>阅读本文大概需要 2 分钟。 记得在 MS Build 2020 大会上，C# 语言开发项目经理 Mads Torgersen 宣称 C# 9.0 将会随着 .NET 5 在今年 11 月份正式发布。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13129012.html</dc:identifier>
</item>
<item>
<title>面试官：淦！0202年你还不知道面向对象？ - 山禾说</title>
<link>http://www.cnblogs.com/viyoung/p/13128956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/13128956.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2020年6月13日 多云转暴雨&lt;/strong&gt;⛈️&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;I'm &lt;s&gt;sad,tired,negative,powerless,miss,lonely&lt;/s&gt; fine :)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;那你回去等通知吧&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：我看你简历上说，你的主要编程语言是&lt;strong&gt;Java&lt;/strong&gt;，偶尔也用&lt;strong&gt;Python&lt;/strong&gt;，那么你可以说一下这两个的相同点在什么地方吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;山禾：它们都是高级程序设计语言，都是面向对象的语言。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：那你讲讲你是怎么理解面向对象的吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;山禾：emmm。。封装，继承，多态是面向对象的三大特征。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：还有其他要补充的吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;山禾：没了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;strong&gt;那你回去等通知吧&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;是什么&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;痛定思痛，挫折只会让我变得更强，奥利给！下面开始进入正文，首先我们需要知道面向对象是什么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向对象，顾名思义，是面向&lt;strong&gt;对象&lt;/strong&gt;，也就是说单身狗是不配使用面向对象的编程语言的（当然只是开个玩笑，逃）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对象&lt;/strong&gt;，就是把现实世界中的&lt;strong&gt;实物&lt;/strong&gt;映射抽象到虚拟世界中，把实物的属性和行为，通过代码的方式表达出来。然后通过设计对象的&lt;strong&gt;数据结构&lt;/strong&gt;（属性），然后使用&lt;strong&gt;算法&lt;/strong&gt;进行行为的模拟（方法），就完成了从现实到虚拟的一个映射。&lt;/p&gt;
&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;实体&lt;/th&gt;
&lt;th&gt;对象&lt;/th&gt;
&lt;th&gt;类&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;数据结构&lt;/td&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;行为&lt;/td&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与面向对象经常拿来对比的就是面向过程编程，那么他们之间的区别在什么地方呢？&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;面向过程和面向对象&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面向过程编程，打个比方，我们买过的一般的玩具（变形金刚），我们必须要按照它说明书上的步骤，一步一步的去组装，才能得到最后的玩具，如果我们想要一个新的玩具，就要去商场买一个新的，然后按照说明书的顺序一步一步的组装。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而面向对象编程，就可以理解为积木，没有一个固定的拼装方式，我们可以发挥自己的想象力，去自由的拼装和组装，同样的模块在不同的地方可以起到不同的作用（多态），一块儿积木就是一个最小的单位，我们不用去关心积木是怎么造的（封装）。也可以用多个对象组装起来去拼装成一个新的对象（继承）。大大的方便了我们的设计，不再拘泥于过程，极大程度上的放飞了生产力和效率。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;为什么&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚已经了解了面向对象是什么，下面我们来说一下，为什么要用面向对象编程&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;首先从理解角度上来说，它符合我们对现实世界的认知习惯，更容易去理解、实现和设计我们的需求。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;其次从软件设计的角度上来说，行为的实现对于外部是完全封闭的，只需要提供对应的接口就可以获得相应的结果，降低了代码与代码之间的耦合度。符合我们高内聚，低耦合的设计理念。&lt;strong&gt;优雅，客观，层次分明&lt;/strong&gt;，像积木一样，可以方便的实现插拔和维护，对象组合而成的模块化和服务化，更是大大扩展了系统的伸缩性，便于&lt;strong&gt;维护、扩展和复用&lt;/strong&gt;。这也是为什么越来越多的编程语言选择向这个方向去靠拢（ TypeScript说的就是你&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;怎么用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚刚我一直忍住，没有去提面向对象的三大特性：封装、继承和多态，我相信我们有一些经验的开发人员来说，这三个词语是再熟悉不过了。下面，我通过代码的方式，来看看这三个特性在代码中的模拟应用。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;封装&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Uzi&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String type;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String bestHero;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Status status;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;status.say();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Status&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是一段非常简单的代码，我定义了一个很简单的类，里面的&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;type&lt;/code&gt;，&lt;code&gt;bestHero&lt;/code&gt;对于我们来说都是一个包装在盒子里的东西。比如：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    Uzi uzi = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uzi();&lt;br/&gt;uzi.setType(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ADC&quot;&lt;/span&gt;);&lt;br/&gt;uzi.setBestHero(&lt;span class=&quot;hljs-string&quot;&gt;&quot;孙尚香&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到的Uzi可能就是一个主玩孙尚香的职业ADC选手（🐶狗头保命，我啥都不知道），他怎么玩的，我们不需要知道，我们只需要知道他这样的一名选手就可以了。这就是封装的魅力：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;隐藏了实现的细节，提供对外的访问方式。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;外部如果想要访问，必须经过这个方法。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;继承&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了封装，下面我们来看继承，我们分别用三个状态去继承Status类：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ShunFeng&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Status&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;顺风狂小狗&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NiFeng&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Status&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;逆风简自豪&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;JueJing&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Status&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;绝境Uzi&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字&lt;strong&gt;extends&lt;/strong&gt;表示正在构造的新类派生于一个已经存在类。这个已经存在的类被称为父类（超类，基类）；新创建的类被称为子类。在通过扩展父类定义子类的时候，仅仅需要指出子类和父类的不同之处。因此在设计类的时候，应该将通用的方法放在父类中，而将具有特殊用途的方法放在子类中。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只是在父类&lt;code&gt;Status&lt;/code&gt;中定义了say方法，然后三种不同的类去继承这个类，然后实现方法，这样就体现出了面向对象在设计上的可扩展性，但是需要注意的是，继承会破坏封装，我们需要谨慎使用，尽量使用一些设计模式去避免继承，合理使用，才能体现出它的优势～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了继承，接下来就要去说多态了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;多态&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说多态之前，我们先来看一下代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Uzi uzi1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uzi();&lt;br/&gt;ShunFeng shunFeng = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ShunFeng();&lt;br/&gt;uzi1.setStatus(shunFeng);&lt;br/&gt;Uzi uzi2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uzi();&lt;br/&gt;NiFeng niFeng = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; NiFeng();&lt;br/&gt;uzi2.setStatus(niFeng);&lt;br/&gt;Uzi uzi3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uzi();&lt;br/&gt;JueJing jueJing = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JueJing();&lt;br/&gt;uzi3.setStatus(jueJing);&lt;p&gt;&lt;br/&gt;Uzi[] uzis = {uzi1,uzi2,uzi3};&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Uzi uzi : uzis) {&lt;br/&gt;uzi.play();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序的结果： &lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2020/06/13/15920440449129.jpg?image/auto-orient,1/quality,q_90&quot; alt=&quot;&quot;/&gt; （TMD，泪目，👴青结）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的多态就是一个对象变量（比如上文中的status变量）可以指示多种实际类型的现象（比如status既可以引用Status对象，也可以引用它的子类ShunFeng对象）被称为&lt;strong&gt;多态&lt;/strong&gt;。在运行时候能够自动地选择调用哪个方法的现象被称为&lt;strong&gt;动态绑定&lt;/strong&gt;，上面打印出的语句，就说明了这一点。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;后续&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来我们天天挂在口边的面向对象，其实某种程度上来说，&lt;strong&gt;更像是一种哲学，一种计算机科学发展的自然规则。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你有学到，请给我点赞👍+关注，这是对一个✊坚持原创作者的最大支持！我是山禾，千篇一律的皮囊，万里挑一的灵魂，一个不太一样的写手。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;世事洞明皆学问，人情练达即文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://viyoungblog.oss-cn-beijing.aliyuncs.com/qrcode_for_gh_a65beceb0947_258_20200615083058.jpg&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Mon, 15 Jun 2020 00:32:00 +0000</pubDate>
<dc:creator>山禾说</dc:creator>
<og:description>你先回去等通知吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/13128956.html</dc:identifier>
</item>
<item>
<title>一文读懂Redis的四种模式，单机、主从、哨兵、集群 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13128955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13128955.html</guid>
<description>&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;少点代码，多点头发&lt;/p&gt;
&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已经被GitHub收录,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/midou-tech/articles&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;入职第一周，我被坑了&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近刚入职新公司，本来想着这刚来新公司，一般都是熟悉熟悉公司同事，看看组内工程文档，找几个demo自己练练手。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咳咳咳，万万没想到啊，一切都是我以为的，我还是太&lt;strong&gt;嫩&lt;/strong&gt;了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入职那天下午，组长给我丢了几个文档，让我看下这个这些工程的缓存系统问题，让我把redis升级为哨兵模式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接到任务的我，内心是懵逼的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gfhur27smkj3064064dfs.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一、不知道都是些什么类型的服务在用redis。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二、不知道以什么姿势在用redis。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三、如果redis挂了会不会影响用户。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四、我完全没用过redis。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说没干过，但咋也&lt;strong&gt;不怂&lt;/strong&gt;。毕竟要是天天干的都是&lt;strong&gt;干过&lt;/strong&gt;的工作，那就是有问题了，很快就被优化掉了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来社招入职和校招还是不一样的，校招进来都会有些入职培训或者新人班课程。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这些形式的教育，第一、了解公司的文化、价值观，第二、学习工作流程、感受公司技术氛围。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;任务&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把我们部门所有使用redis服务升级到&lt;strong&gt;哨兵&lt;/strong&gt;模式。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;redis的多种模式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都说了升级到哨兵模式，那之前用的不是哨兵模式，肯定还有其他模式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单机模式、主从模式、哨兵模式、集群模式&lt;/strong&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;单机模式&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个最简单，一看就懂。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是安装一个redis，启动起来，业务调用即可。具体安装步骤和启动步骤就不赘述了，网上随便搜一下就有了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机在很多场景也是有使用的，例如在一个并非必须保证高可用的情况下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咳咳咳，其实我们的服务使用的就是redis单机模式，所以来了就让我改为哨兵模式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说说单机的&lt;strong&gt;优缺点&lt;/strong&gt;吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;部署简单，0成本。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;成本低，没有备用节点，不需要其他的开支。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;高性能，单机不需要同步数据，数据天然一致性。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;可靠性保证不是很好，单节点有宕机的风险。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;单机高性能受限于CPU的处理能力，redis是单线程的。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机模式选择需要根据自己的业务场景去选择，如果需要很高的性能、可靠性，单机就不太合适了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;主从复制&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfitgiiz4hj30ra0o6abx.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从模式配置很简单，只需要在从节点配置主节点的ip和端口号即可。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;
# 例如
# slaveof &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.1.214 &lt;span class=&quot;hljs-number&quot;&gt;6379&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动&lt;strong&gt;主从&lt;/strong&gt;节点的所有服务，查看日志即可以看到&lt;strong&gt;主从&lt;/strong&gt;节点之间的服务连接。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面很容易就想到一个问题，既然主从复制，意味着master和slave的数据都是一样的，有数据冗余问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在程序设计上，为了高可用性和高性能，是允许有冗余存在的。这点希望大家在设计系统的时候要考虑进去，不用为公司节省这一点资源。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于追求极致&lt;strong&gt;用户体验&lt;/strong&gt;的产品，是绝对不允许有&lt;strong&gt;宕机&lt;/strong&gt;存在的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从模式在很多系统设计时都会考虑，一个master挂在多个slave节点，当master服务宕机，会&lt;strong&gt;选举&lt;/strong&gt;产生一个新的master节点，从而保证服务的高可用性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从模式的优点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;一旦 主节点宕机，&lt;strong&gt;从节点&lt;/strong&gt; 作为 主节点 的 &lt;strong&gt;备份&lt;/strong&gt; 可以随时顶上来。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;扩展 &lt;strong&gt;主节点&lt;/strong&gt; 的 &lt;strong&gt;读能力&lt;/strong&gt;，分担主节点读压力。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;高可用基石：除了上述作用以外，主从复制还是哨兵模式和集群模式能够实施的基础，因此说主从复制是Redis高可用的基石。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有相应的缺点，比如我刚提到的数据冗余问题：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;一旦 &lt;strong&gt;主节点宕机&lt;/strong&gt;，&lt;strong&gt;从节点&lt;/strong&gt; 晋升成 &lt;strong&gt;主节点&lt;/strong&gt;，同时需要修改 &lt;strong&gt;应用方&lt;/strong&gt; 的 &lt;strong&gt;主节点地址&lt;/strong&gt;，还需要命令所有 &lt;strong&gt;从节点&lt;/strong&gt; 去 &lt;strong&gt;复制&lt;/strong&gt; 新的主节点，整个过程需要 &lt;strong&gt;人工干预&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;主节点&lt;/strong&gt; 的 &lt;strong&gt;写能力&lt;/strong&gt; 受到 &lt;strong&gt;单机的限制&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;主节点&lt;/strong&gt; 的 &lt;strong&gt;存储能力&lt;/strong&gt; 受到 &lt;strong&gt;单机的限制&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;哨兵模式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚刚提到了，主从模式，当主节点宕机之后，从节点是可以作为主节点顶上来，继续提供服务的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有一个问题，主节点的IP已经变动了，此时应用服务还是拿着&lt;strong&gt;原&lt;/strong&gt;主节点的地址去访问，这...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，在Redis 2.8版本开始引入，就有了哨兵这个概念。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;复制的基础&lt;/strong&gt;上，哨兵实现了&lt;strong&gt;自动化&lt;/strong&gt;的故障恢复。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfitueyqq3j30ys0n476e.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，哨兵节点由两部分组成，哨兵节点和数据节点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据节点：主节点和从节点都是数据节点。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问redis集群的数据都是通过哨兵集群的，哨兵监控整个redis集群。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦发现redis集群出现了问题，比如刚刚说的主节点挂了，从节点会顶上来。但是主节点地址变了，这时候应用服务无感知，也不用更改访问地址，因为哨兵才是和应用服务做交互的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 很好的解决了故障转移，在高可用方面又上升了一个台阶，当然Sentinel还有其他功能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;strong&gt;主节点存活检测&lt;/strong&gt;、&lt;strong&gt;主从运行情况检测&lt;/strong&gt;、&lt;strong&gt;主从切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis的Sentinel最小配置是 &lt;strong&gt;一主一从&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;说下哨兵模式监控的原理&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Sentinel以 每秒钟 一次的频率，向它&lt;strong&gt;所有&lt;/strong&gt;的 &lt;strong&gt;主服务器&lt;/strong&gt;、&lt;strong&gt;从服务器&lt;/strong&gt; 以及其他Sentinel&lt;strong&gt;实例&lt;/strong&gt; 发送一个PING 命令。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfixu17nfyj30vg0ng41n.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个 实例（instance）距离最后一次有效回复 PING命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel标记为 &lt;strong&gt;主观下线&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个 &lt;strong&gt;主服务器&lt;/strong&gt; 被标记为 &lt;strong&gt;主观下线&lt;/strong&gt;，那么正在 监视 这个 主服务器 的&lt;strong&gt;所有&lt;/strong&gt; Sentinel 节点，要以 &lt;strong&gt;每秒一次&lt;/strong&gt; 的频率确认 该主服务器是否的确进入了 &lt;strong&gt;主观下线&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个 主服务器 被标记为 主观下线，并且有 &lt;strong&gt;足够数量&lt;/strong&gt; 的 Sentinel（至少要达到配置文件指定的数量）在指定的 &lt;strong&gt;时间范围&lt;/strong&gt; 内同意这一判断，那么这个该主服务器被标记为 &lt;strong&gt;客观下线&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一般情况下， 每个 Sentinel 会以每 10秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个 &lt;strong&gt;主服务器&lt;/strong&gt; 被 Sentinel标记为 &lt;strong&gt;客观下线&lt;/strong&gt; 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 INFO 命令的频率，会从10秒一次改为 每秒一次。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel和其他 Sentinel 协商 &lt;strong&gt;主节点&lt;/strong&gt; 的状态，如果 主节点处于 &lt;strong&gt;SDOWN`&lt;strong&gt;状态，则投票&lt;/strong&gt;自动选出&lt;/strong&gt;新的主节点。将剩余的 &lt;strong&gt;从节点&lt;/strong&gt; 指向 &lt;strong&gt;新的主节点&lt;/strong&gt; 进行 &lt;strong&gt;数据复制&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当没有足够数量的 Sentinel 同意 主服务器 下线时， 主服务器 的 &lt;strong&gt;客观下线状态&lt;/strong&gt; 就会被移除。当 &lt;strong&gt;主服务器&lt;/strong&gt; 重新向 Sentinel的PING命令返回 有效回复 时，主服务器 的 &lt;strong&gt;主观下线状态&lt;/strong&gt; 就会被移除。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;哨兵模式的优缺点&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​ 优点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;主从可以自动切换，系统更健壮，可用性更高。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。当被监控的某个 Redis 服务器出现问题，Sentinel 通过API脚本向管理员或者其他的应用程序发送通知。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​ 缺点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Redis较难支持在线扩容，对于集群，容量达到上限时在线扩容会变得很复杂。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;我的任务&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我部署的redis服务就如上图所示，三个哨兵节点，三个主从复制节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用java的jedis去访问我的redis服务，下面来一段简单的演示代码(并非工程里面的代码)：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testSentinel&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{
     
         String masterName = &lt;span class=&quot;hljs-string&quot;&gt;&quot;master&quot;&lt;/span&gt;;
         Set&amp;lt;String&amp;gt; sentinels = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
     
         sentinels.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.200,213:26379&quot;&lt;/span&gt;);
         sentinels.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.200.214:26380&quot;&lt;/span&gt;);
         sentinels.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.200.215:26381&quot;&lt;/span&gt;);
 
     
         JedisSentinelPool pool = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JedisSentinelPool(masterName, sentinels); 
     
         Jedis jedis = pool.getResource();
     
         jedis.set(&lt;span class=&quot;hljs-string&quot;&gt;&quot;key1&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;value1&quot;&lt;/span&gt;);
     
     jedis.get(&lt;span class=&quot;hljs-string&quot;&gt;&quot;key1&quot;&lt;/span&gt;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体部署的配置文件这里太长了，需要的朋友可以公众号后台回复【redis配置】获取。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听起来是入职第二天就部署了任务感觉很难的样子。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实现在看来是个so easy的任务，申请一个redis集群，自己配置下。在把工程里面使用到redis的地方改一下，之前使用的是一个两个单机节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;干完，收工。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfiy23mlv6g306o06oaao.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然领导的任务完成了，但并不意味着学习redis的路结束了。爱学习的龙叔，继续研究了下redis的集群模式。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;集群模式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从不能解决故障自动恢复问题，哨兵已经可以解决故障自动恢复了，那到底为啥还要集群模式呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从和哨兵都还有另外一些问题没有解决，单个节点的存储能力是有上限，访问能力是有上限的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 集群模式具有 &lt;strong&gt;高可用&lt;/strong&gt;、&lt;strong&gt;可扩展性&lt;/strong&gt;、&lt;strong&gt;分布式&lt;/strong&gt;、&lt;strong&gt;容错&lt;/strong&gt; 等特性。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Cluster 集群模式的原理&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数据分片的方式来进行数据共享问题，同时提供数据复制和故障转移功能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的两种模式数据都是在一个节点上的，单个节点存储是存在上限的。集群模式就是把数据进行分片存储，当一个分片数据达到上限的时候，就分成多个分片。&lt;/p&gt;
&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据分片怎么分？&lt;/span&gt;&lt;/h5&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群的键空间被分割为16384个slots（即hash槽），通过hash的方式将数据分到不同的分片上的。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;HASH_SLOT = CRC16(key) &amp;amp; &lt;span class=&quot;hljs-number&quot;&gt;16384&lt;/span&gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CRC16是一种循环校验算法，这里不是我们研究的重点，有兴趣可以看看。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用了&lt;strong&gt;位运算&lt;/strong&gt;得到取模结果，位运算的速度高于取模运算。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfjigqb0omj315w0pc776.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个很重要的问题，为什么是分割为16384个槽？这个问题可能会被面试官随口一问&lt;/p&gt;
&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据分片之后怎么查，怎么写？&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfjiydi719j31980pk426.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读请求分配给slave节点，写请求分配给master，数据同步从master到slave节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读写分离&lt;/strong&gt;提高并发能力，增加高性能。&lt;/p&gt;
&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;如何做到水平扩展？&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfjj6f6zcqj318h0u043d.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;master节点可以做扩充，数据迁移redis内部自动完成。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你新增一个master节点，需要做数据迁移，redis服务不需要下线。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子：上面的有三个master节点，意味着redis的槽被分为三个段，假设三段分别是0~7000，7001~12000、12001~16383。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在因为业务需要新增了一个master节点，四个节点共同占有16384个槽。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;槽需要重新分配，数据也需要重新迁移，但是服务不需要下线。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis集群的重新分片由redis内部的管理软件redis-trib负责执行。redis提供了进行重新分片的所有命令，redis-trib通过向节点发送命令来进行重新分片。&lt;/p&gt;
&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;如何做故障转移？&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gfjjuellcgj316q0u0gqk.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如途中红色的节点故障了，此时master3下面的从节点会通过 &lt;strong&gt;选举&lt;/strong&gt; 产生一个主节点。替换原来的故障节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此过程和哨兵模式的故障转移是一样的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种模式都有各自的优缺点，在实际使用场景中要根据业务特点去选择合适的模式。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis是一个非常&lt;strong&gt;常用&lt;/strong&gt;的中间件，作为一个使用者来说，学习成本一点不高。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果作为一个很好的中间件去研究的话，还是有很多值得学习和借鉴的地方。比如redis的各种数据结构(动态字符串、跳跃表、集合、字典等)、高效的内存分配(jemalloc)、高效的IO模型等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个点都可以深入研究，在后期设计高并发、高可用系统的时候融入进去。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是龙叔，一个分享互联网技术和成长心路历程的star。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gev88f8kfvj30p00dw0tn.jpg&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Mon, 15 Jun 2020 00:31:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>Redis的四种模式详解，单机、主从、哨兵、集群模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13128955.html</dc:identifier>
</item>
<item>
<title>网页元素居中的n种方法 - 丰臣正一</title>
<link>http://www.cnblogs.com/cnroadbridge/p/13128943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnroadbridge/p/13128943.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;导语：元素居中对齐在很多场景看上去很和谐很漂亮。除此之外，对于前端开发面试者的基础也是很好的一个考察点。下面跟着作者的思路，一起来看下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;场景分析&quot;&gt;场景分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个元素，它有可能有背景，那我要它的背景居中对齐&lt;/li&gt;
&lt;li&gt;一个元素，它还有可能有个父级元素，那我要它居中于其父级元素&lt;/li&gt;
&lt;li&gt;一个元素，它也有可能还带有一些子内容，我要让它的子内容居中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;场景建模&quot;&gt;场景建模&lt;/h2&gt;
&lt;p&gt;根据场景分析提出的一些假设，我们试着去建立对应的模型，下面是分别根据上面的三个场景设计的相关模型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;搞父子元素居中对齐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202006/2055171-20200615082212222-349199370.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;搞元素背景居中对齐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202006/2055171-20200615082226483-1696347594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;搞元素内容居中对齐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2055171/202006/2055171-20200615082241956-306194736.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景实现&quot;&gt;场景实现&lt;/h2&gt;
&lt;h3 id=&quot;相关说明&quot;&gt;相关说明&lt;/h3&gt;
&lt;p&gt;为了统一，这里我们定义一个&lt;code&gt;400*400px&lt;/code&gt;的带着黑色边框粉红色身体的类名为&lt;code&gt;.box&lt;/code&gt;的父容器，它有可能会有一个&lt;code&gt;200*200px&lt;/code&gt;的带着原谅色身体的类名为&lt;code&gt;.box-son&lt;/code&gt;的子容器。这里为了效果能够直观且明显，笔者故意把背景图片的原始大小处理成小于宿主像素的大小。好吧，我们开始吧！&lt;/p&gt;
&lt;h3 id=&quot;背景居中&quot;&gt;背景居中&lt;/h3&gt;
&lt;p&gt;我们做这样一件事，在一个div容器中，我们通过&lt;code&gt;background-image&lt;/code&gt;属性引入一张背景，之后我们期望这张引入的背景呢，它能够水平垂直居中于宿主元素。&lt;/p&gt;
&lt;p&gt;这里介绍两个属性&lt;code&gt;background-repeat&lt;/code&gt;和&lt;code&gt;background-position&lt;/code&gt;，如果你初中英语好的话，我想你也应该知道了，这里字面意思就是这个属性的意思。一个是设置背景图片怎么铺宿主元素（默认时铺满的）更美丽的，另一个是设置背景图片相对于宿主元素的的位置，你可以传像素、百分比、相关方向单词（top、bottom、left、right）给它。当其为百分比的时候，它的计算公式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(container width - image width) * (position x%) = (x offset value)
(container height - image height) * (position y%) = (y offset value)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简言之，就是宿主元素的宽高减去图片宽高乘以相关百分比就是相对于宿主元素左上角那个原点的位置。&lt;/p&gt;
&lt;p&gt;在背景图片不重复的情况下，你想让一张图片居中于宿主元素的方法，可以有&lt;code&gt;background-postion: center center&lt;/code&gt;、&lt;code&gt;background-postion: 50%, 50%&lt;/code&gt;,也可以简写成&lt;code&gt;background-postion: center&lt;/code&gt;或者&lt;code&gt;background-postion: 50%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以，在楼上这些前提下，我们大致能够归出一个类，形如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;/** 这里以复杂写法的百分比为例， 分别代表距离宿主元素左上角的x和y轴的距离**/
.box-son {
        background-repeat: no-repeat;
        background-position: 50%, 50%;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文字内容居中&quot;&gt;文字内容居中&lt;/h3&gt;
&lt;p&gt;如果宿主元素的内容是文字之类的，我们期望它能够居中于宿主元素，这里用到两个属性，一个是&lt;code&gt;text-align&lt;/code&gt;，一个是&lt;code&gt;line-height&lt;/code&gt;。&lt;code&gt;text-algin:center&lt;/code&gt;可以使内容水平居中于宿主元素，将&lt;code&gt;line-height&lt;/code&gt;设置成宿主元素相同的高度，便可让宿主元素垂直居中。&lt;/p&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example11&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example11&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;子元素居中于父元素&quot;&gt;子元素居中于父元素&lt;/h3&gt;
&lt;h4 id=&quot;相关说明-2&quot;&gt;相关说明&lt;/h4&gt;
&lt;p&gt;这里解释下，父相子绝，这个是我阉割了“父级元素相对定位，子级元素绝对定位”这句话浓缩后的叫法。后面出现这个概念我就不过多再进行重复介绍了。&lt;/p&gt;
&lt;h4 id=&quot;父相子绝--margin-auto&quot;&gt;父相子绝 + margin: auto&lt;/h4&gt;
&lt;p&gt;父元素相对定位子元素绝对定位后，设置其&lt;code&gt;top、right、bottom、left&lt;/code&gt;都为0，之后我们将其的&lt;code&gt;margin&lt;/code&gt;设置为&lt;code&gt;auto&lt;/code&gt;。这样子的话，父级元素与子级元素他们之间空出来的部分都会被这个&lt;code&gt;margin&lt;/code&gt;均匀撑开。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-position {
    position: relative;
}

.box-example1 {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example1&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example1&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;父相子绝--负值margin&quot;&gt;父相子绝 + 负值margin&lt;/h4&gt;
&lt;p&gt;父元素相对定位子元素绝对定位后，子元素设置&lt;code&gt;top: 50%; left:50%;&lt;/code&gt;，这里的百分比参考值是相对于父元素的宽高，参考的点是父元素的左上角和子元素的左上角，所以我们需要矫正一下，减去子元素宽高的一半。这件事可以让子元素的&lt;code&gt;margin&lt;/code&gt;代劳。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-position {
    position: relative;
}

.box-example2 {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -100px;
    margin-top: -100px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接： &lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example2&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example2&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;父相子绝--平移（translate）&quot;&gt;父相子绝 + 平移（translate）&lt;/h4&gt;
&lt;p&gt;在楼上那个例子的基础上，为了矫正子元素的偏移，我们其实还可以用css的平移属性。这个平移的百分比是相对于其本身的宽高的，所以是向反方向50%。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-position {
    position: relative;
}

.box-example3 {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example3&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example3&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;父子double相（不推荐，做着玩玩的）&quot;&gt;父子double相（不推荐，做着玩玩的）&lt;/h4&gt;
&lt;p&gt;一个不成熟的做法哈，父子都是相对定位也还是可以勉强居中的，硬算嘛，这里没有太大价值就不展开了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-position {
    position: relative;
}

.box-example4 {
    position: relative;
    top: 90px;
    left: 90px;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example4&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example4&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;父子double相--rem（不推荐，同楼上）&quot;&gt;父子double相 + rem（不推荐，同楼上）&lt;/h4&gt;
&lt;p&gt;没有太大价值，略过。&lt;/p&gt;
&lt;p&gt;相关例子链接: &lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example5&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example5&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;父相子绝--calc&quot;&gt;父相子绝 + calc&lt;/h4&gt;
&lt;p&gt;calc这个css属性可以允许在声明css属性值时执行一些计算，回到我们之前的那个矫正偏移量的模型上，那么这里很容易想到子元素&lt;code&gt;top、left&lt;/code&gt;属性设置成50%减去子元素一半的这样一个模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-position {
        position: relative;
}
.box-example6 {
    position: absolute;
    top: calc(50% - 100px);
    left: calc(50% - 100px);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example6&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example6&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;新旧flex&quot;&gt;新旧flex&lt;/h4&gt;
&lt;p&gt;flex布局，但凡一个正经点的初面都会遇到的，因为它好用也很常用，这里介绍两种，一种是新版的flex布局的写法，一种是旧版的flex布局的写法&lt;/p&gt;
&lt;p&gt;flex布局你就把它看成是一条轴线，一条长得还挺夯实的轴线，在这条轴线上，我们想要放一个盒子，有很多种放法，具体的可以搜下阮一峰老师的教程这里不再赘述。一个化繁为简的想法哈，这个是跟琦瑞哥学到的，就是我们很多时候也不一定能记得住那么多属性，我们期望做这样一件事，就是把它化抽象为形象。我们可以用具体的方位去表达我们的想法，简言之就是封装成一个类库，然后用一些接地气的类名去控制flex布局。&lt;/p&gt;
&lt;p&gt;有兴趣的童鞋可以看下我实现的一个低配版的css样式库：&lt;a href=&quot;https://ataola.github.io/show/box/assets/taolaui/flex.css&quot;&gt;https://ataola.github.io/show/box/assets/taolaui/flex.css&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;新版flex的写法&quot;&gt;新版flex的写法&lt;/h5&gt;
&lt;p&gt;在不改变轴方向的情况下，其父元素设置&lt;code&gt;align-items: center;&lt;/code&gt;表示垂直居中，&lt;code&gt;justify-content: center;&lt;/code&gt;表示水平居中。&lt;/p&gt;
&lt;p&gt;父元素设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.flex {
    display: flex;
}

.flex-middle {
    align-items: center;
}

.flex-center {
    justify-content: center;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example7&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example7&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;旧版flex的写法&quot;&gt;旧版flex的写法&lt;/h5&gt;
&lt;p&gt;这里就是提及一下有这么种存在，读者用新版的写法就好。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-old {
    display: -webkit-box;
    -webkit-box-pack: center;
    -webkit-box-align: center;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example8&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example8&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;table布局&quot;&gt;table布局&lt;/h4&gt;
&lt;p&gt;父元素设置&lt;code&gt;display: table&lt;/code&gt;,子元素设置&lt;code&gt;display:table-cell&lt;/code&gt;，在只有一个子元素的情况下它会尽可能撑满父元素，多个子元素的情况下水平均分。设置&lt;code&gt;vertical-align: middle&lt;/code&gt;可以使得其内容垂直居中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-table {
        display: table;
}

.box-son-table {
    display: table-cell;
    vertical-align: middle;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example9&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example9&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;grid布局&quot;&gt;grid布局&lt;/h4&gt;
&lt;p&gt;前面我们提到的flex布局时轴布局是一维的，这里的grid网格布局时二维的是平面的。将其父元素设置成&lt;code&gt;display：grid&lt;/code&gt;，然后子元素设置&lt;code&gt;align-self: center;&lt;/code&gt;表示垂直居中，&lt;code&gt;justify-self: center;&lt;/code&gt;表示水平居中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;.box-grid {
        display: grid;
}

.box-son-grid {
    align-self: center;
    justify-self: center;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关例子链接：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html#example10&quot;&gt;https://ataola.github.io/show/zj/center-middle.html#example10&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;相关实现地址已开源：&lt;a href=&quot;https://ataola.github.io/show/zj/center-middle.html%EF%BC%8C%E8%8B%A5%E6%9C%89%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84%EF%BC%8C%E4%BE%9B%E6%89%B9%E8%AF%84%E6%8C%87%E6%AD%A3%EF%BC%81&quot;&gt;https://ataola.github.io/show/zj/center-middle.html，若有不足之处，供批评指正！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他网页设计基础总结：&lt;a href=&quot;https://ataola.github.io/show/&quot;&gt;https://ataola.github.io/show/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jun 2020 00:25:00 +0000</pubDate>
<dc:creator>丰臣正一</dc:creator>
<og:description>导语：元素居中对齐在很多场景看上去很和谐很漂亮。除此之外，对于前端开发面试者的基础也是很好的一个考察点。下面跟着作者的思路，一起来看下吧。 场景分析 一个元素，它有可能有背景，那我要它的背景居中对齐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnroadbridge/p/13128943.html</dc:identifier>
</item>
<item>
<title>.Net Core微服务入门全纪录（三）——Consul-服务注册与发现（下） - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13096891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13096891.html</guid>
<description>&lt;p&gt;上一篇【&lt;a href=&quot;https://www.cnblogs.com/xhznl/p/13091750.html&quot;&gt;.Net Core微服务入门全纪录（二）——Consul-服务注册与发现（上）&lt;/a&gt;】已经成功将我们的服务注册到Consul中，接下来就该客户端通过Consul去做服务发现了。&lt;/p&gt;

&lt;p&gt;ServiceHelper.cs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ServiceHelper : IServiceHelper
    {
        private readonly IConfiguration _configuration;

        public ServiceHelper(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        public async Task&amp;lt;string&amp;gt; GetOrder()
        {
            //string[] serviceUrls = { &quot;http://localhost:9060&quot;, &quot;http://localhost:9061&quot;, &quot;http://localhost:9062&quot; };//订单服务的地址，可以放在配置文件或者数据库等等...

            var consulClient = new ConsulClient(c =&amp;gt;
            {
                //consul地址
                c.Address = new Uri(_configuration[&quot;ConsulSetting:ConsulAddress&quot;]);
            });

            //consulClient.Catalog.Services().Result.Response;
            //consulClient.Agent.Services().Result.Response;
            var services = consulClient.Health.Service(&quot;OrderService&quot;, null, true, null).Result.Response;//健康的服务

            string[] serviceUrls = services.Select(p =&amp;gt; $&quot;http://{p.Service.Address + &quot;:&quot; + p.Service.Port}&quot;).ToArray();//订单服务地址列表

            if (!serviceUrls.Any())
            {
                return await Task.FromResult(&quot;【订单服务】服务列表为空&quot;);
            }

            //每次随机访问一个服务实例
            var Client = new RestClient(serviceUrls[new Random().Next(0, serviceUrls.Length)]);
            var request = new RestRequest(&quot;/orders&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }

        public async Task&amp;lt;string&amp;gt; GetProduct()
        {
            //string[] serviceUrls = { &quot;http://localhost:9050&quot;, &quot;http://localhost:9051&quot;, &quot;http://localhost:9052&quot; };//产品服务的地址，可以放在配置文件或者数据库等等...

            var consulClient = new ConsulClient(c =&amp;gt;
            {
                //consul地址
                c.Address = new Uri(_configuration[&quot;ConsulSetting:ConsulAddress&quot;]);
            });

            //consulClient.Catalog.Services().Result.Response;
            //consulClient.Agent.Services().Result.Response;
            var services = consulClient.Health.Service(&quot;ProductService&quot;, null, true, null).Result.Response;//健康的服务

            string[] serviceUrls = services.Select(p =&amp;gt; $&quot;http://{p.Service.Address + &quot;:&quot; + p.Service.Port}&quot;).ToArray();//产品服务地址列表

            if (!serviceUrls.Any())
            {
                return await Task.FromResult(&quot;【产品服务】服务列表为空&quot;);
            }

            //每次随机访问一个服务实例
            var Client = new RestClient(serviceUrls[new Random().Next(0, serviceUrls.Length)]);
            var request = new RestRequest(&quot;/products&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;appsettings.json：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;,
  &quot;ConsulSetting&quot;: {
    &quot;ConsulAddress&quot;: &quot;http://localhost:8500&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，以上代码就完成了服务列表的获取。&lt;/p&gt;
&lt;p&gt;浏览器测试一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200612223624498-1549106400.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便停止2个服务：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200612223955339-1406012739.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续访问：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200612224143276-449242601.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这时候停止的服务地址就获取不到了，客户端依然正常运行。&lt;/p&gt;
&lt;p&gt;这时候解决了服务的发现，新的问题又来了...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端每次要调用服务，都先去Consul获取一下地址，这不仅浪费资源，还增加了请求的响应时间，这显然让人无法接受。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么怎么保证不要每次请求都去Consul获取地址，同时又要拿到可用的地址列表呢？&lt;br/&gt;Consul提供的解决方案：——Blocking Queries （阻塞的请求）。详情请见官网：&lt;a href=&quot;https://www.consul.io/api-docs/features/blocking&quot;&gt;https://www.consul.io/api-docs/features/blocking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是什么意思呢，简单来说就是当客户端请求Consul获取地址列表时，需要携带一个版本号信息，Consul会比较这个客户端版本号是否和Consul服务端的版本号一致，如果一致，则Consul会阻塞这个请求，直到Consul中的服务列表发生变化，或者到达阻塞时间上限；如果版本号不一致，则立即返回。这个阻塞时间默认是5分钟，支持自定义。&lt;br/&gt;那么我们另外启动一个线程去干这件事情，就不会影响每次的用户请求了。这样既保证了客户端服务列表的准确性，又节约了客户端请求服务列表的次数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继续改造代码：&lt;br/&gt;IServiceHelper增加一个获取服务列表的接口方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public interface IServiceHelper
    {
        /// &amp;lt;summary&amp;gt;
        /// 获取产品数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;string&amp;gt; GetProduct();

        /// &amp;lt;summary&amp;gt;
        /// 获取订单数据
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task&amp;lt;string&amp;gt; GetOrder();

        /// &amp;lt;summary&amp;gt;
        /// 获取服务列表
        /// &amp;lt;/summary&amp;gt;
        void GetServices();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServiceHelper实现接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ServiceHelper : IServiceHelper
    {
        private readonly IConfiguration _configuration;
        private readonly ConsulClient _consulClient;
        private ConcurrentBag&amp;lt;string&amp;gt; _orderServiceUrls;
        private ConcurrentBag&amp;lt;string&amp;gt; _productServiceUrls;

        public ServiceHelper(IConfiguration configuration)
        {
            _configuration = configuration;
            _consulClient = new ConsulClient(c =&amp;gt;
            {
                //consul地址
                c.Address = new Uri(_configuration[&quot;ConsulSetting:ConsulAddress&quot;]);
            });
        }

        public async Task&amp;lt;string&amp;gt; GetOrder()
        {
            if (_productServiceUrls == null)
                return await Task.FromResult(&quot;【订单服务】正在初始化服务列表...&quot;);

            //每次随机访问一个服务实例
            var Client = new RestClient(_orderServiceUrls.ElementAt(new Random().Next(0, _orderServiceUrls.Count())));
            var request = new RestRequest(&quot;/orders&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }

        public async Task&amp;lt;string&amp;gt; GetProduct()
        {
            if(_productServiceUrls == null)
                return await Task.FromResult(&quot;【产品服务】正在初始化服务列表...&quot;);

            //每次随机访问一个服务实例
            var Client = new RestClient(_productServiceUrls.ElementAt(new Random().Next(0, _productServiceUrls.Count())));
            var request = new RestRequest(&quot;/products&quot;, Method.GET);

            var response = await Client.ExecuteAsync(request);
            return response.Content;
        }

        public void GetServices()
        {
            var serviceNames = new string[] { &quot;OrderService&quot;, &quot;ProductService&quot; };
            Array.ForEach(serviceNames, p =&amp;gt;
            {
                Task.Run(() =&amp;gt;
                {
                    //WaitTime默认为5分钟
                    var queryOptions = new QueryOptions { WaitTime = TimeSpan.FromMinutes(10) };
                    while (true)
                    {
                        GetServices(queryOptions, p);
                    }
                });
            });
        }
        private void GetServices(QueryOptions queryOptions, string serviceName)
        {
            var res = _consulClient.Health.Service(serviceName, null, true, queryOptions).Result;
            
            //控制台打印一下获取服务列表的响应时间等信息
            Console.WriteLine($&quot;{DateTime.Now}获取{serviceName}：queryOptions.WaitIndex：{queryOptions.WaitIndex}  LastIndex：{res.LastIndex}&quot;);

            //版本号不一致 说明服务列表发生了变化
            if (queryOptions.WaitIndex != res.LastIndex)
            {
                queryOptions.WaitIndex = res.LastIndex;

                //服务地址列表
                var serviceUrls = res.Response.Select(p =&amp;gt; $&quot;http://{p.Service.Address + &quot;:&quot; + p.Service.Port}&quot;).ToArray();

                if (serviceName == &quot;OrderService&quot;)
                    _orderServiceUrls = new ConcurrentBag&amp;lt;string&amp;gt;(serviceUrls);
                else if (serviceName == &quot;ProductService&quot;)
                    _productServiceUrls = new ConcurrentBag&amp;lt;string&amp;gt;(serviceUrls);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup的Configure方法中调用一下获取服务列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IServiceHelper serviceHelper)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler(&quot;/Home/Error&quot;);
            }
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });

            //程序启动时 获取服务列表
            serviceHelper.GetServices();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码完成，运行测试：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200613081207554-1589906564.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;现在不用每次先请求服务列表了，是不是流畅多了？&lt;/p&gt;
&lt;p&gt;看一下控制台打印：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200613074917304-1731280476.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候如果服务列表没有发生变化的话，获取服务列表的请求会一直阻塞到我们设置的10分钟。&lt;/p&gt;
&lt;p&gt;随便停止2个服务：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200613075035183-1531572636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200613075115105-2055578034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这时候可以看到，数据被立马返回了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202006/610959-20200613081009885-649972258.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;继续访问客户端网站，同样流畅。&lt;br/&gt;（gif图传的有点问题。。。）&lt;/p&gt;
&lt;p&gt;至此，我们就通过Consul完成了服务的注册与发现。&lt;br/&gt;接下来又引发新的思考。。。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个客户端系统都去维护这一堆服务地址，合理吗？&lt;/li&gt;
&lt;li&gt;服务的ip端口直接暴露给所有客户端，安全吗？&lt;/li&gt;
&lt;li&gt;这种模式下怎么做到客户端的统一管理呢？&lt;br/&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码放在：&lt;a href=&quot;https://github.com/xiajingren/NetCoreMicroserviceDemo&quot;&gt;https://github.com/xiajingren/NetCoreMicroserviceDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未完待续...&lt;/p&gt;
</description>
<pubDate>Mon, 15 Jun 2020 00:17:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 上一篇【.Net Core微服务入门全纪录（二）——Consul-服务注册与发现（上）】已经成功将我们的服务注册到Consul中，接下来就该客户端通过Consul去做服务发现了。 服务发现 同样</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13096891.html</dc:identifier>
</item>
<item>
<title>foreach 集合又抛经典异常了，这次一定要刨根问底 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13128901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13128901.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;最近同事在写一段业务逻辑的时候，程序跑起来总是报：&lt;strong&gt;&lt;code&gt;集合已修改；可能无法执行枚举操作&lt;/code&gt;&lt;/strong&gt;，硬是没有找到什么情况下会导致这个异常产生，就让我来找一下bug，其实这个异常在座的每个程序员几乎都遇到过，谁也不是一生下就是大牛，简单看了下代码，确实是多线程操作foreach，但并没有对foreach进行Add，Remove操作，扫完代码其实我也是有点懵，没撤只能调试了，在foreach里套一层trycatch，查看异常的线程堆栈从而找出了问题代码，代码简化如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var dict = new Dictionary&amp;lt;int, int&amp;gt;()
            {
                [1001] = 1,
                [1002] = 10,
                [1003] = 20
            };

            foreach (var userid in dict.Keys)
            {
                dict[userid] = dict[userid] + 1;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先寻找点安慰，说实话，凭肉眼你觉得这段代码会抛出异常吗？ 反正我是被骗过了，大写的尴尬，结论如下，运行一下便知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074829011-1123958279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中看确实是异常，说明在foreach的过程中连迭代集合的 value 都不可以修改，这让我激起了强烈的探索欲，看看FCL中到底是怎么限制的。&lt;/p&gt;
&lt;h2 id=&quot;二：源码探索&quot;&gt;二：源码探索&lt;/h2&gt;
&lt;h3 id=&quot;1-从il中寻找答案&quot;&gt;1. 从IL中寻找答案&lt;/h3&gt;
&lt;p&gt;C#已发展到 &lt;code&gt;9.0&lt;/code&gt; 了，到处都充斥着语法糖，有时候不看一下底层的IL都不知道到底是转化成了什么，所以这个是必须的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        IL_000d: callvirt instance void class [System.Collections]System.Collections.Generic.Dictionary`2&amp;lt;int32, int32&amp;gt;::set_Item(!0, !1)
        IL_001b: callvirt instance void class [System.Collections]System.Collections.Generic.Dictionary`2&amp;lt;int32, int32&amp;gt;::set_Item(!0, !1)
        IL_0029: callvirt instance void class [System.Collections]System.Collections.Generic.Dictionary`2&amp;lt;int32, int32&amp;gt;::set_Item(!0, !1)
        IL_0037: callvirt instance valuetype [System.Collections]System.Collections.Generic.Dictionary`2/KeyCollection/Enumerator&amp;lt;!0, !1&amp;gt; class [System.Collections]System.Collections.Generic.Dictionary`2/KeyCollection&amp;lt;int32, int32&amp;gt;::GetEnumerator()

        .try
        {
                IL_003d: br.s IL_005a
                // loop start (head: IL_005a)
                        IL_003f: ldloca.s 1
                        IL_0041: call instance !0 valuetype [System.Collections]System.Collections.Generic.Dictionary`2/KeyCollection/Enumerator&amp;lt;int32, int32&amp;gt;::get_Current()
                        IL_004c: callvirt instance !1 class [System.Collections]System.Collections.Generic.Dictionary`2&amp;lt;int32, int32&amp;gt;::get_Item(!0)
                        IL_0053: callvirt instance void class [System.Collections]System.Collections.Generic.Dictionary`2&amp;lt;int32, int32&amp;gt;::set_Item(!0, !1)
                        IL_005a: ldloca.s 1
                        IL_005c: call instance bool valuetype [System.Collections]System.Collections.Generic.Dictionary`2/KeyCollection/Enumerator&amp;lt;int32, int32&amp;gt;::MoveNext()
                        IL_0061: brtrue.s IL_003f
                // end loop

                IL_0063: leave.s IL_0074
        } // end .try
        finally
        {

        } // end handler    

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从IL代码中可以看到，先执行了三次字典的索引器操作，然后调用了 &lt;code&gt;Dictionary.GetEnumerator&lt;/code&gt; 来生成字典的迭代类，这思路就非常清晰了，然后我们看一下类索引器都做了些什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074829376-163944539.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，每一次的索引器操作，这里都执行了version++，所以字典初始化完成之后，这里的 &lt;code&gt;version=3&lt;/code&gt;，没有问题吧，然后继续看代码，寻找 &lt;code&gt;Dictionary.GetEnumerator&lt;/code&gt; 方法启动迭代类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074832312-247049188.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码的 &lt;code&gt;_version = dictionary._version;&lt;/code&gt; 一定要看仔细了，在启动迭代类的时候记录了当时字典的版本号，也就是&lt;code&gt;_version=3&lt;/code&gt;，然后继续探索moveNext方法干了什么，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074832824-1842158121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，当每次执行moveNext的过程中，都会判断一下字典的 version 和 当初初始化迭代类中的version 版本号是否一致，如果不一致就抛出异常，所以这行代码就是点睛之笔了，当在foreach体中执行了 &lt;code&gt;dict[userid] = dict[userid] + 1;&lt;/code&gt; 语句，相当于又执行了一次类索引器操作，这时候字典的version就变成 4 了，而当初初始化迭代类的时候还是3，自然下一次执行 moveNext 就是 &lt;code&gt;3 != 4&lt;/code&gt; 抛出异常了。&lt;/p&gt;
&lt;p&gt;如果你非要让我证明给你看，这里可以使用dnspy直接调试源码，在异常那里下一个断点再查看两个version版本号不就知道啦。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074833131-1656709659.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-面对疾风&quot;&gt;2. 面对疾风&lt;/h3&gt;
&lt;p&gt;有些朋友可能要说，码农今天分享的这篇一点水准都没有，我18年前就知道字典是不能动态修改的，还分析的头头是劲😁😁😁。&lt;/p&gt;
&lt;p&gt;但是我有话要说，这个还确实是我的一个盲区，平时在迭代字典的时候value一般都是引用类型，动态修改引用类型的值自然是没有问题的，这是因为你不管怎么修改都不会改变 &lt;code&gt;_version&lt;/code&gt; 版本号，&lt;span&gt;但质疑我的也不要把话说的太满，因为这种操作是非常语义化非常大众的需求，你能保证后面net版本不支持这个吗？？？&lt;/span&gt; 如果你说不可能，那恭喜你，被我带到坑里面去啦。😄😄😄&lt;/p&gt;
&lt;p&gt;下面我用原封不动的代码在 &lt;code&gt;.net 5&lt;/code&gt; 下跑一次，睁大眼睛好好看哦~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074833452-1474810854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;惊讶吧, 居然在 &lt;code&gt;.Net 5&lt;/code&gt; 中可以的，接下来用ILSpy去查查底层源码，.netcore 3.1 和 net5 中分别对 类索引器 都做了啥修改。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;netcore 3.1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Path： C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.2\System.Private.CoreLib.dll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074833713-305626603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Path： C:\Program Files\dotnet\shared\Microsoft.NETCore.App\5.0.0-preview.5.20278.1\System.Private.CoreLib.dll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200615074833959-890322334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比两张图你会发现 &lt;code&gt;.Net5&lt;/code&gt; 中并没有做 &lt;code&gt;_version++&lt;/code&gt; 操作，这就🐮👃了，如果你再细读代码，你还发现 .Net5 对字典进行了较大幅度的优化，哈哈，当初在 &lt;code&gt;.Net5&lt;/code&gt; 之前产生的错误，在 &lt;code&gt;.Net5&lt;/code&gt; 中居然没有啦!&lt;/p&gt;
&lt;h2 id=&quot;四：-总结&quot;&gt;四： 总结&lt;/h2&gt;
&lt;p&gt;源码面前，不谈隐私，没事多翻翻源码，有可能还有意外收获，比如在 &lt;code&gt;.Net 5&lt;/code&gt;下的这点新发现，&lt;span&gt;可能还是全网第一个哦&lt;/span&gt;，这要是两个大牛争吵，让小白去相信谁呢，嘿嘿，源码才是真正的专家~&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Sun, 14 Jun 2020 23:49:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 最近同事在写一段业务逻辑的时候，程序跑起来总是报：集合已修改；可能无法执行枚举操作，硬是没有找到什么情况下会导致这个异常产生，就让我来找一下bug，其实这个异常在座的每个程序员</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13128901.html</dc:identifier>
</item>
<item>
<title>[.NET 开源] 高性能的 Swifter.MessagePack 已发布，并附带新版本的 Swifter.Json 和 Swifter.Data。 - 陈鑫伟</title>
<link>http://www.cnblogs.com/Dogwei/p/12915046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dogwei/p/12915046.html</guid>
<description>&lt;p&gt;&lt;span&gt;抱歉各位朋友，由于各种私事公事，本应该在 19 年底发布的 Swifter.MessagePack 库延迟了这么久才发布，我深感抱歉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200615002922857-1319139358.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MsgPack 简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MsgPack 一种非常轻巧的二进制数据交换格式，巧妙的设计让它相比其他二进制数据格式更可读，并且有着不错的压缩率和逻辑性能，是目前相当火热的数据交换格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Swifter.MessagePack 遵循 MsgPack 新的规范实现；相比 .NET 其他 MsgPack 序列化库，Swifter.MessagePack 有着更好的性能，生成的内容更紧凑合理且更简单易用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nuget：&lt;span&gt;&lt;a href=&quot;https://www.nuget.org/packages/Swifter.MessagePack/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Swifter.MessagePack&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，&lt;a href=&quot;https://www.nuget.org/packages/Swifter.Json/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Swifter.Json&lt;/span&gt;&lt;/a&gt;，&lt;a href=&quot;https://www.nuget.org/packages/Swifter.Data/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Swifter.Data&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;GitHub：&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Dogwei/Swifter.MessagePack&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Swifter.MessagePack&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，&lt;/span&gt;&lt;a href=&quot;https://github.com/Dogwei/Swifter.Json&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Swifter.Json&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果您想使用 Swifter 库，请在 Nuget 上安装/下载最新版本，如需单文件版本，请自行生成/合并。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单使用 Swifter.MessagePack&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200611170238330-1484849950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MessagePackFormatter 类内部还有&lt;/strong&gt;数&lt;/span&gt;&lt;strong&gt;十个&lt;/strong&gt;方法重载，包括静态和实例方法&lt;strong&gt;，总有一些适合您&lt;/strong&gt;；这些方法都是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更多使用方法请参考早期关于 Swifter.Json 的文章，GitHub 或 Wiki；学习交流进 Swifter 的 QQ 群：&lt;/strong&gt;133630914（新群，欢迎加入）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Swifter 框架的特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) &lt;/strong&gt;Swifter 可以运行在 .NET Framework 2.0+, .NET Core 2.0+, .NET Standard 2.0+, MONO JIT, MONO AOT, Xamarin.Android, Xamarin.iOS, Unity JIT 等平台/运行时上，&lt;strong&gt;&lt;span&gt;Unity IL2CPP 运行时由于没有我们测试环境，不知可否正常运行，更多信息请看下面的 AOT 说明&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) &lt;/strong&gt;Swifter 有着深层的抽象封装，这虽然带来了一些性能和内存的损耗，但也获得了更高的扩展性；Swifter.Json/Swifter.MessagePack/Swifter.Data 的可公用的代码非常多，这使得在 Swifter 上实现一个新的序列化库只需要编写少量代码即可实现，这是其他框架难实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) &lt;/strong&gt;虽然 Swifter 有很多接口和抽象编程，但是 Swifter 并没有因此比其他的框架慢或内存占用大，反比它们更快和更小内存占用；这是因为 Swifter 从来都是使用更好算法和逻辑来获取性能，而不是使用更直接的代码获取直接的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) &lt;/strong&gt;作为类库开发者，我们深知每个人开发和测试的侧重点都与他人不一样，自己找出自己的问题太难，所以 Swifter.Json 和 Swifter.MessagePack 除了我们自己的测试单元之外， 还 &quot;偷&quot; 了 Newtonsoft, Neuecc 和 Spanjson 的 5000+ 个测试单元（ 去除了 Newtonsoft 的部分测试单元）；现已测试通过 4200+ 个，不通过 800+ 个是我们认为可以允许或是更加合理的行为。（不劳而获的测试单元确实用着很爽，但事实是我们&quot;搬&quot;这些测试单元用了 3 天😫，无脑替换改到手指抽筋）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Swifter.Json 和 Swifter.MessagePack&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) &lt;/strong&gt;Swifter.MessagePack 和 Swifter.Json 一样，都有着非常优异的性能和极小的额外内存分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) &lt;/strong&gt;Swifter.MessagePack 和 Swifter.Json 的 API 大致相同，如果使用者同时使用它们，那么可以极小成本在它们之间切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;(3) &lt;/strong&gt;&lt;/strong&gt;得益于 Swifter.Core 的强大数据映射，Swifter.MessagePack 和 Swifter.Json 都同时支持 .NET 上大多数常用的数据结构和类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) &lt;/strong&gt;Swifter.MessagePack 和 Swifter.Json 对重复引用的对象的表示方式不一样，在开启 &lt;span&gt;&lt;strong&gt;MultiReferencingReference&lt;/strong&gt;&lt;/span&gt; 配置项后，Swifter.Json 将使用 { &quot;$ref&quot;: &quot;#/obj/1/target&quot; } 来表示重复引用的对象，而 Swifter.MessagePack 使用对象在 MsgPack 内容的偏移量表示重复引用的对象；相比之下 Swifter.MessagePack 的方案更简单性能更快，但是可读性较差，不过说来 MsgPack 本来就是要专门的工具才能阅读😄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5) &lt;/strong&gt;Swifter.MessagePack 在序列化基础类型时，在保证精度不丢失的前提下，将大数据类型转换为更小数据类型，以得到更紧凑的 MsgPack 内容（如将 double 123 转换为 int 123，int 123 只需要 1 个字节即可表示，如果不做转换则需要 9 个字节表示）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(6) &lt;/strong&gt;Swifter.MessagePack 在序列化未知长度的集合时（如 Enumerable&amp;lt;T&amp;gt;），会将长度定义为四字节 (FixArray32)，然后在写入完成后把实际长度赋予这四字节长度；这样虽然在较短的未知长度集合时，将产生 1-3 个 0；但是这避免了将未知长度的集合转换为 List&amp;lt;T&amp;gt; 或 T[], 这提高了性能也减少了内存分配，这是不亏的（因为未知长度的集合很常用，如 Linq，DbDataReader 等）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;新版本做了啥？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;(1)&lt;/span&gt; 主要是解决了已知 BUG，包括了 Issues 上提到的几个。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) &lt;/strong&gt;允许将 &lt;span&gt;&quot;&quot;&lt;/span&gt; 值解析为 DateTime, int?, double 等基础类型的默认值，但是需要启用 EmptyStringAsDefault 配置项，默认未开启。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;(3)&lt;/span&gt; &lt;/strong&gt;解决了 Swifter.Json 浮点数: float, double 失真的问题&lt;/span&gt;&lt;/strong&gt;，并增加了 UseSystemFloatingPointsMethods 配置项使用系统的浮点数方法，此配置项的更多说明请看该配置项的注释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) &lt;/strong&gt;增加了序列化的事件：ObjectFiltering 和 ArrayFiltering，这两个事件可以对正在序列化中的 键/值 做处理和筛选，包括驼峰命名法，忽略一些值等。它们被放在 JsonFormatter 和 MessagePackFormatter 的实例里面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5) &lt;/strong&gt;增加了 .NET 对象的持久序列化和反序列化功能，这个功能将对象序列化为包含类型信息和字段值的内容，不包含逻辑信息；使用 SerializationBox&amp;lt;T&amp;gt; 盒子使用此功能。图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608163020852-1569230157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多新增的功能请继续看以下内容。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;AOT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Swifter 新版本里，AOT 的 JIT 的界限更加明显，由 &lt;span&gt;&lt;strong&gt;VersionDifferences.IsSupportEmit&lt;/strong&gt;&lt;/span&gt; 字段标识；当这个字段为 true 表示当前平台是 JIT 运行时，Swifter 将在一些类中使用 Emit 技术提高性能；当此字段为 false 时，Swifter 会完全不使用 Emit 技术。&lt;/p&gt;
&lt;p&gt;因我们设备有限，无法提供大规模的平台测试，但我们非常希望可以 Swifter 可以支持更多的平台，&lt;strong&gt;&lt;span&gt;所以希望朋友们加 Swifter 交流 QQ 群：(133630914)&lt;/span&gt;&lt;/strong&gt;，在这里我们可以更快的提供反馈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;直接文档读取/写入的 API&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，将小型对象序列化为 Json/MsgPack 和将小型 Json/MsgPack 反序列化为对象是 .NET 程序中常见的操作，Swifter 也正以此为常用场景做优化，所以 Swifter 在对小型数据操作时性能最佳，且相比其他 Json/MsgPack 解析库优势明显。&lt;/p&gt;
&lt;p&gt;但在大型数据下优势减少，这主要原因是大型数据的存储需要实体类或字典/集合存储，创建/填充/遍历这些对象消耗了大量资源（接口编程的损耗）；所以 Swifter 提供了直接读取/写入的 API 来绕开了对存储介质的操作，以更快更小损耗的读写大型数据。&lt;/p&gt;
&lt;p&gt;使用 JsonFormatter.CreateJsonReader/MessagePackFormatter.CreateMessagePackReader 函数来创建文档读取器，使用 JsonFormatter.CreateJsonWriter/MessagePackFormatter.CreateMessagePackWriter 函数来创建文档写入器。&lt;/p&gt;
&lt;p&gt;使用文档读取器完整的读取一个 Json/MsgPack 文档将比反序列化为对象快 4-8 倍！使用文档写入器生成文档的性能与将实体类序列化为 Json/MsgPack 相差较小，前提是您已构建好了这些对象😄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取器演示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608172721183-1040319350.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写入器演示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608164758133-612572219.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥有简单预测数组的长度的能力&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter 在对小型数组，部分集合写入时，会根据数组的类型，来源（Data,Json,MsgPack 等），名称等信息并结合之前的一些长度记录，简单的预测出新的数组的长度；在写入完成后，如果预测长度与实际长度不符，则扩展或压缩为实际长度；如果与实际长度相符，则不需要重新创建新数组。此能力有效提高反序列化小型数组和部分集合性能，并且减少额外内存分配。&lt;/p&gt;
&lt;p&gt;在其他高性能的 Json 解析库，它们使用 ArrayPool&amp;lt;T&amp;gt; 同样可以提高性能和减少内存分配；但是由于 Swifter 对兼容性的要求，使得我们不能使用 ArrayPool&amp;lt;T&amp;gt; 方案；在数组的长度比较稳定的情况下，我们的方案更好；但在数组长度非常不稳定的情况下，我们的方案可能仍需要 1-3 次的扩容/压缩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;假定有序的对象反序列化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Json 和 Swifter.MessagePack 都支持了假定有序的对象反序列化，当一个 Json/MsgPack 的对象与当前的实体类对象的字段顺序一致时，将有效提升反序列化性能。&lt;/p&gt;
&lt;p&gt;此操作默认不开启，可以使用 AsOrderedObjectDeserialize 配置项开启。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;高性能的反射封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Core 里提供了一些对反射封装的类，它们放在 Swifter.Reflection 命名空间下；这些类型主要功能就是提高了系统反射的性能；XObjectRW 正是使用它们实现不依赖 Emit 的高性能对象读写器。&lt;/p&gt;
&lt;p&gt;虽然放弃一些安全性检查可以提高更多的性能，但是我们并没有这么做；我们仍然有类型安全检查和防溢出检查（事实上读写字段和属性大多数的损害都在这里，如果去掉这些检查将得到上百倍的性能；事实上这些检查只起到了提示程序员不能这么做的作用，程序实际运行时这些检查无意义）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608164918761-1997016275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;高效的数字 ToString 和 Parse 方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Core 提供了一些高性能数字算法，包括 Int64, UInt64, Double, Single, Decimal 的 Parse 和 ToString 算法，它们被放在 Swifter.Tools.NumberHelper 里，这些算法被应用与 Swifter.Json 和一些其他地方，这些算法支持 2-64 进制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608165050540-53556330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;XConvert 万能类型转换器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Tools.XConvert.Convert&amp;lt;TSource, TDestination&amp;gt; 是一个功能强大的万能类型转换函数，它在初始化时尝试以下方式获取合适的转换函数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt; 包含在 System.Convert 里的基础转换函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)&lt;/strong&gt; 类型兼容的隐式转换（如：从子类转换为父类，从 Int32 转换为 Int64，从 Int64 转换为 Double）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)&lt;/strong&gt; 原类型和目标类型中的 static implicit operator (隐式转换) 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4)&lt;/strong&gt; 原类型中的 ToXXX 实例函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5)&lt;/strong&gt; 目标类型中的 Parse 和 ValueOf 静态函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(7)&lt;/strong&gt; 目标类型的构造函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(8)&lt;/strong&gt; 原类型和目标类型中的 static explicit operator (显式转换) 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(9)&lt;/strong&gt; 当以上方法都没有找到合适函数时，将使用 (TDestination)(object)value 进行强制转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608165753792-115525316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;性能测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200609115622335-1226707148.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ServiceStack.Json, Jil, LitJson, NetJson 等库&lt;/strong&gt;因为出错太多未展示出来；如果有需要，您可以到 GitHub 上自行克隆/修改/运行，已收录了&lt;strong&gt; .NET 的&lt;/strong&gt;大多数 Json 序列化库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多实用功能等你发现...&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Core 还提供了许许多多的工具类，包括反射，委托，类型转换，字符串，加密，哈希，数字，日期，数组和集合等工具，它们被放在 Swifter.Tools 命名空间下，您可以使用它们来提高开发效率和运行效率。&lt;/p&gt;
&lt;p&gt;Swifter.RW 命名空间是整个 Swifter 框架的核心，它主要逻辑是：从读取器中读取值，写入到写入器中；如：从 JsonReader 读取值到 ObjectWriter 或 DictionaryWriter 中；熟悉它们就等于精通了 Swifter 框架。&lt;/p&gt;
&lt;p&gt;Swifter.Json/Swifter.MessagePack 有一个非常重要的配置项 JsonFormatterOptions/MessagePackFormatterOptions；使用前&lt;strong&gt;&lt;span&gt;建议先阅读它们&lt;/span&gt;&lt;/strong&gt;，以配置更适合您系统的序列化和反序列化方案。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后附上 Swifter.Data 的简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swifter.Data 是一个小型的 ORM 工具，它相比 Dapper 性能要快一些，功能要强大一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1527310/202006/1527310-20200608161452366-1052886546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;感谢阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jun 2020 23:43:00 +0000</pubDate>
<dc:creator>陈鑫伟</dc:creator>
<og:description>抱歉各位朋友，由于各种私事公事，本应该在 19 年底发布的 Swifter.MessagePack 库延迟了这么久才发布，我深感抱歉。 MsgPack 简介 MsgPack 一种非常轻巧的二进制数据交</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dogwei/p/12915046.html</dc:identifier>
</item>
<item>
<title>面试官：线程池如何按照core、max、queue的执行循序去执行？（内附详细解析） - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/13128890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/13128890.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这是一个真实的面试题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前几天一个朋友在群里分享了他刚刚面试候选者时问的问题：&lt;strong&gt;&quot;线程池如何按照core、max、queue的执行循序去执行？&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们都知道线程池中代码执行顺序是：&lt;strong&gt;corePool-&amp;gt;workQueue-&amp;gt;maxPool&lt;/strong&gt;，源码我都看过，你现在问题让我改源码？？&lt;/p&gt;
&lt;p&gt;一时间群里炸开了锅，小伙伴们纷纷打听他所在的公司，然后拉黑避坑。&lt;strong&gt;(手动狗头，大家一起调侃٩(๑❛ᴗ❛๑)۶)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于线程池他一共问了这么几个问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程池如何按照core、max、queue的顺序去执行？&lt;/li&gt;
&lt;li&gt;子线程抛出的异常，主线程能感知到么？&lt;/li&gt;
&lt;li&gt;线程池发生了异常改怎样处理？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;全是一些有意思的问题，我之前也写过一篇很详细的图文教程：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12945703.html&quot;&gt;【万字图文-原创】 | 学会Java中的线程池，这一篇也许就够了！&lt;/a&gt; ，不了解的小伙伴可以再回顾下~&lt;/p&gt;
&lt;p&gt;但是针对这几个问题，可能大家一时间也有点懵。今天的文章我们以源码为基础来分析下该如何回答这三个问题。&lt;strong&gt;（之前没阅读过源码也没关系，所有的分析都会贴出源码及图解）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池如何按照core、max、queue的顺序执行？&quot;&gt;线程池如何按照core、max、queue的顺序执行？&lt;/h3&gt;
&lt;h4 id=&quot;问题思考&quot;&gt;问题思考&lt;/h4&gt;
&lt;p&gt;对于这个问题，很多小伙伴肯定会疑惑：&lt;strong&gt;&quot;别人源码中写好的执行流程你为啥要改？这面试官脑子有病吧......&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里来思考一下现实工作场景中是否有这种需求？之前也看到过一份简历也写到过这个问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072705573-1473063398.png&quot; alt=&quot;场景描述.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个线程池执行的任务属于&lt;code&gt;IO&lt;/code&gt;密集型，&lt;code&gt;CPU&lt;/code&gt;大多属于闲置状态，系统资源未充分利用。如果一瞬间来了大量请求，如果线程池数量大于&lt;code&gt;coreSize&lt;/code&gt;时，多余的请求都会放入到等待队列中。等待着&lt;code&gt;corePool&lt;/code&gt;中的线程执行完成后再来执行等待队列中的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试想一下，这种场景我们该如何优化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以修改线程池的执行顺序为&lt;strong&gt;corePool-&amp;gt;maxPool-&amp;gt;workQueue&lt;/strong&gt;。 这样就能够充分利用&lt;code&gt;CPU&lt;/code&gt;资源，提交的任务会被优先执行。当线程池中线程数量大于&lt;code&gt;maxSize&lt;/code&gt;时才会将任务放入等待队列中。&lt;/p&gt;
&lt;p&gt;你就说巧不巧？面试官的这个问题显然是经过认真思考来提问的，这是一个很有意思的温恩提，下面就一起看看如何解决吧。&lt;/p&gt;
&lt;h4 id=&quot;线程池运行流程&quot;&gt;线程池运行流程&lt;/h4&gt;
&lt;p&gt;我们都知道线程池执行流程是先&lt;code&gt;corePool&lt;/code&gt;再&lt;code&gt;workQueue&lt;/code&gt;，最后才是&lt;code&gt;maxPool&lt;/code&gt;的一个执行流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072705858-681238152.png&quot; alt=&quot;执行流程.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;线程池核心参数&quot;&gt;线程池核心参数&lt;/h4&gt;
&lt;p&gt;在回顾下&lt;code&gt;ThreadPoolExecutor.execute()&lt;/code&gt;源码前我们先回顾下线程池中的几个重要参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072706060-1065893697.png&quot; alt=&quot;线程池核心参数.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看下这几个参数的定义：&lt;br/&gt;&lt;code&gt;corePoolSize&lt;/code&gt;: 线程池中核心线程数量&lt;br/&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;: 线程池中最大线程数量&lt;br/&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;: 非核心的空闲线程等待新任务的时间&lt;br/&gt;&lt;code&gt;unit&lt;/code&gt;: 时间单位。配合&lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt;也会清理核心线程池中的线程。&lt;br/&gt;&lt;code&gt;workQueue&lt;/code&gt;: 基于&lt;code&gt;Blocking&lt;/code&gt;的任务队列，最好选用有界队列，指定队列长度&lt;br/&gt;&lt;code&gt;threadFactory&lt;/code&gt;: 线程工厂，最好自定义线程工厂，可以自定义每个线程的名称&lt;br/&gt;&lt;code&gt;handler&lt;/code&gt;: 拒绝策略，默认是&lt;code&gt;AbortPolicy&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;threadpoolexecutorexecute源码分析&quot;&gt;ThreadPoolExecutor.execute()源码分析&lt;/h4&gt;
&lt;p&gt;我们可以看下&lt;code&gt;execute()&lt;/code&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072706289-1610433293.png&quot; alt=&quot;execute执行源码.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着来分析下执行过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一步：&lt;code&gt;workerCountOf(c)&lt;/code&gt;时间计算当前线程池中线程的个数，当线程个数小于核心线程数&lt;/li&gt;
&lt;li&gt;第二步：线程池线程数量大于核心线程数，此时提交的任务会放入&lt;code&gt;workQueue&lt;/code&gt;中，使用&lt;code&gt;offer()&lt;/code&gt;进行操作&lt;/li&gt;
&lt;li&gt;第三步：&lt;code&gt;workQueue.offer()&lt;/code&gt;执行失败，新提交的任务会直接执行，&lt;code&gt;addWorker()&lt;/code&gt;会判断如果当前线程池数量大于最大线程数，则执行拒绝策略&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，到了这里我们都已经很清楚了，关键在于第二步和第三步如何交换顺序执行呢？&lt;/p&gt;
&lt;h4 id=&quot;解决思路&quot;&gt;解决思路&lt;/h4&gt;
&lt;p&gt;仔细想一想，如果修改&lt;code&gt;workQueue.offer()&lt;/code&gt;的实现不就可以达到目的了？我们先来画图来看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072706519-331395459.png&quot; alt=&quot;问题思路.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在的问题就在于，如果当前线程池中&lt;code&gt;coreSize &amp;lt; workCount &amp;lt; maxSize&lt;/code&gt;时，一定会先执行&lt;code&gt;offer()&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;我们如果修改&lt;code&gt;offer&lt;/code&gt;的实现是否可以完成执行顺序的更换呢？这里也是画图来展示一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072706730-1807526275.png&quot; alt=&quot;解决方式.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;dubbo中eagerthreadpool解决方案&quot;&gt;Dubbo中EagerThreadPool解决方案&lt;/h4&gt;
&lt;p&gt;凑巧&lt;code&gt;Dubbo&lt;/code&gt;中也有类似的实现，在&lt;code&gt;Dubbo&lt;/code&gt;的&lt;code&gt;EagerThreadPool&lt;/code&gt;自定义了一个&lt;code&gt;BlockingQueue&lt;/code&gt;，在&lt;code&gt;offer()&lt;/code&gt;方法中，如果当前线程池数量小于最大线程池时，直接返回&lt;code&gt;false&lt;/code&gt;，这里就达到了调节线程池执行顺序的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072706935-1372798478.png&quot; alt=&quot;dubbo中解决方案.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码直达&lt;/strong&gt;：&lt;a href=&quot;https://github.com/apache/dubbo/blob/master/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueue.java&quot;&gt;https://github.com/apache/dubbo/blob/master/dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/eager/TaskQueue.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到这里一切都真相大白了，解决思路以及方案都很简单，学会了没有？&lt;/p&gt;
&lt;p&gt;这个问题背后还隐藏了一些场景的优化、源码的扩展等等知识，果然是一个值得思考的好问题。&lt;/p&gt;
&lt;h3 id=&quot;子线程抛出的异常，主线程能感知到么？&quot;&gt;子线程抛出的异常，主线程能感知到么？&lt;/h3&gt;
&lt;h4 id=&quot;问题思考-2&quot;&gt;问题思考&lt;/h4&gt;
&lt;p&gt;这个问题其实也很容易回答，也仅仅是一个面试题而已，实际工作中子线程的异常不应该由主线程来捕获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对这个问题，希望大家清楚的是：&lt;/strong&gt; 我们要明确线程代码的边界，异步化过程中，子线程抛出的异常应该由子线程自己去处理，而不是需要主线程感知来协助处理。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;解决方案很简单，在虚拟机中，当一个线程如果没有显式处理异常而抛出时会将该异常事件报告给该线程对象的 &lt;code&gt;java.lang.Thread.UncaughtExceptionHandler&lt;/code&gt; 进行处理，如果线程没有设置 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，则默认会把异常栈信息输出到终端而使程序直接崩溃。&lt;/p&gt;
&lt;p&gt;所以如果我们想在线程意外崩溃时做一些处理就可以通过实现 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 来满足需求。&lt;/p&gt;
&lt;p&gt;我们使用线程池设置&lt;code&gt;ThreadFactory&lt;/code&gt;时可以指定&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，这样就可以捕获到子线程抛出的异常了。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 测试子线程异常问题
 *
 * @author wangmeng
 * @date 2020/6/13 18:08
 */
public class ThreadPoolExceptionTest {

    public static void main(String[] args) throws InterruptedException {
        MyHandler myHandler = new MyHandler();
        ExecutorService execute = new ThreadPoolExecutor(10, 10,
                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), new ThreadFactoryBuilder().setUncaughtExceptionHandler(myHandler).build());

        TimeUnit.SECONDS.sleep(5);
        for (int i = 0; i &amp;lt; 10; i++) {
            execute.execute(new MyRunner());
        }
    }


    private static class MyRunner implements Runnable {
        @Override
        public void run() {
            int count = 0;
            while (true) {
                count++;
                System.out.println(&quot;我要开始生产Bug了============&quot;);
                if (count == 10) {
                    System.out.println(1 / 0);
                }

                if (count == 20) {
                    System.out.println(&quot;这里是不会执行到的==========&quot;);
                    break;
                }
            }
        }
    }
}

class MyHandler implements Thread.UncaughtExceptionHandler {
    private final static Logger LOGGER = LoggerFactory.getLogger(MyHandler.class);
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        LOGGER.error(&quot;threadId = {}, threadName = {}, ex = {}&quot;, t.getId(), t.getName(), e.getMessage());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072707185-630328833.png&quot; alt=&quot;执行结果.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;uncaughtexceptionhandler-解析&quot;&gt;UncaughtExceptionHandler 解析&lt;/h4&gt;
&lt;p&gt;我们来看下&lt;code&gt;Thread&lt;/code&gt;中的内部接口&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Thread {
    ......
    /**
     * 当一个线程因未捕获的异常而即将终止时虚拟机将使用 Thread.getUncaughtExceptionHandler()
     * 获取已经设置的 UncaughtExceptionHandler 实例，并通过调用其 uncaughtException(...) 方
     * 法而传递相关异常信息。
     * 如果一个线程没有明确设置其 UncaughtExceptionHandler，则将其 ThreadGroup 对象作为其
     * handler，如果 ThreadGroup 对象对异常没有什么特殊的要求，则 ThreadGroup 会将调用转发给
     * 默认的未捕获异常处理器（即 Thread 类中定义的静态未捕获异常处理器对象）。
     *
     * @see #setDefaultUncaughtExceptionHandler
     * @see #setUncaughtExceptionHandler
     * @see ThreadGroup#uncaughtException
     */
    @FunctionalInterface
    public interface UncaughtExceptionHandler {
        /**
         * 未捕获异常崩溃时回调此方法
         */
        void uncaughtException(Thread t, Throwable e);
    }

    /**
     * 静态方法，用于设置一个默认的全局异常处理器。
     */
    public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
         defaultUncaughtExceptionHandler = eh;
     }

    /**
     * 针对某个 Thread 对象的方法，用于对特定的线程进行未捕获的异常处理。
     */
    public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
        checkAccess();
        uncaughtExceptionHandler = eh;
    }

    /**
     * 当 Thread 崩溃时会调用该方法获取当前线程的 handler，获取不到就会调用 group（handler 类型）。
     * group 是 Thread 类的 ThreadGroup 类型属性，在 Thread 构造中实例化。
     */
    public UncaughtExceptionHandler getUncaughtExceptionHandler() {
        return uncaughtExceptionHandler != null ?
            uncaughtExceptionHandler : group;
    }

    /**
     * 线程全局默认 handler。
     */
    public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler() {
        return defaultUncaughtExceptionHandler;
    }
    ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分内容参考自：&lt;a href=&quot;https://mp.weixin.qq.com/s/ghnNQnpou6-NemhFjpl4Jg&quot;&gt;https://mp.weixin.qq.com/s/ghnNQnpou6-NemhFjpl4Jg&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池发生了异常改怎样处理？&quot;&gt;线程池发生了异常改怎样处理？&lt;/h3&gt;
&lt;p&gt;线程池中线程运行过程中出现了异常该怎样处理呢？线程池提交任务有两种方式，分别是&lt;code&gt;execute()&lt;/code&gt;和&lt;code&gt;submit()&lt;/code&gt;，这里会依次说明。&lt;/p&gt;
&lt;h4 id=&quot;threadpoolexecutorrunworker实现&quot;&gt;ThreadPoolExecutor.runWorker()实现&lt;/h4&gt;
&lt;p&gt;不管是使用&lt;code&gt;execute()&lt;/code&gt;还是&lt;code&gt;submit()&lt;/code&gt;提交任务，最终都会执行到&lt;code&gt;ThreadPoolExecutor.runWorker()&lt;/code&gt;，我们来看下源码（源码基于JDK1.8）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072707418-737082823.png&quot; alt=&quot;runWorker().png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到在执行&lt;code&gt;task.run()&lt;/code&gt;时，出现异常会直接向上抛出，这里处理的最好的方式就是在我们业务代码中使用&lt;code&gt;try...catch()&lt;/code&gt;来捕获异常。&lt;/p&gt;
&lt;h4 id=&quot;futuretaskrun实现&quot;&gt;FutureTask.run()实现&lt;/h4&gt;
&lt;p&gt;如果我们使用&lt;code&gt;submit()&lt;/code&gt;来提交任务，在&lt;code&gt;ThreadPoolExecutor.runWorker()&lt;/code&gt;方法执行时最终会调用到&lt;code&gt;FutureTask.run()&lt;/code&gt;方法里面去，不清楚的小伙伴也可以看下我之前的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/13023710.html&quot;&gt;线程池续：你必须要知道的线程池submit()实现原理之FutureTask！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072707687-894104673.png&quot; alt=&quot;FutureTask.run().png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到，如果业务代码抛出异常后，会被&lt;code&gt;catch&lt;/code&gt;捕获到，然后调用&lt;code&gt;setExeception()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072707856-1037893017.png&quot; alt=&quot;FutureTask.setException().png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到其实类似于直接吞掉了，当我们调用&lt;code&gt;get()&lt;/code&gt;方法的时候异常信息会包装到FutureTask内部的变量outcome中，我们也会获取到对应的异常信息。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ThreadPoolExecutor.runWorker()&lt;/code&gt;最后&lt;code&gt;finally&lt;/code&gt;中有一个&lt;code&gt;afterExecute()&lt;/code&gt;钩子方法，如果我们重写了&lt;code&gt;afterExecute()&lt;/code&gt;方法，就可以获取到子线程抛出的具体异常信息&lt;code&gt;Throwable&lt;/code&gt;了。&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;结论&lt;/h4&gt;
&lt;p&gt;对于线程池、包括线程的异常处理推荐以下方式:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接使用&lt;code&gt;try/catch&lt;/code&gt;，这个也是最推荐的方式&lt;/li&gt;
&lt;li&gt;在我们构造线程池的时候，重写&lt;code&gt;uncaughtException()&lt;/code&gt;方法，上面示例代码也有提到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadPoolExceptionTest {

    public static void main(String[] args) throws InterruptedException {
        MyHandler myHandler = new MyHandler();
        ExecutorService execute = new ThreadPoolExecutor(10, 10,
                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), new ThreadFactoryBuilder().setUncaughtExceptionHandler(myHandler).build());

        TimeUnit.SECONDS.sleep(5);
        for (int i = 0; i &amp;lt; 10; i++) {
            execute.execute(new MyRunner());
        }
    }
}

class MyHandler implements Thread.UncaughtExceptionHandler {
    private final static Logger LOGGER = LoggerFactory.getLogger(MyHandler.class);
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        LOGGER.error(&quot;threadId = {}, threadName = {}, ex = {}&quot;, t.getId(), t.getName(), e.getMessage());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3 直接重写&lt;code&gt;afterExecute()&lt;/code&gt;方法，感知异常细节&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这篇文章到这里就结束了，不知道小伙伴们有没有一些感悟或收获？&lt;/p&gt;
&lt;p&gt;通过这几个面试问题，我也深刻的感受到学习知识要多思考，看源码的过程中要多设置一些场景，这样才会收获更多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/799093/202006/799093-20200615072709565-1835814448.png&quot; alt=&quot;原创干货分享.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jun 2020 23:27:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 这是一个真实的面试题。 前几天一个朋友在群里分享了他刚刚面试候选者时问的问题：&amp;amp;quot;线程池如何按照core、max、queue的执行循序去执行？&amp;amp;quot;。 我们都知道线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/13128890.html</dc:identifier>
</item>
<item>
<title>老大吩咐的可重入分布式锁，终于完美的实现了！！！ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13128883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13128883.html</guid>
<description>&lt;h2 id=&quot;重做永远比改造简单&quot;&gt;重做永远比改造简单&lt;/h2&gt;
&lt;p&gt;最近在做一个项目，将一个其他公司的实现系统（&lt;em&gt;下文称作旧系统&lt;/em&gt;），完整的整合到自己公司的系统（&lt;em&gt;下文称作新系统&lt;/em&gt;）中，这其中需要将对方实现的功能完整在自己系统也实现一遍。&lt;/p&gt;
&lt;p&gt;旧系统还有一批存量商户，为了不影响存量商户的体验，新系统提供的对外接口，还必须得跟以前一致。最后系统完整切换之后，功能只运行在新系统中，这就要求旧系统的数据还需要完整的迁移到新系统中。&lt;/p&gt;
&lt;p&gt;当然这些在做这个项目之前就有预期，想过这个过程很难，但是没想到有那么难。原本感觉排期大半年，时间还是挺宽裕，现在感觉就是大坑，还不得不在坑里一点点去填。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615070959849-950502677.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哎，说多都是泪，不吐槽了，等到下次做完再给大家复盘下真正心得体会。&lt;/p&gt;
&lt;p&gt;回到正文，上篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/HlD46m-OP-HDdKJFxgqFYA&quot;&gt;Redis 分布式锁&lt;/a&gt;，咱们基于 Redis 实现一个分布式锁。这个分布式锁基本功能没什么问题，但是缺少可重入的特性，所以这篇文章小黑哥就带大家来实现一下可重入的分布式锁。&lt;/p&gt;
&lt;p&gt;本篇文章将会涉及以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可重入&lt;/li&gt;
&lt;li&gt;基于 ThreadLocal 实现方案&lt;/li&gt;
&lt;li&gt;基于 Redis Hash 实现方案&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看，养成习惯。微信搜索「程序通事」，关注就完事了~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可重入&quot;&gt;可重入&lt;/h2&gt;
&lt;p&gt;说到可重入锁，首先我们来看看一段来自 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5&quot;&gt;wiki&lt;/a&gt; 上可重入的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为&lt;strong&gt;可重入&lt;/strong&gt;（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。&lt;/p&gt;
&lt;p&gt;用一段 Java 代码解释可重入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized void a() {
    b();
}

public synchronized void b() {
    // pass
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时&lt;strong&gt;不可重入&lt;/strong&gt;，线程就必须等待锁释放，再次争抢锁。&lt;/p&gt;
&lt;p&gt;锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615071000003-1637972343.gif&quot; alt=&quot;我打我自己&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。&lt;/p&gt;
&lt;p&gt;可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。&lt;/p&gt;
&lt;p&gt;分布式可重入锁实现方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 ThreadLocal 实现方案&lt;/li&gt;
&lt;li&gt;基于 Redis Hash 实现方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们看下基于 ThreadLocal 实现方案。&lt;/p&gt;
&lt;h2 id=&quot;基于-threadlocal-实现方案&quot;&gt;基于 ThreadLocal 实现方案&lt;/h2&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;实现方式&lt;/h3&gt;
&lt;p&gt;Java 中 &lt;code&gt;ThreadLocal&lt;/code&gt;可以使每个线程拥有自己的实例副本，我们可以利用这个特性对线程重入次数进行技术。&lt;/p&gt;
&lt;p&gt;下面我们定义一个&lt;code&gt;ThreadLocal&lt;/code&gt;的全局变量 &lt;code&gt;LOCKS&lt;/code&gt;，内存存储 &lt;code&gt;Map&lt;/code&gt; 实例变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;private static ThreadLocal&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt; LOCKS = ThreadLocal.withInitial(HashMap::new);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个线程都可以通过 &lt;code&gt;ThreadLocal&lt;/code&gt;获取自己的 &lt;code&gt;Map&lt;/code&gt;实例，&lt;code&gt;Map&lt;/code&gt; 中 &lt;code&gt;key&lt;/code&gt; 存储锁的名称，而 &lt;code&gt;value&lt;/code&gt;存储锁的重入次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加锁的代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 可重入锁
 *
 * @param lockName  锁名字,代表需要争临界资源
 * @param request   唯一标识，可以使用 uuid，根据该值判断是否可以重入
 * @param leaseTime 锁释放时间
 * @param unit      锁释放时间单位
 * @return
 */
public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {
    Map&amp;lt;String, Integer&amp;gt; counts = LOCKS.get();
    if (counts.containsKey(lockName)) {
        counts.put(lockName, counts.get(lockName) + 1);
        return true;
    } else {
        if (redisLock.tryLock(lockName, request, leaseTime, unit)) {
            counts.put(lockName, 1);
            return true;
        }
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ps: &lt;code&gt;redisLock#tryLock&lt;/code&gt; 为上一篇文章实现的分布锁。&lt;/p&gt;
&lt;p&gt;由于公号外链无法直接跳转，关注『&lt;strong&gt;程序通事&lt;/strong&gt;』，回复&lt;strong&gt;分布式锁&lt;/strong&gt;获取源代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加锁方法首先判断当前线程是否已经已经拥有该锁，若已经拥有，直接对锁的重入次数加 1。&lt;/p&gt;
&lt;p&gt;若还没拥有该锁，则尝试去 &lt;strong&gt;Redis&lt;/strong&gt; 加锁，加锁成功之后，再对重入次数加 1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;释放锁的代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 解锁需要判断不同线程池
 *
 * @param lockName
 * @param request
 */
public void unlock(String lockName, String request) {
    Map&amp;lt;String, Integer&amp;gt; counts = LOCKS.get();
    if (counts.getOrDefault(lockName, 0) &amp;lt;= 1) {
        counts.remove(lockName);
        Boolean result = redisLock.unlock(lockName, request);
        if (!result) {
            throw new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by lockName:+&quot; + lockName + &quot; with request: &quot;
                    + request);
        }

    } else {
        counts.put(lockName, counts.get(lockName) - 1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;释放锁的时首先判断重入次数，若大于 1，则代表该锁是被该线程拥有，所以直接将锁重入次数减 1 即可。&lt;/p&gt;
&lt;p&gt;若当前可重入次数小于等于 1，首先移除 &lt;code&gt;Map&lt;/code&gt;中锁对应的 key，然后再到 Redis 释放锁。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，当锁未被该线程拥有，直接解锁，可重入次数也是小于等于 1 ，这次可能无法直接解锁成功。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 使用过程要记得及时清理内部存储实例变量，防止发生内存泄漏，上下文数据串用等问题。&lt;/p&gt;
&lt;p&gt;下次咱来聊聊最近使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 写的 Bug。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;相关问题&quot;&gt;相关问题&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 这种本地记录重入次数，虽然真的简单高效，但是也存在一些问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过期时间问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述加锁的代码可以看到，重入加锁时，仅仅对本地计数加 1 而已。这样可能就会导致一种情况，由于业务执行过长，Redis 已经过期释放锁。&lt;/p&gt;
&lt;p&gt;而再次重入加锁时，由于本地还存在数据，认为锁还在被持有，这就不符合实际情况。&lt;/p&gt;
&lt;p&gt;如果要在本地增加过期时间，还需要考虑本地与 Redis 过期时间一致性的，代码就会变得很复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同线程/进程可重入问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;狭义上可重入性应该只是对于&lt;strong&gt;同一线程&lt;/strong&gt;的可重入，但是实际业务可能需要不同的应用线程之间可以重入同把锁。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;ThreadLocal&lt;/code&gt;的方案仅仅只能满足同一线程重入，无法解决不同线程/进程之间重入问题。&lt;/p&gt;
&lt;p&gt;不同线程/进程重入问题就需要使用下述方案 Redis Hash 方案解决。&lt;/p&gt;
&lt;h2 id=&quot;基于-redis-hash-可重入锁&quot;&gt;基于 Redis Hash 可重入锁&lt;/h2&gt;
&lt;h3 id=&quot;实现方式-2&quot;&gt;实现方式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 的方案中我们使用了 &lt;code&gt;Map&lt;/code&gt; 记载锁的可重入次数，而 Redis 也同样提供了 Hash （哈希表）这种可以存储键值对数据结构。所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 &lt;code&gt;lua&lt;/code&gt; 脚本判断逻辑。&lt;/p&gt;
&lt;p&gt;加锁的 lua 脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;---- 1 代表 true
---- 0 代表 false

if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return 1;
end ;
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return 1;
end ;
return 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果 KEYS:[lock],ARGV[1000,uuid]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不熟悉 lua 语言同学也不要怕，上述逻辑还是比较简单的。&lt;/p&gt;
&lt;p&gt;加锁代码首先使用 Redis &lt;code&gt;exists&lt;/code&gt; 命令判断当前 lock 这个锁是否存在。&lt;/p&gt;
&lt;p&gt;如果锁不存在的话，直接使用 &lt;code&gt;hincrby&lt;/code&gt;创建一个键为 &lt;code&gt;lock&lt;/code&gt; hash 表，并且为 Hash 表中键为 &lt;code&gt;uuid&lt;/code&gt; 初始化为 0，然后再次加 1，最后再设置过期时间。&lt;/p&gt;
&lt;p&gt;如果当前锁存在，则使用 &lt;code&gt;hexists&lt;/code&gt;判断当前 &lt;code&gt;lock&lt;/code&gt; 对应的 hash 表中是否存在 &lt;code&gt;uuid&lt;/code&gt; 这个键，如果存在,再次使用 &lt;code&gt;hincrby&lt;/code&gt; 加 1，最后再次设置过期时间。&lt;/p&gt;
&lt;p&gt;最后如果上述两个逻辑都不符合，直接返回。&lt;/p&gt;
&lt;p&gt;加锁代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 初始化代码

String lockLuaScript = IOUtils.toString(ResourceUtils.getURL(&quot;classpath:lock.lua&quot;).openStream(), Charsets.UTF_8);
lockScript = new DefaultRedisScript&amp;lt;&amp;gt;(lockLuaScript, Boolean.class);

/**
 * 可重入锁
 *
 * @param lockName  锁名字,代表需要争临界资源
 * @param request   唯一标识，可以使用 uuid，根据该值判断是否可以重入
 * @param leaseTime 锁释放时间
 * @param unit      锁释放时间单位
 * @return
 */
public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {
    long internalLockLeaseTime = unit.toMillis(leaseTime);
    return stringRedisTemplate.execute(lockScript, Lists.newArrayList(lockName), String.valueOf(internalLockLeaseTime), request);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Spring-Boot 2.2.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要搞懂 Lua 脚本加锁逻辑，Java 代码实现还是挺简单的，直接使用 SpringBoot 提供的 &lt;code&gt;StringRedisTemplate&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;解锁的 Lua 脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;-- 判断 hash set 可重入 key 的值是否等于 0
-- 如果为 0 代表 该可重入 key 不存在
if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then
    return nil;
end ;
-- 计算当前可重入次数
local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);
-- 小于等于 0 代表可以解锁
if (counter &amp;gt; 0) then
    return 0;
else
    redis.call('del', KEYS[1]);
    return 1;
end ;
return nil;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先使用 &lt;code&gt;hexists&lt;/code&gt; 判断 Redis Hash 表是否存给定的域。&lt;/p&gt;
&lt;p&gt;如果 lock 对应 Hash 表不存在，或者 Hash 表不存在 uuid 这个 key，直接返回 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若存在的情况下，代表当前锁被其持有，首先使用 &lt;code&gt;hincrby&lt;/code&gt;使可重入次数减 1 ，然后判断计算之后可重入次数，若小于等于 0，则使用 &lt;code&gt;del&lt;/code&gt; 删除这把锁。&lt;/p&gt;
&lt;p&gt;解锁的 Java 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 初始化代码：


String unlockLuaScript = IOUtils.toString(ResourceUtils.getURL(&quot;classpath:unlock.lua&quot;).openStream(), Charsets.UTF_8);
unlockScript = new DefaultRedisScript&amp;lt;&amp;gt;(unlockLuaScript, Long.class);

/**
 * 解锁
 * 若可重入 key 次数大于 1，将可重入 key 次数减 1 &amp;lt;br&amp;gt;
 * 解锁 lua 脚本返回含义：&amp;lt;br&amp;gt;
 * 1:代表解锁成功 &amp;lt;br&amp;gt;
 * 0:代表锁未释放，可重入次数减 1 &amp;lt;br&amp;gt;
 * nil：代表其他线程尝试解锁 &amp;lt;br&amp;gt;
 * &amp;lt;p&amp;gt;
 * 如果使用 DefaultRedisScript&amp;lt;Boolean&amp;gt;，由于 Spring-data-redis eval 类型转化，&amp;lt;br&amp;gt;
 * 当 Redis 返回  Nil bulk, 默认将会转化为 false，将会影响解锁语义，所以下述使用：&amp;lt;br&amp;gt;
 * DefaultRedisScript&amp;lt;Long&amp;gt;
 * &amp;lt;p&amp;gt;
 * 具体转化代码请查看：&amp;lt;br&amp;gt;
 * JedisScriptReturnConverter&amp;lt;br&amp;gt;
 *
 * @param lockName 锁名称
 * @param request  唯一标识，可以使用 uuid
 * @throws IllegalMonitorStateException 解锁之前，请先加锁。若为加锁，解锁将会抛出该错误
 */
public void unlock(String lockName, String request) {
    Long result = stringRedisTemplate.execute(unlockScript, Lists.newArrayList(lockName), request);
    // 如果未返回值，代表其他线程尝试解锁
    if (result == null) {
        throw new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by lockName:+&quot; + lockName + &quot; with request: &quot;
                + request);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解锁代码执行方式与加锁类似，只不过解锁的执行结果返回类型使用 &lt;code&gt;Long&lt;/code&gt;。这里之所以没有跟加锁一样使用 &lt;code&gt;Boolean&lt;/code&gt; ,这是因为解锁 lua 脚本中，三个返回值含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 代表解锁成功，锁被释放&lt;/li&gt;
&lt;li&gt;0 代表可重入次数被减 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; 代表其他线程尝试解锁，解锁失败&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果返回值使用 &lt;code&gt;Boolean&lt;/code&gt;，&lt;strong&gt;Spring-data-redis&lt;/strong&gt; 进行类型转换时将会把 &lt;code&gt;null&lt;/code&gt; 转为 false，这就会影响我们逻辑判断，所以返回类型只好使用 &lt;code&gt;Long&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下代码来自 &lt;code&gt;JedisScriptReturnConverter&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615071000265-1799688379.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关问题-2&quot;&gt;相关问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;spring-data-redis 低版本问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 Spring-Boot 使用 Jedis 作为连接客户端,并且使用Redis Cluster 集群模式，需要使用 &lt;strong&gt;2.1.9&lt;/strong&gt; 以上版本的&lt;strong&gt;spring-boot-starter-data-redis&lt;/strong&gt;,不然执行过程中将会抛出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-log&quot;&gt;org.springframework.dao.InvalidDataAccessApiUsageException: EvalSha is not supported in cluster environment.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果当前应用无法升级 &lt;code&gt;spring-data-redis&lt;/code&gt;也没关系，可以使用如下方式，直接使用原生 Jedis 连接执行 lua 脚本。&lt;/p&gt;
&lt;p&gt;以加锁代码为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean tryLock(String lockName, String reentrantKey, long leaseTime, TimeUnit unit) {
    long internalLockLeaseTime = unit.toMillis(leaseTime);
    Boolean result = stringRedisTemplate.execute((RedisCallback&amp;lt;Boolean&amp;gt;) connection -&amp;gt; {
        Object innerResult = eval(connection.getNativeConnection(), lockScript, Lists.newArrayList(lockName), Lists.newArrayList(String.valueOf(internalLockLeaseTime), reentrantKey));
        return convert(innerResult);
    });
    return result;
}

private Object eval(Object nativeConnection, RedisScript redisScript, final List&amp;lt;String&amp;gt; keys, final List&amp;lt;String&amp;gt; args) {

    Object innerResult = null;
    // 集群模式和单点模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行
    // 集群
    if (nativeConnection instanceof JedisCluster) {
        innerResult = evalByCluster((JedisCluster) nativeConnection, redisScript, keys, args);
    }
    // 单点
    else if (nativeConnection instanceof Jedis) {
        innerResult = evalBySingle((Jedis) nativeConnection, redisScript, keys, args);
    }
    return innerResult;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据类型转化问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果使用 Jedis 原生连接执行 Lua 脚本，那么可能又会碰到数据类型的转换坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615071000492-730832562.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 &lt;code&gt;Jedis#eval&lt;/code&gt;返回 &lt;code&gt;Object&lt;/code&gt;，我们需要具体根据 Lua 脚本的返回值的，再进行相关转化。这其中就涉及到 Lua 数据类型转化为 Redis 数据类型。&lt;/p&gt;
&lt;p&gt;下面主要我们来讲下 Lua 数据转化 Redis 的规则中几条比较容易踩坑：&lt;/p&gt;
&lt;p&gt;1、Lua number 与 Redis 数据类型转换&lt;/p&gt;
&lt;p&gt;Lua 中 number 类型是一个双精度的浮点数，但是 Redis 只支持整数类型，所以这个转化过程将会丢弃小数位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615071000624-1930734144.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、Lua boolean 与 Redis 类型转换&lt;/p&gt;
&lt;p&gt;这个转化比较容易踩坑，Redis 中是不存在 boolean 类型，所以当Lua 中 &lt;code&gt;true&lt;/code&gt; 将会转为 Redis 整数 1。而 Lua 中 &lt;code&gt;false&lt;/code&gt; 并不是转化整数，而是转化 &lt;strong&gt;null&lt;/strong&gt; 返回给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200615071000811-779991641.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、Lua nil 与 Redis 类型转换&lt;/p&gt;
&lt;p&gt;Lua nil 可以当做是一个空值，可以等同于 Java 中的 &lt;strong&gt;null&lt;/strong&gt;。在 Lua 中如果 nil 出现在条件表达式，将会当做 false 处理。&lt;/p&gt;
&lt;p&gt;所以 Lua nil 也将会 &lt;strong&gt;null&lt;/strong&gt; 返回给客户端。&lt;/p&gt;
&lt;p&gt;其他转化规则比较简单，详情参考:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://doc.redisfans.com/script/eval.html&quot;&gt;http://doc.redisfans.com/script/eval.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可重入分布式锁关键在于对于锁重入的计数，这篇文章主要给出两种解决方案，一种基于 &lt;code&gt;ThreadLocal&lt;/code&gt; 实现方案，这种方案实现简单，运行也比较高效。但是若要处理锁过期的问题，代码实现就比较复杂。&lt;/p&gt;
&lt;p&gt;另外一种采用 Redis Hash 数据结构实现方案，解决了 &lt;code&gt;ThreadLocal&lt;/code&gt; 的缺陷，但是代码实现难度稍大，需要熟悉 Lua 脚本，以及Redis 一些命令。另外使用 &lt;strong&gt;spring-data-redis&lt;/strong&gt; 等操作 Redis 时不经意间就会遇到各种问题。&lt;/p&gt;
&lt;h2 id=&quot;帮助&quot;&gt;帮助&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-jraft-rheakv-distributedlock/&quot;&gt;https://www.sofastack.tech/blog/sofa-jraft-rheakv-distributedlock/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html&quot;&gt;https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后说两句（求关注）&quot;&gt;最后说两句（求关注）&lt;/h2&gt;
&lt;p&gt;看完文章，哥哥姐姐们点个&lt;strong&gt;赞&lt;/strong&gt;吧，周更真的超累，不知觉又写了两天，拒绝白嫖，来点正反馈呗~。&lt;/p&gt;
&lt;p&gt;最后感谢各位的阅读，才疏学浅，难免存在纰漏，如果你发现错误的地方，可以留言指出。如果看完文章还有其他不懂的地方，欢迎加我，互相学习，一起成长~&lt;/p&gt;
&lt;p&gt;最后谢谢大家支持~&lt;/p&gt;
&lt;p&gt;最最后，重要的事再说一篇~&lt;/p&gt;
&lt;p&gt;快来关注我呀~&lt;br/&gt;快来关注我呀~&lt;br/&gt;快来关注我呀~&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 14 Jun 2020 23:10:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>重做永远比改造简单 最近在做一个项目，将一个其他公司的实现系统（下文称作旧系统），完整的整合到自己公司的系统（下文称作新系统）中，这其中需要将对方实现的功能完整在自己系统也实现一遍。 旧系统还有一批存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13128883.html</dc:identifier>
</item>
<item>
<title>曹工说Redis源码（8）--面试时，redis 内存淘汰总被问，但是总答不好 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/13128882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/13128882.html</guid>
<description>&lt;p&gt;Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于我用c也是好几年以前了，些许错误在所难免，希望读者能不吝指出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12637730.html&quot;&gt;曹工说Redis源码（1）-- redis debug环境搭建，使用clion，达到和调试java一样的效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12682760.html&quot;&gt;曹工说Redis源码（2）-- redis server 启动过程解析及简单c语言基础知识补充&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12685918.html&quot;&gt;曹工说Redis源码（3）-- redis server 启动过程完整解析（中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12694767.html&quot;&gt;曹工说Redis源码（4）-- 通过redis server源码来理解 listen 函数中的 backlog 参数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12709257.html&quot;&gt;曹工说Redis源码（5）-- redis server 启动过程解析，以及EventLoop每次处理事件前的前置工作解析（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12728548.html&quot;&gt;曹工说Redis源码（6）-- redis server 主循环大体流程解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12748424.html&quot;&gt;曹工说Redis源码（7）-- redis server 的周期执行任务，到底要做些啥&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内存淘汰，和平时我们设置redis key的过期时间，不是一回事；内存淘汰是说，假设我们限定redis只能使用8g内存，现在已经使用了这么多了（包括设置了过期时间的key和没设过期时间的key），那，后续的set操作，还怎么办呢？&lt;/p&gt;
&lt;p&gt;是不是只能报错了？&lt;/p&gt;
&lt;p&gt;那不行啊，不科学吧，因为有的key，可能已经很久没人用了，可能以后也不会再用到了，那我们是不是可以把这类key给干掉呢？&lt;/p&gt;
&lt;p&gt;干掉key的过程，就是内存淘汰。&lt;/p&gt;

&lt;p&gt;当我们在配置文件里设置了如下属性时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# maxmemory &amp;lt;bytes&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认，该属性是被注释掉的。&lt;/p&gt;
&lt;p&gt;其实，这个配置项的注释，相当有价值，我们来看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy selected (see maxmemory-policy).
#
# If Redis can't remove keys according to the policy, or if the policy is
# set to 'noeviction', Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
#
# This option is usually useful when using Redis as an LRU cache, or to set
# a hard memory limit for an instance (using the 'noeviction' policy).
#
# WARNING: If you have slaves attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the slaves are subtracted
# from the used memory count, so that network problems / resyncs will
# not trigger a loop where keys are evicted, and in turn the output
# buffer of slaves is full with DELs of keys evicted triggering the deletion
# of more keys, and so forth until the database is completely emptied.
#
# In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is 'noeviction').
#
# maxmemory &amp;lt;bytes&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;渣翻译如下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;不能使用超过指定数量bytes的内存。当该内存限制被达到时，redis会根据过期策略（eviction policy，通过参数 maxmemory-policy来指定）来驱逐key。&lt;/p&gt;
&lt;p&gt;如果redis根据指定的策略，或者策略被设置为“noeviction”，redis会开始针对如下这种命令，回复错误。什么命令呢？会使用更多内存的那类命令，比如set、lpush；只读命令还是不受影响，可以正常响应。&lt;/p&gt;
&lt;p&gt;该选项通常在redis使用LRU缓存时有用，或者在使用noeviction策略时，设置一个进程级别的内存limit。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓策略，意思是，当我们要删除部分key的时候，删哪些，不删哪些？是不是需要一个策略？比如是随机删，就像灭霸一样？还是按照lru时间来删，lru的策略意思就是，最近最少使用的key，将被优先删除。&lt;/p&gt;
&lt;p&gt;总之，我们需要定一个规则。&lt;/p&gt;
&lt;p&gt;redis默认支持以下策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
# 
# volatile-lru -&amp;gt; remove the key with an expire set using an LRU algorithm
# allkeys-lru -&amp;gt; remove any key accordingly to the LRU algorithm
# volatile-random -&amp;gt; remove a random key with an expire set
# allkeys-random -&amp;gt; remove a random key, any key
# volatile-ttl -&amp;gt; remove the key with the nearest expire time (minor TTL)
# noeviction -&amp;gt; don't expire at all, just return an error on write operations
# 
# Note: with any of the above policies, Redis will return an error on write
#       operations, when there are not suitable keys for eviction.
#
#       At the date of writing this commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
#
# The default is:
#
# maxmemory-policy noeviction
maxmemory-policy allkeys-lru
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;针对设置了过期时间的，使用lru算法
# volatile-lru -&amp;gt; remove the key with an expire set using an LRU algorithm

针对全部key，使用lru算法
# allkeys-lru -&amp;gt; remove any key accordingly to the LRU algorithm

针对设置了过期时间的，随机删
# volatile-random -&amp;gt; remove a random key with an expire set

针对全部key，随机删
# allkeys-random -&amp;gt; remove a random key, any key

针对设置了过期时间的，马上要过期的，删掉
# volatile-ttl -&amp;gt; remove the key with the nearest expire time (minor TTL)

不过期，不能写了，就报错
# noeviction -&amp;gt; don't expire at all, just return an error on write operations
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般呢，我们会设置为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allkeys-lru&lt;/code&gt;，即，针对全部key，进行lru。&lt;/p&gt;

&lt;h2 id=&quot;配置读取&quot;&gt;配置读取&lt;/h2&gt;
&lt;p&gt;在如下结构体中，定义了如下字段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct redisServer {
        ...
        unsigned long long maxmemory;   /* Max number of memory bytes to use */
    int maxmemory_policy;           /* Policy for key eviction */
    int maxmemory_samples;          /* Pricision of random sampling */
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们在配置文件中，进入如下配置时，该结构体中几个字段的值如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;maxmemory 3mb
maxmemory-policy allkeys-lru
# maxmemory-samples 5  这个取了默认值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202006/519126-20200614100616444-1893913670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;maxmemory_policy为3，是因为枚举值为3：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define REDIS_MAXMEMORY_VOLATILE_LRU 0
#define REDIS_MAXMEMORY_VOLATILE_TTL 1
#define REDIS_MAXMEMORY_VOLATILE_RANDOM 2
#define REDIS_MAXMEMORY_ALLKEYS_LRU 3
#define REDIS_MAXMEMORY_ALLKEYS_RANDOM 4
#define REDIS_MAXMEMORY_NO_EVICTION 5
#define REDIS_DEFAULT_MAXMEMORY_POLICY REDIS_MAXMEMORY_NO_EVICTION
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;处理命令时，判断是否进行内存淘汰&quot;&gt;处理命令时，判断是否进行内存淘汰&lt;/h2&gt;
&lt;p&gt;在处理命令的时候，会调用中的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;redis.c  processCommand
    
int processCommand(redisClient *c) {
    /* The QUIT command is handled separately. Normal command procs will
     * go through checking for replication and QUIT will cause trouble
     * when FORCE_REPLICATION is enabled and would be implemented in
     * a regular command proc. */
    // 特别处理 quit 命令
    void *commandName = c-&amp;gt;argv[0]-&amp;gt;ptr;
    redisLog(REDIS_NOTICE, &quot;The server is now processing %s&quot;, commandName);

    if (!strcasecmp(c-&amp;gt;argv[0]-&amp;gt;ptr, &quot;quit&quot;)) {
        addReply(c, shared.ok);
        c-&amp;gt;flags |= REDIS_CLOSE_AFTER_REPLY;
        return REDIS_ERR;
    }

    /* Now lookup the command and check ASAP about trivial error conditions
     * such as wrong arity, bad command name and so forth. */
    // 1 查找命令，并进行命令合法性检查，以及命令参数个数检查
    c-&amp;gt;cmd = c-&amp;gt;lastcmd = lookupCommand(c-&amp;gt;argv[0]-&amp;gt;ptr);
    if (!c-&amp;gt;cmd) {
        // 没找到指定的命令
        flagTransaction(c);
        addReplyErrorFormat(c, &quot;unknown command '%s'&quot;,
                            (char *) c-&amp;gt;argv[0]-&amp;gt;ptr);
        return REDIS_OK;
    }

    /* Check if the user is authenticated */
    //2 检查认证信息
    if (server.requirepass &amp;amp;&amp;amp; !c-&amp;gt;authenticated &amp;amp;&amp;amp; c-&amp;gt;cmd-&amp;gt;proc != authCommand) {
        flagTransaction(c);
        addReply(c, shared.noautherr);
        return REDIS_OK;
    }

    /* If cluster is enabled perform the cluster redirection here.
     *
     * 3 如果开启了集群模式，那么在这里进行转向操作。
     *
     * However we don't perform the redirection if:
     *
     * 不过，如果有以下情况出现，那么节点不进行转向：
     *
     * 1) The sender of this command is our master.
     *    命令的发送者是本节点的主节点
     *
     * 2) The command has no key arguments. 
     *    命令没有 key 参数
     */
    if (server.cluster_enabled &amp;amp;&amp;amp;
        !(c-&amp;gt;flags &amp;amp; REDIS_MASTER) &amp;amp;&amp;amp;
        !(c-&amp;gt;cmd-&amp;gt;getkeys_proc == NULL &amp;amp;&amp;amp; c-&amp;gt;cmd-&amp;gt;firstkey == 0)) {
        int hashslot;

        // 集群已下线
        if (server.cluster-&amp;gt;state != REDIS_CLUSTER_OK) {
            flagTransaction(c);
            addReplySds(c, sdsnew(&quot;-CLUSTERDOWN The cluster is down. Use CLUSTER INFO for more information\r\n&quot;));
            return REDIS_OK;

            // 集群运作正常
        } else {
            int error_code;
            clusterNode *n = getNodeByQuery(c, c-&amp;gt;cmd, c-&amp;gt;argv, c-&amp;gt;argc, &amp;amp;hashslot, &amp;amp;error_code);
            // 不能执行多键处理命令
            if (n == NULL) {
                flagTransaction(c);
                if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) {
                    addReplySds(c, sdsnew(&quot;-CROSSSLOT Keys in request don't hash to the same slot\r\n&quot;));
                } else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) {
                    /* The request spawns mutliple keys in the same slot,
                     * but the slot is not &quot;stable&quot; currently as there is
                     * a migration or import in progress. */
                    addReplySds(c, sdsnew(&quot;-TRYAGAIN Multiple keys request during rehashing of slot\r\n&quot;));
                } else {
                    redisPanic(&quot;getNodeByQuery() unknown error.&quot;);
                }
                return REDIS_OK;

                //3.1 命令针对的槽和键不是本节点处理的，进行转向
            } else if (n != server.cluster-&amp;gt;myself) {
                flagTransaction(c);
                // -&amp;lt;ASK or MOVED&amp;gt; &amp;lt;slot&amp;gt; &amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;
                // 例如 -ASK 10086 127.0.0.1:12345
                addReplySds(c, sdscatprintf(sdsempty(),
                                            &quot;-%s %d %s:%d\r\n&quot;,
                                            (error_code == REDIS_CLUSTER_REDIR_ASK) ? &quot;ASK&quot; : &quot;MOVED&quot;,
                                            hashslot, n-&amp;gt;ip, n-&amp;gt;port));

                return REDIS_OK;
            }

            // 如果执行到这里，说明键 key 所在的槽由本节点处理
            // 或者客户端执行的是无参数命令
        }
    }

    /* Handle the maxmemory directive.
     *
     * First we try to free some memory if possible (if there are volatile
     * keys in the dataset). If there are not the only thing we can do
     * is returning an error. */
    //4 如果设置了最大内存，那么检查内存是否超过限制，并做相应的操作
    if (server.maxmemory) {
        //4.1 如果内存已超过限制，那么尝试通过删除过期键来释放内存
        int retval = freeMemoryIfNeeded();
        // 如果即将要执行的命令可能占用大量内存（REDIS_CMD_DENYOOM）
        // 并且前面的内存释放失败的话
        // 那么向客户端返回内存错误
        if ((c-&amp;gt;cmd-&amp;gt;flags &amp;amp; REDIS_CMD_DENYOOM) &amp;amp;&amp;amp; retval == REDIS_ERR) {
            flagTransaction(c);
            addReply(c, shared.oomerr);
            return REDIS_OK;
        }
    }    
    ....
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，查找命令，对应的函数指针（类似于java里的策略模式，根据命令，找对应的策略）&lt;/li&gt;
&lt;li&gt;2处，检查，是否密码正确&lt;/li&gt;
&lt;li&gt;3处，集群相关操作；&lt;/li&gt;
&lt;li&gt;3.1处，不是本节点处理，直接返回ask，指示客户端转向&lt;/li&gt;
&lt;li&gt;4处，判断是否设置了maxMemory，这里就是本文重点：设置了maxMemory时，内存淘汰策略&lt;/li&gt;
&lt;li&gt;4.1处，调用了下方的 freeMemoryIfNeeded&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，深入4.1处：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;
int freeMemoryIfNeeded(void) {
    size_t mem_used, mem_tofree, mem_freed;
    int slaves = listLength(server.slaves);

    /* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */
    // 计算出 Redis 目前占用的内存总数，但有两个方面的内存不会计算在内：
    // 1）从服务器的输出缓冲区的内存
    // 2）AOF 缓冲区的内存
    mem_used = zmalloc_used_memory();
    if (slaves) {
                ...
    }
    if (server.aof_state != REDIS_AOF_OFF) {
        mem_used -= sdslen(server.aof_buf);
        mem_used -= aofRewriteBufferSize();
    }

    /* Check if we are over the memory limit. */
    //1 如果目前使用的内存大小比设置的 maxmemory 要小，那么无须执行进一步操作
    if (mem_used &amp;lt;= server.maxmemory) return REDIS_OK;

    //2 如果占用内存比 maxmemory 要大，但是 maxmemory 策略为不淘汰，那么直接返回
    if (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION)
        return REDIS_ERR; /* We need to free memory, but policy forbids. */

    /* Compute how much memory we need to free. */
    // 3 计算需要释放多少字节的内存
    mem_tofree = mem_used - server.maxmemory;

    // 初始化已释放内存的字节数为 0
    mem_freed = 0;

    // 根据 maxmemory 策略，
    //4 遍历字典，释放内存并记录被释放内存的字节数
    while (mem_freed &amp;lt; mem_tofree) {
        int j, k, keys_freed = 0;

        // 遍历所有字典
        for (j = 0; j &amp;lt; server.dbnum; j++) {
            long bestval = 0; /* just to prevent warning */
            sds bestkey = NULL;
            dictEntry *de;
            redisDb *db = server.db + j;
            dict *dict;

            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||
                server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM) {
                // 如果策略是 allkeys-lru 或者 allkeys-random 
                //5 那么淘汰的目标为所有数据库键
                dict = server.db[j].dict;
            } else {
                // 如果策略是 volatile-lru 、 volatile-random 或者 volatile-ttl 
                //6 那么淘汰的目标为带过期时间的数据库键
                dict = server.db[j].expires;
            }


            /* volatile-random and allkeys-random policy */
            // 如果使用的是随机策略，那么从目标字典中随机选出键
            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM ||
                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM) {
                de = dictGetRandomKey(dict);
                bestkey = dictGetKey(de);
            }
            /* volatile-lru and allkeys-lru policy */
            //7 
            else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||
                     server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU) {
                struct evictionPoolEntry *pool = db-&amp;gt;eviction_pool;

                while (bestkey == NULL) {
                    // 8 
                    evictionPoolPopulate(dict, db-&amp;gt;dict, db-&amp;gt;eviction_pool);
                    /* Go backward from best to worst element to evict. */
                    for (k = REDIS_EVICTION_POOL_SIZE - 1; k &amp;gt;= 0; k--) {
                        if (pool[k].key == NULL) continue;
                        // 8.1
                        de = dictFind(dict, pool[k].key);

                        /* 8.2 Remove the entry from the pool. */
                        sdsfree(pool[k].key);
                        /* Shift all elements on its right to left. */
                        memmove(pool + k, pool + k + 1,
                                sizeof(pool[0]) * (REDIS_EVICTION_POOL_SIZE - k - 1));
                        /* Clear the element on the right which is empty
                         * since we shifted one position to the left.  */
                        pool[REDIS_EVICTION_POOL_SIZE - 1].key = NULL;
                        pool[REDIS_EVICTION_POOL_SIZE - 1].idle = 0;

                        /* If the key exists, is our pick. Otherwise it is
                         * a ghost and we need to try the next element. */
                        // 8.3
                        if (de) {
                            bestkey = dictGetKey(de);
                            break;
                        } else {
                            /* Ghost... */
                            continue;
                        }
                    }
                }
            }

                /* volatile-ttl */
                // 策略为 volatile-ttl ，从一集 sample 键中选出过期时间距离当前时间最接近的键
            else if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_TTL) {
                ...
            }

            /* Finally remove the selected key. */
            // 8.4 删除被选中的键
            if (bestkey) {
                long long delta;

                robj *keyobj = createStringObject(bestkey, sdslen(bestkey));
                propagateExpire(db, keyobj);
                /* We compute the amount of memory freed by dbDelete() alone.
                 * It is possible that actually the memory needed to propagate
                 * the DEL in AOF and replication link is greater than the one
                 * we are freeing removing the key, but we can't account for
                 * that otherwise we would never exit the loop.
                 *
                 * AOF and Output buffer memory will be freed eventually so
                 * we only care about memory used by the key space. */
                // 计算删除键所释放的内存数量
                delta = (long long) zmalloc_used_memory();
                dbDelete(db, keyobj);
                delta -= (long long) zmalloc_used_memory();
                mem_freed += delta;

                // 对淘汰键的计数器增一
                server.stat_evictedkeys++;

                notifyKeyspaceEvent(REDIS_NOTIFY_EVICTED, &quot;evicted&quot;,
                                    keyobj, db-&amp;gt;id);
                decrRefCount(keyobj);
                keys_freed++;
                                ...
            }
        }

        if (!keys_freed) return REDIS_ERR; /* nothing to free... */
    }

    return REDIS_OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1处，如果目前使用的内存大小比设置的 maxmemory 要小，那么无须执行进一步操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2处，如果占用内存比 maxmemory 要大，但是 maxmemory 策略为不淘汰，那么直接返回&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3处，计算需要释放多少字节的内存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4处，遍历字典，释放内存并记录被释放内存的字节数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5处，如果策略是 allkeys-lru 或者 allkeys-random 那么淘汰的目标为所有数据库键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;6处，如果策略是 volatile-lru 、 volatile-random 或者 volatile-ttl ，那么淘汰的目标为带过期时间的数据库键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7处，如果使用的是 LRU 策略， 那么从 sample 键中选出 IDLE 时间最长的那个键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;8处，调用evictionPoolPopulate，该函数在下面讲解,该函数的功能是，传入一个链表，即这里的db-&amp;gt;eviction_pool，然后在函数内部，随机找出n个key，放入传入的链表中，并按照空闲时间排序，空闲最久的，放到最后。&lt;/p&gt;
&lt;p&gt;当该函数，返回后，db-&amp;gt;eviction_pool这个链表里就存放了我们要淘汰的key。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;8.1处，找到这个key，这个key，在后边会被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;8.2处，下面这一段，从db-&amp;gt;eviction_pool将这个已经处理了的key删掉&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;8.3处，如果这个key，是存在的，则跳出循环，在后面8.4处，会被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8.4处，删除这个key&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;选择哪些key作为被淘汰的key&quot;&gt;选择哪些key作为被淘汰的key&lt;/h2&gt;
&lt;p&gt;前面我们看到，在7处，如果为lru策略，则会进入8处的函数：&lt;/p&gt;
&lt;p&gt;evictionPoolPopulate。&lt;/p&gt;
&lt;p&gt;该函数的名称为：填充(populate)驱逐(eviction)对象池(pool)。驱逐的意思，就是现在达到了maxmemory，没办法，只能开始删除掉一部分元素，来腾空间了，不然新的put类型的命令，根本没办法执行。&lt;/p&gt;
&lt;p&gt;该方法的大概思路是，使用lru的时候，随机找n个key，类似于抽样，然后放到一个链表，根据空闲时间排序。&lt;/p&gt;
&lt;p&gt;具体看看该方法的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void evictionPoolPopulate(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，传入的第三个参数，是要被填充的对象，在c语言中，习惯传入一个入参，然后在函数内部填充或者修改入参对象的属性。&lt;/p&gt;
&lt;p&gt;该属性，就是前面说的那个链表，用来存放收集的随机的元素，该链表中节点的结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct evictionPoolEntry {
    unsigned long long idle;    /* Object idle time. */
    sds key;                    /* Key name. */
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该结构共2个字段，一个存储key，一个存储空闲时间。&lt;/p&gt;
&lt;p&gt;该链表中，共maxmemory-samples个元素，会按照idle时间长短排序，idle时间长的在链表尾部，（假设头在左，尾在右）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void evictionPoolPopulate(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
    int j, k, count;
    dictEntry *_samples[EVICTION_SAMPLES_ARRAY_SIZE];
    dictEntry **samples;

    /* Try to use a static buffer: this function is a big hit...
     * Note: it was actually measured that this helps. */
    if (server.maxmemory_samples &amp;lt;= EVICTION_SAMPLES_ARRAY_SIZE) {
        samples = _samples;
    } else {
        samples = zmalloc(sizeof(samples[0]) * server.maxmemory_samples);
    }

    /* 1 Use bulk get by default. */
    count = dictGetRandomKeys(sampledict, samples, server.maxmemory_samples);

        // 2
    for (j = 0; j &amp;lt; count; j++) {
        unsigned long long idle;
        sds key;
        robj *o;
        dictEntry *de;

        de = samples[j];
        key = dictGetKey(de);
        /* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */
        if (sampledict != keydict) de = dictFind(keydict, key);
        // 3
        o = dictGetVal(de);
        // 4
        idle = estimateObjectIdleTime(o);

        /* 5  Insert the element inside the pool.
         * First, find the first empty bucket or the first populated
         * bucket that has an idle time smaller than our idle time. */
        k = 0;
        while (k &amp;lt; REDIS_EVICTION_POOL_SIZE &amp;amp;&amp;amp;
               pool[k].key &amp;amp;&amp;amp;
               pool[k].idle &amp;lt; idle)
            k++;
        
                ...
            
        // 6
        pool[k].key = sdsdup(key);
        pool[k].idle = idle;
    }
    if (samples != _samples) zfree(samples);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;22&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1处，获取 &lt;code&gt;server.maxmemory_samples&lt;/code&gt;个key，这里是随机获取的，（dictGetRandomKeys），这个值，默认值为5，放到samples中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2处，遍历返回来的samples&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;3处，调用如下宏，获取val&lt;/p&gt;
&lt;p&gt;he的类型为dictEntry：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/*
 * 哈希表节点
 */
typedef struct dictEntry {
    
    // 键
    void *key;

    // 值
    union {
        // 1
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

} dictEntry;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，这里去&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;robj *o; 

o = dictGetVal(de);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际就是获取其v属性中的val,(1处)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define dictGetVal(he) ((he)-&amp;gt;v.val)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;4处，准备计算该val的空闲时间&lt;/p&gt;
&lt;p&gt;我们上面3处，看到，获取的o的类型为robj。我们现在看看怎么计算对象的空闲时长：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Given an object returns the min number of milliseconds the object was never
 * requested, using an approximated LRU algorithm. */
unsigned long long estimateObjectIdleTime(robj *o) {
    //4.1 获取系统的当前时间
    unsigned long long lruclock = LRU_CLOCK();
    // 4.2
    if (lruclock &amp;gt;= o-&amp;gt;lru) {
        // 4.3
        return (lruclock - o-&amp;gt;lru) * REDIS_LRU_CLOCK_RESOLUTION;
    } else {
        return (lruclock + (REDIS_LRU_CLOCK_MAX - o-&amp;gt;lru)) *
                    REDIS_LRU_CLOCK_RESOLUTION;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，4.1处，获取系统的当前时间；&lt;/p&gt;
&lt;p&gt;4.2处，如果系统时间，大于对象的lru时间&lt;/p&gt;
&lt;p&gt;4.3处，则用系统时间减去对象的lru时间，再乘以单位,换算为毫秒，最终返回的单位，为毫秒(可以看注释。)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;5处，这里拿当前元素，和pool中已经放进去的元素，从第0个开始比较，如果当前元素的idle时长，大于pool中指针0指向的元素，则和pool中索引1的元素比较；直到条件不满足为止。&lt;/p&gt;
&lt;p&gt;这句话意思就是，类似于冒泡，把当前元素一直往后冒，直到idle时长小于被比较的元素为止。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;6处，把当前元素放进pool中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过上面的处理后，链表中存放了全部的抽样元素，且ide时间最长的，在最右边。&lt;/p&gt;
&lt;h2 id=&quot;对象还有字段存储空闲时间？&quot;&gt;对象还有字段存储空闲时间？&lt;/h2&gt;
&lt;p&gt;前面4处，说到，用系统的当前时间，减去对象的lru时间。&lt;/p&gt;
&lt;p&gt;大家看看对象的结构体&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    //1 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    int refcount;

    // 指向实际值的指针
    void *ptr;

} robj;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面1处，lru属性，就是用来存储这个。&lt;/p&gt;
&lt;h3 id=&quot;创建对象时，直接使用当前系统时间创建&quot;&gt;创建对象时，直接使用当前系统时间创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;robj *createObject(int type, void *ptr) {

    robj *o = zmalloc(sizeof(*o));

    o-&amp;gt;type = type;
    o-&amp;gt;encoding = REDIS_ENCODING_RAW;
    o-&amp;gt;ptr = ptr;
    o-&amp;gt;refcount = 1;

    /*1 Set the LRU to the current lruclock (minutes resolution). */
    o-&amp;gt;lru = LRU_CLOCK();
    return o;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处即是。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;robj *createEmbeddedStringObject(char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1);
    struct sdshdr *sh = (void*)(o+1);

    o-&amp;gt;type = REDIS_STRING;
    o-&amp;gt;encoding = REDIS_ENCODING_EMBSTR;
    o-&amp;gt;ptr = sh+1;
    o-&amp;gt;refcount = 1;
    // 1
    o-&amp;gt;lru = LRU_CLOCK();

    sh-&amp;gt;len = len;
    sh-&amp;gt;free = 0;
    if (ptr) {
        memcpy(sh-&amp;gt;buf,ptr,len);
        sh-&amp;gt;buf[len] = '\0';
    } else {
        memset(sh-&amp;gt;buf,0,len+1);
    }
    return o;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处即是。&lt;/p&gt;
&lt;h3 id=&quot;每次查找该key时，刷新时间&quot;&gt;每次查找该key时，刷新时间&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;robj *lookupKey(redisDb *db, robj *key) {

    // 查找键空间
    dictEntry *de = dictFind(db-&amp;gt;dict,key-&amp;gt;ptr);

    // 节点存在
    if (de) {
        

        // 取出值
        robj *val = dictGetVal(de);

        /* Update the access time for the ageing algorithm.
         * Don't do it if we have a saving child, as this will trigger
         * a copy on write madness. */
        // 更新时间信息（只在不存在子进程时执行，防止破坏 copy-on-write 机制）
        if (server.rdb_child_pid == -1 &amp;amp;&amp;amp; server.aof_child_pid == -1)
            // 1
            val-&amp;gt;lru = LRU_CLOCK();

        // 返回值
        return val;
    } else {

        // 节点不存在

        return NULL;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处即是，包括get、set等各种操作，都会刷新该时间。&lt;/p&gt;
&lt;p&gt;仔细看下面的堆栈，set的，get同理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202006/519126-20200614110730822-1634522816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大家有没有更清楚一些呢？&lt;/p&gt;
&lt;p&gt;总的来说，就是，设置了max-memory后，达到该内存限制后，会在处理命令时，检查是否要进行内存淘汰；如果要淘汰，则根据maxmemory-policy的策略来。&lt;/p&gt;
&lt;p&gt;随机选择maxmemory-sample个元素，按照空闲时间排序，拉链表；挨个挨个清除。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jun 2020 23:05:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>文章导航 Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/13128882.html</dc:identifier>
</item>
</channel>
</rss>