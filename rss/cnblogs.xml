<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>记一次WMS的系统改造（2）-敲定方案 - 水一</title>
<link>http://www.cnblogs.com/breezeli/p/10140999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/breezeli/p/10140999.html</guid>
<description>&lt;h2 id=&quot;既定改造方案&quot;&gt;既定改造方案&lt;/h2&gt;
&lt;p&gt;基于&lt;a href=&quot;https://www.cnblogs.com/breezeli/p/10126185.html&quot;&gt;上一篇&lt;/a&gt;分析出的种种问题，我们将库房人员的系统操作划分为两大类。&lt;br/&gt;第一类为&lt;strong&gt;货物驱动&lt;/strong&gt;的操作，这类操作主要随着货物而前进，人员不看或者看软件的次数比较少，更多是对货物的状态进行系统上的确认和进行下一步的业务数据准备。&lt;br/&gt;第二类为&lt;strong&gt;任务驱动&lt;/strong&gt;的操作，这类在库房目前特指质控的相关工作（这边的领域会有其它的定义），更多是为了处理各种紧急情况、异常情况和纯系统操作，我们将上面的各种情况抽象为一个个的&lt;strong&gt;任务&lt;/strong&gt;，让质控人员来处理一个又一个的任务。&lt;/p&gt;
&lt;h3 id=&quot;货物驱动模式&quot;&gt;货物驱动模式&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;货物驱动&lt;/strong&gt;的工作场景中，定义人员进行尽量少的系统操作，条件允许的情况下使用PDA代替电脑进行简单的操作，条件不允许或者必须使用电脑进行的操作，设计遵循以下几个原则&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;菜单和角色绑定，不再进行单独的权限设置&lt;/li&gt;
&lt;li&gt;菜单不再按照功能模块进行拆分，而按照操作单元进行拆分，尽量减少菜单数量&lt;/li&gt;
&lt;li&gt;所有货物操作由一个扫描框起（灵感来源于&lt;strong&gt;搜索引擎&lt;/strong&gt;），系统自动识别所需操作&lt;/li&gt;
&lt;li&gt;强引导模式，将&lt;strong&gt;操作动线&lt;/strong&gt;限定在比较固定的范围内&lt;/li&gt;
&lt;li&gt;减少列表的使用或原则上禁止使用列表&lt;/li&gt;
&lt;li&gt;将视觉焦点定义出来，并将重点区域进行&lt;strong&gt;极夸张&lt;/strong&gt;的放大&lt;/li&gt;
&lt;li&gt;严格控制界面元素，将元素维持在尽量少的数量内&lt;/li&gt;
&lt;li&gt;非重点区域，进行视觉上的略化&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有操作界面必须支持全键盘操作，尽量不使用鼠标&lt;br/&gt;&lt;em&gt;上面不是所有的设计原则，仅包含特别重要的部分。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;任务驱动模式&quot;&gt;任务驱动模式&lt;/h3&gt;
在&lt;strong&gt;任务驱动&lt;/strong&gt;的工作场景中，约定了几个要点&lt;/li&gt;
&lt;li&gt;任务找人而不是人找任务&lt;/li&gt;
&lt;li&gt;为用户提供充分的决策辅助&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个界面处理所有任务，无需切换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个前提下，我们选用了给&lt;strong&gt;客服&lt;/strong&gt;提供的一套工作平台，界面设计上类似于Slack。&lt;br/&gt;我们将所有任务虚拟成消息放在左边的channel（slack位置）的位置，中间用来推送不同任务的处理界面，把各种内外部系统整合后放在最右边栏根据不同的任务场景推送给用户，用作决策支持。&lt;br/&gt;当然在里面还做了很多小的工具，比如地址、电话的自动识别的，订单的自动连接啊，多异常合并，不同质控或者质控和外部人员的信息互通，目的都是为了加速质控人员的处理效率，降低错误。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/33034/201812/33034-20181219005824796-1583781237.jpg&quot;/&gt;&lt;br/&gt;&lt;em&gt;上图为Slack图&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;基于上面的两个设计，我们就志得意满的开始打造我们的新版WMS系统了，但是到此还没完，中间出了一些变数，下篇我们再继续讲。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 16:59:00 +0000</pubDate>
<dc:creator>水一</dc:creator>
<og:description>既定改造方案 基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/breezeli/p/10140999.html</dc:identifier>
</item>
<item>
<title>再一次审视自己 - venicid</title>
<link>http://www.cnblogs.com/venicid/p/10140991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/venicid/p/10140991.html</guid>
<description>&lt;h2 id=&quot;再一次审视自己&quot;&gt;再一次审视自己&lt;/h2&gt;
&lt;p&gt;如果说自己身上最大的缺点的话，&lt;br/&gt;是不自信以至于自卑呢&lt;br/&gt;还是伪勤奋未曾坚持到底呢&lt;/p&gt;
&lt;p&gt;那还是说下自己的优点吧&lt;br/&gt;吾三日而自省其身&lt;br/&gt;只能想到自己一个这样的&lt;br/&gt;但是自省后，却未能有效的解决问题&lt;/p&gt;
&lt;p&gt;杨奇涵问自己：“今日你更博学了吗？”&lt;br/&gt;我问自己些什么呢？&lt;/p&gt;
&lt;h3 id=&quot;过去最近自己的状态&quot;&gt;过去：最近自己的状态&lt;/h3&gt;
&lt;p&gt;感觉从有第一份不错工资的工作后&lt;br/&gt;自己就像拖闸的洪水&lt;br/&gt;怎么也收不回了&lt;br/&gt;回不到自己当初那样的状态&lt;br/&gt;两耳不闻窗外事&lt;br/&gt;每天夜里学到凌晨&lt;/p&gt;
&lt;p&gt;像把所有的优点全都不要了&lt;br/&gt;堕落下去，坠落，坠落&lt;br/&gt;每天玩LoL&lt;br/&gt;学术上也未能进一步&lt;br/&gt;这样下去毕业都是问题了&lt;br/&gt;遇到问题也不能很好的思考&lt;/p&gt;
&lt;p&gt;越发的，我觉得自己失去了&lt;br/&gt;那种学习的能力，思考的能力&lt;br/&gt;就是把那些公有的知识如何变成自己的那种能力&lt;br/&gt;脑子也转动不起来了&lt;br/&gt;走不出舒适区&lt;br/&gt;也不想走出舒适区&lt;br/&gt;我还没有工作&lt;br/&gt;就变成老员工这样了&lt;/p&gt;
&lt;p&gt;还有的最可怕的&lt;br/&gt;自己立下的计划&lt;br/&gt;好久都不能完成&lt;br/&gt;寸步未能前进&lt;br/&gt;自己也不觉得羞愧&lt;br/&gt;不知廉耻的浪费时间&lt;br/&gt;在B站看非学习的视频&lt;br/&gt;在微博，知乎，看最新的news，别人的想法&lt;/p&gt;
&lt;p&gt;自始至终&lt;br/&gt;我都不能坚持做完某些事情&lt;br/&gt;都是敷衍的完成&lt;br/&gt;或者说敷衍的不去完成&lt;/p&gt;
&lt;h3 id=&quot;现在又想什么想法&quot;&gt;现在：又想什么想法&lt;/h3&gt;
&lt;p&gt;读万卷书不如行万里路&lt;br/&gt;行万里路不如阅人无数&lt;/p&gt;
&lt;p&gt;有人说：是读书太少&lt;br/&gt;有人说：是看这个世界看的太少&lt;br/&gt;有人说：社会中磨砺的太少&lt;/p&gt;
&lt;p&gt;我想我根本还是个弟弟&lt;br/&gt;读万卷书前面是什么呢&lt;br/&gt;或许我还没有达到呢&lt;/p&gt;
&lt;p&gt;上次我说&lt;br/&gt;去健身&lt;br/&gt;要系统的学习健身知识&lt;br/&gt;看健身视频&lt;br/&gt;我没有&lt;/p&gt;
&lt;p&gt;上次我说&lt;br/&gt;学英语&lt;br/&gt;去学朋友圈每日英文文献签到&lt;br/&gt;打卡坚持下去&lt;br/&gt;我没有&lt;/p&gt;
&lt;p&gt;上次我说&lt;br/&gt;要观察自己&lt;br/&gt;坚持了一个礼拜&lt;br/&gt;之后未曾记得&lt;br/&gt;我依旧没有&lt;/p&gt;
&lt;p&gt;我们现在的陋习是不能珍惜时间&lt;br/&gt;浪费了太多时间在那些无用的东西上&lt;/p&gt;
&lt;p&gt;早上&lt;br/&gt;我们起不了床&lt;br/&gt;7点多有段时间很清醒&lt;/p&gt;
&lt;p&gt;去实验室&lt;br/&gt;我们看微博新闻，看抽屉网，看B站，看PT种子网&lt;br/&gt;时间就这样又过去了&lt;/p&gt;
&lt;p&gt;中午&lt;br/&gt;我们不去午睡&lt;br/&gt;看会B站的杂七杂八的视频&lt;br/&gt;看某些主播去吃播&lt;br/&gt;说什么酝酿睡觉情绪&lt;/p&gt;
&lt;p&gt;晚上&lt;br/&gt;我们继续看B站&lt;br/&gt;或者玩LoL&lt;br/&gt;重复继续重复这种生活&lt;/p&gt;
&lt;p&gt;回到宿舍&lt;br/&gt;又是手机的天下&lt;br/&gt;又是B站，又是QQ浏览器&lt;br/&gt;又是微博新闻，又是知乎热榜&lt;/p&gt;
&lt;p&gt;早早上床&lt;br/&gt;以为自己能看书下&lt;br/&gt;没想到又是这些手机垃圾资源&lt;/p&gt;
&lt;p&gt;说是用B站看那些学习视频&lt;br/&gt;说是用手机看那些名著资料&lt;br/&gt;说是系统的学习健身&lt;br/&gt;说是。。。&lt;br/&gt;总是说是。。&lt;br/&gt;我们都会说。。。&lt;br/&gt;但是行动力又太少。。。&lt;/p&gt;
&lt;p&gt;就像alex之前说的那样&lt;br/&gt;就像上面说的意思&lt;br/&gt;具体的我忘了&lt;/p&gt;
&lt;p&gt;不过我想到了python要的东西&lt;br/&gt;Less is More&lt;br/&gt;我讨厌那些复杂的程序C++什么的&lt;br/&gt;前20多年，我什么都想学&lt;br/&gt;最终什么都不会&lt;br/&gt;我们想专注一个&lt;br/&gt;只学python&lt;br/&gt;我讨厌了看更多的语言&lt;br/&gt;了解更多的方向&lt;/p&gt;
&lt;p&gt;我们应该有自己的技术栈&lt;br/&gt;大的方向的技术栈&lt;br/&gt;现在只能说我只会一点&lt;br/&gt;如果给自己定性的话&lt;br/&gt;linux 初级&lt;br/&gt;python 初级&lt;br/&gt;数据结构与算法 0级&lt;br/&gt;C++ 0级&lt;br/&gt;go 0级&lt;/p&gt;
&lt;p&gt;大的方向的话&lt;br/&gt;web开发 初级&lt;br/&gt;图像处理 入门&lt;br/&gt;大数据 0级&lt;br/&gt;机器学习 0级&lt;br/&gt;深度学习 0级&lt;br/&gt;区块链 0级&lt;/p&gt;
&lt;h3 id=&quot;未来觉得该做些什么了&quot;&gt;未来：觉得该做些什么了&lt;/h3&gt;
&lt;p&gt;就像alex把特斯拉CEO 埃隆|马斯克 当做偶像&lt;br/&gt;我想我也需要些偶像去看齐&lt;br/&gt;短期的话，肯定就是必胜老师了或者说文娟大帝或者说那些进入大厂的同学&lt;br/&gt;中期的话，那就是Alex，或者说长期目标，或者说不可期&lt;br/&gt;长期的话，或者说仰望的存在的话，中国引力波，陆奇&lt;/p&gt;
&lt;p&gt;今天了解了下陆奇&lt;br/&gt;这位可以说是精神上的领袖&lt;br/&gt;他每天只睡4个小时&lt;/p&gt;
&lt;p&gt;我想到的是&lt;br/&gt;黑夜才是我喜欢的战场&lt;br/&gt;最近早早上床了&lt;br/&gt;却是压抑了自己擅长的时刻&lt;br/&gt;自己在凌晨的脑子才是最清醒的&lt;br/&gt;虽说是为了舍友能明天早早上班&lt;br/&gt;自己这样做，对自己健康也不好&lt;br/&gt;但是，我喜欢黑夜&lt;br/&gt;或许这就是我的激情所在&lt;br/&gt;我又找到了一个优点&lt;br/&gt;自己的一个兴趣点&lt;/p&gt;
&lt;p&gt;其实很简单&lt;br/&gt;1、继续观察自己 -小本记录&lt;br/&gt;2、系统的学习某些东西 - 思维导图&lt;br/&gt;3、健身 - 健身视频来一套，不行淘宝&lt;br/&gt;4、english - 英语晚上听力，不行的话，也学习同学打卡签到&lt;br/&gt;5、python - 看左神，还没看完；老男孩视频还没看完；爬虫还没看；go语言还没看；高级课程还没看&lt;br/&gt;6、会议论文 - 师姐的毕业设计吧&lt;br/&gt;7、程序 - 慢慢调试吧&lt;br/&gt;8、大论文 - 赶紧动笔，先拼凑第一稿吧。&lt;/p&gt;
&lt;h3 id=&quot;陆奇仰望的存在&quot;&gt;陆奇：仰望的存在&lt;/h3&gt;
&lt;p&gt;最后我觉得放些陆奇的东西吧&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;离开中国之后，有两件事情指引着陆奇的学习和工作。&lt;br/&gt;“一是知道更多，了解到更多的科学和技术”&lt;br/&gt;“第二，要做更多研究，以便人们能在更短的时间内把工作做完”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想我应该用什么指导下，指引下我的学术和工作&lt;br/&gt;那就用他的吧！&lt;br/&gt;至少看起来是对的&lt;br/&gt;“一是知道更多，了解到更多的科学和技术”&lt;br/&gt;“第二，要做更多研究，以便人们能在更短的时间内把工作做完”&lt;/p&gt;
&lt;p&gt;其实我想要的是&lt;br/&gt;系统的学习某些东西&lt;br/&gt;或者学习思维导图&lt;br/&gt;或者学习如何阅读一本书&lt;br/&gt;或者说学习如何去学习&lt;br/&gt;我已经忘了自己怎样学习了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;陆奇的成功并不奇怪。&lt;br/&gt;他的座右铭是要做更多(do more)、知道更多(know more)、成就更多(be more)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;活了二十多年，自己的座右铭好像没有吧&lt;br/&gt;要不要也整个呢&lt;br/&gt;Less is more&lt;br/&gt;另一个是：alex上面说过的&lt;br/&gt;行动力之类的&lt;br/&gt;just do it&lt;br/&gt;他的意思，我们都会说，都能说&lt;br/&gt;但真正能做到的人有谁呢&lt;br/&gt;我忘了他想说的那句原话是什么了&lt;br/&gt;不过大概意思就是这样吧&lt;br/&gt;以后补上吧&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;初入职场时，一位曾参加过美国海军的主管告诫他：&lt;br/&gt;&quot;第一，我不管你努力的过程，我只看结果。&quot;&lt;br/&gt;&quot;第二，你要清楚什么是规矩(rules),什么是指导原则(guidance)&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想这个话，我还不能够理解很深刻&lt;br/&gt;但是冥冥之中，我觉得&lt;br/&gt;不能够理解的肯定就是厉害的&lt;/p&gt;
&lt;p&gt;最后，放点链接，图片什么的，让大家了解下他吧。&lt;br/&gt;照片先来个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p0.ifengimg.com/pmop/2018/0520/E779F2353ACDA84AF7C261C63DF98050D61FDA9D_size35_w900_h600.jpeg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://mat1.gtimg.com/finance/images/stock/p/news/f529cb203bb0ff9f.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个笑容好像我一个同学，白同学。&lt;/p&gt;
&lt;p&gt;百度的介绍这么不详细&lt;br/&gt;太不厚道了&lt;br/&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E9%99%86%E5%A5%87/6482?fr=aladdin&quot;&gt;陆奇百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/54842975&quot;&gt;知乎概述，陆奇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://tv.cctv.com/2017/12/30/VIDE7dlUKTShj1R5cpysaIqa171230.shtml&quot;&gt;中国引力波&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://m.sohu.com/a/247532719_116132?_f=m-channel_30_feeds_10&amp;amp;scm=1001.10001.8a.0&quot;&gt;中年陆奇遇见少年YC | 钛媒体深度&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.shichangbu.com/article-31942-1.html&quot;&gt;让百度损失900亿，真实的陆奇是怎样的？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://tech.sina.cn/it/2017-01-17/detail-ifxzqnip1550130.d.html&quot;&gt;揭秘神秘人陆奇：微软华人高管的窘境与破局&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.time-weekly.com/html/20180109/249019_1.html&quot;&gt;“打工者”陆奇在百度的365天：低调背后的聚焦与取舍&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/277693483?rf=277701842&quot;&gt;如何看待陆奇卸任百度COO和集团总裁？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 16:52:00 +0000</pubDate>
<dc:creator>venicid</dc:creator>
<og:description>再一次审视自己 如果说自己身上最大的缺点的话， 是不自信以至于自卑呢 还是伪勤奋未曾坚持到底呢 那还是说下自己的优点吧 吾三日而自省其身 只能想到自己一个这样的 但是自省后，却未能有效的解决问题 杨奇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/venicid/p/10140991.html</dc:identifier>
</item>
<item>
<title>redis 基本数据类型-字符串(String) - 老瘦家的儿子</title>
<link>http://www.cnblogs.com/art-geek/p/10140956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/art-geek/p/10140956.html</guid>
<description>&lt;p&gt;不瘦原来对redis也是有个大概的了解(就你知道的多), 但是最近和大神聊天的过程中才明白自己知道的简直就是鸡毛蒜皮(让你得瑟),所以不瘦打算从头在捋一遍,顺便把过程也记录下来,如果能给大家在学习redis的道路上提供一条清晰的线索,不瘦胖也瞑目了.&lt;/p&gt;

&lt;p&gt;我们知道redis没有直接使用C语言中的字符串,而是定义了简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。其中SDS数据结构如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct sdshdr {
    int len;     // len表示buf中存储的字符串的长度
    int free;    // free表示buf中空闲空间的长度
    char buf[];  // buf用于存储字符串内容。
&lt;/pre&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到,就是将一个字符数组和两个整型变量封装在结构体中,但是这一封装加上一些看似简单的方法(大道至简)就为SDS增加了很多特性:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;二进制安全&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      和C语言字符串只能某种编码(如ASCII),并且出结尾不能有'\0'字符相比,SDS也可以存储像图片,音频,视频这样的二进制数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串长度计算,时间复杂度为O(1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      因为在SDS结构体中存储了len,计算长度时直接返回即可(以空间换时间),而C语言要计算字符串长度时间复杂度为O(n)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;杜绝缓冲区溢出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      我们知道在C语言拼接字符串时,如果超出原字符串申请的内存大小就会导致缓冲区溢出,而SDS的空间分配策略直接避免了溢出的可能性:当对SDS修改时,会先检查剩余空间是否         满足(free变量的作用),如果不满足,则进行自动扩容.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少修改带来内存分配次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      redis作为数据库经常被用于速度要求严苛、数据被频繁修改的场合,  如果每次修改长度都需要执行一次内存重分配的话, 那么光是执行内存重分配的时间就会占去修改所用时间的       一大部分, 如果这种修改频繁地发生的话, 可能还会对性能造成影响。&lt;/p&gt;
&lt;p&gt;      为了应对这种应用场景,redis采取了两种策略: 增加长度时&lt;strong&gt;空间预分配&lt;/strong&gt;(每次多申请点),减少长度时&lt;strong&gt;空间惰性释放&lt;/strong&gt;(只改free的大小,不实际释放空间)&lt;/p&gt;

&lt;p&gt;注意事项:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SDS作为key时长度不能超过512MB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;《Redis设计与实现》 &lt;/p&gt;

&lt;p&gt;这里是老瘦家的儿子，如需转载请声明，我替老瘦感谢你。&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 16:19:00 +0000</pubDate>
<dc:creator>老瘦家的儿子</dc:creator>
<og:description>不瘦原来对redis也是有个大概的了解(就你知道的多), 但是最近和大神聊天的过程中才明白自己知道的简直就是鸡毛蒜皮(让你得瑟),所以不瘦打算从头在捋一遍,顺便把过程也记录下来,如果能给大家在学习re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/art-geek/p/10140956.html</dc:identifier>
</item>
<item>
<title>反射那些基础-Class - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/10140928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/10140928.html</guid>
<description>&lt;h2 id=&quot;class-类是什么&quot;&gt;1 Class 类是什么？&lt;/h2&gt;
&lt;p&gt;在 Java 中， 一切皆对象。&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Foo{
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类本身就是 &lt;code&gt;java.liang.Class&lt;/code&gt; 的一个对象。 每一个 .class 文件在类加载器加载了之后， 都会在 JVM 中创建一个 &lt;code&gt;Class&lt;/code&gt; 对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;所有的类都是在第一次使用时， 动态加载到 JVM 中。 当程序创建第一个对类的静态成员函数（构造函数也是静态方法）的引用时， 就会加载这个类。 一旦某个类的 &lt;code&gt;Class&lt;/code&gt; 对象被载入内存中， 它就会从来创建这个类的所有对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有反射的入口都是 &lt;code&gt;java.liang.Class&lt;/code&gt;。 因为 Java 中规定了 &lt;code&gt;java.lang.reflect&lt;/code&gt; 包下的所有类的构造函数都不为 public， 因此， 需要获得这些类的对象都需要调用 &lt;code&gt;Class&lt;/code&gt; 类中适当的的方法。&lt;/p&gt;
&lt;h2 id=&quot;如何获取-class-对象&quot;&gt;2 如何获取 Class 对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt; 对象由 JVM 自动创建， 我们可以通过以下几种方法获取相应类或接口的该对象实例。&lt;/p&gt;
&lt;h3 id=&quot;object.getclass&quot;&gt;2.1 Object.getClass()&lt;/h3&gt;
&lt;p&gt;我们都知道所有的类都是继承于 &lt;code&gt;Object&lt;/code&gt;, 因此， &lt;code&gt;Object&lt;/code&gt; 中的方法， 任何类都可以使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public final native Class&amp;lt;?&amp;gt; getClass();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法时 final 所修饰的， 不能重写。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testClass() {
        Class clazz = &quot;foo&quot;.getClass();
        System.out.println(clazz.toString());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该例子中， &quot;foo&quot; 是 String 类型的实例， 因此， 其调用 getClass() 所返回的类型就是 String。&lt;/p&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class java.lang.String&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;class-语法&quot;&gt;2.2 .class 语法&lt;/h3&gt;
&lt;p&gt;如果我们想要获取某个类的 &lt;code&gt;Class&lt;/code&gt;, 我们又没有相应的实例， 那么通过 .class 也可以获取该类的 &lt;code&gt;Class&lt;/code&gt; 对象。 基本数据类型通过该方法是最容易获取到其 &lt;code&gt;Class&lt;/code&gt; 对象 的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testDotClass() {
        boolean b = false;
        // Class clazz = b.getClass(); // 编译错误
        Class clazz = boolean.class;
        System.out.println(clazz);

        Boolean bw = false;
        System.out.println(bw.getClass());

        System.out.println(HashMap.class);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean
class java.lang.Boolean
class java.util.HashMap
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;class.forname&quot;&gt;2.3 Class.forName()&lt;/h3&gt;
&lt;p&gt;如果我们知道某个类的全限定名， 我们可以通过该方法获得对应的 &lt;code&gt;Class&lt;/code&gt; 对象。 该方法不能对基本类型使用。&lt;/p&gt;
&lt;p&gt;使用起来很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testFullNameClass() {
        try {
            Class clazz = Class.forName(&quot;java.lang.System&quot;);
            System.out.println(clazz);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class java.lang.System&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法可能会找不到对应的类， 需要处理受检异常 &lt;code&gt;ClassNotFoundException&lt;/code&gt;。 框架用的大多都是该方法， 因为前面两种需要知道类的实例或类的类名， 而第三中需要的是类的全限定名， 是一串字符串， 我们可以通过配置或扫描等方式告知框架。&lt;/p&gt;
&lt;h3 id=&quot;通过包装类的-type-成员&quot;&gt;2.4 通过包装类的 TYPE 成员&lt;/h3&gt;
&lt;p&gt;对于基本数据类型， 除了以上的 .class 方法之外， 我们还可以使用其对对应包装类的 TYPE 成员变量来获取 &lt;code&gt;Class&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(Double.TYPE); // 输出 double&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;class-的主要方法及其示例&quot;&gt;3 Class 的主要方法及其示例&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt; 里面存储了对应类的所有信息， 因此， 我们可以获得类相关的信息。&lt;/p&gt;
&lt;p&gt;一个类的组成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性：对象数据的描述&lt;/li&gt;
&lt;li&gt;构造方法：用于实例化对象&lt;/li&gt;
&lt;li&gt;普通方法：对象的行为&lt;/li&gt;
&lt;li&gt;注解&lt;/li&gt;
&lt;li&gt;内部类：在类中声明的类（inner class）&lt;/li&gt;
&lt;li&gt;块：分静态块与实例块&lt;/li&gt;
&lt;li&gt;类的声明：（访问权限修饰符public.default（可忽略不写，为默认））（修饰符final.abstract.synchronized）class 类名{ 类体 }&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;属性相关&quot;&gt;3.1 属性相关&lt;/h3&gt;
&lt;p&gt;获取全部 &lt;strong&gt;public&lt;/strong&gt; 属性, 包括其父类， 接口的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Field[] getFields();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取指定的名称的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Field getField(String name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取所有本类（不包含父类， 接口）声明的属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public Field[] getDeclaredFields()；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取本类（不包含父类， 接口）指定的名称的声明属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Field getDeclaredField(String name)；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造函数相关&quot;&gt;3.2 构造函数相关&lt;/h3&gt;
&lt;p&gt;获取所有的 public 构造器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Constructor&amp;lt;?&amp;gt;[] getConstructors()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取指定参数的 public 构造器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Constructor&amp;lt;?&amp;gt; getConstructor(Class&amp;lt;?&amp;gt;... parameterTypes) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取声明（public, private, protected, friendly）的所有构造器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Constructor&amp;lt;?&amp;gt;[] getDeclaredConstructors() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取声明（public, private, protected, friendly）的指定参数构造器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Constructor&amp;lt;?&amp;gt; getDeclaredConstructor(Class&amp;lt;?&amp;gt;... parameterTypes)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;普通方法相关&quot;&gt;3.3 普通方法相关&lt;/h3&gt;
&lt;p&gt;获取所有的 public 方法，包括其父类， 接口的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Method[] getMethods();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取指定参数的 public 方法， 包括其父类， 接口的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取声明（public, private, protected, friendly）的所有普通方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Method[] getDeclaredMethods();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取声明（public, private, protected, friendly）的指定参数的普通方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Method getDeclaredMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注解相关&quot;&gt;3.4 注解相关&lt;/h3&gt;
&lt;p&gt;判断是否为注解， 如果是注解， 就一定是接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public boolean isAnnotation()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断类上面有没有指定类型的注解（包括继承的）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public boolean isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt; annotationClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上面的所有注解（包括继承的）, 没有注解返回长度 0 的数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Annotation[] getAnnotations();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上存在的、指定类型的注解（包括继承的），如果该类型注解不存在，则返回null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;A extends Annotation&amp;gt; A getAnnotation(Class&amp;lt;A&amp;gt; annotationClass);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上面的指定类型的注解（包括继承的）， 没有注解返回长度为 0 的数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;A extends Annotation&amp;gt; A[] getAnnotationsByType(Class&amp;lt;A&amp;gt; annotationClass);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上面指定类型的注解（不包括继承的注解）， 没有则返回 null&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;A extends Annotation&amp;gt; A getDeclaredAnnotation(Class&amp;lt;A&amp;gt; annotationClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上面所有的注解（不包括继承的注解）， 没有则返回长度为0的数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Annotation[] getDeclaredAnnotations()    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取类上面指定类型的注解（不包括继承的注解）， 没有注解返回长度为 0 的数组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public &amp;lt;A extends Annotation&amp;gt; A[] getDeclaredAnnotationsByType(Class&amp;lt;A&amp;gt; annotationClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他常用的方法&quot;&gt;3.5 其他常用的方法&lt;/h3&gt;
&lt;p&gt;返回 Class 对象表示的类型(类、接口、数组或基本类型)的完整路径名字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String getName() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过该方法创建对象， 需要有默认构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public T newInstance()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取该类的类加载器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ClassLoader getClassLoader()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回该Class对象对应类所实现的全部接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Class&amp;lt;?&amp;gt;[] getInterfaces()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回此Class对象对应类的超类的Class对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Class&amp;lt;? super T&amp;gt; getSuperclass()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断此class对象是否表示一个数组类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean isArray() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判定指定的 Class 对象是否表示一个接口类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean isInterface()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判定指定的 Class 对象是否表示一个 Java 的基本类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean isPrimitive()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断此class对象是否表示一个枚举&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;oolean isEnum()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断obj是否是此class对象的实例，该方法可以完全代替instanceof操作符&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isInstance(Object obj)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断是否为匿名类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean isAnonymousClass()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取所有的内部类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Class&amp;lt;?&amp;gt;[] getDeclaredClasses()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取其所在的外部类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Class&amp;lt;?&amp;gt; getDeclaringClass()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Dec 2018 16:03:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>1 Class 类是什么？ 在 Java 中， 一切皆对象。 比如 这个类本身就是 java.liang.Class 的一个对象。 每一个 .class 文件在类加载器加载了之后， 都会在 JVM 中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/10140928.html</dc:identifier>
</item>
<item>
<title>tomcat编译超过64k大小的jsp文件报错原因 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10140889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10140889.html</guid>
<description>&lt;p&gt;今天遇到一个问题，首先是在tomcat中间件上跑的web项目，一个jsp文件，因为代码行数实在是太多了，更新了几个版本之后编译报错了，页面打开都是报500的错误，500的报错，知道http协议返回码的都知道，这是服务端的报错。&lt;/p&gt;
&lt;p&gt;jsp编译过程是先编译为servlet，然后再通过类加载器编译为.class文件，再执行为Servlet实例。这就是jsp的编译过程。所以jsp报500错误也可以理解，属于服务端的报错没什么好怀疑的。&lt;/p&gt;
&lt;p&gt;服务端报错，肯定就是去console拿日志了。从CONSOLE拿到日志关键信息：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The code of method _jspService(HttpServletRequest, HttpServletResponse) is exceeding the 65535 bytes limit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个报错意思大概是超过字节限制。通过网上资料搜索，很多地方都是给出了一个解决方法，不过大部分都没说明为什么。&lt;br/&gt;网上一大堆差不多的博客，都是这样说的，在tomcat的conf文件夹里，找到web.xml，然后在JspServlet的servlet配置里，加上mappedfile参数&lt;br/&gt;修改后的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;jsp&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.apache.jasper.servlet.JspServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;fork&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;xpoweredBy&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;  
            &amp;lt;param-name&amp;gt;mappedfile&amp;lt;/param-name&amp;gt;  
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;  
        &amp;lt;/init-param&amp;gt; 
        &amp;lt;load-on-startup&amp;gt;3&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就是加上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;init-param&amp;gt;  
           &amp;lt;param-name&amp;gt;mappedfile&amp;lt;/param-name&amp;gt;  
           &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;  
 &amp;lt;/init-param&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大部分博客并没有给出原因。不过还是可以解决问题的。不过网上所说的这种方法并不是很好的方法，只能说是暂缓之策。&lt;/p&gt;
&lt;p&gt;首先要从jsp的编译说起，jsp经过tomcat编译后，文件会保存在哪里？&lt;br/&gt;下面介绍一下，一般路径都会在${TOMCAT_HOME}\work\Catalina\localhost\项目名称\org\apache\jsp文件夹下面。&lt;br/&gt;假如新建了一个index.jsp，经过编译之后，都会在该路径下面生成index_jsp.java文件和index_jsp.class文件，index_jsp.java文件是什么？其实可以理解为tomcat编译生成的servlet类，index_jsp.class呢？当然就是servlet类编译之后生成的.class文件了。&lt;br/&gt;随便找个index_jsp.java文件，拿代码来看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/7.0.32
 * Generated at: 2016-11-19 03:26:12 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.*;

public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map&amp;lt;java.lang.String,java.lang.Long&amp;gt; _jspx_dependants;

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map&amp;lt;java.lang.String,java.lang.Long&amp;gt; getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType(&quot;text/html;charset=UTF-8&quot;);
      pageContext = _jspxFactory.getPageContext(this, request, response,
                null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\r');
      out.write('\n');
      if (true) {
        _jspx_page_context.forward(&quot;/login_toLogin&quot;);
        return;
      }
      out.write('\r');
      out.write('\n');
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null &amp;amp;&amp;amp; out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码可以看出，类继承于HttpJspBase类实现JspSourceDependent接口，先看一下HttpJspBase类，这个类从哪来的呢？HttpJspBase是tomcat库提供的，所以拿tomcat库的源码来看看，在${TOMCAT_HOME}/lib里找到价包jasper.jar,反编译代码，找到HttpJspBase类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package org.apache.jasper.runtime;

import java.io.IOException;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.HttpJspPage;
import org.apache.jasper.compiler.Localizer;

public abstract class HttpJspBase extends HttpServlet
  implements HttpJspPage
{
  private static final long serialVersionUID = 1L;

  public final void init(ServletConfig config)
    throws ServletException
  {
    super.init(config);
    jspInit();
    _jspInit();
  }

  public String getServletInfo()
  {
    return Localizer.getMessage(&quot;jsp.engine.info&quot;);
  }

  public final void destroy()
  {
    jspDestroy();
    _jspDestroy();
  }

  public final void service(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException
  {
    _jspService(request, response);
  }

  public void jspInit()
  {
  }

  public void _jspInit()
  {
  }

  public void jspDestroy()
  {
  }

  protected void _jspDestroy()
  {
  }

  public abstract void _jspService(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse)
    throws ServletException, IOException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码并不是说多复杂，HttpJspBase类继承HttpServlet类，实现HttpJspPage接口，也就是说HttpJspBase重写了HttpServlet的service(),init()等等方法，HttpServlet，我们就很熟悉了。HttpJspPage又是什么?看它的包名，马上知道它是jdk提供的接口，马上找到它的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the &quot;License&quot;).  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * glassfish/bootstrap/legal/CDDLv1.0.txt or
 * https://glassfish.dev.java.net/public/CDDLv1.0.html.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * glassfish/bootstrap/legal/CDDLv1.0.txt.  If applicable,
 * add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your
 * own identifying information: Portions Copyright [yyyy]
 * [name of copyright owner]
 *
 * Copyright 2005 Sun Microsystems, Inc. All rights reserved.
 *
 * Portions Copyright Apache Software Foundation.
 */
 
package javax.servlet.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

/**
 * The HttpJspPage interface describes the interaction that a JSP Page
 * Implementation Class must satisfy when using the HTTP protocol.
 *
 * &amp;lt;p&amp;gt;
 * The behaviour is identical to that of the JspPage, except for the signature
 * of the _jspService method, which is now expressible in the Java type
 * system and included explicitly in the interface.
 * 
 * @see JspPage
 */

public interface HttpJspPage extends JspPage {

    /** The _jspService()method corresponds to the body of the JSP page. This
     * method is defined automatically by the JSP container and should never
     * be defined by the JSP page author.
     * &amp;lt;p&amp;gt;
     * If a superclass is specified using the extends attribute, that
     * superclass may choose to perform some actions in its service() method
     * before or after calling the _jspService() method.  See using the extends
     * attribute in the JSP_Engine chapter of the JSP specification.
     *
     * @param request Provides client request information to the JSP.
     * @param response Assists the JSP in sending a response to the client.
     * @throws ServletException Thrown if an error occurred during the 
     *     processing of the JSP and that the container should take 
     *     appropriate action to clean up the request.
     * @throws IOException Thrown if an error occurred while writing the
     *     response for this page.
     */
    public void _jspService(HttpServletRequest request,
                            HttpServletResponse response)
       throws ServletException, IOException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;**很关键的方法名：_jspService，不就是刚才CONSOLE报错提示的方法名？&lt;br/&gt;也就是说jdk提供接口，然后tomcat对接口进行实现，我们知道Java内存模型(JMM)规定了一个方法的大小只能是64k，所以，从刚才的报错，我们简单从源码分析了一下，报错的原因其实就是jsp反编译为Servlet之后，代码要经过_jspService这个方法，这个方法超过了64k，导致报错。**&lt;/p&gt;
&lt;p&gt;查看一下tomcat7官方给出的文档：http://tomcat.apache.org/tomcat-7.0-doc/jasper-howto.html#Configuration&lt;br/&gt;找到mappedfile属性的意思&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;mappedfile - 我们是否应该为每个输入行生成一个print语句的静态内容，以便于调试？ true或者false，默认true。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在分析一下具体原因。代码报错的原因就是因为jsp编译为Servlet之后，经过_jspService这个方法，方法超过64k导致报错。然后通过设置mappedfile参数的原因是尽量减少print代码，暂时使代码不超过，也就是说只是一种暂缓的方法。网上资料说通过&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 15:46:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>今天遇到一个问题，首先是在tomcat中间件上跑的web项目，一个jsp文件，因为代码行数实在是太多了，更新了几个版本之后编译报错了，页面打开都是报500的错误，500的报错，知道http协议返回码的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10140889.html</dc:identifier>
</item>
<item>
<title>.net core 的图片处理及二维码的生成及解析 - 如兹</title>
<link>http://www.cnblogs.com/ruzi/p/10140754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruzi/p/10140754.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageHelper
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxLength = &lt;span&gt;10485760&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10*1024*1024&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SkiaSharp.SKEncodedImageFormat GetImageFormatBySuffix(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; suffix)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Jpeg;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(suffix))
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (suffix[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 suffix = suffix.Substring(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(suffix))
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             suffix =&lt;span&gt; suffix.ToUpper();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (suffix)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Png;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Gif;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Bmp;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ico;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ico;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Dng;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WBMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Wbmp;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WEBP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Webp;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PKM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Pkm;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KTX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ktx;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASTC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Astc;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SkiaSharp.SKEncodedImageFormat GetImageFormatByPath(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; suffix = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (System.IO.Path.HasExtension(path))
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 suffix =&lt;span&gt; System.IO.Path.GetExtension(path);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetImageFormatBySuffix(suffix);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;long&lt;/span&gt;, SkiaSharp.SKEncodedImageFormat&amp;gt; GetImageInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(path))
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;路径不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileLength =&lt;span&gt; fileStream.Length;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileLength &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件过大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件无效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;long&lt;/span&gt;, SkiaSharp.SKEncodedImageFormat&amp;gt;&lt;span&gt;(w, h, fileLength, GetImageFormatByPath(path));
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageMaxCutByCenter(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; saveWidth, &lt;span&gt;int&lt;/span&gt; saveHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageMaxCutByCenter(path, saveWidth, saveHeight, quality);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageMaxCutByCenter(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; saveWidth, &lt;span&gt;int&lt;/span&gt; saveHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (saveWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { saveWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (saveHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { saveHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cutW =&lt;span&gt; saveWidth;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cutH =&lt;span&gt; saveHeight;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; ratio = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (cutW &amp;gt;&lt;span&gt; oW)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 ratio = (&lt;span&gt;double&lt;/span&gt;)oW / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutW;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 cutH = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                 cutW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cutW &amp;lt;&lt;span&gt; oW)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                 ratio = (&lt;span&gt;double&lt;/span&gt;)oW / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutW;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                 cutH = Convert.ToInt32(Convert.ToDouble(cutH) *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                 cutW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; startX = oW &amp;gt; cutW ? (oW / &lt;span&gt;2&lt;/span&gt; - cutW / &lt;span&gt;2&lt;/span&gt;) : (cutW / &lt;span&gt;2&lt;/span&gt; - oW / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; startY = oH &amp;gt; cutH ? (oH / &lt;span&gt;2&lt;/span&gt; - cutH / &lt;span&gt;2&lt;/span&gt;) : (cutH / &lt;span&gt;2&lt;/span&gt; - oH / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(saveWidth, saveHeight);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;                 FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;            sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                sKBitmap,
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = startX, Y =&lt;span&gt; startY },
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = cutH, Width =&lt;span&gt; cutW }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = saveHeight, Width =&lt;span&gt; saveWidth }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;                }, sKPaint);
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage2 =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap2);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;            sKBitmap2.Dispose();
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage2.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            sKImage2.Dispose();
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageScalingToRange(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageScalingToRange(path, maxWidth, maxHeight, quality);
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageScalingToRange(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt;234&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; 
&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; 
&lt;span&gt;258&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; maxWidth &amp;amp;&amp;amp; nH &amp;lt; maxHeight)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放大&lt;/span&gt;
&lt;span&gt;259&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt;&lt;span&gt; maxWidth)
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxWidth / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nW;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;                     nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;                     nH = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nH *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nH &amp;lt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxHeight / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nH;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;                     nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;                     nW = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nW *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;限制超出(缩小)&lt;/span&gt;
&lt;span&gt;274&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nW &amp;gt;&lt;span&gt; maxWidth)
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxWidth / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nW;
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;                 nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;                 nH = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nH *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nH &amp;gt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxHeight / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nH;
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;                 nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                 nW = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nW *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; 
&lt;span&gt;287&lt;/span&gt; 
&lt;span&gt;288&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(nW, nH);
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;                 FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;                 IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;294&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;            sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; &lt;span&gt;                sKBitmap,
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = oH, Width =&lt;span&gt; oW }
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = nH, Width =&lt;span&gt; nW }
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;                }, sKPaint);
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage2 =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap2);
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;            sKBitmap2.Dispose();
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage2.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;            sKImage2.Dispose();
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; 
&lt;span&gt;315&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageScalingByOversized(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageScalingByOversized(path, maxWidth, maxHeight, quality);
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageScalingByOversized(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; 
&lt;span&gt;350&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; 
&lt;span&gt;355&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;358&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt; 
&lt;span&gt;360&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;363&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; 
&lt;span&gt;365&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oW &amp;gt; maxWidth || oH &amp;gt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt;                 nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;                 nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; ratio = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt; 
&lt;span&gt;371&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nH &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nW /&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;                     nH = Convert.ToInt32(oH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt;&lt;span&gt; nH)
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;377&lt;/span&gt;                         ratio = (&lt;span&gt;double&lt;/span&gt;)maxHeight /&lt;span&gt; nH;
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt;                         nW = Convert.ToInt32(nW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;379&lt;/span&gt;                         nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;381&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; nH &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt;                     nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt;                     nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;386&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;387&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nH /&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt;                     nW = Convert.ToInt32(oW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nH &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;393&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nW /&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt;                     nH = Convert.ToInt32(oH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;397&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(nW, nH);
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt;                     FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;                     IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;403&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;404&lt;/span&gt; &lt;span&gt;                sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;405&lt;/span&gt; &lt;span&gt;                    sKBitmap,
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = oH, Width =&lt;span&gt; oW }
&lt;/span&gt;&lt;span&gt;410&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = nH, Width =&lt;span&gt; nW }
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt; &lt;span&gt;                    }, sKPaint);
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; &lt;span&gt;                sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt;                 sKBitmap =&lt;span&gt; sKBitmap2;
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt; 
&lt;span&gt;421&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap);
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;424&lt;/span&gt; &lt;span&gt;            sKImage.Dispose();
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;427&lt;/span&gt; 
&lt;span&gt;428&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt; 
&lt;span&gt;431&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;432&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成二维码(320*320)
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;434&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;435&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;savePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;保存路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;436&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logoPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Logo图片路径(缩放到真实二维码区域尺寸的1/6)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;437&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;keepWhiteBorderPixelVal&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;白边处理(负值表示不做处理，最大值不超过真实二维码区域的1/10)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;438&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QRCoder(&lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;string&lt;/span&gt; logoPath = &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; keepWhiteBorderPixelVal = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;439&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;440&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; format =&lt;span&gt; GetImageFormatByPath(savePath);
&lt;/span&gt;&lt;span&gt;441&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytesLogo = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(logoPath) &amp;amp;&amp;amp;&lt;span&gt; System.IO.File.Exists(logoPath))
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; fsLogo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(logoPath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;                 System.IO.MemoryStream ms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.MemoryStream();
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt; &lt;span&gt;                fsLogo.CopyTo(ms);
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt; &lt;span&gt;                fsLogo.Dispose();
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt;                 bytesLogo =&lt;span&gt; ms.ToArray();
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt; &lt;span&gt;                ms.Dispose();
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt; 
&lt;span&gt;452&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; QRCoder(text, format, bytesLogo, keepWhiteBorderPixelVal);
&lt;/span&gt;&lt;span&gt;453&lt;/span&gt; 
&lt;span&gt;454&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;458&lt;/span&gt; 
&lt;span&gt;459&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;464&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;469&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成二维码(320*320)
&lt;/span&gt;&lt;span&gt;470&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;471&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;472&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;format&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;保存格式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;473&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logoImgae&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Logo图片(缩放到真实二维码区域尺寸的1/6)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;474&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;keepWhiteBorderPixelVal&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;白边处理(负值表示不做处理，最大值不超过真实二维码区域的1/10)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;475&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;476&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] QRCoder(&lt;span&gt;string&lt;/span&gt; text, SkiaSharp.SKEncodedImageFormat format, &lt;span&gt;byte&lt;/span&gt;[] logoImgae = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; keepWhiteBorderPixelVal = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;477&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;478&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] reval = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;479&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; width = &lt;span&gt;320&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; height = &lt;span&gt;320&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;481&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; qRCodeWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.QrCode.QRCodeWriter();
&lt;/span&gt;&lt;span&gt;482&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hints = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;ZXing.EncodeHintType, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;483&lt;/span&gt;             hints.Add(ZXing.EncodeHintType.CHARACTER_SET, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;484&lt;/span&gt;             hints.Add(ZXing.EncodeHintType.QR_VERSION, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;485&lt;/span&gt; &lt;span&gt;            hints.Add(ZXing.EncodeHintType.ERROR_CORRECTION, ZXing.QrCode.Internal.ErrorCorrectionLevel.Q);
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bitMatrix =&lt;span&gt; qRCodeWriter.encode(text, ZXing.BarcodeFormat.QR_CODE, width, height, hints);
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; bitMatrix.Width;
&lt;/span&gt;&lt;span&gt;488&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; bitMatrix.Height;
&lt;/span&gt;&lt;span&gt;489&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(w, h);
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt; 
&lt;span&gt;491&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackStartPointX = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackStartPointY = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackEndPointX =&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackEndPointY =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt; 
&lt;span&gt;496&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; --绘制二维码(同时获取真实的二维码区域起绘点和结束点的坐标)--
&lt;span&gt;497&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap);
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKColorBlack = SkiaSharp.SKColor.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;499&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKColorWihte = SkiaSharp.SKColor.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ffffff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;            sKCanvas.Clear(sKColorWihte);
&lt;/span&gt;&lt;span&gt;501&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; blackStartPointIsNotWriteDown = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;502&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; h; y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;503&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; w; x++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;505&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; flag =&lt;span&gt; bitMatrix[x, y];
&lt;/span&gt;&lt;span&gt;507&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
&lt;/span&gt;&lt;span&gt;508&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (blackStartPointIsNotWriteDown)
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt;                             blackStartPointX =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;                             blackStartPointY =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt;                             blackStartPointIsNotWriteDown = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt;                         blackEndPointX =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt;                         blackEndPointY =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt; &lt;span&gt;                        sKCanvas.DrawPoint(x, y, sKColorBlack);
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;520&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sKCanvas.DrawPoint(x, y, sKColorWihte);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不用绘制(背景是白色的)&lt;/span&gt;
&lt;span&gt;522&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;527&lt;/span&gt; 
&lt;span&gt;528&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; qrcodeRealWidth = blackEndPointX -&lt;span&gt; blackStartPointX;
&lt;/span&gt;&lt;span&gt;529&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; qrcodeRealHeight = blackEndPointY -&lt;span&gt; blackStartPointY;
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt; 
&lt;span&gt;531&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; -- 处理白边 --
&lt;span&gt;532&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (keepWhiteBorderPixelVal &amp;gt; -&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定了边框宽度&lt;/span&gt;
&lt;span&gt;533&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;534&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; borderMaxWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;535&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (keepWhiteBorderPixelVal &amp;gt;&lt;span&gt; borderMaxWidth)
&lt;/span&gt;&lt;span&gt;536&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;537&lt;/span&gt;                     keepWhiteBorderPixelVal =&lt;span&gt; borderMaxWidth;
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; nQrcodeRealWidth = width - keepWhiteBorderPixelVal -&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; nQrcodeRealHeight = height - keepWhiteBorderPixelVal -&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt; 
&lt;span&gt;542&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(width, height);
&lt;/span&gt;&lt;span&gt;543&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKCanvas2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;544&lt;/span&gt; &lt;span&gt;                sKCanvas2.Clear(sKColorWihte);
&lt;/span&gt;&lt;span&gt;545&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维码绘制到临时画布上时无需抗锯齿等处理(避免文件增大)&lt;/span&gt;
&lt;span&gt;546&lt;/span&gt; &lt;span&gt;                sKCanvas2.DrawBitmap(
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt; &lt;span&gt;                    sKBitmap,
&lt;/span&gt;&lt;span&gt;548&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = blackStartPointX, Y =&lt;span&gt; blackStartPointY },
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = qrcodeRealHeight, Width =&lt;span&gt; qrcodeRealWidth }
&lt;/span&gt;&lt;span&gt;552&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;554&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = keepWhiteBorderPixelVal, Y =&lt;span&gt; keepWhiteBorderPixelVal },
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Width = nQrcodeRealWidth, Height =&lt;span&gt; nQrcodeRealHeight }
&lt;/span&gt;&lt;span&gt;557&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;558&lt;/span&gt; 
&lt;span&gt;559&lt;/span&gt;                 blackStartPointX =&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;560&lt;/span&gt;                 blackStartPointY =&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt;                 qrcodeRealWidth =&lt;span&gt; nQrcodeRealWidth;
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt;                 qrcodeRealHeight =&lt;span&gt; nQrcodeRealHeight;
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; 
&lt;span&gt;564&lt;/span&gt; &lt;span&gt;                sKCanvas2.Dispose();
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;566&lt;/span&gt;                 sKBitmap =&lt;span&gt; sKBitmap2;
&lt;/span&gt;&lt;span&gt;567&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;569&lt;/span&gt; 
&lt;span&gt;570&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; -- 绘制LOGO --
&lt;span&gt;571&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (logoImgae != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; logoImgae.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;572&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt;                 SkiaSharp.SKBitmap sKBitmapLogo =&lt;span&gt; SkiaSharp.SKBitmap.Decode(logoImgae);
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;sKBitmapLogo.IsEmpty)
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKPaint2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt;                         FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.None,
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt;                         IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;580&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoTargetMaxWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoTargetMaxHeight = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealHeight / &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;583&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; qrcodeCenterX = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;584&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; qrcodeCenterY = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealHeight / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;585&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoResultWidth =&lt;span&gt; sKBitmapLogo.Width;
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoResultHeight =&lt;span&gt; sKBitmapLogo.Height;
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (logoResultWidth &amp;gt;&lt;span&gt; logoTargetMaxWidth)
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)logoTargetMaxWidth /&lt;span&gt; logoResultWidth;
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;                         logoResultWidth =&lt;span&gt; logoTargetMaxWidth;
&lt;/span&gt;&lt;span&gt;591&lt;/span&gt;                         logoResultHeight = (&lt;span&gt;int&lt;/span&gt;)Math.Floor(logoResultHeight *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;592&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (logoResultHeight &amp;gt;&lt;span&gt; logoTargetMaxHeight)
&lt;/span&gt;&lt;span&gt;594&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)logoTargetMaxHeight /&lt;span&gt; logoResultHeight;
&lt;/span&gt;&lt;span&gt;596&lt;/span&gt;                         logoResultHeight =&lt;span&gt; logoTargetMaxHeight;
&lt;/span&gt;&lt;span&gt;597&lt;/span&gt;                         logoResultWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor(logoResultWidth *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; pointX = qrcodeCenterX - (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)logoResultWidth / &lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; blackStartPointX;
&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; pointY = qrcodeCenterY - (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)logoResultHeight / &lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; blackStartPointY;
&lt;/span&gt;&lt;span&gt;601&lt;/span&gt; 
&lt;span&gt;602&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKCanvas3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap);
&lt;/span&gt;&lt;span&gt;603&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt;                         FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt;                         IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;607&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;608&lt;/span&gt; &lt;span&gt;                    sKCanvas3.DrawBitmap(
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt; &lt;span&gt;                        sKBitmapLogo,
&lt;/span&gt;&lt;span&gt;610&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt;                             Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;613&lt;/span&gt;                             Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = sKBitmapLogo.Height, Width =&lt;span&gt; sKBitmapLogo.Width }
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;615&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;617&lt;/span&gt;                             Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = pointX, Y =&lt;span&gt; pointY },
&lt;/span&gt;&lt;span&gt;618&lt;/span&gt;                             Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = logoResultHeight, Width =&lt;span&gt; logoResultWidth }
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt; &lt;span&gt;                        }, sKPaint);
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt; &lt;span&gt;                    sKCanvas3.Dispose();
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt; &lt;span&gt;                    sKPaint.Dispose();
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt; &lt;span&gt;                    sKBitmapLogo.Dispose();
&lt;/span&gt;&lt;span&gt;623&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;625&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;626&lt;/span&gt; &lt;span&gt;                    sKBitmapLogo.Dispose();
&lt;/span&gt;&lt;span&gt;627&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;629&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;630&lt;/span&gt; 
&lt;span&gt;631&lt;/span&gt;             SkiaSharp.SKImage sKImage =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap);
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;633&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data = sKImage.Encode(format, &lt;span&gt;75&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;634&lt;/span&gt; &lt;span&gt;            sKImage.Dispose();
&lt;/span&gt;&lt;span&gt;635&lt;/span&gt;             reval =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;637&lt;/span&gt; 
&lt;span&gt;638&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; reval;
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QRDecoder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; qrCodeFilePath)
&lt;/span&gt;&lt;span&gt;641&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(qrCodeFilePath))
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;645&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt; 
&lt;span&gt;647&lt;/span&gt;             System.IO.FileStream fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(qrCodeFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;649&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;650&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片文件太大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;653&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; QRDecoder(fileStream);
&lt;/span&gt;&lt;span&gt;654&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QRDecoder(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] qrCodeBytes)
&lt;/span&gt;&lt;span&gt;656&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;657&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(qrCodeBytes==&lt;span&gt;null&lt;/span&gt;|| qrCodeBytes.Length&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;658&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;659&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数qrCodeBytes不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;660&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;661&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (qrCodeBytes.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;662&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片文件太大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;664&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;665&lt;/span&gt;             System.IO.MemoryStream ms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.MemoryStream(qrCodeBytes);
&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; QRDecoder(ms);
&lt;/span&gt;&lt;span&gt;667&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;668&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; QRDecoder(System.IO.Stream qrCodeFileStream)
&lt;/span&gt;&lt;span&gt;669&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;670&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(qrCodeFileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;671&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;672&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;673&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;674&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;675&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;676&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未识别的图片文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;677&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;678&lt;/span&gt; 
&lt;span&gt;679&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;680&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;681&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ps = w *&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;682&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[ps * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;683&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; byteIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;684&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; w; x++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;685&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;686&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; h; y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;687&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;688&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; color =&lt;span&gt; sKBitmap.GetPixel(x, y);
&lt;/span&gt;&lt;span&gt;689&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; color.Red;
&lt;/span&gt;&lt;span&gt;690&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; color.Green;
&lt;/span&gt;&lt;span&gt;691&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; color.Blue;
&lt;/span&gt;&lt;span&gt;692&lt;/span&gt;                     byteIndex += &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;693&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;694&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;695&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;696&lt;/span&gt; 
&lt;span&gt;697&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; qRCodeReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.QrCode.QRCodeReader();
&lt;/span&gt;&lt;span&gt;698&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rGBLuminanceSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.RGBLuminanceSource(bytes, w, h);
&lt;/span&gt;&lt;span&gt;699&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hybridBinarizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.Common.HybridBinarizer(rGBLuminanceSource);
&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; binaryBitmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.BinaryBitmap(hybridBinarizer);
&lt;/span&gt;&lt;span&gt;701&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hints = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;ZXing.DecodeHintType, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;702&lt;/span&gt;             hints.Add(ZXing.DecodeHintType.CHARACTER_SET, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;703&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; qRCodeReader.decode(binaryBitmap, hints);
&lt;/span&gt;&lt;span&gt;704&lt;/span&gt; 
&lt;span&gt;705&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; result != &lt;span&gt;null&lt;/span&gt; ? result.Text : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;706&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;707&lt;/span&gt;     }
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Dec 2018 15:38:00 +0000</pubDate>
<dc:creator>如兹</dc:creator>
<og:description>在 .net core 中采用 SkiaSharp 来做图片处理，顺便采用 ZXing.Net 来处理二维码的生成和解析。用 ZXing.Net 生成的二维码默认是有一定比例的白边的，但是在实际的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ruzi/p/10140754.html</dc:identifier>
</item>
<item>
<title>基于Arduino的音乐动感节奏灯 - zutterhao</title>
<link>http://www.cnblogs.com/zutterhao/p/10140172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zutterhao/p/10140172.html</guid>
<description>&lt;h2&gt;1、音乐动感节奏灯是个什么东西？&lt;/h2&gt;
&lt;p&gt;　　前段时间听音乐觉得无聊，便想着音乐光听也没意思啊，能不能 “看见” 音乐呢？于是谷歌了一番，发现还真有人做了将音乐可视化的东西，那就是音乐节奏灯。说的简单点就是LED灯光颜色亮度等随着音乐的节奏而发生变化，看了下他们的实现方法有很多，不过大都比较复杂，而且灯只能够做节奏灯也比较浪费，于是我便动手做了一个既可以当作普通台灯使用，又可以随着音乐而闪烁的动感节奏灯，一举两得。&lt;/p&gt;
&lt;h2&gt;2、做这个东西需要准备哪些材料？&lt;/h2&gt;
&lt;p&gt;　　工欲善其事，必先利其器。那么做这样一个音乐动感节奏等需要准备哪些材料呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Arduino UNO 开发板&lt;/li&gt;
&lt;li&gt;       声音传感器（最好买Arduino专用的）&lt;/li&gt;
&lt;li&gt;       BLE蓝牙4.0模块&lt;/li&gt;
&lt;li&gt;       WS2812B彩色灯带&lt;/li&gt;
&lt;li&gt;       灯罩&lt;/li&gt;
&lt;li&gt;       3D打印底座&lt;/li&gt;
&lt;li&gt;       电源线和杜邦线若干&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上材料可以在淘宝买到，灯罩和3D打印的底座可以按照自己的实际需求来进行自己选择，为了防止打广告的嫌疑我就不放购买链接了，可以自行设计打印~&lt;/p&gt;
&lt;h2&gt;3、做这个东西需该怎么做？&lt;/h2&gt;
&lt;p&gt;　　准备好上述的材料之后，我们就可以开始进行灯的制作啦~，节奏灯的主要结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218205857333-623092014.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用Arduino UNO作为主要的计算和处理模块，蓝牙4.0模块和手机进行通信，利用手机APP来选择模式（后续会讲），在节奏灯的模式下，通过声音传感器来采集声音，通过得到的声音来控制灯带的颜色和闪烁，在彩色灯的模式下，利用手机来控制灯的颜色，理论上的有160万可调颜色。接下来介绍下详细的步骤。&lt;/p&gt;
&lt;h3&gt;3.1 安装开发环境&lt;/h3&gt;
&lt;p&gt;　　Arduino UNO 开发的环境为Arduino IDE,软件下载地址为 https://www.arduino.cn/thread-5838-1-1.html ，默认安装为最新版即可。安装完IDE之后还需要安装第三方的库。&lt;/p&gt;
&lt;p&gt;　　1） WS2812B的库 FastLED, 选择 &lt;strong&gt;项目-&amp;gt;加载库-&amp;gt;管理库，&lt;/strong&gt;然后在输入栏输入FastLED,选择最新的版本安装,FastLED库的更多使用方法可以参考 &lt;a href=&quot;http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/fastled-library/&quot;&gt;http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/fastled-library/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218211335004-1697280679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2)  物联网开发平台库 Blinker, 在Blinker 官网&lt;a href=&quot;https://doc.blinker.app&quot;&gt;https://doc.blinker.app&lt;/a&gt; 页面下载最新的Blinker库，然后：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　Window&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;将下载好的blinker库解压到 &lt;strong&gt;我的电脑&amp;gt;文档&amp;gt;Arduino&amp;gt;libraries&lt;/strong&gt; 文件夹中&lt;br/&gt;　　　　&lt;strong&gt;Mac OS&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;将下载好的blinker库解压到 &lt;strong&gt;文稿&amp;gt;Arduino&amp;gt;libraries&lt;/strong&gt; 文件夹中&lt;/p&gt;
&lt;p&gt;　　　　可以在&lt;strong&gt;文件-&amp;gt;示例&lt;/strong&gt; 查看库是否安装成功。&lt;/p&gt;
&lt;h3&gt;3.2 连接线路&lt;/h3&gt;
&lt;p&gt;　　具体的线路图由于时间原因没有画，所以直接按照后续的代码可以找到每个模块的连接方式，当然这些连接方式都可以自定义，然后在代码内做简单修改即可。需要注意的是蓝牙模块采用软串口连接，即RX,TX连接在ARDUINO UNO的2 和 3 号脚，而不是0和1 号脚，这个在BLINKER的网站上会说明，如果你代码烧录不了，查查是不是这个原因。&lt;/p&gt;
&lt;h3&gt;3.3 代码编写&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;106&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BLINKER_PRINT Serial
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BLINKER_BLE
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; #include &amp;lt;FastLED.h&amp;gt;
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;Blinker.h&amp;gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* BASIC CONFIGURATION  *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The amount of LEDs in the setup&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; NUM_LEDS 100
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The pin that controls the LEDs&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LED_PIN 6
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The pin that we read sensor values form&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ANALOG_READ 0
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Confirmed microphone low value, and max value&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MIC_LOW 0.0
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MIC_HIGH 300.0
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Other macros &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many previous sensor values effects the operating average?&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; AVGLEN 5
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many previous sensor values decides if we are on a peak/HIGH (e.g. in a song)&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LONG_SECTOR 20
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mneumonics&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; HIGH 3
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; NORMAL 2
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How long do we keep the &quot;current average&quot; sound, before restarting the measuring&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; CYCLES 30 * 1000
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fscale( &lt;span&gt;float&lt;/span&gt; originalMin, &lt;span&gt;float&lt;/span&gt; originalMax, &lt;span&gt;float&lt;/span&gt; newBegin, &lt;span&gt;float&lt;/span&gt; newEnd, &lt;span&gt;float&lt;/span&gt; inputValue, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; curve);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt; val, &lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compute_average(&lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visualize_music();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many LEDs to we display&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; curshow =&lt;span&gt; NUM_LEDS;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Not really used yet. Thought to be able to switch between sound reactive
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;mode, and general gradient pulsing/static color&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Showing different colors based on the mode.&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Average sound measurement the last CYCLES&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; song_avg;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The amount of iterations since the song_avg was reset&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; iter = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The speed the LEDs fade to black if not relit&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fade_scale = &lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Led array&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;CRGB leds[NUM_LEDS];
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Short sound avg used to &quot;normalize&quot; the input values.
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;We use the short average instead of using the sensor input directly &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; avgs[AVGLEN] = {-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Longer sound avg&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; long_avg[LONG_SECTOR] = {-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LED Model 1/Music LED 2/Color LED&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; LED_Model = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Keeping track how often, and how long times we hit a certain mode&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; time_keeping {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;   unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; times_start;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;   &lt;span&gt;short&lt;/span&gt;&lt;span&gt; times;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How much to increment or decrement each color every cycle&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; color {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; g;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; time_keeping high;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; color Color; 
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; when you use the MusicLED as a Color LED&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; CRGB LEDColor(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; uint8_t Bright = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; declare the button&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; BlinkerRGB RGB1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGBKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; BlinkerButton Button1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rgb1_callback&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rgb1_callback(uint8_t r_value, uint8_t g_value, uint8_t b_value, uint8_t bright_value)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; change the color of strip by your set on Blinker&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;       LEDColor.r =&lt;span&gt; r_value;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;       LEDColor.g =&lt;span&gt; g_value;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;       LEDColor.b =&lt;span&gt; b_value;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;       Bright =&lt;span&gt; bright_value;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;      fill_solid(leds,NUM_LEDS,LEDColor);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;   
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;  FastLED.show();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_callback(&lt;span&gt;const&lt;/span&gt; String &amp;amp;&lt;span&gt; state) {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     LEDColor.r = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     LEDColor.g = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     LEDColor.b = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     Bright = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    fill_solid(leds,NUM_LEDS,LEDColor);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     BLINKER_LOG2(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strip_state: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OFF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     LED_Model = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     LED_Model = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;  FastLED.show();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setup() {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;   Serial.begin(&lt;span&gt;9600&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set all lights to make sure all are working as expected&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;   FastLED.addLeds&amp;lt;NEOPIXEL, LED_PIN&amp;gt;&lt;span&gt;(leds, NUM_LEDS);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_LEDS; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     leds[i] = CRGB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;  FastLED.show(); 
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;   delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootstrap average with some low values&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; AVGLEN; i++&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     insert(&lt;span&gt;250&lt;/span&gt;&lt;span&gt;, avgs, AVGLEN);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Initial values&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;   high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;   high.times_start =&lt;span&gt; millis();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;   Color.r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;   Color.g = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;   Color.b = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    Blinker.begin();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;attach the RGB1 SlidersRGB&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    RGB1.attach(rgb1_callback);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;    Button1.attach(button1_callback);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;With this we can change the mode if we want to implement a general 
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;lamp feature, with for instance general pulsing. Maybe if the
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;sound is low for a while? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loop() {
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;  Blinker.run();
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;   
&lt;span&gt;160&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    visualize_music();
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;    
&lt;span&gt;163&lt;/span&gt;   delay(&lt;span&gt;1&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; delay in between reads for stability&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*Funtion to check if the lamp should either enter a HIGH mode,
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;or revert to NORMAL if already in HIGH. If the sensors report values
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;that are higher than 1.1 times the average values, and this has happened
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;more than 30 times the last few milliseconds, it will enter HIGH mode. 
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;TODO: Not very well written, remove hardcoded values, and make it more
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;reusable and configurable.  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; check_high(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; avg) {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (avg &amp;gt; (song_avg/iter * &lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;))  {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (high.times != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (millis() - high.times_start &amp;gt; &lt;span&gt;200.0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         high.times_start =&lt;span&gt; millis();  
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;         high.times++&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;       high.times++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;       high.times_start =&lt;span&gt; millis();
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (high.times &amp;gt; &lt;span&gt;30&lt;/span&gt; &amp;amp;&amp;amp; millis() - high.times_start &amp;lt; &lt;span&gt;50.0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     songmode =&lt;span&gt; HIGH;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (millis() - high.times_start &amp;gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;     high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; 
&lt;span&gt;197&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Main function for visualizing the sounds in the lamp&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visualize_music() {
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sensor_value, mapped, avg, longavg;
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;   
&lt;span&gt;201&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Actual sensor value&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;   sensor_value =&lt;span&gt; analogRead(ANALOG_READ);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;  Serial.println(sensor_value);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;   
&lt;span&gt;205&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;If 0, discard immediately. Probably not right and save CPU.&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (sensor_value == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; 
&lt;span&gt;209&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Discard readings that deviates too much from the past avg.&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;   mapped = (&lt;span&gt;float&lt;/span&gt;)fscale(MIC_LOW, MIC_HIGH, MIC_LOW, (&lt;span&gt;float&lt;/span&gt;)MIC_HIGH, (&lt;span&gt;float&lt;/span&gt;)sensor_value, &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;   avg =&lt;span&gt; compute_average(avgs, AVGLEN);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (((avg - mapped) &amp;gt; avg*&lt;span&gt;0.8&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;|| ((avg - mapped) &amp;lt; -avg*0.8))&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;   
&lt;span&gt;216&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Insert new avg. values&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt; &lt;span&gt;  insert(mapped, avgs, AVGLEN); 
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;  insert(avg, long_avg, LONG_SECTOR); 
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Compute the &quot;song average&quot; sensor value&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt;   song_avg +=&lt;span&gt; avg;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;   iter++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (iter &amp;gt;&lt;span&gt; CYCLES) {  
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;     song_avg = song_avg /&lt;span&gt; iter;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;     iter = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;     
&lt;span&gt;228&lt;/span&gt;   longavg =&lt;span&gt; compute_average(long_avg, LONG_SECTOR);
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; 
&lt;span&gt;230&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Check if we enter HIGH mode &lt;/span&gt;
&lt;span&gt;231&lt;/span&gt; &lt;span&gt;  check_high(longavg);  
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (songmode ==&lt;span&gt; HIGH) {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     fade_scale = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     Color.r = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;     Color.g = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     Color.b = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (songmode ==&lt;span&gt; NORMAL) {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     fade_scale = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;     Color.r = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;     Color.b = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;     Color.g = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Decides how many of the LEDs will be lit&lt;/span&gt;
&lt;span&gt;247&lt;/span&gt;   curshow = fscale(MIC_LOW, MIC_HIGH, &lt;span&gt;0.0&lt;/span&gt;, (&lt;span&gt;float&lt;/span&gt;)NUM_LEDS, (&lt;span&gt;float&lt;/span&gt;)avg, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Set the different leds. Control for too high and too low values.
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;          Fun thing to try: Dont account for overflow in one direction, 
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;    some interesting light effects appear! &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_LEDS; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The leds we want to show&lt;/span&gt;
&lt;span&gt;254&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (i &amp;lt;&lt;span&gt; curshow) {
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].r + Color.r &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;         leds[i].r = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].r + Color.r &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         leds[i].r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;260&lt;/span&gt;         leds[i].r = leds[i].r +&lt;span&gt; Color.r;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;           
&lt;span&gt;262&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].g + Color.g &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;         leds[i].g = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].g + Color.g &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;         leds[i].g = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;267&lt;/span&gt;         leds[i].g = leds[i].g +&lt;span&gt; Color.g;
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].b + Color.b &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         leds[i].b = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].b + Color.b &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;         leds[i].b = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;274&lt;/span&gt;         leds[i].b = leds[i].b +&lt;span&gt; Color.b;  
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;       
&lt;span&gt;276&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;All the other LEDs begin their fading journey to eventual total darkness&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;       leds[i] = CRGB(leds[i].r/fade_scale, leds[i].g/fade_scale, leds[i].b/&lt;span&gt;fade_scale);
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; &lt;span&gt;  FastLED.show(); 
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Compute average of a int array, given the starting pointer and the length&lt;/span&gt;
&lt;span&gt;283&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compute_average(&lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;     sum +=&lt;span&gt; avgs[i];
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; 
&lt;span&gt;288&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)(sum /&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; 
&lt;span&gt;290&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; 
&lt;span&gt;292&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Insert a value into an array, and shift it down removing
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;the first value if array already full &lt;/span&gt;
&lt;span&gt;294&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt; val, &lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (avgs[i] == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;       avgs[i] =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;     avgs[i - &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; avgs[i];
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;   avgs[len - &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt; 
&lt;span&gt;308&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Function imported from the arduino website.
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Basically map, but with a curve on the scale (can be non-uniform).&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fscale( &lt;span&gt;float&lt;/span&gt; originalMin, &lt;span&gt;float&lt;/span&gt; originalMax, &lt;span&gt;float&lt;/span&gt; newBegin, &lt;span&gt;float&lt;/span&gt;
&lt;span&gt;311&lt;/span&gt;     newEnd, &lt;span&gt;float&lt;/span&gt; inputValue, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; curve){
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; 
&lt;span&gt;313&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; OriginalRange = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; NewRange = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; zeroRefCurVal = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; normalizedCurVal = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; rangedValue = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt;   boolean invFlag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; 
&lt;span&gt;320&lt;/span&gt; 
&lt;span&gt;321&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; condition curve parameter
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit range&lt;/span&gt;
&lt;span&gt;323&lt;/span&gt; 
&lt;span&gt;324&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (curve &amp;gt; &lt;span&gt;10&lt;/span&gt;) curve = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (curve &amp;lt; -&lt;span&gt;10&lt;/span&gt;) curve = -&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; 
&lt;span&gt;327&lt;/span&gt;   curve = (curve * -.&lt;span&gt;1&lt;/span&gt;) ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; - invert and scale - this seems more intuitive - postive numbers give more weight to high end on output &lt;/span&gt;
&lt;span&gt;328&lt;/span&gt;   curve = pow(&lt;span&gt;10&lt;/span&gt;, curve); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; convert linear scale into lograthimic exponent for other pow function
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; 
&lt;span&gt;330&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for out of range inputValues&lt;/span&gt;
&lt;span&gt;331&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (inputValue &amp;lt;&lt;span&gt; originalMin) {
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;     inputValue =&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (inputValue &amp;gt;&lt;span&gt; originalMax) {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt;     inputValue =&lt;span&gt; originalMax;
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; 
&lt;span&gt;338&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Zero Refference the values&lt;/span&gt;
&lt;span&gt;339&lt;/span&gt;   OriginalRange = originalMax -&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; 
&lt;span&gt;341&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (newEnd &amp;gt;&lt;span&gt; newBegin){ 
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;     NewRange = newEnd -&lt;span&gt; newBegin;
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;345&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;     NewRange = newBegin -&lt;span&gt; newEnd; 
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt;     invFlag = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; 
&lt;span&gt;350&lt;/span&gt;   zeroRefCurVal = inputValue -&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;   normalizedCurVal  =  zeroRefCurVal / OriginalRange;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; normalize to 0 - 1 float
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; 
&lt;span&gt;353&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for originalMin &amp;gt; originalMax  - the math for all other cases i.e. negative numbers seems to work out fine &lt;/span&gt;
&lt;span&gt;354&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (originalMin &amp;gt;&lt;span&gt; originalMax ) {
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; 
&lt;span&gt;358&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (invFlag == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;     rangedValue =  (pow(normalizedCurVal, curve) * NewRange) +&lt;span&gt; newBegin;
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; 
&lt;span&gt;361&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; invert the ranges&lt;/span&gt;
&lt;span&gt;363&lt;/span&gt; &lt;span&gt;  {   
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt;     rangedValue =  newBegin - (pow(normalizedCurVal, curve) *&lt;span&gt; NewRange); 
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt; 
&lt;span&gt;367&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rangedValue;
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码编译无误后上传到Arduino UNO即可。&lt;/p&gt;
&lt;h3&gt;3.4 下载并使用Blinker软件连接&lt;/h3&gt;
&lt;p&gt;　　Blinker软件的安装包可以在官网上找到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218212641568-1083291784.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好之后注册账号，登陆，在主页面右上角选择--&amp;gt;添加设备--&amp;gt;Arduino--&amp;gt;蓝牙接入，然后会自动发现我们的蓝牙，连接上之后，如图。&lt;/p&gt;
&lt;p&gt;                                                                                           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213104043-408136393.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面表示是否已经连接，现在表示已连接。然后添加上面的两个组件，编辑组件参数如下：&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213234008-640513673.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213301712-116209402.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成之后便可以通过RGB滑条来控制颜色，通过模式按钮来控制灯的模式。&lt;/p&gt;
&lt;h3&gt;3.5 灯的组装&lt;/h3&gt;
&lt;p&gt; 　　我是自己在网上买的灯罩，然后根据自己的需求3D打印的底座，大家可以发挥自己的想象力来创作出不一样的外观~&lt;/p&gt;
&lt;p&gt;　然后来一波安装完成的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213623344-518095696.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后更新一波实测视频（由于不能同时录像和控制，所以只放了节奏灯效果）：&lt;/p&gt;
&lt;p&gt;地址：https://www.bilibili.com/video/av38471827/&lt;/p&gt;









</description>
<pubDate>Tue, 18 Dec 2018 15:12:00 +0000</pubDate>
<dc:creator>zutterhao</dc:creator>
<og:description>Arduino 音乐节奏灯</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zutterhao/p/10140172.html</dc:identifier>
</item>
<item>
<title>作为IT，你的价值在哪里？ - SAP梦心</title>
<link>http://www.cnblogs.com/saper/p/10140736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saper/p/10140736.html</guid>
<description>&lt;p&gt;也许最近是真的被无穷无尽的数据整理、导入、再整理、再导入给恶心到了。&lt;/p&gt;

&lt;p&gt;业务部提交的数据只是一个非常初始的数据，IT还得在这个基础上七整八整，对导出的结果还要再做二次导入三次导入，不仅要帮业务部批导生成销售订单，连着交货、交货过账都得一并处理。十多万笔的数据要在年底之前全部导入系统中，做到分毫不差，而且完成之后还要校验数据的正确性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232139639-552380252.jpg&quot; alt=&quot;&quot; width=&quot;636&quot; height=&quot;424&quot;/&gt; &lt;/p&gt;

&lt;p&gt; 看着SAP系统在忙碌得转着转着，拼命导入数据。等待之余，&lt;strong&gt;我在想，作为IT，你的价值在哪里？为什么会陷入数据整理的茫茫大海中没有方向？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想起几年前在KB公司供职的情形，那边的信息化比较落后。每个月员工食堂的消费数据都是IT从在一卡通系统中下载汇聚到总公司的数据库，然后再导出来到本地，在Excel里经过汇总加工，利用公式得出每个人当月的消费数据，然后再提供给人资去做工资扣款。因为数据非常庞大，再加上公司网络环境比较差，收集整理消费数据就占用掉了IT非常多的时间，导致处理人员每个月前后十天都很忙。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232152372-346670016.jpg&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是，&lt;strong&gt;他们很乐于陷入这种毫无意义而且重复性高的数据收集整理的工作当中，只是看起来很忙而已，在我看来这种工作毫无价值&lt;/strong&gt;。更可怕的是人的固有思维导致他们根本没有意识问题，意识到该去改善这种繁杂的事务。&lt;/p&gt;

&lt;p&gt;后来一卡通经过我一系列的程序处理和流程优化，工作效率直接从之前的10天处理时间变成0，IT从此不需要再关心它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232206116-230080433.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参看当初的博文：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/saper/p/5625289.html &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想说的是，作为IT，&lt;strong&gt;我们的价值就应该体现在能够根据企业的业务发展和管理需求的变化而制定出合理可执行的信息化解决方案&lt;/strong&gt;&lt;strong&gt;，改善用户的操作效率和体验，使系统使用更加顺畅，使数据更加精准&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果IT整天在帮业务部门收集、整理业务数据和擦屁股，惯着业务部门做着自己不擅长的工作，做着不是自己份内的事情，活生生把自己培养成业务部的保姆或下手，整天看起来很忙的样子，不仅丝毫没有价值，而且还吃力不讨好。&lt;/p&gt;

&lt;p&gt;最后：从审计的角度来说，&lt;strong&gt;IT是不能在系统中创建和修改业务数据的，这不符合审计要求（系统上线导入期初数据的情况除外）。而且，IT不能对要批导的业务数据做加工处理，也没办法对业务数据的准确性负责&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232216566-509691714.jpg&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232315480-245803825.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>SAP梦心</dc:creator>
<og:description>也许最近是真的被无穷无尽的数据整理、导入、再整理、再导入给恶心到了。 业务部提交的数据只是一个非常初始的数据，IT还得在这个基础上七整八整，对导出的结果还要再做二次导入三次导入，不仅要帮业务部批导生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saper/p/10140736.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第十一章 授权篇-密码授权模式 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/10140688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/10140688.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;上篇文章介绍了基于&lt;code&gt;Ids4&lt;/code&gt;客户端授权的原理及如何实现自定义的客户端授权，并配合网关实现了统一的授权异常返回值和权限配置等相关功能，本篇将介绍密码授权模式，从使用场景、源码剖析到具体实现详细讲解密码授权模式的相关应用。&lt;/p&gt;
&lt;p&gt;.netcore项目实战交流群（637326624），有兴趣的朋友可以在群里交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一使用场景&quot;&gt;一、使用场景？&lt;/h2&gt;
&lt;p&gt;由于密码授权模式需要用户在业务系统输入账号密码，为了安全起见，对于使用密码模式的业务系统，我们认为是绝对可靠的，不存在泄漏用户名和密码的风险，所以使用场景定位为公司内部系统或集团内部系统或公司内部app等内部应用，非内部应用，尽量不要开启密码授权模式，防止用户账户泄漏。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这种模式适用于用户对应用程序高度信任的情况。比如是用户系统的一部分。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二ids4密码模式的默认实现剖析&quot;&gt;二、Ids4密码模式的默认实现剖析&lt;/h2&gt;
&lt;p&gt;在我们使用密码授权模式之前，我们需要理解密码模式是如何实现的，在上一篇中，我介绍了客户端授权的实现及源码剖析，相信我们已经对&lt;code&gt;Ids4&lt;/code&gt;客户端授权已经熟悉，今天继续分析密码模式是如何获取到令牌的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ids4&lt;/code&gt;的所有授权都在&lt;code&gt;TokenEndpoint&lt;/code&gt;方法中，密码模式授权也是先校验客户端授权，如果客户端校验失败，直接返回删除信息，如果客户端校验成功，继续校验用户名和密码，详细实现代码如下。&lt;/p&gt;
&lt;ul readability=&quot;61&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;1、校验是否存在&lt;code&gt;grantType&lt;/code&gt;，然后根据不同的类型启用不同的校验方式。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// TokenRequestValidator.cs
public async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateRequestAsync(NameValueCollection parameters, ClientSecretValidationResult clientValidationResult)
{
  _logger.LogDebug(&quot;Start token request validation&quot;);

  _validatedRequest = new ValidatedTokenRequest
  {
      Raw = parameters ?? throw new ArgumentNullException(nameof(parameters)),
      Options = _options
  };

  if (clientValidationResult == null) throw new ArgumentNullException(nameof(clientValidationResult));

  _validatedRequest.SetClient(clientValidationResult.Client, clientValidationResult.Secret, clientValidationResult.Confirmation);

  /////////////////////////////////////////////
  // check client protocol type
  /////////////////////////////////////////////
  if (_validatedRequest.Client.ProtocolType != IdentityServerConstants.ProtocolTypes.OpenIdConnect)
  {
      LogError(&quot;Client {clientId} has invalid protocol type for token endpoint: expected {expectedProtocolType} but found {protocolType}&quot;,
               _validatedRequest.Client.ClientId,
               IdentityServerConstants.ProtocolTypes.OpenIdConnect,
               _validatedRequest.Client.ProtocolType);
      return Invalid(OidcConstants.TokenErrors.InvalidClient);
  }

  /////////////////////////////////////////////
  // check grant type
  /////////////////////////////////////////////
  var grantType = parameters.Get(OidcConstants.TokenRequest.GrantType);
  if (grantType.IsMissing())
  {
      LogError(&quot;Grant type is missing&quot;);
      return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
  }

  if (grantType.Length &amp;gt; _options.InputLengthRestrictions.GrantType)
  {
      LogError(&quot;Grant type is too long&quot;);
      return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
  }

  _validatedRequest.GrantType = grantType;

  switch (grantType)
  {
      case OidcConstants.GrantTypes.AuthorizationCode:
          return await RunValidationAsync(ValidateAuthorizationCodeRequestAsync, parameters);
      case OidcConstants.GrantTypes.ClientCredentials:
          return await RunValidationAsync(ValidateClientCredentialsRequestAsync, parameters);
      case OidcConstants.GrantTypes.Password:  //1、密码授权模式调用方法
          return await RunValidationAsync(ValidateResourceOwnerCredentialRequestAsync, parameters);
      case OidcConstants.GrantTypes.RefreshToken:
          return await RunValidationAsync(ValidateRefreshTokenRequestAsync, parameters);
      default:
          return await RunValidationAsync(ValidateExtensionGrantRequestAsync, parameters);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;2、启用密码授权模式校验规则，首先校验传输的参数和&lt;code&gt;scope&lt;/code&gt;是否存在，然后校验用户名密码是否准确，最后校验用户是否可用。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateResourceOwnerCredentialRequestAsync(NameValueCollection parameters)
{
    _logger.LogDebug(&quot;Start resource owner password token request validation&quot;);

    /////////////////////////////////////////////
    // 校验授权模式
    /////////////////////////////////////////////
    if (!_validatedRequest.Client.AllowedGrantTypes.Contains(GrantType.ResourceOwnerPassword))
    {
        LogError(&quot;{clientId} not authorized for resource owner flow, check the AllowedGrantTypes of client&quot;, _validatedRequest.Client.ClientId);
        return Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
    }

    /////////////////////////////////////////////
    // 校验客户端是否允许这些scope
    /////////////////////////////////////////////
    if (!(await ValidateRequestedScopesAsync(parameters)))
    {
        return Invalid(OidcConstants.TokenErrors.InvalidScope);
    }

    /////////////////////////////////////////////
    // 校验参数是否为定义的用户名或密码参数
    /////////////////////////////////////////////
    var userName = parameters.Get(OidcConstants.TokenRequest.UserName);
    var password = parameters.Get(OidcConstants.TokenRequest.Password);

    if (userName.IsMissing() || password.IsMissing())
    {
        LogError(&quot;Username or password missing&quot;);
        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    if (userName.Length &amp;gt; _options.InputLengthRestrictions.UserName ||
        password.Length &amp;gt; _options.InputLengthRestrictions.Password)
    {
        LogError(&quot;Username or password too long&quot;);
        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;


    /////////////////////////////////////////////
    // 校验用户名和密码是否准确
    /////////////////////////////////////////////
    var resourceOwnerContext = new ResourceOwnerPasswordValidationContext
    {
        UserName = userName,
        Password = password,
        Request = _validatedRequest
    };
    //默认使用的是 TestUserResourceOwnerPasswordValidator
    await _resourceOwnerValidator.ValidateAsync(resourceOwnerContext);

    if (resourceOwnerContext.Result.IsError)
    {
        if (resourceOwnerContext.Result.Error == OidcConstants.TokenErrors.UnsupportedGrantType)
        {
            LogError(&quot;Resource owner password credential grant type not supported&quot;);
            await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, &quot;password grant type not supported&quot;);

            return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType, customResponse: resourceOwnerContext.Result.CustomResponse);
        }

        var errorDescription = &quot;invalid_username_or_password&quot;;

        if (resourceOwnerContext.Result.ErrorDescription.IsPresent())
        {
            errorDescription = resourceOwnerContext.Result.ErrorDescription;
        }

        LogInfo(&quot;User authentication failed: {error}&quot;, errorDescription ?? resourceOwnerContext.Result.Error);
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, errorDescription);

        return Invalid(resourceOwnerContext.Result.Error, errorDescription, resourceOwnerContext.Result.CustomResponse);
    }

    if (resourceOwnerContext.Result.Subject == null)
    {
        var error = &quot;User authentication failed: no principal returned&quot;;
        LogError(error);
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, error);

        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    /////////////////////////////////////////////
    // 设置用户可用,比如用户授权后被锁定，可以通过此方法实现 默认实现 TestUserProfileService
    /////////////////////////////////////////////
    var isActiveCtx = new IsActiveContext(resourceOwnerContext.Result.Subject, _validatedRequest.Client, IdentityServerConstants.ProfileIsActiveCallers.ResourceOwnerValidation);
    await _profile.IsActiveAsync(isActiveCtx);

    if (isActiveCtx.IsActive == false)
    {
        LogError(&quot;User has been disabled: {subjectId}&quot;, resourceOwnerContext.Result.Subject.GetSubjectId());
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, &quot;user is inactive&quot;);

        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;
    _validatedRequest.Subject = resourceOwnerContext.Result.Subject;

    await RaiseSuccessfulResourceOwnerAuthenticationEventAsync(userName, resourceOwnerContext.Result.Subject.GetSubjectId());
    _logger.LogDebug(&quot;Resource owner password token request validation success.&quot;);
    return Valid(resourceOwnerContext.Result.CustomResponse);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;3、运行自定义上下文验证&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async Task&amp;lt;TokenRequestValidationResult&amp;gt; RunValidationAsync(Func&amp;lt;NameValueCollection, Task&amp;lt;TokenRequestValidationResult&amp;gt;&amp;gt; validationFunc, NameValueCollection parameters)
{
    // 执行步骤2验证
    var result = await validationFunc(parameters);
    if (result.IsError)
    {
        return result;
    }

    // 运行自定义验证，Ids4 默认有个 DefaultCustomTokenRequestValidator 实现，如果需要扩充其他验证，可以集成ICustomTokenRequestValidator单独实现。
    _logger.LogTrace(&quot;Calling into custom request validator: {type}&quot;, _customRequestValidator.GetType().FullName);

    var customValidationContext = new CustomTokenRequestValidationContext { Result = result };
    await _customRequestValidator.ValidateAsync(customValidationContext);

    if (customValidationContext.Result.IsError)
    {
        if (customValidationContext.Result.Error.IsPresent())
        {
            LogError(&quot;Custom token request validator error {error}&quot;, customValidationContext.Result.Error);
        }
        else
        {
            LogError(&quot;Custom token request validator error&quot;);
        }

        return customValidationContext.Result;
    }

    LogSuccess();
    return customValidationContext.Result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码剖析可以发现，&lt;code&gt;Ids4&lt;/code&gt;给了我们很多的验证方式，并且默认也实现的验证和自定义的扩展，这样如果我们需要使用密码授权模式，就可以重写&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;来实现系统内部用户系统的验证需求。如果需要确认用户在登录以后是否被注销时，可以重写&lt;code&gt;IProfileService&lt;/code&gt;接口实现，这个验证主要是生成token校验时检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;4、最终生成Token&lt;/p&gt;
&lt;p&gt;根据不同的授权模式，生成不同的token记录。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Processes the response.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public virtual async Task&amp;lt;TokenResponse&amp;gt; ProcessAsync(TokenRequestValidationResult request)
{
    switch (request.ValidatedRequest.GrantType)
    {
        case OidcConstants.GrantTypes.ClientCredentials:
            return await ProcessClientCredentialsRequestAsync(request);
        case OidcConstants.GrantTypes.Password: //生成密码授权模式token
            return await ProcessPasswordRequestAsync(request);
        case OidcConstants.GrantTypes.AuthorizationCode:
            return await ProcessAuthorizationCodeRequestAsync(request);
        case OidcConstants.GrantTypes.RefreshToken:
            return await ProcessRefreshTokenRequestAsync(request);
        default:
            return await ProcessExtensionGrantRequestAsync(request);
    }
}

/// &amp;lt;summary&amp;gt;
/// Creates the response for a password request.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual Task&amp;lt;TokenResponse&amp;gt; ProcessPasswordRequestAsync(TokenRequestValidationResult request)
{
    Logger.LogTrace(&quot;Creating response for password request&quot;);

    return ProcessTokenRequestAsync(request);
}

/// &amp;lt;summary&amp;gt;
/// Creates the response for a token request.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;validationResult&quot;&amp;gt;The validation result.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task&amp;lt;TokenResponse&amp;gt; ProcessTokenRequestAsync(TokenRequestValidationResult validationResult)
{
    (var accessToken, var refreshToken) = await CreateAccessTokenAsync(validationResult.ValidatedRequest);
    var response = new TokenResponse
    {
        AccessToken = accessToken,
        AccessTokenLifetime = validationResult.ValidatedRequest.AccessTokenLifetime,
        Custom = validationResult.CustomResponse
    };

    if (refreshToken.IsPresent())
    {
        response.RefreshToken = refreshToken;
    }

    return response;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据请求的&lt;code&gt;scope&lt;/code&gt;判断是否生成&lt;code&gt;refreshToken&lt;/code&gt;，如果标记了&lt;code&gt;offline_access&lt;/code&gt;，则生成&lt;code&gt;refreshToken&lt;/code&gt;，否则不生成。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the access/refresh token.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
/// &amp;lt;exception cref=&quot;System.InvalidOperationException&quot;&amp;gt;Client does not exist anymore.&amp;lt;/exception&amp;gt;
protected virtual async Task&amp;lt;(string accessToken, string refreshToken)&amp;gt; CreateAccessTokenAsync(ValidatedTokenRequest request)
{
    TokenCreationRequest tokenRequest;
    bool createRefreshToken;
  //授权码模式
    if (request.AuthorizationCode != null)
    {//是否包含RefreshToken
        createRefreshToken = request.AuthorizationCode.RequestedScopes.Contains(IdentityServerConstants.StandardScopes.OfflineAccess);

        // load the client that belongs to the authorization code
        Client client = null;
        if (request.AuthorizationCode.ClientId != null)
        {
            client = await Clients.FindEnabledClientByIdAsync(request.AuthorizationCode.ClientId);
        }
        if (client == null)
        {
            throw new InvalidOperationException(&quot;Client does not exist anymore.&quot;);
        }

        var resources = await Resources.FindEnabledResourcesByScopeAsync(request.AuthorizationCode.RequestedScopes);

        tokenRequest = new TokenCreationRequest
        {
            Subject = request.AuthorizationCode.Subject,
            Resources = resources,
            ValidatedRequest = request
        };
    }
    else
    {//是否包含RefreshToken
        createRefreshToken = request.ValidatedScopes.ContainsOfflineAccessScope;

        tokenRequest = new TokenCreationRequest
        {
            Subject = request.Subject,
            Resources = request.ValidatedScopes.GrantedResources,
            ValidatedRequest = request
        };
    }

    var at = await TokenService.CreateAccessTokenAsync(tokenRequest);
    var accessToken = await TokenService.CreateSecurityTokenAsync(at);

    if (createRefreshToken)
    {
        var refreshToken = await RefreshTokenService.CreateRefreshTokenAsync(tokenRequest.Subject, at, request.Client);
        return (accessToken, refreshToken);
    }

    return (accessToken, null);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;38&quot;&gt;
&lt;p&gt;5、RefreshToken持久化&lt;/p&gt;
&lt;p&gt;当我们使用了&lt;code&gt;offline_access&lt;/code&gt;时，就需要生成&lt;code&gt;RefreshToken&lt;/code&gt;并进行持久化，详细的实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public virtual async Task&amp;lt;string&amp;gt; CreateRefreshTokenAsync(ClaimsPrincipal subject, Token accessToken, Client client)
{
    _logger.LogDebug(&quot;Creating refresh token&quot;);

    int lifetime;
    if (client.RefreshTokenExpiration == TokenExpiration.Absolute)
    {
        _logger.LogDebug(&quot;Setting an absolute lifetime: &quot; + client.AbsoluteRefreshTokenLifetime);
        lifetime = client.AbsoluteRefreshTokenLifetime;
    }
    else
    {
        _logger.LogDebug(&quot;Setting a sliding lifetime: &quot; + client.SlidingRefreshTokenLifetime);
        lifetime = client.SlidingRefreshTokenLifetime;
    }

    var refreshToken = new RefreshToken
    {
        CreationTime = Clock.UtcNow.UtcDateTime,
        Lifetime = lifetime,
        AccessToken = accessToken
    };
  //存储RefreshToken并返回值
    var handle = await RefreshTokenStore.StoreRefreshTokenAsync(refreshToken);
    return handle;
}

/// &amp;lt;summary&amp;gt;
/// 存储RefreshToken并返回
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;refreshToken&quot;&amp;gt;The refresh token.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public async Task&amp;lt;string&amp;gt; StoreRefreshTokenAsync(RefreshToken refreshToken)
{
    return await CreateItemAsync(refreshToken, refreshToken.ClientId, refreshToken.SubjectId, refreshToken.CreationTime, refreshToken.Lifetime);
}

/// &amp;lt;summary&amp;gt;
/// 创建Item
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;item&quot;&amp;gt;The item.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;clientId&quot;&amp;gt;The client identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;The subject identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;created&quot;&amp;gt;The created.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lifetime&quot;&amp;gt;The lifetime.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task&amp;lt;string&amp;gt; CreateItemAsync(T item, string clientId, string subjectId, DateTime created, int lifetime)
{
    var handle = await HandleGenerationService.GenerateAsync(); //生成随机值
    await StoreItemAsync(handle, item, clientId, subjectId, created, created.AddSeconds(lifetime)); //存储
    return handle;
}

/// &amp;lt;summary&amp;gt;
/// 存储RefreshToken
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;key&quot;&amp;gt;The key.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;item&quot;&amp;gt;The item.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;clientId&quot;&amp;gt;The client identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;The subject identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;created&quot;&amp;gt;The created.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;expiration&quot;&amp;gt;The expiration.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task StoreItemAsync(string key, T item, string clientId, string subjectId, DateTime created, DateTime? expiration)
{
    key = GetHashedKey(key);

    var json = Serializer.Serialize(item);

    var grant = new PersistedGrant
    {
        Key = key,
        Type = GrantType,
        ClientId = clientId,
        SubjectId = subjectId,
        CreationTime = created,
        Expiration = expiration,
        Data = json
    };

    await Store.StoreAsync(grant);
}

//IPersistedGrantStore 我们在dapper持久化时已经实现了StoreAsync方式，是不是都关联起来了。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们整个密码授权模式全部讲解完成，相信大家跟我一样完全掌握了授权的整个流程，如果需要持久化如何进行持久化流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;理解了完整的密码授权模式流程后，使用自定义的用户体系就得心应手了，下面就开始完整的实现自定义帐户授权。&lt;/p&gt;
&lt;h2 id=&quot;三设计自定义的账户信息并应用&quot;&gt;三、设计自定义的账户信息并应用&lt;/h2&gt;
&lt;p&gt;为了演示方便，我这里就设计简单的用户帐户信息，作为自定义的哦帐户基础，如果正式环境中使用，请根据各自业务使用各自的帐户体系即可。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;-- 创建用户表
CREATE TABLE CzarUsers
(
    Uid INT IDENTITY(1,1),            --用户主键    
    uAccount varchar(11),             --用户账号
    uPassword varchar(200),           --用户密码
    uNickName varchar(50),            --用户昵称
    uMobile varchar(11),              --用户手机号
    uEmail varchar(100),              --用户邮箱
    uStatus int not null default(1)   -- 用户状态 1 正常 0 不可用
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加用户实体代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 授权用户信息
/// &amp;lt;/summary&amp;gt;
public class CzarUsers
{
    public CzarUsers() { }

    public int Uid { get; set; }
    public string uAccount { get; set; }
    public string uPassword { get; set; }
    public string uNickName { get; set; }
    public string uMobile { get; set; }
    public string uEmail { get; set; }
    public string uStatus { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面开始密码授权模式开发，首先需要重新实现&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;接口，使用我们定义的用户表来验证请求的用户名和密码信息。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 自定义用户名密码校验
/// &amp;lt;/summary&amp;gt;
public class CzarResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        private readonly ICzarUsersServices _czarUsersServices;
        public CzarResourceOwnerPasswordValidator(ICzarUsersServices czarUsersServices)
        {
            _czarUsersServices = czarUsersServices;
        }
        /// &amp;lt;summary&amp;gt;
        /// 验证用户身份
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            var user = _czarUsersServices.FindUserByuAccount(context.UserName, context.Password);
            if (user != null)
            {
                context.Result = new GrantValidationResult(
                    user.Uid.ToString(),
                    OidcConstants.AuthenticationMethods.Password, 
                    DateTime.UtcNow);
            }
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写完自定义校验后，我们需要注入到具体的实现，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton(Configuration);
    services.Configure&amp;lt;CzarConfig&amp;gt;(Configuration.GetSection(&quot;CzarConfig&quot;));
    services.AddIdentityServer(option=&amp;gt; {
        option.PublicOrigin = Configuration[&quot;CzarConfig:PublicOrigin&quot;];
    })
        .AddDeveloperSigningCredential()
        .AddDapperStore(option =&amp;gt;
                        {
                            option.DbConnectionStrings = Configuration[&quot;CzarConfig:DbConnectionStrings&quot;];
                        })
        //使用自定义的密码校验
        .AddResourceOwnerValidator&amp;lt;CzarResourceOwnerPasswordValidator&amp;gt;()
        ;
    //  .UseMySql();


    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下的就是把&lt;code&gt;ICzarUsersServices&lt;/code&gt;接口实现并注入即可。详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户服务接口
/// &amp;lt;/summary&amp;gt;
public interface ICzarUsersServices
{
    /// &amp;lt;summary&amp;gt;
    /// 根据账号密码获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByuAccount(string uaccount, string upassword);

    /// &amp;lt;summary&amp;gt;
    /// 根据用户主键获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByUid(string sub);
}

/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户服务实现
/// &amp;lt;/summary&amp;gt;
public class CzarUsersServices : ICzarUsersServices
    {
        private readonly ICzarUsersRepository _czarUsersRepository;
        public CzarUsersServices(ICzarUsersRepository czarUsersRepository)
        {
            _czarUsersRepository = czarUsersRepository;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByuAccount(string uaccount, string upassword)
        {
            return _czarUsersRepository.FindUserByuAccount(uaccount, upassword);
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户主键获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByUid(string sub)
        {
            return _czarUsersRepository.FindUserByUid(sub);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们实现仓储接口和方法，即可完成校验流程。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户仓储接口
/// &amp;lt;/summary&amp;gt;
public interface ICzarUsersRepository
{
    /// &amp;lt;summary&amp;gt;
    /// 根据账号密码获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByuAccount(string uaccount, string upassword);

    /// &amp;lt;summary&amp;gt;
    /// 根据用户主键获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByUid(string sub);
}

/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户实体基于SQLSERVER的实现
/// &amp;lt;/summary&amp;gt;
public class CzarUsersRepository : ICzarUsersRepository
    {
        private readonly string DbConn = &quot;&quot;;
        public CzarUsersRepository(IOptions&amp;lt;CzarConfig&amp;gt; czarConfig)
        {
            DbConn = czarConfig.Value.DbConnectionStrings;
        }
        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByuAccount(string uaccount, string upassword)
        {
            using (var connection = new SqlConnection(DbConn))
            {
                string sql = @&quot;SELECT * from CzarUsers where uAccount=@uaccount and uPassword=upassword and uStatus=1&quot;;
                var result = connection.QueryFirstOrDefault&amp;lt;CzarUsers&amp;gt;(sql, new { uaccount, upassword = SecretHelper.ToMD5(upassword) });
                return result;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户主键获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByUid(string sub)
        {
            using (var connection = new SqlConnection(DbConn))
            {
                string sql = @&quot;SELECT * from CzarUsers where uid=@uid&quot;;
                var result = connection.QueryFirstOrDefault&amp;lt;CzarUsers&amp;gt;(sql, new { uid=sub });
                return result;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在万事俱备，之前注入和插入测试用户数据进行测试了，为了方便注入，我们采用&lt;code&gt;autofac&lt;/code&gt;程序集注册。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 使用程序集注册
/// &amp;lt;/summary&amp;gt;
public class CzarModule : Autofac.Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            //注册Repository程序集
            builder.RegisterAssemblyTypes(typeof(CzarUsersRepository).GetTypeInfo().Assembly).AsImplementedInterfaces().InstancePerLifetimeScope();
            //注册Services程序集
            builder.RegisterAssemblyTypes(typeof(CzarUsersServices).GetTypeInfo().Assembly).AsImplementedInterfaces().InstancePerLifetimeScope();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要修改&lt;code&gt;ConfigureServices&lt;/code&gt;代码如下,就完成了仓储和服务层的注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddSingleton(Configuration);
    services.Configure&amp;lt;CzarConfig&amp;gt;(Configuration.GetSection(&quot;CzarConfig&quot;));
    services.AddIdentityServer(option=&amp;gt; {
        option.PublicOrigin = Configuration[&quot;CzarConfig:PublicOrigin&quot;];
    })
        .AddDeveloperSigningCredential()
        .AddDapperStore(option =&amp;gt;
                        {
                            option.DbConnectionStrings = Configuration[&quot;CzarConfig:DbConnectionStrings&quot;];
                        })
        .AddResourceOwnerValidator&amp;lt;CzarResourceOwnerPasswordValidator&amp;gt;()
        ;
    //  .UseMySql();


    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    //使用Autofac进行注入
    var container = new ContainerBuilder();
    container.RegisterModule(new CzarModule());
    container.Populate(services);
    return new AutofacServiceProvider(container.Build());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了验证密码授权模式信息，这里需要往数据库插入测试的用户数据，插入脚本如下。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;--密码123456  MD5加密结果
INSERT INTO CzarUsers VALUES('13888888888','E10ADC3949BA59ABBE56E057F20F883E','金焰的世界','13888888888','541869544@qq.com',1); &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四测试密码授权模式&quot;&gt;四、测试密码授权模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：测试密码授权模式之前，我们需要对测试的客户端&lt;code&gt;ClientGrantTypes&lt;/code&gt;表添加&lt;code&gt;password&lt;/code&gt;授权方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开我们的测试神器&lt;code&gt;Postman&lt;/code&gt;,然后开始调试密码授权模式，测试结果如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225012340-16337323.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很完美，得到了我们想要的授权结果，那我们查看下这个access_token是什么信息，可以使用&lt;a href=&quot;https://jwt.io/&quot; class=&quot;uri&quot;&gt;https://jwt.io/&lt;/a&gt;查看到详细的内容，发现除了客户端信息和用户主键无其他附加信息，那如何添加自定义的Claim信息呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225028816-853023018.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先修改下&lt;code&gt;CzarUsers&lt;/code&gt;实体，增加如下代码，如果有其他属性可自行扩展。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public List&amp;lt;Claim&amp;gt; Claims
        {
            get
            {
                return new List&amp;lt;Claim&amp;gt;() {
                    new Claim(&quot;nickname&quot;,uNickName??&quot;&quot;),
                    new Claim(&quot;email&quot;,uEmail??&quot;&quot;),
                    new Claim(&quot;mobile&quot;,uMobile??&quot;&quot;)
                };
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改校验方法，增加&lt;code&gt;Claim&lt;/code&gt;输出，&lt;code&gt;CzarResourceOwnerPasswordValidator&lt;/code&gt;修改代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 验证用户身份
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
{
    var user = _czarUsersServices.FindUserByuAccount(context.UserName, context.Password);
    if (user != null)
    {
        context.Result = new GrantValidationResult(
            user.Uid.ToString(),
            OidcConstants.AuthenticationMethods.Password, 
            DateTime.UtcNow,
            user.Claims);
    }
    return Task.CompletedTask;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要把用户的claims应用到Token，这里我们需要重写&lt;code&gt;IProfileService&lt;/code&gt;，然后把用户的claim输出，实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CzarProfileService : IProfileService
    {
        public Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            //把用户返回的Claims应用到返回
            context.IssuedClaims = context.Subject.Claims.ToList();
            return Task.CompletedTask;
        }

        /// &amp;lt;summary&amp;gt;
        /// 验证用户是否有效
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive = true;
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后别忘了注入&lt;code&gt;.AddProfileService&amp;lt;CzarProfileService&amp;gt;()&lt;/code&gt;，好了现在我们再次测试下授权，最终得到的结果如下所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225048444-1876304490.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;奈斯，得到了我们预期授权结果。&lt;/p&gt;
&lt;p&gt;那如何获取&lt;code&gt;refresh_token&lt;/code&gt;呢？通过前面的介绍，我们需要增加&lt;code&gt;scope&lt;/code&gt;为&lt;code&gt;offline_access&lt;/code&gt;，并且需要设置客户端支持，因此&lt;code&gt;AllowOfflineAccess&lt;/code&gt;属性需要设置为&lt;code&gt;True&lt;/code&gt;，现在来测试下获取的授权结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225103752-1081408298.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终完成了&lt;code&gt;refresh_token&lt;/code&gt;的获取，至此整个密码授权模式全部讲解并实现完成。&lt;/p&gt;
&lt;h2 id=&quot;五总结及思考&quot;&gt;五、总结及思考&lt;/h2&gt;
&lt;p&gt;本篇文章我们从密码授权模式使用场景、源码剖析、自定义用户授权来讲解了密码授权模式的详细思路和代码实现，从中不难发现&lt;code&gt;Ids4&lt;/code&gt;设计的巧妙，在默认实现的同时也预留了很多自定义扩展，本篇的自定义用户体系也是重新实现接口然后注入就完成集成工作。本篇主要难点就是要理解&lt;code&gt;Ids4&lt;/code&gt;的实现思路和数据库的相关配置，希望通过本篇的讲解让我们熟练掌握密码验证的流程，便于应用到实际生产环境。&lt;/p&gt;
&lt;p&gt;上篇的客户端授权模式和本篇的密码授权模式都讲解完可能有人会存在以下几个疑问。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如何校验令牌信息的有效性？&lt;/li&gt;
&lt;li&gt;2、如何强制有效令牌过期？&lt;/li&gt;
&lt;li&gt;3、如何实现单机登录？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下篇文章我将会从这3个疑问出发，来详细讲解下这三个问题的实现思路和代码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225122662-109340743.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 14:52:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/10140688.html</dc:identifier>
</item>
<item>
<title>Audio Bandwidth Extension - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/10129271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/10129271.html</guid>
<description>&lt;p&gt;&lt;span&gt;论文和代码都在这个&lt;a href=&quot;https://github.com/SomeshGanesh94/Audio-Bandwidth-Extension&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者：Somesh Ganesh；单位：Georgia Tech Center for Music Technology，Georgia Institute of Technology；Email:someshg94@gatech.edu&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　音频带宽扩展是一种利用各种音频编解码器提高有限频带音频感知质量的技术。本文提出了几种音频带宽扩展的方法，并通过听力测试对其进行了评估。比较了半波校正和全波校正，以及子带滤波的应用。结果表明，采用子带滤波的半波校正是测试算法中的最佳技术。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在当今世界里有很多频带受限的音频，这主要是由于以下原因。信号的数字化要求对模拟信号进行采样。当模拟到数字转换器中的采样率不高时，就会产生混叠现象。为了避免这一点，反混叠滤波实现作为预处理步骤。这些滤波器基本上是低通滤波器，限制着信号的带宽。存在大量带宽被限音频的另一个原因是因为音频编解码器实现的算法，&lt;/span&gt;&lt;span&gt;为了增加存储，音频编解码器利用这样的事实：与低频分量相比，人类对高频分量不太敏感，因此舍去了音频文件的高频分量。这样的做法可以提高存储量，并能显著提高比特率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　频带限制降低了音频的质量。因此，需要开发一种音频带宽扩展算法来恢复原始音频质量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　让我们首先把相关工作分为两大类：盲源频带扩展和非盲源频带扩展。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;A、非盲源带宽扩展&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　非盲带宽扩展是指利用特定的编码和解码技术重建缺失频谱的过程。这包括一些时域或频率信息、噪声水平或在对信号进行编码时缺失的频率分量以及低频分量有关的任何其他相关信息。最著名的非盲源带宽扩展算法之一是频谱折叠(SBR)&lt;sup&gt;[1]&lt;/sup&gt;。该方法有自己的编解码器，其工作原理是假设低频分量与高频分量有很强的相关性。利用逆滤波、自适应加噪和正弦再生等技术，对相关系数较低的信号进行了分析。&lt;sup&gt;[2]&lt;/sup&gt;提出了一种利用分形自相似模型(FSSM)对音频信号进行修正离散余弦变换(MDCT)表示的算法。&lt;/span&gt;&lt;span&gt;该方法用于多种音频信号，并对缺失频谱进行了细节的重建。[3]引入精确谱替换(ASR)技术，对缺失频谱中的色调分量和谐波结构进行重建。&lt;sup&gt;[4]&lt;/sup&gt;使用[2]和[3]中的概念，并将它们应用于信号的高频分辨率表示，如MDCT。它还包括“多波段时域幅度编码”(Mbtac)，用于重构高频分量的时间整形。&lt;span&gt;这些方法的问题在于，该过程需要额外的信道资源来传输有关缺失频谱的信息&lt;/span&gt;。当对比特率和存储有限制时，这是不可取的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、盲源带宽扩展&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　盲源带宽扩展是指在没有任何缺失频谱的前提情况下进行重建的过程。&lt;sup&gt;[5]&lt;/sup&gt;提出了一种基于半波整流的盲源带宽扩展算法。该方法对带限信号中的最高倍频程采用半波整流法，产生高频谱。这个新的频谱通过增益因子进行缩放，并被添加到延迟输入信号中。[6]通过提出一种不同的过滤最高倍频程的方法来优化这一过程以实现实时应用。该方法还包括作为预处理步骤的带宽检测模块和作为后处理步骤的自适应增益。[7]和[8]建议采用线性外推法求出高频谱的包络并进行重构。文[9]中的算法是基于相位空间重构(PSR)的方法。这里，PSR被用来将宽带音频的低频MDCT系数转换成多维空间。高频频谱根据听者的感知进行调整。这包括线性和非线性预测。[10]提出了基于混沌预测理论的算法，并建议根据音频产生原理和人耳知觉生成高频信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本论文所使用的算法是一种盲带宽扩展算法。这是因为目前频带受限的音频数据集很大并且没有原始音频。在这种情况下，非盲源频带扩展不会有多大作用。首先&lt;/span&gt;&lt;span&gt;让我们简要地看一下图一中实现的系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181218163249342-1527418028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1：算法概述&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;A、滤波器1&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一部分包括对频带受限音频进行的滤波操作。在此过程中，提取信号的最高倍频程。假设信号中的最高频率分量是$f_{hf}$。现在，假设信号中的采样频率$fs≥4*f_{hf}$，这可以通过采样作为预处理步骤。信号中的最高倍频程在$\frac{f_{hf}}{2}-f_{hf}$之间。使用非线性设备在下一模块中用滤波后的信号来生成缺失的高频谱。&lt;/span&gt;&lt;span&gt;非线性器件产生互调失真(在下一节中定义)。为了研究这种失真对系统质量的影响，我们设计了两个不同版本的该模块。&lt;/span&gt;&lt;span&gt;第一版本是一个简单的IIR(无限脉冲响应)带通滤波器，它允许$\frac{f_{hf}}{2}-f_{hf}$范围的频率通过。&lt;/span&gt;&lt;span&gt;互调失真随频率分量的增加而增加。因此，第二个版本是两个IIR带通滤波器的组合，其中第一个滤除信号中最高倍频程的一半，而另一个滤除另一半。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、非线性设备 Non-Linear Device(NLD)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　该部分由非线性设备组成，该设备利用来自向前模块滤波后的信号产生高频谱。这部分产生信号的高频谐波。&lt;/span&gt;&lt;span&gt;在这里，我们使用了两个非线性设备。一个是半波整流器，另一个是全波整流器。&lt;/span&gt;&lt;span&gt;我们选择了整改，因为这是一个均匀的过程。整流器的输出主要是输入频率的二次谐波，二次谐波的衰减为12dB每倍频程。&lt;/span&gt;&lt;span&gt;半波整流输出的频谱由原始输入频率和所有谐波组成。另一方面，全波整流输出的频谱仅由输入频率的谐波组成。&lt;/span&gt;&lt;span&gt;我们对谐波的产生感兴趣，&lt;/span&gt;&lt;span&gt;我们感兴趣的是产生下一次谐波，即$f_{hf}-2*f_{hf}$之间的频谱。接下来，让我们来定义互调失真(IMD)。当一个频率分量由两个或两个以上的频率分量组成，经过非线性设备运算时，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个由两个或多个频率分量组成的信号经过非线性运算时，输出不仅包含这些频率分量，而且还包含几个不理想的分量，这些分量基本上是输入分量的总和差。输出中的这种失真称为互调失真。本文研究了半波互调失真和全波整流对重建音频信号主观质量的影响。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;C、滤波器2&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一部分在非线性设备模块后面，我们之前的模块仅关注高频谱的生成，经过前一步的整流之后，&lt;/span&gt;&lt;span&gt;高频分量将主要包含输入频率分量的二次谐波。由于互调失真，会出现低于$f_{hf}$和高于$2*f_{hf}$的不良成分。这些分量需要消除。因此，目标信号将位于$f_{hf}$和$2*f_{hf}$之间。在这个阶段，这些边界之间的信号将被过滤掉。类似于滤波器1模块，这个模块我们有来两个版本。第一个版本将包含一个简单的IIR带通滤波器，它将滤除$f_{hf}$和$2*f_{hf}$之间的信号。第二个版本包含两个独立的IIR带通滤波器。当使用第二版本的滤波器1时，再使用这个版本的滤波器。第一个滤波器将会滤除第二版本滤波器1的输入频率的二次谐波&lt;/span&gt;&lt;span&gt;。第二滤波器将会滤除滤波器1中第二版本的第二滤波器输入频率产生的二次谐波&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;这样可以增加这两个滤波器的输出，使我们得到完整的重构高频谱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，将产生的高频频谱添加到输入中，输入延迟的量相当于产生频谱所需的时间。因此，我们最终有频带扩展的信号。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;A、试验方法与技术&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在评估方面，进行听力测试来证明带宽扩展音频的主观质量。实验数据集是用一个简单的IIR低通滤波器生成的。五首歌来自不同的流派-电子，摇滚，电子屋，声学和世界音乐。所有音频文件的采样频率都为44.1kHz，带宽限制为7 kHz。每个文件都有20秒长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于听力测试，进行了MUSHRA[11]样试验。首先让参与者听到原始的音频文件(参考)，然后是带宽受限的音频文件。之后，他们按随机顺序听到五个音频文件，其中包括一个隐藏的参考音频。另外四个音频文件是使用上述算法经过频带扩展的音频文件。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;半波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的半波校正&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的全波校正&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;然后对这些音频文件的评分按1到10划分等级，&lt;/span&gt;&lt;span&gt;1是感知质量的最差的等级，10是感知质量的最好的等级。重复播放这5首歌，&lt;/span&gt;&lt;span&gt;所有音频文件的响度均方值标准化为0.7。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中一首歌曲的所有5个音频文件的频谱图图以及频带受限信号如下图2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000019385-2056188127.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2a，原始语音信号(参考信号)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000049754-380266220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2b：频带受限语音信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000247648-1732939561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2c：半波整流重建后的信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000617779-67617014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2d：半波整流和子带滤波重建信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000637069-410966795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2e：全波整流重建信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000657850-104201475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2f：全波整流和子带滤波重建信号&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　测试有6名参与者。记录结果，计算评分均值。这些数字列于表1。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000925502-980263652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1：评估方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从结果可以看出，原始音频文件(参考)获得最高的评分。这就告诉我们，参与者给出的评分是真实的，是可以考虑的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217001147022-2069259279.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3：评估方法的柱形图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从图3中的条形图中，我们可以看到原始音频文件比带宽扩展后的音频文件具有更好的质量。我们还可以看到，在算法中使用子带滤波对音频文件的主观质量有积极的影响。使用简单的全波整流做音频扩展得到的音频文件中发现，在所有音频文件中，感知质量的得分最少。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　首先，对本文提出的算法和实验结果进行了讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结果表明，采用子带滤波可以降低重建输出的互调失真，因此具有较高的主观的得分。我们还可以得出结论，与全波整流相比，半波整流是一种更好的方法。根据所收到的评分，我们可以根据感知质量的得分对算法进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;基于子带滤波的半波整流&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的全波整流&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;半波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全波整流;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　这些结果验证了文献[6]所提出的方法，即子带滤波的使用预期具有较高的感知质量，但是未与文献[5]中使用的一般滤波技术相比较。本文还比较了半波整流与全波整流对感知质量的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，让我们来讨论一下本文提出的算法和实验的缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、该算法只有当频带限制音频信号$f_{hf}=\frac{f_s}{4}$中存在最高频率的情况下，才能将频谱重构到最大极限$\frac{fs}{2}$。如果$f_{hf}&amp;lt;\frac{f_s}{4}$，如图2所示，我们无法在最大范围内重建高频频谱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、所进行的实验只有很少的参与者和一个很小的数据集。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文可作为今后音频带宽扩展工作的基本框架。以下是本文算法和实验的改进和扩展。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;高频谱的重建可以独立于频带受限音频中的最高频率。这将允许适当的重建，即使信号中的最高频率很低，即在5-7kHz的范围内。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在本文中由于在非线性设备模块中只使用了两种不同的整流器，因此可以对不同的非线性设备(如积分器)进行进一步的研究。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;整个系统可以进一步优化，以更好地实时工作。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　本文对不同的音频带宽扩展方法进行了比较，并通过听力测试对结果进行了评价。实验结果表明，半波整流作为一种非线性设备，其校正效果优于全波整流，采用子带滤波可以提高带宽扩展信号的感知质量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;[1] P. Ekstrand, “Bandwidth extension of audio signals by spectral band replication,” in Proceedings of the 1st IEEE Benelux Workshop on Model Based Processing and Coding of Audio (MPCA ’02, 2002.)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2] Deepen Sinha, Anibal Ferreira, and, Deep Sen “A Fractal Self-Similarity Model for the Spectral Representation of Audio Signals,” 118th Convention of the Audio Engineering Society, May 2005, Paper 6467.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[3] Anibal J. S. Ferreira and Deepen Sinha, “Accurate Spectral Replacement,” 118th Convention of the Audio Engineering Society, May 2005, Paper 6383.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[4] H. E. V., A. J. S. Ferreira, and D. Sinha, “A Novel Integrated Audio Bandwidth Extension Toolkit (ABET),” presented at the Audio Engineering Society Convention 120, 2006.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[5] E. Larsen, R. M. Aarts, and M. Danessis, “Efficient High-frequency Bandwidth Extension of Music and Speech,” presented at the Audio Engineering Society Convention 112, 2002.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[6] M. Arora, J. Lee, and S. Park, “High Quality Blind Bandwidth Extension of Audio for Portable Player Applications,” presented at the Audio Engineering Society Convention 120, 2006.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[7] C.-M. Liu, W.-C. Lee, and H.-W. Hsu, “High Frequency Reconstruction for Band-Limited Audio Signals,” in Proceedings of the 6th International Conference on Digital Audio Effects (DAFX-03), 2003.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[8] “AES E-Library » High Frequency Reconstruction by Linear Extrapolation.” [Online]. Available: http://www.aes.org/elib/browse.cfm?elib=12426.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[9] C.-C. Bao, X. Liu, Y.-T. Sha, and X.-T. Zhang, “A blind bandwidth extension method for audio signals based on phase space reconstruction,” EURASIP Journal on Audio, Speech, and Music Processing, vol. 2014, no. 1, p. 1, 2014.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[10] Y. T Sha, C. C Bao, M. S Jia, and X. Liu, “High frequency reconstruction of audio signal based on chaotic prediction theory,” in 2010 IEEE International Conference on Acoustics, Speech and Signal Processing, 2010, pp. 381–384.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[11] The MUSHRA audio subjective test method - BBC R&amp;amp;D, 2002.&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 14:12:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>论文和代码都在这个地址。 作者：Somesh Ganesh；单位：Georgia Tech Center for Music Technology，Georgia Institute of Techn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LXP-Never/p/10129271.html</dc:identifier>
</item>
</channel>
</rss>