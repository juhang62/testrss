<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【项目实践】一文带你搞定Spring Security + JWT - RudeCrab</title>
<link>http://www.cnblogs.com/RudeCrab/p/14265273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RudeCrab/p/14265273.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085019858-1640273167.jpg&quot; alt=&quot;首图.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以项目驱动学习，以实践检验真知&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于认证和授权，R之前已经写了两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/RudeCrab/p/14251154.html&quot; target=&quot;_blank&quot;&gt;📖【项目实践】在用安全框架前，我想先让你手撸一个登陆认证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/RudeCrab/p/14251274.html&quot; target=&quot;_blank&quot;&gt;📖【项目实践】一文带你搞定页面权限、按钮权限以及数据权限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这两篇文章中我们没有使用安全框架就搞定了认证和授权功能，并理解了其核心原理。R在之前就说过，核心原理掌握了，无论什么安全框架使用起来都会非常容易！那么本文就讲解如何使用主流的安全框架Spring Security来实现认证和授权功能。&lt;/p&gt;
&lt;p&gt;当然，本文并不只是对框架的使用方法进行讲解，还会剖析Spring Security的源码，看到最后你就会发现你掌握了使用方法的同时，还对框架有了深度的理解！如果没有看过前两篇文章的，强烈建议先看一下，因为安全框架只是帮我们封装了一些东西，背后的原理是不会变的。&lt;/p&gt;
&lt;p&gt;本文所有代码都放在了&lt;a href=&quot;https://github.com/RudeCrab/rude-java&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;上，克隆下来即可运行！&lt;/p&gt;

&lt;p&gt;Web系统中登录认证（Authentication）的核心就是&lt;strong&gt;凭证&lt;/strong&gt;机制，无论是&lt;code&gt;Session&lt;/code&gt;还是&lt;code&gt;JWT&lt;/code&gt;，都是在用户成功登录时返回给用户一个凭证，后续用户访问接口需携带凭证来标明自己的身份。后端会对需要进行认证的接口进行安全判断，若凭证没问题则代表已登录就放行接口，若凭证有问题则直接拒绝请求。这个安全判断&lt;strong&gt;都是放在过滤器里统一处理的&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085020523-530662725.jpg&quot; alt=&quot;认证过滤器.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录认证是对&lt;strong&gt;用户的身份&lt;/strong&gt;进行确认，权限授权（Authorization）是对&lt;strong&gt;用户能否访问某个资源&lt;/strong&gt;进行确认，授权发生都认证之后。 认证一样，这种通用逻辑都是放在过滤器里进行的统一操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085021023-973338173.jpg&quot; alt=&quot;授权过滤器.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoginFilter&lt;/code&gt;先进行登录认证判断，认证通过后再由&lt;code&gt;AuthFilter&lt;/code&gt;进行权限授权判断，一层一层没问题后才会执行我们真正的业务逻辑。&lt;/p&gt;
&lt;p&gt;Spring Security对Web系统的支持&lt;strong&gt;就是基于这一个个过滤器组成的过滤器链&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085021940-256434050.jpg&quot; alt=&quot;过滤器链.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户请求都会经过&lt;code&gt;Servlet&lt;/code&gt;的过滤器链，在之前两篇文章中我们就是通过自定义的两个过滤器实现了认证授权功能！而Spring Security也是做的同样的事完成了一系列功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085022237-320474672.jpg&quot; alt=&quot;自定义过滤器链.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Servlet&lt;/code&gt;过滤器链中，Spring Security向其添加了一个&lt;code&gt;FilterChainProxy&lt;/code&gt;过滤器，这个代理过滤器会创建一套Spring Security自定义的过滤器链，然后执行一系列过滤器。我们可以大概看一下&lt;code&gt;FilterChainProxy&lt;/code&gt;的大致源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void doFilter(ServletRequest request, ServletResponse response,
                     FilterChain chain) throws IOException, ServletException {
    ...省略其他代码
    
    // 获取Spring Security的一套过滤器
    List&amp;lt;Filter&amp;gt; filters = getFilters(request);
    // 将这一套过滤器组成Spring Security自己的过滤链，并开始执行
    VirtualFilterChain vfc = new VirtualFilterChain(fwRequest, chain, filters);
    vfc.doFilter(request, response);
    
    ...省略其他代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下Spring Security默认会启用多少过滤器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085023600-961373993.jpg&quot; alt=&quot;seucirty默认过滤器链.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面我们只需要重点关注两个过滤器即可：&lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;负责登录认证，&lt;code&gt;FilterSecurityInterceptor&lt;/code&gt;负责权限授权。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;💡Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security&lt;/strong&gt;！这个框架的使用方式就是对这些过滤器和组件进行扩展。&lt;/p&gt;
&lt;p&gt;一定要记住这句话，带着这句话去使用和理解Spring Security，你会像站在高处俯瞰，整个框架的脉络一目了然。&lt;/p&gt;
&lt;p&gt;刚才我们总览了一下全局，现在我们就开始进行代码编写了。&lt;/p&gt;
&lt;p&gt;要使用Spring Security肯定是要先引入依赖包（Web项目其他必备依赖我在之前文章中已讲解，这里就不过多阐述了）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖包导入后，Spring Security就默认提供了许多功能将整个应用给保护了起来：&lt;/p&gt;
&lt;p&gt;📝要求经过身份验证的用户才能与应用程序进行交互&lt;/p&gt;
&lt;p&gt;📝创建好了默认登录表单&lt;/p&gt;
&lt;p&gt;📝生成用户名为&lt;code&gt;user&lt;/code&gt;的随机密码并打印在控制台上&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;CSRF&lt;/code&gt;攻击防护、&lt;code&gt;Session Fixation&lt;/code&gt;攻击防护&lt;/p&gt;
&lt;p&gt;📝等等等等......&lt;/p&gt;
&lt;p&gt;在实际开发中，这些&lt;strong&gt;默认配置好的功能往往不符合我们的实际需求，所以我们一般会自定义一些配置&lt;/strong&gt;。配置方式很简单，新建一个配置类即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该类中重写&lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt;的方法就能对Spring Security进行自定义配置。&lt;/p&gt;

&lt;p&gt;依赖包和配置类准备好后，接下来我们要完成的第一个功能那自然是登录认证，毕竟用户要使用我们系统第一步就是登录。之前文章介绍了&lt;code&gt;Session&lt;/code&gt;和&lt;code&gt;JWT&lt;/code&gt;两种认证方式，这里我们来用Spring Security实现这两种认证。&lt;/p&gt;
&lt;h2 id=&quot;最简单的认证方式&quot;&gt;最简单的认证方式&lt;/h2&gt;
&lt;p&gt;不管哪种认证方式和框架，有些核心概念是不会变的，这些核心概念在安全框架中会以各种组件来体现，了解各个组件的同时功能也就跟着实现了功能。&lt;/p&gt;
&lt;p&gt;我们系统中会有许多用户，确认当前是哪个用户正在使用我们系统就是登录认证的最终目的。这里我们就提取出了一个核心概念：&lt;strong&gt;当前登录用户/当前认证用户&lt;/strong&gt;。整个系统安全都是围绕当前登录用户展开的！这个不难理解，要是当前登录用户都不能确认了，那A下了一个订单，下到了B的账户上这不就乱套了。这一概念在Spring Security中的体现就是 &lt;strong&gt;💡&lt;code&gt;Authentication&lt;/code&gt;&lt;/strong&gt;，它存储了认证信息，代表当前登录用户。&lt;/p&gt;
&lt;p&gt;我们在程序中如何获取并使用它呢？我们需要通过 &lt;strong&gt;&lt;code&gt;💡SecurityContext&lt;/code&gt;&lt;/strong&gt; 来获取&lt;code&gt;Authentication&lt;/code&gt;，看了之前文章的朋友大概就猜到了这个&lt;code&gt;SecurityContext&lt;/code&gt;就是我们的上下文对象！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这种在一个线程中横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context）。上下文对象是非常有必要的，否则你每个方法都得额外增加一个参数接收对象，实在太麻烦了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个上下文对象则是交由 &lt;strong&gt;💡&lt;code&gt;SecurityContextHolder&lt;/code&gt;&lt;/strong&gt; 进行管理，你可以在程序&lt;strong&gt;任何地方&lt;/strong&gt;使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到调用链路是这样的：&lt;code&gt;SecurityContextHolder&lt;/code&gt;👉&lt;code&gt;SecurityContext&lt;/code&gt;👉&lt;code&gt;Authentication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SecurityContextHolder&lt;/code&gt;原理非常简单，就是和我们之前实现的上下文对象一样，使用&lt;code&gt;ThreadLocal&lt;/code&gt;来保证一个线程中传递同一个对象！源码我就不贴了，具体可看之前文章写的上下文对象实现。&lt;/p&gt;
&lt;p&gt;现在我们已经知道了Spring Security中三个核心组件：&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;Authentication&lt;/code&gt;：存储了认证信息，代表当前登录用户&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;SeucirtyContext&lt;/code&gt;：上下文对象，用来获取&lt;code&gt;Authentication&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;SecurityContextHolder&lt;/code&gt;：上下文管理对象，用来在程序任何地方获取&lt;code&gt;SecurityContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;他们关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085024357-410977701.jpg&quot; alt=&quot;securitycontextholder.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Authentication&lt;/code&gt;中那三个玩意就是认证信息：&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;Principal&lt;/code&gt;：用户信息，没有认证时一般是用户名，认证后一般是用户对象&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;Credentials&lt;/code&gt;：用户凭证，一般是密码&lt;/p&gt;
&lt;p&gt;📝&lt;code&gt;Authorities&lt;/code&gt;：用户权限&lt;/p&gt;
&lt;p&gt;现在我们知道如何获取并使用当前登录用户了，那这个用户是怎么进行认证的呢？总不能我随便new一个就代表用户认证完毕了吧。所以我们还缺一个生成&lt;code&gt;Authentication&lt;/code&gt;对象的认证过程！&lt;/p&gt;
&lt;p&gt;认证过程就是登录过程，不使用安全框架时咱们的认证过程是这样的：&lt;/p&gt;
&lt;p&gt;查询用户数据👉判断账号密码是否正确👉正确则将用户信息存储到上下文中👉上下文中有了这个对象则代表该用户登录了&lt;/p&gt;
&lt;p&gt;Spring Security的认证流程也是如此：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Authentication authentication = new UsernamePasswordAuthenticationToken(用户名, 用户密码, 用户的权限集合);
SecurityContextHolder.getContext().setAuthentication(authentication);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和不使用安全框架一样，将认证信息放到上下文中就代表用户已登录。上面代码演示的就是Spring Security最简单的认证方式，直接将&lt;code&gt;Authentication&lt;/code&gt;放置到&lt;code&gt;SecurityContext&lt;/code&gt;中就完成认证了！&lt;/p&gt;
&lt;p&gt;这个流程和之前获取当前登录用户的流程自然是相反的：&lt;code&gt;Authentication&lt;/code&gt;👉&lt;code&gt;SecurityContext&lt;/code&gt;👉&lt;code&gt;SecurityContextHolder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;是不是觉得，就这？这就完成认证啦？这也太简单了吧。对于Spring Security来说，这样确实就完成了认证，但对于我们来说还少了一步，那就是判断用户的账号密码是否正确。用户进行登录操作时从会传递过来账号密码，我们肯定是要查询用户数据然后判断传递过来的账号密码是否正确，只有正确了咱们才会将认证信息放到上下文对象中，不正确就直接提示错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 调用service层执行判断业务逻辑
if (!userService.login(用户名, 用户密码)) {
    return &quot;账号密码错误&quot;;
}
// 账号密码正确了才将认证信息放到上下文中（用户权限需要再从数据库中获取，后面再说，这里省略）
Authentication authentication = new UsernamePasswordAuthenticationToken(用户名, 用户密码, 用户的权限集合);
SecurityContextHolder.getContext().setAuthentication(authentication);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样才算是一个完整的认证过程，和不使用安全框架时的流程是一样的哦，只是一些组件之前是我们自己实现的。&lt;/p&gt;
&lt;p&gt;这里查询用户信息并校验账号密码是完全由我们自己在业务层编写所有逻辑，其实这一块Spring Security也有组件供我们使用：&lt;/p&gt;
&lt;h2 id=&quot;authenticationmanager认证方式&quot;&gt;AuthenticationManager认证方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;💡&lt;code&gt;AuthenticationManager&lt;/code&gt;&lt;/strong&gt; 就是Spring Security用于执行身份验证的组件，只需要调用它的&lt;code&gt;authenticate&lt;/code&gt;方法即可完成认证。Spring Security默认的认证方式就是在&lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;这个过滤器中调用这个组件，该过滤器负责认证逻辑。&lt;/p&gt;
&lt;p&gt;我们要按照自己的方式使用这个组件，先在之前配置类配置一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们写上完整的登录接口代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(&quot;/API&quot;)
public class LoginController {
    @Autowired
    private AuthenticationManager authenticationManager;

    @PostMapping(&quot;/login&quot;)
    public String login(@RequestBody LoginParam param) {
        // 生成一个包含账号密码的认证信息
        Authentication token = new UsernamePasswordAuthenticationToken(param.getUsername(), param.getPassword());
        // AuthenticationManager校验这个认证信息，返回一个已认证的Authentication
        Authentication authentication = authenticationManager.authenticate(token);
        // 将返回的Authentication存到上下文中
        SecurityContextHolder.getContext().setAuthentication(authentication);
        return &quot;登录成功&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，这里流程和之前说的流程是完全一样的，只是用户身份验证改成了使用&lt;code&gt;AuthenticationManager&lt;/code&gt;来进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;的校验逻辑非常简单：&lt;/p&gt;
&lt;p&gt;根据用户名先查询出用户对象(没有查到则抛出异常)👉将用户对象的密码和传递过来的密码进行校验，密码不匹配则抛出异常&lt;/p&gt;
&lt;p&gt;这个逻辑没啥好说的，再简单不过了。重点是这里每一个步骤Spring Security都提供了组件：&lt;/p&gt;
&lt;p&gt;📝是谁执行 &lt;strong&gt;根据用户名查询出用户对象&lt;/strong&gt; 逻辑的呢？用户对象数据可以存在内存中、文件中、数据库中，你得确定好怎么查才行。这一部分就是交由&lt;strong&gt;💡&lt;code&gt;UserDetialsService&lt;/code&gt;&lt;/strong&gt; 处理，该接口只有一个方法&lt;code&gt;loadUserByUsername(String username)&lt;/code&gt;，通过用户名查询用户对象，默认实现是在内存中查询。&lt;/p&gt;
&lt;p&gt;📝那查询出来的 &lt;strong&gt;用户对象&lt;/strong&gt; 又是什么呢？每个系统中的用户对象数据都不尽相同，咱们需要确认我们的用户数据是啥样的才行。Spring Security中的用户数据则是由&lt;strong&gt;💡&lt;code&gt;UserDetails&lt;/code&gt;&lt;/strong&gt;来体现，该接口中提供了账号、密码等通用属性。&lt;/p&gt;
&lt;p&gt;📝&lt;strong&gt;对密码进行校验&lt;/strong&gt;大家可能会觉得比较简单，&lt;code&gt;if、else&lt;/code&gt;搞定，就没必要用什么组件了吧？但框架毕竟是框架考虑的比较周全，除了&lt;code&gt;if、else&lt;/code&gt;外还解决了密码加密的问题，这个组件就是&lt;strong&gt;💡&lt;code&gt;PasswordEncoder&lt;/code&gt;&lt;/strong&gt;，负责密码加密与校验。&lt;/p&gt;
&lt;p&gt;我们可以看下&lt;code&gt;AuthenticationManager&lt;/code&gt;校验逻辑的大概源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Authentication authenticate(Authentication authentication) throws AuthenticationException {
    ...省略其他代码
    
    // 传递过来的用户名
    String username = authentication.getName();
    // 调用UserDetailService的方法，通过用户名查询出用户对象UserDetail（查询不出来UserDetailService则会抛出异常）
    UserDetails userDetails = this.getUserDetailsService().loadUserByUsername(username);
    String presentedPassword = authentication.getCredentials().toString();
        
    // 传递过来的密码
    String password = authentication.getCredentials().toString();
    // 使用密码解析器PasswordEncoder传递过来的密码是否和真实的用户密码匹配
    if (!passwordEncoder.matches(password, userDetails.getPassword())) {
        // 密码错误则抛出异常
        throw new BadCredentialsException(&quot;错误信息...&quot;);
    }
    
    // 注意哦，这里返回的已认证Authentication，是将整个UserDetails放进去充当Principal
    UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(userDetails,
                                authentication.getCredentials(), userDetails.getAuthorities());
        return result;
    
    ...省略其他代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UserDetialsService&lt;/code&gt;👉&lt;code&gt;UserDetails&lt;/code&gt;👉&lt;code&gt;PasswordEncoder&lt;/code&gt;，这三个组件Spring Security都有默认实现，这一般是满足不了我们的实际需求的，所以这里我们自己来实现这些组件！&lt;/p&gt;
&lt;h3 id=&quot;加密器passwordencoder&quot;&gt;加密器PasswordEncoder&lt;/h3&gt;
&lt;p&gt;首先是&lt;code&gt;PasswordEncoder&lt;/code&gt;，这个接口很简单就两个重要方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface PasswordEncoder {
    /**
         * 加密
         */
    String encode(CharSequence rawPassword);
    /**
         * 将未加密的字符串（前端传递过来的密码）和已加密的字符串（数据库中存储的密码）进行校验
         */
    boolean matches(CharSequence rawPassword, String encodedPassword);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以实现此接口定义自己的加密规则和校验规则，不过Spring Security提供了很多加密器实现，我们这里选定一个就好。可以在之前所说的&lt;strong&gt;配置类&lt;/strong&gt;里进行如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public PasswordEncoder passwordEncoder() {
    // 这里我们使用bcrypt加密算法，安全性比较高
    return new BCryptPasswordEncoder();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为密码加密是我前面文章少数没有介绍的功能，所以这里额外提一嘴。往数据库中添加用户数据时就要将密码进行加密，否则后续进行密码校验时从数据库拿出来的还是明文密码，是无法通过校验的。比如我们有一个用户注册的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private PasswordEncoder passwordEncoder;

@PostMapping(&quot;/register&quot;)
public String register(@RequestBody UserParam param) {
    UserEntity user = new UserEntity();
    // 调用加密器将前端传递过来的密码进行加密
    user.setUsername(param.getUsername()).setPassword(passwordEncoder.encode(param.getPassword()));
    // 将用户实体对象添加到数据库
    userService.save(user);
    return &quot;注册成功&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样数据库中存储的密码都是已加密的了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085024631-87486152.jpg&quot; alt=&quot;密码加密.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户对象userdetails&quot;&gt;用户对象UserDetails&lt;/h3&gt;
&lt;p&gt;该接口就是我们所说的用户对象，它提供了用户的一些通用属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserDetails extends Serializable {
   /**
    * 用户权限集合（这个权限对象现在不管它，到权限时我会讲解）
    */
   Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities();
   /**
    * 用户密码
    */
   String getPassword();
   /**
    * 用户名
    */
   String getUsername();
   /**
    * 用户没过期返回true，反之则false
    */
   boolean isAccountNonExpired();
   /**
    * 用户没锁定返回true，反之则false
    */
   boolean isAccountNonLocked();
   /**
    * 用户凭据(通常为密码)没过期返回true，反之则false
    */
   boolean isCredentialsNonExpired();
   /**
    * 用户是启用状态返回true，反之则false
    */
   boolean isEnabled();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际开发中我们的用户属性各种各样，这些默认属性必然是满足不了，所以我们一般会自己实现该接口，然后设置好我们实际的用户实体对象。实现此接口要重写很多方法比较麻烦，我们可以继承Spring Security提供的&lt;code&gt;org.springframework.security.core.userdetails.User&lt;/code&gt;类，该类实现了&lt;code&gt;UserDetails&lt;/code&gt;接口帮我们省去了重写方法的工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserDetail extends User {
    /**
     * 我们自己的用户实体对象，要调取用户信息时直接获取这个实体对象。（这里我就不写get/set方法了）
     */
    private UserEntity userEntity;

    public UserDetail(UserEntity userEntity, Collection&amp;lt;? extends GrantedAuthority&amp;gt; authorities) {
        // 必须调用父类的构造方法，以初始化用户名、密码、权限
        super(userEntity.getUsername(), userEntity.getPassword(), authorities);
        this.userEntity = userEntity;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;业务对象userdetailsservice&quot;&gt;业务对象UserDetailsService&lt;/h3&gt;
&lt;p&gt;该接口很简单只有一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserDetailsService {
        /**
         * 根据用户名获取用户对象（获取不到直接抛异常）
         */
        UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;咱们自己的用户业务类该接口即可完成自己的逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class UserServiceImpl implements UserService, UserDetailsService {
    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) {
        // 从数据库中查询出用户实体对象
        UserEntity user = userMapper.selectByUsername(username);
        // 若没查询到一定要抛出该异常，这样才能被Spring Security的错误处理器处理
        if (user == null) {
            throw new UsernameNotFoundException(&quot;没有找到该用户&quot;);
        }
        // 走到这代表查询到了实体对象，那就返回我们自定义的UserDetail对象（这里权限暂时放个空集合，后面我会讲解）
        return new UserDetail(user, Collections.emptyList());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManager&lt;/code&gt;校验所调用的三个组件我们就已经做好实现了！&lt;/p&gt;
&lt;p&gt;不知道大家注意到没有，当我们查询用户失败时或者校验密码失败时都会抛出Spring Security的自定义异常。这些异常不可能放任不管，Spring Security对于这些异常都是在&lt;code&gt;ExceptionTranslationFilter&lt;/code&gt;过滤器中进行处理（可以回顾一下前面的过滤器截图），而&lt;strong&gt;💡&lt;code&gt;AuthenticationEntryPoint&lt;/code&gt;&lt;/strong&gt;则专门处理认证异常！&lt;/p&gt;
&lt;h3 id=&quot;认证异常处理器authenticationentrypoint&quot;&gt;认证异常处理器AuthenticationEntryPoint&lt;/h3&gt;
&lt;p&gt;该接口也只有一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface AuthenticationEntryPoint {
        /**
         * 接收异常并处理
         */
        void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来自定义一个类实现我们自己的错误处理逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException {
        response.setContentType(&quot;application/json;charset=utf-8&quot;);
        PrintWriter out = response.getWriter();
        // 直接提示前端认证错误
        out.write(&quot;认证错误&quot;);
        out.flush();
        out.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户传递过来账号密码👉认证校验👉异常处理，这一整套流程的组件我们就都给定义完了！现在只差最后一步，就是在Spring Security配置类里面进行一些配置，才能让这些生效。&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;Spring Security对哪些接口进行保护、什么组件生效、某些功能是否启用等等都需要在配置类中进行配置，注意看代码注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private UserServiceImpl userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 关闭csrf和frameOptions，如果不关闭会影响前端请求接口（这里不展开细讲了，感兴趣的自行了解）
        http.csrf().disable();
        http.headers().frameOptions().disable();
        // 开启跨域以便前端调用接口
        http.cors();

        // 这是配置的关键，决定哪些接口开启防护，哪些接口绕过防护
        http.authorizeRequests()
                // 注意这里，是允许前端跨域联调的一个必要配置
                .requestMatchers(CorsUtils::isPreFlightRequest).permitAll()
                // 指定某些接口不需要通过验证即可访问。登陆、注册接口肯定是不需要认证的
                .antMatchers(&quot;/API/login&quot;, &quot;/API/register&quot;).permitAll()
                // 这里意思是其它所有接口需要认证才能访问
                .anyRequest().authenticated()
                // 指定认证错误处理器
                .and().exceptionHandling().authenticationEntryPoint(new MyEntryPoint());
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 指定UserDetailService和加密器
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中用的最多的就是&lt;code&gt;configure(HttpSecurity http)&lt;/code&gt;方法，可以通过&lt;code&gt;HttpSecurity&lt;/code&gt; 进行许多配置。当我们重写这个方法时，就已经关闭了默认的表单登录方式，然后我们再配置好启用哪些组件、指定哪些接口需要认证，就搞定了！&lt;/p&gt;
&lt;p&gt;假设现在我们有一个&lt;code&gt;/API/test&lt;/code&gt;接口，在没有登录的时候调用该接口看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085025275-299247427.jpg&quot; alt=&quot;认证错误.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们登录一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085025620-1767401760.jpg&quot; alt=&quot;登录接口.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再调用测试接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085025963-327396699.jpg&quot; alt=&quot;认证通过.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到未登录时测试接口是无法正常访问的，会按照我们在&lt;code&gt;EntryPoint&lt;/code&gt;中的逻辑返回错误提示。&lt;/p&gt;
&lt;h3 id=&quot;总结和补充&quot;&gt;总结和补充&lt;/h3&gt;
&lt;p&gt;有人可能会问，用&lt;code&gt;AuthenticationManager&lt;/code&gt;认证方式要配置好多东西啊，我就用之前说的那种最简单的方式不行吗？当然是可以的啦，用哪种方式都随便，只要完成功能都行。其实不管哪种方式我们的认证的逻辑代码一样都没少，只不过一个是我们自己业务类全部搞定，一个是可以集成框架的组件。这里也顺带再总结一下流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户调进行登录操作，传递账号密码过来👉登录接口调用&lt;code&gt;AuthenticationManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据用户名查询出用户数据👉&lt;code&gt;UserDetailService&lt;/code&gt;查询出&lt;code&gt;UserDetails&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将传递过来的密码和数据库中的密码进行对比校验👉&lt;code&gt;PasswordEncoder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;校验通过则将认证信息存入到上下文中👉将&lt;code&gt;UserDetails&lt;/code&gt;存入到&lt;code&gt;Authentication&lt;/code&gt;，将&lt;code&gt;Authentication&lt;/code&gt;存入到&lt;code&gt;SecurityContext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果认证失败则抛出异常👉由&lt;code&gt;AuthenticationEntryPoint&lt;/code&gt;处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;刚才我们讲的认证方式都是基于&lt;code&gt;session&lt;/code&gt;机制，认证后Spring Security会将&lt;code&gt;Authentication&lt;/code&gt;存入到&lt;code&gt;session&lt;/code&gt;中，Key为&lt;code&gt;HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY&lt;/code&gt;。也就是说，你完全可以通过如下方式获取&lt;code&gt;Authentication&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Authentication = (Authentication)session.getAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，官方还是不推荐这样直接操作的，因为统一通过&lt;code&gt;SecurityContextHolder&lt;/code&gt;操作更利于管理！使用&lt;code&gt;SecurityContextHolder&lt;/code&gt;除了获取当前用户外，退出登录的操作也是很方便的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/logout&quot;)
public String logout() {
    SecurityContextHolder.clearContext();
    return &quot;退出成功&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;认证咱们就讲解到此，接下来咱们讲解&lt;code&gt;JWT&lt;/code&gt;的认证。&lt;/p&gt;
&lt;h2 id=&quot;jwt集成&quot;&gt;JWT集成&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;JWT&lt;/code&gt;的介绍和工具类等我在前面文章已经讲的很清楚了，这里我就不额外说明了，直接带大家实现代码。&lt;/p&gt;
&lt;p&gt;采用&lt;code&gt;JWT&lt;/code&gt;的方式进行认证首先做的第一步就是在配置类里禁用掉&lt;code&gt;session&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 禁用session
http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意，这里的禁用是指Spring Security不采用&lt;code&gt;session&lt;/code&gt;机制了，不代表你禁用掉了整个系统的&lt;code&gt;session&lt;/code&gt;功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们再修改一下登录接口，当用户登录成功的同时，我们需要生成&lt;code&gt;token&lt;/code&gt;并返回给前端，这样前端才能访问其他接口时携带&lt;code&gt;token&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private UserService userService;

@PostMapping(&quot;/login&quot;)
public UserVO login(@RequestBody @Validated LoginParam user) {
    // 调用业务层执行登录操作
    return userService.login(user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;业务层方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public UserVO login(LoginParam param) {
    // 根据用户名查询出用户实体对象
    UserEntity user = userMapper.selectByUsername(param.getUsername());
    // 若没有查到用户 或者 密码校验失败则抛出自定义异常
    if (user == null || !passwordEncoder.matches(param.getPassword(), user.getPassword())) {
        throw new ApiException(&quot;账号密码错误&quot;);
    }

    // 需要返回给前端的VO对象
    UserVO userVO = new UserVO();
    userVO.setId(user.getId())
        .setUsername(user.getUsername())
        // 生成JWT，将用户名数据存入其中
        .setToken(jwtManager.generate(user.getUsername()));
    return userVO;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行一下登录操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085026581-529786086.jpg&quot; alt=&quot;JWT登录.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到登录成功时接口会返回&lt;code&gt;token&lt;/code&gt;，后续我们再访问其它接口时需要将&lt;code&gt;token&lt;/code&gt;放到请求头中。这里我们需要自定义一个认证过滤器，来对&lt;code&gt;token&lt;/code&gt;进行校验：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class LoginFilter extends OncePerRequestFilter {
    @Autowired
    private JwtManager jwtManager;
    @Autowired
    private UserServiceImpl userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
        // 从请求头中获取token字符串并解析（JwtManager之前文章有详解，这里不多说了）
        Claims claims = jwtManager.parse(request.getHeader(&quot;Authorization&quot;));
        if (claims != null) {
            // 从`JWT`中提取出之前存储好的用户名
            String username = claims.getSubject();
            // 查询出用户对象
            UserDetails user = userService.loadUserByUsername(username);
            // 手动组装一个认证对象
            Authentication authentication = new UsernamePasswordAuthenticationToken(user, user.getPassword(), user.getAuthorities());
            // 将认证对象放到上下文中
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        chain.doFilter(request, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤器中的逻辑和之前介绍的&lt;strong&gt;最简单的认证方式&lt;/strong&gt;逻辑是一致的，每当一个请求来时我们都会校验&lt;code&gt;JWT&lt;/code&gt;进行认证，上下文对象中有了&lt;code&gt;Authentication&lt;/code&gt;后续过滤器就会知道该请求已经认证过了。&lt;/p&gt;
&lt;p&gt;咱们这个自定义的过滤器需要替换掉Spring Security默认的认证过滤器，这样我们的过滤器才能生效，所以我们需要进行如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 将我们自定义的认证过滤器替换掉默认的认证过滤器
http.addFilterBefore(loginFilter, UsernamePasswordAuthenticationFilter.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以断点调试看一下现在的过滤器是怎样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085027744-1007689107.jpg&quot; alt=&quot;自定义过滤器.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们自定义的过滤器已经替换掉了&lt;code&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;默认过滤器了！当我们携带&lt;code&gt;token&lt;/code&gt;访问接口时可以发现已经生效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085028108-609275994.jpg&quot; alt=&quot;JWT认证生效.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录认证到此就讲解完毕了，接下来我们一鼓作气来实现权限授权！&lt;/p&gt;

&lt;p&gt;菜单权限主要是通过前端渲染，数据权限主要靠&lt;code&gt;SQL&lt;/code&gt;拦截，和Spring Security没太大耦合，就不多展开了。我们来梳理一下&lt;strong&gt;接口权限&lt;/strong&gt;的授权的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当一个请求过来，我们先得知道这个请求的规则，即需要怎样的权限才能访问&lt;/li&gt;
&lt;li&gt;然后获取当前登录用户所拥有的权限&lt;/li&gt;
&lt;li&gt;再校验当前用户是否拥有该请求的权限&lt;/li&gt;
&lt;li&gt;用户拥有这个权限则正常返回数据，没有权限则拒绝请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;完成了登录认证功能后，想必大家已经有点感觉：Spring Security将流程功能分得很细，每一个小功能都会有一个组件专门去做，我们要做的就是去自定义这些组件！Spring Security针对上述流程也提供了许多组件。&lt;/p&gt;
&lt;p&gt;Spring Security的授权发生在&lt;code&gt;FilterSecurityInterceptor&lt;/code&gt;过滤器中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先调用的是&lt;strong&gt;💡&lt;code&gt;SecurityMetadataSource&lt;/code&gt;&lt;/strong&gt;，来获取当前请求的鉴权规则&lt;/li&gt;
&lt;li&gt;然后通过&lt;code&gt;Authentication&lt;/code&gt;获取当前登录用户所有权限数据：&lt;strong&gt;💡&lt;code&gt;GrantedAuthority&lt;/code&gt;&lt;/strong&gt;，这个我们前面提过，认证对象里存放这权限数据&lt;/li&gt;
&lt;li&gt;再调用&lt;strong&gt;💡&lt;code&gt;AccessDecisionManager&lt;/code&gt;&lt;/strong&gt; 来校验当前用户是否拥有该权限&lt;/li&gt;
&lt;li&gt;如果有就放行接口，没有则抛出异常，该异常会被&lt;strong&gt;💡&lt;code&gt;AccessDeniedHandler&lt;/code&gt;&lt;/strong&gt; 处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以来看一下过滤器里大概的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    ...省略其它代码
        
    // 这是Spring Security封装的对象，该对象里包含了request等信息
    FilterInvocation fi = new FilterInvocation(request, response, chain);
    // 这里调用了父类的AbstractSecurityInterceptor的方法,认证核心逻辑基本全在父类里
    InterceptorStatusToken token = super.beforeInvocation(fi);

    ...省略其它代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父类的&lt;code&gt;beforeInvocation&lt;/code&gt;大概源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected InterceptorStatusToken beforeInvocation(Object object) {
    ...省略其它代码
    
    // 调用SecurityMetadataSource来获取当前请求的鉴权规则，这个ConfigAttribue就是规则，后面我会讲
    Collection&amp;lt;ConfigAttribute&amp;gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object);
    // 如果当前请求啥规则也没有，就代表该请求无需授权即可访问，直接结束方法
    if (CollectionUtils.isEmpty(attributes)) {
        return null;
    }
    
    // 获取当前登录用户
    Authentication authenticated = authenticateIfRequired();
    // 调用AccessDecisionManager来校验当前用户是否拥有该权限，没有权限则抛出异常
    this.accessDecisionManager.decide(authenticated, object, attributes);
    
    ...省略其它代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老生常谈，核心流程都是一样的。我们接下来自定义这些组件，以完成我们自己的鉴权逻辑。&lt;/p&gt;

&lt;p&gt;该接口我们只需要关注一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SecurityMetadataSource {
        /**
         * 获取当前请求的鉴权规则
         
         * @param object 该参数就是Spring Security封装的FilterInvocation对象，包含了很多request信息
         * @return 鉴权规则对象
         */
        Collection&amp;lt;ConfigAttribute&amp;gt; getAttributes(Object object);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConfigAttribute&lt;/code&gt;就是我们所说的鉴权规则，该接口只有一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ConfigAttribute {
        /**
         * 这个字符串就是规则，它可以是角色名、权限名、表达式等等。
         * 你完全可以按照自己想法来定义，后面AccessDecisionManager会用这个字符串
         */
        String getAttribute();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在之前文章中我们授权的实现全是靠着资源&lt;code&gt;id&lt;/code&gt;，用户&lt;code&gt;id&lt;/code&gt;关联角色&lt;code&gt;id&lt;/code&gt;，角色&lt;code&gt;id&lt;/code&gt;关联资源&lt;code&gt;id&lt;/code&gt;，这样用户就相当于关联了资源，而我们接口资源在数据库中的体现是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085028739-216486441.jpg&quot; alt=&quot;资源表.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还是一样，我们照样以资源&lt;code&gt;id&lt;/code&gt;作为权限的标记。接下咱们就来自定义&lt;code&gt;SecurityMetadataSource&lt;/code&gt;组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MySecurityMetadataSource implements SecurityMetadataSource {
    /**
     * 当前系统所有接口资源对象，放在这里相当于一个缓存的功能。
     * 你可以在应用启动时将该缓存给初始化，也可以在使用过程中加载数据，这里我就不多展开说明了
     */
    private static final Set&amp;lt;Resource&amp;gt; RESOURCES = new HashSet&amp;lt;&amp;gt;();

    @Override
    public Collection&amp;lt;ConfigAttribute&amp;gt; getAttributes(Object object) {
        // 该对象是Spring Security帮我们封装好的，可以通过该对象获取request等信息
        FilterInvocation filterInvocation = (FilterInvocation) object;
        HttpServletRequest request = filterInvocation.getRequest();
        // 遍历所有权限资源，以和当前请求进行匹配
        for (Resource resource : RESOURCES) {
            // 因为我们url资源是这种格式：GET:/API/user/test/{id}，冒号前面是请求方法，冒号后面是请求路径，所以要字符串拆分
            String[] split = resource.getPath().split(&quot;:&quot;);
            // 因为/API/user/test/{id}这种路径参数不能直接equals来判断请求路径是否匹配，所以需要用Ant类来匹配
            AntPathRequestMatcher ant = new AntPathRequestMatcher(split[1]);
            // 如果请求方法和请求路径都匹配上了，则代表找到了这个请求所需的权限资源
            if (request.getMethod().equals(split[0]) &amp;amp;&amp;amp; ant.matches(request)) {
                // 将我们权限资源id返回，这个SecurityConfig就是ConfigAttribute一个简单实现
                return Collections.singletonList(new SecurityConfig(resource.getId().toString()));
            }
        }
        // 走到这里就代表该请求无需授权即可访问，返回空
        return null;
    }

    @Override
    public Collection&amp;lt;ConfigAttribute&amp;gt; getAllConfigAttributes() {
        // 不用管，这么写就行
        return null;
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; clazz) {
        // 不用管，这么写就行
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，我们这里返回的&lt;code&gt;ConfigAttribute&lt;/code&gt;鉴权规则，就是我们的资源&lt;code&gt;id&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;用户权限grantedauthority&quot;&gt;用户权限GrantedAuthority&lt;/h2&gt;
&lt;p&gt;该组件代表用户所拥有的权限，和&lt;code&gt;ConfigAttribute&lt;/code&gt;一样也只有一个方法，该方法返回的字符串就是代表着权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface GrantedAuthority extends Serializable {
        String getAuthority();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;GrantedAuthority&lt;/code&gt;和&lt;code&gt;ConfigAttribute&lt;/code&gt;一对比，就知道用户是否拥有某个权限了。&lt;/p&gt;
&lt;p&gt;Spring Security对&lt;code&gt;GrantedAuthority&lt;/code&gt;有一个简单实现&lt;code&gt;SimpleGrantedAuthority&lt;/code&gt;，对咱们来说够用了，所以我们额外再新建一个实现。我们要做的就是在&lt;code&gt;UserDetialsService&lt;/code&gt;中，获取用户对象的同时也将权限数据查询出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public UserDetails loadUserByUsername(String username) {
    UserEntity user = userMapper.selectByUsername(username);
    if (user == null) {
        throw new UsernameNotFoundException(&quot;没有找到该用户&quot;);
    }
    // 先将该用户所拥有的资源id全部查询出来，再转换成`SimpleGrantedAuthority`权限对象
    Set&amp;lt;SimpleGrantedAuthority&amp;gt; authorities = resourceService.getIdsByUserId(user.getId())
        .stream()
        .map(String::valueOf)
        .map(SimpleGrantedAuthority::new)
        .collect(Collectors.toSet());
    // 将用户实体和权限集合都放到UserDetail中，
    return new UserDetail(user, authorities);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样当认证完毕时，&lt;code&gt;Authentication&lt;/code&gt;就会拥有用户信息和权限数据了。&lt;/p&gt;
&lt;h2 id=&quot;授权管理accessdecisionmanager&quot;&gt;授权管理AccessDecisionManager&lt;/h2&gt;
&lt;p&gt;终于要来到我们真正的授权组件了，这个组件才最终决定了你有没有某个权限，该接口我们只需关注一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface AccessDecisionManager {

        /**
         * 授权操作，如果没有权限则抛出异常 
         *
     * @param authentication 当前登录用户，以获取当前用户权限信息
         * @param object FilterInvocation对象，以获取request信息
         * @param configAttributes 当前请求鉴权规则
         */
        void decide(Authentication authentication, Object object, Collection&amp;lt;ConfigAttribute&amp;gt; configAttributes)
                        throws AccessDeniedException, InsufficientAuthenticationException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法接受了这几个参数后完全能做到权限校验了，我们来实现自己的逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MyDecisionManager implements AccessDecisionManager {
    @Override
    public void decide(Authentication authentication, Object object, Collection&amp;lt;ConfigAttribute&amp;gt; configAttributes) {
        // 如果授权规则为空则代表此URL无需授权就能访问
        if (Collections.isEmpty(configAttributes)) {
            return;
        }
        // 判断授权规则和当前用户所属权限是否匹配
        for (ConfigAttribute ca : configAttributes) {
            for (GrantedAuthority authority : authentication.getAuthorities()) {
                // 如果匹配上了，代表当前登录用户是有该权限的，直接结束方法
                if (Objects.equals(authority.getAuthority(), ca.getAttribute())) {
                    return;
                }
            }
        }
        // 走到这里就代表没有权限，必须要抛出异常，否则错误处理器捕捉不到
        throw new AccessDeniedException(&quot;没有相关权限&quot;);
    }

    @Override
    public boolean supports(ConfigAttribute attribute) {
        // 不用管，这么写就行
        return true;
    }

    @Override
    public boolean supports(Class&amp;lt;?&amp;gt; clazz) {
        // 不用管，这么写就行
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;授权错误处理器accessdeniedhandler&quot;&gt;授权错误处理器AccessDeniedHandler&lt;/h2&gt;
&lt;p&gt;该组件和之前的认证异常处理器一样，只有一个方法用来处理异常，只不过这个是用来处理授权异常的。我们直接来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        response.setContentType(&quot;application/json;charset=utf-8&quot;);
        out.write(&quot;没有相关权限&quot;);
        out.flush();
        out.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置-1&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;组件都定义好了，那我们接下来就是最后一步咯，就是让这些组件生效。我们的鉴权规则源组件&lt;code&gt;SecurityMetadataSource&lt;/code&gt;和授权管理组件&lt;code&gt;AccessDecisionManager&lt;/code&gt;必须通过授权过滤器&lt;code&gt;FilterSecurityInterceptor&lt;/code&gt;来配置生效，所以我们得自己先写一个过滤器，这个过滤器的核心代码基本按照父类的写就行，主要就是属性的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class AuthFilter extends AbstractSecurityInterceptor implements Filter {
    @Autowired
    private SecurityMetadataSource securityMetadataSource;

    @Override
    public SecurityMetadataSource obtainSecurityMetadataSource() {
        // 将我们自定义的SecurityMetadataSource给返回
        return this.securityMetadataSource;
    }

    @Override
    @Autowired
    public void setAccessDecisionManager(AccessDecisionManager accessDecisionManager) {
        // 将我们自定义的AccessDecisionManager给注入
        super.setAccessDecisionManager(accessDecisionManager);
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // 下面的就是按照父类写法写的
        FilterInvocation fi = new FilterInvocation(request, response, chain);
        InterceptorStatusToken token = super.beforeInvocation(fi);
        try {
            // 执行下一个拦截器
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        }  finally {
            // 请求之后的处理
            super.afterInvocation(token, null);
        }
    }

    @Override
    public Class&amp;lt;?&amp;gt; getSecureObjectClass() {
        return FilterInvocation.class;
    }

    @Override
    public void init(FilterConfig filterConfig) {}

    @Override
    public void destroy() {}
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤器定义好了，我们回到Spring Security配置类让这个过滤器替换掉原有的过滤器就一切都搞定啦：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;http.addFilterBefore(authFilter, FilterSecurityInterceptor.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以来看下效果，没有权限的情况下访问接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210112085029661-1860709031.jpg&quot; alt=&quot;授权失败.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有权限的情况下访问接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085029885-1288238309.jpg&quot; alt=&quot;授权通过.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;整个Spring Security就讲解完毕了，我们对两个过滤器、N多个组件进行了自定义实现，从而达到了我们的功能。这里做了一个思维导图方便大家理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210112085030502-869377035.jpg&quot; alt=&quot;思维导图.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;别看组件这么多，认证授权的核心流程和一些概念是不会变的，什么安全框架都万变不离其宗。比如&lt;code&gt;Shiro&lt;/code&gt;，其中最基本的概念&lt;code&gt;Subject&lt;/code&gt;就代表当前用户，&lt;code&gt;SubjectManager&lt;/code&gt;就是用户管理器……&lt;/p&gt;
&lt;p&gt;在我前两篇文章中有人也谈到用安全框架还不如自己手写，确实，手写可以最大灵活度按照自己的想法来（并且也不复杂），使用安全框架反而要配合框架的定式，好像被束缚了。那安全框架对比手写有什么优势呢？我觉得优势主要有如下两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一些功能开箱即用，比如Spring Security的加密器，非常方便&lt;/li&gt;
&lt;li&gt;框架的定式既是束缚也是规范，无论谁接手你的项目，一看到熟悉的安全框架就能立马上手&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;讲解到这里就结束了，本文所有代码、&lt;code&gt;SQL&lt;/code&gt;语句都放在&lt;a href=&quot;https://github.com/RudeCrab/rude-java&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;，克隆下来即可运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210108125800650-1747993399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Jan 2021 00:53:00 +0000</pubDate>
<dc:creator>RudeCrab</dc:creator>
<og:description>前后端分离下的认证与授权</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RudeCrab/p/14265273.html</dc:identifier>
</item>
<item>
<title>基于CefSharp开发（七）浏览器收藏夹菜单 - 咸鱼翻身？</title>
<link>http://www.cnblogs.com/mchao/p/14237923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mchao/p/14237923.html</guid>
<description>&lt;h2&gt;一、Edge收藏夹菜单分析&lt;/h2&gt;
&lt;p&gt;如下图所示为Edge收藏夹菜单， 点击收藏夹菜单按钮（红框部分）弹出收藏夹菜单窗体，窗体中包含工具栏（绿框部分）和树型菜单（黄框部分）&lt;/p&gt;
&lt;p&gt;工具栏按钮功能分别为添加当前网页到根节点、创建新文件夹到根节点、搜索收藏夹内容、单中单（收藏夹菜单中的其他功能）、收藏夹菜单固定到右侧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/814381/202101/814381-20210105202920151-519873135.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在树节点上右键，有如下右键菜单功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/814381/202101/814381-20210105204415620-1878023320.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 要完成此功能，需先仿其形，再谋其神。&lt;/p&gt;
&lt;h2&gt;二、仿其形&lt;/h2&gt;
&lt;p&gt;这里所谓的仿其形，即模仿它的样式（Style）&lt;/p&gt;
&lt;h3&gt;1、创建收藏夹菜单UserControl&lt;/h3&gt;
&lt;p&gt;创建FavoritesMenuUc，Grid内容如下：ToggleButton控制菜单显隐，Popup展示弹出菜单，&lt;/p&gt;
&lt;p&gt;StackPanel 中添加五个按钮用于实现工具栏中的功能，MTreeView用于实现树型菜单&lt;/p&gt;
&lt;p&gt;关于MTreeView的实现请参照 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mchao/p/14192196.html&quot;&gt;Cys_Control（六） MTreeView&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToggleButton &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;FavoritesButton&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource ToggleButton.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Checked&lt;/span&gt;&lt;span&gt;=&quot;FavoritesButton_OnChecked&quot;&lt;/span&gt;&lt;span&gt;
                      Unchecked&lt;/span&gt;&lt;span&gt;=&quot;FavoritesButton_OnUnchecked&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe646;&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;26&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; IsChecked&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=FavoritesPop,Path=IsOpen}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Popup &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;FavoritesPop&quot;&lt;/span&gt;&lt;span&gt; PopupAnimation&lt;/span&gt;&lt;span&gt;=&quot;Fade&quot;&lt;/span&gt;&lt;span&gt; Placement&lt;/span&gt;&lt;span&gt;=&quot;Bottom&quot;&lt;/span&gt;&lt;span&gt;  PlacementTarget&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=FavoritesButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               StaysOpen&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt; AllowsTransparency&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; HorizontalOffset&lt;/span&gt;&lt;span&gt;=&quot;-330&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource WebBrowserBrushes.WebMenuBackground}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; CornerRadius&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border.Effect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DropShadowEffect &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Color.MenuItemDropShadowBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Opacity&lt;/span&gt;&lt;span&gt;=&quot;0.3&quot;&lt;/span&gt;&lt;span&gt; ShadowDepth&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border.Effect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;360&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;660&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;Auto&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;40&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;Auto&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;Auto&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;收藏夹栏&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;10,0,0,0&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource WebBrowserBrushes.DefaultForeground}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0,0,10,0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Button.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe659;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Button.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe652;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Button.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe65c;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Button.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;...&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;0,0,0,12&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource Button.FontButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe6b9;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Rectangle &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Fill&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource WebBrowserBrushes.WebMenuDivideLine}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MTreeView &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;FavoritesTree&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Popup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建类TreeNode用于显示TreeView显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TreeNode
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NodeId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ParentId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NodeName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TreeNode&amp;gt; ChildNodes { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; List&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Type { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0-文件，1-文件夹&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FavoritesMenuUc.xaml.cs文件中增加测试数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetFavoritesInfo()
{
    nodes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;TreeNode&amp;gt;&lt;span&gt;()
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=-&lt;span&gt;1&lt;/span&gt;, NodeId=&lt;span&gt;0&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收藏夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;0&lt;/span&gt;, NodeId=&lt;span&gt;1&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;0&lt;/span&gt;, NodeId=&lt;span&gt;2&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;音频&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;0&lt;/span&gt;, NodeId=&lt;span&gt;3&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;视频&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;},

                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;1&lt;/span&gt;, NodeId=&lt;span&gt;11&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文本1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;1&lt;/span&gt;, NodeId=&lt;span&gt;12&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文本2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TreeNode(){ParentId=&lt;span&gt;1&lt;/span&gt;, NodeId=&lt;span&gt;13&lt;/span&gt;, NodeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文本3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Type = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
            };
    List&lt;/span&gt;&amp;lt;TreeNode&amp;gt; root = GetNodes(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, nodes);
    AddTreeViewItems(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, root[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;TreeNode&amp;gt; GetNodes(&lt;span&gt;int&lt;/span&gt; parentId, List&amp;lt;TreeNode&amp;gt;&lt;span&gt; nodes)
{
    List&lt;/span&gt;&amp;lt;TreeNode&amp;gt; mainNodes = nodes.Where(x =&amp;gt; x.ParentId == parentId).OrderByDescending(x =&amp;gt;&lt;span&gt; x.Type).ToList();
    List&lt;/span&gt;&amp;lt;TreeNode&amp;gt; otherNodes = nodes.Where(x =&amp;gt; x.ParentId != parentId).OrderByDescending(x =&amp;gt;&lt;span&gt; x.Type).ToList();
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (TreeNode node &lt;span&gt;in&lt;/span&gt;&lt;span&gt; mainNodes)
        node.ChildNodes &lt;/span&gt;=&lt;span&gt; GetNodes(node.NodeId, otherNodes);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mainNodes;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddTreeViewItems(MTreeViewItem parent, TreeNode treeNode, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isRoot)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; treeViewItem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MTreeViewItem();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (treeNode.ChildNodes.Count &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (treeNode.Type == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            treeViewItem.Header &lt;/span&gt;=&lt;span&gt; treeNode.Url;
            treeViewItem.Icon &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ueb1e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            treeViewItem.IsExpandedIcon &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ueb1e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            treeViewItem.IconForeground &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SolidColorBrush(Color.FromRgb(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            treeViewItem.Header &lt;/span&gt;=&lt;span&gt; treeNode.NodeName;
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        treeViewItem.Header &lt;/span&gt;=&lt;span&gt; treeNode.NodeName;
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; child &lt;span&gt;in&lt;/span&gt;&lt;span&gt; treeNode.ChildNodes)
        {
            AddTreeViewItems(treeViewItem, child, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isRoot)
        parent.Items.Add(treeViewItem);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        FavoritesTree.Items.Add(treeViewItem);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/814381/202101/814381-20210106090342395-405124628.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、为MTreeView添加右键菜单&lt;/h3&gt;
&lt;p&gt;右键子菜单可使用MMneuItem，xaml样式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MTreeView &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;FavoritesTree&quot;&lt;/span&gt;&lt;span&gt; ContextMenuOpening&lt;/span&gt;&lt;span&gt;=&quot;FavoritesTree_OnContextMenuOpening&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MTreeView.ContextMenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContextMenu &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;FavoritesContextMenu&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource WebCustomMenus.DefaultContextMenu}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;全部打开（16个）&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe600;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;在新建窗口中全部打开（16个）&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe602;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;在新 InPrivate窗口全部打开（16个）&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe68c;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;按名称排序&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe606;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;重命名&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe712;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;删除&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe74e;&quot;&lt;/span&gt;&lt;span&gt; IconFontSize&lt;/span&gt;&lt;span&gt;=&quot;26&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;将当前标签页添加到文件夹&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe659;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;将所有标签页添加到文件夹&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:MMenuItem &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;添加文件夹&quot;&lt;/span&gt;&lt;span&gt; Icon&lt;/span&gt;&lt;span&gt;=&quot;&amp;amp;#xe652;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ContextMenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:MTreeView.ContextMenu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:MTreeView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当右键未选中时增加屏蔽右键菜单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FavoritesTree_OnContextMenuOpening(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ContextMenuEventArgs e)
{
    _currentRightItem &lt;/span&gt;= ControlHelper.FindVisualParent&amp;lt;MTreeViewItem&amp;gt;(e.OriginalSource &lt;span&gt;as&lt;/span&gt;&lt;span&gt; DependencyObject);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; _currentRightItem)
    {
        e.Handled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/814381/202101/814381-20210106112443594-722098523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、谋其神&lt;/h2&gt;
&lt;p&gt;这里的谋其神，就是使其可以完成正常的业务处理。&lt;/p&gt;
&lt;p&gt;前面仿造了Edge浏览器的大致样式，接下来要对及增加数据存储、命令处理等&lt;/p&gt;
&lt;h3&gt;1、增加Favorites数据存储&lt;/h3&gt;
&lt;p&gt;这里使用同数据下载同样的处理逻辑，将收藏夹保存为Json文件&lt;/p&gt;
&lt;p&gt;新建FavoritesDataRepository,类中添加 SaveFavoritesSetting、GetFavoritesSetting用于保存与读取数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FavoritesDataRepository
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SaveFavoritesSetting()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; setting =&lt;span&gt; GlobalInfo.FavoritesSetting;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setting == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileName =&lt;span&gt; FileDataPath.GetFilePath(DataFileType.Favorites);
            CommonOperator.SaveDataJson(setting, fileName);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {

        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FavoritesSetting GetFavoritesSetting()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileName =&lt;span&gt; FileDataPath.GetFilePath(DataFileType.Favorites);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; setting = CommonOperator.GetDataJson&amp;lt;FavoritesSetting&amp;gt;&lt;span&gt;(fileName);
        setting &lt;/span&gt;??= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FavoritesSetting();
        setting.FavoritesInfos &lt;/span&gt;??= &lt;span&gt;new&lt;/span&gt; List&amp;lt;TreeNode&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setting.FavoritesInfos.Count &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            setting.FavoritesInfos.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode()
            {
                ParentId &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                NodeId &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                NodeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收藏夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Type &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            });
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; setting;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2、增加菜单事件&lt;/h3&gt;
&lt;p&gt;由于事件较多，目前仅处理添加文件夹、添加收藏、删除功能&lt;/p&gt;
&lt;p&gt;添加folder,这里的if用来判断是收藏夹工具栏的按钮还是右键菜单C&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddFolder_OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sender &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Button)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newTreeNode = GetNewTreeNodeInfo(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新建文件夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == FavoritesTree || FavoritesTree.Items.Count &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; treeNodeUc = FavoritesTree.Items[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(treeNodeUc &lt;span&gt;is&lt;/span&gt; MTreeViewItem item)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        item.Items.Add(newTreeNode.Item2);
        GlobalInfo.FavoritesSetting.FavoritesInfos.Add(newTreeNode.Item1);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sender &lt;span&gt;is&lt;/span&gt;&lt;span&gt; MMenuItem)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newTreeNode = GetNewTreeNodeInfo(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新建文件夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_currentRightItem != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _currentRightItem.Type == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            _currentRightItem.Items.Add(newTreeNode.Item2);
            GlobalInfo.FavoritesSetting.FavoritesInfos.Add(newTreeNode.Item1);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加收藏，添加收藏增加了GetWebUrlEvent事件 用于获取当前tab页的url;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddFavorites_OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model = GetWebUrlEvent?&lt;span&gt;.Invoke();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == model) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sender &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Button)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(FavoritesTree.Items[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;is&lt;/span&gt; MTreeViewItem item)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newTreeNode = GetNewTreeNodeInfo(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, model.Title, model.CurrentUrl);
        GlobalInfo.FavoritesSetting.FavoritesInfos.Add(newTreeNode.Item1);
        item.Items.Add(newTreeNode.Item2);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (sender &lt;span&gt;is&lt;/span&gt;&lt;span&gt; MMenuItem)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_currentRightItem != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; _currentRightItem.Type == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newTreeNode = GetNewTreeNodeInfo(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, model.Title, model.CurrentUrl);
            _currentRightItem.Items.Add(newTreeNode.Item2);
            GlobalInfo.FavoritesSetting.FavoritesInfos.Add(newTreeNode.Item1);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除当前节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete_OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_currentRightItem?.Parent == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _currentRightItem.Items)
    {
        _currentRightItem.Items.Remove(item);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!GlobalInfo.FavoritesSetting.FavoritesInfos.Exists(x =&amp;gt; x.NodeId ==&lt;span&gt; _currentRightItem.NodeId))
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentNode = (GlobalInfo.FavoritesSetting.FavoritesInfos.FirstOrDefault(x =&amp;gt; x.NodeId ==&lt;span&gt; _currentRightItem.NodeId));
        GlobalInfo.FavoritesSetting.FavoritesInfos.Remove(currentNode);
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_currentRightItem.Parent &lt;span&gt;is&lt;/span&gt;&lt;span&gt; MTreeViewItem items)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GlobalInfo.FavoritesSetting.FavoritesInfos.Exists(x =&amp;gt; x.NodeId ==&lt;span&gt; _currentRightItem.NodeId))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentNode = (GlobalInfo.FavoritesSetting.FavoritesInfos.FirstOrDefault(x =&amp;gt; x.NodeId ==&lt;span&gt; _currentRightItem.NodeId));
            GlobalInfo.FavoritesSetting.FavoritesInfos.Remove(currentNode);
        }
        items.Items.Remove(_currentRightItem);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于创建TreeNode代码细节请参考文章末尾源码&lt;/p&gt;
&lt;p&gt;增加OpenNewTabEvent事件用于点击收藏内容时打开网页&lt;/p&gt;
&lt;h2&gt;四、运行效果&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/814381/202101/814381-20210111214356672-495528602.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、源码地址&lt;/h2&gt;
&lt;p&gt;gitee地址：&lt;a href=&quot;https://gitee.com/sirius_machao/mweb-browser&quot; target=&quot;_blank&quot;&gt;https://gitee.com/sirius_machao/mweb-browser&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Jan 2021 00:44:00 +0000</pubDate>
<dc:creator>咸鱼翻身？</dc:creator>
<og:description>一、Edge收藏夹菜单分析 如下图所示为Edge收藏夹菜单， 点击收藏夹菜单按钮（红框部分）弹出收藏夹菜单窗体，窗体中包含工具栏（绿框部分）和树型菜单（黄框部分） 工具栏按钮功能分别为添加当前网页到根</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mchao/p/14237923.html</dc:identifier>
</item>
<item>
<title>【小菜学网络】MAC地址详解 - fasionchan</title>
<link>http://www.cnblogs.com/fasionchan/p/mac.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fasionchan/p/mac.html</guid>
<description>&lt;p&gt;上一小节介绍了以太网帧的结构，以及帧中各个字段的作用。参与以太网通讯的实体，由以太网地址唯一标识。以太网地址也叫做 &lt;em&gt;MAC&lt;/em&gt; 地址，我们对它仍知之甚少。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以太网地址在不同场景，称谓也不一样，常用叫法包括这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以太网地址&lt;/li&gt;
&lt;li&gt;&lt;em&gt;MAC&lt;/em&gt; 地址&lt;/li&gt;
&lt;li&gt;硬件地址&lt;/li&gt;
&lt;li&gt;物理地址&lt;/li&gt;
&lt;li&gt;网卡地址&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;网卡&quot;&gt;网卡&lt;/h2&gt;
&lt;p&gt;在以太网中，每台主机都需要安装一个物理设备并通过网线连接到一起：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/18394ac97c9ef2e90596d62f6bc2f07b28796694.png#width=340px&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个设备就是 &lt;strong&gt;网卡&lt;/strong&gt; ( &lt;em&gt;NIC&lt;/em&gt; )，&lt;strong&gt;网络接口卡&lt;/strong&gt; ( &lt;em&gt;network interface card&lt;/em&gt; )的简称。有些文献也将网卡称为 &lt;strong&gt;网络接口控制器&lt;/strong&gt; ( &lt;em&gt;network interface controller&lt;/em&gt; )。&lt;/p&gt;
&lt;p&gt;从物理的层面看，网卡负责将比特流转换成电信号发送出去； 反过来，也负责将检测到的电信号转换成比特流并接收。&lt;/p&gt;
&lt;p&gt;从软件的层面看，发送数据时，内核协议栈负责封装以太网帧(填充 &lt;strong&gt;目的地址&lt;/strong&gt; ， &lt;strong&gt;源地址&lt;/strong&gt; ， &lt;strong&gt;类型&lt;/strong&gt; 和 &lt;strong&gt;数据&lt;/strong&gt; 并计算 &lt;strong&gt;校验和&lt;/strong&gt;)，并调用网卡驱动发送； 接收数据时，负责验证 &lt;strong&gt;目的地址&lt;/strong&gt; 、 &lt;strong&gt;校验和&lt;/strong&gt; 并取出数据部分，交由上层协议栈处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/d58604f365fbacb3a220d2379c0474605e64a3af.jpg#width=340px&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每块网卡出厂时，都预先分配了一个全球唯一的 &lt;strong&gt;MAC地址&lt;/strong&gt; ，并烧进硬件。 不管后来网卡身处何处，接入哪个网络，&lt;em&gt;MAC&lt;/em&gt; 地址均不变。 当然，某些操作系统也允许修改网卡的 &lt;em&gt;MAC&lt;/em&gt; 地址。&lt;/p&gt;
&lt;h2 id=&quot;mac地址&quot;&gt;MAC地址&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;MAC&lt;/em&gt; 地址由 &lt;em&gt;6&lt;/em&gt; 个字节组成( &lt;em&gt;48&lt;/em&gt; 位)，可以唯一标识 $2^{48}$ ，即 &lt;em&gt;281474976710656&lt;/em&gt; 个网络设备(比如网卡)。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MAC&lt;/em&gt; 地址 &lt;em&gt;6&lt;/em&gt; 个字节可以划分成两部分，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/18f17216ce3ec65b7b61c3a070c5d1d7e49dba4a.jpg#width=400px&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;3&lt;/em&gt; 字节长的 &lt;strong&gt;厂商代码&lt;/strong&gt; ( &lt;em&gt;OUI&lt;/em&gt; )，由国际组织分配给不同的网络设备商；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;3&lt;/em&gt; 字节长的 &lt;strong&gt;序列号&lt;/strong&gt; ( &lt;em&gt;SN&lt;/em&gt; )，由厂商分配给它生产的网络设备；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;厂商代码和序列号都是唯一分配，因此 &lt;em&gt;MAC&lt;/em&gt; 地址是 &lt;strong&gt;全球唯一&lt;/strong&gt; 的。&lt;/p&gt;
&lt;h2 id=&quot;冒分十六进制表示法&quot;&gt;冒分十六进制表示法&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;MAC&lt;/em&gt; 地址 &lt;em&gt;6&lt;/em&gt; 个字节如何展示呢？ 是否能够作为 &lt;em&gt;ASCII&lt;/em&gt; 来解读并显示？&lt;/p&gt;
&lt;p&gt;恐怕不能。一个字节总共有 &lt;em&gt;8&lt;/em&gt; 个位，而 &lt;em&gt;ASCII&lt;/em&gt; 只定义了其中的 &lt;em&gt;7&lt;/em&gt; 位。况且 &lt;em&gt;ASCII&lt;/em&gt; 中定义了很多控制字符，能显示的也只有字母、数字以及一些常用符号。以上述地址为例，只有 &lt;code&gt;0x5B&lt;/code&gt; 这个字节是可以显示的，对应着字符 &lt;code&gt;[&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/7d20b966b4622355560fd0d2ba54227a717c1662.png#width=619px&quot; alt=&quot;4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好在，我们可以用多个可读字符来表示一个原始字节。我们将一个字节分成两部分，高 &lt;code&gt;4&lt;/code&gt; 位以及低 &lt;code&gt;4&lt;/code&gt; 位，每部分可以用一个十六进制字符来表示。以 &lt;code&gt;0x00&lt;/code&gt; 这个字节为例，可以用两个字符 &lt;code&gt;00&lt;/code&gt; 表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/7a59527148a3b97626c41569cab75bf2fb41f2b2.png#width=366px&quot; alt=&quot;5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，整个地址可以用一个 &lt;em&gt;12&lt;/em&gt; 字节长的字符串表示： &lt;code&gt;0010A4BA875B&lt;/code&gt; 。 为了进一步提高可读性，可以在中间插入冒号 &lt;code&gt;:&lt;/code&gt; ： &lt;code&gt;00:10:A4:BA:87:5B&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/67043e74cdcd09aaa861efe5393f1779a334b8ed.png&quot; alt=&quot;6&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是 &lt;strong&gt;冒分十六进制表示法&lt;/strong&gt; ( &lt;em&gt;colon hexadecimal notation&lt;/em&gt; )。&lt;/p&gt;
&lt;p&gt;注意到，冒分十六进制总共需要 &lt;code&gt;17&lt;/code&gt; 个字节。 如果算上字符串结尾处的 &lt;code&gt;\0&lt;/code&gt; ，将达到 &lt;em&gt;18&lt;/em&gt; 个字节，原始 &lt;em&gt;MAC&lt;/em&gt; 地址的整整 &lt;em&gt;3&lt;/em&gt; 倍！顺便提一下，十六进制字母字符用大小写都可以。&lt;/p&gt;
&lt;h2 id=&quot;网卡管理&quot;&gt;网卡管理&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Linux&lt;/em&gt; 上有不少工具命令可以查看系统当前接入的网卡以及每张网卡的详细信息。&lt;/p&gt;
&lt;p&gt;首先是 &lt;em&gt;ifconfig&lt;/em&gt; 命令，他默认显示已启用的网卡，详情中可以看到每张网卡的物理地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;fasion@u2004 [ ~ ]  ➜ ifconfig
enp0s3: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::a00:27ff:fe49:50dd  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 08:00:27:49:50:dd  txqueuelen 1000  (Ethernet)
        RX packets 3702  bytes 4881568 (4.8 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 538  bytes 42999 (42.9 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

enp0s8: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500
        inet 192.168.56.2  netmask 255.255.255.0  broadcast 192.168.56.255
        inet6 fe80::a00:27ff:fe56:831c  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 08:00:27:56:83:1c  txqueuelen 1000  (Ethernet)
        RX packets 4183  bytes 1809871 (1.8 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2674  bytes 350013 (350.0 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&amp;lt;UP,LOOPBACK,RUNNING&amp;gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&amp;lt;host&amp;gt;
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 679  bytes 1510416 (1.5 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 679  bytes 1510416 (1.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中，系统总共有 &lt;em&gt;3&lt;/em&gt; 块已启用网卡，名字分别是 &lt;em&gt;enp0s3&lt;/em&gt; 、 &lt;em&gt;enp0s8&lt;/em&gt; 以及 &lt;em&gt;lo&lt;/em&gt; 。其中 &lt;em&gt;lo&lt;/em&gt; 是环回网卡，用于本机通讯。&lt;code&gt;ether 08:00:27:49:50:dd&lt;/code&gt; 表明，网卡 &lt;em&gt;enp0s3&lt;/em&gt; 的物理地址是 &lt;code&gt;08:00:27:49:50:dd&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请注意，&lt;em&gt;ifconfig&lt;/em&gt; 是一个比较老旧的命令，正在慢慢淡出历史舞台。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;ip&lt;/em&gt; 命令也可以查看系统网卡信息，默认显示所有网卡：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;fasion@u2004 [ ~ ]  ➜ ip link
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:49:50:dd brd ff:ff:ff:ff:ff:ff
3: enp0s8: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:56:83:1c brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;ip&lt;/em&gt; 命令输出信息比较紧凑， &lt;code&gt;link/ether 08:00:27:49:50:dd&lt;/code&gt; 这行展示网卡的物理地址。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ip&lt;/em&gt; 命令是一个比较新的命令，功能非常强大。它除了可以用于管理网络设备，还可以用于管理路由表，策略路由以及各种隧道。因此，推荐重点学习掌握 &lt;em&gt;ip&lt;/em&gt; 命令的用法。&lt;/p&gt;
&lt;h2 id=&quot;编程获取网卡地址&quot;&gt;编程获取网卡地址&lt;/h2&gt;
&lt;p&gt;如果程序中需要用到网卡地址，如何获取呢？&lt;/p&gt;
&lt;p&gt;有个方法是执行 &lt;em&gt;ip&lt;/em&gt; 命令输出网卡详情，然后从输出信息中截取网卡地址。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;fasion@u2004 [ ~ ]  ➜ ip link show dev enp0s3 | grep 'link/ether' | awk '{print $2}'
08:00:27:49:50:dd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法多用于 &lt;em&gt;Shell&lt;/em&gt; 编程中。&lt;/p&gt;
&lt;p&gt;更优雅的办法是通过套接字编程，直接向操作系统获取。&lt;em&gt;Linux&lt;/em&gt; 套接字支持通过 &lt;em&gt;ioctl&lt;/em&gt; 系统调用获取网络设备信息，大致步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个套接字，任意类型均可；&lt;/li&gt;
&lt;li&gt;准备 &lt;em&gt;ifreq&lt;/em&gt; 结构体，用于保存网卡设备信息；&lt;/li&gt;
&lt;li&gt;将待查询网卡名填充到 &lt;em&gt;ifreq&lt;/em&gt; 结构体；&lt;/li&gt;
&lt;li&gt;调用 &lt;em&gt;ioctl&lt;/em&gt; 系统调用，向套接字发起 &lt;code&gt;SIOCGIFHWADDR&lt;/code&gt; 请求，获取物理地址；&lt;/li&gt;
&lt;li&gt;如无错漏，内核将被查询网卡的物理地址填充在 &lt;em&gt;ifreq&lt;/em&gt; 结构体 &lt;em&gt;ifr_hwaddr&lt;/em&gt; 字段中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，附上一个完整的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;

/**
 *  Convert binary MAC address to readable format.
 *
 *  Arguments
 *      n: binary format, must be 6 bytes.
 *
 *      a: buffer for readable format, 18 bytes at least(`\0` included).
 **/
void mac_ntoa(unsigned char *n, char *a) {
    // traverse 6 bytes one by one
    sprintf(a, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;, n[0], n[1], n[2], n[3], n[4], n[5]);
}


int main(int argc, char *argv[]) {
    if (argc &amp;lt; 2) {
        fprintf(stderr, &quot;no iface given\n&quot;);
        return 1;
    }

    // create a socket, any type is ok
    int s = socket(AF_INET, SOCK_STREAM, 0);
    if (-1 == s) {
        perror(&quot;Fail to create socket&quot;);
        return 2;
    }

    // fill iface name to struct ifreq
    struct ifreq ifr;
    strncpy(ifr.ifr_name, argv[1], 15);

    // call ioctl to get hardware address
    int ret = ioctl(s, SIOCGIFHWADDR, &amp;amp;ifr);
    if (-1 == ret) {
        perror(&quot;Fail to get mac address&quot;);
        return 3;
    }

    // convert to readable format
    char mac[18];
    mac_ntoa((unsigned char *)ifr.ifr_hwaddr.sa_data, mac);

    // output result
    printf(&quot;IFace: %s\n&quot;, ifr.ifr_name);
    printf(&quot;MAC: %s\n&quot;, mac);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;em&gt;mac_ntoa&lt;/em&gt; 函数调用字符串格式化函数 &lt;em&gt;sprintf&lt;/em&gt; 将原始 &lt;em&gt;MAC&lt;/em&gt; 地址转换成冒分十六进制形式。&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://fasionchan.com/network/&quot; target=&quot;_blank&quot;&gt;小菜学网络&lt;/a&gt;】系列文章首发于公众号【小菜学编程】，敬请关注：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/coding-fan-wechat-soso.png?x-oss-process=image/resize,w_359&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Jan 2021 00:43:00 +0000</pubDate>
<dc:creator>fasionchan</dc:creator>
<og:description>上一小节介绍了以太网帧的结构，以及帧中各个字段的作用。参与以太网通讯的实体，由以太网地址唯一标识。以太网地址也叫做 MAC 地址，我们对它仍知之甚少。 以太网地址在不同场景，称谓也不一样，常用叫法包括</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fasionchan/p/mac.html</dc:identifier>
</item>
<item>
<title>【Nginx学习笔记】-初识Nginx - IT胖</title>
<link>http://www.cnblogs.com/FLY_DREAM/p/14265110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FLY_DREAM/p/14265110.html</guid>
<description>&lt;p&gt;Nginx中文文档 - &lt;a href=&quot;https://www.nginx.cn/doc/&quot; target=&quot;_blank&quot;&gt;https://www.nginx.cn/doc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nginx (&quot;engine x&quot;) 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。&lt;/p&gt;
&lt;p&gt;Nginx 解决了服务器的C10K（就是在一秒之内连接客户端的数目为10k即1万）问题。它的设计不像传统的服务器那样使用线程处理请求，而是一个更加高级的机制—&lt;code&gt;事件驱动机制&lt;/code&gt;，是一种异步事件驱动结构。它可以轻松在百万并发连接下实现高吞吐量的Web服务，同时诸多应用场景下的问题都可以通过种种Nginx模块得以解决，而我们所需的工作量也并不大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/1610378133_20200624150926016_509393060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nginx-特点&quot;&gt;Nginx 特点&lt;/h2&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;高并发请求的同时保持高效的服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;热部署&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;低内存消耗/很高的可靠性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理响应请求很快&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;非阻塞、高并发连接-IO多路复用epoll（IO复用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轻量级&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加&lt;/li&gt;
&lt;li&gt;代码模块化 - 更适合二次开发，如阿里巴巴Tengine&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU亲和&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Nginx接收用户请求是异步的，即先将用户请求全部接收下来，再一次性发送到后端Web服务器，极大减轻后端Web服务器的压力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;支持内置服务器检测。Nginx能够根据应用服务器处理页面返回的状态码、超时信息等检测服务器是否出现故障，并及时返回错误的请求重新提交到其它节点上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;采用Master/worker多进程工作模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nginx-基本功能&quot;&gt;Nginx 基本功能&lt;/h2&gt;
&lt;p&gt;Nginx的功能包括基本HTTP功能和扩展功能。和Apache服务器一样，Nginx服务器为了提供更多的功能并且能够有效地扩展这些功能。每一个模块都提供了一个功能，通过编译这些功能模块来实现功能的扩展&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本HTTP功能&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;a）提供静态文件和index文件，处理静态文件，索引文件以及自动索引，打开文件描述符缓存；&lt;br/&gt;b）使用缓存加速反向代理，反向代理加速（无缓存），简单的负载均衡和容错；&lt;br/&gt;c）使用缓存机制加速远程FastCGI，简单的负载均衡和容错；&lt;br/&gt;d）模块化的结构。过滤器包括gzipping,byte ranges,chunked responses，以及 SSI-filter。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；&lt;br/&gt;e）支持SSL 和 TLS SNI 支持；&lt;br/&gt;f）IMAP/POP3代理服务功能；&lt;br/&gt;g）使用外部 HTTP 认证服务器重定向用户到 IMAP/POP3 后端；&lt;br/&gt;h）使用外部 HTTP 认证服务器认证用户后连接重定向到内部的 SMTP 后端；&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;其他HTTP功能&lt;br/&gt;a）基于名称和基于IP的虚拟服务器；&lt;br/&gt;b）支持Keep-alive和管道连接；&lt;br/&gt;c）灵活的配置和重新配置、在线升级的时候不用中断客户访问的处理；&lt;br/&gt;d）访问日志的格式，缓存日志写入和快速日志轮循；&lt;br/&gt;e）3xx-5xx错误代码重定向；&lt;br/&gt;f）速度限制&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;nginx-使用场景&quot;&gt;Nginx 使用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;搭建静态资源服务器&lt;/li&gt;
&lt;li&gt;反向代理分发后端服务（可以和nodejs搭配实现前后端分离）和跨域问题&lt;/li&gt;
&lt;li&gt;根据User Agent来重定向站点&lt;/li&gt;
&lt;li&gt;开发环境或测试环境切换（切换host）&lt;/li&gt;
&lt;li&gt;url重写，使用rewrie规则本地映射&lt;/li&gt;
&lt;li&gt;资源内容篡改&lt;/li&gt;
&lt;li&gt;获取cookie做分流&lt;/li&gt;
&lt;li&gt;资源合并&lt;/li&gt;
&lt;li&gt;gzip压缩&lt;/li&gt;
&lt;li&gt;压缩图片&lt;/li&gt;
&lt;li&gt;sourceMap调试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112000306.jpeg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nginx-安装卸载&quot;&gt;Nginx 安装/卸载&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;docker-方式运行&quot;&gt;Docker 方式运行&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;docker run --name nginx -p 8080:80 -d nginx&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;ubuntu上安装&quot;&gt;Ubuntu上安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get install software-properties-common
sudo add-apt-repository ppa:nginx/stable 
sudo apt-get update
sudo apt-get install nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，检查Nginx服务的状态&lt;code&gt;sudo systemctl status nginx&lt;/code&gt; 和 版本&lt;code&gt;nginx -V&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;访问：&lt;a href=&quot;http://localhost&quot; target=&quot;_blank&quot;&gt;http://localhost&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112000843.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动时候若显示端口80被占用： &lt;code&gt;Starting nginx: [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)，&lt;/code&gt;&lt;br/&gt;修改文件：/etc/nginx/sites-available/default,把 listen 后面的 80 端口号改为自己的端口，访问是需要添加端口号。&lt;br/&gt;安装完后如出现403错误，那可能是nginx配置文件里的网站路径不正确&lt;/p&gt;
&lt;h3 id=&quot;卸载nginx&quot;&gt;卸载Nginx&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。
sudo apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。
sudo apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。
sudo apt-get remove nginx-full nginx-common #卸载删除两个主要的包。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;nginx-命令&quot;&gt;Nginx 命令&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;- sudo nginx #打开 nginx
- nginx -s reload|reopen|stop|quit #重新加载配置|重启|停止|退出 nginx
- nginx -t #测试配置是否有语法错误

nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]

-?,-h : 打开帮助信息
-v : 显示版本信息并退出
-V : 显示版本和配置选项信息，然后退出
-t : 检测配置文件是否有语法错误，然后退出
-q : 在检测配置文件期间屏蔽非错误信息
-s signal : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件）
-p prefix : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/）
-c filename : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf）
-g directives : 设置配置文件外的全局指令
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证配置是否正确: nginx -t&lt;br/&gt;配置文件修改重装载命令：nginx -s reload&lt;/p&gt;
&lt;p&gt;停止nginx: &lt;code&gt;sudo systemctl stop nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动nginx: &lt;code&gt;sudo systemctl start nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认，nginx是随着系统启动的时候自动运行，&lt;code&gt;sudo systemctl disable nginx&lt;/code&gt;可以禁止nginx开机启动.&lt;/p&gt;
&lt;p&gt;重新配置nginx开机自动启动: &lt;code&gt;sudo systemctl enable nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重启nginx: &lt;code&gt;sudo systemctl restart nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;平滑加载配置(不会断开用户访问）：&lt;code&gt;sudo systemctl reload nginx&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;reload，重新加载的意思，reload会重新加载配置文件，nginx服务不会中断，而且reload时会测试conf语法等，如果出错会rollback用上一次正确配置文件保持正常运行。&lt;/li&gt;
&lt;li&gt;restart，重启，会重启nginx服务。这个重启会造成服务一瞬间的中断，当然如果配置文件出错会导致服务启动失败，那就是更长时间的服务中断了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nginx-目录结构&quot;&gt;Nginx 目录结构&lt;/h2&gt;
&lt;p&gt;网站文件位置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/var/www/html: 网站文件存放的地方, 默认只有我们上面看到nginx页面，可以通过改变nginx配置文件的方式来修改这个位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/etc/nginx: nginx配置文件目录。所有的nginx配置文件都在这里。&lt;/li&gt;
&lt;li&gt;/etc/nginx/nginx.conf: Nginx的主配置文件. 可以修改他来改变nginx的全局配置。&lt;/li&gt;
&lt;li&gt;/etc/nginx/sites-available/: 这个目录存储每一个网站的&quot;server blocks&quot;。nginx通常不会使用这些配置，除非它们陪连接到 sites-enabled 目录 (see below)。一般所有的server block 配置都在这个目录中设置，然后软连接到别的目录 。&lt;/li&gt;
&lt;li&gt;/etc/nginx/sites-enabled/: 这个目录存储生效的 &quot;server blocks&quot; 配置. 通常,这个配置都是链接到 sites-available目录中的配置文件&lt;/li&gt;
&lt;li&gt;/etc/nginx/snippets: 这个目录主要可以包含在其它nginx配置文件中的配置片段。重复的配置都可以重构为配置片段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;日志文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/var/log/nginx/access.log: 每一个访问请求都会记录在这个文件中，除非你做了其它设置&lt;/li&gt;
&lt;li&gt;/var/log/nginx/error.log: 任何Nginx的错误信息都会记录到这个文件中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nginx热部署&quot;&gt;Nginx热部署&lt;/h2&gt;
&lt;p&gt;所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）&lt;/p&gt;
&lt;p&gt;通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt; 修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt; 修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。&lt;/p&gt;
&lt;p&gt;Nginx采用的就是方案二来达到热部署的！&lt;/p&gt;
&lt;h2 id=&quot;nginx-运行原理&quot;&gt;Nginx 运行原理&lt;/h2&gt;
&lt;h3 id=&quot;master-worker模式&quot;&gt;Master-Worker模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/1610378134_20200624162443069_232260949.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/1610378134_20200624162509036_171276403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Master进程的作用是？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取并验证配置文件nginx.conf；管理worker进程；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Worker进程的作用是？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，Nginx在启动时，会解析配置文件，得到需要监听的端口与IP地址，然后在Nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的IP地址端口，再listen)，然后再fork(一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程 )出多个子进程出来，然后子进程会竞争accept新的连接。&lt;/p&gt;
&lt;p&gt;此时，客户端就可以向Nginx发起连接了。当客户端与Nginx进行三次握手，与Nginx建立好一个连接后，某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建Nginx对连接的封装，即ngx_connection_t结构体。&lt;/p&gt;
&lt;p&gt;接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx或客户端来主动关掉连接&lt;/p&gt;
&lt;h3 id=&quot;nginx如何做到高并发下的高效处理？&quot;&gt;Nginx如何做到高并发下的高效处理？&lt;/h3&gt;
&lt;p&gt;上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。&lt;/p&gt;
&lt;p&gt;作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞...&lt;/p&gt;
&lt;p&gt;要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。&lt;/p&gt;
&lt;p&gt;Nginx采用了Linux的&lt;strong&gt;epoll模型&lt;/strong&gt;，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。&lt;/p&gt;
&lt;h2 id=&quot;nginx-高可用&quot;&gt;Nginx 高可用&lt;/h2&gt;
&lt;p&gt;Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。&lt;/p&gt;
&lt;p&gt;答案是：&lt;strong&gt;Keepalived+Nginx&lt;/strong&gt;实现高可用。&lt;/p&gt;
&lt;p&gt;Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）&lt;/p&gt;
&lt;p&gt;Keepalived+Nginx实现高可用的思路：&lt;br/&gt;第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）&lt;br/&gt;第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/1610378135_20200624172822781_380420450.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 16:34:00 +0000</pubDate>
<dc:creator>IT胖</dc:creator>
<og:description>Nginx中文文档 - https://www.nginx.cn/doc/ Nginx (&amp;amp;quot;engine x&amp;amp;quot;) 是一个高性能的 HTTP 和 反向代理 服务器，也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FLY_DREAM/p/14265110.html</dc:identifier>
</item>
<item>
<title>我是如何在短期内快速掌握Dubbo的原理和源码的（纯干货）？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14264989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14264989.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;上周，在【Dubbo系列专题】中更新了两篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247489794&amp;amp;idx=1&amp;amp;sn=aa9efb732ac7fe3d2bc927c1491cae57&amp;amp;chksm=cf55ae03f82227157bb69cb487df2081b5b623d173b1df603be66347692acec56d455da6aae1&amp;amp;token=942113583&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;冰河开始对Dubbo下手了！&lt;/a&gt;》和《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247489831&amp;amp;idx=1&amp;amp;sn=e1126303a91f8fccb6154196695c5e6e&amp;amp;chksm=cf55ae26f82227302f71ced14c0aa312f631c8f03df65650dd3a49dc7fa9f339685342c38f5a&amp;amp;token=942113583&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;俯瞰Dubbo全局，阅读源码前必须掌握这些！！&lt;/a&gt;》，收到了很多小伙伴的微信私聊消息，大部分都是在询问如何快速的掌握Dubbo的原理和源码。针对这个问题，我也在思考如何以更简单、易懂的方式让小伙伴们更好的掌握Dubbo的原理和源码。今天，我就为小伙伴们分享下我是如何快速掌握Dubbo的原理和源码的。&lt;/p&gt;
&lt;p&gt;文章已收录到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;阅读源码的前提&quot;&gt;阅读源码的前提&lt;/h2&gt;
&lt;p&gt;阅读某一项技术框架，或者说开源项目的源码前，你必须了解这个框架是干啥用的，说白了，就是你至少了解这个框架该怎么用，在什么场景下用，使用的过程中会遇到哪些坑，如何解决。而学习一个框架，最简单有效的方式就是它的官方文档。Dubbo也不例外，我在学习Dubbo的时候，也是首先看的Dubbo的官方文档，基本没看其他的文章或者资料。为啥？因为Dubbo的官方文档是最权威的，是最可信的。&lt;/p&gt;
&lt;p&gt;即使你在项目中没有使用过Dubbo框架，你也可以按照Dubbo的官方文档基于Dubbo写一个简单的示例程序，通过示例能够让自己快速的了解Dubbo。&lt;/p&gt;
&lt;h2 id=&quot;为何要阅读源码&quot;&gt;为何要阅读源码&lt;/h2&gt;
&lt;p&gt;阅读源码前，你要清楚的知道自己为何要阅读源码，带着问题去看源码。 &lt;strong&gt;想要看框架的源码，无外乎两种情况：一种就是在项目中遇到了无法通过文档或者其他技术资料解决的问题，想通过源码来找解决方案；另一种就是对框架的底层实现好奇，这么牛逼的技术是如何实现的？&lt;/strong&gt; 而我，基本属于后者。在我经历的用户上亿的高并发电商系统中，部分核心子系统使用了Dubbo，经过性能调优，Dubbo的表现良好。我就很好奇：Dubbo是如何抗住这么高的并发的？它内部是如何实现的？&lt;/p&gt;
&lt;p&gt;其次，阅读源码前，你要为自己提几个问题，比如我在看Dubbo源码前，就明确了很多问题，比如：Dubbo是如何实现RPC服务的？服务提供者和调用者之间是如何交互的？Dubbo是如何封装网络调用使其看起来和调用本地方法一样？Dubbo又是如何实现服务治理的？等等一系列的问题，我记得我当时看源码前，足足给自己提了上百个问题。&lt;strong&gt;带着问题看源码，能够让你事半功倍，不仅仅是Dubbo，对于其他的框架，也是如此。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有就是，不要为了看源码而看源码，很多小伙伴看了不少框架的源码，可没过多久就忘记了，跟没看一样，还浪费了很多时间。这种就是典型的为了看源码而看源码，并没有去深究这个框架的实现原理和细节，遇到看不懂的，可以先跳过，记录下，等把相关联的代码看懂后，再反过头来重新梳理没有看懂的源码。&lt;/p&gt;
&lt;h2 id=&quot;框架使用了哪些技术&quot;&gt;框架使用了哪些技术&lt;/h2&gt;
&lt;p&gt;阅读源码前，还有一项重要的工作就是，要了解框架中使用了哪些技术。对所用的技术要有个大体的了解。比如：在Dubbo中使用了SPI、时间轮定时任务、服务注册与发现、Netty、序列化、自定义协议等等技术。所以，在阅读源码前，先要对这些技术有个大体的了解。&lt;/p&gt;
&lt;p&gt;比如，在看Dubbo源码前，我就已经了解到Dubbo的网路交互底层使用的Netty，正好在我工作不久的时候，我又深入研究过Netty的源码，这就有助于我在看Dubbo源码时，能够更好的理解Dubbo的网络编程部分。&lt;/p&gt;
&lt;p&gt;所以说，台上一分钟，台下十年功，在看Dubbo源码前，我也是做了充分的准备。&lt;/p&gt;
&lt;h2 id=&quot;阅读源码时注意什么&quot;&gt;阅读源码时注意什么&lt;/h2&gt;
&lt;p&gt;任何一项技术框架，或者说开源项目，肯定是为了解决某些场景而生的，就比如Dubbo，相信小伙伴们都知道，Dubbo作为一个分布式服务治理框架，一个典型的使用场景就是分布式系统。&lt;/p&gt;
&lt;p&gt;其次，一个优秀的技术框架或开源项目背后肯定蕴含着众多其他技术的原理与实现。我们同样是以Dubbo为例，在Dubbo中，为了实现在分布式场景下，调用远程RPC服务就像调用本地服务一样，其至少需要实现如下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务之间功性能的通信。&lt;/li&gt;
&lt;li&gt;服务调用需要做到负载均衡、高可用、限流。&lt;/li&gt;
&lt;li&gt;服务治理。&lt;/li&gt;
&lt;li&gt;高可靠、容错。&lt;/li&gt;
&lt;li&gt;服务能够自动注册和发现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而实现这些功能时，Dubbo借助了哪些优秀的开源框架？这些开源框架Dubbo是如何集成起来的？是硬编码方式集成？还是其他更好的方式？这些都是需要我们在阅读源码的时候，去源码中找到答案。&lt;/p&gt;
&lt;h2 id=&quot;阅读源码的方式&quot;&gt;阅读源码的方式&lt;/h2&gt;
&lt;p&gt;我把阅读源码的方式总结为：&lt;strong&gt;先整体再局部，先宏观再微观，先粗略再细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么意思呢？就是在看源码的是时候，先从整体上把握源码的设计原理和设计理念，先整体上大概了解源码是如何实现的。比如在Dubbo中，网络编程是基于Netty实现的，你就可以先做个了解，知道这么回事。从整体上把握基本的框架源码后，再从细节中死磕具体的实现，比如，在Dubbo中是如何使用Netty实现网络交互的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住，阅读源码时切忌在还没有搞懂整体的设计原理和整体源码设计前，就开始死扣源码的细节。否则，你会在源码里面迷失自己。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何验证自己掌握了源码？&quot;&gt;如何验证自己掌握了源码？&lt;/h2&gt;
&lt;p&gt;阅读源码光看源码还不行，还要自己去动手实践，正所谓“实践是掌握整理的唯一标准”。你不实践，怎么知道自己是不是掌握了。&lt;/p&gt;
&lt;p&gt;我把实践部分分为两个组成部分：&lt;strong&gt;在看源码的过程中动手实践；在看源码后动手实践。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在看源码的过程中动手实践就是说：在看源码的过程中，将自己不明白的地方记录下来，查阅官网文档或者其他资料，如果是由于自己的技术能力有欠缺，看不懂的，就要及时为自己充电来补充相关的知识点了。如果是遇到自己认为比较好的实现方式时，可以在框架的代码上以注释的方式标记自己的理解。比如，我在看Dubbo源码的时候，就标注了大量的注释。&lt;/p&gt;
&lt;p&gt;在看源码后，一定要动手实操。看过Dubbo的整体源码后，如果你认为自己掌握了Dubbo，就不妨自己动手实现一个RPC框架，看看自己实现的框架与Dubbo框架有哪些区别，为啥Dubbo框架是这样实现的。再反过头来带着问题看Dubbo的源码，你肯定会理解的更加深入。而我，在看完Dubbo框架的源码后，也是这样做的。&lt;/p&gt;
&lt;h2 id=&quot;阅读源码的总结&quot;&gt;阅读源码的总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最后，跟小伙伴们透露下：我从开始看Dubbo源码，到掌握Dubbo的原理和源码，前前后后只用了不到两个月。记住，阅读源码前，一定要明确为何读源码，带着问题读源码，对于源码中所涉及的其他技术或框架，一定要有所了解。阅读源码的过程中，要遵循：先整体再局部，先宏观再微观，先粗略再细节的原则。最重要的一点是：在阅读源码的过程中和阅读源码后都要动手实践。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 15:39:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 上周，在【Dubbo系列专题】中更新了两篇文章《冰河开始对Dubbo下手了！》和《俯瞰Dubbo全局，阅读源码前必须掌握这些！！》，收到了很多小伙伴的微信私聊消息，大部分都是在询问如何快速的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14264989.html</dc:identifier>
</item>
<item>
<title>965七年我失去了什么？得到了什么？ - 逃离沙漠</title>
<link>http://www.cnblogs.com/demingblog/p/14264979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demingblog/p/14264979.html</guid>
<description>&lt;p&gt;近几年“996”的话题热度不断，或者说996话题在“互联网从业者”圈子中热度不断。然而每一次，我都感觉这个话题“跟我无关”，因为我真的965了七年。曾经有人这么说我：“你都不像一个程序员，程序员哪有下班这么早的？”。是的，我确实不像“主流程序员”那样，即没有有996，也不像媒体口中描述的那样“黑色双肩包”，“格子衬衫”。&lt;br/&gt;我不是一个爱蹭热度的人，实际上我几乎不怎么关心大家都热烈讨论的热度话题。我是一个“自私”、“理性”到只关心“自己关心的话题”的人，安安静静的在那里，仿佛对整个世界无害。我只是想在这个时间点回顾一下自己这7年是怎么一路965过来的，和996相比，我失去了什么？又得到了什么？&lt;/p&gt;

&lt;h2 id=&quot;第一家公司&quot;&gt;第一家公司&lt;/h2&gt;
&lt;p&gt;我于2013年毕业，7月份的时候加入了一家公司，在北京五道口。3个月刚转正我就离职了。离职的时候，部门经理跟我谈话说：“真是不好意思，你都来3个月了，直到今天离职我才知道我两是老乡”（他是驻马店的，我是信阳的）。在一个技术部门人数不过20人的公司，部门经理不认识手底下的人，确实应该“不好意思”。而我离职的原因在于，他们只是把我招进去，并不让我干活（活太少），工资也是拖拖拉拉。于是，这第一份3个月955的工作结束了。&lt;/p&gt;
&lt;h2 id=&quot;第二家公司&quot;&gt;第二家公司&lt;/h2&gt;
&lt;p&gt;离职的下一周，我加入了一家创业公司（经朋友介绍），这家创业公司氛围很好，CTO十分给力。在这个团队里，我只因为一次“突击任务”进行了为期一个月的995生活，其他的时间都是965。在这家公司工作真的非常爽，CTO能力超强，他即是产品也是技术的架构，也管任务的拆分，也定项目的进度安排。我们每个人的工作都十分确定，目标也十分确定，他在trello 中给每个人建好任务列表，我们这些干活的人就像是打“消消乐”游戏一样，把每一条待完成的任务写完，然后拖到已完成列表。每天都能消除好多条任务，大家眼见这每日目标一点点达成，非常有成就感，每天都是准点一起下班，无比的开心和充实。在这里，没有时间的浪费，十分高效，也就无需996了。&lt;br/&gt;然而，一年半之后，公司融资没到位，几位创始人多番努力之下，还是无力回天，我们拿着N+1遗憾离职。离职那天，我们同事在五道口吃饭聊天到很久，十分的不舍。&lt;/p&gt;
&lt;h2 id=&quot;第三家公司&quot;&gt;第三家公司&lt;/h2&gt;
&lt;p&gt;在第二家公司离职之后，我整个人懵了2天。我觉得我们产品做的非常好，我们干的非常起劲，我也非常喜欢那家公司的同事以及公司的氛围。怎么就忽然要“分手”了呢？23岁的我从情感上无法接受，因此并没有急于找下一份工作。然而，第三家公司找上了我，这是一家大公司，有自己的办公园区，集团旗下有好几个公司，面试之前我精心准备了，CTO觉得我是个有干劲的小伙子，我也感觉跟着这个大叔挺不错，也参观了一下办公环境，咨询了一下公司的各方面，感觉很满意，很想去。几天后我拿到offer，成功入职。实事证明，我这次的判断十分准确，公司氛围真的超好，CTO也真的超级棒。我在这里度过了我职业生涯最开心、最充实、最有意义的2年。在这家公司工作的期间，我是CTO的“得力干将”之一，只要有什么任务需求，CTO基本第一个想到让我去参与干，在群里@我。我干的很起劲，也获得了提前转正，也赢得了被动涨薪（“被动涨薪”指的是我并没有没提，CTO主动给我涨了）。在这里我觉得我得到了极大的认可，我得到了极大的放权，我有限的能力得到了充分的发挥。在这里依然是965，周末偶尔在家处理一些问题，也都是我自愿，且乐意为之。&lt;/p&gt;
&lt;h2 id=&quot;第四家公司&quot;&gt;第四家公司&lt;/h2&gt;
&lt;p&gt;上家公司那么喜欢，那么好，为什么走了呢？因为CTO因为非正常原因走了之后，我也遭受了新CTO的办公室政治等原因，无奈主动离职。而后来到了第4家公司一干就是3年半，这家公司是我待过“最离谱”的公司，离谱到什么程度呢？——6点下班，6:00就有人打卡了（能听到走廊打卡机的声音）6:05人走了一半，6:20就剩几个人了，6:30没走的就是要上线的。这家公司完全没有PUA，一丁点都没有，一切全靠主动，我觉得这家公司的理念是“老板相信你会自主把手头的活干好”，所以没有那么多的强制要求，不存在谁下班早不合群，谁比领导走的早会遭殃。事实上，我在这家公司，除了做好自己产品需求，还自发的做了很多优化。也仍然没有加班过，只是一年有那么三五次大一点的上线会弄到很晚。其他时间都是离谱到“6:00下班”，北京的夏天6点下班真的太阳很晒，很热。周末从不加班，加班也是给钱，法定假日加班妥妥的3倍工资。在996盛行的互联网行业，这简直是“离谱”！离谱到极致！&lt;/p&gt;
&lt;h2 id=&quot;第五家公司&quot;&gt;第五家公司&lt;/h2&gt;
&lt;p&gt;现在的公司和之前的几家相比，紧张了很多很多。任务非常多，需求非常急，还常常搞并行。这个任务还在开发，后面的2个需求文档就送过来了，天天让你评估需求，评估工期，安排资源进度。真的是压得人喘不过气。然而，你想不到的是，这边也没有强制加班这么一说，10点上班，19点下班（往前推一个小时就是965了）。活就是这么多，工期和资源你要是能安排好，你可以965满负荷进行，不必加班，如果你真的没评估好时间进度，那只能加加班了。因为很多项目排期拍好了之后是不能变的，因为涉及的资源太多了，牵扯的事情太多了，各方都排好了，你延期了你就得耽误别的团队，整体损失严重。&lt;br/&gt;我承认在这里真的很忙，但是我发现：只要我足够认真，足够用心的去分析设计好项目进度安排，并充分利用工作日的时间，不要中途玩手机不要划水，965完全没问题。事实上，我大多数时候都是19:10左右下班的，少部分时间是20:00下班的。总体来说，也是约等于965，就算不能全等于965，但是已经很接近了。&lt;/p&gt;

&lt;p&gt;我曾想过，“为何我所选择的公司都是965“，其实我并没有完全总结出来原因，毕竟“当局者迷”。我觉得有一部分的原因是“个人性格使然”。我不是那种很喜欢“卖命”的人，不是一个特别“卖力”的人，是一个“点到为止”这样心态的人，是一个“不太勤快”的人。我不是很认可通过“加班”的形式去赶任务，我觉得编程是个脑力脑洞，需要重复的思考和梳理，是急不得的，与其草草的写出一堆bug，不如稍微不那么快写出稳健一点的应用。我还觉得，我们应该砍需求，而不是盲目的做一对没用的需求，成天忙的要死，实际上是“无价值”的忙碌。我不认可大家一起“造业绩，骗老板的钱”这种工作模式。&lt;br/&gt;也许是这样的“指导思想”，潜移默化的影响了我找工作时候的会关注点，和心态。我甚至没有刻意，却总能找到不需要996的公司。&lt;br/&gt;我没有遭遇996，其实还有一个原因——我没有去过一线大厂。且不谈我的能力够不够去大厂，奇怪的是我从来没有想过去一个大厂，大厂似乎对我没有吸引力，我似乎没有那么大的兴趣去。可能是我没有“野心”，没有“上进心”吧！&lt;/p&gt;

&lt;p&gt;说996是大厂的代名词，不过分吧？——一点都不过分，毕竟现在的大厂几乎都是996，而小公司没有996的需求。既然996能够作为大厂的代名词，那么“我没有996”就等于我没有去大厂工作。没去大厂工作等于什么？就等于我少挣了一大笔钱，比如昨天看到匿名区一个某大厂的程序员说“自己年终奖34万，觉得加班苦，但是钱很香，值！”。&lt;br/&gt;如果是我我也觉得很值，一年加班能给自己加34万，作为一个占据社会财富10%的90%人群中的一员，一年多这34万是无比的香。当然了，没必要质疑这个34万的真假，我曾跟够大厂的员工聊过（因为工作上的合作，曾一起办公过几天）对方大概讲了各个层次年终奖最差几个月以及自己知道的都是几个月。因此我觉得34万这个信息不需要质疑。&lt;br/&gt;我还失去了什么，我失去了996大厂潜在的能力提升赛道、失去了潜在的优质人脉赛道、失去了挣更多的钱的机会、失去了在大厂找一个优秀老婆的可能性、失去了和一位大厂老婆结合，二人“强强联手”在一线城市购买千万房子的机会。&lt;br/&gt;是这样吗？不是，这一切都是意淫。虽然我们可以根据一定的规则推断和分析预判。然而人生之路并没有那么简单。即使你计划的很好，也不一定能实现目标，即使你十分的努力，也不见得能100%达成期望的结果。&lt;br/&gt;然而我少挣了一些钱，这倒是真的，因为平均来讲，同样的水平和级别大厂开的薪资要高很多。所以，这7年，没有996，我可能真的少挣了二百万。&lt;/p&gt;

&lt;p&gt;没有996，我看起来还算年轻，感觉比实际年龄小1岁吧（也许996的人也一样年轻），发量也得到较好的保持（也许996的人也一样发量充足）。前几年我一直都是下班回家吃老婆做的晚饭，吃完饭跟老婆去楼下丢垃圾散散步，周末去外面转转，用手机拍一些照片。​赔小孩子玩，给小孩子洗澡。同时也利用闲余时间看了一些技术书籍，我也看了一系列闲书（跟技术无关）。&lt;br/&gt;这都是我自己的时间，尽管我并没有用这些时间创造非常大的价值，但是这是我自己可以支配并浪费的时间。我并没有去吃晚上7:30的点加班餐，或是品尝9点的夜宵，或是10点的免费打车。作为一个非常普通的普通人，我只是按照自己的方式自由的浪费自己的时间。&lt;br/&gt;如果非要让我说我得到了什么，我还真的无法量化的给你看（这一点，到不如加班得到34万这么直观的可以衡量）。&lt;/p&gt;

&lt;p&gt;从互联网就业环境来讲，996的公司确实不在少数，以至于从概率上讲，我们很大程度上能碰到996的公司。每一次网上爆发996的热度悲剧事件的时候，一批人说“996公司是万恶之源”，我们要抵制；另一帮人又说其实每个人都可以有自己的选择。&lt;br/&gt;首先我想说说“任何人都有选择”的问题，我想请问：你觉得真的有选择吗？你在各个事情是都有选择吗？。从主观上来讲，我们确实是有自己的选择，但是从客观上来讲就不一定“真的有自我选择了”。举个例子：你有手机的自主选择权吗？我觉得我没有，我需要的是一款屏幕大小为4寸左右的手机，因为我手不大，真的不喜欢双手捧个打手机，那么高的像素我也不需要，我就拍简单的照片，多出来的配置就以为了多付出很多钱，就我这需求，我能在市面上买到对应的手机吗？我买不到！我没得选，我只能在一堆大屏幕手机里边选。我是有自主选择手机的权利，但是我选择的对象就是那些，我不选就没得用，除非我自己给自己量身定做一个手机。或者我接受这个事实，退而求其次买个老人机。&lt;br/&gt;工作也是一样，我们是可以自主选择那些不加班的工作，选择离家近的工作，选择压力小的工作。但是如果所有的公司都是强度高，压力大，你有得选吗？没得选，996和非996公司在待遇上、技术氛围上、逼格上、发展前途上两级分化严重，势必让那些人“高不成低不就”只能选择在利好的地方被强奸。&lt;br/&gt;再说，“996是否是万恶之源”，“996是否应该抵制”的问题，这个问题太复杂了，我所具备的知识还无法给与科学完备的解释。我现在是一名员工，我能看到的只是手头的工作，我不希望996。如果我是老板，我有一家公司，我会把公司变成996公司吗？我会变成疯狂压榨剩余价值的人吗？我不确定，我现在可以说“我不是那样的人”，万一我入场之后就变了呢？不好说，人是不确定的，未来也是不确定的。&lt;br/&gt;而那些想“以个人之力反对996”，“以辞职表明我与996势不两立态度”，“从我做起改变社会”等情况，其实也许都是“徒劳”，你不去，有人去，你做不了，有人能做得了，这不是三两个人就能改变的事情，这个事情的前因后果极其复杂，你的抵制和赞同也许都是肤浅的。对于那些因为996的根本原因而丧命，或者在精神上遭受严重损失，或者在身体健康方面遭受严重损失的同行，我深表遗憾，哪个年轻生命的陨落不让人心痛呢？对于这些人的情况来说，最亏的是他自己，最伤的是他的亲人。&lt;/p&gt;

&lt;p&gt;所以，总结一下：&lt;strong&gt;我对于996的看法是：我没有看法，也没有建议，不赞同，也不反对&lt;/strong&gt;,这个问题太复杂我真的说不清楚。如果是我的好朋友，我的身边的人问我：我要不要去那家996公司啊？我要不要继续996啊？我会说：能干就干，不能干就不干，想干就干，不相干就不干，根据自己的情况做选择，自己做决定。&lt;br/&gt;&lt;strong&gt;其实每个人心中都有答案。特别是你在寻求别人意见的时候……&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 15:35:00 +0000</pubDate>
<dc:creator>逃离沙漠</dc:creator>
<og:description>近几年“996”的话题热度不断，或者说996话题在“互联网从业者”圈子中热度不断。然而每一次，我都感觉这个话题“跟我无关”，因为我真的965了七年。曾经有人这么说我：“你都不像一个程序员，程序员哪有下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/demingblog/p/14264979.html</dc:identifier>
</item>
<item>
<title>SQL Server On Linux：基于实际项目案例，总结功能支持情况及相关问题解决方案 - 赖天卓水</title>
<link>http://www.cnblogs.com/camelliabloglyf/p/14262631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/camelliabloglyf/p/14262631.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上个月，有个朋友问我说Sql Sever向Mysql迁移有什么好的经验分享，他们公司客户明确提出不再提供Windows服务器，现在计划Mysql迁移。我说Mysql迁移成本太高了，不妨可以了解一下SQL Server On Linux再做决定。于是，我把之前给运维分享的Word文档发给了他，告诉他，如果可以接受一些不支持的功能，选择成本，风险小的，如果项目中用到的技术知识刚好避开了那些不支持的功能，3~5个小时可以完成一个项目的迁移。我们公司也有案例，在Linux平台上，同时安装了Sqlserver2017和Mysql,旧功能升级Sql Server，新功能用Mysql。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上周他很高兴的告诉我，他们公司最终选择了SQL Server On Linux，已经完成了一个大项目的升级了，目前使用稳定，项目在正常运行中,他说他今年升职加薪有戏了。后来了解到，他们选择Mysql迁移，是因为他们不知道Sqlserver2017及以上版本也是支持Linxu平台的，于是强烈建议我把内容分享到博客园，让一些人少走一些弯路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在过去的20多年中，微软的各大产品靠Windows绑定市场，众多的微软ISV围绕着Windows开发系列产品，形成一个以Windows为核心的生态系统。随着互联网的发展，出现了Google,Facebook,Tencent,Baidu,Alibaba 都是以Linux 操作系统构建的产品生态系统，他们不再是具体的产品，而是提供服务，而且服务所用技术都是开源的，和原来Windows的生态不是同一个维度的世界，微软封闭的生态系统只有慢慢的瓦解。微软也意识到问题的严重性，换了那个称Linux为毒瘤的CEO&lt;strong&gt;史蒂夫·鲍尔默&lt;/strong&gt;，用领导微软云的&lt;strong&gt;萨提亚·纳德拉&lt;/strong&gt;来带领微软走出原来封闭的生态系统，走入开放的云生态系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)     云计算机会比 Windows 大，Windows占微软的营收越来越少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b)     服务器版操作系统市场份额基本是Linux稳占第一把交椅，微软要让自家的数据库市场份额扩大来挤占其他数据库的份额，必然要做出SQL Server on Linux的决定。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　SQL Server 在 Red Hat Enterprise Linux (RHEL)、SUSE Linux Enterprise Server (SLES) 和 Ubuntu 上受支持。 此外，它也可作为 Docker 映像提供，可在 Linux 上的 Docker 引擎或用于 Windows/Mac 的 Docker 上运行。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;215&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;支持的版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;215&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Red Hat Enterprise Linux&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;7.3、7.4、7.5、7.6、8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;215&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SUSE Linux Enterprise Server&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p&gt;&lt;span&gt;v12 SP2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;215&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;16.04&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;18.04&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;215&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Docker&lt;/strong&gt; &lt;strong&gt;引擎&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;
&lt;p&gt;&lt;span&gt;1.8+&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　You need to have at least Ubuntu 16.04 or you will face unmet dependencies problems.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　SQL Server 对 Linux 具有以下系统要求：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;内存：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;2 GB&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;文件系统：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;XFS 或 EXT4（其他文件系统均不受支持，如 BTRFS）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;磁盘空间：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;6 GB&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;处理器速度：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;2 GHz&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;处理器核心数：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;2 个核心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;处理器类型：&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;span&gt;仅兼容 x64&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;&lt;strong&gt;SQL Server&lt;/strong&gt;&lt;strong&gt;版本&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;企业&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;SQL Server Enterprise Edition是高级产品，可提供全面的高端数据中心功能，并具有超快的性能，可为任务关键型工作负载提供高服务水平。可用性组支持总副本（一个主副本，八个辅助副本）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;标准&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;SQL Server Standard Edition为部门和小型组织提供了运行其应用程序的基本数据管理，并支持用于内部部署和云的通用开发工具-以最少的IT资源实现有效的数据库管理。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;网页&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;SQL Server Web版是Web托管者和Web VAP的总拥有成本低的选项，可为小型到大型Web属性提供可伸缩性，可负担性和可管理性。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;&lt;strong&gt;开发者&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;SQL Server Developer&lt;/strong&gt;&lt;strong&gt;版本使开发人员可以在SQL Server之上构建任何类型的应用程序。它包含企业版的所有功能，但已获许可用作开发和测试系统，而不用作生产服务器。SQL Server Developer是构建和测试应用程序的人们的理想选择。&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p&gt;速成版&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Express Edition是入门级的免费数据库，非常适合学习和构建台式机和小型服务器数据驱动的应用程序。对于构建客户端应用程序的独立软件供应商，开发人员和爱好者来说，这是最佳选择。如果需要更高级的数据库功能，则可以将SQL Server Express无缝升级到SQL Server的其他更高端版本。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Choose an edition of SQL Server:
   1. Evaluation (free, no production use rights, 180-day limit)
   2. Developer (free, no production use rights)
   3. Express (free)
   4. Web (PAID)
   5. Standard (PAID)
   6. Enterprise (PAID)
   7. Enterprise Core (PAID)
   8. I bought a license through a retail sales channel and have a product key to enter.
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;下面安装以&lt;strong&gt;Red Hat&lt;/strong&gt;&lt;strong&gt;为例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Wget安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
　yum -y install wget
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　已经安装了就跳过此步。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;安装mssql-server&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　如果 Linux 计算机无法访问联机存储库，则可以直接下载包文件。 这些包位于 Microsoft 存储库中，地址为 &lt;a href=&quot;https://packages.microsoft.com/&quot;&gt;https://packages.microsoft.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)   创建目录下载RPM包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
mkdir -p /opt/sqlserver2017 
cd /opt/sqlserver2017/
wget https://packages.microsoft.com/rhel/7/mssql-server-2017/mssql-server-14.0.3048.4-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       b)   Yum安装mssql-server&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
yum localinstall mssql-server-14.0.3048.4-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111172935491-1718203676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/opt/mssql/bin/mssql-conf setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;运行 mssql-conf setup，按照提示设置 SA 密码并选择版本。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;请确保为 SA 帐户指定强密码（最少 8 个字符，包括大写和小写字母、十进制数字和/或非字母数字符号）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Developer (free, no production use rights)（版本选择2，Developer）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111173308331-1624613040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 验证服务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
systemctl status mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111173351525-1833919620.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;服务启停&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
systemctl stop mssql-server
systemctl start mssql-server
systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装 sqlcmd 和 bcp SQL Server 命令行工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;a) &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;下载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;wget https://packages.microsoft.com/rhel/7.3/prod/msodbcsql-13.1.6.0-1.x86_64.rpm
wget https://packages.microsoft.com/rhel/7.3/prod/mssql-tools-14.0.5.0-1.x86_64.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　  b) &lt;/strong&gt; &lt;strong&gt;安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
yum localinstall msodbcsql-13.1.6.0-1.x86_64.rpm
yum localinstall mssql-tools-14.0.5.0-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;添加环境变量&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　为方便起见，向 PATH 环境变量添加 &lt;code&gt;/opt/mssql-tools/bin/&lt;/code&gt;。 这样可以在不指定完整路径的情况下运行这些工具。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　运行以下命令以修改登录会话和交互式/非登录会话的路径：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt;&amp;gt; ~/&lt;span&gt;.bash_profile
echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt;&amp;gt; ~/&lt;span&gt;.bashrc
source &lt;/span&gt;~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置远程连接，打开端口&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　默认的 SQL Server 端口为 TCP 1433。 如果为防火墙使用的是 &lt;strong&gt;FirewallD&lt;/strong&gt;，则可以使用以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo firewall-cmd --zone=&lt;span&gt;public&lt;/span&gt; --add-port=&lt;span&gt;1433&lt;/span&gt;/tcp --&lt;span&gt;permanent
sudo firewall&lt;/span&gt;-cmd --reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　使用 SQL Server 名称 (-S)，用户名 (-U) 和密码 (-P) 的参数运行 sqlcmd 。 用户名为 &lt;code&gt;SA&lt;/code&gt;，密码是在安装过程中为 SA 帐户提供的密码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　sqlcmd -S localhost -U SA -P &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;YourPassword&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
　sqlcmd &lt;/span&gt;-S &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.XXX -U userName
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接着输入密码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
SELECT Name FROM Master..SysDatabases ORDER BY Name
SELECT Name FROM Sys.Databases ORDER BY Name
go
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111174153367-653211830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此时可以用Navicat或者SqlServer2017验证连接情况。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;安装设置Agent（SQL Server代理）&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　SQL Server Agent 也叫SQL Server代理，以前称为SQL执行者，这是SQL Server&lt;/span&gt;&lt;span&gt;的任务日程表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种服务主要是用于在设定的时间备份、复制数据，以及在自动执行调度表上设置的其他项目。启动这个服务后，设定好在什么时候做什么事，这个服务会让它自动运行，不需要人工干预。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　a) &lt;/strong&gt; &lt;strong&gt;下载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
wget https://packages.microsoft.com/rhel/7/mssql-server-2017/mssql-server-agent-14.0.3015.40-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　b) &lt;/strong&gt; &lt;strong&gt;安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
yum localinstall mssql-server-agent-14.0.3015.40-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　c) &lt;/strong&gt; &lt;strong&gt;启用代理（作业）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用 sqlagent.enabled 设置可启用 SQL Server 代理。 默认情况下，SQL Server 代理处于禁用状态。 如果 mssql.conf 设置文件中不存在 sqlagent.enabled，则 SQL Server 在内部假定已禁用 SQL Server 代理。若要更改此设置，请使用以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo /opt/mssql/bin/mssql-conf set sqlagent.enabled true
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　d) &lt;/strong&gt; &lt;strong&gt;代理错误日志设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sqlpagent.errorlogfile 和 sqlpagent.errorlogginglevel 设置允许你分别设置 SQL 代理日志文件路径和日志记录级别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sudo /opt/mssql/bin/mssql-conf set sqlagent.errorfile &lt;strong&gt;&amp;lt;path&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SQL 代理日志记录级别是位掩码值，等于：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1 = 错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2 = 警告&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4 = 信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果要捕获所有级别，请使用 &lt;code&gt;7&lt;/code&gt; 作为值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
　sudo /opt/mssql/bin/mssql-conf set sqlagent.errorlogginglevel 7
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置默认语言与排序规则&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　a)   若要获取支持的排序规则的列表，请运行 sys.fn_helpcollations 函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SELECT NAME FROM SYS.FN_HELPCOLLATIONS()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111181214090-42922947.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b)   &lt;span&gt;如果安装时没有指定环境变量参数，会按默认设置安装，字符集会是拉丁字符集，默认语言是英语，此时中国用户需要进行另外设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
systemctl stop mssql-server
/opt/mssql/bin/mssql-conf set-collation
Chinese_PRC_CI_AS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;c)   可以通过预先设置环境变量来按照指定的字符集及本地语言等设置参数，这样的话无需安装后再进行配置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MSSQL_LCID=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2052&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; MSSQL_COLLATION=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chinese_PRC_CI_AS&lt;/span&gt;&lt;span&gt;'&lt;br/&gt;&lt;/span&gt;/opt/mssql/bin/mssql-conf setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　d)   查询当前排序规则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; serverproperty(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Collation&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置内存限制&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　使用 memory.memorylimitmb 设置可控制 SQL Server 可用的物理内存量（以 MB 为单位）。 默认值为物理内存的80%。（我们根据情况而定，更改此设置时，不要将此值设置得太高。 如果不留出足够的内存，则可能会遇到 Linux 操作系统和其他 Linux 应用程序的问题）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)   使用 memory.memorylimitmb 的 set 命令以根用户身份运行 mssql-conf 脚本 。 以下示例将 SQL Server 可用的内存更改为 3.25 GB (3328 MB)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo /opt/mssql/bin/mssql-conf &lt;span&gt;set&lt;/span&gt; memory.memorylimitmb &lt;span&gt;6656&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　b)   重启 SQL Server 服务以应用更改&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;更改TCP端口&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　使用 network.tcpport 设置可更改 SQL Server 侦听连接的 TCP 端口。 默认情况下，此端口设置为 1433。 若要更改端口，请运行以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　a)  使用“network.tcpport”的“set”命令以根用户身份运行mssql-conf 脚本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo /opt/mssql/bin/mssql-conf set network.tcpport &amp;lt;new_tcp_port&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　b)  重启 SQL Server 服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;c)  连接到 SQL Server 后，必须在主机名或 IP 地址后用逗号 (,) 指定自定义端口。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;例如，要使用 SQLCMD 进行连接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sqlcmd -S localhost,&amp;lt;new_tcp_port&amp;gt; -U test -P test&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# iptables -A INPUT -p tcp --dport &lt;span&gt;1433&lt;/span&gt; -&lt;span&gt;j ACCEPT
# iptables&lt;/span&gt;-save &amp;gt; /etc/sysconfig/&lt;span&gt;iptables
# firewall&lt;/span&gt;-cmd --add-port=&lt;span&gt;1433&lt;/span&gt;/tcp --&lt;span&gt;permanent
# firewall&lt;/span&gt;-cmd --reload
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;更改默认数据或日志目录位置&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　使用 filelocation.defaultdatadir 和 filelocation.defaultlogdir 设置可更改创建新数据库和日志文件的位置 。 默认情况下，此位置为 /var/opt/mssql/data。 若要更改这些设置，请使用以下步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)   为新的数据库数据和日志文件创建目标目录。 以下示例创建一个新的&lt;strong&gt;/mssql/data&lt;/strong&gt;目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir -p /mssql/data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　b)   将目录的所有者和组更改为 &lt;strong&gt;mssql&lt;/strong&gt; 用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;数据目录的上一级目录必须设置mssql用户才会有权限！！！！（与Mysql的不同）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo chown mssql /mssql
sudo chgrp mssql /mssql
sudo chown mssql /mssql/data
sudo chgrp mssql /mssql/data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　c)   使用 mssql-conf 通过 set 命令更改默认数据目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo /opt/mssql/bin/mssql-conf &lt;span&gt;set&lt;/span&gt; filelocation.defaultdatadir /mssql/data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　现在，为新数据库创建的所有数据库文件都将存储在此新位置。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　d)   更改新数据库的日志文件 (.ldf) 位置，可以使用下面的“set”命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
mkdir -p /mssql/mssqllog
sudo chown mssql /mssql/mssqllog
sudo chgrp mssql /mssql/mssqllog
sudo /opt/mssql/bin/mssql-conf set filelocation.defaultlogdir /mssql/mssqllog　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　e)   重启 SQL Server 服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;更改默认转储目录位置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　使用 filelocation.defaultdumpdir 设置可更改每当系统崩溃时生成内存和 SQL 转储的默认位置。 默认情况下，这些文件在 /var/opt/mssql/log 中生成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　若要设置新位置，请使用以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)   新的转储文件创建目标目录。 以下示例创建一个新的 &lt;strong&gt;/mssql/mssql&lt;/strong&gt;dump 目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo mkdir /mssql/mssqldump
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　b)   将目录的所有者和组更改为 &lt;strong&gt;mssql&lt;/strong&gt; 用户&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo chown mssql /mssql/mssqldump
sudo chgrp mssql /mssql/mssqldump
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　c)   使用 mssql-conf 通过 set 命令更改默认数据目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo /opt/mssql/bin/mssql-conf set filelocation.defaultdumpdir /mssql/mssqldump
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　d)   重启 SQL Server 服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;启用可用性组(默认不用开启)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　使用 hadr.hadrenabled 选项可在 SQL Server 实例上启用可用性组。 下面的命令通过将 hadr.hadrenabled 设置为 1 来启用可用性组。 必须重启 SQL Server，该设置才能生效。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sudo /opt/mssql/bin/mssql-conf set hadr.hadrenabled  1
sudo systemctl restart mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;验证创建库&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a)   创建创建库的存储过程，如有这个存储过程就不用创建了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
CREATE PROCEDURE [dbo].[PROC_CREATE_DB]
    @DB_NAME  varchar(100),
    @data_path_root varchar(256) = 'D:\DBData\' --'/mssql/data/'
AS
BEGIN
    IF DB_ID (@DB_NAME) IS NOT NULL
    EXECUTE ('DROP DATABASE ' + @DB_NAME)
    
    -- execute the CREATE DATABASE statement 
    EXECUTE ('CREATE DATABASE ' + @DB_NAME + '
    ON 
    ( NAME = '''+ @DB_NAME +''',
        FILENAME = '''+ @data_path_root + @DB_NAME + '.mdf'',
        SIZE = 500,
        MAXSIZE = UNLIMITED,
        FILEGROWTH = 500 )
    LOG ON
    ( NAME = '''+ @DB_NAME +'_log'',
        FILENAME = '''+ @data_path_root + @DB_NAME + '_log.ldf'',
        SIZE = 50MB,
        MAXSIZE = UNLIMITED,
        FILEGROWTH = 50 )'
    )
    EXECUTE ('ALTER DATABASE ' + @DB_NAME  + ' SET RECOVERY SIMPLE')
END　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　b)   执行创建库的存储过程，注意路径&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
EXEC PROC_CREATE_DB '库名','/mssql/data/'  --库名、路径
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;查询当前时间&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;如果与当前时间不符，则需要修改系统时间：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
clock --set --date=&quot;2020-10-19 19:30:39&quot;
clock –hctosys
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; GETDATE()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111182602655-780618099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果一台服务器同时部署了mysql，则修改时间后要去mysql查询当前时间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
select now()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111182634221-566024985.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;创建用户并分配权限&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　需要SA用户登录才有权限设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a)   应用程序和管理人员账号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　Linux上的SQL Server不支持ADMINISTER BULK OPERATIONS权限或bulkadmin角色。只有sysadmin可以在Linux上对SQL Server执行批量插入。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　sysadmin读写权限比较高，专门给系统相关程序或管理员使用，不得通过任何人为方式使用。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
DECLARE @loginName VARCHAR(50) = '用户名'
DECLARE @loginPassword VARCHAR(50) = '密码'
IF EXISTS(SELECT 1 FROM sys.syslogins WHERE name = @loginName)
BEGIN
        PRINT '登录名【' + @loginName + '】已存在。'
        RETURN
END

DECLARE @sql VARCHAR(8000)
SET @sql = 'CREATE LOGIN ' + @loginName + ' WITH PASSWORD = ''' + @loginPassword + ''''
EXEC(@sql) 
--分配角色
EXEC sys.sp_addsrvrolemember @rolename = 'sysadmin', @loginame = @loginName
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　所以，如果是部署在&lt;strong&gt;Windows&lt;/strong&gt;的话，程序账户用bulkadmin、dbcreator。建议不用sysadmin。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
EXEC sys.sp_addsrvrolemember @rolename = 'bulkadmin', @loginame = @loginName
EXEC sys.sp_addsrvrolemember @rolename = 'dbcreator', @loginame = @loginName
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;删除用户（不要手贱！）&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　a)      在删除该登录名之前,请更改相应数据库的所有者。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
USE [SLSW_YN]; 
EXEC dbo.sp_changedbowner @loginame = N'sa', @map = false;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;@map: 将别名及其权限移交给新的数据库所有者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　找到对应用户所拥有的数据库权限，并转给其他用户,如SA用户。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
SELECT 'use ['+A.NAME+']; exec dbo.sp_changedbowner @loginame = N''sa'', @map = false; '
FROM SYS.DATABASES A
INNER JOIN SYS.SYSLOGINS B ON A.OWNER_SID=B.SID
WHERE B.NAME='用户名'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　b)   执行a）产生的所有SQL语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   c)   杀掉账号所有线程再删除账号（不杀的话，禁用以后，原来打开的进程依然可以运行）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
CREATE PROC [dbo].[PROC_mgr_login_process_kill_all]
@loginName VARCHAR(255)
AS
BEGIN
DECLARE @processes TABLE
(
ID INT IDENTITY(1, 1),
spid INT,
ecid INT,
status VARCHAR(50),
loginname VARCHAR(255),
hostname VARCHAR(255),
blk INT,
dbname VARCHAR(255),
cmd VARCHAR(8000),
request_id INT
)

DECLARE @sql VARCHAR(8000)
SET @sql = 'EXEC sp_who ''' + @loginName + ''''

INSERT INTO @processes
(
spid,
ecid,
status,
loginname,
hostname,
blk,
dbname,
cmd,
request_id
)
EXEC(@sql)

DECLARE @iLoop INT
DECLARE @totalCount INT

SELECT @iLoop = 1,
@totalCount = COUNT(*)
FROM @processes

WHILE @iLoop &amp;lt;= @totalCount
BEGIN
DECLARE @spid INT
SELECT @spid = spid FROM @processes WHERE ID = @iLoop

SET @sql = 'KILL ' + CAST(@spid AS VARCHAR(20))
EXEC(@sql)

SET @iLoop += 1
END
EN
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
EXEC MTNOH_AAA_DB.[dbo].[PROC_mgr_login_process_kill_all] '用户名';
EXEC sys.sp_droplogin @loginame = '用户名';
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;mssql.conf格式配置&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　类似mysql的etc/my.cnf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　/var/opt/mssql/mssql.conf&lt;/strong&gt;文件提供了每个设置的示例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　cat /var/opt/mssql/mssql.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;自 &lt;span lang=&quot;EN-US&quot;&gt;CU20&lt;/span&gt; 起，&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017&lt;/span&gt; 开始支持 &lt;span lang=&quot;EN-US&quot;&gt;RHEL 8&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;以下用于 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017&lt;/span&gt; 的命令指向 &lt;span lang=&quot;EN-US&quot;&gt;RHEL 8&lt;/span&gt; 存储库。&lt;span lang=&quot;EN-US&quot;&gt; RHEL 8&lt;/span&gt; 未预安装 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 所需的 &lt;span lang=&quot;EN-US&quot;&gt;python2&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;在开始 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 的安装步骤之前，请执行以下命令，并验证是否选择了 &lt;span lang=&quot;EN-US&quot;&gt;python2&lt;/span&gt; 作为解释器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo alternatives --config python
# If not configured, install python2 and openssl10 using the following commands:
sudo yum install python2
sudo yum install compat-openssl10
# Configure python2 as the default interpreter using this command:
sudo alternatives --config python
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　有关详细信息，请参阅以下博客，了解如何安装 &lt;span lang=&quot;EN-US&quot;&gt;python2&lt;/span&gt; 并将其配置为默认解释器：&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://www.redhat.com/en/blog/installing-microsoft-sql-server-red-hat-enterprise-linux-8-beta&quot;&gt;&lt;span&gt;https://www.redhat.com/en/blog/installing-microsoft-sql-server-red-hat-enterprise-linux-8-beta&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　如果使用 &lt;span lang=&quot;EN-US&quot;&gt;RHEL 7&lt;/span&gt;，请将以下路径更改为&lt;span lang=&quot;EN-US&quot;&gt; /rhel/7 &lt;/span&gt;而不是&lt;span lang=&quot;EN-US&quot;&gt; /rhel/8&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;安装&lt;span lang=&quot;EN-US&quot;&gt;mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span&gt;  下载&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017 Red Hat&lt;/span&gt; 存储库配置文件并安装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo curl -o /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/8/mssql-server-2019.repo
sudo yum install -y mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果想安装 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019&lt;/span&gt;，必须改为注册 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019&lt;/span&gt; 存储库。 使用以下命令安装 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo curl -o /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/8/mssql-server-2019.repo
sudo yum install -y mssql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
/opt/mssql/bin/mssql-conf setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　运行 &lt;span lang=&quot;EN-US&quot;&gt;mssql-conf setup&lt;/span&gt;，按照提示设置 &lt;span lang=&quot;EN-US&quot;&gt;SA&lt;/span&gt; 密码并选择版本。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;安装&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;sqlcmd&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;bcp SQL Server&lt;/span&gt; &lt;span&gt;命令行工具&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　下载 &lt;span lang=&quot;EN-US&quot;&gt;Microsoft Red Hat&lt;/span&gt; 存储库配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo curl -o /etc/yum.repos.d/msprod.repo https://packages.microsoft.com/config/rhel/8/prod.repo
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　如果安装了早期版本的&lt;span lang=&quot;EN-US&quot;&gt; &lt;strong&gt;mssql-tools&lt;/strong&gt;&lt;/span&gt;，请删除所有旧的 &lt;span lang=&quot;EN-US&quot;&gt;unixODBC&lt;/span&gt;包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo yum remove unixODBC-utf16 unixODBC-utf16-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　使用 &lt;span lang=&quot;EN-US&quot;&gt;unixODBC&lt;/span&gt; 开发人员包安装&lt;span lang=&quot;EN-US&quot;&gt; &lt;strong&gt;mssql-tools&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo yum install -y mssql-tools unixODBC-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　…………&lt;/p&gt;
&lt;p&gt;　　其他参考脱机安装章节&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#!/bin/bash -e

# Use the following variables to control your install:

# Password for the SA user (required)
MSSQL_SA_PASSWORD='&amp;lt;YourStrong!Passw0rd&amp;gt;'

# Product ID of the version of SQL server you're installing
# Must be evaluation, developer, express, web, standard, enterprise, or your 25 digit product key
# Defaults to developer
MSSQL_PID='evaluation'

# Install SQL Server Agent (recommended)
SQL_ENABLE_AGENT='y'

# Install SQL Server Full Text Search (optional)
# SQL_INSTALL_FULLTEXT='y'

# Create an additional user with sysadmin privileges (optional)
# SQL_INSTALL_USER='&amp;lt;Username&amp;gt;'
# SQL_INSTALL_USER_PASSWORD='&amp;lt;YourStrong!Passw0rd&amp;gt;'

if [ -z $MSSQL_SA_PASSWORD ]
then
  echo Environment variable MSSQL_SA_PASSWORD must be set for unattended install
  exit 1
fi

echo Adding Microsoft repositories...
sudo curl -o /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/7/mssql-server-2017.repo
sudo curl -o /etc/yum.repos.d/msprod.repo https://packages.microsoft.com/config/rhel/7/prod.repo

echo Installing SQL Server...
sudo yum install -y mssql-server

echo Running mssql-conf setup...
sudo MSSQL_SA_PASSWORD=$MSSQL_SA_PASSWORD \
     MSSQL_PID=$MSSQL_PID \
     /opt/mssql/bin/mssql-conf -n setup accept-eula

echo Installing mssql-tools and unixODBC developer...
sudo ACCEPT_EULA=Y yum install -y mssql-tools unixODBC-devel

# Add SQL Server tools to the path by default:
echo Adding SQL Server tools to your path...
echo PATH=&quot;$PATH:/opt/mssql-tools/bin&quot; &amp;gt;&amp;gt; ~/.bash_profile
echo 'export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;' &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc

# Optional Enable SQL Server Agent :
if [ ! -z $SQL_ENABLE_AGENT ]
then
  echo Enable SQL Server Agent...
  sudo /opt/mssql/bin/mssql-conf set sqlagent.enabled true
  sudo systemctl restart mssql-server
fi

# Optional SQL Server Full Text Search installation:
if [ ! -z $SQL_INSTALL_FULLTEXT ]
then
    echo Installing SQL Server Full-Text Search...
    sudo yum install -y mssql-server-fts
fi

# Configure firewall to allow TCP port 1433:
echo Configuring firewall to allow traffic on port 1433...
sudo firewall-cmd --zone=public --add-port=1433/tcp --permanent
sudo firewall-cmd --reload

# Example of setting post-installation configuration options
# Set trace flags 1204 and 1222 for deadlock tracing:
#echo Setting trace flags...
#sudo /opt/mssql/bin/mssql-conf traceflag 1204 1222 on

# Restart SQL Server after making configuration changes:
echo Restarting SQL Server...
sudo systemctl restart mssql-server

# Connect to server and get the version:
counter=1
errstatus=1
while [ $counter -le 5 ] &amp;amp;&amp;amp; [ $errstatus = 1 ]
do
  echo Waiting for SQL Server to start...
  sleep 5s
  /opt/mssql-tools/bin/sqlcmd \
    -S localhost \
    -U SA \
    -P $MSSQL_SA_PASSWORD \
    -Q &quot;SELECT @@VERSION&quot; 2&amp;gt;/dev/null
  errstatus=$?
  ((counter++))
done

# Display error if connection failed:
if [ $errstatus = 1 ]
then
  echo Cannot connect to SQL Server, installation aborted
  exit $errstatus
fi

# Optional new user creation:
if [ ! -z $SQL_INSTALL_USER ] &amp;amp;&amp;amp; [ ! -z $SQL_INSTALL_USER_PASSWORD ]
then
  echo Creating user $SQL_INSTALL_USER
  /opt/mssql-tools/bin/sqlcmd \
    -S localhost \
    -U SA \
    -P $MSSQL_SA_PASSWORD \
    -Q &quot;CREATE LOGIN [$SQL_INSTALL_USER] WITH PASSWORD=N'$SQL_INSTALL_USER_PASSWORD', DEFAULT_DATABASE=[master], CHECK_EXPIRATION=ON, CHECK_POLICY=ON; ALTER SERVER ROLE [sysadmin] ADD MEMBER [$SQL_INSTALL_USER]&quot;
fi

echo Done!
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;&lt;span&gt;若要验证&lt;/span&gt; &lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt; 上的 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 的当前版本和版本，&lt;/span&gt;&lt;span&gt;请先安装&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; &lt;span&gt;命令行工具&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　使用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;“sqlcmd”&lt;/span&gt;&lt;span&gt;运行显示&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; &lt;span&gt;版本的&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;Transact-SQL&lt;/span&gt; &lt;span&gt;命令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sqlcmd -S localhost -U SA -Q 'select @@VERSION'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111190108549-1608554281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
select @@VERSION
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111190119184-1980255398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
SELECT SERVERPROPERTY('Edition')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111190139420-1723849435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;span&gt;若要删除 &lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt; 上的&lt;span lang=&quot;EN-US&quot;&gt;“mssql-server”&lt;/span&gt;包，不同平台命令会不一样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;包删除命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;RHEL&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo yum remove mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SLES&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo zypper remove mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Ubuntu&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo apt-get remove mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　删除包不会删除生成的数据库文件。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;如果希望删除数据库文件，请使用以下命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
　sudo rm -rf /var/opt/mssql/
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;span&gt;若要将&lt;span lang=&quot;EN-US&quot;&gt;“mssql-server”&lt;/span&gt;包更新到最新版本，请根据你的平台使用以下命令之一：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;包更新命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;RHEL&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo yum update mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SLES&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo zypper update mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Ubuntu&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;/span&gt; &lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo apt-get install mssql-server&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　这些命令将下载最新包，并替换&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;/opt/mssql/&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;下的二进制文件。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;此操作不会影响到用户生成的数据库和系统数据库。&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　若要升级 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;，请首先&lt;/span&gt;&lt;strong&gt;&lt;span&gt;将配置的存储库更改&lt;span&gt;为所需的 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 版本&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　然后使用同一个 &lt;span lang=&quot;EN-US&quot;&gt;update&lt;/span&gt; 命令升级 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 版本。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　存储库的作用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：用于获取数据库引擎包、&lt;span lang=&quot;EN-US&quot;&gt;mssql-server&lt;/span&gt; 以及相关 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 包 。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　现有五个主要存储库：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;存储库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2019&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql-server-2019&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019&lt;/span&gt; &lt;span&gt;累积更新 &lt;span lang=&quot;EN-US&quot;&gt;(CU)&lt;/span&gt; 存储库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2019 GDR&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql-server-2019-gdr&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019 GDR&lt;/span&gt; &lt;span&gt;存储库仅用于关键更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2019&lt;/span&gt; &lt;span&gt;预览版&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql-server-preview&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2019&lt;/span&gt; &lt;span&gt;预览版和 &lt;span lang=&quot;EN-US&quot;&gt;RC&lt;/span&gt; 存储库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2017&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql-server-2017&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017&lt;/span&gt; &lt;span&gt;累积更新 &lt;span lang=&quot;EN-US&quot;&gt;(CU)&lt;/span&gt; 存储库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2017 GDR&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql-server-2017-gdr&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017 GDR&lt;/span&gt; &lt;span&gt;存储库仅用于关键更新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;span&gt;若要将 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 回滚或降级到以前的版本，请使用以下步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;       a)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;标识要降级到的 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 包的版本号。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;有关包版本号的列表，请参阅&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/linux/sql-server-linux-release-notes?view=sql-server-linux-2017&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;发行说明&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;       b)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;降级到 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 的早期版本。&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;在以下命令中，将&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;&amp;lt;version_number&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;替换为步骤 &lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt; 中标识的 &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt; 版本号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;包更新命令&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;RHEL&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo yum downgrade mssql-server-&amp;lt;version_number&amp;gt;.x86_64&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SLES&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo zypper install --oldpackage mssql-server=&amp;lt;version_number&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;130&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Ubuntu&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;438&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;sudo apt-get install mssql-server=&amp;lt;version_number&amp;gt;&lt;/span&gt;&lt;/code&gt; &lt;span lang=&quot;EN-US&quot;&gt;sudo systemctl start mssql-server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　只支持降级到相同主版本（如&lt;span lang=&quot;EN-US&quot;&gt;SQL Server 2017&lt;/span&gt;）内的版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;span&gt;相比&lt;span lang=&quot;EN-US&quot;&gt;Windows&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;会有些功能不完全支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;MsoTableGrid&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;类别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Windows&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;span&gt;基础语法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;存储过程&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;345&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;包括&lt;span lang=&quot;EN-US&quot;&gt;CLR&lt;/span&gt;函数。不支持设置了&lt;span lang=&quot;EN-US&quot;&gt;EXTERNAL_ACCESS&lt;/span&gt;或&lt;span lang=&quot;EN-US&quot;&gt;UNSAFE&lt;/span&gt;权限的&lt;span lang=&quot;EN-US&quot;&gt;CLR&lt;/span&gt;程序集&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;作业&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;视图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;数据库分区&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;链接服务器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;345&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;只支持&lt;span lang=&quot;EN-US&quot;&gt;SQLServer&lt;/span&gt;链接服务器，不支持&lt;span lang=&quot;EN-US&quot;&gt;Mysql&lt;/span&gt;。低版本连接高版本会出现部分问题&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;系统表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;备份、还原&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;调用&lt;span lang=&quot;EN-US&quot;&gt;bat&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;×&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;旧版本工单创建、更新会用到&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;BCP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;×&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xp_cmdshell&lt;/span&gt;&lt;span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;bulk insert&lt;/span&gt;，数据库入库会乱码&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;文件操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;×&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;xp_cmdshell&lt;/span&gt;&lt;span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;bulk insert&lt;/span&gt;，数据库入库会乱码&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;111&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;维护计划&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;57&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;√&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;55&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;×&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; nowrap=&quot;nowrap&quot; width=&quot;345&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;整库迁移&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　把&lt;span lang=&quot;EN-US&quot;&gt;Sqlserver2008&lt;/span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;Windows&lt;/span&gt;）的数据库迁移到&lt;span lang=&quot;EN-US&quot;&gt;Sqlserver2017&lt;/span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　&lt;span&gt;a) &lt;/span&gt; &lt;span&gt;从Sqlserver2008(Windows)备份&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
SELECT 'BACKUP DATABASE ' + name + ' TO  DISK = N'''
+ 'D:'
+ '\' + name + '.bak''
   WITH COMPRESSION,NOFORMAT, NOINIT,
   NAME = N''' + name + '-完整 数据库 备份'',
   SKIP, NOREWIND, NOUNLOAD,  STATS = 10'
FROM SYS.DATABASES
WHERE NAME IN ('库名1','库名2')
ORDER BY NAME
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111190650422-480677405.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;b)  在Sqlserver2017(Linux)还原&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
exec PROC_CREATE_DB '库名','/mssql/data/'
RESTORE DATABASE SLSW FROM DISK = '/home/slsw1009/SLSW.bak'
WITH
MOVE 'SLSW' TO '/home/mssqldata/SLSW.mdf',
MOVE 'SLSW_log' TO '/home/mssqldata/SLSW.ldf',
STATS = 1, REPLACE, RECOVERY
GO
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/742073/202101/742073-20210111190844811-171940518.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;span&gt;恢复数据库时出现&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Exclusive access could not be obtained because the database is in use&lt;/span&gt;&lt;span&gt;错误，那是因为库正在使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　运行以下&lt;span lang=&quot;EN-US&quot;&gt;query&lt;/span&gt;语句将数据库离线&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;把&lt;span lang=&quot;EN-US&quot;&gt;[db_name]&lt;/span&gt;替换成你的数据库名，下同&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
use master 
alter database [db_name] set offline with rollback immediate
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　接着进行数据库恢复的相关操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
RESTORE DATABASE SLSW FROM DISK = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/slsw1009//SLSW.bak&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
WITH
MOVE &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SLSW&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/mssqldata/SLSW.mdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
MOVE &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SLSW_log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/mssqldata/SLSW.ldf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
STATS &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, REPLACE, RECOVERY
GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　最后执行下面的&lt;span lang=&quot;EN-US&quot;&gt;query&lt;/span&gt;语句将数据库恢复在线&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;use master 
alter database [db_name] &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; online with rollback immediate;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;  &lt;span&gt;c)&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;在&lt;span lang=&quot;EN-US&quot;&gt;Sqlserver&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2017(Linux)&lt;/span&gt;&lt;span&gt;备份&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　备份路径要有&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;mssql&lt;/span&gt;&lt;span&gt;用户的权限&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
mkdir -p /home/mssqlbackup
chown mssql /home/mssqlbackup
chgrp mssql /home/mssqlbackup
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
BACKUP DATABASE TestDB TO  DISK = N'/home/mssqlbackup/TestDB.bak'    
WITH COMPRESSION,NOFORMAT, NOINIT,    
NAME = N'TestDB_BACKUP', SKIP, NOREWIND, NOUNLOAD,  STATS = 10
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; a)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;安装&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;的主机名的长度必须为&lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;个字符或更少&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;解决方法：将&lt;span lang=&quot;EN-US&quot;&gt;/ etc / hostname&lt;/span&gt;中的名称更改为&lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;个字符以下的长度。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; b)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;手动将系统时间倒退设置为时间会导致&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;停止更新&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;中的内部系统时间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;解决方法：重新启动&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; c)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;仅支持单实例安装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;建议在主机上运行多个容器以具有多个不同的实例。使用&lt;span lang=&quot;EN-US&quot;&gt;docker&lt;/span&gt;可以轻松实现这一点，但是每个容器都需要侦听不同的端口&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; d)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;&lt;span&gt;上不支持用户权限&lt;span lang=&quot;EN-US&quot;&gt;ADMINISTER BULK OPERATIONS&lt;/span&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;bulkadmin&lt;/span&gt;服务器角色）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; e)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;SQLServer&lt;/span&gt;&lt;span&gt;和相关工具目前不支持在&lt;span lang=&quot;EN-US&quot;&gt;Windows 10&lt;/span&gt;上运行的&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; f)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;&lt;span&gt;数据和日志目录不支持符号链接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt; g)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;重置系统管理（&lt;span lang=&quot;EN-US&quot;&gt;SA&lt;/span&gt;）密码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
sudo systemctl stop mssql-server
sudo /opt/mssql/bin/mssql-conf setup
sqlcmd -S myserver -U sa -P Test\$\$
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;如果在&lt;span lang=&quot;EN-US&quot;&gt;SQL Server&lt;/span&gt;登录密码中使用某些字符，则在终端的&lt;span lang=&quot;EN-US&quot;&gt;Linux&lt;/span&gt;命令中使用它们时，可能需要使用反斜杠将其转义。例如，在终端命令&lt;span lang=&quot;EN-US&quot;&gt;/ shell&lt;/span&gt;脚本中使用美元符号（&lt;span lang=&quot;EN-US&quot;&gt;$&lt;/span&gt;）时，必须随时对其进行转义&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoListParagraph&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://tldp.org/LDP/abs/html/special-chars.html&quot;&gt;https://tldp.org/LDP/abs/html/special-chars.html&lt;/a&gt;&lt;/span&gt;&lt;span&gt;（特殊字符）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　Translate 函数（实现批量替换）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　string_agg函数（分组合并字符串）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　trim函数（移除左右空格、指定字符）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　string_split函数（拆分字符串）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据转成&lt;span lang=&quot;EN-US&quot;&gt;JSON格式（2016特性）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/linux/sql-server-linux-configure-mssql-conf?view=sql-server-linux-2017%20%EF%BC%88%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%89%20https://www.cnblogs.com/shanyou/p/5272628.html%20&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/linux/sql-server-linux-configure-mssql-conf?view=sql-server-linux-2017&lt;/a&gt; （微软官方文档）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/5272628.html&quot;&gt;https://www.cnblogs.com/shanyou/p/5272628.html&lt;/a&gt; （背景段落摘抄）&lt;/p&gt;

</description>
<pubDate>Mon, 11 Jan 2021 15:26:00 +0000</pubDate>
<dc:creator>赖天卓水</dc:creator>
<og:description>上个月，有个朋友问我说Sql Sever向Mysql迁移有什么好的经验分享，他们公司客户明确提出不再提供Windows服务器，现在计划Mysql迁移。我说Mysql迁移成本太高了，不妨可以了解一下SQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/camelliabloglyf/p/14262631.html</dc:identifier>
</item>
<item>
<title>Spring Security OAuth2.0认证授权三：使用JWT令牌 - 狂盗一枝梅</title>
<link>http://www.cnblogs.com/kuangdaoyizhimei/p/14264844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kuangdaoyizhimei/p/14264844.html</guid>
<description>&lt;p&gt;本篇文章将会讲解集成jwt以及将客户端信息和授权码信息保存到数据库&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;242.99777643016&quot;&gt;
&lt;p&gt;Spring Security OAuth2.0系列文章：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面两篇文章详细讲解了如何基于spring boot + oath2.0搭建认证中心和资源中心，本篇文章将会讲解集成jwt以及将客户端信息和授权码信息保存到数据库。&lt;/p&gt;
&lt;h2 id=&quot;一、-jwt&quot;&gt;一、 JWT&lt;/h2&gt;
&lt;h3 id=&quot;1-jwt简介&quot;&gt;1. JWT简介&lt;/h3&gt;
&lt;p&gt;JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://jwt.io/&quot; target=&quot;_blank&quot;&gt;https://jwt.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准： &lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc7519&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JWT令牌的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）jwt基于json，非常方便解析。&lt;/p&gt;
&lt;p&gt;2）可以在令牌中自定义丰富的内容，易扩展。&lt;/p&gt;
&lt;p&gt;3）通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。&lt;/p&gt;
&lt;p&gt;4）资源服务使用JWT可不依赖认证服务即可完成授权。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）JWT令牌较长，占存储空间比较大，这意味着会耗费一定的带宽资源&lt;/p&gt;
&lt;p&gt;2）JWT签名和验签都要耗费处理器资源&lt;/p&gt;
&lt;h3 id=&quot;2-jwt令牌结构&quot;&gt;2. JWT令牌结构&lt;/h3&gt;
&lt;p&gt;JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 Header&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）一个例子如下：&lt;/p&gt;
&lt;p&gt;下边是Header部分的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{ 
&quot;alg&quot;: &quot;HS256&quot;,
&quot;typ&quot;: &quot;JWT&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 Payload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。&lt;/p&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{ 
&quot;sub&quot;: &quot;1234567890&quot;,
&quot;name&quot;: &quot;456&quot;,
&quot;admin&quot;: true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.3 Signature&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三部分是签名，此部分用于防止jwt内容被篡改。&lt;/p&gt;
&lt;p&gt;这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。&lt;/p&gt;
&lt;p&gt;一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;HMACSHA256( 
base64UrlEncode(header) + &quot;.&quot; +
base64UrlEncode(payload),
secret
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;base64UrlEncode(header)：jwt令牌的第一部分。&lt;/li&gt;
&lt;li&gt;base64UrlEncode(payload)：jwt令牌的第二部分。&lt;/li&gt;
&lt;li&gt;secret：签名所使用的密钥。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、配置jwt&quot;&gt;二、配置JWT&lt;/h2&gt;
&lt;h3 id=&quot;1认证服务配置jwt&quot;&gt;1.认证服务配置JWT&lt;/h3&gt;
&lt;p&gt;TokenConfig类的修改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class TokenConfig {

private static final String SIGNING_KEY = &quot;auth123&quot;;

@Bean
public TokenStore tokenStore() {
return new JwtTokenStore(accessTokenConverter());
}

@Bean
public JwtAccessTokenConverter accessTokenConverter(){
JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
jwtAccessTokenConverter.setSigningKey(SIGNING_KEY);//对称秘钥，资源服务器使用该秘钥来验证
return jwtAccessTokenConverter;
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthorizationServerTokenServices设置Token增强类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private JwtAccessTokenConverter jwtAccessTokenConverter;

@Bean
public AuthorizationServerTokenServices tokenServices(){
DefaultTokenServices services = new DefaultTokenServices();
services.setClientDetailsService(clientDetailsService);
services.setSupportRefreshToken(true);
services.setTokenStore(tokenStore);
services.setAccessTokenValiditySeconds(7200);
services.setRefreshTokenValiditySeconds(259200);

TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
tokenEnhancerChain.setTokenEnhancers(Collections.singletonList(jwtAccessTokenConverter));
services.setTokenEnhancer(tokenEnhancerChain);

return services;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以测试了：&lt;/p&gt;
&lt;p&gt;POST请求接口：&lt;a href=&quot;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;得到响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbIlJPTEVfQURNSU4iLCJST0xFX1VTRVIiLCJST0xFX0FQSSJdLCJleHAiOjE2MTAzNzI5MzUsImF1dGhvcml0aWVzIjpbInAxIiwicDIiXSwianRpIjoiOWQzMzRmZGMtOTcwZC00YmJkLWI2MmMtZDU4MDZkNTgzM2YwIiwiY2xpZW50X2lkIjoiYzEifQ.gZraRNeX-o_jKiH7XQgg3TlUQBpxUcXa2-qR_Treu8U&quot;,
&quot;token_type&quot;: &quot;bearer&quot;,
&quot;refresh_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbIlJPTEVfQURNSU4iLCJST0xFX1VTRVIiLCJST0xFX0FQSSJdLCJhdGkiOiI5ZDMzNGZkYy05NzBkLTRiYmQtYjYyYy1kNTgwNmQ1ODMzZjAiLCJleHAiOjE2MTA2MjQ5MzUsImF1dGhvcml0aWVzIjpbInAxIiwicDIiXSwianRpIjoiN2U1NzE0NTgtNmU2Zi00YjlmLTkxODQtOWUzZmVmZmQ1YTNjIiwiY2xpZW50X2lkIjoiYzEifQ.wyiS-z-xhBPZSODXZHQVDJCQ6dcmeJjAwBPWe2GhT94&quot;,
&quot;expires_in&quot;: 7199,
&quot;scope&quot;: &quot;ROLE_ADMIN ROLE_USER ROLE_API&quot;,
&quot;jti&quot;: &quot;9d334fdc-970d-4bbd-b62c-d5806d5833f0&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现accessToken长了很多，这是因为token是jwt字符串，分为三部分，第二部分payload携带了很多信息，打开jwt.io网站，将上面的accessToken贴上去，可以看到Base64解码后的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.kdyzm.cn/storage/thumbnails/_signature/2B8J8S7BH0UB15MRJNP45M1G6J.png&quot; alt=&quot;2021-01-11_201526.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2资源服务配置&quot;&gt;2.资源服务配置&lt;/h3&gt;
&lt;p&gt;第一步，将认证服务中的TokenConfig直接拷贝到资源服务中&lt;/p&gt;
&lt;p&gt;第二步，修改ResouceServerConfig 类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private TokenStore tokenStore;

@Override
public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
resources
.resourceId(RESOURCE_ID)
// .tokenServices(resourceServerTokenServices)//令牌服务
.tokenStore(tokenStore)
.stateless(true);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可完成资源服务集成jwt的功能。&lt;/p&gt;
&lt;h3 id=&quot;3接口测试&quot;&gt;3.接口测试&lt;/h3&gt;
&lt;p&gt;POST请求 &lt;a href=&quot;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&lt;/a&gt; 获取令牌，获取到accessToken之后携带token GET 请求 &lt;a href=&quot;http://127.0.0.1:30001/r1&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30001/r1&lt;/a&gt; ，得到响应结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;访问资源r1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可证明成功。&lt;/p&gt;
&lt;h2 id=&quot;三、客户端信息保存到数据库&quot;&gt;三、客户端信息保存到数据库&lt;/h2&gt;
&lt;p&gt;认证服务客户端信息还是保存在内存中，现在将其改造放到数据库中&lt;/p&gt;
&lt;h3 id=&quot;1-新建表&quot;&gt;1. 新建表&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;DROP TABLE IF EXISTS `oauth_client_details`;

CREATE TABLE `oauth_client_details` (
`client_id` varchar(255) NOT NULL COMMENT '客户端标识',
`resource_ids` varchar(255) DEFAULT NULL COMMENT '接入资源列表',
`client_secret` varchar(255) DEFAULT NULL COMMENT '客户端秘钥',
`scope` varchar(255) DEFAULT NULL,
`authorized_grant_types` varchar(255) DEFAULT NULL,
`web_server_redirect_uri` varchar(255) DEFAULT NULL,
`authorities` varchar(255) DEFAULT NULL,
`access_token_validity` int(11) DEFAULT NULL,
`refresh_token_validity` int(11) DEFAULT NULL,
`additional_information` longtext,
`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
`archived` tinyint(4) DEFAULT NULL,
`trusted` tinyint(4) DEFAULT NULL,
`autoapprove` varchar(255) DEFAULT NULL,
PRIMARY KEY (`client_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='接入客户端信息';

/*Data for the table `oauth_client_details` */

insert into `oauth_client_details`(`client_id`,`resource_ids`,`client_secret`,`scope`,`authorized_grant_types`,`web_server_redirect_uri`,`authorities`,`access_token_validity`,`refresh_token_validity`,`additional_information`,`create_time`,`archived`,`trusted`,`autoapprove`) values
('c1','res1','$2a$10$X2xVwW.7cOEh2niPqHYAne9EnjRJFj7QI4TqfmnDou9fT/45sCFEm','ROLE_ADMIN,ROLE_USER,ROLE_API','client_credentials,password,authorization_code,implicit,refresh_token','https://www.baidu.com',NULL,7200,259200,NULL,'2021-01-11 09:09:53',0,0,'false'),
('c2','res2','$2a$10$X2xVwW.7cOEh2niPqHYAne9EnjRJFj7QI4TqfmnDou9fT/45sCFEm','ROLE_API','client_credentials,password,authorization_code,implicit,refresh_token','https://www.baidu.com',NULL,31536000,2592000,NULL,'2021-01-11 09:09:56',0,0,'false');

/*Table structure for table `oauth_code` */

DROP TABLE IF EXISTS `oauth_code`;

CREATE TABLE `oauth_code` (
`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
`code` varchar(255) DEFAULT NULL,
`authentication` blob,
KEY `code_index` (`code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述SQL新建了两张表&lt;code&gt;oauth_client_details&lt;/code&gt;以及&lt;code&gt;oauth_code&lt;/code&gt;分别用于存储客户端信息以及授权码信息，由于使用了jwt token（jwt token本身就存储了数据），所以不再保存数据库，两张表均为spring oauth2.0内置表，不需要写SQL，内置框架自动识别表。&lt;/p&gt;
&lt;h3 id=&quot;2修改配置&quot;&gt;2.修改配置&lt;/h3&gt;
&lt;p&gt;对应上述两张表，分别修改Bean对象的创建为jdbc类型的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public AuthorizationCodeServices authorizationCodeServices(DataSource dataSource){
return new JdbcAuthorizationCodeServices(dataSource);
}

@Bean
public ClientDetailsService clientDetailsService(DataSource dataSource) {
JdbcClientDetailsService clientDetailsService = new JdbcClientDetailsService(dataSource);
clientDetailsService.setPasswordEncoder(passwordEncoder);
return clientDetailsService;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后修改客户端配置对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
clients.withClientDetails(clientDetailsService);
// clients.inMemory()
// .withClient(&quot;c1&quot;)
// .secret(new BCryptPasswordEncoder().encode(&quot;secret&quot;))//$2a$10$0uhIO.ADUFv7OQ/kuwsC1.o3JYvnevt5y3qX/ji0AUXs4KYGio3q6
// .resourceIds(&quot;r1&quot;)
// .authorizedGrantTypes(&quot;authorization_code&quot;, &quot;password&quot;, &quot;client_credentials&quot;, &quot;implicit&quot;, &quot;refresh_token&quot;)
// .scopes(&quot;all&quot;)
// .autoApprove(false)
// .redirectUris(&quot;https://www.baidu.com&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成修改。&lt;/p&gt;
&lt;h3 id=&quot;3接口测试-1&quot;&gt;3.接口测试&lt;/h3&gt;
&lt;p&gt;GET请求：&lt;a href=&quot;http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;amp;response_type=code&amp;amp;scope=ROLE_API&amp;amp;redirect_uri=https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30000/oauth/authorize?client_id=c1&amp;amp;response_type=code&amp;amp;scope=ROLE_API&amp;amp;redirect_uri=https://www.baidu.com&lt;/a&gt; 获取授权码后，观察表oauth_code，里面应当已经有了授权码数据。&lt;/p&gt;
&lt;h2 id=&quot;四、源码地址&quot;&gt;四、源码地址&lt;/h2&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v4.0.0&quot; target=&quot;_blank&quot;&gt;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v4.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的博客地址：&lt;a href=&quot;https://blog.kdyzm.cn/&quot; target=&quot;_blank&quot;&gt;https://blog.kdyzm.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 11 Jan 2021 14:58:00 +0000</pubDate>
<dc:creator>狂盗一枝梅</dc:creator>
<og:description>本篇文章将会讲解集成jwt以及将客户端信息和授权码信息保存到数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kuangdaoyizhimei/p/14264844.html</dc:identifier>
</item>
<item>
<title>冷饭新炒：理解Redisson中分布式锁的实现 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/14264804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/14264804.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;在很早很早之前，写过一篇文章介绍过&lt;code&gt;Redis&lt;/code&gt;中的&lt;code&gt;red lock&lt;/code&gt;的实现，但是在生产环境中，笔者所负责的项目使用的分布式锁组件一直是&lt;code&gt;Redisson&lt;/code&gt;。&lt;code&gt;Redisson&lt;/code&gt;是具备多种内存数据网格特性的基于&lt;code&gt;Java&lt;/code&gt;编写的&lt;code&gt;Redis&lt;/code&gt;客户端框架（&lt;code&gt;Redis Java Client with features of In-Memory Data Grid&lt;/code&gt;），基于&lt;code&gt;Redis&lt;/code&gt;的基本数据类型扩展出很多种实现的高级数据结构，具体见其官方的简介图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文要分析的&lt;code&gt;R(ed)Lock&lt;/code&gt;实现，只是其中一个很小的模块，其他高级特性可以按需选用。下面会从基本原理、源码分析和基于&lt;code&gt;Jedis&lt;/code&gt;仿实现等内容进行展开。本文分析的&lt;code&gt;Redisson&lt;/code&gt;源码是&lt;code&gt;2020-01&lt;/code&gt;左右&lt;code&gt;Redisson&lt;/code&gt;项目的&lt;code&gt;main&lt;/code&gt;分支源码，对应版本是&lt;code&gt;3.14.1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;red lock&lt;/code&gt;的基本原理其实就&quot;光明正大地&quot;展示在&lt;code&gt;Redis&lt;/code&gt;官网的首页文档中（具体链接是&lt;code&gt;https://redis.io/topics/distlock&lt;/code&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘录一下简介进行翻译：在许多环境中不同进程必须以互斥方式使用共享资源进行操作时，分布式锁是一个非常有用的原语。此试图提供一种更规范的算法来实现Redis的分布式锁。我们提出了一种称为&lt;code&gt;Redlock&lt;/code&gt;的算法，它实现了&lt;code&gt;DLM&lt;/code&gt;（猜测是&lt;code&gt;Distributed Lock Manager&lt;/code&gt;的缩写，分布式锁管理器），我们认为它比普通的单实例方法更安全。&lt;/p&gt;
&lt;p&gt;算法的三个核心特征（三大最低保证）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Safety property&lt;/code&gt;（安全性）：互斥。确保在任何给定时刻下，只有一个客户端可以持有锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Liveness property A&lt;/code&gt;（活性&lt;code&gt;A&lt;/code&gt;）：无死锁。即使存在曾经锁定资源的客户端崩溃或者出现网络分区异常，确保锁总是能够成功获取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Liveness property B&lt;/code&gt;（活性&lt;code&gt;B&lt;/code&gt;）：容错性。只要大多数&lt;code&gt;Redis&lt;/code&gt;节点处于正常运行状态，客户端就可以获取和释放锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文档中还指出了目前算法对于故障转移的实现还存在明显的竞态条件问题（描述的应该是&lt;code&gt;Redis&lt;/code&gt;主从架构下的问题）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端&lt;code&gt;A&lt;/code&gt;获取&lt;code&gt;Redis&lt;/code&gt;主节点中的锁（假设锁定的资源为&lt;code&gt;X&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Redis&lt;/code&gt;主节点把&lt;code&gt;KEY&lt;/code&gt;同步到&lt;code&gt;Redis&lt;/code&gt;从节点之前，&lt;code&gt;Redis&lt;/code&gt;主节点崩溃&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;从节点因为故障晋升为主节点&lt;/li&gt;
&lt;li&gt;此时，客户端&lt;code&gt;B&lt;/code&gt;获取资源&lt;code&gt;X&lt;/code&gt;的锁成功，问题是资源&lt;code&gt;X&lt;/code&gt;的锁在前面已经被客户端&lt;code&gt;A&lt;/code&gt;获取过，这样就出现了并发问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;算法的实现很简单，单个&lt;code&gt;Redis&lt;/code&gt;实例下加锁命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;SET $resource_name $random_value NX PX $ttl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;Nx&lt;/code&gt;和&lt;code&gt;PX&lt;/code&gt;是&lt;code&gt;SET&lt;/code&gt;命令的增强参数，自从&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;2.6.12&lt;/code&gt;版本起，&lt;code&gt;SET&lt;/code&gt;命令已经提供了可选的复合操作符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;EX&lt;/code&gt;：设置超时时间，单位是秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PX&lt;/code&gt;：设置超时时间，单位是毫秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NX&lt;/code&gt;：&lt;code&gt;IF NOT EXIST&lt;/code&gt;的缩写，只有&lt;code&gt;KEY&lt;/code&gt;不存在的前提下才会设置&lt;code&gt;K-V&lt;/code&gt;，设置成功返回&lt;code&gt;1&lt;/code&gt;，否则返回&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XX&lt;/code&gt;：&lt;code&gt;IF EXIST&lt;/code&gt;的缩写，只有在&lt;code&gt;KEY&lt;/code&gt;存在的前提下才会设置&lt;code&gt;K-V&lt;/code&gt;，设置成功返回&lt;code&gt;1&lt;/code&gt;，否则返回&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单个&lt;code&gt;Redis&lt;/code&gt;实例下解锁命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# KEYS[1] = $resource_name
# ARGV[1] = $random_value
if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用redisson中的rlock&quot;&gt;使用Redisson中的RLock&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;RLock&lt;/code&gt;要先实例化&lt;code&gt;Redisson&lt;/code&gt;，&lt;code&gt;Redisson&lt;/code&gt;已经适配了&lt;code&gt;Redis&lt;/code&gt;的哨兵、集群、普通主从和单机模式，因为笔者本地只安装了单机&lt;code&gt;Redis&lt;/code&gt;，所以这里使用单机模式配置进行演示。实例化&lt;code&gt;RedissonClient&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static RedissonClient REDISSON;

@BeforeClass
public static void beforeClass() throws Exception {
    Config config = new Config();
    // 单机
    config.useSingleServer()
            .setTimeout(10000)
            .setAddress(&quot;redis://127.0.0.1:6379&quot;);
    REDISSON = Redisson.create(config);
//        // 主从
//        config.useMasterSlaveServers()
//                .setMasterAddress(&quot;主节点连接地址&quot;)
//                .setSlaveAddresses(Sets.newHashSet(&quot;从节点连接地址&quot;));
//        REDISSON = Redisson.create(config);
//        // 哨兵
//        config.useSentinelServers()
//                .setMasterName(&quot;Master名称&quot;)
//                .addSentinelAddress(new String[]{&quot;哨兵连接地址&quot;});
//        REDISSON = Redisson.create(config);
//        // 集群
//        config.useClusterServers()
//                .addNodeAddress(new String[]{&quot;集群节点连接地址&quot;});
//        REDISSON = Redisson.create(config);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加锁和解锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testLockAndUnLock() throws Exception {
    String resourceName = &quot;resource:x&quot;;
    RLock lock = REDISSON.getLock(resourceName);
    Thread threadA = new Thread(() -&amp;gt; {
        try {
            lock.lock();
            process(resourceName);
        } finally {
            lock.unlock();
            System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
        }
    }, &quot;threadA&quot;);
    Thread threadB = new Thread(() -&amp;gt; {
        try {
            lock.lock();
            process(resourceName);
        } finally {
            lock.unlock();
            System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
        }
    }, &quot;threadB&quot;);
    threadA.start();
    threadB.start();
    Thread.sleep(Long.MAX_VALUE);
}

private void process(String resourceName) {
    String threadName = Thread.currentThread().getName();
    System.out.println(String.format(&quot;线程%s获取到资源%s的锁&quot;, threadName, resourceName));
    try {
        Thread.sleep(1000);
    } catch (InterruptedException ignore) {
    }
}

// 某次执行的输出结果
线程threadB获取到资源resource:x的锁
线程threadB释放资源resource:x的锁
线程threadA获取到资源resource:x的锁
线程threadA释放资源resource:x的锁
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的时候，我们会选用带等待时间周期和锁最大持有时间的&lt;code&gt;API&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testTryLockAndUnLock() throws Exception {
    String resourceName = &quot;resource:x&quot;;
    int waitTime = 500;
    int leaseTime = 1000;
    Thread threadA = new Thread(() -&amp;gt; {
        process(resourceName, waitTime, leaseTime);
    }, &quot;threadA&quot;);
    Thread threadB = new Thread(() -&amp;gt; {
        process(resourceName, waitTime, leaseTime);
    }, &quot;threadB&quot;);
    threadA.start();
    threadB.start();
    Thread.sleep(Long.MAX_VALUE);
}

private void process(String resourceName, int waitTime, int leaseTime) {
    RLock lock = REDISSON.getLock(resourceName);
    try {
        String threadName = Thread.currentThread().getName();
        boolean tryLock = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);
        if (tryLock) {
            try {
                System.out.println(String.format(&quot;线程%s获取到资源%s的锁&quot;, threadName, resourceName));
                Thread.sleep(800);
            } finally {
                lock.unlock();
                System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }
        } else {
            System.out.println(String.format(&quot;线程%s获取资源%s的锁失败,等待时间:%d ms&quot;, threadName, resourceName, waitTime));
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
// 某次执行的输出结果
线程threadA获取到资源resource:x的锁
线程threadB获取资源resource:x的锁失败,等待时间:500 ms
线程threadA释放资源resource:x的锁
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使用的时候更加简单，可以参考&lt;code&gt;spring-tx&lt;/code&gt;中的编程式事务那样进行轻度封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequiredArgsConstructor
private static class RedissonLockProvider {

    private final RedissonClient redissonClient;

    public &amp;lt;T&amp;gt; T executeInLock(String resourceName, LockAction lockAction) {
        RLock lock = redissonClient.getLock(resourceName);
        try {
            lock.lock();
            lockAction.onAcquire(resourceName);
            return lockAction.doInLock(resourceName);
        } finally {
            lock.unlock();
            lockAction.onExit(resourceName);
        }
    }

    public &amp;lt;T&amp;gt; T executeInLock(String resourceName, int waitTime, int leaseTime, LockAction lockAction) throws InterruptedException {
        RLock lock = redissonClient.getLock(resourceName);
        boolean tryLock = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);
        if (tryLock) {
            try {
                lockAction.onAcquire(resourceName);
                return lockAction.doInLock(resourceName);
            } finally {
                lock.unlock();
                lockAction.onExit(resourceName);
            }
        }
        return null;
    }

    public void executeInLockWithoutResult(String resourceName, int waitTime, int leaseTime, LockActionWithoutResult lockAction) throws InterruptedException {
        RLock lock = redissonClient.getLock(resourceName);
        boolean tryLock = lock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS);
        if (tryLock) {
            try {
                lockAction.onAcquire(resourceName);
                lockAction.doInLock(resourceName);
            } finally {
                lock.unlock();
                lockAction.onExit(resourceName);
            }
        }
    }

    public void executeInLockWithoutResult(String resourceName, LockActionWithoutResult lockAction) {
        RLock lock = redissonClient.getLock(resourceName);
        try {
            lock.lock();
            lockAction.onAcquire(resourceName);
            lockAction.doInLock(resourceName);
        } finally {
            lock.unlock();
            lockAction.onExit(resourceName);
        }
    }
}

@FunctionalInterface
interface LockAction {

    default void onAcquire(String resourceName) {

    }

    &amp;lt;T&amp;gt; T doInLock(String resourceName);

    default void onExit(String resourceName) {

    }
}

@FunctionalInterface
interface LockActionWithoutResult {

    default void onAcquire(String resourceName) {

    }

    void doInLock(String resourceName);

    default void onExit(String resourceName) {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;RedissonLockProvider&lt;/code&gt;（仅供参考）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testRedissonLockProvider() throws Exception {
    RedissonLockProvider provider = new RedissonLockProvider(REDISSON);
    String resourceName = &quot;resource:x&quot;;
    Thread threadA = new Thread(() -&amp;gt; {
        provider.executeInLockWithoutResult(resourceName, new LockActionWithoutResult() {

            @Override
            public void onAcquire(String resourceName) {
                System.out.println(String.format(&quot;线程%s获取到资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }

            @Override
            public void doInLock(String resourceName) {
                try {
                    Thread.sleep(800);
                } catch (InterruptedException ignore) {

                }
            }

            @Override
            public void onExit(String resourceName) {
                System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }
        });
    }, &quot;threadA&quot;);
    Thread threadB = new Thread(() -&amp;gt; {
        provider.executeInLockWithoutResult(resourceName, new LockActionWithoutResult() {

            @Override
            public void onAcquire(String resourceName) {
                System.out.println(String.format(&quot;线程%s获取到资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }

            @Override
            public void doInLock(String resourceName) {
                try {
                    Thread.sleep(800);
                } catch (InterruptedException ignore) {

                }
            }

            @Override
            public void onExit(String resourceName) {
                System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }
        });
    }, &quot;threadB&quot;);
    threadA.start();
    threadB.start();
    Thread.sleep(Long.MAX_VALUE);
}
// 某次执行结果
线程threadA获取到资源resource:x的锁
线程threadA释放资源resource:x的锁
线程threadB获取到资源resource:x的锁
线程threadB释放资源resource:x的锁
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;redisson中rlock的实现原理&quot;&gt;Redisson中RLock的实现原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Redisson&lt;/code&gt;中&lt;code&gt;RLock&lt;/code&gt;的实现是基本参照了&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;red lock&lt;/code&gt;算法进行实现，不过在原始的&lt;code&gt;red lock&lt;/code&gt;算法下进行了改良，主要包括下面的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;互斥&lt;/li&gt;
&lt;li&gt;无死锁&lt;/li&gt;
&lt;li&gt;可重入，类似于&lt;code&gt;ReentrantLock&lt;/code&gt;，同一个线程可以重复获取同一个资源的锁（一般使用计数器实现），锁的重入特性一般情况下有利于提高资源的利用率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;续期&lt;/strong&gt;，这个是一个比较前卫解决思路，也就是如果一个客户端对资源&lt;code&gt;X&lt;/code&gt;永久锁定，那么并不是直接对&lt;code&gt;KEY&lt;/code&gt;生存周期设置为&lt;code&gt;-1&lt;/code&gt;，而是通过一个守护线程每隔固定周期延长&lt;code&gt;KEY&lt;/code&gt;的过期时间，这样就能实现&lt;strong&gt;在守护线程不被杀掉的前提下，避免客户端崩溃导致锁无法释放长期占用资源的问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;锁状态变更订阅，依赖于&lt;code&gt;org.redisson.pubsub.LockPubSub&lt;/code&gt;，用于订阅和通知锁释放事件&lt;/li&gt;
&lt;li&gt;不是完全参考&lt;code&gt;red lock&lt;/code&gt;算法的实现，数据类型选用了&lt;code&gt;HASH&lt;/code&gt;，配合&lt;code&gt;Lua&lt;/code&gt;脚本完成多个命令的原子性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;续期或者说延长&lt;code&gt;KEY&lt;/code&gt;的过期时间在&lt;code&gt;Redisson&lt;/code&gt;使用&lt;code&gt;watch dog&lt;/code&gt;实现，理解为用于续期的守护线程，底层依赖于&lt;code&gt;Netty&lt;/code&gt;的时间轮&lt;code&gt;HashedWheelTimer&lt;/code&gt;和任务&lt;code&gt;io.netty.util.Timeout&lt;/code&gt;实现，&lt;strong&gt;俗称看门狗&lt;/strong&gt;，下面会详细分析。&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;RLock&lt;/code&gt;的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里有一个疑惑点，RedissonRedLock（RedissonMultiLock的子类）的注释中提到RedLock locking algorithm implementation for multiple locks. It manages all locks as one. 但从直观上看，RedissonLock才是整个锁体系的核心，里面的实现思路也是遵从red lock算法的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;RedissonLock&lt;/code&gt;就是&lt;code&gt;RLock&lt;/code&gt;的直接实现，也是分布式锁实现的核心类，从源码中看到&lt;code&gt;Redisson#getLock()&lt;/code&gt;就是直接实例化&lt;code&gt;RedissonLock&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Redisson implements RedissonClient {
    
    // ...... 省略其他代码

    @Override
    public RLock getLock(String name) {
        return new RedissonLock(connectionManager.getCommandExecutor(), name);
    }

    // ...... 省略其他代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此只需要围绕&lt;code&gt;RedissonLock&lt;/code&gt;的源码进行分析即可。&lt;code&gt;RedissonLock&lt;/code&gt;的类继承图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要有几点认知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RedissonLock&lt;/code&gt;实现了&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;接口中除了&lt;code&gt;newCondition()&lt;/code&gt;方法外的所有方法，也就是可以基本无缝适配&lt;code&gt;Lock&lt;/code&gt;接口，对于习惯&lt;code&gt;Lock&lt;/code&gt;接口的&lt;code&gt;API&lt;/code&gt;的使用者来说是一个福音&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RedissonLock&lt;/code&gt;基本所有同步&lt;code&gt;API&lt;/code&gt;都依赖于异步&lt;code&gt;API&lt;/code&gt;的实现，也就是&lt;code&gt;RLock&lt;/code&gt;的实现依赖于&lt;code&gt;RLockAsync&lt;/code&gt;的实现，底层依赖的是&lt;code&gt;Netty&lt;/code&gt;的&lt;code&gt;io.netty.util.concurrent.Promise&lt;/code&gt;，具体见&lt;code&gt;RedissonPromise&lt;/code&gt;，如果用过&lt;code&gt;JUC&lt;/code&gt;中的&lt;code&gt;Future&lt;/code&gt;的开发者应该比较熟悉&lt;code&gt;Future#get()&lt;/code&gt;，这里的做法类似&lt;/li&gt;
&lt;li&gt;右边的几个父类的简单功能描述如下：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RObjectAsync&lt;/code&gt;：所有&lt;code&gt;Redisson&lt;/code&gt;对象的基础接口，提供一些内存测量、对象拷贝、移动等的异步方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RObject&lt;/code&gt;：&lt;code&gt;RObjectAsync&lt;/code&gt;的同步版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RExpirableAsync&lt;/code&gt;：提供对象&lt;code&gt;TTL&lt;/code&gt;相关的异步方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RExpirable&lt;/code&gt;：&lt;code&gt;RExpirableAsync&lt;/code&gt;的同步版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RedissonObject&lt;/code&gt;：直接实现类&lt;code&gt;RObject&lt;/code&gt;接口中的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RedissonExpirable&lt;/code&gt;：主要是实现了&lt;code&gt;RExpirable&lt;/code&gt;接口中的方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着先看&lt;code&gt;RedissonLock&lt;/code&gt;的构造函数和核心属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 存放entryName -&amp;gt; ExpirationEntry，用于获取当前entryName的线程重入计数器和续期任务
private static final ConcurrentMap&amp;lt;String, ExpirationEntry&amp;gt; EXPIRATION_RENEWAL_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 内部的锁持有的最大时间，来源于参数Config#lockWatchdogTimeout，用于控制续期的周期
protected long internalLockLeaseTime;

// ID，唯一标识，是一个UUID
final String id;

// 
final String entryName;

// 锁释放事件订阅发布相关
protected final LockPubSub pubSub;

// 命令异步执行器实例
final CommandAsyncExecutor commandExecutor;

/**
 * CommandAsyncExecutor是命令的异步执行器，里面的方法是相对底层的面向通讯框架的方法，包括异步写、异步读和同步结果获取等
 * name参数就是getLock()时候传入的参数，其实就是最终同步到Redis中的KEY
 */
public RedissonLock(CommandAsyncExecutor commandExecutor, String name) {
    super(commandExecutor, name);
    this.commandExecutor = commandExecutor;
    // 这里的ID为外部初始化的UUID实例，调用toString()
    this.id = commandExecutor.getConnectionManager().getId();
    this.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();
    // 这里的entryName = uuid值 + : + 外部传进来的name(KEY)，如559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x
    this.entryName = id + &quot;:&quot; + name;
    // 初始化LockPubSub实例，用于订阅和发布锁释放的事件
    this.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();
}

// RedissonLock内部类ExpirationEntry，存放着线程重入的计数器和续期的Timeout任务
public static class ExpirationEntry {
    
    // 线程ID -&amp;gt; 线程重入的次数
    private final Map&amp;lt;Long, Integer&amp;gt; threadIds = new LinkedHashMap&amp;lt;&amp;gt;();
    private volatile Timeout timeout;
    
    public ExpirationEntry() {
        super();
    }
    
    // 这个方法主要记录线程重入的计数
    public void addThreadId(long threadId) {
        Integer counter = threadIds.get(threadId);
        if (counter == null) {
            counter = 1;
        } else {
            counter++;
        }
        threadIds.put(threadId, counter);
    }

    public boolean hasNoThreads() {
        return threadIds.isEmpty();
    }

    public Long getFirstThreadId() {
        if (threadIds.isEmpty()) {
            return null;
        }
        return threadIds.keySet().iterator().next();
    }

    public void removeThreadId(long threadId) {
        Integer counter = threadIds.get(threadId);
        if (counter == null) {
            return;
        }
        counter--;
        if (counter == 0) {
            threadIds.remove(threadId);
        } else {
            threadIds.put(threadId, counter);
        }
    }
    
    public void setTimeout(Timeout timeout) {
        this.timeout = timeout;
    }
    public Timeout getTimeout() {
        return timeout;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要关注一下&lt;code&gt;Config&lt;/code&gt;中的&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译一下大意：&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;参数只有在没有使用&lt;code&gt;leaseTimeout&lt;/code&gt;参数定义的成功获取到锁的场景（简单来说就是不设置时限的加锁）下生效，如果看门狗在下一个&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;周期内不进行续期，那么锁就会过期释放（&lt;strong&gt;从源码上看，每三分之一&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;就会执行一次续期任务，每次通过&lt;code&gt;pexpire&lt;/code&gt;把&lt;code&gt;KEY&lt;/code&gt;的存活周期延长&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;&lt;/strong&gt;），&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;的默认值为&lt;code&gt;30000&lt;/code&gt;，也就是&lt;code&gt;30&lt;/code&gt;秒。&lt;/p&gt;
&lt;p&gt;这里先列举一下&lt;code&gt;RedissonLock&lt;/code&gt;中获取名称的方法，以便后面分析这些名称作为&lt;code&gt;K-V&lt;/code&gt;结构的&lt;code&gt;KEY&lt;/code&gt;时候使用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt;：由配置实例化时候实例化的&lt;code&gt;UUID&lt;/code&gt;实例生成，从源码上分析每个连接方式的&lt;code&gt;Redisson&lt;/code&gt;实例有唯一的&lt;code&gt;UUID&lt;/code&gt;，&lt;code&gt;ConnectionManager&lt;/code&gt;初始化的时候会调用&lt;code&gt;UUID id = UUID.randomUUID()&lt;/code&gt;，笔者认为可以理解为&lt;code&gt;Redisson&lt;/code&gt;实例在某个应用程序进程中的唯一标识，毕竟一般情况下，一个应用程序应该只会应用一种&lt;code&gt;Redisson&lt;/code&gt;的连接方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getEntryName()&lt;/code&gt;：返回的是&lt;code&gt;UUID + : + $KEY&lt;/code&gt;，例如&lt;code&gt;559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getName()&lt;/code&gt;：返回的是&lt;code&gt;$KEY&lt;/code&gt;，例如&lt;code&gt;resource:x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getChannelName()&lt;/code&gt;：返回的是&lt;code&gt;redisson_lock__channel:{$KEY}&lt;/code&gt;，例如&lt;code&gt;redisson_lock__channel:{resource:x}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getLockName(long threadId)&lt;/code&gt;：返回的是&lt;code&gt;UUID + : + $threadId&lt;/code&gt;，例如&lt;code&gt;559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着看加锁的方法，核心实现主要是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException&lt;/code&gt;：&lt;code&gt;lock&lt;/code&gt;方法体系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException&lt;/code&gt;：&lt;code&gt;tryLock&lt;/code&gt;方法体系&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先看只包含锁最大持有时间的&lt;code&gt;lock()&lt;/code&gt;方法体系：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 获取锁，不指定等待时间，只指定锁的最大持有时间
 * 通过interruptibly参数配置支持中断
 */
private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException {
    long threadId = Thread.currentThread().getId();
    // 尝试获取锁，返回的ttl为空代表获取锁成功，返回的ttl代表已经存在的KEY的剩余存活时间
    Long ttl = tryAcquire(leaseTime, unit, threadId);
    // lock acquired
    if (ttl == null) {
        return;
    }
    // 订阅redisson_lock__channel:{$KEY}，其实本质的目的是为了客户端通过Redis的订阅发布，感知到解锁的事件
    // 这个方法会在LockPubSub中注册一个entryName -&amp;gt; RedissonLockEntry的哈希映射，RedissonLockEntry实例中存放着RPromise&amp;lt;RedissonLockEntry&amp;gt;结果，一个信号量形式的锁和订阅方法重入计数器
    // 下面的死循环中的getEntry()或者RPromise&amp;lt;RedissonLockEntry&amp;gt;#getNow()就是从这个映射中获取的
    RFuture&amp;lt;RedissonLockEntry&amp;gt; future = subscribe(threadId);
    // 同步订阅执行，获取注册订阅Channel的响应，区分是否支持中断
    if (interruptibly) {
        commandExecutor.syncSubscriptionInterrupted(future);
    } else {
        commandExecutor.syncSubscription(future);
    }
    // 走到下面的for循环说明返回的ttl不为空，也就是Redis已经存在对应的KEY，有其他客户端已经获取到锁，此客户端线程的调用需要阻塞等待获取锁
    try {
        while (true) {
            // 死循环中尝试获取锁，这个是后面会分析的方法
            ttl = tryAcquire(leaseTime, unit, threadId);
            // 返回的ttl为空，说明获取到锁，跳出死循环，这个死循环或者抛出中断异常，或者获取到锁成功break跳出，没有其他方式
            if (ttl == null) {
                break;
            }

            // 这个ttl来源于等待存在的锁的KEY的存活时间，直接使用许可为0的信号量进行阻塞等待，下面的几个分支判断都是大同小异，只是有的支持超时时间，有的支持中断
            // 有的是永久阻塞直到锁释放事件订阅LockPubSub的onMessage()方法回调激活getLatch().release()进行解锁才会往下走
            // 这里可以学到一个特殊的技巧，Semaphore(0)，信号量的许可设置为0，首个调用acquire()的线程会被阻塞，直到其他线程调用此信号量的release()方法才会解除阻塞，类似于一个CountDownLatch(1)的效果
            if (ttl &amp;gt;= 0) {
                try {
                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    if (interruptibly) {
                        throw e;
                    }
                    future.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                }
            } else {
                if (interruptibly) {
                    future.getNow().getLatch().acquire();
                } else {
                    future.getNow().getLatch().acquireUninterruptibly();
                }
            }
        }
    } finally {
        // 获取到锁或者抛出中断异常，退订redisson_lock__channel:{$KEY}，不再关注解锁事件
        unsubscribe(future, threadId);
    }
}

// 这是一个异步转同步的方法，类似于FutureTask#get()，关键看调用的tryAcquireAsync()方法
private Long tryAcquire(long leaseTime, TimeUnit unit, long threadId) {
    return get(tryAcquireAsync(leaseTime, unit, threadId));
}

/**
 * 通过传入锁持有的最大时间和线程ID异步获取锁
 */
private &amp;lt;T&amp;gt; RFuture&amp;lt;Long&amp;gt; tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {
    // 锁持有最大时间不为-1，也就是明确锁的持有时间，不是永久持有的场景
    if (leaseTime != -1) {
        return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
    }
    // 走到这里说明是leaseTime == -1，KEY不设置过期时间的分支，需要启动看门狗机制。尝试内部异步获取锁，注意这里的lockWatchdogTimeout是从配置中获取传进去，不是内部的internalLockLeaseTime属性，这里的默认值还是30000毫秒
    RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);
    ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {
        // 执行异常场景直接返回
        if (e != null) {
            return;
        }

        // 成功获取到锁的场景，需要基于线程ID启用看门狗，通过时间轮指定定时任务进行续期
        if (ttlRemaining == null) {
            // 定时调度进行续期操作
            scheduleExpirationRenewal(threadId);
        }
    });
    return ttlRemainingFuture;
}

/**
 * 转换锁持有最大时间，通过参数进行加锁的LUA脚本调用 
 * getName()就是传入的KEY，如resource:x getLockName()就是锁的名称，形式是：UUID + : + threadId，如559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1
 * internalLockLeaseTime在leaseTime != -1的前提下使用的是原值，在leaseTime == -1的前提下，使用的是lockWatchdogTimeout
 */
&amp;lt;T&amp;gt; RFuture&amp;lt;T&amp;gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) {
    // 时间转换为毫秒，注意一点这里的internalLockLeaseTime是类内的属性，被重新赋值了
    internalLockLeaseTime = unit.toMillis(leaseTime);
    // 底层向Redis服务执行LUA脚本
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; +
                    &quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; +
                    &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                    &quot;return nil; &quot; +
                &quot;end; &quot; +
                &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                    &quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; +
                    &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                    &quot;return nil; &quot; +
                &quot;end; &quot; +
                &quot;return redis.call('pttl', KEYS[1]);&quot;,
                Collections.&amp;lt;Object&amp;gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;先留意一下属性&lt;code&gt;internalLockLeaseTime&lt;/code&gt;，它在&lt;code&gt;tryLockInnerAsync()&lt;/code&gt;方法内被重新赋值，在&lt;code&gt;leaseTime == -1L&lt;/code&gt;的前提下，它被赋值为&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;，这个细节很重要，决定了后面续期方法（看门狗）的调度频率。另外，&lt;code&gt;leaseTime != -1L&lt;/code&gt;不会进行续期，也就是不会启动看门狗机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着需要仔细分析一下&lt;code&gt;tryLockInnerAsync()&lt;/code&gt;中执行的&lt;code&gt;LUA&lt;/code&gt;脚本，笔者把它提取出来通过注释进行描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;-- KEYS[1] == getName() --&amp;gt; $KEY --&amp;gt; resource:x
-- ARGV[1] == internalLockLeaseTime --&amp;gt; 30000
-- ARGV[2] == getLockName(threadId) --&amp;gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1
-- 第一段代码是判断锁定的资源KEY不存在的时候进行相应值的设置，代表资源没有被锁定，首次获取锁成功
if (redis.call('exists', KEYS[1]) == 0) then
    -- 这里是设置调用次数，可以理解为延长KEY过期时间的调用次数
    redis.call('hset', KEYS[1], ARGV[2], 1);
    -- 设置KEY的过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
-- 第二段代码是判断HASH的field是否存在，如果存在说明是同一个线程重入的情况，这个时候需要延长KEY的TTL，并且HASH的field对应的value加1，记录延长ttl的次数
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    -- 这里是增加调用次数，可以理解为增加延长KEY过期时间的调用次数
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    -- 延长KEY的过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
-- 第三段代码是兜底的，走到这里说明当前线程获取锁失败，锁已经被其他（进程中的）线程占有，返回当前KEY被占用资源的ttl，用来确定需要休眠的最大时间
return redis.call('pttl', KEYS[1]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里画一个图演示一下这个&lt;code&gt;Lua&lt;/code&gt;脚本中三段代码出现的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剩下一个&lt;code&gt;scheduleExpirationRenewal(threadId)&lt;/code&gt;方法还没有分析，里面的逻辑就是看门狗的定期续期逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 基于线程ID定时调度和续期
private void scheduleExpirationRenewal(long threadId) {
    // 如果需要的话新建一个ExpirationEntry记录线程重入计数，同时把续期的任务Timeout对象保存在属性中
    ExpirationEntry entry = new ExpirationEntry();
    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
    if (oldEntry != null) {
        // 当前进行的当前线程重入加锁
        oldEntry.addThreadId(threadId);
    } else {
        // 当前进行的当前线程首次加锁
        entry.addThreadId(threadId);
        // 首次新建ExpirationEntry需要触发续期方法，记录续期的任务句柄
        renewExpiration();
    }
}

// 处理续期
private void renewExpiration() {
    // 根据entryName获取ExpirationEntry实例，如果为空，说明在cancelExpirationRenewal()方法已经被移除，一般是解锁的时候触发
    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());
    if (ee == null) {
        return;
    }
    // 新建一个定时任务，这个就是看门狗的实现，io.netty.util.Timeout是Netty结合时间轮使用的定时任务实例
    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
        @Override
        public void run(Timeout timeout) throws Exception {
            // 这里是重复外面的那个逻辑，
            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());
            if (ent == null) {
                return;
            }
            // 获取ExpirationEntry中首个线程ID，如果为空说明调用过cancelExpirationRenewal()方法清空持有的线程重入计数，一般是锁已经释放的场景
            Long threadId = ent.getFirstThreadId();
            if (threadId == null) {
                return;
            }
            // 向Redis异步发送续期的命令
            RFuture&amp;lt;Boolean&amp;gt; future = renewExpirationAsync(threadId);
            future.onComplete((res, e) -&amp;gt; {
                // 抛出异常，续期失败，只打印日志和直接终止任务
                if (e != null) {
                    log.error(&quot;Can't update lock &quot; + getName() + &quot; expiration&quot;, e);
                    return;
                }
                // 返回true证明续期成功，则递归调用续期方法（重新调度自己），续期失败说明对应的锁已经不存在，直接返回，不再递归
                if (res) {
                    // reschedule itself
                    renewExpiration();
                }
            });
        }
    }, 
    // 这里的执行频率为leaseTime转换为ms单位下的三分之一，由于leaseTime初始值为-1的情况下才会进入续期逻辑，那么这里的执行频率为lockWatchdogTimeout的三分之一
    internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); 
    
    // ExpirationEntry实例持有调度任务实例
    ee.setTimeout(task);
}

// 调用Redis，执行Lua脚本，进行异步续期
protected RFuture&amp;lt;Boolean&amp;gt; renewExpirationAsync(long threadId) {
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
                &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
                &quot;return 1; &quot; +
            &quot;end; &quot; +
            &quot;return 0;&quot;,
        Collections.&amp;lt;Object&amp;gt;singletonList(getName()), 
        //  这里根据前面的分析，internalLockLeaseTime在leaseTime的值为-1的前提下，对应值为lockWatchdogTimeout
        internalLockLeaseTime, getLockName(threadId));  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于源码推断出续期的机制由入参&lt;code&gt;leaseTime&lt;/code&gt;决定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当&lt;code&gt;leaseTime == -1&lt;/code&gt;的前提下（一般是&lt;code&gt;lock()&lt;/code&gt;和&lt;code&gt;lockInterruptibly()&lt;/code&gt;这类方法调用），续期任务的调度周期为&lt;code&gt;lockWatchdogTimeout / 3&lt;/code&gt;，锁的最大持有时间（&lt;code&gt;KEY&lt;/code&gt;的过期时间）被刷新为&lt;code&gt;lockWatchdogTimeout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;leaseTime != -1&lt;/code&gt;的前提下（一般是&lt;code&gt;lock(long leaseTime, TimeUnit unit)&lt;/code&gt;和&lt;code&gt;lockInterruptibly(long leaseTime, TimeUnit unit)&lt;/code&gt;这类方法调用指定&lt;code&gt;leaseTime&lt;/code&gt;不为&lt;code&gt;-1&lt;/code&gt;），这种情况下会直接设置锁的过期时间为输入值转换为&lt;code&gt;ms&lt;/code&gt;单位的时间量，不会启动续期机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;提取续期的&lt;code&gt;Lua&lt;/code&gt;脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;-- KEYS[1] == getName() --&amp;gt; $KEY --&amp;gt; resource:x
-- ARGV[1] == internalLockLeaseTime --&amp;gt; 30000
-- ARGV[2] == getLockName(threadId) --&amp;gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return 1;
end;
return 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，不带&lt;code&gt;waitTime&lt;/code&gt;参数的加锁和续期逻辑基本分析完毕，而带&lt;code&gt;waitTime&lt;/code&gt;参数的&lt;code&gt;tryLock(long waitTime, long leaseTime, TimeUnit unit)&lt;/code&gt;实现其实和只存在&lt;code&gt;leaseTime&lt;/code&gt;参数的&lt;code&gt;lock(long leaseTime, TimeUnit unit, boolean interruptibly)&lt;/code&gt;实现底层调用的方法是一致的，最大的区别是会在尝试获取锁操作之后基于前后的&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;计算出时间差和&lt;code&gt;waitTime&lt;/code&gt;做对比，决定需要阻塞等待还是直接超时获取锁失败返回，处理阻塞等待的逻辑是客户端本身的逻辑，这里就不做详细展开，因为源码实现也不是十分优雅（太多&lt;code&gt;long currentTime = System.currentTimeMillis()&lt;/code&gt;的代码段了）。接着花点功夫分析一下解锁的实现，包括一般情况下的解锁&lt;code&gt;unlock()&lt;/code&gt;和强制解锁&lt;code&gt;forceUnlockAsync()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//  一般情况下的解锁
@Override
public void unlock() {
    try {
        get(unlockAsync(Thread.currentThread().getId()));
    } catch (RedisException e) {
        // IllegalMonitorStateException一般是A线程加锁，B线程解锁，内部判断线程状态不一致抛出的
        if (e.getCause() instanceof IllegalMonitorStateException) {
            throw (IllegalMonitorStateException) e.getCause();
        } else {
            throw e;
        }
    }
}

@Override
public RFuture&amp;lt;Void&amp;gt; unlockAsync() {
    // 获取当前调用解锁操作的线程ID
    long threadId = Thread.currentThread().getId();
    return unlockAsync(threadId);
}

@Override
public RFuture&amp;lt;Void&amp;gt; unlockAsync(long threadId) {
    // 构建一个结果RedissonPromise
    RPromise&amp;lt;Void&amp;gt; result = new RedissonPromise&amp;lt;Void&amp;gt;();
    // 返回的RFuture如果持有的结果为true，说明解锁成功，返回NULL说明线程ID异常，加锁和解锁的客户端线程不是同一个线程
    RFuture&amp;lt;Boolean&amp;gt; future = unlockInnerAsync(threadId);
    future.onComplete((opStatus, e) -&amp;gt; {
        // 这是内部的异常，说明解锁异常，需要取消看门狗的续期任务
        if (e != null) {
            cancelExpirationRenewal(threadId);
            result.tryFailure(e);
            return;
        }
        // 这种情况说明线程ID异常，加锁和解锁的客户端线程不是同一个线程，抛出IllegalMonitorStateException异常
        if (opStatus == null) {
            IllegalMonitorStateException cause = new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by current thread by node id: &quot;
                    + id + &quot; thread-id: &quot; + threadId);
            result.tryFailure(cause);
            return;
        }
        // 走到这里说明正常解锁，取消看门狗的续期任务
        cancelExpirationRenewal(threadId);
        result.trySuccess(null);
    });
    return result;
}

// 真正的内部解锁的方法，执行解锁的Lua脚本
protected RFuture&amp;lt;Boolean&amp;gt; unlockInnerAsync(long threadId) {
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            &quot;if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then &quot; +
                &quot;return nil;&quot; +
            &quot;end; &quot; +
            &quot;local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); &quot; +
            &quot;if (counter &amp;gt; 0) then &quot; +
                &quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; +
                &quot;return 0; &quot; +
            &quot;else &quot; +
                &quot;redis.call('del', KEYS[1]); &quot; +
                &quot;redis.call('publish', KEYS[2], ARGV[1]); &quot; +
                &quot;return 1; &quot;+
            &quot;end; &quot; +
            &quot;return nil;&quot;,
            Arrays.&amp;lt;Object&amp;gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));
}

// 取消续期任务
void cancelExpirationRenewal(Long threadId) {
    // 这里说明ExpirationEntry已经被移除，一般是基于同一个线程ID多次调用解锁方法导致的（并发解锁）
    ExpirationEntry task = EXPIRATION_RENEWAL_MAP.get(getEntryName());
    if (task == null) {
        return;
    }
    // 传入的线程ID不为NULL，从ExpirationEntry中移除线程ID，如果持有的线程ID对应的线程重入计数不为0，会先递减到0，等于0的前提下才会进行删除
    if (threadId != null) {
        task.removeThreadId(threadId);
    }
    // 这里threadId == null的情况是为了满足强制解锁的场景，强制解锁需要直接删除锁所在的KEY，不需要理会传入的线程ID（传入的线程ID直接为NULL）
    // 后者task.hasNoThreads()是为了说明当前的锁没有被任何线程持有，对于单线程也确定在移除线程ID之后重入计数器已经为0，从ExpirationEntry中移除，这个时候获取ExpirationEntry的任务实例进行取消即可
    if (threadId == null || task.hasNoThreads()) {
        Timeout timeout = task.getTimeout();
        if (timeout != null) {
            timeout.cancel();
        }
        // EntryName -&amp;gt; ExpirationEntry映射中移除当前锁的相关实例ExpirationEntry
        EXPIRATION_RENEWAL_MAP.remove(getEntryName());
    }
}

// 强制解锁
@Override
public boolean forceUnlock() {
    return get(forceUnlockAsync());
}

@Override
public RFuture&amp;lt;Boolean&amp;gt; forceUnlockAsync() {
    // 线程ID传入为NULL，取消当前的EntryName对应的续期任务
    cancelExpirationRenewal(null);
    // 执行Lua脚本强制删除锁所在的KEY并且发布解锁消息
    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            &quot;if (redis.call('del', KEYS[1]) == 1) then &quot;
            + &quot;redis.call('publish', KEYS[2], ARGV[1]); &quot;
            + &quot;return 1 &quot;
            + &quot;else &quot;
            + &quot;return 0 &quot;
            + &quot;end&quot;,
            Arrays.&amp;lt;Object&amp;gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里列出一般情况下解锁和强制解锁的&lt;code&gt;Lua&lt;/code&gt;脚本，分析如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;-- unlockInnerAsync方法的lua脚本
-- KEYS[1] == getName() --&amp;gt; $KEY --&amp;gt; resource:x
-- KEYS[2] == getChannelName() --&amp;gt; 订阅锁的Channel --&amp;gt; redisson_lock__channel:{resource:x}
-- ARGV[1] == LockPubSub.UNLOCK_MESSAGE --&amp;gt; 常量数值0
-- ARGV[2] == internalLockLeaseTime --&amp;gt; 30000或者具体的锁最大持有时间
-- ARGV[3] == getLockName(threadId) --&amp;gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1
-- 第一个IF分支判断如果锁所在的哈希的field不存在，说明当前线程ID未曾获取过对应的锁，返回NULL表示解锁失败
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    return nil;
end;
-- 走到这里通过hincrby进行线程重入计数-1,返回计数值
local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1);
-- 计数值大于0，说明线程重入加锁，这个时候基于internalLockLeaseTime对锁所在KEY进行续期
if (counter &amp;gt; 0) then
    redis.call('pexpire', KEYS[1], ARGV[2]);
    return 0;
else
    -- 计数值小于或等于0，说明可以解锁，删除锁所在的KEY，并且向redisson_lock__channel:{$KEY}发布消息，内容是0（常量数值）
    redis.call('del', KEYS[1]);
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1;
end;
-- 最后的return nil;在IDEA中提示是不会到达的语句，估计这里是开发者笔误写上去的，前面的if-else都有返回语句，这里应该是不可达的
return nil;

-------------------------------------------------- 不怎么华丽的分割线 -------------------------------------------------

-- forceUnlockAsync方法的lua脚本
-- KEYS[1] == getName() --&amp;gt; $KEY --&amp;gt; resource:x
-- KEYS[2] == getChannelName() --&amp;gt; 订阅锁的Channel --&amp;gt; redisson_lock__channel:{resource:x}
-- ARGV[1] == LockPubSub.UNLOCK_MESSAGE --&amp;gt; 常量数值0
-- 强制删除锁所在的KEY，如果删除成功向redisson_lock__channel:{$KEY}发布消息，内容是0（常量数值）
if (redis.call('del', KEYS[1]) == 1) then
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1
else
    return 0
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他辅助方法都相对简单，这里弄个简单的&quot;流水账&quot;记录一番：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;isLocked()&lt;/code&gt;：基于&lt;code&gt;getName()&lt;/code&gt;调用&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;EXISTS $KEY&lt;/code&gt;命令判断是否加锁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isHeldByThread(long threadId)&lt;/code&gt;和&lt;code&gt;isHeldByCurrentThread()&lt;/code&gt;：基于&lt;code&gt;getName()&lt;/code&gt;和&lt;code&gt;getLockName(threadId)&lt;/code&gt;调用&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;HEXISTS $KEY $LOCK_NAME&lt;/code&gt;命令判断&lt;code&gt;HASH&lt;/code&gt;中对应的&lt;code&gt;field-value&lt;/code&gt;是否存在，存在则说明锁被对应线程&lt;code&gt;ID&lt;/code&gt;的线程持有&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getHoldCount()&lt;/code&gt;：基于&lt;code&gt;getName()&lt;/code&gt;和&lt;code&gt;getLockName(threadId)&lt;/code&gt;调用&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;HGET $KEY $LOCK_NAME&lt;/code&gt;命令，用于获取线程对于某一个锁的持有量（注释叫&lt;code&gt;holds&lt;/code&gt;，其实就是同一个线程对某一个锁的&lt;code&gt;KEY&lt;/code&gt;的续期次数）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;订阅和发布&lt;/strong&gt;部分设计到大量&lt;code&gt;Netty&lt;/code&gt;组件使用相关的源码，这里不详细展开，这部分的逻辑简单附加到后面这个流程图中。最后，通过一个比较详细的图分析一下&lt;code&gt;Redisson&lt;/code&gt;的加锁和解锁流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不带&lt;code&gt;waitTime&lt;/code&gt;参数的加锁流程：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带有&lt;code&gt;waitTime&lt;/code&gt;参数的加锁流程（图右边的流程基本不变，主要是左边的流程每一步都要计算时间间隔）：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解锁流程：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设不同进程的两个不同的线程&lt;code&gt;X&lt;/code&gt;和&lt;code&gt;Y&lt;/code&gt;去竞争资源&lt;code&gt;RESOURCE&lt;/code&gt;的锁，那么可能的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/202101/l-f-x-c-r-i-10.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再概括一下&lt;code&gt;Redisson&lt;/code&gt;中实现&lt;code&gt;red lock&lt;/code&gt;算法使用的&lt;code&gt;HASH&lt;/code&gt;数据类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;KEY&lt;/code&gt;代表的就是资源或者锁，&lt;strong&gt;创建、存在性判断，延长生存周期和删除操作总是针对&lt;code&gt;KEY&lt;/code&gt;进行的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIELD&lt;/code&gt;代表的是锁名称&lt;code&gt;lockName()&lt;/code&gt;，但是其实它由&lt;code&gt;Redisson&lt;/code&gt;连接管理器实例的初始化&lt;code&gt;UUID&lt;/code&gt;拼接客户端线程&lt;code&gt;ID&lt;/code&gt;组成，严格来说应该是获取锁的客户端线程唯一标识&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VALUE&lt;/code&gt;代表的是客户端线程对于锁的持有量，从源码上看应该是&lt;code&gt;KEY&lt;/code&gt;被续期的次数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基于jedis实现类似redisson的分布式锁功能&quot;&gt;基于Jedis实现类似Redisson的分布式锁功能&lt;/h2&gt;
&lt;p&gt;前面的章节已经比较详细分析了&lt;code&gt;Redisson&lt;/code&gt;中分布式锁的实现原理，这里使用&lt;code&gt;Jedis&lt;/code&gt;和多线程技巧做一个类似的实现。为了简单起见，这里只实现一个无入参的&lt;code&gt;lock()&lt;/code&gt;方法（类似于&lt;code&gt;Redisson&lt;/code&gt;中&lt;code&gt;leaseTime == -1&lt;/code&gt;的场景）和&lt;code&gt;unlock()&lt;/code&gt;方法。定义接口&lt;code&gt;RedLock&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface RedLock {

    void lock(String resource) throws InterruptedException;

    void unlock(String resource);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简单起见，笔者把所有实现逻辑都写在实现类&lt;code&gt;RedisRedLock&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequiredArgsConstructor
public class RedisRedLock implements RedLock {

    private final JedisPool jedisPool;
    private final String uuid;

    private static final String WATCH_DOG_TIMEOUT_STRING = &quot;30000&quot;;
    private static final long WATCH_DOG_TASK_DURATION = 10000L;
    private static final String CHANNEL_PREFIX = &quot;__red__lock:&quot;;
    private static final String UNLOCK_STATUS_STRING = &quot;0&quot;;

    private static final String LOCK_LUA = &quot;if (redis.call('exists', KEYS[1]) == 0) then\n&quot; +
            &quot;    redis.call('hset', KEYS[1], ARGV[2], 1);\n&quot; +
            &quot;    redis.call('pexpire', KEYS[1], ARGV[1]);\n&quot; +
            &quot;    return nil;\n&quot; +
            &quot;end;\n&quot; +
            &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then\n&quot; +
            &quot;    redis.call('hincrby', KEYS[1], ARGV[2], 1);\n&quot; +
            &quot;    redis.call('pexpire', KEYS[1], ARGV[1]);\n&quot; +
            &quot;    return nil;\n&quot; +
            &quot;end;\n&quot; +
            &quot;return redis.call('pttl', KEYS[1]);&quot;;

    private static final String UNLOCK_LUA = &quot;if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then\n&quot; +
            &quot;    return nil;\n&quot; +
            &quot;end;\n&quot; +
            &quot;local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1);\n&quot; +
            &quot;if (counter &amp;gt; 0) then\n&quot; +
            &quot;    redis.call('pexpire', KEYS[1], ARGV[2]);\n&quot; +
            &quot;    return 0;\n&quot; +
            &quot;else\n&quot; +
            &quot;    redis.call('del', KEYS[1]);\n&quot; +
            &quot;    redis.call('publish', KEYS[2], ARGV[1]);\n&quot; +
            &quot;    return 1;\n&quot; +
            &quot;end;&quot;;

    private static final String RENEW_LUA = &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; +
            &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; +
            &quot;return 1; &quot; +
            &quot;end; &quot; +
            &quot;return 0;&quot;;

    private static final ExecutorService SUB_PUB_POOL = Executors.newCachedThreadPool();
    private static final ScheduledExecutorService WATCH_DOG_POOL = new ScheduledThreadPoolExecutor(
            Runtime.getRuntime().availableProcessors() * 2
    );

    private static class ThreadEntry {

        private final ConcurrentMap&amp;lt;Long, Integer&amp;gt; threadCounter = Maps.newConcurrentMap();

        private volatile WatchDogTask watchDogTask;

        public synchronized void addThreadId(long threadId) {
            Integer counter = threadCounter.get(threadId);
            if (counter == null) {
                counter = 1;
            } else {
                counter++;
            }
            threadCounter.put(threadId, counter);
        }

        public synchronized boolean hasNoThreads() {
            return threadCounter.isEmpty();
        }

        public synchronized Long getFirstThreadId() {
            if (threadCounter.isEmpty()) {
                return null;
            }
            return threadCounter.keySet().iterator().next();
        }

        public synchronized void removeThreadId(long threadId) {
            Integer counter = threadCounter.get(threadId);
            if (counter == null) {
                return;
            }
            counter--;
            if (counter == 0) {
                threadCounter.remove(threadId);
            } else {
                threadCounter.put(threadId, counter);
            }
        }

        public void setWatchDogTask(WatchDogTask watchDogTask) {
            this.watchDogTask = watchDogTask;
        }

        public WatchDogTask getWatchDogTask() {
            return watchDogTask;
        }
    }

    @Getter
    private static class SubPubEntry {

        private final String key;
        private final Semaphore latch;
        private final SubscribeListener subscribeListener;

        public SubPubEntry(String key) {
            this.key = key;
            this.latch = new Semaphore(0);
            this.subscribeListener = new SubscribeListener(key, latch);
        }
    }

    private static final ConcurrentMap&amp;lt;String, ThreadEntry&amp;gt; THREAD_ENTRY_MAP = Maps.newConcurrentMap();

    @Override
    public void lock(String resource) throws InterruptedException {
        long threadId = Thread.currentThread().getId();
        String lockName = uuid + &quot;:&quot; + threadId;
        String entryName = uuid + &quot;:&quot; + resource;
        // 获取锁
        Long ttl = acquire(resource, lockName, threadId, entryName);
        // 加锁成功直接返回
        if (Objects.isNull(ttl)) {
            return;
        }
        // 订阅
        SubPubEntry subPubEntry = subscribeAsync(resource);
        try {
            for (; ; ) {
                ttl = acquire(resource, lockName, threadId, entryName);
                // 加锁成功直接返回
                if (Objects.isNull(ttl)) {
                    return;
                }
                if (ttl &amp;gt; 0L) {
                    subPubEntry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                }
            }
        } finally {
            unsubscribeSync(subPubEntry);
        }
    }

    private Long acquire(String key, String lockName, long threadId, String entryName) {
        Object result = execute0(jedis -&amp;gt; jedis.eval(LOCK_LUA, Lists.newArrayList(key),
                Lists.newArrayList(WATCH_DOG_TIMEOUT_STRING, lockName)));
        if (Objects.nonNull(result)) {
            return Long.parseLong(String.valueOf(result));
        }
        // 启动看门狗
        ThreadEntry entry = new ThreadEntry();
        ThreadEntry oldEntry = THREAD_ENTRY_MAP.putIfAbsent(entryName, entry);
        if (oldEntry != null) {
            oldEntry.addThreadId(threadId);
        } else {
            entry.addThreadId(threadId);
            Runnable renewAction = () -&amp;gt; executeWithoutResult(jedis -&amp;gt; jedis.eval(RENEW_LUA, Lists.newArrayList(key),
                    Lists.newArrayList(WATCH_DOG_TIMEOUT_STRING, lockName)));
            WatchDogTask watchDogTask = new WatchDogTask(new AtomicReference&amp;lt;&amp;gt;(renewAction));
            entry.setWatchDogTask(watchDogTask);
            WATCH_DOG_POOL.scheduleWithFixedDelay(watchDogTask, 0, WATCH_DOG_TASK_DURATION, TimeUnit.MILLISECONDS);
        }
        return null;
    }

    private SubPubEntry subscribeAsync(String key) {
        SubPubEntry subPubEntry = new SubPubEntry(key);
        SUB_PUB_POOL.submit(() -&amp;gt; {
            SubscribeListener subscribeListener = subPubEntry.getSubscribeListener();
            executeWithoutResult(jedis -&amp;gt; jedis.subscribe(subscribeListener, subscribeListener.getChannelName()));
            return null;
        });
        return subPubEntry;
    }

    private void unsubscribeSync(SubPubEntry subPubEntry) {
        SubscribeListener subscribeListener = subPubEntry.getSubscribeListener();
        subscribeListener.unsubscribe(subscribeListener.getChannelName());
    }

    @Override
    public void unlock(String resource) {
        long threadId = Thread.currentThread().getId();
        String entryName = uuid + &quot;:&quot; + resource;
        String lockName = uuid + &quot;:&quot; + threadId;
        String channelName = CHANNEL_PREFIX + resource;
        Object result = execute0(jedis -&amp;gt; jedis.eval(UNLOCK_LUA, Lists.newArrayList(resource, channelName),
                Lists.newArrayList(UNLOCK_STATUS_STRING, WATCH_DOG_TIMEOUT_STRING, lockName)));
        ThreadEntry threadEntry = THREAD_ENTRY_MAP.get(entryName);
        if (Objects.nonNull(threadEntry)) {
            threadEntry.removeThreadId(threadId);
            if (threadEntry.hasNoThreads() &amp;amp;&amp;amp; Objects.nonNull(threadEntry.getWatchDogTask())) {
                threadEntry.getWatchDogTask().cancel();
            }
        }
        if (Objects.isNull(result)) {
            throw new IllegalMonitorStateException();
        }
    }

    private static class SubscribeListener extends JedisPubSub {

        @Getter
        private final String key;
        @Getter
        private final String channelName;
        @Getter
        private final Semaphore latch;

        public SubscribeListener(String key, Semaphore latch) {
            this.key = key;
            this.channelName = CHANNEL_PREFIX + key;
            this.latch = latch;
        }

        @Override
        public void onMessage(String channel, String message) {
            if (Objects.equals(channelName, channel) &amp;amp;&amp;amp; Objects.equals(UNLOCK_STATUS_STRING, message)) {
                latch.release();
            }
        }
    }

    @RequiredArgsConstructor
    private static class WatchDogTask implements Runnable {

        private final AtomicBoolean running = new AtomicBoolean(true);
        private final AtomicReference&amp;lt;Runnable&amp;gt; actionReference;

        @Override
        public void run() {
            if (running.get() &amp;amp;&amp;amp; Objects.nonNull(actionReference.get())) {
                actionReference.get().run();
            } else {
                throw new WatchDogTaskStopException(&quot;watch dog cancel&quot;);
            }
        }

        public void cancel() {
            actionReference.set(null);
            running.set(false);
        }
    }

    private &amp;lt;T&amp;gt; T execute0(Function&amp;lt;Jedis, T&amp;gt; function) {
        try (Jedis jedis = jedisPool.getResource()) {
            return function.apply(jedis);
        }
    }

    interface Action {

        void apply(Jedis jedis);
    }

    private void executeWithoutResult(Action action) {
        try (Jedis jedis = jedisPool.getResource()) {
            action.apply(jedis);
        }
    }

    private static class WatchDogTaskStopException extends RuntimeException {

        @Override
        public synchronized Throwable fillInStackTrace() {
            return this;
        }
    }

    public static void main(String[] args) throws Exception {
        String resourceName = &quot;resource:x&quot;;
        RedLock redLock = new RedisRedLock(new JedisPool(new GenericObjectPoolConfig()), UUID.randomUUID().toString());
        Thread threadA = new Thread(() -&amp;gt; {
            try {
                redLock.lock(resourceName);
                process(resourceName);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                redLock.unlock(resourceName);
                System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }
        }, &quot;threadA&quot;);
        Thread threadB = new Thread(() -&amp;gt; {
            try {
                redLock.lock(resourceName);
                process(resourceName);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                redLock.unlock(resourceName);
                System.out.println(String.format(&quot;线程%s释放资源%s的锁&quot;, Thread.currentThread().getName(), resourceName));
            }
        }, &quot;threadB&quot;);
        threadA.start();
        threadB.start();
        Thread.sleep(Long.MAX_VALUE);
    }

    private static void process(String resourceName) {
        String threadName = Thread.currentThread().getName();
        System.out.println(String.format(&quot;线程%s获取到资源%s的锁&quot;, threadName, resourceName));
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ignore) {
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的实现短时间内编写完，没有做详细的&lt;code&gt;DEBUG&lt;/code&gt;，可能会有纰漏。某次执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;线程threadB获取到资源resource:x的锁
线程threadB释放资源resource:x的锁
线程threadA获取到资源resource:x的锁
线程threadA释放资源resource:x的锁
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Redisson&lt;/code&gt;中的&lt;code&gt;red lock&lt;/code&gt;实现，应用到下面的核心技术：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合理应用&lt;code&gt;Redis&lt;/code&gt;的基本数据类型&lt;code&gt;HASH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;的订阅发布&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lua&lt;/code&gt;脚本的原子性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt;中的&lt;code&gt;Promise&lt;/code&gt;实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty&lt;/code&gt;中的时间轮&lt;code&gt;HashedWheelTimer&lt;/code&gt;和对应的定时任务&lt;code&gt;(HashedWheel)Timeout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;进行带期限、永久或者可中断的阻塞以及唤醒，替代&lt;code&gt;CountDownLatch&lt;/code&gt;中的无等待期限阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的核心技术相对合理地应用，才能实现一个高效而且容错能力相对比较高的分布式锁方案，但是从目前来看，&lt;code&gt;Redisson&lt;/code&gt;仍未解决&lt;code&gt;red lock&lt;/code&gt;算法中的故障转移缺陷，笔者认为这个有可能是&lt;code&gt;Redis&lt;/code&gt;实现分布式锁方案的一个底层缺陷，&lt;strong&gt;此方案在&lt;code&gt;Redis&lt;/code&gt;单实例中是相对完善&lt;/strong&gt;，一旦应用在&lt;code&gt;Redis&lt;/code&gt;集群（普通主从、哨兵或者&lt;code&gt;Cluster&lt;/code&gt;），有几率会出现前文提到的节点角色切换导致多个不同客户端获取到同一个资源对应的锁的问题。暂时无解。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Redisson&lt;/code&gt;开源版本源码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;官方文档&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;画图用的是&lt;code&gt;ProcessOn&lt;/code&gt;：&lt;code&gt;https://www.processon.com/view/link/5ffc540de0b34d2060d2d715&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（c-2-w e-a-20210110 2021年的第一篇文章，希望这一年不要这么鸽，这个系列的下一篇是《冷饭新炒：理解JDK中UUID的底层实现》）&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 14:40:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 在很早很早之前，写过一篇文章介绍过Redis中的red lock的实现，但是在生产环境中，笔者所负责的项目使用的分布式锁组件一直是Redisson。Redisson是具备多种内存数据网格特性的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/14264804.html</dc:identifier>
</item>
<item>
<title>Python基础（下篇） - kele是可乐呀</title>
<link>http://www.cnblogs.com/kele-develop/p/14264779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kele-develop/p/14264779.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本篇文章主要内容：&lt;span&gt;&lt;strong&gt;异常处理，函数，模块和包&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;在开始正篇之前我们先来看看上一篇可乐留下的题目。&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;变量 a= {&quot;name&quot;: &quot;可乐&quot;, &quot;age&quot;: 18, &quot;hello&quot;: &quot;python&quot;}，现在要将 a 所有的 key 放入到 b 列表中，所有的 value 放到 c 列表中。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现方法有很多种，可乐在这里用两种方式来实现：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码实现1：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = {&quot;name&quot;: &quot;可乐&quot;, &quot;age&quot;: 18, &quot;hello&quot;: &quot;python&quot;}
b = []
c = []
for key, value in a.items():
    b.append(key)
    c.append(value)
print(f&quot;存储key的b列表是{b}&quot;)
print(f&quot;存储value的c列表是{c}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码实现2：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = {&quot;name&quot;: &quot;可乐&quot;, &quot;age&quot;: 18, &quot;hello&quot;: &quot;python&quot;}
b = [key for key in a.keys()]
c = [value for value in a.values()]
print(f&quot;存储key的b列表是{b}&quot;)
print(f&quot;存储value的c列表是{c}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注：第二种是列表推导式，上篇可乐没有提出来，大家可以自行百度或者私聊可乐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就是我们本篇的主角&lt;span&gt;&lt;strong&gt;异常处理，函数，模块和包&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、异常处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;u&gt;何谓异常呢&lt;/u&gt;？&lt;/strong&gt;&lt;/span&gt; 就是我们IT界鼎鼎有名的 &quot; bug &quot; 兄。bug 也就是指程序没有按照我们所期望的去运行而出现的一些错误情况。比如一个除法表达式 a / b ，如果我们不加处理，那么就会出现 a / 0 的情况，此时程序就会出现异常。那么这就是一个 bug 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;u&gt;何谓异常处理呢&lt;/u&gt;？&lt;/strong&gt;&lt;/span&gt; 顾名思义就是当程序出现异常的时候，我们针对这些异常进行处理的机制。在 python 中默认的处理方法是出现异常后，程序会在出现异常的地方终止，然而这可能不是我们想要的。所以我们可以通过几个内置的关键字来进行自定义处理方式。&lt;/p&gt;&lt;p&gt;我们先来了解两个 python 的异常处理类：&lt;br/&gt;&lt;span&gt;&lt;strong&gt;- BaseException&lt;br/&gt;- Exception&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;1.1 BaseException&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;这个异常处理类是所有 python 异常处理的基类。我们在自定义异常处理时，可以继承这个类。&lt;span&gt;&lt;strong&gt;(官方不推荐)&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;1.2 Exception&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.4545454545455&quot;&gt;
&lt;p&gt;&lt;span&gt;这个异常处理类是常规处理的基类，但是 Exception 也继承于 BaseException ，官方推荐我们自定义异常类时，继承于 Exception 。&lt;a href=&quot;https://docs.python.org/zh-cn/3.7/library/exceptions.html#Exception&quot; target=&quot;_blank&quot;&gt;(官方文档）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;1.3 异常处理关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;关键字：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;try&lt;/th&gt;
&lt;th&gt;except&lt;/th&gt;
&lt;th&gt;else&lt;/th&gt;
&lt;th&gt;finally&lt;/th&gt;
&lt;th&gt;raise&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;语法 - try、except、else、finally：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;try:&lt;br/&gt;　可能异常的代码&lt;br/&gt;except Error... as e:&lt;br/&gt;　当出现 Error 后处理的代码&lt;br/&gt;else:&lt;br/&gt;　如果不出现异常，执行的代码&lt;br/&gt;finally:&lt;br/&gt;　无论是否发生异常都执行的代码&lt;br/&gt;&lt;span&gt;注意：一般时候只需要 try / except 即可，try 不可以单独使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    a = 1 / 0
except Exception as e:
    print(f&quot;异常是{e}&quot;)
​
输出: 异常是division by zero
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例2：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    a = 1 / 0
except Exception as e:
    print(f&quot;异常是{e}&quot;)
else:
    print(&quot;没有异常执行&quot;)
finally:
    print(&quot;执行了finally&quot;)
​
输出: 异常是division by zero（执行了finally）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;语法 - raise：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;raise 异常类(描述信息)&lt;br/&gt;&lt;span&gt;注：&lt;/span&gt;raise 用于主动抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    a = 2
    raise ValueError(&quot;a不能等于2&quot;)
except Exception as e:
    print(f&quot;异常是{e}&quot;)
​
输出 异常是a不能等于2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;类&lt;/span&gt;可乐会在下一篇&lt;span&gt;python高级之面向对象&lt;/span&gt;中详细解释。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1 语法&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;def func_name(参数):&lt;br/&gt;　代码部分&lt;br/&gt;　return 返回值&lt;br/&gt;&lt;span&gt;注：&lt;/span&gt;函数可以有返回值，可以没有返回值。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们先来看看一个简单的示例：&lt;span&gt;在函数当中计算 1 + 2 + ... + 9 的和，并且返回&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1.1 无参数，无返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_sum():
    sum = 0
    for i in range(10):
        sum += i
    print(sum)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;那么函数写好后，我们怎么调用它呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;func_name(参数)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;调用函数示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_sum()
​
输出 45
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2.1.2 无参数，有返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;​def num_sum():
    sum = 0
    for i in range(10):
        sum += i
    return sum
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;我们再来打印一下函数返回的数值：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_sum():
    sum = 0
    for i in range(10):
        sum += i
    return sum
print(num_sum)
​
输出 45
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2.1.3 有参数，无返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_sum(number):
    sum = 0
    for i in range(number):
        sum += i
    print(sum)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在上述函数中我们可以实现&lt;span&gt;1到任何数之间所相加的和&lt;/span&gt;，只需要把期望的值传递给函数即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1.4 有参数，有返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_sum(number):
    sum = 0
    for i in range(number):
        sum += i
    return sum
total = num_sum(10)
print(total)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在这里我们用一个变量 total 来接收函数 num_sum 的返回值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在函数这里有下面一些重点需要注意(每一个注意点可乐都会有一个示例)。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 注意点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2.1 全局变量和局部变量&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;全局变量：&lt;/span&gt;在函数外部定义的变量。&lt;br/&gt;&lt;span&gt;局部变量：&lt;/span&gt;在函数内部定义的变量。&lt;br/&gt;- 如果局部变量定义的名字和全局变量定义的名字相同，那么在函数体内局部变量会覆盖全局变量。&lt;br/&gt;- 函数体内变量的作用域或者说生命周期，仅在函数体内有。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def scope():
    name = &quot;可乐&quot;
    print(f&quot;我是函数体内的{name}&quot;)
scope()
print(f&quot;我是函数体外的{name}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;结果如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/133161f06ed816a5e79aac103ecd10ed.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;我们在函数体内定义的 name 变量是可以正常打印的，但是在函数体外抛出了 name 没有被定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2.2 修改全局变量&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;- 如果是&lt;span&gt;不可变类型&lt;/span&gt;，需要通过 global 来声明操作全局变量；&lt;br/&gt;- 如果是&lt;span&gt;可变类型&lt;/span&gt;，那么可以直接操作全局变量不需要通过 global 来声明。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = [1, 2, 3]
b = &quot;可乐&quot;
def scope():
    a.append(4)
    print(f&quot;函数体内a的值是{a}&quot;)
    global b
    b = &quot;可乐很帅&quot;
    print(f&quot;函数体内b的值是{b}&quot;)
scope()
print(f&quot;全局变量a的值是{a}&quot;)
print(f&quot;全局变量b的值是{b}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;结果如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/37ae8a00ca8bad8e0b27eac255878292.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;在函数传参时，实际情况下&lt;span&gt;&lt;strong&gt;无论是可变类型还是不可变类型，传递的都是引用&lt;/strong&gt;&lt;/span&gt;。但是由于不可变类型改变值后是用新的内存地址来存储，所以网上有很多这样一个结论：&lt;strong&gt;函数接收参数时，如果参数是可变类型，那么传递的是参数的引用；如果参数是不可变类型，那么传递的是参数的值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以结论是：在 python 函数传参，无论是可变类型还是不可变类型本质上都是引用传递，但是由于不可变类型不能直接修改原有的值，所以在表现上不可变类型是传值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 10
b = [&quot;可乐&quot;]
​
def scope(change):
    print(f&quot;改变前s_change的内存地址是{id(change)}&quot;)
    change = 20
    print(f&quot;改变后s_change的内存地址是{id(change)}&quot;)
    print(f&quot;改变后s_change的值是{change}&quot;)
​
def scope2(change):
    print(f&quot;改变前s2_change的内存地址是{id(change)}&quot;)
    change.append(&quot;很帅&quot;)
    print(f&quot;改变后s2_change的内存地址是{id(change)}&quot;)
    print(f&quot;改变后s2_change的值是{change}&quot;)
​
scope(a)
print(f&quot;a的值是{a},a的内存地址是{id(a)}&quot;)
scope2(b)
print(f&quot;b的值是{b},b的内存地址是{id(b)}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;结果如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/8a326a809fb348485afba4d6181862fd.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;2.2.3 函数的不定长参数和关键字参数&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不定长参数：&lt;/span&gt;*args&lt;br/&gt;&lt;span&gt;关键字参数：&lt;/span&gt;**kwargs&lt;br/&gt;在正常情况下，参数接收几个参数我们就写几个参数名就可以了，可是在实际开发中有的函数的参数并不是固定的，那么我们就可以用关键字参数和可变参数来替代。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;2.2.3.1 不定长参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def scope(*args):
    print(args)
scope(1, 2, 3)
​
输出: (1,2,3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在这里的时候需要注意，如果我们在调用函数的时候传递的是一个&lt;span&gt;元组&lt;/span&gt;，而不是 1，2，3 这三个参数，那么这个元组就是一个参数，如果需要达到上述函数的效果，需要对他&lt;span&gt;解包&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = (1, 2, 3)
def scope(*args):
    print(args)
scope(a)
scope(*a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;结果如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c7912732c7639ae6e6526b22e0ddc219.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;重申：&lt;/strong&gt;&lt;/span&gt;如果我们在传递函数参数时是一个元组、列表、字典等时，如果不对他解包，那么传递的是该元组、列表、字典的整体。如果需要对他的每个元素进行分别传参，则需要对其解包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2.3.2 关键字参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;关键字参数&lt;/strong&gt;&lt;/span&gt;是针对字典这键值对类型的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = {&quot;name&quot;: &quot;可乐&quot;, &quot;age&quot;: 18}
def scope(**kwargs):
    print(kwargs)
scope(name=&quot;可乐&quot;, age=18)
scope(**a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意：&lt;/span&gt;函数参数的匹配顺序(指定参数名除外)为&lt;span&gt;从左往右&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;​def scope(name1, name2, name3):
    print(name1)
    print(name2)
    print(name3)
scope(&quot;可乐&quot;, &quot;python&quot;, &quot;是可乐呀&quot;)
print()
scope(name3=&quot;可乐&quot;, name2=&quot;是可乐呀&quot;, name1=&quot;python&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;结果如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/30885a9ebd07018c23d4f9d1fe72eb74.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;如果在函数的参数既有不定长参数和关键字参数又有普通参数，那么一定要将普通参数放在最前面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2.4 默认参数&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;顾名思义：默认参数就是如果我们没有传值给这个参数的话，那他就是默认值。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def scope(name=&quot;可乐&quot;):
    print(name)
scope()
​
输出: 可乐
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例2：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def scope(name=&quot;可乐&quot;):
    print(name)
scope(&quot;是可乐呀&quot;)
​
输出: 是可乐呀
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2.2.5 匿名参数&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;解释：匿名函数也就是这个函数是没有名字的，不过匿名函数的关键字不是通过def来定义，而是 &lt;span&gt;lambda&lt;/span&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;lambda 参数(可以多个) : 表达式(只能有一个)&lt;br/&gt;&lt;span&gt;注：返回一个新的函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;b = lambda x, y: y + x
print(b(1, 2))
​
输出: 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;解读：&lt;/strong&gt;&lt;/span&gt;① 定义一个匿名函数用来计算 x+y 的值并且返回。② 匿名函数定义完后返回新的函数给变量 b，b 调用这个匿名函数并且将参数 1，2 传递。③ 打印 x+y 表达式的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数更高层次的理解和使用例如：装饰器，闭包。可乐会在高级部分讲解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、模块和包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;模块：&lt;/strong&gt;&lt;/span&gt;我们可以通俗的理解模块就是一个 &lt;span&gt;&lt;strong&gt;py 文件包&lt;/strong&gt;&lt;/span&gt;（若干个 py 文件 + ini.py 组成的文件夹就是一个包）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;init.py 文件的作用：&lt;/strong&gt;&lt;/span&gt;用于初始化这个包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/19aa3132f093c5c2a75e4c56e9d74328.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;如果我们有一个函数或者变量需要从另外的一个包当中引用过来，那么我们应该怎么做呢？答案就是&lt;span&gt;&lt;strong&gt;导包&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1 导包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;① import module_name&lt;br/&gt;② from xxx import module_name&lt;br/&gt;③ from module_name import *&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;mark&gt;&lt;span&gt;&lt;strong&gt;示例如下图：&lt;/strong&gt;&lt;/span&gt;&lt;/mark&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d286ebe2ad8c92b1033ca96846115261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cea9e5fd35403e585042d076a83b2501.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;输出：hello world&lt;br/&gt;其他的两种方式大家可自己线下测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2 模块的搜索路径顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;当前主目录&lt;/strong&gt;&lt;/span&gt; &amp;gt; &lt;span&gt;&lt;strong&gt;PTYHONPATH 目录&lt;/strong&gt;&lt;/span&gt;（开始安装 python 时设置的环境变量路径，忘记可往回看 python 安装） &amp;gt; &lt;span&gt;&lt;strong&gt;标准的连接库路径&lt;/strong&gt;&lt;/span&gt; &amp;gt; &lt;span&gt;&lt;strong&gt;.pth 文件&lt;/strong&gt;&lt;/span&gt; &amp;gt; &lt;span&gt;&lt;strong&gt;第三方包&lt;/strong&gt;&lt;/span&gt;（site-package 目录）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们也可以通过 &lt;span&gt;&lt;strong&gt;sys.path&lt;/strong&gt;&lt;/span&gt; 来查看搜索路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/14b9bbe7cc15e565033be7ecf2dea318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;我们根据模块的搜索路径顺序得知，我们在给包或者模块取名的时候，一定&lt;span&gt;&lt;strong&gt;不要和系统包或者第三方包同名&lt;/strong&gt;&lt;/span&gt;，否则会找不到对应的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.3 相对路径和绝对路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;相对路径：&lt;/strong&gt;&lt;/span&gt;相对于你的工作目录的路径&lt;br/&gt;&lt;span&gt;&lt;strong&gt;绝对路径：&lt;/strong&gt;&lt;/span&gt;以系统的根路径为为根目录，如：windows C: linux /&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此Python基础篇的内容就全部结束了，大家在学习过程中遇到疑问可以私聊可乐，可乐看到了都会一一回复的( •̀ ω •́ )✧。&lt;/span&gt;&lt;/p&gt;
&lt;br/&gt;&lt;center&gt;&lt;span&gt;&lt;strong&gt;&amp;lt; END&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/center&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201229144802188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODYwNzQ4Mw==,size_1,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Jan 2021 14:35:00 +0000</pubDate>
<dc:creator>kele是可乐呀</dc:creator>
<og:description>本篇文章主要内容：异常处理，函数，模块和包。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kele-develop/p/14264779.html</dc:identifier>
</item>
</channel>
</rss>