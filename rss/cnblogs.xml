<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>彩虹排序 | 荷兰旗问题 - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13946800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13946800.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;微信搜索🔍「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilv8ex9ij30t80ceagx.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;荷兰旗问题又称三色排序，或者彩虹排序，&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilxkbf9uj30pi094dgq.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为荷兰旗就三种颜色嘛，那这道题的问题就是给你三种颜色，按照给定的顺序排好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，题目的问法各种各样，有的给数字，有的给字母，但本质都是一样的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如给你一个只含有三个数字的数组：312312312231111122113，&lt;br/&gt;要求按照 1 2 3 的顺序排好，即： 111111111222222222223333333333&lt;br/&gt;（请不要真的去数数，认真你就输了）&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkily8ory3j30t80b143x.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilyfa5spj30t80b10yd.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilym8eowj30t80chgqp.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是用我们经典的「挡板法」。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在快排中，我们用了两个挡板把数组分成三个区域：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt;= pivot；未排序区间；&amp;gt; pivot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里就要三个挡板，分成四个区域：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;1, 2, 3, 未排序区间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Partition&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体说来，用 i, j, k 这三个指针分一下：&lt;br/&gt;[0, i): 存 1&lt;br/&gt;[i, j): 存 2&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(k, array.length-1]: 存 3&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 j 放在未排序区间的左边和右边都行，但基本上大家都是放左边，所以我们也没必要“标新立异”。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;初始化：&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;i = 0;&lt;br/&gt;j = 0;&lt;br/&gt;k = array.length - 1;&lt;br/&gt;这样才能保证 1，2，3 的每个区间都为空。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过&lt;strong&gt;观察指针 j 指向的元素&lt;/strong&gt;来不断缩小未排序区间，直到为空。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;例子：1232312&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilywmfboj30po0d9ta8.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了好看，排好序的元素我们用 RGB 三原色标示一下。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step1.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针 j 指向 1，而 1 应该放在 [0, i) 区间内， 这里应该把指针 i 和指针 j 所指的元素交换一下，并且俩指针往前走。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在这步看来是否交换没什么区别，但是如果 i 和 j 之间有元素，就有区别了，比如 Step7.&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilz59ai7g30ms0a6nc2.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step2.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针 j 指向 2，而 2 应该放在 [i, j) 区间内，所以 &lt;strong&gt;j++.&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilzdz21yg30ms0a4h2u.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step3.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针 j 指向 3，而 3 应该放在&lt;br/&gt;(k, array.length-1] 区间内，所以这里&lt;br/&gt;&lt;strong&gt;j 和 k 指向的元素交换一下，并且 k--.&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里就不能 j-- 了，因为新换回来的元素还没瞧呢，不知道它是几。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilznpotwg30ms0a4tnd.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step4.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指针 j 指向 2，同 Step2，直接移动指针 j 即可。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkilzvamf8g30ms0a4as8.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step5.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续移动指针 j。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim03mvn4g30ms0a44gi.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step6.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同 Step3.&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim0c1mxvg30ms0a41bp.gif&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Step7.&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步就很明显看出来了，&lt;br/&gt;由于 1 应该放在 [0,i) 区间，所以这里把指针 i，j 所指向的元素交换一下，并且 i++, j++.&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim0kkqfeg30ms0a47o4.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样未排序区间为空，我们就排好了～&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim0wldu3j30t80cxdpc.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim13heghj30t809i0w0.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;时间复杂度&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法的 bottle neck 就在这个 while loop 里了，每次循环是 O(1)，总共是 O(n).&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;空间复杂度&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;O(1)&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkim1axbx3j30t80h5wpq.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多干货文章见我的 Github: https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Nov 2020 00:26:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>微信搜索&amp;amp;#128269;「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～ 荷兰旗问题又称三色排序，或者彩虹排</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13946800.html</dc:identifier>
</item>
<item>
<title>5年程序员面试，常见面试问题解析 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/13946797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/13946797.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a1dfc1234d607a8bbab8ef962e2a6028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;成长&amp;amp;认知&lt;/strong&gt; 丨 作者 / 袁吴范&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;pointers公众号&lt;/strong&gt;分享的第&lt;strong&gt;16&lt;/strong&gt;篇原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面试，想必所有人都经历过。可以说，面试是相当重要的，因为他决定了你的起点。&lt;/p&gt;
&lt;p&gt;从业这么多年，到现在面试的人数应该不下200人，看过的简历更是超过1000+。&lt;/p&gt;
&lt;p&gt;那么这篇文章就从面试官的角度，分享一些面试经验给大家。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;面试的过程原本就是双方互相选择的过程。&lt;/p&gt;
&lt;p&gt;面试者了解岗位要求，公司所处行业，业务和产品情况。&lt;/p&gt;
&lt;p&gt;面试官了解对方是否符合招聘要求。&lt;/p&gt;
&lt;p&gt;互联网的头部企业不管从福利待遇，工资水平、还是技术氛围、成长潜力、培养机制都在行业内首屈一指的，这也就让程序员们趋之若鹜。&lt;/p&gt;
&lt;p&gt;如果你面试的是这些企业的岗位，对你来说恐怕这不是一个公平的选择过程，特别是应届毕业生来说，基本上是没有任何溢价的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个所谓的”公平“，是建立在你对公司有价值的基础上，你身上有企业看得上的闪光点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，你的技术能力，项目管理水平，团队管理能力等等。&lt;/p&gt;
&lt;p&gt;作为普通程序员的你，最重要的一条心法，就是要详细了解对方，匹配自己优势，然后自信的面试。&lt;/p&gt;
&lt;p&gt;想象下这样一种场景：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你终于把你的女神约出来了，你应该做好哪些准备呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你是不是提前需要了解她喜欢喝什么？是奶茶，还是咖啡？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对方喜欢吃什么风味的菜，是日料，韩料，火锅，港餐，还是西餐？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对方的爱好是什么？看电影，还是喜欢看书？听音乐？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你要把妹子的方方面面都了解清楚。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;每个男人应该都会这样去做的，这是非常常规，大众都能想到的方式。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;找对象和找工作一样，&lt;strong&gt;一定要匹配才行，颜值要和职业形象不能差太远。否则你不在乎，会让人家感到不舒服&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对应到面试，其实也是一样的，就是跟你女神约会，也需要做好充分的准备。&lt;/p&gt;
&lt;p&gt;接下来的事情就是怎样做准备了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步就是要清楚企业需要怎样的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过研究岗位职责、职位描述、浏览公司网站、app产品等方式判断产品的用户量，可能用到的技术，从而做相应的准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步，了解对方公司和岗位怎么样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全面深入地了解对方的公司，包括公司业务发展历程、产品愿景、迭代周期、团队风格、技术氛围、公司目前遇到的问题和挑战等。&lt;/p&gt;
&lt;p&gt;总之，尽可能多地详细了解对方，然后针对性地进行面试。&lt;/p&gt;
&lt;p&gt;大致可以把职责要求分2类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专业要求和胜任素质要求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专业要求又可以分为专业知识和专业技能。&lt;/p&gt;
&lt;p&gt;专业知识就是对完成工作有用的事实性及经验性信息&lt;/p&gt;
&lt;p&gt;专业技能就是知识掌握程度及应用技能的能力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举一个面试例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你对Linux系统中，你最熟悉哪一块？具体怎么学的？这块内容能够具体的展开讲下吗？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;另一个就是胜任素质要求，其中又包括了：&lt;strong&gt;思维能力、主动承担、脚踏实地、激情进取、坚韧不拔&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思维能力&lt;/strong&gt;重点考察你的分析能力和归纳能力，也就是事物看清，看透的能力和提炼、总结的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动承担&lt;/strong&gt;重点考察是否对自己行为和结果负责，遇到边界工作不推诿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚踏实地&lt;/strong&gt;主要考察你做事是否应付了事，注重实效，不浮于表面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;激情进取&lt;/strong&gt;主要考察是否对工作充满激情精力充沛&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;请介绍一个你主动为自己设立的具有挑战性的目标，为什么觉得这是一个挑战性的目标，为什么给自己设置这个目标？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;坚韧不拔&lt;/strong&gt;主要考察是否积极对待出现的问题，面对困难坚韧不拔。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;_分享一件你觉得压力特别大的事情，为什么压力大？你做了哪些来调节？&lt;br/&gt;_&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你经过多年努力而获得的一项技能是什么？你是怎么做到的？花了多长时间？为什么坚持下来了？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么接下来咱们就具体的典型问题，进行分析，展示出其问题的内核。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;面试的本质就是将自己的优势展示给对方，并且满足对方的核心需求，甚至超出。&lt;/p&gt;
&lt;p&gt;这个过程需要双方展示出诚意。&lt;/p&gt;
&lt;p&gt;招聘方表现诚意的方式是对人才求贤若渴的态度。&lt;/p&gt;
&lt;p&gt;面试者最佳的展示诚意的方式就是你很想通过这次面试环节，获得招聘岗位名额。&lt;/p&gt;
&lt;p&gt;那怎么做呢？回答好每一个面试官的问题，第一个问题往往都是“你好，请介绍下自己”。&lt;/p&gt;
&lt;p&gt;自我介绍本身并不难，我们认识新的朋友时都会自我介绍。这个过程就是对方对你大致了解的过程。&lt;/p&gt;
&lt;p&gt;为什么简历上都写的？还要进行3到5分钟的自我介绍呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个原因就是对你进行熟悉。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多公司面试官，本身可能是部门主管，肯定是非常忙的，对应聘者并不熟悉，可能你的简历在他手上才几分钟，HR就安排了就这个面试。&lt;/p&gt;
&lt;p&gt;在你自我介绍的几分钟之内，同时也在翻阅你的简历，对你进行熟悉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个原因就是了解你的语音表达能力、总结概括能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让你做自我介绍，还可以通过你介绍的过程，看到你的语言表达能力、总结概括能力、逻辑思维能力等等。&lt;/p&gt;
&lt;p&gt;在你做自我介绍的时候，如果你讲得一塌糊涂，能指望你工作以后和同事沟通效率高吗。&lt;/p&gt;
&lt;p&gt;自我介绍前言不搭后语，乱七八糟不知所谓，能指望你工作以后这个要做的事情安排的先后序井井有条吗？&lt;/p&gt;
&lt;p&gt;我曾经面试过这样的人。&lt;/p&gt;
&lt;p&gt;我：请麻烦你简单的介绍下自己。&lt;/p&gt;
&lt;p&gt;他：我叫xx，我工作3年，一直从事软件开发，其他的简历上都有的，就这样。&lt;/p&gt;
&lt;p&gt;很快的就结束了。&lt;/p&gt;
&lt;p&gt;我都没准备好，连忙补充到：请你对你负责的业务详细展开讲下。&lt;/p&gt;
&lt;p&gt;这次面试，我对面试者的第一印象，首先已经打了折扣。虽然还不至于直接pass，但至少已经失去了一些印象分了。以后他和同事共事，沟通上肯定有很大的隐患。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;越简单的问题，越不可大意，背后有大道理和深层次的逻辑&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;“你遇到最大的困难是什么？你是如何解决的？”&lt;/p&gt;
&lt;p&gt;作为面试中的高频题型，常常令应聘者头大。&lt;/p&gt;
&lt;p&gt;面试官到底想考察什么？回答的侧重点又是什么？&lt;/p&gt;
&lt;p&gt;从面试官的角度来看，这个问题的重点并不是你经历的困难本身，而是考察你面对困难所做的思考和努力以及你解决问题的能力。&lt;/p&gt;
&lt;p&gt;事情的结果没有那么重要，克服困难固然值得鼓励，但没能顺利解决也不意味着一无所获，如何从失败的经历中总结经验并有效指导接下来的工作才是一个优秀员工应该具备的基本素质。&lt;/p&gt;
&lt;p&gt;我也分享一个我曾经面试的人。&lt;/p&gt;
&lt;p&gt;他自述解决了一个系统崩溃的问题，当我询问解决的细节时，支支吾吾，遮遮掩掩，回答不到问题的核心。最后追问得知，这个问题其实是他同事解决的。&lt;/p&gt;
&lt;p&gt;切记不要说一些自己没有把握的话，&lt;/p&gt;
&lt;p&gt;因为很多工作只有你真正的参与其中，才能够准确说出其中的难点。&lt;/p&gt;
&lt;p&gt;当面试官就某一个困难深度挖掘时，你的弱点以及不诚实就会毫无保留的暴露出来，最终导致前面的努力功亏一篑。&lt;/p&gt;
&lt;p&gt;整体要把握住“实在比过分夸大更有效”的回答原则，可以适当增加困难程度，衬托出自己做事能力，但不能过分夸大。&lt;/p&gt;
&lt;p&gt;这个问题的核心方法就是要闭环&lt;strong&gt;：一、遇事不乱，冷静分析已有困难；二、展现综合能力，把你的能力表现出来。三、最后进行总结和反思&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总之，这个问题主要考察问题解决能力、随机应变能力。&lt;/p&gt;
&lt;p&gt;什么是最大的困难？(目标很高或情况紧急；STAR法则，把控细节）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决的方法比结果更重要&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;很多面试者，听到这个问题，一时脑袋一片空白。自己根本没有想过这个问题，不知道如何回答。这个问题其实就是考察两点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一，自我认知：我是谁?我从哪里来？到哪里去？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我是谁，什么意思？&lt;/p&gt;
&lt;p&gt;就是自我认知，了解自己发展的定位，了解自己的优劣势机遇挑战，明确自身发展的需要及工作定位,细分下岗位职责等&lt;/p&gt;
&lt;p&gt;我从哪里来？什么意思？&lt;/p&gt;
&lt;p&gt;就是经过多年以后，你是否坚持当初的理想，是否迷失了自己。&lt;/p&gt;
&lt;p&gt;我到哪里去？&lt;/p&gt;
&lt;p&gt;你是否有自己清晰的目标，是否有对自己未来发展的设想、职业生涯的规划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二、考察稳定性：即组织承诺，你到底能在公司踏实干几年？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象下，招聘的岗位是开发，当你回答职业规划时，表示明年想干项目经理。作为面试官，你会怎么想？&lt;/p&gt;
&lt;p&gt;现在你知道怎么回答了吗？，重要的不是回答，而是如何准备。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;离职原因，无非就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动离职，&lt;/strong&gt;原因无非就是钱少、活多、离家远、晋升遇到瓶颈、行业发展慢、工作环境差、领导同事不好相处，等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被动离职，&lt;/strong&gt;原因无非就是公司倒闭、裁员、末位淘汰等。&lt;/p&gt;
&lt;p&gt;这些原因都是可以被理解的。&lt;strong&gt;问题的关键不在于原因，而是给出一个合理的解释&lt;/strong&gt;。就是重点是结合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;你之前的背景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你上一份工作情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你现在面试的岗位&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;给一个合理的解释。&lt;/p&gt;
&lt;p&gt;举一个我面试的例子。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有个面试者说他看不到晋升的可能，他从华为跳槽我们公司，这个解释是无法自圆其说的。因为华为的晋升体系是非常完善的，无法晋升的唯一可能性就是你的能力差。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;很多同学说，离职原因不能说是因为钱少。我的答案是“不一定”&lt;/p&gt;
&lt;p&gt;在我面试200个人中，大概有四分之一都是因为这个原因，本身这并不代表什么，每个人都是社会中的人，必须要考虑现实问题，我觉得是合理的。前提是你的能力必须和薪资水平保持匹配。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;“我问完了，你有什么要问我吗？”&lt;/p&gt;
&lt;p&gt;面试临近结束的时候，其实是一个特别好的机会。&lt;/p&gt;
&lt;p&gt;有些同学在面试结束时，神经开始松懈，以为终于结束了。&lt;/p&gt;
&lt;p&gt;其实，真正的考验，往往在最后出现。&lt;/p&gt;
&lt;p&gt;你可以千万不要问下面的问题。&lt;/p&gt;
&lt;p&gt;公司交社保吗？加班严重吗？同事年纪都是多大？一年有多少年假？&lt;/p&gt;
&lt;p&gt;这些问题不是说不好，而是这些问题都太简单了，都是“百度一下，你就知道”的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可以这样提问&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果我有幸加入贵公司/团队/部门，那么前期我将主要负责哪方面的工作内容呢？&lt;/p&gt;
&lt;p&gt;目前最紧要的任务是什么？&lt;/p&gt;
&lt;p&gt;如果我有幸应聘成功，团队对我会有哪些期望呢，&lt;/p&gt;
&lt;p&gt;公司对我面试的这个岗位的定位是什么？&lt;/p&gt;
&lt;p&gt;最希望这个人达成的工作指标有哪些？&lt;/p&gt;
&lt;p&gt;公司是一群什么样的小伙伴，这个岗位所在的的团队是什么氛围？&lt;/p&gt;
&lt;p&gt;您对我的评价是什么，您觉得我的优势和劣势是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些问题将会帮助你更好的了解到入职之后的主要工作，同时也可以让面试官了解到你对这份工作的热情与期待。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;记住这个心法：&lt;strong&gt;详细了解对方，匹配自己优势，回答好重点问题，自信面试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;祝你能找到最适合自己的工作。献上！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员成为高级管理者的三次跃升&lt;/a&gt;（推荐）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483962&amp;amp;idx=1&amp;amp;sn=cc73b3d2124fc23d89ccc4c5c612d18c&amp;amp;chksm=cf209728f8571e3e4345d4737029960d1e5c3f7b005fd4c8545a1ac283c086a73e4ca914ede0&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员如何打造个人品牌？&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483954&amp;amp;idx=1&amp;amp;sn=4d122f3d2330254f5a5ecca3876c46a8&amp;amp;chksm=cf209720f8571e368d1123e185b30e930c83463496b0a9d8b76aec9ebcffeeb1c3f5155cb1dc&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员你应该勇敢说不&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=7629654c4acf6bd1c5f53639707a9c61&amp;amp;chksm=cf209738f8571e2e66764576dfa494bec92059058c9f2609391ede8c40bc010c167b2d535820&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;聊一聊 软件系统中的“热力学第二定律”&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=a170a555f571d4cbd2c4136b8ed57eff&amp;amp;chksm=cf209711f8571e07d674b4582488fe61e4e64d7179be7cb5ca5574edeee36f207d0cf7b0ea52&amp;amp;scene=21#wechat_redirect&quot;&gt;谈一谈程序员的职业发展路线&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=f30fe58e4ea99d647b1853eca6bd5a6a&amp;amp;chksm=cf209482f8571d94e7dd372851397f98a838e84a9fbea9299337e5ee2301084228a4f57d315c&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;送给刚毕业的程序员——7点建议&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;程序员进阶技术专家必备能力——深度思考&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;觉得不错，记得关注、转发和在看！多年经验分享，实属不易，感谢支持！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;博主是一位物联网大厂技术总监，从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！有问题可以加我微信交流：&lt;strong&gt;pointersss&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你有技术成长的瓶颈、对未来迷茫、关注我，帮你答疑解惑！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/425da483c978ace9c0672045e177b1d1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Nov 2020 00:21:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>成长&amp;amp;认知&amp;#160;丨 作者 / 袁吴范 这是pointers公众号分享的第16篇原创文章 面试，想必所有人都经历过。可以说，面试是相当重要的，因为他决定了你的起点。 从业这么多年，到现在面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/13946797.html</dc:identifier>
</item>
<item>
<title>【QT】子类化QThread实现多线程 - 李春港</title>
<link>http://www.cnblogs.com/lcgbk/p/13946793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcgbk/p/13946793.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;这个是本文章实例的源码地址：&lt;a href=&quot;https://gitee.com/CogenCG/QThreadExample.git&quot;&gt;https://gitee.com/CogenCG/QThreadExample.git&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;子类化QThread来实现多线程， QThread只有run函数是在新线程里的，其他所有函数都在QThread生成的线程里。正确启动线程的方法是调用QThread::start()来启动，如果直接调用run成员函数，这个时候并不会有新的线程产生（ &lt;strong&gt;原因：&lt;/strong&gt; 可以查看往期《QThread源码浅析》文章，了解下run函数是怎么被调用的）。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;子类化 QThread；&lt;/li&gt;
&lt;li&gt;重写run，将耗时的事件放到此函数执行；&lt;/li&gt;
&lt;li&gt;根据是否需要事件循环，若需要就在run函数中调用 QThread::exec() ，开启线程的事件循环。事件循环的作用可以查看往期《QThread源码浅析》文章中《QThread::run()源码》小节进行阅读；&lt;/li&gt;
&lt;li&gt;为子类定义信号和槽，由于槽函数并不会在新开的线程运行，所以需要在构造函数中调用 moveToThread(this)。 &lt;em&gt;&lt;strong&gt;注意：虽然调用moveToThread(this)可以改变对象的线程依附性关系，但是QThread的大多数成员方法是线程的控制接口，QThread类的设计本意是将线程的控制接口供给旧线程（创建QThread对象的线程）使用。所以不要使用moveToThread()将该接口移动到新创建的线程中，调用moveToThread(this)被视为不好的实现。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来会通过 使用线程来实现计时器，并实时在UI上显示 的实例来说明不使用事件循环和使用事件循环的情况。（此实例使用QTimer会更方便，此处为了说明QThread的使用，故使用线程来实现）&lt;/p&gt;

&lt;p&gt;InheritQThread.hpp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class InheritQThread:public QThread
{
    Q_OBJECT
public:
    InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        
    }
    
    void StopThread(){
        QMutexLocker lock(&amp;amp;m_lock);
        m_flag = false;
    }
    
protected:
    //线程执行函数
    void run(){
        qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
        int i=0;
        m_flag = true;
        
        while(1)
        {
            ++i;
            emit ValueChanged(i); //发送信号不需要事件循环机制
            QThread::sleep(1);
            
            {
                QMutexLocker lock(&amp;amp;m_lock);
                if( !m_flag )
                    break;
            }
            
        }
    }
    
signals:
    void ValueChanged(int i);
    
public:
    bool m_flag;
    QMutex m_lock;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mainwindow.hpp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){
        ui-&amp;gt;setupUi(this);
        
        qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
        WorkerTh = new InheritQThread(this);
        connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);
    }
    
    ~MainWindow(){
        delete ui;
    }
    
public slots:
    void setValue(int i){
        ui-&amp;gt;lcdNumber-&amp;gt;display(i);
    }
    
private slots:
    void on_startBt_clicked(){
        WorkerTh-&amp;gt;start();
    }
    
    void on_stopBt_clicked(){
        WorkerTh-&amp;gt;StopThread();
    }
    
    void on_checkBt_clicked(){
        if(WorkerTh-&amp;gt;isRunning()){
            ui-&amp;gt;label-&amp;gt;setText(&quot;Running&quot;);
        }else{
            ui-&amp;gt;label-&amp;gt;setText(&quot;Finished&quot;);
        }
    }
    
private:
    Ui::MainWindow *ui;
    InheritQThread *WorkerTh;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;在使用多线程的时候，如果出现共享资源使用，需要注意资源抢夺的问题，例如上述InheritQThread类中m_flag变量就是一个多线程同时使用的资源，上面例子使用 &lt;strong&gt;QMutexLocker+QMutex&lt;/strong&gt; 的方式对临界资源进行安全保护使用，其实际是使用了 &lt;strong&gt;RAII技术：&lt;/strong&gt;（Resource Acquisition Is Initialization）,也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。简单的说，RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。具体 &lt;strong&gt;QMutexLocker+QMutex&lt;/strong&gt; 互斥锁的原理以及使用方法，在这里就不展开说了，这个知识点网上有很多非常好的文章。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）在不点【start】按键的时候，点击【check thread state】按钮检查线程状态，该线程是未开启的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112427205-1805374044.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）按下【start】后效果如下，并查看终端消息打印信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112446742-53866391.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112452122-284179721.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有调用了QThread::start()后，子线程才是真正的启动，并且只有在run()函数才处于子线程内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）我们再试一下点击【stop】按钮，然后检查线程的状态：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112529946-369890700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【stop】按钮使 m_flag = false， 此时run函数也就可以跳出死循环，并且停止了线程的运作，之后我们就不能再次使用该线程了，也许有的人说，我再一次start不就好了吗？再一次start已经不是你刚才使用的线程了，这是start的是一个全新的线程。到此子类化 QThread ，不使用事件循环的线程使用就实现了，就这么简单。&lt;/p&gt;

&lt;p&gt;run函数中的 while 或者 for 循环执行完之后，如果还想让线程保持运作，后期继续使用，那应该怎么做？&lt;br/&gt;可以启动子线程的事件循环，并且使用信号槽的方式继续使用子线程。&lt;strong&gt;注意：一定要使用信号槽的方式，否则函数依旧是在创建QThread对象的线程执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在run函数中添加QThread::exec()来启动事件循环。（&lt;em&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在没退出事件循环时，QThread::exec()后面的语句都无法被执行，退出后程序会继续执行其后面的语句&lt;/em&gt;）；&lt;/li&gt;
&lt;li&gt;为QThread子类定义信号和槽；&lt;/li&gt;
&lt;li&gt;在QThread子类构造函数中调用 moveToThread(this)（&lt;em&gt;&lt;strong&gt;注意：&lt;/strong&gt; 可以实现构造函数在子线程内执行，但此方法不推荐，更好的方法会在后期的文章进行介绍&lt;/em&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着上述的实例，在InheritQThread类构造函数中添加并且调用moveToThread(this)；在run函数中添加exec()；并定义槽函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/**************在InheritQThread构造函数添加moveToThread(this)**********/
InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        moveToThread(this); 
    }

/**************在InheritQThread::run函数添加exec()***************/
void run(){
    qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

    int i=0;
    m_flag = true;

    while(1)
    {
        ++i;

        emit ValueChanged(i);
        QThread::sleep(1);

        {
            QMutexLocker lock(&amp;amp;m_lock);
            if( !m_flag )
                break;
        }
    }
    
    exec(); //开启事件循环
    }

/************在InheritQThread类中添加QdebugSlot()槽函数***************/
public slots:
    void QdebugSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;QdebugSlot function is in thread:&quot;&amp;lt;&amp;lt;QThread::currentThreadId();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在MainWindow类中添加QdebugSignal信号；在构造函数中将QdebugSignal信号与InheritQThread::QdebugSlot槽函数进行绑；添加一个发送QdebugSignal信号的按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/**********在MainWindow构造函数中绑定信号槽******************/
explicit MainWindow(QWidget *parent = nullptr) :
    QMainWindow(parent),
    ui(new Ui::MainWindow){

    qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

    ui-&amp;gt;setupUi(this);
    WorkerTh = new InheritQThread(this);
    connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);
    connect(this, &amp;amp;MainWindow::QdebugSignal, WorkerTh, &amp;amp;InheritQThread::QdebugSlot); //绑定信号槽
}

/********MainWindow类中添加信号QdebugSignal槽以及按钮事件槽函数**********/
signals:
    void QdebugSignal(); //添加QdebugSignal信号
private slots:
    //按钮的事件槽函数
    void on_SendQdebugSignalBt_clicked()
    {
        emit QdebugSignal();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现事件循环的程序已修改完成，来看下效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）在运行的时候为什么会出现以下警告？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QObject::moveToThread: Cannot move objects with a parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到MainWindow类中是这样定义InheritQThread类对象的：WorkerTh = new InheritQThread(this)。如果需要使用moveToThread()来改变对象的依附性，其创建时不能够带有父类。将语句改为：WorkerTh = new InheritQThread()即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）修改完成后，点击【start】启动线程，然后点击【stop】按钮跳出run函数中的while循环，最后点击【check thread state】按钮来检查线程的状态，会是什么样的情况呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112544167-712087663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，线程依旧处于运行状态，这是因为run函数中调用了exec()，此时线程正处于事件循环中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）接下来再点击【Send QdebugSignal】按钮来发送QdebugSignal信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112558982-2075944686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由终端的打印信息得知，InheritQThread::QdebugSlot槽函数是在子线程中执行的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112612739-783717229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，事件循环是一个无止尽循环，事件循环结束之前，exec()函数后的语句无法得到执行。只有槽函数所在线程开启了事件循环，它才能在对应信号发射后被调用。无论事件循环是否开启，信号发送后会直接进入槽函数所依附的线程的事件队列，然而，只有开启了事件循环，对应的槽函数才会在线程中得到调用。下面通过几种情况来验证下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）代码和《三、使用事件循环》小节的代码一样，然后进行如下的操作：点击【start】按钮-&amp;gt;再点击【Send QdebugSignal】按钮，这个时候槽函数会不会被执行呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112658586-655435592.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112704732-1223060405.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况无论点多少次发送QdebugSignal信号，InheritQThread::QdebugSlot槽函数都不会执行。因为当前线程还处于while循环当中，如果需要实现槽函数在当前线程中执行，那么当前线程就应该处于事件循环的状态，也就是正在执行exec()函数。所以如果需要InheritQThread::QdebugSlot槽函数执行，就需要点击【stop】按钮退出while循环，让线程进入事件循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）在《三、使用事件循环》小节的代码基础上，把InheritQThread::run函数删除，然后进行如下的操作：点击【start】启动线程-&amp;gt;点击【stop】按钮跳出run函数中的while循环进入事件循环-&amp;gt;点击【Send QdebugSignal】按钮来发送QdebugSignal信号，会有什么结果呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结果会和上面第一种情况一样，虽然信号已经在子线程的事件队列上，但是由于子线程没有事件循环，所以槽函数永远都不会被执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）在上面《三、使用事件循环》小节的代码基础上，将InheritQThread构造函数中的 moveToThread(this) 去除掉。进行如下操作：点击【start】启动线程-&amp;gt;点击【stop】按钮跳出run函数中的while循环进入事件循环-&amp;gt;点击【Send QdebugSignal】按钮来发送QdebugSignal信号，会有什么结果呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112724770-106445139.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出InheritQThread::QdebugSlot槽函数居然是在GUI主线程中执行了。因为InheritQThread对象我们是在主线程中new出来的，如果不使用moveToThread(this)来改变对象的依附性关系，那么InheritQThread对象就是属于GUI主线程，根据connect信号槽的执行规则，最终槽函数会在对象所依赖的线程中执行。&lt;strong&gt;信号与槽绑定的connect函数的细节会在后期的《跨线程的信号槽》文章进行单独介绍。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;InheritQThread类的代码不变动，和上述的代码一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef INHERITQTHREAD_H
#define INHERITQTHREAD_H
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QMutex&amp;gt;
#include &amp;lt;QMutexLocker&amp;gt;
#include &amp;lt;QDebug&amp;gt;

class InheritQThread:public QThread
{
    Q_OBJECT

public:
    InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        moveToThread(this);
    }

    void StopThread(){
        QMutexLocker lock(&amp;amp;m_lock);
        m_flag = false;
    }

protected:
    //线程执行函数
    void run(){
        qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        int i=0;
        m_flag = true;

        while(1)
        {
            ++i;

            emit ValueChanged(i);
            QThread::sleep(1);

            {
                QMutexLocker lock(&amp;amp;m_lock);
                if( !m_flag )
                    break;
            }
        }

        exec();
    }

signals:
    void ValueChanged(int i);

public slots:
    void QdebugSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;QdebugSlot function is in thread:&quot;&amp;lt;&amp;lt;QThread::currentThreadId();
    }

public:
    bool m_flag;
    QMutex m_lock;
};

#endif // INHERITQTHREAD_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindow类添加ExitBt、TerminateBt两个按钮，用于调用WorkerTh-&amp;gt;exit(0)、WorkerTh-&amp;gt;terminate()退出线程函数。由往期《QThread源码浅析》文章中《QThread::quit()、QThread::exit()、QThread::terminate()源码》小节得知调用quit和exit是一样的，所以本处只添加了ExitBt按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &quot;ui_mainwindow.h&quot;
#include &quot;InheritQThread.h&quot;
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QDebug&amp;gt;

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){

        qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        ui-&amp;gt;setupUi(this);
        WorkerTh = new InheritQThread();
        connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);

        connect(this, &amp;amp;MainWindow::QdebugSignal, WorkerTh, &amp;amp;InheritQThread::QdebugSlot);
    }

    ~MainWindow(){
        delete ui;
    }

signals:
    void QdebugSignal();

public slots:
    void setValue(int i){
        ui-&amp;gt;lcdNumber-&amp;gt;display(i);
    }

private slots:
    void on_startBt_clicked(){
        WorkerTh-&amp;gt;start();
    }

    void on_stopBt_clicked(){
        WorkerTh-&amp;gt;StopThread();
    }

    void on_checkBt_clicked(){
        if(WorkerTh-&amp;gt;isRunning()){
            ui-&amp;gt;label-&amp;gt;setText(&quot;Running&quot;);
        }else{
            ui-&amp;gt;label-&amp;gt;setText(&quot;Finished&quot;);
        }
    }

    void on_SendQdebugSignalBt_clicked(){
        emit QdebugSignal();
    }

    void on_ExitBt_clicked(){
        WorkerTh-&amp;gt;exit(0);
    }

    void on_TerminateBt_clicked(){
        WorkerTh-&amp;gt;terminate();
    }

private:
    Ui::MainWindow *ui;
    InheritQThread *WorkerTh;
};

#endif // MAINWINDOW_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上述的例程，点击【start】启动线程按钮，然后直接点击【exit(0)】或者【terminate()】，这样会直接退出线程吗？&lt;br/&gt;点击【exit(0)】按钮（猛点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112738784-1050849222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【terminate()】按钮（就点一点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112807098-2035266926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上述情况我们可以看到上面例程的线程启动之后，无论怎么点击【start】按钮，线程都不会退出，点击【terminate()】按钮的时候就会立刻退出当前线程。由往期《QThread源码浅析》文章中《QThread::quit()、QThread::exit()、QThread::terminate()源码》小节可以得知，若使用QThread::quit()、QThread::exit()来退出线程，该线程就必须要在事件循环的状态（也就是正在执行exec()），线程才会退出。而QThread::terminate()不管线程处于哪种状态都会强制退出线程，但这个函数存在非常多不安定因素，不推荐使用。我们下面来看看如何正确退出线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）如何正确退出线程？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程内没有事件循环，那么只需要用一个标志变量来跳出run函数的while循环，这就可以正常退出线程了。&lt;/li&gt;
&lt;li&gt;如果线程内有事件循环，那么就需要调用QThread::quit()或者QThread::exit()来结束事件循环。像刚刚举的例程，不仅有while循环，循环后面又有exec()，那么这种情况就需要先让线程跳出while循环，然后再调用QThread::quit()或者QThread::exit()来结束事件循环。如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201107112937869-1625125915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：尽量不要使用QThread::terminate()来结束线程，这个函数存在非常多不安定因素。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）如何正确释放线程资源？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;退出线程不代表线程的资源就释放了，退出线程只是把线程停止了而已，那么QThread类或者QThread派生类的资源应该如何释放呢？直接 delete QThread类或者派生类的指针吗？当然不能这样做，&lt;strong&gt;千万别手动delete线程指针，手动delete会发生不可预料的意外。理论上所有QObject都不应该手动delete，如果没有多线程，手动delete可能不会发生问题，但是多线程情况下delete非常容易出问题，那是因为有可能你要删除的这个对象在Qt的事件循环里还排队，但你却已经在外面删除了它，这样程序会发生崩溃。&lt;/strong&gt; 线程资源释放分为两种情况，一种是在创建QThread派生类时，添加了父对象，例如在MainWindow类中WorkerTh = new InheritQThread(this)让主窗体作为InheritQThread对象的父类；另一种是不设置任何父类，例如在MainWindow类中WorkerTh = new InheritQThread()。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、创建QThread派生类，有设置父类的情况：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种情况，QThread派生类的资源都让父类接管了，当父对象被销毁时，QThread派生类对象也会被父类delete掉，我们无需显示delete销毁资源。但是子线程还没结束完，主线程就destroy掉了(WorkerTh的父类是主线程窗口，主线程窗口如果没等子线程结束就destroy的话，会顺手把WorkerTh也delete这时就会奔溃了)。 &lt;strong&gt;注意：这种情况不能使用moveToThread(this)改变对象的依附性。&lt;/strong&gt; 因此我们应该把上面MainWindow类的构造函数改为如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;~MainWindow(){
    WorkerTh-&amp;gt;StopThread();//先让线程退出while循环
    WorkerTh-&amp;gt;exit();//退出线程事件循环
    WorkerTh-&amp;gt;wait();//挂起当前线程，等待WorkerTh子线程结束
    delete ui;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、创建QThread派生类，没有设置父类的情况：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是没有任何父类接管资源了，又不能直接delete QThread派生类对象的指针，但是QObject类中有 &lt;strong&gt;void QObject::deleteLater () [slot]&lt;/strong&gt; 这个槽，这个槽非常有用，后面会经常用到它用于安全的线程资源销毁。我们通过查看往期《QThread源码浅析》文章中《QThreadPrivate::start()源码》小节可知线程结束之后会发出 &lt;strong&gt;QThread::finished()&lt;/strong&gt; 的信号，我们将这个信号和 &lt;strong&gt;deleteLater&lt;/strong&gt; 槽绑定，线程结束后调用deleteLater来销毁分配的内存。&lt;br/&gt;在MainWindow类构造函数中，添加以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;connect(WorkerTh, &amp;amp;QThread::finished, WorkerTh, &amp;amp;QObject::deleteLater) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;~MainWindow()析构函数可以把 wait()函数去掉了，因为该线程的资源已经不是让主窗口来接管了。当我们启动线程之后，然后退出主窗口或者直接点击【stop】+【exit()】按钮的时候，会出现以下的警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QThread::wait: Thread tried to wait on itself
QThread: Destroyed while thread is still running
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让子线程能够响应信号并在子线程执行槽函数，我们在InheritQThread类构造函数中添加了 &lt;strong&gt;moveToThread(this)&lt;/strong&gt; ，此方法是官方极其不推荐使用的方法。那么现在我们就遇到了由于这个方法引发的问题，我们把moveToThread(this)删除，程序就可以正常结束和释放资源了。那如果要让子线程能够响应信号并在子线程执行槽函数，这应该怎么做？在下一期会介绍一个官方推荐的《子类化QObject+moveToThread》的方法。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;QThread只有run函数是在新线程里；&lt;/li&gt;
&lt;li&gt;如果必须需要实现在线程内执行槽的情景，那就需要在QThread的派生类构造函数中调用moveToThread(this)，并且在run函数内执行QThread::exec()开启事件循环；（极其不推荐使用moveToThread(this)，下一期会介绍一种安全可靠的方法）&lt;/li&gt;
&lt;li&gt;若需要使用事件循环，需要在run函数中调用QThread::exec()；&lt;/li&gt;
&lt;li&gt;尽量不要使用terminate()来结束线程，可以使用bool标志位退出或者在线程处于事件循环时调用QThread::quit、QThread::exit来退出线程；&lt;/li&gt;
&lt;li&gt;善用QObject::deleteLater来进行内存管理；&lt;/li&gt;
&lt;li&gt;在QThread执行start函数之后，run函数还未运行完毕，再次start，不会发生任何结果；&lt;/li&gt;
&lt;li&gt;子类化QThread多线程的方法适用于后台执行长时间的耗时操作、单任务执行的、无需在线程内执行槽的情景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;这个是本文章实例的源码地址：&lt;a href=&quot;https://gitee.com/CogenCG/QThreadExample.git&quot;&gt;https://gitee.com/CogenCG/QThreadExample.git&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Nov 2020 00:18:00 +0000</pubDate>
<dc:creator>李春港</dc:creator>
<og:description>《QThread源码浅析》 这个是本文章实例的源码地址：https://gitee.com/CogenCG/QThreadExample.git 子类化QThread来实现多线程，&amp;amp;#160;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lcgbk/p/13946793.html</dc:identifier>
</item>
<item>
<title>Flink的sink实战之二：kafka - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13946789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13946789.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《Flink的sink实战》系列的第二篇，前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105597628&quot;&gt;《Flink的sink实战之一：初探》&lt;/a&gt;对sink有了基本的了解，本章来体验将数据sink到kafka的操作；&lt;/p&gt;
&lt;h3 id=&quot;全系列链接&quot;&gt;全系列链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105597628&quot;&gt;《Flink的sink实战之一：初探》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105598224&quot;&gt;《Flink的sink实战之二：kafka》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105598968&quot;&gt;《Flink的sink实战之三：cassandra3》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105599511&quot;&gt;《Flink的sink实战之四：自定义》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;版本和环境准备&quot;&gt;版本和环境准备&lt;/h3&gt;
&lt;p&gt;本次实战的环境和版本如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK：1.8.0_211&lt;/li&gt;
&lt;li&gt;Flink：1.9.2&lt;/li&gt;
&lt;li&gt;Maven：3.6.0&lt;/li&gt;
&lt;li&gt;操作系统：macOS Catalina 10.15.3 （MacBook Pro 13-inch, 2018）&lt;/li&gt;
&lt;li&gt;IDEA：2018.3.5 (Ultimate Edition)&lt;/li&gt;
&lt;li&gt;Kafka：2.4.0&lt;/li&gt;
&lt;li&gt;Zookeeper：3.5.5&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;请确保上述环境和服务已经就绪；&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;如果您不想写代码，整个系列的源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;flinksinkdemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081046069-1123443178.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;准备完毕，开始开发；&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;正式编码前，先去官网查看相关资料了解基本情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;地址：&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html&quot;&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.9/dev/connectors/kafka.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我这里用的kafka是2.4.0版本，在官方文档查找对应的库和类，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081046570-900671175.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;kafka准备&quot;&gt;kafka准备&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建名为test006的topic，有四个分区，参考命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./kafka-topics.sh \
--create \
--bootstrap-server 127.0.0.1:9092 \
--replication-factor 1 \
--partitions 4 \
--topic test006
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在控制台消费test006的消息，参考命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./kafka-console-consumer.sh \
--bootstrap-server 127.0.0.1:9092 \
--topic test006
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;此时如果该topic有消息进来，就会在控制台输出；&lt;/li&gt;
&lt;li&gt;接下来开始编码；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;创建工程&quot;&gt;创建工程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用maven命令创建flink工程：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn \
archetype:generate \
-DarchetypeGroupId=org.apache.flink \
-DarchetypeArtifactId=flink-quickstart-java \
-DarchetypeVersion=1.9.2
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;根据提示，groupid输入&lt;span&gt;com.bolingcavalry&lt;/span&gt;，artifactid输入&lt;span&gt;flinksinkdemo&lt;/span&gt;，即可创建一个maven工程；&lt;/li&gt;
&lt;li&gt;在pom.xml中增加kafka依赖库：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;flink-connector-kafka_2.11&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;工程创建完成，开始编写flink任务的代码；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;发送字符串消息的sink&quot;&gt;发送字符串消息的sink&lt;/h3&gt;
&lt;p&gt;先尝试发送字符串类型的消息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建KafkaSerializationSchema接口的实现类，后面这个类要作为创建sink对象的参数使用：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.addsink;

import org.apache.flink.streaming.connectors.kafka.KafkaSerializationSchema;
import org.apache.kafka.clients.producer.ProducerRecord;
import java.nio.charset.StandardCharsets;

public class ProducerStringSerializationSchema implements KafkaSerializationSchema&amp;lt;String&amp;gt; {

    private String topic;

    public ProducerStringSerializationSchema(String topic) {
        super();
        this.topic = topic;
    }

    @Override
    public ProducerRecord&amp;lt;byte[], byte[]&amp;gt; serialize(String element, Long timestamp) {
        return new ProducerRecord&amp;lt;byte[], byte[]&amp;gt;(topic, element.getBytes(StandardCharsets.UTF_8));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建任务类KafkaStrSink，请注意FlinkKafkaProducer对象的参数，FlinkKafkaProducer.Semantic.EXACTLY_ONCE表示严格一次：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.addsink;

import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

public class KafkaStrSink {
    public static void main(String[] args) throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        //并行度为1
        env.setParallelism(1);

        Properties properties = new Properties();
        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;192.168.50.43:9092&quot;);

        String topic = &quot;test006&quot;;
        FlinkKafkaProducer&amp;lt;String&amp;gt; producer = new FlinkKafkaProducer&amp;lt;&amp;gt;(topic,
                new ProducerStringSerializationSchema(topic),
                properties,
                FlinkKafkaProducer.Semantic.EXACTLY_ONCE);

        //创建一个List，里面有两个Tuple2元素
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&quot;aaa&quot;);
        list.add(&quot;bbb&quot;);
        list.add(&quot;ccc&quot;);
        list.add(&quot;ddd&quot;);
        list.add(&quot;eee&quot;);
        list.add(&quot;fff&quot;);
        list.add(&quot;aaa&quot;);

        //统计每个单词的数量
        env.fromCollection(list)
           .addSink(producer)
           .setParallelism(4);

        env.execute(&quot;sink demo : kafka str&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;使用mvn命令编译构建，在target目录得到文件&lt;span&gt;flinksinkdemo-1.0-SNAPSHOT.jar&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在flink的web页面提交flinksinkdemo-1.0-SNAPSHOT.jar，并制定执行类，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081046995-1443904821.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;提交成功后，如果flink有四个可用slot，任务会立即执行，会在消费kafak消息的终端收到消息，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081047250-126291163.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;任务执行情况如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081047654-1385387273.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;发送对象消息的sink&quot;&gt;发送对象消息的sink&lt;/h3&gt;
&lt;p&gt;再来尝试如何发送对象类型的消息，这里的对象选择常用的Tuple2对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建KafkaSerializationSchema接口的实现类，该类后面要用作sink对象的入参，请注意代码中捕获异常的那段注释：&lt;span&gt;生产环境慎用printStackTrace()!!!&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.addsink;

import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.flink.streaming.connectors.kafka.KafkaSerializationSchema;
import org.apache.kafka.clients.producer.ProducerRecord;
import javax.annotation.Nullable;

public class ObjSerializationSchema implements KafkaSerializationSchema&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; {

    private String topic;
    private ObjectMapper mapper;

    public ObjSerializationSchema(String topic) {
        super();
        this.topic = topic;
    }

    @Override
    public ProducerRecord&amp;lt;byte[], byte[]&amp;gt; serialize(Tuple2&amp;lt;String, Integer&amp;gt; stringIntegerTuple2, @Nullable Long timestamp) {
        byte[] b = null;
        if (mapper == null) {
            mapper = new ObjectMapper();
        }
        try {
            b= mapper.writeValueAsBytes(stringIntegerTuple2);
        } catch (JsonProcessingException e) {
            // 注意，在生产环境这是个非常危险的操作，
            // 过多的错误打印会严重影响系统性能，请根据生产环境情况做调整
            e.printStackTrace();
        }
        return new ProducerRecord&amp;lt;byte[], byte[]&amp;gt;(topic, b);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建flink任务类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.addsink;

import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaProducer;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

public class KafkaObjSink {
    public static void main(String[] args) throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        //并行度为1
        env.setParallelism(1);

        Properties properties = new Properties();
        //kafka的broker地址
        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;192.168.50.43:9092&quot;);

        String topic = &quot;test006&quot;;
        FlinkKafkaProducer&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; producer = new FlinkKafkaProducer&amp;lt;&amp;gt;(topic,
                new ObjSerializationSchema(topic),
                properties,
                FlinkKafkaProducer.Semantic.EXACTLY_ONCE);

        //创建一个List，里面有两个Tuple2元素
        List&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(new Tuple2(&quot;aaa&quot;, 1));
        list.add(new Tuple2(&quot;bbb&quot;, 1));
        list.add(new Tuple2(&quot;ccc&quot;, 1));
        list.add(new Tuple2(&quot;ddd&quot;, 1));
        list.add(new Tuple2(&quot;eee&quot;, 1));
        list.add(new Tuple2(&quot;fff&quot;, 1));
        list.add(new Tuple2(&quot;aaa&quot;, 1));

        //统计每个单词的数量
        env.fromCollection(list)
            .keyBy(0)
            .sum(1)
            .addSink(producer)
            .setParallelism(4);
        
        env.execute(&quot;sink demo : kafka obj&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;像前一个任务那样编译构建，把jar提交到flink，并指定执行类是&lt;span&gt;com.bolingcavalry.addsink.KafkaObjSink&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;消费kafka消息的控制台输出如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081048052-286222548.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在web页面可见执行情况如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201109081048701-1323728773.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，flink将计算结果作为kafka消息发送出去的实战就完成了，希望能给您提供参考，接下来的章节，我们会继续体验官方提供的sink能力；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 09 Nov 2020 00:11:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13946789.html</dc:identifier>
</item>
<item>
<title>Spring 自调用事务失效，你是怎么解决的？ - 刘志航</title>
<link>http://www.cnblogs.com/liuzhihang/p/spring-self-call.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhihang/p/spring-self-call.html</guid>
<description>&lt;p&gt;相信大家都遇到一种事务失效场景，那就是 Spring 自调用，就是在 Service 方法内，调用另一个加 @Transactional 注解的方法，发现事务失效，这时候你是怎么解决的呢？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;147.73642105263&quot;&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相信大家都遇到一种事务失效场景，那就是 Spring 自调用，就是在 Service 方法内，调用另一个加 &lt;code&gt;@Transactional&lt;/code&gt; 注解的方法，发现事务失效，这时候你是怎么解决的呢？&lt;/p&gt;
&lt;p&gt;公众号：『 刘志航 』，记录工作学习中的技术、开发及源码笔记；时不时分享一些生活中的见闻感悟。欢迎大佬来指导！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;事情回顾&quot;&gt;事情回顾&lt;/h3&gt;
&lt;p&gt;那是一个我忘了天气咋样的下午，突然蹦出一个小红点，嗯~ 挺着急的小红点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3E8q0W-3Cg65u.png&quot; alt=&quot;3E8q0W-3Cg65u&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来是事务失效了！&lt;/p&gt;
&lt;p&gt;莫慌！莫慌！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kRoqUW-MKbcBj.png&quot; alt=&quot;kRoqUW-MKbcBj&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KVdtlZ-F3jW3p.png&quot; alt=&quot;KVdtlZ-F3jW3p&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T4poZK-qyiLEV.png&quot; alt=&quot;T4poZK-qyiLEV&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后小伙伴选择了抽走，是我的工具类不香了么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zVf6LC-tLzseS.png&quot; alt=&quot;zVf6LC-tLzseS&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然故事的结果是完美的，问题解决了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/v3W8tg-VJEgZS.jpg&quot; alt=&quot;v3W8tg-VJEgZS&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
&lt;p&gt;在开发中涉及到同时操作多个表的时候，要保证两个操作要么一起成功，要么一起失败，这时候就需要用到事务。&lt;/p&gt;
&lt;p&gt;现在一般使用的都是基于 &lt;code&gt;@Transactional&lt;/code&gt; 注解的&lt;strong&gt;声明式事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而事务使用过程中有以下几个注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事务只能应用到 public 方法上才会有效；&lt;/li&gt;
&lt;li&gt;事务需要从外部调用，Spring 自调用会失效；&lt;/li&gt;
&lt;li&gt;建议事务注解 @Transactional 一般添加在实现类上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然这几句话不是说我的，人家官方文档可是明确说明的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IlNXVn-uemNYF.png&quot; alt=&quot;IlNXVn-uemNYF&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可是说明了&lt;code&gt;应仅将 @Transactional 注解应用于具有公开可见性的方法。如果对受 protected, private o或 package-visible 修饰的方法使用，则不会引发任何错误，但是被注解的方法不会显示已配置的事务设置。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说白了，就是你用了，不会报错，但是不生效！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/M5XTck-YnrPiu.png&quot; alt=&quot;M5XTck-YnrPiu&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于建议加在实现类上，这个只是建议，不过如果加在接口类或接口方法上时，只有配置基于接口的代理才会生效。所以这块还是老老实实的&lt;code&gt;加在实现类或实现类方法上&lt;/code&gt;吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/P28Ciu-4YvetS.png&quot; alt=&quot;P28Ciu-4YvetS&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为代理模式只拦截通过代理传入的外部方法调用，所以自调用事务是不生效的。&lt;/p&gt;
&lt;p&gt;官方的解释还是比较简单明了的，虽然我看不懂，但是不影响我截图。&lt;/p&gt;
&lt;p&gt;那我还是再截一个吧……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sBkeIz-80K1UE.png&quot; alt=&quot;sBkeIz-80K1UE&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实际使用&quot;&gt;实际使用&lt;/h3&gt;
&lt;p&gt;但是在开发中，小伙伴们往往会遇到这种情况！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/g1BG6s-BgQfOw.png&quot; alt=&quot;g1BG6s-BgQfOw&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来&lt;strong&gt;自己写的&lt;/strong&gt;代码就一坨坨的又臭又长，里面有各种验签、验参、查询、验证等等，就想着来个事务，让事务包裹的范围最小，仅仅在同时更新的时候加上事务吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/38SYyX-gEXV58.png&quot; alt=&quot;38SYyX-gEXV58&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么写，咦~ IDEA 报错了，好像不能 &lt;code&gt;private&lt;/code&gt; 修饰，那我改成 &lt;code&gt;public&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;很显然事务是不生效的。&lt;/p&gt;
&lt;p&gt;把更新的代码放到&lt;code&gt;又臭又长&lt;/code&gt;的代码里面，让它变得更臭更长，然后用 &lt;code&gt;@Transactional&lt;/code&gt; 注解一加。完美解决！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/9r8ioC-W6kSbv.jpg&quot; alt=&quot;9r8ioC-W6kSbv&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请放过那坨代码吧！来看看下面的办法。&lt;/p&gt;
&lt;h4 id=&quot;解决方案-1&quot;&gt;解决方案 1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/08fPAy-ee1X6A.png&quot; alt=&quot;08fPAy-ee1X6A&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我改成外部调用不就行了么？&lt;/p&gt;
&lt;p&gt;再声明一个 Service，把更新表的逻辑放过去。&lt;/p&gt;
&lt;p&gt;我一般就喜欢使用这个办法。&lt;/p&gt;
&lt;h4 id=&quot;解决方案-2&quot;&gt;解决方案 2&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;编程式事务&lt;/code&gt;，前面说了，使用&lt;code&gt;声明式事务&lt;/code&gt;时，又这又那，我换一种总可以吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/yuJKad-LGJuVt.png&quot; alt=&quot;yuJKad-LGJuVt&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你看，我还把方法改成 &lt;code&gt;private&lt;/code&gt; 修饰了，事务也生效。完美解决！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8orQs4-tgtQts.jpg&quot; alt=&quot;8orQs4-tgtQts&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这个方法也很不错哦！&lt;/p&gt;
&lt;h4 id=&quot;解决方案-3&quot;&gt;解决方案 3&lt;/h4&gt;
&lt;p&gt;又想用注解，又想自调用怎么办？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MBSeHo-E5RDuC.jpg&quot; alt=&quot;MBSeHo-E5RDuC&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过... 麻烦一点还是可以的。&lt;/p&gt;
&lt;p&gt;咱们可以参考&lt;code&gt;编程式事务&lt;/code&gt;的方式，不就是不让自调用么，我调外部方法，然后外部方法再给我调回来不就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class TransactionalComponent {

    public interface Cell {

        void run() throws Exception;
    }

    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
    public void required(Cell cell) throws Exception {

        cell.run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话不就可以通过 &lt;code&gt;TransactionalComponent&lt;/code&gt; 调用了么，并且还可以使用 &lt;code&gt;lambda&lt;/code&gt; 表达式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/y5bnw5-TMtjKN.png&quot; alt=&quot;y5bnw5-TMtjKN&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然基于这个版本也可以做一个迭代，就是使用静态方法调用，不用每次都用 &lt;code&gt;@Autowired&lt;/code&gt; 注入一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TransactionalUtils {
    
    private static volatile TransactionalComponent transactionalComponent;

    private static synchronized TransactionalComponent getTransactionalComponent() {
        if (transactionalComponent == null) {
            // 从容器中获取 transactionalComponent
            transactionalComponent = ApplicationContextUtils.getBean(TransactionalComponent.class);
        }
        return transactionalComponent;
    }

    public static void required(TransactionalComponent.Cell cell) throws Exception {
        getTransactionalComponent().required(cell);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/awzH4i-JjJNp4.png&quot; alt=&quot;awzH4i-JjJNp4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样通过工具类 &lt;code&gt;TransactionalUtils&lt;/code&gt; 便可以直接调用静态方法的方式执行事务操作。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;h4 id=&quot;结束语&quot;&gt;结束语&lt;/h4&gt;
&lt;p&gt;本文主要介绍为什么会遇到事务失效，以及事务失效的避免方式，同时提供了三种方式来解决自调用事务失效的问题。不足之处，欢迎指正。&lt;/p&gt;
&lt;h4 id=&quot;相关资料&quot;&gt;相关资料&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Spring 文档：&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations&quot;&gt;https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Sun, 08 Nov 2020 23:52:00 +0000</pubDate>
<dc:creator>刘志航</dc:creator>
<og:description>相信大家都遇到一种事务失效场景，那就是 Spring 自调用，就是在 Service 方法内，调用另一个加 @Transactional 注解的方法，发现事务失效，这时候你是怎么解决的呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuzhihang/p/spring-self-call.html</dc:identifier>
</item>
<item>
<title>vscode实现远程linux服务器上Python开发 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13946762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13946762.html</guid>
<description>&lt;p&gt;（3）在linux修改.ssh目录和authorized_keys权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# chmod 700 .ssh
# chmod 600 authorized_keys

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）测试配置是否成功，如果成功，在windows系统中就可以通过以下方式免密登录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ssh 用户名@远程服务器ip&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 08 Nov 2020 23:42:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>最近需要训练一个生成对抗网络模型，然后开发接口，不得不在一台有显卡的远程linux服务器上进行，所以，趁着这个机会研究了下怎么使用vscode来进行远程开发。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/13946762.html</dc:identifier>
</item>
<item>
<title>程序员的十年之痒 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13946758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13946758.html</guid>
<description>&lt;h2 id=&quot;缘起&quot;&gt;缘起&lt;/h2&gt;
&lt;p&gt;一路回忆过来，发现我应该不能算是个正经程序员，&lt;strong&gt;这后来的一切都源于十年前的一个传单&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073322331-300188484.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那时候在读高中二年级，那个中午刚走到学校大门外，阳光正好通过那个传单刺到了我的眼睛，传单的内容很长，是一个技术学院为了招生写的关于黑客的描述，大概意思是那是热爱自由、平等、开源，躲在黑暗角落的怪人。&lt;/p&gt;
&lt;p&gt;我接下这个传单后就一发不可收拾了，过了几天就做了一个决定，决定不上高三了，直接去那个学院报名，奈不过家里的逼迫，最终还是坚持读完了高三，但是在读高三的这一年里现在想来真是想穿越过去扇自己两巴掌。我用非常&lt;code&gt;工整&lt;/code&gt;的字体把传单抄在了白纸上，&lt;strong&gt;别人背文言文，我读传单&lt;/strong&gt;。那时候李阳来学校演讲推他的疯狂英语，全校就每天疯狂英语，我每天就读那个传单。那时候我还没有手机，还不会上网，就是单纯的被那种&lt;code&gt;黑客精神&lt;/code&gt;所吸引。后来在书店发现一本《黑客X档案》的杂志，有空了就去看，后来还经常去网吧研究怎么&lt;code&gt;免费上网&lt;/code&gt;，有一次电脑突然被搞蓝屏了，拔腿就跑了。再后来就在一个更大的书店发现了程序设计系列的书，当时花重金买了一本，第二天就被班主任没收了。就这样过了几个月，同学们每天疯狂的为考大学做着各种努力，我却根本就没打算考大学，原因就是我想&lt;code&gt;按需学习&lt;/code&gt;，不想为了应试学习，&lt;strong&gt;这个想法也为以后各种痛苦的经历埋下了伏笔&lt;/strong&gt;，但是当距离高考不到半年的时候，还是开始紧张起来了，有一次在书店里溜达，突然看到了七田真的超右脑系列，关于波动速读，关于照相记忆，又是一阵痴迷，天天研究那些玩意，还嘲笑身边同学说他们那是最低效的学习方式，还说我们人类要想快速进入更高级的文明，必须要有更加高等的学习方式，就这样，高考到了，自然而然的考的很差，高中结束后，傻逼了......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073332854-753456971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但我对那个传单的内容一直念念不忘，打听了那个学院的学费后还是放弃了。听说有个亲戚在北京搞软件开发，就要了联系方式，买了去北京的火车票，在火车上过了18岁的生日，长这么大从来没出过家门，在火车上哭成泪人，&lt;strong&gt;只是因为想家&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;
&lt;p&gt;到了北京，在10 号线终点站&lt;code&gt;巴沟村&lt;/code&gt;三百块钱租了一个七平左右的房子，一排排，一片片，房子只有一层，屋顶铺了一层石棉瓦，晚上猫在屋顶跑来跑去，屋里听到哗啦哗啦响。过了几天就跟亲戚（下文统一称师父）借了几本书，弄了个二手大头显示器的电脑，师父是一个 Java 工程师，就这样开始了Java 程序员之旅，开始看 Java 语法大全，写下了第一个 &lt;code&gt;Hello World&lt;/code&gt; ，当看到控制台输出的这几个字符，就感觉从这一刻开始，&lt;strong&gt;不再是为了兴趣而学习，而是在为自己的选择而负责&lt;/strong&gt;。我把半本书的代码都敲了一遍，然后就开始学&lt;code&gt;数据库&lt;/code&gt;的相关内容，最后用 SSH 框架+ JSP 写了几个可以交互的小页面，中间遇到的问题也会向师傅即时请教。说来心酸，这段时间晚上以泪洗面，无比思念家乡。但是第二天还是强忍着继续敲代码，就这样持续了大概三个多月吧，感觉自己啥都会了，就开始准备投简历找工作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：以下办证、工作年限等内容强烈&lt;code&gt;反对&lt;/code&gt;效仿，此举是为了保证故事的真实性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一打开招聘网站，就看到要求基本上都是本科或者大专以上学历，最低要求一年以上经验，瞬间傻眼了，怎么办呢？有一次路过人大校门口，听到路边摆摊阿姨在喊&lt;code&gt;办证&lt;/code&gt;，咦，办证？办啥证？最后用二百块钱换了一个某某大学的毕业证，学历有了，经验怎么办呢？网上找了几个项目，包装了三年项目经验，开始投简历面试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073343359-554304413.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次去面试的印象非常深刻，站在一个很高的写字楼门口，看到来来往往的打工人穿的真好，有穿西装的、有穿运动服运动鞋的，再反观下我自己，大冷天的还穿着拖鞋和破旧衣。&lt;strong&gt;一个刚从村里跑出来的孩子带着一丝畏惧准备进去面试&lt;/strong&gt;，中途还被保安拦下了。面试现场，就在一个小隔间里，面试官只问了几个技术问题，我就开始怀疑人生了。更恐怖的是开始算时间，十八九岁，大学毕业，三年经验，天才呀！ 尴尬，太尴尬了！那个，面试官不好意思，我再回去准备准备，第一次面试就这样结束了。&lt;/p&gt;
&lt;p&gt;回去开始疯狂刷面试题，继续投简历面试，差不多把整个北京都跑遍了，基本上一天一两家，就这样持续了三个多月，面了一百家左右，最终靠运气被一家公司录取了，录取原因就是&lt;code&gt;笔试&lt;/code&gt;做的不错，这家公司项目经理也是某某大学的，平时聊天时还偶尔问一下你认识那个什么什么老师吗，我就含糊其辞的说不清楚。。。。。。每天对聊这些都很担惊受怕。&lt;/p&gt;
&lt;p&gt;后来我就开始做项目，舆情监控系统，让我用 JNI 调用 c++ 写的一些接口，搞了一周也没搞好，还因此让项目经理和一位清华大学的博士顾问吵了起来，我没怎么见过世面，可被这阵仗吓坏了。第二天就跟技术负责人说你把我开除吧，这事我做不了，过了几天就让我走了。于是我第一份工作就这样被吓跑了，那天晚上还下着雪，站在雪地里哭的像个孩子，雪泪交融。。。。。。雪停了，慢慢走回到了屋子里，心想着收拾收拾回家吧，可是回家做什么呢？跟爸妈一起去打工？我也好想跟他们去打工，去新疆摘棉花，去广州电子厂做小孩的玩具，可是这样他们就算是培养出了一个没出息的儿子。在脑海中各种声音的折磨中做了最后的选择，继续学习继续面试吧！&lt;strong&gt;心智在泪水的冲刷和现实的洗涤中慢慢变得成熟了起来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073353423-1721919475.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过了一个月，又靠运气找到了一家公司，虽然面试的过程中又被算时间了，又说是个天才了。是个国企，都说国企会查学历，每天担惊受怕的。在这家公司遇到了到现在为止最好的一个同事，大家都叫她月姐，平时遇到问题都会耐心的帮忙，后端开发一共三个人，还有一个小吴同学，我们关系都非常好。&lt;/p&gt;
&lt;p&gt;后面开始接触项目，无线定位系统，一开始经常去北京的各种精神病院出差，后面就去另外一个城市的监狱出差，而且都是我自己一个人去。大概有一年的时间都是在监狱度过的，在这里发生了很多事情，我们做的系统就是监控这些犯人的，还都是重刑犯，有&lt;code&gt;狱警&lt;/code&gt;跟着，我也不用担心会被他们突然干掉。而且他们也不是我想象的那样恐怖，后来混熟了，狱警也不用跟着了。他们白天的工作就是做羽绒服，每层楼差不多一百多人，每个人的工作台上都有个牌子，上面写着犯的什么罪，判了多少年，跟他们聊天会让你更珍惜生命。看到几个年龄跟我相仿的，有二十年的，四十年的，无期的。我还问那个无期的你在这每天干活的动力是啥呢？他只是说&lt;code&gt;好好表现&lt;/code&gt;争取减刑，跟他们聊了一段时间后再反问我自己，我还有什么理由在困难面前屈服呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073401045-290354841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;印象最深的一次就是在监狱门口招待所二楼写代码的时候，刚实现了一个越界报警的功能，突然听到外面很吵，看到监狱上面好多直升机，外面的玉米地瞬间被武警夷为平地。原来是有人越狱了，我居然目睹了现场版的越狱，当时还在想，如果我们这个系统上线了，就不会发生这种事了。那几天吓的都不敢出门，还担心他突然出现把我给干掉。半个月后还是被抓回来了，我们这个项目上打通的关系人，因为这次事件基本上都换掉了，被迫停工。&lt;/p&gt;
&lt;p&gt;后来回去继续写代码，公司来了个新同事，也是某某大学的，经常叫我学长，还经常约我去学校看看，又是尴尬，对关系这么好的同事隐瞒我的经历，我每天都在内疚中度过。虽然现在在准备自考了，但是还需要几年才能毕业，我开始萌生了一个念头，我要离开这个让我百感交集的城市。因为公司所属研究所有名额，项目经理建议我考北航的研究生，条件是毕业后要在公司待够几年，答应了肯定就露馅了。当时北京雾霾又非常严重，&lt;strong&gt;严重到出门呼吸都困难&lt;/strong&gt;；再加上每天对同事隐瞒的内疚，这些条件加在一起，做了个决定，跟月姐和小吴同学坦白了我的隐瞒，月姐说她早就猜到了，只是不在意这些，当时我就感动的留下了眼泪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073409301-1156264490.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;坦白后第二天就辞职了，跟同事道别之后，回去收拾收拾准备跟这个城市道别，工作期间为了离公司更近，从巴沟村搬到了上地软件园附近的上地佳园，走之前跟师父师娘道了别，一日为师，终生为师，江湖再见。&lt;/p&gt;
&lt;h2 id=&quot;在路上&quot;&gt;在路上&lt;/h2&gt;
&lt;p&gt;坐上了从北京到杭州的火车，回想这三年的经历，真是历历在目。后来得知月姐去了一线互联网公司，小吴同学回家继承家产了。坐了一夜火车，天亮了，马上要到站了，看到眼前这个城市像是修建在森林里，心情也好了很多。拖着行李去租房子，安定下来之后开始学习准备找工作，我把简历认真改了一波，把三年经验改为两年，终于能以&lt;code&gt;真实面目&lt;/code&gt;去找工作了。要是学历也能用真实学历，这个心理大包袱应该就可以发下了，那种坦荡的感觉好向往。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073428543-1790417255.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一次面试路过黄龙时代广场的一栋大楼，整个用白色玻璃装饰的，看上去很气派，心里想要是能在这里工作就好了。一个月过去了，有一家外包公司一个月前有一次电话技术面试，中间有一次电话复试，电话复试的时候 HR 告诉我他们会查学历，我就跟 HR 坦白了我的真实学历就是高中。过了几天 HR 打电话让我提供高中毕业证明，也可以把高中老师电话给他通话确认下，我找了两天终于找到了高中班主任的电话，他们通话确认后就让我去现场面试。还说虽然是外包，但是那家公司要求也很高，到了现场发现面试地点就是那个白色大楼，很激动的进去了，这次面试像是被面试官&lt;code&gt;活剥&lt;/code&gt;了一样，他问的问题我也都给出了答案，感觉这一次面试学到的东西比过去一年学到的都多。结束后过了几天打电话说被录取了，就开始去那里上班了，过了几天我忍不住好奇问了 HR，为什么我会被录取，他回复了两个字，诚实。&lt;/p&gt;
&lt;p&gt;于是我就开始了正常的上下班生活，周末骑着自行车穿梭在山间、茶林。有一天下午在公司二楼的一个书店看到了一本书《背包十年》，看到小鹏描述的生活方式，心想那大概就是我向往的生活，一个念头挥之不去，我要辞职去旅行。&lt;/p&gt;
&lt;p&gt;过了一个月，就跟项目经理发了离职申请，理由就是我要去旅行，离职后开始背着包到处跑，回想一下在这家公司确实学到很多很多。用的技术和环境基本上都是很前沿的，印象最深刻的就是年会的时候这家公司 CEO 在舞台上唱了几首歌，然后在舞台上单膝跪地。公司全球各地的员工几万人都聚到了这个体育场，看到一些老员工老泪纵横，有人叫他马老师，也有人叫他马总。&lt;/p&gt;
&lt;p&gt;就这样跑了几个月，花光了所有的钱。然后又去上海工作了一年，攒到一点钱，又对&lt;code&gt;机器学习&lt;/code&gt;产生了兴趣。就萌生了一个念头，我要&lt;code&gt;辞职&lt;/code&gt;去一趟西藏，然后回来闭关修炼，好好学习。于是我就在浦东图书馆对面租了个很便宜的房子，木板隔断的，一层隔出了五六间。&lt;/p&gt;
&lt;p&gt;我买好了去昆明的车票，准备从云南骑车去拉萨，第二天天刚亮，就突然听到敲门声，然后隔断的木板就被砸开了，不知道哪里来这么多保安，拿起锤子就砸，砸完瞬间房间变得敞亮了很多，五六张男男女女的床一览无余。大家也不慌张，就各自坐在自己床上开始聊天，原来我隔壁住的是个摄影师，更巧的是他后天要开车去丽江，跟他聊起来就决定蹭他的车先去丽江，把去昆明的车票退了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073437059-479816545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过了两天我们就开车出发了，屋里的行李也不管了，往角落里一堆就让房东给注意下，后来跟房东打听到说上海在打击群租房，我猜是想让我们这些穷的租不起房子的人滚出上海。同行的还有另一个人，他有一些资源，想跟丽江那边合作开发新的旅游路线。我们就这样三个人一路玩到丽江，摄影师也在跟丽江一家很大的旅行社合作，我们都住到了老板的别墅里，每天去各种景点游玩，而且是专门推荐的。因为我们说是上海那边的旅行社，想跟这边合作，现在是来采点的，那些管理人员马上安排各种既有特色又有意思的路线，就这样免费玩了半个多月。&lt;/p&gt;
&lt;p&gt;中间还遇到一对华侨夫妇，在美国工作了几十年，现在退休了在环游世界，真是羡慕。他跟我同行，也是个&lt;code&gt;程序员&lt;/code&gt;，我问他在哪个公司啊，他说先后在摩根和花旗呆了几十年，还告诉了我他的退休金，妈呀！他的退休金每月都比我工资不知道高了多少倍！都是搞技术的，差距怎么这么大呐。跟摄影师也比较聊的来，摄影师想收我为学徒，说过两天要去雨崩和梅里雪山拍几组照片，预计二十天左右。我拒绝了，因为我打算收一辆二手自行车骑车去西藏，摄影师和另外一些伙伴听到后强烈的建议我不要这么做，一个人，而且毫无准备，很大概率会遇到危险。&lt;/p&gt;
&lt;p&gt;听到这么多有经验的人这么说，我也就打消了这个念头，就买了大巴车票去了，跟他们道别后就出发了，走之前有个人告诉我说他认识一个妹子现在正好也是一个人在拉萨，如果她还没离开的话你可以去找她，就把联系方式给我了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073447989-1764900453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有香格里拉才有到拉萨的车，就先去了香格里拉，由于这段时间在限速，坐了四天三夜终于到了拉萨，我下车后开始找客栈，走在拉萨的马路上稍微走快一点就感觉头疼。走到了那家客栈，遇到了那个她，就一起结伴去了&lt;code&gt;纳木错&lt;/code&gt;，她高原反应，我就在身边守着。过了几天互相道别，她回了江苏，我继续我的旅行，当我走到青海湖的时候，就决定结束这段旅程去找那个女孩。&lt;/p&gt;
&lt;p&gt;离开了青海湖到了上海收拾收拾行李就去了，本来打算在这里闭关修炼好好研究下机器学习的。。。。。。去了江苏没多久钱就花完了，就想能不能做点小生意，联系了新疆的朋友，跟他合作&lt;code&gt;卖红枣&lt;/code&gt;，他把货发到江苏这边，我骑着电瓶车满城跑着去各种商家推销，半个月过去，一点没卖出去。在马路边上一边吃着红枣，一边思考人生，后来想着那就去步行街摆摊试试吧，一周过去还是一点没有卖出去。印象中只有一只狗来光顾这小摊，看它马上要抬起后腿，发现情况不妙，一声吼就把它吓跑了。做生意不成，开始找工作，去了一家做婚纱摄影的影楼，呆了几个月后就跟她提了下，要不我们一起出去玩吧，她说好啊，于是我俩开始了一段说走就走的旅行。我们一起走过了呼伦贝尔大草原，满洲里，大理，香格里拉，稻城亚丁，还一起去了小鹏在丽江束河古镇开的背包十年客栈。。。。。。一年后我们就结婚了。&lt;/p&gt;
&lt;h2 id=&quot;安与惑&quot;&gt;安与惑&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;择一城终老&lt;/strong&gt;，选来选去选择了成都，一年后决定要一个孩子，这颗心彻底安定下来了，要为这个家努力奋斗了。&lt;/p&gt;
&lt;p&gt;后来我开始专心工作，每天上班下班过着安稳日子，一眨眼五年时间就过去了，慢慢开始变得迷茫起来，虽然做了一些架构师相关的工作，但一想到下一个十年的规划，就变得不知所措，不知该何去何从。&lt;/p&gt;
&lt;p&gt;突然就觉得应该转个行，像十年前那样从零开始选择一个更有价值有意思的工作，说是十年之痒也不夸张，甚至有时候会对自己现在做的事情感到腻烦，有时候从多纬度想事情的时候，就会愈发的坐不住了。现在 T 字形还没形成，π 又来了。现在遇到有些资历的人就抓住聊职业规划，大概是快疯了，何去何从，一直到现在也没有答案，继续寻找。。。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073518351-1827754562.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;最后感谢下 cxuan 的这次机会，发现写字的过程也是一个跟自己深度对话的过程，建议大家也多写写试试。&lt;/p&gt;
&lt;p&gt;另外，作为一个程序员，我的经历可以说是毫无参考价值可言，甚至要引以为戒，如果引起大家的反感，还请见谅。&lt;/p&gt;
&lt;p&gt;2020.11.6 写于下班公交车上&lt;/p&gt;
&lt;p&gt;程序员纪实录接受故事类的投稿，有偿投稿，欢迎说出你的故事，详情微信 becomecxuan&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201109073654029-1496724440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Nov 2020 23:36:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>缘起 一路回忆过来，发现我应该不能算是个正经程序员，这后来的一切都源于十年前的一个传单。 那时候在读高中二年级，那个中午刚走到学校大门外，阳光正好通过那个传单刺到了我的眼睛，传单的内容很长，是一个技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13946758.html</dc:identifier>
</item>
<item>
<title>.NetCore HttpClient发送请求的时候为什么自动带上了一个RequestId头部？ - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/why-httpclient-auto-add-header-request-id.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/why-httpclient-auto-add-header-request-id.html</guid>
<description>&lt;h2 id=&quot;奇怪的问题&quot;&gt;奇怪的问题&lt;/h2&gt;
&lt;p&gt;最近在公司有个系统需要调用第三方的一个webservice。本来调用一个下很简单的事情，使用HttpClient构造一个SOAP请求发送出去拿到XML解析就是了。&lt;br/&gt;可奇怪的是我们的请求在运行一段时间后就会被服务器504给拒绝掉了。导致系统无法使用，用户叫苦连天。&lt;br/&gt;古怪就古怪在这个问题不是每次都会出现，是隔三差五的查询，每次修改完代码发布上去以为好了，&lt;br/&gt;过了两天又不行了，简直让人奔溃。&lt;/p&gt;
&lt;h2 id=&quot;postman测试&quot;&gt;Postman测试&lt;/h2&gt;
&lt;p&gt;在反复调试代码无果的情况下，我怀疑是对方服务器的问题。于是拿出Postman往对方服务器发送请求测试。&lt;br/&gt;postman测试一测就测出问题了，不管发送什么，服务器全部给出了504的响应。因为在浏览器里访问webservice的首页是可以的，但是为什么在postman上面就不行了呢？&lt;br/&gt;于是我开始反复检查postman的请求有何不同，到这里感觉离发现问题不远了。在反复查看下我开始怀疑是postman的一个头部的问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Postman-Token: 4d407574-636b-9343-8216-7f2845cbeef1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;postman每次发送请求的时候都会带上一个叫做postman-token的头部。于是我把这个头部给禁用了再试一次，果断成功了。&lt;br/&gt;在反复测试下终于明白了，对方服务器应该有防护，只要http请求里带有自定义的头部就会直接给出504的响应，直接拒绝请求。&lt;br/&gt;至此服务器拒绝请求的原因终于明了了。&lt;/p&gt;
&lt;h2 id=&quot;fiddler监控&quot;&gt;fiddler监控&lt;/h2&gt;
&lt;p&gt;但是，我们的代码发送请求的时候并没有带上任何自定义的头部啊。莫非.NET Core会在发送请求的时候带上什么头部吗？&lt;br/&gt;于是在服务器上安装fiddler，把请求通过fiddler代理转发出去，然后监控http请求的头部。当系统再次出现问题的时候&lt;br/&gt;果断上去查看fiddler。一看果然发现了问题，所有被拒绝的请求都带上了一个叫“Request-Id”的头部。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/09/BTgP1A.png&quot; alt=&quot;BTgP1A.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;当时我是震惊的，.NetCore居然会自说自话给我加上一个头部？&lt;br/&gt;如果不是亲身发现，打死我也不会相信的。或许你看到这里也还是不相信，心里在想一定是我搞错了吧。&lt;/p&gt;
&lt;h2 id=&quot;request-id头部到底哪里来的？&quot;&gt;Request-Id头部到底哪里来的？&lt;/h2&gt;
&lt;p&gt;这个问题真是百思不得其解，于是开始请教google。很快在.net core runtime的github上的issues发现一个同样的问题：&lt;br/&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/issues/35337&quot;&gt;HttpClient automatically adds Request-Id HTTP header&lt;/a&gt;&lt;br/&gt;提问的人说使用HttpClient发送请求的时候莫名其妙加上了一个Request-Id，跟我情况一毛一样。&lt;br/&gt;于是乎有人开始讨论。有人说HttpClient不可能自己加上Request-Id这个头部的，下面的老哥直接打脸，说：事实上会的，还给出了源码的位置。笑哭！后来还有开发者回复这个功能是内置的，是为了分布式追踪。&lt;br/&gt;既然源码都给出来了，直接从上面老哥给出的源码位置开始追源码。下面大概说一下源码：&lt;br/&gt;HttpClient默认构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public HttpClient()
            : this(new HttpClientHandler())
        {
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续看里面的HttpClientHandler：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   protected internal override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request,
            CancellationToken cancellationToken)
        {
            return DiagnosticsHandler.IsEnabled() ?
                _diagnosticsHandler.SendAsync(request, cancellationToken) :
                _socketsHttpHandler.SendAsync(request, cancellationToken);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HttpClientHandler发送请求的时候会判断是否使用diagnosticsHandler来发送请求。继续看diagnosticsHandler的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private static void InjectHeaders(Activity currentActivity, HttpRequestMessage request)
        {
            if (currentActivity.IdFormat == ActivityIdFormat.W3C)
            {
                if (!request.Headers.Contains(DiagnosticsHandlerLoggingStrings.TraceParentHeaderName))
                {
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.TraceParentHeaderName, currentActivity.Id);
                    if (currentActivity.TraceStateString != null)
                    {
                        request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.TraceStateHeaderName, currentActivity.TraceStateString);
                    }
                }
            }
            else
            {
                if (!request.Headers.Contains(DiagnosticsHandlerLoggingStrings.RequestIdHeaderName))
                {
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.RequestIdHeaderName, currentActivity.Id);
                }
            }

            // we expect baggage to be empty or contain a few items
            using (IEnumerator&amp;lt;KeyValuePair&amp;lt;string, string?&amp;gt;&amp;gt; e = currentActivity.Baggage.GetEnumerator())
            {
                if (e.MoveNext())
                {
                    var baggage = new List&amp;lt;string&amp;gt;();
                    do
                    {
                        KeyValuePair&amp;lt;string, string?&amp;gt; item = e.Current;
                        baggage.Add(new NameValueHeaderValue(WebUtility.UrlEncode(item.Key), WebUtility.UrlEncode(item.Value)).ToString());
                    }
                    while (e.MoveNext());
                    request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.CorrelationContextHeaderName, baggage);
                }
            }
        }

        private static readonly DiagnosticListener s_diagnosticListener =
            new DiagnosticListener(DiagnosticsHandlerLoggingStrings.DiagnosticListenerName);

        #endregion
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于找到关键的位置了有个叫InjectHeaders的方法里面有这么一句 request.Headers.TryAddWithoutValidation(DiagnosticsHandlerLoggingStrings.RequestIdHeaderName, currentActivity.Id);其中DiagnosticsHandlerLoggingStrings.RequestIdHeaderName是个常量，它的值就是&quot;Request-Id&quot;。&lt;br/&gt;到这里是谁带上的Request-Id头部的问题终于石锤了。&lt;/p&gt;
&lt;h2 id=&quot;复现问题&quot;&gt;复现问题&lt;/h2&gt;
&lt;p&gt;原因找到了，于是开始测试解决办法。解决问题的第一步是先复现问题。正常情况下你使用HttpClient发送请求时不会带上这个头部的。要让本地发送的请求也带上这个头部也不是件容易的事。经过查看源代码发现其实是跟.net core的Diagnostics机制有关。由于源码逻辑比较复杂，直接给出会带上头部的代码：&lt;br/&gt;首先定义一个Observer：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class MyObserver&amp;lt;T&amp;gt; : IObserver&amp;lt;T&amp;gt;
    {
        private Action&amp;lt;T&amp;gt; _next;
        public MyObserver(Action&amp;lt;T&amp;gt; next)
        {
            _next = next;
        }

        public void OnCompleted()
        {
        }

        public void OnError(Exception error)
        {
        }

        public void OnNext(T value) =&amp;gt; _next(value);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅HttpHandlerDiagnosticListener：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    DiagnosticListener.AllListeners.Subscribe(new MyObserver&amp;lt;DiagnosticListener&amp;gt;(listener =&amp;gt;
            {
                //判断发布者的名字
                if (listener.Name == &quot;HttpHandlerDiagnosticListener&quot;)
                {
                    //获取订阅信息
                    listener.Subscribe(new MyObserver&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;(listenerData =&amp;gt;
                    {
                        System.Console.WriteLine($&quot;监听名称:{listenerData.Key}&quot;);
                        dynamic data = listenerData.Value;
                    
                    }));

                }
            }));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们订阅HttpHandlerDiagnosticListener的时候HttpClient发送的请求就会带上这个头部。这个设计的真的比较变态，因为DiagnosticListener.AllListeners是静态的，所以它的影响是全局的。也就是说我这里订阅了一个监听，会导致整个程序中所有的HttpClient都开始带上这个头部。&lt;br/&gt;这也解释了为何我们的程序运行一段时间之后才带上Request-Id的头部。因为我们程序中其它模块，或者引用的三方库的在达到某种状态的时候会开始订阅HttpHandlerDiagnosticListener这个监听，导致我请求webservice的代码也带上了这个头部。&lt;/p&gt;
&lt;h2 id=&quot;解决问题&quot;&gt;解决问题&lt;/h2&gt;
&lt;p&gt;问题的原因也找到了，本地也复现了，现在我们要开始真正的解决问题了。经过google跟查看源码，要让HttpClient不发送这个Request-Id头部有几种办法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;方法1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设置System.Net.Http.EnableActivityPropagation开关为false&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string switchName = &quot;System.Net.Http.EnableActivityPropagation&quot;;
AppContext.SetSwitch(switchName, false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法2&lt;br/&gt;配置环境变量DOTNET_SYSTEM_NET_HTTP_ENABLEACTIVITYPROPAGATIO=false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法3&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    public class DisableActivityHandler : DelegatingHandler
    {
        public DisableActivityHandler(HttpMessageHandler innerHandler) : base(innerHandler)
        {

        }

        protected override async Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            Activity.Current = null;

            return await base.SendAsync(request, cancellationToken);
        }
    }

    var httpClient = new HttpClient(new DisableActivityHandler(new HttpClientHandler()));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法定义一个DisableActivityHandler再构造HttpClient，在每次发送请求的时候都把Activity.Current置空。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;最近被这个Request-Id折腾了很久。这里忍不住要吐槽下，这个内置的功能真的好吗，强力插入自定义头部，有考虑过防火墙的感受吗？或者是不是可以让开发者主动选择是否计入Diagnostic统计，而不是某一处开始订阅就全部请求都添加头部，毕竟我们无法控制第三方的库是否有什么骚操作。如果要关闭这个Diagnostic是不是可以在HttpClient实例上直接给出一个明确的开关让开发者关闭它，而不是需要配置什么环境变量。&lt;/p&gt;
&lt;p&gt;ps：如果是使用HttpWebRequest类发送请求同样有这个问题，因为HttpWebRequest发送请求的时候就是用的HttpClient。&lt;/p&gt;
&lt;h2 id=&quot;关注我的公众号一起玩转技术&quot;&gt;关注我的公众号一起玩转技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/29/NfQjds.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Nov 2020 17:19:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>奇怪的问题 最近在公司有个系统需要调用第三方的一个webservice。本来调用一个下很简单的事情，使用HttpClient构造一个SOAP请求发送出去拿到XML解析就是了。 可奇怪的是我们的请求在运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/why-httpclient-auto-add-header-request-id.html</dc:identifier>
</item>
<item>
<title>23张图，带你入门推荐系统 - IT人的职场进阶</title>
<link>http://www.cnblogs.com/luojunwu/p/13946606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luojunwu/p/13946606.html</guid>
<description>&lt;p&gt;做广告业务1年多时间了，但是平时的工作主要和 广告工程 有关，核心的广告算法由 AI 部门支持，对我们而言可以说是「黑盒般」的存在，只需要对训练好的模型进行调用即可。&lt;/p&gt;
&lt;p&gt;近期，我打算系统性地学习下广告中的搜索和推荐算法，当然更多是从工程的视角去弄清楚：算法的基本原理、以及面对线上海量数据时算法是如何解决性能问题的？整个过程，我会将有价值的技术点输出成系列文章。&lt;/p&gt;
&lt;p&gt;这篇文章属于推荐系统的入门篇，本文暂不考虑线上环境的海量数据，目的是先了解清楚推荐系统的基本构成，我会通过图解推荐算法以及程序demo的形式展开，内容包括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/078a9b34-f993-4b49-a83f-f4892320228e.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;01-走进推荐系统的世界&quot;&gt;&lt;strong&gt;01 走进推荐系统的世界&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;“啤酒与尿布” 的故事相信很多人都听过，年轻爸爸去超市购买尿布时，经常会买点啤酒犒劳自己。因此，沃尔玛将这两种商品进行了捆绑销售，最终获得了更好的销量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/dd9258bc-5f2e-4009-8cf9-c8481e3b2ec2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个故事背后的理论依据就是 “推荐算法”， 因为尿布和啤酒经常出现在同一个购物车中，那么向购买尿布的年轻爸爸推荐啤酒确实有一定道理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、推荐系统到底解决的是什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;推荐系统从20世纪90年代就被提出来了，但是真正进入大众视野以及在各大互联网公司中流行起来，还是最近几年的事情。&lt;/p&gt;
&lt;p&gt;随着移动互联网的发展，越来越多的信息开始在互联网上传播，产生了严重的信息过载。因此，如何从众多信息中找到用户感兴趣的信息，这个便是推荐系统的价值。精准推荐解决了用户痛点，提升了用户体验，最终便能留住用户。&lt;/p&gt;
&lt;p&gt;推荐系统本质上就是一个信息过滤系统，通常分为：召回、排序、重排序这3个环节，每个环节逐层过滤，最终从海量的物料库中筛选出几十个用户可能感兴趣的物品推荐给用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a89fdcce-db65-4190-bd07-9154cc6ee8b3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、推荐系统的应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哪里有海量信息，哪里就有推荐系统，我们每天最常用的APP都涉及到推荐功能：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;资讯类：今日头条、腾讯新闻等&lt;/p&gt;
&lt;p&gt;电商类：淘宝、京东、拼多多、亚马逊等&lt;/p&gt;
&lt;p&gt;娱乐类：抖音、快手、爱奇艺等&lt;/p&gt;
&lt;p&gt;生活服务类：美团、大众点评、携程等&lt;/p&gt;
&lt;p&gt;社交类：微信、陌陌、脉脉等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/d566c50d-5b1a-4f84-8b2d-1968d1607673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐系统的应用场景通常分为以下两类：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于用户维度的推荐：根据用户的历史行为和兴趣进行推荐，比如淘宝首页的猜你喜欢、抖音的首页推荐等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;基于物品维度的推荐：根据用户当前浏览的标的物进行推荐，比如打开京东APP的商品详情页，会推荐和主商品相关的商品给你。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、搜索、推荐、广告三者的异同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搜索和推荐是AI算法最常见的两个应用场景，在技术上有相通的地方。这里提到广告，主要考虑很多没做过广告业务的同学不清楚为什么广告和搜索、推荐会有关系，所以做下解释。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;搜索&lt;/strong&gt;：有明确的搜索意图，搜索出来的结果和用户的搜索词相关。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;推荐&lt;/strong&gt;：不具有目的性，依赖用户的历史行为和画像数据进行个性化推荐。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;广告&lt;/strong&gt;：借助搜索和推荐技术实现广告的精准投放，可以将广告理解成搜索推荐的一种应用场景，技术方案更复杂，涉及到智能预算控制、广告竞价等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;02-推荐系统的整体架构&quot;&gt;&lt;strong&gt;02 推荐系统的整体架构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/81b662e3-8870-4eae-8208-eb4f364aec90.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是推荐系统的整体架构图，自下而上分成了多层，各层的主要作用如下：&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据源&lt;/strong&gt;：推荐算法所依赖的各种数据源，包括物品数据、用户数据、行为日志、其他可利用的业务数据、甚至公司外部的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;计算平台&lt;/strong&gt;：负责对底层的各种异构数据进行清洗、加工，离线计算和实时计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据存储层&lt;/strong&gt;：存储计算平台处理后的数据，根据需要可落地到不同的存储系统中，比如Redis中可以存储用户特征和用户画像数据，ES中可以用来索引物品数据，Faiss中可以存储用户或者物品的embedding向量等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;召回层&lt;/strong&gt;：包括各种推荐策略或者算法，比如经典的协同过滤，基于内容的召回，基于向量的召回，用于托底的热门推荐等。为了应对线上高并发的流量，召回结果通常会预计算好，建立好倒排索引后存入缓存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;融合过滤层&lt;/strong&gt;：触发多路召回，由于召回层的每个召回源都会返回一个候选集，因此这一层需要进行融合和过滤。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;排序层&lt;/strong&gt;：利用机器学习或者深度学习模型，以及更丰富的特征进行重排序，筛选出更小、更精准的推荐集合返回给上层业务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从数据存储层到召回层、再到融合过滤层和排序层，候选集逐层减少，但是精准性要求越来越高，因此也带来了计算复杂度的逐层增加，这个便是推荐系统的最大挑战。&lt;/p&gt;
&lt;p&gt;其实对于推荐引擎来说，最核心的部分主要是两块：特征和算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a8c8b562-a5e9-4420-9c3b-76eab112ce6e.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特征计算由于数据量大，通常采用大数据的离线和实时处理技术，像Spark、Flink等，然后将计算结果保存在Redis或者其他存储系统中（比如HBase、MongoDB或者ES），供召回和排序模块使用。&lt;/p&gt;
&lt;p&gt;召回算法的作用是：从海量数据中快速获取一批候选数据，要求是快和尽可能的准。这一层通常有丰富的策略和算法，用来确保多样性，为了更好的推荐效果，某些算法也会做成近实时的。&lt;/p&gt;
&lt;p&gt;排序算法的作用是：对多路召回的候选集进行精细化排序。它会利用物品、用户以及它们之间的交叉特征，然后通过复杂的机器学习或者深度学习模型进行打分排序，这一层的特点是计算复杂但是结果更精准。&lt;/p&gt;
&lt;h2 id=&quot;03-图解经典的协同过滤算法&quot;&gt;&lt;strong&gt;03 图解经典的协同过滤算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;了解了推荐系统的整体架构和技术方案后，下面带大家深入一下算法细节。这里选择图解的是推荐系统中的明星算法：协同过滤（Collaborative Filtering，CF）。&lt;/p&gt;
&lt;p&gt;对于工程同学来说，可能觉得 AI 算法晦涩难懂，门槛太高，确实很多深度学习算法的确是这样，但是协同过滤却是一个简单同时效果很好的算法，只要你有初中数学的基础就能看懂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、协同过滤是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;协同过滤算法的核心就是「找相似」，它基于用户的历史行为（浏览、收藏、评论等），去发现用户对物品的喜好，并对喜好进行度量和打分，最终筛选出推荐集合。它又包括两个分支：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基于用户的协同过滤&lt;/strong&gt;： User-CF，核心是找相似的人。比如下图中，用户 A 和用户 C 都购买过物品 a 和物品 b，那么可以认为 A 和 C 是相似的，因为他们共同喜欢的物品多。这样，就可以将用户 A 购买过的物品 d 推荐给用户 C 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/f0fbb4cc-50ea-4c33-91a6-5a945c3363c8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基于物品的协同过滤&lt;/strong&gt;：Item-CF，核心是找相似的物品。比如下图中，物品 a 和物品 b 同时被用户 A，B，C 购买了，那么物品 a 和 物品 b 被认为是相似的，因为它们的共现次数很高。这样，如果用户 D 购买了物品 a，则可以将和物品 a 最相似的物品 b 推荐给用户 D。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/538ee41b-e7d9-49c0-a8f7-6f5658cc24c1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、如何找相似？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面讲到，协同过滤的核心就是找相似，User-CF是找用户之间的相似，Item-CF是找物品之间的相似，那到底如何衡量两个用户或者物品之间的相似性呢？&lt;/p&gt;
&lt;p&gt;我们都知道，对于坐标中的两个点，如果它们之间的夹角越小，这两个点越相似，这就是初中学过的余弦距离，它的计算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/2eeec427-7c16-4c9b-8480-227382b85ca8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，A坐标是（0，3，1），B坐标是（4，3，0），那么这两个点的余弦距离是0.569，余弦距离越接近1，表示它们越相似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/3f300341-2898-439b-9ec2-5e2976a6cd23.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了余弦距离，衡量相似性的方法还有很多种，比如：欧式距离、皮尔逊相关系数、Jaccard 相似系数等等，这里不做展开，只是计算公式上的差异而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Item-CF的算法流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;清楚了相似性的定义后，下面以Item-CF为例，详细说下这个算法到底是如何选出推荐物品的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：整理物品的共现矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有 A、B、C、D、E 5个用户，其中用户 A 喜欢物品 a、b、c，用户 B 喜欢物品 a、b等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/fd0da0cb-66ee-412b-97f5-8ea99690a179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓共现，即：两个物品被同一个用户喜欢了。比如物品 a 和 b，由于他们同时被用户 A、B、C 喜欢，所以 a 和 b 的共现次数是3，采用这种统计方法就可以快速构建出共现矩阵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：计算物品的相似度矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 Item-CF 算法来说，一般不采用前面提到的余弦距离来衡量物品的相似度，而是采用下面的公式 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/8b388b5a-21a9-49a5-85b4-ff5051b2c76c.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，N(u) 表示喜欢物品 u 的用户数，N(v) 表示喜欢物品 v 的用户数，两者的交集表示同时喜欢物品 u 和物品 v 的用户数。很显然，如果两个物品同时被很多人喜欢，那么这两个物品越相似。&lt;/p&gt;
&lt;p&gt;基于第1步计算出来的共现矩阵以及每个物品的喜欢人数，便可以构造出物品的相似度矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7519d3ed-74bf-4dfa-9339-6b2d846095e9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：推荐物品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一步，便可以基于相似度矩阵推荐物品了，公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/9ce0fdd6-a46c-414f-a406-a5632c247404.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，P uj 表示用户 u 对物品 j 的感兴趣程度，值越大，越值得被推荐。N(u) 表示用户 u 感兴趣的物品集合，S(j,N) 表示和物品 j 最相似的前 N 个物品，W ij 表示物品 i 和物品 j 的相似度，R ui 表示用户 u 对物品 i 的兴趣度。&lt;/p&gt;
&lt;p&gt;上面的公式有点抽象，直接看例子更容易理解，假设我要给用户 E 推荐物品，前面我们已经知道用户 E 喜欢物品 b 和物品 c，喜欢程度假设分别为 0.6 和 0.4。那么，利用上面的公式计算出来的推荐结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/75e1cb68-295f-46c4-b798-6cba6a8be12b.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为物品 b 和物品 c 已经被用户 E 喜欢过了，所以不再重复推荐。最终对比用户 E 对物品 a 和物品 d 的 感兴 趣程度，因为 0.682 &amp;gt; 0.3，因此选择推荐物品 a。&lt;/p&gt;
&lt;h2 id=&quot;04-从0到1搭建一个推荐系统&quot;&gt;&lt;strong&gt;04 从0到1搭建一个推荐系统&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有了上面的理论基础后，我们就可以用 Python 快速实现出一个推荐系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、选择数据集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里采用的是推荐领域非常经典的 MovieLens 数据集，它是一个关于电影评分的数据集，官网上提供了多个不同大小的版本，下面以 ml-1m 数据集（大约100万条用户评分记录）为例。&lt;/p&gt;
&lt;p&gt;下载解压后，文件夹中包含：ratings.dat、movies.dat、users.dat 3个文件，共6040个用户，3900部电影，1000209条评分记录。各个文件的格式都是一样的，每行表示一条记录，字段之间采用 :: 进行分割。&lt;/p&gt;
&lt;p&gt;以ratings.dat为例，每一行包括4个属性： UserID, MovieID, Rating, Timestamp。 通过脚本可以统计出不同评分的人数分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/3b0406b6-9e71-4fcd-98ca-ba30918900ce.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、读取原始数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序主要使用数据集中的 ratings.dat 这个文件，通过解析该文件，抽取出 user_id、movie_id、rating 3个字段，最终构造出算法依赖的数据，并保存在变量 dataset 中，它的格式为：dict[user_id][movie_id] = rate&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/4c436d91-ab14-4ffb-9265-2695d926999e.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、 构造物品的相似度矩阵&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于第 2 步的 dataset，可以进一步统计出每部电影的评分次数以及电影的共生矩阵，然后再生成相似度矩阵。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/c70f528a-f03e-4b33-b187-1bc61de07ab2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、 基于相似度矩阵推荐物品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，可以基于相似度矩阵进行推荐了，输入一个用户id，先针对该用户评分过的电影，依次选出 top 10 最相似的电影，然后加权求和后计算出每个候选电影的最终评分，最后再选择得分前 5 的电影进行推荐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/c03962ff-19f6-4d61-9d9b-74fc4cb863d6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、 调用推荐系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面选择 UserId=1 这个用户，看下程序的执行结果。由于推荐程序输出的是 movieId 列表，为了更直观的了解推荐结果，这里转换成电影的标题进行输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/08080ce8-451b-46a4-b128-5775e7556584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终推荐的前5个电影为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/60ce5200-3dce-4fa2-a592-503424d705db.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;05-线上推荐系统的挑战&quot;&gt;&lt;strong&gt;05 线上推荐系统的挑战&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的介绍，大家对推荐系统的基本构成应该有了一个初步认识，但是真正运用到线上真实环境时，还会遇到很多算法和工程上的挑战，绝对不是几十行 Python 代码可以搞定的。&lt;/p&gt;
&lt;p&gt;1、上面的示例使用了标准化的数据集，而线上环境的数据是非标准化的，因此涉及到海量数据的收集、清洗和加工，最终构造出模型可使用的数据集。&lt;/p&gt;
&lt;p&gt;2、复杂且繁琐的特征工程，都说算法模型的上限由数据和特征决定。对于线上环境，需要从业务角度选择出可用的特征，然后对数据进行清洗、标准化、归一化、离散化，并通过实验效果进一步验证特征的有效性。&lt;/p&gt;
&lt;p&gt;3、算法复杂度如何降低？比如上面介绍的Item-CF算法，时间和空间复杂度都是O(N×N)，而线上环境的数据都是千万甚至上亿级别的，如果不做算法优化，可能几天都跑不出数据，或者内存中根本放不下如此大的矩阵数据。&lt;/p&gt;
&lt;p&gt;4、实时性如何满足？因为用户的兴趣随着他们最新的行为在实时变化的，如果模型只是基于历史数据进行推荐，可能结果不够精准。因此，如何满足实时性要求，以及对于新加入的物品或者用户该如何推荐，都是要解决的问题。&lt;/p&gt;
&lt;p&gt;5、算法效果和性能的权衡。从算法角度追求多样性和准确性，从工程角度追求性能，这两者之间必须找到一个平衡点。&lt;/p&gt;
&lt;p&gt;6、推荐系统的稳定性和效果追踪。需要有一套完善的数据监控和应用监控体系，同时有 ABTest 平台进行灰度实验，进行效果对比。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这篇文章是推荐系统的入门篇，目的是让大家对推荐系统先有一个整体的认识，后续我会再连载出一些文章，详细地介绍面对具体业务和线上海量数据时，推荐系统应该如何设计？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果需要文章中Item CF的Python源代码和数据集，可以从百度网盘下载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/18-RihJQhnYDxpevEVlP9MQ&quot;&gt;https://pan.baidu.com/s/18-RihJQhnYDxpevEVlP9MQ&lt;/a&gt; ，提取码: cax7&lt;/p&gt;
&lt;p&gt;作者简介：985硕士，前亚马逊工程师，现58转转技术总监&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎扫描下方的二维码，关注我的个人公众号：IT人的职场进阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201107215432925.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Nov 2020 16:18:00 +0000</pubDate>
<dc:creator>IT人的职场进阶</dc:creator>
<og:description>做广告业务1年多时间了，但是平时的工作主要和 广告工程 有关，核心的广告算法由 AI 部门支持，对我们而言可以说是「黑盒般」的存在，只需要对训练好的模型进行调用即可。 近期，我打算系统性地学习下广告中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luojunwu/p/13946606.html</dc:identifier>
</item>
<item>
<title>深度优先搜索和广度优先搜索 - 喜欢兰花山丘</title>
<link>http://www.cnblogs.com/life2refuel/p/13936009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/life2refuel/p/13936009.html</guid>
<description>&lt;p&gt;　　当我们在学习和临摹垃圾回收(Garbage Collection, 缩写为 GC)相关算法和源码时候, 内在细节离不开&lt;/p&gt;
&lt;p&gt;这两大类搜索算法支撑. 这就是构建的背景❉, 文章定位是科普扫盲❤.&lt;/p&gt;

&lt;p&gt;　　&lt;a title=&quot;知乎 - 结点 or 节点 ?&quot; href=&quot;https://www.zhihu.com/question/21564534&quot; target=&quot;_blank&quot;&gt;[0] 知乎 - 节点 or 结点 ?&lt;/a&gt; [走进科学]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;维基百科-广度优先搜索&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&quot; target=&quot;_blank&quot;&gt;[1] 维基百科 - 广度优先搜索&lt;/a&gt; [概念参照]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;维基百科-深度优先搜索&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&quot; target=&quot;_blank&quot;&gt;[2] 维基百科 - 深度优先搜索&lt;/a&gt; [概念参照]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;维基百科-树的遍历&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86&quot; target=&quot;_blank&quot;&gt;[3] 维基百科 - 树的遍历&lt;/a&gt; [概念参照]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;CSDN-二叉树的深度优先遍历与广度优先遍历&quot; href=&quot;https://blog.csdn.net/fuzhongmin05/article/details/106883153&quot; target=&quot;_blank&quot;&gt;[4] CSDN - 二叉树的深度优先遍历与广度优先遍历&lt;/a&gt; [盗图]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;博客园 - 数据结构之图的基本概念&quot; href=&quot;https://www.cnblogs.com/xiaobingqianrui/p/8902111.html&quot; target=&quot;_blank&quot;&gt;[5] 博客园 - 数据结构之图的基本概念&lt;/a&gt; [递归抄袭]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;博客园-图的遍历之 深度优先搜索和广度优先搜索&quot; href=&quot;https://www.cnblogs.com/skywang12345/p/3711483.html#anchor11&quot; target=&quot;_blank&quot;&gt;[6] 博客园 - 图的遍历之 深度优先搜索和广度优先搜索&lt;/a&gt; [深度抄袭]&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;github-深度搜索和广度搜索&quot; href=&quot;https://github.com/wangzhione/temp/tree/master/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2&quot; target=&quot;_blank&quot;&gt;[7] github - 深度搜索和广度搜索&lt;/a&gt; [演示素材]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt; &lt;a title=&quot;1. 概念介绍&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab1&quot;&gt;1. 概念介绍&lt;/a&gt;&lt;br/&gt; &lt;a title=&quot;2. 树的例子&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2&quot;&gt;2. 树的例子&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;2.1 前序遍历&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2_1&quot;&gt;2.1 前序遍历&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;2.2 中序遍历&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2_2&quot;&gt;2.2 中序遍历&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;2.3 后序遍历&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2_3&quot;&gt;2.3 后序遍历&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;2.4 层次遍历&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2_4&quot;&gt;2.4 层次遍历&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;2.5 搜索算法源码&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab2_5&quot;&gt;2.5 搜索算法源码&lt;/a&gt;&lt;br/&gt; &lt;a title=&quot;3. 图的例子&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3&quot;&gt;3. 图的例子&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;3.0 图的基本概念&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_0&quot; target=&quot;_blank&quot;&gt;3.0 图的基本概念&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.0.1 图的定义&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_0_1&quot;&gt;3.0.1 图的定义&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.0.2 图的基本概念&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_0_2&quot;&gt;3.0.2 图的基本概念&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.0.3 图最基础的两种存储结构&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_0_3&quot;&gt;3.0.3 图最基础的两类存储结构&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.0.3.1 邻接矩阵表示法&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab_3_0_3_1&quot;&gt;3.0.3.1 邻接矩阵表示法&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.0.3.2 邻接表表示法&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab_3_0_3_2&quot;&gt;3.0.3.2 邻接表表示法&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;3.1 深度优先搜索图文介绍&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_1&quot;&gt;3.1 深度优先搜索图文介绍&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.1.1 深度优先搜索介绍&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_1_1&quot;&gt;3.1.1 深度优先搜索介绍&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.1.2 深度优先搜索图解&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_1_2&quot;&gt;3.1.2 深度优先搜索图解&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.1.2.1 无向图的深度优先搜索&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_1_2_1&quot;&gt;3.1.2.1 无向图的深度优先搜索&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.1.2.2 有向图的深度优先搜索&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_1_2_2&quot;&gt;3.1.2.2 有向图的深度优先搜索&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;3.2 广度优先搜索图文介绍&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_2&quot;&gt;3.2 广度优先搜索图文介绍&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.2 广度优先搜索图文介绍&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_2_1&quot;&gt;3.2.1 广度优先搜索介绍&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.2.2 广度优先搜索图解&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_2_2&quot;&gt;3.2.2 广度优先搜索图解&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.2.2.1 无向图的广度优先搜索&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_2_2_1&quot;&gt;3.2.2.1 无向图的广度优先搜索&lt;/a&gt;&lt;br/&gt;　　　　　　&lt;a title=&quot;3.2.2.2 有向图的广度优先搜索&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_2_2_2&quot;&gt;3.2.2.2 有向图的广度优先搜索&lt;/a&gt;&lt;br/&gt;　　&lt;a title=&quot;3.3 搜索算法源码&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_3&quot;&gt;3.3 搜索算法源码&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.3.1 邻接矩阵图表示的无向图 (Matrix Undirected Graph)&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_3_1&quot;&gt;3.3.1 邻接矩阵图表示的无向图 (Matrix Undirected Graph)&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.3.2 邻接矩阵图表示的有向图 (Matrix Directed Graph)&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_3_2&quot;&gt;3.3.2 邻接矩阵图表示的有向图 (Matrix Directed Graph)&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.3.3 邻接链表图表示的无向图 (List Undirected Graph)&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_3_3&quot;&gt;3.3.3 邻接链表图表示的无向图 (List Undirected Graph)&lt;/a&gt;&lt;br/&gt;　　　　&lt;a title=&quot;3.3.4 邻接链表图表示的有向图 (List Directed Graph)&quot; href=&quot;https://www.cnblogs.com/life2refuel/p/13936009.html#tab3_3_4&quot;&gt;3.3.4 邻接链表图表示的有向图 (List Directed Graph)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　关于遍历算法种类有很多很多, 这里选了最通用, 深度优先遍历和广度优先遍历两类搜索算法进行浅显&lt;/p&gt;
&lt;p&gt;讲解(作者能力有限). 基础有时候很有趣, 真的! ok, 那我们 go on. &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;　　&lt;strong&gt;深度优先搜索算法(&lt;/strong&gt;&lt;span lang=&quot;en&quot;&gt;Depth-First-Search, 缩写为 &lt;span lang=&quot;en&quot;&gt;DFS), 是一种用于遍历或搜索树或图的算法. 这个算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;会尽可能深的搜索树的分支. 当结点 v 的所在边都己被探寻过, 搜索将回溯到发现结点 v 的那条边的起始结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;点. 这一过程一直进行到已发现从源结点可达的所有结点为止. 如果还存在未被发现的结点, 则选择其中一&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;作为源结点并重复以上过程, 整个进程反复进行直到所有结点都被访问为止.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;广度优先搜索算法(&lt;/strong&gt;&lt;span lang=&quot;en&quot;&gt;Breadth-First Search, 缩写为 BFS), 又译作&lt;strong&gt;宽度优先搜索, &lt;/strong&gt;或&lt;strong&gt;横向优先搜索, &lt;/strong&gt;&lt;span lang=&quot;en&quot;&gt;是一种&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;图&lt;span lang=&quot;en&quot;&gt;形搜索算法. 简单的说, BFS 是从根结点开始, 沿着树的宽度遍历树的结点. 如果所有结点均被访问, &lt;span lang=&quot;en&quot;&gt;则算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;中&lt;span lang=&quot;en&quot;&gt;止. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在计算机科学里, &lt;strong&gt;树的遍历(&lt;/strong&gt;也称为&lt;strong&gt;树的搜索)&lt;/strong&gt;是图的遍历的一种, 指的是按照某种规则, 不重复地访问某&lt;/p&gt;
&lt;p&gt;种树的所有结点的过程. 具体的访问操作可能是检查结点的值, 更新结点的值等. 不同的遍历方式, 其访问结&lt;/p&gt;
&lt;p&gt;点的顺序是不一样的. 以下我们将二叉树的广度优先和深度优先遍历算法归类，但它们也适用于其它树形结&lt;/p&gt;
&lt;p&gt;构.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先遍历(搜索)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　前序遍历(Pre-Order Traversal)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201106161057376-1486979954.png&quot; alt=&quot;树-前序遍历-演示&quot; width=&quot;489&quot; title=&quot;树-前序遍历-演示&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索 - 前序遍历: F -&amp;gt; B -&amp;gt; A -&amp;gt; D -&amp;gt; C -&amp;gt; E -&amp;gt; G -&amp;gt; I -&amp;gt;H&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　中序遍历(In-Order Traversal)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201106164227520-633478625.png&quot; alt=&quot;树-中序遍历-演示&quot; width=&quot;489&quot; title=&quot;树-中序遍历-演示&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索 - 中序遍历: A -&amp;gt; B -&amp;gt; C -&amp;gt; D -&amp;gt; E -&amp;gt; F -&amp;gt; G -&amp;gt; H -&amp;gt; I&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　后序遍历(Post-Order Traversal)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201106164453716-562253113.png&quot; alt=&quot;树-后序遍历-演示&quot; width=&quot;489&quot; title=&quot;树-后序遍历-演示&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索 - 后序遍历: A -&amp;gt; C -&amp;gt; E -&amp;gt; D -&amp;gt; B -&amp;gt; H -&amp;gt; I -&amp;gt; G -&amp;gt; F&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广度优先遍历&lt;/strong&gt;(搜索)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　层次遍历(Level Order Traversal)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201106164759402-1412405633.png&quot; alt=&quot;树-层次遍历-演示&quot; width=&quot;489&quot; title=&quot;树-层次遍历-演示&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广度优先搜索 - 层次遍历：F -&amp;gt; B -&amp;gt; G -&amp;gt; A -&amp;gt; D -&amp;gt; I -&amp;gt; C -&amp;gt; E -&amp;gt; H&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;种树的所有结点的过程. 具体的访问操作可能是检查结点的值, 更新结点的值等. 不同的遍历方式, 其访问结&lt;/p&gt;
&lt;p&gt;　　通过阅读和思考以上维基百科中提供的摘录, 我们大致对两类遍历算法有了点直观的认知. 不知道有没&lt;/p&gt;
&lt;p&gt;有人有这样的疑惑, 为什么宽度优先搜索叫法没有广度优先搜索这个叫法流传广, 明明在树结构中要好理解&lt;/p&gt;
&lt;p&gt;多了呢? 乍看确实这样, 但不要忘了树结构是一种特殊图结构, 而复杂图结构可能没有直观从上到下, 从左到&lt;/p&gt;
&lt;p&gt;右这种直观的观感了. 因而宽度优先搜索名词在一般化中显得不够准确了. 哈哈哈. 另外一个认知是关于必要&lt;/p&gt;
&lt;p&gt;条件的. 例如深度和广度优先搜索包含很多不同遍历相关相关算法, 不仅仅只有文章中介绍那几个, 这点大家&lt;/p&gt;
&lt;p&gt;要充分认识. 　　&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201106174347446-1704635030.png&quot; alt=&quot;树-遍历-演示&quot; width=&quot;648&quot; title=&quot;树-遍历-演示&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　观察图片, 提示中可以发现前中后序遍历定义是围绕根结点访问时机定义的(还存在潜规则, 默认先左子&lt;/p&gt;
&lt;p&gt;树后右子树).  下面我们通过具体的代码来表达遍历思路. 首先我们构造树结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 方便测试和描述算法, 用 int node 构建 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; node_t;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; node_printf(node_t value) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; %2d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value);
}


&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tree {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; left;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; right;

    node_t node;
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; inline &lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; tree_new(node_t value) {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree * node = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt; (&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tree));
    node&lt;/span&gt;-&amp;gt;left = node-&amp;gt;right =&lt;span&gt; NULL;
    node&lt;/span&gt;-&amp;gt;node =&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tree_delete_partial(&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; node) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;left) tree_delete_partial(node-&amp;gt;&lt;span&gt;left);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;right) tree_delete_partial(node-&amp;gt;&lt;span&gt;right);
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(node);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
tree_delete(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (root) tree_delete_partial(root);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.1 前序遍历&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tree_preorder_partial(&lt;span&gt;struct&lt;/span&gt; stack *&lt;span&gt; s) {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; top;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.1 访问栈顶结点, 并将其出栈&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((top =&lt;span&gt; stack_pop_top(s))) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2 做业务处理&lt;/span&gt;
        node_printf(top-&amp;gt;&lt;span&gt;node);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 如果根结点存在右孩子, 则将右孩子入栈&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;right)
            stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 如果根结点存在左孩子, 则将左孩子入栈&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;left)
            stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 前序遍历:
 *      根结点 -&amp;gt; 左子树 -&amp;gt; 右子树
 * 
 * 遍历算法:
 *      1. 先将根结点入栈
        2. 访问栈顶结点, 做业务处理, 并将其出栈
        3. 如果根结点存在右孩子, 则将右孩子入栈
        4. 如果根结点存在左孩子, 则将左孩子入栈
        重复 2 - 4 直到栈空
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
tree_preorder(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; stack s[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]; 
    stack_init(s);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 先将根结点入栈&lt;/span&gt;
&lt;span&gt;    stack_push(s, root);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复 2 - 4 直到栈空&lt;/span&gt;
&lt;span&gt;    tree_preorder_partial(s);

    stack_free(s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 中序遍历&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 中序遍历:
 *      左子树 -&amp;gt; 根结点 -&amp;gt; 右子树
 * 
 * 遍历算法:
 *      1. 先将根结点入栈
        2. 将当前结点的所有左孩子入栈, 直到左孩子为空
        3. 弹出并访问栈顶元素, 做业务处理.
        4. 如果栈顶元素存在右孩子, 重复第 2 - 3步, 直到栈空并且不存在待访问结点
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
tree_inorder(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; stack s[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]; 
    stack_init(s);

    tree_inorder_partial(root, s);

    stack_free(s);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tree_postorder_partial(&lt;span&gt;struct&lt;/span&gt; stack *&lt;span&gt; s) { 
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; top;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录前一次出栈结点&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; tree * last =&lt;span&gt; NULL;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复 1-2 直到栈空&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((top =&lt;span&gt; stack_top(s))) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2 如果我们发现它左右子结点都为空, 则可以做业务处理;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.3 或者，如果发现前一个出栈的结点是它的左结点或者右子结点，则可以做业务处理;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((!top-&amp;gt;left &amp;amp;&amp;amp; !top-&amp;gt;right) || (last &amp;amp;&amp;amp; (last == top-&amp;gt;left || last == top-&amp;gt;&lt;span&gt;right))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做业务处理&lt;/span&gt;
            node_printf(top-&amp;gt;&lt;span&gt;node);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出栈&lt;/span&gt;
&lt;span&gt;            stack_pop(s);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录此次出栈结点&lt;/span&gt;
            last =&lt;span&gt; top;
         } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.4. 否则，表示这个结点是一个新的结点，需要尝试将其右左子结点依次入栈.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;right)
                stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;left)
                stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
         }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 后序遍历&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tree_postorder_partial(&lt;span&gt;struct&lt;/span&gt; stack *&lt;span&gt; s) { 
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; top;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录前一次出栈结点&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; tree * last =&lt;span&gt; NULL;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复 1-2 直到栈空&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((top =&lt;span&gt; stack_top(s))) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2 如果我们发现它左右子结点都为空, 则可以做业务处理;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.3 或者，如果发现前一个出栈的结点是它的左结点或者右子结点，则可以做业务处理;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((!top-&amp;gt;left &amp;amp;&amp;amp; !top-&amp;gt;right) || (last &amp;amp;&amp;amp; (last == top-&amp;gt;left || last == top-&amp;gt;&lt;span&gt;right))) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做业务处理&lt;/span&gt;
            node_printf(top-&amp;gt;&lt;span&gt;node);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出栈&lt;/span&gt;
&lt;span&gt;            stack_pop(s);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录此次出栈结点&lt;/span&gt;
            last =&lt;span&gt; top;
         } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.4. 否则，表示这个结点是一个新的结点，需要尝试将其右左子结点依次入栈.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;right)
                stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;right);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (top-&amp;gt;&lt;span&gt;left)
                stack_push(s, top&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
         }
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 后序遍历:
 *      左子树 -&amp;gt; 右子树 -&amp;gt; 根结点
 * 
 * 遍历算法:
 *      1. 拿到一个结点, 先将其入栈, 则它一定在比较靠栈底的地方, 比较晚出栈
        2. 在出栈时候判断到底是只有左结点还是只有右结点或者是两者都有或者是都没有.
           如果我们发现它左右子结点都为空, 则可以做业务处理;
           或者，如果发现前一个出栈的结点是它的左结点或者右子结点，则可以做业务处理;
           否则，表示这个结点是一个新的结点，需要尝试将其右左子结点依次入栈.
        重复 1-2 直到栈空
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
tree_postorder(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; stack s[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]; 
    stack_init(s);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 先将根结点入栈&lt;/span&gt;
&lt;span&gt;    stack_push(s, root);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复 1 - 4 直到栈空&lt;/span&gt;
&lt;span&gt;    tree_postorder_partial(s);

    stack_free(s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;思考上面深度优先搜索三种方式, 大致会感觉占用栈空间多少映象是 &lt;strong&gt;前序遍历 &amp;lt; 中序遍历 &amp;lt; 后序遍历&lt;/strong&gt; (存在特&lt;/p&gt;
&lt;p&gt;例). 可能, 这也是前序遍历是树深度优先搜索算法中流传最广的原因. 对于树的后序遍历代码实现, 版本也有好&lt;/p&gt;
&lt;p&gt;几个. 有的很容易手写, 很花哨偷巧, 这里推荐的是正规工程版本. &lt;/p&gt;
&lt;h2&gt;2.4 层次遍历&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 层次遍历:
 *      根结点 -&amp;gt; 下一层 | 左结点 -&amp;gt; 右结点
 *
 * 遍历算法:
 *      1. 对于不为空的结点, 先把该结点加入到队列中
 *      2. 从队中弹出结点, 并做业务处理, 尝试将左结点右结点依次压入队列中
 *      重复 1 - 2 指导队列为空 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
tree_level(&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; tree *&lt;span&gt; root) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!root) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    q_t q;
    q_init(q);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 对于不为空的结点, 先把该结点加入到队列中&lt;/span&gt;
&lt;span&gt;    q_push(q, root);
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.1 从队中弹出结点, 并做业务处理&lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; tree * node =&lt;span&gt; q_pop(q);

        node_printf(node&lt;/span&gt;-&amp;gt;&lt;span&gt;node);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2 尝试将左结点右结点依次压入队列中&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;left) 
            q_push(q, node&lt;/span&gt;-&amp;gt;&lt;span&gt;left);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node-&amp;gt;&lt;span&gt;right)
            q_push(q, node&lt;/span&gt;-&amp;gt;&lt;span&gt;right);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复 1 - 2 指导队列为空&lt;/span&gt;
    } &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (q_exist(q));

    q_free(q);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　本章会先对图的深度优先搜索和广度优先搜索进行简单介绍, 然后再给出 C 的源码实现.&lt;/p&gt;
&lt;h2&gt;3.0 图的基本概念&lt;/h2&gt;
&lt;h3&gt;3.0.1 图的定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义:&lt;/span&gt; &lt;/strong&gt;图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成, 通常表示为: &lt;strong&gt;G(V, E), &lt;/strong&gt;其中, &lt;strong&gt;G &lt;/strong&gt;表示&lt;strong&gt;一&lt;/strong&gt;&lt;strong&gt;个图&lt;/strong&gt;, &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;             V &lt;/strong&gt;是 &lt;strong&gt;图 G&lt;/strong&gt; 中顶点的集合, &lt;strong&gt;E &lt;/strong&gt;是 &lt;strong&gt;图 G&lt;/strong&gt; 中&lt;strong&gt;边的集合&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在图中需要注意的是: &lt;/p&gt;
&lt;p&gt;(1) 线性表中我们把数据元素叫元素, 树中将数据元素叫结点, &lt;strong&gt;在图中数据元素, 我们则称之为顶点&lt;/strong&gt;(&lt;strong&gt;Vertex&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;(2) 线性表可以没有元素, 称为空表; 树中可以没有结点, 称为空树; 但是, &lt;strong&gt;在图中不允许没有顶点&lt;/strong&gt;(有穷非空性).&lt;/p&gt;
&lt;p&gt;(3) 线性表中的各元素是线性关系, 树中的各元素是层次关系, 而, &lt;strong&gt;图中各顶点的关系是用边来表示&lt;/strong&gt;(边集可以为&lt;/p&gt;
&lt;p&gt;      空).&lt;/p&gt;
&lt;h3&gt;3.0.2 图的基本概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1) 无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108204802935-2015483579.jpg&quot; alt=&quot;无向图&quot; width=&quot;489&quot; title=&quot;无向图&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边), 则称该图为无向图(Undirected&lt;/p&gt;
&lt;p&gt;graphs).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 有向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108205102471-789860068.jpg&quot; alt=&quot;有向图&quot; width=&quot;489&quot; title=&quot;有向图&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边), 则称该图为有向图(Directed graphs).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 完全图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 无向完全图: 在无向图中, 如果任意两个顶点之间都存在边, 则称该图为无向完全图. (含有 n 个顶点的无向完&lt;/p&gt;
&lt;p&gt;    全图有 (n×(n-1))/2 条边) 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108205706930-20034402.jpg&quot; alt=&quot;无向完全图&quot; width=&quot;489&quot; title=&quot;无向完全图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 有向完全图: 在有向图中, 如果任意两个顶点之间都存在方向互为相反的两条弧, 则称该图为有向完全图. (含&lt;/p&gt;
&lt;p&gt;     有 n 个顶点的有向完全图有 n×(n-1) 条边) 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108205743291-294917076.jpg&quot; alt=&quot;有向完全图&quot; width=&quot;489&quot; title=&quot;有向完全图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS:&lt;/span&gt; 当一个图接近完全图时, 则称它为稠密图(Dense Graph), 而当一个图含有较少的边时, 则称它为稀疏图(&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         Spare Graph).&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) 顶点的度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顶点 V 的度(Degree) 是指在图中与 V 相关联的边的条数. 对于有向图来说, 有入度(In-degree)和出度&lt;/p&gt;
&lt;p&gt;(Out-degree) 之分, 有向图顶点的度等于该顶点的入度和出度之和.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5) 邻接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 若无向图中的两个顶点 V 和 W 存在一条边(V, W), 则称顶点 V 和 W 邻接(Adjacent);&lt;/p&gt;
&lt;p&gt;② 若有向图中存在一条边&amp;lt;V, W&amp;gt;，则称 &lt;strong&gt;顶点 V 邻接到 顶点 W&lt;/strong&gt; ，活&lt;strong&gt; &lt;/strong&gt;顶点 W &lt;strong&gt;邻接自&lt;/strong&gt; 顶点 V; &lt;/p&gt;
&lt;p&gt;      以 &lt;strong&gt;(2) 有向图&lt;/strong&gt; 举例, 有 &amp;lt;A, D&amp;gt; &amp;lt;B, A&amp;gt; &amp;lt;B, C&amp;gt; &amp;lt;C, A&amp;gt; 邻接关系.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(6) 弧头和弧尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有向图中, &lt;strong&gt;无箭头一端的顶点&lt;/strong&gt;通常被称为&quot;初始点&quot;或&quot;&lt;strong&gt;弧尾&lt;/strong&gt;&quot;, &lt;strong&gt;箭头直线的顶点&lt;/strong&gt;被称为&quot;终端点&quot;或&quot;&lt;strong&gt;弧头&lt;/strong&gt;&quot;. &amp;lt;A, D&amp;gt;&lt;/p&gt;
&lt;p&gt;邻接关系中, 顶点 A 就是弧尾, 顶点 D 就是弧头. &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS: &lt;/span&gt;无向图中的边使用小括号&quot;()&quot;表示, 而有向图中的边使用尖括号&quot;&amp;lt;&amp;gt;&quot; 表示.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(7) 路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在无向图中, 若从顶点 V 出发有一组边可到达顶点 W, 则称顶点 V 到顶点 W 的顶点序列, 为从顶点 V 到顶点 W的&lt;/p&gt;
&lt;p&gt;路径(Path).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(8) 连通&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若从 V 到 W 有路径可通, 则称顶点 V 和顶点 W 是连通(Connected)的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(9) 权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108212725279-230846968.jpg&quot; alt=&quot;网-权&quot; title=&quot;网-权&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有些图的边或弧具有与它相关的数字, 这种与图的边或弧相关的数叫做权(Weight).&lt;/p&gt;
&lt;p&gt;有些图的边或弧具有与它相关的数字, 这种与图的边或弧相关的数叫做权(Weight).&lt;/p&gt;
&lt;h3&gt;3.0.3 图最基础的两类存储结构&lt;/h3&gt;
&lt;p&gt;　　图的存储结构除了要存储图中的各个顶点本身的信息之外, 还要存储顶点与顶点之间的关系, 因此, 图的结&lt;/p&gt;
&lt;p&gt;构也比较复杂. 常用最基础的两类图的存储结构有邻接矩阵和邻接表.&lt;/p&gt;
&lt;h4&gt;3.0.3.1 邻接矩阵表示法&lt;/h4&gt;
&lt;p&gt;　　图的&lt;strong&gt;邻接矩阵(&lt;/strong&gt;Adjacency Matrix)存储方式是&lt;strong&gt;用两个数组来表示图. &lt;/strong&gt;一个一维数组存储图中顶点信息, 一个&lt;/p&gt;
&lt;p&gt;二维数组(称为邻接矩阵)存储图中的边或弧的信息.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108214540135-2075393923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以设置两个数组, 顶点数组为 vertex[4] = {V0, V1, V2, V3}, 边数组 edges[4][4] 为上图右边这样的一个矩&lt;/p&gt;
&lt;p&gt;阵. 对于矩阵的主对角线的值, 即 edges[0][0], edges[1][1], edges[2][2], edges[3][3], 全为 0,  因为不存在顶点&lt;/p&gt;
&lt;p&gt;自己到自己的边.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 有向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一个有向图样例, 如下图所示的左边. 顶点数组为 vertex[4] = {V0, V1, V2, V3}, 弧数组 edges[4][4]&lt;/p&gt;
&lt;p&gt;为下图右边这样的一个矩阵. 主对角线上数值依然为 0. 但因为是&lt;strong&gt;有向图&lt;/strong&gt;, 所以此&lt;strong&gt;矩阵并不对称&lt;/strong&gt;, 比如由 V1 到 V0&lt;/p&gt;
&lt;p&gt;有弧, 得到 edges[1][0] = 1, 而 V0 到 V1 没有弧, 因此 edges[0][1] = 0.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108215102621-116574366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不足: &lt;/strong&gt;&lt;/span&gt;由于存在 n 个顶点的图需要 n*n 个数组元素进行存储, &lt;strong&gt;当图为稀疏图时, 使用邻接矩阵存储方法将会出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;             现&lt;/strong&gt;&lt;strong&gt;大量 0 元素, 这会造成极大的空间浪费. &lt;/strong&gt;这时, 可以考虑使用邻接表表示法来存储图中的数据.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.0.3.2 邻接表表示法&lt;/h4&gt;
&lt;p&gt;　　首先, 回忆我们烙印在身体里的线性表存储结构, 顺序存储结构因为存在预先分配内存可能造成存储空间&lt;/p&gt;
&lt;p&gt;浪费的问题, 于是想到了链式存储的结构. 同样的, 我们也可以尝试对边或弧使用链式存储的方式来避免空间浪&lt;/p&gt;
&lt;p&gt;费的问题.&lt;/p&gt;
&lt;p&gt;　　邻接表由&lt;strong&gt;表头结点&lt;/strong&gt;和&lt;strong&gt;表结点&lt;/strong&gt;两部分组成, 图中每个顶点均对应一个存储在数组中的表头结点. 如果这个表&lt;/p&gt;
&lt;p&gt;头结点所对应的顶点存在邻接结点, 则把邻接结点依次存放于表头结点所指向的单向链表中.&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;无向图: &lt;/strong&gt;下图所示的就是一个无向图的邻接表结构.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108215337373-389012872.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中我们知道, 顶点表的各个结点由 data 和 firstedge 两个域表示, data 是数据域, 存储顶点的信息,&lt;/p&gt;
&lt;p&gt;firstedge 是指针域, 指向边表的第一个结点, 即此顶点的第一个邻接点. 边表结点由 adjvex 和 next 两个域组成.&lt;/p&gt;
&lt;p&gt;adjvex 是邻接点域, 存储某顶点的邻接点在顶点表中的下标, next 则存储指向边表中下一个结点的指针. 例如:&lt;/p&gt;
&lt;p&gt;V1 顶点与 V0, V2 互为邻接点, 则在 V1 的边表中，adjvex 分别为 V0 的 0 和 V2 的 2.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PS:&lt;/span&gt; 对于无向图来说, 使用邻接表进行存储也会出现数据冗余的现象. 例如上图中, 顶点 V0 所指向的链表中存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         在一个指向顶点 V3 的同时，顶点 V3 所指向的链表中也会存在一个指向 V0 的顶点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;有向图: &lt;/strong&gt;若是有向图, 邻接表结构是类似的，但要注意的是有向图由于有方向的. 因此, 有向图的邻接表分为&lt;/p&gt;
&lt;p&gt;出边表和入边表(又称逆邻接表), 出边表的表结点存放的是从表头结点出发的有向边所指的尾结点; 入边表的表&lt;/p&gt;
&lt;p&gt;结点存放的则是指向表头结点的某个顶点, 如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108215405910-709846531.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;带权图: &lt;/strong&gt;对于带权值的&lt;strong&gt;网图&lt;/strong&gt;, 可以在边表结点定义中再增加一个 weight 的数据域, 存储权值信息即可, 如下&lt;/p&gt;
&lt;p&gt;图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108215423549-247847983.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.1 深度优先搜索图文介绍&lt;/h2&gt;
&lt;h3&gt;3.1.1 深度优先搜索介绍&lt;/h3&gt;
&lt;p&gt;　　图的深度优先搜索(Depth First Search)，我们再重复重复加深理解. 我们介绍下它的搜索步骤: 假设初始&lt;/p&gt;
&lt;p&gt;状态是图中所有顶点均未被访问, 则从某个 顶点(结点) v 出发, 首先访问该顶点, 然后依次从它的各个未被访问&lt;/p&gt;
&lt;p&gt;的邻接点出发深度优先搜索遍历图, 直至图中所有和 顶点 v 有路径相通的顶点都被访问到. 若此时, 尚有其他顶&lt;/p&gt;
&lt;p&gt;点未被访问到, 则另选一个未被访问的顶点作起始点, 重复上述过程, 直至图中所有顶点都被访问到为止.  显然，&lt;/p&gt;
&lt;p&gt;深度优先搜索对于图这类结构很容易被递归过程所构造. &lt;/p&gt;
&lt;h3&gt;3.1.2 深度优先搜索图解&lt;/h3&gt;
&lt;h4&gt;3.1.2.1 无向图的深度优先搜索&lt;/h4&gt;
&lt;p&gt;　　下面以&quot;无向图&quot;为例, 来对深度优先搜索进行演示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108191711398-255299673.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对上面的 图 G1 进行深度优先遍历，从 顶点 A 开始.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108191719270-617406649.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步: &lt;/strong&gt;访问 A.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步: &lt;/strong&gt;访问(A 的邻接点) C.&lt;/p&gt;
&lt;p&gt;            在 &lt;strong&gt;第1步&lt;/strong&gt; 访问 A 之后, 接下来应该访问的是 A 的邻接点, 即 &quot;C, D, F&quot; 中的一个. 但在本文的实现中,&lt;/p&gt;
&lt;p&gt;            顶点 ABCDEFG 是按照顺序存储，C在&quot;D和F&quot;的前面，因此，先访问C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步: &lt;/strong&gt;访问(C 的邻接点) B.&lt;/p&gt;
&lt;p&gt;            在 &lt;strong&gt;第2步&lt;/strong&gt; 访问 C 之后, 接下来应该访问 C 的邻接点, 即 &quot;B和D&quot; 中一个(A已经被访问过，就不算在内)&lt;/p&gt;
&lt;p&gt;            . 而由于 B 在 D 之前, 先访问 B.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步: &lt;/strong&gt;访问(C 的邻接点) D.&lt;/p&gt;
&lt;p&gt;           在 &lt;strong&gt;第3步&lt;/strong&gt; 访问了 C 的邻接点 B 之后, B 没有未被访问的邻接点; 因此, 返回访问 C 的另一个邻接点 D.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第5步: &lt;/strong&gt;访问(A 的邻接点) F.&lt;/p&gt;
&lt;p&gt;            前面已经访问了 A, 并且访问完了 &quot;A 的邻接点 B 的所有邻接点(包括递归的邻接点在内)&quot;; 因此, 此时&lt;/p&gt;
&lt;p&gt;            返回到访问A的另一个邻接点F。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第6步: &lt;/strong&gt;访问(F 的邻接点) G.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第7步: &lt;/strong&gt;访问(G 的邻接点) E.&lt;/p&gt;
&lt;p&gt;因此访问顺序是: &lt;strong&gt;A -&amp;gt; C -&amp;gt; B -&amp;gt; D -&amp;gt; F -&amp;gt; G -&amp;gt; E&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;3.1.2.2 有向图的深度优先搜索&lt;/h4&gt;
&lt;p&gt;　　下面以&quot;有向图&quot;为例, 来对深度优先搜索进行演示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108192821395-1762981994.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对上面的 图 G2 进行深度优先遍历, 从 顶点 A 开始.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108192850377-758312069.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步: &lt;/strong&gt;访问 A.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步: &lt;/strong&gt;访问 B.&lt;/p&gt;
&lt;p&gt;            在访问了 A 之后, 接下来应该访问的是 A 的出边的另一个顶点, 即顶点 B.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步: &lt;/strong&gt;访问 C.&lt;/p&gt;
&lt;p&gt;            在访问了 B 之后, 接下来应该访问的是 B 的出边的另一个顶点, 即 顶点 C, E, F. 在本文实现的图中, 顶&lt;/p&gt;
&lt;p&gt;            点 ABCDEFG 按照顺序存储, 因此先访问 C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步: &lt;/strong&gt;访问 E.&lt;/p&gt;
&lt;p&gt;            接下来访问 C 的出边的另一个顶点, 即顶点 E.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第5步: &lt;/strong&gt;访问 D.&lt;/p&gt;
&lt;p&gt;            接下来访问 E 的出边的另一个顶点, 即 顶点 B, D. 顶点 B 已经被访问过, 因此访问 顶点 D.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第6步: &lt;/strong&gt;访问 F.&lt;/p&gt;
&lt;p&gt;            接下应该回溯&quot;访问 A 的出边的另一个顶点 F&quot;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第7步: &lt;/strong&gt;访问 G.&lt;/p&gt;
&lt;p&gt;因此访问顺序是: &lt;strong&gt;A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; D -&amp;gt; F -&amp;gt; G&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3.2 广度优先搜索图文介绍&lt;/h2&gt;
&lt;h3&gt;3.2.1 广度优先搜索介绍&lt;/h3&gt;
&lt;p&gt;　　广度优先搜索算法(Breadth First Search), 又称为&quot;宽度优先搜索&quot;或&quot;横向优先搜索&quot;, 简称BFS. 它的遍历&lt;/p&gt;
&lt;p&gt;常规思路是: 从图中某顶点(结点) v 出发, 在访问了 v 之后依次访问 v 的各个未曾访问过的邻接点, 然后分别从&lt;/p&gt;
&lt;p&gt;这些邻接点出发依次访问它们的邻接点, 并使得&quot;先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问&lt;/p&gt;
&lt;p&gt;, 直至图中所有已被访问的顶点的邻接点都被访问到. 如果此时图中尚有顶点未被访问, 则需要另选一个未曾被&lt;/p&gt;
&lt;p&gt;访问过的顶点作为新的起始点, 重复上述过程, 直至图中所有顶点都被访问到为止. 换句话说, 广度优先搜索遍历&lt;/p&gt;
&lt;p&gt;图的过程是以 v 为起点, 由近至远, 依次访问和 v 有路径相通且'路径长度'为 1, 2 ... 的顶点.&lt;/p&gt;
&lt;h3&gt;3.2.2 广度优先搜索图解&lt;/h3&gt;
&lt;h4&gt;3.2.2.1 无向图的广度优先搜索&lt;/h4&gt;
&lt;p&gt;　　下面以&quot;无向图&quot;为例, 来对广度优先搜索进行演示. 还是以上面的 图 G1 为例进行说明.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108195117286-1234527530.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步: &lt;/strong&gt;访问 A.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步: &lt;/strong&gt;依次访问 C, D, F.&lt;/p&gt;
&lt;p&gt;            在访问了 A 之后，接下来访问 A 的邻接点. 前面已经说过, 在本文实现中, 顶点 ABCDEFG 按照顺序存储&lt;/p&gt;
&lt;p&gt;            的, C 在 &quot;D 和 F&quot; 的前面, 因此, 先访问 C. 再访问完 C 之后, 再依次访问 D, F.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步: &lt;/strong&gt;依次访问 B, G.&lt;/p&gt;
&lt;p&gt;            在 &lt;strong&gt;第2步&lt;/strong&gt; 访问完 C, D, F 之后, 再依次访问它们的邻接点. 首先访问 C 的邻接点 B, 再访问 F 的邻接点 G.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步: &lt;/strong&gt;访问 E.&lt;/p&gt;
&lt;p&gt;            在 &lt;strong&gt;第3步&lt;/strong&gt; 访问完 B, G 之后, 再依次访问它们的邻接点. 只有 G 有邻接点 E, 因此访问 G 的邻接点 E.&lt;/p&gt;
&lt;p&gt;因此访问顺序是: &lt;strong&gt;A -&amp;gt; C -&amp;gt; D -&amp;gt; F -&amp;gt; B -&amp;gt; G -&amp;gt; E&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;3.2.2.2 有向图的广度优先搜索&lt;/h4&gt;
&lt;p&gt;　　下面以&quot;有向图&quot;为例, 来对广度优先搜索进行演示. 还是以上面的 图 G2 为例进行说明.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202011/532523-20201108200117839-918766280.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步: &lt;/strong&gt;访问 A.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步: &lt;/strong&gt;访问 B.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步: &lt;/strong&gt;依次访问 C, E, F.&lt;/p&gt;
&lt;p&gt;            在访问了 B 之后, 接下来访问 B 的出边的另一个顶点, 即 C, E, F. 前面已经说过, 在本文实现中，顶点&lt;/p&gt;
&lt;p&gt;            ABCDEFG 按照顺序存储的, 因此会先访问 C, 再依次访问 E, F.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步: &lt;/strong&gt;依次访问 D, G.&lt;/p&gt;
&lt;p&gt;            在访问完 C, E, F 之后, 再依次访问它们的出边的另一个顶点. 还是按照 C, E, F 的顺序访问, C 的已经全部&lt;/p&gt;
&lt;p&gt;            访问过了, 那么就只剩下 E, F; 先访问 E 的邻接点 D, 再访问 F 的邻接点 G.&lt;/p&gt;
&lt;p&gt;因此访问顺序是：&lt;strong&gt;A -&amp;gt; B -&amp;gt; C -&amp;gt; E -&amp;gt; F -&amp;gt; D -&amp;gt; G&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3.3 搜索算法源码&lt;/h2&gt;
&lt;h3&gt;&lt;a title=&quot;邻接矩阵图表示的无向图 (Matrix Undirected Graph)&quot; name=&quot;tab3_3_1&quot; href=&quot;https://github.com/wangzhione/temp/blob/master/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/code/graph/mudg.c&quot; target=&quot;_blank&quot;&gt;3.3.1 邻接矩阵图表示的无向图 (Matrix Undirected Graph)&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a title=&quot;3.3.2 邻接矩阵图表示的有向图 (Matrix Directed Graph)&quot; name=&quot;tab3_3_2&quot; href=&quot;https://github.com/wangzhione/temp/blob/master/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/code/graph/mdg.c&quot; target=&quot;_blank&quot;&gt;3.3.2 邻接矩阵图表示的有向图 (Matrix Directed Graph)&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a title=&quot;3.3.3 邻接链表图表示的无向图 (List Undirected Graph)&quot; name=&quot;tab3_3_3&quot; href=&quot;https://github.com/wangzhione/temp/blob/master/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/code/graph/ludg.c&quot; target=&quot;_blank&quot;&gt;3.3.3 邻接链表图表示的无向图 (List Undirected Graph)&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a title=&quot;3.3.4 邻接链表图表示的有向图 (List Directed Graph)&quot; href=&quot;https://github.com/wangzhione/temp/blob/master/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2/code/graph/ldg.c&quot; target=&quot;_blank&quot;&gt;3.3.4 邻接链表图表示的有向图 (List Directed Graph)&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Sun, 08 Nov 2020 16:17:00 +0000</pubDate>
<dc:creator>喜欢兰花山丘</dc:creator>
<og:description>当我们在学习和临摹垃圾回收(Garbage Collection, 缩写为 GC)相关算法和源码时候, 内在细节离不开 这两大类搜索算法支撑. 这就是构建的背景❉, 文章定位是科普扫盲❤. 0. 引述</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/life2refuel/p/13936009.html</dc:identifier>
</item>
</channel>
</rss>