<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python之变量的创建过程 - Kwan、C</title>
<link>http://www.cnblogs.com/Kwan-C/p/11444595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kwan-C/p/11444595.html</guid>
<description>&lt;h2 id=&quot;一变量创建过程&quot;&gt;&lt;span&gt;一、变量创建过程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;首先，当我们定义了一个变量name = 'Kwan'的时候，在内存中其实是做了这样一件事：&lt;/p&gt;
&lt;p&gt;程序开辟了一块内存空间，将'Kwan'存储进去，再让变量名name指向'Kwan'所在的内存地址。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655140/201909/1655140-20190902083420658-1907343311.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;id()&lt;/code&gt;方法查看这个变量在内存中的地址。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;name = 'Kwan'
print(id(name))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二变量的修改&quot;&gt;&lt;span&gt;二、变量的修改&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一般我们认为修改一个变量就是用新值把就旧值覆盖掉，可Python真是这么实现的么？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;name = 'Kwan'
print(id(name))
name = 'Kobe'
print(id(name))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655140/201909/1655140-20190902083431936-754327296.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际的原理是什么样的呢？&lt;strong&gt;程序先申请了一块内存空间来存储'Kwan'，让name变量名指向这块内存空间，往下执行name = 'Kobe'之后，又申请了另一块内存空间来存储'Kobe'，并让原本指向'Kwan'内存的链接断开，让name再指向'Kobe'。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655140/201909/1655140-20190902083437770-866742507.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三变量的指向关系&quot;&gt;&lt;span&gt;三、变量的指向关系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;问：下面这段代码为何出现这样的现象？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;name1 = 'Kwan'
name2 = name1
print(name1, name2)

name1 = 'Kobe'
print(name1, name2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655140/201909/1655140-20190902083443399-605995242.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要想知道上面问题的结果是为什么，首先要了解再内存中两个变量的存储情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655140/201909/1655140-20190902083448357-1832148878.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的示意图中我们可以知道，&lt;strong&gt;当执行&lt;code&gt;name2 = name1&lt;/code&gt;时，事实上时让name2指向了'Kwan'所在的内存地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改name1的值，相当于断开了name1到'Kwan'的链接，重新建立name1和'Kobe'之间的链接。在这个过程中，始终没有影响到name2和'Kwan'之间的关系，因此name2还是'Kwan'，而name1变成了'Kobe'。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:36:00 +0000</pubDate>
<dc:creator>Kwan、C</dc:creator>
<og:description>本节主要介绍Python中变量创建过程和修改过程的相关内存地址变化以及思路。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Kwan-C/p/11444595.html</dc:identifier>
</item>
<item>
<title>JavaScript 数据结构与算法之美 - 冒泡排序、插入排序、选择排序 - 天明夜尽</title>
<link>http://www.cnblogs.com/biaochenxuying/p/11444593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/biaochenxuying/p/11444593.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083352192-836082744.png&quot; alt=&quot;JavaScript 数据结构与算法之美&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083404646-2137199756.gif&quot; alt=&quot;全栈修炼&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;算法为王。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者写的 &lt;strong&gt;JavaScript 数据结构与算法之美&lt;/strong&gt; 系列用的语言是 &lt;strong&gt;JavaScript&lt;/strong&gt; ，旨在入门数据结构与算法和方便以后复习。&lt;/p&gt;
&lt;p&gt;之所以把&lt;code&gt;冒泡排序、选择排序、插入排序&lt;/code&gt;放在一起比较，是因为它们的平均时间复杂度都为 O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/p&gt;
&lt;p&gt;请大家带着问题：&lt;code&gt;为什么插入排序比冒泡排序更受欢迎 ？&lt;/code&gt;来阅读下文。&lt;/p&gt;
&lt;h2 id=&quot;如何分析一个排序算法&quot;&gt;2. 如何分析一个排序算法&lt;/h2&gt;
&lt;p&gt;复杂度分析是整个算法学习的精髓。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度: 一个算法执行所耗费的时间。&lt;/li&gt;
&lt;li&gt;空间复杂度: 运行完一个程序所需内存的大小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;时间和空间复杂度的详解，请看 &lt;a href=&quot;https://juejin.im/post/5cf37b6d6fb9a07eb15d3e88&quot;&gt;JavaScript 数据结构与算法之美 - 时间和空间复杂度&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。&lt;/p&gt;
&lt;p&gt;分析一个排序算法，要从 &lt;code&gt;执行效率&lt;/code&gt;、&lt;code&gt;内存消耗&lt;/code&gt;、&lt;code&gt;稳定性&lt;/code&gt; 三方面入手。&lt;/p&gt;
&lt;h3 id=&quot;执行效率&quot;&gt;2.1 执行效率&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 最好情况、最坏情况、平均情况时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。&lt;br/&gt;除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 时间复杂度的系数、常数 、低阶&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。&lt;/p&gt;
&lt;p&gt;但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 比较次数和交换（或移动）次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。&lt;/p&gt;
&lt;p&gt;所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。&lt;/p&gt;
&lt;h3 id=&quot;内存消耗&quot;&gt;2.2 内存消耗&lt;/h3&gt;
&lt;p&gt;也就是看空间复杂度。&lt;/p&gt;
&lt;p&gt;还需要知道如下术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内排序&lt;/strong&gt;：所有排序操作都在内存中完成；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外排序&lt;/strong&gt;：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原地排序&lt;/strong&gt;：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。&lt;br/&gt;其中，冒泡排序就是原地排序算法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;稳定性&quot;&gt;2.3 稳定性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;稳定：如果待排序的序列中存在值&lt;code&gt;相等&lt;/code&gt;的元素，经过排序之后，相等元素之间原有的先后顺序&lt;code&gt;不变&lt;/code&gt;。&lt;br/&gt;比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；&lt;/li&gt;
&lt;li&gt;不稳定：如果待排序的序列中存在值&lt;code&gt;相等&lt;/code&gt;的元素，经过排序之后，相等元素之间原有的先后顺序&lt;code&gt;改变&lt;/code&gt;。&lt;br/&gt;比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;3. 冒泡排序&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083406214-1617427358.gif&quot; alt=&quot;冒泡&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;冒泡排序只会操作相邻的两个数据。&lt;/li&gt;
&lt;li&gt;每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。&lt;/li&gt;
&lt;li&gt;一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：排序算法的基础，简单实用易于理解。&lt;/li&gt;
&lt;li&gt;缺点：比较次数多，效率较低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 冒泡排序（未优化）
const bubbleSort = arr =&amp;gt; {
    console.time('改进前冒泡排序耗时');
    const length = arr.length;
    if (length &amp;lt;= 1) return;
    // i &amp;lt; length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
    for (let i = 0; i &amp;lt; length - 1; i++) {
        // j &amp;lt; length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
        for (let j = 0; j &amp;lt; length - i - 1; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    console.log('改进前 arr :', arr);
    console.timeEnd('改进前冒泡排序耗时');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 冒泡排序（已优化）
const bubbleSort2 = arr =&amp;gt; {
    console.time('改进后冒泡排序耗时');
    const length = arr.length;
    if (length &amp;lt;= 1) return;
    // i &amp;lt; length - 1 是因为外层只需要 length-1 次就排好了，第 length 次比较是多余的。
    for (let i = 0; i &amp;lt; length - 1; i++) {
        let hasChange = false; // 提前退出冒泡循环的标志位
        // j &amp;lt; length - i - 1 是因为内层的 length-i-1 到 length-1 的位置已经排好了，不需要再比较一次。
        for (let j = 0; j &amp;lt; length - i - 1; j++) {
            if (arr[j] &amp;gt; arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                hasChange = true; // 表示有数据交换
            }
        }

        if (!hasChange) break; // 如果 false 说明所有元素已经到位，没有数据交换，提前退出
    }
    console.log('改进后 arr :', arr);
    console.timeEnd('改进后冒泡排序耗时');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 测试
const arr = [7, 8, 4, 5, 6, 3, 2, 1];
bubbleSort(arr);
// 改进前 arr : [1, 2, 3, 4, 5, 6, 7, 8]
// 改进前冒泡排序耗时: 0.43798828125ms

const arr2 = [7, 8, 4, 5, 6, 3, 2, 1];
bubbleSort2(arr2);
// 改进后 arr : [1, 2, 3, 4, 5, 6, 7, 8]
// 改进后冒泡排序耗时: 0.318115234375ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，冒泡排序是原地排序算法吗 ？&lt;br/&gt;冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个&lt;code&gt;原地&lt;/code&gt;排序算法。&lt;/li&gt;
&lt;li&gt;第二，冒泡排序是稳定的排序算法吗 ？&lt;br/&gt;在冒泡排序中，只有交换才可以改变两个元素的前后顺序。&lt;br/&gt;为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。&lt;br/&gt;所以冒泡排序是&lt;code&gt;稳定&lt;/code&gt;的排序算法。&lt;/li&gt;
&lt;li&gt;第三，冒泡排序的时间复杂度是多少 ？&lt;br/&gt;最佳情况：T(n) = O(n)，当数据已经是正序时。&lt;br/&gt;最差情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)，当数据是反序时。&lt;br/&gt;平均情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083415832-1347348275.gif&quot; alt=&quot;冒泡排序动画&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083419341-1599369879.gif&quot; alt=&quot;冒泡排序动画&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;插入排序&quot;&gt;4. 插入排序&lt;/h2&gt;
&lt;p&gt;插入排序又为分为 &lt;strong&gt;直接插入排序&lt;/strong&gt; 和优化后的 &lt;strong&gt;拆半插入排序&lt;/strong&gt; 与 &lt;strong&gt;希尔排序&lt;/strong&gt;，我们通常说的插入排序是指直接插入排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、直接插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。&lt;/p&gt;
&lt;p&gt;插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序；&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描；&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置；&lt;/li&gt;
&lt;li&gt;重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后；&lt;/li&gt;
&lt;li&gt;重复步骤 2~5。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 插入排序
const insertionSort = array =&amp;gt; {
    const len = array.length;
    if (len &amp;lt;= 1) return

    let preIndex, current;
    for (let i = 1; i &amp;lt; len; i++) {
        preIndex = i - 1; //待比较元素的下标
        current = array[i]; //当前元素
        while (preIndex &amp;gt;= 0 &amp;amp;&amp;amp; array[preIndex] &amp;gt; current) {
            //前置条件之一: 待比较元素比当前元素大
            array[preIndex + 1] = array[preIndex]; //将待比较元素后移一位
            preIndex--; //游标前移一位
        }
        if (preIndex + 1 != i) {
            //避免同一个元素赋值给自身
            array[preIndex + 1] = current; //将当前元素插入预留空位
            console.log('array :', array);
        }
    }
    return array;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 测试
const array = [5, 4, 3, 2, 1];
console.log(&quot;原始 array :&quot;, array);
insertionSort(array);
// 原始 array:    [5, 4, 3, 2, 1]
// array:        [4, 5, 3, 2, 1]
// array:        [3, 4, 5, 2, 1]
// array:        [2, 3, 4, 5, 1]
// array:        [1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，插入排序是原地排序算法吗 ？&lt;br/&gt;插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个&lt;code&gt;原地&lt;/code&gt;排序算法。&lt;/li&gt;
&lt;li&gt;第二，插入排序是稳定的排序算法吗 ？&lt;br/&gt;在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是&lt;code&gt;稳定&lt;/code&gt;的排序算法。&lt;/li&gt;
&lt;li&gt;第三，插入排序的时间复杂度是多少 ？&lt;br/&gt;最佳情况：T(n) = O(n)，当数据已经是正序时。&lt;br/&gt;最差情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)，当数据是反序时。&lt;br/&gt;平均情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083422116-1992503232.gif&quot; alt=&quot;insertion-sort.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、拆半插入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入排序也有一种优化算法，叫做&lt;code&gt;拆半插入&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取 0 ~ i-1 的中间点 ( m = (i-1)&amp;gt;&amp;gt;1 )，array[i] 与 array[m] 进行比较，若 array[i] &amp;lt; array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；反之，则说明它应该处于数组的 m ~ i-1 索引之间。&lt;/li&gt;
&lt;li&gt;重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。&lt;/li&gt;
&lt;li&gt;将数组中插入位置之后的元素全部后移一位。&lt;/li&gt;
&lt;li&gt;在指定位置插入第 i 个元素。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：x&amp;gt;&amp;gt;1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x&amp;gt;&amp;gt;1 == Math.floor(x/2) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 折半插入排序
const binaryInsertionSort = array =&amp;gt; {
    const len = array.length;
    if (len &amp;lt;= 1) return;

    let current, i, j, low, high, m;
    for (i = 1; i &amp;lt; len; i++) {
        low = 0;
        high = i - 1;
        current = array[i];

        while (low &amp;lt;= high) {
            //步骤 1 &amp;amp; 2 : 折半查找
            m = (low + high) &amp;gt;&amp;gt; 1; // 注: x&amp;gt;&amp;gt;1 是位运算中的右移运算, 表示右移一位, 等同于 x 除以 2 再取整, 即 x&amp;gt;&amp;gt;1 == Math.floor(x/2) .
            if (array[i] &amp;gt;= array[m]) {
                //值相同时, 切换到高半区，保证稳定性
                low = m + 1; //插入点在高半区
            } else {
                high = m - 1; //插入点在低半区
            }
        }
        for (j = i; j &amp;gt; low; j--) {
            //步骤 3: 插入位置之后的元素全部后移一位
            array[j] = array[j - 1];
            console.log('array2 :', JSON.parse(JSON.stringify(array)));
        }
        array[low] = current; //步骤 4: 插入该元素
    }
    console.log('array2 :', JSON.parse(JSON.stringify(array)));
    return array;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const array2 = [5, 4, 3, 2, 1];
console.log('原始 array2:', array2);
binaryInsertionSort(array2);
// 原始 array2:  [5, 4, 3, 2, 1]
// array2 :     [5, 5, 3, 2, 1]
// array2 :     [4, 5, 5, 2, 1]
// array2 :     [4, 4, 5, 2, 1]
// array2 :     [3, 4, 5, 5, 1]
// array2 :     [3, 4, 4, 5, 1]
// array2 :     [3, 3, 4, 5, 1]
// array2 :     [2, 3, 4, 5, 5]
// array2 :     [2, 3, 4, 4, 5]
// array2 :     [2, 3, 3, 4, 5]
// array2 :     [2, 2, 3, 4, 5]
// array2 :     [1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、希尔排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希尔排序是一个平均时间复杂度为 O(nlogn) 的算法，会在下一个章节和 归并排序、快速排序、堆排序 一起讲，本文就不展开了。&lt;/p&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;5. 选择排序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。&lt;/li&gt;
&lt;li&gt;再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;/li&gt;
&lt;li&gt;重复第二步，直到所有元素均排序完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const selectionSort = array =&amp;gt; {
    const len = array.length;
    let minIndex, temp;
    for (let i = 0; i &amp;lt; len - 1; i++) {
        minIndex = i;
        for (let j = i + 1; j &amp;lt; len; j++) {
            if (array[j] &amp;lt; array[minIndex]) {
                // 寻找最小的数
                minIndex = j; // 将最小数的索引保存
            }
        }
        temp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = temp;
        console.log('array: ', array);
    }
    return array;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 测试
const array = [5, 4, 3, 2, 1];
console.log('原始array:', array);
selectionSort(array);
// 原始 array:  [5, 4, 3, 2, 1]
// array:        [1, 4, 3, 2, 5]
// array:        [1, 2, 3, 4, 5]
// array:        [1, 2, 3, 4, 5]
// array:        [1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，选择排序是原地排序算法吗 ？&lt;br/&gt;选择排序空间复杂度为 O(1)，是一种&lt;code&gt;原地&lt;/code&gt;排序算法。&lt;/li&gt;
&lt;li&gt;第二，选择排序是稳定的排序算法吗 ？&lt;br/&gt;选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种&lt;code&gt;不稳定&lt;/code&gt;的排序算法。&lt;/li&gt;
&lt;li&gt;第三，选择排序的时间复杂度是多少 ？&lt;br/&gt;无论是正序还是逆序，选择排序都会遍历 n&lt;sup&gt;2&lt;/sup&gt; / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。&lt;br/&gt;最佳情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;br/&gt;最差情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;br/&gt;平均情况：T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083425432-85836920.gif&quot; alt=&quot;selection-sort.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;解答开篇&quot;&gt;6. 解答开篇&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么插入排序比冒泡排序更受欢迎 ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序和插入排序的时间复杂度都是 O(n&lt;sup&gt;2&lt;/sup&gt;)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢 ？&lt;/p&gt;
&lt;p&gt;这里关乎到 逆序度、满有序度、有序度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有序度&lt;/strong&gt;：是数组中具有有序关系的元素对的个数。&lt;br/&gt;有序元素对用数学表达式表示就是这样：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;有序元素对：a[i] &amp;lt;= a[j], 如果 i &amp;lt; j。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;逆序元素对：a[i] &amp;gt; a[j], 如果 i &amp;lt; j。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083427141-1614541025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；&lt;br/&gt;对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 **n*(n-1)/2** ，也就是满有序度为 15。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。&lt;/li&gt;
&lt;li&gt;插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。&lt;/li&gt;
&lt;li&gt;但是，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个，数据量一旦大了，这差别就非常明显了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;复杂性对比&quot;&gt;7. 复杂性对比&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;复杂性对比&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;冒泡排序&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;插入排序&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;选择排序&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;算法可视化工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里推荐一个算法可视化工具。&lt;/p&gt;
&lt;p&gt;算法可视化工具 &lt;a href=&quot;https://github.com/algorithm-visualizer/algorithm-visualizer&quot;&gt;algorithm-visualizer&lt;/a&gt; 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。&lt;/p&gt;
&lt;p&gt;效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204203/201909/1204203-20190902083432972-1522495204.gif&quot; alt=&quot;算法可视化工具&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;8. 最后&lt;/h2&gt;
&lt;p&gt;喜欢就点个小星星吧。&lt;/p&gt;
&lt;p&gt;文中所有的代码及测试事例都已经放到我的 &lt;a href=&quot;https://github.com/biaochenxuying/blog/tree/master/data-structure-and-algorithms&quot;&gt;GitHub&lt;/a&gt; 上了。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:35:00 +0000</pubDate>
<dc:creator>天明夜尽</dc:creator>
<og:description>1. 前言 算法为王。 想学好前端，先练好内功，只有内功深厚者，前端之路才会走得更远 。 笔者写的 JavaScript 数据结构与算法之美 系列用的语言是 JavaScript ，旨在入门数据结构与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/biaochenxuying/p/11444593.html</dc:identifier>
</item>
<item>
<title>如何成为更好的程序员？ - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/11444588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/11444588.html</guid>
<description>&lt;p&gt;&lt;em&gt;阅读本文并了解如何使用具有功能组合的声明性代码成为更好的程序员。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在许多情况下，具有功能组合的声明性解决方案提供优于传统命令式代码的代码度。阅读本文并了解如何使用具有功能组合的声明性代码成为更好的程序员。&lt;/p&gt;
&lt;p&gt;在本文中，我们将仔细研究三个问题示例，并研究两种不同的技术（命令式和声明性）来解决这些问题。&lt;/p&gt;
&lt;p&gt;本文中的所有源代码都是开源的，可从&lt;a href=&quot;https://github.com/minborg/imperative-vs-declarative&quot; class=&quot;uri&quot;&gt;https://github.com/minborg/imperative-vs-declarative&lt;/a&gt;获取。最后，我们还将看到本文的学习如何应用于数据库应用程序领域。我们将使用&lt;a href=&quot;https://speedment.com/stream/&quot;&gt;Speedment Stream&lt;/a&gt;作为ORM工具，因为它提供了与数据库中的表，视图和连接相对应的标准Java Streams，并支持声明性构造。&lt;/p&gt;
&lt;p&gt;实际上有无数个候选示例可用于代码度量评估。&lt;/p&gt;
&lt;h2 id=&quot;问题示例&quot;&gt;1.问题示例&lt;/h2&gt;
&lt;p&gt;在本文中，我选择了开发人员在日常工作可能遇到的三个常见问题：&lt;/p&gt;
&lt;h3 id=&quot;sumarray&quot;&gt;1.1.SumArray&lt;/h3&gt;
&lt;p&gt;迭代数组并执行计算&lt;/p&gt;
&lt;h3 id=&quot;groupingby&quot;&gt;1.2.GroupingBy&lt;/h3&gt;
&lt;p&gt;并行聚合值&lt;/p&gt;
&lt;h3 id=&quot;rest&quot;&gt;1.3.Rest&lt;/h3&gt;
&lt;p&gt;使用分页实现REST接口&lt;/p&gt;
&lt;h2 id=&quot;解决方案技术&quot;&gt;2.解决方案技术&lt;/h2&gt;
&lt;p&gt;正如本文开头所描述的，我们将使用这两种编码技术解决问题：&lt;/p&gt;
&lt;h3 id=&quot;命令式解决方案&quot;&gt;2.1 命令式解决方案&lt;/h3&gt;
&lt;p&gt;一个命令式的解决方案，我们使用带有for循环和显式可变状态的传统代码样例。&lt;/p&gt;
&lt;h3 id=&quot;声明式解决方案&quot;&gt;2.2 声明式解决方案&lt;/h3&gt;
&lt;p&gt;声明式解决方案，其中我们组合各种函数以形成解决问题的高阶复合函数，通常使用&lt;code&gt;java.util.stream.Stream&lt;/code&gt;或其变体。&lt;/p&gt;
&lt;h2 id=&quot;代码指标&quot;&gt;3.代码指标&lt;/h2&gt;
&lt;p&gt;然而，我们的想法是使用SonarQube（此处为SonarQube Community Edition，Version 7.7）将静态代码分析应用于不同的解决方案，以便我们可以为问题/解决方案组合推导出有用且标准化的代码度量标准。然后将比较这些指标。&lt;/p&gt;
&lt;p&gt;在本文中，我们将使用以下代码度量标准：&lt;/p&gt;
&lt;h3 id=&quot;loc&quot;&gt;3.1. LOC&lt;/h3&gt;
&lt;p&gt;“LOC”表示“代码行”，是代码中非空行的数量。&lt;/p&gt;
&lt;h3 id=&quot;statements&quot;&gt;3.2. Statements&lt;/h3&gt;
&lt;p&gt;是代码中的语句总数。每个代码行上可能有零到多个语句。&lt;/p&gt;
&lt;h3 id=&quot;循环复杂性&quot;&gt;3.3. 循环复杂性&lt;/h3&gt;
&lt;p&gt;表示代码的复杂性，并且是通过源代码程序的线性独立路径数量的定量度量。例如，单个“if”子句在代码中显示两条单独的路径。在维基百科上阅读更多&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclomatic_complexity&quot;&gt;内容&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;认知复杂性&quot;&gt;3.4。认知复杂性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SonarCube声称：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“认知复杂性改变了使用数学模型来评估软件可维护性的实践。它从Cyclomatic Complexity设定的先例开始，但是使用人为判断来评估结构应该如何计算，并决定应该将什么添加到模型中作为一个整体结果，它产生了方法复杂性分数，这使得程序员对可维护性模型的评估比以前更公平。“&lt;/p&gt;
&lt;p&gt;在SonarCube自己的页面上可以阅读更多&lt;a href=&quot;https://www.sonarsource.com/resources/white-papers/cognitive-complexity.html&quot;&gt;内容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;通常情况下，需要设想一个解决方案，其中这些指标很小而不是很大。&lt;/p&gt;
&lt;p&gt;对于记录，应该注意下面设计的任何解决方案只是解决任何给定问题的一种方法。如果您知道更好的解决方案，请随时通过&lt;a href=&quot;https://github.com/minborg/imperative-vs-declarative%E6%8B%89%E5%8F%96%E8%AF%B7%E6%B1%82%E6%8F%90%E4%BA%A4%E6%84%8F%E8%A7%81%E3%80%82&quot; class=&quot;uri&quot;&gt;https://github.com/minborg/imperative-vs-declarative拉取请求提交意见。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;迭代数组&quot;&gt;4.迭代数组&lt;/h2&gt;
&lt;p&gt;我们从简单开始。此问题示例的对象是计算int数组中元素的总和，并将结果返回为long。以下接口定义了问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface SumArray {
    long sum(int[] arr);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令式解决方案-1&quot;&gt;4.1.命令式解决方案&lt;/h3&gt;
&lt;p&gt;以下解决方案使用命令式技术实现SumArray问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SumArrayImperative implements SumArray {
    @Override
    public long sum(int[] arr) {
        long sum = 0;
        for (int i : arr) {
            sum += i;
        }
        return sum;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明式解决方案-1&quot;&gt;4.2声明式解决方案&lt;/h3&gt;
&lt;p&gt;这是一个使用声明性技术实现SumArray的解决方案：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SumArrayDeclarative implements SumArray {
    @Override
    public long sum(int[] arr) {
        return IntStream.of(arr)
            .mapToLong(i -&amp;gt; i)
            .sum();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，IntStream :: sum只返回一个int，因此，我们必须加入中间操作mapToLong（）。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;4.3.分析&lt;/h3&gt;
&lt;p&gt;SonarQube提供以下分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083136582-1882827051.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083136911-1154503597.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SumArray的代码度量标准如下表所示（通常更低）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Imperative&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Functional&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是它在图表中的值（通常更低）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083137229-1360629414.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;并行聚合值&quot;&gt;5.并行聚合值&lt;/h2&gt;
&lt;p&gt;这个问题示例的对象是将Person对象分组到不同的桶中，其中每个桶构成一个人的出生年份和一个人工作的国家的唯一组合。对于每个组，应计算平均工资。聚合应使用公共ForkJoin池并行计算。&lt;/p&gt;
&lt;p&gt;这是（不可变的）Person类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class Person {
    private final String firstName;
    private final String lastName;
    private final int birthYear;
    private final String country;
    private final double salary;
    public Person(String firstName, 
                  String lastName, 
                  int birthYear, 
                  String country, 
                  double salary) {
        this.firstName = requireNonNull(firstName);
        this.lastName = requireNonNull(lastName);
        this.birthYear = birthYear;
        this.country = requireNonNull(country);
        this.salary = salary;
    }
    public String firstName() { return firstName; }
    public String lastName() { return lastName; }
    public int birthYear() { return birthYear; }
    public String country() { return country; }
    public double salary() { return salary; }
    // equals, hashCode and toString not shown for brevity
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还定义了另一个名为YearCountry的不可变类，把它作为分组键：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class YearCountry {
    private final int birthYear;
    private final String country;
    public YearCountry(Person person) {
        this.birthYear = person.birthYear();
        this.country = person.country();
    }
    public int birthYear() { return birthYear; }
    public String country() { return country; }
    // equals, hashCode and toString not shown for brevity
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了这两个类之后，我们现在可以通过接口定义此问题示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface GroupingBy {
    Map&amp;lt;YearCountry, Double&amp;gt; average(Collection&amp;lt;Person&amp;gt; persons);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令式的解决方案&quot;&gt;5.1.命令式的解决方案&lt;/h3&gt;
&lt;p&gt;实现GroupingBy示例问题的命令式解决方案并非易事。这是问题的一个解决方案：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GroupingByImperative implements GroupingBy {
    @Override
    public Map&amp;lt;YearCountry, Double&amp;gt; average(Collection&amp;lt;Person&amp;gt; persons) {
        final List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;(persons);
        final int threads = ForkJoinPool.commonPool().getParallelism();
        final int step = personList.size() / threads;
        // Divide the work into smaller work items
        final List&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; subLists = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; threads - 1; i++) {
           subLists.add(personList.subList(i * step, (i + 1) * step));
        }
        subLists.add(personList.subList((threads - 1) * step, personList.size()));
        final ConcurrentMap&amp;lt;YearCountry, AverageAccumulator&amp;gt; accumulators = new ConcurrentHashMap&amp;lt;&amp;gt;();
        // Submit the work items to the common ForkJoinPool
        final List&amp;lt;CompletableFuture&amp;lt;Void&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; threads; i++) {
            final List&amp;lt;Person&amp;gt; subList = subLists.get(i);
       futures.add(CompletableFuture.runAsync(() -&amp;gt; average(subList, accumulators)));
        }
        // Wait for completion
        for (int i = 0; i &amp;lt; threads; i++) {
            futures.get(i).join();
        }
        // Construct the result
        final Map&amp;lt;YearCountry, Double&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
        accumulators.forEach((k, v) -&amp;gt; result.put(k, v.average()));
        return result;
    }
    private void average(List&amp;lt;Person&amp;gt; subList, ConcurrentMap&amp;lt;YearCountry, AverageAccumulator&amp;gt; accumulators) {
        for (Person person : subList) {
            final YearCountry bc = new YearCountry(person);
          accumulators.computeIfAbsent(bc, unused -&amp;gt; new AverageAccumulator())
                .add(person.salary());
        }
    }
    private final class AverageAccumulator {
        int count;
        double sum;
        synchronized void add(double term) {
            count++;
            sum += term;
        }
        double average() {
            return sum / count;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明式解决方案-2&quot;&gt;5.2. 声明式解决方案&lt;/h3&gt;
&lt;p&gt;这是一个使用声明性构造实现GroupingBy的解决方案：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GroupingByDeclarative implements GroupingBy {
    @Override
    public Map&amp;lt;YearCountry, Double&amp;gt; average(Collection&amp;lt;Person&amp;gt; persons) {
        return persons.parallelStream()
            .collect(
             groupingBy(YearCountry::new, averagingDouble(Person::salary))
            );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我使用了一些来自Collectors类的静态导入（例如Collectors :: groupingBy）。这不会影响代码指标。&lt;/p&gt;
&lt;h3 id=&quot;分析-1&quot;&gt;5.3.分析&lt;/h3&gt;
&lt;p&gt;SonarQube提供以下分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083137985-1079429875.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083139006-1700725359.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GroupingBy&lt;/code&gt;的代码度量标准如下表所示（通常更低）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Imperative&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Functional&lt;/td&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是它在图表中的值（通常更低）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083139474-1776517701.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现rest接口&quot;&gt;6.实现REST接口&lt;/h2&gt;
&lt;p&gt;在该示例性问题中，我们将为Person对象提供分页服务。出现在页面上的Persons必须满足某些（任意）条件，并按特定顺序排序。该页面将作为不可修改的Person对象列表返回。&lt;/p&gt;
&lt;p&gt;这是一个解决问题的接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Rest {

/**

 * Returns an unmodifiable list from the given parameters.
 *
 * @param persons as the raw input list
 * @param predicate to select which elements to include
 * @param order in which to present persons
 * @param page to show. 0 is the first page
 * @return an unmodifiable list from the given parameters
 */

 List&amp;lt;Person&amp;gt; page(List&amp;lt;Person&amp;gt; persons, 
                   Predicate&amp;lt;Person&amp;gt; predicate,
                   Comparator&amp;lt;Person&amp;gt; order,
                   int page);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面的大小在名为RestUtil的单独工具程序类中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class RestUtil {
    private RestUtil() {}
    public static final int PAGE_SIZE = 50;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令式实现方法&quot;&gt;6.1.命令式实现方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class RestImperative implements Rest {
    @Override
    public List&amp;lt;Person&amp;gt; page(List&amp;lt;Person&amp;gt; persons, 
                Predicate&amp;lt;Person&amp;gt; predicate, 
                  Comparator&amp;lt;Person&amp;gt; order, 
                             int page) {
        final List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (Person person:persons) {
            if (predicate.test(person)) {
                list.add(person);
            }
        }
        list.sort(order);
        final int from = RestUtil.PAGE_SIZE * page;
        if (list.size() &amp;lt;= from) {
            return Collections.emptyList();
        }
        return unmodifiableList(list.subList(from, Math.min(list.size(), from + RestUtil.PAGE_SIZE)));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;声明式解决方法&quot;&gt;6.2.声明式解决方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class RestDeclarative implements Rest {
    @Override
    public List&amp;lt;Person&amp;gt; page(List&amp;lt;Person&amp;gt; persons,
                      Predicate&amp;lt;Person&amp;gt; predicate, 
                        Comparator&amp;lt;Person&amp;gt; order,
                             int page) {
        return persons.stream()
            .filter(predicate)
            .sorted(order)
            .skip(RestUtil.PAGE_SIZE * (long) page)
            .limit(RestUtil.PAGE_SIZE)
           .collect(collectingAndThen(toList(), Collections::unmodifiableList));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分析-2&quot;&gt;6.3.分析&lt;/h3&gt;
&lt;p&gt;SonarQube提供以下分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083140223-396813454.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083141325-1923470922.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rest&lt;/code&gt;的代码度量标准如下表所示（通常更低）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Imperative&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Functional&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是它在图表中的值（通常更低）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083141541-605398939.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-11改进&quot;&gt;7.Java 11改进&lt;/h2&gt;
&lt;p&gt;上面的例子是用Java 8编写的。使用Java 11，我们可以使用LVTI（局部变量类型推断）缩短声明性代码。这会使我们的代码更短，但不会影响代码指标。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public List&amp;lt;Person&amp;gt; page(List&amp;lt;Person&amp;gt; persons,
                         Predicate&amp;lt;Person&amp;gt; predicate, 
                         Comparator&amp;lt;Person&amp;gt; order, 
                         int page) {
    final var list = new ArrayList&amp;lt;Person&amp;gt;();
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与Java 8相比，Java 11包含一些新的收集器。例如，&lt;code&gt;Collectors.toUnmodifiableList&lt;/code&gt;（），它将使我们的声明性Rest解决方案更短：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class RestDeclarative implements Rest {
@Override
public List&amp;lt;Person&amp;gt; page(List&amp;lt;Person&amp;gt; persons,
                         Predicate&amp;lt;Person&amp;gt; predicate, 
                         Comparator&amp;lt;Person&amp;gt; order, 
                         int page) {
    return persons.stream()
        .filter(predicate)
        .sorted(order)
        .skip(RestUtil.PAGE_SIZE * (long) page)
        .limit(RestUtil.PAGE_SIZE)
        .collect(toUnmodifiableList());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，这不会影响代码指标。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;8.摘要&lt;/h2&gt;
&lt;p&gt;三个示例性问题的平均代码度量产生以下结果（通常更低）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083141706-1524480062.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鉴于本文中的输入要求，当我们从命令式构造到声明式构造时，所有代码度量标准都有显着改进。&lt;/p&gt;
&lt;h3 id=&quot;在数据库应用程序中使用声明性构造&quot;&gt;8.1.在数据库应用程序中使用声明性构造&lt;/h3&gt;
&lt;p&gt;为了在数据库应用程序中获得声明性构造的好处，我们使用了&lt;a href=&quot;https://speedment.com/stream/&quot;&gt;Speedment Stream&lt;/a&gt;。 Speedment Stream是一个基于流的Java ORM工具，可以将任何数据库表/视图/连接转换为Java流，从而允许您在数据库应用程序中应用声明性技能。&lt;/p&gt;
&lt;p&gt;您的数据库应用程序代码将变得更好。事实上，针对数据库的Speedment和Spring Boot的分页REST解决方案可能表达如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Stream&amp;lt;Person&amp;gt; page(Predicate&amp;lt;Person&amp;gt; predicate, 
                     Comparator&amp;lt;Person&amp;gt; order, 
                           int page) {
    return persons.stream()
        .filter(predicate)
        .sorted(order)
        .skip(RestUtil.PAGE_SIZE * (long) page)
        .limit(RestUtil.PAGE_SIZE);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Manager&amp;lt;Person&amp;gt; persons&lt;/code&gt;由Speedment提供，并构成数据库表“Person”的句柄，可以通过Spring使用@AutoWired注解。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;9.总结&lt;/h2&gt;
&lt;p&gt;选择声明性命令式解决方案可以大大降低一般代码复杂性，并且可以提供许多好处，包括更快的编码，更好的代码质量，更高的可读性，更少的测试，更低的维护成本等等。&lt;/p&gt;
&lt;p&gt;为了从数据库应用程序中的声明性构造中受益，Speedment Stream是一种可以直接从数据库提供标准Java Streams的工具。&lt;/p&gt;
&lt;p&gt;掌握声明性构造和功能组合是当今任何当代Java开发人员必须的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;8月福利准时来袭，关注公众号&lt;br/&gt;​&lt;br/&gt;后台回复：003即可领取7月翻译集锦哦~&lt;br/&gt;​&lt;br/&gt;往期福利回复：001，002即可领取！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201909/1692986-20190902083142930-1558827498.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:32:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>阅读本文并了解如何使用具有功能组合的声明性代码成为更好的程序员。 在许多情况下，具有功能组合的声明性解决方案提供优于传统命令式代码的代码度。阅读本文并了解如何使用具有功能组合的声明性代码成为更好的程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/11444588.html</dc:identifier>
</item>
<item>
<title>快40岁了，我还要不要继续写代码呢？ - jonlan</title>
<link>http://www.cnblogs.com/jonlan/p/11444581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonlan/p/11444581.html</guid>
<description>&lt;p&gt;正所谓，男怕入错行、女怕嫁错郎，一旦入错行，这意味着你人生方向走错了，职业生涯中会遇到很多不幸和挫折，然后一连串的不顺利，经济收入不理想、给生活带来压力和各种烦恼。其实，每个行业都不容易，关键是你有没有对这个行业兴趣，如果你对这个行业没有兴趣，强迫自己进入这个行业，那肯定你是入错行了。我认为，如果你对这个行业有浓厚的兴趣，我认为跟岁数没有太大的关系。请大家后退一步，我要装逼了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1336993/201909/1336993-20190902082034836-2112000807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对编程有着极大的好奇心及兴趣，使我进入了这个行业。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在学校时，刚刚开始学C语言，竟然能实现一些简单的加减乘除的程序，这让我感到编程非常的神奇，之前也是生活中使用计算器这些东西，但是不知道是怎么实现的，通过学习竟然能使自己通过计算机语言实现了，那真的是妙不可言啊。课程上还学了flash，当时老师演示了通过flash脚本实现鼠标经过按钮、离开按钮的效果，那真的是太神奇了，还有网页制作方面的课程，html，css这些实现的各种效果，实在是太神奇了。就这样，怀着一颗好奇的心，让我对编程产生了兴趣。&lt;/p&gt;
&lt;p&gt;2005年的时候，当时刚刚毕业，非常渴望得到一份编程的工作，于是在招聘网上狂搜跟编程有关的职位，搜出来的都选上，然后投上简历，每天都会收到面试电话，忙的很，成果满满的。虽然每一次面试回来都是同样一个结果，那就是：一周内给你电话。绝大部分都是没有电话的，后来才明白这句话的意思。记得有一次面试回来，第二天接到一个电话，但是不知道是什么电话，然后就去找前一天面试的公司问是不是他们给我的复试电话，人家说不是，我还是不相信，哈哈，想想都可笑。正是因为我太渴望得到编程的工作了，所以每次我面试回来都做了总结，为什么我不能被聘用？于是我找原因，最终我找到了原因。&lt;/p&gt;
&lt;p&gt;一、 没有开发经验。&lt;/p&gt;
&lt;p&gt;大部分都是创业公司，他们不需要的是有经验的人，能一进公司就能为公司创造价值，他们不想花人力、物力、财力来培养一个新手，所以，不要一个没有开发经验的人，是很正常的。&lt;/p&gt;
&lt;p&gt;二、 简历包装的不够好。&lt;/p&gt;
&lt;p&gt;由于没有工作经验，没有开发过项目，所以简历也就缺少这一块，恰恰这两点是最重要的，一个从不了解的人，别人要了解你，就是要通过你的简历。&lt;/p&gt;
&lt;p&gt;所以，经过多次面试失败，我从这两点开始做工作，每次我看完招聘的职位要求，我都针对性的去把要点去熟悉一遍，甚至去实践一次，这样，当我去面试的时候，面试官问我的问题时，我早有准备了，我会很轻松的回答他提出的问题。另外，简历上，我是根据自己最近熟悉的知识点编造一下曾经参考开发过的项目，这样，我的简历就有内容了，不想以前那么空洞，看起来比以前丰富多了。这样，经过一次次的失败，我终于找到了一份网站开发的工作，那个开心啊！编程职业生涯，从此开始。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1336993/201909/1336993-20190902082129514-1389810542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挣外快，让我对编程产生动力，自身的技术水平能力提升的更快。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在2006、2007年的时候，还是PC盛行的时代，也是企业建站的盛行时代，每个企业如果没有自己的网站，就会觉得比同行有网站的低一个档次，就这样，建站的需求就这样产生，因此，建站公司应运而生。我当时就是在一个建站公司从事开发网站的工作，已经工作了两年，开发也有了一定的经验，但是不是很全面。偶尔一次，公司的一位业务员跟我说，有个客户想开发一个网站，问我个人能不能接这个单子，我当时想，程序的编写是没有问题的，但是，前端和美工不行，最后，我还是推掉了。后来想想，我也可以自己学前端、美工啊。于是，我就花了几个月的时间自学，我学会了前端开发，还学会了简单的美工设计，其实都是通过抄袭别人的网站。后来，那位同事到了别的公司上班，偶尔会联系我，问我能不能接外快，可以赚钱，于是我最终我鼓起勇气，接了一单，经过我的努力，我还是完成了我工作生涯的第一个外快项目，虽然钱不多，但是足够我几个月的房租了，经过那一次，我特别有动力，我感觉我到了人生的巅峰，各种想法在脑海翻腾，盘算着一个月接多少单多少单，我每个月就可以多挣多少钱，幻想着终有一天会成为全村子里最有钱的人，哈哈。回想起来，这段时间虽然比较辛苦，但是收获良多，收入这块就不用说的，明摆在那里的，更重要的是我付出的努力比平时多出了一倍，因此，我的技术水平提升的更快，知识面变得更广，从后端编程到前端开发、美工设计、对整个项目的把控，还有服务器的搭建、配置、部署实施，可谓是独当一面。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1336993/201909/1336993-20190902082156761-210749953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术能力水平不断提升，工作经验不断丰富，工资也相应提高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一份工作时，对工资要求根本就没有要求，只求有工作，积累经验，那时候工资仅仅1100元/月，除了房租，每个月开支，月底也所剩无几，基本算是月光族了。随着能力的提升、工作经历的不断丰富，原来的工资待遇肯定不能满足自己的要求，后来找到第二家公司，待遇1800元/月，当时非常开心，上班一年左右，由于公司经营不好，迫不得已，找了第三份工作，工资2500元/月，真是太开心了，第四份工作待遇3500元/月，第五份工作6500元/月，这一跃，连我自己都有点心虚，感觉自己的付出和回报不成比例，太虚了，每个月领工资时总感觉心里不踏实，于是，在工作上，我也主动加班加点的，目的就是为了平衡心态。前面几年跳的比较频繁，接下来都是基本两年一跳，因为，通过跳槽工资会比呆在本公司提升更快，这是规律，不过太频繁也不好，因为大公司要看你的忠诚度，小公司跳频点也无所谓。第六份工作12000元/月，当时都不敢相信自己，感觉这是我职业生涯最高待遇的一份工作了。前面几年找工作都是靠投简历，后面基本上都是靠朋友介绍，这是因为在平时业余做兼职时积累出来的人脉，平时帮朋友免费做一些项目，并且按时保质保量完成，也就这样建立了信任感，朋友介绍的工作自然就不用怎么面试了，直接上班，这也算是一种回报吧。第七份工作25000元/月，这真是应验了平时口头中说的工作顺利、事业步步高升啊，哈哈。第八份工作到现在，工资就更高了，这里不说了，生活还可以，反正房子也有了，车子也有了，问我要电话号码的美女也越来越多了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1336993/201909/1336993-20190902082438225-2069601295.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快40&lt;/strong&gt;&lt;strong&gt;岁了，我还要不要继续写代码呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这十多年的职业生涯中，一路走来，我自己觉得算是比较幸运的，也是比较顺利的，虽然比不起那些大公司年薪过百万的高管，但是对于我个人，我很满足，我现在还在坚守在第一线写代码，这个年纪了，我是不是应该转行或者往管理方向发展？其实，每个行业都一样，如果你在一个领域不够精通，你只是泛泛之辈，你是无法立足的，很简单，就拿玩游戏来说，你如果把一款游戏玩得“出神入化”，你可能有资本去跟别人玩，如果你什么游戏都会一点点，那你根本跟别人玩不了。快40 岁还写不写代码，不是问题，是不是还依靠写代码挣钱，也不是问题。关键在于你热不热爱写代码这事情，以及你写的是什么代码？如果你在写代码中没有收获任何乐趣，不用 40 岁，20 来岁写代码就是一个悲剧。做自己喜欢做的事情，又有钱挣，何乐而不？从现在开始，我注册了一个公众号“程序员之事”，准备跟各位分享相关技术文章，欢迎朋友们关注，一起交流，一起学习，一起进步。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:31:00 +0000</pubDate>
<dc:creator>jonlan</dc:creator>
<og:description>快40岁了，我还要不要继续写代码呢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jonlan/p/11444581.html</dc:identifier>
</item>
<item>
<title>一文看尽Java-Thread - 大魔王先生</title>
<link>http://www.cnblogs.com/wtzbk/p/11443271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtzbk/p/11443271.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;主要分成两部说起:Thread源码解读和常见面试题解答，废话不多说开始；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;二、源码解读&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     首先看下构造函数，构造函数都是通过调用init方法对属性进行初始化，主要是对线程组、线程名字、栈大小等信息进行初始化；init内部通过调用currentThread本地方法，获取当前的线程，这个本地方法封装在JVM中,有兴趣的可以看下这个这个链接查找下JVM实现&lt;a href=&quot;https://hg.openjdk.java.net/jdk8u&quot;&gt;https://hg.openjdk.java.net/jdk8u&lt;/a&gt;，接下来对ThreadGroup的判断，如果没有传入线程组的话， 第一是使用SecurityManager中的ThreadGroup， 如果从SecurityManager 中获取不到ThreadGroup()， 那么就从当前线程中获取线程组，最后做了检验和些参数的赋值，整体上相对比较简单；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ea92d419-150b-40ad-8b18-8782cc1a16f0')&quot; readability=&quot;52.5&quot;&gt;&lt;img id=&quot;code_img_closed_ea92d419-150b-40ad-8b18-8782cc1a16f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ea92d419-150b-40ad-8b18-8782cc1a16f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ea92d419-150b-40ad-8b18-8782cc1a16f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ea92d419-150b-40ad-8b18-8782cc1a16f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;100&quot;&gt;
&lt;pre&gt;
 
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(ThreadGroup g, Runnable target, String name,
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize) {
      init(g, target, name, stackSize, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(ThreadGroup g, Runnable target, String name,
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize, AccessControlContext acc) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name cannot be null&quot;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name.toCharArray();
      Thread parent &lt;/span&gt;=&lt;span&gt; currentThread();
      SecurityManager security &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (g == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Determine if it's an applet or not &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If there is a security manager, ask the security manager
             what to do. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (security != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
              g &lt;/span&gt;=&lt;span&gt; security.getThreadGroup();
          }
          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If the security doesn't have a strong opinion of the matter
             use the parent thread group. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (g == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
              g &lt;/span&gt;=&lt;span&gt; parent.getThreadGroup();
          }
      }
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; checkAccess regardless of whether or not threadgroup is
         explicitly passed in. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      g.checkAccess();
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       * Do we have the required permissions?
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (security != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCCLOverridden(getClass())) {
              security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
          }
      }
      g.addUnstarted();
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.group =&lt;span&gt; g;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.daemon =&lt;span&gt; parent.isDaemon();
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.priority =&lt;span&gt; parent.getPriority();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (security == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; isCCLOverridden(parent.getClass()))
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contextClassLoader =&lt;span&gt; parent.getContextClassLoader();
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
          &lt;span&gt;this&lt;/span&gt;.contextClassLoader =&lt;span&gt; parent.contextClassLoader;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inheritedAccessControlContext =&lt;span&gt;
              acc &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; acc : AccessController.getContext();
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
      setPriority(priority);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;span&gt;
              ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Stash the specified stack size in case the VM cares &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.stackSize =&lt;span&gt; stackSize;
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Set thread ID &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      tid &lt;/span&gt;=&lt;span&gt; nextThreadID();
  }
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread() {
      init(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &quot;Thread-&quot; + nextThreadNum(), 0&lt;span&gt;);
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread(Runnable target) {
      init(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, target, &quot;Thread-&quot; + nextThreadNum(), 0&lt;span&gt;);
  }
  Thread(Runnable target, AccessControlContext acc) {
      init(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, target, &quot;Thread-&quot; + nextThreadNum(), 0&lt;span&gt;, acc);
  }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程名&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread(String name) {
      init(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, name, 0&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程组和线程名&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread(ThreadGroup group, String name) {
      init(group, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, name, 0&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程任务，线程名&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread(Runnable target, String name){
      init(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, target, name, 0&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程组， 线程任务， 线程名 ，栈大小&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; Thread(ThreadGroup group, Runnable target, String name, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize) {
      init(group, target, name, stackSize);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt; 接下来看下主要的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5f74ec5d-1bc0-483e-9c16-207d62d15a9a')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_5f74ec5d-1bc0-483e-9c16-207d62d15a9a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5f74ec5d-1bc0-483e-9c16-207d62d15a9a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5f74ec5d-1bc0-483e-9c16-207d62d15a9a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5f74ec5d-1bc0-483e-9c16-207d62d15a9a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类加载的时候，调用本地的注册本地方静态方法， 这个方法是本地方法&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerNatives();
  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
      registerNatives();
  }
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;  name[];
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;            priority;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Thread         threadQ;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;           eetop;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Whether or not to single_step this thread. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;     single_step;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Whether or not the thread is a daemon thread. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设设置这个线程是否是守护线程&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;     daemon = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; JVM state &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;     stillborn = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; What will be run. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要执行的run方法的对象&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Runnable target;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The group of this thread &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个线程的线程组&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadGroup group;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The context ClassLoader for this thread &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个线程的上下文类加载器&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ClassLoader contextClassLoader;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The inherited AccessControlContext of this thread &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccessControlContext inheritedAccessControlContext;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; For autonumbering anonymous threads. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadInitNumber;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextThreadNum() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; threadInitNumber++&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ThreadLocal values pertaining to this thread. This map is maintained
   * by the ThreadLocal class. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ThreadLocal.ThreadLocalMap threadLocals &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * InheritableThreadLocal values pertaining to this thread. This map is
   * maintained by the InheritableThreadLocal class.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ThreadLocal.ThreadLocalMap inheritableThreadLocals &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * The requested stack size for this thread, or 0 if the creator did
   * not specify a stack size.  It is up to the VM to do whatever it
   * likes with this number; some VMs will ignore it.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给这个线程设置的栈的大小,默认为0 &lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * JVM-private state that persists after native thread termination.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nativeParkEventPointer;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   * Thread ID
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程id&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; tid;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; For generating thread ID &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; threadSeqNumber;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Java thread status for tools,
   * initialized to indicate thread 'not yet started'
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadStatus = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nextThreadID() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ++&lt;span&gt;threadSeqNumber;
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * The argument supplied to the current call to
   * java.util.concurrent.locks.LockSupport.park.
   * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
   * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Object parkBlocker;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The object in which this thread is blocked in an interruptible I/O
   * operation, if any.  The blocker's interrupt method should be invoked
   * after setting this thread's interrupt status.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Interruptible blocker;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object blockerLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; blockedOn(Interruptible b) {
      &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (blockerLock) {
          blocker &lt;/span&gt;=&lt;span&gt; b;
      }
  }
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * The minimum priority that a thread can have.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程执行的最低优先级 为1&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MIN_PRIORITY = 1&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * The default priority that is assigned to a thread.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程默认的执行优先级为 5&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORM_PRIORITY = 5&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * The maximum priority that a thread can have.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程执行的最高的优先级为 10&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_PRIORITY = 10;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt;最后介绍下方法的作用和线程状态，源码都比较简单，没必进行过多的介绍，都是通过调用JVM的本地方法实现；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190901200219214-975485936.png&quot; alt=&quot;&quot; width=&quot;874&quot; height=&quot;257&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    线程状态：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190901201438092-1096669849.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三&lt;strong&gt;&lt;strong&gt;、常见面试题&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.线程与进程的区别?&lt;/p&gt;
&lt;p&gt;       进程是资源分配最小的单位，线程是CPU调度最小的单位；&lt;/p&gt;
&lt;p&gt;       线程属于进程，共享进程分配的资源；&lt;/p&gt;
&lt;p&gt;       进程属于抢占式调度，资源不相互共享；&lt;/p&gt;
&lt;p&gt;    2.start和run的区别?&lt;/p&gt;
&lt;p&gt;      run是Thread的一个普通的方法；&lt;/p&gt;
&lt;p&gt;      start方法会创建一个新的子线程并启动；&lt;/p&gt;
&lt;p&gt;    3.sleep与wait的区别?&lt;/p&gt;
&lt;p&gt;      sleep是Thread方法，wait是Object的方法；&lt;/p&gt;
&lt;p&gt;      wait方法只能在synchroized方法或者块中使用；&lt;/p&gt;
&lt;p&gt;      Thread.sleep只会让出CPU，不会改变锁的行为；&lt;/p&gt;
&lt;p&gt;      Object.wait不仅会让出CPU，同时还会释放占有同步资源的锁；&lt;/p&gt;
&lt;p&gt;    4.线程状态的转化?&lt;/p&gt;
&lt;p&gt;     图中将&lt;span&gt;WAITING&lt;/span&gt;&lt;span&gt; 和&lt;/span&gt;&lt;span&gt;TIMED_WAITING&lt;/span&gt;&lt;span&gt; 两个状态合并为&lt;/span&gt;&lt;span&gt;WAITING&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;，没有分开，大家不要搞错；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201909/1005447-20190901202849577-807896020.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;633&quot;/&gt;&lt;/p&gt;


&lt;p&gt;     5.如何处理线程的返回值?&lt;/p&gt;
&lt;p&gt;        主线程等待法，使用while等待主线程返回值；&lt;/p&gt;
&lt;p&gt;        join阻塞当前线程以等待子线程；&lt;/p&gt;
&lt;p&gt;        通过FuTureTask获取子线程的返回值；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f06f2795-3eeb-409d-88b2-5c5063c35b00')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f06f2795-3eeb-409d-88b2-5c5063c35b00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f06f2795-3eeb-409d-88b2-5c5063c35b00&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f06f2795-3eeb-409d-88b2-5c5063c35b00',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f06f2795-3eeb-409d-88b2-5c5063c35b00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyCallable &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;String&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        String value&lt;/span&gt;=&quot;test&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;start&quot;&lt;span&gt;);
        Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;end&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;

    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FutureTaskDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] main) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {
        FutureTask&lt;/span&gt;&amp;lt;String&amp;gt; futureTask=&lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyCallable());

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(futureTask).start();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;futureTask.isDone()){
            System.out.println(&lt;/span&gt;&quot;waiting&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;return&quot;+&lt;span&gt;futureTask.get());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        通过线程池获取返回值； &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d5a7447d-47fc-4d45-bb01-5777b4083603')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d5a7447d-47fc-4d45-bb01-5777b4083603&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d5a7447d-47fc-4d45-bb01-5777b4083603&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d5a7447d-47fc-4d45-bb01-5777b4083603',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d5a7447d-47fc-4d45-bb01-5777b4083603&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolDemo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        ExecutorService executorService&lt;/span&gt;=&lt;span&gt; Executors.newCachedThreadPool();
        Future&lt;/span&gt;&amp;lt;String&amp;gt; futureTask=executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyCallable());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;futureTask.isDone()){
            System.out.println(&lt;/span&gt;&quot;wait&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(futureTask.get());
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex){
            ex.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException ex){
            ex.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            executorService.shutdown();
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    6.Thread和Runnable？&lt;/p&gt;
&lt;p&gt;       Thread是类，Runnable是接口，Thread是Runnable实现；&lt;/p&gt;
&lt;p&gt;       类的继承单一原则，Runnable是更高层次的抽象；&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;四、结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;span&gt;欢迎大家加群438836709！欢迎大家关注我！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1005447/201906/1005447-20190620221533393-1847070636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:29:00 +0000</pubDate>
<dc:creator>大魔王先生</dc:creator>
<og:description>一、前言 主要分成两部说起:Thread源码解读和常见面试题解答，废话不多说开始； 二、源码解读 首先看下构造函数，构造函数都是通过调用init方法对属性进行初始化，主要是对线程组、线程名字、栈大小等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wtzbk/p/11443271.html</dc:identifier>
</item>
<item>
<title>设计模式之模板方法模式实战解析 - 安卓小煜</title>
<link>http://www.cnblogs.com/nesger/p/11444583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/11444583.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文微信公众号「AndroidTraveler」首发。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;最近在看《设计模式之禅》，为了能够更加深入的理解设计模式，达到学以致用。&lt;br/&gt;这边记录一下自己的一些感受和看法，并结合具体代码实战来进行说明。&lt;/p&gt;
&lt;h3 id=&quot;模板方法模式&quot;&gt;模板方法模式&lt;/h3&gt;
&lt;p&gt;但凡和设计模式挂上钩，我们总是会觉得「高不可攀」。&lt;br/&gt;然而实际上，设计模式是基于大量实际代码的经验总结，它来自于实际的代码。&lt;br/&gt;与其说「高不可攀」，其实它反而是比较「接地气」。&lt;br/&gt;而模板方法模式相信你看完本篇文章之后，会发现，原来这就是模板方法模式，然后就去看你之前的代码了。&lt;/p&gt;
&lt;h3 id=&quot;小例子初识模板方法模式&quot;&gt;小例子初识模板方法模式&lt;/h3&gt;
&lt;p&gt;理解设计模式最好的方法就是通过项目开发中的实际场景来说明。&lt;/p&gt;
&lt;p&gt;大家做 Android 开发的时候写 Activity 应该都会看到下面类似代码吧？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void getIntents() {
    // 从 Intent 获取传递过来的一些参数，设置到属性中
}

private void findViewById() {
    // 通过 findViewById 来初始化各个组件
}

private void setViews() {
    // 给组件设置监听或者初始状态
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我每个界面都这样写，那么重复代码太多了，很没必要。&lt;br/&gt;虽然每个方法具体的逻辑不一样，但是都有这些操作。&lt;/p&gt;
&lt;p&gt;这个时候我们第一个想法就是&lt;strong&gt;继承&lt;/strong&gt;，抽取出一个 BaseActivity。&lt;br/&gt;然后将这些通用代码都放到了 BaseActivity 里面，子类再来覆写就可以了。&lt;/p&gt;
&lt;p&gt;但是还有一个问题，那就是，我每次都需要写下面代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;getIntents();
findViewById();
setViews();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尤其是通用代码多的时候，有时候手误可能导致某些界面这三个方法调用顺序还不一样。&lt;br/&gt;那怎么办呢？我们可以抽取出一个方法，这个方法代表了这三个方法统一的调用顺序，这样就不怕手误写错了。&lt;br/&gt;而这个方法就是我们的&lt;strong&gt;模板方法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class BaseActivity extends Activity {
    /**
     * 从 Intent 获取传递过来的一些参数，设置到属性中
     */
    protected abstract void getIntents();

    /**
     * 通过 findViewById 来初始化各个组件
     */
    protected abstract void findViewById();

    /**
     * 给组件设置监听或者初始状态
     */
    protected abstract void setViews();

    /**
     * 模板方法
     */
    final public void init() {
        getIntents();
        findViewById();
        setViews();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我后面的 Activity 都可以继承这个 BaseActivity，然后只需要调用 init 方法即可。&lt;br/&gt;至于不同的 Activity 的逻辑我再在三个方法里面各自实现即可。&lt;/p&gt;
&lt;h3 id=&quot;钩子方法&quot;&gt;钩子方法&lt;/h3&gt;
&lt;p&gt;一听到这个词，是不是觉得有点「高大上」，似乎很 NB？&lt;br/&gt;然而，听完我后面的讲述，你内心估计&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/29/16cdd2f75dd6ac5d?w=255&amp;amp;h=255&amp;amp;f=png&amp;amp;s=41949&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们上面的方法里面，并不是所有的 Activity 都有其他 Activity 传递数据过来的，因此 getIntents 这个方法不一定所有子类都要调用。&lt;br/&gt;这个时候我们可以提供一个钩子方法，改动部分代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 模板方法
 */
final public void init() {
    if (isGetIntents()) {
        getIntents();
    }
    findViewById();
    setViews();
}

/**
 * 钩子方法，是否需要设置数据，默认为 true
 * @return
 */
protected boolean isGetIntents() {
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过钩子方法，当我们默认需要获取数据时，什么都不用改动，如果我们不需要获取数据，只需要覆写我们的钩子方法 isGetIntents 并返回 false 即可。&lt;/p&gt;
&lt;p&gt;好了，有了初步的印象之后，接下来就正式的加深了解吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/22/16add3eca3d46bbf?w=640&amp;amp;h=480&amp;amp;f=jpeg&amp;amp;s=26634&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.&lt;br/&gt;定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的说就是父类定义了一个模板方法，在这个模板方法里面有一些特定的步骤。具体的步骤实现留给子类去处理。&lt;/p&gt;
&lt;p&gt;父类的模板方法保持了各个子类的共性，模板方法里面的步骤使得每个子类都有自己的个性。&lt;/p&gt;
&lt;h3 id=&quot;通用代码实现&quot;&gt;通用代码实现&lt;/h3&gt;
&lt;p&gt;父类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractPatternClass {
    /**
     * 基本方法，模板方法里面调用
     */
    protected abstract void firstModule();
    /**
     * 基本方法，模板方法里面调用
     */
    protected abstract void secondModule();

    /**
     * 模板方法，多个基本方法组合
     */
    final public void templateMethod() {
        firstModule();
        secondModule();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体子类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConcreteClass extends AbstractPatternClass {
    @Override
    protected void firstModule() {
        // TODO 子类实现自己的逻辑
    }

    @Override
    protected void secondModule() {
        // TODO 子类实现自己的逻辑
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景使用类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PatternTest {
    public static void main(String[] args) {
        AbstractPatternClass abstractPatternClass = new ConcreteClass();
        // 调用模板方法
        abstractPatternClass.templateMethod();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;钩子方法我们上面已经说过了，相信聪明的你知道如何使用，这里就不再赘述了。&lt;/p&gt;
&lt;h3 id=&quot;注意点&quot;&gt;注意点&lt;/h3&gt;
&lt;p&gt;父类中的基本方法尽量设计为 protected 类型，符合迪米特法则。&lt;br/&gt;父类中的模板方法一般设置为 final，不允许子类覆写。这样的目的一个是为了避免子类恶意操作，一个是为了模板的共性。&lt;/p&gt;
&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;当你在写代码经常用到&lt;strong&gt;复制和粘贴快捷键&lt;/strong&gt;时，你就要考虑是不是可以进行抽取。&lt;br/&gt;当你修改一个地方的时候，发现其他地方也要连带修改，也需要考虑一下。&lt;br/&gt;多个子类有公共方法，并且逻辑基本相同。&lt;br/&gt;复杂的一些算法之类的，可以让子类通过基本方法传递一些参数，核心逻辑放在模板方法里面。&lt;br/&gt;重构项目的时候，也可以考虑一下把相同代码抽取到父类，通过钩子方法定制化模板。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后一点就是注意不要滥用设计模式，不要为了设计而设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;br/&gt;设计模式之禅（第2版）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/5/16bc08e14696aba3?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=231181&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:29:00 +0000</pubDate>
<dc:creator>安卓小煜</dc:creator>
<og:description>本文微信公众号「AndroidTraveler」首发。 背景 最近在看《设计模式之禅》，为了能够更加深入的理解设计模式，达到学以致用。 这边记录一下自己的一些感受和看法，并结合具体代码实战来进行说明。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nesger/p/11444583.html</dc:identifier>
</item>
<item>
<title>持续集成高级篇之Jenkins Pipeline git拉取 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11444579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11444579.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;pipeline中拉取远程git仓库&quot;&gt;PipeLine中拉取远程git仓库&lt;/h2&gt;
&lt;p&gt;前面讲自由式任务的时候,我们可以看到通过自由式job里提供的图形界面配置git拉取非常方便的,实际上使用PipeLine也并不复杂.这一节我们展示一下如何在PipeLine任务中拉取git仓库代码.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node{
    stage(&quot;check out&quot;){
         git  credentialsId: '3c210def-c000-4e2a-9b2d-838986a6b172', url: 'https://github.com/mrtylerzhou/gitShow.git'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码非常简单,通过使用git关键字,配置&lt;code&gt;credentialsId&lt;/code&gt;和&lt;code&gt;url&lt;/code&gt;后Jenkins就可以拉取远程git仓库代码了.Url很好理解,即为远程仓库的地址.这里比较费解的是&lt;code&gt;credentialsId&lt;/code&gt;是什么,如何设置它?其实也非常简单,前面讲自由式任务的时候我们讲过如何在jenkins里添加添加一个git用户名和密码,这里的&lt;code&gt;credentialsId&lt;/code&gt;即为我们创建的包含用户名和密码的用户信息的id(这个id是jenkins自动生成的)这里通过这个id,Jenkins便可以找到这个用户名和密码.&lt;/p&gt;
&lt;h2 id=&quot;创建一个用户名和密码&quot;&gt;创建一个用户名和密码&lt;/h2&gt;
&lt;p&gt;要创建一个用户名和密码也不是非常复杂,我们在Jenkins主面板左侧导航面板里找到&lt;code&gt;Credentials&lt;/code&gt;,点击进入,便可以看到以下一个面板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190902082402091-488820647.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里左侧&lt;code&gt;Credentials&lt;/code&gt;下面有一个&lt;code&gt;System&lt;/code&gt;我们点击一下,此时面板中央位置如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190902082349742-1660669013.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击这个链接进入,此时左侧会出现一个添加&lt;code&gt;Credentials&lt;/code&gt;按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190902082341309-9686011.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击便会出现一个可以设置用户名和密码的界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201909/811801-20190902082332132-956807256.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示,&lt;code&gt;Kind&lt;/code&gt;使用默认的,添加一个用户名和密码.然后添加用户名和密码,此时id可以手输入,如果留空则Jenkins会自动生成一个.Description为一个简短描述,用户名和密码很多时方便区分.&lt;/p&gt;
&lt;p&gt;添加成功后我们想要看到这条记录的id,点击板右侧的搬手螺丝刀图标就可以看到id了.我们把这个id复制到 PipeLine里&lt;code&gt;credentialsId&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;添加一个ssh-key&quot;&gt;添加一个ssh key&lt;/h2&gt;
&lt;p&gt;使用用户名和密码容易泄密,实际工作中常常使用ssh方式登陆,这里对如何生成ssh key,如何在远程仓库中添加公钥不再赘述,不熟悉的童鞋可以参考前面章节或者官方帮助文档以及在互联网上搜索相关材料.这里介绍下如何把ssh 私钥添加到Jenkins里,以便Jenkins使用ssh连接远程仓库.&lt;/p&gt;
&lt;p&gt;添加私钥类似以上添加用户名密码,只是添加用户名密码时&lt;code&gt;Kind&lt;/code&gt;选项使用的是默认的选择,这里&lt;code&gt;Kind&lt;/code&gt;下拉一下,选择&lt;code&gt;SSH username with private key&lt;/code&gt;,用户名即为你的git账户用户名,&lt;code&gt;private key&lt;/code&gt;勾选&lt;code&gt;Enter directly&lt;/code&gt;把我们本机的私钥添复制到框里面.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意的是ssh和http地址是不一样的,一定要注意.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;把代码拉到指定位置&quot;&gt;把代码拉到指定位置&lt;/h2&gt;
&lt;p&gt;Jenkins默认会的把项目拉到Jenkins安装目录下&lt;code&gt;Workspace+项目名&lt;/code&gt;的目录下面,很多时候由于一些原因我们可能希望改变这一行为,把项目拉到自定义的一个目录下面,这时候可以使用&lt;code&gt;dir&lt;/code&gt;函数,然后把要执行的代码写在&lt;code&gt;dir&lt;/code&gt;函数代码块内.示例代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node{
    stage(&quot;check out&quot;){
        dir(&quot;projdir&quot;){
            git  credentialsId: '3c210def-c000-4e2a-9b2d-838986a6b172', url: 'https://github.com/mrtylerzhou/gitShow.git'
        }
         
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上语句执行后,可以看到jenkins会把代码拉到&lt;code&gt;Workspace+项目名+projdir&lt;/code&gt;的目录下,当然也可以指定绝对路径.&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:26:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' PipeLine中拉取远程git仓库 前面讲自由式任务的时候,我们可以看到通过自由式job里提供的图形界面配置git拉取非常方便的,实际上使用PipeLine也并不复杂.这一节我们展示一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11444579.html</dc:identifier>
</item>
<item>
<title>Swifter.Json 可能是 .Net 平台迄今为止性能最佳的 Json 序列化库【开源】 - 陈鑫伟</title>
<link>http://www.cnblogs.com/Dogwei/p/11444426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dogwei/p/11444426.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;a1d02-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Json 简介&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;arup3-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;arup3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Json (JavaScript Object Notation) 是一种轻量级的数据交换格式。它作为目前最欢迎的数据交换格式，也是各大开源贡献者的必争之地，如：阿里爸爸的 fastjson(java)，腾讯的 rapidjson(c++) 等。但 .Net 却没有得到大厂的青睐，在 Swifter.Json 之前 .Net 的 Json 解析库都不完美。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;277q5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json 简介&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;duhb-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;6.4&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;duhb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json 是 .Net 平台上一个功能强大，简单易用，稳定及高性能的 Json 序列化和反序列化工具。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;acku-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json 强大之处&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;fht3p-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fht3p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;1：支持 .Net 已知所有对象结构，包括深度循环结构，引用类型属性等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;comk2-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;comk2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;2：支持几乎所有常用的数据类型，并多方案轻松自定义类型的序列化行为，后续将持续增加。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;b4rlq-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b4rlq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;3：支持缩进 Json，忽略 Null 值 0 值 &quot;&quot; 值等，支持使用 { &quot;$Ref&quot; : &quot;#/Target&quot; } 表示重复引用，或将循环引用序列化为 Null 等，支持设置最大深度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;e08l1-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e08l1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;4：支持 .Net Core 2.0+，.Net Framework 2.0+，.Net Standard 2.0+，Xamarin，Unify，Mono 等平台。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;1720a-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1720a-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;5：Swifter.Json 几乎是无 BUG 的，因为它已有多个上线项目在运行，且每次发布都会经过我们自己单元测试和 Newtonsoft.Json 和 Spanjson 的单元测试来确保它的稳定性，如果您遇到了问题，可以在 Github 上发布一个 issue，我们会尽力帮助您。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;elrmm-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;elrmm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;6：完整全面的 API 中文文档，每个公开的类型和方法都有中文说明，也有 Github 上的 Wiki 文档 (现主要维护文档)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;biu08-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;为什么要重复造轮子？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;f0uof-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f0uof-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;目前 .Net 平台上的 Json 库都存在一些明显的缺点：一些虽然简单易用，但是性能不高，一些性能高却不稳定，稳定的有性能低且过于复杂。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;1ifqc-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1ifqc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们迫切需要一个强大，稳定，高性能且易于使用的 Json 序列化工具！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;1ivkp-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1ivkp-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以 Swifter.Json 被制作出来了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;4dgcu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json 的库引用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;2hpam-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2hpam-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Core：这是一个工具包，它可以为类库开发者提供巨大的帮助，Swifter.Json 基于它。它提供了高效的数据读写 API，高效的数学算法以及 .Net CLR 无数据信息，以及解决各平台版本之间的差异问题等，后期我们将基于这个库开发一个 Swifter.MessagePack (已开发好，待发布)。这个库 300~400KB 之间(各平台有差异)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;10i1u-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;10i1u-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Unsafe：这是一个 IL 代码编写的库，因为提供的操作与 System.Runtime.ComplierServices.Unsafe 提供的功能类似，所以取名叫 Swifter.Unsafe，这个库大慨 5KB。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;ljqs-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ljqs-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json：实现 Swifter.Json 的 IValueReader, IValueWriter 即实现了对任意对象执行序列化和反序列化，主要的代码在 JsonSerializer (实现 IValueWriter) 和 JsonDeserializer (实现 IValueReader)中，JsonFormatter 提供 API重载，现在已支持全异步 API。这个库大概 86KB。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;c5rur-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Swifter.Json 的性能&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;38g1p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;.Net Core 3.0 Preview 7 的测试结果&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527310/201909/1527310-20190902004548026-1590153850.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;32thv-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;32thv-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;相比 Newtonsoft.Json 提高了 5 到 10 倍左右，虽然目前已有许多 Json 库号称高性能，但实际上我认可的除Swifter.Json只有 Spanjson，但它缺点太明显，仅支持 .Net Core 2.1+ 且稳定性不好。如果您不愿意使用 Swifter.Json，那本人建议您使用 Newtonsoft.Json，毕竟它除了性能之外全是优点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;4quv1-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4quv1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;还有一个与性能密切相关一个特性：小分配。顾名思义就是分配的内存大小，举例：当程序在执行反序列化数组操作时，因为对数组长度未知，所以多数 Json 工具都在这个过程中反复的创建更大的数组，这个过程相当耗时且耗资源。Swifter.Json 已使用池技术完美解决这个问题。Spanjson 也使用 Core 上的 ArrayPool 池解决，所以我为 Spanjson 点了小星星。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bn83v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;简单使用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bn83v-0-0&quot;&gt;&lt;span data-offset-key=&quot;bn83v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527310/201909/1527310-20190902004602414-233208480.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;3rq64-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3rq64-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;更多使用方法和文档请上 Github 查看 Wiki。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-offset-key=&quot;dc7rl-0-0&quot; data-block=&quot;true&quot; data-editor=&quot;a91dj&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;dc7rl-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;最后附上一张我们对 .Net 平台已有的 Json 库一个简单的评价&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dc7rl-0-0&quot;&gt;&lt;span data-offset-key=&quot;dc7rl-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1527310/201909/1527310-20190902004616772-1869679770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;uho5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;感谢阅读！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Sep 2019 00:03:00 +0000</pubDate>
<dc:creator>陈鑫伟</dc:creator>
<og:description>Json 简介 Json (JavaScript Object Notation) 是一种轻量级的数据交换格式。它作为目前最欢迎的数据交换格式，也是各大开源贡献者的必争之地，如：阿里爸爸的 fastj</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dogwei/p/11444426.html</dc:identifier>
</item>
<item>
<title>快速了解会话管理三剑客cookie、session和JWT - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11444510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11444510.html</guid>
<description>&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。&lt;/p&gt;

&lt;p&gt;三者都是应用在web中对http无状态协议的补充，达到状态保持的目的&lt;/p&gt;
&lt;p&gt;cookie：cookie中的信息是以键值对的形式储存在浏览器中，而且在浏览器中可以直接看到数据。下图为safari的cookie截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190902072324946-2094518590.png&quot; alt=&quot;cookie&quot;/&gt;&lt;/p&gt;
&lt;p&gt;session：session存储在服务器中，然后发送一个cookie存储在浏览器中，cookie中存储的是session_id，之后每次请求服务器通过session_id可以获取对应的session信息&lt;/p&gt;
&lt;p&gt;JWT：JWT存储在浏览器的storage或者cookie中。由服务器产生加密的json数据包括：header，payload和signature三部分组成。header中通常来说由token的生成算法和类型组成；payload中则用来保存相关的状态信息；signature部分由header，payload，secret_key三部分加密生成。&lt;br/&gt;注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。下图为官网的截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190902072326552-1527419929.png&quot; alt=&quot;JWT&quot;/&gt;&lt;/p&gt;

&lt;p&gt;cookie:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结构简单。cookie是一种基于文本的轻量结构，包含简单的键值对。&lt;/li&gt;
&lt;li&gt;数据持久。虽然客户端计算机上cookie的持续时间取决于客户端上的cookie过期处理和用户干预，cookie通常是客户端上持续时间最长的数据保留形式。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;大小受到限制。大多数浏览器对 cookie 的大小有 4096 字节的限制，尽管在当今新的浏览器和客户端设备版本中，支持 8192 字节的 cookie 大小已愈发常见。&lt;/li&gt;
&lt;li&gt;非常不安全。cookie将数据裸露在浏览器中，这样大大增大了数据被盗取的风险，所有我们不应该将中要的数据放在cookie中，或者将数据加密处理。&lt;/li&gt;
&lt;li&gt;容易被csrf攻击。可以设置csrf_token来避免攻击。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;session：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;session的信息存储在服务端，相比于cookie就在一定程度上加大了数据的安全性；相比于jwt方便进行管理，也就是说当用户登录和主动注销，只需要添加删除对应的session就可以，这样管理起来很方便。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;session存储在服务端，这就增大了服务器的开销，当用户多的情况下，服务器性能会大大降低。&lt;/li&gt;
&lt;li&gt;因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。&lt;/li&gt;
&lt;li&gt;用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，会限制负载均衡和集群水平拓展的能力。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;JWT：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为json的通用性，jwt可以支持跨语言请求，像JAVA,JavaScript,PHP等很多语言都可以使用。&lt;/li&gt;
&lt;li&gt;因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。&lt;/li&gt;
&lt;li&gt;便于传输，JWT的构成非常简单，字节占用很小，所以它是非常便于传输的。&lt;/li&gt;
&lt;li&gt;不需要在服务端保存会话信息, 利于服务器横向拓展。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;登录状态信息续签问题。比如设置token的有效期为一个小时，那么一个小时后，如果用户仍然在这个web应用上，这个时候当然不能指望用户再登录一次。目前可用的解决办法是在每次用户发出请求都返回一个新的token，前端再用这个新的token来替代旧的，这样每一次请求都会刷新token的有效期。但是这样，需要频繁的生成token。另外一种方案是判断还有多久这个token会过期，在token快要过期时，返回一个新的token。&lt;/li&gt;
&lt;li&gt;用户主动注销。JWT并不支持用户主动退出登录，客户端在别处使用token仍然可以正常访问。为了支持注销，我的解决方案是在注销时将该token加入到服务器的redis黑名单中。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这两个概念总有人用混淆，所以一起介绍了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OAuth2是一种授权框架，用在使用第三方账号登录的情况（比如使用weibo, qq, github登录某个app）&lt;br/&gt;JWT是一种认证协议，用在前后端分离，需要简单的对后台API进行保护时使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;无论使用哪种方式切记用HTTPS来保证数据的安全性；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201909/1327889-20190902072326773-789833783.gif&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Sep 2019 23:23:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>更多内容，欢迎关注微信公众号：全菜工程师小辉。公众号回复关键词，领取免费学习资料。 存储位置 三者都是应用在web中对http无状态协议的补充，达到状态保持的目的 cookie：cookie中的信息是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11444510.html</dc:identifier>
</item>
<item>
<title>.Net Core 2.2与Java 12性能对比 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11443770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11443770.html</guid>
<description>&lt;p&gt;我发现&lt;a href=&quot;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/csharp.html&quot;&gt;基准游戏&lt;/a&gt;(&lt;a href=&quot;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/csharp.html&quot;&gt;https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/csharp.html&lt;/a&gt;)是一套非常好的基准测试。基准测试经过深思熟虑，涵盖了经典的单线程计算到多线程IO数据处理。显然，在这种基准游戏中，诸如网络性能等领域并不容易测试。组织者是艰难但公平的，规则很有意义。这些基准确实可以解决比我见过的大多数现实问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213508038-889718648.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213513678-674963472.png&quot; alt=&quot;image&quot; width=&quot;486&quot; height=&quot;511&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213518866-1875463438.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213525662-206276960.png&quot; alt=&quot;image&quot; width=&quot;485&quot; height=&quot;520&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213531636-111495186.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201909/510-20190901213537961-876704978.png&quot; alt=&quot;image&quot; width=&quot;485&quot; height=&quot;439&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总体印象是.Net Core 2.2要比Java 12 的表现好很多。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Sep 2019 23:02:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>我发现基准游戏(https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/csharp.html)是一套非常好的基准测试。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11443770.html</dc:identifier>
</item>
</channel>
</rss>