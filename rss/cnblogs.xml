<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java架构之路（多线程）大厂方式手写单例模式 - 小菜技术</title>
<link>http://www.cnblogs.com/cxiaocai/p/12189488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxiaocai/p/12189488.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;上期回顾：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上次博客我们说了我们的volatile关键字，我们知道volatile可以保证我们变量被修改马上刷回主存，并且可以有效的防止指令重排序，思想就是加了我们的内存屏障，再后面的多线程博客里还有说到很多的屏障问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1506597/202001/1506597-20200113200725107-1229193181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　volatile虽然好用，但是别用的太多，咱们就这样想啊，一个被volatile修饰的变量持续性的在修改，每次修改都要及时的刷回主内存，我们讲JMM时，我们的CPU和主内存之间是通过总线来连接的，也就是说，每次我们的volatile变量改变了以后都需要经过总线，“道路就那么宽，持续性的通车”,一定会造成堵车的，也就是我们的说的总线风暴。所以使用volatile还是需要注意的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单例模式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例（根据需要，也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例），就是说每次我们创建的对象成功以后，在一个线程中有且仅有一个对象在正常使用。可以分为懒汉式和饿汉式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　懒汉式就是什么意思呢，创建时并没有实例化对象，而是调用时才会被实例化。我们来看一下简单的代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LasySingletonMode {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        LasySingleton instnace &lt;/span&gt;=&lt;span&gt; LasySingleton.getInstnace();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LasySingleton {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法,禁止外部直接new对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LasySingleton() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给予一个对象作为返回值使用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton instnace;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给予一个获取对象的入口
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; LasySingleton对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton getInstnace() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
            instnace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LasySingleton();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instnace;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看起来很简单的样子，私有化构造方法，给予入口，返回对象，差不多就这样就可以了，但是有一个问题，如果是多线程呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton getInstnace() {
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
　　　　instnace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LasySingleton();
　　}
&lt;/span&gt;&lt;span&gt;　　return&lt;/span&gt;&lt;span&gt; instnace;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们假想两个线程，要一起运行这段代码，线程A进来了，看到instnace是null的，ε=(´ο｀*)))唉，线程B进来看见instnace也是null的(因为线程A还没有运行到instnace = new LasySingleton()这个代码)，这时就会造成线程A，B创建了两个对象出来，也就不符合我们的单例模式了，我们来改一下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton getInstnace() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LasySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
            instnace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LasySingleton();
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instnace;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样貌似就可以了，就算是两个线程进来，也只有一个对象可以拿到synchronized锁，就不会产生new 两个对象的行为了，其实不然啊，我们还是两个线程来访问我们的这段代码，线程A和线程B，两个线程来了一看，对象是null的，需要创建啊，于是线程A拿到锁，开始创建，线程B继续等待，线程A创建完成，返回对象，将锁释放，这时线程B可以获取到锁（因为null == instnace判断已经通过了，在if里面进行的线程等待），这时线程B还是会创建一个对象的，这显然还是不符合我们的单例模式啊，我们来继续改造。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton getInstnace() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LasySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
                instnace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LasySingleton();
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instnace;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次基本就可以了吧，回想一下我们上次的volatile有序性，难道真的这样就可以了吗？instnace = new LasySingleton()是一个原子操作吗？有时候你面试小厂，这样真的就可以了，我们来继续深挖一下代码。看一下程序的汇编指令码，首先找我们的class文件。运行javap -c ****.class。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
E:\IdeaProjects\tuling-mvc-&lt;span&gt;3&lt;/span&gt;\target\classes\com\tuling\control&amp;gt;javap -&lt;span&gt;c LasySingleton.class
Compiled from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LasySingletonMode.java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
class com.tuling.control.LasySingleton {
  public static com.tuling.control.LasySingleton getInstnace();
    Code:
       &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;: aconst_null
       &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: getstatic     #&lt;span&gt;2&lt;/span&gt;                  // Field instnace:Lcom/tuling/control/&lt;span&gt;LasySingleton;
       &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: if_acmpne     &lt;span&gt;17&lt;/span&gt;
       &lt;span&gt;7&lt;/span&gt;: new           #&lt;span&gt;3&lt;/span&gt;                  // class com/tuling/control/&lt;span&gt;LasySingleton
      &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;: dup
      &lt;/span&gt;&lt;span&gt;11&lt;/span&gt;: invokespecial #&lt;span&gt;4&lt;/span&gt;                  // Method &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
      &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;: putstatic     #&lt;span&gt;2&lt;/span&gt;                  // Field instnace:Lcom/tuling/control/&lt;span&gt;LasySingleton;
      &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;: getstatic     #&lt;span&gt;2&lt;/span&gt;                  // Field instnace:Lcom/tuling/control/&lt;span&gt;LasySingleton;
      &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;: areturn
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　不是很好理解啊，我们只想看instnace = new LasySingleton()是不是一个原子操作，我们可以这样来做，创建一个最简单的类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Demo demo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Demo();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们运行javap -c -v ***.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
E:\IdeaProjects\tuling-mvc-&lt;span&gt;3&lt;/span&gt;\target\classes&amp;gt;javap -c -&lt;span&gt;v Demo.class
Classfile &lt;/span&gt;/E:/IdeaProjects/tuling-mvc-&lt;span&gt;3&lt;/span&gt;/target/classes/&lt;span&gt;Demo.class
  Last modified &lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;13&lt;/span&gt;; size &lt;span&gt;389&lt;/span&gt;&lt;span&gt; bytes
  MD5 checksum f8b222a4559c4bf7ea05ef086bd3198c
  Compiled from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demo.java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
public class Demo
  minor version: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  major version: &lt;/span&gt;&lt;span&gt;49&lt;/span&gt;&lt;span&gt;
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   &lt;/span&gt;#&lt;span&gt;1&lt;/span&gt; = Methodref          #&lt;span&gt;4&lt;/span&gt;.#&lt;span&gt;19&lt;/span&gt;         // java/lang/Object.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
   &lt;/span&gt;#&lt;span&gt;2&lt;/span&gt; = Class              #&lt;span&gt;20&lt;/span&gt;            //&lt;span&gt; Demo
   &lt;/span&gt;#&lt;span&gt;3&lt;/span&gt; = Methodref          #&lt;span&gt;2&lt;/span&gt;.#&lt;span&gt;19&lt;/span&gt;         // Demo.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
   &lt;/span&gt;#&lt;span&gt;4&lt;/span&gt; = Class              #&lt;span&gt;21&lt;/span&gt;            // java/lang/&lt;span&gt;Object
   &lt;/span&gt;#&lt;span&gt;5&lt;/span&gt; = Utf8               &amp;lt;init&amp;gt;
   #&lt;span&gt;6&lt;/span&gt; =&lt;span&gt; Utf8               ()V
   &lt;/span&gt;#&lt;span&gt;7&lt;/span&gt; =&lt;span&gt; Utf8               Code
   &lt;/span&gt;#&lt;span&gt;8&lt;/span&gt; =&lt;span&gt; Utf8               LineNumberTable
   &lt;/span&gt;#&lt;span&gt;9&lt;/span&gt; =&lt;span&gt; Utf8               LocalVariableTable
  &lt;/span&gt;#&lt;span&gt;10&lt;/span&gt; =&lt;span&gt; Utf8               this
  &lt;/span&gt;#&lt;span&gt;11&lt;/span&gt; =&lt;span&gt; Utf8               LDemo;
  &lt;/span&gt;#&lt;span&gt;12&lt;/span&gt; =&lt;span&gt; Utf8               main
  &lt;/span&gt;#&lt;span&gt;13&lt;/span&gt; = Utf8               ([Ljava/lang/&lt;span&gt;String;)V
  &lt;/span&gt;#&lt;span&gt;14&lt;/span&gt; =&lt;span&gt; Utf8               args
  &lt;/span&gt;#&lt;span&gt;15&lt;/span&gt; = Utf8               [Ljava/lang/&lt;span&gt;String;
  &lt;/span&gt;#&lt;span&gt;16&lt;/span&gt; =&lt;span&gt; Utf8               demo
  &lt;/span&gt;#&lt;span&gt;17&lt;/span&gt; =&lt;span&gt; Utf8               SourceFile
  &lt;/span&gt;#&lt;span&gt;18&lt;/span&gt; =&lt;span&gt; Utf8               Demo.java
  &lt;/span&gt;#&lt;span&gt;19&lt;/span&gt; = NameAndType        #&lt;span&gt;5&lt;/span&gt;:#&lt;span&gt;6&lt;/span&gt;          // &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
  &lt;/span&gt;#&lt;span&gt;20&lt;/span&gt; =&lt;span&gt; Utf8               Demo
  &lt;/span&gt;#&lt;span&gt;21&lt;/span&gt; = Utf8               java/lang/&lt;span&gt;Object
{
  public Demo();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;, locals=&lt;span&gt;1&lt;/span&gt;, args_size=&lt;span&gt;1&lt;/span&gt;
         &lt;span&gt;0&lt;/span&gt;&lt;span&gt;: aload_0
         &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: invokespecial #&lt;span&gt;1&lt;/span&gt;                  // Method java/lang/Object.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
         &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;       &lt;span&gt;5&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  this   LDemo;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava&lt;/span&gt;/lang/&lt;span&gt;String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;, locals=&lt;span&gt;2&lt;/span&gt;, args_size=&lt;span&gt;1&lt;/span&gt;
         &lt;span&gt;0&lt;/span&gt;: new           #&lt;span&gt;2&lt;/span&gt;                  //&lt;span&gt; class Demo
         &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: dup
         &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: invokespecial #&lt;span&gt;3&lt;/span&gt;                  // Method &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:()V
         &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;: astore_1
         &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
      LineNumberTable:
        line &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        line &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;       &lt;span&gt;9&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;  args   [Ljava/lang/&lt;span&gt;String;
            &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;&lt;span&gt;  demo   LDemo;
}
SourceFile: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Demo.java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

E:\IdeaProjects\tuling&lt;/span&gt;-mvc-&lt;span&gt;3&lt;/span&gt;\target\classes&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是这样的,我们来分析一下代码,先看这个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;0&lt;/span&gt;: new           #&lt;span&gt;2&lt;/span&gt;                  // class Demo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是什么意思呢?我们要给予Demo对象在对空间上开辟一个空间,并且返回内存地址，指向我们的操作数栈的Demo对象&lt;/p&gt;

&lt;p&gt;是一个对象复制的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;4&lt;/span&gt;: invokespecial #&lt;span&gt;3&lt;/span&gt;                  // Method &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;init&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:()V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见名知意，init是一个初始化过程，我们会把我们的刚才开辟的栈空间进行一个初始化，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;7&lt;/span&gt;: astore_1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个就是一个赋值的过程，刚才我们有个复制的操作对吧，这时会把我们复制的一个对象赋值给我们的栈空间上的Demo，是不是有点蒙圈了，别急，后面的简单。&lt;/p&gt;
&lt;p&gt;　　这是一个对象的初始化过程，在我的JVM系列博客简单的说过一点，后面我会详细的去说这个，总结起来就是三个过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.开辟空间
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.初始化空间
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;.给引用赋值
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个代码一般情况下，会按照123的顺序去执行的，但是超高并发的场景下，可能会变为132，考虑一下是不是，我们的as-if-serial，132的执行顺序在单线程的场景下也是合理的，如果真的出现了132的情况，会造成什么后果呢？回到我们的单例模式，所以说我们上面单例模式代码还需要改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LasySingletonMode {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        LasySingleton instnace &lt;/span&gt;=&lt;span&gt; LasySingleton.getInstnace();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LasySingleton {


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法,禁止外部直接new对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LasySingleton() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给予一个对象作为返回值使用
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; LasySingleton instnace;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 给予一个获取对象的入口
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; LasySingleton对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LasySingleton getInstnace() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LasySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; instnace) {
                    instnace &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LasySingleton();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instnace;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样来写，就是一个满分的单例模式了，无论出于什么样的考虑，都是满足条件的。也说明你真的理解了我们的volatile关键字。&lt;/p&gt;
&lt;p&gt;　　饿汉式相当于懒汉式就简单很多了，不需要考虑那么多了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tuling.control;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HungrySingletonMode {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String name &lt;/span&gt;=&lt;span&gt; HungrySingleton.name;
        System.out.println(name);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HungrySingleton {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 私有化构造方法,禁止外部直接new对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HungrySingleton() {
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HungrySingleton instnace =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  HungrySingleton();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String name = &quot;XXX&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.out.println(&lt;/span&gt;&quot;我被创建了&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; HungrySingleton getInstance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instnace;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很简单，也不是属于我们多线程范畴该说的，这里就是带着说了一下，就是当我们调用内部方法时，会主动触发对象的创建，这样就是饿汉模式。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jan 2020 00:32:00 +0000</pubDate>
<dc:creator>小菜技术</dc:creator>
<og:description>上期回顾： 上次博客我们说了我们的volatile关键字，我们知道volatile可以保证我们变量被修改马上刷回主存，并且可以有效的防止指令重排序，思想就是加了我们的内存屏障，再后面的多线程博客里还有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxiaocai/p/12189488.html</dc:identifier>
</item>
<item>
<title>Django之Session与Cookie - 辜老板</title>
<link>http://www.cnblogs.com/guyouyin123/p/12190210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyouyin123/p/12190210.html</guid>
<description>&lt;h2 id=&quot;cookie的由来&quot;&gt;Cookie的由来&lt;/h2&gt;
&lt;p&gt;大家都知道HTTP协议是无状态的。&lt;/p&gt;
&lt;p&gt;无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响，也不会直接影响后面的请求响应情况。&lt;/p&gt;
&lt;p&gt;一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。&lt;/p&gt;
&lt;p&gt;状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的，也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。&lt;/p&gt;
&lt;h2 id=&quot;什么是cookie&quot;&gt;什么是Cookie&lt;/h2&gt;
&lt;p&gt;Cookie具体指的是一段小信息，它是服务器发送出来存储在浏览器上的一组组键值对，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。&lt;/p&gt;
&lt;h2 id=&quot;cookie的原理&quot;&gt;Cookie的原理&lt;/h2&gt;
&lt;p&gt;cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。&lt;/p&gt;
&lt;h2 id=&quot;查看cookie&quot;&gt;&lt;strong&gt;查看Cookie&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们使用Chrome浏览器，打开开发者工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201804/867021-20180403225926558-498750585.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cookie与session的作用&quot;&gt;cookie与session的作用&lt;/h2&gt;
&lt;p&gt;保存信息&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;当你第一次登陆成功之后 服务端给你返回了一个随机字符串
保存客户端浏览器上 之后再次朝服务端发请求 只需要携带该随机字符串
服务端就能够识别当前用户身份
超时时间的概念

cookie虽然是保存在客户端的浏览器上的 但是是服务端设置的
浏览器也是可以拒绝服务端对要求 不保存cookie&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;获取cookie&quot;&gt;获取Cookie&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.COOKIES['key']  或者  request.COOKIES.get('username')    username是key
request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;default: 默认值&lt;/li&gt;
&lt;li&gt;salt: 加密盐&lt;/li&gt;
&lt;li&gt;max_age: 后台控制过期时间&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;设置cookie&quot;&gt;设置Cookie&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;rep = HttpResponse(...)
rep ＝ render(request, ...)

rep.set_cookie(key,value,...)
rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key, 键&lt;/li&gt;
&lt;li&gt;value='', 值&lt;/li&gt;
&lt;li&gt;max_age=None, 超时时间&lt;/li&gt;
&lt;li&gt;expires=None, 超时时间(IE requires expires, so set it if hasn't been already.)&lt;/li&gt;
&lt;li&gt;path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问&lt;/li&gt;
&lt;li&gt;domain=None, Cookie生效的域名&lt;/li&gt;
&lt;li&gt;secure=False, https传输&lt;/li&gt;
&lt;li&gt;httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;删除cookie&quot;&gt;删除Cookie&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;def logout(request):
    rep = redirect(&quot;/login/&quot;)
    rep.delete_cookie(&quot;user&quot;)  # 删除用户浏览器上之前设置的usercookie值
    return rep&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cookie版登陆校验&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def check_login(func):
    @wraps(func)
    def inner(request, *args, **kwargs):
        next_url = request.get_full_path()
        if request.get_signed_cookie(&quot;login&quot;, salt=&quot;SSS&quot;, default=None) == &quot;yes&quot;:
            # 已经登录的用户...
            return func(request, *args, **kwargs)
        else:
            # 没有登录的用户，跳转刚到登录页面
            return redirect(&quot;/login/?next={}&quot;.format(next_url))
    return inner


def login(request):
    if request.method == &quot;POST&quot;:
        username = request.POST.get(&quot;username&quot;)
        passwd = request.POST.get(&quot;password&quot;)
        if username == &quot;xxx&quot; and passwd == &quot;dashabi&quot;:
            next_url = request.GET.get(&quot;next&quot;)
            if next_url and next_url != &quot;/logout/&quot;:
                response = redirect(next_url)
            else:
                response = redirect(&quot;/class_list/&quot;)
            response.set_signed_cookie(&quot;login&quot;, &quot;yes&quot;, salt=&quot;SSS&quot;)
            return response
    return render(request, &quot;login.html&quot;)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;django中默认的session超时时间为14天&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;session的由来&quot;&gt;&lt;strong&gt;Session的由来&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。&lt;/p&gt;
&lt;p&gt;问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。&lt;/p&gt;
&lt;p&gt;我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。&lt;/p&gt;
&lt;p&gt;总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。&lt;/p&gt;
&lt;p&gt;另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。&lt;/p&gt;
&lt;h2 id=&quot;设置session&quot;&gt;设置session&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.session['key'] = value
这一句代码干的事情：
    1.django内部会自动生成一个随机字符串
    2.去django_session表中存储数据 键就是随机字符串 值是要保存的数据(中间件干的)
    3.将生成好的随机字符串返回给客户端浏览器   浏览器保存键值对
    sessionid  随机字符串        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取session&quot;&gt;获取session&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.session.get('key')
这一句代码干的事情：
    1.django会自动取浏览器的cookie查找sessionid键值对 获取随机字符串
    2.拿着该随机字符串取django_session表中比对数据
    3.如果比对上了 就将随机字符串对应的数据获取出来并封装到request.session供用户调用&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;django中默认的session超时时间为14天&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;request.session.set_expiry(value)
        * 如果value是个整数，session会在些秒数后失效。
        * 如果value是个datatime或timedelta，session就会在这个时间后失效。
        * 如果value是0,用户关闭浏览器session就会失效。
        * 如果value是None,session会依赖全局session失效策略。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除当前的会话数据并删除会话的cookie推荐&quot;&gt;删除当前的会话数据并删除会话的Cookie（推荐）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;request.session.flush() 
        这用于确保前面的会话数据不可以再次被用户的浏览器访问
        例如，django.contrib.auth.logout() 函数中就会调用它。
    
    session是保存在服务端&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 获取、设置、删除Session中数据
request.session['k1']
request.session.get('k1',None)
request.session['k1'] = 123
request.session.setdefault('k1',123) # 存在则不设置
del request.session['k1']


# 所有 键、值、键值对
request.session.keys()
request.session.values()
request.session.items()
request.session.iterkeys()
request.session.itervalues()
request.session.iteritems()

# 会话session的key
request.session.session_key

# 将所有Session失效日期小于当前日期的数据删除
request.session.clear_expired()

# 检查会话session的key在数据库中是否存在
request.session.exists(&quot;session_key&quot;)

# 删除当前会话的所有Session数据
request.session.delete()
　　
# 删除当前的会话数据并删除会话的Cookie。
request.session.flush() 
    这用于确保前面的会话数据不可以再次被用户的浏览器访问
    例如，django.contrib.auth.logout() 函数中就会调用它。

# 设置会话Session和Cookie的超时时间
request.session.set_expiry(value)
    * 如果value是个整数，session会在些秒数后失效。
    * 如果value是个datatime或timedelta，session就会在这个时间后失效。
    * 如果value是0,用户关闭浏览器session就会失效。
    * 如果value是None,session会依赖全局session失效策略。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;session流程解析&quot;&gt;Session流程解析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/867021/201805/867021-20180514143525989-365124875.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;session版登陆验证&quot;&gt;Session版登陆验证&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps


def check_login(func):
    @wraps(func)
    def inner(request, *args, **kwargs):
        next_url = request.get_full_path()
        if request.session.get(&quot;user&quot;):
            return func(request, *args, **kwargs)
        else:
            return redirect(&quot;/login/?next={}&quot;.format(next_url))
    return inner


def login(request):
    if request.method == &quot;POST&quot;:
        user = request.POST.get(&quot;user&quot;)
        pwd = request.POST.get(&quot;pwd&quot;)

        if user == &quot;alex&quot; and pwd == &quot;alex1234&quot;:
            # 设置session
            request.session[&quot;user&quot;] = user
            # 获取跳到登陆页面之前的URL
            next_url = request.GET.get(&quot;next&quot;)
            # 如果有，就跳转回登陆之前的URL
            if next_url:
                return redirect(next_url)
            # 否则默认跳转到index页面
            else:
                return redirect(&quot;/index/&quot;)
    return render(request, &quot;login.html&quot;)


@check_login
def logout(request):
    # 删除所有当前请求相关的session
    request.session.delete()
    return redirect(&quot;/login/&quot;)


@check_login
def index(request):
    current_user = request.session.get(&quot;user&quot;, None)
    return render(request, &quot;index.html&quot;, {&quot;user&quot;: current_user})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;django中的session配置&quot;&gt;Django中的Session配置&lt;/h2&gt;
&lt;p&gt;Django中默认支持Session，其内部提供了5种类型的Session供开发者使用。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1. 数据库Session
SESSION_ENGINE = 'django.contrib.sessions.backends.db'   # 引擎（默认）

2. 缓存Session
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎
SESSION_CACHE_ALIAS = 'default'                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置

3. 文件Session
SESSION_ENGINE = 'django.contrib.sessions.backends.file'    # 引擎
SESSION_FILE_PATH = None                                    # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 

4. 缓存+数据库
SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'        # 引擎

5. 加密Cookie Session
SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'   # 引擎

其他公用设置项：
SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）
SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）
SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）
SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）
SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）
SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）
SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）
SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 14 Jan 2020 00:30:00 +0000</pubDate>
<dc:creator>辜老板</dc:creator>
<og:description>[TOC] 一、cookie Cookie的由来 大家都知道HTTP协议是无状态的。 无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyouyin123/p/12190210.html</dc:identifier>
</item>
<item>
<title>SpringBoot2 整合Nacos组件，环境搭建和入门案例详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12190192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12190192.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/middle-ware-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/middle-ware-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;概念简介&quot;&gt;1、概念简介&lt;/h2&gt;
&lt;p&gt;Nacos 是构建以“服务”为中心的现代应用架构，如微服务范式、云原生范式等服务基础设施。聚焦于发现、配置和管理微服务。Nacos提供一组简单易用的特性集，帮助开发者快速实现动态服务发现、服务配置、服务元数据及流量管理。敏捷构建、交付和管理微服务平台。&lt;/p&gt;
&lt;h2 id=&quot;关键特性&quot;&gt;2、关键特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;动态配置服务&lt;/li&gt;
&lt;li&gt;服务发现和服务健康监测&lt;/li&gt;
&lt;li&gt;动态 DNS 服务&lt;/li&gt;
&lt;li&gt;服务及其元数据管理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;专业术语解释&quot;&gt;3、专业术语解释&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;命名空间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。&lt;/p&gt;
&lt;p&gt;一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置集 ID&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Nacos 中的某个配置集的ID。配置集ID是组织划分配置的维度之一。DataID通常用于组织划分系统的配置集。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置分组&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串对配置集进行（Group）分组，从而区分 Data ID 相同的配置集。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置快照&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Nacos 的客户端 SDK 会在本地生成配置的快照。当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务注册&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储服务实例和服务负载均衡策略的数据库。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务发现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用服务名对服务下的实例的地址和元数据进行探测，并以预先定义的接口提供给客户端进行查询。&lt;/p&gt;
&lt;p&gt;Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略等。&lt;/p&gt;
&lt;h2 id=&quot;nacos生态圈&quot;&gt;4、Nacos生态圈&lt;/h2&gt;
&lt;p&gt;Nacos 无缝支持一些主流的开源框架生态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Cloud 微服务框架 ;&lt;/li&gt;
&lt;li&gt;Dubbo RPC框架 ;&lt;/li&gt;
&lt;li&gt;Kubernetes 容器应用 ;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境版本&quot;&gt;1、环境版本&lt;/h2&gt;
&lt;p&gt;这里在Windos环境下搭建Nacos单个服务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Nacos版本：官方推荐的稳定版本为1.1.4。&lt;/li&gt;
&lt;li&gt;基础环境：JDK 1.8+；Maven 3.2.x&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;环境包下载&quot;&gt;2、环境包下载&lt;/h2&gt;
&lt;p&gt;这里直接下载打包好的文件，也可以下载源码自己打包。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://github.com/alibaba/nacos/releases&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载文件：nacos-server-1.1.4.zip&lt;/p&gt;
&lt;h2 id=&quot;启动环境&quot;&gt;3、启动环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;启动文件地址：&lt;code&gt;nacos\bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动文件：&lt;code&gt;startup.cmd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关闭文件：&lt;code&gt;shutdown.cmd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动后登陆，账户密码默认：nacos/nacos ;首页效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/202001/1691717-20200114074917075-1595394912.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。&lt;/p&gt;
&lt;h2 id=&quot;新建配置&quot;&gt;1、新建配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/202001/1691717-20200114074935893-820902132.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心依赖&quot;&gt;2、核心依赖&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- Nacos 组件依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;nacos-discovery-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;nacos-config-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;yml配置文件&quot;&gt;3、Yml配置文件&lt;/h2&gt;
&lt;p&gt;这里把项目作为服务注册到Nacos中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nacos:
  config:
    server-addr: 127.0.0.1:8848
  discovery:
    server-addr: 127.0.0.1:8848&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动类配置&quot;&gt;4、启动类配置&lt;/h2&gt;
&lt;p&gt;启动类关联配置中心的dataId标识。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableSwagger2
@SpringBootApplication
@NacosPropertySource(dataId = &quot;WARE_ID&quot;, autoRefreshed = true)
public class Application7017 {
    public static void main(String[] args) {
        SpringApplication.run(Application7017.class,args) ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;核心配置类&quot;&gt;5、核心配置类&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.alibaba.nacos.api.annotation.NacosInjected;
import com.alibaba.nacos.api.exception.NacosException;
import com.alibaba.nacos.api.naming.NamingService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import javax.annotation.PostConstruct;
@Configuration
public class NacosConfig {
    @Value(&quot;${server.port}&quot;)
    private int serverPort;
    @Value(&quot;${spring.application.name}&quot;)
    private String applicationName;
    @NacosInjected
    private NamingService namingService;
    @PostConstruct
    public void registerInstance() throws NacosException {
        namingService.registerInstance(applicationName, &quot;127.0.0.1&quot;, serverPort);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后查询服务列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/202001/1691717-20200114074949134-221259355.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础api用例&quot;&gt;6、基础API用例&lt;/h2&gt;
&lt;p&gt;这里演示两个基础用法：上述步骤1的配置内容读取，步骤4的服务列表读取。基于swagger2管理测试接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/202001/1691717-20200114075007388-1210452699.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Api(&quot;Nacos接口管理&quot;)
@RestController
@RequestMapping(&quot;/nacos&quot;)
public class NacosController {

    @NacosValue(value = &quot;${MyName:null}&quot;, autoRefreshed = true)
    private String myName;
    @NacosValue(value = &quot;${project:null}&quot;, autoRefreshed = true)
    private String project;

    @ApiOperation(value=&quot;查询配置信息&quot;)
    @GetMapping(value = &quot;/info&quot;)
    public String info () {
        return myName+&quot;:&quot;+project;
    }

    @NacosInjected
    private NamingService namingService;

    @ApiOperation(value=&quot;查询服务列表&quot;)
    @GetMapping(value = &quot;/getServerList&quot;)
    public List&amp;lt;Instance&amp;gt; getServerList (@RequestParam String serviceName) {
        try {
            return namingService.getAllInstances(serviceName) ;
        } catch (Exception e){
            e.printStackTrace();
        }
        return null ;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/middle-ware-parent
GitEE·地址
https://gitee.com/cicadasmile/middle-ware-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jan 2020 00:01:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、Nacos基础简介 1、概念简介 Nacos 是构建以“服务”为中心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12190192.html</dc:identifier>
</item>
<item>
<title>EntityFramework Core表名原理解析，让我来，揭开你神秘的面纱 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12180250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12180250.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;上一节我们针对最开始抛出的异常只是进行了浅尝辄止的解析，是不是有点意犹未尽的感觉，是的，我也有这种感觉，看到这里相信您和我会有一些疑惑，要是我们接下来通过注解、Fluent APi、DbSet分别对表名进行如下设置，是否会抛出异常呢？若不是，有其优先级，那么其优先级到底是怎样的呢？内置具体是如何实现的呢？让我们从头开始揭开其神秘的面纱。&lt;/p&gt;
&lt;h2&gt;EntityFramework Core表名原理解析&lt;/h2&gt;
&lt;p&gt;我们暂不知道到底是否有其优先级还是会抛出异常，那么接下来我们进行如下配置（模型请参考上一节《&lt;a title=&quot;EntityFramework Core一劳永逸动态加载模型，我们要知道些什么呢？&quot; href=&quot;https://www.cnblogs.com/CreateMyself/p/12175618.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CreateMyself/p/12175618.html&lt;/a&gt;》）进行原理分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blog1 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

[Table(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

modelBuilder.Entity&lt;/span&gt;&amp;lt;Blog&amp;gt;().ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在还未进入原理解析之前，让我们大胆猜测通过如上配置后优先级将是怎样的呢？是Fluent Api &amp;gt; 注解 &amp;gt; DbSet &amp;gt; 约定吗？假设是这样的话，EntityFramework Core内置是怎样实现的呢？是采用覆盖的机制吗？一堆疑问浮现在我们眼前，来，让我们进入探究枯燥源码的世界，为您一一解惑。 首先我们需要明确的是，在我们实例化上下文进行操作之前，EntityFramework Core具体做了些什么？故事就要从我们派生自DbContext上下文说起，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFCoreDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        &lt;/span&gt;=&amp;gt; optionsBuilder.UseSqlServer(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Server=.;Database=EFTest;Trusted_Connection=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blog1 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Blog&amp;gt;(b =&amp;gt;&lt;span&gt;
            {
                b.ToTable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });

            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在EntityFramework Core中我们利用上下文进行操作之前就是按照上述代码由上至下整体上做了如下三步准备工作：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;【1】实例化上下文时，查找DbSet属性并缓存到内存中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【2】以上下文作为缓存的键，将上下文中的所有模型数据缓存在内存中，若未缓存执行第【3】步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【3】创建上下文中所有模型有关数据。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;查找DbSet属性并缓存&lt;/h3&gt;
&lt;p&gt;接下来我们步步分析，步步逼近以上三步操作实现，无论是主动实例化还是在Web中添加上下文中间件时，都必须经过将我们需要用到所有接口进行依赖注入，当然EntityFramework Core是用的【 &lt;span class=&quot;cnblogs_code&quot;&gt;Microsoft.Extensions.DependencyInjection&lt;/span&gt; 】库，至于注册了哪些，这些细节我们并不关心，我们只关注所需要用到的且会一一说明，获取接口【IDbSetInitializer】的具体实现【DbSetInitializer】，调用该类中的如下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitializeSets(DbContext context)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; setInfo &lt;span&gt;in&lt;/span&gt; _setFinder.FindSets(context.GetType()).Where(p =&amp;gt; p.Setter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
            {
                setInfo.Setter.SetClrValue(
                    context,
                    ((IDbSetCache)context).GetOrAddSet(_setSource, setInfo.ClrType));
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来获取接口【IDbSetFinder】的具体实现【DbSetFinder】去过滤查找存在Setter属性的DbSet（这点就不用我解释），查找细节我们不关心，每个DbSet都有其【DbSetProperty】属性，所以查找到后添加到该属性并缓存到【IDbSetCache】中，到此对于DbSet的查找和缓存就已完事，接下来去创建上下文中的所有模型数据。&lt;/p&gt;
&lt;h3&gt;创建上下文模型&lt;/h3&gt;
&lt;p&gt;首先是去获取上下文中所有模型数据，以上下文为键去查找缓存的模型数据，若没有则创建，否则创建缓存，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IModel GetModel(
            DbContext context,
            IConventionSetBuilder conventionSetBuilder)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; Dependencies.MemoryCache;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cacheKey =&lt;span&gt; Dependencies.ModelCacheKeyFactory.Create(context);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cache.TryGetValue(cacheKey, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; IModel model))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make sure OnModelCreating really only gets called once, since it may not be thread safe.&lt;/span&gt;
                &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_syncObject)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cache.TryGetValue(cacheKey, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; model))
                    {
                        model &lt;/span&gt;=&lt;span&gt; CreateModel(context, conventionSetBuilder);
                        model &lt;/span&gt;= cache.Set(cacheKey, model, &lt;span&gt;new&lt;/span&gt; MemoryCacheEntryOptions { Size = &lt;span&gt;100&lt;/span&gt;, Priority =&lt;span&gt; CacheItemPriority.High });
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来到了缓存不存在创建模型的环节，创建模型主要做了以下三件事。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IModel CreateModel(
            [NotNull] DbContext context,
            [NotNull] IConventionSetBuilder conventionSetBuilder)
        {
            Check.NotNull(context, nameof(context));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建默认约定集合，通过约定分发机制去处理各个约定&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; modelBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelBuilder(conventionSetBuilder.CreateConventionSet());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理OnModelCreating方法中的自定义配置&lt;/span&gt;
&lt;span&gt;            Dependencies.ModelCustomizer.Customize(modelBuilder, context);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模型构建完毕后，重新根据约定分发机制使得模型数据处于最新状态&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelBuilder.FinalizeModel();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当实例化ModelBuilder通过约定分发机制处理各个约定，具体做了哪些操作呢？主要做了以下三件事&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;【1】各个约定进行初始化做一些准备工作，并将其添加到对应约定集合中去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【2】遍历自定义约定插件集合，修改对应默认约定并返回最新约定集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【3】通过约定分发机制，处理获取得到的最新约定集合。 &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述第【1】和【2】步通过如下代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; ConventionSet CreateConventionSet()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conventionSet =&lt;span&gt; _conventionSetBuilder.CreateConventionSet();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; plugin &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _plugins)
            {
                conventionSet &lt;/span&gt;=&lt;span&gt; plugin.ModifyConventions(conventionSet);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conventionSet;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EntityFramework Core内置提供了三个创建默认约定集合提供者接口【IProviderConventionSetBuilder】的具体实现，分别是【ProviderConventionSetBuilder】用来构建针对数据库使用的默认约定集合的提供者，【RelationalConventionSetBuilder】用来构建模型与数据库映射的默认约定集合的提供者，【SqlServerConventionSetBuilder】用来针对SQL Server数据库构建默认约定集合的提供者，三者继承关系如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlServerConventionSetBuilder : RelationalConventionSetBuilder
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conventionSet = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CreateConventionSet();
        ......
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RelationalConventionSetBuilder : ProviderConventionSetBuilder
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ConventionSet CreateConventionSet()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conventionSet = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CreateConventionSet();
            
            &lt;/span&gt;&lt;span&gt;var tableNameFromDbSetConvention = new&lt;/span&gt;&lt;span&gt;&lt;span&gt; TableNameFromDbSetConvention(Dependencies, RelationalDependencies);&lt;/span&gt;
            
           &lt;span&gt; conventionSet.EntityTypeAddedConventions.Add(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new RelationalTableAttributeConvention(Dependencies, RelationalDependencies));
            
            conventionSet.EntityTypeAddedConventions.Add(tableNameFromDbSetConvention);

            ReplaceConvention(conventionSet.EntityTypeBaseTypeChangedConventions, valueGenerationConvention);
            conventionSet.EntityTypeBaseTypeChangedConventions.Add(tableNameFromDbSetConvention);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conventionSet;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProviderConventionSetBuilder : IProviderConventionSetBuilder
    {  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; ConventionSet CreateConventionSet()
        {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　   ......
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上多余我们用不到的约定已经剔除，我们看到往【EntityTypeAddedConventions】约定集合中先后添加了【RelationalTableAttributeConvention】和【TableNameFromDbSetConvention】对于表名的约定，对于【TableNameFromDbSetConvention】约定在构造实例化时做了如下操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TableNameFromDbSetConvention : IEntityTypeAddedConvention, IEntityTypeBaseTypeChangedConvention
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IDictionary&amp;lt;Type, DbSetProperty&amp;gt;&lt;span&gt; _sets;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TableNameFromDbSetConvention(
            [NotNull] ProviderConventionSetBuilderDependencies dependencies,
            [NotNull] RelationalConventionSetBuilderDependencies relationalDependencies)
        {
            _sets &lt;/span&gt;=&lt;span&gt; dependencies.SetFinder.CreateClrTypeDbSetMapping(dependencies.ContextType);

            Dependencies &lt;/span&gt;=&lt;span&gt; dependencies;
        }
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续看上述通过上下文是如何获取对应模型的DbSet属性的呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IDictionary&amp;lt;Type, DbSetProperty&amp;gt;&lt;span&gt; CreateClrTypeDbSetMapping(
            [NotNull] &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IDbSetFinder setFinder, [NotNull] Type contextType)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sets = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;Type, DbSetProperty&amp;gt;&lt;span&gt;();
          
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; alreadySeen = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Type&amp;gt;&lt;span&gt;();
          
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; setFinder.FindSets(contextType))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!alreadySeen.Contains(&lt;span&gt;set&lt;/span&gt;&lt;span&gt;.ClrType))
                {
                    alreadySeen.Add(&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;.ClrType);
                    sets.Add(&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;.ClrType, &lt;span&gt;set&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    sets.Remove(&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;.ClrType);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sets;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为在初始化上下文时我们就已经对上下文中的所有DbSet属性进行了缓存，所以通过如上方法就是获取模型与对应上下文缓存的DbSet属性的映射，还是很好理解，如下也给出调试源码时所显示Blog对应的DbSet属性信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112141513151-267900714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经获取到了所有默认约定集合，接下来实例化ModelBuilder，将默认约定集合作为参数传进去，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ModelBuilder : IInfrastructure&amp;lt;InternalModelBuilder&amp;gt;&lt;span&gt;
{
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; InternalModelBuilder _builder;

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelBuilder([NotNull] ConventionSet conventions)
     {
         _builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; InternalModelBuilder(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model(conventions));
     }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来继续实例化Model，传入默认约定集合，开始实例化约定分配类并通过约定分发机制对模型进行处理，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Model : ConventionAnnotatable, IMutableModel, IConventionModel
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Model([NotNull] ConventionSet conventions)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dispatcher = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConventionDispatcher(conventions);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt; InternalModelBuilder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        ConventionDispatcher &lt;/span&gt;=&lt;span&gt; dispatcher;
        Builder &lt;/span&gt;=&lt;span&gt; builder;
        dispatcher.OnModelInitialized(builder);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述【ConventionDispatcher】类就是对模型的各个阶段进行分发处理（关于分发处理机制后续再单独通过一篇博客来详细分析），因为上述我们将表名的两个约定放在【EntityTypeAddedConventions】集合中，接下来我们来到约定分发机制对该约定集合中12个默认约定遍历处理，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IConventionEntityTypeBuilder OnEntityTypeAdded(IConventionEntityTypeBuilder entityTypeBuilder)
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; (_dispatcher.DelayConventions())
    {
        _entityTypeBuilderConventionContext.ResetState(entityTypeBuilder);
        
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entityTypeConvention &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _conventionSet.EntityTypeAddedConventions)
        {
            entityTypeConvention.ProcessEntityTypeAdded(entityTypeBuilder, _entityTypeBuilderConventionContext);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entityTypeBuilder;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为首先添加的【RelationalTableAttributeConvention】约定，所以当遍历到【RelationalTableAttributeConvention】约定时，就去到处理该约定的具体实现，说白了该约定就是获取表名的注解即遍历特性，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessEntityTypeAdded(
    IConventionEntityTypeBuilder entityTypeBuilder,
    IConventionContext&lt;/span&gt;&amp;lt;IConventionEntityTypeBuilder&amp;gt;&lt;span&gt; context)
{
    Check.NotNull(entityTypeBuilder, nameof(entityTypeBuilder));

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attributes = type.GetTypeInfo().GetCustomAttributes&amp;lt;TAttribute&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
    {
        ProcessEntityTypeAdded(entityTypeBuilder, attribute, context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法【ProcessEntityTypeAdded】的最终具体实现就是设置对应具体模型的表名，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessEntityTypeAdded(
    IConventionEntityTypeBuilder entityTypeBuilder,
    TableAttribute attribute,
    IConventionContext&lt;/span&gt;&amp;lt;IConventionEntityTypeBuilder&amp;gt;&lt;span&gt; context)
{
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若定义架构特性，则为模型添加架构名称和表名特性&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(attribute.Schema))
    {
        entityTypeBuilder.ToTable(attribute.Name, attribute.Schema, fromDataAnnotation: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(attribute.Name))
    {  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若表名非空，则添加模型表名为定义的表名特性&lt;/span&gt;
        entityTypeBuilder.ToTable(attribute.Name, fromDataAnnotation: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有童鞋就问了，我们在表特性上只定义架构名称，那么上述不就产生bug了吗，用过注解的都知道既然在表特性上提供了架构名称，那么表名必须提供，但是表名提供，架构名称可不提供，所以上述处理逻辑并没任何毛病。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112141828253-530796424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们继续看上述在【RelationalEntityTypeBuilderExtensions】类中对于ToTable方法的实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IConventionEntityTypeBuilder ToTable(
    [NotNull] &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; IConventionEntityTypeBuilder entityTypeBuilder, [CanBeNull] &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;bool&lt;/span&gt; fromDataAnnotation = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;entityTypeBuilder.CanSetTable(name, fromDataAnnotation))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    entityTypeBuilder.Metadata.SetTableName(name, fromDataAnnotation);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entityTypeBuilder;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到该方法主要目的是判断该表名是否可设置，若不可设置则返回空，否则将设置该注解的名称作为模型的表名，我们看看上述CanSetTable又是如何判断是否可设置呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanSetTable(
    [NotNull] &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; IConventionEntityTypeBuilder entityTypeBuilder, [CanBeNull] &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;bool&lt;/span&gt; fromDataAnnotation = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
{
    Check.NullButNotEmpty(name, nameof(name));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entityTypeBuilder.CanSetAnnotation(RelationalAnnotationNames.TableName, name, fromDataAnnotation);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;真是一层套一层，上述【RelationalAnnotationNames.TableName】是专为通过注解获取表名而定义的常量，其值为【Relational:TableName】，此时在注解字典中不存在该键，最终当然也就将模型的表特性名称作为模型的表名，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanSetAnnotation([NotNull] &lt;span&gt;string&lt;/span&gt; name, [CanBeNull] &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, ConfigurationSource configurationSource)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; existingAnnotation =&lt;span&gt; Metadata.FindAnnotation(name);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; existingAnnotation == &lt;span&gt;null&lt;/span&gt;
        || CanSetAnnotationValue(existingAnnotation, value, configurationSource, canOverrideSameSource: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Annotation FindAnnotation([NotNull] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
{
    Check.NotEmpty(name, nameof(name));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _annotations == &lt;span&gt;null&lt;/span&gt;
        ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
        : _annotations.TryGetValue(name, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; annotation)
            &lt;/span&gt;?&lt;span&gt; annotation
            : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanSetAnnotationValue(
    ConventionAnnotation annotation, &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; value, ConfigurationSource configurationSource, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; canOverrideSameSource)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Equals(annotation.Value, value))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; existingConfigurationSource =&lt;span&gt; annotation.GetConfigurationSource();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurationSource.Overrides(existingConfigurationSource)
        &lt;/span&gt;&amp;amp;&amp;amp; (configurationSource !=&lt;span&gt; existingConfigurationSource
            &lt;/span&gt;||&lt;span&gt; canOverrideSameSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112142936806-1572174521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述就是ToTable方法中调用第一个方法CanSetTable是否可设置表名的过程，主要就是在注解字典中查找注解名称为Relational:TableName是否已存在的过程，我们可以看到注解字典中不存在表名的注解名称，接下来调用第二个方法SetTableName方法去设置表名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetTableName(
    [NotNull] &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; IConventionEntityType entityType, [CanBeNull] &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;bool&lt;/span&gt; fromDataAnnotation = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;=&amp;gt;&lt;span&gt; entityType.SetOrRemoveAnnotation(
        RelationalAnnotationNames.TableName,
        Check.NullButNotEmpty(name, nameof(name)),
        fromDataAnnotation);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来将是向注解字典中添加名为Relational:TableName，值为Blog2的注解，通过如下图监控可以清楚看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112130911543-4968233.png&quot; alt=&quot;&quot; width=&quot;1615&quot; height=&quot;575&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，对于模型Blog已经通过注解即表特性设置了表名，接下来处理约定【TableNameFromDbSetConvention】，到底是覆盖还是跳过呢？我们还是一探其实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessEntityTypeAdded(
    IConventionEntityTypeBuilder entityTypeBuilder,
    IConventionContext&lt;/span&gt;&amp;lt;IConventionEntityTypeBuilder&amp;gt;&lt;span&gt; context)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; entityType =&lt;span&gt; entityTypeBuilder.Metadata;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (entityType.BaseType == &lt;span&gt;null&lt;/span&gt;
        &amp;amp;&amp;amp; entityType.ClrType != &lt;span&gt;null&lt;/span&gt;
        &amp;amp;&amp;amp;&lt;span&gt; _sets.ContainsKey(entityType.ClrType))
    {
        entityTypeBuilder.ToTable(_sets[entityType.ClrType].Name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先获取模型Blog的元数据，接下来判断其基类是否为空，该类型的原始类型不能为空，同时在其暴露的DbSet属性中包含该类型，很显然都满足条件，最后将我们上述对模型和DbSet属性进行了映射，所以设置其表名为Blog1，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112142501649-493496765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上只是满足了条件进行设置，我们还要看看方法【ToTable】的具体实现才能最终下结论，此时依然会和注解判断逻辑一样，但是此时在注解字典中已存在键Relational:TableName，所以将跳过，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112133128201-1732293420.png&quot; alt=&quot;&quot; width=&quot;1467&quot; height=&quot;398&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200112141122135-320993640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到此为止针对注解和DbSet对表名的设置已经讨论完毕，接下来我们进行到执行OnModelCreating方法即我们自定义的设置，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Dependencies.ModelCustomizer.Customize(modelBuilder, context);
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Customize(ModelBuilder modelBuilder, DbContext context)
{
    context.OnModelCreating(modelBuilder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时将执行到我们对Blog自定义设置的表名Blog3，我们看看最终其ToTable方法直接跳过了CanSetTable方法，直接将参数名称赋值作为模型表名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EntityTypeBuilder ToTable(
    [NotNull] &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; EntityTypeBuilder entityTypeBuilder,
    [CanBeNull] &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
{
    entityTypeBuilder.Metadata.SetTableName(name);
    entityTypeBuilder.Metadata.RemoveAnnotation(RelationalAnnotationNames.ViewDefinition);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entityTypeBuilder;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/202001/589642-20200111213004844-149270902.png&quot; alt=&quot;&quot; width=&quot;1639&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此为止对模型的初始化准备工作已经完成，接下来开始利用上下文进行操作，此时我们回到上一节利用上下文获取表名的方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetTableName([NotNull] &lt;span&gt;this&lt;/span&gt; IEntityType entityType) =&amp;gt;&lt;span&gt;
        entityType.BaseType &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;
            ?&lt;span&gt; entityType.GetRootType().GetTableName()
            : (&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;)entityType[RelationalAnnotationNames.TableName] ?? GetDefaultTableName(entityType);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过分析可知，无论是根据DbSet配置表名还是通过注解配置表名又或者是通过在OnModelCreating方法中自定义配置表名，最终在落地设置时，都统一以RelationalAnnotationNames.TableName即常量Relational:TableName为键设置表名值，所以上述若基类不存在就获取该表名常量的值，否则都未配置表名的话，才去以模型名称作为表名。&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;通过此篇和上一篇我们才算对EntityFramework Core中表名的详细解析才算明朗，我们下一个结论：&lt;span&gt;EntityFramework Core对于表名的配置优先级是自定义（OnModelCreating方法）&amp;gt; 注解（表特性）&amp;gt; DbSet属性名称 &amp;gt; 模型名称，可能我们会想何不先注册DbSet约定，然后再注册表特性约定，采取覆盖的机制呢？但是事实并非如此，这里我们仅仅只是研究源码的冰山一角或许是为了考虑其他吧。若暴露DbSet属性，根据注册的默认约定表名为DbSet属性名称，否则表名为模型名称，若通过注解设置表名，此时上下文中暴露的DbSet属性将会被忽略，若通过OnModelCreating方法自定义配置表名，则最终以其自定义表名为准。&lt;span&gt;那么问题来了，对于属性而言是否可以依此类推呢？想知道，只能您亲自去看源码了，逐步调试源码验证使得整个逻辑能够自圆其说、阅读博客是否有语句不通畅或错别字，两篇文章花费我一天多的时间，希望对阅读本文的您能有些许收获，谢谢。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 23:44:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 上一节我们针对最开始抛出的异常只是进行了浅尝辄止的解析，是不是有点意犹未尽的感觉，是的，我也有这种感觉，看到这里相信您和我会有一些疑惑，要是我们接下来通过注解、Fluent APi、DbSet分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12180250.html</dc:identifier>
</item>
<item>
<title>用markdown写博客，看这一篇就够了 - siwei718</title>
<link>http://www.cnblogs.com/siweihz/p/12185549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siweihz/p/12185549.html</guid>
<description>&lt;ul readability=&quot;6.0437086092715&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;为什么用markdown写博客？&lt;/p&gt;
&lt;p&gt;在写博客的过程中，最大的“痛点”在于写作中总是被“格式”之类的困扰，&lt;strong&gt;无法专注于内容写作&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;在线写博客，会被网络或者编辑器本身所拖累；&lt;/p&gt;
&lt;p&gt;本文介绍的markdown写作，可以使你专注于博客内容本身，写好即成稿；&lt;/p&gt;
&lt;p&gt;更重要的是，博客内容及相关素材保存在本地，可以几乎不用修改就可以发布在不同的平台，类似java程序的“一次编写，到处运行”。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;记得上次用markdown写博客，尽管我有markdown使用经验，但第一篇markdown博客还是不得已的“回滚”了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.18461538461538&quot;&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://www.cnblogs.com/siweihz/p/12150312.html&quot; target=&quot;_blank&quot;&gt;记录一下第一次用markdown写博客回滚过程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;“痛定思痛”，简单总结后，再次出发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;markdown语法根本上还是不熟悉&lt;/p&gt;
&lt;p&gt;实话说，虽然以前用过markdown，但也仅仅是入门级别。很多“高级”用法没掌握，在写的过程中，无法像传统方式（如&lt;code&gt;word&lt;/code&gt;，或者在博客园的&lt;code&gt;TinyMCE&lt;/code&gt;编辑器）那样高效。&lt;/p&gt;
&lt;p&gt;最近用markdown写了3篇博客，一篇比一篇有手感。在这个过程中，慢慢的感觉不到工具的影响了，可以专注于博客内容本身了。&lt;/p&gt;
&lt;p&gt;就像卖油翁，熟能生巧，慢慢的工具不再是桎梏。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;格式混乱&lt;/p&gt;
&lt;p&gt;第一篇markdown排版的博客，我从&lt;code&gt;TinyMCE&lt;/code&gt;编辑器拷贝内容到Markdown工具&lt;code&gt;Typora&lt;/code&gt;中，其实已经包含了部分“格式”。我没有意识到这一点，去排版就相当尴尬了。现在想来，应该先清除格式，比如先拷贝到“记事本”，或者用Typora的“清除样式”，然后再重新排版。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;图片排版&lt;/p&gt;
&lt;p&gt;在Typora中写博客的时候，第一次我是用的本地图片。这个本身没问题的，但是当拷贝到博客园中后，图片路径是找不到的。调整后，导致&lt;code&gt;Typora&lt;/code&gt;中写的内容和发布的内容不一致，从而维护困难的问题。&lt;/p&gt;
&lt;p&gt;解决办法：在博客园的markdown编辑器中，只需要如下3步即可。&lt;/p&gt;
&lt;p&gt;步骤1）点击右边的“上传图片”图标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200113104801220-607275678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤2）点击“上传本地图片”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200113104813224-1417093491.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤3）复制文本及链接到&lt;code&gt;Typora&lt;/code&gt;中即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200113104824700-1787811876.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工欲善其事必先利其器，好的工具，正确的使用方法，必然能带来效率的提升。&lt;/p&gt;
&lt;p&gt;我尝试过大量的工具来写markdown，个人认为&lt;code&gt;Typora&lt;/code&gt;是比较好用的工具。最大的原因在于，你在写的过程中，熟悉后，几乎感知不到工具的存在。&lt;/p&gt;
&lt;p&gt;创作博客，第一位的是内容，其次是格式。markdown作为轻量级的工具，在写博客的过程中主要涉及如下几个方面：&lt;/p&gt;
&lt;ul readability=&quot;14&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先选定，后操作&lt;/p&gt;
&lt;p&gt;类似office的操作，要先选定要操作的对象，再设定格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;字体格式&lt;/p&gt;
&lt;p&gt;主要包括是 &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;倾斜&lt;/em&gt; &lt;u&gt;下划线&lt;/u&gt;，可以通过快捷键，菜单，鼠标右键完成。&lt;/p&gt;
&lt;p&gt;加粗的快捷键是&lt;code&gt;Ctrl + B&lt;/code&gt;，或者输入两个&lt;code&gt;**&lt;/code&gt;包围需要加粗的文字；&lt;/p&gt;
&lt;p&gt;倾斜的快捷键是&lt;code&gt;Ctrl + I&lt;/code&gt;，或者输入&lt;code&gt;*&lt;/code&gt;标签围绕需要倾斜的文字；&lt;/p&gt;
&lt;p&gt;下划线的快捷键是&lt;code&gt;Ctrl + U&lt;/code&gt;，或者输入&lt;code&gt;&amp;lt;u&amp;gt;&amp;lt;/u&amp;gt;&lt;/code&gt;标签围绕需要下划线的文字。&lt;/p&gt;
&lt;p&gt;字体、颜色，需要通过&lt;span&gt;html&lt;/span&gt;的标签完成。Typora中，我是通过手工输入html及css标记完成的。如绿色的html就是通过font标签实现的：&lt;code&gt;&amp;lt;font face=&quot;黑体&quot; color=green size=5&amp;gt;html&amp;lt;/font&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;段落及标题&lt;/p&gt;
&lt;p&gt;这部分可以通过快捷键 &lt;code&gt;Ctrl + 0~6&lt;/code&gt;来实现，如&lt;strong&gt;&lt;code&gt;Ctrl+ 0&lt;/code&gt;&lt;/strong&gt;是段落，&lt;strong&gt;&lt;code&gt;Ctrl + 1&lt;/code&gt;&lt;/strong&gt;是一级标题等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;p&gt;插入代码块的快捷键是 &lt;code&gt;Ctrl + Shift +`&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;也可以右键，选择插入--代码块实现；&lt;/p&gt;
&lt;p&gt;我是通过直接输入3个点（键盘左上角的那个键，Esc的下方）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;超链接及图片&lt;/p&gt;
&lt;p&gt;插入超链接的快捷键是&lt;code&gt;Ctrl+k&lt;/code&gt;，得到 &lt;span&gt; 大括号[]小括号()&lt;/span&gt; &lt;code&gt;[]()&lt;/code&gt;，其中中括号中输入标题，小括号中输入超链接；&lt;/p&gt;
&lt;p&gt;插入本地图片快捷键是&lt;code&gt;Ctrl + Shift + I&lt;/code&gt;，得到得到 &lt;span&gt;感叹号！大括号[] 小括号()&lt;/span&gt; &lt;code&gt;![]()&lt;/code&gt;，和超链接的唯一区别在于&quot;最前面有感叹号&quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;p&gt;有序列表的快捷键是&lt;code&gt;Ctrl + Shift + [&lt;/code&gt;，直接输入数字后面紧跟一个.即可；&lt;/p&gt;
&lt;p&gt;无序列表的快捷键是&lt;code&gt;Ctrl + Shift + ]&lt;/code&gt;，也可以输入 &lt;code&gt;*&lt;/code&gt;（星号） 、&lt;code&gt;+&lt;/code&gt;（加号） 或者 &lt;code&gt;-&lt;/code&gt;（减号）中的任何一个，后面紧跟“空格”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;5.0042517006803&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;进一步熟悉工具&lt;/p&gt;
&lt;p&gt;强迫自己使用markdown，慢慢就习惯了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关于快捷键&lt;/p&gt;
&lt;p&gt;尽量用快捷键，这可以极大的提升效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6.7745664739884&quot;&gt;
&lt;p&gt;关于超链接无法在新窗口打开的问题&lt;/p&gt;
&lt;p&gt;在博客园，超链接只能在当前窗口打开。&lt;/p&gt;
&lt;p&gt;该问题可以通过html的超链接 a标签的target=_blank来解决，比如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/siweihz/p/12150312.html&quot; target=&quot;_blank&quot;&gt;记录一下第一次用markdown写博客回滚过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;markdown的标准做法是在链接后面加上 ?_blank，但在博客园的markdown编辑器中无效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关于缩进问题&lt;/p&gt;
&lt;p&gt;实话说，本文发布后，在缩进方面还是需要进一步的改进。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个乐于分享的博主，如果需要请自行下载本文对应的markdown文件。如果需要前几篇的，请留言，我发给你！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/siweihz/%E7%94%A8markdown%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.rar&quot;&gt;用markdown写博客，看这一篇就够了.rar&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 23:30:00 +0000</pubDate>
<dc:creator>siwei718</dc:creator>
<og:description>0. 前言 为什么用markdown写博客？ 在写博客的过程中，最大的“痛点”在于写作中总是被“格式”之类的困扰， 无法专注于内容写作 ； 在线写博客，会被网络或者编辑器本身所拖累； 本文介绍的mar</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/siweihz/p/12185549.html</dc:identifier>
</item>
<item>
<title>Go Web 编程之 静态文件 - darjun</title>
<link>http://www.cnblogs.com/darjun/p/12190173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darjun/p/12190173.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在 Web 开发中，需要处理很多静态资源文件，如 css/js 和图片文件等。本文将介绍在 Go 语言中如何处理文件请求。&lt;br/&gt;接下来，我们将介绍两种处理文件请求的方式：原始方式和&lt;code&gt;http.FileServer&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;原始方式&quot;&gt;原始方式&lt;/h2&gt;
&lt;p&gt;原始方式比较简单粗暴，直接读取文件，然后返回给客户端。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
  mux := http.NewServeMux()
  mux.HandleFunc(&quot;/static/&quot;, fileHandler)

  server := &amp;amp;http.Server {
    Addr:    &quot;:8080&quot;,
    Handler: mux,
  }
  if err := server.ListenAndServe(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们创建了一个文件处理器，将它挂载到路径&lt;code&gt;/static/&lt;/code&gt;上。一般地，静态文件的路径有一个共同的前缀，以便与其它路径区分。如这里的&lt;code&gt;/static/&lt;/code&gt;，还有一些常用的，例如&lt;code&gt;/public/&lt;/code&gt;等。&lt;br/&gt;代码的其它部分与&lt;a href=&quot;https://darjun.github.io/2019/12/05/goweb/structure/#%E6%80%BB%E7%BB%93&quot;&gt;程序模板&lt;/a&gt;没什么不同，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，这里的注册路径&lt;code&gt;/static/&lt;/code&gt;最后的&lt;code&gt;/&lt;/code&gt;不能省略。我们在前面的文章&lt;a href=&quot;https://darjun.github.io/2019/12/05/goweb/structure/&quot;&gt;程序结构&lt;/a&gt;中介绍过，如果请求的路径没有精确匹配的处理，会逐步去掉路径最后部分再次查找。&lt;br/&gt;静态文件的请求路径一般为&lt;code&gt;/static/hello.html&lt;/code&gt;这种形式。没有精确匹配的路径，继而查找&lt;code&gt;/static/&lt;/code&gt;，这个路径与&lt;code&gt;/static&lt;/code&gt;是不能匹配的。&lt;/p&gt;
&lt;p&gt;接下来，我们看看文件处理器的实现：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func fileHandler(w http.ResponseWriter, r *http.Request) {
  path := &quot;.&quot; + r.URL.Path
  fmt.Println(path)

  f, err := os.Open(path)
  if err != nil {
    Error(w, toHTTPError(err))
    return
  }
  defer f.Close()

  d, err := f.Stat()
  if err != nil {
    Error(w, toHTTPError(err))
    return
  }

  if d.IsDir() {
    DirList(w, r, f)
    return
  }

  data, err := ioutil.ReadAll(f)
  if err != nil {
    Error(w, toHTTPError(err))
    return
  }

  ext := filepath.Ext(path)
  if contentType := extensionToContentType[ext]; contentType != &quot;&quot; {
    w.Header().Set(&quot;Content-Type&quot;, contentType)
  }

  w.Header().Set(&quot;Content-Length&quot;, strconv.FormatInt(d.Size(), 10))
  w.Write(data)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们读出请求路径，再加上相对可执行文件的路径。一般地，&lt;code&gt;static&lt;/code&gt;目录与可执行文件在同一个目录下。然后打开该路径，查看信息。&lt;br/&gt;如果该路径表示的是一个文件，那么根据文件的后缀设置&lt;code&gt;Content-Type&lt;/code&gt;，读取文件的内容并返回。代码中简单列举了几个后缀对应的&lt;code&gt;Content-Type&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var extensionToContentType = map[string]string {
  &quot;.html&quot;: &quot;text/html; charset=utf-8&quot;,
  &quot;.css&quot;: &quot;text/css; charset=utf-8&quot;,
  &quot;.js&quot;: &quot;application/javascript&quot;,
  &quot;.xml&quot;: &quot;text/xml; charset=utf-8&quot;,
  &quot;.jpg&quot;:  &quot;image/jpeg&quot;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果该路径表示的是一个目录，那么返回目录下所有文件与目录的列表：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func DirList(w http.ResponseWriter, r *http.Request, f http.File) {
  dirs, err := f.Readdir(-1)
  if err != nil {
    Error(w, http.StatusInternalServerError)
    return
  }
  sort.Slice(dirs, func(i, j int) bool { return dirs[i].Name() &amp;lt; dirs[j].Name() })

  w.Header().Set(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;)
  fmt.Fprintf(w, &quot;&amp;lt;pre&amp;gt;\n&quot;)
  for _, d := range dirs {
    name := d.Name()
    if d.IsDir() {
      name += &quot;/&quot;
    }
    url := url.URL{Path: name}
    fmt.Fprintf(w, &quot;&amp;lt;a href=\&quot;%s\&quot;&amp;gt;%s&amp;lt;/a&amp;gt;\n&quot;, url.String(), name)
  }
  fmt.Fprintf(w, &quot;&amp;lt;/pre&amp;gt;\n&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数先读取目录下第一层的文件和目录，然后按照名字排序。最后拼装成包含超链接的 HTML 返回。用户可以点击超链接访问对应的文件或目录。&lt;/p&gt;
&lt;p&gt;如何上述过程中出现错误，我们使用&lt;code&gt;toHTTPError&lt;/code&gt;函数将错误转成对应的响应码，然后通过&lt;code&gt;Error&lt;/code&gt;回复给客户端。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func toHTTPError(err error) int {
  if os.IsNotExist(err) {
    return http.StatusNotFound
  }
  if os.IsPermission(err) {
    return http.StatusForbidden
  }
  return http.StatusInternalServerError
}

func Error(w http.ResponseWriter, code int) {
  w.WriteHeader(code)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同级目录下&lt;code&gt;static&lt;/code&gt;目录内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static
├── folder
│   ├── file1.txt
│   └── file2.txt
│   └── file3.txt
├── hello.css
├── hello.html
├── hello.js
└── hello.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序看看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go run main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开浏览器，请求&lt;code&gt;localhost:8080/static/hello.html&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072853664-732873554.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到页面&lt;code&gt;hello.html&lt;/code&gt;已经呈现了：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- hello.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;Go Web 编程之 静态文件&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/static/hello.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p class=&quot;greeting&quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt;
  &amp;lt;script src=&quot;/static/hello.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;html 使用的 css 和 js 文件也是通过&lt;code&gt;/static/&lt;/code&gt;路径请求的，两个文件都比较简单：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.greeting {
  font-family: sans-serif;
  font-size: 15px;
  font-style: italic;
  font-weight: bold;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log(&quot;Hello World!&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;Hello World!&quot;字体显示为 css 设置的样式，通过观察控制台也能看到 js 打印的信息。&lt;/p&gt;
&lt;p&gt;再来看看文件目录浏览，在浏览器中请求&lt;code&gt;localhost:8080/static/&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072854082-1864926161.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以依次点击列表中的文件查看其内容。&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;hello.css&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072854431-1876735226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;hello.js&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072854731-1180338893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次点击&lt;code&gt;folder&lt;/code&gt;和&lt;code&gt;file1.txt&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072855050-1269964271.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072855411-1363519282.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;静态文件的请求路径也会输出到运行服务器的控制台中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go run main.go 
./static/
./static/hello.css
./static/hello.js
./static/folder/
./static/folder/file1.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原始方式的实现有一个缺点，实现逻辑复杂。上面的代码尽管我们已经忽略很多情况的处理了，代码量还是不小。自己编写很繁琐，而且容易产生 BUG。&lt;br/&gt;静态文件服务的逻辑其实比较一致，应该通过库的形式来提供。为此，Go 语言提供了&lt;code&gt;http.FileServer&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;http.fileserver&quot;&gt;&lt;code&gt;http.FileServer&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;先来看看如何使用：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
)

func main() {
  mux := http.NewServeMux()
  mux.Handle(&quot;/static/&quot;, http.FileServer(http.Dir(&quot;&quot;)))


  server := &amp;amp;http.Server {
    Addr: &quot;:8080&quot;,
    Handler: mux,
  }

  if err := server.ListenAndServe(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码使用&lt;code&gt;http.Server&lt;/code&gt;方法，几行代码就实现了与原始方式相同的效果，是不是很简单？这就是使用库的好处！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http.FileServer&lt;/code&gt;接受一个&lt;code&gt;http.FileSystem&lt;/code&gt;接口类型的变量：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/net/http/fs.go
type FileSystem interface {
  Open(name string) (File, error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传入&lt;code&gt;http.Dir&lt;/code&gt;类型变量，注意&lt;code&gt;http.Dir&lt;/code&gt;是一个类型，其底层类型为&lt;code&gt;string&lt;/code&gt;，并不是方法。因而&lt;code&gt;http.Dir(&quot;&quot;)&lt;/code&gt;只是一个类型转换，而非方法调用：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/net/http/fs.go
type Dir string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;http.Dir&lt;/code&gt;表示文件的起始路径，空即为当前路径。调用&lt;code&gt;Open&lt;/code&gt;方法时，传入的参数需要在前面拼接上该起始路径得到实际文件路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http.FileServer&lt;/code&gt;的返回值类型是&lt;code&gt;http.Handler&lt;/code&gt;，所以需要使用&lt;code&gt;Handle&lt;/code&gt;方法注册处理器。&lt;code&gt;http.FileServer&lt;/code&gt;将收到的请求路径传给&lt;code&gt;http.Dir&lt;/code&gt;的&lt;code&gt;Open&lt;/code&gt;方法打开对应的文件或目录进行处理。&lt;br/&gt;在上面的程序中，如果请求路径为&lt;code&gt;/static/hello.html&lt;/code&gt;，那么拼接&lt;code&gt;http.Dir&lt;/code&gt;的起始路径&lt;code&gt;.&lt;/code&gt;，最终会读取路径为&lt;code&gt;./static/hello.html&lt;/code&gt;的文件。&lt;/p&gt;
&lt;p&gt;有时候，我们想要处理器的注册路径和&lt;code&gt;http.Dir&lt;/code&gt;的起始路径不相同。有些工具在打包时会将静态文件输出到&lt;code&gt;public&lt;/code&gt;目录中。&lt;br/&gt;这时需要使用&lt;code&gt;http.StripPrefix&lt;/code&gt;方法，该方法会将请求路径中特定的前缀去掉，然后再进行处理：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
)

func main() {
  mux := http.NewServeMux()
  mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static&quot;, http.FileServer(http.Dir(&quot;./public&quot;))))


  server := &amp;amp;http.Server {
    Addr: &quot;:8080&quot;,
    Handler: mux,
  }

  if err := server.ListenAndServe(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，请求&lt;code&gt;localhost:8080/static/hello.html&lt;/code&gt;将会返回&lt;code&gt;./public/hello.html&lt;/code&gt;文件。&lt;br/&gt;路径&lt;code&gt;/static/index.html&lt;/code&gt;经过处理器&lt;code&gt;http.StripPrefix&lt;/code&gt;去掉了前缀&lt;code&gt;/static&lt;/code&gt;得到&lt;code&gt;/index.html&lt;/code&gt;，然后又加上了&lt;code&gt;http.Dir&lt;/code&gt;的起始目录&lt;code&gt;./public&lt;/code&gt;得到文件最终路径&lt;code&gt;./public/hello.html&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;http.FileServer&lt;/code&gt;还会根据请求文件的后缀推断内容类型，更全面：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/mime/type.go
var builtinTypesLower = map[string]string{
  &quot;.css&quot;:  &quot;text/css; charset=utf-8&quot;,
  &quot;.gif&quot;:  &quot;image/gif&quot;,
  &quot;.htm&quot;:  &quot;text/html; charset=utf-8&quot;,
  &quot;.html&quot;: &quot;text/html; charset=utf-8&quot;,
  &quot;.jpeg&quot;: &quot;image/jpeg&quot;,
  &quot;.jpg&quot;:  &quot;image/jpeg&quot;,
  &quot;.js&quot;:   &quot;application/javascript&quot;,
  &quot;.mjs&quot;:  &quot;application/javascript&quot;,
  &quot;.pdf&quot;:  &quot;application/pdf&quot;,
  &quot;.png&quot;:  &quot;image/png&quot;,
  &quot;.svg&quot;:  &quot;image/svg+xml&quot;,
  &quot;.wasm&quot;: &quot;application/wasm&quot;,
  &quot;.webp&quot;: &quot;image/webp&quot;,
  &quot;.xml&quot;:  &quot;text/xml; charset=utf-8&quot;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果文件后缀无法推断，&lt;code&gt;http.FileServer&lt;/code&gt;将读取文件的前 512 个字节，根据内容来推断内容类型。感兴趣可以看一下源码&lt;code&gt;src/net/http/sniff.go&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;http.servecontent&quot;&gt;&lt;code&gt;http.ServeContent&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;除了直接使用&lt;code&gt;http.FileServer&lt;/code&gt;之外，&lt;code&gt;net/http&lt;/code&gt;库还暴露了&lt;code&gt;ServeContent&lt;/code&gt;方法。这个方法可以用在处理器需要返回一个文件内容的时候，非常易用。&lt;/p&gt;
&lt;p&gt;例如下面的程序，根据 URL 中的&lt;code&gt;file&lt;/code&gt;参数返回对应的文件内容：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;os&quot;
  &quot;time&quot;
)

func ServeFileContent(w http.ResponseWriter, r *http.Request, name string, modTime time.Time) {
  f, err := os.Open(name)
  if err != nil {
    w.WriteHeader(500)
    fmt.Fprint(w, &quot;open file error:&quot;, err)
    return
  }
  defer f.Close()

  fi, err := f.Stat()
  if err != nil {
    w.WriteHeader(500)
    fmt.Fprint(w, &quot;call stat error:&quot;, err)
    return
  }

  if fi.IsDir() {
    w.WriteHeader(400)
    fmt.Fprint(w, &quot;no such file:&quot;, name)
    return
  }

  http.ServeContent(w, r, name, fi.ModTime(), f)
}

func fileHandler(w http.ResponseWriter, r *http.Request) {
  query := r.URL.Query()
  filename := query.Get(&quot;file&quot;)

  if filename == &quot;&quot; {
    w.WriteHeader(400)
    fmt.Fprint(w, &quot;filename is empty&quot;)
    return
  }

  ServeFileContent(w, r, filename, time.Time{})
}

func main() {
  mux := http.NewServeMux()
  mux.HandleFunc(&quot;/show&quot;, fileHandler)

  server := &amp;amp;http.Server {
    Addr:    &quot;:8080&quot;,
    Handler: mux,
  }

  if err := server.ListenAndServe(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;http.ServeContent&lt;/code&gt;除了接受参数&lt;code&gt;http.ResponseWriter&lt;/code&gt;和&lt;code&gt;http.Request&lt;/code&gt;，还需要文件名&lt;code&gt;name&lt;/code&gt;，修改时间&lt;code&gt;modTime&lt;/code&gt;和&lt;code&gt;io.ReadSeeker&lt;/code&gt;接口类型的参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;modTime&lt;/code&gt;参数是为了设置响应的&lt;code&gt;Last-Modified&lt;/code&gt;首部。如果请求中携带了&lt;code&gt;If-Modified-Since&lt;/code&gt;首部，&lt;code&gt;ServeContent&lt;/code&gt;方法会根据&lt;code&gt;modTime&lt;/code&gt;判断是否需要发送内容。&lt;br/&gt;如果需要发送内容，&lt;code&gt;ServeContent&lt;/code&gt;方法从&lt;code&gt;io.ReadSeeker&lt;/code&gt;接口重读取内容。&lt;code&gt;*os.File&lt;/code&gt;实现了接口&lt;code&gt;io.ReadSeeker&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;Web 开发中的静态资源都可以使用&lt;code&gt;http.FileServer&lt;/code&gt;来处理。除此之外，&lt;code&gt;http.FileServer&lt;/code&gt;还可以用于实现一个简单的文件服务器，浏览或下载文件：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import (
  &quot;flag&quot;
  &quot;log&quot;
  &quot;net/http&quot;
)

var (
  ServeDir string
)

func init() {
  flag.StringVar(&amp;amp;ServeDir, &quot;sd&quot;, &quot;./&quot;, &quot;the directory to serve&quot;)
}

func main() {
  flag.Parse()

  mux := http.NewServeMux()
  mux.Handle(&quot;/static/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(ServeDir))))


  server := &amp;amp;http.Server {
    Addr:    &quot;:8080&quot;,
    Handler: mux,
  }

  if err := server.ListenAndServe(); err != nil {
    log.Fatal(err)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，我们构建了一个简单的文件服务器。编译之后，将想浏览的目录作为参数传给命令行选项，就可以浏览和下载该目录下的文件了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./main.exe -sd D:/code/golang&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以将端口也作为命令行选项，这样做出一个通用的文件服务器，编译之后就可以在其它机器上使用了😀。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了如何处理静态文件，依次介绍了原始方式、&lt;code&gt;http.FileServer&lt;/code&gt;和&lt;code&gt;http.ServeContent&lt;/code&gt;。最后使用&lt;code&gt;http.FileServer&lt;/code&gt;实现了一个简单的文件服务器，可供日常使用。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/27204133/&quot;&gt;Go Web 编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://golang.org/pkg/net/http/&quot;&gt;net/http&lt;/a&gt;文档&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;我&quot;&gt;我&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://darjun.github.io&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1919725/202001/1919725-20200114072855693-362392922.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Jan 2020 23:29:00 +0000</pubDate>
<dc:creator>darjun</dc:creator>
<og:description>概述 在 Web 开发中，需要处理很多静态资源文件，如 css/js 和图片文件等。本文将介绍在 Go 语言中如何处理文件请求。 接下来，我们将介绍两种处理文件请求的方式：原始方式和 方法。 原始方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/darjun/p/12190173.html</dc:identifier>
</item>
<item>
<title>MariaDB的备份与主从、高可用实践 - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12183521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12183521.html</guid>
<description>&lt;p data-reactid=&quot;.0.1.0.1.3.0:$2.$1&quot;&gt;1、编写脚本，支持让用户自主选择，使用mysqldump还是xtraback全量备份。&lt;/p&gt;&lt;p&gt;　　说明：以上脚本实现了用户选择一款工具的名称做备份，然后指定连接数据库的用户名，如果未指定用户名，默认是当前Linux登录用户的用户名作为连接mariadb数据库的用户；指定连接数据库的密码，若未指定默认是空；指定数据库地址，若未指定，默认是localhost 或者127.0.0.1 ，最后还要指定备份到那个的地方，如果使用mysqldump 那么需要指定其存放文件的全路径（包括文件名称，若只是给定了一个目录，那么mysqldump默认会在指定的目录下创建一个all_backup.sql文件），若未指定存放文件的全路径，则默认放在当前用户家目录下，并取名backup.all.sql;如果选择的是xtrabackup备份工具备份数据，也需要指定其数据库用户名，密码，数据库地址，以及存放备份文件的目录，用户名和密码和数据库地址 ，若都没有指定，那么用户名就是用的当前Linux登录用户，密码为空，数据库地址为localhost或127.0.0.1 同mysqldump 工具的默认值相同。最后就是存放备份数据库文件目录，若未指定默认存放在当前用户的家目录的backup下存放。&lt;/p&gt;&lt;div data-reactid=&quot;.0.1.0.1.3.0:$3&quot; readability=&quot;33.31884057971&quot;&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$1&quot;&gt;2、配置Mysql主从同步&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$2&quot;&gt; 　　1）准备两台mariadb数据库 centos7上的mariadb为主库，centos6上的mariadb为从库   mariadb 编译安装请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12111497.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12111497.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$3.$2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200113001606044-1010202880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200113001619331-780880074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　2）在主库上开启log-bin日志，并配置主库和从库的server-id（组从库server-id不能相同），如果从库需要级联其他从库需开启log-bin&lt;/p&gt;
&lt;p&gt;　　主库配置文件&lt;/p&gt;
&lt;/div&gt;&lt;div data-reactid=&quot;.0.1.0.1.3.0:$4&quot; readability=&quot;284.93922847266&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# grep -Eiv ^&quot;#|^$&quot; /etc/my.cnf    
[client]
port            = 3306
socket          = /data/mysql/mysql.sock
[mysqld]
port            = 3306
socket          = /data/mysql/mysql.sock
skip-external-locking
key_buffer_size = 384M
max_allowed_packet = 1M
table_open_cache = 512
sort_buffer_size = 2M
read_buffer_size = 2M
read_rnd_buffer_size = 8M
myisam_sort_buffer_size = 64M
thread_cache_size = 8
query_cache_size = 32M
thread_concurrency = 8
log-bin=mysql-bin
server-id       = 1
[mysqldump]
quick
max_allowed_packet = 16M
[mysql]
no-auto-rehash
[myisamchk]
key_buffer_size = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M
[mysqlhotcopy]
interactive-timeout
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：主库配置文件中只需要开启log-bin和server-id 即可&lt;/p&gt;
&lt;p&gt;　　从库配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# grep -Eiv ^&quot;#|^$&quot; /etc/my.cnf
[client]
port            = 3306
socket          = /data/mysql/mysql.sock
[mysqld]
port            = 3306
socket          = /data/mysql/mysql.sock
skip-external-locking
key_buffer_size = 384M
max_allowed_packet = 1M
table_open_cache = 512
sort_buffer_size = 2M
read_buffer_size = 2M
read_rnd_buffer_size = 8M
myisam_sort_buffer_size = 64M
thread_cache_size = 8
query_cache_size = 32M
thread_concurrency = 8
server-id       = 2
read_only       =ON
relay_log       =relay-log
relay_log_index =relay-log.index
[mysqldump]
quick
max_allowed_packet = 16M
[mysql]
no-auto-rehash
[myisamchk]
key_buffer_size = 256M
sort_buffer_size = 256M
read_buffer = 2M
write_buffer = 2M
[mysqlhotcopy]
interactive-timeout
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从库需要开启中继日志，并把从库设置为只读（普通用户只能读，不能修改），server-id 不同于主库即可。更改了主从库的配置文件后需要重启服务才能生效。&lt;/p&gt;
&lt;p&gt;　　3）重启主从库数据库，使其配置文件生效&lt;/p&gt;
&lt;p&gt;　　主库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# /etc/init.d/mysqld restart
Restarting mysqld (via systemctl):                         [  OK  ]
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# /etc/init.d/mysqld restart
Shutting down MariaDB.. SUCCESS! 
Starting MariaDB.200113 09:00:23 mysqld_safe Logging to '/data/mysql/test-centos6-node1.err'.
200113 09:00:23 mysqld_safe Starting mysqld daemon with databases from /data/mysql
 SUCCESS! 
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：本次实验我是源码编译安装的mariadb,所以启动都是直接用脚本启动。&lt;/p&gt;
&lt;p&gt;　　4）在主库上创建用于同步的账号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; select user,password,host from mysql.user;
+------+----------+--------------------+
| user | password | host               |
+------+----------+--------------------+
| root |          | localhost          |
| root |          | test-centos7-node1 |
| root |          | 127.0.0.1          |
| root |          | ::1                |
+------+----------+--------------------+
4 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; grant replication slave on *.* to 'rep_user'@'192.168.0.%' identified by 'admin';
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; select user,password,host from mysql.user;                                       
+----------+-------------------------------------------+--------------------+
| user     | password                                  | host               |
+----------+-------------------------------------------+--------------------+
| root     |                                           | localhost          |
| root     |                                           | test-centos7-node1 |
| root     |                                           | 127.0.0.1          |
| root     |                                           | ::1                |
| rep_user | *4ACFE3202A5FF5CF467898FC58AAB1D615029441 | 192.168.0.%        |
+----------+-------------------------------------------+--------------------+
5 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：授权只需要给replication slave 权限即可，有关mysql创建用户授权可参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/9741166.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/9741166.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　5）在从库上测试创建的账号是否能够登录到主库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# mysql -urep_user -padmin -h192.168.0.10
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 22
Server version: 10.2.19-MariaDB-log Source distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：是能够连接上主库的，说明账号没有问题。如果创建的账号无法连接主库，需要检查主库是否开启了防火墙，检查账号是否正确，最后还要检查主库的监听端口等。&lt;/p&gt;
&lt;p&gt;　　5）在主库上查看二进制文件名和位置点，并记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; show master logs;
+------------------+-----------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 |       328 |
+------------------+-----------+
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6）在从库上配置连接主库用于复制到账号信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; show slave status\G
Empty set (0.00 sec)

MariaDB [(none)]&amp;gt; CHANGE MASTER TO
    -&amp;gt;   MASTER_HOST='192.168.0.10',
    -&amp;gt;   MASTER_USER='rep_user',
    -&amp;gt;   MASTER_PASSWORD='admin',
    -&amp;gt;   MASTER_PORT=3306,
    -&amp;gt;   MASTER_LOG_FILE='mysql-bin.000001',
    -&amp;gt;   MASTER_LOG_POS=328;
Query OK, 0 rows affected (0.02 sec)

MariaDB [(none)]&amp;gt; show slave status\G                  
*************************** 1. row ***************************
               Slave_IO_State: 
                  Master_Host: 192.168.0.10
                  Master_User: rep_user
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000001
          Read_Master_Log_Pos: 328
               Relay_Log_File: relay-log.000001
                Relay_Log_Pos: 4
        Relay_Master_Log_File: mysql-bin.000001
             Slave_IO_Running: No
            Slave_SQL_Running: No
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 328
              Relay_Log_Space: 256
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: NULL
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
                   Using_Gtid: No
                  Gtid_IO_Pos: 
      Replicate_Do_Domain_Ids: 
  Replicate_Ignore_Domain_Ids: 
                Parallel_Mode: conservative
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: 
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：change master to 这个命令太长了，可用help change master to 查看其帮助。我们需要配置好主库地址，用于复制到账号，密码，以及主库的端口，二进制文件名，二进制日志位置点信息即可，配置好后就可以用show slave status\G 查看得到刚才我们配置的信息&lt;/p&gt;
&lt;p&gt;　　7）从库开启同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; start slave ;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.0.10
                  Master_User: rep_user
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000001
          Read_Master_Log_Pos: 328
               Relay_Log_File: relay-log.000002
                Relay_Log_Pos: 555
        Relay_Master_Log_File: mysql-bin.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 328
              Relay_Log_Space: 858
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1
               Master_SSL_Crl: 
           Master_SSL_Crlpath: 
                   Using_Gtid: No
                  Gtid_IO_Pos: 
      Replicate_Do_Domain_Ids: 
  Replicate_Ignore_Domain_Ids: 
                Parallel_Mode: conservative
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到IO线程和sql线程都已经是yes的了。到此mariadb的主从复制就做好了，接下来测试&lt;/p&gt;
&lt;p&gt;测试：在主库上导入数据，看看从库是否能够及时的同步过来&lt;/p&gt;
&lt;p&gt;　　1）主库导入数据并查看导入到数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%       7 KB    7 KB/s 00:00:01       0 Errors

[root@test-centos7-node1 ~]# mysql &amp;lt; hellodb_innodb.sql 
[root@test-centos7-node1 ~]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 21
Server version: 10.2.19-MariaDB-log Source distribution

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| hellodb            |
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; use hellodb
Database changed
MariaDB [hellodb]&amp;gt; show tables;
+-------------------+
| Tables_in_hellodb |
+-------------------+
| classes           |
| coc               |
| courses           |
| scores            |
| students          |
| teachers          |
| toc               |
+-------------------+
7 rows in set (0.00 sec)

MariaDB [hellodb]&amp;gt; select * from students;
+-------+---------------+-----+--------+---------+-----------+
| StuID | Name          | Age | Gender | ClassID | TeacherID |
+-------+---------------+-----+--------+---------+-----------+
|     1 | Shi Zhongyu   |  22 | M      |       2 |         3 |
|     2 | Shi Potian    |  22 | M      |       1 |         7 |
|     3 | Xie Yanke     |  53 | M      |       2 |        16 |
|     4 | Ding Dian     |  32 | M      |       4 |         4 |
|     5 | Yu Yutong     |  26 | M      |       3 |         1 |
|     6 | Shi Qing      |  46 | M      |       5 |      NULL |
|     7 | Xi Ren        |  19 | F      |       3 |      NULL |
|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL |
|     9 | Ren Yingying  |  20 | F      |       6 |      NULL |
|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL |
|    11 | Yuan Chengzhi |  23 | M      |       6 |      NULL |
|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL |
|    13 | Tian Boguang  |  33 | M      |       2 |      NULL |
|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL |
|    15 | Duan Yu       |  19 | M      |       4 |      NULL |
|    16 | Xu Zhu        |  21 | M      |       1 |      NULL |
|    17 | Lin Chong     |  25 | M      |       4 |      NULL |
|    18 | Hua Rong      |  23 | M      |       7 |      NULL |
|    19 | Xue Baochai   |  18 | F      |       6 |      NULL |
|    20 | Diao Chan     |  19 | F      |       7 |      NULL |
|    21 | Huang Yueying |  22 | F      |       6 |      NULL |
|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL |
|    23 | Ma Chao       |  23 | M      |       4 |      NULL |
|    24 | Xu Xian       |  27 | M      |    NULL |      NULL |
|    25 | Sun Dasheng   | 100 | M      |    NULL |      NULL |
+-------+---------------+-----+--------+---------+-----------+
25 rows in set (0.00 sec)

MariaDB [hellodb]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到主库已经有数据生成&lt;/p&gt;
&lt;p&gt;　　2）从库查看数据是否同主库一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# mysql -e &quot;show databases;&quot;
+--------------------+
| Database           |
+--------------------+
| hellodb            |
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
[root@test-centos6-node1 ~]# mysql -e &quot;use hellodb;show tables;&quot;     
+-------------------+
| Tables_in_hellodb |
+-------------------+
| classes           |
| coc               |
| courses           |
| scores            |
| students          |
| teachers          |
| toc               |
+-------------------+
[root@test-centos6-node1 ~]# mysql -e &quot;use hellodb;select * from students;&quot;
+-------+---------------+-----+--------+---------+-----------+
| StuID | Name          | Age | Gender | ClassID | TeacherID |
+-------+---------------+-----+--------+---------+-----------+
|     1 | Shi Zhongyu   |  22 | M      |       2 |         3 |
|     2 | Shi Potian    |  22 | M      |       1 |         7 |
|     3 | Xie Yanke     |  53 | M      |       2 |        16 |
|     4 | Ding Dian     |  32 | M      |       4 |         4 |
|     5 | Yu Yutong     |  26 | M      |       3 |         1 |
|     6 | Shi Qing      |  46 | M      |       5 |      NULL |
|     7 | Xi Ren        |  19 | F      |       3 |      NULL |
|     8 | Lin Daiyu     |  17 | F      |       7 |      NULL |
|     9 | Ren Yingying  |  20 | F      |       6 |      NULL |
|    10 | Yue Lingshan  |  19 | F      |       3 |      NULL |
|    11 | Yuan Chengzhi |  23 | M      |       6 |      NULL |
|    12 | Wen Qingqing  |  19 | F      |       1 |      NULL |
|    13 | Tian Boguang  |  33 | M      |       2 |      NULL |
|    14 | Lu Wushuang   |  17 | F      |       3 |      NULL |
|    15 | Duan Yu       |  19 | M      |       4 |      NULL |
|    16 | Xu Zhu        |  21 | M      |       1 |      NULL |
|    17 | Lin Chong     |  25 | M      |       4 |      NULL |
|    18 | Hua Rong      |  23 | M      |       7 |      NULL |
|    19 | Xue Baochai   |  18 | F      |       6 |      NULL |
|    20 | Diao Chan     |  19 | F      |       7 |      NULL |
|    21 | Huang Yueying |  22 | F      |       6 |      NULL |
|    22 | Xiao Qiao     |  20 | F      |       1 |      NULL |
|    23 | Ma Chao       |  23 | M      |       4 |      NULL |
|    24 | Xu Xian       |  27 | M      |    NULL |      NULL |
|    25 | Sun Dasheng   | 100 | M      |    NULL |      NULL |
+-------+---------------+-----+--------+---------+-----------+
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到从库把主库里新加的库和表都复制过来了&lt;/p&gt;
&lt;p&gt;有关mysql主从复制详细说明请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/9762855.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/9762855.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$4.$1&quot;&gt;3、使用MHA实现Mysql高可用。&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$4.$1&quot;&gt;　　1）环境说明 3台centos7为mariadb数据库主从复制环境，centos6为mha管理节点，其中node1为主从复制主节点，2、3为从节点&lt;/p&gt;
&lt;p data-reactid=&quot;.0.1.0.1.3.0:$4.$1&quot;&gt;　　2）前期准备工作，关闭所有服务器上的selinu和防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# systemctl stop firewalld
[root@test-centos7-node1 ~]# systemctl is-enabled firewalld
enabled
[root@test-centos7-node1 ~]# systemctl disable firewalld
Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
[root@test-centos7-node1 ~]# systemctl is-enabled firewalld
disabled
[root@test-centos7-node1 ~]# sed -i 's/SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config
[root@test-centos7-node1 ~]# cat /etc/selinux/config

# This file controls the state of SELinux on the system.
# SELINUX=disabled
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 


[root@test-centos7-node1 ~]# setenforce 0
[root@test-centos7-node1 ~]# getenforce
Permissive
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：在主从复制所有节点以及管理节点都关闭防火墙和selinux&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# /etc/init.d/iptables stop
iptables: Setting chains to policy ACCEPT: filter          [  OK  ]
iptables: Flushing firewall rules:                         [  OK  ]
iptables: Unloading modules:                               [  OK  ]
[root@test-centos6-node1 ~]# chkconfig iptables off
[root@test-centos6-node1 ~]# chkconfig --list|grep iptables
iptables        0:off   1:off   2:off   3:off   4:off   5:off   6:off
[root@test-centos6-node1 ~]# sed -i 's/SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config 
[root@test-centos6-node1 ~]# cat /etc/selinux/config

# This file controls the state of SELinux on the system.
# SELINUX=disabled
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of these two values:
#     targeted - Targeted processes are protected,
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 


[root@test-centos6-node1 ~]# setenforce 0
[root@test-centos6-node1 ~]# getenforce 
Permissive
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：centos6是管理节点，也需要关闭防火墙和selinux，这样做就是排除后续做实验，防火墙和selinux带来的不必要的错误。&lt;/p&gt;
&lt;p&gt;　　3）搭建mariadb的主从复制&lt;/p&gt;
&lt;p&gt;　　主节点配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 my.cnf.d]# cat /etc/my.cnf.d/master.cnf 
[mysqld]
log-bin
server_id=1
skip_name_resolve=1
[root@test-centos7-node1 my.cnf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以在server.cnf里添加以上配置，也可以在my.cnf里面加，当然也可以单独建立独立的配置文件，这样方便管理&lt;/p&gt;
&lt;p&gt;　　从节点配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
root@test-centos7-node2 ~]# cat /etc/my.cnf.d/slave.cnf 
[mysqld]
server_id=2
log-bin
read_only
relay_log_purge=0
skip_name_resolve=1
[root@test-centos7-node2 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从节点需要加上relay_log_purge=0表示不清除中继日志。注意这里需要说明一点的是，在备用的主节点(将来可能成为主的服务器)上需要开启log-bin，server_id 的值不同于其他主机即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node3 ~]# cat /etc/my.cnf.d/slave.cnf 
[mysqld]
server_id=3
read_only
relay_log_purge=0
skip_name_resolve=1
[root@test-centos7-node3 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）重新启动所有节点的数据库服务，在主库上查看二进制日志文件名和日志位置点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# systemctl restart mariadb
[root@test-centos7-node1 ~]#
[root@test-centos7-node1 ~]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 2
Server version: 5.5.56-MariaDB MariaDB Server

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show master logs;
+--------------------+-----------+
| Log_name           | File_size |
+--------------------+-----------+
| mariadb-bin.000001 |       245 |
+--------------------+-----------+
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：之所以查看主库二进制日志名称和位置点数方便待会从库里配置&lt;/p&gt;
&lt;p&gt;　　5）主库创建用于从库连接主库复制的账号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; grant replication slave on *.* to repuser@'192.168.0.%' identified by 'admin';
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; select user,host,password from mysql.user;
+---------+--------------------+-------------------------------------------+
| user    | host               | password                                  |
+---------+--------------------+-------------------------------------------+
| root    | localhost          |                                           |
| root    | test-centos7-node1 |                                           |
| root    | 127.0.0.1          |                                           |
| root    | ::1                |                                           |
|         | localhost          |                                           |
|         | test-centos7-node1 |                                           |
| repuser | 192.168.0.%        | *4ACFE3202A5FF5CF467898FC58AAB1D615029441 |
+---------+--------------------+-------------------------------------------+
7 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6）在从库上测试主库刚才建立的账号是否可登录主库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node2 ~]# mysql -urepuser -padmin -h192.168.0.10
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 5.5.56-MariaDB MariaDB Server

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show grants for repuser@'192.168.0.%';
+------------------------------------------------------------------------------------------------------------------------------+
| Grants for repuser@192.168.0.%                                                                                               |
+------------------------------------------------------------------------------------------------------------------------------+
| GRANT REPLICATION SLAVE ON *.* TO 'repuser'@'192.168.0.%' IDENTIFIED BY PASSWORD '*4ACFE3202A5FF5CF467898FC58AAB1D615029441' |
+------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7）在从库上配置连接主库进行复制的账号和二进制日志名称及位置点信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node2 ~]# mysql
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 3
Server version: 5.5.56-MariaDB MariaDB Server

Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]&amp;gt; show slave status\G
Empty set (0.01 sec)

MariaDB [(none)]&amp;gt; CHANGE MASTER TO
    -&amp;gt;   MASTER_HOST='192.168.0.10',
    -&amp;gt;   MASTER_USER='repuser',
    -&amp;gt;   MASTER_PASSWORD='admin',
    -&amp;gt;   MASTER_PORT=3306,
    -&amp;gt;   MASTER_LOG_FILE='mariadb-bin.000001',
    -&amp;gt;   MASTER_LOG_POS=245;
Query OK, 0 rows affected (0.08 sec)

MariaDB [(none)]&amp;gt; show slave status\G                    
*************************** 1. row ***************************
               Slave_IO_State: 
                  Master_Host: 192.168.0.10
                  Master_User: repuser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mariadb-bin.000001
          Read_Master_Log_Pos: 245
               Relay_Log_File: mariadb-relay-bin.000001
                Relay_Log_Pos: 4
        Relay_Master_Log_File: mariadb-bin.000001
             Slave_IO_Running: No
            Slave_SQL_Running: No
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 245
              Relay_Log_Space: 245
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: NULL
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 0
1 row in set (0.01 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：两从库都执行上面相同的change master to 命令即可&lt;/p&gt;
&lt;p&gt;　　8）从库开启复制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; start slave;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; show slave status\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.0.10
                  Master_User: repuser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mariadb-bin.000001
          Read_Master_Log_Pos: 397
               Relay_Log_File: mariadb-relay-bin.000002
                Relay_Log_Pos: 683
        Relay_Master_Log_File: mariadb-bin.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 397
              Relay_Log_Space: 979
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 1
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：到此主从复制就大家完成，接下来在主库上创建用于管理端管理数据库的账号&lt;/p&gt;
&lt;p&gt;　　9）在主库上创建用于管理端管理数据库的管理帐号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
MariaDB [(none)]&amp;gt; grant all on *.* to repmanage@'192.168.0.%' identified by 'admin';                     
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; select user,host,password from mysql.user;                        
+-----------+--------------------+-------------------------------------------+
| user      | host               | password                                  |
+-----------+--------------------+-------------------------------------------+
| root      | localhost          |                                           |
| root      | test-centos7-node1 |                                           |
| root      | 127.0.0.1          |                                           |
| root      | ::1                |                                           |
|           | localhost          |                                           |
|           | test-centos7-node1 |                                           |
| repuser   | 192.168.0.%        | *4ACFE3202A5FF5CF467898FC58AAB1D615029441 |
| repmanage | 192.168.0.%        | *4ACFE3202A5FF5CF467898FC58AAB1D615029441 |
+-----------+--------------------+-------------------------------------------+
8 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此刻就可以去从节点看刚才在主库创建的账号是否同步到从库里去了，如果同步了，说明mariadb的主从复制是没有问题的。&lt;/p&gt;
&lt;p&gt;　　10）在所有节点上做ssh key验证包括管理节点上，实现双向key验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
99:5f:36:b0:d1:cb:d2:85:f3:fa:65:ac:68:86:0e:e3 root@test-centos6-node1
The key's randomart image is:
+--[ RSA 2048]----+
|                 |
|           . .   |
|          o + .  |
|         o * =   |
|        S o B .  |
|         . + o . |
|        o ...   +|
|       . o. oo + |
|        E..o. o  |
+-----------------+
[root@test-centos6-node1 ~]# ssh-copy-id 192.168.0.11
The authenticity of host '192.168.0.11 (192.168.0.11)' can't be established.
RSA key fingerprint is f7:d4:c0:12:41:4a:46:4e:8b:d6:eb:80:06:ca:5e:fe.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.11' (RSA) to the list of known hosts.
root@192.168.0.11's password: 
Now try logging into the machine, with &quot;ssh '192.168.0.11'&quot;, and check in:

  .ssh/authorized_keys

to make sure we haven't added extra keys that you weren't expecting.

[root@test-centos6-node1 ~]# scp -rp /root/.ssh 192.168.0.10:/root/
The authenticity of host '192.168.0.10 (192.168.0.10)' can't be established.
RSA key fingerprint is 7e:4a:a2:53:1b:fa:7b:52:c3:b6:9d:f7:7a:8d:4d:23.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.10' (RSA) to the list of known hosts.
root@192.168.0.10's password: 
authorized_keys                                                                                                                          100%  405     0.4KB/s   00:00    
id_rsa                                                                                                                                   100% 1675     1.6KB/s   00:00    
id_rsa.pub                                                                                                                               100%  405     0.4KB/s   00:00    
known_hosts                                                                                                                              100%  788     0.8KB/s   00:00    
[root@test-centos6-node1 ~]# scp -rp /root/.ssh 192.168.0.20:/root/
The authenticity of host '192.168.0.20 (192.168.0.20)' can't be established.
RSA key fingerprint is 7e:4a:a2:53:1b:fa:7b:52:c3:b6:9d:f7:7a:8d:4d:23.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.20' (RSA) to the list of known hosts.
root@192.168.0.20's password: 
authorized_keys                                                                                                                          100%  405     0.4KB/s   00:00    
id_rsa                                                                                                                                   100% 1675     1.6KB/s   00:00    
id_rsa.pub                                                                                                                               100%  405     0.4KB/s   00:00    
known_hosts                                                                                                                              100% 1182     1.2KB/s   00:00    
[root@test-centos6-node1 ~]# scp -rp /root/.ssh 192.168.0.30:/root/
The authenticity of host '192.168.0.30 (192.168.0.30)' can't be established.
RSA key fingerprint is 7e:4a:a2:53:1b:fa:7b:52:c3:b6:9d:f7:7a:8d:4d:23.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.30' (RSA) to the list of known hosts.
root@192.168.0.30's password: 
authorized_keys                                                                                                                          100%  405     0.4KB/s   00:00    
id_rsa                                                                                                                                   100% 1675     1.6KB/s   00:00    
id_rsa.pub                                                                                                                               100%  405     0.4KB/s   00:00    
known_hosts                                                                                                                              100% 1576     1.5KB/s   00:00    
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：这样在管理端做好了ssh key验证后，管理端可以任意登录被管理端，同时被管理端也可以连接管理端。到此所有环境的准备都已经准备好了，接下来装包&lt;/p&gt;
&lt;p&gt;　　11）在管理端安装两个包mha4mysql-manager和mha4mysql-node&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%      85 KB   85 KB/s 00:00:01       0 Errors-0.el6.noarch.rpm...

[root@test-centos6-node1 ~]# rz
rz waiting to receive.
 zmodem trl+C ȡ

  100%      35 KB   35 KB/s 00:00:01       0 Errorsel6.noarch.rpm...

[root@test-centos6-node1 ~]# ls
mha4mysql-manager-0.56-0.el6.noarch.rpm  mha4mysql-node-0.56-0.el6.noarch.rpm
[root@test-centos6-node1 ~]# yum install mha4mysql-*
Loaded plugins: fastestmirror
Setting up Install Process
Examining mha4mysql-manager-0.56-0.el6.noarch.rpm: mha4mysql-manager-0.56-0.el6.noarch
Marking mha4mysql-manager-0.56-0.el6.noarch.rpm to be installed
Loading mirror speeds from cached hostfile
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Examining mha4mysql-node-0.56-0.el6.noarch.rpm: mha4mysql-node-0.56-0.el6.noarch
Marking mha4mysql-node-0.56-0.el6.noarch.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package mha4mysql-manager.noarch 0:0.56-0.el6 will be installed
--&amp;gt; Processing Dependency: perl(Config::Tiny) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Config::Tiny) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(DBI) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Log::Dispatch) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Log::Dispatch) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Log::Dispatch::File) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Log::Dispatch::Screen) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Parallel::ForkManager) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Parallel::ForkManager) for package: mha4mysql-manager-0.56-0.el6.noarch
--&amp;gt; Processing Dependency: perl(Time::HiRes) for package: mha4mysql-manager-0.56-0.el6.noarch
---&amp;gt; Package mha4mysql-node.noarch 0:0.56-0.el6 will be installed
--&amp;gt; Processing Dependency: perl(DBD::mysql) for package: mha4mysql-node-0.56-0.el6.noarch
--&amp;gt; Running transaction check
---&amp;gt; Package perl-Config-Tiny.noarch 0:2.12-7.1.el6 will be installed
---&amp;gt; Package perl-DBD-MySQL.x86_64 0:4.013-3.el6 will be installed
---&amp;gt; Package perl-DBI.x86_64 0:1.609-4.el6 will be installed
---&amp;gt; Package perl-Log-Dispatch.noarch 0:2.27-1.el6 will be installed
--&amp;gt; Processing Dependency: perl(MIME::Lite) for package: perl-Log-Dispatch-2.27-1.el6.noarch
--&amp;gt; Processing Dependency: perl(Mail::Send) for package: perl-Log-Dispatch-2.27-1.el6.noarch
--&amp;gt; Processing Dependency: perl(Mail::Sender) for package: perl-Log-Dispatch-2.27-1.el6.noarch
--&amp;gt; Processing Dependency: perl(Mail::Sendmail) for package: perl-Log-Dispatch-2.27-1.el6.noarch
--&amp;gt; Processing Dependency: perl(Params::Validate) for package: perl-Log-Dispatch-2.27-1.el6.noarch
---&amp;gt; Package perl-Parallel-ForkManager.noarch 0:1.20-1.el6 will be installed
---&amp;gt; Package perl-Time-HiRes.x86_64 4:1.9721-144.el6 will be installed
--&amp;gt; Running transaction check
---&amp;gt; Package perl-MIME-Lite.noarch 0:3.027-2.el6 will be installed
--&amp;gt; Processing Dependency: perl(MIME::Types) &amp;gt;= 1.28 for package: perl-MIME-Lite-3.027-2.el6.noarch
--&amp;gt; Processing Dependency: perl(Email::Date::Format) for package: perl-MIME-Lite-3.027-2.el6.noarch
---&amp;gt; Package perl-Mail-Sender.noarch 0:0.8.16-3.el6 will be installed
---&amp;gt; Package perl-Mail-Sendmail.noarch 0:0.79-12.el6 will be installed
---&amp;gt; Package perl-MailTools.noarch 0:2.04-4.el6 will be installed
--&amp;gt; Processing Dependency: perl(Date::Parse) for package: perl-MailTools-2.04-4.el6.noarch
--&amp;gt; Processing Dependency: perl(Date::Format) for package: perl-MailTools-2.04-4.el6.noarch
---&amp;gt; Package perl-Params-Validate.x86_64 0:0.92-3.el6 will be installed
--&amp;gt; Running transaction check
---&amp;gt; Package perl-Email-Date-Format.noarch 0:1.002-5.el6 will be installed
---&amp;gt; Package perl-MIME-Types.noarch 0:1.28-2.el6 will be installed
---&amp;gt; Package perl-TimeDate.noarch 1:1.16-13.el6 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

=================================================================================================
 Package                   Arch   Version             Repository                            Size
=================================================================================================
Installing:
 mha4mysql-manager         noarch 0.56-0.el6          /mha4mysql-manager-0.56-0.el6.noarch 325 k
 mha4mysql-node            noarch 0.56-0.el6          /mha4mysql-node-0.56-0.el6.noarch    102 k
Installing for dependencies:
 perl-Config-Tiny          noarch 2.12-7.1.el6        base                                  23 k
 perl-DBD-MySQL            x86_64 4.013-3.el6         base                                 134 k
 perl-DBI                  x86_64 1.609-4.el6         base                                 705 k
 perl-Email-Date-Format    noarch 1.002-5.el6         base                                  16 k
 perl-Log-Dispatch         noarch 2.27-1.el6          epel                                  71 k
 perl-MIME-Lite            noarch 3.027-2.el6         base                                  82 k
 perl-MIME-Types           noarch 1.28-2.el6          base                                  32 k
 perl-Mail-Sender          noarch 0.8.16-3.el6        epel                                  54 k
 perl-Mail-Sendmail        noarch 0.79-12.el6         epel                                  28 k
 perl-MailTools            noarch 2.04-4.el6          base                                 101 k
 perl-Parallel-ForkManager noarch 1.20-1.el6          epel                                  27 k
 perl-Params-Validate      x86_64 0.92-3.el6          base                                  75 k
 perl-Time-HiRes           x86_64 4:1.9721-144.el6    base                                  49 k
 perl-TimeDate             noarch 1:1.16-13.el6       base                                  37 k

Transaction Summary
=================================================================================================
Install      16 Package(s)

Total size: 1.8 M
Total download size: 1.4 M
Installed size: 3.5 M
Is this ok [y/N]: y
Downloading Packages:
(1/14): perl-Config-Tiny-2.12-7.1.el6.noarch.rpm                          |  23 kB     00:00     
(2/14): perl-DBD-MySQL-4.013-3.el6.x86_64.rpm                             | 134 kB     00:00     
(3/14): perl-DBI-1.609-4.el6.x86_64.rpm                                   | 705 kB     00:00     
(4/14): perl-Email-Date-Format-1.002-5.el6.noarch.rpm                     |  16 kB     00:00     
(5/14): perl-Log-Dispatch-2.27-1.el6.noarch.rpm                           |  71 kB     00:00     
(6/14): perl-MIME-Lite-3.027-2.el6.noarch.rpm                             |  82 kB     00:00     
(7/14): perl-MIME-Types-1.28-2.el6.noarch.rpm                             |  32 kB     00:00     
(8/14): perl-Mail-Sender-0.8.16-3.el6.noarch.rpm                          |  54 kB     00:00     
(9/14): perl-Mail-Sendmail-0.79-12.el6.noarch.rpm                         |  28 kB     00:00     
(10/14): perl-MailTools-2.04-4.el6.noarch.rpm                             | 101 kB     00:00     
(11/14): perl-Parallel-ForkManager-1.20-1.el6.noarch.rpm                  |  27 kB     00:00     
(12/14): perl-Params-Validate-0.92-3.el6.x86_64.rpm                       |  75 kB     00:00     
(13/14): perl-Time-HiRes-1.9721-144.el6.x86_64.rpm                        |  49 kB     00:00     
(14/14): perl-TimeDate-1.16-13.el6.noarch.rpm                             |  37 kB     00:00     
-------------------------------------------------------------------------------------------------
Total                                                            669 kB/s | 1.4 MB     00:02     
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : perl-DBI-1.609-4.el6.x86_64                                                  1/16 
  Installing : perl-DBD-MySQL-4.013-3.el6.x86_64                                            2/16 
  Installing : mha4mysql-node-0.56-0.el6.noarch                                             3/16 
  Installing : perl-MIME-Types-1.28-2.el6.noarch                                            4/16 
  Installing : perl-Config-Tiny-2.12-7.1.el6.noarch                                         5/16 
  Installing : perl-Parallel-ForkManager-1.20-1.el6.noarch                                  6/16 
  Installing : perl-Params-Validate-0.92-3.el6.x86_64                                       7/16 
  Installing : 4:perl-Time-HiRes-1.9721-144.el6.x86_64                                      8/16 
  Installing : perl-Mail-Sender-0.8.16-3.el6.noarch                                         9/16 
  Installing : 1:perl-TimeDate-1.16-13.el6.noarch                                          10/16 
  Installing : perl-MailTools-2.04-4.el6.noarch                                            11/16 
  Installing : perl-Mail-Sendmail-0.79-12.el6.noarch                                       12/16 
  Installing : perl-Email-Date-Format-1.002-5.el6.noarch                                   13/16 
  Installing : perl-MIME-Lite-3.027-2.el6.noarch                                           14/16 
  Installing : perl-Log-Dispatch-2.27-1.el6.noarch                                         15/16 
  Installing : mha4mysql-manager-0.56-0.el6.noarch                                         16/16 
  Verifying  : mha4mysql-manager-0.56-0.el6.noarch                                          1/16 
  Verifying  : perl-Email-Date-Format-1.002-5.el6.noarch                                    2/16 
  Verifying  : perl-Mail-Sendmail-0.79-12.el6.noarch                                        3/16 
  Verifying  : mha4mysql-node-0.56-0.el6.noarch                                             4/16 
  Verifying  : perl-DBD-MySQL-4.013-3.el6.x86_64                                            5/16 
  Verifying  : 1:perl-TimeDate-1.16-13.el6.noarch                                           6/16 
  Verifying  : perl-MIME-Lite-3.027-2.el6.noarch                                            7/16 
  Verifying  : perl-Mail-Sender-0.8.16-3.el6.noarch                                         8/16 
  Verifying  : perl-DBI-1.609-4.el6.x86_64                                                  9/16 
  Verifying  : 4:perl-Time-HiRes-1.9721-144.el6.x86_64                                     10/16 
  Verifying  : perl-Params-Validate-0.92-3.el6.x86_64                                      11/16 
  Verifying  : perl-MailTools-2.04-4.el6.noarch                                            12/16 
  Verifying  : perl-Parallel-ForkManager-1.20-1.el6.noarch                                 13/16 
  Verifying  : perl-Config-Tiny-2.12-7.1.el6.noarch                                        14/16 
  Verifying  : perl-Log-Dispatch-2.27-1.el6.noarch                                         15/16 
  Verifying  : perl-MIME-Types-1.28-2.el6.noarch                                           16/16 

Installed:
  mha4mysql-manager.noarch 0:0.56-0.el6            mha4mysql-node.noarch 0:0.56-0.el6           

Dependency Installed:
  perl-Config-Tiny.noarch 0:2.12-7.1.el6           perl-DBD-MySQL.x86_64 0:4.013-3.el6           
  perl-DBI.x86_64 0:1.609-4.el6                    perl-Email-Date-Format.noarch 0:1.002-5.el6   
  perl-Log-Dispatch.noarch 0:2.27-1.el6            perl-MIME-Lite.noarch 0:3.027-2.el6           
  perl-MIME-Types.noarch 0:1.28-2.el6              perl-Mail-Sender.noarch 0:0.8.16-3.el6        
  perl-Mail-Sendmail.noarch 0:0.79-12.el6          perl-MailTools.noarch 0:2.04-4.el6            
  perl-Parallel-ForkManager.noarch 0:1.20-1.el6    perl-Params-Validate.x86_64 0:0.92-3.el6      
  perl-Time-HiRes.x86_64 4:1.9721-144.el6          perl-TimeDate.noarch 1:1.16-13.el6            

Complete!
[root@test-centos6-node1 ~]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：安装这两个包需要开启epel源，因为它们的依赖包有些来自epel源里&lt;/p&gt;
&lt;p&gt;　　12）在各个被管理端安装mha4mysql-node包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# ls
mha4mysql-node-0.56-0.el6.noarch.rpm
[root@test-centos7-node1 ~]# yum install mha4mysql-node-0.56-0.el6.noarch.rpm 
Loaded plugins: fastestmirror
Examining mha4mysql-node-0.56-0.el6.noarch.rpm: mha4mysql-node-0.56-0.el6.noarch
Marking mha4mysql-node-0.56-0.el6.noarch.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package mha4mysql-node.noarch 0:0.56-0.el6 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

=================================================================================================================================
 Package                     Arch                Version                    Repository                                      Size
=================================================================================================================================
Installing:
 mha4mysql-node              noarch              0.56-0.el6                 /mha4mysql-node-0.56-0.el6.noarch              102 k

Transaction Summary
=================================================================================================================================
Install  1 Package

Total size: 102 k
Installed size: 102 k
Is this ok [y/d/N]: y
Downloading packages:
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : mha4mysql-node-0.56-0.el6.noarch                                                                              1/1 
  Verifying  : mha4mysql-node-0.56-0.el6.noarch                                                                              1/1 

Installed:
  mha4mysql-node.noarch 0:0.56-0.el6                                                                                             

Complete!
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：到此mha的软件都已部署完毕，接下来是在管理端建立配置文件&lt;/p&gt;
&lt;p&gt;　　13）在管理节点新建配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# mkdir /etc/mastermh/   
[root@test-centos6-node1 ~]# cd /etc/mastermh/
[root@test-centos6-node1 mastermh]# cat &amp;gt;&amp;gt; mariadb.cnf &amp;lt;&amp;lt; EOF
&amp;gt; [server default]
&amp;gt; user=repmanage
&amp;gt; password=admin
&amp;gt; manager_workdir=/data/mastermha/mariadb/
&amp;gt; manager_log=/data/mastermha/mariadb/manager.log
&amp;gt; remote_workdir=/data/mastermha/mariadb/
&amp;gt; ssh_user=root
&amp;gt; repl_user=repuser
&amp;gt; repl_password=admin
&amp;gt; ping_interval=1
&amp;gt; 
&amp;gt; 
&amp;gt; [server1]
&amp;gt; hostname=192.168.0.10
&amp;gt; candidate_master=1
&amp;gt; [server2]
&amp;gt; hostname=192.168.0.20
&amp;gt; candidate_master=1
&amp;gt; [server3]
&amp;gt; hostname=192.168.0.30
&amp;gt; EOF
[root@test-centos6-node1 mastermh]# cat mariadb.cnf 
[server default]
user=repmanage
password=admin
manager_workdir=/data/mastermha/mariadb/
manager_log=/data/mastermha/mariadb/manager.log
remote_workdir=/data/mastermha/mariadb/
ssh_user=root
repl_user=repuser
repl_password=admin
ping_interval=1


[server1]
hostname=192.168.0.10
candidate_master=1
[server2]
hostname=192.168.0.20
candidate_master=1
[server3]
hostname=192.168.0.30
[root@test-centos6-node1 mastermh]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此文件的文件可以说任意名称，只要自己知道就行，也没有特定规定放在哪个位置，看自己的喜好即可。因为待会启动mha 我们是要指定配置文件的路径，配置文件中主要配置了用于管理mariadb节点的账号密码以及ssh管理的用户以及主从复制到账号和密码信息还有就是各个节点的地址，candidate_master=1表示将来可能选举成为主节点。ping_interval=1表示检测主库的时间间隔，心跳值；配置文件中manager的工作目录和日志目录我们不需要提前建立好，它这个目录只要我们指定了会自动生成的。&lt;/p&gt;
&lt;p&gt;　　14）mha验证ssh基于KEY验证是否正常&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# masterha_check_ssh --conf=/etc/mastermh/mariadb.cnf 
Tue Jan 14 08:05:04 2020 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Tue Jan 14 08:05:04 2020 - [info] Reading application default configuration from /etc/mastermh/mariadb.cnf..
Tue Jan 14 08:05:04 2020 - [info] Reading server configuration from /etc/mastermh/mariadb.cnf..
Tue Jan 14 08:05:04 2020 - [info] Starting SSH connection tests..
Tue Jan 14 08:05:05 2020 - [debug] 
Tue Jan 14 08:05:04 2020 - [debug]  Connecting via SSH from root@192.168.0.10(192.168.0.10:22) to root@192.168.0.20(192.168.0.20:22)..
Warning: Permanently added '192.168.0.20' (ECDSA) to the list of known hosts.
Tue Jan 14 08:05:05 2020 - [debug]   ok.
Tue Jan 14 08:05:05 2020 - [debug]  Connecting via SSH from root@192.168.0.10(192.168.0.10:22) to root@192.168.0.30(192.168.0.30:22)..
Warning: Permanently added '192.168.0.30' (ECDSA) to the list of known hosts.
Tue Jan 14 08:05:05 2020 - [debug]   ok.
Tue Jan 14 08:05:06 2020 - [debug] 
Tue Jan 14 08:05:05 2020 - [debug]  Connecting via SSH from root@192.168.0.30(192.168.0.30:22) to root@192.168.0.10(192.168.0.10:22)..
Tue Jan 14 08:05:06 2020 - [debug]   ok.
Tue Jan 14 08:05:06 2020 - [debug]  Connecting via SSH from root@192.168.0.30(192.168.0.30:22) to root@192.168.0.20(192.168.0.20:22)..
Tue Jan 14 08:05:06 2020 - [debug]   ok.
Tue Jan 14 08:05:06 2020 - [debug] 
Tue Jan 14 08:05:04 2020 - [debug]  Connecting via SSH from root@192.168.0.20(192.168.0.20:22) to root@192.168.0.10(192.168.0.10:22)..
Tue Jan 14 08:05:05 2020 - [debug]   ok.
Tue Jan 14 08:05:05 2020 - [debug]  Connecting via SSH from root@192.168.0.20(192.168.0.20:22) to root@192.168.0.30(192.168.0.30:22)..
Warning: Permanently added '192.168.0.30' (ECDSA) to the list of known hosts.
Tue Jan 14 08:05:06 2020 - [debug]   ok.
Tue Jan 14 08:05:06 2020 - [info] All SSH connection tests passed successfully.
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：如果没有报错表示SSH key验证是没有问题的，在配置文件中配置的ssh信息是正确的&lt;/p&gt;
&lt;p&gt;　　15）mha验证配置文件中配置的主从复制信息是否正确&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# masterha_check_repl --conf=/etc/mastermh/mariadb.cnf 
Tue Jan 14 09:55:54 2020 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Tue Jan 14 09:55:54 2020 - [info] Reading application default configuration from /etc/mastermh/mariadb.cnf..
Tue Jan 14 09:55:54 2020 - [info] Reading server configuration from /etc/mastermh/mariadb.cnf..
Tue Jan 14 09:55:54 2020 - [info] MHA::MasterMonitor version 0.56.
Tue Jan 14 09:55:55 2020 - [info] GTID failover mode = 0
Tue Jan 14 09:55:55 2020 - [info] Dead Servers:
Tue Jan 14 09:55:55 2020 - [info] Alive Servers:
Tue Jan 14 09:55:55 2020 - [info]   192.168.0.10(192.168.0.10:3306)
Tue Jan 14 09:55:55 2020 - [info]   192.168.0.20(192.168.0.20:3306)
Tue Jan 14 09:55:55 2020 - [info]   192.168.0.30(192.168.0.30:3306)
Tue Jan 14 09:55:55 2020 - [info] Alive Slaves:
Tue Jan 14 09:55:55 2020 - [info]   192.168.0.20(192.168.0.20:3306)  Version=5.5.56-MariaDB (oldest major version between slaves) log-bin:enabled
Tue Jan 14 09:55:55 2020 - [info]     Replicating from 192.168.0.10(192.168.0.10:3306)
Tue Jan 14 09:55:55 2020 - [info]     Primary candidate for the new Master (candidate_master is set)
Tue Jan 14 09:55:55 2020 - [info]   192.168.0.30(192.168.0.30:3306)  Version=5.5.56-MariaDB (oldest major version between slaves) log-bin:disabled
Tue Jan 14 09:55:55 2020 - [info]     Replicating from 192.168.0.10(192.168.0.10:3306)
Tue Jan 14 09:55:55 2020 - [info] Current Alive Master: 192.168.0.10(192.168.0.10:3306)
Tue Jan 14 09:55:55 2020 - [info] Checking slave configurations..
Tue Jan 14 09:55:55 2020 - [warning]  log-bin is not set on slave 192.168.0.30(192.168.0.30:3306). This host cannot be a master.
Tue Jan 14 09:55:55 2020 - [info] Checking replication filtering settings..
Tue Jan 14 09:55:55 2020 - [info]  binlog_do_db= , binlog_ignore_db= 
Tue Jan 14 09:55:55 2020 - [info]  Replication filtering check ok.
Tue Jan 14 09:55:55 2020 - [info] GTID (with auto-pos) is not supported
Tue Jan 14 09:55:55 2020 - [info] Starting SSH connection tests..
Tue Jan 14 09:55:58 2020 - [info] All SSH connection tests passed successfully.
Tue Jan 14 09:55:58 2020 - [info] Checking MHA Node version..
Tue Jan 14 09:55:58 2020 - [info]  Version check ok.
Tue Jan 14 09:55:58 2020 - [info] Checking SSH publickey authentication settings on the current master..
Tue Jan 14 09:55:59 2020 - [info] HealthCheck: SSH to 192.168.0.10 is reachable.
Tue Jan 14 09:55:59 2020 - [info] Master MHA Node version is 0.56.
Tue Jan 14 09:55:59 2020 - [info] Checking recovery script configurations on 192.168.0.10(192.168.0.10:3306)..
Tue Jan 14 09:55:59 2020 - [info]   Executing command: save_binary_logs --command=test --start_pos=4 --binlog_dir=/var/lib/mysql,/var/log/mysql --output_file=/data/mastermha/mariadb//save_binary_logs_test --manager_version=0.56 --start_file=mariadb-bin.000002 
Tue Jan 14 09:55:59 2020 - [info]   Connecting to root@192.168.0.10(192.168.0.10:22).. 
  Creating /data/mastermha/mariadb if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to mariadb-bin.000002
Tue Jan 14 09:55:59 2020 - [info] Binlog setting check done.
Tue Jan 14 09:55:59 2020 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..
Tue Jan 14 09:55:59 2020 - [info]   Executing command : apply_diff_relay_logs --command=test --slave_user='repmanage' --slave_host=192.168.0.20 --slave_ip=192.168.0.20 --slave_port=3306 --workdir=/data/mastermha/mariadb/ --target_version=5.5.56-MariaDB --manager_version=0.56 --relay_log_info=/var/lib/mysql/relay-log.info  --relay_dir=/var/lib/mysql/  --slave_pass=xxx
Tue Jan 14 09:55:59 2020 - [info]   Connecting to root@192.168.0.20(192.168.0.20:22).. 
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to mariadb-relay-bin.000007
    Temporary relay log file is /var/lib/mysql/mariadb-relay-bin.000007
    Testing mysql connection and privileges.. done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Tue Jan 14 09:55:59 2020 - [info]   Executing command : apply_diff_relay_logs --command=test --slave_user='repmanage' --slave_host=192.168.0.30 --slave_ip=192.168.0.30 --slave_port=3306 --workdir=/data/mastermha/mariadb/ --target_version=5.5.56-MariaDB --manager_version=0.56 --relay_log_info=/var/lib/mysql/relay-log.info  --relay_dir=/var/lib/mysql/  --slave_pass=xxx
Tue Jan 14 09:55:59 2020 - [info]   Connecting to root@192.168.0.30(192.168.0.30:22).. 
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to mariadb-relay-bin.000009
    Temporary relay log file is /var/lib/mysql/mariadb-relay-bin.000009
    Testing mysql connection and privileges.. done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Tue Jan 14 09:56:00 2020 - [info] Slaves settings check done.
Tue Jan 14 09:56:00 2020 - [info] 
192.168.0.10(192.168.0.10:3306) (current master)
 +--192.168.0.20(192.168.0.20:3306)
 +--192.168.0.30(192.168.0.30:3306)

Tue Jan 14 09:56:00 2020 - [info] Checking replication health on 192.168.0.20..
Tue Jan 14 09:56:00 2020 - [info]  ok.
Tue Jan 14 09:56:00 2020 - [info] Checking replication health on 192.168.0.30..
Tue Jan 14 09:56:00 2020 - [info]  ok.
Tue Jan 14 09:56:00 2020 - [warning] master_ip_failover_script is not defined.
Tue Jan 14 09:56:00 2020 - [warning] shutdown_script is not defined.
Tue Jan 14 09:56:00 2020 - [info] Got exit code 0 (Not master dead).

MySQL Replication Health is OK.
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：看到最后提示MySQL Replication Health is OK 代表我们mariadb主从复制环境是健康的。接下来就可以开启监控&lt;/p&gt;
&lt;p&gt;　　16）启动mha&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200114015833829-1273132581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：mha开启默认是前台执行，所以我们开启后光标一直在屏幕上闪烁，看到这种情况说明mha已经在监控我们的主从复制环境了，生产环境中 一般建议后台运行，前台运行关闭了CRT，mha也跟随着停止了工作，所以后台方式运行最佳。还需要说明一点的是mha它只是一次使用，也就是说它不能重复使用，如果我们主从环境中主节点宕机了，它的工作就是把主切换到我们预先配置的从节点，使其变为主节点，后续它就退出。接下来测试&lt;/p&gt;
&lt;p&gt;　　测试：把主从环境中的主节点宕机，看看mha是否能够将我们预先设置好的从切换成主&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200114020723896-896427889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200114020740444-444599704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：我们在主库上停止了mariadb服务后，管理节点上的mha立马就有反应了，过后就退出了，从上面的mha打印的信息看不出来具体哪个服务器成为主库了。我们可以查看manager的日志可以看到&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# tail -20 /data/mastermha/mariadb/manager.log
Tue Jan 14 10:07:03 2020 - [info] Master failover to 192.168.0.20(192.168.0.20:3306) completed successfully.
Tue Jan 14 10:07:03 2020 - [info] 

----- Failover Report -----

mariadb: MySQL Master failover 192.168.0.10(192.168.0.10:3306) to 192.168.0.20(192.168.0.20:3306) succeeded

Master 192.168.0.10(192.168.0.10:3306) is down!

Check MHA Manager logs at test-centos6-node1:/data/mastermha/mariadb/manager.log for details.

Started automated(non-interactive) failover.
The latest slave 192.168.0.20(192.168.0.20:3306) has all relay logs for recovery.
Selected 192.168.0.20(192.168.0.20:3306) as a new master.
192.168.0.20(192.168.0.20:3306): OK: Applying all logs succeeded.
192.168.0.30(192.168.0.30:3306): This host has the latest relay log events.
Generating relay diff files from the latest slave succeeded.
192.168.0.30(192.168.0.30:3306): OK: Applying all logs succeeded. Slave started, replicating from 192.168.0.20(192.168.0.20:3306)
192.168.0.20(192.168.0.20:3306): Resetting slave info succeeded.
Master failover to 192.168.0.20(192.168.0.20:3306) completed successfully.
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：从manage.log里记录的日志可以看到主库从192.168.0.10成功转移到192.168.0.20上，并且192.168.0.30已经从192.168.0.20哪里把所有的日志应用成功，并启动了slave，也就是告诉我们30已经切换新主去做主从同步数据了　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node3 ~]# mysql -e &quot;show slave status\G&quot;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.0.20
                  Master_User: repuser
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mariadb-bin.000003
          Read_Master_Log_Pos: 245
               Relay_Log_File: mariadb-relay-bin.000002
                Relay_Log_Pos: 531
        Relay_Master_Log_File: mariadb-bin.000003
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
           Replicate_Do_Table: 
       Replicate_Ignore_Table: 
      Replicate_Wild_Do_Table: 
  Replicate_Wild_Ignore_Table: 
                   Last_Errno: 0
                   Last_Error: 
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 245
              Relay_Log_Space: 827
              Until_Condition: None
               Until_Log_File: 
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File: 
           Master_SSL_CA_Path: 
              Master_SSL_Cert: 
            Master_SSL_Cipher: 
               Master_SSL_Key: 
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error: 
               Last_SQL_Errno: 0
               Last_SQL_Error: 
  Replicate_Ignore_Server_Ids: 
             Master_Server_Id: 2
[root@test-centos7-node3 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到原来的从库已经拥护现在新的主库了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node2 ~]# mysql -e &quot; show slave status&quot;  
[root@test-centos7-node2 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：原来的从节点上已经没有原主库同步的信息了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node2 ~]# mysql -e &quot; show variables like 'read_only'&quot;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| read_only     | OFF   |
+---------------+-------+
[root@test-centos7-node2 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：原来的从节点只读属性已经关闭了，这是因为原来的主节点宕机后，管理端把它提升为主的同时，关闭了它的只读属性。这里还需要说明一点，mha切换了主后，如果原来的主库后续又恢复正常，此时它也不能顶替现在的主库，相当于它和现在的集群环境没有关系了，只是一台单独的主机。&lt;/p&gt;
&lt;p&gt;到此mha高可用实验就做完了，以上就是mha高可用实验的整个过程。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 13 Jan 2020 18:37:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>1、编写脚本，支持让用户自主选择，使用mysqldump还是xtraback全量备份。 [root@test-centos7-node1 scripts]# cat chose_backup_mysq</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12183521.html</dc:identifier>
</item>
<item>
<title>Java多线程的三种实现方式 - dengyongchang</title>
<link>http://www.cnblogs.com/sunshine6/p/12190127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine6/p/12190127.html</guid>
<description>&lt;p&gt;今天简单说一下Java三种多线程实现方式和区别，主要有实现Runnable、Callable和继承Thread三种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现Runnable的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式比较常用，当我们的线程类有继承其他的类的情况下（Java不支持类多继承），并且线程任务不需要返回值的情况下可以选用这种方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadRunnableDemo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 计数变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         ThreadRunnableDemo threadRunnableDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadRunnableDemo();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化线程&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(threadRunnableDemo, &quot;threadRunnableDemoA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(String.format(&quot;线程状态preStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠1000ms&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(String.format(&quot;线程状态after1000ms: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         System.out.println(String.format(&quot;线程名称：%s, 线程状态：%s, count：%s&quot;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                Thread.currentThread().getName(), Thread.currentThread().getState(), count));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;线程状态preStart: NEW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;线程状态afterStart: RUNNABLE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 线程名称：threadRunnableDemoA, 线程状态：RUNNABLE, count：1
&lt;span&gt;4&lt;/span&gt; 线程状态after1000ms: TERMINATED
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;实现Callable的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们执行线程需要返回值的时候那么就必须选用实现Callable类的方式，因为目前只有这种方式能返回值。当然这种方式我们也可以不需要获取返回值。&lt;/p&gt;
&lt;p&gt;这种方式是通过FutureTask的get()方法（下面代码的第22行）或者get(long timeout, TimeUnit unit)（下面代码的第28行）方法获取返回值。当我们看Callable的接口定义的源码会发现“public interface Callable&amp;lt;V&amp;gt; ” ，我们实现的时候是需要定义返回类型，如下面代码所示。&lt;/p&gt;
&lt;p&gt;除此之外我们还需要注意的是：当我们通过FutureTask的get()方法去获取线程的返回值的时候是要等到线程call()内容都执行完毕之后才能获取得到，并且get()方法后面的代码必须等待，说明这一定是同步的，所以我们可以在真正需要线程返回值的时候才通过get()方法去获取，以免被阻塞。当我们通过get(long timeout, TimeUnit unit)方式去获取的时候可以设置超时时间，如果超过所设置的超时时间都没有获取到线程返回的值则会抛出 java.util.concurrent.TimeoutException 异常，当然如果在get(long timeout, TimeUnit unit)之前用get()方式获取了的话就不会抛异常。&lt;/p&gt;
&lt;p&gt;实现Callable还有个好处就是可以线程可以抛异常，如果我们需要在线程里抛出异常的话也可以选用这种方式，其他两种方式只能捕获异常信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadCallableDemo &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 计数变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException, TimeoutException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         ThreadCallableDemo threadCallableDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadCallableDemo();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过FutureTask获取返回值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         FutureTask&amp;lt;Integer&amp;gt; taskA = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(threadCallableDemo);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化线程&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(taskA, &quot;threadCallableDemoA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(String.format(&quot;线程状态preStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过FutureTask的get()方法获取返回值&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; taskA.get();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;是否同步测试....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(String.format(&quot;result: %s&quot;&lt;span&gt;, result));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterGetResult1: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过FutureTask的get()方法获取返回值 设置超时时间 单位为ms&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; resultWithTime = taskA.get(100&lt;span&gt;, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(String.format(&quot;resultWithTime: %s&quot;&lt;span&gt;, resultWithTime));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterGetResult2: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * 实现Callable的call类
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自增&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         
&lt;span&gt;43&lt;/span&gt;         System.out.println(String.format(&quot;线程名称：%s, 线程状态：%s, count：%s&quot;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    Thread.currentThread().getName(), Thread.currentThread().getState(), count));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         System.out.println(&quot;休眠1000ms....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         Thread.currentThread().sleep(1000);
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;线程状态preStart: NEW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;线程状态afterStart: RUNNABLE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 线程名称：threadCallableDemoA, 线程状态：RUNNABLE, count：1
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;休眠1000ms....
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;是否同步测试....
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; result: 1
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;线程状态afterGetResult1: TERMINATED
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; resultWithTime: 1
&lt;span&gt;9&lt;/span&gt; 线程状态afterGetResult2: TERMINATED
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;继承Thread的方式 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Thread类实际上也是实现Runnable接口，所以当我们继承Thread的时候我们即使不实现run()方法也不会报错，这种方式也经常用。&lt;/p&gt;
&lt;p&gt;下面我写了两种不同继承Thread的代码，大家可以看一下区别，我在网上看到很多人说 继承Thread实现多线程，线程间不能共享数据，但是我用下面的代码1方式似乎也可以共享哇，欢迎大家提出质疑。&lt;/p&gt;
&lt;p&gt;代码1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadThreadDemo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 计数变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         ThreadThreadDemo  threadThreadDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadThreadDemo();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化线程&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(threadThreadDemo, &quot;threadThreadDemoA&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(String.format(&quot;线程状态preStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterStart: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠1000s&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(String.format(&quot;线程状态after1000ms: %s&quot;&lt;span&gt;, thread.getState()));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt;         System.out.println(String.format(&quot;线程名称：%s, 线程状态：%s, count：%s&quot;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                Thread.currentThread().getName(), Thread.currentThread().getState(), count));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;线程状态preStart: NEW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;线程状态afterStart: RUNNABLE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 线程名称：threadThreadDemoA, 线程状态：RUNNABLE, count：1
&lt;span&gt;4&lt;/span&gt; 线程状态after1000ms: TERMINATED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 代码2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadThreadDemo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 计数变量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         ThreadThreadDemo  threadThreadDemo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadThreadDemo();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化线程&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         System.out.println(String.format(&quot;线程状态preStart: %s&quot;&lt;span&gt;, threadThreadDemo.getState()));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        threadThreadDemo.start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(String.format(&quot;线程状态afterStart: %s&quot;&lt;span&gt;, threadThreadDemo.getState()));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠1000s&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(String.format(&quot;线程状态after1000ms: %s&quot;&lt;span&gt;, threadThreadDemo.getState()));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt;         System.out.println(String.format(&quot;线程名称：%s, 线程状态：%s, count：%s&quot;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                Thread.currentThread().getName(), Thread.currentThread().getState(), count));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;线程状态preStart: NEW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;线程状态afterStart: RUNNABLE
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 线程名称：Thread-0, 线程状态：RUNNABLE, count：1
&lt;span&gt;4&lt;/span&gt; 线程状态after1000ms: TERMINATED
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果不要求线程返回结果，也不需要抛异常也没有继承其他的类，那么三种方式可以任选，看喜好；&lt;/li&gt;
&lt;li&gt;如果有继承其他类，那么就只能用实现Runnable和实现Callable的方式；&lt;/li&gt;
&lt;li&gt;如果需要线程返回结果或者需要线程抛异常那么选择实现Callable的方式的方式，但是需要注意的是获取返回结果是同步的方式。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果有疑问或者有问题欢迎留言讨论！&lt;/p&gt;


</description>
<pubDate>Mon, 13 Jan 2020 17:43:00 +0000</pubDate>
<dc:creator>dengyongchang</dc:creator>
<og:description>今天简单说一下Java三种多线程实现方式和区别，主要有实现Runnable、Callable和继承Thread三种方式。 实现Runnable的方式 这种方式比较常用，当我们的线程类有继承其他的类的情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshine6/p/12190127.html</dc:identifier>
</item>
<item>
<title>揭发233的docker/machine - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/233docker-machine.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/233docker-machine.html</guid>
<description>&lt;p&gt;继&lt;a id=&quot;post_title_link_12182346&quot; href=&quot;https://www.cnblogs.com/A-Z/p/build_docker_vmware_driver.html&quot;&gt;手动滑稽之golang-vmware-driver广告篇&lt;/a&gt;，今天把vmware-driver完成&lt;/p&gt;
&lt;p&gt;然而我却要发一篇牢骚，这是对docker公信力的挑战！！！&lt;/p&gt;
&lt;p&gt;本来很简单的升级到vmware 15.x的兼容vmx文件简直是小菜一碟&lt;/p&gt;
&lt;p&gt;顺着大便，把&lt;a id=&quot;post_title_link_12174190&quot; href=&quot;https://www.cnblogs.com/A-Z/p/docker2dockerfile.html&quot;&gt;Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO) 下篇dockerの奥义&lt;/a&gt;提到的知识点1涂抹了一下&lt;/p&gt;
&lt;p&gt;这样就达成了1986年toshiba洗衣机广告那样的&lt;span&gt;全自动效应&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更新driver再也不用打开VMware workstation手动停止，更新配置了，效果异常的完美&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在此基础之上，配套了ssh和dockerd port,这样我又可以让各位猜猜猜了&lt;/p&gt;
&lt;p&gt;然而ssh port配合无间，dockerd port就...一言能尽，失败！&lt;/p&gt;
&lt;p&gt;为什么失败先从怎么成功说起，一言能尽，减了一处hard code，加了3行GetSSHPort，内容从base.go来，d *BaseDriver好吧，这点legacy就别缴税了&lt;/p&gt;
&lt;p&gt;错误性息就不贴了没头脑和不高兴，聚焦到流程后，我在git的源码处发现了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;WaitForDocker() --&amp;gt; provision.WaitForDocker(provisioner, engine.DefaultPort)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果进一步检索，甚至发现&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;dockerPort &lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;:= &lt;span data-mce-=&quot;&quot;&gt;engine.&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;DefaultPort&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 甚至又又探测出&lt;/p&gt;
&lt;blockquote readability=&quot;2.96875&quot;&gt;
&lt;p&gt;&lt;a title=&quot;libmachine/provision/utils_test.go&quot; href=&quot;https://github.com/docker/machine/blob/eae38c196a2e10e4e11cc7b8d6dfe8863fb60519/libmachine/provision/utils_test.go&quot; data-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;search_result.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;page_number&amp;quot;:1,&amp;quot;per_page&amp;quot;:10,&amp;quot;query&amp;quot;:&amp;quot;dockerPort&amp;quot;,&amp;quot;result_position&amp;quot;:1,&amp;quot;click_id&amp;quot;:27494663,&amp;quot;result&amp;quot;:{&amp;quot;id&amp;quot;:27494663,&amp;quot;global_relay_id&amp;quot;:&amp;quot;MDEwOlJlcG9zaXRvcnkyNzQ5NDY2Mw==&amp;quot;,&amp;quot;model_name&amp;quot;:&amp;quot;Repository&amp;quot;,&amp;quot;url&amp;quot;:&amp;quot;https://github.com/docker/machine/blob/eae38c196a2e10e4e11cc7b8d6dfe8863fb60519/libmachine/provision/utils_test.go&amp;quot;},&amp;quot;client_id&amp;quot;:&amp;quot;1282428705.1578925872&amp;quot;,&amp;quot;originating_request_id&amp;quot;:&amp;quot;E6B5:1181:1DEDC2E:358D4E5:5E1CA13B&amp;quot;,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/docker/machine/search?q=dockerPort&amp;amp;unscoped_q=dockerPort&amp;quot;,&amp;quot;referrer&amp;quot;:&amp;quot;https://github.com/docker/machine/search?q=DefaultPort&amp;amp;unscoped_q=DefaultPort&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-hydro-click-hmac=&quot;d62a96b6e70e4cbd5c14a414d9e1f37f0188fc13f47b9eec83c5e9a8ec31a4a7&quot;&gt;utils_test.go&lt;/a&gt; dockerPort := 1234&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了颠覆印象，又找到了&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;GenerateDockerOptions(&lt;span&gt;dockerPort&lt;/span&gt; int ..&lt;/p&gt;
&lt;p&gt;.{ ...&lt;/p&gt;
&lt;p&gt;DOCKER_HOST='-H tcp://0.0.0.0:{{&lt;span&gt;.DockerPort&lt;/span&gt;}}'&lt;/p&gt;
&lt;p&gt;... engineConfigContext := EngineConfigContext{&lt;/p&gt;
&lt;p&gt;DockerPort:    &lt;span&gt;dockerPort&lt;/span&gt;, ......&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后诧异的联想machine/drivers/azure/util.go&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt; // getSecurityRules creates network security group rules based on driver&lt;br/&gt;// &lt;span&gt;configuration&lt;/span&gt; such as SSH port, docker port and swarm port.&lt;/p&gt;
&lt;p&gt; // Base ports to be opened for any machine&lt;br/&gt; rl := []network.SecurityRule{&lt;br/&gt;  mkRule(100, &quot;SSHAllowAny&quot;, &quot;Allow ssh from public Internet&quot;, &quot;*&quot;, fmt.Sprintf(&quot;%d&quot;, d.BaseDriver.SSHPort), network.TCP),&lt;br/&gt;  mkRule(300, &quot;DockerAllowAny&quot;, &quot;Allow docker engine access (TLS-protected)&quot;, &quot;*&quot;, fmt.Sprintf(&quot;%d&quot;, d.DockerPort), network.TCP),&lt;br/&gt; }&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt; 好吧，最终的觉悟是，对改动docker/machine我是想说NO的&lt;/p&gt;
&lt;p&gt;machine/libmachine/provision/ 绝大多数文件的日期都是在2年前，或者4年前&lt;/p&gt;
&lt;p&gt;至今，仍旧保持着最初的风貌，而我的新光盘和new driver配合非常默契，当然少了自定义的docker port也无所谓，至少我确认了所有的远景都在预期内&lt;/p&gt;
&lt;p&gt;至多，不少一个port&lt;/p&gt;
&lt;p&gt;全篇无图，希望能用心灵和文字的力量感受到视觉上新光盘和new driver的抽象&lt;/p&gt;
&lt;p&gt;以上233的docker/machine揭发完毕&lt;/p&gt;
&lt;p&gt;请轻声鼓掌&lt;/p&gt;

&lt;p&gt;OVER.&lt;/p&gt;
</description>
<pubDate>Mon, 13 Jan 2020 17:19:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>本文言辞尖锐，心里承受能力差的男生女生勿入！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/233docker-machine.html</dc:identifier>
</item>
<item>
<title>JVM之JVM的体系结构 - 君子生非异也</title>
<link>http://www.cnblogs.com/jalja365/p/12184872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jalja365/p/12184872.html</guid>
<description>&lt;h3&gt;一、JDK的组成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200112211946261-1483292101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK：&lt;/strong&gt;JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。JDK中包含JRE（在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre）和一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java Runtime Environment（JRE）：&lt;/strong&gt;是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。JRE中包含了Java virtual machine（JVM），runtime class libraries和Java application launcher，这些是运行Java程序的必要组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM（java virtual machine）：&lt;/strong&gt;就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。&lt;/p&gt;
&lt;h3&gt;二、JVM的位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200112213606964-455608443.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JVM就是运行在操作系统之上的一个软件&lt;/p&gt;
&lt;h3&gt; 三、JVM体系结构&lt;/h3&gt;
&lt;p&gt;JVM的组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类加载子系统 Class loader&lt;/li&gt;
&lt;li&gt;运行时数据区 JVM 内存模型&lt;/li&gt;
&lt;li&gt;执行引擎&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;四、类加载子系统&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200112220654141-1414832180.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ======================类加载器=======================&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 类加载器(ClassLoader)：&lt;/strong&gt;负责加载class文件(classs文件在文件开头有特定的文件标识)，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构；ClassLoader只负责加载class文件的加载，至于它是否可以运行，则由Execution Engine决定。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113205428567-1412363241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、BootStrapLoader(引导类加载器)&lt;/strong&gt;：类加载器也是java类，他们也需要类加载器加载进入内存，显然必须要有第一个不是java类的类加载器，来完成这个工作，这个正是BootStrap。负责加载存放在D:\Program Files (x86)\Java\jdk1.7.0_79\jre\lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）；启动类加载器是无法被Java程序直接引用的；rt.jar 里面的类的加载器都是BootStrapLoader。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113211029247-1254103010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2、Extension ClassLoader(扩展类加载器)：&lt;/strong&gt;该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载D:\Program Files (x86)\Java\jdk1.7.0_79\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。ext 目录下所有的类的加载器都是Extension ClassLoader&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113213520394-1446521672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3、Application ClassLoader(应用程序类加载器):&lt;/strong&gt;该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113213753427-988045180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;====================JVM类加载机制==============&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全盘负责：&lt;/strong&gt;当前线程的类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用CLassLoader.loadClass()指定类加载器来载入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父类委托：&lt;/strong&gt;先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。所以我们在开发中尽量不要使用与JDK相同的类（例如自定义一个java.lang.System类），因为父类加载器中已经有一份java.lang.System类了，它会直接将该类给程序使用，而你自定义的类压根就不会被加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双亲委派模型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，&lt;br/&gt;只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。&lt;br/&gt;双亲委派机制:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。&lt;/li&gt;
&lt;li&gt;2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrap ClassLoader去完成。&lt;/li&gt;
&lt;li&gt;3、如果BootStrap ClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；&lt;/li&gt;
&lt;li&gt;4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;双亲委派模型意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　-系统类防止内存中出现多份同样的字节码&lt;/li&gt;
&lt;li&gt;　　-保证Java程序安全稳定运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113215252324-1697077420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; ==================类的加载过程======================&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200113220150453-2135046371.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类的加载过程：&lt;/strong&gt;JVM将javac编译好的class字节码文件加载到内存中，并对该数据进行验证、解析和初始化、形成JVM可以直接使用的JAVA类，最终回收(卸载)的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节码（.class）文件来源：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;– 从本地系统中直接加载&lt;/li&gt;
&lt;li&gt;– 通过网络下载.class文件&lt;/li&gt;
&lt;li&gt;– 从zip，jar等归档文件中加载.class文件&lt;/li&gt;
&lt;li&gt;– 从专有数据库中提取.class文件&lt;/li&gt;
&lt;li&gt;– 将Java源文件动态编译为.class文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、加载：&lt;/strong&gt;加载阶段其实就是JVM通过一个类的全限定名来获取其定义的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构且在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。在该阶段我们开发人员可以干预，例如：我们可以指定类加载器来加载该字节数组或者自定义类加载器来加载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、链接：&lt;/strong&gt;将java类的二进制代码合并到JVM的运行状态中的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a、验证：验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。&lt;/li&gt;
&lt;li&gt;b、准备：该阶段是在方法区中为类变量（static变量）分配内存并设置类变量初始值。例如：public static int flag=1；该阶段初始化值为0。&lt;/li&gt;
&lt;li&gt;c、解析：虚拟机将常量池中的符号引用替换为直接引用的过程。（直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3、初始化：&lt;/strong&gt;初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化阶段就是执行类构造器&amp;lt;clinit&amp;gt;()的过程，类构造器&amp;lt;clinit&amp;gt;()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。&lt;/li&gt;
&lt;li&gt;当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先初始化其父类。&lt;/li&gt;
&lt;li&gt;虚拟机会保证一个类的&amp;lt;clinit&amp;gt;()方法在多线程环境中被正确加锁和同步。&lt;/li&gt;
&lt;li&gt;当访问一个java 类的静态域时，只有正真申明这个域的类才会被初始化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、使用：&lt;/strong&gt;程序使用JVM加载的类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、卸载 &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行了System.exit()方法&lt;/li&gt;
&lt;li&gt;JVM垃圾回收机制触发回收&lt;/li&gt;
&lt;li&gt;程序正常执行结束&lt;/li&gt;
&lt;li&gt;程序在执行过程中遇到了异常或错误而异常终止&lt;/li&gt;
&lt;li&gt;由于操作系统出现错误而导致Java虚拟机进程终止&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;五、运行时数据区&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1911569/202001/1911569-20200112220514624-2139252059.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;253&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、方法区(Method Area)：&lt;/strong&gt;方法区是各个线程共享的内存区域；方法区用于存储已被虚拟机加载的类的模板信息、常量、静态变量等；虽然Java虚拟机规范把方法区描述为堆的一部分，但是他还有个别名叫做Non-heap（非堆），目的应该是与Java堆区分开来；根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常；相对而言，垃圾收集在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样永久存在了。这区域的内存回收目标重要是针对常量池的回收和类型的卸载。&lt;br/&gt;&lt;strong&gt;方法区只是一个规范：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在HotSpot虚拟机上开发、部署程序我们把方法区称为“永久代”（Permanent Generation）；&lt;/li&gt;
&lt;li&gt;他虚拟机（如 BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。&lt;/li&gt;
&lt;li&gt;HotSpot虚拟机在JKD.8中已经没有方法区的概念了，他使用元空间代替该区域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2、PC寄存器(程序计数器)：&lt;/strong&gt;每个线程都有一个程序计数器，是线程私有的；就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址，既将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记；它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。如果执行的是一个Native方法，那这个计数器是空的；用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出OOM错误&lt;br/&gt;本地方法栈(Native Stack)：与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。(栈的空间大小远远小于堆)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、虚拟机栈(Vm Stack)&lt;/strong&gt;&lt;br/&gt;　　栈也叫栈内存，主管 Java 程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就仔放，对于栈来说不存在垃圾回收问题，只要线程结束该栈就释放，生命周期和线程一致，是线程私有的。8种基木类型的变量＋对象的引用变量＋实例方法都是在函数的栈内存中分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的运行原理：&lt;/strong&gt;栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（ Method ）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 Fl ，并被压入到栈中， A方法又调用了B方法，于是产生栈帧 F2 也被压入栈，B方法又调用了C方法，于是产生栈帧 F3 也被压入栈，执行完毕后，先弹出 F3 栈帧，再弹出 F2 栈帧，再弹出 Fl 栈帧 以此类推， 遵循“先进后出” / “后进先出”原则。每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在 256K~1024K 之间， 1M 左右。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM栈的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部变量表所需的内存空间在编译期间完成内存分配。当进入一个方法时，这个方法需要在帧中分配多大的内存空间是完全确定的，在方法运行期间不会改变局部变量表的大小。&lt;/li&gt;
&lt;li&gt;在Java虚拟机规范中，对这个区域规定了两种异常状态：如果线程请求的栈的深度大于虚拟机允许的深度，将抛出StackOverFlowError异常（栈溢出）；如果虚拟机栈可以动态扩展（现在大部分Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的java虚拟机栈），如果扩展时无法申请到足够的内存空间，就会抛出OutOfMemoryError异常（没有足够的内存）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4、本地方法栈（Native Method Stacks）：&lt;/strong&gt;与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的本地Native方法服务‘；在虚拟机规范中对本地方法栈中的使用方法、语言、数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（例如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverFlowError和OutOfmMemoryError异常。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5、Java堆（Java Heap）&lt;/strong&gt;：是Java虚拟机管理内存中的最大一块；Java堆是所有线程共享的一块内存管理区域。此内存区域唯一目的就是存放对象的实例，几乎所有对象实例都在堆中分配内存。这一点在Java虚拟机规范中的描述是：所有对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也不是变的那么“绝对”了。详解请学习我的：&lt;a title=&quot;JVM之堆的体系结构&quot; href=&quot;https://www.cnblogs.com/jalja365/p/12181272.html&quot; target=&quot;_blank&quot;&gt;JVM之堆的体系结构&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 Jan 2020 16:42:00 +0000</pubDate>
<dc:creator>君子生非异也</dc:creator>
<og:description>栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（ Method ）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 Fl ，并被压</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jalja365/p/12184872.html</dc:identifier>
</item>
</channel>
</rss>