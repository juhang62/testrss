<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Elasticsearch索引生命周期管理方案 - zlt2000</title>
<link>http://www.cnblogs.com/zlt2000/p/14209665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zlt2000/p/14209665.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1769816/202012/1769816-20201230084209655-1454406711.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;Elasticsearch&lt;/code&gt; 的日常中，有很多如存储 &lt;strong&gt;系统日志&lt;/strong&gt;、&lt;strong&gt;行为数据&lt;/strong&gt;等方面的应用场景，这些场景的特点是数据量非常大，并且随着时间的增长 &lt;code&gt;索引&lt;/code&gt; 的数量也会持续增长，然而这些场景基本上只有最近一段时间的数据有使用价值或者会被经常使用（热数据），而历史数据几乎没有作用或者很少会被使用（冷数据），这个时候就需要对 &lt;code&gt;索引&lt;/code&gt; 进行一定策略的维护管理甚至是删除清理，否则随着数据量越来越多除了浪费磁盘与内存空间之外，还会严重影响 &lt;code&gt;Elasticsearch&lt;/code&gt; 的性能；&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Elastic Stack 6.6&lt;/code&gt; 版本后推出了新功能 &lt;code&gt;Index Lifecycle Management(索引生命周期管理)&lt;/code&gt;，支持针对索引的全生命周期托管管理，并且在 &lt;code&gt;Kibana&lt;/code&gt; 上也提供了一套 UI 界面来配置策略。本文主要介绍 &lt;code&gt;Elasticsearch&lt;/code&gt; 索引生命周期管理如何配置和使用。&lt;/p&gt;

&lt;h2 id=&quot;二、生命周期&quot;&gt;二、生命周期&lt;/h2&gt;
&lt;h3 id=&quot;21-阶段介绍&quot;&gt;2.1. 阶段介绍&lt;/h3&gt;
&lt;p&gt;索引生命周期分为4个阶段：hot、warm、cold、delete，其中hot主要负责对索引进行rollover操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;rollover：滚动更新创建的新索引将添加到索引别名，并被指定为写索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;：4个阶段中只有hot阶段是必须的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1769816/202012/1769816-20201230084210166-9053356.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引根据时间参数min_age进入生命周期阶段，若未设置，默认是0ms。min_age通常是从创建索引的时间开始计算，如果索引被设置为滚动索引，那么min_age是从索引滚动开始计算。注意，在检查min_age参数并进入下一个阶段前，当前阶段的操作必须完成。&lt;/p&gt;

&lt;h3 id=&quot;22-阶段动作&quot;&gt;2.2. 阶段动作&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶段/action&lt;/th&gt;
&lt;th&gt;优先级设置&lt;/th&gt;
&lt;th&gt;取消跟随&lt;/th&gt;
&lt;th&gt;滚动索引&lt;/th&gt;
&lt;th&gt;分片分配&lt;/th&gt;
&lt;th&gt;只读&lt;/th&gt;
&lt;th&gt;强制段合并&lt;/th&gt;
&lt;th&gt;收缩索引&lt;/th&gt;
&lt;th&gt;冻结索引&lt;/th&gt;
&lt;th&gt;删除&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;hot&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;warm&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cold&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;23-例子&quot;&gt;2.3. 例子&lt;/h3&gt;
&lt;p&gt;下面以索引 &lt;code&gt;syslog-2020.10.01&lt;/code&gt; 为例子，在索引创建 1 天后转为 Warm 阶段，30 天后转为 Cold 阶段，30 天后删除&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;动作&lt;/th&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2020-10-01&lt;/td&gt;
&lt;td&gt;创建索引 &lt;code&gt;syslog-2020.10.01&lt;/code&gt; ，处理读写请求&lt;/td&gt;
&lt;td&gt;hot阶段&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2020-10-02&lt;/td&gt;
&lt;td&gt;&lt;code&gt;syslog-2020.10.01&lt;/code&gt; 改为只读&lt;/td&gt;
&lt;td&gt;warm阶段&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2020-11-01&lt;/td&gt;
&lt;td&gt;&lt;code&gt;syslog-2020.10.01&lt;/code&gt; 为只读，并迁移到冷节点储存&lt;/td&gt;
&lt;td&gt;cold阶段&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2020-12-01&lt;/td&gt;
&lt;td&gt;删除索引 &lt;code&gt;syslog-2020.10.01&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;delete阶段&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;三、模拟过程&quot;&gt;三、模拟过程&lt;/h2&gt;
&lt;h3 id=&quot;31-创建索引生命周期策略&quot;&gt;3.1. 创建索引生命周期策略&lt;/h3&gt;
&lt;p&gt;假设 &lt;code&gt;Policy&lt;/code&gt; 设定如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;索引以每10个文档做一次 &lt;code&gt;Rollover&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rollover&lt;/code&gt; 后 5 秒转为 &lt;code&gt;Warm&lt;/code&gt; 阶段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rollover&lt;/code&gt; 后 20 秒转为 &lt;code&gt;Cold&lt;/code&gt; 阶段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rollover&lt;/code&gt; 后 40 秒删除&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -XPUT &quot;http://$IP:9200/_ilm/policy/my_ilm_policy&quot; \
    -H 'Content-Type: application/json' \
    -u elastic:changeme \
    -d '{
      &quot;policy&quot;: {
        &quot;phases&quot;: {
          &quot;hot&quot;: {
            &quot;actions&quot;: {
              &quot;rollover&quot;: {
                &quot;max_docs&quot;: &quot;10&quot;
              }
            }
          },
          &quot;warm&quot;: {
            &quot;min_age&quot;: &quot;5s&quot;,
            &quot;actions&quot;: {
              &quot;allocate&quot;: {
                &quot;include&quot;: {
                  &quot;box_type&quot;: &quot;warm&quot;
                }
              }
            }
          },
          &quot;cold&quot;: {
            &quot;min_age&quot;: &quot;20s&quot;,
            &quot;actions&quot;: {
              &quot;allocate&quot;: {
                &quot;include&quot;: {
                  &quot;box_type&quot;: &quot;cold&quot;
                }
              }
            }
          },
          &quot;delete&quot;: {
            &quot;min_age&quot;: &quot;40s&quot;,
            &quot;actions&quot;: {
              &quot;delete&quot;: {}
            }
          }
        }
      }
    }'
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ip、用户名和密码按实际情况修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;32-关联策略&quot;&gt;3.2. 关联策略&lt;/h3&gt;
&lt;p&gt;关联策略有两种方式，分别是使用索引模板关联和索引直接关联&lt;/p&gt;
&lt;h4 id=&quot;321-索引模板关联&quot;&gt;3.2.1. 索引模板关联&lt;/h4&gt;
&lt;p&gt;索引模板来创建所需的索引，并关联ilm策略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -XPUT &quot;http://$IP:9200/_template/my_test_template&quot; \
    -H 'Content-Type: application/json' \
    -u elastic:changeme \
    -d '{
        &quot;index_patterns&quot;: [&quot;my-test-*&quot;], 
        &quot;settings&quot;: {
            &quot;number_of_shards&quot;: 1,
            &quot;number_of_replicas&quot;: 0,
            &quot;index.lifecycle.name&quot;: &quot;my_ilm_policy&quot;, 
            &quot;index.lifecycle.rollover_alias&quot;: &quot;my-test&quot;,
            &quot;index.routing.allocation.include.box_type&quot;: &quot;hot&quot;
        }
    }'
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ip、用户名和密码按实际情况修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;index.lifecycle.name：指明该索引应用的 ILM Policy&lt;br/&gt;index.lifecycle.rollover_alias：指明在 Rollover 的时候使用的 alias&lt;br/&gt;index.routing.allocation.include.box_type：指明新建的索引都分配在 hot 节点上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;322-索引直接关联&quot;&gt;3.2.2. 索引直接关联&lt;/h4&gt;
&lt;p&gt;为现有的索引单独关联策略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -XPUT &quot;http://$IP:9200/my-test-*/_settings&quot; \
    -H 'Content-Type: application/json' \
    -u elastic:changeme \
    -d '{
      &quot;index&quot;: {
        &quot;lifecycle&quot;: {
          &quot;name&quot;: &quot;my_ilm_policy&quot;
        }
      }
    }'
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ip、用户名和密码按实际情况修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;33-查看索引所处阶段&quot;&gt;3.3. 查看索引所处阶段&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http://$IP:9200/my-test-*/_ilm/explain
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;34-更新策略&quot;&gt;3.4. 更新策略&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果没有index应用这份策略，那么我们可以直接更新该策略。&lt;/li&gt;
&lt;li&gt;如果有index应用了这份策略，那么当前正在执行的阶段不会同步修改，当当前阶段结束后，会进入新版本策略的下个阶段。&lt;/li&gt;
&lt;li&gt;如果更换了策略，当前正在执行的阶段不会变化，在结束当前阶段后，将会由新的策略管理下一个生命周期。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;35-kibana图形化操作&quot;&gt;3.5. kibana图形化操作&lt;/h3&gt;
&lt;p&gt;上述的步骤，大部分都可以在 &lt;code&gt;Kibana&lt;/code&gt; 中以图形化界面的方式进行操作&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1769816/202012/1769816-20201230084210456-1227497607.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1769816/202012/1769816-20201230084210633-488915121.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果使用图形化界面来创建策略，删除阶段会缺失 &lt;code&gt;actions&lt;/code&gt; 内容而导致无法删除&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;四、修改轮询间隔可选&quot;&gt;四、修改轮询间隔(可选)&lt;/h2&gt;
&lt;p&gt;ILM Service 会在后台轮询执行 Policy，默认间隔时间为 10 分钟，为了测试更快地看到效果，可将其修改为1秒。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -XPUT &quot;http://$IP:9200/_cluster/settings&quot; \
    -H 'Content-Type: application/json' \
    -u elastic:changeme \
    -d '{
        &quot;persistent&quot;: {
          &quot;indices.lifecycle.poll_interval&quot;:&quot;1s&quot;
        }
    }'
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ip、用户名和密码按实际情况修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;五、启动和停止索引生命周期管理&quot;&gt;五、启动和停止索引生命周期管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ILM 默认开启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由ILM管理的所有索引将继续执行其策略。有时可能不需要某些索引，甚至集群中的所有索引都不需要。例如，当需要集群拓扑更改时，可能会有计划的维护窗口，这可能会影响正在运行的ILM操作。因此，ILM有两种禁用操作的方法。&lt;/p&gt;
&lt;p&gt;停止ILM时，快照生命周期管理操作也会停止，这意味着不会创建计划的快照（当前正在进行的快照不受影响）。&lt;/p&gt;
&lt;p&gt;通常，ILM将默认运行。要查看ILM的当前运行状态，请使用&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.4/ilm-get-status.html&quot; target=&quot;_blank&quot;&gt;Get Status API&lt;/a&gt; 来查看ILM的当前状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;GET  _ilm/status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果请求没有遇到错误，您将收到以下结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;operation_mode&quot;: &quot;RUNNING&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ILM的操作模式&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶段/action&lt;/th&gt;
&lt;th&gt;优先级设置&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;正在运行&lt;/td&gt;
&lt;td&gt;正常运行，所有策略均正常执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;停止&lt;/td&gt;
&lt;td&gt;ILM已收到停止请求，但仍在处理某些策略&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;已停止&lt;/td&gt;
&lt;td&gt;这表示没有执行任何策略的状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;51-停止ilm&quot;&gt;5.1. 停止ILM&lt;/h3&gt;
&lt;p&gt;可以暂停ILM服务，以便使用&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.4/ilm-stop.html&quot; target=&quot;_blank&quot;&gt;Stop API&lt;/a&gt;不再执行其他步骤。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;POST  _ilm/stop
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;停止后，所有其他政策措施都将停止。这将反映在状态API中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;operation_mode&quot;: &quot;STOPPING&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;然后，ILM服务将异步地将所有策略运行到可以安全停止的位置。在ILM确认它是安全的之后，它将移至该&lt;code&gt;STOPPED&lt;/code&gt;模式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;operation_mode&quot;: &quot;STOPPED&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;52-启动ilm&quot;&gt;5.2. 启动ILM&lt;/h3&gt;
&lt;p&gt;要启动ILM并继续执行策略，请使用&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.4/ilm-start.html&quot; target=&quot;_blank&quot;&gt;Start API&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;POST  _ilm/start
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Start API将向ILM服务发送请求，以立即开始正常操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;operation_mode&quot;: &quot;RUNNING&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;六、api清单&quot;&gt;六、API清单&lt;/h2&gt;
&lt;p&gt;可以使用以下API来管理索引策略。可参考官方文档 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.4/index-lifecycle-management.html&quot; target=&quot;_blank&quot;&gt;管理索引生命周期&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;政策管理API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引管理API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运营管理API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;扫码关注有惊喜！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1769816/202012/1769816-20201230084210827-860915113.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 00:42:00 +0000</pubDate>
<dc:creator>zlt2000</dc:creator>
<og:description>一、前言 在 Elasticsearch 的日常中，有很多如存储 系统日志、行为数据等方面的应用场景，这些场景的特点是数据量非常大，并且随着时间的增长 索引 的数量也会持续增长，然而这些场景基本上只有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zlt2000/p/14209665.html</dc:identifier>
</item>
<item>
<title>SpringBoot 的多数据源配置 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/14209663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/14209663.html</guid>
<description>&lt;p&gt;最近在项目开发中，需要为一个使用 MySQL 数据库的 SpringBoot 项目，新添加一个 PLSQL 数据库数据源，那么就需要进行 SpringBoot 的多数据源开发。代码很简单，下面是实现的过程。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;SpringBoot 2.4.1&lt;/li&gt;
&lt;li&gt;Maven 3.6.3&lt;/li&gt;
&lt;li&gt;MySQL 5.7&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为我本地只有 MySQL 数据库，为了方便演示，我会在启动一个本地 MySQL，在 MySQL 创建两个数据库，每个库中均有一个表，以此进行演示。&lt;/p&gt;
&lt;h3 id=&quot;数据准备&quot;&gt;数据准备&lt;/h3&gt;
&lt;p&gt;本地 MySQL 端口默认不做改动，端口号 3306。&lt;/p&gt;
&lt;p&gt;创建数据库 demo1，demo2。在 demo1 数据库中创建表 book。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- create table
create table Book
(
    id          int auto_increment
        primary key,
    author      varchar(64)  not null comment '作者信息',
    name        varchar(64)  not null comment '书籍名称',
    price       decimal      not null comment '价格',
    createTime  datetime     null comment '上架时间',
    description varchar(128) null comment '书籍描述'
);
-- insert data
INSERT INTO demo1.Book (id, author, name, price, createTime, description) VALUES (1, '金庸', '笑傲江湖', 13, '2020-12-19 15:26:51', '武侠小说');
INSERT INTO demo1.Book (id, author, name, price, createTime, description) VALUES (2, '罗贯中', '三国演义', 14, '2020-12-19 15:28:36', '历史小说');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 demo2 数据库中创建表 user。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;-- create table
create table User
(
    id       int auto_increment
        primary key,
    name     varchar(32) null comment '用户名称',
    birthday date        null comment '出生日期'
)
    comment '用户信息表';
-- insert data
INSERT INTO demo2.User (id, name, birthday) VALUES (1, '金庸', '1924-03-10');
INSERT INTO demo2.User (id, name, birthday) VALUES (2, '罗贯中', '1330-01-10');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据准备完毕，表中都新增了两条数据。&lt;/p&gt;
&lt;h3 id=&quot;项目准备&quot;&gt;项目准备&lt;/h3&gt;
&lt;p&gt;这里直接从 Spring 官方上初始化一个添加了 web、lombok、mybatis、mysql 依赖的 SpringBoot 项目。&lt;/p&gt;
&lt;p&gt;访问直接下载：&lt;a href=&quot;https://start.spring.io/starter.zip?type=maven-project&amp;amp;language=java&amp;amp;bootVersion=2.4.1.RELEASE&amp;amp;baseDir=demo&amp;amp;groupId=com&amp;amp;artifactId=wdbyte&amp;amp;name=demo&amp;amp;description=Demo%20project%20for%20Spring%20Boot&amp;amp;packageName=com.wdbyte.demo&amp;amp;packaging=jar&amp;amp;javaVersion=1.8&amp;amp;dependencies=mybatis,lombok,web,mysql&quot; target=&quot;_blank&quot;&gt;https://start.spring.io/starter.zip?type=maven-project&amp;amp;language=java&amp;amp;bootVersion=2.4.1.RELEASE&amp;amp;baseDir=demo&amp;amp;groupId=com&amp;amp;artifactId=wdbyte&amp;amp;name=demo&amp;amp;description=Demo%20project%20for%20Spring%20Boot&amp;amp;packageName=com.wdbyte.demo&amp;amp;packaging=jar&amp;amp;javaVersion=1.8&amp;amp;dependencies=mybatis,lombok,web,mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你手上已经有了一个 SpringBoot 项目，既然你想改造成多数据源，那么你应该已经有了一个数据源了，如果新增的数据源数据库和目前的一致，你可以直接使用你的项目进行改造测试。&lt;/p&gt;
&lt;h2 id=&quot;多数据源&quot;&gt;多数据源&lt;/h2&gt;
&lt;p&gt;SpringBoot 的多数据源开发十分简单，如果多个数据源的数据库相同，比如都是 MySQL，那么依赖是不需要任何改动的，只需要进行多数据源配置即可。&lt;/p&gt;
&lt;p&gt;如果你新增的数据库数据源和目前的数据库不同，记得引入新数据库的驱动依赖，比如 MySQL 和 PGSQL。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;42.2.7&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连接配置&quot;&gt;连接配置&lt;/h3&gt;
&lt;p&gt;既然有多个数据源，因为数据库用户名密码可能不相同，所以是需要配置多个数据源信息的，直接在 &lt;code&gt;properties/yml&lt;/code&gt; 中配置即可。这里要注意根据配置的属性名进行区分，同时因为数据源要有一个默认使用的数据源，最好在名称上有所区分（这里使用 &lt;strong&gt;primary&lt;/strong&gt; 作为主数据源标识）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;########################## 主数据源 ##################################
spring.datasource.primary.jdbc-url=jdbc:mysql://127.0.0.1:3306/demo1?characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8
spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.primary.username=root
spring.datasource.primary.password=

########################## 第二个数据源 ###############################
spring.datasource.datasource2.jdbc-url=jdbc:mysql://127.0.0.1:3306/demo2?characterEncoding=utf-8&amp;amp;serverTimezone=GMT%2B8
spring.datasource.datasource2.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.datasource2.username=root
spring.datasource.datasource2.password=

# mybatis
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.wdbyte.domain
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，配置中的数据源连接 url 末尾使用的是 &lt;code&gt;jdbc-url&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;因为使用了 Mybatis 框架，所以 Mybatis 框架的配置信息也是少不了的，指定扫描目录 &lt;code&gt;mapper&lt;/code&gt; 下的&lt;code&gt;mapper xml&lt;/code&gt; 配置文件。&lt;/p&gt;
&lt;h3 id=&quot;mybatis-配置&quot;&gt;Mybatis 配置&lt;/h3&gt;
&lt;p&gt;如何编写 Mybatis Mapper 或者如何使用工具生成 &lt;code&gt;Mybatis Mapper&lt;/code&gt; 不是本文的重点，如果你不知道可以参考 Mybatis 官方文档或者我之前的文章。&lt;/p&gt;
&lt;p&gt;链接一：&lt;a href=&quot;https://mp.weixin.qq.com/s/-8ytSdjKGmukdNKx_f0jLw&quot; target=&quot;_blank&quot;&gt;使用 Mybatis（自动生成插件） 访问数据库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;链接二：&lt;a href=&quot;https://mp.weixin.qq.com/s/Eij-GU3yQijyYmQcsghsgg&quot; target=&quot;_blank&quot;&gt;使用 Mybatis 集成 pagehelper 分页插件和 mapper 插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我已经按照上面的两个库中的两个表，Book 和 User 表分别编写相应的 Mybatis 配置。&lt;/p&gt;
&lt;p&gt;创建 &lt;code&gt;BookMapper.xml&lt;/code&gt; 和 &lt;code&gt;UserMapper.xml&lt;/code&gt; 放到配置文件配置的路径 mapper 目录下。创建 UserMapper 和 BookMapper 接口操作类放在不同的目录。这里注意 Mapper 接口要按数据源分开放在不同的目录中。后续好使用不同的数据源配置扫描不同的目录，这样就可以实现不同的 Mapper 使用不同的数据源配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cb53a35fe94b08ba85d1e45bdc716f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;Mybatis 文件配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Service 层没有变化，这里 BookMapper 和 UserMapper 都有一个 &lt;code&gt;selectAll()&lt;/code&gt; 方法用于查询测试。&lt;/p&gt;
&lt;h3 id=&quot;多数据源配置&quot;&gt;多数据源配置&lt;/h3&gt;
&lt;p&gt;上面你应该看到了，到目前为止和 Mybatis 单数据源写法唯一的区别就是 Mapper 接口使用不同的目录分开了，那么这个不同点一定会在数据源配置中体现。&lt;/p&gt;
&lt;h4 id=&quot;主数据源&quot;&gt;主数据源&lt;/h4&gt;
&lt;p&gt;开始配置两个数据源信息，先配置主数据源，配置扫描的 &lt;code&gt;MapperScan&lt;/code&gt; 目录为 &lt;code&gt;com.wdbyte.mapper.primary&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 主数据源配置
 *
 * @author niujinpeng
 * @website: https://www.wdbyte.com
 * @date 2020/12/19
 */
@Configuration
@MapperScan(basePackages = {&quot;com.wdbyte.mapper.primary&quot;}, sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)
public class PrimaryDataSourceConfig {

    @Bean(name = &quot;dataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;)
    @Primary
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = &quot;sqlSessionFactory&quot;)
    @Primary
    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;));
        return bean.getObject();
    }

    @Bean(name = &quot;transactionManager&quot;)
    @Primary
    public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean(name = &quot;sqlSessionTemplate&quot;)
    @Primary
    public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和单数据源不同的是这里把&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dataSource&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlSessionFactory&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transactionManager&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlSessionTemplate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;都单独进行了配置，简单的 bean 创建，下面是用到的一些注解说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;)&lt;/code&gt;：使用spring.datasource.primary 开头的配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Primary&lt;/code&gt; ：声明这是一个主数据源（默认数据源），多数据源配置时&lt;strong&gt;必不可少&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Qualifier&lt;/code&gt;：显式选择传入的 Bean。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第二个数据源&quot;&gt;第二个数据源&lt;/h4&gt;
&lt;p&gt;第二个数据源和主数据源唯一不同的只是 &lt;code&gt;MapperScan&lt;/code&gt; 扫描路径和创建的 Bean 名称，同时没有 &lt;code&gt;@Primary&lt;/code&gt; 主数据源的注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 第二个数据源配置
 * 
 * @author niujinpeng
 * @website: https://www.wdbyte.com
 * @date 2020/12/19
 */
@Configuration
@MapperScan(basePackages = {&quot;com.wdbyte.mapper.datasource2&quot;}, sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;)
public class SecondDataSourceConfig {

    @Bean(name = &quot;dataSource2&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.datasource2&quot;)
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = &quot;sqlSessionFactory2&quot;)
    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;));
        return bean.getObject();
    }

    @Bean(name = &quot;transactionManager2&quot;)
    public DataSourceTransactionManager transactionManager(@Qualifier(&quot;dataSource2&quot;) DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean(name = &quot;sqlSessionTemplate2&quot;)
    public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory2&quot;) SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：因为已经在两个数据源中分别配置了扫描的 Mapper 路径，如果你之前在 SpringBoot 启动类中也使用了 Mapper 扫描注解，&lt;strong&gt;需要删掉&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;访问测试&quot;&gt;访问测试&lt;/h3&gt;
&lt;p&gt;编写两个简单的查询 Controller 然后进行访问测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// BookController
@RestController
public class BookController {

    @Autowired
    private BookService bookService;

    @GetMapping(value = &quot;/books&quot;)
    public Response selectAll() throws Exception {
        List&amp;lt;Book&amp;gt; books = bookService.selectAll();
        return ResponseUtill.success(books);
    }
}

// UserController
@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @ResponseBody
    @GetMapping(value = &quot;/users&quot;)
    public Response selectAll() {
        List&amp;lt;User&amp;gt; userList = userService.selectAll();
        return ResponseUtill.success(userList);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问测试，我这里直接 CURL 请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;➜  ~ curl localhost:8080/books 
{
  &quot;code&quot;: &quot;0000&quot;,
  &quot;message&quot;: &quot;success&quot;,
  &quot;data&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;author&quot;: &quot;金庸&quot;,
      &quot;name&quot;: &quot;笑傲江湖&quot;,
      &quot;price&quot;: 13,
      &quot;createtime&quot;: &quot;2020-12-19T07:26:51.000+00:00&quot;,
      &quot;description&quot;: &quot;武侠小说&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;author&quot;: &quot;罗贯中&quot;,
      &quot;name&quot;: &quot;三国演义&quot;,
      &quot;price&quot;: 14,
      &quot;createtime&quot;: &quot;2020-12-19T07:28:36.000+00:00&quot;,
      &quot;description&quot;: &quot;历史小说&quot;
    }
  ]
}
➜  ~ curl localhost:8080/users 
{
  &quot;code&quot;: &quot;0000&quot;,
  &quot;message&quot;: &quot;success&quot;,
  &quot;data&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;金庸&quot;,
      &quot;birthday&quot;: &quot;1924-03-09T16:00:00.000+00:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;罗贯中&quot;,
      &quot;birthday&quot;: &quot;1330-01-09T16:00:00.000+00:00&quot;
    }
  ]
}
➜  ~
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，多数据源配置完成，测试成功。&lt;/p&gt;
&lt;h2 id=&quot;连接池&quot;&gt;连接池&lt;/h2&gt;
&lt;p&gt;其实在多数据源改造中，我们一般情况下都不会使用默认的 JDBC 连接方式，往往都需要引入连接池进行连接优化，不然你可能会经常遇到数据源连接被断开等报错日志。其实数据源切换连接池数据源也是十分简单的，直接引入连接池依赖，然后把创建 dataSource 的部分换成连接池数据源创建即可。&lt;/p&gt;
&lt;p&gt;下面以阿里的 Druid 为例，先引入连接池数据源依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加 Druid 的一些配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.datasource2.initialSize=3 # 根据自己情况设置
spring.datasource.datasource2.minIdle=3
spring.datasource.datasource2.maxActive=20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改写 dataSource Bean 的创建代码部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${spring.datasource.datasource2.jdbc-url}&quot;)
private String url;
@Value(&quot;${spring.datasource.datasource2.driver-class-name}&quot;)
private String driverClassName;
@Value(&quot;${spring.datasource.datasource2.username}&quot;)
private String username;
@Value(&quot;${spring.datasource.datasource2.password}&quot;)
private String password;
@Value(&quot;${spring.datasource.datasource2.initialSize}&quot;)
private int initialSize;
@Value(&quot;${spring.datasource.datasource2.minIdle}&quot;)
private int minIdle;
@Value(&quot;${spring.datasource.datasource2.maxActive}&quot;)
private int maxActive;

@Bean(name = &quot;dataSource2&quot;)
public DataSource dataSource() {
    DruidDataSource dataSource = new DruidDataSource();
    dataSource.setUrl(url);
    dataSource.setDriverClassName(driverClassName);
    dataSource.setUsername(username);
    dataSource.setPassword(password);
    dataSource.setInitialSize(initialSize);
    dataSource.setMinIdle(minIdle);
    dataSource.setMaxActive(maxActive);
    return dataSource;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只是简单的提一下使用连接池的重要性，Druid 的详细用法还请参考官方文档。&lt;/p&gt;
&lt;p&gt;文中代码已经上传到 Github: &lt;a href=&quot;https://github.com/niumoo/springboot&quot; target=&quot;_blank&quot;&gt;https://github.com/niumoo/springboot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持！&lt;br/&gt;文章每周持续更新，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47de355947494602bde836515b35617b~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 00:41:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>最近在项目开发中，需要为一个使用 MySQL 数据库的 SpringBoot 项目，新添加一个 PLSQL 数据库数据源，那么就需要进行 SpringBoot 的多数据源开发。代码很简单，下面是实现的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/14209663.html</dc:identifier>
</item>
<item>
<title>[数据库]000 - 🍳Sysbench 数据库压力测试工具 - AnonyStar</title>
<link>http://www.cnblogs.com/i-code/p/14209648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i-code/p/14209648.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083309640-1446375969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sysbench&lt;/code&gt; 是一个开源的、模块化的、跨平台的多线程性能测试工具，可以用来进行CPU、内存、磁盘&lt;code&gt;I/O&lt;/code&gt;、线程、数据库的性能测试。目前支持的数据库有&lt;code&gt;MySQL&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt;和&lt;code&gt;PostgreSQL&lt;/code&gt;。以下操作都将以支持&lt;code&gt;MySQL&lt;/code&gt;数据库为例进行。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;1-linux-上安装-sysbench-工具&quot;&gt;1. Linux 上安装 sysbench 工具&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;安装方式有两种，一种是通过 &lt;code&gt;yum&lt;/code&gt;/&lt;code&gt;apt&lt;/code&gt; 等来安装，另一种自己下载源码包来安装，笔者这里采用的是&lt;code&gt;centos&lt;/code&gt; ,采用&lt;code&gt;yum&lt;/code&gt; 安装&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sysbench&lt;/code&gt; 的源码包下载地址： &lt;a href=&quot;http://sourceforge.net/projects/sysbench&quot; target=&quot;_blank&quot;&gt;http://sourceforge.net/projects/sysbench&lt;/a&gt; ，采用源码安装的可转这里&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;yum&lt;/code&gt; 安装如下：
&lt;ul&gt;&lt;li&gt;设置 &lt;code&gt;yum repo&lt;/code&gt; 仓库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.0416666666667&quot;&gt;
&lt;p&gt;curl -s &lt;a href=&quot;https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh&quot; target=&quot;_blank&quot;&gt;https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh&lt;/a&gt; | sudo bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sudo yum -y install sysbench&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;安装完检查是否成功&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;sysbench --version&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083310706-18219576.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-数据库测试用例准备&quot;&gt;2. 数据库测试用例准备&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;我们这里测试的是 &lt;code&gt;MySQL&lt;/code&gt; ，首先我们在数据库创建一个专门用来测试的库 &lt;code&gt;test_db&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083311232-521136475.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;sysbench&lt;/code&gt; 创建20个测试表，每个表中创建100万数据，再通过10个线程对测试库发起访问，持续5分钟，对其进行压测&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;3-sysbench-构建表与数据&quot;&gt;3. sysbench 构建表与数据&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;执行下面命令准备数据&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_read_write --db-ps-mode=disable prepare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;上面命令的参数说明：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;--db-driver=mysql&lt;/code&gt; : 表示数据库的驱动类型，我们使用的是 &lt;code&gt;MySQL&lt;/code&gt; 所以填&lt;code&gt;mysql&lt;/code&gt; ,如果使用 &lt;code&gt;Oracle&lt;/code&gt; 则填写相应的&lt;code&gt;oracle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--time=300&lt;/code&gt; : 这个参数表示持续访问的时间 300秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--threads=10&lt;/code&gt; : 表示使用10个线程模拟并发访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--report-interval=1&lt;/code&gt; : 表示每隔一秒输出以此压测情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root&lt;/code&gt; : 这一块的配置，就是基本的数据库链接信息，指定数据库&lt;code&gt;IP&lt;/code&gt; ，端口，账号密码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mysql-db=test_db --tables=20 --table_size=1000000&lt;/code&gt; : 这三个参数设置，表示指定测试的库为&lt;code&gt;test_db&lt;/code&gt; , 同时在这个库中构建20个表，并且每个表中构建出 100万条测试数据，表的名字会类似 &lt;code&gt;sbtest1&lt;/code&gt;,&lt;code&gt;sbtest2&lt;/code&gt; 这种格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oltp_read_write&lt;/code&gt; : 表示执行&lt;code&gt;oltp&lt;/code&gt; 数据库的读写测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--db-ps-mode=disable&lt;/code&gt; : 禁止 &lt;code&gt;ps&lt;/code&gt; 模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepare&lt;/code&gt; : 表示按照命令设置去构建出我们的数据，也就是对前面所有命令的执行方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;4-全方位测试&quot;&gt;4. 全方位测试&lt;/h4&gt;
&lt;h5 id=&quot;1-综合读写测试&quot;&gt;1. 综合读写测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的综合读写&lt;code&gt;TPS&lt;/code&gt; ,使用 &lt;code&gt;oltp_read_write&lt;/code&gt; 模式&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_read_write --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：命令最后不再是 之前的 prepare，这里是 run ，表示运行压测，前面的是准备数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083312179-585469253.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上面是直接输出到控制台，我们也可以将其全部记录在文件中，通过管道，&lt;code&gt;| tee /tmp/mysysbench.log&lt;/code&gt; 整个命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_read_write --db-ps-mode=disable run | tee /tmp/mysysbench.log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;2-只读性能测试&quot;&gt;2. 只读性能测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的只读性能，使用 &lt;code&gt;oltp_read_only&lt;/code&gt; 模式，命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_read_only --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083312957-151946034.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果要输出到文件如上&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;3-删除性能测试&quot;&gt;3. 删除性能测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的删除性能，使用模式：&lt;code&gt;oltp_delete&lt;/code&gt; ,命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_delete --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;4-更新索引字段测试&quot;&gt;4. 更新索引字段测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的更新索引字段的性能，使用模式：&lt;code&gt;oltp_update_index&lt;/code&gt; , 命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_update_index --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5-更新非索引字段测试&quot;&gt;5. 更新非索引字段测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库中更新非索引字段的性能，使用模式：&lt;code&gt;oltp_update_non_index&lt;/code&gt;, 命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_update_non_index --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;6-插入性能测试&quot;&gt;6. 插入性能测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的数据插入性能，使用模式：&lt;code&gt;oltp_insert&lt;/code&gt;,命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_insert --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;7-写入性能测试&quot;&gt;7. 写入性能测试&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;测试数据库的写入性能，使用模式：&lt;code&gt;oltp_write_only&lt;/code&gt;, 命令如下：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_write_only --db-ps-mode=disable run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;8-清理数据&quot;&gt;8. 清理数据&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;前面命令进行了各种测试，在测试完之后我们可以通过下面的 &lt;code&gt;cleanup&lt;/code&gt; 命令来清除构建的测试数据&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;sysbench --db-driver=mysql --time=300 --threads=10 --report-interval=1 --mysql-host=192.168.56.10 --mysql-port=3306 --mysql-user=root --mysql-password=root --mysql-db=test_db --tables=20 --table_size=1000000 oltp_read_write --db-ps-mode=disable cleanup&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;9-压测结果分析&quot;&gt;9. 压测结果分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;通过上面的命令我们可以全方位的得到测试的结果，我们直接每个一秒输出一次结果，在控制台会输出类似下面的东西：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[ 31s ] thds: 10 tps: 350.35 qps: 5575.50 (r/w/o: 4874.81/0.00/700.69) lat (ms,95%): 36.89 err/s: 0.00 reconn/s: 0.00&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们来解释一下其中的含义，首先&lt;code&gt;[31s]&lt;/code&gt; 表示这是在第31秒的时候输出的一段压测统计结果，其他字段如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;thds:10&lt;/code&gt; : 表示当前有&lt;code&gt;10&lt;/code&gt;个线程正在压测&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tps:350.35&lt;/code&gt; : 表示当前每秒执行了 &lt;code&gt;350.35&lt;/code&gt; 个事务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qps:5575.50&lt;/code&gt;: 表示当前每秒可以执行 &lt;code&gt;5575.50&lt;/code&gt; 个请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(r/w/o: 4874.81/0.00/700.69)&lt;/code&gt; : 表示在每秒 &lt;code&gt;5575.50&lt;/code&gt; 个请求中，有 &lt;code&gt;4874.81&lt;/code&gt; 个读请求，&lt;code&gt;0.00&lt;/code&gt; 个写请求，&lt;code&gt;700.69&lt;/code&gt; 个其他请求，其实就是对 &lt;code&gt;qps&lt;/code&gt; 的细化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lat (ms,95%): 36.89&lt;/code&gt;：表示 95% 的请求的延迟都在36.89 毫秒以下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;err/s: 0.00 reconn/s: 0.00&lt;/code&gt;：表示有0个请求失败，发生了0次的网络重连&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在压测结束后会输出一个总的压测结果，如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083313544-127209051.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中的参数的解释：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083317082-1864416318.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;10-常用监控命令&quot;&gt;10. 常用监控命令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在压测过程中我们要时刻关注服务器的 &lt;code&gt;CPU&lt;/code&gt; 、磁盘&lt;code&gt;I/O&lt;/code&gt; 、网络负载等信息，一旦发现任何一个超出一定负荷，则不适合再继续加大线程数来压测了&lt;/li&gt;
&lt;li&gt;一定要注意，压测的过程是要保证机器各项指标在正常范围内的最大负载，而不是我们不断的增大 &lt;code&gt;sysbench&lt;/code&gt; 的线程数，不关系其他指标，这样即使机器每秒抗住了很高的&lt;code&gt;qps&lt;/code&gt; ,但是这时候的机器已经是满负荷运行了，内存，&lt;code&gt;cpu&lt;/code&gt;，网络带宽等都几乎被打满，这种情况机器随时可能挂掉，这时候的测压就没有什么代表性了，因为你不可能在生产者让它达到这样的负荷&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;观察-cpu-的的负荷&quot;&gt;观察 CPU 的的负荷&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;Linux&lt;/code&gt;下最常见的命令就是&lt;code&gt;top&lt;/code&gt; 命令，可以输出详细的情况，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083317991-1134280414.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于上面的输出，我们详细来分析一下，首先看第一行的输出&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;top - 16:24:21 up 13:41, 4 users, load average: 0.11, 3.10, 3.72&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;16:24:21&lt;/code&gt; : 表示当前的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up 13:41&lt;/code&gt;：表示已经运行了多长时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4 users&lt;/code&gt;：当前机器有几个用户在使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;load average: 0.11, 3.10, 3.72&lt;/code&gt;&lt;/strong&gt;：这是核心。表示 &lt;code&gt;CPU&lt;/code&gt; 在 一分钟、五分钟、十五分钟 内的平均负载情况，简单解释一下，假设我们是一个四核的&lt;code&gt;CPU&lt;/code&gt; ，此时如果我们的&lt;code&gt;CPU&lt;/code&gt; 负载是 &lt;code&gt;0.15&lt;/code&gt; ，那么表示这四个核心中连一个核心都没使用满，表明整体比较空闲；如果整个负载是1，则表示四个核中有一个已经使用的比较繁忙了，但是其他三个还是比较空闲的；如果负载是4，则说明当前四个核心都处于跑满的状态，如果负载大于四，假设6，那说明四核的&lt;code&gt;CPU&lt;/code&gt; 被超负荷使用也无法处理完当前的任务，有很多线程与要等待&lt;code&gt;CPU&lt;/code&gt; 资源&lt;/li&gt;
&lt;li&gt;后面有内存的使用情况，&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;KiB Mem : 498684 total, 6216 free, 366620 used, 125848 buff/cache&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;498684 total&lt;/code&gt; ： 总的内存，差不多 &lt;code&gt;490M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6216 free&lt;/code&gt;：当前可用内存，&lt;code&gt;6M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;366620 used&lt;/code&gt;：已使用内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;125848 buff/cache&lt;/code&gt;：用于&lt;code&gt;IO&lt;/code&gt; 缓冲的内存&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;磁盘io检测&quot;&gt;磁盘IO检测&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在检测&lt;code&gt;CPU&lt;/code&gt; 和内存使用的同时，我们还需要检测磁盘的使用状况，包括&lt;code&gt;IO&lt;/code&gt; 吞吐量，&lt;code&gt;IOPS&lt;/code&gt; 等信息&lt;/li&gt;
&lt;li&gt;主要通过 &lt;code&gt;dstat&lt;/code&gt; 命令来查看，如果系统没有装可以通过 &lt;code&gt;yum install dstat&lt;/code&gt; 进行安装&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;dstat -d&lt;/code&gt; 命令，可以看到如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083318439-1862326864.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面显示的内存可以看到存储的IO吞吐量的详细数据，每秒读&lt;code&gt;19M&lt;/code&gt;数据，每秒写 &lt;code&gt;6521K&lt;/code&gt;的数据，这个吞吐量并不是很高，一般普通的机械硬盘可以到达上百&lt;code&gt;MB&lt;/code&gt;的读写量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用命令 &lt;code&gt;dstat -r&lt;/code&gt; 来查看&lt;code&gt;IOPS&lt;/code&gt; 的情况，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083319003-304051172.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如上面结果可以看到，读写分别的&lt;code&gt;IOPS&lt;/code&gt; 的值，&lt;strong&gt;也就是说随即磁盘读取/写入每秒多少次&lt;/strong&gt;，通常来说磁盘的读写每秒在两三百次是可接受的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;网卡流量检测&quot;&gt;网卡流量检测&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;同样我们可以通过 &lt;code&gt;dstat -n&lt;/code&gt; 来查看网卡的具体流量情况，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202012/2024393-20201230083319328-8897079.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以看到上面所示，网卡每秒接收和发送的数据量。通常来说如果我们电脑是千兆网卡，那么每秒钟网卡的总流量也就在&lt;code&gt;100M&lt;/code&gt; 左右，甚至更低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6.0520833333333&quot;&gt;
&lt;p&gt;本文由AnonyStar 发布,可转载但需声明原文出处。&lt;br/&gt;欢迎关注微信公账号 ：云栖简码 获取更多优质文章&lt;br/&gt;更多文章关注笔者博客 ：&lt;a href=&quot;https://i-code.online/&quot; target=&quot;_blank&quot;&gt;云栖简码 i-code.online&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 30 Dec 2020 00:33:00 +0000</pubDate>
<dc:creator>AnonyStar</dc:creator>
<og:description>000 - &amp;amp;#127859;Sysbench 数据库压力测试工具 sysbench 是一个开源的、模块化的、跨平台的多线程性能测试工具，可以用来进行CPU、内存、磁盘I/O、线程、数据库的性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i-code/p/14209648.html</dc:identifier>
</item>
<item>
<title>你说一下Redis为什么快吧，怎么实现高可用，还有持久化怎么做的？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14204650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14204650.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;作为Java程序员，在面试过程中，缓存相关的问题是躲不掉的，肯定会问，例如缓存一致性问题，缓存雪崩、击穿、穿透等。说到缓存，那肯定少不了Redis，我在面试的时候也是被问了很多关于Redis相关的知识，但是Redis的功能太强大了，并不是一时半会儿能掌握好的，因为有些高级特性或是知识平时并不会用到。&lt;br/&gt;所以回答的不好，人家就会觉得你对自己平时使用的工具都没有了解，自然就凉凉了。其实很早就有这个打算，打算好好总结一下Redis的知识，但也是由于自己都没有好好的了解Redis呢，所以一直没有开始。这次准备慢慢的来总结。&lt;/p&gt;
&lt;h2 id=&quot;redis为什么这么快&quot;&gt;Redis为什么这么快&lt;/h2&gt;
&lt;p&gt;Redis是一个由C语言编写的开源的，基于内存，支持多种数据结构可持久化的NoSQL数据库。&lt;br/&gt;它速度快主要是有以下几个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基于内存运行，性能高效；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据结构设计高效，例如String是由动态字符数组构成，zset内部的跳表；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采用单线程，避免了线程的上下文切换，也避免了线程竞争产生的死锁等问题；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用I/O多路复用模型，非阻塞IO；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官网上给出单台Redis的可以达到10w+的QPS的， 一台服务器上在使用Redis的时候单核的就够了，但是目前服务器都是多核CPU，要想不浪费资源，又能提交效率，可以在一台服务器上部署多个Redis实例。&lt;/p&gt;
&lt;h2 id=&quot;高可用方案&quot;&gt;高可用方案&lt;/h2&gt;
&lt;p&gt;虽然单台Redis的的性能很好，但是Redis的单节点并不能保证它不会挂了啊，毕竟单节点的Redis是有上限的，而且人家单节点又要读又要写，小身板扛不住咋办，所以为了保证高可用，一般都是做成集群。&lt;/p&gt;
&lt;h3 id=&quot;主从（master-slave）&quot;&gt;主从（Master-Slave）&lt;/h3&gt;
&lt;p&gt;Redis官方是支持主从同步的，而且还支持从从同步，从从同步也可以理解为主从同步，只不过从从同步的主节点是另一个主从的从节点。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201221231623140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;有了主从同步的集群，那么主节点就负责提供写操作，而从节点就负责支持读操作。&lt;/p&gt;
&lt;h4 id=&quot;那么他们之间是如何进行数据同步的呢？&quot;&gt;那么他们之间是如何进行数据同步的呢？&lt;/h4&gt;
&lt;p&gt;如果Slave（从节点）是第一次跟Master进行连接，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;那么会首先会向Master发送同步请求&lt;code&gt;psync&lt;/code&gt;；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主节点接收到同步请求，开始fork主子进程开始进行全量同步，然后生成RDB文件；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个时候主节点同时会将新的写请求，保存到缓存区（buffer）中；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从节点接收到RDB文件后，先清空老数据，然后将RDB中数据加载到内存中；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等到从节点将RDB文件同步完成后再同步缓存区中的写请求。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有一点需要注意的就是，主节点的缓存区是有限的，内部结构是一个环形数组，当数组被占满之后就会覆盖掉最早之前的数据。&lt;/p&gt;
&lt;p&gt;所以如果由于网络或是其他原因，造成缓存区中的数据被覆盖了，那么当从节点处理完主节点的RDB文件后，就不得不又要进行一全量的RDB文件的复制，才能保证主从节点的数据一致。&lt;/p&gt;
&lt;p&gt;如果不设置好合理的buffer区空间，是会造成一个RDB复制的死循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当主从间的数据同步完成之后，后面主节点的每次写操作就都会同步到从节点，这样进行增量同步了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于负载的不断上升就导致了主从之间的延时变大，所以就有了上面我说的从从同步了，主节点先同步到一部分从节点，然后由从节点去同步其他的从节点。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Redis从2.8.18开始支持无盘复制，主节点通过套接字，一边遍历内存中的数据，一边让数据发送给从节点，从节点和之前一样，先将数据存储在磁盘文件中，然后再一次性加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;另外由于主从同步是异步的，所以从Redis3.0之后出现了同步复制，就是通过wait命令来进行控制，wait命令有两个参数，第一个是从库数量，第二个是等待从库的复制时间，如果第二个参数设置为0，那么就是代表要等待所有从库都复制完才去执行后面的命令。&lt;br/&gt;但是这样就会存在一个隐患，当网络异常后，wait命令会一直阻塞下去，导致Redis不可用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;哨兵（sentinel）&quot;&gt;哨兵（Sentinel）&lt;/h3&gt;
&lt;p&gt;哨兵可以监控Redis集群的健康状态，当主节点挂掉之后，选举出新的主节点。客户端在使用Redis的时候会先通过Sentinel来获取主节点地址，然后再通过主节点来进行数据交互。当主节点挂掉之后，客户端会再次向Sentinel获取主节点，这样客户端就可以无感知的继续使用了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201225224935698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;哨兵集群工作过程，主节点挂掉之后会选举出新的主节点，然后监控挂掉的节点，当挂掉的节点恢复后，原先的主节点就会变成从节点，从新的主节点那里建立主从关系。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202012252321072.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;集群分片（redis-cluster）&quot;&gt;集群分片（Redis Cluster）&lt;/h3&gt;
&lt;p&gt;Redis Cluster是Redis官方推荐的集群模式，Redis Cluster将所有数据划分到16384个槽（&lt;code&gt;slots&lt;/code&gt;）中，每个节点负责一部分槽位的读写操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020122716591125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;存储&quot;&gt;存储&lt;/h4&gt;
&lt;p&gt;Redis Cluster默认是通过CRC16算法获取到key的hash值，然后再对16384进行取余（&lt;code&gt;CRC16(key)%16384&lt;/code&gt;），获取到的槽位在哪个节点负责的范围内（&lt;strong&gt;这里一般是会有一个槽位和节点的映射表来进行快速定位节点的，通常使用bitmap来实现&lt;/strong&gt;），就存储在哪个节点上。&lt;/p&gt;
&lt;h4 id=&quot;重定向&quot;&gt;重定向&lt;/h4&gt;
&lt;p&gt;当Redis Cluster的客户端在和集群建立连接的时候，也会获得一份槽位和节点的配置关系（&lt;strong&gt;槽位和节点的映射表&lt;/strong&gt;），这样当客户端要查找某个key时，可以直接定位到目标节点。&lt;/p&gt;
&lt;p&gt;但是当客户端发送请求时，如果接收请求的节点发现该数据的槽位并不在当前节点上，那么会返回&lt;code&gt;MOVED&lt;/code&gt;指令将正确的槽位和节点信息返回给客户端，客户接着请求正确的节点获取数据。&lt;/p&gt;
&lt;p&gt;一般客户端在接收到&lt;code&gt;MOVED&lt;/code&gt;指令后，也会更新自己本地的槽位和节点的映射表，这样下次获取数据时就可以直接命中了。这整个重定向的过程对客户端是透明的。&lt;/p&gt;
&lt;h4 id=&quot;数据迁移&quot;&gt;数据迁移&lt;/h4&gt;
&lt;p&gt;当集群中新增节点或删除节点后，节点间的数据迁移是按槽位为单位的，一个槽位一个槽位的迁移，当迁移时原节点状态处于：&lt;code&gt;magrating&lt;/code&gt;，目标节点处于：&lt;code&gt;importing&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在迁移过程中，客户端首先访问旧节点，如果数据还在旧节点，那么旧节点正常处理，如果不在旧节点，就会返回一个&lt;code&gt;-ASK + 目标节点地址&lt;/code&gt;的指令，客户端收到这个&lt;code&gt;-ASK&lt;/code&gt;指令后，向目标节点执行一个&lt;code&gt;asking&lt;/code&gt;指令（告诉新节点，必须处理客户端这个数据），然后再向目标节点执行客户端的访问数据的指令。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227200044891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;容错&quot;&gt;容错&lt;/h4&gt;
&lt;p&gt;Redis Cluster可以为每个主节点设置多个从节点，当单个主节点挂掉后，集群会自动将其中某个从节点提升为主节点，若没有从节点，那么集群将处于不可用状态。&lt;br/&gt;Redis提供了一个参数：&lt;code&gt;cluster-require-full-coverage&lt;/code&gt;，用来配置可以允许部分节点出问题后，还有其他节点在运行时可以正常提供服务。&lt;/p&gt;
&lt;p&gt;另外一点比较特殊的是，Cluster中当一个节点发现某个其他节点出现失联了，这个时候问题节点只是&lt;code&gt;PFail&lt;/code&gt;（&lt;code&gt;Possibly&lt;/code&gt;-可能下线），然后它会把这个失联信息广播给其他节点，当一个节点接收到某个节点的失联信息达到集群的大多数时，就可以将失联节点标记为下线，然后将下线信息广播给其他节点。若失联节点为主节点，那么将立即对该节点进行主从切换。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;Redis高可用就先说到这里吧，后面其实还有Codis，但是目前Cluster逐渐流行起来了，Codis的竞争力逐渐被蚕食，而且对新版本的支持，更新的也比较慢，所以这里就不说它了，感兴趣的可以自己去了解一下，国人开源的Redis集群模式Codis。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;持久化&quot;&gt;持久化&lt;/h2&gt;
&lt;p&gt;Redis持久化的意义在于，当出现宕机问题后，能将数据恢复到缓存中，它提供了两种持久化机制：&lt;strong&gt;一种是快照（RDB），一种是AOF日志。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快照是一次全量备份，而AOF是增量备份。快照是内存数据的二进制序列化形式，存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本。&lt;/p&gt;
&lt;h3 id=&quot;快照备份（rdb）&quot;&gt;快照备份（RDB）&lt;/h3&gt;
&lt;p&gt;因为Redis是单线程的，所以在做快照持久化的时候，通常有两个选择，&lt;strong&gt;save命令，会阻塞线程，直到备份完成&lt;/strong&gt;；bgsave会异步的执行备份，其实是fork出了一个子进程，用子进程去执行快照持久化操作，将数据保存在一个.rdb文件中。&lt;/p&gt;
&lt;p&gt;子进程刚刚产生的时候，是和父进程共享内存中的数据的，但是子进程做持久化时，是不会修改数据的，而父进程是要持续提供服务的，所以父进程就会持续的修改内存中的数据，这个时候父进程就会将内存中的数据，Copy出一份来进行修改。&lt;/p&gt;
&lt;p&gt;父进程copy的数据是以数据页为单位的（4k一页），对那一页数据进行修改就copy哪一页的数据。&lt;/p&gt;
&lt;p&gt;子进程由于数据没有变化就会一直的去遍历数据，进程持久化操作了，这就是只保留了创建子进程的时候的快照。&lt;/p&gt;
&lt;p&gt;那么RDB是在什么时候触发的呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;
save 60 10000
save 300 10 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上这段配置就是在redis.conf文件中配置的，第一个参数是时间单位是秒，第二个参数执行数据变化的次数。&lt;br/&gt;意思就是说：&lt;strong&gt;300秒之内至少发生10次写操作、&lt;br/&gt;60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;增量日志备份（aof）&quot;&gt;增量日志备份（AOF）&lt;/h3&gt;
&lt;p&gt;Redis在接收到客户端请求指令后，会先进行校验，校验成功后，立即将指令存储到AOF日志文件中，就是说，Redis是先记录日志，再执行命令。这样即使命令还没执行突然宕机了，通过AOF日志文件也是可以恢复的。&lt;/p&gt;
&lt;h4 id=&quot;aof重写&quot;&gt;AOF重写&lt;/h4&gt;
&lt;p&gt;AOF日志文件，随着时间的推移，会越来越大，所以就需要进行重写瘦身。AOF重写的原理就是，&lt;strong&gt;fork一个子进程，对内存进行遍历，然后生成一系列的Redis指令，然后序列化到一个新的aof文件中。然后再将遍历内存阶段的增量日志，追加到新的aof文件中，追加完成后立即替换旧的aof文件，这样就完成了AOF的瘦身重写&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;fsync&quot;&gt;fsync&lt;/h4&gt;
&lt;p&gt;因为AOF是一个写文件的IO操作，是比较耗时。所以AOF日志并不是直接写入到日志文件的，而是先写到一个内核的缓存中，然后通过异步刷脏，来将数据保存到磁盘的。&lt;/p&gt;
&lt;p&gt;由于这个情况，就导致了会有还没来得急刷脏然后就宕机了，导致数据丢失的风险。&lt;/p&gt;
&lt;p&gt;所以Redis提供了一个配置，可以手动的来选择刷脏的频率。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;mark&gt;&lt;strong&gt;always&lt;/strong&gt;&lt;/mark&gt;：每一条AOF记录都立即同步到文件，性能很低，但较为安全。&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;everysec&lt;/strong&gt;&lt;/mark&gt;：&lt;strong&gt;每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式。如果遇到物理服务器故障，可能导致最多1秒的AOF记录丢失。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;&lt;strong&gt;no&lt;/strong&gt;&lt;/mark&gt;：Redis永不直接调用文件同步，而是让操作系统来决定何时同步磁盘。性能较好，但很不安全。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AOF默认是关闭的，需要在配置文件中手动开启。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 只有在“yes”下，aof重写/文件同步等特性才会生效  
appendonly yes  
## 指定aof文件名称  
appendfilename appendonly.aof  
## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  
appendfsync everysec 
## 在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  
no-appendfsync-on-rewrite no  
## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  
auto-aof-rewrite-min-size 64mb 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis40混合持久化&quot;&gt;Redis4.0混合持久化&lt;/h3&gt;
&lt;p&gt;Redis4.0提供了一种新的持久化机制，就是RDB和AOF结合使用，将rdb文件内容和aof文件存在一起，AOF中保存的不再是全部数据了，而是从RDB开始的到结束的增量日志。&lt;/p&gt;
&lt;p&gt;这样在Redis恢复数据的时候，可以先假装RDB文件中的内容，然后在顺序执行AOF日志中指令，这样就将Redis重启时恢复数据的效率得到了大幅度提升。&lt;/p&gt;
&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;恩，这次就先总结到这里吧，后面会继续总结Redis相关知识，LRU、LFU、内存淘汰策略，管道等等。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 00:32:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 作为Java程序员，在面试过程中，缓存相关的问题是躲不掉的，肯定会问，例如缓存一致性问题，缓存雪崩、击穿、穿透等。说到缓存，那肯定少不了Redis，我在面试的时候也是被问了很多关于Redis相关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14204650.html</dc:identifier>
</item>
<item>
<title>快速沃尔什变换 (FWT)学习笔记 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/14209640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/14209640.html</guid>
<description>&lt;p&gt;证明均来自&lt;a href=&quot;https://www.luogu.com.cn/blog/xht37/solution-p4717&quot; target=&quot;_blank&quot;&gt;xht37 的洛谷博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;在 &lt;span class=&quot;math inline&quot;&gt;\(OI\)&lt;/span&gt; 中，&lt;span class=&quot;math inline&quot;&gt;\(FWT\)&lt;/span&gt; 是用于解决对下标进行位运算卷积问题的方法。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(c_{i}=\sum_{i=j \oplus k} a_{j} b_{k}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\oplus\)&lt;/span&gt; 是二元位运算中的一种。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;h3 id=&quot;运算&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(or\)&lt;/span&gt; 运算&lt;/h3&gt;
&lt;p&gt;构造 &lt;span class=&quot;math inline&quot;&gt;\(fwt[a]_i = \sum_{j|i=i} a_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{aligned} fwt[a] \times fwt[b] &amp;amp;= \left(\sum_{j|i=i} a_j\right)\left(\sum_{k|i=i} b_k\right) \\\\ &amp;amp;= \sum_{j|i=i} \sum_{k|i=i} a_jb_k \\\\ &amp;amp;= \sum_{(j|k)|i = i} a_jb_k \\\\ &amp;amp;= fwt[c] \end{aligned}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从 &lt;span class=&quot;math inline&quot;&gt;\([a]\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(fwt[a]\)&lt;/span&gt; 可以分治解决&lt;/p&gt;
&lt;p&gt;我们从小到大依次枚举长度为 &lt;span class=&quot;math inline&quot;&gt;\(2^i\)&lt;/span&gt; 的区间&lt;/p&gt;
&lt;p&gt;设最高位为第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 位&lt;/p&gt;
&lt;p&gt;此时我们已经求出了前 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位的贡献&lt;/p&gt;
&lt;p&gt;并且区间的左半部分最高位上的数字为 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;区间的右半部分最高位上的数字为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于左边的这些数，右边的数显然不可能是左边的数的子集&lt;/p&gt;
&lt;p&gt;只能由自己 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位的贡献转移过来&lt;/p&gt;
&lt;p&gt;但是左边的数会给相应位置的右边的数做出贡献&lt;/p&gt;
&lt;p&gt;因此我们在进行变换的时候要把这个贡献加上&lt;/p&gt;
&lt;p&gt;同样在进行逆变换的时候相应地减去即可&lt;/p&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void fwtor(rg int A[],rg int typ){
        for(rg int k=1,o=2;o&amp;lt;=mmax;k&amp;lt;&amp;lt;=1,o&amp;lt;&amp;lt;=1){
                for(rg int j=0;j&amp;lt;mmax;j+=o){
                        for(rg int i=0;i&amp;lt;k;i++){
                                A[i+j+k]+=typ*A[i+j];
                                A[i+j+k]=getmod(A[i+j+k]);
                        }
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运算-1&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(and\)&lt;/span&gt; 运算&lt;/h3&gt;
&lt;p&gt;和 &lt;span class=&quot;math inline&quot;&gt;\(or\)&lt;/span&gt; 运算基本一样，只是这次变成了右区间对左区间有贡献&lt;/p&gt;
&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void fwtand(rg int A[],rg int typ){
        for(rg int k=1,o=2;o&amp;lt;=mmax;k&amp;lt;&amp;lt;=1,o&amp;lt;&amp;lt;=1){
                for(rg int j=0;j&amp;lt;mmax;j+=o){
                        for(rg int i=0;i&amp;lt;k;i++){
                                A[i+j]+=typ*A[i+j+k];
                                A[i+j]=getmod(A[i+j]);
                        }
                }
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运算-2&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(xor\)&lt;/span&gt; 运算&lt;/h3&gt;
&lt;p&gt;这种运算比较复杂，因为不再是简单的子集的关系了&lt;/p&gt;
&lt;p&gt;但是我们仍然可以用以上两种运算的思想&lt;/p&gt;
&lt;p&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(x\otimes y=\text{popcount}(x \&amp;amp; y) \bmod 2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\text{popcount}\)&lt;/span&gt; 表示「二进制下 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数」&lt;/p&gt;
&lt;p&gt;满足 &lt;span class=&quot;math inline&quot;&gt;\((i \otimes j) \operatorname{xor} (i \otimes k) = i \otimes (j \operatorname{xor} k)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;构造 &lt;span class=&quot;math inline&quot;&gt;\(fwt[a]_i = \sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则有&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\begin{aligned} fwt[a] \times fwt[b] &amp;amp;= \left(\sum_{i\otimes j = 0} a_j - \sum_{i\otimes j = 1} a_j\right)\left(\sum_{i\otimes k = 0} b_k - \sum_{i\otimes k = 1} b_k\right) \\ &amp;amp;=\left(\sum_{i\otimes j=0}a_j\right)\left(\sum_{i\otimes k=0}b_k\right)-\left(\sum_{i\otimes j=0}a_j\right)\left(\sum_{i\otimes k=1}b_k\right)-\left(\sum_{i\otimes j=1}a_j\right)\left(\sum_{i\otimes k=0}b_k\right)+\left(\sum_{i\otimes j=1}a_j\right)\left(\sum_{i\otimes k=1}b_k\right) \\ &amp;amp;=\sum_{i\otimes(j \operatorname{xor} k)=0}a_jb_k-\sum_{i\otimes(j\operatorname{xor} k)=1}a_jb_k \\ &amp;amp;= fwt[c] \end{aligned} \)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当最高位是 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 时，因为 &lt;span class=&quot;math inline&quot;&gt;\(0\&amp;amp;1=0\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(0\&amp;amp;0=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二进制下 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 的个数不变&lt;/p&gt;
&lt;p&gt;所以左边区间的价值应为只考虑前 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位时左边区间的价值加上只考虑前 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位时右边区间的价值&lt;/p&gt;
&lt;p&gt;而对于右边区间，当 &lt;span class=&quot;math inline&quot;&gt;\(1\&amp;amp;1=1\)&lt;/span&gt; 时，二进制下一的个数会发生变化&lt;/p&gt;
&lt;p&gt;所以应该是只考虑前 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位时左边区间的价值减去只考虑前 &lt;span class=&quot;math inline&quot;&gt;\(i-1\)&lt;/span&gt; 位时右边区间的价值&lt;/p&gt;
&lt;p&gt;逆变换就是反这来，乘上 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt; 即可&lt;/p&gt;
&lt;h4 id=&quot;代码-2&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void fwtxor(rg int A[],rg int typ){
        for(rg int k=1,o=2;o&amp;lt;=mmax;k&amp;lt;&amp;lt;=1,o&amp;lt;&amp;lt;=1){
                for(rg int j=0;j&amp;lt;mmax;j+=o){
                        for(rg int i=0;i&amp;lt;k;i++){
                                rg int x=1LL*A[i+j]*typ%mod,y=1LL*A[i+j+k]*typ%mod;
                                A[i+j]=getmod(x+y);
                                A[i+j+k]=getmod(x-y);
                        }
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;h3 id=&quot;p5366-snoi2017遗失的答案&quot;&gt;P5366 [SNOI2017]遗失的答案&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5366&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;先特判掉 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt; 不能整除 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 的情况&lt;/p&gt;
&lt;p&gt;然后把 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 同时除以 &lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样问题就转化为了在 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 中选择一些数&lt;/p&gt;
&lt;p&gt;使得他们的最大公因数为 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，最小公倍数为 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 进行质因数分解，设 &lt;span class=&quot;math inline&quot;&gt;\(L=p_1^{a_1}p_2^{a_2}...p_n^{a_n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果要满足条件&lt;/p&gt;
&lt;p&gt;那么对于任意一个质因数 &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; ，选择的数中必须至少存在一个数，使得它分解质因数后 &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; 的指数等于 &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同理，对于任意一个质因数 &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; ，选择的数中必须至少存在一个数，不含有 &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; 这个质因数&lt;/p&gt;
&lt;p&gt;第一个条件可以看做是否满足上界，第二个条件可以看作是否满足下界&lt;/p&gt;
&lt;p&gt;因为 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 小于等于 &lt;span class=&quot;math inline&quot;&gt;\(10^{8}\)&lt;/span&gt;，所以最多含有 &lt;span class=&quot;math inline&quot;&gt;\(8\)&lt;/span&gt; 个不同的质因数&lt;/p&gt;
&lt;p&gt;因此可以状压&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(11\)&lt;/span&gt; 表示同时满足上界和下界，&lt;span class=&quot;math inline&quot;&gt;\(10\)&lt;/span&gt; 表示只满足上界，&lt;span class=&quot;math inline&quot;&gt;\(01\)&lt;/span&gt; 表示只满足下界，&lt;span class=&quot;math inline&quot;&gt;\(00\)&lt;/span&gt; 表示上界和下界都不满足&lt;/p&gt;
&lt;p&gt;显然满足条件的只能是 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 的因数，我们可以把 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 的所有因数都筛出来&lt;/p&gt;
&lt;p&gt;然后求出这些因数所代表的状态&lt;/p&gt;
&lt;p&gt;因数不会太多，最多只有 &lt;span class=&quot;math inline&quot;&gt;\(768\)&lt;/span&gt; 个&lt;/p&gt;
&lt;p&gt;如果没有必须选择 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的限制，那么直接设 &lt;span class=&quot;math inline&quot;&gt;\(f[i][j]\)&lt;/span&gt; 表示考虑前 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数，状态为 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 的方案数进行 &lt;span class=&quot;math inline&quot;&gt;\(dp\)&lt;/span&gt; 即可&lt;/p&gt;
&lt;p&gt;如果考虑 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的限制，我们就需要维护一个前缀 &lt;span class=&quot;math inline&quot;&gt;\(dp\)&lt;/span&gt; 数组 &lt;span class=&quot;math inline&quot;&gt;\(pre\)&lt;/span&gt; 和后缀 &lt;span class=&quot;math inline&quot;&gt;\(dp\)&lt;/span&gt; 数组 &lt;span class=&quot;math inline&quot;&gt;\(suf\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数，我们把 &lt;span class=&quot;math inline&quot;&gt;\(pre[i-1]\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(suf[i+1]\)&lt;/span&gt; 进行或运算卷积&lt;/p&gt;
&lt;p&gt;最后只要第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个数的状态与某个状态进行或运算等于全集&lt;/p&gt;
&lt;p&gt;那么就可以累加这个状态的答案&lt;/p&gt;
&lt;h3 id=&quot;代码-3&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int mod=1e9+7,maxn=70005,maxm=1005;
int n,g,l,q,x,mmax;
int getmod(rg int now){
        return now&amp;gt;=mod?now-mod:now&amp;lt;0?now+mod:now;
}
void fwtor(rg int A[],rg int typ){
        for(rg int o=2,k=1;o&amp;lt;=mmax;o&amp;lt;&amp;lt;=1,k&amp;lt;&amp;lt;=1){
                for(rg int i=0;i&amp;lt;mmax;i+=o){
                        for(rg int j=0;j&amp;lt;k;j++){
                                A[i+j+k]+=A[i+j]*typ;
                                A[i+j+k]=getmod(A[i+j+k]);
                        }
                }
        }
}
int pri[maxn],mi[maxn];
void divid(rg int now){
        rg int m=sqrt(now),ncnt=0;
        for(rg int i=2;i&amp;lt;=m;i++){
                if(now%i==0){
                        ncnt=0;
                        pri[++pri[0]]=i;
                        while(now%i==0){
                                now/=i;
                                ncnt++;
                        }
                        mi[pri[0]]=ncnt;
                }
        }
        if(now&amp;gt;1){
                pri[++pri[0]]=now;
                mi[pri[0]]=1;
        }
}
int sta[maxn],tp,zt[maxn];
void getit(){
        rg int m=sqrt(l);
        for(rg int i=1;i&amp;lt;=m;i++){
                if(l%i==0){
                        if(i&amp;lt;=n) sta[++tp]=i;
                        if(i*i!=l &amp;amp;&amp;amp; l/i&amp;lt;=n) sta[++tp]=l/i;
                }
        }
}
int pre[maxm][maxn],suf[maxm][maxn],tmp[maxn],ans[maxn];
int getzt(rg int now){
        rg int zt0=0,zt1=0;
        for(rg int i=1;i&amp;lt;=pri[0];i++){
                rg int ncnt=0;
                while(now%pri[i]==0){
                        now/=pri[i];
                        ncnt++;
                }
                if(ncnt==0) zt0|=(1&amp;lt;&amp;lt;(i-1));
                else if(ncnt==mi[i]) zt1|=(1&amp;lt;&amp;lt;(i-1));
        }
        return zt0|(zt1&amp;lt;&amp;lt;pri[0]);
}
int main(){
        n=read(),g=read(),l=read(),q=read();
        if(l%g){
                for(rg int i=1;i&amp;lt;=q;i++){
                        x=read();
                        printf(&quot;0\n&quot;);
                }
        } else {
                l/=g,n/=g;
                divid(l);
                mmax=1&amp;lt;&amp;lt;(2*pri[0]);
                getit();
                std::sort(sta+1,sta+1+tp);
                for(rg int i=1;i&amp;lt;=tp;i++) zt[i]=getzt(sta[i]);
                pre[0][0]=suf[tp+1][0]=1;
                for(rg int i=1;i&amp;lt;=tp;i++){
                        memcpy(pre[i],pre[i-1],sizeof(pre[i-1]));
                        for(rg int j=0;j&amp;lt;mmax;j++){
                                pre[i][j|zt[i]]=getmod(pre[i][j|zt[i]]+pre[i-1][j]);
                        }
                }
                for(rg int i=tp;i&amp;gt;=1;i--){
                        memcpy(suf[i],suf[i+1],sizeof(suf[i+1]));
                        for(rg int j=0;j&amp;lt;mmax;j++){
                                suf[i][j|zt[i]]=getmod(suf[i][j|zt[i]]+suf[i+1][j]);
                        }
                }
                for(rg int i=0;i&amp;lt;=tp+1;i++){
                        fwtor(pre[i],1);
                        fwtor(suf[i],1);
                }
                for(rg int i=1;i&amp;lt;=tp;i++){
                        for(rg int j=0;j&amp;lt;mmax;j++){
                                tmp[j]=1LL*pre[i-1][j]*suf[i+1][j]%mod;
                        }
                        fwtor(tmp,-1);
                        for(rg int j=0;j&amp;lt;mmax;j++){
                                if((zt[i]|j)==mmax-1) ans[i]=getmod(ans[i]+tmp[j]);
                        }
                }
                for(rg int i=1;i&amp;lt;=q;i++){
                        x=read();
                        if(x%g) printf(&quot;0\n&quot;);
                        else {
                                x/=g;
                                if(l%x) printf(&quot;0\n&quot;);
                                else {
                                        rg int wz=std::lower_bound(sta+1,sta+1+tp,x)-sta;
                                        printf(&quot;%d\n&quot;,ans[wz]);
                                }
                        }
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;p3175-haoi2015按位或&quot;&gt;P3175 [HAOI2015]按位或&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3175&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析-1&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;要用到 &lt;span class=&quot;math inline&quot;&gt;\(min\)&lt;/span&gt;−&lt;span class=&quot;math inline&quot;&gt;\(max\)&lt;/span&gt; 容斥&lt;/p&gt;
&lt;p&gt;不会的可以看我的&lt;a href=&quot;https://www.cnblogs.com/liuchanglc/p/13858476.html&quot; target=&quot;_blank&quot;&gt;容斥原理学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T) $&lt;/p&gt;
&lt;p&gt;$min(S)=\sum_{T\subseteq S}(-1)^{|T|+1}max(T) $&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(max(S)\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中最晚的元素出现的期望次数&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(min(S)\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中最早的元素出现的期望次数&lt;/p&gt;
&lt;p&gt;问题转换为如何求 &lt;span class=&quot;math inline&quot;&gt;\(min(T)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(P=\sum\limits_{S\subseteq\complement_UT}P(S)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(E(\min(T))=P\sum\limits^{+\infty}_{i=1}i(1-p)^{i-1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有边是一个等比数列乘等差数列的求和公式&lt;/p&gt;
&lt;p&gt;化简之后是&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1-(1-P)^n}{P^2}-\frac{n(1-P)^n}{P}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 趋进于无穷大时&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\((1-P)^n\)&lt;/span&gt; 趋进于 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此最终的结果是 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{P^2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再乘上外面的一个 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，就是 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{P}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;剩下的再用一个或运算卷积即可&lt;/p&gt;
&lt;h3 id=&quot;代码-4&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=2e6+5,mod=998244353;
const double eps=1e-10;
int n,mmax,siz[maxn];
double a[maxn];
void fwtor(rg double A[],rg int typ){
        for(rg int i=1;i&amp;lt;=n;i++){
                for(rg int j=0;j&amp;lt;mmax;j+=(1&amp;lt;&amp;lt;i)){
                        for(rg int k=0;k&amp;lt;1&amp;lt;&amp;lt;(i-1);k++){
                                A[j|(1&amp;lt;&amp;lt;(i-1))|k]+=A[j|k]*typ;
                        }
                }
        }
}
int main(){
        n=read();
        mmax=1&amp;lt;&amp;lt;n;
        for(rg int i=0;i&amp;lt;mmax;i++){
                scanf(&quot;%lf&quot;,&amp;amp;a[i]);
        }
        fwtor(a,1);
        for(rg int i=0;i&amp;lt;mmax;i++){
                siz[i]=siz[i&amp;gt;&amp;gt;1]+(i&amp;amp;1);
        }
        rg double nans=0;
        for(rg int i=1;i&amp;lt;mmax;i++){
                if(1.0-a[(mmax-1)^i]&amp;lt;eps){
                        printf(&quot;INF\n&quot;);
                        return 0;
                }
                nans+=((siz[i]&amp;amp;1)?(1.0):(-1.0))/(1.0-a[(mmax-1)^i]);
        }
        printf(&quot;%.8f\n&quot;,nans);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;p5643-pkuwc2018随机游走&quot;&gt;P5643 [PKUWC2018]随机游走&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5643&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析-2&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;同样是 &lt;span class=&quot;math inline&quot;&gt;\(min\)&lt;/span&gt;-&lt;span class=&quot;math inline&quot;&gt;\(max\)&lt;/span&gt; 容斥，先求出至少经过一个点的期望步数&lt;/p&gt;
&lt;p&gt;然后再求出全部经过的期望步数&lt;/p&gt;
&lt;p&gt;$max(S)=\sum_{T\subseteq S}(-1)^{|T|+1}min(T) $&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(f_i\)&lt;/span&gt; 表示从 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 出发，经过 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 中的至少一个点的期望步数&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(deg_i\)&lt;/span&gt; 为点 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的度数，&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 的儿子节点&lt;/p&gt;
&lt;p&gt;可以得到这样的递推式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_i=\frac1{deg_i}(f_{fa_i}+\sum f_j)+1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(f_i=k_if_{fa_i}+b_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;化简之后可以得到&lt;/p&gt;
&lt;p&gt;$f_i=\frac1{deg_i-\sum k_j}f_{fa_i}+\frac{deg_i+\sum b_j}{deg_i-\sum k_j} $&lt;/p&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;p&gt;$k_i=\frac 1{deg_i-\sum k_j},b_i=\frac{deg_i+\sum b_j}{deg_i-\sum k_j} $&lt;/p&gt;
&lt;p&gt;这个东西可以 &lt;span class=&quot;math inline&quot;&gt;\(dfs\)&lt;/span&gt; 求出来&lt;/p&gt;
&lt;p&gt;然后就可以用或运算卷积合并预处理出每一个集合的答案&lt;/p&gt;
&lt;h3 id=&quot;代码-5&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;cstring&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e6+5,maxm=25,mod=998244353;
int n,q,x,mmax,h[maxm],k[maxm],a[maxm],tot=1,du[maxm],ans[maxn],siz[maxn];
int ksm(rg int ds,rg int zs){
        rg int nans=1;
        while(zs){
                if(zs&amp;amp;1) nans=1LL*nans*ds%mod;
                ds=1LL*ds*ds%mod;
                zs&amp;gt;&amp;gt;=1;
        }
        return nans;
}
struct asd{
        int to,nxt;
}b[maxm&amp;lt;&amp;lt;1];
void ad(rg int aa,rg int bb){
        b[tot].to=bb;
        b[tot].nxt=h[aa];
        h[aa]=tot++;
}
int getmod(rg int now){
        return (now&amp;gt;=mod)?(now-mod):((now&amp;lt;0)?(now+mod):now);
}
void fwtor(rg int A[],rg int typ){
        for(rg int o=2,k=1;o&amp;lt;=mmax;o&amp;lt;&amp;lt;=1,k&amp;lt;&amp;lt;=1){
                for(rg int i=0;i&amp;lt;mmax;i+=o){
                        for(rg int j=0;j&amp;lt;k;j++){
                                A[i+j+k]+=A[i+j]*typ;
                                A[i+j+k]=getmod(A[i+j+k]);
                        }
                }
        }
}
void dfs(rg int now,rg int lat,rg int zt){
        if(zt&amp;amp;(1&amp;lt;&amp;lt;(now-1))) return;
        rg int ans1=0,ans2=0;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat) continue;
                dfs(u,now,zt);
                ans1+=k[u];
                ans2+=a[u];
                ans1=getmod(ans1);
                ans2=getmod(ans2);
        }
        k[now]=ksm(getmod(du[now]-ans1),mod-2);
        a[now]=1LL*k[now]*getmod(du[now]+ans2)%mod;
}
int main(){
        memset(h,-1,sizeof(h));
        n=read(),q=read(),x=read();
        rg int aa,bb,cc;
        for(rg int i=1;i&amp;lt;n;i++){
                aa=read(),bb=read();
                ad(aa,bb);
                ad(bb,aa);
                du[aa]++,du[bb]++;
        }
        mmax=1&amp;lt;&amp;lt;n;
        for(rg int i=0;i&amp;lt;mmax;i++) siz[i]=siz[i&amp;gt;&amp;gt;1]+(i&amp;amp;1);
        for(rg int i=0;i&amp;lt;mmax;i++){
                memset(k,0,sizeof(k));
                memset(a,0,sizeof(a));
                dfs(x,0,i);
                ans[i]=a[x]*((siz[i]&amp;amp;1)?1:(-1));
                ans[i]=getmod(ans[i]);
        }
        fwtor(ans,1);
        for(rg int i=1;i&amp;lt;=q;i++){
                aa=read();
                cc=0;
                for(rg int j=1;j&amp;lt;=aa;j++){
                        bb=read();
                        cc|=(1&amp;lt;&amp;lt;(bb-1));
                }
                printf(&quot;%d\n&quot;,ans[cc]);
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 30 Dec 2020 00:28:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>证明均来自xht37 的洛谷博客 作用 在 \(OI\) 中，\(FWT\) 是用于解决对下标进行位运算卷积问题的方法。 \(c_{i}=\sum_{i=j \oplus k} a_{j} b_{k}</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/14209640.html</dc:identifier>
</item>
<item>
<title>Node.js躬行记（5）——定时任务的调试 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/14185714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/14185714.html</guid>
<description>&lt;p&gt;　　最近做一个活动，需要用到定时任务，于是使用了 &lt;span&gt;&lt;a href=&quot;https://github.com/node-schedule/node-schedule&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;node-schedule&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 库。&lt;/p&gt;
&lt;p&gt;　　用法很简单，就是可配置开始、结束时间，以及重复执行的时间点，如下所示，从2020-12-23T09:00:00Z开始，每10分钟执行一次，直至2020-12-23T09:30:30Z结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;schedule.scheduleJob({ 
  start: &lt;/span&gt;'2020-12-23T09:00:00Z'&lt;span&gt;, 
  end: &lt;/span&gt;'2020-12-23T09:30:30Z'&lt;span&gt;, 
  rule: &lt;/span&gt;'* */10 * * * *'&lt;span&gt; 
}, test);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果是需要在未来某个时间段执行的定时任务，那么要还原真实场景，就得修改服务器时间。&lt;/p&gt;
&lt;p&gt;　　测试环境虽然可以改时间，但是我们这边是几个组共用几台服务器，修改了时间后，可能会影响其他组的业务，并且正式环境的时间是不能修改的。&lt;/p&gt;
&lt;p&gt;　　一开始测试的时候，改过几次时间，改时间毕竟太繁琐，每次代码发布，服务器的时间就又会重置，又要修正一次，还收到了其他组的投诉。&lt;/p&gt;
&lt;p&gt;　　后面就改成今天的时间段，这次的定时任务的时间段有7个，每次修改好后，就要提交一遍代码，然后合并分支，最后发布一下代码，服务也会重新启动。&lt;/p&gt;
&lt;p&gt;　　这种纯手工方式过于费时，后面想到可以在后台做个通用配置（下图是个配置列表），将这些常量（例如时间参数）存在数据库（例如MongoDB或MySQL）中，可随时读写。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201225110712813-1920678763.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图是个增和改的弹框，在新增的时候需要格式化多行文本中的JSON数据，先用 eval()，再用JSON.stringify()，这样的话在调用JSON.parse()的时候就不会出错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
JSON.stringify(eval(`(${values.content})`))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201225111030125-1152467946.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了让JSON数据的展示更友好，就需要格式化数据，也就是要有空格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
JSON.stringify(JSON.parse(record.content), &lt;span&gt;null&lt;/span&gt;, 2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在测试环境或正式环境，如果定时任务处理的数据错误了，那么只能通过日志来排查。&lt;/p&gt;
&lt;p&gt;　　而一台跑着的服务器中会有很多其他的定时任务，在测试环境中，为了能看清楚日志，可以只运行一个任务。&lt;/p&gt;
&lt;p&gt;　　但是在正式环境中，是不能停止任务的，像目前运行的定时任务，可能几秒内就有几百行的日志，用肉眼观察有点累。&lt;/p&gt;
&lt;p&gt;　　好在我们这边接入了阿里云的日志服务，可以查看日志控制台，里面有丰富的查询过滤条件，可以准确的定位到某条日志。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201225111244963-978980070.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果你有更好的调试方法，欢迎留言讨论。&lt;/p&gt;

&lt;p&gt;　　在线上运行的时候，可能会因为这个那个的问题导致任务没有在指定时间运行。&lt;/p&gt;
&lt;p&gt;　　那么就得开放一个入口，来手动执行这个任务。&lt;/p&gt;
&lt;p&gt;　　一开始的想法是写个临时接口，然后用postman手动访问，不过这样的话对运营不太友好，毕竟运营会有人半夜值班盯着活动，但开发人员是不会半夜还盯着服务器的。&lt;/p&gt;
&lt;p&gt;　　于是又快速搭了个后台执行页面，有个下拉框可选择任务时间段，还有个运行按钮，到时候出问题的话，就手动运行一次。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201225113549272-925835210.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 30 Dec 2020 00:05:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>最近做一个活动，需要用到定时任务，于是使用了&amp;#160;node-schedule 库。 用法很简单，就是可配置开始、结束时间，以及重复执行的时间点，如下所示，从2020-12-23T09:00:00</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/14185714.html</dc:identifier>
</item>
<item>
<title>浅谈IAT加密原理及过程 - __阿阿阿怪</title>
<link>http://www.cnblogs.com/aaaguai/p/14207468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaaguai/p/14207468.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;   1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt;   2&lt;/span&gt; #include&amp;lt;Windows.h&amp;gt;
&lt;span&gt;   3&lt;/span&gt; #include&amp;lt;map&amp;gt;
&lt;span&gt;   4&lt;/span&gt; #include&amp;lt;vector&amp;gt;
&lt;span&gt;   5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Asmjit\\asmjit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;   6&lt;/span&gt; 
&lt;span&gt;   7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;   8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; asmjit;
&lt;/span&gt;&lt;span&gt;   9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; asmjit::x86;
&lt;/span&gt;&lt;span&gt;  10&lt;/span&gt; 
&lt;span&gt;  11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iFileSize = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件大小&lt;/span&gt;
&lt;span&gt;  12&lt;/span&gt; UCHAR *g_pFileSrc = NULL;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件内容  (此处必须为无符号字符指针，因为char会将十六进制的最高位默认为符号位)&lt;/span&gt;
&lt;span&gt;  13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iSectionAlignment = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存对齐大小&lt;/span&gt;
&lt;span&gt;  14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iFileAlignment = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件对齐大小&lt;/span&gt;
&lt;span&gt;  15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iImageBase = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址&lt;/span&gt;
&lt;span&gt;  16&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iNewOEP = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新入口点&lt;/span&gt;
&lt;span&gt;  17&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; g_iOldOEP = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旧入口点&lt;/span&gt;
&lt;span&gt;  18&lt;/span&gt; 
&lt;span&gt;  19&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; FuncTag
&lt;/span&gt;&lt;span&gt;  20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  21&lt;/span&gt;     BYTE iFuncNameLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数名称长度&lt;/span&gt;
&lt;span&gt;  22&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;szFuncName;
&lt;/span&gt;&lt;span&gt;  23&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;  24&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DLLFuncTag
&lt;/span&gt;&lt;span&gt;  25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  26&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; bDllNameLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DLL名长度&lt;/span&gt;
&lt;span&gt;  27&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;szDllName;
&lt;/span&gt;&lt;span&gt;  28&lt;/span&gt;     WORD wFuncNum;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前DLL的函数数量&lt;/span&gt;
&lt;span&gt;  29&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; bTab;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入方式：0为序号导入 1为名称&lt;/span&gt;
&lt;span&gt;  30&lt;/span&gt;     vector&amp;lt;FuncTag&amp;gt;vFuncNAMEorNo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：此时的序号已经去掉最高位&lt;/span&gt;
&lt;span&gt;  31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;  32&lt;/span&gt; vector&amp;lt;DLLFuncTag&amp;gt;g_tagDllFunc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放IAT信息的结构体，成员为DLL名长度，DLL名，函数数量，标志(最高位为1则是序号，否则为一个字符串的地址)，函数名列表
&lt;/span&gt;&lt;span&gt;  33&lt;/span&gt; 
&lt;span&gt;  34&lt;/span&gt; 
&lt;span&gt;  35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先通过遍历获得下面结构体中各个成员的值  注：成员的位置皆为RVA&lt;/span&gt;
&lt;span&gt;  36&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  37&lt;/span&gt; &lt;span&gt;1.将dwRelocAddr这4字节的地址放入重定位表中，使其在运行后该位置的值变为程序基址
&lt;/span&gt;&lt;span&gt;  38&lt;/span&gt; &lt;span&gt;2.先去dwCallAddr的位置，将那行代码修改为jmp dwJmpAddr(如果是mov eax，则直接修改即可，其他的则要填充多一个nop(0x90)，以便对齐指令长度)
&lt;/span&gt;&lt;span&gt;  39&lt;/span&gt; &lt;span&gt;3.执行shellcode时，会将2的调用地址+5/+6作为返回地址压栈 （jmp指令除外）
&lt;/span&gt;&lt;span&gt;  40&lt;/span&gt; &lt;span&gt;4.将NewLatAddr的值，加上基址后，在得到的地址上取值，该地址上的值与原IAT所指向的值相同
&lt;/span&gt;&lt;span&gt;  41&lt;/span&gt; &lt;span&gt;5.执行完后，根据3得到的值，返回到调用指令的下一条指令上
&lt;/span&gt;&lt;span&gt;  42&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  43&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; IatAddrTab
&lt;/span&gt;&lt;span&gt;  44&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  45&lt;/span&gt;     DWORD dwCallAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以便区分当前是什么类型下使用了这个IAT地址  注意，这里为整个调用代码的位置，而非调用的代码的函数地址的位置    &lt;/span&gt;
&lt;span&gt;  46&lt;/span&gt;     BYTE bType;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该调用类型 0-7为mov eax、edx、esp、esi、ecx、ebx、ebp、edi  8为call 9为jmp (其中8和9可以归类成一个处理方式) 10为push  &lt;/span&gt;
&lt;span&gt;  47&lt;/span&gt;     DWORD dwRelocAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于添加到重定位块中，该位置存放的为基址&lt;/span&gt;
&lt;span&gt;  48&lt;/span&gt;     WORD wIndex;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前IAT位于加载表的下标 每个地址占4字节&lt;/span&gt;
&lt;span&gt;  49&lt;/span&gt;     DWORD dwOldIatAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原IAT地址&lt;/span&gt;
&lt;span&gt;  50&lt;/span&gt;     DWORD dwNewIatAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将要替换成的新IAT地址&lt;/span&gt;
&lt;span&gt;  51&lt;/span&gt;     DWORD dwJmpAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode所在的起始位置RVA     &lt;/span&gt;
&lt;span&gt;  52&lt;/span&gt; &lt;span&gt;};  
&lt;/span&gt;&lt;span&gt;  53&lt;/span&gt; vector&amp;lt;IatAddrTab&amp;gt;g_tagIAT;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放IAT替换地址的结构体，成员为IAT地址，以及一个调用地址位置，还有一个该IAT类型&lt;/span&gt;
&lt;span&gt;  54&lt;/span&gt; 
&lt;span&gt;  55&lt;/span&gt; 
&lt;span&gt;  56&lt;/span&gt; vector&amp;lt;DWORD&amp;gt;&lt;span&gt;g_IATaddrList;
&lt;/span&gt;&lt;span&gt;  57&lt;/span&gt; 
&lt;span&gt;  58&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tagRelocation
&lt;/span&gt;&lt;span&gt;  59&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  60&lt;/span&gt; &lt;span&gt;    DWORD wR_Head;
&lt;/span&gt;&lt;span&gt;  61&lt;/span&gt;     vector&amp;lt;WORD&amp;gt;&lt;span&gt;wR_Offset;
&lt;/span&gt;&lt;span&gt;  62&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;  63&lt;/span&gt; vector&amp;lt;tagRelocation&amp;gt;&lt;span&gt;vOldReloction;
&lt;/span&gt;&lt;span&gt;  64&lt;/span&gt; 
&lt;span&gt;  65&lt;/span&gt; 
&lt;span&gt;  66&lt;/span&gt; VOID GetKernel32Base(X86Assembler &amp;amp;&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;  67&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  68&lt;/span&gt;     Label GetInfoBegin =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt;  69&lt;/span&gt;     Label cmpDllName =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt;  70&lt;/span&gt;     Label cmpChar =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt;  71&lt;/span&gt;     Label GetNextModule =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt;  72&lt;/span&gt;     Label GetBaseOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt;  73&lt;/span&gt; 
&lt;span&gt;  74&lt;/span&gt; &lt;span&gt;    a.push(ebx);
&lt;/span&gt;&lt;span&gt;  75&lt;/span&gt; &lt;span&gt;    a.push(ecx);
&lt;/span&gt;&lt;span&gt;  76&lt;/span&gt; &lt;span&gt;    a.push(edx);
&lt;/span&gt;&lt;span&gt;  77&lt;/span&gt; &lt;span&gt;    a.push(esi);
&lt;/span&gt;&lt;span&gt;  78&lt;/span&gt; &lt;span&gt;    a.push(edi);
&lt;/span&gt;&lt;span&gt;  79&lt;/span&gt; &lt;span&gt;    a.mov(edx, esp);
&lt;/span&gt;&lt;span&gt;  80&lt;/span&gt;     a.sub(esp, &lt;span&gt;0x18&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  81&lt;/span&gt;     
&lt;span&gt;  82&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x00&lt;/span&gt;), &lt;span&gt;0x0065006B&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  83&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x04&lt;/span&gt;), &lt;span&gt;0x006E0072&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  84&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x08&lt;/span&gt;), &lt;span&gt;0x006C0065&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  85&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x0C&lt;/span&gt;), &lt;span&gt;0x00320033&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  86&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x10&lt;/span&gt;), &lt;span&gt;0x0064002E&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  87&lt;/span&gt;     a.mov(dword_ptr(esp, &lt;span&gt;0x14&lt;/span&gt;), &lt;span&gt;0x006C006C&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;  88&lt;/span&gt; &lt;span&gt;    a.xor_(eax, eax);
&lt;/span&gt;&lt;span&gt;  89&lt;/span&gt;     a.mov(esi, dword_ptr_abs(&lt;span&gt;0x30&lt;/span&gt;).setSegment(fs));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得PEB 同理mov esi,fs:[30]&lt;/span&gt;
&lt;span&gt;  90&lt;/span&gt;     a.mov(esi, dword_ptr(esi, &lt;span&gt;0x0C&lt;/span&gt;));            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到dll的列表指针&lt;/span&gt;
&lt;span&gt;  91&lt;/span&gt;     a.mov(esi, dword_ptr(esi, &lt;span&gt;0x1C&lt;/span&gt;));             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到初始化序模块化&lt;/span&gt;
&lt;span&gt;  92&lt;/span&gt; 
&lt;span&gt;  93&lt;/span&gt;     a.bind(GetInfoBegin);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历模块信息&lt;/span&gt;
&lt;span&gt;  94&lt;/span&gt;     a.mov(edi, dword_ptr(esi, &lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到当前模块基址&lt;/span&gt;
&lt;span&gt;  95&lt;/span&gt;     a.lea(ebx, dword_ptr(esi, &lt;span&gt;0x1c&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到UNICODE STRING结构&lt;/span&gt;
&lt;span&gt;  96&lt;/span&gt;     a.movzx(ecx, word_ptr(ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出长度&lt;/span&gt;
&lt;span&gt;  97&lt;/span&gt;     a.cmp (ecx, &lt;span&gt;24&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比长度&lt;/span&gt;
&lt;span&gt;  98&lt;/span&gt;     a.jne(GetNextModule);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不等则获取下一个模块&lt;/span&gt;
&lt;span&gt;  99&lt;/span&gt;     a.mov(ebx, dword_ptr(ebx , &lt;span&gt;4&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到字符串地址  此时ebx不再为结构地址&lt;/span&gt;
&lt;span&gt; 100&lt;/span&gt;     a.mov(ecx, &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于遍历&lt;/span&gt;
&lt;span&gt; 101&lt;/span&gt; 
&lt;span&gt; 102&lt;/span&gt;     a.bind(cmpDllName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比模块名字&lt;/span&gt;
&lt;span&gt; 103&lt;/span&gt;     a.cmp(ecx, &lt;span&gt;24&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 104&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历到字符末尾 找到目标模块(先对的长度再对的字符，排除了前面同名后面A/W的情况)&lt;/span&gt;
&lt;span&gt; 105&lt;/span&gt;     a.jnl(GetBaseOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取基址结束&lt;/span&gt;
&lt;span&gt; 106&lt;/span&gt;     a.xor_ (eax, eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空容器&lt;/span&gt;
&lt;span&gt; 107&lt;/span&gt; &lt;span&gt;    a.movzx(eax, word_ptr(ebx, ecx));
&lt;/span&gt;&lt;span&gt; 108&lt;/span&gt;     a.cmp(eax, &lt;span&gt;0x41&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是大写字符(41~5A)范围内，转成小写&lt;/span&gt;
&lt;span&gt; 109&lt;/span&gt; &lt;span&gt;    a.jna(cmpChar);
&lt;/span&gt;&lt;span&gt; 110&lt;/span&gt;     a.cmp(eax, &lt;span&gt;0x5A&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 111&lt;/span&gt; &lt;span&gt;    a.ja(cmpChar);
&lt;/span&gt;&lt;span&gt; 112&lt;/span&gt;     a.add(eax, &lt;span&gt;0x20&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大写字符的值+0x20即转成小写字符&lt;/span&gt;
&lt;span&gt; 113&lt;/span&gt;     
&lt;span&gt; 114&lt;/span&gt;     a.bind(cmpChar);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比每个字符&lt;/span&gt;
&lt;span&gt; 115&lt;/span&gt;     a.cmp(ax, word_ptr(esp, ecx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比字符串内容&lt;/span&gt;
&lt;span&gt; 116&lt;/span&gt;     a.jne(GetNextModule);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不等则获取下一个模块&lt;/span&gt;
&lt;span&gt; 117&lt;/span&gt;     a.add(ecx, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 118&lt;/span&gt; &lt;span&gt;    a.jmp(cmpDllName);
&lt;/span&gt;&lt;span&gt; 119&lt;/span&gt; 
&lt;span&gt; 120&lt;/span&gt;     a.bind(GetNextModule);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得下一个模块信息&lt;/span&gt;
&lt;span&gt; 121&lt;/span&gt;     a.mov(esi, dword_ptr(esi));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得下一个初始化模块&lt;/span&gt;
&lt;span&gt; 122&lt;/span&gt; &lt;span&gt;    a.test(esi, esi);
&lt;/span&gt;&lt;span&gt; 123&lt;/span&gt;     a.jnz(GetInfoBegin);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不为空则继续遍历&lt;/span&gt;
&lt;span&gt; 124&lt;/span&gt; 
&lt;span&gt; 125&lt;/span&gt; &lt;span&gt;    a.bind(GetBaseOver);
&lt;/span&gt;&lt;span&gt; 126&lt;/span&gt; &lt;span&gt;    a.mov(eax, edi);
&lt;/span&gt;&lt;span&gt; 127&lt;/span&gt;     a.add(esp, &lt;span&gt;0x18&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 128&lt;/span&gt; &lt;span&gt;    a.pop(edi);
&lt;/span&gt;&lt;span&gt; 129&lt;/span&gt; &lt;span&gt;    a.pop(esi);
&lt;/span&gt;&lt;span&gt; 130&lt;/span&gt; &lt;span&gt;    a.pop(edx);
&lt;/span&gt;&lt;span&gt; 131&lt;/span&gt; &lt;span&gt;    a.pop(ecx);
&lt;/span&gt;&lt;span&gt; 132&lt;/span&gt; &lt;span&gt;    a.pop(ebx);
&lt;/span&gt;&lt;span&gt; 133&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 134&lt;/span&gt; 
&lt;span&gt; 135&lt;/span&gt; VOID GetLoadLibraryAAddr(X86Assembler &amp;amp;&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt; 136&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 137&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转标记&lt;/span&gt;
&lt;span&gt; 138&lt;/span&gt;     Label FindFuncAddr =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 139&lt;/span&gt;     Label FindFuncAddrOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 140&lt;/span&gt; 
&lt;span&gt; 141&lt;/span&gt; &lt;span&gt;    a.push(ebx);
&lt;/span&gt;&lt;span&gt; 142&lt;/span&gt; &lt;span&gt;    a.push(ecx);
&lt;/span&gt;&lt;span&gt; 143&lt;/span&gt; &lt;span&gt;    a.push(esi);
&lt;/span&gt;&lt;span&gt; 144&lt;/span&gt; &lt;span&gt;    a.push(ebp);
&lt;/span&gt;&lt;span&gt; 145&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记得开始获取出来的都是RVA  要加上DLL的基址edi来取值&lt;/span&gt;
&lt;span&gt; 146&lt;/span&gt;     a.mov(eax, dword_ptr(edi, &lt;span&gt;0x3c&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 147&lt;/span&gt;     a.mov(ebx, dword_ptr(edi, eax, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x78&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NT头+0x78 = 导入表RVA
&lt;/span&gt;&lt;span&gt; 148&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面等价于[edi + eax + 0x78]，如果没有0的话，他会把第三个参数当成2的N次方变成了edi + eax * 2的0x78次方&lt;/span&gt;
&lt;span&gt; 149&lt;/span&gt;     a.add(ebx, edi);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebx=导入表&lt;/span&gt;
&lt;span&gt; 150&lt;/span&gt;     a.mov(ecx, dword_ptr(ebx, &lt;span&gt;0x18&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ecx=按名称导出个数&lt;/span&gt;
&lt;span&gt; 151&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x20&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=导出函数名称表rva&lt;/span&gt;
&lt;span&gt; 152&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 153&lt;/span&gt; 
&lt;span&gt; 154&lt;/span&gt; &lt;span&gt;    a.bind(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 155&lt;/span&gt;     a.sub(ecx, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从后面往前遍历 能少占用一个寄存器，但要记得先-1再遍历&lt;/span&gt;
&lt;span&gt; 156&lt;/span&gt;     a.jz(FindFuncAddrOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减到0即遍历完&lt;/span&gt;
&lt;span&gt; 157&lt;/span&gt;     a.mov(ebp, dword_ptr(esi, ecx, &lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到函数名称比拗最后一个函数名的RVA 等价于[esi,ecx*(2的n次方)]&lt;/span&gt;
&lt;span&gt; 158&lt;/span&gt; &lt;span&gt;    a.add(ebp, edi);
&lt;/span&gt;&lt;span&gt; 159&lt;/span&gt;     a.cmp(dword_ptr(ebp), &lt;span&gt;0x64616F4C&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 160&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 161&lt;/span&gt;     a.cmp(dword_ptr(ebp, &lt;span&gt;4&lt;/span&gt;), &lt;span&gt;0x7262694C&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 162&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 163&lt;/span&gt;     a.cmp(dword_ptr(ebp, &lt;span&gt;8&lt;/span&gt;), &lt;span&gt;0x41797261&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 164&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 165&lt;/span&gt;     a.cmp(byte_ptr(ebp, &lt;span&gt;12&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束符  防止类似LoadLibrary和LoadLibraryA扩展函数名偏差出现&lt;/span&gt;
&lt;span&gt; 166&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 167&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时ecx为遍历的下标 &lt;/span&gt;
&lt;span&gt; 168&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x24&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=导出函数序号表RVA(上面名称对比完 回收esi)&lt;/span&gt;
&lt;span&gt; 169&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 170&lt;/span&gt;     a.movzx(ebp, word_ptr(esi, ecx, &lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebp=函数序号 ebp=[esi+ecx*2一次方]
&lt;/span&gt;&lt;span&gt; 171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EBP:Get=2b0 Load=3c2&lt;/span&gt;
&lt;span&gt; 172&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x1c&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=函数地址表RVA&lt;/span&gt;
&lt;span&gt; 173&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 174&lt;/span&gt;     a.mov(eax, dword_ptr(esi, ebp, &lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址=地址表+序号*2的2次方&lt;/span&gt;
&lt;span&gt; 175&lt;/span&gt; &lt;span&gt;    a.add(eax, edi);
&lt;/span&gt;&lt;span&gt; 176&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时eax为loadlibraryA地址&lt;/span&gt;
&lt;span&gt; 177&lt;/span&gt; &lt;span&gt;    a.bind(FindFuncAddrOver);
&lt;/span&gt;&lt;span&gt; 178&lt;/span&gt; &lt;span&gt;    a.pop(ebp);
&lt;/span&gt;&lt;span&gt; 179&lt;/span&gt; &lt;span&gt;    a.pop(esi);
&lt;/span&gt;&lt;span&gt; 180&lt;/span&gt; &lt;span&gt;    a.pop(ecx);
&lt;/span&gt;&lt;span&gt; 181&lt;/span&gt; &lt;span&gt;    a.pop(ebx);
&lt;/span&gt;&lt;span&gt; 182&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 183&lt;/span&gt; 
&lt;span&gt; 184&lt;/span&gt; VOID GetGetProcAddressAddr(X86Assembler &amp;amp;&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt; 185&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 186&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转标记&lt;/span&gt;
&lt;span&gt; 187&lt;/span&gt;     Label FindFuncAddr =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 188&lt;/span&gt;     Label FindFuncAddrOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 189&lt;/span&gt; 
&lt;span&gt; 190&lt;/span&gt; &lt;span&gt;    a.push(ebx);
&lt;/span&gt;&lt;span&gt; 191&lt;/span&gt; &lt;span&gt;    a.push(ecx);
&lt;/span&gt;&lt;span&gt; 192&lt;/span&gt; &lt;span&gt;    a.push(esi);
&lt;/span&gt;&lt;span&gt; 193&lt;/span&gt; &lt;span&gt;    a.push(ebp);
&lt;/span&gt;&lt;span&gt; 194&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记得开始获取出来的都是RVA  要加上DLL的基址edi来取值&lt;/span&gt;
&lt;span&gt; 195&lt;/span&gt;     a.mov(eax, dword_ptr(edi, &lt;span&gt;0x3c&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 196&lt;/span&gt;     a.mov(ebx, dword_ptr(edi, eax, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x78&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NT头+0x78 = 导入表RVA
&lt;/span&gt;&lt;span&gt; 197&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面等价于[edi + eax + 0x78]，如果没有0的话，他会把第三个参数当成2的N次方变成了edi + eax * 2的0x78次方&lt;/span&gt;
&lt;span&gt; 198&lt;/span&gt;     a.add(ebx, edi);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebx=导入表&lt;/span&gt;
&lt;span&gt; 199&lt;/span&gt;     a.mov(ecx, dword_ptr(ebx, &lt;span&gt;0x18&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ecx=按名称导出个数&lt;/span&gt;
&lt;span&gt; 200&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x20&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=导出函数名称表rva&lt;/span&gt;
&lt;span&gt; 201&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 202&lt;/span&gt; 
&lt;span&gt; 203&lt;/span&gt; &lt;span&gt;    a.bind(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 204&lt;/span&gt;     a.sub(ecx, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从后面往前遍历 能少占用一个寄存器，但要记得先-1再遍历&lt;/span&gt;
&lt;span&gt; 205&lt;/span&gt;     a.jz(FindFuncAddrOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减到0即遍历完&lt;/span&gt;
&lt;span&gt; 206&lt;/span&gt;     a.mov(ebp, dword_ptr(esi, ecx, &lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到函数名称比拗最后一个函数名的RVA 等价于[esi,ecx*(2的n次方)]&lt;/span&gt;
&lt;span&gt; 207&lt;/span&gt; &lt;span&gt;    a.add(ebp, edi);
&lt;/span&gt;&lt;span&gt; 208&lt;/span&gt;     a.cmp(dword_ptr(ebp), &lt;span&gt;0x50746547&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 209&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 210&lt;/span&gt;     a.cmp(dword_ptr(ebp, &lt;span&gt;4&lt;/span&gt;), &lt;span&gt;0x41636f72&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 211&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 212&lt;/span&gt;     a.cmp(dword_ptr(ebp, &lt;span&gt;8&lt;/span&gt;), &lt;span&gt;0x65726464&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 213&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 214&lt;/span&gt;     a.cmp(word_ptr(ebp, &lt;span&gt;12&lt;/span&gt;), &lt;span&gt;0x7373&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 215&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 216&lt;/span&gt;     a.cmp(byte_ptr(ebp, &lt;span&gt;14&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束符  防止类似LoadLibrary和LoadLibraryA扩展函数名偏差出现&lt;/span&gt;
&lt;span&gt; 217&lt;/span&gt; &lt;span&gt;    a.jne(FindFuncAddr);
&lt;/span&gt;&lt;span&gt; 218&lt;/span&gt; 
&lt;span&gt; 219&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时ecx为遍历的下标 &lt;/span&gt;
&lt;span&gt; 220&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x24&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=导出函数序号表RVA(上面名称对比完 回收esi)&lt;/span&gt;
&lt;span&gt; 221&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 222&lt;/span&gt;     a.movzx(ebp, word_ptr(esi, ecx, &lt;span&gt;1&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebp=函数序号 ebp=[esi+ecx*2一次方]
&lt;/span&gt;&lt;span&gt; 223&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EBP:Get=2b0 Load=3c2&lt;/span&gt;
&lt;span&gt; 224&lt;/span&gt;     a.mov(esi, dword_ptr(ebx, &lt;span&gt;0x1c&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi=函数地址表RVA&lt;/span&gt;
&lt;span&gt; 225&lt;/span&gt; &lt;span&gt;    a.add(esi, edi);
&lt;/span&gt;&lt;span&gt; 226&lt;/span&gt;     a.mov(eax, dword_ptr(esi, ebp, &lt;span&gt;2&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址=地址表+序号*2的2次方&lt;/span&gt;
&lt;span&gt; 227&lt;/span&gt; &lt;span&gt;    a.add(eax, edi);
&lt;/span&gt;&lt;span&gt; 228&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时eax为loadlibraryA地址&lt;/span&gt;
&lt;span&gt; 229&lt;/span&gt; &lt;span&gt;    a.bind(FindFuncAddrOver);
&lt;/span&gt;&lt;span&gt; 230&lt;/span&gt; &lt;span&gt;    a.pop(ebp);
&lt;/span&gt;&lt;span&gt; 231&lt;/span&gt; &lt;span&gt;    a.pop(esi);
&lt;/span&gt;&lt;span&gt; 232&lt;/span&gt; &lt;span&gt;    a.pop(ecx);
&lt;/span&gt;&lt;span&gt; 233&lt;/span&gt; &lt;span&gt;    a.pop(ebx);
&lt;/span&gt;&lt;span&gt; 234&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 235&lt;/span&gt; DWORD RVAtoFA(DWORD dwRVA)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;RVA转文件地址&lt;/span&gt;
&lt;span&gt; 236&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 237&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; PIMAGE_DOS_HEADER(g_pFileSrc);
&lt;/span&gt;&lt;span&gt; 238&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = PIMAGE_NT_HEADERS((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 239&lt;/span&gt;     PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)(pNtHead-&amp;gt;FileHeader.SizeOfOptionalHeader + (DWORD)&amp;amp;pNtHead-&amp;gt;&lt;span&gt;OptionalHeader);
&lt;/span&gt;&lt;span&gt; 240&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; iSectionNum = pNtHead-&amp;gt;&lt;span&gt;FileHeader.NumberOfSections;
&lt;/span&gt;&lt;span&gt; 241&lt;/span&gt; 
&lt;span&gt; 242&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; iSectionNum; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 243&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 244&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (dwRVA &amp;gt;= pSection-&amp;gt;VirtualAddress &amp;amp;&amp;amp; dwRVA &amp;lt; (pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize))
&lt;/span&gt;&lt;span&gt; 245&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 246&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (DWORD)g_pFileSrc + dwRVA - pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;PointerToRawData;
&lt;/span&gt;&lt;span&gt; 247&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 248&lt;/span&gt;         pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 249&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 250&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换失败&lt;/span&gt;
&lt;span&gt; 251&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 252&lt;/span&gt; 
&lt;span&gt; 253&lt;/span&gt; DWORD FAtoRVA(DWORD dwFA)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件地址转RVA&lt;/span&gt;
&lt;span&gt; 254&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 255&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; PIMAGE_DOS_HEADER(g_pFileSrc);
&lt;/span&gt;&lt;span&gt; 256&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = PIMAGE_NT_HEADERS((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 257&lt;/span&gt;     PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)(pNtHead-&amp;gt;FileHeader.SizeOfOptionalHeader + (DWORD)&amp;amp;pNtHead-&amp;gt;&lt;span&gt;OptionalHeader);
&lt;/span&gt;&lt;span&gt; 258&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; iSectionNum = pNtHead-&amp;gt;&lt;span&gt;FileHeader.NumberOfSections;
&lt;/span&gt;&lt;span&gt; 259&lt;/span&gt; 
&lt;span&gt; 260&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; iSectionNum; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 261&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 262&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (dwFA &amp;gt;= pSection-&amp;gt;PointerToRawData &amp;amp;&amp;amp; dwFA &amp;lt; (pSection-&amp;gt;PointerToRawData + pSection-&amp;gt;&lt;span&gt;SizeOfRawData))
&lt;/span&gt;&lt;span&gt; 263&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 264&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (DWORD)dwFA - pSection-&amp;gt;PointerToRawData + pSection-&amp;gt;&lt;span&gt;VirtualAddress;
&lt;/span&gt;&lt;span&gt; 265&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 266&lt;/span&gt;         pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 267&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 268&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换失败&lt;/span&gt;
&lt;span&gt; 269&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 270&lt;/span&gt; 
&lt;span&gt; 271&lt;/span&gt; 
&lt;span&gt; 272&lt;/span&gt; BOOL LoadFile(&lt;span&gt;char&lt;/span&gt; *pFileName)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件内容&lt;/span&gt;
&lt;span&gt; 273&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 274&lt;/span&gt;     HANDLE hFile =&lt;span&gt; CreateFileA(pFileName,
&lt;/span&gt;&lt;span&gt; 275&lt;/span&gt; &lt;span&gt;        GENERIC_READ,
&lt;/span&gt;&lt;span&gt; 276&lt;/span&gt; &lt;span&gt;        FILE_SHARE_READ,
&lt;/span&gt;&lt;span&gt; 277&lt;/span&gt; &lt;span&gt;        NULL,
&lt;/span&gt;&lt;span&gt; 278&lt;/span&gt; &lt;span&gt;        OPEN_EXISTING,
&lt;/span&gt;&lt;span&gt; 279&lt;/span&gt; &lt;span&gt;        FILE_ATTRIBUTE_NORMAL,
&lt;/span&gt;&lt;span&gt; 280&lt;/span&gt;         &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 281&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hFile)
&lt;/span&gt;&lt;span&gt; 282&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 283&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 284&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 285&lt;/span&gt;     g_iFileSize =&lt;span&gt; GetFileSize(hFile, NULL);
&lt;/span&gt;&lt;span&gt; 286&lt;/span&gt; 
&lt;span&gt; 287&lt;/span&gt;     g_pFileSrc = (UCHAR*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(g_iFileSize);
&lt;/span&gt;&lt;span&gt; 288&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;g_pFileSrc)
&lt;/span&gt;&lt;span&gt; 289&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 290&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;申请内存失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 291&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 292&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 293&lt;/span&gt; 
&lt;span&gt; 294&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ReadFile(hFile, g_pFileSrc, g_iFileSize, NULL, NULL))
&lt;/span&gt;&lt;span&gt; 295&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 296&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;读取文件失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt; 297&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 298&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 299&lt;/span&gt; 
&lt;span&gt; 300&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 301&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 302&lt;/span&gt; 
&lt;span&gt; 303&lt;/span&gt; 
&lt;span&gt; 304&lt;/span&gt; BOOL CheckPE()        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查PE文件格式&lt;/span&gt;
&lt;span&gt; 305&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 306&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; PIMAGE_DOS_HEADER(g_pFileSrc);
&lt;/span&gt;&lt;span&gt; 307&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = PIMAGE_NT_HEADERS((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 308&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pDosHead-&amp;gt;e_magic != &lt;span&gt;0x5a4d&lt;/span&gt; || pNtHead-&amp;gt;Signature != &lt;span&gt;0x4550&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 309&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 310&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 311&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 312&lt;/span&gt;     g_iImageBase = pNtHead-&amp;gt;&lt;span&gt;OptionalHeader.ImageBase;
&lt;/span&gt;&lt;span&gt; 313&lt;/span&gt;     g_iFileAlignment = pNtHead-&amp;gt;&lt;span&gt;OptionalHeader.FileAlignment;
&lt;/span&gt;&lt;span&gt; 314&lt;/span&gt;     g_iSectionAlignment = pNtHead-&amp;gt;&lt;span&gt;OptionalHeader.SectionAlignment;
&lt;/span&gt;&lt;span&gt; 315&lt;/span&gt;     g_iOldOEP = pNtHead-&amp;gt;&lt;span&gt;OptionalHeader.AddressOfEntryPoint;
&lt;/span&gt;&lt;span&gt; 316&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 317&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 318&lt;/span&gt; 
&lt;span&gt; 319&lt;/span&gt; 
&lt;span&gt; 320&lt;/span&gt; 
&lt;span&gt; 321&lt;/span&gt; BOOL FindCodeAddr()         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到调用了IAT中的地址的代码位置&lt;/span&gt;
&lt;span&gt; 322&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 323&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 324&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 325&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].VirtualAddress)
&lt;/span&gt;&lt;span&gt; 326&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 327&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 328&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 329&lt;/span&gt; 
&lt;span&gt; 330&lt;/span&gt;     PIMAGE_IMPORT_DESCRIPTOR pImpotrList = (PIMAGE_IMPORT_DESCRIPTOR)RVAtoFA(pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;1&lt;/span&gt;].VirtualAddress);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IAT&lt;/span&gt;
&lt;span&gt; 331&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (pImpotrList-&amp;gt;FirstThunk)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得该程序的IAT地址&lt;/span&gt;
&lt;span&gt; 332&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 333&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 334&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 335&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 336&lt;/span&gt;             DWORD iIatAddr = *(DWORD*)RVAtoFA(pImpotrList-&amp;gt;FirstThunk + i * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(DWORD));
&lt;/span&gt;&lt;span&gt; 337&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;iIatAddr)
&lt;/span&gt;&lt;span&gt; 338&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 339&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 340&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 341&lt;/span&gt;             DWORD dwIatAddr = pImpotrList-&amp;gt;FirstThunk + i * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(DWORD);
&lt;/span&gt;&lt;span&gt; 342&lt;/span&gt; &lt;span&gt;            g_IATaddrList.push_back(dwIatAddr);
&lt;/span&gt;&lt;span&gt; 343&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 344&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 345&lt;/span&gt;         pImpotrList++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 346&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 347&lt;/span&gt; 
&lt;span&gt; 348&lt;/span&gt; 
&lt;span&gt; 349&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取调用这些IAT地址的代码地址&lt;/span&gt;
&lt;span&gt; 350&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g_iFileSize - &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 351&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 352&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mov eax&lt;/span&gt;
&lt;span&gt; 353&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i] == &lt;span&gt;0xA1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 354&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 355&lt;/span&gt;             DWORD IatAddr = *(DWORD*)(g_pFileSrc + i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 356&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; iNum = &lt;span&gt;0&lt;/span&gt;; iNum &amp;lt; g_IATaddrList.size(); iNum++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 357&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 358&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (g_IATaddrList[iNum] == (IatAddr^&lt;span&gt;g_iImageBase))
&lt;/span&gt;&lt;span&gt; 359&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 360&lt;/span&gt; &lt;span&gt;                    IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 361&lt;/span&gt;                     IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 362&lt;/span&gt;                     IatInfo.bType = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 363&lt;/span&gt;                     IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 364&lt;/span&gt;                     IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 365&lt;/span&gt; &lt;span&gt;                    g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 366&lt;/span&gt;                     i += &lt;span&gt;4&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环会加1，操作符+地址共5字节&lt;/span&gt;
&lt;span&gt; 367&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 368&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 369&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 370&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 371&lt;/span&gt; 
&lt;span&gt; 372&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mov edx、esp、esi、ecx、ebx、ebp、edi&lt;/span&gt;
&lt;span&gt; 373&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i] == &lt;span&gt;0x8B&lt;/span&gt; &amp;amp;&amp;amp; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x15&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x25&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x35&lt;/span&gt; ||
&lt;span&gt; 374&lt;/span&gt;             g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x0D&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x1D&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x2D&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x3D&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 375&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 376&lt;/span&gt;             DWORD IatAddr = *(DWORD*)(g_pFileSrc + i + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 377&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; iNum = &lt;span&gt;0&lt;/span&gt;; iNum &amp;lt; g_IATaddrList.size(); iNum++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 378&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 379&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (g_IATaddrList[iNum] == (IatAddr^&lt;span&gt;g_iImageBase))
&lt;/span&gt;&lt;span&gt; 380&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 381&lt;/span&gt;                     DWORD ddddd =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 382&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x15&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;edx&lt;/span&gt;
&lt;span&gt; 383&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 384&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 385&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 386&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 387&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 388&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 389&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 390&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 391&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x25&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;esp&lt;/span&gt;
&lt;span&gt; 392&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 393&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 394&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 395&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 396&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 397&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 398&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 399&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 400&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x35&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi&lt;/span&gt;
&lt;span&gt; 401&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 402&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 403&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 404&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 405&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 406&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 407&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 408&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 409&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x0D&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ecx&lt;/span&gt;
&lt;span&gt; 410&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 411&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 412&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 413&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 414&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 415&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 416&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 417&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 418&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x1D&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebx&lt;/span&gt;
&lt;span&gt; 419&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 420&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 421&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 422&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 423&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 424&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 425&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 426&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 427&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x2D&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebp&lt;/span&gt;
&lt;span&gt; 428&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 429&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 430&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 431&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 432&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 433&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 434&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 435&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 436&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x3D&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;edi&lt;/span&gt;
&lt;span&gt; 437&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 438&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 439&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 440&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 441&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 442&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 443&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 444&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 445&lt;/span&gt;                     i += &lt;span&gt;5&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环会加1，操作符+地址共6字节&lt;/span&gt;
&lt;span&gt; 446&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 447&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 448&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 449&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 450&lt;/span&gt; 
&lt;span&gt; 451&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;call jmp push&lt;/span&gt;
&lt;span&gt; 452&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i] == &lt;span&gt;0xFF&lt;/span&gt; &amp;amp;&amp;amp; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x15&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x25&lt;/span&gt; || g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x35&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 453&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 454&lt;/span&gt;             DWORD IatAddr = *(DWORD*)(g_pFileSrc + i + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 455&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; iNum = &lt;span&gt;0&lt;/span&gt;; iNum &amp;lt; g_IATaddrList.size(); iNum++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 456&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 457&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (g_IATaddrList[iNum] == (IatAddr^&lt;span&gt;g_iImageBase))
&lt;/span&gt;&lt;span&gt; 458&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 459&lt;/span&gt;                     DWORD ddddd =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 460&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x15&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;
&lt;span&gt; 461&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 462&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 463&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 464&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 465&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 466&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 467&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 468&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 469&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x25&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jmp&lt;/span&gt;
&lt;span&gt; 470&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 471&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 472&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 473&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 474&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 475&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 476&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 477&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 478&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_pFileSrc[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0x35&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;
&lt;span&gt; 479&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 480&lt;/span&gt; &lt;span&gt;                        IatAddrTab IatInfo;
&lt;/span&gt;&lt;span&gt; 481&lt;/span&gt;                         IatInfo.dwCallAddr =&lt;span&gt; FAtoRVA(i);
&lt;/span&gt;&lt;span&gt; 482&lt;/span&gt;                         IatInfo.bType = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 483&lt;/span&gt;                         IatInfo.wIndex =&lt;span&gt; iNum;
&lt;/span&gt;&lt;span&gt; 484&lt;/span&gt;                         IatInfo.dwOldIatAddr =&lt;span&gt; g_IATaddrList[iNum];
&lt;/span&gt;&lt;span&gt; 485&lt;/span&gt; &lt;span&gt;                        g_tagIAT.push_back(IatInfo);
&lt;/span&gt;&lt;span&gt; 486&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 487&lt;/span&gt;                     i += &lt;span&gt;5&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环会加1，操作符+地址共6字节&lt;/span&gt;
&lt;span&gt; 488&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 489&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 490&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 491&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 492&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 493&lt;/span&gt; 
&lt;span&gt; 494&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 495&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 496&lt;/span&gt; 
&lt;span&gt; 497&lt;/span&gt; 
&lt;span&gt; 498&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SaveDll() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存DLL相关数据&lt;/span&gt;
&lt;span&gt; 499&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 500&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 501&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 502&lt;/span&gt;     DWORD dwImportRVA = pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].VirtualAddress;
&lt;/span&gt;&lt;span&gt; 503&lt;/span&gt;     PIMAGE_IMPORT_DESCRIPTOR pImport =&lt;span&gt; (PIMAGE_IMPORT_DESCRIPTOR)RVAtoFA(dwImportRVA);
&lt;/span&gt;&lt;span&gt; 504&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (pImport-&amp;gt;&lt;span&gt;FirstThunk)
&lt;/span&gt;&lt;span&gt; 505&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 506&lt;/span&gt;         DLLFuncTag tagDllList;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Dll信息结构&lt;/span&gt;
&lt;span&gt; 507&lt;/span&gt; 
&lt;span&gt; 508&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *szDllName = (&lt;span&gt;char&lt;/span&gt;*)RVAtoFA(pImport-&amp;gt;&lt;span&gt;Name);
&lt;/span&gt;&lt;span&gt; 509&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iDllNameLen = strlen(szDllName) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 510&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *szNewDllName = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(iDllNameLen);
&lt;/span&gt;&lt;span&gt; 511&lt;/span&gt; &lt;span&gt;        memcpy(szNewDllName, szDllName, iDllNameLen);
&lt;/span&gt;&lt;span&gt; 512&lt;/span&gt; 
&lt;span&gt; 513&lt;/span&gt;         tagDllList.szDllName =&lt;span&gt; szNewDllName;
&lt;/span&gt;&lt;span&gt; 514&lt;/span&gt;         tagDllList.bDllNameLenth =&lt;span&gt; iDllNameLen;
&lt;/span&gt;&lt;span&gt; 515&lt;/span&gt; 
&lt;span&gt; 516&lt;/span&gt;         PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)RVAtoFA(pImport-&amp;gt;&lt;span&gt;FirstThunk);
&lt;/span&gt;&lt;span&gt; 517&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (pIAT-&amp;gt;&lt;span&gt;u1.Function)
&lt;/span&gt;&lt;span&gt; 518&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 519&lt;/span&gt;             FuncTag tagFuncInfo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数信息结构&lt;/span&gt;
&lt;span&gt; 520&lt;/span&gt;             DWORD dwFuncAddr = pIAT-&amp;gt;&lt;span&gt;u1.Function;
&lt;/span&gt;&lt;span&gt; 521&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (dwFuncAddr &amp;amp; &lt;span&gt;0x80000000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 522&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 523&lt;/span&gt;                 tagDllList.bTab = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按序号导入&lt;/span&gt;
&lt;span&gt; 524&lt;/span&gt;                 tagFuncInfo.iFuncNameLenth = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 525&lt;/span&gt;                 tagFuncInfo.szFuncName = (&lt;span&gt;char&lt;/span&gt;*)(dwFuncAddr ^ &lt;span&gt;0x80000000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 526&lt;/span&gt; &lt;span&gt;                tagDllList.vFuncNAMEorNo.push_back(tagFuncInfo);
&lt;/span&gt;&lt;span&gt; 527&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 528&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 529&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 530&lt;/span&gt;                 tagDllList.bTab = &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按名称导入&lt;/span&gt;
&lt;span&gt; 531&lt;/span&gt;                 PIMAGE_IMPORT_BY_NAME pFunc = (PIMAGE_IMPORT_BY_NAME)RVAtoFA(pIAT-&amp;gt;&lt;span&gt;u1.Function);
&lt;/span&gt;&lt;span&gt; 532&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; iFuncNameLen = strlen(pFunc-&amp;gt;Name) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 533&lt;/span&gt;                 &lt;span&gt;char&lt;/span&gt; *szFuncName = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(iFuncNameLen);
&lt;/span&gt;&lt;span&gt; 534&lt;/span&gt;                 memcpy(szFuncName, pFunc-&amp;gt;&lt;span&gt;Name, iFuncNameLen);
&lt;/span&gt;&lt;span&gt; 535&lt;/span&gt;                 tagFuncInfo.iFuncNameLenth =&lt;span&gt; iFuncNameLen;
&lt;/span&gt;&lt;span&gt; 536&lt;/span&gt;                 tagFuncInfo.szFuncName =&lt;span&gt; szFuncName;
&lt;/span&gt;&lt;span&gt; 537&lt;/span&gt; &lt;span&gt;                tagDllList.vFuncNAMEorNo.push_back(tagFuncInfo);
&lt;/span&gt;&lt;span&gt; 538&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 539&lt;/span&gt;             pIAT++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 540&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 541&lt;/span&gt;         tagDllList.wFuncNum =&lt;span&gt; tagDllList.vFuncNAMEorNo.size();
&lt;/span&gt;&lt;span&gt; 542&lt;/span&gt; &lt;span&gt;        g_tagDllFunc.push_back(tagDllList);
&lt;/span&gt;&lt;span&gt; 543&lt;/span&gt;         pImport++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 544&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 545&lt;/span&gt; 
&lt;span&gt; 546&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IAT表信息隐藏(每个DLL只有一个导入函数)&lt;/span&gt;
&lt;span&gt; 547&lt;/span&gt;     PIMAGE_IMPORT_DESCRIPTOR pImpotrList = (PIMAGE_IMPORT_DESCRIPTOR)RVAtoFA(pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].VirtualAddress);
&lt;/span&gt;&lt;span&gt; 548&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (pImpotrList-&amp;gt;&lt;span&gt;FirstThunk)
&lt;/span&gt;&lt;span&gt; 549&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 550&lt;/span&gt;         PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)RVAtoFA(pImpotrList-&amp;gt;&lt;span&gt;FirstThunk);
&lt;/span&gt;&lt;span&gt; 551&lt;/span&gt;         PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)RVAtoFA(pImpotrList-&amp;gt;&lt;span&gt;OriginalFirstThunk);
&lt;/span&gt;&lt;span&gt; 552&lt;/span&gt;         pIAT++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保留第一个&lt;/span&gt;
&lt;span&gt; 553&lt;/span&gt;         pINT++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 554&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (pIAT-&amp;gt;u1.Function)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IAT清空&lt;/span&gt;
&lt;span&gt; 555&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 556&lt;/span&gt;             pIAT-&amp;gt;u1.Function = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 557&lt;/span&gt;             pIAT++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 558&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 559&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (pINT-&amp;gt;u1.Function)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将INT清空&lt;/span&gt;
&lt;span&gt; 560&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 561&lt;/span&gt;             pINT-&amp;gt;u1.Function = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 562&lt;/span&gt;             pINT++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 563&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 564&lt;/span&gt;         pImpotrList++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 565&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 566&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 567&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 568&lt;/span&gt; 
&lt;span&gt; 569&lt;/span&gt; 
&lt;span&gt; 570&lt;/span&gt; 
&lt;span&gt; 571&lt;/span&gt; 
&lt;span&gt; 572&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; NewIat()
&lt;/span&gt;&lt;span&gt; 573&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 574&lt;/span&gt;     PIMAGE_DOS_HEADER pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 575&lt;/span&gt;     PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 576&lt;/span&gt;     PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt; 577&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; pNtHead-&amp;gt;FileHeader.NumberOfSections; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 578&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 579&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将每个节都改为可写属性，以便在后续修改。
&lt;/span&gt;&lt;span&gt; 580&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本来只修改.text节的属性即可，但由于该节的位置不在data数组里面记录，单凭节名判断未必准确，所以将所以节都改为可写-&lt;/span&gt;
&lt;span&gt; 581&lt;/span&gt;         pSection-&amp;gt;Characteristics += &lt;span&gt;0x80000000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 582&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 583&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!(pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;5&lt;/span&gt;].VirtualAddress))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当当前程序没有重定位表&lt;/span&gt;
&lt;span&gt; 584&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 585&lt;/span&gt;         PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt; 586&lt;/span&gt;         pSection += pNtHead-&amp;gt;FileHeader.NumberOfSections - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 587&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewSectionFileAddr = pSection-&amp;gt;PointerToRawData + pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt; 588&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewSectionFileMapAddr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 589&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt; 590&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 591&lt;/span&gt;             iNewSectionFileMapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt; 592&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 593&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 594&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 595&lt;/span&gt;             iNewSectionFileMapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize
&lt;/span&gt;&lt;span&gt; 596&lt;/span&gt;                 + g_iSectionAlignment - (pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt; 597&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 598&lt;/span&gt; 
&lt;span&gt; 599&lt;/span&gt;         pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 600&lt;/span&gt;         memcpy(pSection-&amp;gt;Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.KD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 601&lt;/span&gt;         pSection-&amp;gt;VirtualAddress =&lt;span&gt; iNewSectionFileMapAddr;
&lt;/span&gt;&lt;span&gt; 602&lt;/span&gt;         pSection-&amp;gt;PointerToRawData =&lt;span&gt; iNewSectionFileAddr;
&lt;/span&gt;&lt;span&gt; 603&lt;/span&gt;         pSection-&amp;gt;Characteristics = (&lt;span&gt;0x20000000&lt;/span&gt; | &lt;span&gt;0x40000000&lt;/span&gt; | &lt;span&gt;0x80000000&lt;/span&gt; | &lt;span&gt;0x40&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节属性 可读可写可执行已被初始化&lt;/span&gt;
&lt;span&gt; 604&lt;/span&gt;         pNtHead-&amp;gt;FileHeader.NumberOfSections += &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节表数量+1
&lt;/span&gt;&lt;span&gt; 605&lt;/span&gt; 
&lt;span&gt; 606&lt;/span&gt; 
&lt;span&gt; 607&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IAT的数据压入新节中数据排列分别为DLL数量(2字节)、DLL名字长度、该&lt;/span&gt;
&lt;span&gt; 608&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iAddIatLenth = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经增加的iat数据长度
&lt;/span&gt;&lt;span&gt; 609&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先添加2字节数据说明该程序的DLL数量&lt;/span&gt;
&lt;span&gt; 610&lt;/span&gt;         g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 611&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt; bDllNum =&lt;span&gt; g_tagDllFunc.size();
&lt;/span&gt;&lt;span&gt; 612&lt;/span&gt;         memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, &amp;amp;bDllNum, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 613&lt;/span&gt;         iAddIatLenth += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 614&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; bDllNum; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 615&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 616&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加DLL名长度&lt;/span&gt;
&lt;span&gt; 617&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; bDllNameLenth =&lt;span&gt; g_tagDllFunc[i].bDllNameLenth;
&lt;/span&gt;&lt;span&gt; 618&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 619&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, &amp;amp;bDllNameLenth, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 620&lt;/span&gt;             iAddIatLenth += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 621&lt;/span&gt; 
&lt;span&gt; 622&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加DLL名&lt;/span&gt;
&lt;span&gt; 623&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth +&lt;span&gt; bDllNameLenth);
&lt;/span&gt;&lt;span&gt; 624&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize +&lt;span&gt; iAddIatLenth, g_tagDllFunc[i].szDllName, bDllNameLenth);
&lt;/span&gt;&lt;span&gt; 625&lt;/span&gt;             iAddIatLenth +=&lt;span&gt; bDllNameLenth;
&lt;/span&gt;&lt;span&gt; 626&lt;/span&gt; 
&lt;span&gt; 627&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加该DLL中的导入函数数量  方便后续遍历&lt;/span&gt;
&lt;span&gt; 628&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 629&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (DWORD*)&amp;amp;g_tagDllFunc[i].wFuncNum, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 630&lt;/span&gt;             iAddIatLenth += &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 631&lt;/span&gt; 
&lt;span&gt; 632&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加该DLL的导入方式 0为序号1为名称&lt;/span&gt;
&lt;span&gt; 633&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 634&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (&lt;span&gt;byte&lt;/span&gt;*)&amp;amp;g_tagDllFunc[i].bTab, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 635&lt;/span&gt;             iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 636&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; g_tagDllFunc[i].wFuncNum; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 637&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 638&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加函数名或序号&lt;/span&gt;
&lt;span&gt; 639&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!(g_tagDllFunc[i].bTab)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;序号&lt;/span&gt;
&lt;span&gt; 640&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 641&lt;/span&gt;                     g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;6&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2长度4序号&lt;/span&gt;
&lt;span&gt; 642&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (WORD*)&amp;amp;g_tagDllFunc[i].vFuncNAMEorNo[j].iFuncNameLenth, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 643&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 644&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (DWORD*)&amp;amp;g_tagDllFunc[i].vFuncNAMEorNo[j].szFuncName, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 645&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 646&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 647&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字&lt;/span&gt;
&lt;span&gt; 648&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 649&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; iFuncNameLenth = g_tagDllFunc[i].vFuncNAMEorNo[j].iFuncNameLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度&lt;/span&gt;
&lt;span&gt; 650&lt;/span&gt;                     g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;2&lt;/span&gt; + iFuncNameLenth);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前2字节存放长度 后面为函数名称&lt;/span&gt;
&lt;span&gt; 651&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (WORD*)&amp;amp;iFuncNameLenth, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 652&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 653&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize +&lt;span&gt; iAddIatLenth, g_tagDllFunc[i].vFuncNAMEorNo[j].szFuncName, iFuncNameLenth);
&lt;/span&gt;&lt;span&gt; 654&lt;/span&gt;                     iAddIatLenth +=&lt;span&gt; iFuncNameLenth;
&lt;/span&gt;&lt;span&gt; 655&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 656&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 657&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 658&lt;/span&gt; 
&lt;span&gt; 659&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取新的OEP并修改旧的OEP&lt;/span&gt;
&lt;span&gt; 660&lt;/span&gt;         g_iNewOEP = iNewSectionFileMapAddr + iAddIatLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新节的&lt;/span&gt;
&lt;span&gt; 661&lt;/span&gt;         pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 662&lt;/span&gt;         pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 663&lt;/span&gt;         pNtHead-&amp;gt;OptionalHeader.AddressOfEntryPoint =&lt;span&gt; g_iNewOEP;
&lt;/span&gt;&lt;span&gt; 664&lt;/span&gt; 
&lt;span&gt; 665&lt;/span&gt; &lt;span&gt;        JitRuntime        _x86RunTimeObject;
&lt;/span&gt;&lt;span&gt; 666&lt;/span&gt;         X86Assembler    a(&amp;amp;&lt;span&gt;_x86RunTimeObject);
&lt;/span&gt;&lt;span&gt; 667&lt;/span&gt; 
&lt;span&gt; 668&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当程序没有重定位表时，根据call 0000 0000来获得进程基址，有重定位表时则根据重定位表&lt;/span&gt;
&lt;span&gt; 669&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; szGetOEP[] = { &lt;span&gt;0xE8&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt; }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同理jit.call(0x00000000);&lt;/span&gt;
&lt;span&gt; 670&lt;/span&gt; &lt;span&gt;        a.pop(eax);
&lt;/span&gt;&lt;span&gt; 671&lt;/span&gt;         a.sub(eax, &lt;span&gt;5&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时得到oep所在的地址 oep距离基址隔着&lt;/span&gt;
&lt;span&gt; 672&lt;/span&gt;         a.sub(eax, g_iNewOEP);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OEP所在的基址-偏移  得到基址&lt;/span&gt;
&lt;span&gt; 673&lt;/span&gt;         a.mov(ebp, eax);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存进程基址到ebp&lt;/span&gt;
&lt;span&gt; 674&lt;/span&gt; &lt;span&gt;        a.add(eax, g_iOldOEP);
&lt;/span&gt;&lt;span&gt; 675&lt;/span&gt; &lt;span&gt;        a.jmp(eax);
&lt;/span&gt;&lt;span&gt; 676&lt;/span&gt; 
&lt;span&gt; 677&lt;/span&gt;         PVOID szJit =&lt;span&gt; a.make();
&lt;/span&gt;&lt;span&gt; 678&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iJitLenth = a.getCodeSize() + &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包括e8 0000 0000；&lt;/span&gt;
&lt;span&gt; 679&lt;/span&gt; 
&lt;span&gt; 680&lt;/span&gt;         g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth +&lt;span&gt; iJitLenth);
&lt;/span&gt;&lt;span&gt; 681&lt;/span&gt;         memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, szGetOEP, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 682&lt;/span&gt;         memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;, szJit, iJitLenth);
&lt;/span&gt;&lt;span&gt; 683&lt;/span&gt; 
&lt;span&gt; 684&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iAddSrcLen = iAddIatLenth + iJitLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一共增加的代码
&lt;/span&gt;&lt;span&gt; 685&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完善节长度等数据  保守起见重新获取节表信息&lt;/span&gt;
&lt;span&gt; 686&lt;/span&gt;         pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 687&lt;/span&gt;         pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 688&lt;/span&gt;         pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt; 689&lt;/span&gt;         pSection += pNtHead-&amp;gt;FileHeader.NumberOfSections - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 690&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(iAddSrcLen%&lt;span&gt;g_iFileAlignment))
&lt;/span&gt;&lt;span&gt; 691&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 692&lt;/span&gt;             pSection-&amp;gt;SizeOfRawData =&lt;span&gt; iAddSrcLen;
&lt;/span&gt;&lt;span&gt; 693&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 694&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 695&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 696&lt;/span&gt;             pSection-&amp;gt;SizeOfRawData = iAddSrcLen + g_iFileAlignment - (iAddSrcLen%&lt;span&gt;g_iFileAlignment);
&lt;/span&gt;&lt;span&gt; 697&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 698&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(iAddSrcLen%&lt;span&gt;g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt; 699&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 700&lt;/span&gt;             pSection-&amp;gt;Misc.VirtualSize =&lt;span&gt; iAddSrcLen;
&lt;/span&gt;&lt;span&gt; 701&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 702&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 703&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 704&lt;/span&gt;             pSection-&amp;gt;Misc.VirtualSize = iAddSrcLen + g_iSectionAlignment - (iAddSrcLen%&lt;span&gt;g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt; 705&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 706&lt;/span&gt;         pNtHead-&amp;gt;OptionalHeader.SizeOfImage += pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt; 707&lt;/span&gt; 
&lt;span&gt; 708&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (iAddSrcLen != pSection-&amp;gt;SizeOfRawData)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当新增长度与对齐后的节长度不相等时，将其补全&lt;/span&gt;
&lt;span&gt; 709&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 710&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iLenth = pSection-&amp;gt;SizeOfRawData;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先保存，以免扩容后原地址被回收
&lt;/span&gt;&lt;span&gt; 711&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;g_pFileSrc = (UCHAR*)realloc(g_pFileSrc, g_iFileSize + iLenth);&lt;/span&gt;
&lt;span&gt; 712&lt;/span&gt;             UCHAR *uuu = (UCHAR*)&lt;span&gt;malloc&lt;/span&gt;(g_iFileSize +&lt;span&gt; iAddSrcLen);
&lt;/span&gt;&lt;span&gt; 713&lt;/span&gt;             memcpy(uuu, g_pFileSrc, g_iFileSize +&lt;span&gt; iAddSrcLen);
&lt;/span&gt;&lt;span&gt; 714&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;malloc&lt;/span&gt;(g_iFileSize +&lt;span&gt; iLenth);
&lt;/span&gt;&lt;span&gt; 715&lt;/span&gt;             memcpy(g_pFileSrc, uuu, g_iFileSize +&lt;span&gt; iAddSrcLen);
&lt;/span&gt;&lt;span&gt; 716&lt;/span&gt;             memset(g_pFileSrc + g_iFileSize + iAddSrcLen, &lt;span&gt;0&lt;/span&gt;, iLenth -&lt;span&gt; iAddSrcLen);
&lt;/span&gt;&lt;span&gt; 717&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 718&lt;/span&gt;         g_iFileSize += pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt; 719&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 720&lt;/span&gt; 
&lt;span&gt; 721&lt;/span&gt; 
&lt;span&gt; 722&lt;/span&gt; 
&lt;span&gt; 723&lt;/span&gt;     &lt;span&gt;///////////////////////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 724&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当有重定位表时，先保存相关数据，删除重定位表，新增节，再在后面还原重定位表&lt;/span&gt;
&lt;span&gt; 725&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 726&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 727&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把重定位表数据移动到新节当中
&lt;/span&gt;&lt;span&gt; 728&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取位置和长度&lt;/span&gt;
&lt;span&gt; 729&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iRelocationAddr = pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;].VirtualAddress;
&lt;/span&gt;&lt;span&gt; 730&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iRelocationLenth = pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;5&lt;/span&gt;].Size;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据长度&lt;/span&gt;
&lt;span&gt; 731&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *szR_Src = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(iRelocationLenth);
&lt;/span&gt;&lt;span&gt; 732&lt;/span&gt;         memcpy(szR_Src, (&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)RVAtoFA(iRelocationAddr), iRelocationLenth);
&lt;/span&gt;&lt;span&gt; 733&lt;/span&gt;         
&lt;span&gt; 734&lt;/span&gt;         PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt; 735&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; szR_Name[&lt;span&gt;8&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 736&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iR_MapLenth = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节中映射长度&lt;/span&gt;
&lt;span&gt; 737&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iR_FileLenth = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节中文件长度&lt;/span&gt;
&lt;span&gt; 738&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 739&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 740&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (pSection-&amp;gt;VirtualAddress == iRelocationAddr) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位到重定位表节表&lt;/span&gt;
&lt;span&gt; 741&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 742&lt;/span&gt;                 strcpy(szR_Name, (&lt;span&gt;char&lt;/span&gt;*)pSection-&amp;gt;&lt;span&gt;Name);
&lt;/span&gt;&lt;span&gt; 743&lt;/span&gt;                 iR_MapLenth = pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt; 744&lt;/span&gt;                 iR_FileLenth = pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt; 745&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 746&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 747&lt;/span&gt;             pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 748&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 749&lt;/span&gt; 
&lt;span&gt; 750&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除重定位表相关信息&lt;/span&gt;
&lt;span&gt; 751&lt;/span&gt;         memset(g_pFileSrc + g_iFileSize - iR_FileLenth, &lt;span&gt;0&lt;/span&gt;, iR_FileLenth);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把重定位表数据用0覆盖&lt;/span&gt;
&lt;span&gt; 752&lt;/span&gt;         memset(pSection, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(IMAGE_SECTION_HEADER));
&lt;/span&gt;&lt;span&gt; 753&lt;/span&gt;         pNtHead-&amp;gt;FileHeader.NumberOfSections--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 754&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整文件内存大小&lt;/span&gt;
&lt;span&gt; 755&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iAlignmentSize = iR_MapLenth %&lt;span&gt; g_iSectionAlignment;
&lt;/span&gt;&lt;span&gt; 756&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;iAlignmentSize)
&lt;/span&gt;&lt;span&gt; 757&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 758&lt;/span&gt;             pNtHead-&amp;gt;OptionalHeader.SizeOfImage -= iR_MapLenth;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整文件内存大小&lt;/span&gt;
&lt;span&gt; 759&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 760&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 761&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 762&lt;/span&gt;             pNtHead-&amp;gt;OptionalHeader.SizeOfImage =
&lt;span&gt; 763&lt;/span&gt;                 pNtHead-&amp;gt;&lt;span&gt;OptionalHeader.SizeOfImage
&lt;/span&gt;&lt;span&gt; 764&lt;/span&gt;                 - (iR_MapLenth - iAlignmentSize +&lt;span&gt; g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt; 765&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 766&lt;/span&gt;         g_iFileSize -=&lt;span&gt; iR_FileLenth;
&lt;/span&gt;&lt;span&gt; 767&lt;/span&gt; 
&lt;span&gt; 768&lt;/span&gt; 
&lt;span&gt; 769&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增节&lt;/span&gt;
&lt;span&gt; 770&lt;/span&gt;         pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt; 771&lt;/span&gt;         pSection += pNtHead-&amp;gt;FileHeader.NumberOfSections - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 772&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewSectionFileAddr = pSection-&amp;gt;PointerToRawData + pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt; 773&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewSectionFileMapAddr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 774&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt; 775&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 776&lt;/span&gt;             iNewSectionFileMapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt; 777&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 778&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 779&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 780&lt;/span&gt;             iNewSectionFileMapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize
&lt;/span&gt;&lt;span&gt; 781&lt;/span&gt;                 + g_iSectionAlignment - (pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt; 782&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 783&lt;/span&gt; 
&lt;span&gt; 784&lt;/span&gt;         pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 785&lt;/span&gt;         memcpy(pSection-&amp;gt;Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.KD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 786&lt;/span&gt;         pSection-&amp;gt;VirtualAddress =&lt;span&gt; iNewSectionFileMapAddr;
&lt;/span&gt;&lt;span&gt; 787&lt;/span&gt;         pSection-&amp;gt;PointerToRawData =&lt;span&gt; iNewSectionFileAddr;
&lt;/span&gt;&lt;span&gt; 788&lt;/span&gt;         pSection-&amp;gt;Characteristics = (&lt;span&gt;0x20000000&lt;/span&gt; | &lt;span&gt;0x40000000&lt;/span&gt; | &lt;span&gt;0x80000000&lt;/span&gt; | &lt;span&gt;0x40&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节属性 可读可写可执行已被初始化&lt;/span&gt;
&lt;span&gt; 789&lt;/span&gt;         pNtHead-&amp;gt;FileHeader.NumberOfSections += &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节表数量+1
&lt;/span&gt;&lt;span&gt; 790&lt;/span&gt; 
&lt;span&gt; 791&lt;/span&gt; 
&lt;span&gt; 792&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IAT的数据压入新节中数据排列分别为DLL数量(2字节)、DLL名字长度、该&lt;/span&gt;
&lt;span&gt; 793&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iAddIatLenth = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经增加的iat数据长度
&lt;/span&gt;&lt;span&gt; 794&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先添加1字节数据说明该程序的DLL数量&lt;/span&gt;
&lt;span&gt; 795&lt;/span&gt;         g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 796&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt; bDllNum =&lt;span&gt; g_tagDllFunc.size();
&lt;/span&gt;&lt;span&gt; 797&lt;/span&gt;         memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, &amp;amp;bDllNum, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 798&lt;/span&gt;         iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 799&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; bDllNum; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 800&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 801&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加DLL名长度&lt;/span&gt;
&lt;span&gt; 802&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt; bDllNameLenth =&lt;span&gt; g_tagDllFunc[i].bDllNameLenth;
&lt;/span&gt;&lt;span&gt; 803&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 804&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, &amp;amp;bDllNameLenth, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 805&lt;/span&gt;             iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 806&lt;/span&gt; 
&lt;span&gt; 807&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加DLL名&lt;/span&gt;
&lt;span&gt; 808&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth +&lt;span&gt; bDllNameLenth);
&lt;/span&gt;&lt;span&gt; 809&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize +&lt;span&gt; iAddIatLenth, g_tagDllFunc[i].szDllName, bDllNameLenth);
&lt;/span&gt;&lt;span&gt; 810&lt;/span&gt;             iAddIatLenth +=&lt;span&gt; bDllNameLenth;
&lt;/span&gt;&lt;span&gt; 811&lt;/span&gt; 
&lt;span&gt; 812&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加该DLL中的导入函数数量  方便后续遍历&lt;/span&gt;
&lt;span&gt; 813&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 814&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (DWORD*)&amp;amp;g_tagDllFunc[i].wFuncNum, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 815&lt;/span&gt;             iAddIatLenth += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 816&lt;/span&gt; 
&lt;span&gt; 817&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加该DLL的导入方式 0为序号1为名称&lt;/span&gt;
&lt;span&gt; 818&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 819&lt;/span&gt;             memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (&lt;span&gt;byte&lt;/span&gt;*)&amp;amp;g_tagDllFunc[i].bTab, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 820&lt;/span&gt;             iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 821&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; g_tagDllFunc[i].wFuncNum; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 822&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 823&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加函数名或序号&lt;/span&gt;
&lt;span&gt; 824&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!(g_tagDllFunc[i].bTab)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;序号&lt;/span&gt;
&lt;span&gt; 825&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 826&lt;/span&gt;                     g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;5&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1长度4序号&lt;/span&gt;
&lt;span&gt; 827&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (BYTE*)&amp;amp;g_tagDllFunc[i].vFuncNAMEorNo[j].iFuncNameLenth, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 828&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 829&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (DWORD*)&amp;amp;g_tagDllFunc[i].vFuncNAMEorNo[j].szFuncName, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 830&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 831&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 832&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名字&lt;/span&gt;
&lt;span&gt; 833&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 834&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; iFuncNameLenth = g_tagDllFunc[i].vFuncNAMEorNo[j].iFuncNameLenth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度&lt;/span&gt;
&lt;span&gt; 835&lt;/span&gt;                     g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + &lt;span&gt;1&lt;/span&gt; + iFuncNameLenth);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前2字节存放长度 后面为函数名称&lt;/span&gt;
&lt;span&gt; 836&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth, (BYTE*)&amp;amp;iFuncNameLenth, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 837&lt;/span&gt;                     iAddIatLenth += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 838&lt;/span&gt;                     memcpy(g_pFileSrc + g_iFileSize +&lt;span&gt; iAddIatLenth, g_tagDllFunc[i].vFuncNAMEorNo[j].szFuncName, iFuncNameLenth);
&lt;/span&gt;&lt;span&gt; 839&lt;/span&gt;                     iAddIatLenth +=&lt;span&gt; iFuncNameLenth;
&lt;/span&gt;&lt;span&gt; 840&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 841&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 842&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 843&lt;/span&gt; 
&lt;span&gt; 844&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放加载的函数地址表的RVA&lt;/span&gt;
&lt;span&gt; 845&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iLoadAddressTabRVA = iNewSectionFileMapAddr +&lt;span&gt; iAddIatLenth;
&lt;/span&gt;&lt;span&gt; 846&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iLoadIatLenth = g_IATaddrList.size() * &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存放加载的函数地址表长度  此处多4字节来存放基址
&lt;/span&gt;&lt;span&gt; 847&lt;/span&gt; 
&lt;span&gt; 848&lt;/span&gt; 
&lt;span&gt; 849&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取新的OEP并修改旧的OEP&lt;/span&gt;
&lt;span&gt; 850&lt;/span&gt;         g_iNewOEP = iNewSectionFileMapAddr + iAddIatLenth +&lt;span&gt; iLoadIatLenth;
&lt;/span&gt;&lt;span&gt; 851&lt;/span&gt;         pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt; 852&lt;/span&gt;         pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt; 853&lt;/span&gt;          pNtHead-&amp;gt;OptionalHeader.AddressOfEntryPoint =&lt;span&gt; g_iNewOEP;
&lt;/span&gt;&lt;span&gt; 854&lt;/span&gt; 
&lt;span&gt; 855&lt;/span&gt; &lt;span&gt;        JitRuntime        _x86RunTimeObject;
&lt;/span&gt;&lt;span&gt; 856&lt;/span&gt;         X86Assembler    a(&amp;amp;&lt;span&gt;_x86RunTimeObject);
&lt;/span&gt;&lt;span&gt; 857&lt;/span&gt; 
&lt;span&gt; 858&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转标记&lt;/span&gt;
&lt;span&gt; 859&lt;/span&gt;         Label LoadDllBegin =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 860&lt;/span&gt;         Label LoadDllOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 861&lt;/span&gt;         
&lt;span&gt; 862&lt;/span&gt;         Label NameExport =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 863&lt;/span&gt;         Label NameExportBegin =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 864&lt;/span&gt;         Label NameExportOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 865&lt;/span&gt;         Label NoExportBegin =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 866&lt;/span&gt;         Label NoExportOver =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 867&lt;/span&gt; 
&lt;span&gt; 868&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;
&lt;span&gt; 869&lt;/span&gt;         Label lTest =&lt;span&gt; a.newLabel();
&lt;/span&gt;&lt;span&gt; 870&lt;/span&gt;         
&lt;span&gt; 871&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当有重定位表时，将NewOEP+1新增到重定位项中，重定位后的地址-OldOEP即可得到新的基址
&lt;/span&gt;&lt;span&gt; 872&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里push g_iOldOEP + g_iImageBase而不是g_iImageBase(直接得到新基址 不用再-旧OEP)，是因为push完还要ret到旧OEP
&lt;/span&gt;&lt;span&gt; 873&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行完这段后，栈上是旧OEP的地址，ebx是程序基址&lt;/span&gt;
&lt;span&gt; 874&lt;/span&gt;         a.push(g_iOldOEP +&lt;span&gt; g_iImageBase);
&lt;/span&gt;&lt;span&gt; 875&lt;/span&gt; &lt;span&gt;        a.mov(ebx, dword_ptr(esp));
&lt;/span&gt;&lt;span&gt; 876&lt;/span&gt; &lt;span&gt;        a.sub(ebx, g_iOldOEP);
&lt;/span&gt;&lt;span&gt; 877&lt;/span&gt;         
&lt;span&gt; 878&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;a.call(lTest);
&lt;/span&gt;&lt;span&gt; 879&lt;/span&gt; &lt;span&gt;        a.bind(lTest);
&lt;/span&gt;&lt;span&gt; 880&lt;/span&gt; &lt;span&gt;        a.pop(eax);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 881&lt;/span&gt; 
&lt;span&gt; 882&lt;/span&gt; &lt;span&gt;        a.pusha();
&lt;/span&gt;&lt;span&gt; 883&lt;/span&gt;         a.push(ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将程序基址保存到栈上&lt;/span&gt;
&lt;span&gt; 884&lt;/span&gt;         a.sub(esp, &lt;span&gt;0x8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 885&lt;/span&gt;         a.mov(ebp, esp); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebp从上往下分别是LoadLibraryA函数地址、GetProcAddress函数地址和程序基址  ebp-4为Dll基址 -8为填充函数加载地址起始地址&lt;/span&gt;
&lt;span&gt; 886&lt;/span&gt;         a.sub(esp, &lt;span&gt;0x8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 887&lt;/span&gt;         
&lt;span&gt; 888&lt;/span&gt; &lt;span&gt;        GetKernel32Base(a);
&lt;/span&gt;&lt;span&gt; 889&lt;/span&gt;         a.mov(edi, eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;edi为所遍历到的DLL基址
&lt;/span&gt;&lt;span&gt; 890&lt;/span&gt; 
&lt;span&gt; 891&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算函数地址&lt;/span&gt;
&lt;span&gt; 892&lt;/span&gt; &lt;span&gt;        GetLoadLibraryAAddr(a);
&lt;/span&gt;&lt;span&gt; 893&lt;/span&gt;         a.mov(dword_ptr(ebp, &lt;span&gt;0&lt;/span&gt;), eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存LoadLibraryA的值到栈上&lt;/span&gt;
&lt;span&gt; 894&lt;/span&gt; &lt;span&gt;        GetGetProcAddressAddr(a);
&lt;/span&gt;&lt;span&gt; 895&lt;/span&gt;         a.mov(dword_ptr(ebp, &lt;span&gt;4&lt;/span&gt;), eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存GetProcAddress的值到栈上&lt;/span&gt;
&lt;span&gt; 896&lt;/span&gt; &lt;span&gt;        a.mov(eax, iLoadAddressTabRVA);
&lt;/span&gt;&lt;span&gt; 897&lt;/span&gt;         a.add(eax, dword_ptr(ebp, &lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充函数地址RVA+程序基址&lt;/span&gt;
&lt;span&gt; 898&lt;/span&gt;         a.mov(dword_ptr(ebp, -&lt;span&gt;8&lt;/span&gt;), eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放到ebp-8的地址上
&lt;/span&gt;&lt;span&gt; 899&lt;/span&gt; 
&lt;span&gt; 900&lt;/span&gt; 
&lt;span&gt; 901&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始遍历IAT数据，填充函数加载地址表&lt;/span&gt;
&lt;span&gt; 902&lt;/span&gt; &lt;span&gt;        a.mov(esi, iNewSectionFileMapAddr);
&lt;/span&gt;&lt;span&gt; 903&lt;/span&gt;         a.add(esi, dword_ptr(ebp, &lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;esi为IAT数据起点&lt;/span&gt;
&lt;span&gt; 904&lt;/span&gt;         a.mov(ebx, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以ebx开始遍历  达到长度 退出
&lt;/span&gt;&lt;span&gt; 905&lt;/span&gt; 
&lt;span&gt; 906&lt;/span&gt; 
&lt;span&gt; 907&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载DLL&lt;/span&gt;
&lt;span&gt; 908&lt;/span&gt; &lt;span&gt;        a.bind(LoadDllBegin);
&lt;/span&gt;&lt;span&gt; 909&lt;/span&gt;         a.cmp(ebx, iAddIatLenth);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果遍历长度大于等于IAT数据长度&lt;/span&gt;
&lt;span&gt; 910&lt;/span&gt; &lt;span&gt;        a.jnl(LoadDllOver);
&lt;/span&gt;&lt;span&gt; 911&lt;/span&gt;         a.movzx(ecx, byte_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得DLL名长度&lt;/span&gt;
&lt;span&gt; 912&lt;/span&gt;         a.add(ebx, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+Dll名长度的变量1&lt;/span&gt;
&lt;span&gt; 913&lt;/span&gt;         a.lea(eax, dword_ptr(esi,ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得函数名地址&lt;/span&gt;
&lt;span&gt; 914&lt;/span&gt; &lt;span&gt;        a.push(eax);
&lt;/span&gt;&lt;span&gt; 915&lt;/span&gt;         a.add(ebx, ecx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+DLL名长度&lt;/span&gt;
&lt;span&gt; 916&lt;/span&gt;         a.mov(eax, dword_ptr(ebp));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得loadlibrary地址&lt;/span&gt;
&lt;span&gt; 917&lt;/span&gt; &lt;span&gt;        a.call(eax);
&lt;/span&gt;&lt;span&gt; 918&lt;/span&gt;         a.mov(dword_ptr(ebp,-&lt;span&gt;4&lt;/span&gt;),eax);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ebp为load.. +4为get.. +8为程序基址  -4为当前Dll基址 -8为填充函数加载地址位置&lt;/span&gt;
&lt;span&gt; 919&lt;/span&gt;         a.movzx(edi, word_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出该DLL导出函数数量&lt;/span&gt;
&lt;span&gt; 920&lt;/span&gt;         a.add(ebx, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 921&lt;/span&gt;         a.movzx(edx, byte_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出导出方式&lt;/span&gt;
&lt;span&gt; 922&lt;/span&gt;         a.add(ebx, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 923&lt;/span&gt;         a.cmp(edx, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为1时，名称导出&lt;/span&gt;
&lt;span&gt; 924&lt;/span&gt; &lt;span&gt;        a.je(NameExportBegin);
&lt;/span&gt;&lt;span&gt; 925&lt;/span&gt; 
&lt;span&gt; 926&lt;/span&gt; 
&lt;span&gt; 927&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;序号导出&lt;/span&gt;
&lt;span&gt; 928&lt;/span&gt;         a.bind(NoExportBegin);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序号导出循环起点&lt;/span&gt;
&lt;span&gt; 929&lt;/span&gt;         a.cmp(edi, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 930&lt;/span&gt; &lt;span&gt;        a.je(NoExportOver);
&lt;/span&gt;&lt;span&gt; 931&lt;/span&gt;         a.add(ebx, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 932&lt;/span&gt;         a.mov(eax, dword_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得序号&lt;/span&gt;
&lt;span&gt; 933&lt;/span&gt;         a.add(ebx, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 934&lt;/span&gt; &lt;span&gt;        a.push(eax);
&lt;/span&gt;&lt;span&gt; 935&lt;/span&gt;         a.push(dword_ptr(ebp, -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 936&lt;/span&gt;         a.mov(eax, dword_ptr(ebp, &lt;span&gt;4&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得GetProcAddress&lt;/span&gt;
&lt;span&gt; 937&lt;/span&gt; &lt;span&gt;        a.call(eax);
&lt;/span&gt;&lt;span&gt; 938&lt;/span&gt;         a.mov(edx, dword_ptr(ebp, -&lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得装载函数表&lt;/span&gt;
&lt;span&gt; 939&lt;/span&gt; &lt;span&gt;        a.mov(dword_ptr(edx), eax);
&lt;/span&gt;&lt;span&gt; 940&lt;/span&gt;         a.add(dword_ptr(ebp, -&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;装载函数表RVA+4&lt;/span&gt;
&lt;span&gt; 941&lt;/span&gt;         a.sub(edi, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 942&lt;/span&gt; &lt;span&gt;        a.jmp(NoExportBegin);
&lt;/span&gt;&lt;span&gt; 943&lt;/span&gt;         a.bind(NoExportOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序号导出循环终点&lt;/span&gt;
&lt;span&gt; 944&lt;/span&gt;         a.jmp(LoadDllBegin); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新加载新DLL
&lt;/span&gt;&lt;span&gt; 945&lt;/span&gt; 
&lt;span&gt; 946&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称导出&lt;/span&gt;
&lt;span&gt; 947&lt;/span&gt;         a.bind(NameExportBegin);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称导出循环起点&lt;/span&gt;
&lt;span&gt; 948&lt;/span&gt;         a.cmp(edi, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 949&lt;/span&gt; &lt;span&gt;        a.je(NameExportOver);
&lt;/span&gt;&lt;span&gt; 950&lt;/span&gt;         a.movzx(ecx, byte_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得名称长度&lt;/span&gt;
&lt;span&gt; 951&lt;/span&gt;         a.add(ebx, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 952&lt;/span&gt;         a.lea(eax, dword_ptr(esi, ebx));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称地址&lt;/span&gt;
&lt;span&gt; 953&lt;/span&gt; &lt;span&gt;        a.push(eax);
&lt;/span&gt;&lt;span&gt; 954&lt;/span&gt; &lt;span&gt;        a.add(ebx, ecx);
&lt;/span&gt;&lt;span&gt; 955&lt;/span&gt;         a.push(dword_ptr(ebp, -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 956&lt;/span&gt;         a.mov(eax, dword_ptr(ebp, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 957&lt;/span&gt; &lt;span&gt;        a.call(eax);
&lt;/span&gt;&lt;span&gt; 958&lt;/span&gt;         a.mov(edx, dword_ptr(ebp, -&lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得装载函数表&lt;/span&gt;
&lt;span&gt; 959&lt;/span&gt; &lt;span&gt;        a.mov(dword_ptr(edx), eax);
&lt;/span&gt;&lt;span&gt; 960&lt;/span&gt;         a.add(dword_ptr(ebp, -&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;装载函数表RVA+4&lt;/span&gt;
&lt;span&gt; 961&lt;/span&gt;         a.sub(edi, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 962&lt;/span&gt; &lt;span&gt;        a.jmp(NameExportBegin);
&lt;/span&gt;&lt;span&gt; 963&lt;/span&gt;         a.bind(NameExportOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称导出循环终点&lt;/span&gt;
&lt;span&gt; 964&lt;/span&gt;         a.jmp(LoadDllBegin); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新加载新DLL&lt;/span&gt;
&lt;span&gt; 965&lt;/span&gt;         
&lt;span&gt; 966&lt;/span&gt; 
&lt;span&gt; 967&lt;/span&gt;         
&lt;span&gt; 968&lt;/span&gt;         &lt;span&gt;/////////&lt;/span&gt;&lt;span&gt;//开始构造替换调用代码的shellcode&lt;/span&gt;&lt;span&gt;////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 969&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意esp为当前操作的栈顶  ebp+8为程序所在基址&lt;/span&gt;
&lt;span&gt; 970&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewJitBeginAddrRva = iNewSectionFileMapAddr + iAddIatLenth + iLoadIatLenth; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换的shellcode开始的地址&lt;/span&gt;
&lt;span&gt; 971&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt; 972&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g_tagIAT.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 973&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 974&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;0&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EAX&lt;/span&gt;
&lt;span&gt; 975&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 976&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 977&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt; 978&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt; 979&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt; 980&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt; 981&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 982&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt; 983&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt; 984&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt; 985&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+5+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt; 986&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt; 987&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt; 988&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt; 989&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt; 990&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt; 991&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt; 992&lt;/span&gt; &lt;span&gt;                a.pop(eax);
&lt;/span&gt;&lt;span&gt; 993&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt; 994&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt; 995&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt; 996&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 997&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EDX&lt;/span&gt;
&lt;span&gt; 998&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 999&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1002&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1003&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1004&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1005&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1006&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1007&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1008&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+5+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1009&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1010&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1011&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1012&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1013&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1014&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1015&lt;/span&gt; &lt;span&gt;                a.pop(edx);
&lt;/span&gt;&lt;span&gt;1016&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1017&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1018&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1019&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1020&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;2&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ESP&lt;/span&gt;
&lt;span&gt;1021&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1022&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1023&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1025&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1026&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1027&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1028&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1029&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1030&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1031&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1032&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1033&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1034&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1035&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1036&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1037&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1038&lt;/span&gt; &lt;span&gt;                a.pop(esp);
&lt;/span&gt;&lt;span&gt;1039&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1040&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1041&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1042&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1043&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;3&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ESI&lt;/span&gt;
&lt;span&gt;1044&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1045&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1046&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1047&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1048&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1049&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1050&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1051&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1052&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1053&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1054&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1055&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1056&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1057&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1058&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1059&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1060&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1061&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1062&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1063&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1064&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1065&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1066&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;4&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ECX&lt;/span&gt;
&lt;span&gt;1067&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1068&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1069&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1070&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1071&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1072&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1073&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1074&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1075&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1076&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1077&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1078&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1079&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1080&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1081&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1082&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1083&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1084&lt;/span&gt; &lt;span&gt;                a.pop(ecx);
&lt;/span&gt;&lt;span&gt;1085&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1086&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1087&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1088&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1089&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;5&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EBX&lt;/span&gt;
&lt;span&gt;1090&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1091&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1092&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1093&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1094&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1095&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1096&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1097&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1098&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1099&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1100&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1101&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1102&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1103&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1104&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1105&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1106&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1107&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1108&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1109&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1110&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1111&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1112&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;6&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EBP&lt;/span&gt;
&lt;span&gt;1113&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1114&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1115&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1116&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1117&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1118&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1119&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1120&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1121&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1122&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1123&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1124&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1125&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1126&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1127&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1128&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1129&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1130&lt;/span&gt; &lt;span&gt;                a.pop(ebp);
&lt;/span&gt;&lt;span&gt;1131&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1132&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1133&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1134&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1135&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;7&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EDI&lt;/span&gt;
&lt;span&gt;1136&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1137&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1138&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1139&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1140&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1141&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1142&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1143&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1144&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1145&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1146&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前指令所在RVA+6+程序基址 =返回地址&lt;/span&gt;
&lt;span&gt;1147&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1148&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1149&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1150&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0x8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代替原函数地址的地址&lt;/span&gt;
&lt;span&gt;1151&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1152&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1153&lt;/span&gt; &lt;span&gt;                a.pop(edi);
&lt;/span&gt;&lt;span&gt;1154&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1155&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1156&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1157&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1158&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;8&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Call&lt;/span&gt;
&lt;span&gt;1159&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1160&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1161&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1162&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1163&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1164&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1165&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1166&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1167&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1168&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1169&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1170&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;8&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放目标函数地址的地址的RVA&lt;/span&gt;
&lt;span&gt;1171&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回地址RVA&lt;/span&gt;
&lt;span&gt;1172&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1173&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;&lt;span&gt;), ebx); 
&lt;/span&gt;&lt;span&gt;1174&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1175&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1176&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1177&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1178&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1179&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1180&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;9&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JMP&lt;/span&gt;
&lt;span&gt;1181&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1182&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1183&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1184&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1185&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1186&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1187&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1188&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1189&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1190&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1191&lt;/span&gt;                 a.mov(dword_ptr(esp,&lt;span&gt;4&lt;/span&gt;), &lt;span&gt;0x3535&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充垃圾数据&lt;/span&gt;
&lt;span&gt;1192&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1193&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放目标函数地址的地址的RVA&lt;/span&gt;
&lt;span&gt;1194&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1195&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1196&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1197&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1198&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1199&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1200&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1201&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;10&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PUSH&lt;/span&gt;
&lt;span&gt;1202&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1203&lt;/span&gt;                 g_tagIAT[i].dwNewIatAddr = iNewSectionFileMapAddr + iAddIatLenth + g_tagIAT[i].wIndex * &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1204&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1205&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1206&lt;/span&gt; &lt;span&gt;                a.push(ebx);
&lt;/span&gt;&lt;span&gt;1207&lt;/span&gt; &lt;span&gt;                a.push(esi);
&lt;/span&gt;&lt;span&gt;1208&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)g_tagIAT[i].dwNewIatAddr);
&lt;/span&gt;&lt;span&gt;1209&lt;/span&gt;                 a.mov(esi, g_iImageBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;程序基址 后续会将这个位置添加到重定位块处，运行时即变为程序基址了&lt;/span&gt;
&lt;span&gt;1210&lt;/span&gt;                 g_tagIAT[i].dwRelocAddr = iNewJitBeginAddrRva + a.getCodeSize() - &lt;span&gt;4&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shellcode开始的位置+当前jit长度 再往回4字节  即为存放基址的位置&lt;/span&gt;
&lt;span&gt;1211&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1212&lt;/span&gt; &lt;span&gt;                a.mov(ebx, dword_ptr(ebx));
&lt;/span&gt;&lt;span&gt;1213&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;0xC&lt;/span&gt;), ebx);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放目标函数地址的地址的RVA&lt;/span&gt;
&lt;span&gt;1214&lt;/span&gt;                 a.mov(ebx, (&lt;span&gt;int&lt;/span&gt;)g_tagIAT[i].dwCallAddr + &lt;span&gt;6&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回地址RVA&lt;/span&gt;
&lt;span&gt;1215&lt;/span&gt; &lt;span&gt;                a.lea(ebx, dword_ptr(ebx, esi));
&lt;/span&gt;&lt;span&gt;1216&lt;/span&gt;                 a.mov(dword_ptr(esp, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;), ebx);
&lt;/span&gt;&lt;span&gt;1217&lt;/span&gt; &lt;span&gt;                a.pop(esi);
&lt;/span&gt;&lt;span&gt;1218&lt;/span&gt; &lt;span&gt;                a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1219&lt;/span&gt; &lt;span&gt;                a.ret();
&lt;/span&gt;&lt;span&gt;1220&lt;/span&gt;                 g_tagIAT[i].dwJmpAddr = iNewJitBeginAddrRva +&lt;span&gt; iNewJitLenth;
&lt;/span&gt;&lt;span&gt;1221&lt;/span&gt;                 iNewJitLenth =&lt;span&gt; a.getCodeSize();
&lt;/span&gt;&lt;span&gt;1222&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1223&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1224&lt;/span&gt;         a.bind(LoadDllOver);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载函数地址表以及构建替代IAT的ShellCode完成&lt;/span&gt;
&lt;span&gt;1225&lt;/span&gt;         a.mov(edi, dword_ptr(ebp, &lt;span&gt;8&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得基址&lt;/span&gt;
&lt;span&gt;1226&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g_tagIAT.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1227&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt;1228&lt;/span&gt; &lt;span&gt;            a.lea(ecx, dword_ptr(edi, g_tagIAT[i].dwCallAddr));
&lt;/span&gt;&lt;span&gt;1229&lt;/span&gt;             a.mov(byte_ptr(ecx), &lt;span&gt;0xE9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1230&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于这里的E9后面的值，是偏移，所以不用加上基址。偏移量=目标地址-当前指令地址-指令长度&lt;/span&gt;
&lt;span&gt;1231&lt;/span&gt;             a.mov(dword_ptr(ecx, &lt;span&gt;1&lt;/span&gt;), (&lt;span&gt;int&lt;/span&gt;)(g_tagIAT[i].dwJmpAddr - g_tagIAT[i].dwCallAddr - &lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;1232&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1233&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1235&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1236&lt;/span&gt;             a.mov(byte_ptr(ecx, &lt;span&gt;5&lt;/span&gt;), &lt;span&gt;0x90&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1237&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1238&lt;/span&gt;         a.add(esp, &lt;span&gt;0x10&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8+8&lt;/span&gt;
&lt;span&gt;1239&lt;/span&gt; &lt;span&gt;        a.pop(ebx);
&lt;/span&gt;&lt;span&gt;1240&lt;/span&gt; &lt;span&gt;        a.popa();
&lt;/span&gt;&lt;span&gt;1241&lt;/span&gt; &lt;span&gt;        a.ret();
&lt;/span&gt;&lt;span&gt;1242&lt;/span&gt; 
&lt;span&gt;1243&lt;/span&gt;         PVOID szJit =&lt;span&gt; a.make();
&lt;/span&gt;&lt;span&gt;1244&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iJitLenth =&lt;span&gt; a.getCodeSize(); 
&lt;/span&gt;&lt;span&gt;1245&lt;/span&gt;          g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize + iAddIatLenth + iLoadIatLenth +&lt;span&gt; iJitLenth);
&lt;/span&gt;&lt;span&gt;1246&lt;/span&gt;         memcpy(g_pFileSrc + g_iFileSize + iAddIatLenth +&lt;span&gt; iLoadIatLenth , szJit, iJitLenth);
&lt;/span&gt;&lt;span&gt;1247&lt;/span&gt; 
&lt;span&gt;1248&lt;/span&gt; 
&lt;span&gt;1249&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一共增加的代码=IAT相关数据+加载后的函数地址表大小+JIT代码长度&lt;/span&gt;
&lt;span&gt;1250&lt;/span&gt;          &lt;span&gt;int&lt;/span&gt; iAddSrcLen = iAddIatLenth + iLoadIatLenth +&lt;span&gt; iJitLenth;
&lt;/span&gt;&lt;span&gt;1251&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完善节长度等数据  保守起见重新获取节表信息&lt;/span&gt;
&lt;span&gt;1252&lt;/span&gt;         pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt;1253&lt;/span&gt;         pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt;1254&lt;/span&gt;         pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt;1255&lt;/span&gt;         pSection += pNtHead-&amp;gt;FileHeader.NumberOfSections - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1256&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(iAddSrcLen%&lt;span&gt;g_iFileAlignment))
&lt;/span&gt;&lt;span&gt;1257&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1258&lt;/span&gt;             pSection-&amp;gt;SizeOfRawData =&lt;span&gt; iAddSrcLen;
&lt;/span&gt;&lt;span&gt;1259&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1260&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1261&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1262&lt;/span&gt;             pSection-&amp;gt;SizeOfRawData = iAddSrcLen + g_iFileAlignment - (iAddSrcLen%&lt;span&gt;g_iFileAlignment);
&lt;/span&gt;&lt;span&gt;1263&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1264&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(iAddSrcLen%&lt;span&gt;g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt;1265&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1266&lt;/span&gt;             pSection-&amp;gt;Misc.VirtualSize =&lt;span&gt; iAddSrcLen;
&lt;/span&gt;&lt;span&gt;1267&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1268&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1269&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1270&lt;/span&gt;             pSection-&amp;gt;Misc.VirtualSize = iAddSrcLen + g_iSectionAlignment - (iAddSrcLen%&lt;span&gt;g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt;1271&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1272&lt;/span&gt;         pNtHead-&amp;gt;OptionalHeader.SizeOfImage += pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt;1273&lt;/span&gt; 
&lt;span&gt;1274&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (iAddSrcLen != pSection-&amp;gt;SizeOfRawData)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当新增长度与对齐后的节长度不相等时，将其补全&lt;/span&gt;
&lt;span&gt;1275&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1276&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iLenth = pSection-&amp;gt;SizeOfRawData;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先保存，以免扩容后原地址被回收&lt;/span&gt;
&lt;span&gt;1277&lt;/span&gt;             g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize +&lt;span&gt; iLenth);
&lt;/span&gt;&lt;span&gt;1278&lt;/span&gt;             memset(g_pFileSrc + g_iFileSize + iAddSrcLen, &lt;span&gt;0&lt;/span&gt;, iLenth -&lt;span&gt; iAddSrcLen);
&lt;/span&gt;&lt;span&gt;1279&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1280&lt;/span&gt;           g_iFileSize += pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt;1281&lt;/span&gt; 
&lt;span&gt;1282&lt;/span&gt;         
&lt;span&gt;1283&lt;/span&gt; 
&lt;span&gt;1284&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原重定位中  涉及IAT的重定位项删掉
&lt;/span&gt;&lt;span&gt;1285&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.先统计IAT中的地址位置代码(除了mov eax的地址位置在指令位置+1处，其他皆为+2)&lt;/span&gt;
&lt;span&gt;1286&lt;/span&gt;         vector&amp;lt;WORD&amp;gt;vDeleteIatAddr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要删除的重定位信息&lt;/span&gt;
&lt;span&gt;1287&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g_tagIAT.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1288&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1289&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (g_tagIAT[i].bType==&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mov eax  重定位地址位于调用地址+1处&lt;/span&gt;
&lt;span&gt;1290&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1291&lt;/span&gt;                 vDeleteIatAddr.push_back(g_tagIAT[i].dwCallAddr + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1292&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1293&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1294&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1295&lt;/span&gt;                 vDeleteIatAddr.push_back(g_tagIAT[i].dwCallAddr + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1296&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1297&lt;/span&gt;             
&lt;span&gt;1298&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1299&lt;/span&gt; 
&lt;span&gt;1300&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.统计出重定位表有几个重定位块，每个块的基址是多少，里面有多少个偏移&lt;/span&gt;
&lt;span&gt;1301&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; iRelocationLenth; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1302&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1303&lt;/span&gt; &lt;span&gt;            tagRelocation addR;
&lt;/span&gt;&lt;span&gt;1304&lt;/span&gt;             addR.wR_Head = *(&lt;span&gt;int&lt;/span&gt;*)(szR_Src +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;1305&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iR_Lenth = *(&lt;span&gt;int&lt;/span&gt;*)(szR_Src + i + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1306&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;8&lt;/span&gt;; j &amp;lt; iR_Lenth; j+=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1307&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1308&lt;/span&gt;                 WORD ccc = *(WORD*)(szR_Src + i +&lt;span&gt; j);
&lt;/span&gt;&lt;span&gt;1309&lt;/span&gt; &lt;span&gt;                addR.wR_Offset.push_back(ccc);
&lt;/span&gt;&lt;span&gt;1310&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1311&lt;/span&gt; &lt;span&gt;            vOldReloction.push_back(addR);
&lt;/span&gt;&lt;span&gt;1312&lt;/span&gt;             i += iR_Lenth - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1313&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1314&lt;/span&gt; 
&lt;span&gt;1315&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.根据IAT里的地址，在重定位地址表查找，找到之后将其删除 &lt;/span&gt;
&lt;span&gt;1316&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vDeleteIatAddr.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1317&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1318&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; vOldReloction.size(); j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1319&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1320&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((vDeleteIatAddr[i] &amp;amp; &lt;span&gt;0xFFF000&lt;/span&gt;) &amp;gt; vOldReloction[j].wR_Head) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当调用地址的重定位块大于当前重定位表块时&lt;/span&gt;
&lt;span&gt;1321&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1322&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1323&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1324&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((vDeleteIatAddr[i] &amp;amp; &lt;span&gt;0xFFF000&lt;/span&gt;) &amp;lt;&lt;span&gt; vOldReloction[j].wR_Head)
&lt;/span&gt;&lt;span&gt;1325&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1326&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1327&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1328&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到对应重定位块&lt;/span&gt;
&lt;span&gt;1329&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1330&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; vOldReloction[j].wR_Offset.size(); k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1331&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;1332&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; ((vDeleteIatAddr[i] &amp;amp; &lt;span&gt;0xFFF&lt;/span&gt;) == (vOldReloction[j].wR_Offset[k] &amp;amp; &lt;span&gt;0xFFF&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;1333&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;1334&lt;/span&gt;                             vOldReloction[j].wR_Offset.erase(vOldReloction[j].wR_Offset.begin() +&lt;span&gt; k);
&lt;/span&gt;&lt;span&gt;1335&lt;/span&gt;                             &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; NextIatAddr;
&lt;/span&gt;&lt;span&gt;1336&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;1337&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;1338&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1339&lt;/span&gt; 
&lt;span&gt;1340&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1341&lt;/span&gt; &lt;span&gt;        NextIatAddr:;    
&lt;/span&gt;&lt;span&gt;1342&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1343&lt;/span&gt; 
&lt;span&gt;1344&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.对齐重定位表数据，&lt;/span&gt;
&lt;span&gt;1345&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果重定位块中项目为偶数个，则跳过
&lt;/span&gt;&lt;span&gt;1346&lt;/span&gt; &lt;span&gt;        如果是奇数个，看最后一个是否为0。如果为0，删掉；如果不为0，补0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;1347&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vOldReloction.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1348&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1349&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iReloctionNum =&lt;span&gt; vOldReloction[i].wR_Offset.size();
&lt;/span&gt;&lt;span&gt;1350&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (iReloctionNum % &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取余  如果能取到 说明为奇数&lt;/span&gt;
&lt;span&gt;1351&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1352&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (vOldReloction[i].wR_Offset[iReloctionNum-&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1353&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1354&lt;/span&gt; &lt;span&gt;                    vOldReloction[i].wR_Offset.pop_back();
&lt;/span&gt;&lt;span&gt;1355&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1356&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1357&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1358&lt;/span&gt;                     vOldReloction[i].wR_Offset.push_back(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1359&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1360&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1361&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1362&lt;/span&gt; 
&lt;span&gt;1363&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复重定位表&lt;/span&gt;
&lt;span&gt;1364&lt;/span&gt;         szR_Src =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;1365&lt;/span&gt;         iRelocationLenth = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1366&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; vOldReloction.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1367&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1368&lt;/span&gt;             szR_Src = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szR_Src, iRelocationLenth + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1369&lt;/span&gt;             memcpy(szR_Src + iRelocationLenth, &amp;amp;vOldReloction[i].wR_Head, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1370&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iR_Lenth = vOldReloction[i].wR_Offset.size() * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1371&lt;/span&gt;             memcpy(szR_Src + iRelocationLenth + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iR_Lenth, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1372&lt;/span&gt;             iRelocationLenth += &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1373&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; vOldReloction[i].wR_Offset.size(); j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1374&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1375&lt;/span&gt;                 szR_Src = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szR_Src, iRelocationLenth + &lt;span&gt;8&lt;/span&gt; + j*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1376&lt;/span&gt;                 memcpy(szR_Src + iRelocationLenth + j*&lt;span&gt;2&lt;/span&gt;, &amp;amp;vOldReloction[i].wR_Offset[j], &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);            
&lt;/span&gt;&lt;span&gt;1377&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1378&lt;/span&gt;             iRelocationLenth += vOldReloction[i].wR_Offset.size() * &lt;span&gt;2&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;1379&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1380&lt;/span&gt;         
&lt;span&gt;1381&lt;/span&gt; 
&lt;span&gt;1382&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加新的重定位项&lt;/span&gt;
&lt;span&gt;1383&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *szAddRelocSrc = NULL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总新增重定位数据&lt;/span&gt;
&lt;span&gt;1384&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *szNowAddrelocSrc = NULL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子新增重定位数据&lt;/span&gt;
&lt;span&gt;1385&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iAddRelocLen = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总重定位数据长度&lt;/span&gt;
&lt;span&gt;1386&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iNowAddRelocLen = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子重定位数据长度&lt;/span&gt;
&lt;span&gt;1387&lt;/span&gt;         
&lt;span&gt;1388&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iPage = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1389&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iPageOffset = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;页内偏移
&lt;/span&gt;&lt;span&gt;1390&lt;/span&gt; 
&lt;span&gt;1391&lt;/span&gt; 
&lt;span&gt;1392&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先增加新OEP用于求得基址的重定位项&lt;/span&gt;
&lt;span&gt;1393&lt;/span&gt;         iNowAddRelocLen = &lt;span&gt;10&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子长度&lt;/span&gt;
&lt;span&gt;1394&lt;/span&gt;         szNowAddrelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(iNowAddRelocLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子数据&lt;/span&gt;
&lt;span&gt;1395&lt;/span&gt;         iPage = (g_iNewOEP + &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;0xfff000&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PUSH 0000 0000  重定位数据为地址 偏移+1&lt;/span&gt;
&lt;span&gt;1396&lt;/span&gt;         iPageOffset = ((g_iNewOEP + &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;0xfff&lt;/span&gt;) | &lt;span&gt;0x3000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1397&lt;/span&gt;         memcpy(szNowAddrelocSrc, &amp;amp;iPage, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页偏移&lt;/span&gt;
&lt;span&gt;1398&lt;/span&gt;         memcpy(szNowAddrelocSrc + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iNowAddRelocLen, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1399&lt;/span&gt;         memcpy(szNowAddrelocSrc + &lt;span&gt;8&lt;/span&gt;, &amp;amp;iPageOffset, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1400&lt;/span&gt; 
&lt;span&gt;1401&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始新增shellcode中的重定位项&lt;/span&gt;
&lt;span&gt;1402&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g_tagIAT.size(); i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1403&lt;/span&gt; &lt;span&gt;        {            
&lt;/span&gt;&lt;span&gt;1404&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (iPage == ((g_tagIAT[i].dwRelocAddr) &amp;amp; &lt;span&gt;0xfff000&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否与当前页大小一致&lt;/span&gt;
&lt;span&gt;1405&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1406&lt;/span&gt;                 szNowAddrelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szNowAddrelocSrc, iNowAddRelocLen + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1407&lt;/span&gt;                 iPageOffset = (g_tagIAT[i].dwRelocAddr &amp;amp; &lt;span&gt;0xfff&lt;/span&gt;) | &lt;span&gt;0x3000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1408&lt;/span&gt;                 memcpy(szNowAddrelocSrc + iNowAddRelocLen, &amp;amp;iPageOffset, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1409&lt;/span&gt;                 iNowAddRelocLen += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1410&lt;/span&gt;                 memcpy(szNowAddrelocSrc + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iNowAddRelocLen, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1411&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1412&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启新页&lt;/span&gt;
&lt;span&gt;1413&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1414&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((iNowAddRelocLen % &lt;span&gt;4&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否4字节对齐&lt;/span&gt;
&lt;span&gt;1415&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;1416&lt;/span&gt;                     szNowAddrelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szNowAddrelocSrc, iNowAddRelocLen + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1417&lt;/span&gt;                     memset(szNowAddrelocSrc + iNowAddRelocLen, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1418&lt;/span&gt;                     iNowAddRelocLen += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1419&lt;/span&gt;                     memcpy(szNowAddrelocSrc + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iNowAddRelocLen, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1420&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;1421&lt;/span&gt;                 
&lt;span&gt;1422&lt;/span&gt;                 szAddRelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szAddRelocSrc, iAddRelocLen + iNowAddRelocLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将总重定位数据扩容&lt;/span&gt;
&lt;span&gt;1423&lt;/span&gt;                 memcpy(szAddRelocSrc + iAddRelocLen, szNowAddrelocSrc, iNowAddRelocLen);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制子重定位块到总重定位块中&lt;/span&gt;
&lt;span&gt;1424&lt;/span&gt;                 iAddRelocLen += iNowAddRelocLen;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新总重定位块大小&lt;/span&gt;
&lt;span&gt;1425&lt;/span&gt; 
&lt;span&gt;1426&lt;/span&gt;                 iNowAddRelocLen = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1427&lt;/span&gt;                 szNowAddrelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(iNowAddRelocLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子数据&lt;/span&gt;
&lt;span&gt;1428&lt;/span&gt;                 iPage = g_tagIAT[i].dwRelocAddr &amp;amp; &lt;span&gt;0xfff000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1429&lt;/span&gt;                 iPageOffset = (g_tagIAT[i].dwRelocAddr &amp;amp; &lt;span&gt;0xfff&lt;/span&gt;) | &lt;span&gt;0x3000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1430&lt;/span&gt;                 memcpy(szNowAddrelocSrc, &amp;amp;iPage, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页偏移&lt;/span&gt;
&lt;span&gt;1431&lt;/span&gt;                 memcpy(szNowAddrelocSrc + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iNowAddRelocLen, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1432&lt;/span&gt;                 memcpy(szNowAddrelocSrc + &lt;span&gt;8&lt;/span&gt;, &amp;amp;iPageOffset, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1433&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1434&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1435&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时 由于已经遍历到tagIAT结构最后 但当前重定位块并为添加到总重定位块中，故需要再进行填充&lt;/span&gt;
&lt;span&gt;1436&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((iNowAddRelocLen % &lt;span&gt;4&lt;/span&gt;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否4字节对齐&lt;/span&gt;
&lt;span&gt;1437&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1438&lt;/span&gt;             szNowAddrelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szNowAddrelocSrc, iNowAddRelocLen + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1439&lt;/span&gt;             memset(szNowAddrelocSrc + iNowAddRelocLen, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1440&lt;/span&gt;             iNowAddRelocLen += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1441&lt;/span&gt;             memcpy(szNowAddrelocSrc + &lt;span&gt;4&lt;/span&gt;, &amp;amp;iNowAddRelocLen, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页大小&lt;/span&gt;
&lt;span&gt;1442&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1443&lt;/span&gt; 
&lt;span&gt;1444&lt;/span&gt;         szAddRelocSrc = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;(szAddRelocSrc, iAddRelocLen + iNowAddRelocLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将总重定位数据扩容&lt;/span&gt;
&lt;span&gt;1445&lt;/span&gt;         memcpy(szAddRelocSrc + iAddRelocLen, szNowAddrelocSrc, iNowAddRelocLen);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制子重定位块到总重定位块中&lt;/span&gt;
&lt;span&gt;1446&lt;/span&gt;         iAddRelocLen += iNowAddRelocLen;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新总重定位块大小&lt;/span&gt;
&lt;span&gt;1447&lt;/span&gt; 
&lt;span&gt;1448&lt;/span&gt; 
&lt;span&gt;1449&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((iR_FileLenth - iRelocationLenth) &amp;lt; iAddRelocLen) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节表长度和实际数据长度是否足够填充新的重定位块&lt;/span&gt;
&lt;span&gt;1450&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1451&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩充重定位数据
&lt;/span&gt;&lt;span&gt;1452&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;整数取余 = (新增数据总大小- 之前剩余空间间隙)%对齐大小&lt;/span&gt;
&lt;span&gt;1453&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; iZeroLenth = (iAddRelocLen - (iR_FileLenth - iRelocationLenth)) %&lt;span&gt; g_iFileAlignment;
&lt;/span&gt;&lt;span&gt;1454&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (iZeroLenth)
&lt;/span&gt;&lt;span&gt;1455&lt;/span&gt; &lt;span&gt;            { 
&lt;/span&gt;&lt;span&gt;1456&lt;/span&gt;                 iR_FileLenth = iRelocationLenth + iAddRelocLen + g_iFileAlignment -&lt;span&gt; iZeroLenth;
&lt;/span&gt;&lt;span&gt;1457&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1458&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1459&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;1460&lt;/span&gt;                 iR_FileLenth = iRelocationLenth +&lt;span&gt; iAddRelocLen;
&lt;/span&gt;&lt;span&gt;1461&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;1462&lt;/span&gt;             szR_Src = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;&lt;span&gt;(szR_Src, iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1463&lt;/span&gt;             memcpy(szR_Src +&lt;span&gt; iRelocationLenth, szAddRelocSrc, iAddRelocLen);
&lt;/span&gt;&lt;span&gt;1464&lt;/span&gt;             memset(szR_Src + iRelocationLenth + iAddRelocLen, &lt;span&gt;0&lt;/span&gt;, iR_FileLenth - iRelocationLenth -&lt;span&gt; iAddRelocLen);
&lt;/span&gt;&lt;span&gt;1465&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1466&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1467&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1468&lt;/span&gt;             szR_Src = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;realloc&lt;/span&gt;&lt;span&gt;(szR_Src, iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1469&lt;/span&gt;             memcpy(szR_Src +&lt;span&gt; iRelocationLenth, szAddRelocSrc, iAddRelocLen);
&lt;/span&gt;&lt;span&gt;1470&lt;/span&gt;             iRelocationLenth +=&lt;span&gt; iAddRelocLen;
&lt;/span&gt;&lt;span&gt;1471&lt;/span&gt;             memset(szR_Src + iRelocationLenth, &lt;span&gt;0&lt;/span&gt;, iR_FileLenth -&lt;span&gt; iRelocationLenth);
&lt;/span&gt;&lt;span&gt;1472&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1473&lt;/span&gt; 
&lt;span&gt;1474&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还原重定位&lt;/span&gt;
&lt;span&gt;1475&lt;/span&gt;         g_pFileSrc = (UCHAR*)&lt;span&gt;realloc&lt;/span&gt;(g_pFileSrc, g_iFileSize +&lt;span&gt; iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1476&lt;/span&gt;         memcpy(g_pFileSrc +&lt;span&gt; g_iFileSize, szR_Src, iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1477&lt;/span&gt;         g_iFileSize +=&lt;span&gt; iR_FileLenth;
&lt;/span&gt;&lt;span&gt;1478&lt;/span&gt;         
&lt;span&gt;1479&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/直接用realloc又抽风 用其他转移吧&lt;/span&gt;
&lt;span&gt;1480&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;char *szCopyBuff = (char*)malloc(g_iFileSize + iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1481&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;memcpy(szCopyBuff, g_pFileSrc, g_iFileSize);
&lt;/span&gt;&lt;span&gt;1482&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;memcpy(szCopyBuff + g_iFileSize, szR_Src, iR_FileLenth);
&lt;/span&gt;&lt;span&gt;1483&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;g_iFileSize += iR_FileLenth;
&lt;/span&gt;&lt;span&gt;1484&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;memcpy(g_pFileSrc, szCopyBuff, g_iFileSize);&lt;/span&gt;
&lt;span&gt;1485&lt;/span&gt;         
&lt;span&gt;1486&lt;/span&gt; 
&lt;span&gt;1487&lt;/span&gt;         pDosHead =&lt;span&gt; (PIMAGE_DOS_HEADER)g_pFileSrc;
&lt;/span&gt;&lt;span&gt;1488&lt;/span&gt;         pNtHead = (PIMAGE_NT_HEADERS)((DWORD)pDosHead + pDosHead-&amp;gt;&lt;span&gt;e_lfanew);
&lt;/span&gt;&lt;span&gt;1489&lt;/span&gt;         pSection = (PIMAGE_SECTION_HEADER)((DWORD)&amp;amp;pNtHead-&amp;gt;OptionalHeader + pNtHead-&amp;gt;&lt;span&gt;FileHeader.SizeOfOptionalHeader);
&lt;/span&gt;&lt;span&gt;1490&lt;/span&gt;         pSection += pNtHead-&amp;gt;FileHeader.NumberOfSections - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1491&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iR_FileAddr = pSection-&amp;gt;PointerToRawData + pSection-&amp;gt;&lt;span&gt;SizeOfRawData;
&lt;/span&gt;&lt;span&gt;1492&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iR_MapAddr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1493&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt;1494&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1495&lt;/span&gt;             iR_MapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize;
&lt;/span&gt;&lt;span&gt;1496&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1497&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1498&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1499&lt;/span&gt;             iR_MapAddr = pSection-&amp;gt;VirtualAddress + pSection-&amp;gt;&lt;span&gt;Misc.VirtualSize
&lt;/span&gt;&lt;span&gt;1500&lt;/span&gt;                 + g_iSectionAlignment - (pSection-&amp;gt;Misc.VirtualSize %&lt;span&gt; g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt;1501&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1502&lt;/span&gt; 
&lt;span&gt;1503&lt;/span&gt;         pSection++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1504&lt;/span&gt;         strcpy((&lt;span&gt;char&lt;/span&gt;*)pSection-&amp;gt;&lt;span&gt;Name, szR_Name);
&lt;/span&gt;&lt;span&gt;1505&lt;/span&gt;         pSection-&amp;gt;Characteristics = (&lt;span&gt;0x20000000&lt;/span&gt; | &lt;span&gt;0x40000000&lt;/span&gt; | &lt;span&gt;0x80000000&lt;/span&gt; | &lt;span&gt;0x40&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1506&lt;/span&gt;         pSection-&amp;gt;VirtualAddress =&lt;span&gt; iR_MapAddr;
&lt;/span&gt;&lt;span&gt;1507&lt;/span&gt;         pSection-&amp;gt;Misc.VirtualSize =&lt;span&gt; iR_FileLenth;
&lt;/span&gt;&lt;span&gt;1508&lt;/span&gt;         pSection-&amp;gt;PointerToRawData =&lt;span&gt; iR_FileAddr;
&lt;/span&gt;&lt;span&gt;1509&lt;/span&gt;         pSection-&amp;gt;SizeOfRawData =&lt;span&gt; iR_FileLenth;
&lt;/span&gt;&lt;span&gt;1510&lt;/span&gt;         pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;5&lt;/span&gt;].VirtualAddress =&lt;span&gt; iR_MapAddr;
&lt;/span&gt;&lt;span&gt;1511&lt;/span&gt;         pNtHead-&amp;gt;OptionalHeader.DataDirectory[&lt;span&gt;5&lt;/span&gt;].Size =&lt;span&gt; iRelocationLenth;
&lt;/span&gt;&lt;span&gt;1512&lt;/span&gt;         pNtHead-&amp;gt;FileHeader.NumberOfSections += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1513&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(iR_FileLenth%&lt;span&gt;g_iSectionAlignment))
&lt;/span&gt;&lt;span&gt;1514&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1515&lt;/span&gt;             pNtHead-&amp;gt;OptionalHeader.SizeOfImage +=&lt;span&gt; iR_FileLenth;
&lt;/span&gt;&lt;span&gt;1516&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1517&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;1518&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;1519&lt;/span&gt;             pNtHead-&amp;gt;OptionalHeader.SizeOfImage += iR_FileLenth + g_iSectionAlignment - (iR_FileLenth%&lt;span&gt;g_iSectionAlignment);
&lt;/span&gt;&lt;span&gt;1520&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;1521&lt;/span&gt; 
&lt;span&gt;1522&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1523&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1524&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;1525&lt;/span&gt; 
&lt;span&gt;1526&lt;/span&gt; 
&lt;span&gt;1527&lt;/span&gt; 
&lt;span&gt;1528&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;1529&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;1530&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;C:\\Users\\Admin\\Desktop\\弹窗.exe&lt;/span&gt;
&lt;span&gt;1531&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; FileName[] = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Admin\\Desktop\\弹窗.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;1532&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;LoadFile(FileName))
&lt;/span&gt;&lt;span&gt;1533&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1534&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;1535&lt;/span&gt;         system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1536&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1537&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1538&lt;/span&gt; 
&lt;span&gt;1539&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CheckPE())
&lt;/span&gt;&lt;span&gt;1540&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1541&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该程序不是PE文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;1542&lt;/span&gt;         system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1543&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1544&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1545&lt;/span&gt; 
&lt;span&gt;1546&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!FindCodeAddr())    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到对应调用IAT的地址&lt;/span&gt;
&lt;span&gt;1547&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1548&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该程序没有导入表，请检查&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;1549&lt;/span&gt;         system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1550&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1551&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1552&lt;/span&gt; 
&lt;span&gt;1553&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;SaveDll())
&lt;/span&gt;&lt;span&gt;1554&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1555&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存DLL信息失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;1556&lt;/span&gt;         system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1557&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1558&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1559&lt;/span&gt; 
&lt;span&gt;1560&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;NewIat())
&lt;/span&gt;&lt;span&gt;1561&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1562&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新建IAT表失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;1563&lt;/span&gt;         system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1564&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1565&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1566&lt;/span&gt; 
&lt;span&gt;1567&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;C:\\Users\\Admin\\Desktop\\弹窗IAT加密测试.exe&lt;/span&gt;
&lt;span&gt;1568&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; NewFilePath[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Admin\\Desktop\\弹窗IAT加密测试.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1569&lt;/span&gt;     HANDLE hNewFile =&lt;span&gt; CreateFileA(NewFilePath,
&lt;/span&gt;&lt;span&gt;1570&lt;/span&gt;         GENERIC_READ |&lt;span&gt; GENERIC_WRITE,
&lt;/span&gt;&lt;span&gt;1571&lt;/span&gt;         FILE_SHARE_READ |&lt;span&gt; FILE_SHARE_WRITE,
&lt;/span&gt;&lt;span&gt;1572&lt;/span&gt; &lt;span&gt;        NULL,
&lt;/span&gt;&lt;span&gt;1573&lt;/span&gt;         CREATE_ALWAYS,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建并覆盖上一个文件&lt;/span&gt;
&lt;span&gt;1574&lt;/span&gt; &lt;span&gt;        FILE_ATTRIBUTE_ARCHIVE,
&lt;/span&gt;&lt;span&gt;1575&lt;/span&gt; &lt;span&gt;        NULL);
&lt;/span&gt;&lt;span&gt;1576&lt;/span&gt; 
&lt;span&gt;1577&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (hNewFile ==&lt;span&gt; INVALID_HANDLE_VALUE)
&lt;/span&gt;&lt;span&gt;1578&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;1579&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件保存失败\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1580&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iError =&lt;span&gt; GetLastError();
&lt;/span&gt;&lt;span&gt;1581&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1582&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;1583&lt;/span&gt; 
&lt;span&gt;1584&lt;/span&gt;     LPDWORD iNum =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;1585&lt;/span&gt;     WriteFile(hNewFile, g_pFileSrc, g_iFileSize, iNum, NULL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入文件&lt;/span&gt;
&lt;span&gt;1586&lt;/span&gt; &lt;span&gt;    CloseHandle(hNewFile);
&lt;/span&gt;&lt;span&gt;1587&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *NewFileName1 = strrchr(NewFilePath, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;1588&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *NewFileName = strtok(NewFileName1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1589&lt;/span&gt;     MessageBoxA(&lt;span&gt;0&lt;/span&gt;, NewFileName, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;加密成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1590&lt;/span&gt;     MessageBoxA(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;by:阿怪\n          2020.12.26&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IAT加密&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1591&lt;/span&gt; 
&lt;span&gt;1592&lt;/span&gt;     system(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;1593&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Tue, 29 Dec 2020 20:16:00 +0000</pubDate>
<dc:creator>__阿阿阿怪</dc:creator>
<og:description>上一次做完代码段加密后，又接触到了新的加密方式：IAT加密 IAT加密是通过隐藏程序的导入表信息，以达到增加分析程序的难度。因为没有导入表，就无法单纯的从静态状态下分析调用了什么函数，动态调试时，也无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aaaguai/p/14207468.html</dc:identifier>
</item>
<item>
<title>容器编排系统K8s之访问控制--用户认证 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14207381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14207381.html</guid>
<description>&lt;p&gt;　　前文我们聊到了k8s的statefulset控制器相关使用说明，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14201103.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14201103.html&lt;/a&gt;；今天我们来聊一下k8s安全相关话题；&lt;/p&gt;
&lt;p&gt;　　我们知道在k8s上APIserver是整个集群的访问入口，etcd是保存整个集群所有资源状态配置信息的kv键值存储数据库，一旦etcd宕机，k8s整个集群将无法正常工作，为此我们需要对etcd做高可用；除此之外为了保证etcd中的数据安全，k8s只允许APIserver去访问/操作etcd;这也是APIserver为什么是整个集群的访问入口的原因；简单讲etcd的客户端只有APIserver，我们用客户端想要查看对应资源的状态或者修改对应资源属性等等操作，都需要把请求发送给APIserver，由APIserver再把客户端的请求代理到etcd上，从而实现客户端访问/操作etcd中对应资源的状态或属性信息；这样一来APIserver就承担了整个etcd的数据访问安全；一旦APIserver出现问题，把恶意请求放进来，对应etcd的中的数据安全将无从保证；为此APIserver就必须拥有一套对客户端请求进行验证管控的机制；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201229204516954-634489976.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1、用户认证&lt;/p&gt;
&lt;p&gt;　　首先APIserver要验证客户端是否是合法客户端，在k8s上我们用kubectl工具去管理k8s集群，APIserver首先要验证kubectl客户端的证书，同时kubectl也要验证对应APIserver的证书；这个过程我们叫k8s用户认证的过程；在k8s上除了有通过证书方式认证客户端，还有其他机制，比如用户名和密码，利用token机制去验证对应客户端；其中利用token机制中有明文token（plain token）和引导token（bootstrap token）；不管是用户名密码还是token方式认证用户，在发送给APIserver时都是通过把对应的信息转化成http协议头部信息传递给APIserver；对应APIserver收到对应客户端请求，就会把对应头部信息检索下来，进行验证；不同的是plain token主要用于验证对应客户端是否合法，是否能够登陆APIserver；而对应bootstrap token是用来验证对应节点是否能够加入到k8s集群，如果bootstrap认证通过后，对应APIserver会调用ca给对应节点上的kubelet和kubeproxy颁发证书；此后kubelet和kubeproxy就可以通过APIserver认可的ca颁发的证书到APIserver认证，访问对应资源的信息了；&lt;/p&gt;
&lt;p&gt;　　用户认证只是验证对应客户端是否是合法客户端，这里的验证的机制是一票通过的机制；所谓一票通过是指在APIserver上有多种验证机制（方法），它会从上至下依次进行验证，如果对应验证方法没有明确拒绝，接着它会用下一个验证方法，直到有一个机制通过以后，余下的就不验证了；比如，在k8s上有证书验证，用户名密码验证，token验证，如果此时有一个客户端拿着一个token来登陆APIserver，此时APIserver就会先用证书验证的方法验证客户端，如果对应验证方法没有明确拒绝，说明此方法不识别对应的客户端信息，接着它会用用户名密码的方法进行验证，如果对应方法也没有明确拒绝，接着它会用token方法进行验证，如果对应方法通过了，那么接下来的其他方法验证就不会再进行下去；如果所有验证方法都没有拒绝，说明该客户端提供的认证信息在k8s上不适配，此时apiserver 就会把对应客户端归纳为匿名用户；当然此类用户虽然登陆到APIserver上，但它没有权限操作资源；&lt;/p&gt;
&lt;p&gt;　　2、验证授权&lt;/p&gt;
&lt;p&gt;　　只有验证通过的客户端，才会有机会进行权限验证，所谓权限验证是指验证对应客户端是否拥有对应k8s上的资源访问/操作权限；验证权限也是一票通过的机制；只要对应客户端有对应资源的操作/访问权限，则其他资源的权限验证就不会再进行下去；如果没有对应资源访问/操作权限，此时APIserver就直接响应对应的客户端请求没有权限访问；如果对应客户端有对资源的访问/操作操作权限，此时客户端请求会进入到下一个步骤，准入控制；&lt;/p&gt;
&lt;p&gt;　　3、准入控制&lt;/p&gt;
&lt;p&gt;　　所谓准入控制是指检查对应客户端的请求是否符合对应请求/操作API规范；传递参数是否是正确的；比如我们要想k8s上创建一个pod，此时准入控制会检查我们提交的信息是否符合创建对应资源的规范，如果符合规范就创建，不符合规范就拒绝；准入控制这个环节是使用的一票否决的机制，所谓一票否决是指只要有一项不通过，则整个请求都将是拒绝的，即便余下的检查都是通过的；当然只要有一项没有通过，余下的验证就不会再进行；除了检查对应客户端提交的信息是否符合对应API资源的规范，准入控制还会帮助我们把我们没有明确指定的字段信息，通过默认值的方式把对应的字段填充到客户端请求中；然后把填充好的信息一并由APIserver把客户端请求更新到对应资源在etcd中的对应信息上；&lt;/p&gt;
&lt;p&gt;　　k8s上的用户&lt;/p&gt;
&lt;p&gt;　　在k8s上用户有两类，一类是常规用户（normal users），一类是服务帐号（Service Account）；所谓常规用户就是指对应客户端现实生活中的操作者，这个有点类似Linux上的登录用户；它把对应操作该客户端的人，映射到对应客户端的名称上；比如我们用kubectl去操作k8s集群，在k8s上我们自己就是对应kubeclt持有的证书信息中的/CN对应的字符串；服务帐号是指非人类操作的客户端所用到的用户名，有点类似Linux系统上的系统账号；它的存在只是为了在k8s上方便权限的划分；简单讲服务帐号就是用来针对那些程序自身向apiserver发起连接时，附加的用户信息，主要作用是apiserver可以根据对应的用户信息，来判断对应客户端在apiserver上的权限；如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201229231027945-642057254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：上图是一个pod的详细信息，其中我们并没有定义存储卷，创建pod后，它默认会生成这个存储卷；这个存储卷被挂载到对应pod容器内部的//var/run/secrets/kubernetes.io/serviceaccount 这个路径；其实这个就是对应pod检索/更新自己的状态信息，要在apiserver上进行认证的serviceaccount信息，保存在secret存储卷中；如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201229231529979-368258502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对应pod挂载secret存储卷，主要作用是在检索/更新自己的状态信息时，它会把这个token发送给apiserver进行验证；apiserver认证通过后就把对应状态信息更新到etcd中进行保存；正是因为pod提供了sa（serviceaccount的简写）账号token信息，使得apiserver才能正常判断出对应token对应用户的权限；这个token是在创建pod时，对应准入控制器自动生成sa账号，并把对应的sa账号的token信息以secret存储卷的方式挂载至对应pod的对应位置，pod更新或检索自己的信息时，它会把/var/run/secrets/kubernetes.io/serviceaccount这个文件中的信息发送给apiserver进行验证；此时apiserver一验证对应token信息，就能知道这个token是对应sa账号的token信息，从而识别到对应sa账号的权限；所以pod才能够正常的通过apiserver更新/检索自己的状态信息；&lt;/p&gt;
&lt;p&gt;　　客户端配置文件kubeconfig&lt;/p&gt;
&lt;p&gt;　　在k8s上各个客户端都是优先使用证书来做认证，apiserver通过验证各客户端的证书来确认对应的客户端是否能够正常访问apiserver；在k8s上证书验证是双向的，apiserver会验证客户端的证书中的subj中的CN（common name）的信息，是否符合对应客户端持有的身份信息，即用户名称；把证书中的subj中的O（organization）信息视为对应用户组；除此之外apiserver还会验证对应客户端证书是否是自己信任的CA所颁发的证书；对于客户端来说，也是同样的逻辑，它也需要验证apiserver的证书是否吻合对应apiserver的名称，是否是同一CA颁发的证书；那么问题来了，每次客户端是怎么向apiserver发送自己的的证书信息的呢？在k8s上每一个客户端都有一个配置文件，这个配置文件主要用来记录客户端证书验证相关信息；这个配置文件有一个统一的称呼叫kubeconfig；保存在/etc/kubernetes/目录下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# ll /etc/kubernetes/
total 32
-rw------- 1 root root 5567 Dec 22 20:00 admin.conf
-rw------- 1 root root 5599 Dec 22 20:00 controller-manager.conf
-rw------- 1 root root 1955 Dec 22 20:01 kubelet.conf
drwxr-xr-x 2 root root  113 Dec 22 20:00 manifests
drwxr-xr-x 3 root root 4096 Dec 22 20:00 pki
-rw------- 1 root root 5547 Dec 22 20:00 scheduler.conf
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们使用kubectl客户端工具去访问对应apiserver时，默认没有指定其配置文件，主要原因是在对应Linux用户的家目录下有一个.kube的目录里有一个config文件；这个文件是我们在初始化集群后，从/etc/kubernetes/admin.conf文件复制过来的，两者内容一样；默认不指定其配置文件kubectl会到当前Linux用户所在家目录下的.kube/config文件作为对应访问apiserver的认证文件；&lt;/p&gt;
&lt;p&gt;　　查看kubctl的配置文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl config view
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.0.41:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: kubernetes-admin
  name: kubernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes
kind: Config
preferences: {}
users:
- name: kubernetes-admin
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示；k8s上的客户端配置文件主要有4部分组成，分别是，users、clusters、contexts、current-context；users是指定用户帐号以及相关认证列表；clusters用来指定目标集群列表；contexts用来指定以哪个user接入那个cluster的对应连接组合；curren-context是用来指定当前使用的context；从上面的信息可以看到当前使用的是kubernetes-admin@kubernetes context连接k8s集群，对应context中，集群名叫kubernetes,使用的用户是kubernetes-admin；而对应集群的地址是https://192.168.0.41:6443,对应用户的的证书和私钥这里被隐藏了；&lt;/p&gt;
&lt;p&gt; 　　查看集群列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl config get-clusters
NAME
kubernetes
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看用户列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl config get-users
NAME
kubernetes-admin
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看context列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl config get-contexts
CURRENT   NAME                          CLUSTER      AUTHINFO           NAMESPACE
*         kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看当前使用的context&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# kubectl config current-context
kubernetes-admin@kubernetes
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：创建一个集群、常规用户、context，把对应信息保存到一个配置文件中，用对应配置文件去apiserver上请求资源，看看是否能够请求到对应资源信息？&lt;/p&gt;
&lt;p&gt;　　创建私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cd /etc/kubernetes/pki/
[root@master01 pki]# ls
apiserver.crt              apiserver-kubelet-client.crt  etcd                    front-proxy-client.key
apiserver-etcd-client.crt  apiserver-kubelet-client.key  front-proxy-ca.crt      sa.key
apiserver-etcd-client.key  ca.crt                        front-proxy-ca.key      sa.pub
apiserver.key              ca.key                        front-proxy-client.crt
[root@master01 pki]# openssl genrsa -out tom.key 2048
Generating RSA private key, 2048 bit long modulus
..............+++
..........................................................................................................................................................................................................................................+++
e is 65537 (0x10001)
[root@master01 pki]# ls
apiserver.crt              apiserver-kubelet-client.crt  etcd                    front-proxy-client.key
apiserver-etcd-client.crt  apiserver-kubelet-client.key  front-proxy-ca.crt      sa.key
apiserver-etcd-client.key  ca.crt                        front-proxy-ca.key      sa.pub
apiserver.key              ca.key                        front-proxy-client.crt  tom.key
[root@master01 pki]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用tom.key为tom用户生成签署请求文件tom.csr&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 pki]# openssl req -new -key ./tom.key -out tom.csr -subj &quot;/CN=tom/O=myuser&quot;
[root@master01 pki]# ls
apiserver.crt                 apiserver-kubelet-client.key  front-proxy-ca.key      tom.csr
apiserver-etcd-client.crt     ca.crt                        front-proxy-client.crt  tom.key
apiserver-etcd-client.key     ca.key                        front-proxy-client.key
apiserver.key                 etcd                          sa.key
apiserver-kubelet-client.crt  front-proxy-ca.crt            sa.pub
[root@master01 pki]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用apiserver信任的ca给tom用户签发证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 pki]# openssl x509 -req -in tom.csr -CA ./ca.crt -CAkey ./ca.key  -CAcreateserial -out tom.crt -days 365
Signature ok
subject=/CN=tom/O=myuser
Getting CA Private Key
[root@master01 pki]# ls
apiserver.crt                 apiserver-kubelet-client.key  front-proxy-ca.key      tom.crt
apiserver-etcd-client.crt     ca.crt                        front-proxy-client.crt  tom.csr
apiserver-etcd-client.key     ca.key                        front-proxy-client.key  tom.key
apiserver.key                 etcd                          sa.key
apiserver-kubelet-client.crt  front-proxy-ca.crt            sa.pub
[root@master01 pki]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里使用的CA必须要用apiserver信任的ca来签发证书，否则apiserver它不认；&lt;/p&gt;
&lt;p&gt;　　创建集群，指定对应ca的证书信息，集群名字以及集群的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config set-cluster myk8s --server=&quot;https://192.168.0.41:6443&quot; --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=true
Cluster &quot;myk8s&quot; set.
[root@master01 ~]# kubectl config get-clusters
NAME
myk8s
kubernetes
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：--embed-certs=ture表示隐藏证书信息；这里默认没有指定将配置信息保存在那个配置文件，默认就保存在当前配置文件（用户家目录的./kube/config文件中）；如果要想指定保存在某个配置文件中，可以在后面加上--kubeconfig选项来指定对应的配置文件即可；&lt;/p&gt;
&lt;p&gt;　　把创建集群的配置保存在/tmp/myk8s.config文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config set-cluster myk8s --server=&quot;https://192.168.0.41:6443&quot; --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=true --kubeconfig=/tmp/myk8s.config
Cluster &quot;myk8s&quot; set.
[root@master01 ~]# kubectl config get-clusters --kubeconfig=/tmp/myk8s.config
NAME
myk8s
[root@master01 ~]# cat /tmp/myk8s.config             
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJd01USXdPREEyTXpnMU5Gb1hEVE13TVRJd05qQTJNemcxTkZvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSzZXCjl5Mkc5YUxFc3h1Q3dNQllBbEdtRys5TG5nMU9OWm9aRDZDd2ZLUUY3Y3lHSStuN1BwSDJFT2o1K292WlBNWG0KckpNaVFHOXB2bVNDZC9FRkxod05YRWNOREZDbGF6Y0cvQ1B0QjlCRlQ1ZGdVMXJnMGxvRUxEVXduUk16eU43QwozRkdacW9maW9kMXJZaGhRaHpDc2N6a0w3dWJjcTBOS2NFQjY0OTB1N0hyeVZ5Y0pGSmwzR0ZKVnN0d0pYZkV1CmtVQ2s2bVlYNFFWb2NObHlKVWZLaWZUMFBZSVQwVVBqZWwvc2NrTnJIUjFFTU5sVXJOWXlHMkJ1cTFhSENhZ2oKRGNrUWh5dU44cTZqNERiSGwrS0pJUTNtN0dxL29vTzBSMm5LNFlKUVMyZjI4bkFhWkRlRWZZcDEwdmg0ditUQwpjaXI5RStmYm1EYWFUQXNsVGdrQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZMNVRSSG9QUGJDWk4vUFRVcjdCZGVidmdkMFRNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBQTRxa3prejNsTGFRYlQ3a0x3SnBoTXZnczJUdzU1b01VYWlzdlBJczVwSk1aZmNwNQpDcFdiRnc1VzR6R0RqWFBpRUExb3BvOEFEQzlXTERZem01eHV3V1ZQeWlWZzRmWjYxK3hISU9KMnlnQW4rWEo1CjRVUHMzYUl3RUJ3OHNPdTM4c1N0a29HNDJTY1gzTXR5cDRjRHJDakFGYnVrMUR5U3E5RytOWG9iL3FVdWxDWC8KSkdzSUJZd3pHVmVDSzVweVJDdHUwY0VRWkp4N1pQc2RhOXcwWXVBdGt5dFN3YkxVakU5MWpMNDV4blRHdllpMwo4eC9ocmJOYVBKUjVlNStpZlZqQVR1TDNHM3liNkduaVNsMGNBSDlNeEUzNE50MStwUFlOTmduVk9HdC9SZTdwClVubzVocXd4RTB2cmQxanU2YlVmVDZ6U0ozb1hpejI5Ri93RwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
    server: https://192.168.0.41:6443
  name: myk8s
contexts: null
current-context: &quot;&quot;
kind: Config
preferences: {}
users: null
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里的证书信息是一base64编码处理以后的信息；&lt;/p&gt;
&lt;p&gt;　　创建用户，指定对应用户名称，用户证书和私钥信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config set-credentials tom --client-certificate=/etc/kubernetes/pki/tom.crt --client-key=/etc/kubernetes/pki/tom.key --username=tom --embed-certs=true
User &quot;tom&quot; set.
[root@master01 ~]# kubectl config set-credentials tom --client-certificate=/etc/kubernetes/pki/tom.crt --client-key=/etc/kubernetes/pki/tom.key --username=tom --embed-certs=true --kubeconfig=/tmp/myk8s.config
User &quot;tom&quot; set.
[root@master01 ~]# kubectl config view --kubeconfig=/tmp/myk8s.config
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.0.41:6443
  name: myk8s
contexts: null
current-context: &quot;&quot;
kind: Config
preferences: {}
users:
- name: tom
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED
    username: tom
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：--username指定的名字尽量同证书中的CN名称相同，因为apiserver会把CN的信息识别为对应用户信息；这里补充一点，在k8s上没有真正的人类用户，它是把对应客户端的证书中的CN信息识别成对应操作该客户端的用户；只要对应的证书能够通过认证，不管对应操作者是谁，k8s并不关心；就像我们在使用Linux时，拿着root用户登录了系统，只要密码正确，Linux内核就认为是root在操作；这里的证书就好比Linuxroot的密码；&lt;/p&gt;
&lt;p&gt;　　创建context，把tom用户和myk8s集群做关联，并指定对应context的名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config set-context tom@myk8s --cluster=myk8s --user=tom
Context &quot;tom@myk8s&quot; created.
[root@master01 ~]# kubectl config set-context tom@myk8s --cluster=myk8s --user=tom --kubeconfig=/tmp/myk8s.config             
Context &quot;tom@myk8s&quot; created.
[root@master01 ~]# kubectl config view --kubeconfig=/tmp/myk8s.config                                          
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.0.41:6443
  name: myk8s
contexts:
- context:
    cluster: myk8s
    user: tom
  name: tom@myk8s
current-context: &quot;&quot;
kind: Config
preferences: {}
users:
- name: tom
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED
    username: tom
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：创建context尽量做到见名知意；一般都是使用用户名@集群名的格式为context命名；&lt;/p&gt;
&lt;p&gt;　　到此，对应tom用户的配置文件就做好了，我们在/tmp/myk8s.config文件中保存了对应新建的用户、集群、context信息，在当前配置文件中也保存了相应的配置信息；&lt;/p&gt;
&lt;p&gt;　　测试：在没有切换配置之前，查看集群运行在default名称空间运行的pod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config get-contexts
CURRENT   NAME                          CLUSTER      AUTHINFO           NAMESPACE
*         kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   
          tom@myk8s                     myk8s        tom                
[root@master01 ~]# kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   0          117m
web-0            1/1     Running   1          27h
web-1            1/1     Running   1          27h
web-2            1/1     Running   1          27h
web-3            1/1     Running   2          27h
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：当前配置还是用的kubernetes-admin@kubernetes这个context，查看default名称空间下的pod能够正常查询到；&lt;/p&gt;
&lt;p&gt;　　切换context到tom@myk8s context上，看看是否还能看到default名称空间下的pod 呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config use-context tom@myk8s   
Switched to context &quot;tom@myk8s&quot;.
[root@master01 ~]# kubectl config get-contexts         
CURRENT   NAME                          CLUSTER      AUTHINFO           NAMESPACE
          kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   
*         tom@myk8s                     myk8s        tom                
[root@master01 ~]# kubectl get pods
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到切换到tom@myk8s这个context后，再次查看default名称空间下pod列表就看不到；这里提示我们权限拒绝；其实看不到才是正常的，因为我们只是把tom用户接入到apiserver上进行认证，并没有给他授权，所以tom用户目前只是通过了验证，并没有对资源的操作权限，在权限验证时给拒绝了；&lt;/p&gt;
&lt;p&gt;　　使用/tmp/myk8s.config配置文件查看default名称空间下的pod列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config get-contexts --kubeconfig=/tmp/myk8s.config
CURRENT   NAME        CLUSTER   AUTHINFO   NAMESPACE
          tom@myk8s   myk8s     tom        
[root@master01 ~]# kubectl config use-context tom@myk8s --kubeconfig=/tmp/myk8s.config 
Switched to context &quot;tom@myk8s&quot;.
[root@master01 ~]# kubectl config get-contexts --kubeconfig=/tmp/myk8s.config         
CURRENT   NAME        CLUSTER   AUTHINFO   NAMESPACE
*         tom@myk8s   myk8s     tom        
[root@master01 ~]# kubectl get pods --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用/tmp/myk8s.config配置文件去apiserver上验证，也是一样的情况看不到pod，响应我们对应资源禁止访问；&lt;/p&gt;
&lt;p&gt;　　切回kubernetes-admin@kubernetes context再次查看default名称空间下的pod列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config use-context kubernetes-admin@kubernetes
Switched to context &quot;kubernetes-admin@kubernetes&quot;.
[root@master01 ~]# kubectl config get-contexts
CURRENT   NAME                          CLUSTER      AUTHINFO           NAMESPACE
*         kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   
          tom@myk8s                     myk8s        tom                
[root@master01 ~]# kubectl get pods
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   0          132m
web-0            1/1     Running   1          27h
web-1            1/1     Running   1          27h
web-2            1/1     Running   1          27h
web-3            1/1     Running   2          27h
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：切回kubernetes-admin@kubernetes context后，查看default名称空间下的pod列表，能够正常查看到，这是因为切换context以后，对应的用户认证在apiserver有查看对应资源的权限；&lt;/p&gt;
&lt;p&gt;　　创建一个sa账号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat sa-demo.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: sa-demo
  namespace: default
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：sa是k8s上的一个标准资源，其群组为v1，类型为ServiceAccount；其中metadata.name是用来指定sa账号的名称，namespace用来指定其名称空间信息；创建一个sa资源用户只需要定义对应的名称和名称空间就可以了；对应secret资源会自动创建并生成的对应的token信息；这样一来就意味着只要我们创建一个sa账号，在k8s上就能够被认证通过；因为创建sa它自动创建secret并将对应的token生成好；我们可以理解为创建secret并生成token的过程就是在把对应sa账号和对应token进行关联；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f sa-demo.yaml
serviceaccount/sa-demo created
[root@master01 ~]# kubectl get sa 
NAME      SECRETS   AGE
default   1         21d
sa-demo   1         5s
[root@master01 ~]# kubectl describe sa sa-demo
Name:                sa-demo
Namespace:           default
Labels:              &amp;lt;none&amp;gt;
Annotations:         &amp;lt;none&amp;gt;
Image pull secrets:  &amp;lt;none&amp;gt;
Mountable secrets:   sa-demo-token-8kjhc
Tokens:              sa-demo-token-8kjhc
Events:              &amp;lt;none&amp;gt;
[root@master01 ~]# kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-xvd4c            kubernetes.io/service-account-token   3      21d
docker-registry.io             kubernetes.io/dockerconfigjson        1      3d1h
mysql-auth                     Opaque                                2      3d
sa-demo-token-8kjhc            kubernetes.io/service-account-token   3      26s
test-secret-demo               Opaque                                2      2d23h
test-secret-demo1              Opaque                                2      2d23h
test-tls                       kubernetes.io/tls                     2      3d
www-myapp-com-ingress-secret   kubernetes.io/tls                     2      7d23h
[root@master01 ~]# kubectl describe secret sa-demo-token-8kjhc
Name:         sa-demo-token-8kjhc
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: sa-demo
              kubernetes.io/service-account.uid: 34cb62e8-23bd-4f2b-be82-4a8c9afc4037

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1066 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IjM4WnU0Z1Q1c0hBNmR5Q1V0ejRaMFk4d2J2WncwWjNiUTAxZk02SGN4OTgifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InNhLWRlbW8tdG9rZW4tOGtqaGMiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtZGVtbyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjM0Y2I2MmU4LTIzYmQtNGYyYi1iZTgyLTRhOGM5YWZjNDAzNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OnNhLWRlbW8ifQ.XyYaqpeZXexal1wr1aiBaZOelRJtlQ2drElDcvWIep1yj4TNYKhqsEUA11fzazStUahpLzuTMXGHMDG7AKA8MqBgBUxRW7UPNBxF7_radK4dfUxig_049Dp7nBYpPKl3sRyPfZcm_R0bXrnXfiMj7KEsfenx3_Skr7R0Wtc4asuVcLgYR1PGFMKbAqi_FDLlZYsledP74fGs3pGNnQ46LNaZ7-ZrsDuIOCxsaJ-QKR_zUQni8wmmKYzGmuVTRvSmlk79DCjMhmVJ6B-AOtXLc8N8yoZ35_ZtXc5VyBTdGTYtIE6x7O6kUlNMFZQLwYgRnUQJdwbfSEUAJXD4b7KMQw
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用资源清单以后，对应sa就成功被创建，同时查看sa的详细信息，它关联了一个secret资源，对应secret资源的详细信息中明确标注了对应sa用户名称为sa-demo；从上面反馈的信息我们不难理解，创建sa账号，它会自动创建一个secret，并且把对应的secret中的token与sa账号做绑定；这就意味着，我们只要拿着对应的token去apiserver认证，对应apiserver一定能够在etcd中查到对应的token绑定的sa账号；从而对应sa账号就能顺利的通过apiserver中的认证机制；&lt;/p&gt;
</description>
<pubDate>Tue, 29 Dec 2020 18:15:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了k8s的statefulset控制器相关使用说明，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/14201103.html；今天我们来聊一下k8</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14207381.html</dc:identifier>
</item>
<item>
<title>程序员你是如何使用镜像中心Harbor的？ - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/14209453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/14209453.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202012/268922-20201230000616833-218626247.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;harbor即docker的私服；管理公司内部输出的镜像制品；&lt;/p&gt;
&lt;p&gt;是VMware公司中国团队为企业用户设计的镜像注册服务器，用途：存储和分发docker镜像；&lt;/p&gt;
&lt;p&gt;在官方的docker registry服务中增加了安全，访问控制，审计，管理页面，发现，高可用等功能；&lt;/p&gt;

&lt;p&gt;找一台linux机器：提前安装好docker-compose;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载harbor安装包&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下载不下来可到csdn上找一个国内的资源下载；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;wget https://github.com/goharbor/harbor/releases/download/v2.1.2/harbor-offline-installer-v2.1.2.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;解压&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -xzvf harbor-offline-installer-v2.1.2.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vim harbor.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改:&lt;/p&gt;
&lt;p&gt;harbor_admin_password； 默认密码&lt;/p&gt;
&lt;p&gt;hostname：访问ip&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;启动harbor&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./install.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;查看容器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker ps
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;启停harbor,通过docker-compose的方式进行&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker-compose stop
docker-compose start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;harbor默认信任https协议，所以如果docker命令登录和推送镜像，需要添加 --insecure-registry到docker配置文件；&lt;/p&gt;
&lt;p&gt;修改配置方法：&lt;/p&gt;

&lt;p&gt;打开： &lt;a href=&quot;http://hostname/harbor&quot; target=&quot;_blank&quot;&gt;http://hostname/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;账号： admin&lt;/p&gt;
&lt;p&gt;密码: 你预设的管理员密码&lt;/p&gt;
&lt;p&gt;已经搭建好的harbor环境：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;docker登录注册中心&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker login  -u admin -password-stdin xxxx   xxx.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;本地docker镜像打tag：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker tag repox:tagName xxx.com/project/repox:tagName
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本地镜像推送：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker push  xxx.com/myproject/myrepo:mytag
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;远程获取镜像并运行；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先登录，然后直接从镜像中心获取镜像即可；&lt;/p&gt;
&lt;p&gt;见步骤1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull xxx.com/project/repox:tagName
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;基于docker和docker-compose来运行本地开发好的程序；&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本地作为ci的环境，制作镜像推送到harbor;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;远程服务器作为CD的环境，通过harbor拉取镜像来运行程序；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;扩展作为k8s的镜像仓库，支持k8s部署；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202012/268922-20201230000617163-562944413.png&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源码： &lt;a href=&quot;https://github.com/goharbor/harbor&quot; target=&quot;_blank&quot;&gt;https://github.com/goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网： &lt;a href=&quot;https://goharbor.io/&quot; target=&quot;_blank&quot;&gt;https://goharbor.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;harbor安装和使用： &lt;a href=&quot;https://www.toutiao.com/a6840826675383501320/&quot; target=&quot;_blank&quot;&gt;https://www.toutiao.com/a6840826675383501320/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创不易，关注诚可贵，转发价更高！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 29 Dec 2020 16:06:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>背景 harbor即docker的私服；管理公司内部输出的镜像制品； 是VMware公司中国团队为企业用户设计的镜像注册服务器，用途：存储和分发docker镜像； 在官方的docker registr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/14209453.html</dc:identifier>
</item>
<item>
<title>Gitlab Runner的分布式缓存实战 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14209386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14209386.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于本文&quot;&gt;关于本文&lt;/h3&gt;
&lt;p&gt;本文目标是为K8S环境的Gitlab Runner准备好分布式缓存，并在pipeline脚本中使用该缓存，因此，在阅读本文前建议您对GitLab CI有一定了解，最好是阅读过甚至编写过pipeline脚本；&lt;/p&gt;
&lt;h3 id=&quot;关于gitlab-runner&quot;&gt;关于GitLab Runner&lt;/h3&gt;
&lt;p&gt;如下图所示，开发者将代码提交到GitLab后，可以触发CI脚本在GitLab Runner上执行，通过编写CI脚本我们可以完成很多使用的功能：编译、构建、生成docker镜像、推送到私有仓库等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234505598-2116260564.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gitlab-runner的分布式缓存&quot;&gt;Gitlab Runner的分布式缓存&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;官方文档地址，有关缓存的详情可以参考此文：&lt;a href=&quot;https://docs.gitlab.com/runner/configuration/autoscale.html#distributed-runners-caching&quot; target=&quot;_blank&quot;&gt;https://docs.gitlab.com/runner/configuration/autoscale.html#distributed-runners-caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如下是官方的分布式缓存示例(config.toml 文件)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[[runners]]
  limit = 10
  executor = &quot;docker+machine&quot;
  [runners.cache]
    Type = &quot;s3&quot;
    Path = &quot;path/to/prefix&quot;
    Shared = false
    [runners.cache.s3]
      ServerAddress = &quot;s3.example.com&quot;
      AccessKey = &quot;access-key&quot;
      SecretKey = &quot;secret-key&quot;
      BucketName = &quot;runner&quot;
      Insecure = false
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;接下来通过实战完成分布式缓存配置；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境和版本信息&quot;&gt;环境和版本信息&lt;/h3&gt;
&lt;p&gt;本次实战涉及到多个服务，下面给出它们的版本信息供您参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GitLab：Community Edition 13.0.6&lt;/li&gt;
&lt;li&gt;GilLab Runner：13.1.0&lt;/li&gt;
&lt;li&gt;kubernetes：1.15.3&lt;/li&gt;
&lt;li&gt;Harbor：1.1.3&lt;/li&gt;
&lt;li&gt;Minio：2020-06-18T02:23:35Z&lt;/li&gt;
&lt;li&gt;Helm：2.16.1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;部署分布式缓存&quot;&gt;部署分布式缓存&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;minio是兼用S3的分布式缓存，也是官方推荐使用的，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234505894-1202508441.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;minio作为一个独立的服务部署，我将用docker部署在服务器：&lt;span&gt;192.168.50.43&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在服务器上准备两个目录，分别存储minio的配置和文件，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; mkdir -p /var/services/homes/zq2599/minio/config \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/config
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;执行docker命令创建minio服务，指定服务端口是9000，并且指定了access key(最短三位)和secret key(最短八位)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker run -p 9000:9000 --name minio \
-d --restart=always \
-e &quot;MINIO_ACCESS_KEY=access&quot; \
-e &quot;MINIO_SECRET_KEY=secret123456&quot; \
-v /var/services/homes/zq2599/minio/gitlab_runner:/gitlab_runner \
-v /var/services/homes/zq2599/minio/config:/root/.minio \
minio/minio server /gitlab_runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;浏览器访问，输入access key和secret key后登录成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234506359-1361573367.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，点击红框中的图标，创建一个bucket，名为runner：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234506679-1244729008.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;至此，minio已备好，接下来在GitLab Runner上配置；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;gitlab-runner上配置缓存&quot;&gt;GitLab Runner上配置缓存&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;我这里是用helm部署的GitLab Runner，因此修改的是helm的value配置，如果您没有用helm，可以参考接下来的操作直接去配置&lt;span&gt;config.toml&lt;/span&gt;文件；&lt;/li&gt;
&lt;li&gt;helm下载了&lt;span&gt;GitLab Runner&lt;/span&gt;的包后，解开可见配置信息如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234510559-1339990107.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 打开&lt;span&gt;values.yaml&lt;/span&gt;，找到cache的配置，当前cache的配置如下图，可见值为空内容的大括号，其余信息全部被注释了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234511530-2131422184.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 修改后的cache配置如下图，红框1中原先的大括号已去掉，红框2中的是去掉了注释符号，内容不变，红框3中填写的是minio的访问地址，红框4中的是去掉了注释符号，内容不变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234512306-430415507.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 上图红框4中的&lt;span&gt;s3CacheInsecure&lt;/span&gt;参数等于&lt;span&gt;false&lt;/span&gt;表示对minio的请求为http(如果是true就是https)，但实际证明，&lt;span&gt;当前版本的chart中该配置是无效的&lt;/span&gt;，等到运行时还是会以https协议访问，解决此问题的方法是修改templates目录下的_cache.tpl文件，打开此文件，找到下图红框中的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234513001-345901984.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6. 将上图红框中的内容替换成下面红框中的样子，即删除原先的if判断和对应的end这两行，直接给CACHE_S3_INSECURE赋值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234513975-1667451224.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;7. 以上只是cache相关的配置，helm部署GitLab Runner的其他设置还请自行处理，所有设置完成后回到values.yam所在目录，执行以下命令即可创建GitLab Runner：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm install \
--name-template gitlab-runner \
-f values.yaml . \
--namespace gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;配置完毕，启动Riglab Runner成功后，一起来验证一下；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在GitLab仓库中，增加名为.gitlab-ci.yml的文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 设置执行镜像
image: busybox:latest

# 整个pipeline有两个stage
stages:
- build
- test

# 定义全局缓存，缓存的key来自分支信息，缓存位置是vendor文件夹
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
  - vendor/

before_script:
  - echo &quot;Before script section&quot;

after_script:
  - echo &quot;After script section&quot;

build1:
  stage: build
    tags:
  - k8s
  script:
    - echo &quot;将内容写入缓存&quot;
    - echo &quot;build&quot; &amp;gt; vendor/hello.txt

test1:
  stage: test
  script:
    - echo &quot;从缓存读取内容&quot;
    - cat vendor/hello.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;提交上述脚本到GitLab，如下图，可见pipeline会被触发，状态为pending是因为正在等待runner创建executor pod：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234514524-576525885.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;稍后就会执行成功，点开看结果：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234516378-1664829661.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 点开build1的图标，可见此job的输出信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234518034-464627937.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 点开test1的图标，可见对应的控制台输出，上一个job写入的数据被成功读取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201229234519978-210448719.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;至此，可见分布式缓存已经生效，在多台机器的环境中也可以使用pipeline语法的缓存功能了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 29 Dec 2020 15:45:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14209386.html</dc:identifier>
</item>
</channel>
</rss>