<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Xamarin.Forms 5.0 来了 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/14270227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/14270227.html</guid>
<description>&lt;p&gt;Xamarin.Forms 5.0 已经正式发布，并带来其新功能，具体看官方博客&lt;a title=&quot;https://devblogs.microsoft.com/xamarin/xamarin-forms-5-0-is-here/&quot; href=&quot;https://devblogs.microsoft.com/xamarin/xamarin-forms-5-0-is-here/&quot;&gt;https://devblogs.microsoft.com/xamarin/xamarin-forms-5-0-is-here/&lt;/a&gt;。 在很大程度上，它是关于稳定版本功能的正式发布的，这些功能已在实验版本中获得使用，但现在正是机会回顾一下并了解其进步之处。 Xamarin.Forms过去一年一直在这样做。 很多功能都在&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/14057665.html&quot;&gt;Xamarin.Form 5.0： 新功能和控件以及调试改进&lt;/a&gt; 进行了介绍。&lt;/p&gt;
&lt;p&gt;Xamarin.Forms 5.0 的补齐了最后一个弱点，创建矢量形状，渐变或复杂路径不再需要任何第三方库。视觉元素可以根据任何几何形状进行切割，从而为现代而精美的设计打开了大门。这一切都要感谢&lt;a href=&quot;https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/brushes/&quot;&gt;&lt;code&gt;Brush&lt;/code&gt;&lt;/a&gt;，&lt;a href=&quot;https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/shapes/&quot;&gt;&lt;code&gt;Shape&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/shapes/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;到现在为止，我们可以通过组合现有的Xamarin.Forms控件或通过从头开始创建一个新控件来创建新控件，也就是说，每个平台从头开始有针对性的编写一个版本。Xamarin.Forms 5.0 大量的特定于平台的代码，这些代码将消失，不再使用通用代码。大大减少了开发，维护和错误修复时间！这是迈向100％跨平台Xamarin.Forms的第一步，也是迈向&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/&quot;&gt;MAUI的&lt;/a&gt;第一步。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/release-notes/5.0/5.0.0&quot; href=&quot;https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/release-notes/5.0/5.0.0&quot;&gt;Xamarin.Forms 5.0的完整变更日志&lt;/a&gt; 有具体说明，同时David Ortinau和James Montemagno在视频中展示了所有这些内容：&lt;/p&gt;

</description>
<pubDate>Wed, 13 Jan 2021 00:28:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>Xamarin.Forms 5.0 已经正式发布，并带来其新功能，具体看官方博客https://devblogs.microsoft.com/xamarin/xamarin-forms-5-0-is-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/14270227.html</dc:identifier>
</item>
<item>
<title>2020年工作上的最大收获——监控告警体系 - 老於`</title>
<link>http://www.cnblogs.com/hunternet/p/14270218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/14270218.html</guid>
<description>&lt;h3 id=&quot;1-背景&quot;&gt;1 背景&lt;/h3&gt;
&lt;p&gt;2020年工作上的最大收获就是初步完善了系统的监控告警体系。&lt;br/&gt;2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产故障按在地上摩擦。可怜还因疫情原因公司福利大大缩减。&lt;br/&gt;总结了一下令人头疼的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每次大的发布总会产生一堆的生产问题&lt;/li&gt;
&lt;li&gt;日常应用出错不能第一时间感知，总是到了客户那里才报过来&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如有一次发布后产生了一个小小的传值问题，但是会阻碍一部分客户下单，结果两天后通过客户报障才发现，最终导致大量订单损失！&lt;br/&gt;总体来讲就是缺乏对系统的掌控，应用发布上去后，就像个黑匣子，你只知道它在运行，却不知道里面到底是个什么状况，也许内部已经乱的不可开交,你却一无所知，发布之后只留下一脸懵逼的你独自凌乱。以致于每次发布后的几天都是提心吊胆，有点风吹草动就慌得一比！而在互联网这个频繁发布的行业简直就是灾难&lt;br/&gt;痛定思痛！终于在下半年的时候忍无可忍，决定给系统插上X光机。不仅要扒掉系统这个“美女”的黑色外衣，甚至让其骨骼线条都赤裸裸的暴露在开发人员眼中。这个X光机就是监控告警体系。&lt;/p&gt;
&lt;h3 id=&quot;2-技术方案&quot;&gt;2 技术方案&lt;/h3&gt;
&lt;p&gt;我们所使用的是公司自研的监控系统。其大致实现如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610016490223-213e566b-6127-42fa-8dc1-904858d5cbf4.png#align=left&amp;amp;display=inline&amp;amp;height=459&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=459&amp;amp;originWidth=861&amp;amp;size=80822&amp;amp;status=done&amp;amp;style=none&amp;amp;width=861&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;各应用系统通过代理客户端写入Kafka&lt;/li&gt;
&lt;li&gt;持久化层服务订阅Kafka消息进行持久化，这其中Influxdb主要存储时序埋点，MySql与ES存储点的一些特性方便检索与聚合&lt;/li&gt;
&lt;li&gt;UI层读取展示埋点信息，监控告警配置，主要借助两个强大的可视化工具，Graphana与Kibana。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实现监控告警体系其实就分3步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用系统埋点&lt;/li&gt;
&lt;li&gt;可视化展示&lt;/li&gt;
&lt;li&gt;监控告警配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最简单的方式可以通过 ES+Kibana的方案来实现&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610017130202-4bb10e63-96cc-4e9e-9951-21c1a1192ca6.png#align=left&amp;amp;display=inline&amp;amp;height=188&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=188&amp;amp;originWidth=858&amp;amp;size=15663&amp;amp;status=done&amp;amp;style=none&amp;amp;width=858&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;注意;在系统没有遇到瓶颈的时候应该尽可能的用最简单的方案解决问题，每引入一个中间件便大大增加了系统的复杂度和维护成本&lt;/p&gt;
&lt;h3 id=&quot;3-监控内容&quot;&gt;3 监控内容&lt;/h3&gt;
&lt;p&gt;技术上的实现，其实只是监控体系的第一步。最重要的部分在于监控的内容，只有做好了监控内容才算是给你的系统构建了一个良好的监控大网。而监控哪些内容，不同的系统，不同的业务需求都不相同，这就需要根据业务与系统的要求去制定与不断的完善。&lt;br/&gt;根据我们的经验总结了几个通用的监控点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请求量不仅可以用来统计接口调用的数量、QPS等信息，还可以发现系统的问题。&lt;br/&gt;这里请求量主要包含两部分，一个是你自己提供的接口的请求量，一部分是你所依赖接口的请求量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你自己提供的接口的请求量突然下降，那么说明依赖你接口的下游应用、或是前置页面极有可能除了问题。&lt;/li&gt;
&lt;li&gt;而如果你自己接口的请求量正常，而所调用的第三方接口的请求量突然下降，那么极有可能你自己的代码逻辑除了问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610018671344-96acd1ec-184f-49a4-af40-e12ceb3ef666.png#align=left&amp;amp;display=inline&amp;amp;height=302&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=302&amp;amp;originWidth=891&amp;amp;size=49898&amp;amp;status=done&amp;amp;style=none&amp;amp;width=891&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;请求量一般通过曲线图展示，可以更好的反映出来一个趋势。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;响应量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;响应量通常可以和请求量结合使用，如果一个接口正常响应量小于请求量，那么说明有一部分的请求是存在问题的。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610018889617-2fcc11d9-864c-4179-9c1c-60cad7f192a9.png#align=left&amp;amp;display=inline&amp;amp;height=259&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=312&amp;amp;originWidth=889&amp;amp;size=50224&amp;amp;status=done&amp;amp;style=none&amp;amp;width=739&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;耗时&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接口耗时主要用来监控接口性能，同样包括你自己提供的接口的耗时和你所依赖的接口耗时。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610019154215-6b9f6f3b-d302-4d23-8220-68228c561563.png#align=left&amp;amp;display=inline&amp;amp;height=312&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=312&amp;amp;originWidth=880&amp;amp;size=49026&amp;amp;status=done&amp;amp;style=none&amp;amp;width=880&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;订单量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在许多系统中，订单量都是一个很重要的业务指标，也是我们最重要的监控指标之一。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;响应状态&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;响应状态是一个很好的监控指标，它能够很好的反映我们程序的处理结果。响应状态比较适合用饼图来展示。可以很好的反映出各种状态的占比。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/479376/1610019374339-eecf31f9-1a2d-4aba-b34f-0e39450dc57e.png#align=left&amp;amp;display=inline&amp;amp;height=285&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=285&amp;amp;originWidth=875&amp;amp;size=25642&amp;amp;status=done&amp;amp;style=none&amp;amp;width=875&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;异常状态&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同响应状态一样，异常状态的监控也具有很重要的意义。同时异常状态也是我们用户告警的重要指标之一，他可以很直观的反映出我们系统的健康状态，异常状态可以用饼图，也可以用曲线图来展示。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;页面之间转化率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;页面之间转化率不仅仅是用户衡量产品价值的指标，同样是我们系统监控的重要指标，如果从一个页面到另一个页面的转化率突然降低，那么极有可能是这之间出现了什么问题。&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;其它&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有很多针对具体业务的监控指标，如搜索通常会有空搜率，商品会有缺货率。。。&lt;br/&gt;当然，可能还有很多不足，也可能随着业务需求的变化，有些监控内容可能已经过时，又可能会需要更多监控，&lt;br/&gt;这里只提供一些思路，总之针对业务上的各种场景你可以尽情去做到一切皆埋点。&lt;/p&gt;
&lt;h3 id=&quot;4-告警策略&quot;&gt;4 告警策略&lt;/h3&gt;
&lt;p&gt;监控内容最好之后，监控体系并没有结束，还差一步，就是自动告警。自动告警的功能Grafana和Kibana都可以提供，也可以自定义我们想要的告警方式。&lt;br/&gt;这里我们主要的告警策略主要有三种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阈值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以对请求量、订单量、异常量设定一个阈值，当每分钟每小时请求量下降到某个阈值，或者异常量达到某个阈值的时候，触发我们的告警。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;环比&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;环比主要是与前一段时间的对比，比如这一小时(或一天)的请求量与上一小时(或一天)的请求量对比，如果小于如果小于某个阈值，就触发我们的告警。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;同比&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有些时候环比是不可靠的，比如，我们系统的特性就是周二、周三、周四的请求量要远大于周五、周六、周天的请求量，此时如果拿周六的请求量和周五的请求量的去对比是没有意义的，这里就需要用到同比，即拿上周五的请求量和本周五的请求量进行对比，当小于某个阈值的时候触发告警。&lt;br/&gt;&lt;strong&gt;注意:这里的告警和阈值并非可以一蹴而就的，需要结合实际去慢慢调整它到一个合适的值，我们就深感其痛。(起初就因为一些不合理的告警配置，我们优秀的人工智能经常三更半夜给打你电话，结果通常是虚惊一场，它还比较轴，你不处理它就一直打)。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-监控成果&quot;&gt;5 监控成果&lt;/h3&gt;
&lt;p&gt;历时半年，我们对系统的监控告警体系的打造总算是告一段落。俗话说要想吃多少肉，就要先挨多少揍。这期间过程虽然是辛苦的，但成果也是巨大的。之前的问题得到了良好的解决。大部分的线上问题，第一时间就暴露了出来，有些问题在测试环境上通过监控就提早发现。这也侧面的助力我们的测试工作。甚至在监控体系上线后一些“陈年”老bug也开始暴露出来。生产事件率大幅下降。&lt;br/&gt;最重要的是每个开发人员对系统多了一种掌控的感觉，期待有一天，一群苦逼了许久的程序员可以在今后的每次发布后，轻松看着监控大盘，喝茶扯淡！&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 00:16:00 +0000</pubDate>
<dc:creator>老於`</dc:creator>
<og:description>1 背景 2020年工作上的最大收获就是初步完善了系统的监控告警体系。 2020年工作上可谓是非常苦逼的，项目上忙到脚打后脑勺的同时还被各种发布问题、生产故障按在地上摩擦。可怜还因疫情原因公司福利大大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/14270218.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之七：patch操作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14270204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14270204.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《Kubernetes官方java客户端》系列的第七篇，以下提到的&lt;span&gt;java客户端&lt;/span&gt;都是指&lt;span&gt;client-jar.jar&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;本文主要内容是通过java客户端发起patch请求，用来修改已有资源;&lt;/li&gt;
&lt;li&gt;接下来会对kubernetes的patch做一些介绍，由于咱们这里的&lt;span&gt;重点还是java客户端的patch操作&lt;/span&gt;，因此不会对patch的原理和概念展开太多，仅做最基本的说明能即可；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本文内容&quot;&gt;本文内容&lt;/h3&gt;
&lt;p&gt;这是篇万字长文，所以一开始就要明确本文的核心内容：开发一个SpringBoot应用并部署在kubernetes环境，这个应用通过kubernetes的java客户端向API Server发请求，请求内容包括：创建名为&lt;span&gt;test123&lt;/span&gt;的deployment、对这个deployment进行patch操作，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075543245-1254844652.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来先了解一些kubernetes的patch相关的基本知识；&lt;/p&gt;
&lt;h3 id=&quot;关于patch&quot;&gt;关于patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;是对各种资源的增删改查是kubernetes的基本操作；&lt;/li&gt;
&lt;li&gt;对于修改操作，分为&lt;span&gt;Replace&lt;/span&gt;和&lt;span&gt;Patch&lt;/span&gt;两种；&lt;/li&gt;
&lt;li&gt;Replace好理解，就是用指定资源替换现有资源，replace有个特点，就是optimistic lock约束（类似与转账操作，先读再计算再写入）；&lt;/li&gt;
&lt;li&gt;Patch用来对资源做局部更新，没有optimistic lock约束，总是最后的请求会生效，因此如果您只打算修改局部信息，例如某个属性，只要指定属性去做patch即可（如果用Replace，就只能先取得整个资源，在本地修改指定属性，再用Replace整体替换）；&lt;/li&gt;
&lt;li&gt;更详细的信息请参考下图，来自官方文档，地址：&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075543878-233291855.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;patch的四种类型&quot;&gt;patch的四种类型&lt;/h3&gt;
&lt;p&gt;kubernetes的patch一共有四种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;json patch：在请求中指定操作类型，例如：add、replace，再指定json内容进行操作z，请参考：&lt;a href=&quot;https://tools.ietf.org/html/rfc6902&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc6902&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;merge patch：合并操作，可以提交整个资源的信息，与现有信息进行合并后生效，也可以提交部分信息用于替换，请参考：&lt;a href=&quot;https://tools.ietf.org/html/rfc7386&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc7386&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;strategic merge patch：json patch和merge patch都遵守rfc标准，但是strategic merge patch却是kubernetes独有的，官方中文文档中称为&lt;span&gt;策略性合并&lt;/span&gt;，也是merge的一种，但是真正执行时kubernetes会做合并还是替换是和具体的资源定义相关的（具体策略由 Kubernetes 源代码中字段标记中的 patchStrategy 键的值指定），以Pod的Container为例，下面是其源码，红框中显示其Container节点的patchStrategy属性是merge，也就是说如果您提交了一份strategic merge patch，里面的内容是关于Pod的Container的，那么原有的Container不会被替换，而是合并(例如以前只有nginx，提交的strategic merge patch是redis，那么最终pod下会有两个container：nginx和redis)：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075544660-1463953377.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;通过源码查看资源的&lt;span&gt;patchStrategy&lt;/span&gt;属性是很麻烦的事情，因此也可以通过Kubernetes API 文档来查看，如下图，地址是：&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core&quot; target=&quot;_blank&quot;&gt;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075545836-1834303446.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;第四种是apply patch：主要是指kubernetes 1.14版本开始的server-side apply，由APIServer 做 diff 和 merge 操作，很多原本易碎的现象都得到了解决(例如controller和kubectl都在更新)，另外要格外注意的是：1.14版本默认是不开启server-side apply特性的，具体的开启操作在下面会详细讲解；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;以上是对kubernetes四种patch的简介，讲得很浅，如果您想深入了解每种patch，建议参阅官方资料，接下来咱们聚焦java客户端对这些patch能力的实现；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075546279-772666828.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战步骤概述&quot;&gt;实战步骤概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接下来会创建一个springboot工程(该工程是&lt;span&gt;kubernetesclient&lt;/span&gt;的子工程)，针对四种patch咱们都有对应的操作；&lt;/li&gt;
&lt;li&gt;每种patch都会准备对应的json文件，提前将这些文件的内容保存在字符串变量中，在程序里用kubernetes客户端的patch专用API，将此json字符串发送出去，流程简图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075546974-681897421.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;编码完成后，就来动手验证功能，具体操作如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;部署名为&lt;span&gt;patch&lt;/span&gt;的deployment，这里面是咱们编码的SpringBoot工程，提供多个web接口；&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;span&gt;/patch/deploy&lt;/span&gt;接口，就会创建名为&lt;span&gt;test123&lt;/span&gt;的deployment，这个deployment里面是个nginx，接下来的patch操作都是针对这个名为test123的deployment；&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;span&gt;test123&lt;/span&gt;的nginx服务，确保部署成功了；&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;span&gt;/patch/json&lt;/span&gt;接口，该接口会修改test123的一个属性：&lt;span&gt;terminationGracePeriodSeconds&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;span&gt;/patch/fullmerge&lt;/span&gt;接口，该接口会提交全量merge请求，修改内容很少，仅增加了一个label属性；&lt;/li&gt;
&lt;li&gt;接下来是对比merge patch和strategic merge patch区别，分别访问&lt;span&gt;/patch/partmerge&lt;/span&gt;和&lt;span&gt;/patch/strategic&lt;/span&gt;这两个接口，其实它们操作的是同一段patch内容(一个新的container)，结果merge patch会替换原有的continer，而strategic merge patch不会动原有的container，而是新增container，导致test123这个deployment下面的pod从一个变为两个；&lt;/li&gt;
&lt;li&gt;最后是apply yaml patch，访问接口&lt;span&gt;/patch/apply&lt;/span&gt;，会将nginx容器的标签从&lt;span&gt;1.18.0&lt;/span&gt;改为&lt;span&gt;1.19.1&lt;/span&gt;，咱们只要在浏览器访问test123里面的nginx服务就能确定是否修改生效了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;准备工作包括创建工程、编写辅助功能代码、初始化代码等：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/107480015&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之一：准备 》&lt;/a&gt;一文创建的项目&lt;span&gt;kubernetesclient&lt;/span&gt;，新增名为&lt;span&gt;patch&lt;/span&gt;的子工程，pom.xml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;patch&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;patch&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;patch demo&amp;lt;/description&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-json&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;!--该配置会在jar中增加layer描述文件，以及提取layer的工具--&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;layers&amp;gt;
                        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
                    &amp;lt;/layers&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;编写一个辅助类&lt;span&gt;ClassPathResourceReader.java&lt;/span&gt;，作用是读取json文件的内容作为字符串返回：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.patch;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.stream.Collectors;
import org.springframework.core.io.ClassPathResource;

public class ClassPathResourceReader {

    private final String path;

    private String content;

    public ClassPathResourceReader(String path) {
        this.path = path;
    }

    public String getContent() {
        if (content == null) {
            try {
                ClassPathResource resource = new ClassPathResource(path);
                BufferedReader reader = new BufferedReader(new InputStreamReader(resource.getInputStream()));
                content = reader.lines().collect(Collectors.joining(&quot;\n&quot;));
                reader.close();
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }
        return content;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;接下来新建本篇文章的核心类&lt;span&gt;PatchExample.java&lt;/span&gt;，首先这个类中有main方法，整个应用从这里启动：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
        SpringApplication.run(PatchExample.class, args);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;接下来有两个常量定义，分别是kubernetes环境里用来测试的deployment名称，以及namespace名称：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static String DEPLOYMENT_NAME = &quot;test123&quot;;

static String NAMESPACE = &quot;default&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;然后定义几个字符串变量，执行patch操作时用到的json内容都保存到这些字符串变量中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;static String deployStr, jsonStr, mergeStr, strategicStr, applyYamlStr;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;在&lt;span&gt;resources&lt;/span&gt;文件夹中放入json文件，稍后的初始化代码会将这些文件读取到字符串变量中，如下图，这些json文件的内容稍后会详细说明：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075548552-862877937.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;编写初始化代码(通过&lt;span&gt;PostConstruct&lt;/span&gt;注解实现)，主要是客户端配置，还有将json文件的内容读出来，保存到刚刚准备的字符串变量中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostConstruct
    private void init() throws IOException {
        // 设置api配置
        ApiClient client = Config.defaultClient();
        Configuration.setDefaultApiClient(client);
        // 设置超时时间
        Configuration.getDefaultApiClient().setConnectTimeout(30000);

        // 部署用的JSON字符串
        deployStr = new ClassPathResourceReader(&quot;deploy.json&quot;).getContent();

        // json patch用的JSON字符串
        jsonStr = new ClassPathResourceReader(&quot;json.json&quot;).getContent();

        // merge patch用的JSON字符串，和部署的JSON相比：replicas从1变成2，增加一个名为from的label，值为merge
        mergeStr = new ClassPathResourceReader(&quot;merge.json&quot;).getContent();

        // strategic merge patch用的JSON字符串
        strategicStr = new ClassPathResourceReader(&quot;strategic.json&quot;).getContent();

        // server side apply用的JSON字符串
        applyYamlStr = new ClassPathResourceReader(&quot;applyYaml.json&quot;).getContent();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以上就是准备工作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建服务&quot;&gt;创建服务&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先要开发一个部署的接口，通过调用此接口可以在kubernetes环境部署一个deployment：&lt;/li&gt;
&lt;li&gt;部署服务的path是&lt;span&gt;/patch/deploy&lt;/span&gt;，代码如下，可见部署deployment的代码分为三步：创建api实例、用字符串创建body实例、把body传给api即可：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * 通用patch方法
     * @param patchFormat patch类型，一共有四种
     * @param deploymentName deployment的名称
     * @param namespace namespace名称
     * @param jsonStr patch的json内容
     * @param fieldManager server side apply用到
     * @param force server side apply要设置为true
     * @return patch结果对象转成的字符串
     * @throws Exception
     */
    private String patch(String patchFormat, String deploymentName, String namespace, String jsonStr, String fieldManager, Boolean force) throws Exception {
        // 创建api对象，指定格式是patchFormat
        ApiClient patchClient = ClientBuilder
                .standard()
                .setOverridePatchFormat(patchFormat)
                .build();

        log.info(&quot;start deploy : &quot; + patchFormat);

        // 开启debug便于调试，生产环境慎用！！！
        patchClient.setDebugging(true);

        // 创建deployment
        ExtensionsV1beta1Deployment deployment = new ExtensionsV1beta1Api(patchClient)
                .patchNamespacedDeployment(
                        deploymentName,
                        namespace,
                        new V1Patch(jsonStr),
                        null,
                        null,
                        fieldManager,
                        force
                );

        log.info(&quot;end deploy : &quot; + patchFormat);

        return new GsonBuilder().setPrettyPrinting().create().toJson(deployment);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;body实例用到的json字符串来自deploy.json文件，内容如下，很简单，只有nginx的1.18.0版本的pod：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;kind&quot;:&quot;Deployment&quot;,
  &quot;apiVersion&quot;:&quot;extensions/v1beta1&quot;,
  &quot;metadata&quot;:{
    &quot;name&quot;:&quot;test123&quot;,
    &quot;labels&quot;:{
      &quot;run&quot;:&quot;test123&quot;
    }
  },
  &quot;spec&quot;:{
    &quot;replicas&quot;:1,
    &quot;selector&quot;:{
      &quot;matchLabels&quot;:{
        &quot;run&quot;:&quot;test123&quot;
      }
    },
    &quot;template&quot;:{
      &quot;metadata&quot;:{
        &quot;creationTimestamp&quot;:null,
        &quot;labels&quot;:{
          &quot;run&quot;:&quot;test123&quot;
        }
      },
      &quot;spec&quot;:{
        &quot;terminationGracePeriodSeconds&quot;:30,
        &quot;containers&quot;:[
          {
            &quot;name&quot;:&quot;test123&quot;,
            &quot;image&quot;:&quot;nginx:1.18.0&quot;,
            &quot;ports&quot;:[
              {
                &quot;containerPort&quot;:80
              }
            ],
            &quot;resources&quot;:{

            }
          }
        ]
      }
    },
    &quot;strategy&quot;:{

    }
  },
  &quot;status&quot;:{

  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;如此一来，web浏览器只要访问&lt;span&gt;/patch/deploy&lt;/span&gt;就能创建deployment了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;发起patch请求的通用方法&quot;&gt;发起patch请求的通用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过kubernetes的客户端发起不同的patch请求，其大致步骤都是相同的，只是参数有所不同，我这里做了个私有方法，发起几种patch请求的操作都调用此方法实现(只是入参不同而已)，可见都是先建好ApiClient实例，将patch类型传入，再创建V1Patch实例，将patch字符串传入，最后执行ExtensionsV1beta1Api实例的patchNamespacedDeployment方法即可发送patch请求：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * 通用patch方法
     * @param patchFormat patch类型，一共有四种
     * @param deploymentName deployment的名称
     * @param namespace namespace名称
     * @param jsonStr patch的json内容
     * @param fieldManager server side apply用到
     * @param force server side apply要设置为true
     * @return patch结果对象转成的字符串
     * @throws Exception
     */
    private String patch(String patchFormat, String deploymentName, String namespace, String jsonStr, String fieldManager, Boolean force) throws Exception {
        // 创建api对象，指定格式是patchFormat
        ApiClient patchClient = ClientBuilder
                .standard()
                .setOverridePatchFormat(patchFormat)
                .build();

        log.info(&quot;start deploy : &quot; + patchFormat);

        // 开启debug便于调试，生产环境慎用！！！
        patchClient.setDebugging(true);

        // 创建deployment
        ExtensionsV1beta1Deployment deployment = new ExtensionsV1beta1Api(patchClient)
                .patchNamespacedDeployment(
                        deploymentName,
                        namespace,
                        new V1Patch(jsonStr),
                        null,
                        null,
                        fieldManager,
                        force
                );

        log.info(&quot;end deploy : &quot; + patchFormat);

        return new GsonBuilder().setPrettyPrinting().create().toJson(deployment);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上述代码中，有一行代码要格外重视，就是&lt;span&gt;patchClient.setDebugging(true)&lt;/span&gt;这段，执行了这一行，在log日志中就会将http的请求和响应全部打印出来，是我们调试的利器，但是日志内容过多，生产环境请慎用；&lt;/li&gt;
&lt;li&gt;上述patch方法有六个入参，其实除了patch类型和patch内容，其他参数都可以固定下来，于是再做个简化版的&lt;span&gt;patch&lt;/span&gt;方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * 通用patch方法，fieldManager和force都默认为空
     * @param patchFormat patch类型，一共有四种
     * @param jsonStr patch的json内容
     * @return patch结果对象转成的字符串
     * @throws Exception
     */
    private String patch(String patchFormat, String jsonStr) throws Exception {
        return patch(patchFormat,  DEPLOYMENT_NAME, NAMESPACE, jsonStr, null, null);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;入参patchFormat的值是四种patch类型的定义，在V1Patch.java中，其值如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075549425-1809932043.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来可以轻松的开发各种类型patch的代码了；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;执行json-patch&quot;&gt;执行json patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先来看json patch要提交的内容，即&lt;span&gt;json.json&lt;/span&gt;文件的内容，这些内容在应用启动时被保存到变量&lt;span&gt;jsonStr&lt;/span&gt;，如下所示，非常简单，修改了&lt;span&gt;terminationGracePeriodSeconds&lt;/span&gt;属性的值，原来是30，这个属性在停止pod的时候用到，是等待pod的主进程的最长时间：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
  {
    &quot;op&quot;:&quot;replace&quot;,
    &quot;path&quot;:&quot;/spec/template/spec/terminationGracePeriodSeconds&quot;,
    &quot;value&quot;:27
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;接下来就是web接口的代码，可见非常简单，仅需调用前面准备好的&lt;span&gt;patch&lt;/span&gt;方法：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * JSON patch格式的关系
     *
     * @return
     * @throws Exception
     */
    @RequestMapping(value = &quot;/patch/json&quot;, method = RequestMethod.GET)
    public String json() throws Exception {
        return patch(V1Patch.PATCH_FORMAT_JSON_PATCH, jsonStr);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;merge-patch（全量）&quot;&gt;merge patch（全量）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先尝试全量的merge patch，也就是准备好完整的deployment内容，修改其中一部分后进行提交，下图是json文件merge.json的内容，其内容前面的deploy.json相比，仅增加了红框处的内容，即增加了一个label：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075550293-915272359.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;代码依然很简单：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(value = &quot;/patch/fullmerge&quot;, method = RequestMethod.GET)
    public String fullmerge() throws Exception {
        return patch(V1Patch.PATCH_FORMAT_JSON_MERGE_PATCH, mergeStr);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;merge-patch（增量）&quot;&gt;merge patch（增量）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;前面曾提到merge patch和strategic merge patch的区别：merge patch提交一个container时做的是替换，而strategic merge patch提交一个container时做的是合并，为了展示这两种patch的不同，这里我们就用同一个json内容，分别执行merge patch和strategic merge patch，看看结果有什么区别，这是最直观的学习方法；&lt;/li&gt;
&lt;li&gt;这个json对应的文件是&lt;span&gt;strategic.json&lt;/span&gt;，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;spec&quot;:{
    &quot;template&quot;:{
      &quot;spec&quot;:{
        &quot;containers&quot;:[
          {
            &quot;name&quot;:&quot;test456&quot;,
            &quot;image&quot;:&quot;tomcat:7.0.105-jdk8&quot;
          }
        ]
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;增量merge的代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(value = &quot;/patch/partmerge&quot;, method = RequestMethod.GET)
    public String partmerge() throws Exception {
        return patch(V1Patch.PATCH_FORMAT_JSON_MERGE_PATCH, strategicStr);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;strategic-merge-patch&quot;&gt;strategic merge patch&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;strategic merge patch用的json内容和前面的增量merge patch是同一个，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(value = &quot;/patch/strategic&quot;, method = RequestMethod.GET)
    public String strategic() throws Exception {
        return patch(V1Patch.PATCH_FORMAT_STRATEGIC_MERGE_PATCH, strategicStr);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apply-yaml-patch&quot;&gt;apply yaml patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;apply yaml patch与其他patch略有不同，调用&lt;span&gt;ExtensionsV1beta1Api&lt;/span&gt;的patchNamespacedDeployment方法发请求时，fieldManager和force字段不能像之前那样为空了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @RequestMapping(value = &quot;/patch/apply&quot;, method = RequestMethod.GET)
    public String apply() throws Exception {
        return patch(V1Patch.PATCH_FORMAT_APPLY_YAML,  DEPLOYMENT_NAME, NAMESPACE, applyYamlStr, &quot;example-field-manager&quot;, true);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上面的代码中，如果force字段不等于true，可能会导致patch失败，在官方文档也有说明，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075551428-1152625027.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;apply yaml patch的json字符串来自文件&lt;span&gt;applyYaml.json&lt;/span&gt;，其内容是从deploy.json直接复制的，然后改了下图两个红框中的内容，红框1修改了nginx的版本号，用来验证patch是否生效(原有版本是1.18)，红框2是kubernetes1.16之前的一个问题，protocol字段必填，否则会报错，问题详情请参考：&lt;a href=&quot;https://github.com/kubernetes-sigs/structured-merge-diff/issues/130&quot; target=&quot;_blank&quot;&gt;https://github.com/kubernetes-sigs/structured-merge-diff/issues/130&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075552892-489044656.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;以上就是所有代码和patch的内容了，接下来部署到kubernetes环境实战吧&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;制作镜像并且部署&quot;&gt;制作镜像并且部署&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在patch工程目录下执行以下命令编译构建：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean package -U -DskipTests
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在patch工程目录下创建Dockerfile文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 指定基础镜像，这是分阶段构建的前期阶段
FROM openjdk:8u212-jdk-stretch as builder
# 执行工作目录
WORKDIR application
# 配置参数
ARG JAR_FILE=target/*.jar
# 将编译构建得到的jar文件复制到镜像空间中
COPY ${JAR_FILE} application.jar
# 通过工具spring-boot-jarmode-layertools从application.jar中提取拆分后的构建结果
RUN java -Djarmode=layertools -jar application.jar extract

# 正式构建镜像
FROM openjdk:8u212-jdk-stretch
WORKDIR application
# 前一阶段从jar中提取除了多个文件，这里分别执行COPY命令复制到镜像空间中，每次COPY都是一个layer
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在patch工程目录下执行以下命令创建docker镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -t 192.168.50.43:5888/common/patch:1.0-SNAPSHOT .
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;如果您已经配置了docker镜像仓库私服，建议将此镜像推送到私服上去，以便kubernetes上可以使用该镜像，我这边的推送命令如下，仅供参考(涉及到身份验证的话还请执行docker login登录)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker push 192.168.50.43:5888/common/patch:1.0-SNAPSHOT
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;SSH登录kubernetes环境，新建patch.yaml文件，内容如下，image那里请按您的镜像情况自行调整：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: patch
  namespace : kubernetesclient
spec:
  type: NodePort
  ports:
    - port: 8080
      nodePort: 30102
  selector:
    name: patch
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  namespace : kubernetesclient
  name: patch
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: patch
    spec:
      serviceAccountName: kubernates-client-service-account
      containers:
        - name: patch
          image: 192.168.50.43:5888/common/patch:1.0-SNAPSHOT
          tty: true
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 5
            failureThreshold: 10
            timeoutSeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 5
            timeoutSeconds: 10
            periodSeconds: 5
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: &quot;512Mi&quot;
              cpu: &quot;100m&quot;
            limits:
              memory: &quot;1Gi&quot;
              cpu: &quot;1000m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;执行以下命令即可完成部署：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl apply -f patch.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;用于验证patch的deployment名为test123(浏览器访问/patch/deploy就会创建)，这个deployment里面是个nginx容器，咱们要给它准备一个NodePort类型的service，以便验证的是否可以通过浏览器访问，该service对应的yaml文件是nginx-service.yaml，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: test123
  namespace : default
spec:
  type: NodePort
  ports:
    - port: 80
      nodePort: 30101
  selector:
    run: test123
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;执行以下命令即可完成部署：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl apply -f nginx-service.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;终于，部署工作全部完成，可以验证patch了！&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证的步骤&quot;&gt;验证的步骤&lt;/h3&gt;
&lt;p&gt;先说一下验证的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用创建deployment的接口，创建名为test123的deployment，里面是个nginx-1.18版本的pod，可以通过浏览器访问到(前面的nginx-service.yaml已经部署了service)；&lt;/li&gt;
&lt;li&gt;通过web请求执行各种patch操作；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;创建deployment&quot;&gt;创建deployment&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;假设kubernetes宿主机IP地址是192.168.50.135，所以通过浏览器访问：&lt;a href=&quot;http://192.168.50.135:30102/patch/deploy%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%88%9B%E5%BB%BA%E5%90%8D%E4%B8%BAtest123%E7%9A%84deployment%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F%E5%90%8Edeployment%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%BC%9A%E5%B1%95%E7%A4%BA%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%EF%BC%9A&quot; target=&quot;_blank&quot;&gt;http://192.168.50.135:30102/patch/deploy，即可创建名为test123的deployment，如下图，创建成功后deployment的详细信息会展示在浏览器上：&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075556150-1894285749.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;用kubectl命令验证deployment和pod都正常：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075557039-1715730566.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;浏览器访问&lt;span&gt;test123&lt;/span&gt;这个deployment里面的nginx容器，地址是&lt;span&gt;&lt;a href=&quot;http://192.168.50.135:30101/&quot; target=&quot;_blank&quot;&gt;http://192.168.50.135:30101/&lt;/a&gt;&lt;/span&gt; ，如下图红框所示，返回的header中显示，nginx的版本是1.18.0：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075558254-1874620010.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;接下来开始提交patch；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证json-patch&quot;&gt;验证json patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;json patch修改的是原deployment的&lt;span&gt;terminationGracePeriodSeconds&lt;/span&gt;属性，所以咱们先来看看修改前是啥样的，执行命令&lt;span&gt;kubectl get deployment test123 -o yaml&lt;/span&gt;，如下图红框，terminationGracePeriodSeconds等于&lt;span&gt;30&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075559255-2008566477.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;浏览器访问&lt;a href=&quot;http://192.168.50.135:30102/patch/json&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30102/patch/json&lt;/span&gt;&lt;/a&gt;，即可发起json patch请求，并将deployment的结果返回，如下图所示，terminationGracePeriodSeconds属性值已经改变：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075601578-1270298313.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;再次用命令&lt;span&gt;kubectl get deployment test123 -o yaml&lt;/span&gt;查看，如下图红框，json patch已经生效：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075602642-1998513683.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;执行&lt;span&gt;kubectl logs -f patch-56cd7f7f87-bpl5r -n kubernetesclient&lt;/span&gt;可以看到咱们应用通过java客户端与kubernetes 的API Server之前的详细日志(patch-56cd7f7f87-bpl5r是patch工程对应的pod)，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075605193-1605771650.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;json patch验证已经完成，接着验证下一个；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证merge-patch（全量）&quot;&gt;验证merge patch（全量）&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;merge patch（全量）给原有的deployment增加了一个label，先看看执行patch之前是啥样，如下图红框：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075606337-1347112522.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器访问http://192.168.50.135:30102/patch/fullmerge ，就发起了merge请求，操作成功后再次查看，如下图红框，新增了一个label：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075607333-1838088706.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证merge-patch（增量）&quot;&gt;验证merge patch（增量）&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问&lt;a href=&quot;http://192.168.50.135:30102/patch/partmerge&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30102/patch/partmerge&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在kubernetes环境查看&lt;span&gt;test123&lt;/span&gt;这个deployment的pod，发现原有pod被删除，新增了一个：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075608166-1151730322.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行命令&lt;span&gt;kubectl describe pod test123-5ff477967-tv729&lt;/span&gt;查看新pod的详情，发现已经部署nginx了，而是patch中提交的tomcat，如下图所示，&lt;span&gt;看来增量merge patch实际上做是替换操作&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075608990-1488647750.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证strategic-merge-patch&quot;&gt;验证strategic merge patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;此时的&lt;span&gt;test123&lt;/span&gt;这个deployment，其pod已经被刚才的merge patch操作改成了tomcat，不适合接下来的验证，因此要执行以下操作进行清理和重新部署：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上述操作完成后，test123就恢复到最初状态了，在浏览器执行&lt;a href=&quot;http://192.168.50.135:30102/patch/strategic&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30102/patch/strategic&lt;/span&gt;&lt;/a&gt; ，即可提交strategic merge patch&lt;/li&gt;
&lt;li&gt;再去执行&lt;span&gt;kubectl get pod&lt;/span&gt;命令查看，会发现pod会被删除，然后创建新pod，这个新pod的容器数量是2，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075610558-1610734678.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;执行命令&lt;span&gt;kubectl describe pod test123-59db4854f5-bstz5&lt;/span&gt;查看新pod的详情，下图两个红框，可见原有的strategic merge patch并没有替换container，而是新增了一个：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075612356-1700998650.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;此时您应该对merge patch和strategic merge patch的区别应该有了清晰的认识；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开启kubernetes的server-side-apply低于116版本才需要执行&quot;&gt;开启kubernetes的Server-side Apply(低于1.16版本才需要执行)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;最后一个实战是apply yaml patch，此类型patch主要是用于Server-side Apply特性的，&lt;/li&gt;
&lt;li&gt;该特性自kubernetes的1.14版本就有了，但是默认并未开启，直到1.16版本才默认开启，因此，如果您的kubernetes低于1.16版本，需要开启这个特性；&lt;/li&gt;
&lt;li&gt;java客户端的官方demo代码中，有一些简单描述，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075613299-1543827529.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot; readability=&quot;1.2424892703863&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;kubernetes的官方文档中，提到此特性在低版本可以通过开关来开启，文档地址：&lt;a href=&quot;https://kubernetes.cn/docs/reference/command-line-tools-reference/feature-gates/&quot; target=&quot;_blank&quot;&gt;https://kubernetes.cn/docs/reference/command-line-tools-reference/feature-gates/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075613808-1129778127.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我这里kubernetes版本是&lt;span&gt;1.14&lt;/span&gt;，因此需要手动开启Server-side Apply，首先SSH登录kubernetes环境；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开文件&lt;span&gt;/etc/kubernetes/manifests/kube-apiserver.yaml&lt;/span&gt; ，给spec.containers.command增加一个参数&lt;span&gt;--feature-gates=ServerSideApply=true&lt;/span&gt;，如下图红框所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075614452-1773747109.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;修改完毕后请保存，由于kubernetes一直在监听此文件，因此会立即自动生效；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证apply-yaml-patch&quot;&gt;验证apply yaml patch&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;此时的test123，由于刚刚验证过strategic merge patch，现在的pod里面有nginx和tomcat两个container；&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;a href=&quot;http://192.168.50.135:30102/patch/apply&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30102/patch/apply&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;此时pod会重建，如下图，可见最终container还是两个，也就是说，尽管applyYaml.json中的container只有一个nginx，但由于是在服务端merge的，服务端只会升级nginx的版本，对于已有的tomcat这个container依旧会保留：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075615586-174917898.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 用浏览器访问test123提供的nginx服务，如下图红框所示，nginx版本已经升级，证明本次patch已经生效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210113075616511-988460319.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，通过kubernetes的java客户端执行patch操作的实战就全部完成了，从理论到环境准备，再到实际操作，涉及到太多内容，感谢您的耐心，希望本文能助您用好java客户端这个利器，更高效的操作kubernetes环境；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 Jan 2021 23:56:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14270204.html</dc:identifier>
</item>
<item>
<title>Appium 介绍及环境安装 - 测试开发小记</title>
<link>http://www.cnblogs.com/hiyong/p/14163337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiyong/p/14163337.html</guid>
<description>&lt;p&gt;Appium是一个可用于测试iOS、 Android操作系统和Windows桌面平台原生应用，移动网页应用和混合应用的自动化测试框架。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;原生应用&lt;/strong&gt;（Native App）：用 android、iOS或者Windows SDK编写的应用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;移动网页应用&lt;/strong&gt;（Web App）：通过手机浏览器访问的网页应用，比如iOS中 safari应用，Android上的Chrome应用或者内置浏览器应用，不会占用手机的存储空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;混合应用&lt;/strong&gt;（Hybrid App）：同时具备Native App和Web App的特性，一种 webview应用，将Javascript，HTML和CSS执行在embedded webview中，外层用Native App wrapper包起來。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133232238-1316832927.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Appium 跨语言支持：Java、 Python、 Ruby、JavaScript (Node.js)、PHP、C# (.NET)、RobotFramework等，Appium是跨平台的，可以用在OSX，Windows以及Linux桌面系统上运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133242483-785101557.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;appium引擎列表&quot;&gt;Appium引擎列表&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Android 4.3+
&lt;ul&gt;&lt;li&gt;UIAutomator&lt;/li&gt;
&lt;li&gt;UIAutomator2[推荐]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;iOS
&lt;ul&gt;&lt;li&gt;UIAutomation (iOS ≤ 9.3)&lt;/li&gt;
&lt;li&gt;XCUITest[推荐] (iOS ≥ 9.3)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Windows:
&lt;ul&gt;&lt;li&gt;WinAppDriver&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;appium的设计理念&quot;&gt;Appium的设计理念&lt;/h2&gt;
&lt;h3 id=&quot;clientserver设计模式&quot;&gt;Client/Server设计模式&lt;/h3&gt;
&lt;p&gt;Appium采用 C/S架构，Appium与客户端建立连接并监听命令，然后在移动设备上执行这些命令，命令执行结果通过 HTTP 响应的方式返回。客户端通过 WebDriver json wire协议与服务端通讯。由于Appium的这种特性，我们可以将Appium server放在与测试机不同的机器上。Appium Server是使用 Node.js 编写的HTTP服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133253287-1114673834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;session-会话&quot;&gt;session 会话&lt;/h3&gt;
&lt;p&gt;Appium自动化执行时会首先拉起一个session会话，客户端和服务器之间初始化一个session，通过发送一个&lt;code&gt;POST /session&lt;/code&gt;建立连接，客户端的post请求中携带一个称为 'desired capabilities‘ 的JSON对象，定义设备平台（iOS或Android）、版本、server地址等请求字段，后面的文章将详细介绍。服务器接收到请求后会建立一个session并回应一个session ID，建立好连接后就可以发送命令了。&lt;/p&gt;
&lt;h3 id=&quot;appium-clients&quot;&gt;Appium Clients&lt;/h3&gt;
&lt;p&gt;Appium支持多语言，包括Java, Ruby, Python, PHP, JavaScript, 和 C#，这些客户端库支持WebDriver 协议扩展。&lt;/p&gt;

&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;adb&lt;/strong&gt;：android的控制工具，用于获取 android的各种数据和控制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Appium Desktop&lt;/strong&gt;：内嵌了 appium server和inspector的综合工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Appium Server&lt;/strong&gt;：appium的核心工具，命令行工具&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Appium client&lt;/strong&gt;：各种语言的客户端封装库，用于连接 appium server&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;AppCrawler&lt;/strong&gt;：自动遍历工具&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;appium使用 appium-xcuitest-driver来测试iPhone设备,其中需要安装 facebook开发的WDA(webdriver agent)来驱动iOS测试，下面介绍Android APP测试环境安装。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Java1.8版本&lt;/li&gt;
&lt;li&gt;Android sdk&lt;/li&gt;
&lt;li&gt;Node.js(&amp;gt;=10 版本)，npm(&amp;gt;=6 版本)&lt;/li&gt;
&lt;li&gt;Python3&lt;/li&gt;
&lt;li&gt;Appium-desktop&lt;/li&gt;
&lt;li&gt;Appium python client&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1、安装nodejs&quot;&gt;1、安装Node.js&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境&lt;/li&gt;
&lt;li&gt;Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。&lt;/li&gt;
&lt;li&gt;是运行在服务端的 JavaScript&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133317148-1775462106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行窗口中运行&lt;code&gt;node -v&lt;/code&gt; 查看是否安装成功&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133334277-1925528852.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、安装jdk&quot;&gt;2、安装jdk&lt;/h2&gt;
&lt;p&gt;jdk下载下载地址：&lt;br/&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照默认路径安装&lt;br/&gt;&lt;strong&gt;配置环境变量&lt;/strong&gt;&lt;br/&gt;“我的电脑”右键菜单---&amp;gt;属性---&amp;gt;高级---&amp;gt;环境变量---&amp;gt;系统变量--&amp;gt;新建&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量名：JAVA_HOME &lt;br/&gt;变量值：C:\Program Files (x86)\Java\jdk1.8.0_144&lt;/li&gt;
&lt;li&gt;变量名：CALSS_PATH&lt;br/&gt;变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;找到path变量名—&amp;gt;“编辑”添加：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量名：PATH&lt;br/&gt;变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查看是否安装成功：java -version&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133346277-512196612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-安装android-sdk&quot;&gt;3. 安装Android SDK&lt;/h2&gt;
&lt;p&gt;Android SDK是Google提供的Android开发工具包，在开发Android应用的时候会用到，需要通过引入工具包来调用Android的API&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://developer.android.com/&quot; target=&quot;_blank&quot;&gt;https://developer.android.com/&lt;/a&gt;&lt;br/&gt;中文社区的SDK下载地址：&lt;a href=&quot;http://tools.android-studio.org/index.php/sdk&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;http://tools.android-studio.org/index.php/sdk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;双击打开SDK Manage.exe，安装API版本和对应的工具包，这些在运行模拟器和真机测试的时候会使用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置环境变量&lt;/strong&gt;&lt;br/&gt;新建环境变量ANDROID_HOME，变量值为sdk的路径：E:\Android\android-sdk&lt;/p&gt;
&lt;p&gt;“我的电脑”右键菜单---&amp;gt;属性---&amp;gt;高级---&amp;gt;环境变量---&amp;gt;系统变量--&amp;gt;新建&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量名：ANDROID_HOME &lt;br/&gt;变量值：D:\android\android-sdk-windows&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;找到环境变量path—&amp;gt;“编辑”添加：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量名：PATH
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量值：;% ANDROID_HOME%\platform-tools;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量值：% ANDROID_HOME%\build-tools;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量值：% ANDROID_HOME%\tools;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tools目录下运行android命令，platform-tools目录运行adb命令&lt;/p&gt;
&lt;p&gt;检验Android SDK是否安装成功：&lt;code&gt;adb version&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133402434-737947465.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-安装appium&quot;&gt;4. 安装Appium&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://bitbucket.org/appium/appium.app/downloads/?tab=downloads&quot; target=&quot;_blank&quot;&gt;https://bitbucket.org/appium/appium.app/downloads/?tab=downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133414409-1876186352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装完成后添加到环境变量&lt;/li&gt;
&lt;li&gt;把安装的appium文件夹的Appium\node_modules.bin加到系统环境变量path中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行appium-doctor，检测appium运行环境的工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133423593-1184940060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-安装appium-desktop&quot;&gt;5. 安装appium-desktop&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/appium/appium-desktop/releases/tag/v1.15.1&quot; target=&quot;_blank&quot;&gt;https://github.com/appium/appium-desktop/releases/tag/v1.15.1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-下载appium-python-client&quot;&gt;6. 下载Appium-Python-Client&lt;/h2&gt;
&lt;p&gt;下载链接：&lt;a href=&quot;https://pypi.org/project/Appium-Python-Client/&quot; target=&quot;_blank&quot;&gt;https://pypi.org/project/Appium-Python-Client/&lt;/a&gt;&lt;br/&gt;运行&lt;code&gt;python setup.py install&lt;/code&gt;安装&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220133437249-496735769.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者运行 &lt;code&gt;pip install Appium-Python-Client&lt;/code&gt; 安装。&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;--THE END--&lt;/strong&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;5.4292682926829&quot;&gt;
&lt;p&gt;&lt;strong&gt;文章标题：Appium 介绍及环境安装&lt;br/&gt;本文作者：hiyo&lt;br/&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/hiyong/p/14163337.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hiyong/p/14163337.html&lt;/a&gt;&lt;br/&gt;欢迎关注公众号:「测试开发小记」及时接收最新技术文章！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 Jan 2021 23:33:00 +0000</pubDate>
<dc:creator>测试开发小记</dc:creator>
<og:description>Appium是一个可用于测试iOS、 Android操作系统和Windows桌面平台原生应用，移动网页应用和混合应用的自动化测试框架。 原生应用（Native App）：用 android、iOS或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hiyong/p/14163337.html</dc:identifier>
</item>
<item>
<title>顶象验证码破解与研究 - 码头工人</title>
<link>http://www.cnblogs.com/boycelee/p/14270112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boycelee/p/14270112.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原创文章，请勿转载！&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;1、本文内容仅限于安全研究，不公开具体源码。维护网络安全，人人有责。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2、如果想更系统地了解第三代验证码、更全面体会安全产品的设计，可以结合我的另几篇篇文章&lt;/strong&gt;&lt;br/&gt;（1）《第三代验证码研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/11363611.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/11363611.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）《顶象验证码破解与研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/14269941.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/14269941.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（3）《极验验证码破解与研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/14021048.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/14021048.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（4）《极验无感验证破解》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/13951819.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/13951819.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（5）《同盾小程序指纹破解》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/13899956.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/13899956.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、本文主要通过破解协议的方式绕过顶象安全验证，思路与网上自动化的方式有很大的不同&lt;/strong&gt;&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;（1）顶象的验证码真的非常棒。从2018年12月开始到2019年5月持续与顶象验证码对抗半年。&lt;/p&gt;
&lt;p&gt;（2）我猜在对抗期间顶象很多的防护策略都是被我逼出来的吧（哈哈哈，个人yy）&lt;/p&gt;
&lt;p&gt;（3）js混淆与加密算法一天更换两次、滑块验证码干扰槽等应该都是在于我对抗中升级的。&lt;/p&gt;
&lt;p&gt;（4）一年后回头看顶象的验证码产品又多了语序点选、刮刮卡验证、空间语义验证、乱序拼图验证、旋转验证、面积验证等验证码类型，在创新方面做得非常好，应该是国内数一数二的。&lt;/p&gt;
&lt;p&gt;（5）与顶象的对抗，使我对安全产品有了更深刻、全面的认识。&lt;/p&gt;
&lt;p&gt;（6）以下是我与顶象的对抗过程。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97%E6%97%B6%E9%97%B4%E7%BA%BF.png&quot; alt=&quot;极验完整流程&quot; width=&quot;90%&quot; height=&quot;100%&quot;/&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;访问顶象官网，注册账号后登录控制台，访问“无感验证”模块，申请开通后系统会分配一个唯一的AppId、AppSecret。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当用户滑动验证码通过后，验证码服务会生成一个&lt;code&gt;token&lt;/code&gt;，用户的业务请求带上这个验证码&lt;code&gt;token&lt;/code&gt;，业务系统再调用后台 SDK 验证&lt;code&gt;token&lt;/code&gt;的有效性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;顶象请求链路如下：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;极验完整流程&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、研究目标&quot;&gt;1、研究目标&lt;/h3&gt;
&lt;p&gt;当用户滑动验证码通过后，验证码服务就会生成token，用户携带token上传至顶象服务进行验证。我们的目标就是生成没有被标记为异常的token。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%811.png&quot; alt=&quot;极验完整流程&quot; width=&quot;35%&quot; height=&quot;35%&quot;/&gt;&lt;h3 id=&quot;2、案例历史研究&quot;&gt;2、案例历史研究&lt;/h3&gt;
&lt;p&gt;2018年12月研究的是国航的手机注册场景。不过由于国航该场景的验证码已经不再是滑块，所以后续可能需要使用官网案例来具体分析。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E5%9B%BD%E8%88%AA%E6%A1%88%E4%BE%8B.png&quot; alt=&quot;极验完整流程&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;h3 id=&quot;3、官网案例分析&quot;&gt;3、官网案例分析&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E5%AE%98%E7%BD%91%E6%A1%88%E4%BE%8B.png&quot; alt=&quot;极验完整流程&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;p&gt;从请求中我们可以看出，一共是三个请求（c1、a、v1）。我们需要弄清楚这三个请求分别的含义。（从设计角度个人觉得顶象相对于极验要简洁一些。个人觉得顶象的设计非常棒，在做公司的安全产品时，我也会参考一些顶象的设计）&lt;/p&gt;

&lt;h3 id=&quot;1、c1请求：请求顶象服务器，获取c参数。&quot;&gt;&lt;strong&gt;1、c1请求：请求顶象服务器，获取c参数。&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;目的：此处应该是计算设备指纹，通过设备指纹能够标识唯一设备信息&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;（1）请求参数示例-：&quot;&gt;（1）请求参数示例 ：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;428#X8m8K4SIcMDkTOm/r2P3j5vTyaRhmW3m9aksXQ8m2r13DgOarX1TmbmTMX13/vXXC9RmXS8m2XHfDg/uV8RP/4uaMuk8/WnUNX+6Xnah2rDfmZ3YXXwR0gpt2lJu07Nozs5jXY433RaCfCO6Y8VX/6aVU2mT6cuhX14q+2v8jcQ/awvNF8X1YuuJmzf3XXbXmCvq8M8uiwXSm3vhmyyuXXOiXmo8Ya21XXGjS8ft1qT2+Al3+Ab0wXWXmyf8aCO4WrrXj6flFh9p4PnSFPokuP5vXmuFn9fM8Am+JXvlT2TiW8QL88SXjtZykz8LUtZ9kAQpkd4pn2oXmpP9upuLVr2XvVTUjyTPTXWPCy+oTofzwi2oRX41sYk1sXWARiw1w32AOrfAe1fPTXVXivd2CFHaGgNezipHxx6cciF1xORN2iUklOpQzldUBvAxwBHXSoHBAGyUXXJ99ei8lxEoj2X8sJTvz/novxbofltai6k3wmXXjtyTItyoi8QsjUMIGI0siT3XYWKG9FkI54DQdTnXm00umH0KBTIXmACOT1rFmC8XmA2rTPuVmm/Xmg1R9usmM5/6XX+vqnlSylnDXX+jGnElyi3fXXphvMw444YeNUpw0TyXuFi3HFitgAiquUM3HXtquUM3HXwt1rXSuNMs1MJfuNrniBCkEnrfYmCsYuL5Y5Cf+nCkUFCkYdCSUFrSJXonuMoXZkrpk8nf3Ue/P9F0pmjG6Q9/DgBJzVZqcg6po/NleM6PXXVE8F9oSzdt++YgMiFBYxWbOUaHPXXS+2C5jY5/ZcmEaAvR+cxxjRQ+k8CoD1xHFcxSj6ovU270Dwyik9oBPTVXYNS86LTmha3t68oQPrXs3/ZLJMPTI2QLAtomXX07drAmu4omycphXrnXYbUG9GpOSg6yts0JX2XfTXVqvE26Y/COD9OqWA5IPaQTDVxc41r6mXXn8Xo6JyIPJPyuXYQim8OYJX3tu6ci/TX3muOg/Lm8//nuY9nljN/sX3vTXX4qX1nIa//1Yc9x
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（2）请求参数信息：&quot;&gt;（2）请求参数信息：&lt;/h4&gt;
&lt;p&gt;只展示部分数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;supportAddBehavior&quot;: &quot;ab&quot;,&quot;adblock&quot;: &quot;adb&quot;,&quot;availResolution&quot;: &quot;ar&quot;,&quot;canvasFP&quot;: &quot;can&quot;,&quot;cpuClass&quot;: &quot;cc&quot;,&quot;colorDepth&quot;: &quot;cd&quot;,&quot;cookieEnabled&quot;: &quot;ce&quot;,&quot;canPlayType&quot;: &quot;cpt&quot;,&quot;collectTime&quot;: &quot;ct&quot;,&quot;doNotTrack&quot;: &quot;dnt&quot;,&quot;deviceMemory&quot;: &quot;dm&quot;,&quot;languages&quot;: &quot;lugs&quot;,&quot;mimeTypes&quot;: &quot;mts&quot;,&quot;mediaDevices&quot;: &quot;mds&quot;,&quot;platform&quot;: &quot;np&quot;,&quot;supportOpenDatabase&quot;: &quot;od&quot;,&quot;devicePixelRatio&quot;: &quot;pr&quot;,&quot;resolution&quot;: &quot;res&quot;,&quot;plugins&quot;: &quot;rp&quot;,&quot;supportSessionStorage&quot;: &quot;ss&quot;,&quot;timezoneOffset&quot;: &quot;to&quot;,&quot;touch&quot;: &quot;ts&quot;,&quot;userAgent&quot;: &quot;ua&quot;,&quot;webgl&quot;: &quot;web&quot;,&quot;webgl2&quot;: &quot;gi&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过加密以上操作系统与浏览器以及网络数据等信息生成c1请求参数param。&lt;/p&gt;
&lt;h4 id=&quot;（3）加密算法&quot;&gt;（3）加密算法&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95index.png&quot; alt=&quot;极验完整流程&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;p&gt;index.js?_t=xxxx中，进行每日更新。那么该如何确保每日都能获取到准确的加密算法呢？通过解析原语法树，生成我们想要的语法树。（这个后续讲）&lt;/p&gt;
&lt;h4 id=&quot;（4）返回参数&quot;&gt;（4）返回参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{&quot;data&quot;:&quot;f8839e00435f2e05f9ed60b3d3c5498554cb367655ec6e7318adefda150437040a74963c&quot;,&quot;msg&quot;:&quot;lid invalid&quot;,&quot;status&quot;:-4} // 会根据指纹情况对指纹进行风险等级判断
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（5）指纹本地存储&quot;&gt;（5）指纹本地存储&lt;/h4&gt;
&lt;p&gt;顶象会将指纹进行多地存储，例如cookie、Session Storage、Local Storage等&lt;/p&gt;
&lt;h3 id=&quot;2、a请求：获取图片与token2&quot;&gt;&lt;strong&gt;2、a请求：获取图片与token2&lt;/strong&gt;&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87.png&quot; alt=&quot;极验完整流程&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;h4 id=&quot;（1）请求参数示例：&quot;&gt;（1）请求参数示例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;de=0&amp;amp;wp=1&amp;amp;aid=dx-1547996895410-3601284-1&amp;amp;jsv=1.3.11.98&amp;amp;c=5c3c65a6uSNGXiEhdEwxwwICxBq5Qdjdky4kxjo1&amp;amp;ak=5f6727ec854786a86cd4c3c171d13499&amp;amp;s=50&amp;amp;h=150&amp;amp;w=300&amp;amp;_r=0.9866721061865382
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;wp：表示图片类型。非常重要，因为通过该参数选择图片类型，省去了我们取转换webp格式图片（0表示jpg,1表示webp。目前只有chrome支持，safari不支持webp格式）。&lt;/li&gt;
&lt;li&gt;aid：时间戳+随机数+1。目前猜测其目的是number once。&lt;/li&gt;
&lt;li&gt;jsv：表示版本号。&lt;/li&gt;
&lt;li&gt;c：c1请求返回参数，可以理解为第一阶段token1。&lt;/li&gt;
&lt;li&gt;ak：appKey，顶象会为每一个接入其无感验证码的server提供一个appKey，以便标识他们是哪一个服务。&lt;/li&gt;
&lt;li&gt;s、h、w：描述图片的长宽等信息。h与w非常重要，因为获取的图片信息是200*400，所以我们在计算距离时，应该按比率缩小，否则滑块无法通过。&lt;/li&gt;
&lt;li&gt;_r：number once。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;（2）返回参数：&quot;&gt;（2）返回参数：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;sid&quot;:&quot;86ae78ed0fba04f8384f3c9376271b0d&quot;,&quot;y&quot;:30,&quot;success&quot;:true,&quot;p1&quot;:&quot;/dx/ib3oV3MeuO/zib3/b5cce61f91c6447bbc2f10e7836a7827.webp&quot;,&quot;p2&quot;:&quot;/dx/ib3oV3MeuO/zib3/e34db2ab70064b2c998d14159f0b8ff8.webp&quot;,&quot;p3&quot;:&quot;/dx/ib3oV3MeuO/zib3/50969dc0b2f14d118fcf166dc0871021.webp&quot;,&quot;msg&quot;:null,&quot;t&quot;:null,&quot;result&quot;:1,&quot;type&quot;:0,&quot;logo&quot;:null}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;sid：token2。&lt;/li&gt;
&lt;li&gt;y：y坐标&lt;/li&gt;
&lt;li&gt;p1：不完整图片&lt;/li&gt;
&lt;li&gt;p2：拼图块&lt;/li&gt;
&lt;li&gt;p3：完整图片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：如果该请求错误，可能会返回另一种图片验证码（点击类型）&lt;/p&gt;
&lt;h3 id=&quot;3、v1请求：获取token3&quot;&gt;&lt;strong&gt;3、v1请求：获取token3&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;（1）请求示例：&quot;&gt;（1）请求示例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;y: 30 x: 33 aid: dx-1547997910506-78792589-1 sid: 75dc20f81b2bd0ff871b9f12e54ef2c8 jsv: 1.3.11.98 c: 5c448ee09pUgUAwgiaRMmhhDea79K4O1B7oQhRh1 ak: 5f6727ec854786a86cd4c3c171d13499 ac: 492#X8Xn8AQv/Y6pdvgYXXfOuMffR/W3XjVgMOYfQntkaQbRZ/smuRlFpvD6L+qHM21JPdOjXTgzLGKauxS0c29jXCAeYaTRl589z9Ug+vZ1YDXIBNwrm8X1k6vEf3rKmrXmS2WXmFPMgH3nXX8XXXXmY8XEJ37H/cWc68WnDdW+DXSjXtXZj9c6v33n6aa6W9bhYu/c8XIXui83m5U1gFUJzxqJzxoGUqNSYXpFY2Xio3O5Ja/dw/NP2X5X3oFjcWf2r9znqaJQ2LQr7homIr5X3oFPjnXMr9znqaJQ2LQr7homIr2XsBHwJhSSRygCnh3ufTc1v/8V8YZsiz/D4raoj9XLRtOYv9a53D2kZcWV8YcHUAa/mrXmS25X3oFPjvS2r9znqaJQ2LQr7homIr5XjoFPjvrMr9DIGaUiwYmYYrXslqs+7bRz2kEuonW=
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;y：坐标，a请求会返回，所以不需要自己计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;x：坐标，需要计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;aid：时间戳+随机数+1。目前猜测其目的是number once。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jsv：表示版本号。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;c：c1请求的返回值，理解为token1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ak：appKey，顶象会为每一个接入其无感验证码的server提供一个appKey，以便标识他们是哪一个服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ac：加密信息。包括时间戳、操作系统对应编码、Referer、特殊加密算法（随机取加密算法中一段并加密）、JSV、token(sid)、是否使用headless、浏览器版本、屏幕信息、服务网址、版本、检测是否使用webdriver等方式抓取、token、鼠标轨迹等进行数据加密。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;（2）返回示例：&quot;&gt;（2）返回示例：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;success&quot;:true,&quot;token&quot;:&quot;37AD877DC3953CA1116E487DFBF6DB435DFE7C4CD204B8DC861D5857BE2FDDCF4565648C95BAFD15030AA555713B5DA1FD5D57C82427F4C7D222E5990F47AB83B3F13ED08965032CFF26FA37B82012FF&quot;,&quot;msg&quot;:null,&quot;tp&quot;:null,&quot;sv&quot;:null,&quot;retry&quot;:0}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;返回token则表示成功。但注意此时token未必有效，如果c1请求使用appKey与v1请求使用的不同，是无法通过check校验的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;4、check&quot;&gt;&lt;strong&gt;4、check&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在获取token之后会通过check接口，进行token时效性与正确性校验。使用方通过调用顶象的open api进行token校验。通过则说明，验证码完成。&lt;/p&gt;

&lt;h4 id=&quot;greenseerjs部分服务化代码&quot;&gt;greenseer.js部分服务化代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;function getParamUa(sid, position, referer, browserVersion) {
    var _ua = &quot;&quot;;
    var ua = &quot;&quot;;
    var tm = new Date().getTime();
    delete require.cache[require.resolve('../builder/dingxiang_greenseer_finish.js')];
    var encryptionFunc = require('../builder/dingxiang_greenseer_finish.js');
    var replace_encrypt = encryptionFunc.replace_encrypt;

    delete require.cache[require.resolve('../builder/dingxiang_version_finish.js')];
    var versionFunc = require('../builder/dingxiang_version_finish.js');
    var replace_version = versionFunc.replace_encrypt;
    let mouseMove = buildMouseMove(position);
    let mouseMoveEvent = buildMouseMoveEvent(mouseMove);
    let mouseDownEvent = buildMouseDownEvent(mouseMoveEvent);
    app = function (u, c) {
        var s = (0, toStr)([u].concat((0, replace_bs2)(c.length)));
        _ua += [s, c].join(&quot;&quot;),
            ua = [replace_version.exports.version, &quot;#&quot;, (0, replace_btoa)(_ua)].join(&quot;&quot;);
        console.log(ua);
        ua.replace(&quot;xxxxxxxxx&quot;, &quot;&quot;);
    }
    process = function (t) {
        var c = [].slice.call(arguments);
        return t = c.length === 1 &amp;amp;&amp;amp; (0, isArray)(t) ? t : c, t = (0, flatten)(t), (0, toStr)(t)
    }
    getTM = function () {
        var a = process((0, replace_bs8)(tm));
        app(1, (0, replace_encrypt.encryptTM)(a))
    }
    //浏览器版本
    getBR = function (browserVersion) {
        //浏览器版本 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36
        //Chrome/73.0.3683.86 ,chromeVersion = &quot;73&quot;
        //var version = browserVersion;
        var version = browserVersion;
        console.log(&quot;version: &quot; + version)
        var a = 3, b = [1, version], c = b[1];
        a = process(a, b[0], (0, replace_bs2)(c.length), (0, replace_bss)(c));
        app(2, (0, replace_encrypt.encryptBR)(a))
    }
    //屏幕信息
    getSC = function () {
        //7,128,4,56,7,128,4,33,0,241,4,56,7,128,1,73,7,128,4,56
        //var n = this.process((0, getScreenInfo)());
        //var n = &quot;8! ´:8&quot;;
        //var scValue = [[5,160],[3,132],[5,160],[3,109],[0,0],[0,0],[5,160],[1,49],[5,160],[3,132]];
        var scValue = buildSCArray();
        //var scValue = [[7,128],[4,56],[7,128],[4,33],[0,241],[4,56],[7,128],[2,5],[7,128],[0,0]];
        var n = this.process(scValue);
        app(3, (0, replace_encrypt.encryptSC)(n))
    }
    //网址
    getLO = function (referer) {
        var o = &quot;&quot;,
            a = referer,
            i = this.process((0, replace_bs2)(a.length), (0, replace_bss)(a), (0, replace_bs2)(0), (0, replace_bss)(o));
        app(4, (0, replace_encrypt.encryptLO)(i))
    }
    //函数
    getCF = function () {
        let cfParam = buildCFParam();
        let range = Math.floor(Math.random() * 3 + 7);
        let lastIndex = Math.floor(Math.random() * (cfParam.length - 9) + 9);
        let beginIndex = lastIndex - range;
        cfParam = cfParam.slice(beginIndex, lastIndex);
        var s = this.process((0, replace_bs2)(beginIndex), (0, replace_bs2)(range), (0, replace_bss)(cfParam));
        //var s = &quot; += t&quot;;
        app(5, (0, replace_encrypt.encryptCF)(s))
    }
    //是否开启控制台
    getDI = function () {
        var a = 1;
        a = process(a);
        app(6, (0, replace_encrypt.encryptDI)(a))
    }
    //检测是否使用webdriver等方式抓取
    getEM = function () {
        var s = process((0, replace_bs4)(0));
        app(7, (0, replace_encrypt.encryptEM)(s))
    }
    //版本
    getJSV = function () {
        var o = process((0, replace_bs4)(1));
        app(8, (0, replace_encrypt.encryptJSV)(o))
    }
    //token
    getTK = function (sid) {
        var a = sid;
        a &amp;amp;&amp;amp; (a = this.process((0, replace_bs2)(a.length), (0, replace_bss)(a)),
            app(9, (0, replace_encrypt.encryptTK)(a)))
    }
    getMM = function (mouseMove) {
        var v = mouseMove.eventName
            , h = mouseMove.tm
            , d = mouseMove.x
            , p = mouseMove.y
            , l = this.process((0, replace_bs4)(h)
            , (0, replace_bs2)(d)
            , (0, replace_bs2)(p)
            , (0, replace_bs2)(v.length)
            , (0, replace_bss)(v));
        console.log(&quot;mouse_mm info :&quot; + &quot;MM_v:&quot; + v + &quot; tm:&quot; + h + &quot; MM_getPageX:&quot; + d + &quot; MM_getPageY:&quot; + p);
        this.app(11, (0, replace_encrypt.encryptMM)(l))
    }
    getMD = function (mouseDown) {
        var f = mouseDown.eventName
            , s = mouseDown.button
            , v = mouseDown.tm
            , h = mouseDown.x
            , d = mouseDown.y
            , p = this.process((0, replace_bs4)(v)
            , (0, replace_bs2)(h)
            , (0, replace_bs2)(d)
            , s
            , (0, replace_bs2)(f.length)
            , (0, replace_bss)(f));
        console.log(&quot;MD_getTarget:&quot; + f + &quot; MD_getButton:&quot; + s + &quot; MD_time:&quot; + v + &quot; MD_getPageX:&quot; + h + &quot; MD_getPageY:&quot; + d + &quot; MD_process:&quot; + p);
        this.app(12, (0, replace_encrypt.encryptMD)(p))
    }
    var _sa = [];
    recordSA = function (mouseMove) {
        var i = mouseMove.tm
            , u = mouseMove.x
            , c = mouseMove.y
            , f = this.process((0, replace_bs4)(i),
            (0, replace_bs2)(u),
            (0, replace_bs2)(c));
        console.log(&quot;recordSA: &quot; + &quot; tm: &quot; + i + &quot; getPageX: &quot; + u + &quot; getPageY: &quot; + c);
        _sa.push((0, replace_encrypt.encryptSA)(f))
    }
    sendSA = function (r) {
        this.app(17, r);
    }
    sendTemp = function (t) {
        var n = process((0, replace_bs2)(t.length), (0, replace_bss)(t));
        app(10, (0, replace_encrypt.encryptTEMP)(n))
    }

    var tm = getTM();
    var br = getBR(browserVersion);
    var LO = getLO(referer);
    var CF = getCF();
    var DI = getDI();
    var EM = getEM();
    var JSV = getJSV();
    var TK = getTK(sid);
    var SC = getSC();
    var MM = getMM(mouseMoveEvent[mouseMoveEvent.length - 1]);
    var MD = getMD(mouseDownEvent[0]);
    var DI = getDI();
    for (let mveIndex = mouseMoveEvent.length - 2; mveIndex &amp;gt;= 0; mveIndex--) {
        var MM = getMM(mouseMoveEvent[mveIndex]);
    }
    for (let mvIndex = mouseMove.length - 1; mvIndex &amp;gt;= 0; mvIndex--) {
        var SA1 = recordSA(mouseMove[mvIndex]);
    }
    for (let saIndex = 0; saIndex &amp;lt; _sa.length; saIndex++) {
        var SA2 = sendSA(_sa[saIndex]);
    }
    var temp = sendTemp(position);
    return ua;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;java服务化代码&quot;&gt;Java服务化代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
    public CrackResult crackDingXiang(DingXiangParam dingXiangParam, Integer captchaType, String caller) throws IOException {
        Preconditions.checkNotNull(dingXiangParam, &quot;crackDingXiang dingXiangParam is null&quot;);
        Preconditions.checkNotNull(StringUtils.isNotBlank(caller), &quot;caller is null&quot;);

        String userAgent = HeaderBuilder.buildChrome();
        String browserVersion = getBrowserVersion(userAgent);
        dingXiangParam.setUserAgent(userAgent);
        //Lid请求
        String lidResult = getDingXiangLidFunc(dingXiangParam);
        dingXiangParam = changeDingXiangParam(dingXiangParam, lidResult);
        //C请求
        String cFunctionResult = getDingxiangCFunc(dingXiangParam);
        CFunctionResponse cFunctionResponse = buildCFunctionResponse(cFunctionResult);
        AFunctionParam aFunctionParam = buildPictureRequestParam(cFunctionResponse, dingXiangParam);
        //A请求
        String aFunctionResult = getDingXiangAFunc(aFunctionParam);
        AFunctionResponse aFunctionResponse = buildAFunctionResponse(aFunctionResult);
        //分析图片
        PictureAnalysisParam pictureAnalysisParam = buildPictureAnalysisParam(dingXiangParam, aFunctionResponse, browserVersion);
        String pictureAnalysisResult = analysePicture(pictureAnalysisParam);
        PictureAnalysisResponse pictureAnalysisResponse = buildPictureAnalysisResponse(pictureAnalysisResult, pictureAnalysisParam);
        //V请求
        VFunctionParam vFunctionParam = buildVFunctionParam(pictureAnalysisResponse, aFunctionParam, aFunctionResponse, dingXiangParam);
        List&amp;lt;NameValuePair&amp;gt; vFunctionPostParam = buildDingXiangVFuncPostParam(vFunctionParam);
        String vFunctionResult = getDingXiangVFunc(vFunctionPostParam, dingXiangParam);
        VFunctionResponse vFunctionResponse = buildDingXiangVFuncResponse(vFunctionResult);
        CrackResult crackResult = buildCrackResult(vFunctionResponse, cFunctionResponse, dingXiangParam, captchaType);

        return crackResult;
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1、图片还原&quot;&gt;1、图片还原&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E5%9B%BE%E7%89%87%E8%BF%98%E5%8E%9F.png&quot; alt=&quot;极验完整流程&quot; width=&quot;90%&quot; height=&quot;90%&quot;/&gt;&lt;h3 id=&quot;2、随机加密算法解析（重点设计部分）&quot;&gt;2、随机加密算法解析（重点设计部分）&lt;/h3&gt;
&lt;p&gt;加密算法会随着js混淆的改变而改变，如何服务化？&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90.png&quot; alt=&quot;极验完整流程&quot; width=&quot;90%&quot; height=&quot;90%&quot;/&gt;&lt;h4 id=&quot;（1）语法树思路&quot;&gt;（1）语法树思路&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E8%AF%AD%E6%B3%95%E6%A0%91%E6%80%9D%E8%B7%AF.png&quot; alt=&quot;极验完整流程&quot; width=&quot;90%&quot; height=&quot;90%&quot;/&gt;&lt;h4 id=&quot;（2）举例子&quot;&gt;（2）举例子&lt;/h4&gt;
&lt;p&gt;（1）未处理的index.js。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E6%9C%AA%E5%A4%84%E7%90%86index.js.png&quot; alt=&quot;极验完整流程&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;p&gt;（2）创建模板并生成其语法树。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E5%A4%84%E7%90%86%E5%90%8E%E7%94%9F%E6%88%90%E8%AF%AD%E6%B3%95%E6%A0%91%E6%A8%A1%E6%9D%BF.png&quot; alt=&quot;极验完整流程&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;p&gt;（3）将加密算法转化成语法树-&amp;gt; 与模板语法树结合 -&amp;gt; 生成新的语法树 -&amp;gt; 生成新的js文件&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E6%96%B0%E7%9A%84index.png&quot; alt=&quot;极验完整流程&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;p&gt;（4）启用定时任务，每天固定时间去生成新的加密算法js文件。&lt;/p&gt;

&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E6%88%90%E6%9E%9C.png&quot; alt=&quot;极验完整流程&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;
&lt;h4 id=&quot;（1）顶象无感验证流程图&quot;&gt;（1）顶象无感验证流程图&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E6%97%A0%E6%84%9F%E9%AA%8C%E8%AF%81%E7%A0%81%E6%B5%81%E7%A8%8B%E5%9B%BE1.png&quot; alt=&quot;极验完整流程&quot; width=&quot;80%&quot; height=&quot;80%&quot;/&gt;&lt;h4 id=&quot;（2）顶象风控流程图&quot;&gt;（2）顶象风控流程图&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/%E9%A1%B6%E8%B1%A1-%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B%E5%9B%BE2.png&quot; alt=&quot;极验完整流程&quot; width=&quot;60%&quot; height=&quot;80%&quot;/&gt;
&lt;p&gt;（1）顶象相对于极验产品设计更加清晰。步骤非常明确 &quot;设备数据-&amp;gt;行为数据-&amp;gt;验证&quot;；&lt;/p&gt;
&lt;p&gt;（2）通过每日更新混淆js文件、加密算法提升破解服务化难度；&lt;/p&gt;
&lt;p&gt;（3）通过验证码下发策略，进行验证码种类变换，提升验证码识别难度；&lt;/p&gt;
&lt;p&gt;（4）验证码产品创新能力强，例如：空间语义验证、乱序拼图验证、面积验证、旋转验证等；&lt;/p&gt;
&lt;p&gt;（5）整体而言，顶象对于验证码的理解应该是业界领先的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、目前国内在安全产品方面的文章较少，我们很难全面了解与学习安全产品，希望我的文章能够帮助到更多人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、如果想系统地了解第三代验证码，可以结合我的另几篇篇文章&lt;/strong&gt;&lt;br/&gt;（1）《第三代验证码研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/11363611.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/11363611.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）《顶象验证码破解与研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/14269941.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/14269941.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（3）《极验验证码破解与研究》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/14021048.html%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/14021048.html（推荐）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（4）《极验无感验证破解》&lt;a href=&quot;https://www.cnblogs.com/boycelee/p/13951819.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/p/13951819.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（5）《同盾小程序指纹破解》&lt;a href=&quot;https://www.cnblogs.com/boycelee/category/1819211.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/boycelee/category/1819211.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、本文不提供完整解决方案和完整数据，仅用于理论研究，维护网络安全，人人有责。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Jan 2021 16:47:00 +0000</pubDate>
<dc:creator>码头工人</dc:creator>
<og:description>顶象验证码研究，顶象破解极验验证码协议</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/boycelee/p/14270112.html</dc:identifier>
</item>
<item>
<title>ElasticSearch- 单节点 unassigned_shards 故障排查 - IT胖</title>
<link>http://www.cnblogs.com/FLY_DREAM/p/14269859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FLY_DREAM/p/14269859.html</guid>
<description>&lt;h2 id=&quot;故障现象&quot;&gt;故障现象&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112231802.png&quot; alt=&quot;kibana&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在部署ELK的单机环境，当连接Kibana时候提示下面错误，即使重启整个服务也是提示&lt;code&gt;Kibana server is not ready&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;{&quot;message&quot;:&quot;all shards failed: [search_phase_execution_exception] all shards failed&quot;,&quot;statusCode&quot;:503,&quot;error&quot;:&quot;Service Unavailable&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;排查过程&quot;&gt;排查过程&lt;/h2&gt;
&lt;p&gt;前段时间ELK服务还是正常的，进入容器去ping ip 也都没问题，服务也都是&lt;code&gt;Up&lt;/code&gt; 状态； ElasticSearch 服务也可以通过&lt;code&gt;http://localhost:9200/&lt;/code&gt; 访问到，但是就是kibana 不能连接ElasticSearch&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112231919.png&quot; alt=&quot;ELK&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再查看 kibana 日志发现如下信息, 其中包含了&lt;code&gt;no_shard_available_action_exception&lt;/code&gt;, 看起来是&lt;code&gt;分片&lt;/code&gt; 的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;type&quot;: &quot;error&quot;,
    &quot;@timestamp&quot;: &quot;2020-09-15T00:41:09Z&quot;,
    &quot;tags&quot;: [
        &quot;warning&quot;,
        &quot;stats-collection&quot;
    ],
    &quot;pid&quot;: 1,
    &quot;level&quot;: &quot;error&quot;,
    &quot;error&quot;: {
        &quot;message&quot;: &quot;[no_shard_available_action_exception] No shard available for [get [.kibana][doc][config:6.8.11]: routing [null]]&quot;,
        &quot;name&quot;: &quot;Error&quot;,
        &quot;stack&quot;: &quot;[no_shard_available_action_exception] No shard available for [get [.kibana][doc][config:6.8.11]: routing [null]] :: {\&quot;path\&quot;:\&quot;/.kibana/doc/config%3A6.8.11\&quot;,\&quot;query\&quot;:{},\&quot;statusCode\&quot;:503,\&quot;response\&quot;:\&quot;{\\\&quot;error\\\&quot;:{\\\&quot;root_cause\\\&quot;:[{\\\&quot;type\\\&quot;:\\\&quot;no_shard_available_action_exception\\\&quot;,\\\&quot;reason\\\&quot;:\\\&quot;No shard available for [get [.kibana][doc][config:6.8.11]: routing [null]]\\\&quot;}],routing [null]]&quot;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;a href=&quot;https://blog.csdn.net/liumiaocn/article/details/98517815&quot; target=&quot;_blank&quot;&gt;ES可视化工具-cerebro&lt;/a&gt; 查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112231922.png&quot; alt=&quot;cerebro&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际当时情况是&quot;红色&quot;的，而不是目前看到的 &quot;黄色&quot;， &lt;code&gt;heap/disk/cup/load&lt;/code&gt; 基本都是红色的, 可能因为当时手动删除了几个index原因&lt;/p&gt;
&lt;p&gt;黄色虽然kibana可以访问ES了，但是&lt;code&gt;黄色代表ES仍然是不健康的&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看单节点elasticsearch健康状态&quot;&gt;查看单节点Elasticsearch健康状态&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;curl -XGET http://localhost:9200/_cluster/health\?pretty&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;status&quot; : &quot;red&quot;,
  &quot;timed_out&quot; : false,
  &quot;number_of_nodes&quot; : 1,
  &quot;number_of_data_nodes&quot; : 1,
  &quot;active_primary_shards&quot; : 677,
  &quot;active_shards&quot; : 677,
  &quot;relocating_shards&quot; : 0,
  &quot;initializing_shards&quot; : 4,
  &quot;unassigned_shards&quot; : 948,
  &quot;delayed_unassigned_shards&quot; : 0,
  &quot;number_of_pending_tasks&quot; : 5,
  &quot;number_of_in_flight_fetch&quot; : 0,
  &quot;task_max_waiting_in_queue_millis&quot; : 599,
  &quot;active_shards_percent_as_number&quot; : 41.559238796807854
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的 &lt;code&gt;unassigned_shards&lt;/code&gt; 可以存在大量分片没有被分配，当时看到的实际有1000多个。&lt;/p&gt;
&lt;h3 id=&quot;查询-unassigned-类型的索引名字&quot;&gt;查询 UNASSIGNED 类型的索引名字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;curl -XGET http://localhost:9200/_cat/shards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112231926.png&quot; alt=&quot;UNASSIGNED&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;故障原因大概确定了，应该就是&lt;code&gt;unassigned_shards&lt;/code&gt;导致的 下面就看如何解决&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果是集群环境，可以考虑使用 &lt;code&gt;POST /_cluster/reroute&lt;/code&gt; 强制把问题分片分配到其中一个节点上了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;但是对于目前的单机环境，从上面截图可以看出存在5个 unassigned 的分片，新建索引时候，分片数为5，副本数为1，新建之后集群状态成为yellow，其根本原因是因为集群存在没有启用的副本分片。&lt;/p&gt;
&lt;p&gt;解决办法就是，在单节点的elasticsearch集群，删除存在副本分片的索引，新建索引的副本都设为0。然后再查看集群状态&lt;/p&gt;
&lt;p&gt;通过如果下命令，设置&lt;code&gt;number_of_replicas=0&lt;/code&gt;,将副本调整为0. 如下图所示，es变成了“绿色”&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -XPUT 'http://localhost:9200/_settings' -H 'content-Type:application/json' -d'
{
&quot;number_of_replicas&quot;: 0
}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.devopsing.site/2020/20210112231930.png&quot; alt=&quot;Fix-UNASSIGNED&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;知识点&quot;&gt;知识点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;副本分片&lt;/strong&gt; 主要目的就是为了故障转移，如果持有主分片的节点挂掉了，一个副本分片就会晋升为主分片的角色。&lt;/p&gt;
&lt;p&gt;所以副本分片和主分片是不能放到一个节点上面的，可是在只有一个节点的集群里，副本分片没有办法分配到其他的节点上，所以出现所有副本分片都unassigned得情况。因为只有一个节点，如果存在主分片节点挂掉了，那么整个集群理应就挂掉了，不存在副本分片升为主分片的情况。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Tue, 12 Jan 2021 15:26:00 +0000</pubDate>
<dc:creator>IT胖</dc:creator>
<og:description>故障现象 在部署ELK的单机环境，当连接Kibana时候提示下面错误，即使重启整个服务也是提示Kibana server is not ready. {&amp;amp;quot;message&amp;amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FLY_DREAM/p/14269859.html</dc:identifier>
</item>
<item>
<title>Detectron2 快速开始，使用 WebCam 测试 - GoCodingInMyWay</title>
<link>http://www.cnblogs.com/gocodinginmyway/p/14269765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gocodinginmyway/p/14269765.html</guid>
<description>&lt;p&gt;本文将引导快速使用 Detectron2 ，介绍用摄像头测试实时目标检测。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;h3 id=&quot;基础环境&quot;&gt;基础环境&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Ubuntu 18.04
&lt;/li&gt;
&lt;li&gt;Nvidia Driver
&lt;/li&gt;
&lt;li&gt;Anaconda Python
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;detectron2&quot;&gt;Detectron2&lt;/h3&gt;
&lt;p&gt;安装，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 创建 Python 虚拟环境
conda create -n detectron2 python=3.8 -y
conda activate detectron2

# 安装 PyTorch with CUDA
conda install pytorch==1.7.1 torchvision==0.8.2 cudatoolkit=10.2 -c pytorch -y

# 安装 Detectron2
git clone https://github.com/facebookresearch/detectron2.git
python -m pip install -e detectron2

# 安装 OpenCV ，捕获相机图像及显示
pip install opencv-python
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ python - &amp;lt;&amp;lt;EOF
import torch, torchvision
print(torch.__version__, torch.cuda.is_available())
import cv2 as cv
print(cv.__version__)
EOF

1.7.1 True
4.5.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;现有模型进行推断&quot;&gt;现有模型进行推断&lt;/h2&gt;
&lt;p&gt;从其 &lt;a href=&quot;https://github.com/facebookresearch/detectron2/blob/master/MODEL_ZOO.md&quot; target=&quot;_blank&quot;&gt;model zoo&lt;/a&gt; 选择一个感兴趣的模型进行推断。这里以 &lt;code&gt;COCO&lt;/code&gt; &lt;code&gt;R50-FPN&lt;/code&gt; &lt;code&gt;3x&lt;/code&gt; 训练的各类模型进行演示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112155945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载 &lt;code&gt;model&lt;/code&gt; 进如下路径，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;detectron2/models/
├── COCO-Detection
│   └── faster_rcnn_R_50_FPN_3x
│       └── 137849458
│           ├── metrics.json
│           └── model_final_280758.pkl
├── COCO-InstanceSegmentation
│   └── mask_rcnn_R_50_FPN_3x
│       └── 137849600
│           ├── metrics.json
│           └── model_final_f10217.pkl
├── COCO-Keypoints
│   └── keypoint_rcnn_R_50_FPN_3x
│       └── 137849621
│           ├── metrics.json
│           └── model_final_a6e10b.pkl
└── COCO-PanopticSegmentation
    └── panoptic_fpn_R_50_3x
        └── 139514569
            ├── metrics.json
            └── model_final_c10459.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;目标检测---faster-r-cnn&quot;&gt;目标检测 - Faster R-CNN&lt;/h3&gt;
&lt;p&gt;执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd detectron2/
mkdir -p _output

python demo/demo.py \
--config-file configs/COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml \
--input ../data/bicycle.jpg \
--output _output/bicycle_COCO-Detection.jpg \
--confidence-threshold 0.5 \
--opts MODEL.WEIGHTS models/COCO-Detection/faster_rcnn_R_50_FPN_3x/137849458/model_final_280758.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112143231.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实例分割---mask-r-cnn&quot;&gt;实例分割 - Mask R-CNN&lt;/h3&gt;
&lt;p&gt;执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;python demo/demo.py \
--config-file configs/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml \
--input ../data/bicycle.jpg \
--output _output/bicycle_COCO-InstanceSegmentation.jpg \
--confidence-threshold 0.5 \
--opts MODEL.WEIGHTS models/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112143241.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;姿态估计---keypoint-r-cnn&quot;&gt;姿态估计 - Keypoint R-CNN&lt;/h3&gt;
&lt;p&gt;执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;python demo/demo.py \
--config-file configs/COCO-Keypoints/keypoint_rcnn_R_50_FPN_3x.yaml \
--input ../data/bicycle.jpg \
--output _output/bicycle_COCO-Keypoints.jpg \
--confidence-threshold 0.5 \
--opts MODEL.WEIGHTS models/COCO-Keypoints/keypoint_rcnn_R_50_FPN_3x/137849621/model_final_a6e10b.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112143310.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全景分割---panoptic-fpn&quot;&gt;全景分割 - Panoptic FPN&lt;/h3&gt;
&lt;p&gt;执行，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;python demo/demo.py \
--config-file configs/COCO-PanopticSegmentation/panoptic_fpn_R_50_3x.yaml \
--input ../data/bicycle.jpg \
--output _output/bicycle_COCO-PanopticSegmentation.jpg \
--confidence-threshold 0.5 \
--opts MODEL.WEIGHTS models/COCO-PanopticSegmentation/panoptic_fpn_R_50_3x/139514569/model_final_c10459.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112143319.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;webcam-摄像头使用&quot;&gt;WebCam 摄像头使用&lt;/h3&gt;
&lt;p&gt;获取本机的 WebCam 列表，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ ls /dev/video*
/dev/video0  /dev/video1  /dev/video2  /dev/video3

# 查看 WebCam 列表
#   如下：有 0, 2 两个 videos
#   - 第一个是 video ，第二个是 metadata
#   - 从 Linux Kernel 4.16 开始，增加的 metadata node
$ sudo apt install v4l-utils
$ v4l2-ctl --list-devices
HD Webcam: HD Webcam (usb-0000:00:14.0-13):
        /dev/video0
        /dev/video1

HD Pro Webcam C920 (usb-0000:00:14.0-4):
        /dev/video2
        /dev/video3

# 查看某 WebCam 支持的格式、分辨率、fps 信息
$ v4l2-ctl -d 2 --list-formats-ext
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;demo/demo.py&lt;/code&gt; 可修改期望打开的摄像头及其分辨率等，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-py&quot;&gt;elif args.webcam:
  cam = cv2.VideoCapture(2)
  cam.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
  cam.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
  cam.set(cv2.CAP_PROP_FPS, 30)
  print(f&quot;wencam: {cam.get(cv2.CAP_PROP_FRAME_WIDTH)}x{cam.get(cv2.CAP_PROP_FRAME_HEIGHT)} {cam.get(cv2.CAP_PROP_FPS)}&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;python demo/demo.py \
--config-file configs/COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml \
--webcam \
--confidence-threshold 0.5 \
--opts MODEL.WEIGHTS models/COCO-Detection/faster_rcnn_R_50_FPN_3x/137849458/model_final_280758.pkl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ikuokuo/pic/raw/master/pic/20210112143206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GoCoding 个人实践的经验分享，可关注公众号！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 Jan 2021 15:10:00 +0000</pubDate>
<dc:creator>GoCodingInMyWay</dc:creator>
<og:description>本文将引导快速使用 Detectron2 ，介绍用摄像头测试实时目标检测。 Detectron2: https://github.com/facebookresearch/detectron2 环境准</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gocodinginmyway/p/14269765.html</dc:identifier>
</item>
<item>
<title>人生苦短我用Python，本文助你快速入门 - 耶low</title>
<link>http://www.cnblogs.com/lbhym/p/14269528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbhym/p/14269528.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;友情提示：本文针对的是非编程零基础的朋友，可以帮助我们快速了解Python语法，接着就可以快乐的投入到实战环节了。如果是零基础，还是老老实实看书最为稳妥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;​ 偶然在知乎上看到了一些好玩的Python项目(&lt;a href=&quot;https://www.zhihu.com/question/34098079&quot; target=&quot;_blank&quot;&gt;学 Python 都用来干嘛的？&lt;/a&gt;)，让我对Python产生了些许兴趣。距离北漂实习还有两个月时间，正好可以在这段空闲时间里学一学。如果能做出些小工具，说不定对工作还有帮助，何乐而不为呢？&lt;/p&gt;
&lt;p&gt;​ 关于环境的安装和IDE就不多说了，网上有很多教程。这里贴出一篇博客，大家按里面的步骤安装就行：&lt;a href=&quot;https://blog.csdn.net/qq429477872/article/details/101721869&quot; target=&quot;_blank&quot;&gt;VSCode搭建Python开发环境&lt;/a&gt;。使用VSCode主要是因为免费，而且有大量插件可以下载，大家可以尽情的定制自己的IDE。如果曾经没有使用过VSCode，最好多了解下哪些必须的插件，优化自己的Coding体验。比如：&lt;a href=&quot;https://blog.csdn.net/hnshhshjq/article/details/80140401&quot; target=&quot;_blank&quot;&gt;Python插件推荐&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​ 环境搭建好后，就可以愉快地敲代码了。VSCode需要自己创建Python文件，以.py为后缀。Ctrl+F5运行程序，F5调试程序。&lt;/p&gt;
&lt;h2 id=&quot;python基础&quot;&gt;Python基础&lt;/h2&gt;
&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;​ 单行注释：#&lt;/p&gt;
&lt;p&gt;​ 多行注释：''' (三个英文单引号开头，三个英文单引号结尾)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 这是单行注释

'''
这是多行注释
'''
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;变量&quot;&gt;变量&lt;/h3&gt;
&lt;p&gt;​ Python的变量定义不需要显式指明数据类型，直接【变量名=值】即可。注意变量名分大小写，如Name和name不是同一个变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;name = &quot;小王&quot;
print(name) # 输出 小王
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据类型&quot;&gt;数据类型&lt;/h3&gt;
&lt;p&gt;​ Python提供&lt;strong&gt;6种基础的数据类型&lt;/strong&gt;：数字类型（number）、字符串类型（string）、列表（list）、元组（tuple）、字典（dictionary）、集合（set）。其中数字类型还包括三种数值类型：整型（int）、浮点型（float）、复数类型（complex）。&lt;/p&gt;
&lt;p&gt;​ 列表、元组那些我们留在容器那一节里面讲，先看看数字类型。&lt;/p&gt;
&lt;h4 id=&quot;浮点型&quot;&gt;浮点型&lt;/h4&gt;
&lt;p&gt;​ 浮点型表示小数，我们创建一个浮点型变量，再通过type函数看一看它的类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;pi = 3.1415926
print(type(pi)) # 输出&amp;lt;class 'float'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;strong&gt;int整数型&lt;/strong&gt;就不说了，其为Integer的缩写。&lt;/p&gt;
&lt;h4 id=&quot;复数类型&quot;&gt;复数类型&lt;/h4&gt;
&lt;p&gt;​ 复数类型，所谓复数就是我们中学学的，实数+虚数，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = 10+1.2j # 虚数以j或J结尾
print(type(x)) # 输出&amp;lt;class 'complex'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 刚开始接触复数时，很纳闷为啥会有这种类型，到底有啥实际作用，遂百度了一番：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;mzy0324：微电子方面的运算基本全部都是复数运算。&lt;/p&gt;
&lt;p&gt;hilevel：至少复数用来计算向量的旋转要比矩阵方便多了。科学计算和物理应该会用得到吧。PS:我经常把Python当带编程功能的计算器用，用来调试纯粹的数学算法挺方便的。&lt;/p&gt;
&lt;p&gt;morris88：Python 的一大应用领域，主要是科学计算，主要用于太空宇航、银行等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 联想到Python平时在算法、科学研究等领域应用颇多，所以也就明白了，只是自己没使用的需求而已。&lt;/p&gt;
&lt;h4 id=&quot;字符串&quot;&gt;字符串&lt;/h4&gt;
&lt;p&gt;​ 字符串类型的变量定义用一对&lt;strong&gt;双引号或者单引号&lt;/strong&gt;括起来。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = &quot;Hello Python&quot;
y = 'Hello Python'
print(x,y) # 输出Hello Python Hello Python
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 字符串内置函数：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;find(str[,start,end])&lt;/td&gt;
&lt;td&gt;在字符串中查找子串str，可选参数start和end可以限定范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;count(str[,start,end])&lt;/td&gt;
&lt;td&gt;在字符串中统计子串str的个数，可选参数start和end可以限定范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;replace(old,new[,count])&lt;/td&gt;
&lt;td&gt;在字符串中用new子串替换old子串，可选参数count代表替换个数，默认全部替换&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;split(sep[,maxsplit])&lt;/td&gt;
&lt;td&gt;用指定分隔符sep分割字符，返回一个列表，可选参数maxsplit代表分割几次，默认全部&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;upper()、lower()&lt;/td&gt;
&lt;td&gt;转换大小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;join(序列)&lt;/td&gt;
&lt;td&gt;把序列中的元素用指定字符隔开并生成一个字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;startwith(prefix[,start,end])&lt;/td&gt;
&lt;td&gt;判断字符串中是否以prefix开头，返回bool类型。还有一个&lt;strong&gt;endwith&lt;/strong&gt;，判断结尾的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;strip([,str])&lt;/td&gt;
&lt;td&gt;去掉字符串开头和结尾的空白字符(包括\n、\t这些)，可选参数代表可以去掉指定字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;布尔类型&quot;&gt;布尔类型&lt;/h4&gt;
&lt;p&gt;​ 顺便再说一下布尔类型，不过与Java不同的是，布尔类型的True和False，首字母必须大写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = True
print(type(x)) # 输出&amp;lt;class 'bool'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类型转换&quot;&gt;类型转换&lt;/h3&gt;
&lt;p&gt;​ 说完几个基本的数据类型，不免要提到类型转换。Python内置一些类型转换的函数：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;int(x)&lt;/td&gt;
&lt;td&gt;将x转换为整型（小数转整型会去掉小数部分）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float(x)&lt;/td&gt;
&lt;td&gt;将x转换为浮点型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;str(x)&lt;/td&gt;
&lt;td&gt;将x转换为字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tuple(x)&lt;/td&gt;
&lt;td&gt;将x转换为元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;list(x)&lt;/td&gt;
&lt;td&gt;将x转换为列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set(x)&lt;/td&gt;
&lt;td&gt;将x转换为集合，并去重&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;输入与输出&quot;&gt;输入与输出&lt;/h3&gt;
&lt;p&gt;​ 输入函数为&lt;strong&gt;input&lt;/strong&gt;。input函数返回用户输入的信息为字符串类型。所以如果你输入的是数字类型，&lt;strong&gt;记得类型转换&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = input(&quot;请输入数字&quot;)
print(type(x),x) # 输出&amp;lt;class 'str'&amp;gt; 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 输出前面已经演示了很多次了，函数为&lt;strong&gt;print&lt;/strong&gt;，可以直接输出变量与值。一次输出多个变量可以用&lt;strong&gt;逗号隔开&lt;/strong&gt;，就想上面的演示一样，既要输出类型，也要输出值。&lt;strong&gt;不换行&lt;/strong&gt;输出，可以在print函数里加上end=&quot;&quot;这个参数，因为print默认end=&quot;\n&quot;，\n就是换行的意思。如果想输出特殊字符，可能需要用到转义字符：\。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = 10
y = 20
print(x,y,end=&quot;&quot;) # 输出10 20 加上end=&quot;&quot; 不换行
print(&quot;Hello \\n Python&quot;) # 输出 Hello \n Python
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在输出时，还可以&lt;strong&gt;格式化&lt;/strong&gt;输出内容：%s代表字符串格式、%d代表整型、%f代表浮点型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;z = 1.2
print(&quot;%f&quot;%z) # 输出 1.200000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 除了格式化，%d等还可以当作占位符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;name = &quot;小明&quot;
age = 18
print(&quot;姓名：%s,年龄：%d&quot;%(name,age)) # 姓名：小明,年龄：18
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 如果你闲这个占位符麻烦，还可以使用format函数，占位符只用写一对{}：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;print(&quot;姓名：{},年龄：{}&quot;.format(name,age)) # 姓名：小明,年龄：18
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运算符&quot;&gt;运算符&lt;/h3&gt;
&lt;h4 id=&quot;算术运算符&quot;&gt;算术运算符&lt;/h4&gt;
&lt;p&gt;​ 除了加减乘除，还有幂（**）、取模（%）、取整（//）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = 3 ** 2 # x=9 即3的2次方 
y = 5 % 3 # y=2 即5除以3余2
z = 5 // 2 # z=2 即5除以2,整数部分为2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;比较运算符&quot;&gt;比较运算符&lt;/h4&gt;
&lt;p&gt;​ 和其他常用编程语言基本一模一样，不等于（!=）、大于等于（&amp;gt;=）、等于（==）。&lt;/p&gt;
&lt;h4 id=&quot;赋值运算符&quot;&gt;赋值运算符&lt;/h4&gt;
&lt;p&gt;​ Python也支持+=、*=等形式的赋值运算。除此之外，当然也支持前面说到的幂、取模等算术运算符，如取整并赋值（//=）、取模并赋值（%=）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = 10
x %= 3
print(x) # 输出1 ,x%=3 意为 x = x%3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;逻辑运算符&quot;&gt;逻辑运算符&lt;/h4&gt;
&lt;p&gt;​ 非（not）、与（and）、或（or）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;x = True
print(not x) # 输出 False
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;if、while、for&quot;&gt;if、while、for&lt;/h3&gt;
&lt;p&gt;​ 这三个和其他编程语言基本没差，就是写法上有点区别。首先没了大括号，条件语句后以&lt;strong&gt;冒号&lt;/strong&gt;开头；代码快有&lt;strong&gt;严格的缩进要求&lt;/strong&gt;，因为没了大括号，缩进就是条件语句判断自己代码快范围的依据。其他的基本一样，比如continue跳过当次循环，break跳出整个循环体。下面看三个简单的例子就明白了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 10
# if或else后面是冒号，代码块还需要缩进
if a &amp;gt;= 10:
    print(&quot;你好啊老大&quot;)
else:
    print(&quot;滚蛋&quot;)
    
# 同样的while后面也需要冒号，代码块必须缩进。（Python没有num++，得写成num+=1）
# print想不换行打印，最后得加个end=&quot;&quot;,因为默认有一个end=&quot;\n&quot;
# &quot; &quot;*(j-i),代表j-i个空格
i = 1
j = 4
while i &amp;lt;= j:
    print(&quot; &quot;*(j-i), end=&quot;&quot;)
    n = 1
    while n &amp;lt;= 2*i-1:
        print(&quot;*&quot;, end=&quot;&quot;)
        n += 1
    print(&quot;&quot;)
    i += 1

# 语法：for 变量 in 序列 ,还没讲序列，暂时用range表示，代表1-21的序列
# continue略过当次循环，break跳出整个循环
for i in range(1, 21):
    if i % 2 == 0:
        if(i % 10 == 0):
            continue
        if(i &amp;gt;= 15):
            break
        print(i)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;
&lt;h3 id=&quot;列表&quot;&gt;列表&lt;/h3&gt;
&lt;p&gt;​ 列表使用一对[]定义，每个元素用逗号隔开，元素类型不强求相同，通过索引获取列表元素。具体的我们看下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;info_list = [&quot;小红&quot;, 18, &quot;男&quot;] #可以不是同一类型
info_list[2] = &quot;女&quot; # 修改指定索引位置的元素
del info_list[1] # 删除指定索引位置的元素
info_list.remove(&quot;女&quot;) # 删除列表中指定的值
for att in info_list:   # 遍历元素
    print(att)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 上面的示例代码演示了部分列表的用法，下面再列出一些其他的常用函数或语法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数或语法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list.append(element)&lt;/td&gt;
&lt;td&gt;向列表list结尾添加元素（这个元素也可以是个列表）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;list.insert(index,element)&lt;/td&gt;
&lt;td&gt;向列表指定位置添加元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list.extend(new_list)&lt;/td&gt;
&lt;td&gt;向列表list添加new_list的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list.pop([,index])&lt;/td&gt;
&lt;td&gt;弹出最后一个元素，可选参数index，弹出指定位置元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;list.sort([,reverse=True])&lt;/td&gt;
&lt;td&gt;对列表排序，可选参数reverse=True表示降序&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list[start:end]&lt;/td&gt;
&lt;td&gt;对列表分片，start和end代表起始结束索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;list1+list2&lt;/td&gt;
&lt;td&gt;拼接两个列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;元组&quot;&gt;元组&lt;/h3&gt;
&lt;p&gt;​ 元组用一对（）定义。元组也是有序的，它和列表的区别就是，列表可以修改元素，元组不行。正是因为这个特点，元组占用的内存也比列表小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;name_list=(&quot;小红&quot;,&quot;小王&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字典&quot;&gt;字典&lt;/h3&gt;
&lt;p&gt;​ 字典使用一对{}定义，元素是键值对。用法示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;user_info_dict = {&quot;name&quot;: &quot;小王&quot;, &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;男&quot;}
name = user_info_dict[&quot;name&quot;] # 直接用key获取value
age = user_info_dict.get(&quot;age&quot;) # 也可以用get(key)获取value
user_info_dict[&quot;tel&quot;] = &quot;13866663333&quot; # 当key不存在，就是往字典添加键值对，如果存在就是修改value
del user_info_dict[&quot;tel&quot;] # 删除指定键值对
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 以上就是常用语法和函数。字典也可以遍历，只是遍历时，需要指定遍历的是key还是value，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;for k in dict.keys(): # 遍历所有key
for v in dict.values(): # 遍历所有value
for item in dict.items(): # 也可以直接遍历键值对
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合&quot;&gt;集合&lt;/h3&gt;
&lt;p&gt;​ 集合是无序的，也用一对{}定义，但不是键值对了，是单独且不重复的元素。部分用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;user_id_set = {&quot;1111&quot;,&quot;22222&quot;,&quot;3333&quot;} # 元素不重复
print(type(user_id_set)) # 输出&amp;lt;class 'set'&amp;gt;
# 除了直接用{}定义，还可以用set函数传入一个序列，其会为list去重，并返回一个集合（如果是字符串，字符串会被拆成字符）
new_user_id_set = set(list) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 上面演示了部分用法，下面我们用一个表格展示一些常用的函数或语法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数或语法&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;element in set&lt;/td&gt;
&lt;td&gt;判断元素是否在集合中，返回布尔类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;element not in set&lt;/td&gt;
&lt;td&gt;判断元素是否不在集合中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set.add(element)&lt;/td&gt;
&lt;td&gt;向集合添加元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set.update(list,.....)&lt;/td&gt;
&lt;td&gt;将序列中的每个元素去重并添加到集合中，如果有多个序列，用逗号隔开&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set.remove(element)&lt;/td&gt;
&lt;td&gt;删除指定元素，如果元素不存在就会报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set.discard(element)&lt;/td&gt;
&lt;td&gt;删除指定元素，如果元素不存在也不会报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set.pop()&lt;/td&gt;
&lt;td&gt;随机删除集合中的元素，并返回被删除的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;set1 &amp;amp; set2 或set1 intersection set2&lt;/td&gt;
&lt;td&gt;求两个集合的交集，两种用法结果一样&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set1 | set2 或set1 union set2&lt;/td&gt;
&lt;td&gt;求两个集合的并集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;set1 - set2 或set1.difference(set2)&lt;/td&gt;
&lt;td&gt;求两个集合的差集，注意顺序。set1-set2代表set1有set2没有的元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;h3 id=&quot;函数的定义&quot;&gt;函数的定义&lt;/h3&gt;
&lt;p&gt;​ Python中函数用&lt;strong&gt;def&lt;/strong&gt;定义，格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def function_name(参数列表): # 参数可为空，多个参数用逗号隔开
        函数体
        return 返回值 #可选

# 函数的调用
function_name(参数列表)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;缺省参数&quot;&gt;缺省参数&lt;/h3&gt;
&lt;p&gt;​ 和循环体一样的，因为没有了大括号，所以&lt;strong&gt;缩进是严格要求的&lt;/strong&gt;。除了上面那种比较常见的格式，Python函数的参数中，还有一种缺省参数，即&lt;strong&gt;带有默认值的参数&lt;/strong&gt;。调用带有缺省参数的函数时，可以不用传入缺省参数的值，如果传入了缺省参数的值，则会使用传入的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_add(x,y=10): # y为缺省函数，如果调用这个函数只传入了x的值，那么y默认为10
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命名参数&quot;&gt;命名参数&lt;/h3&gt;
&lt;p&gt;​ 一般情况下，调用函数传入实参时，都会遵循参数列表的顺序。而命名参数的意思就是，调用函数时，通过参数名传入实参，这样可以不用按照参数定义的顺序传入实参。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def num_add(x, y):
    print(&quot;x:{},y:{}&quot;.format(x, y))
    return x+y
# 输出：
# x:10,y:5
# 15
print(num_add(y=5, x=10))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不定长参数&quot;&gt;不定长参数&lt;/h3&gt;
&lt;p&gt;​ 不定长参数可以接收任意多个参数，Python中有两种方法接收：1.在参数前加一个*，传入的参数会放到元组里；2.在参数前加两个**，代表接收的是键值对形式的参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 一个*
def eachNum(*args):
    print(type(args))
    for num in args:
        print(num)
# 输出：
# &amp;lt;class 'tuple'&amp;gt;‘
# (1, 2, 3, 4, 5)
eachNum(1,2,3,4,5)

## 两个**。这个other是想告诉你，在使用不定长参数时，也可以搭配普通的参数
def user_info(other,**info):
    print(type(info))
    print(&quot;其他信息：{}&quot;.format(other))
    for key in info.keys():
        print(&quot;{} : {}&quot;.format(key,info[key]))
# 传入参数时，不用像定义字典一样，加个大括号再添加键值对，直接当命名参数传入即可
# 输出：
# &amp;lt;class 'dict'&amp;gt;
# 其他信息：管理员
# 略...
user_info(&quot;管理员&quot;,name=&quot;赵四&quot;,age=18,gender=&quot;男&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 上面示例代码中的注释说到了，当使用不定长参数时，不用像字典或者元组的定义那样，直接传入参数即可。但有时候，可能会遇到想把字典、元组等容器中的元素传入到不定长参数的函数中，这个时候就需要用到&lt;strong&gt;拆包&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;​ 所谓拆包，其实就是在传入参数时，在容器前面加上一个或两个*。还是以上面的user_info函数为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;user_info_dict={&quot;name&quot;:&quot;赵四&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;}
user_info(&quot;管理员&quot;,**user_info_dict) # 效果和上面一样
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 注意，如果接收方的不定长参数只用了一个 * 定义，那么传入实参时，也只能用一个 *。&lt;/p&gt;
&lt;h3 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h3&gt;
&lt;p&gt;​ 匿名函数，即没有名字的函数。在定义匿名函数时，既不需要名称，也不需要def关键字。语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lambda 参数列表: 表达式
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 多个参数用逗号隔开，匿名函数会自动把表达式的结果return。在使用时，一般会用一个变量接收匿名函数，或者直接把匿名函数当参数传入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;sum = lambda x,y : x+y
print(sum(1,2)) # 输出3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;闭包和装饰器&quot;&gt;闭包和装饰器&lt;/h3&gt;
&lt;p&gt;​ 在Python中，函数内还可以定义函数，外面这个函数我们就称为外部函数，里面的函数我们就称为内部函数。而外部函数的返回值是&lt;strong&gt;内部函数的引用&lt;/strong&gt;，这种表达方式就是&lt;strong&gt;闭包&lt;/strong&gt;。内部函数可以调用外部函数的变量，我们看一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 外部函数
def sum_closure(x):
    # 内部函数
    def sum_inner(y):
        return x+y
    return sum_inner # 返回内部函数
# 获取了内部函数
var1 = sum_closure(1)
print(var1) # 输出&amp;lt;function sum_closure.&amp;lt;locals&amp;gt;.sum_inner at 0x000001D82900E0D0&amp;gt;，是个函数类型
print(var1(2)) # 输出3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 说完闭包的用法，接着了解一下&lt;strong&gt;装饰器&lt;/strong&gt;。不知道大家了解过AOP没，即面向切面编程。说人话就是在目标函数前后加上一些公共函数，比如记录日志、权限判断等。Python中当然也提供了实现切面编程的方法，那就是装饰器。装饰器和闭包一起，可以很灵活的实现类似功能，下面看示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import datetime #如果没有这个包，在终端里输入pip3 install datetime
# 外部函数，其参数是目标函数
def log(func):
    #内部函数，参数得和目标函数一致。也可以使用不定长参数，进一步提升程序灵活性
    def do(x, y):
        # 假装记录日志，执行切面函数。（第一次datetime是模块、第二个是类、now是方法。在下一节讲到模块）
        print(&quot;时间：{}&quot;.format(datetime.datetime.now()))
        print(&quot;记录日志&quot;)
        # 执行目标函数
        func(x, y)
    return do

# @就是装饰器的语法糖，log外部函数
@ log
def something(x, y):
    print(x+y)
    
# 调用目标函数
# 输出：
# 时间：2021-01-06 16:17:00.677198
# 记录日志
# 30
something(10, 20)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 函数相关的就说到这里了，其实还有一些知识没说到，比如变量的作用域、返回值等。这部分内容和其他语言几乎无异，一点区别无非就是返回值不用在乎类型了，毕竟定义函数时也没指定函数返回值类型，这一点各位老司机应该也会想到。&lt;/p&gt;
&lt;h2 id=&quot;包和模块&quot;&gt;包和模块&lt;/h2&gt;
&lt;h3 id=&quot;包&quot;&gt;包&lt;/h3&gt;
&lt;p&gt;​ Python中包与普通文件夹的区别就是，包内要创建一个__init__.py文件，来标识它是一个包。这个文件可以是空白的，也可以定义一些&lt;strong&gt;初始化操作&lt;/strong&gt;。当其他包下的模块调用本包下的模块时，&lt;strong&gt;会自动的执行__init__.py文件的内容&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;
&lt;p&gt;​ 一个Python文件就是一个模块，不同包下的模块可以重名，在使用的时候以“包名.模块名”区别。导入其他模块用import关键字，前面的示例代码中也演示过一次。导入多个模块可以用逗号隔开，也可以直接分开写。除了导入整个模块，还可以导入模块中指定的函数或类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from model_name import func_name(or class_name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 导入函数或类后，就不要使用模块名了，&lt;strong&gt;直接调用导入的类或函数即可&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;面向对象&lt;/h2&gt;
&lt;h3 id=&quot;类和对象&quot;&gt;类和对象&lt;/h3&gt;
&lt;p&gt;​ Python是一种面向对象的解释型编程语言。面向对象的关键就在于类和对象。Python中类的定义用class关键字，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class 类名:
        def 方法名(self[,参数列表])
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 定义在类里面的函数叫做方法，只是与类外部的函数做个区分，不用在意叫法。类里面的方法，参数列表中会有一个默认的参数，表示当前对象，&lt;strong&gt;你可以当作Java中的this&lt;/strong&gt;。因为一个类可以创建多个对象，有了self，Python就知道自己在操作哪个对象了。我们在调用这个方法时，&lt;strong&gt;不需要手动传入self&lt;/strong&gt;。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Demo:
    def do(self):
        print(self)
# 创建两个Demmo类型的对象
demo1=Demo()
demo1.do() # 输出&amp;lt;__main__.Demo object at 0x0000019C78106FA0&amp;gt;
demo2=Demo() 
demo2.do() # 输出&amp;lt;__main__.Demo object at 0x0000019C77FE8640&amp;gt;
print(type(demo1)) # &amp;lt;class '__main__.Demo'&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造方法&quot;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;​ 构造方法的作用是在创建一个类的对象时，对对象进行初始化操作。Python中类的构造方法的名称是__init__（两边分别两个下划线）。在创建对象时，__init__方法自动执行。和普通方法一样的，如果你想自定义构造方法，也要接收self参数。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Demo:
    # 构造方法，还可以传入其他参数化
    def __init__(self,var1,var2):
        # 把参数设置到当前对象上，即使类中没有属性也可以设置
        self.var1=var1
        self.var2=var2
        print(&quot;初始化完成&quot;)
    def do(self):
        print(&quot;Working...&quot;)
# 通过构造方法传入实参
demo1=Demo(66,77)
demo1.do()
# 通过当前对象，获取刚刚设置的参数
print(demo1.var1)
print(demo1.var2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问权限&quot;&gt;访问权限&lt;/h3&gt;
&lt;p&gt;​ Java或C#中有好几种访问权限，在Python中，&lt;strong&gt;属性和方法前添加两个下划线&lt;/strong&gt;即为私有，反之就是共公有。具有私有访问权限的属性和方法，&lt;strong&gt;只能在类的内部方法&lt;/strong&gt;，外部无法访问。和其他语言一样，私有的目的是为了保证属性的准确性和安全性，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Demo:
    # 为了方便理解，我们显示的设置一个私有属性
    __num = 10
    # 公有的操作方法，里面加上判断，保证数据的准确性
    def do(self, temp):
        if temp &amp;gt; 10:
            self.__set(temp)
        # 私有的设置方法，不让外部直接设置属性
    def __set(self, temp):
        self.__num = temp
        # 公有的get方法
    def get(self):
        print(self.__num)

demo1 = Demo()
demo1.do(11)
demo1.get() # 输出 11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 一堆self.刚开始看时还有点晕乎，把它当作this就好。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;p&gt;​ 继承是面向对象编程里另一大利器，好处之一就是代码重用。子类只能继承父类的&lt;strong&gt;公有属性和方法&lt;/strong&gt;，Python的语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class SonClass(FatherClass):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 当我们创建一个SonClass对象时，直接可以用该对象调用FatherClass的公有方法。Python还支持多继承，如果是多继承就在小括号里把父类用逗号隔开。&lt;/p&gt;
&lt;p&gt;​ 如果想在子类里面调用父类的方法，一般有两种方式：1.父类名.方法名(self[,参数列表])。此时的self是子类的self，且需要显示传入；2.super().方法名()。第二种方式因为没有指定父类，所以在多继承的情况下，如果调用了这些父类中同名的方法，Python实际会执行小括号里写在前面的父类中的方法。&lt;/p&gt;
&lt;p&gt;​ 如果子类定义了与父类同名的方法，子类的方法就会覆盖父类的方法，这就是&lt;strong&gt;重写&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;
&lt;h3 id=&quot;捕获异常&quot;&gt;捕获异常&lt;/h3&gt;
&lt;p&gt;​ 捕获异常的语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try: 
    代码快 # 可能发生异常的代码
except (异常类型,...) as err: # 多个异常类型用逗号隔开，如果只有一个异常类型可以不要小括号。err是取的别名
    异常处理 
finally:
    代码快 # 无论如何都会执行
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在try代码块中，错误代码之后的代码是不会执行的，但&lt;strong&gt;不会影响到try ... except之外的代码&lt;/strong&gt;。看个示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    open(&quot;123.txt&quot;) #打开不存在的文件，发生异常
    print(&quot;hi&quot;) # 这行代码不会执行
except FileNotFoundError as err:
    print(&quot;发生异常：{}&quot;.format(err)) # 异常处理

print(&quot;我是try except之外的代码&quot;) #正常执行
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 虽然上面的内容和其他语言相差不大，但是刚刚接触Python鬼知道有哪些异常类型，有没有类似Java的Exception异常类型呢？肯定是有的。Python同样提供了&lt;strong&gt;Exception&lt;/strong&gt;异常类型来捕获全部异常。&lt;/p&gt;
&lt;p&gt;​ 那如果发生异常的代码没有用try except捕获呢？这种情况要么直接报错，程序停止运行。要么会被外部的try except捕获到，也就是说&lt;strong&gt;异常是可以传递的&lt;/strong&gt;。比如func1发生异常没有捕获，func2调用了func1并用了try except，那么func1的异常会被传递到func2这里。是不是和Java的throws差不多？&lt;/p&gt;
&lt;h3 id=&quot;抛出异常&quot;&gt;抛出异常&lt;/h3&gt;
&lt;p&gt;​ Python中抛出异常的关键字是&lt;strong&gt;raise&lt;/strong&gt;，其作用和Java的throw new差不多。示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def do(x):
    if(x&amp;gt;3): # 如果大于3就抛出异常
        raise Exception(&quot;不能大于3&quot;) # 抛出异常，如果你知道具体的异常最好，后面的小括号可以写上异常信息
    else:
        print(x)

try:
    do(4)
except Exception as err:
    print(&quot;发生异常：{}&quot;.format(err)) # 输出 发生异常：不能大于3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件操作&quot;&gt;文件操作&lt;/h2&gt;
&lt;h3 id=&quot;读写文件&quot;&gt;读写文件&lt;/h3&gt;
&lt;p&gt;​ 想要操作一个文件，首先得打开它。Python中有个内置的函数：&lt;strong&gt;open&lt;/strong&gt;。使用open打开文件可以有三种模式，分别为：只读（默认的模式，只能读取文件内容，r表示）、只写（会覆盖原文本内容，w表示）、追加（新内容追加到末尾，a表示）。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;f = open(&quot;text.txt&quot;,&quot;a&quot;) # 用追加的方式获取文件对象
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 因为text.txt和代码在同一目录所以只写了文件名，如果不在同一目录需要写好相对路径或绝对路径。&lt;/p&gt;
&lt;p&gt;​ 获取到文件对象后，接下来就可以操作了，反正就是些API，直接看示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;f = open(&quot;text.txt&quot;,&quot;a&quot;,encoding=&quot;utf-8&quot;) # 以追加的方式打开文件，并设置编码方式，因为接下来要写入中文
f.write(&quot;234567\n&quot;) # 写入数据，最后的\n是换行符，实现换行
f.writelines([&quot;张三\n&quot;,&quot;赵四\n&quot;,&quot;王五\n&quot;]) # write只能写一个字符串，writelines可以写入一列表的字符串
f.close() # 操作完记得关闭
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 以上是写文件的两个方法。最后记得关闭文件，因为操作系统会把写入的内容缓存起来，万一系统崩溃，写入的数据就会丢失。虽然程序执行完文件会自动关闭，但是实际项目中，肯定不止这点代码。Python也很贴心，防止我们忘了close，提供了一种安全打开文件的方式，语法是 with open() as 别名：，示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;with open(&quot;test.txt&quot;,&quot;w&quot;) as f: # 安全打开文件，不需要close。
    f.write(&quot;123&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 写完了，该读一读了。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;f = open(&quot;text.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
data = f.read() # read会一次性读出所有内容
print(data)
f.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 除了一次性读取完，还可以按行的方式返回全部内容，并用一个列表装起来，这样我们就可以进行遍历了。方法是readlines，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;f = open(&quot;text.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
lines = f.readlines() # lines是个列表
for line in lines:
    print(line)
f.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件管理&quot;&gt;文件管理&lt;/h3&gt;
&lt;p&gt;​ 在操作文件的时候，肯定不止读写这么简单，可能还会涉及文件的删除、重命名、创建等等。在用Python的函数操作文件之前，需要导入os模式：&lt;code&gt;import os&lt;/code&gt; 。下面简单的演示一下重命名的函数，其他的函数我们以表格的形式展现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import os
os.rename(&quot;text.txt&quot;,&quot;123.txt&quot;) # 把text.txt改名为123.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;os.remove(path)&lt;/td&gt;
&lt;td&gt;删除指定文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;os.mkdir(path)&lt;/td&gt;
&lt;td&gt;在指定路径下创建新文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;os.getcwd()&lt;/td&gt;
&lt;td&gt;获取程序运行的绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;os.listdir(path)&lt;/td&gt;
&lt;td&gt;获取指定路径下的文件列表，包含文件和文件夹&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;os.redir(path)&lt;/td&gt;
&lt;td&gt;删除指定路径下的空文件夹（如果不是空文件夹就会报错）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;操作json&quot;&gt;操作JSON&lt;/h3&gt;
&lt;p&gt;​ 学了前面的容器，会发现JSON的格式和Python的字典有点像，都是键值对形式的。虽然格式很像，但还是有点小区别，比如：Python的元组和列表在JSON中都是列表、Python的True和Flase会被转换成小写、空类型None会被转换成null。下面我们来看一些具体的函数把。&lt;/p&gt;
&lt;p&gt;​ 在Python中操作JSON格式的数据需要导入json模块。同样的，我这里只演示一个函数，其他常用的用表格列出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import json
user_info={&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;,&quot;hobby&quot;:(&quot;唱歌&quot;,&quot;跳舞&quot;,&quot;打篮球&quot;),&quot;other&quot;:None} # 创建一个字典
json_str=json.dumps(user_info,ensure_ascii=False) # dumps函数会把字典转换为json字符串
# 输出 {&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;男&quot;, &quot;hobby&quot;: [&quot;唱歌&quot;, &quot;跳舞&quot;, &quot;打篮球&quot;], &quot;other&quot;: null}
print(json_str)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 需要注意如果数据存在中文，需要在dumps函数加上&lt;code&gt;ensure_ascii=False&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;json.loads(json_str)&lt;/td&gt;
&lt;td&gt;把json字符串转换为Python数据结构&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;json.dump(user_info,file)&lt;/td&gt;
&lt;td&gt;把Python数据写入到json文件，要先获取文件，那个file就是文件对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;json.load(file)&lt;/td&gt;
&lt;td&gt;把json文件中的数据转为成Python数据结构，同样需要获取文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 关于JSON的操作就说这些。通用的数据格式不止JSON一种，比如还有xml、csv等。为了节约篇幅，就不再赘述了，大家可以根据自己的需求查对应的API即可。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h2&gt;
&lt;p&gt;​ 最后一节讲正则表达式，一是因为这也算个基础知识，在很多地方都有可能用到。二是因为后面的爬虫实战，肯定会用到正则表达式来解析各种数据。&lt;/p&gt;
&lt;p&gt;​ Python中内置了re模块来处理正常表达式，有了这个模块我们就可以很方便的对字符串进行各种规则匹配检查。不过正则表达式真正难的是表达式的书写，函数主要就一个：&lt;code&gt;re.match(pattern,string)&lt;/code&gt;，其中pattren就是正则表达式，stirng就是待匹配字符串。如果匹配成功就会返回一个Match对象，否则就返回None。&lt;strong&gt;匹配是从左往右，如果不匹配就直接返回None，不会接着匹配下去&lt;/strong&gt;。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import re
res=re.match(&quot;asd&quot;,&quot;asdabcqwe&quot;) # 匹配字符串中是否有asd(如果asd不在开头就会返回None)
print(res) # 输出 &amp;lt;re.Match object; span=(0, 3), match='asd'&amp;gt;
print(res.group()) # 输出 asd 如果想获取匹配的子字符就用这个函数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 秉着帮人帮到底的精神，下面就简单的介绍下正则表达式的一些规则。&lt;/p&gt;
&lt;h3 id=&quot;单字符匹配&quot;&gt;单字符匹配&lt;/h3&gt;
&lt;p&gt;​ 单字符匹配，顾名思义就是匹配一个字符。除了直接使用某个具体的字符，还可以使用以下符号来进行匹配：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除”\n“以外的任意单个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配0-9之间的一个数字，等价于[0-9]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配一个非数字字符，等价于[^0-9]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配任意空白字符，如空格、\t、\n等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配任意非空白字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配单词字符，包括字母、数字、下划线&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配非单词字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;匹配[]中列举的字符，比如[abc]，只要出现这三个字母中的一个即可匹配&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 以防有的朋友从未接触过正则表达式，不知道怎么用，下面我来做个简答的演示。假如我想匹配三个字符：第一个是数字、第二个是空格、第三个是字母，一起来看看怎么写这个正则表达式吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import re
pattern = &quot;\d\s\w&quot; # \d匹配数字、\s匹配空格、\w匹配字母（切记是从左往右依次匹配的，只要有一个字符匹配不上就直接返回None）
string = &quot;2 z你好&quot;
res=re.match(pattern,string)
print(res.group()) # 输出:2 z
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 看到这你可能会想，非得一个个字符匹配，那多麻烦啊，有没有更灵活的规则？当然有了，接着看。&lt;/p&gt;
&lt;h3 id=&quot;数量表示&quot;&gt;数量表示&lt;/h3&gt;
&lt;p&gt;​ 如果我们只想匹配字母，但不限制有多少个，该怎么写呢？看下面的表格就知道了：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配一个字符出现0次或多次&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;匹配一个字符至少出现一次，等价于{,1}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;匹配一个字符出现0次或1次，等价于{1,2}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{m}&lt;/td&gt;
&lt;td&gt;匹配一个字符出现m次&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{m,}&lt;/td&gt;
&lt;td&gt;匹配一个字符至少出现m次&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{m,n}&lt;/td&gt;
&lt;td&gt;匹配一个字符出现m到n次&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 数量匹配的符号后面如果加上&lt;code&gt;?&lt;/code&gt;，&lt;strong&gt;就会尽可能少的去匹配字符&lt;/strong&gt;，在Python里面叫非贪婪模式，反之默认的就是贪婪模式。比如&lt;code&gt;{m,}&lt;/code&gt;会尽可能多的去匹配字符，而&lt;code&gt;{m,}?&lt;/code&gt;在满足至少有m个的情况下尽可能少的去匹配字符。其他的同理。&lt;/p&gt;
&lt;p&gt;​ 来看一个例子，我想匹配开头是任意个小写字母，接着是1到5个2-6的数字，最后是至少一个空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import re
pat = r&quot;[a-z]*[2-6]{1,5}\s+&quot;
str = &quot;abc423  你好&quot;
res=re.match(pat,str) 
print(res) #输出 abc423  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 我们来解析下这个正则表达式，pat字符串开头的r是告诉Python这是个正则表达式，不要转义里面的\，建议写表达式时都加上。&lt;code&gt;[a-z]&lt;/code&gt;代表任意小写字母，不用\w的原因是，\w还包括数字、下划线，没有严格符合我们的要求。加上个*就代表任意数量。这里强调一下&lt;strong&gt;单字符匹配和数量表示之间的逻辑关系&lt;/strong&gt;，以&lt;code&gt;[a-z]*&lt;/code&gt;为例，&lt;strong&gt;其表达的是任意个&lt;code&gt;[a-z]&lt;/code&gt;，而不是某个字母有任意个&lt;/strong&gt;。明白了这个逻辑后，其他的也好理解了。&lt;/p&gt;
&lt;p&gt;​ 前面的例子都是我随意编的，其实学了这些，已经可以写出一个有实际作用的表达式了，比如我们来匹配一个手机号。首先手机号只有11位，第一个数字必须是1，第二个是3、5、7、8中的一个。知道了这三个个规律，我们来写一下表达式：&lt;code&gt;1[3578]\d{9}&lt;/code&gt;。看上去好像可以，但是仔细一想，前面不是说了正则表达式是从左往右匹配，只要符合了就会返回结果，也不会管字符串匹配完全没有。如果最后有10个数字，这个表达式也会匹配成功。关于这个问题我们接着看。&lt;/p&gt;
&lt;h3 id=&quot;边界表示&quot;&gt;边界表示&lt;/h3&gt;
&lt;p&gt;​ 边界表示符有两个：开头&lt;code&gt;^&lt;/code&gt;和结尾&lt;code&gt;$&lt;/code&gt;。使用起来也很简单，还是以上面的手机号为例，我们再来完善一下：&lt;code&gt;^1[3578]\d{9}$&lt;/code&gt;。其中&lt;code&gt;^1&lt;/code&gt;表示以1开头，&lt;code&gt;\d{9}$&lt;/code&gt;表示以9个数字结尾。其实这个&lt;code&gt;^1&lt;/code&gt;可有可无，毕竟是从左往右的，字符串不是1开头的话直接就会返回None，但是这个结尾符是必须的。&lt;/p&gt;
&lt;h3 id=&quot;转义字符&quot;&gt;转义字符&lt;/h3&gt;
&lt;p&gt;​ 假如我们想匹配的字符与正则表达式规定的这些字符一样该怎么办？比如我们想单纯的匹配&lt;code&gt;.&lt;/code&gt;这个字符，但是这个字符在正则表达式中表示的是任意字符。这时候就要用到转义字符&lt;code&gt;\&lt;/code&gt;了。其实这个转义字符在很多语言里都是一样的。那么前面的例子就可以写出&lt;code&gt;\.&lt;/code&gt;。我们再演示个匹配邮箱的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import re
pat = r&quot;^\w{4,10}@qq\.com&quot; # 如果.前面不加\，就代表任意字符了
str = &quot;1234@qq.com&quot;
res=re.match(pat,str)
print(res)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匹配分组&quot;&gt;匹配分组&lt;/h3&gt;
&lt;p&gt;​ 看到上面的匹配邮箱例子，是不是有个疑问，如果我想不止匹配QQ邮箱该怎么办呢。那就要用到分组了，其可以实现匹配多种情况。分组符号如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;将括号里的内容当作一个分组，每个分组会有一个编号，从1开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;连接多个表达式，表达式之间是“或”的关系，可与()一起使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\num&lt;/td&gt;
&lt;td&gt;引用分组，num代表分组编号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(?P...)&lt;/td&gt;
&lt;td&gt;给分组取别名，别名写在表达式前面，name不用打引号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(?P=name)&lt;/td&gt;
&lt;td&gt;根据别名使用分组中的正则表达式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ 那么我们把上面的例子稍微修改下：&lt;code&gt;^\w{4,10}@(qq|163|outlook|gmail)\.com&lt;/code&gt;。这样就可以匹配多种邮箱了。&lt;/p&gt;
&lt;p&gt;​ 简单的演示了下&lt;code&gt;|&lt;/code&gt;的用法，大家可能对其他的分组符号还有点疑惑，下面我们再来演示一下这些符号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import re
pat = r&quot;&amp;lt;(.+)&amp;gt;&amp;lt;(.+)&amp;gt;.*&amp;lt;(/\2)&amp;gt;&amp;lt;(/\1)&amp;gt;&quot; 
str = &quot;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&quot;
res=re.match(pat,str)
print(res)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 这个表达式匹配的是由两个标签组成的html字符串。第一眼看上去有点麻烦，实际很简单。再次强调一下，普通字符也可以当表达式来匹配的，比如上面的&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt;就是普通字符而已。&lt;/p&gt;
&lt;p&gt;​ 我们来分析一下这个表达式，首先一对小括号表示一个分组，里面的&lt;code&gt;.+&lt;/code&gt;表示只有一个非\n字符。中间的&lt;code&gt;.*&lt;/code&gt;用来匹配标签内的内容。&lt;code&gt;/\2&lt;/code&gt;中，第一个斜杠与前面的html标签组成一对，/2表示引用第二个分组的内容。这里为什么要使用分组呢？&lt;strong&gt;因为我们还要保证html标签正确匹配&lt;/strong&gt;。如果后面也使用&lt;code&gt;.+&lt;/code&gt;，大家可以试着把&lt;code&gt;/div&lt;/code&gt;和&lt;code&gt;/body&lt;/code&gt;交换位置，表达式依旧匹配成功，但这显然不符合html的语法。&lt;/p&gt;
&lt;h3 id=&quot;操作函数&quot;&gt;操作函数&lt;/h3&gt;
&lt;p&gt;​ 正则表达式的一些规则符号终于讲完了，最后再列举几个Python中操作正则表达式的函数：（re为导入的模块）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;re.compile(patt)&lt;/td&gt;
&lt;td&gt;封装正则表达式，并返回一个表达式对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;re.search(patt,str)&lt;/td&gt;
&lt;td&gt;从左往右搜索第一个配正则表达式匹配的子字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;re.findall(patt,str)&lt;/td&gt;
&lt;td&gt;在字符串中查找正则表达式匹配到的所有子字符串，并返回一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;re.finditer(patt,str)&lt;/td&gt;
&lt;td&gt;在字符串中查找正则表达式匹配到的所有子字符串，并返回一个Iterator对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;re.sub(patt,newstr,str)&lt;/td&gt;
&lt;td&gt;将字符串中被正则表达式匹配到的子字符串替换成newstr，并返回新的字符串，原字符串不变&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;​ Python的第一篇文章就到这里了。接下来会边学边写，做一些好玩的Python项目，再一起分享出来。如有错误，感谢指出！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考资料：《Python 3快速入门与实战》&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 12 Jan 2021 14:05:00 +0000</pubDate>
<dc:creator>耶low</dc:creator>
<og:description>友情提示：本文针对的是非编程零基础的朋友，可以帮助我们快速了解Python语法，接着就可以快乐的投入到实战环节了。如果是零基础，还是老老实实看书最为稳妥。 前言 ​	偶然在知乎上看到了一些好玩的Pyt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lbhym/p/14269528.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 RabbitMQ Masstransit 介绍）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14269509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14269509.html</guid>
<description>&lt;ul&gt;&lt;li&gt;Masstransit 是什么&lt;/li&gt;
&lt;li&gt;Quickstart&lt;/li&gt;
&lt;li&gt;消息 Message&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;masstransit-是什么&quot;&gt;Masstransit 是什么&lt;/h2&gt;
&lt;p&gt;Masstransit 是一个 .NET 免费开源的分布式应用框架&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集成多种消息中间件（Rabbitmq, Azure, Service Bus, ActiveMQ, Kafka, In-Memory）&lt;/li&gt;
&lt;li&gt;强大且完整的消息模式（发布与订阅，saga，event-driven state machine，最终一致性支持）&lt;/li&gt;
&lt;li&gt;端到端解决方案（消息路由，异常，重试，并发控制，连接与消费生命周期管理）&lt;/li&gt;
&lt;li&gt;使用简单&lt;/li&gt;
&lt;li&gt;单元测试友好&lt;/li&gt;
&lt;li&gt;内置监控&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;quickstart&quot;&gt;Quickstart&lt;/h2&gt;
&lt;p&gt;新建控制台程序 mt-001，引入 Masstransit 包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace mt_001
{
    class Program
    {
        static async Task Main(string[] args)
        {
            var bus = Bus.Factory.CreateUsingInMemory(sbc =&amp;gt;
            {
                sbc.ReceiveEndpoint(&quot;test_queue&quot;, ep =&amp;gt;
                {
                    ep.Handler&amp;lt;Message&amp;gt;(context =&amp;gt; Console.Out.WriteLineAsync($&quot;Received: {context.Message.Text}&quot;));
                });
            });

            await bus.StartAsync();// This is important !

            await bus.Publish(new Message { Text = &quot;Hi&quot; });

            Console.WriteLine(&quot;Please input your message with enter:&quot;);
            string message = Console.ReadLine();

            while (message != &quot;EXIT&quot;)
            {
                await bus.Publish(new Message() {Text = message});
                message = Console.ReadLine();
            }

            await bus.StopAsync();

            Console.WriteLine(&quot;Hello World!&quot;);
        }
    }

    public class Message
    {
        public string Text { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动程序，收发消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210112220110158-968169911.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建控制台程序 mt-002，引入 MassTransit.RabbitMQ 包&lt;/p&gt;
&lt;p&gt;方法改为 CreateUsingRabbitMq，并且添加 rabbitmq host&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var bus = Bus.Factory.CreateUsingRabbitMq(sbc =&amp;gt;
{
    sbc.Host(&quot;rabbitmq://localhost&quot;);

    sbc.ReceiveEndpoint(&quot;test_queue&quot;, ep =&amp;gt;
    {
        ep.Handler&amp;lt;Message&amp;gt;(context =&amp;gt; Console.Out.WriteLineAsync($&quot;Received: {context.Message.Text}&quot;));
    });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动两个客户端，消息是轮询接收的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210112220120614-1469577088.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;消息-message&quot;&gt;消息 Message&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;消息&lt;/li&gt;
&lt;li&gt;消息类型&lt;/li&gt;
&lt;li&gt;消息头&lt;/li&gt;
&lt;li&gt;最佳实践&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消息&quot;&gt;消息&lt;/h3&gt;
&lt;p&gt;MassTransit 使用 C# 强类型来定义，一个消息可以被定义为接口，通常我们也称之为消息契约&lt;/p&gt;
&lt;p&gt;消息分为 command 命令与 event 事件，分别对应 send 和 publish 方法&lt;/p&gt;
&lt;p&gt;在不同项目里面创建类来消费消息时确保命名空间一致，否则消费不到&lt;/p&gt;
&lt;p&gt;命名空间：Company.Application.Contracts&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Company.Application.Contracts
{
        using System;

        public interface UpdateCustomerAddress
        {
                Guid CommandId { get; }
                DateTime Timestamp { get; }
                string CustomerId { get; }
                string HouseNumber { get; }
                string Street { get; }
                string City { get; }
                string State { get; }
                string PostalCode { get; }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消息类型&quot;&gt;消息类型&lt;/h3&gt;
&lt;p&gt;Command&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 send 发送到一个 endpoint&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Event&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 publish，不直接发送到 endpoint，发布到多个消费者&lt;/li&gt;
&lt;li&gt;通常以名称短语（过去式的形式来命名）比如 OrderCreatedEvent, OrderSubmitted, OrderPaid, OrderDeliveried&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消息头&quot;&gt;消息头&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210112220134447-1516132280.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210112220142626-646373128.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h3&gt;
&lt;p&gt;尽量使用接口来定义消息类型，使用消息初始化器（有点困难）&lt;/p&gt;
&lt;p&gt;使用类以及继承时需要特别注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过消费基类并利用多态行为来处理，总会遇到很多问题&lt;/li&gt;
&lt;li&gt;消息格式设计不是面向对象设计，消息中应该只包含状态而不应该包含行为&lt;/li&gt;
&lt;li&gt;大的基类也会产生很多问题，特别是在支持消息版本的时候&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;github源码链接：&quot;&gt;GitHub源码链接：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp&quot; target=&quot;_blank&quot;&gt;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Jan 2021 14:02:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.6.6 RabbitMQ -- Masstransit 介绍 Masstransit 是什么 Quickstart 消息 Message Masstransit 是什么 Masstransit 是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14269509.html</dc:identifier>
</item>
<item>
<title>ThreadX应用笔记：内核初始化和任务调度 - zzssdd2</title>
<link>http://www.cnblogs.com/zzssdd2/p/14269508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzssdd2/p/14269508.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;zzssdd2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-mail：&lt;/strong&gt;zzssdd2@foxmail.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;了解&lt;code&gt;ThreadX&lt;/code&gt;的初始化流程有助于移植使用，掌握任务的的调度有助于更加得心应手地运用该实时操作系统。&lt;/p&gt;

&lt;p&gt;官方手册给出的&lt;strong&gt;ThreadX&lt;/strong&gt;初始化流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210112215751167-100534211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;STM32F429 + MDK-ARM-AC6&lt;/strong&gt;平台举例，初始化流程的前3步在&lt;code&gt;startup_stm32f429xx.s&lt;/code&gt;文件中完成 ，该启动文件内容是STM32复位后首先执行的，主要完成以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置堆栈（ __initial_sp、__heap_base、__heap_limit）&lt;/li&gt;
&lt;li&gt;设置中断向量表（__Vectors）&lt;/li&gt;
&lt;li&gt;设置复位入口程序（Reset_Handler）&lt;/li&gt;
&lt;li&gt;链接到C库中的__main，最终进入到&lt;em&gt;main()&lt;/em&gt;函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210112215800940-1234018632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入&lt;em&gt;main()&lt;/em&gt;函数后开始进行ThreadX的x相关初始化，后面几步更详细的调用流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210112215809835-1868607108.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210112215816176-2128670086.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于STM32移植ThreadX更详细的过程可以参考这篇文章：&lt;a href=&quot;https://www.cnblogs.com/zzssdd2/p/14125804.html&quot; target=&quot;_blank&quot;&gt;ThreadX移植——STM32H7+MDK-AC6平台&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;理解线程的不同处理状态是理解整个多线程环境的关键因素。在&lt;strong&gt;ThreadX&lt;/strong&gt;中包含5种不同的线程状态：&lt;code&gt;就绪&lt;/code&gt;、&lt;code&gt;挂起&lt;/code&gt;、&lt;code&gt;执行&lt;/code&gt;、&lt;code&gt;终止&lt;/code&gt;和&lt;code&gt;完成&lt;/code&gt;。下图展示了ThreadX的线程状态转换图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210112215830763-1767682013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当线程准备执行时处于就绪状态，就绪线程只有在它是处于就绪线程列表的最高优先级时才会执行。当线程开始执行时其状态由就绪态转为运行态&lt;/li&gt;
&lt;li&gt;如果更高优先级的线程准备就绪，则执行线程将恢复到就绪状态。然后执行新准备好的高优先级线程，将其逻辑状态更改为运行态。每次发生线程抢占时，都会发生就绪状态和运行状态之间的转换。&lt;/li&gt;
&lt;li&gt;在任何给定的时刻，只有一个线程处于执行状态。这是因为处于执行状态的线程对底层处理器具有控制权。&lt;/li&gt;
&lt;li&gt;处于挂起状态的线程不符合执行条件。处于挂起状态的原因包括时间挂起、队列消息、信号量、互斥、事件标志、内存和基本线程挂起。在清除挂起的原因后，线程将恢复到就绪状态。&lt;/li&gt;
&lt;li&gt;处于完成状态的线程是已完成其任务处理并从其入口函数返回的线程。 入口函数是在线程创建期间指定的。 处于完成状态的线程无法再次执行。&lt;/li&gt;
&lt;li&gt;线程处于终止状态是因为另一个线程或是线程本身调用&lt;strong&gt;tx_thread_terminate&lt;/strong&gt;服务。线程处于终止状态将无法再次执行。&lt;/li&gt;
&lt;li&gt;如果需要重新启动已完成或终止的线程，应用程序必须首先删除该线程。然后可以重新创建并重新启动它。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在使用&lt;strong&gt;ThreadX&lt;/strong&gt;时，有一些配置选项可供选择。这些选项包含在&lt;em&gt;&lt;strong&gt;tx_user.h&lt;/strong&gt;&lt;/em&gt;文件中。要使用这些配置项的前提是工程编译时包含&lt;em&gt;&lt;strong&gt;TX_INCLUDE_USER_DEFINE_FILE&lt;/strong&gt;&lt;/em&gt; 宏定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;52.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，此选项可在字节池上收集性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_DISABLE_ERROR_CHECKING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绕过基本服务呼叫错误检查。在应用程序源中定义时，将禁用所有基本参数错误检查。这可以将性能提高多达30％，并且还可以减小镜像大小。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:只有在应用程序可以绝对保证所有输入参数在所有情况下始终有效的情况下，才可以禁用错误检查，包括从外部输入派生的输入参数。如果在禁用错误检查的情况下向API提供了无效的输入，则导致的行为是不确定的，并且可能导致内存损坏或系统崩溃。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意:不受禁用错误检查影响的ThreadX API返回值在第4章的每个API描述的“返回值”部分中以粗体列出。如果通过使用TX_DISABLE_ERROR_CHECKING选项禁用了错误检查，则非粗体返回值将无效。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_DISABLE_NOTIFY_CALLBACKS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，将为各种ThreadX对象禁用通知回调。使用此选项可略微减小代码大小并提高性能。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_DISABLE_PREEMPTION_THRESHOLD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，将禁用抢占阈值功能，并略微减小代码大小并提高性能。当然，抢占阈值功能不再可用。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_DISABLE_REDUNDANT_CLEARING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，删除用于将ThreadX全局C数据结构初始化为零的逻辑。仅当编译器的初始化代码将所有未初始化的C全局数据设置为零时，才应使用此方法。使用此选项可略微减小代码大小并提高初始化期间的性能。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_DISABLE_STACK_FILLING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义时，禁用在创建时将0xEF值放置在每个线程堆栈的每个字节中。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_ENABLE_EVENT_TRACE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，ThreadX启用事件收集代码以创建TraceX跟踪缓冲区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_ENABLE_STACK_CHECKING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，将启用ThreadX运行时堆栈检查，其中包括分析已使用了多少堆栈以及检查堆栈区域之前和之后的数据模式“围栏”。如果检测到堆栈错误，则会调用已注册的应用程序堆栈错误处理程序。此选项的确会导致开销和代码大小略有增加。查看&lt;em&gt;&lt;strong&gt;tx_thread_stack_error_notify&lt;/strong&gt;&lt;/em&gt; API函数以获取更多信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可以收集有关事件标志组的性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_INLINE_THREAD_RESUME_SUSPEND&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，ThreadX通过内联代码改进&lt;em&gt;&lt;strong&gt;tx_thread_resume&lt;/strong&gt;&lt;/em&gt;和&lt;em&gt;&lt;strong&gt;tx_thread_suspend&lt;/strong&gt;&lt;/em&gt; API调用。这增加了代码大小，但增强了这两个API调用的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_MAX_PRIORITIES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义ThreadX的优先级。合法值的范围是32到1024（含），并且&lt;em&gt;必须&lt;/em&gt;能被32整除。增加的优先级级别数对于每组32个优先级将RAM使用量增加128字节。但是，对性能的影响可忽略不计。默认情况下，此值设置为32个优先级。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_MINIMUM_STACK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义最小堆栈大小（以字节为单位）。创建线程时，用于错误检查。默认值是特定于端口的，可以在&lt;em&gt;&lt;strong&gt;tx_port.h中&lt;/strong&gt;&lt;/em&gt;找到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_MISRA_ENABLE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，ThreadX将使用符合MISRA C的约定。有关详细信息，请参考 &lt;em&gt;&lt;strong&gt;ThreadX_MISRA_Compliance.pdf&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_MUTEX_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可以收集互斥量上的性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_NO_TIMER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，将完全禁用ThreadX计时器逻辑。在不使用ThreadX计时器功能（线程睡眠，API超时，时间分片和应用程序计时器）的情况下，这很有用。如果&lt;strong&gt;TX_NO_TIMER&lt;/strong&gt;指定，则选项&lt;strong&gt;TX_TIMER_PROCESS_IN_ISR&lt;/strong&gt;也必须定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_NOT_INTERRUPTABLE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，ThreadX不会尝试最小化中断锁定时间。这样可以加快执行速度，但会略微增加中断锁定时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_QUEUE_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可以在队列上收集性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_REACTIVATE_INLINE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，直接内联执行ThreadX计时器，而不使用函数调用。这样可以提高性能，但会稍微增加代码大小。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可以收集有关信号量的性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_THREAD_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可以在线程上收集性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_TIMER_ENABLE_PERFORMANCE_INFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，可在计时器上收集性能信息。默认情况下，未定义此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_TIMER_PROCESS_IN_ISR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义后，消除ThreadX的内部系统计时器线程。由于不再需要定时器堆栈和控制块，因此可以提高定时器事件的性能，并减少对RAM的需求。但是，使用此选项会将所有计时器到期处理移至计时器ISR级别。默认情况下，未定义此选项。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：ISR可能不允许计时器允许的服务，因此使用此选项时可能不允许。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_TIMER_THREAD_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义内部ThreadX系统计时器线程的优先级。默认值是优先级0，即ThreadX中的最高优先级。默认值在&lt;em&gt;&lt;strong&gt;tx_port.h中&lt;/strong&gt;&lt;/em&gt;定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;TX_TIMER_THREAD_STACK_SIZE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义内部ThreadX系统计时器线程的堆栈大小（以字节为单位）。该线程处理所有线程睡眠请求以及所有服务调用超时。此外，所有应用程序计时器回调例程都从该上下文中调用。默认值是特定于端口的，可以在&lt;em&gt;&lt;strong&gt;tx_port.h中&lt;/strong&gt;&lt;/em&gt;找到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、创建应用程序线程&quot;&gt;1、创建应用程序线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_create(
    TX_THREAD *thread_ptr,
    CHAR *name_ptr, 
    VOID (*entry_function)(ULONG),
    ULONG entry_input, 
    VOID *stack_start,
    ULONG stack_size, 
    UINT priority,
    UINT preempt_threshold, 
    ULONG time_slice,
    UINT auto_start);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、删除应用程序线程&quot;&gt;2、删除应用程序线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;该服务删除指定的应用程序线程。由于指定的线程必须处于终止或完成状态，因此无法从试图删除自身的线程中调用此服务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;sub&gt;注意：应用程序负责管理与线程的堆栈关联的内存区域，此服务完成后才可用。此外，应用程序必须阻止使用已删除的线程。&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的应用程序线程的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功删除线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_DELETE_ERROR&lt;/strong&gt;（0x11）指定的线程未处于终止或完成状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_delete(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、在线程进入和退出时通知应用程序&quot;&gt;3、在线程进入和退出时通知应用程序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;此服务注册一个通知回调函数，该函数将在进入或退出指定线程时调用。通知回调的处理由应用程序定义。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：不允许应用程序的线程进入/退出通知回调调用具有暂停选项的任何ThreadX API。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的线程的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;entry_exit_notify&lt;/strong&gt;指向应用程序的线程进入/退出通知功能的指针。进入/退出通知功能的第二个参数指定是否存在进入或退出。值&lt;strong&gt;TX_THREAD_ENTRY&lt;/strong&gt;（0x00）表示已进入线程，而值&lt;strong&gt;TX_THREAD_EXIT&lt;/strong&gt;（0x01）表示已退出线程。如果此值为&lt;strong&gt;TX_NULL&lt;/strong&gt;，则禁用通知。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功注册线程进入/退出通知功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_FEATURE_NOT_ENABLED&lt;/strong&gt;（0xFF）系统在禁用通知功能的情况下进行了编译。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_entry_exit_notify(
    TX_THREAD *thread_ptr,
    VOID (*entry_exit_notify)(TX_THREAD *, UINT));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、查询当前正在执行的任务&quot;&gt;4、查询当前正在执行的任务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;该服务返回指向当前正在执行的线程的指针。如果没有线程在执行，则此服务返回空指针。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;sub&gt;注意：如果从ISR调用此服务，则返回值表示在执行中断处理程序之前运行的线程。&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;空&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;thread pointer&lt;/strong&gt; 指向当前正在执行的线程的指针。如果没有线程在执行，则返回值为&lt;strong&gt;TX_NULL&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;TX_THREAD* tx_thread_identify(VOID);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5、查询任务相关信息&quot;&gt;5、查询任务相关信息&lt;/h2&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_info_get(
    TX_THREAD *thread_ptr, 
    CHAR **name,
    UINT *state, 
    ULONG *run_count,
    UINT *priority,
    UINT *preemption_threshold,
    ULONG *time_slice,
    TX_THREAD **next_thread,
    TX_THREAD **suspended_thread);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6、更改线程的抢占阈值&quot;&gt;6、更改线程的抢占阈值&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;此服务更改指定线程的抢占阈值。抢占阈值可防止等于或小于抢占阈值的线程抢占指定线程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;sub&gt;注意：使用抢占阈值会禁用指定线程的时间片。&lt;/sub&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的应用程序线程的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;new_threshold&lt;/strong&gt;新的抢占阈值优先级（0到（TX_MAX_PRIORITIES-1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;old_threshold&lt;/strong&gt;指向要返回先前抢占阈值的位置的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的抢占阈值更改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THRESH_ERROR&lt;/strong&gt;（0x18）指定的新抢占阈值不是有效的线程优先级（（从（0到（&lt;strong&gt;TX_MAX_PRIORITIES&lt;/strong&gt; -1）以外的值））或大于当前线程优先级（（较低的优先级））。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt;（0x03）指向先前抢占&lt;strong&gt;阈值&lt;/strong&gt;存储位置的无效指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_preemption_change(
    TX_THREAD *thread_ptr,
    UINT new_threshold, 
    UINT *old_threshold);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7、更改线程的优先级&quot;&gt;7、更改线程的优先级&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;该服务更改指定线程的优先级。有效优先级的范围是0到（TX_MAX_PRIORITES-1），其中0表示最高优先级。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：指定线程的抢占阈值将自动设置为新优先级。如果需要新的阈值，则必须在此调用之后使用&lt;/em&gt;&lt;strong&gt;tx_thread_preemption_change&lt;/strong&gt;*服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的应用程序线程的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;new_priority&lt;/strong&gt;新线程优先级（0到（TX_MAX_PRIORITIES-1））。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;old_priority&lt;/strong&gt;指向一个位置的指针，以返回线程先前的优先级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的优先级更改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PRIORITY_ERROR&lt;/strong&gt;（0x0F）指定的新优先级无效（（（0到（TX_MAX_PRIORITIES-1）以外的值））。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt;（0x03）指向先前优先级存储位置的无效指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_priority_change(
    TX_THREAD *thread_ptr,
    UINT new_priority, 
    UINT *old_priority);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8、线程释放控制权&quot;&gt;8、线程释放控制权&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;此服务放弃处理器的控制权，转交给其他相同或更高优先级的处于就绪状态的线程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;除了将控制权放弃给相同优先级的线程之外，此服务还将控制权放弃给由于当前线程的抢占阈值设置而阻止执行的最高优先级线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;空&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;p&gt;空&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;VOID tx_thread_relinquish(VOID);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;9、重置线程&quot;&gt;9、重置线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;此服务将指定的线程重置为在线程创建时定义的入口点执行。线程必须处于&lt;strong&gt;TX_COMPLETED&lt;/strong&gt;或&lt;strong&gt;TX_TERMINATED&lt;/strong&gt;状态才能重置&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：必须恢复(resume)该线程以使其再次执行&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的线程的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的线程重置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_NOT_DONE&lt;/strong&gt;（0x20）指定的线程不处于&lt;strong&gt;TX_COMPLETED&lt;/strong&gt;或&lt;strong&gt;TX_TERMINATED&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_reset(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;10、恢复线程&quot;&gt;10、恢复线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_resume(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;11、挂起线程&quot;&gt;11、挂起线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;此服务挂起指定的应用程序线程。线程可以调用此服务来挂起自身。&lt;/p&gt;
&lt;p&gt;挂起后，必须由&lt;em&gt;&lt;strong&gt;tx_thread_resume&lt;/strong&gt;&lt;/em&gt;恢复该线程才能再次执行。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：如果指定的线程由于其他原因已经挂起，则此挂起操作将在内部保持，直到先前的挂起解除为止。当发生这种情况时，将执行指定线程的无条件挂起。进一步的无条件中止请求无效。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向应用程序线程的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的线程挂起。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_SUSPEND_ERROR&lt;/strong&gt;（0x14）指定的线程处于终止或完成状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_suspend(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12、将当前线程挂起指定的时间&quot;&gt;12、将当前线程挂起指定的时间&lt;/h2&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_sleep(ULONG timer_ticks);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;13、线程堆栈错误通知回调&quot;&gt;13、线程堆栈错误通知回调&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;该服务注册了一个通知回调函数来处理线程堆栈错误。当ThreadX在执行过程中检测到线程堆栈错误时，它将调用此通知函数来处理错误。错误的处理完全由应用程序定义。从暂停违规线程到重置整个系统，任何事情都可以完成。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：必须定义&lt;/em&gt;&lt;strong&gt;TX_ENABLE_STACK_CHECKING&lt;/strong&gt; &lt;em&gt;配置选项，以便此服务返回性能信息。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;error_handler&lt;/strong&gt;指向应用程序的堆栈错误处理功能的指针。如果此值为TX_NULL，则禁用通知。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的线程重置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_FEATURE_NOT_ENABLED&lt;/strong&gt;（0xFF）系统未在启用性能信息的情况下进行编译。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_stack_error_notify(VOID (*error_handler)(TX_THREAD *));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;14、终止线程&quot;&gt;14、终止线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;描述
&lt;ul&gt;&lt;li&gt;该服务终止指定的应用程序线程，而不管该线程是否被挂起。线程可以调用此服务以终止自身。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序有责任确保线程处于适合终止的状态。例如，线程不应在关键应用程序处理期间或在其他中间件组件内部终止，否则可能会使这种处理处于未知状态。&lt;/strong&gt;**&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止后，必须重置线程以使其再次执行。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参数
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向应用程序线程的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回值
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功终止线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_terminate(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;15、更改线程的时间片&quot;&gt;15、更改线程的时间片&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;该服务更改指定应用程序线程的时间片。为线程选择时间片可确保在相同或更高优先级的其他线程有机会执行之前，它不会执行超过指定数量的计时器滴答。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：使用抢占阈值会禁用指定线程的时间片。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向应用程序线程的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;new_time_slice&lt;/strong&gt;新的时间片值。合法值包括TX_NO_TIME_SLICE和从1到0xFFFFFFFF的数值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;old_time_slice&lt;/strong&gt;指向用于存储指定线程的先前时间片值的位置的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的时间切片机会。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_PTR_ERROR&lt;/strong&gt;（0x03）指向先前时间片存储位置的无效指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_CALLER_ERROR&lt;/strong&gt;（0x13）该服务的无效调用者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_time_slice_change(
    TX_THREAD *thread_ptr,
    ULONG new_time_slice, 
    ULONG *old_time_slice);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;16、中止指定线程&quot;&gt;16、中止指定线程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;此服务中止睡眠或指定线程的任何其他对象挂起。如果等待被中止，则线程正在等待的服务将返回&lt;strong&gt;TX_WAIT_ABORTED&lt;/strong&gt;值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：该服务不会释放由tx_thread_suspend服务进行的显式挂起。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;thread_ptr&lt;/strong&gt;指向先前创建的应用程序线程的指针。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TX_SUCCESS&lt;/strong&gt;（0x00）成功的线程等待中止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_THREAD_ERROR&lt;/strong&gt;（0x0E）无效的应用程序线程指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TX_WAIT_ABORT_ERROR&lt;/strong&gt;（0x1B）指定的线程未处于等待状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;UINT tx_thread_wait_abort(TX_THREAD *thread_ptr);
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Jan 2021 14:01:00 +0000</pubDate>
<dc:creator>zzssdd2</dc:creator>
<og:description>作者：zzssdd2 E-mail：zzssdd2@foxmail.com 一、前言 了解ThreadX的初始化流程有助于移植使用，掌握任务的的调度有助于更加得心应手地运用该实时操作系统。 二、初始化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzssdd2/p/14269508.html</dc:identifier>
</item>
</channel>
</rss>