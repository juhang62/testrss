<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>20190312_浅谈go&amp;java差异(二) - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/10801474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/10801474.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1161789/201905/1161789-20190505011136111-1338735843.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/funnyzpc/p/10801474.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/funnyzpc/p/10801474.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二节内容概览&quot;&gt;第二节内容概览&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;循环(for、switch)&lt;/li&gt;
&lt;li&gt;多值返回&lt;/li&gt;
&lt;li&gt;defer &amp;amp; finally&lt;/li&gt;
&lt;li&gt;init(go) 与默认构造函数(java)&lt;/li&gt;
&lt;li&gt;常量、静态变量(const 与 static final)&lt;/li&gt;
&lt;li&gt;参数或方法访问属性&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;循环&quot;&gt;循环&lt;/h5&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;go&lt;br/&gt;go提供了range关键字可以循环各种切片和数组，同时也提供了多参，这点相比较java会灵活不少，&lt;br/&gt;另外switch循环也不同与java，默认仅进入匹配的case内不会往下循环，若需要往下循环需要用到&lt;br/&gt;fallthrough关键字，这个也确实有利于开发，不用像java一样写break结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  func main() {
      arr := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}

      for val := range arr {
          fmt.Println(arr[val])
      }

      for i := 0; i &amp;lt; 10; i++ {
          fmt.Println(i)
      }

      caseVal := &quot;C&quot;
      switch caseVal {
      case &quot;A&quot;:
          fmt.Println(&quot;This is A&quot;)
      case &quot;B&quot;:
          fmt.Println(&quot;This is B&quot;)
      case &quot;C&quot;:
          fmt.Println(&quot;This is C&quot;)
      default:
          fmt.Println(&quot;This is other word!&quot;)
      }

  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java 提供了多种循环，分别是for、foreach、Stream foreach(java8提供)，while、do while&lt;br/&gt;switch ，我就直接展示代码吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @Test
  public void forTest(){
      String[] arr = new String[]{&quot;A&quot;,&quot;B&quot;,&quot;C&quot;};
      for (String item:arr) {
          LOG.info(item);
      }

      for(int i=0;i&amp;lt;arr.length;i++){
          LOG.info(arr[i]);
      }

      String word = &quot;B&quot;;

      switch (word){
          case &quot;A&quot;:
              LOG.info(&quot;This is A&quot;);
              break;
          case &quot;B&quot;:
              LOG.info(&quot;This is B&quot;);
              break;
          case &quot;C&quot;:
              LOG.info(&quot;This is C&quot;);
              break;
          default:
              LOG.info(&quot;This is Other word!&quot;);
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;多值返回&quot;&gt;多值返回&lt;/h6&gt;
&lt;ul readability=&quot;15&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;go&lt;br/&gt;go提供了多参返回，当参数较少当时候可以一次性返回，不用构造结构体返回&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  func main() {
      a, b, c, err := process(11, &quot;A&quot;, true)
      fmt.Println(a, b, c, err)
  }

  func process(aa int32, bb string, cc bool) (int32, string, bool, error) {
      var ccReturn bool
      if true == cc {
          ccReturn = false
      } else {
          ccReturn = true
      }
      return aa + 1, bb + &quot;_return&quot;, ccReturn, nil
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java并没有提供多参返回，若要实现多参返回，一般将返回参数封装入Map、List 这类集合类型中，&lt;br/&gt;或者构造一个新对象放入返回值后返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      @Test
      public void returnObjec(){
          Map&amp;lt;String,Object&amp;gt; result = this.processObj();
          LOG.info(new JSONObject(result).toString());
      }

      public Map&amp;lt;String,Object&amp;gt; processObj(){
          return new HashMap&amp;lt;String,Object&amp;gt;(){{
              put(&quot;val1&quot;,true);
              put(&quot;val2&quot;,&quot;str&quot;);
              put(&quot;val3&quot;,999777L);
          }};
      }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;defer-finally&quot;&gt;defer &amp;amp; finally&lt;/h5&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;go&lt;br/&gt;首先 defer 和 finally 大多用于资源关闭或异常处理&lt;br/&gt;go中的defer 与 java的finally个人感觉是相似的，但是如果将defer放入到循环内的话可就像&lt;br/&gt;一个反向队列了，若一个处理逻辑内有多个defer的时候 先defer的晚于后defer,很有意思，大家可以试试哈～&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  func main() {
      doSomething()
  }

  func doSomething() {
      fmt.Println(&quot;something start&quot;)
      defer fmt.Println(&quot;something defer&quot;)
      fmt.Println(&quot;something end&quot;)

      arr := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
      for val := range arr {
          defer fmt.Println(val)
      }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java 的finally 大多用于异常处理，尤其是文件流异常处理，同时也不存在类似于defer的倒序处理，&lt;br/&gt;这里就给个简单的例子～&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @Test
  public void processFinal(){
      String[] arr = new String[]{&quot;A&quot;,&quot;B&quot;};

      try{
          LOG.info(arr[2]);
      }catch (Exception e){
          LOG.info(&quot;异常了：{}&quot;,e);
      }finally {
          LOG.info(&quot;最后进入～&quot;);
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;init-与默认构造函数&quot;&gt;init 与默认构造函数&lt;/h5&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;go&lt;br/&gt;go不存在默认构造函数，但是提供了init函数；我一开始也想不起来go的init函数如何与java的初始化&lt;br/&gt;对比，灵机一动就有了无参的构造函数，虽然这样对比其实并不恰当，但是功能上是有相似的地方。另外需要&lt;br/&gt;说明的是go的init的函数是在包被引入的时候调用的 若与main函数存在同一代码块 也是init先被调用，&lt;br/&gt;而java的默认构造函数仅在对象被new的时候调用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  func main() {
      fmt.Println(&quot;func main()&quot;)
  }

  func init() {
      fmt.Println(&quot;func init()&quot;)
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java的默认构造方法其实并不常用，但是在每启一个类的时候都有默认的构造方法，若是定义了就会走默认的构造&lt;br/&gt;方法，若无则在编译为class文件的时候自动为所在类加入一个。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public class ConstructTest {
      private static final Logger LOG = LoggerFactory.getLogger(ConstructTest.class);
      @Test
      public void processConst(){
          LOG.info(&quot;&amp;gt;&amp;gt;&amp;gt; start&quot;);
          Person person = new Person();
          LOG.info(&quot;&amp;gt;&amp;gt;&amp;gt; end&quot;);
      }
  }

  class Person{
      private static final Logger logger = LoggerFactory.getLogger(Person.class);
      private String name;
      private Integer age;

      public Person() {
          logger.info(&quot;default Constructor&quot;);
      }

      public String getName() {
          return name;
      }

      public void setName(String name) {
          this.name = name;
      }

      public Integer getAge() {
          return age;
      }

      public void setAge(Integer age) {
          this.age = age;
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;const-与-static-final&quot;&gt;const 与 static final&lt;/h6&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;go&lt;br/&gt;go的静态(也可叫静态常量，主要用于基本数据类型)，使用关键字const指定。&lt;br/&gt;使用const定义的静态变量是不可用修改或赋值的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  const name int = 11

  const (
      a = &quot;hello&quot;
      b = true
      c = 99
  )

  func main() {
      fmt.Println(name)
      fmt.Println(a)
      fmt.Println(b)
      fmt.Println(c)
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java的常量需要用两个关键字修饰 &lt;code&gt;static&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; ,前者表示静态的意思，但这个静态是可以被修改的，&lt;br/&gt;修改的前提是类型不变，而第二个关键字表示最终的意思，一旦变量被这个关键字修饰则不可重新修改变量。&lt;br/&gt;但是对于复合对象，比如List、Map、自定义对象等，又是可以被修改的,对于这点个人觉得 java 的常量的定义&lt;br/&gt;并不够严谨。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class staticFinalTest {
    private static final Logger LOG = LoggerFactory.getLogger(staticFinalTest.class);
    private static final String name = &quot;Tom&quot;;

    private static String item = &quot;first item&quot;;

    private static final List&amp;lt;String&amp;gt; initArr = new ArrayList&amp;lt;String&amp;gt;(){{
        add(&quot;A&quot;);
        add(&quot;B&quot;);
        add(&quot;C&quot;);
    }};

    @Test
    public void process(){
        LOG.info(name);

        item = &quot;youth!&quot;;

        LOG.info(item);

        initArr.add(&quot;hello&quot;);

        LOG.info(initArr.toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;参数或方法访问属性&quot;&gt;参数或方法访问属性&lt;/h5&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;go&lt;br/&gt;go 的方法或参数需要被外部访问，需要使用大写开头参数名或函数名(go文件大小写是与与否与是否私有无关)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 可被文件外函数访问
  var Name string = &quot;John&quot;

  func main() {
      fmt.Println(Name)
      Process()
  }

  // 可被文件外函数调用
  func Process() {
      fmt.Println(&quot;Process()&quot;)
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;java&lt;br/&gt;java的参数或方法属性不同于go，大致分为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;private 仅当前类内访问&lt;/li&gt;
&lt;li&gt;public 可公共访问&lt;/li&gt;
&lt;li&gt;protect 仅可同包内访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  public class ObjectTypeTest {
      private static final Logger LOG = LoggerFactory.getLogger(ObjectTypeTest.class);

      //私有访问（仅可同一类中）
      private String name1 = &quot;name01&quot;;
      // 保护访问（仅可同一包内）
      protected String name2 = &quot;name01&quot;;
      // 公共访问 (任何类均可访问)
      public String name3 = &quot;name01&quot;;

      @Test
      public void process(){
          LOG.info(this.doSomeThing());
          LOG.info(name1);
          LOG.info(name2);
          LOG.info(name3);

      }

      public String doSomeThing(){
          return &quot;hello&quot;;
      }

  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 04 May 2019 17:14:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<og:description>转载请注明出处： 'https://www.cnblogs.com/funnyzpc/p/10801474.html' 第二节内容概览 + 循环(for、switch) + 多值返回 + defer</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/10801474.html</dc:identifier>
</item>
<item>
<title>图片像素的数值运算和逻辑运算及对比度调节 - tuxiaoping</title>
<link>http://www.cnblogs.com/1121518wo/p/10810687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1121518wo/p/10810687.html</guid>
<description>&lt;p&gt;         &lt;span&gt;一、算术运算&lt;/span&gt;：这个主要包括---------&lt;span&gt;加、减 、乘、除；&lt;/span&gt;     &lt;/p&gt;
&lt;p&gt;           1、进行两张照片相加处理，利用它自带的add（）函数处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; shu_image(m1,m2):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     src=&lt;span&gt;cv.add(m1,m2)  #进行相加处理
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; src1=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; src2=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src1)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src2)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;shu_image(src1,src2)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       实现效果 如下(&lt;span&gt;这里解释一下add这个窗口结果显示，这个是因为imga1窗口照片黑色部分它的色彩位数是0，而image2窗口照片除微软那个logo 外其余部分色彩在0----255之间，所以结果就是这部分颜色了，其余部分都是按照相加即可&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190504232226472-1063793672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    2、进行相减处理，用subtract()函数处理：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; shu_image(m1,m2):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       src=cv.subtract(m1,m2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;相减处理&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;       cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subtract&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; src1=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; src2=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src1)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src2)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; shu_image(src1,src2)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是用src1-src2处理的&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  实现效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190504233355142-1255319328.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     3、进行相乘处理，使用函数mutiply()处理：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; shu_image(m1,m2):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      src=&lt;span&gt;cv.multiply(m1,m2)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mutiply&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; src1=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; src2=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src1)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src2)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; shu_image(src1,src2)  
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     实现效果如下：  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190504233959357-881209373.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        4、进行相除处理，利用函数divide()处理：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; shu_image(m1,m2):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      src=&lt;span&gt;cv.divide(m1,m2)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;divide&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; src1=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; src2=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src1)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src2)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;shu_image(src1,src2)   
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; cv.waitKey(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      实现效果如下：&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190504234515805-5619105.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;二、逻辑运算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            1、逻辑运算函数：&lt;/p&gt;
&lt;p&gt;                &lt;span&gt;a、bitwise_and()     与运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                b、bitwise_or()         或运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                c、bitwise_not()       非运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                d、 bitwise_xor()        异或运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           2、代码操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; luo_image(m1,m2):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     src=cv.bitwise_and(m1,m2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;与运算&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     src = cv.bitwise_or(m1, m2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;或运算&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, src)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     src = cv.bitwise_not(m1, m2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;非运算&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, src)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     src = cv.bitwise_xor(m1, m2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;异或运算&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, src)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; src1=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; src2=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hhhh.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src1)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src2)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;luo_image(src1,src2)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;cv.waitKey(0)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;           实现效果如下：&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190505000849581-1057579287.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;          &lt;span&gt; 三、对比度调节，用addWeighted()函数处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;             这个addWeighted()参数比较多，看一下它标准参数有哪些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; Help on built-&lt;span&gt;in&lt;/span&gt;&lt;span&gt; function addWeighted:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;addWeighted(...)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -&amp;gt;&lt;span&gt; dst
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    .   @brief Calculates the weighted sum of two arrays.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    .   
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    .   The function addWeighted calculates the weighted sum of two arrays as follows:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     .   \f[\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +&lt;span&gt;  \texttt{gamma} )\f]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     .   where I &lt;span&gt;is&lt;/span&gt; a multi-dimensional index of array elements. In case of multi-&lt;span&gt;channel arrays, each
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     .   channel &lt;span&gt;is&lt;/span&gt;&lt;span&gt; processed independently.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    .   The function can be replaced with a matrix expression:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    .   @code{.cpp}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     .   dst = src1*alpha + src2*beta +&lt;span&gt; gamma;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    .   @endcode
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     .   @note Saturation &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; applied when the output array has the depth CV_32S. You may even get
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     .   result of an incorrect sign &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the case of overflow.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    .   @param src1 first input array.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    .   @param alpha weight of the first array elements.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     .   @param src2 second input array of the same size &lt;span&gt;and&lt;/span&gt;&lt;span&gt; channel number as src1.
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    .   @param beta weight of the second array elements.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    .   @param gamma scalar added to each sum.
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     .   @param dst output array that has the same size &lt;span&gt;and&lt;/span&gt;&lt;span&gt; number of channels as the input arrays.
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    .   @param dtype optional depth of the output array; when both input arrays have the same depth, dtype
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     .   can be set to -1&lt;span&gt;, which will be equivalent to src1.depth().
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     .   @sa  add, subtract, scaleAdd, Mat::convertTo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  然后我们实现功能代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2 as cv
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; contrast_bright_image(m1,a,g):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     h,w,ch = m1.shape   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取图片的大小，height,width以及通道&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新建全零图片数组m2,将height和width,类型设置为原图片的通道类型（色素全为0，输出全为黑色）&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     m2=np.zeros([h,w,ch],m1.dtype)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用numpy 的矩阵处理功能&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     dst=cv.addWeighted(m1,a,m2,1-&lt;span&gt;a,g)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     cv.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bright&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,dst)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; src=cv.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/hh.JPG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; cv.namedWindow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;原来&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cv.WINDOW_NORMAL)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; cv.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原来&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,src)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; contrast_bright_image(src,1.2,30) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.2 表示对比度，10表示亮度值&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;cv.waitKey(0)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; cv.destoryAllWindows()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     效果如下：&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603241/201905/1603241-20190505004821555-1657839850.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;              好了今天的分享就到这里了，明天继续加油。 &lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 16:51:00 +0000</pubDate>
<dc:creator>tuxiaoping</dc:creator>
<og:description>一、算术运算：这个主要包括 加、减 、乘、除； 1、进行两张照片相加处理，利用它自带的add（）函数处理： 实现效果 如下(这里解释一下add这个窗口结果显示，这个是因为imga1窗口照片黑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1121518wo/p/10810687.html</dc:identifier>
</item>
<item>
<title>kali渗透综合靶机(四)--node1靶机 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10801183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10801183.html</guid>
<description>&lt;p&gt;&lt;span&gt;kali渗透综合靶机(四)--node1靶机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;靶机下载地址::&lt;a href=&quot;https://download.vulnhub.com/node/Node.ova&quot; target=&quot;_blank&quot;&gt;https://download.vulnhub.com/node/Node.ova&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、主机发现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.netdiscover -i eth0 -r 192.168.10.0/24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501225652751-1623910837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、端口扫描&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.masscan --rate=10000 -p 0-65535 192.168.10.157&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501225701804-119086085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、端口服务识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. nmap -sV -T4 -O 192.168.10.157 -p 22,3000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501225802178-841469193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、漏洞发现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.dirb http://192.168.10.157:3000 -f /usr/share/dirb/wordlists/big.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫描目录发现,什么都没有扫描出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501225959365-1573612509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查看页面源代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尝试访问http://192.168.138.137:3000/api/users/latest后得到以下信息,然后解密&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230016352-658672843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 去掉lastest再次访问 发现得到了一个管理员用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230039135-1538102211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.登录管理员账户, 登录后发现 可以下载网站备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230056907-1764905973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 下载后的文件,打开发现是base64编码,尝试以base64解码后发现是zip文件,解压压缩包,提示需要密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230114119-1300825959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 使用kali自带的工具进行破解 fcrackzip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fcrackzip -v -b -u -c a -p magicaaaa myplace&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过字典猜解出密码为magicword&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.尝试ssh登录,登陆成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230134499-902057556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230151667-535955187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.搜索是否有Ubuntu 16.04漏洞利用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230206685-353696769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.漏洞利用脚本放到www目录下,开启web服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11.下载漏洞脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230219913-1774960874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12.编译脚本,执行脚本,获得管理员权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201905/1592114-20190501230237261-693606084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.信息收集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.dirb目录扫描&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.页面源码敏感信息泄露&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.fcrackzip破解zip文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.利用系统漏洞提权　&lt;/span&gt;　&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 16:12:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>kali渗透综合靶机(四)--node1靶机 靶机下载地址::https://download.vulnhub.com/node/Node.ova 一、主机发现 1.netdiscover -i et</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10801183.html</dc:identifier>
</item>
<item>
<title>如何管理团队知识？快速搭建一套管理工具 - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/birddoc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/birddoc.html</guid>
<description>&lt;p&gt;&lt;span&gt;阅读全文需要15分钟，动手实践需要30分钟，请收藏点赞后再读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;演示地址：&lt;a title=&quot;点击我&quot; href=&quot;http://birddoc.jayh.club&quot; target=&quot;_blank&quot;&gt;http://birddoc.jayh.club&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Github链接：&lt;a title=&quot;查看源码&quot; href=&quot;https://github.com/Jackson0714/BirdDoc&quot; target=&quot;_blank&quot;&gt;https://github.com/Jackson0714/BirdDoc&lt;/a&gt;   记得点个&lt;strong&gt;Star&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.1 用户故事&lt;/h2&gt;
&lt;p&gt;我是一名开发人员，经常会迷失在寻找团队内的各种开发文档中，我期望有一个网站，所有文档都集中在这个网站中，我可以进行根据目录浏览，最好能支持搜索，而且我贡献的文档别人不知道，会再跑过来问我。&lt;/p&gt;
&lt;h2&gt;1.2 用户痛点&lt;/h2&gt;
&lt;p&gt;（1）文档存放位置杂乱&lt;/p&gt;
&lt;p&gt;（2）搜索文档困难&lt;/p&gt;
&lt;p&gt;（3）文档没有目录&lt;/p&gt;
&lt;p&gt;（4）文档普及度不高&lt;/p&gt;
&lt;h2&gt;1.3 产品团队深挖用户痛点&lt;/h2&gt;
&lt;p&gt;根据用户的痛点，产品团队设计了一个模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430110754977-193344140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）左侧具有菜单导航栏&lt;/p&gt;
&lt;p&gt;（2）顶部具有搜索栏&lt;/p&gt;
&lt;p&gt;（3）可以通过网站的形式访问，方便用户访问&lt;/p&gt;

&lt;p&gt;这种团队管理工具有很多，很多大厂出了软件专门来做知识管理：&lt;/p&gt;
&lt;p&gt;比如xx笔记企业版&lt;/p&gt;
&lt;p&gt;这些大厂的软件必须购买企业版才能在团队内共享，且笔记很杂，不利于管理。而且根本就没有解决用户痛点。&lt;/p&gt;
&lt;p&gt;最后选择了vuePress来做，它的好处是可以用markdown语言来做笔记，让你专注于写作，还可以将笔记提交到gitlab进行管理，还有变更记录，而且高度支持自定义主题等等。&lt;/p&gt;
&lt;p&gt;于是我们选择了vuepress。官网链接：&lt;a href=&quot;https://v0.vuepress.vuejs.org/zh/&quot;&gt;https://v0.vuepress.vuejs.org/zh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网也是用VuePress做的哦。但这个开源工具不是下载下来就可以直接用的，还有些开发工作需要做。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430112008454-953549886.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外有人提出怎么不用GitBook ？&lt;/p&gt;
&lt;p&gt; GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。 -- 来源vuepress&lt;/p&gt;

&lt;h2&gt;3.1 方案一 按照官网搭建&lt;/h2&gt;
&lt;h3 id=&quot;快速上手&quot;&gt;快速上手&lt;/h3&gt;
&lt;div class=&quot;warning custom-block&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;custom-block-title&quot;&gt;注意&lt;/p&gt;
&lt;p&gt;请确保你的 Node.js 版本 &amp;gt;= 8。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;全局安装&quot;&gt;全局安装&lt;/h3&gt;
&lt;p&gt;如果你只是想尝试一下 VuePress，你可以全局安装它：&lt;/p&gt;

&lt;h3 id=&quot;现有项目&quot;&gt;现有项目&lt;/h3&gt;
&lt;p&gt;如果你想在一个现有项目中使用 VuePress，同时想要在该项目中管理文档，则应该将 VuePress 安装为本地依赖。作为本地依赖安装让你可以使用持续集成工具，或者一些其他服务（比如 Netlify）来帮助你在每次提交代码时自动部署。&lt;/p&gt;

&lt;div class=&quot;warning custom-block&quot; readability=&quot;7.8139534883721&quot;&gt;
&lt;p class=&quot;custom-block-title&quot;&gt;WARNING&lt;/p&gt;
&lt;p&gt;如果你的现有项目依赖了 webpack 3.x，推荐使用 &lt;a href=&quot;https://yarnpkg.com/en/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Yarn&lt;/a&gt; 而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接着，在 &lt;code&gt;package.json&lt;/code&gt; 里加一些脚本:&lt;/p&gt;

&lt;p&gt;然后就可以开始写作了:&lt;/p&gt;

&lt;p&gt;要生成静态的 HTML 文件，运行：&lt;/p&gt;

&lt;p&gt;默认情况下，文件将会被生成在 &lt;code&gt;.vuepress/dist&lt;/code&gt;，当然，你也可以通过 &lt;code&gt;.vuepress/config.js&lt;/code&gt; 中的 &lt;code&gt;dest&lt;/code&gt; 字段来修改，生成的文件可以部署到任意的静态文件服务器上，参考 &lt;a href=&quot;https://v0.vuepress.vuejs.org/zh/guide/deploy.html&quot;&gt;部署&lt;/a&gt; 来了解更多。&lt;/p&gt;
&lt;p&gt;这些步骤执行完后，只能看到搜索栏和标题，是没有菜单的，需要自己创建菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430124411768-2063119041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 方案二、用我的demo搭建&lt;/h2&gt;
&lt;h3&gt;3.2.2 如何创建菜单&lt;/h3&gt;
&lt;p&gt;上面只有搜索功能，没有菜单功能。修改config文件定义菜单，然后加上菜单对应的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175753583-1236259463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.2.2 下载demo&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我已经有一份做好的demo供大家使用&lt;/span&gt;，该demo的功能：展示接口文档，供第三方使用。功能如下图。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github路径：&lt;a href=&quot;https://github.com/Jackson0714/BirdDoc&quot;&gt;https://github.com/Jackson0714/BirdDoc&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175832163-277838830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.3.3 如何编写文档&lt;/h3&gt;
&lt;p&gt;比如想增加一个删除优惠券的接口，可以在coupon目录下面创建一个delete.md文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175245381-25554123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在config.js 文件配置菜单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175315250-996876631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果已经安装了node.js和npm，则在根目录执行这条命令就可以运行起来了&lt;/p&gt;

&lt;p&gt; 这条命令其实就是执行&lt;span&gt;npm vuepress dev&lt;/span&gt;来进行实时编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201904/414640-20190430132912975-2119060846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 编译完成后，会提示监听8080端口，可以打开http://localhost:8080查看效果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501175944292-1793831289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;5.1 打包成静态文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm run build
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.2 配置nginx和hosts&lt;/h2&gt;
&lt;p&gt;我是部署到ubuntu上的，需要创建nginx 配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 创建nginx配置文件&lt;br/&gt;sudo vim /etc/nginx/conf.d/interface.conf
// interface.conf
server {
    listen       8002;
    server_name  birddoc.com;

    location / {
        root   /home/user/project/github/BirdDoc/public;
        index  index.html index.htm;
        try_files $uri $uri/ =404;
    }
}
// 重启nginx服务
sudo service nginx restart
// 配置hosts文件，映射网站域名
sudo vim /etc/hosts
localhost birddoc.com
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.3 打开站点&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://birddoc.com:8002/&quot;&gt;http://birddoc.com:8002/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;6.1 拉取代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
git clone git@github.com:Jackson0714/BirdDoc.git
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.2 打包镜像文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37.5&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot; readability=&quot;8&quot;&gt;
npm run build&lt;p&gt;&amp;gt; kidsplace-interface@1.0.0 build /home/workspace/BirdDoc/BirdDoc
&amp;gt; vuepress build


 WAIT  Extracting site metadata...
[9:59:39 AM] Compiling Client
[9:59:39 AM] Compiling Server
[9:59:45 AM] Compiled Server in 6s
[9:59:51 AM] Compiled Client in 13s
 WAIT  Rendering static HTML...

 DONE  Success! Generated static files in public.&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成静态文件，路径为 /home/workspace/BirdDoc/BirdDoc/public&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501100138464-2046059715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6.3 添加域名解析&lt;/h2&gt;
&lt;p&gt;在云服务器控制台 添加 birddoc.jay.club的域名解析，网站jay.club是我自己备案的网站。&lt;/p&gt;
&lt;p&gt;等待10分钟就生效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501094706941-1115329334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6.4 修改nginx配置文件&lt;/h2&gt;
&lt;p&gt;监听通过birddoc.jay.club发来的请求，路由到静态文件目录 /home/workspace/BirdDoc/BirdDoc/public&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
server {
    listen       80;
    &lt;span&gt;server_name  birddoc.jayh.club;&lt;/span&gt;

    location / {
        root   /home/workspace/BirdDoc/BirdDoc/public;
        index  index.html index.htm;
        try_files $uri $uri/ =404;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 6.5 打开网站&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;http://birddoc.jayh.club&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501100943947-1755771389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（临时网站，后面可能会停掉。）&lt;/p&gt;
&lt;h2&gt; 6.6 如何用jenkins部署&lt;/h2&gt;
&lt;p&gt;参考我之前写的文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jackson0714/p/deploy1.html&quot;&gt;1. 容器化部署一套云服务 第一讲 Jenkins（Docker + Jenkins + Yii2 + 云服务器)）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后部署成功，控制台输出如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501180024833-827294838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查看public目录下这些文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501164722569-382900739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 6.7 如何自动部署&lt;/h2&gt;
&lt;p&gt;自动部署的方式很多&lt;/p&gt;
&lt;h3&gt;6.7.1 Jenkins 定时构建&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501170851088-1240438184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.7.2 Crontab定时构建&lt;/h3&gt;
&lt;p&gt;注意：该脚本还有些编译问题未解决，仅供参考。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/home/job/build.sh

#!/bin/bash
cd /home/workspace/BirdDoc/BirdDoc
/usr/bin/git pull
/usr/local/n/versions/node/10.15.3/bin/npm run build
currentTime=$(date)
echo $currentTime &amp;gt;&amp;gt; /home/job/build.log

crontab -e
* * * * * sleep 0; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 5; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 10; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 15; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 20; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 25; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 30; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 35; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 40; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 45; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
* * * * * sleep 55; /home/job/build.sh &amp;gt;&amp;gt; /home/job/cron.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　遇到的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aa50e6a6-972c-4b39-8878-295e0f3be6f8')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aa50e6a6-972c-4b39-8878-295e0f3be6f8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa50e6a6-972c-4b39-8878-295e0f3be6f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SyntaxError: Block-scoped declarations (let, &lt;span&gt;const&lt;/span&gt;, function, &lt;span&gt;class&lt;/span&gt;&lt;span&gt;) not yet supported outside strict mode
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     at exports.runInThisContext (vm.js:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     at Module._compile (module.js:&lt;span&gt;374&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     at Object.Module._extensions..js (module.js:&lt;span&gt;417&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     at Module.load (module.js:&lt;span&gt;344&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     at Function.Module._load (module.js:&lt;span&gt;301&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     at Function.Module.runMain (module.js:&lt;span&gt;442&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     at startup (node.js:&lt;span&gt;136&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     at node.js:&lt;span&gt;966&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; Already up-to-&lt;span&gt;date.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; /usr/local/n/versions/node/&lt;span&gt;10.15&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;/lib/node_modules/npm/bin/npm-cli.js:&lt;span&gt;85&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       let notifier = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;update-notifier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)({pkg})
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       ^^^
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; SyntaxError: Block-scoped declarations (let, &lt;span&gt;const&lt;/span&gt;, function, &lt;span&gt;class&lt;/span&gt;&lt;span&gt;) not yet supported outside strict mode
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     at exports.runInThisContext (vm.js:&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     at Module._compile (module.js:&lt;span&gt;374&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     at Object.Module._extensions..js (module.js:&lt;span&gt;417&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     at Module.load (module.js:&lt;span&gt;344&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     at Function.Module._load (module.js:&lt;span&gt;301&lt;/span&gt;:&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     at Function.Module.runMain (module.js:&lt;span&gt;442&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     at startup (node.js:&lt;span&gt;136&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     at node.js:&lt;span&gt;966&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;6.7.3 Jenkins通过git提交代码触发构建&lt;/h3&gt;
&lt;p&gt;我配置了GitHub hook trigger for GITScm polling，但还是没有自动触发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501173834985-340230510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.8 如何用docker跑起来&lt;/h3&gt;
&lt;p&gt;后续再用docker run起来。&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.1883614088821&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：悟空聊架构 &lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于移动开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！ &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/414640/201905/414640-20190501174331917-43146210.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悟空聊架构 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注我，带你每天进步一点点！&lt;/p&gt;
&lt;p&gt;还有111本书籍赠送~~&lt;/p&gt;

</description>
<pubDate>Sat, 04 May 2019 15:30:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>阅读全文需要15分钟，动手实践需要30分钟，请收藏点赞后再读。 演示地址：http://birddoc.jayh.club Github链接：https://github.com/Jackson071</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/birddoc.html</dc:identifier>
</item>
<item>
<title>Docker环境下的前后端分离项目部署与运维（四）Linux系统构成和基本操作 - 进击的辣条</title>
<link>http://www.cnblogs.com/wyt007/p/10810389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyt007/p/10810389.html</guid>
<description>&lt;pre&gt;
--&lt;span&gt;查询已经开放的端口
firewall&lt;/span&gt;-cmd --permanent --list-&lt;span&gt;ports
&lt;/span&gt;--开放8080-&lt;span&gt;8085tcp端口
firewall&lt;/span&gt;-cmd --permanent --add-port=&lt;span&gt;8080&lt;/span&gt;-&lt;span&gt;8085&lt;/span&gt;/&lt;span&gt;tcp
&lt;/span&gt;--&lt;span&gt;重新加载
firewall&lt;/span&gt;-cmd --&lt;span&gt;reload
&lt;/span&gt;--关闭8080-&lt;span&gt;8085tcp端口
firewall&lt;/span&gt;-cmd --permanent --remove-port=&lt;span&gt;8080&lt;/span&gt;-&lt;span&gt;8085&lt;/span&gt;/&lt;span&gt;tcp
&lt;/span&gt;--&lt;span&gt;查询开放的端口服务
firewall&lt;/span&gt;-cmd --permanent --list-services
&lt;/pre&gt;</description>
<pubDate>Sat, 04 May 2019 15:20:00 +0000</pubDate>
<dc:creator>进击的辣条</dc:creator>
<og:description>Linux目录结构 Linux常用命令 ls：列出目录内容 mkdir &lt;name&gt;：创建文件夹 touch &lt;name&gt;：创建文件 cp &lt;source&gt; &lt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyt007/p/10810389.html</dc:identifier>
</item>
<item>
<title>TensorFlow中的显存管理器——BFC Allocator - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;使用GPU训练时，一次训练任务无论是模型参数还是中间结果都需要占用大量显存。为了避免每次训练重新开辟显存带来计算之外的开销，一般框架的做法是在真正的训练任务开始前，将每个节点的输入和输出，以及模型参数的shape计算出来并全局开辟一次，例如Caffe就是这种做法。随着深度学习模型的发展和迭代，不仅模型训练的数据shape可能发生变化，就连模型本身在训练过程中也可能发生变化，那么按照固定shape一次开辟显存的做法就不能满足需求了。为此，TensorFlow重新设计了较为灵活的显存管理机制，它使用了名为BFC的分配算法，并通过BFC Allocator为每个Tensor分配满足需求的显存。本节我们将一起窥探BFC Allocator的设计思想。&lt;/p&gt;

&lt;h2&gt;为Tensor分配存储区的时机&lt;/h2&gt;
&lt;p&gt;在进入主题之前，让我们先思考一个问题：TensorFlow中的Tensor究竟是何时拿到所需存储区的呢？&lt;strong&gt;答案是在Tensor对象被创建时就立即进行分配。&lt;/strong&gt;在TensorFlow的一轮训练结束后，所有的Tensor都已经被释放，下一轮计算开始后会按照需求重新创建Tensor，并为其分配新的存储空间。下面的代码片段中我们可以看到Tensor创建时，使用Allocator分配存储区的代码段。&lt;/p&gt;
&lt;p&gt;在创建Tensor对象时需要传入一个Allocator，这个Allocator可以是任何实现类，在GPU上使用的就是BFCAllocator。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Tensor::Tensor(Allocator* a, DataType type, &lt;span&gt;const&lt;/span&gt; TensorShape&amp;amp;&lt;span&gt; shape)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    : shape_(shape), buf_(nullptr) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  set_dtype(type);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  CHECK_NOTNULL(a);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (shape_.num_elements() &amp;gt; &lt;span&gt;0&lt;/span&gt; || a-&amp;gt;&lt;span&gt;ShouldAllocateEmptyTensors()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     CASES(type, buf_ = &lt;span&gt;new&lt;/span&gt; Buffer&amp;lt;T&amp;gt;&lt;span&gt;(a, shape.num_elements()));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (buf_ != nullptr &amp;amp;&amp;amp; buf_-&amp;gt;data() != nullptr &amp;amp;&amp;amp;&lt;span&gt; LogMemory::IsEnabled()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     LogMemory::RecordTensorAllocation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LogMemory::UNKNOWN_STEP_ID,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                                       *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码的第6行创建了Buffer对象，它就是Tensor对象的实际存储区，让我们看看其构造函数的实现内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; emplate &amp;lt;typename T&amp;gt;
&lt;span&gt;2&lt;/span&gt; Buffer&amp;lt;T&amp;gt;::Buffer(Allocator*&lt;span&gt; a, int64 n,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                   &lt;span&gt;const&lt;/span&gt; AllocationAttributes&amp;amp;&lt;span&gt; allocation_attr)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     : BufferBase(a, a-&amp;gt;Allocate&amp;lt;T&amp;gt;(n, allocation_attr)), elem_(n) {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码段重点在于第4行，因为在此处调用了Allocate函数，此时Buffer真正获得了一片实际的存储区。这已经能够说明存储区分配的时机是在一个Tensor对象被创建时立即发生的。&lt;/p&gt;
&lt;h2&gt;遇到的问题——显存分配与回收的性能需求&lt;/h2&gt;
&lt;p&gt;Tensor在每次创建时会得到存储区域，而每一轮训练都要重新创建新的Tensor，那么这里面临的一个问题：如此频繁的分配和回收存储区，如何才能做的高效？试想对于GPU来说，如果Allocate函数直接封装CUDA中昂贵的cudaMalloc函数，当Tensor被释放时直接调用cudaFree函数，那么训练速度将会因为这些overhead大打折扣。&lt;/p&gt;
&lt;h2&gt;解决问题的基本思路——存储池&lt;/h2&gt;
&lt;p&gt;如果你对操作系统这门课比较熟悉，那么应该很容易想到解决办法：将显存按照不同的大小一次性开辟出来，并组成存储池，每次调用Allocate函数时从存储池中获取，Tensor回收时将显存重新挂到存储池中。这样做确实可以满足性能需求，但是需要为此设计一个相对复杂的存储管理器。BFC Allocator就是TensorFlow中管理GPU显存的存储管理器。&lt;/p&gt;
&lt;p&gt;好了，需求和背景都已经了解了，接下来可以进入正题了，让我们先从原理开始说起。&lt;/p&gt;

&lt;p&gt;BFC的全称是Best-Fit with Coalescing。从TensorFlow源码注释中得知，BFC算法并非TensorFlow完全原创，而是dlmalloc的一个简单实现版本。dlmalloc是一款优秀的存储分配器，它以Doug Lea的名字命名，&lt;a href=&quot;http://g.oswego.edu/dl/html/malloc.html&quot; target=&quot;_blank&quot;&gt;这个站点&lt;/a&gt;包含了dlmalloc的详细说明，有兴趣的同学可以去看一看。之所以在TensorFlow中引入一个简单版本的dlmalloc算法，是因为该算法可以非常高效的按需分配和回收存储区，并尽可能减少存储碎片。&lt;/p&gt;

&lt;p&gt;核心在于将存储区划分成块，并挂入存储池中进行管理。将存储区划分成存储块时要满足以下要求。&lt;/p&gt;
&lt;p&gt;1. 块内地址是连续地址&lt;/p&gt;
&lt;p&gt;2. 存储池中的块要以每个块基地址升序排列，并组织成双向链表&lt;/p&gt;
&lt;p&gt;3. 高地址块的size大于低地址块的size&lt;/p&gt;
&lt;p&gt;TensorFlow将存储块以及相应的块信息抽象为一种叫做Chunk的数据结构。&lt;/p&gt;
&lt;h2&gt;核心数据结构&lt;/h2&gt;
&lt;h3&gt;Chunk&lt;/h3&gt;
&lt;p&gt;Chunk是BFC最核心的数据结构之一，在TensorFlow源码中是以struct来描述的。具体来说，一个Chunk代表一段连续的存储空间，BFC要求各个Chunk要按照基地址升序排列并组织成双向链表，下图展示了Chunk的结构以及Chunk之间的连接关系。初始时，每个Chunk都有自己的size，并且这些size都是以256字节为模。应当注意，&lt;strong&gt;每个Chunk或者完全被标记为使用，或者完全标记为空闲，不存在该Chunk内只有部分空间被使用的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201904/1437153-20190420214100952-654999029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;prev，next：这两个变量起到指针作用，分别指向前驱和后继Chunk。因为在BFC Allocator模块中多个chunk都被放入了vector中，所以这两个指针实际上就是前驱和后继的index&lt;/p&gt;
&lt;p&gt;ptr：该Chunk的起始存储地址，或者叫基地址&lt;/p&gt;
&lt;p&gt;size：该Chunk描述存储区的&lt;strong&gt;实际总大小&lt;/strong&gt;，每个Chunk的size是不同的，但都以256字节为模&lt;/p&gt;
&lt;p&gt;requested_size：该Chunk描述存储区的&lt;strong&gt;使用大小，&lt;/strong&gt;代表了用户请求使用的大小&lt;strong&gt;，&lt;/strong&gt;它一定小于等于size&lt;strong&gt;。&lt;/strong&gt;因为Chunk不能被部分使用，所以即使用户实际只使用requested_size，那么也只能将整个大小为size的Chunk全部分配出去，显然这可能会造成一些碎片的浪费&lt;/p&gt;
&lt;p&gt;allocation_id：该值如果不为0，则代表已经被标记为使用，反之则是空闲&lt;/p&gt;
&lt;p&gt;bin_num：代表该Chunk所在Bin的Index。Bin是另一个核心数据结构，下面将会做详细介绍&lt;/p&gt;
&lt;h3&gt;Bin&lt;/h3&gt;
&lt;p&gt;如果我们想查询某一块符合条件的空闲Chunk并取出，那么只能对双向链表做遍历，显然这个效率不是很高。为了加速查询某块Chunk的速度，可以在创建Chunk链表时按一定顺序排列，并将整个有序链表在逻辑上切分成多个段，为每个段记录所包含的Chunk的范围，这种结构就是Bin，它相当于一种索引。因此，Bin结构是为了方便Chunk的查询而出现的。在BFC Allocator中，每个段中Chunk的顺序是按照size和基地址升序排序的，每个Bin都设有自己的bin_size，该bin_size表示该段包含的最小Chunk的size。这样一来，用户端就可以根据所需要申请的Memory大小直接找到对应的Bin，然后在该Bin中遍历寻找适合的Chunk。为了能够根据bin_size直接定位到Bin，规定bin_size与bin_num的大小关系为：bin_size=256 * 2&lt;sup&gt;bin_num&lt;/sup&gt;。用户在申请Memory时，会将实际大小映射到最适合的bin_size上，然后再根据bin_size与bin_num的关系找到对应的Bin，进而在该段中遍历搜索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504144033445-910888917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bin中Chunk的是通过Set组织的，为了能在Set中体现双向链表的逻辑，只需要让Chunk在Set中按照规则升序排列，并修正前驱后继指针即可。指定Chunk顺序的Comparator代码段定义在Bin结构中，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sort first by size and then use pointer address as a tie breaker.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;()(&lt;span&gt;const&lt;/span&gt;&lt;span&gt; ChunkHandle ha,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;const&lt;/span&gt; ChunkHandle hb) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; NO_THREAD_SAFETY_ANALYSIS {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;const&lt;/span&gt; Chunk* a = allocator_-&amp;gt;&lt;span&gt;ChunkFromHandle(ha);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;const&lt;/span&gt; Chunk* b = allocator_-&amp;gt;&lt;span&gt;ChunkFromHandle(hb);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (a-&amp;gt;size != b-&amp;gt;&lt;span&gt;size) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a-&amp;gt;size &amp;lt; b-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; a-&amp;gt;ptr &amp;lt; b-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;辅助工具类&lt;/h2&gt;
&lt;h2&gt;AllocationRegion与RegionManager&lt;/h2&gt;
&lt;p&gt;这两个类是起到辅助作用。BFC Allocator每次分配存储区时都以Chunk为单位，指向Chunk的指针又是ChunkHandle类型（实际为数组下标），但分配存储的最终目的是把Chunk中指向存储区域的头指针ptr分配给请求方。另外，当系统回收存储区时，面对的也是存储区的头指针，那么如果不能根据头指针找到Chunk和Bin信息，回收就不能成功。因此这里显然应该设计一系列接口和函数：&lt;strong&gt;它能够记录每次分配的Chunk，并且能够保存分配存储区的地址ptr与Chunk之间的映射关系&lt;/strong&gt;。AllocationRegion和RegionManager就是完成这些功能的接口。&lt;/p&gt;
&lt;p&gt;具体而言，AllocationRegion对应一次存储区分配的记录。一次存储区分配的信息包括起始地址ptr和存储区大小memory_size，这可能包括多个Chunk，所以该结构要记录此次分配中所包含所有Chunk的信息。RegionManager是AllocationRegion的管理器，它维护了AllocationRegion的数组。在RegionManager中，AllocationRegion数组是需要按照end_ptr地址排序的。&lt;/p&gt;
&lt;p&gt;利用RegionManager查询某个ptr所对应的ChunkHandle的时序图如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504203539466-288395100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分功能较为简单，所以不再展开代码逻辑，感兴趣的同学可以阅读这两个类的定义立即就能理解。&lt;/p&gt;

&lt;p&gt;介绍完基本结构和BFC的设计思想之后，就可以试着去理解具体的存储区分配和回收过程了。&lt;/p&gt;
&lt;h2&gt;Allocate流程&lt;/h2&gt;
&lt;h3&gt;AllocateRawInternal&lt;/h3&gt;
&lt;p&gt;这是BFCAllocator的为用户分配Chunk的总体流程。因为物理设备上实际的&lt;strong&gt;空闲&lt;/strong&gt;存储区已经被事先开辟好，并以Chunk的形式组织成了双向链表，那么BFC Allocator为用户分配存储区时直接从Chunk中获取即可。当双向链表中找不到合适的Chunk时，不得不向物理设备上申请更多存储空间，并创建新的Chunk放入到双向链表中，并挂入到B相应的Bin中。下面的流程图展示了这一过程，该过程涉及到了几个比较重要的子过程。它们分别是遍历搜索寻找最佳Chunk指针的FIndChunkPtr过程，当Chunk链表中不存在合适的Chunk以至于不得不向物理设备申请新存储空间的Extend过程，以及分配Chunk时为缓解碎片问题而出现的SplitChunk过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504225734983-60895445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体流程的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt; BFCAllocator::AllocateRawInternal(size_t unused_alignment,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                                        size_t num_bytes,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                                         &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; dump_log_on_failure,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                                        uint64 freed_before) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (num_bytes == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tried to allocate 0 bytes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, always allocate memory of at least kMinAllocationSize
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bytes, and always allocate multiples of kMinAllocationSize bytes
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; so all memory addresses are nicely byte aligned.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   size_t rounded_bytes =&lt;span&gt; RoundedBytes(num_bytes);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The BFC allocator tries to find the best fit first.&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   BinNum bin_num =&lt;span&gt; BinNumForSize(rounded_bytes);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  mutex_lock l(lock_);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt;* ptr =&lt;span&gt; FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (ptr !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ptr;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try to extend&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Extend(unused_alignment, rounded_bytes)) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     ptr =&lt;span&gt; FindChunkPtr(bin_num, rounded_bytes, num_bytes, freed_before);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ptr !=&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ptr;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We searched all bins for an existing free chunk to use and
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; couldn't find one.  This means we must have run out of memory,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Dump the memory log for analysis.&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dump_log_on_failure) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     LOG(WARNING) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Allocator (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Name() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) ran out of memory trying &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;to allocate &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; strings::HumanReadableNumBytes(num_bytes)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                  &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.  Current allocation summary follows.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    DumpMemoryLog(rounded_bytes);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     LOG(WARNING) &amp;lt;&amp;lt;&lt;span&gt; RenderOccupancy();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;FindChunkPtr过程&lt;/h3&gt;
&lt;p&gt;因为Chunk在每个Bin中都是按照size和基地址升序排列，所以搜索Chunk时只需顺序遍历free_chunks即可，首个找到的符合要求的Chunk即为所求。这个过程非常简单，不再以图的形式描述，只展示代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;*&lt;span&gt; BFCAllocator::FindChunkPtr(BinNum bin_num, size_t rounded_bytes,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                                 size_t num_bytes, uint64 freed_before) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; First identify the first bin that could satisfy rounded_bytes.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (; bin_num &amp;lt; kNumBins; bin_num++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start searching from the first bin for the smallest chunk that fits
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rounded_bytes.&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Bin* b =&lt;span&gt; BinFromIndex(bin_num);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (auto citer = b-&amp;gt;free_chunks.begin(); citer != b-&amp;gt;&lt;span&gt;free_chunks.end();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          ++&lt;span&gt;citer) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;const&lt;/span&gt; BFCAllocator::ChunkHandle h = (*&lt;span&gt;citer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       BFCAllocator::Chunk* chunk =&lt;span&gt; ChunkFromHandle(h);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       DCHECK(!chunk-&amp;gt;&lt;span&gt;in_use());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (freed_before &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; freed_before &amp;lt; chunk-&amp;gt;&lt;span&gt;freed_count) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;=&lt;span&gt; rounded_bytes) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We found an existing chunk that fits us that wasn't in use, so remove
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it from the free bin structure prior to using.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         RemoveFreeChunkIterFromBin(&amp;amp;b-&amp;gt;&lt;span&gt;free_chunks, citer);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we can break the size of the chunk into two reasonably large
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pieces, do so.  In any case don't waste more than
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; kMaxInternalFragmentation bytes on padding this alloc.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;const&lt;/span&gt; int64 kMaxInternalFragmentation = &lt;span&gt;128&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 128mb&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;= rounded_bytes * &lt;span&gt;2&lt;/span&gt; ||
&lt;span&gt;26&lt;/span&gt;             static_cast&amp;lt;int64&amp;gt;(chunk-&amp;gt;size) - rounded_bytes &amp;gt;=
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                kMaxInternalFragmentation) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;          SplitChunk(h, rounded_bytes);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;           chunk = ChunkFromHandle(h);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update chunk pointer in case it moved&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The requested size of the returned chunk is what the user
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; has allocated.&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         chunk-&amp;gt;requested_size =&lt;span&gt; num_bytes;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assign a unique id and increment the id counter, marking the
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; chunk as being in use.&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         chunk-&amp;gt;allocation_id = next_allocation_id_++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update stats.&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         ++&lt;span&gt;stats_.num_allocs;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         stats_.bytes_in_use += chunk-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         stats_.peak_bytes_in_use =
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            std::max(stats_.peak_bytes_in_use, stats_.bytes_in_use);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         stats_.largest_alloc_size =
&lt;span&gt;45&lt;/span&gt;             std::max&amp;lt;std::size_t&amp;gt;(stats_.largest_alloc_size, chunk-&amp;gt;&lt;span&gt;size);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         VLOG(&lt;span&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Returning: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; chunk-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (VLOG_IS_ON(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;           LOG(INFO) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; RenderOccupancy();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; chunk-&amp;gt;&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;SplitChunk过程&lt;/h3&gt;
&lt;p&gt;上图中没有展示出SplitChunk发生的位置，其实该过程是在FindChunkPtr中发生。在选取Chunk时，会有一定概率出现请求的size比所选的Chunk总size小很多的情况。因为每块Chunk只有in use或free两种状态，所以如果空闲的size比请求的size大很多，显然会造成该Chunk的实际使用率过低，这是一种浪费。BFC Allocator通过调用SplitChunk将Chunk分割成两部分来缓解这一问题。SplitChunk的功能顾名思义，就是将一块大的Chunk分割成两个部分。该过程发生在FindChunkPtr中，我们需要注意触发SplitChunk过程的条件，在代码中我们能看到这一函数的调用条件如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we can break the size of the chunk into two reasonably large
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pieces, do so.  In any case don't waste more than
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; kMaxInternalFragmentation bytes on padding this alloc.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; int64 kMaxInternalFragmentation = &lt;span&gt;128&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;20&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 128mb&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (chunk-&amp;gt;size &amp;gt;= rounded_bytes * &lt;span&gt;2&lt;/span&gt; ||
&lt;span&gt; 6&lt;/span&gt;     static_cast&amp;lt;int64&amp;gt;(chunk-&amp;gt;size) - rounded_bytes &amp;gt;=
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        kMaxInternalFragmentation) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  SplitChunk(h, rounded_bytes);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   chunk = ChunkFromHandle(h);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update chunk pointer in case it moved&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码中可以清晰的看到，当以下两个条件之一满足时，SplitChunk过程将被触发。&lt;/p&gt;
&lt;p&gt;1. 当chunk的size是用户请求的round size两倍及以上时（用户请求的size会根据最小分配单元做round近似）&lt;/p&gt;
&lt;p&gt;2. 当chunk的size减去用户请求的round size后依然大于等于最大碎片限定时（128MB）&lt;/p&gt;
&lt;p&gt;在执行SplitChunk时，需要调整Chunk的前驱后继指针，这就是链表的基本操作，非常简单。另外，SplitChunk会产生新的Free Chunk，需要根据它的大小将它插入到对应的Bin中。&lt;/p&gt;
&lt;h3&gt;Extend过程&lt;/h3&gt;
&lt;p&gt;上面的流程图已经展示，只有在双向链表中不能找到合适的Chunk时，Extend过程才会被调用。它的调用说明现有的存储池中已经没有可以满足需求的存储区了，需要向物理设备申请，并创建新的Chunk，然后放入Bin中。向物理设备申请存储空间时，如果因为一次申请的空间较大而失败，会将请求空间做0.9因子的衰退，下面的代码段展示了这个细节。申请结束后，需要向region_manager中记录该次申请。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try allocating.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; size_t bytes =&lt;span&gt; std::min(curr_region_allocation_bytes_, available_bytes);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* mem_addr = sub_allocator_-&amp;gt;&lt;span&gt;Alloc(alignment, bytes);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mem_addr == nullptr &amp;amp;&amp;amp; !&lt;span&gt;started_backpedal_) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only backpedal once.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   started_backpedal_ = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; constexpr &lt;span&gt;float&lt;/span&gt; kBackpedalFactor = &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try allocating less memory.&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (mem_addr ==&lt;span&gt; nullptr) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     bytes = RoundedBytes(bytes *&lt;span&gt; kBackpedalFactor);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bytes &amp;lt; rounded_bytes) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     mem_addr = sub_allocator_-&amp;gt;&lt;span&gt;Alloc(alignment, bytes);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Deallocate流程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为在回收时只知道存储空间首地址指针，并不知道其对应的Chunk，所以需要先借助region_manager等辅助工具获取其所对应的Chunk指针，然后考虑其前驱后继节点是否可以合并。下面展示了整体流程。因为Merge的过程即使链表合并的过程，比较简单，所以在此不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201905/1437153-20190504221452222-244135340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分对应的代码逻辑如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BFCAllocator::FreeAndMaybeCoalesce(BFCAllocator::ChunkHandle h) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   Chunk* c =&lt;span&gt; ChunkFromHandle(h);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   CHECK(c-&amp;gt;in_use() &amp;amp;&amp;amp; (c-&amp;gt;bin_num ==&lt;span&gt; kInvalidBinNum));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark the chunk as no longer in use.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   c-&amp;gt;allocation_id = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optionally record the free time.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timing_counter_) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     c-&amp;gt;freed_count = timing_counter_-&amp;gt;&lt;span&gt;next();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Updates the stats.&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   stats_.bytes_in_use -= c-&amp;gt;&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;   ChunkHandle coalesced_chunk =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the next chunk is free, merge it into c and delete it.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;next != kInvalidChunkHandle &amp;amp;&amp;amp; !ChunkFromHandle(c-&amp;gt;next)-&amp;gt;&lt;span&gt;in_use()) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; VLOG(8) &amp;lt;&amp;lt; &quot;Merging c-&amp;gt;next &quot; &amp;lt;&amp;lt; ChunkFromHandle(c-&amp;gt;next)-&amp;gt;ptr
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         &amp;lt;&amp;lt; &quot; with c &quot; &amp;lt;&amp;lt; c-&amp;gt;ptr;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     RemoveFreeChunkFromBin(c-&amp;gt;&lt;span&gt;next);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     Merge(h, c-&amp;gt;&lt;span&gt;next);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the previous chunk is free, merge c into it and delete c.&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;prev != kInvalidChunkHandle &amp;amp;&amp;amp; !ChunkFromHandle(c-&amp;gt;prev)-&amp;gt;&lt;span&gt;in_use()) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; VLOG(8) &amp;lt;&amp;lt; &quot;Merging c &quot; &amp;lt;&amp;lt; c-&amp;gt;ptr &amp;lt;&amp;lt; &quot; into c-&amp;gt;prev &quot;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;         &amp;lt;&amp;lt; ChunkFromHandle(c-&amp;gt;prev)-&amp;gt;ptr;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     coalesced_chunk = c-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     RemoveFreeChunkFromBin(c-&amp;gt;&lt;span&gt;prev);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     Merge(c-&amp;gt;&lt;span&gt;prev, h);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;  InsertFreeChunkIntoBin(coalesced_chunk);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是控制Allocator的一个选项，默认是False，此时会在设备上开辟最大限度的存储空间，并且全局只开辟一次。因为已经开辟了设备上的全部存储空间，所以若在双向链表中找不到合适的Chunk，那么将会直接报错OOM退出。当选项为True时，会经历多次存储空间的开辟，这完全取决于当前存储池中是否还有符合需求大小的Chunk。如果没有，则不断以2的n次方为基本大小进行开辟尝试，直到满足需求为止。那么这个值有什么用处呢？这取决于同一个Device是否允许被多个程序复用。比如在云基础设施上，如果能够开启Device复用，并打开Device的空分复用功能，那么将会大大提高集群资源的利用率。&lt;/p&gt;

&lt;p&gt;本文总结了TensorFlow中存储管理器——BFC Allocator。它的设计思路来自于经典来的dlmalloc分配算法，是Best fit coalecing的简单实现版本。BFC Allocator是为了应对TensorFlow中频繁分配释放存储空间需求的场景而出现的解决方案，通过事先将存储空间从物理设备上开辟好，并将这些空闲存储空间封装成Chunk，组织成有序双向链表，然后利用Bin这一种索引结构为Chunk的查询做加速，最终完成了高效的分配算法。在实际分配时，可能会遇到Chunk链表中不存在符合要求的空闲Chunk情况，这时候就可能需要向物理设备中再次开辟新的存储空间，这个过程被视为对Chunk链表的扩展，对应的过程是Extend。因为是按Chunk进行分配，势必可能造成存储碎片，为了解决碎片问题，BFC Allocator设计了SplitChunk和Merge函数。BFC Allocator是TensorFlow代码中比较精简的一个部分，该部分的代码难度较低，并且模块独立性较强，涉及到的代码量非常小，但是设计思想和功能却非常全面，非常适合初学者阅读和学习。&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 15:00:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 使用GPU训练时，一次训练任务无论是模型参数还是中间结果都需要占用大量显存。为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10741859.html</dc:identifier>
</item>
<item>
<title>Java核心技术梳理-异常处理 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10810238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10810238.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常总是不可避免的，就算我们自身的代码足够优秀，但却不能保证用户都按照我们想法进行输入，就算用户按照我们的想法进行输入，我们也不能保证操作系统稳定，另外还有网络环境等，不可控因素太多，异常也不可避免。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但我们可以通过异常处理机制让程序有更好的容错性和兼容性，当程序出现异常时，系统自动生成Exception对象通知系统，从而将业务功能实现代码和错误处理代码分离。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常处理已经成为衡量一门语言是否成熟的标志之一，增加了异常处理机制后程序有更好的健壮性和容错性。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;异常处理机制&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;我们希望系统有一种机制能够将错误处理代码和正常实现代码分离开，相当于一个if else,if中为正常实现代码，而else为错误的处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;try...catch 捕获异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;我们按照上面的思路，java利用try catch来进行异常捕获。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务代码&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException ex){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理    &lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理代码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当try块代码出错时，系统生成一个异常对象，并将对象抛给运行环境，这个过程叫做抛出异常，运行环境接收到异常对象是，会寻找处理该异常对象的catch代码块，找到合适的catch块，就将对象给其处理，如果找不到，则运行环境终止，程序也将退出。&lt;/p&gt;
&lt;h3&gt;2.2 异常类继承体系&lt;/h3&gt;
&lt;p&gt;Java提供了丰富的异常类，这些异常类有严格的继承关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190504223458890-896620832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从这个图可以看出异常主要分为两类，Error与Exception，Error错误一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误，这些错误无法恢复或不可能捕获，将导致应用程序崩溃，这些不需要我们去捕获。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在捕获异常时我们通常把Exception类放在最后，因为按照异常捕获的机制，从上至下判断该异常对象是否是catch中的异常类或其异常子类，一旦比较成功则用此catch进行处理。如果将Exception类放在前面，那么就会进行直接进入其中，因为Exception类是所有异常类的父类，那排在它后面的异常类将永远得不到执行的机会，这种机制我们称为&lt;span&gt;&lt;strong&gt;先小后大&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.3 &lt;/span&gt;多异常捕获&lt;/h3&gt;
&lt;p&gt;Java 7 开始，一个catch块中可以捕获多种类型的异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Integer a &lt;/span&gt;= Integer.parseInt(args[0&lt;span&gt;]);
        Integer b &lt;/span&gt;= Integer.parseInt(args[1&lt;span&gt;]);
        Integer c &lt;/span&gt;= a /&lt;span&gt; b;
        System.out.println(c);

    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IndexOutOfBoundsException |&lt;span&gt; NumberFormatException
            &lt;/span&gt;|&lt;span&gt; ArithmeticException ie) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常变量默认final，不能重新赋值&lt;/span&gt;
        ie = &lt;span&gt;new&lt;/span&gt; ArithmeticException(&quot;text&quot;&lt;span&gt;);

    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个异常之间用竖线（|）隔开，并且异常变量默认final，不能重新赋值。&lt;/p&gt;
&lt;h3&gt;2.4 获取异常信息&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常捕获后我们想要查看异常信息，可以通过catch后的异常形参来获得，常用的方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;getMessage()：返回异常的详细描述字符串。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;getStackTrace()：返回异常跟踪栈信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;printStackTrace()：将异常跟踪栈信息按照标准格式输出。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;printStackTrace(PrintStream p)：将异常跟踪栈信息输出到指定输出流。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.5 finally回收资源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;在try里面打开的一些物理连接，需要显示的回收，但显然在try里面或者catch里面进行回收是不行的，try中一旦出现异常，回收可能不会执行到，而catch更不行，因为在没有异常时根本不会执行，于是异常处理机制提供了finally，finally块代码一定会被执行，即是try中执行了return语句也还是会执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务代码&lt;/span&gt;
}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(XXXException xx){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常处理&lt;/span&gt;
}&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(XXXException xx){
    
}&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;资源回收&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在异常处理中，try是必须的，没有try块，后面的catch和finally没有意义，catch和finally必须出现一个，finally块必须是最后。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果try块中有return语句，则会先执行finally，然后再执行return语句，如果try块中有exit语句，则不会执行finally,都直接退出虚拟机了当然不会再去执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;6 自动关闭的try语句&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;每次都需要资源回收，显得有些麻烦，Java还支持一种写法，直接在try后申明资源，那么就可以替换掉finally，但这个资源必须实现Closeable或者AutoCloseable接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; (
        BufferedReader bufferedReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; FileReader(&quot;&quot;&lt;span&gt;))
) {
    bufferedReader.read();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;Checked异常与Runtime异常&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Java的异常分为两大类：Checked（可检查）异常和Runtime（运行时）异常，所有的RuntimeException类及其子类的实例就是Runtime异常，其他的都是Checked异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对于Checked异常处理方式有两种，一种是明确知道如何处理该异常，用try catch来捕获异常，然后在catch中修复异常，一种是不知道如何处理，在定义方法时申明抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Runtime异常无需显示申明抛出，需要捕获异常，就用try catch来实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 使用throws声明抛出异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用throws声明的思路是：当前方法不知道如何处理这种类型的异常，则由上一级调用者处理，如果main方法也不知道如何处理，也可以使用throws抛给JVM，JVM的处理是，打印异常的跟踪栈信息，并终止程序。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;throws声明抛出只能在方法签名中使用，可以声明抛出多个异常类，多个异常类用逗号隔开，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    FileInputStream fileInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;申明了throws就不需要再使用try catch来捕获异常了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果某段代码中调用了一个带throws声明的方法，那么必须用try catch来处理或者也带throws声明，如下例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        test();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        e.printStackTrace();
    }

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test () &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
    FileInputStream fileInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个时候要注意，子类方法声明抛出的异常应该是父类方法声明抛出异常的子类活相同，不允许比父类声明抛出的异常多。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;本人之前是C#开发，C#开发没有Checked异常，个人觉得这个Checked异常有些繁琐，它最大的作用仿佛是提醒开发处理异常，避免因为粗心而忘记处理异常，不知道是不是理解有误。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;四、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;使用throw抛出异常&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;程序出现错误，系统会抛出异常，有时候我们也想自行抛出异常，比如用户未登录，我们可能就直接抛出错误，这种自行抛出的异常一般都与业务相关，因为业务数据与既定不符，但是这种异常并不是一种错误，系统不会捕捉，就需要我们自行抛出。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用throw语句进行异常抛出，抛出的不是一个异常类，而是一个异常实例，而且每次只能抛出一个：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (user== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;用户不存在&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们又要区分Checked异常与运行时异常，运行时异常申明非常简单，直接抛出即可，而Checked异常又要像之前一样，要么使用try catch，要么声明throws&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查时异常需要写try catch&lt;/span&gt;
&lt;span&gt;        test1();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        e.printStackTrace();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行时异常直接调用即可&lt;/span&gt;
&lt;span&gt;    test2();

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test1() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (1 &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;用户不存在&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (1 &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;用户不存在&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.1 自定义异常类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;为了让错误更直观的表达信息，有时候我们需要自定义异常， 自定义异常很简单，只需要继承Exception或者RuntimeException基类，一般会提供两个构造器，一个空构造器，一个带有描述信息的构造器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GlobalException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RuntimeException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlobalException() {
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带有错误描述信息的构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GlobalException(String msg) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;4.2 异常链&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在实际开发中，我们一般会分层开发，比较常用的是三层，表现出、业务逻辑层、数据库访问层，我们不会抛出数据库异常给用户，因为这些异常中有堆栈信息，很不安全，也非常的不友好。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通常，我们捕获原始异常（可以写入日志），然后再抛出一个业务异常（通常是自定义的异常），这个业务异常可以提示用户异常的原因：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; GlobalException{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException ex){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;        ...
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出自定义错误&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GlobalException(&quot;数据库报错&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录日志&lt;/span&gt;
&lt;span&gt;        ...
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GlobalException(&quot;未知错误！&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种捕获一个异常然后抛出另一个异常，并将原始信息保存起来的是一种典型的链式处理（责任链模式）。&lt;/p&gt;
&lt;h2&gt;五、&lt;span class=&quot;md-expand&quot;&gt;异常处理规则&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;异常给系统带来了健壮性和容错性，但是使用异常处理并非如此简单，我们还要注意性能和结构的优化，有些规则我们必须了解，而这些规则的主要目标是：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;程序代码混乱最小化。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;捕获并保留诊断信息。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通知合适的人员&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;采用合适的方式结束异常。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.1 不要过度使用异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;什么叫过度使用异常呢？有两种情况，一是把异常和普通错误放在一起，使用异常来代替错误，什么意思呢？就是对一些我们已知或可控的错误进行异常处理，如一些业务逻辑判断，用户的输入等，并不是只有直接抛出异常这种选择，我们可以直接通过业务处理进行错误返回，而不是抛出错误，抛出错误的效率要低一些，只有对外部的、不能确定和预知的运行时错误使用异常。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;二就是使用异常来代替流程控制，异常处理机制的初衷是将不可以预期的错误和正常的业务代码分离，不应该用异常来进行流程控制。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.2 不要使用过大的try块&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不要把大量的业务代码放在try中，大量的业务代码意味着错误可能性也增大，也意味着一旦出错，分析错误的复杂度也增加，而且try中包含大量业务，可能后面紧跟的catch块也很多，我们会使用多个catch来捕获错误，这样代码也很臃肿，应该尽量细分try，去分别捕获并处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;5.3 不要忽略捕获到的异常&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;不要忽略异常，当我们捕获到异常时，我们不要去忽略它，如果在catch中什么也不做，那是一种恐怖的做法，因为这意味着出现了错误我们并不知道（极特殊的情况例外，比如：一些可重试的业务处理），最起码的做法是打印错误日志，更进一步看是否可以修复错误，或者向上抛出错误。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:49:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 异常总是不可避免的，就算我们自身的代码足够优秀，但却不能保证用户都按照我们想法进行输入，就算用户按照我们的想法进行输入，我们也不能保证操作系统稳定，另外还有网络环境等，不可控因素太多，异常也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10810238.html</dc:identifier>
</item>
<item>
<title>React的世界观及与Vue之比较 - 大唐西域都护</title>
<link>http://www.cnblogs.com/leegent/p/10794047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leegent/p/10794047.html</guid>
<description>&lt;p&gt;写在前面：本文谈论的是&lt;strong&gt;主观的个人感受&lt;/strong&gt;，不追求立场的“客观、公正”，因此我下面所说的很可能是错的，欢迎交流指正。&lt;/p&gt;

&lt;p&gt;我学习前端时，跟大部分beginner一样，学的第一个框架是Vue，入职后也一直写Vue。写了一年多，想换换口味了，于是决定最近的新项目改用React试试。用了大半个月后，我已经完全被这个迷人的框架洗脑了，特别是它背后的设计理念非常优秀，让人耳目一新。&lt;/p&gt;
&lt;p&gt;React的设计思想有何过人之处呢？拿它和Vue做个对比就清楚了。&lt;/p&gt;

&lt;h2&gt;Vue: 填模板游戏继续&lt;/h2&gt;
&lt;p&gt;Vue之所以成为国内前端初学者（包括我）的首选，一方面是因为中文文档写得好，更重要的原因则是它符合人们对于网页开发的传统认知。&lt;/p&gt;
&lt;p&gt;Vue虽然内部做了很多工作（如Virtual DOM），但暴露给开发者的体验更像是&lt;strong&gt;升级版的模板引擎&lt;/strong&gt;，类似于Jade、Handlerbars。模板引擎的作用就是在静态的模板上动态替换JS变量，以渲染出最终的页面。基于Vue的项目目录下，每个组件目录下都有html、css、js文件三足鼎立（或者集中到一个.vue文件里，但仍然是分开的三部分），html是静态模板，js管理动态的变量，整体结构非常的直观。&lt;/p&gt;
&lt;p&gt;此外，Vue在模板引擎的基础上增加了“双向绑定”功能，即用户输入造成的DOM变动可以反过来同步给关联的JS变量；并且自定义了一些v指令，大大简化了事件绑定、条件渲染、动态列表等常用功能的实现复杂度。这些因素使得Vue写起来既像模板引擎一样易于理解，又比模板引擎方便很多。我个人写Vue的时候，一般就是先写html模板，在此过程中把需要动态填充的数据定义出来，随手写个mock数据先占位；等模板写完了，再来写获取这些数据的js逻辑。&lt;/p&gt;
&lt;p&gt;也就是说，Vue的开发思路差不多就是“写模板-填模板”的套路，与jQuery时代一脉相承。&lt;/p&gt;
&lt;p&gt;这种套路上手容易，但是没什么发挥空间，写多了真的容易腻烦。而且在JS逻辑越来越复杂的情况下，状态管理非常麻烦，心智负担沉重。&lt;/p&gt;
&lt;p&gt;骚年，要不要换一种玩法试试？&lt;/p&gt;

&lt;h2&gt;React: 一种新的玩法&lt;/h2&gt;
&lt;p&gt;刚接触React的时候，是不是被嵌在js里的html（JSX）、满天飞的箭头函数、高阶函数等弄得有点不适应？反正我是脑阔疼了好一阵。&lt;/p&gt;
&lt;p&gt;但是进一步了解React后就会明白，这不是脸书的攻城狮们在耍帅或者故弄玄虚，而是这些语法真的能够更好地表达React的思想，帮助代码作者和读者thinking in React。&lt;/p&gt;
&lt;p&gt;React的核心思想是什么呢？不妨来看看Vue和React的组件对比。这是一个非常简单的组件——展示从父组件收到的message字符串：&lt;/p&gt;
&lt;p&gt;Vue的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; demo.vue&lt;/span&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;{{message}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; =&lt;span&gt; {
    props: ['&lt;/span&gt;&lt;span&gt;message']&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; demo.jsx&lt;/span&gt;
&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; props =&amp;gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;div&amp;gt;{props.message}&amp;lt;/div&amp;gt;
);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两段代码一眼就能一个非常明显的不同点——Vue组件实现为一个有模板（template）、有数据（props）的&lt;strong&gt;对象&lt;/strong&gt;， React组件则实现为一个输入数据（props）、输出html片段（JSX）的&lt;strong&gt;函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数有什么特别呢？从数学上讲，函数本质上就是表示一种&lt;strong&gt;映射关系&lt;/strong&gt;。React受函数式编程思想的影响，&lt;strong&gt;将html视为数据映射的结果&lt;/strong&gt;。一个数据映射出一个html片段，所有的html片段拼起来，就形成了完整的页面DOM树。当然，React组件还可以是class形式，但只是为了更好地操作数据，最终render函数会完成映射这一步。这是一种截然不同于模板填充的思维方式，姑且称之为“&lt;strong&gt;映射思维&lt;/strong&gt;”。相应的，将变量绑定到模板上的思维方式就称之为“&lt;strong&gt;模板思维&lt;/strong&gt;”。理解这两种思维的对立非常重要，因为这是React与Vue等其他框架的核心差异所在。&lt;/p&gt;
&lt;p&gt;我画了如下两张图，尝试阐明模板思维与映射思维的不同：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/900937/201905/900937-20190504210912035-119393005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种思维的根本分歧在于：&lt;strong&gt;视图层与数据层何者第一，何者第二&lt;/strong&gt;？或者说，是先有html再有js，还是先有js再有html？&lt;/p&gt;
&lt;p&gt;模板思维认为是先有html，再有js。正如上面图的左半部分所示，模板本身已经是一个接近完整的网页了，只不过其中几个变量没法确定，需要一点逻辑来动态填充，所以找了js这么个小弟来打打下手，把这几个变量给补上去。因此，在模板思维的世界观里，html居于主导地位，js服从于html的需要。&lt;/p&gt;
&lt;p&gt;映射思维却相反，认为js里的数据才是第一性的，html只不过是数据层向视图层的单向映射或者说投影，如上图右半部分所示，一个个数据的投影片段拼起来，组成了完整的html。在这个世界观里，&lt;strong&gt;数据是本体，视图是现象&lt;/strong&gt;，他们之间的关系就像一棵树与它的影子一样，要想改变影子，就必须改变树，而不能影子变了树没变。明白了这一点，React那些乍看之下有些奇怪的设定（如阻止input标签直接响应的用户输入），以及React社区对单向数据流的偏好（如Redux），就不难理解了。&lt;/p&gt;

&lt;h2&gt;孰优孰劣？&lt;/h2&gt;
&lt;p&gt;我可不想像很多文章那样偷懒地来一句“各有优劣”，再不痛不痒地分别列举几个优缺点完事。我，旗帜鲜明地认为，&lt;strong&gt;映射思维才是前端未来正确的发展方向&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在上古时代的网页里，js只是嵌在html里的一行或者一小段脚本，干着弹个提示、飞个广告之类的杂活，远远称不上一个完整的程序，说它是html的小弟或补充，一点问题也没有。但如今，页面越来越复杂，异步加载、动态渲染的开发模式越来越流行，在这种模式下，整个页面都是由js绘制出来的，正是因为js对页面有了完全的掌控权，才使得网页真正进化为“WebApp”，成为一个真正的程序，而不再是一个简单的、无逻辑的类XML标记语言文件，进而使得数据-视图层的分离及其映射关系的建立成为可能。&lt;/p&gt;
&lt;p&gt;在WebApp里，有一个原则显然应该被始终遵守——一致性，即用户看到的DOM元素状态应该与对应的js变量值保持一致。Vue的解决方案是双向绑定，React则实现了单向数据流，这都是从它们各自的世界观出发做出的自然而然的选择。但在我看来，视图=表象，&lt;strong&gt;不应该让表象承载实质，否则会导致形实关系的混乱&lt;/strong&gt;——自然法则允许通过修剪树来改变它的影子，难道也要允许通过改变影子反过来改变树吗？表象就应该是实质的忠实呈现，以及用户触达实质的媒介（事件绑定），不应越俎代庖。&lt;/p&gt;

&lt;p&gt;在模板思维看来，html模板和js数据都是实质，二者是并列的关系；在映射思维的世界观里，js数据是唯一的实质。&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;如无必要，勿增实体&lt;/strong&gt;”，我选择简单的那个方案。&lt;/p&gt;
&lt;p&gt;事实也是如此，学会了thinking in React，可以在编写复杂页面的时候，仍然保持逻辑清晰和极度舒适。&lt;/p&gt;
&lt;p&gt;真香！！！&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:46:00 +0000</pubDate>
<dc:creator>大唐西域都护</dc:creator>
<og:description>从设计哲学的角度认识React，很多技术细节自会豁然开朗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leegent/p/10794047.html</dc:identifier>
</item>
<item>
<title>spi-mem: 为SPI存储器生态带来一些一致性 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/10810054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/10810054.html</guid>
<description>&lt;p&gt;在本文中，我们将介绍关于spi-mem Linux内核框架的工作，该框架将允许在SPI NOR设备和常规SPI设备以及SPI NAND设备上复用SPI控制器驱动程序。&lt;/p&gt;
&lt;h2 id=&quot;从spi到双线四线八线spi&quot;&gt;从SPI到双线、四线、八线SPI&lt;/h2&gt;
&lt;p&gt;在过去，SPI是一个简单的协议，总线上的所有设备只共享3根信号线:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MISO: Master In Slave Out，主设备输入从设备输出线&lt;/li&gt;
&lt;li&gt;MOSI: Master Out Slave In，主设备输出从设备输入线&lt;/li&gt;
&lt;li&gt;SCLK: Serial Clock，时钟线&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504215659040-1835640828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外每个设备有一个独立信号线，用于选择我们想要通信的设备:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SS: Slave Select，从设备选择线 (有时也称为片选线CS，Chip Select)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但随后SPI存储出现了。它从较小且相对较慢的SPI NORs开始，如dataflash、EEPROMs和SRAMs，然后逐渐发展到较大的SPI NORs和SPI NANDs。像往常一样，当涉及到处理存储时，我们希望得到最佳性能表现。SPI总线的限制很快成为瓶颈，因此供应商决定添加更多的I/O线路，并使 MISO/MOSI 线可以双向通信。现在我们看到SPI控制器支持最多8路I/O。这就是业内所说的DualSPI QuadSPI和OctoSPI。&lt;/p&gt;
&lt;p&gt;为了在主从设备的数据传输中用上所有的I/O线，必须有某种主从设备之间的协议，这样双方才能知道，何时可以在I/O线上收发数据，应该使用多少根I/O线等。这些由一组从设备预定义的操作规定了如何进行，主设备必须遵循这组操作的规定，进入特定的发送或接收状态。SPI存储器操作通常包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1字节的操作码，表示将要进行从操作 (未来将很快会将出现2字节的操作码，请做好准备)&lt;/li&gt;
&lt;li&gt;0-N 字节的地址，其含义取决于操作码(可以是绝对内存地址，或其他含义)&lt;/li&gt;
&lt;li&gt;0-N 字节的哑字节，使得从设备有足够的时间来进入操作码请求的特定状态，同样，哑字节的数量时取决于操作码的&lt;/li&gt;
&lt;li&gt;0-N 字节的输入或输出数据，方向是取决于操作码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请注意，虽然这个协议倾向于被用于存储设备，但并没有什么能限制它只能用于存储设备，如果一些FPGA使用相同的协议来操作非存储设备，我也不会感到惊讶。&lt;/p&gt;
&lt;h2 id=&quot;linux-spi-生态&quot;&gt;Linux SPI 生态&lt;/h2&gt;
&lt;p&gt;Linux支持双线SPI和四线SPI模式已经有一段时间了(v3.12)， SPI设备驱动程序可以为每个SPI传输指定I/O通道的数量。使用这种方式，对SPI存储的操作可以被分为多次SPI传输，每次SPI传输使用预定义数量的I/O通道进行传输。&lt;/p&gt;
&lt;p&gt;这种方式可以正常工作，直到一些IP供应商决定让它们的SPI控制器更加智能，嵌入某种高级接口，可以在单个的步骤中执行SPI存储器的操作，而不是使用分开的多次传输操作。(事实上，大多数SPI控制器甚至比这更加智能，可以允许你直接将SPI存储映射到CPU的地址空间，但让我们先把这种情况留待以后处理吧)。在这种情况下，我们需要赋予SPI控制器更多的控制权，这样它就可以决定具体该做什么，而不必从一组分散的SPI传输命令中，重建SPI存储器操作。&lt;/p&gt;
&lt;p&gt;当时的决定是，将这些控制器专门用于一个任务，控制SPI NORs（当时这是唯一会用到双线和四线模式的情况），SPI NOR框架就是为此而创建的。&lt;/p&gt;
&lt;p&gt;由于这个决定，我们现在在Linux中有一个SPI NOR框架用于连接SPI NOR控制器驱动和SPI NOR的逻辑代码（&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/mtd/spi-nor&quot;&gt;spi-nor 子系统&lt;/a&gt;），同时我们有常规的SPI控制器驱动，可以进行基础的SPI传输（&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/spi&quot;&gt;spi 子系统&lt;/a&gt;）。然而，从硬件的角度看，能为SPI NOR提供特殊特性的SPI控制器，一般也拥有进行基本传输的能力，即可用于控制常规的SPI设备。不幸的是，基于当前的spi-nor 子系统和spi 子系统是分裂开来的情况，如果一个SPI控制器被spi-nor子系统的驱动支持了，它将无法被用于与spi子系统中的常规设备进行通信。&lt;/p&gt;
&lt;p&gt;作为一个针对这个问题的部分的解决方案，&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/include/linux/spi/spi.h#L551&quot;&gt;-&amp;gt;spi_flash_read()&lt;/a&gt;操作被添加到&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/ident/spi_controller&quot;&gt;结构体 spi_controller&lt;/a&gt;中，这允许spi子系统中的常规spi控制器驱动提供一个较优的方式，来从SPI NOR存储中读取数据，这种方式被通用SPI NOR驱动&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/drivers/mtd/devices/m25p80.c#L157&quot;&gt;m25p80&lt;/a&gt;所使用。然而，这个解决方案是部分的，因为它只优化了读取，并且仅限于SPI NORs。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504215720700-402997482.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在当前的架构中，我们有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SPI NOR框架，它包含与SPI NOR存储器通讯的协议。这个框架依赖于&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/include/linux/mtd/spi-nor.h#L280&quot;&gt;结构体spi_nor&lt;/a&gt;中列出的接口，这些接口的实现是：&lt;/li&gt;
&lt;li&gt;专用的SPI NOR控制器，支持专用于SPI NORs的高级SPI控制器&lt;/li&gt;
&lt;li&gt;m25p80驱动，提供同样的接口，但基于常规SPI控制器驱动，可能具有-&amp;gt;spi_flash_read()的优化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;是什么促使我们提出spi存储器接口&quot;&gt;是什么促使我们提出SPI存储器接口?&lt;/h2&gt;
&lt;p&gt;我们之前已经看到，基于SPI NOR框架，SPI NOR存储器已经得到了适当的支持。但NORs 并非SPI总线上唯一的存储设备，SPI NANDs 正在变得越来越流行。&lt;br/&gt;Peter Pan提出了一个遵循SPI NOR模型的，用于支持SPI NAND设备的&lt;a href=&quot;https://lwn.net/Articles/723694/&quot;&gt;框架&lt;/a&gt;: SPI控制器必须实现SPI NAND控制器接口才能控制SPI NAND。但是当我们更深入地参与到这个开发中时，我们很快意识到沿着这条路走会有多么麻烦，因为这意味着，如果SPI控制器想要同时控制两种设备，就必须同时实现SPI NOR和SPI NAND接口。当SPI NVRAM或任何其他类型的存储制造商决定采用SPI总线时，将会发生什么?再添加一个SPI控制器必须实现的接口？这听起来不是个好主意。&lt;/p&gt;
&lt;p&gt;因此我们决定用另外的方式解决这个问题，尝试找出SPI NANDs和SPI NORs的共同点。SPI NORs和SPI NANDs 指令集不同，行为和约束也不同(主要是由于NOR和NAND本身的不同)，但当与设备交互时，都遵循同样的SPI存储器操作语义，这也是高级控制器都在尝试优化的部分。&lt;/p&gt;
&lt;p&gt;SPI 存储器层只是提供一种方式给SPI控制器驱动，用于传递高级SPI存储器操作，而不是让它们处理SPI传输细节并自行尝试优化它们。这同样简化了SPI存储器驱动，因为它们只需要按照SPI存储器规范发送SPI存储器操作指令，不需要关心复杂的、不断发展的、依赖具体存储器的接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908492/201905/908492-20190504220445010-1210480635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这个新的架构，SPI NOR和SPI NAND都可以基于相同的SPI控制器驱动进行支持了。m25p80驱动将被修改成，使用spi-mem接口，取代具有局限性的-&amp;gt;spi_flash_read()接口。目前，我们仍然有专用的SPI NOR控制器驱动，但最终目标是移除它们，并将它们移植为 drivers/spi 下的普通SPI控制器驱动。非常欢迎这方面的帮助和贡献。&lt;/p&gt;
&lt;h2 id=&quot;spi存储器api是什么样子的&quot;&gt;SPI存储器API是什么样子的?&lt;/h2&gt;
&lt;p&gt;SPI存储器的API 由 &lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi.git/tree/include/linux/spi/spi-mem.h?h=for-4.18&quot;&gt;include/linux/spi/spi-mem.h&lt;/a&gt; 描述。&lt;/p&gt;
&lt;p&gt;希望使用SPI存储器API的SPI设备驱动程序，应该将自己声明为spi_mem_drivers，并实现-&amp;gt;probe()和-&amp;gt;remove()函数。&lt;br/&gt;它们将被传入一个spi_mem对象，它只是一个围绕spi_device对象的简单包装，我们引入一个不同的对象的原因是，我们希望能够拓展spi_mem对象，并在需要时附加更多的信息（例如存储器类型，存储器组织方式和其他的高级SPI控制器可能需要的信息）。&lt;br/&gt;当驱动想要执行SPI存储器操作时，它将填充spi_mem_op结构并调用spi_mem_exec_op()。另外，可以使用spi_mem_supports_op()，测试一个SPI控制器是否支持特定的存储器操作，使用spi_mem_adjust_op_size()，获取控制器支持的最大传输大小，并尝试拆分数据传输以避免超出限制。&lt;/p&gt;
&lt;p&gt;现在让我们看下控制器端。一个希望优化SPI存储器操作的SPI控制器，可以实现spi_mem_ops接口，该接口包含三个直接对应用户API的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-&amp;gt;exec_op():执行存储器操作，如果不支持则返回-ENOTSUPP。&lt;/li&gt;
&lt;li&gt;-&amp;gt;supports_op(): 检查这个存储器操作是否支持。&lt;/li&gt;
&lt;li&gt;-&amp;gt;adjust_op_size(): 调整存储器操作的数据传输大小，以符合对齐要求和最大FIFO大小的约束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，当spi_mem_ops 没有实现时，core层将通过创建由多个SPI传输组成的SPI消息，来添加对该特性的通用支持，就像以前通用SPI NOR控制器驱动程序(名为m25p80)所做的那样。&lt;/p&gt;
&lt;p&gt;如你所见，这些API非常直截了当，所以希望有更多的SPI存储器驱动能够转换为使用它，而不是手动创建包含多个SPI传输的SPI消息。&lt;/p&gt;
&lt;h2 id=&quot;当前状态&quot;&gt;当前状态&lt;/h2&gt;
&lt;p&gt;一部分已经被贡献出去并合并，计划成为Linux 4.18的一部分：&lt;/p&gt;
&lt;h2 id=&quot;下一步是什么&quot;&gt;下一步是什么？&lt;/h2&gt;
&lt;p&gt;先进的SPI控制器不仅能够优化SPI存储器操作的执行，它们可以进一步将所有存储器访问的复杂性隐藏起来，提供一个直接映射的IOMEM区域，对此区域的访问会自动在总线上触发SPI存储器操作，为你完成数据的收发，这样的行为就像一个连接在并行的内存总线上的内存。可以想象，这将允许更高的吞吐量和更少的用于SPI存储器操作管理的CPU时间，但这同时也是一个难以通过常规的方式进行支持的功能。我们已经在linux-mtd邮件列表上发布了一个支持这种直接映射功能的&lt;a href=&quot;http://lists.infradead.org/pipermail/linux-mtd/2018-June/081460.html&quot;&gt;建议&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如前所述，另一个具有挑战性的主题是，将所有的SPI NOR控制器驱动转换为基于SPI mem模型，以便所有的QSPI控制器都真正表现为SPI控制器而非SPI NOR控制器。这可能需要一些时间，因为目前在driver/mtd/spi-nor 下有10个驱动，我们只知道其中2个被转换为了SPI mem方法(fsl-quadspi和atmel-quadspi)。&lt;/p&gt;
&lt;p&gt;本文地址 &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/10810054.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/10810054.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译自 &lt;a href=&quot;https://bootlin.com/blog/spi-mem-bringing-some-consistency-to-the-spi-memory-ecosystem/&quot; class=&quot;uri&quot;&gt;https://bootlin.com/blog/spi-mem-bringing-some-consistency-to-the-spi-memory-ecosystem/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者 Boris Brezillon&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 14:12:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>在本文中，我们将介绍关于spi mem Linux内核框架的工作，该框架将允许在SPI NOR设备和常规SPI设备以及SPI NAND设备上复用SPI控制器驱动程序。 从SPI到双线、四线、八线SPI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zqb-all/p/10810054.html</dc:identifier>
</item>
<item>
<title>搭配 VS Code Remote 远程开发扩展在 WSL 下开发 - nczitzk</title>
<link>http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</guid>
<description>&lt;blockquote readability=&quot;3.3734939759036&quot;&gt;
&lt;p&gt;❗ 注意：远程开发扩展需要在 &lt;a href=&quot;http://code.visualstudio.com/insiders&quot;&gt;Visual Studio Code Insiders&lt;/a&gt; 上使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Visual Studio Code Remote - WSL 扩展允许你直接借助 VS Code 令 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl&quot;&gt;「适用于 Linux 的 Windows 子系统」（WSL）&lt;/a&gt; 作为你的全职开发环境。你可以在基于 Linux 的环境中进行开发，使用 Linux 特有的的工具链和实用库，并在舒适的 Windows 中运行和调试基于 Linux 的应用程序。&lt;/p&gt;
&lt;p&gt;该扩展直接在 WSL 中运行命令和其它扩展，因此你可以编辑位于 WSL 中的文件或挂载在其上的 Windows 文件系统（例如 /mnt/c），而无需担心遇到文件路径问题、二进制兼容性或其它跨操作系统的难题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/architecture-wsl.png&quot; alt=&quot;WSL Architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这使得 VS Code 能够提供有着在本地进行开发一样效率的开发体验——包括完整的IntelliSense（代码补全）、代码导航和调试——无论你的代码在何处托管，都是如此。&lt;/p&gt;
&lt;h2&gt;上手&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;上手前你需要做的几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装对应你偏好的 Linux 发行版的 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/install-win10&quot;&gt;「适用于 Linux 的 Windows 子系统」&lt;/a&gt;。VS Code 将使用你安装的默认发行版，因此可以根据需要使用 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/wsl-config&quot;&gt;wslconfig.exe&lt;/a&gt; 更改默认发行版。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.906976744186&quot;&gt;
&lt;p&gt;注意：WSL 确实存在一些 &lt;a href=&quot;https://code.visualstudio.com/docs/remote/wsl#_known-limitations&quot;&gt;已知的对于某些类型的开发的限制&lt;/a&gt;，这些限制也会影响你的 VS Code 体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;1.30044345898&quot;&gt;&lt;li readability=&quot;-0.65822784810127&quot;&gt;
&lt;p&gt;在 Windows 端安装 &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;（而不是在 WSL 中）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.55&quot;&gt;
&lt;p&gt;安装 &lt;a href=&quot;https://aka.ms/vscode-remote/download/extension&quot;&gt;Remote Development&lt;/a&gt; 扩展包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.9090909090909&quot;&gt;
&lt;p&gt;考虑在 Windows 端禁用 Git 的行尾结束符自动转换，方法是使用命令提示符运行：&lt;strong&gt;git config --global core.autocrlf false&lt;/strong&gt; 如果该项保持启用状态，由于行尾结束符的差异，此设置可能导致你未编辑的文件中出现了修改操作。有关详细信息，请参阅 &lt;a href=&quot;https://aka.ms/vscode-remote/download/extension&quot;&gt;提示和技巧&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;在 WSL 中打开文件夹&lt;/h3&gt;
&lt;p&gt;在 VS Code 中打开「适用于 Linux 的 Windows 子系统」中的文件夹与从命令提示符打开 Windows 文件夹非常相似。&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开 WSL 终端窗口（使用开始菜单项或从命令提示符键入 &lt;strong&gt;wsl&lt;/strong&gt; ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;切换到你要在 VS Code 中打开的文件夹（包括但不限于 Windows 文件系统挂载点，如 &lt;strong&gt;/mnt/c&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在终端中输入 &lt;strong&gt;code-insiders .&lt;/strong&gt;。在第一次执行此操作时，你应该看到 VS code 在获取运行于 WSL 所需的组件。这应该只需要很短的时间，而且只需要执行一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;片刻之后，一个新的 VS Code 窗口将会出现，你将看到一个 VS Code 正在 WSL 中打开文件夹的通知。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-starting-notification.png&quot; alt=&quot;WSL Starting notification&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VS Code 现在将继续在 WSL 中配置自身，并在 WSL 中安装你在本地运行的任何 VS Code 扩展以优化性能。 VS Code 会对你通知它所获得的进展。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完成后，你现在可以在左下角看到一个 WSL 小标识，你将能够像平常一样使用 VS Code！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-statusbar-indicator.png&quot; alt=&quot;WSL Status Bar Item&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是如此啦！你在此窗口中执行的任何 VS code 操作都将在 WSL 环境中执行，从编辑和文件操作到调试、使用终端等等都是如此。&lt;/p&gt;
&lt;h2&gt;管理扩展&lt;/h2&gt;
&lt;p&gt;VS Code 在以下两个位置之一运行扩展：在 UI / 客户端这边或在 WSL 中。虽然作用于 VS Code UI 的扩展（如主题和代码片段）是在本地安装的，但大多数扩展都将安装在 WSL 中。&lt;/p&gt;
&lt;p&gt;如果从「扩展」视图安装扩展，它将自动安装在正确的位置。一旦安装后，你可以根据类别分组确定扩展的安装位置。那将有「本地 - 已安装」的类别和一个安装在 WSL 的类别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-installed-remote-indicator.png&quot; alt=&quot;Workspace Extension Category&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-local-installed-extensions.png&quot; alt=&quot;&amp;gt;Local Extension Category&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.2847682119205&quot;&gt;
&lt;p&gt;注意：如果你是扩展作者并且你的扩展程序无法正常运行或安装在错误的位置，请参阅 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt; 查看详情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际需要远程运行的本地扩展在「本地 - 已安装」类别中显示为「已禁用」。你可以单击「安装」按钮在远程主机上安装扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/wsl-disabled-extensions.png&quot; alt=&quot;Disabled Extensions&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;高级：强制在本地/远程运行扩展&lt;/h3&gt;
&lt;p&gt;扩展通常为单独运行在本地或远程而设计和测试，而非对于两者。但是，如果扩展程序支持这项特性，则可以强制它在 &lt;strong&gt;settings.json&lt;/strong&gt; 文件中指定的特定位置运行。&lt;/p&gt;
&lt;p&gt;例如，下面的设置将强制 Docker 和 Debugger for Chrome 扩展程序 远程运行而不是默认在本地运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;json&quot;&gt;&quot;remote.extensionKind&quot;: {
    &quot;msjsdiag.debugger-for-chrome&quot;: &quot;workspace&quot;,
    &quot;peterjausovec.vscode-docker&quot;: &quot;workspace&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值&lt;strong&gt;「ui」&lt;/strong&gt;而不是&lt;strong&gt;「workspace」&lt;/strong&gt;将强制扩展在本地 UI /客户端 端运行。 通常，除非在扩展程序的文档中另有说明，否则这应仅用于测试，因为它可以中断扩展。 了解详细信息，请参阅有关 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt; 的文章。&lt;/p&gt;
&lt;h2&gt;在 WSL 中打开终端&lt;/h2&gt;
&lt;p&gt;从 VS Code 在 WSL 中打开终端很简单。在 WSL 中打开文件夹后，在 VS code (Terminal &amp;gt; New Terminal) 中打开的任何终端窗口将自动在 WSL 中运行，而不是在本地运行。&lt;/p&gt;
&lt;p&gt;你还可以使用此同一终端窗口中的 &lt;strong&gt;code-insiders&lt;/strong&gt; 命令行来执行许多操作，例如在 WSL 中打开新文件或文件夹。 键入 &lt;strong&gt;code-insiders --help&lt;/strong&gt; 以查看命令行中可用的选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/assets/docs/remote/wsl/code-command-in-terminal.png&quot; alt=&quot;Using the code CLI&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;在 WSL 中调试&lt;/h2&gt;
&lt;p&gt;在 WSL 中打开文件夹后，可以像在本地运行应用程序一样使用 VS Code 的调试器。例如，如果在 &lt;strong&gt;launch.json&lt;/strong&gt; 中选择一个启动配置并开始调试（F5），应用程序将在远程主机上启动并与调试器交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.vscode/launch.json&lt;/strong&gt; 中有关配置 VS Code 调试功能的详细信息，请参阅 &lt;a href=&quot;https://code.visualstudio.com/docs/editor/debugging&quot;&gt;debugging&lt;/a&gt; 文档。&lt;/p&gt;
&lt;h2&gt;WSL 特定设置&lt;/h2&gt;
&lt;p&gt;在 WSL 中打开文件夹时，也会引用 VS Code 的本地用户设置。虽然这可以保持用户体验的一致性，但你可能希望更改本地计算机和 WSL 之间一些设置。幸运的是，一旦连接到 WSL，你还可以通过运行「首选项」来设置 WSL 特定设置：打开从命令选项板（F1）中打开「远程设置命令」或在设置编辑器中选择「远程」选项卡。这些将覆盖你在 WSL 中打开文件夹时所具有的任何本地设置。&lt;/p&gt;
&lt;h2&gt;已知限制&lt;/h2&gt;
&lt;p&gt;本节包含 WSL 常见已知问题的列表。目的不是提供完整的问题列表，而是强调 WSL 中常见的一些问题。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://aka.ms/vscode-remote/wsl/issues&quot;&gt;这里浏览有关 WSL 的活跃问题列表&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;常见问题&lt;/h2&gt;
&lt;h3&gt;我应该如何更改「远程 - WSL」使用的发行版呢？&lt;/h3&gt;
&lt;p&gt;「远程 - WSL」扩展使用的是你的默认发行版，你可以通过 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl/wsl-config&quot;&gt;wslconfig.exe&lt;/a&gt; 对其进行更改。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash&quot;&gt;wslconfig /setdefault Ubuntu&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以下命令得知你一已安装的发行版：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;bash&quot;&gt;wslconfig /l&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;我看到有关缺少库或依赖项的错误&lt;/h3&gt;
&lt;p&gt;某些扩展依赖于某些 WSL Linux 发行版原生安装缺失而找不到的库。你可以使用其包管理器将其他库添加到Linux发行版中。 对于基于 Ubuntu 和 Debian 的发行版，运行 &lt;strong&gt;sudo apt-get install &amp;lt;package&amp;gt;&lt;/strong&gt; 来安装所需的库。检查扩展的文档或提及的运行时信息以获取其它安装详细信息。&lt;/p&gt;
&lt;h3&gt;在WSL中运行时，VS Code Server 的连接要求是什么？&lt;/h3&gt;
&lt;p&gt;VS Code Server 需要与 &lt;strong&gt;update.code.visualstudio.com&lt;/strong&gt; 和 &lt;strong&gt;marketplace.visualstudio.com&lt;/strong&gt;的 HTTPS（端口443）连接。服务器和 VS code 客户端之间的所有其它通信都是通过经过身份验证的随机的本地 TCP 端口完成的。&lt;/p&gt;
&lt;h3&gt;作为扩展作者，我需要做什么？&lt;/h3&gt;
&lt;p&gt;VS Code 扩展 API 抽象出本地/远程详细信息，因此大多数扩展都可以在不进行修改的情况下工作。但是，如果扩展可以使用它们所需的任何 node 模块或运行时，则可能需要进行调整。 我们建议你测试扩展程序，以此来确定是否需要更新。有关详细信息，请参阅 &lt;a href=&quot;https://code.visualstudio.com/api/advanced-topics/remote-extensions&quot;&gt;支持远程开发&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;问题或反馈&lt;/h3&gt;
&lt;p&gt;本文由 &lt;a href=&quot;https://docs.microsoft.com/windows/wsl&quot;&gt;VS Code Remote 官方文档&lt;/a&gt; 翻译而成，同时发表在 &lt;a href=&quot;https://ethans.me/codes/develop-in-wsl-with-vscode-remote-zh_CN&quot; target=&quot;_blank&quot;&gt;ethans.me&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 13:48:00 +0000</pubDate>
<dc:creator>nczitzk</dc:creator>
<og:description>Visual Studio Code Remote - WSL 扩展允许你直接借助 VS Code 令 「适用于 Linux 的 Windows 子系统」（WSL） 作为你的全职开发环境。你可以在基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html</dc:identifier>
</item>
</channel>
</rss>